{"sha": "8d50d6a93c8f408b54f887670f70726421a48f0a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkNTBkNmE5M2M4ZjQwOGI1NGY4ODc2NzBmNzA3MjY0MjFhNDhmMGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-22T17:31:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-22T17:31:25Z"}, "message": "auto merge of #14346 : alexcrichton/rust/rustdoc-external-crates, r=pcwalton\n\nThis commit alters rustdoc to crawl the metadata of upstream libraries in order\r\nto fill in default methods for traits implemented in downstream crates. This,\r\nfor example, documents the `insert` function on hash maps.\r\n\r\nThis is a fairly lossy extraction from the metadata. Documentation and\r\nattributes are lost, but they aren't used anyway. Unfortunately, argument names\r\nare also lost because they are not present in the metadata. Source links are\r\nalso lost because the spans are not serialized.\r\n\r\nWhile not perfect, it appears that presenting this documentation through rustdoc\r\nis much better than nothing, so I wanted to land this to allow iteration on it\r\nlater on.", "tree": {"sha": "fd184c0e9833266e8bcdcec13eafbeead317678c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd184c0e9833266e8bcdcec13eafbeead317678c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d50d6a93c8f408b54f887670f70726421a48f0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d50d6a93c8f408b54f887670f70726421a48f0a", "html_url": "https://github.com/rust-lang/rust/commit/8d50d6a93c8f408b54f887670f70726421a48f0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d50d6a93c8f408b54f887670f70726421a48f0a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c9f2a5d0a22828dae30ad5926049fb321897eab", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c9f2a5d0a22828dae30ad5926049fb321897eab", "html_url": "https://github.com/rust-lang/rust/commit/3c9f2a5d0a22828dae30ad5926049fb321897eab"}, {"sha": "c746c503f0bb0ba27e5ee6170a85d03013d3ac1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c746c503f0bb0ba27e5ee6170a85d03013d3ac1c", "html_url": "https://github.com/rust-lang/rust/commit/c746c503f0bb0ba27e5ee6170a85d03013d3ac1c"}], "stats": {"total": 537, "additions": 433, "deletions": 104}, "files": [{"sha": "236c98b72e65a125a6db14051286257134e3eec2", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 339, "deletions": 28, "changes": 367, "blob_url": "https://github.com/rust-lang/rust/blob/8d50d6a93c8f408b54f887670f70726421a48f0a/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d50d6a93c8f408b54f887670f70726421a48f0a/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=8d50d6a93c8f408b54f887670f70726421a48f0a", "patch": "@@ -25,6 +25,7 @@ use rustc::driver::driver;\n use rustc::metadata::cstore;\n use rustc::metadata::csearch;\n use rustc::metadata::decoder;\n+use rustc::middle::ty;\n \n use std::strbuf::StrBuf;\n \n@@ -128,7 +129,7 @@ pub struct Item {\n     pub attrs: Vec<Attribute> ,\n     pub inner: ItemEnum,\n     pub visibility: Option<Visibility>,\n-    pub id: ast::NodeId,\n+    pub def_id: ast::DefId,\n }\n \n impl Item {\n@@ -274,7 +275,7 @@ impl Clean<Item> for doctree::Module {\n             attrs: self.attrs.clean(),\n             source: where.clean(),\n             visibility: self.vis.clean(),\n-            id: self.id,\n+            def_id: ast_util::local_def(self.id),\n             inner: ModuleItem(Module {\n                is_crate: self.is_crate,\n                items: items.iter()\n@@ -339,20 +340,33 @@ impl<'a> attr::AttrMetaMethods for &'a Attribute {\n #[deriving(Clone, Encodable, Decodable)]\n pub struct TyParam {\n     pub name: StrBuf,\n-    pub id: ast::NodeId,\n+    pub did: ast::DefId,\n     pub bounds: Vec<TyParamBound>,\n }\n \n impl Clean<TyParam> for ast::TyParam {\n     fn clean(&self) -> TyParam {\n         TyParam {\n             name: self.ident.clean(),\n-            id: self.id,\n+            did: ast::DefId { krate: ast::LOCAL_CRATE, node: self.id },\n             bounds: self.bounds.clean().move_iter().collect(),\n         }\n     }\n }\n \n+impl Clean<TyParam> for ty::TypeParameterDef {\n+    fn clean(&self) -> TyParam {\n+        let cx = super::ctxtkey.get().unwrap();\n+        cx.external_typarams.borrow_mut().get_mut_ref().insert(self.def_id,\n+                                                               self.ident.clean());\n+        TyParam {\n+            name: self.ident.clean(),\n+            did: self.def_id,\n+            bounds: self.bounds.clean(),\n+        }\n+    }\n+}\n+\n #[deriving(Clone, Encodable, Decodable)]\n pub enum TyParamBound {\n     RegionBound,\n@@ -369,6 +383,96 @@ impl Clean<TyParamBound> for ast::TyParamBound {\n     }\n }\n \n+fn external_path(name: &str) -> Path {\n+    Path {\n+        global: false,\n+        segments: vec![PathSegment {\n+            name: name.to_strbuf(),\n+            lifetimes: Vec::new(),\n+            types: Vec::new(),\n+        }]\n+    }\n+}\n+\n+impl Clean<TyParamBound> for ty::BuiltinBound {\n+    fn clean(&self) -> TyParamBound {\n+        let cx = super::ctxtkey.get().unwrap();\n+        let tcx = match cx.maybe_typed {\n+            core::Typed(ref tcx) => tcx,\n+            core::NotTyped(_) => return RegionBound,\n+        };\n+        let (did, path) = match *self {\n+            ty::BoundStatic => return RegionBound,\n+            ty::BoundSend =>\n+                (tcx.lang_items.send_trait().unwrap(), external_path(\"Send\")),\n+            ty::BoundSized =>\n+                (tcx.lang_items.sized_trait().unwrap(), external_path(\"Sized\")),\n+            ty::BoundCopy =>\n+                (tcx.lang_items.copy_trait().unwrap(), external_path(\"Copy\")),\n+            ty::BoundShare =>\n+                (tcx.lang_items.share_trait().unwrap(), external_path(\"Share\")),\n+        };\n+        let fqn = csearch::get_item_path(tcx, did);\n+        let fqn = fqn.move_iter().map(|i| i.to_str().to_strbuf()).collect();\n+        cx.external_paths.borrow_mut().get_mut_ref().insert(did,\n+                                                            (fqn, TypeTrait));\n+        TraitBound(ResolvedPath {\n+            path: path,\n+            typarams: None,\n+            did: did,\n+        })\n+    }\n+}\n+\n+impl Clean<TyParamBound> for ty::TraitRef {\n+    fn clean(&self) -> TyParamBound {\n+        let cx = super::ctxtkey.get().unwrap();\n+        let tcx = match cx.maybe_typed {\n+            core::Typed(ref tcx) => tcx,\n+            core::NotTyped(_) => return RegionBound,\n+        };\n+        let fqn = csearch::get_item_path(tcx, self.def_id);\n+        let fqn = fqn.move_iter().map(|i| i.to_str().to_strbuf())\n+                     .collect::<Vec<StrBuf>>();\n+        let path = external_path(fqn.last().unwrap().as_slice());\n+        cx.external_paths.borrow_mut().get_mut_ref().insert(self.def_id,\n+                                                            (fqn, TypeTrait));\n+        TraitBound(ResolvedPath {\n+            path: path,\n+            typarams: None,\n+            did: self.def_id,\n+        })\n+    }\n+}\n+\n+impl Clean<Vec<TyParamBound>> for ty::ParamBounds {\n+    fn clean(&self) -> Vec<TyParamBound> {\n+        let mut v = Vec::new();\n+        for b in self.builtin_bounds.iter() {\n+            if b != ty::BoundSized {\n+                v.push(b.clean());\n+            }\n+        }\n+        for t in self.trait_bounds.iter() {\n+            v.push(t.clean());\n+        }\n+        return v;\n+    }\n+}\n+\n+impl Clean<Option<Vec<TyParamBound>>> for ty::substs {\n+    fn clean(&self) -> Option<Vec<TyParamBound>> {\n+        let mut v = Vec::new();\n+        match self.regions {\n+            ty::NonerasedRegions(..) => v.push(RegionBound),\n+            ty::ErasedRegions => {}\n+        }\n+        v.extend(self.tps.iter().map(|t| TraitBound(t.clean())));\n+\n+        if v.len() > 0 {Some(v)} else {None}\n+    }\n+}\n+\n #[deriving(Clone, Encodable, Decodable)]\n pub struct Lifetime(StrBuf);\n \n@@ -386,6 +490,29 @@ impl Clean<Lifetime> for ast::Lifetime {\n     }\n }\n \n+impl Clean<Lifetime> for ty::RegionParameterDef {\n+    fn clean(&self) -> Lifetime {\n+        Lifetime(token::get_name(self.name).get().to_strbuf())\n+    }\n+}\n+\n+impl Clean<Option<Lifetime>> for ty::Region {\n+    fn clean(&self) -> Option<Lifetime> {\n+        match *self {\n+            ty::ReStatic => Some(Lifetime(\"static\".to_strbuf())),\n+            ty::ReLateBound(_, ty::BrNamed(_, name)) =>\n+                Some(Lifetime(token::get_name(name).get().to_strbuf())),\n+\n+            ty::ReLateBound(..) |\n+            ty::ReEarlyBound(..) |\n+            ty::ReFree(..) |\n+            ty::ReScope(..) |\n+            ty::ReInfer(..) |\n+            ty::ReEmpty(..) => None\n+        }\n+    }\n+}\n+\n // maybe use a Generic enum and use ~[Generic]?\n #[deriving(Clone, Encodable, Decodable)]\n pub struct Generics {\n@@ -402,6 +529,15 @@ impl Clean<Generics> for ast::Generics {\n     }\n }\n \n+impl Clean<Generics> for ty::Generics {\n+    fn clean(&self) -> Generics {\n+        Generics {\n+            lifetimes: self.region_param_defs.clean(),\n+            type_params: self.type_param_defs.clean(),\n+        }\n+    }\n+}\n+\n #[deriving(Clone, Encodable, Decodable)]\n pub struct Method {\n     pub generics: Generics,\n@@ -428,11 +564,11 @@ impl Clean<Item> for ast::Method {\n             name: Some(self.ident.clean()),\n             attrs: self.attrs.clean().move_iter().collect(),\n             source: self.span.clean(),\n-            id: self.id.clone(),\n+            def_id: ast_util::local_def(self.id.clone()),\n             visibility: self.vis.clean(),\n             inner: MethodItem(Method {\n                 generics: self.generics.clean(),\n-                self_: self.explicit_self.clean(),\n+                self_: self.explicit_self.node.clean(),\n                 fn_style: self.fn_style.clone(),\n                 decl: decl,\n             }),\n@@ -466,12 +602,12 @@ impl Clean<Item> for ast::TypeMethod {\n             name: Some(self.ident.clean()),\n             attrs: self.attrs.clean().move_iter().collect(),\n             source: self.span.clean(),\n-            id: self.id,\n+            def_id: ast_util::local_def(self.id),\n             visibility: None,\n             inner: TyMethodItem(TyMethod {\n                 fn_style: self.fn_style.clone(),\n                 decl: decl,\n-                self_: self.explicit_self.clean(),\n+                self_: self.explicit_self.node.clean(),\n                 generics: self.generics.clean(),\n             }),\n         }\n@@ -486,9 +622,9 @@ pub enum SelfTy {\n     SelfOwned,\n }\n \n-impl Clean<SelfTy> for ast::ExplicitSelf {\n+impl Clean<SelfTy> for ast::ExplicitSelf_ {\n     fn clean(&self) -> SelfTy {\n-        match self.node {\n+        match *self {\n             ast::SelfStatic => SelfStatic,\n             ast::SelfValue => SelfValue,\n             ast::SelfUniq => SelfOwned,\n@@ -511,7 +647,7 @@ impl Clean<Item> for doctree::Function {\n             attrs: self.attrs.clean(),\n             source: self.where.clean(),\n             visibility: self.vis.clean(),\n-            id: self.id,\n+            def_id: ast_util::local_def(self.id),\n             inner: FunctionItem(Function {\n                 decl: self.decl.clean(),\n                 generics: self.generics.clean(),\n@@ -533,7 +669,7 @@ pub struct ClosureDecl {\n impl Clean<ClosureDecl> for ast::ClosureTy {\n     fn clean(&self) -> ClosureDecl {\n         ClosureDecl {\n-            lifetimes: self.lifetimes.clean().move_iter().collect(),\n+            lifetimes: self.lifetimes.clean(),\n             decl: self.decl.clean(),\n             onceness: self.onceness,\n             fn_style: self.fn_style,\n@@ -571,6 +707,25 @@ impl Clean<FnDecl> for ast::FnDecl {\n     }\n }\n \n+impl Clean<FnDecl> for ty::FnSig {\n+    fn clean(&self) -> FnDecl {\n+        FnDecl {\n+            output: self.output.clean(),\n+            cf: Return,\n+            attrs: Vec::new(), // FIXME: this is likely wrong\n+            inputs: Arguments {\n+                values: self.inputs.iter().map(|t| {\n+                    Argument {\n+                        type_: t.clean(),\n+                        id: 0,\n+                        name: \"\".to_strbuf(), // FIXME: where are the names?\n+                    }\n+                }).collect(),\n+            },\n+        }\n+    }\n+}\n+\n #[deriving(Clone, Encodable, Decodable)]\n pub struct Argument {\n     pub type_: Type,\n@@ -616,7 +771,7 @@ impl Clean<Item> for doctree::Trait {\n             name: Some(self.name.clean()),\n             attrs: self.attrs.clean(),\n             source: self.where.clean(),\n-            id: self.id,\n+            def_id: ast_util::local_def(self.id),\n             visibility: self.vis.clean(),\n             inner: TraitItem(Trait {\n                 methods: self.methods.clean(),\n@@ -669,6 +824,58 @@ impl Clean<TraitMethod> for ast::TraitMethod {\n     }\n }\n \n+impl Clean<TraitMethod> for ty::Method {\n+    fn clean(&self) -> TraitMethod {\n+        let m = if self.provided_source.is_some() {Provided} else {Required};\n+        let cx = super::ctxtkey.get().unwrap();\n+        let tcx = match cx.maybe_typed {\n+            core::Typed(ref tcx) => tcx,\n+            core::NotTyped(_) => fail!(),\n+        };\n+        let mut attrs = Vec::new();\n+        csearch::get_item_attrs(&tcx.sess.cstore, self.def_id, |v| {\n+            attrs.extend(v.move_iter().map(|i| i.clean()));\n+        });\n+        let (self_, sig) = match self.explicit_self {\n+            ast::SelfStatic => (ast::SelfStatic.clean(), self.fty.sig.clone()),\n+            s => {\n+                let sig = ty::FnSig {\n+                    inputs: Vec::from_slice(self.fty.sig.inputs.slice_from(1)),\n+                    ..self.fty.sig.clone()\n+                };\n+                let s = match s {\n+                    ast::SelfRegion(..) => {\n+                        match ty::get(*self.fty.sig.inputs.get(0)).sty {\n+                            ty::ty_rptr(r, mt) => {\n+                                SelfBorrowed(r.clean(), mt.mutbl.clean())\n+                            }\n+                            _ => s.clean(),\n+                        }\n+                    }\n+                    s => s.clean(),\n+                };\n+                (s, sig)\n+            }\n+        };\n+        m(Item {\n+            name: Some(self.ident.clean()),\n+            visibility: Some(ast::Inherited),\n+            def_id: self.def_id,\n+            attrs: attrs,\n+            source: Span {\n+                filename: \"\".to_strbuf(),\n+                loline: 0, locol: 0, hiline: 0, hicol: 0,\n+            },\n+            inner: TyMethodItem(TyMethod {\n+                fn_style: self.fty.fn_style,\n+                generics: self.generics.clean(),\n+                self_: self_,\n+                decl: sig.clean(),\n+            })\n+        })\n+    }\n+}\n+\n /// A representation of a Type suitable for hyperlinking purposes. Ideally one can get the original\n /// type out of the AST/ty::ctxt given one of these, if more information is needed. Most importantly\n /// it does not preserve mutability or boxes.\n@@ -684,9 +891,9 @@ pub enum Type {\n     TyParamBinder(ast::NodeId),\n     /// For parameterized types, so the consumer of the JSON don't go looking\n     /// for types which don't exist anywhere.\n-    Generic(ast::NodeId),\n+    Generic(ast::DefId),\n     /// For references to self\n-    Self(ast::NodeId),\n+    Self(ast::DefId),\n     /// Primitives are just the fixed-size numeric types (plus int/uint/float), and char.\n     Primitive(ast::PrimTy),\n     Closure(Box<ClosureDecl>, Option<Lifetime>),\n@@ -753,6 +960,93 @@ impl Clean<Type> for ast::Ty {\n     }\n }\n \n+impl Clean<Type> for ty::t {\n+    fn clean(&self) -> Type {\n+        match ty::get(*self).sty {\n+            ty::ty_nil => Unit,\n+            ty::ty_bot => Bottom,\n+            ty::ty_bool => Bool,\n+            ty::ty_char => Primitive(ast::TyChar),\n+            ty::ty_int(t) => Primitive(ast::TyInt(t)),\n+            ty::ty_uint(u) => Primitive(ast::TyUint(u)),\n+            ty::ty_float(f) => Primitive(ast::TyFloat(f)),\n+            ty::ty_box(t) => Managed(box t.clean()),\n+            ty::ty_uniq(t) => Unique(box t.clean()),\n+            ty::ty_str => String,\n+            ty::ty_vec(mt, None) => Vector(box mt.ty.clean()),\n+            ty::ty_vec(mt, Some(i)) => FixedVector(box mt.ty.clean(),\n+                                                   format_strbuf!(\"{}\", i)),\n+            ty::ty_ptr(mt) => RawPointer(mt.mutbl.clean(), box mt.ty.clean()),\n+            ty::ty_rptr(r, mt) => BorrowedRef {\n+                lifetime: r.clean(),\n+                mutability: mt.mutbl.clean(),\n+                type_: box mt.ty.clean(),\n+            },\n+            ty::ty_bare_fn(ref fty) => BareFunction(box BareFunctionDecl {\n+                fn_style: fty.fn_style,\n+                generics: Generics {\n+                    lifetimes: Vec::new(), type_params: Vec::new()\n+                },\n+                decl: fty.sig.clean(),\n+                abi: fty.abi.to_str().to_strbuf(),\n+            }),\n+            ty::ty_closure(ref fty) => {\n+                let decl = box ClosureDecl {\n+                    lifetimes: Vec::new(), // FIXME: this looks wrong...\n+                    decl: fty.sig.clean(),\n+                    onceness: fty.onceness,\n+                    fn_style: fty.fn_style,\n+                    bounds: fty.bounds.iter().map(|i| i.clean()).collect(),\n+                };\n+                match fty.store {\n+                    ty::UniqTraitStore => Proc(decl),\n+                    ty::RegionTraitStore(ref r, _) => Closure(decl, r.clean()),\n+                }\n+            }\n+            ty::ty_struct(did, ref substs) |\n+            ty::ty_enum(did, ref substs) |\n+            ty::ty_trait(box ty::TyTrait { def_id: did, ref substs, .. }) => {\n+                let cx = super::ctxtkey.get().unwrap();\n+                let tcx = match cx.maybe_typed {\n+                    core::Typed(ref tycx) => tycx,\n+                    core::NotTyped(_) => fail!(),\n+                };\n+                let fqn = csearch::get_item_path(tcx, did);\n+                let fqn: Vec<StrBuf> = fqn.move_iter().map(|i| {\n+                    i.to_str().to_strbuf()\n+                }).collect();\n+                let mut path = external_path(fqn.last().unwrap().to_str());\n+                let kind = match ty::get(*self).sty {\n+                    ty::ty_struct(..) => TypeStruct,\n+                    ty::ty_trait(..) => TypeTrait,\n+                    _ => TypeEnum,\n+                };\n+                path.segments.get_mut(0).lifetimes = match substs.regions {\n+                    ty::ErasedRegions => Vec::new(),\n+                    ty::NonerasedRegions(ref v) => {\n+                        v.iter().filter_map(|v| v.clean()).collect()\n+                    }\n+                };\n+                path.segments.get_mut(0).types = substs.tps.clean();\n+                cx.external_paths.borrow_mut().get_mut_ref().insert(did,\n+                                                                    (fqn, kind));\n+                ResolvedPath {\n+                    path: path,\n+                    typarams: None,\n+                    did: did,\n+                }\n+            }\n+            ty::ty_tup(ref t) => Tuple(t.iter().map(|t| t.clean()).collect()),\n+\n+            ty::ty_param(ref p) => Generic(p.def_id),\n+            ty::ty_self(did) => Self(did),\n+\n+            ty::ty_infer(..) => fail!(\"ty_infer\"),\n+            ty::ty_err => fail!(\"ty_err\"),\n+        }\n+    }\n+}\n+\n #[deriving(Clone, Encodable, Decodable)]\n pub enum StructField {\n     HiddenStructField, // inserted later by strip passes\n@@ -770,7 +1064,7 @@ impl Clean<Item> for ast::StructField {\n             attrs: self.node.attrs.clean().move_iter().collect(),\n             source: self.span.clean(),\n             visibility: Some(vis),\n-            id: self.node.id,\n+            def_id: ast_util::local_def(self.node.id),\n             inner: StructFieldItem(TypedStructField(self.node.ty.clean())),\n         }\n     }\n@@ -798,7 +1092,7 @@ impl Clean<Item> for doctree::Struct {\n             name: Some(self.name.clean()),\n             attrs: self.attrs.clean(),\n             source: self.where.clean(),\n-            id: self.id,\n+            def_id: ast_util::local_def(self.id),\n             visibility: self.vis.clean(),\n             inner: StructItem(Struct {\n                 struct_type: self.struct_type,\n@@ -843,7 +1137,7 @@ impl Clean<Item> for doctree::Enum {\n             name: Some(self.name.clean()),\n             attrs: self.attrs.clean(),\n             source: self.where.clean(),\n-            id: self.id,\n+            def_id: ast_util::local_def(self.id),\n             visibility: self.vis.clean(),\n             inner: EnumItem(Enum {\n                 variants: self.variants.clean(),\n@@ -866,7 +1160,7 @@ impl Clean<Item> for doctree::Variant {\n             attrs: self.attrs.clean(),\n             source: self.where.clean(),\n             visibility: self.vis.clean(),\n-            id: self.id,\n+            def_id: ast_util::local_def(self.id),\n             inner: VariantItem(Variant {\n                 kind: self.kind.clean(),\n             }),\n@@ -988,7 +1282,7 @@ impl Clean<Item> for doctree::Typedef {\n             name: Some(self.name.clean()),\n             attrs: self.attrs.clean(),\n             source: self.where.clean(),\n-            id: self.id.clone(),\n+            def_id: ast_util::local_def(self.id.clone()),\n             visibility: self.vis.clean(),\n             inner: TypedefItem(Typedef {\n                 type_: self.ty.clean(),\n@@ -1037,7 +1331,7 @@ impl Clean<Item> for doctree::Static {\n             name: Some(self.name.clean()),\n             attrs: self.attrs.clean(),\n             source: self.where.clean(),\n-            id: self.id,\n+            def_id: ast_util::local_def(self.id),\n             visibility: self.vis.clean(),\n             inner: StaticItem(Static {\n                 type_: self.type_.clean(),\n@@ -1089,7 +1383,7 @@ impl Clean<Item> for doctree::Impl {\n             name: None,\n             attrs: self.attrs.clean(),\n             source: self.where.clean(),\n-            id: self.id,\n+            def_id: ast_util::local_def(self.id),\n             visibility: self.vis.clean(),\n             inner: ImplItem(Impl {\n                 generics: self.generics.clean(),\n@@ -1113,7 +1407,7 @@ impl Clean<Item> for ast::ViewItem {\n             name: None,\n             attrs: self.attrs.clean().move_iter().collect(),\n             source: self.span.clean(),\n-            id: 0,\n+            def_id: ast_util::local_def(0),\n             visibility: self.vis.clean(),\n             inner: ViewItemItem(ViewItem {\n                 inner: self.node.clean()\n@@ -1219,7 +1513,7 @@ impl Clean<Item> for ast::ForeignItem {\n             name: Some(self.ident.clean()),\n             attrs: self.attrs.clean().move_iter().collect(),\n             source: self.span.clean(),\n-            id: self.id,\n+            def_id: ast_util::local_def(self.id),\n             visibility: self.vis.clean(),\n             inner: inner,\n         }\n@@ -1288,7 +1582,7 @@ fn name_from_pat(p: &ast::Pat) -> StrBuf {\n }\n \n /// Given a Type, resolve it using the def_map\n-fn resolve_type(path: Path, tpbs: Option<Vec<TyParamBound> >,\n+fn resolve_type(path: Path, tpbs: Option<Vec<TyParamBound>>,\n                 id: ast::NodeId) -> Type {\n     let cx = super::ctxtkey.get().unwrap();\n     let tycx = match cx.maybe_typed {\n@@ -1303,13 +1597,13 @@ fn resolve_type(path: Path, tpbs: Option<Vec<TyParamBound> >,\n     };\n \n     match def {\n-        ast::DefSelfTy(i) => return Self(i),\n+        ast::DefSelfTy(i) => return Self(ast_util::local_def(i)),\n         ast::DefPrimTy(p) => match p {\n             ast::TyStr => return String,\n             ast::TyBool => return Bool,\n             _ => return Primitive(p)\n         },\n-        ast::DefTyParam(i, _) => return Generic(i.node),\n+        ast::DefTyParam(i, _) => return Generic(i),\n         ast::DefTyParamBinder(i) => return TyParamBinder(i),\n         _ => {}\n     };\n@@ -1337,9 +1631,26 @@ fn register_def(cx: &core::DocContext, def: ast::Def) -> ast::DefId {\n     let fqn = fqn.move_iter().map(|i| i.to_str().to_strbuf()).collect();\n     debug!(\"recording {} => {}\", did, fqn);\n     cx.external_paths.borrow_mut().get_mut_ref().insert(did, (fqn, kind));\n+    match kind {\n+        TypeTrait => {\n+            let t = build_external_trait(tcx, did);\n+            cx.external_traits.borrow_mut().get_mut_ref().insert(did, t);\n+        }\n+        _ => {}\n+    }\n     return did;\n }\n \n+fn build_external_trait(tcx: &ty::ctxt, did: ast::DefId) -> Trait {\n+    let def = csearch::get_trait_def(tcx, did);\n+    let methods = ty::trait_methods(tcx, did);\n+    Trait {\n+        generics: def.generics.clean(),\n+        methods: methods.iter().map(|i| i.clean()).collect(),\n+        parents: Vec::new(), // FIXME: this is likely wrong\n+    }\n+}\n+\n fn resolve_use_source(path: Path, id: ast::NodeId) -> ImportSource {\n     ImportSource {\n         path: path,\n@@ -1369,7 +1680,7 @@ impl Clean<Item> for doctree::Macro {\n             attrs: self.attrs.clean(),\n             source: self.where.clean(),\n             visibility: ast::Public.clean(),\n-            id: self.id,\n+            def_id: ast_util::local_def(self.id),\n             inner: MacroItem(Macro {\n                 source: self.where.to_src(),\n             }),"}, {"sha": "470f706e81e12f67a9b358fa17a08b77c017d3ce", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8d50d6a93c8f408b54f887670f70726421a48f0a/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d50d6a93c8f408b54f887670f70726421a48f0a/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=8d50d6a93c8f408b54f887670f70726421a48f0a", "patch": "@@ -20,7 +20,7 @@ use syntax;\n \n use std::cell::RefCell;\n use std::os;\n-use collections::{HashSet, HashMap};\n+use collections::{HashMap, HashSet};\n \n use visit_ast::RustdocVisitor;\n use clean;\n@@ -39,6 +39,8 @@ pub struct DocContext {\n     pub maybe_typed: MaybeTyped,\n     pub src: Path,\n     pub external_paths: ExternalPaths,\n+    pub external_traits: RefCell<Option<HashMap<ast::DefId, clean::Trait>>>,\n+    pub external_typarams: RefCell<Option<HashMap<ast::DefId, StrBuf>>>,\n }\n \n impl DocContext {\n@@ -54,6 +56,8 @@ pub struct CrateAnalysis {\n     pub exported_items: privacy::ExportedItems,\n     pub public_items: privacy::PublicItems,\n     pub external_paths: ExternalPaths,\n+    pub external_traits: RefCell<Option<HashMap<ast::DefId, clean::Trait>>>,\n+    pub external_typarams: RefCell<Option<HashMap<ast::DefId, StrBuf>>>,\n }\n \n /// Parses, resolves, and typechecks the given crate\n@@ -104,11 +108,15 @@ fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<StrBuf>)\n         krate: krate,\n         maybe_typed: Typed(ty_cx),\n         src: cpath.clone(),\n+        external_traits: RefCell::new(Some(HashMap::new())),\n+        external_typarams: RefCell::new(Some(HashMap::new())),\n         external_paths: RefCell::new(Some(HashMap::new())),\n     }, CrateAnalysis {\n         exported_items: exported_items,\n         public_items: public_items,\n         external_paths: RefCell::new(None),\n+        external_traits: RefCell::new(None),\n+        external_typarams: RefCell::new(None),\n     })\n }\n \n@@ -126,5 +134,9 @@ pub fn run_core(libs: HashSet<Path>, cfgs: Vec<StrBuf>, path: &Path)\n \n     let external_paths = ctxt.external_paths.borrow_mut().take();\n     *analysis.external_paths.borrow_mut() = external_paths;\n+    let map = ctxt.external_traits.borrow_mut().take();\n+    *analysis.external_traits.borrow_mut() = map;\n+    let map = ctxt.external_typarams.borrow_mut().take();\n+    *analysis.external_typarams.borrow_mut() = map;\n     (krate, analysis)\n }"}, {"sha": "77b12aec97b41bd72357bd709b329212d696871a", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d50d6a93c8f408b54f887670f70726421a48f0a/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d50d6a93c8f408b54f887670f70726421a48f0a/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=8d50d6a93c8f408b54f887670f70726421a48f0a", "patch": "@@ -19,7 +19,7 @@ pub trait DocFolder {\n \n     /// don't override!\n     fn fold_item_recur(&mut self, item: Item) -> Option<Item> {\n-        let Item { attrs, name, source, visibility, id, inner } = item;\n+        let Item { attrs, name, source, visibility, def_id, inner } = item;\n         let inner = inner;\n         let inner = match inner {\n             StructItem(mut i) => {\n@@ -83,7 +83,7 @@ pub trait DocFolder {\n         };\n \n         Some(Item { attrs: attrs, name: name, source: source, inner: inner,\n-                    visibility: visibility, id: id })\n+                    visibility: visibility, def_id: def_id })\n     }\n \n     fn fold_mod(&mut self, m: Module) -> Module {"}, {"sha": "948d47b2eaf7e25d20f27c7712e36d57b44b7d79", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8d50d6a93c8f408b54f887670f70726421a48f0a/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d50d6a93c8f408b54f887670f70726421a48f0a/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=8d50d6a93c8f408b54f887670f70726421a48f0a", "patch": "@@ -284,11 +284,15 @@ fn tybounds(w: &mut fmt::Formatter,\n impl fmt::Show for clean::Type {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            clean::TyParamBinder(id) | clean::Generic(id) => {\n+            clean::TyParamBinder(id) => {\n                 let m = cache_key.get().unwrap();\n-                f.write(m.typarams.get(&id).as_bytes())\n+                f.write(m.typarams.get(&ast_util::local_def(id)).as_bytes())\n             }\n-            clean::ResolvedPath{ did, ref typarams, ref path} => {\n+            clean::Generic(did) => {\n+                let m = cache_key.get().unwrap();\n+                f.write(m.typarams.get(&did).as_bytes())\n+            }\n+            clean::ResolvedPath{ did, ref typarams, ref path } => {\n                 try!(resolved_path(f, did, path, false));\n                 tybounds(f, typarams)\n             }"}, {"sha": "752f193fa3f35e76421ce04c629bf580bab49341", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 65, "deletions": 66, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/8d50d6a93c8f408b54f887670f70726421a48f0a/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d50d6a93c8f408b54f887670f70726421a48f0a/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=8d50d6a93c8f408b54f887670f70726421a48f0a", "patch": "@@ -85,7 +85,7 @@ pub struct Context {\n     /// functions), and the value is the list of containers belonging to this\n     /// header. This map will change depending on the surrounding context of the\n     /// page.\n-    pub sidebar: HashMap<StrBuf, Vec<StrBuf> >,\n+    pub sidebar: HashMap<StrBuf, Vec<StrBuf>>,\n     /// This flag indicates whether [src] links should be generated or not. If\n     /// the source files are present in the html rendering, then this will be\n     /// `true`.\n@@ -124,15 +124,15 @@ pub struct Cache {\n     /// Mapping of typaram ids to the name of the type parameter. This is used\n     /// when pretty-printing a type (so pretty printing doesn't have to\n     /// painfully maintain a context like this)\n-    pub typarams: HashMap<ast::NodeId, StrBuf>,\n+    pub typarams: HashMap<ast::DefId, StrBuf>,\n \n     /// Maps a type id to all known implementations for that type. This is only\n     /// recognized for intra-crate `ResolvedPath` types, and is used to print\n     /// out extra documentation on the page of an enum/struct.\n     ///\n     /// The values of the map are a list of implementations and documentation\n     /// found on that implementation.\n-    pub impls: HashMap<ast::NodeId, Vec<(clean::Impl, Option<StrBuf>)> >,\n+    pub impls: HashMap<ast::NodeId, Vec<(clean::Impl, Option<StrBuf>)>>,\n \n     /// Maintains a mapping of local crate node ids to the fully qualified name\n     /// and \"short type description\" of that node. This is used when generating\n@@ -145,15 +145,12 @@ pub struct Cache {\n     /// Implementations of a crate should inherit the documentation of the\n     /// parent trait if no extra documentation is specified, and default methods\n     /// should show up in documentation about trait implementations.\n-    pub traits: HashMap<ast::NodeId, clean::Trait>,\n+    pub traits: HashMap<ast::DefId, clean::Trait>,\n \n     /// When rendering traits, it's often useful to be able to list all\n     /// implementors of the trait, and this mapping is exactly, that: a mapping\n     /// of trait ids to the list of known implementors of the trait\n-    pub implementors: HashMap<ast::NodeId, Vec<Implementor>>,\n-\n-    /// Implementations of external traits, keyed by the external trait def id.\n-    pub foreign_implementors: HashMap<ast::DefId, Vec<Implementor>>,\n+    pub implementors: HashMap<ast::DefId, Vec<Implementor>>,\n \n     /// Cache of where external crate documentation can be found.\n     pub extern_locations: HashMap<ast::CrateNum, ExternalLocation>,\n@@ -251,6 +248,7 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n     // Crawl the crate to build various caches used for the output\n     let analysis = ::analysiskey.get();\n     let public_items = analysis.as_ref().map(|a| a.public_items.clone());\n+    let public_items = public_items.unwrap_or(NodeSet::new());\n     let paths = analysis.as_ref().map(|a| {\n         let paths = a.external_paths.borrow_mut().take_unwrap();\n         paths.move_iter().map(|(k, (v, t))| {\n@@ -267,18 +265,21 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n     }).unwrap_or(HashMap::new());\n     let mut cache = Cache {\n         impls: HashMap::new(),\n-        typarams: HashMap::new(),\n         paths: paths,\n-        traits: HashMap::new(),\n         implementors: HashMap::new(),\n-        foreign_implementors: HashMap::new(),\n         stack: Vec::new(),\n         parent_stack: Vec::new(),\n         search_index: Vec::new(),\n         extern_locations: HashMap::new(),\n         privmod: false,\n-        public_items: public_items.unwrap_or(NodeSet::new()),\n+        public_items: public_items,\n         orphan_methods: Vec::new(),\n+        traits: analysis.as_ref().map(|a| {\n+            a.external_traits.borrow_mut().take_unwrap()\n+        }).unwrap_or(HashMap::new()),\n+        typarams: analysis.as_ref().map(|a| {\n+            a.external_typarams.borrow_mut().take_unwrap()\n+        }).unwrap_or(HashMap::new()),\n     };\n     cache.stack.push(krate.name.clone());\n     krate = cache.fold_crate(krate);\n@@ -431,7 +432,8 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n         // Update the list of all implementors for traits\n         let dst = cx.dst.join(\"implementors\");\n         try!(mkdir(&dst));\n-        for (&did, imps) in cache.foreign_implementors.iter() {\n+        for (&did, imps) in cache.implementors.iter() {\n+            if ast_util::is_local(did) { continue }\n             let &(ref remote_path, remote_item_type) = cache.paths.get(&did);\n \n             let mut mydst = dst.clone();\n@@ -686,7 +688,7 @@ impl DocFolder for Cache {\n         // trait\n         match item.inner {\n             clean::TraitItem(ref t) => {\n-                self.traits.insert(item.id, t.clone());\n+                self.traits.insert(item.def_id, t.clone());\n             }\n             _ => {}\n         }\n@@ -695,15 +697,10 @@ impl DocFolder for Cache {\n         match item.inner {\n             clean::ImplItem(ref i) => {\n                 match i.trait_ {\n-                    // FIXME: this is_local() check seems to be losing\n-                    // information\n                     Some(clean::ResolvedPath{ did, .. }) => {\n-                        let v = if ast_util::is_local(did) {\n-                            self.implementors.find_or_insert(did.node, Vec::new())\n-                        } else {\n-                            self.foreign_implementors.find_or_insert(did,\n-                                                                     Vec::new())\n-                        };\n+                        let v = self.implementors.find_or_insert_with(did, |_| {\n+                            Vec::new()\n+                        });\n                         match i.for_ {\n                             clean::ResolvedPath{..} => {\n                                 v.unshift(PathType(i.for_.clone()));\n@@ -789,33 +786,38 @@ impl DocFolder for Cache {\n             clean::TypedefItem(..) | clean::TraitItem(..) |\n             clean::FunctionItem(..) | clean::ModuleItem(..) |\n             clean::ForeignFunctionItem(..) => {\n-                // Reexported items mean that the same id can show up twice in\n-                // the rustdoc ast that we're looking at. We know, however, that\n-                // a reexported item doesn't show up in the `public_items` map,\n-                // so we can skip inserting into the paths map if there was\n-                // already an entry present and we're not a public item.\n-                let did = ast_util::local_def(item.id);\n-                if !self.paths.contains_key(&did) ||\n-                   self.public_items.contains(&item.id) {\n-                    self.paths.insert(did, (self.stack.clone(),\n-                                            shortty(&item)));\n+                if ast_util::is_local(item.def_id) {\n+                    // Reexported items mean that the same id can show up twice\n+                    // in the rustdoc ast that we're looking at. We know,\n+                    // however, that a reexported item doesn't show up in the\n+                    // `public_items` map, so we can skip inserting into the\n+                    // paths map if there was already an entry present and we're\n+                    // not a public item.\n+                    let id = item.def_id.node;\n+                    if !self.paths.contains_key(&item.def_id) ||\n+                       self.public_items.contains(&id) {\n+                        self.paths.insert(item.def_id,\n+                                          (self.stack.clone(), shortty(&item)));\n+                    }\n                 }\n             }\n             // link variants to their parent enum because pages aren't emitted\n             // for each variant\n             clean::VariantItem(..) => {\n                 let mut stack = self.stack.clone();\n                 stack.pop();\n-                self.paths.insert(ast_util::local_def(item.id),\n-                                  (stack, item_type::Enum));\n+                self.paths.insert(item.def_id, (stack, item_type::Enum));\n             }\n             _ => {}\n         }\n \n         // Maintain the parent stack\n         let parent_pushed = match item.inner {\n             clean::TraitItem(..) | clean::EnumItem(..) | clean::StructItem(..) => {\n-                self.parent_stack.push(item.id); true\n+                if ast_util::is_local(item.def_id) {\n+                    self.parent_stack.push(item.def_id.node);\n+                }\n+                true\n             }\n             clean::ImplItem(ref i) => {\n                 match i.for_ {\n@@ -893,7 +895,7 @@ impl DocFolder for Cache {\n impl<'a> Cache {\n     fn generics(&mut self, generics: &clean::Generics) {\n         for typ in generics.type_params.iter() {\n-            self.typarams.insert(typ.id, typ.name.clone());\n+            self.typarams.insert(typ.did, typ.name.clone());\n         }\n     }\n }\n@@ -1411,7 +1413,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         try!(write!(w, \"</div>\"));\n     }\n \n-    match cache_key.get().unwrap().implementors.find(&it.id) {\n+    match cache_key.get().unwrap().implementors.find(&it.def_id) {\n         Some(implementors) => {\n             try!(write!(w, \"\n                 <h2 id='implementors'>Implementors</h2>\n@@ -1667,7 +1669,7 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n }\n \n fn render_methods(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n-    match cache_key.get().unwrap().impls.find(&it.id) {\n+    match cache_key.get().unwrap().impls.find(&it.def_id.node) {\n         Some(v) => {\n             let mut non_trait = v.iter().filter(|p| {\n                 p.ref0().trait_.is_none()\n@@ -1714,16 +1716,10 @@ fn render_methods(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n fn render_impl(w: &mut fmt::Formatter, i: &clean::Impl,\n                dox: &Option<StrBuf>) -> fmt::Result {\n     try!(write!(w, \"<h3 class='impl'><code>impl{} \", i.generics));\n-    let trait_id = match i.trait_ {\n-        Some(ref ty) => {\n-            try!(write!(w, \"{} for \", *ty));\n-            match *ty {\n-                clean::ResolvedPath { did, .. } => Some(did),\n-                _ => None,\n-            }\n-        }\n-        None => None\n-    };\n+    match i.trait_ {\n+        Some(ref ty) => try!(write!(w, \"{} for \", *ty)),\n+        None => {}\n+    }\n     try!(write!(w, \"{}</code></h3>\", i.for_));\n     match *dox {\n         Some(ref dox) => {\n@@ -1753,31 +1749,34 @@ fn render_impl(w: &mut fmt::Formatter, i: &clean::Impl,\n         try!(docmeth(w, meth, true));\n     }\n \n+    fn render_default_methods(w: &mut fmt::Formatter,\n+                              t: &clean::Trait,\n+                              i: &clean::Impl) -> fmt::Result {\n+        for method in t.methods.iter() {\n+            let n = method.item().name.clone();\n+            match i.methods.iter().find(|m| { m.name == n }) {\n+                Some(..) => continue,\n+                None => {}\n+            }\n+\n+            try!(docmeth(w, method.item(), false));\n+        }\n+        Ok(())\n+    }\n+\n     // If we've implemented a trait, then also emit documentation for all\n     // default methods which weren't overridden in the implementation block.\n-    match trait_id {\n-        None => {}\n-        // FIXME: this should work for non-local traits\n-        Some(did) if ast_util::is_local(did) => {\n+    match i.trait_ {\n+        Some(clean::ResolvedPath { did, .. }) => {\n             try!({\n-                match cache_key.get().unwrap().traits.find(&did.node) {\n-                    Some(t) => {\n-                        for method in t.methods.iter() {\n-                            let n = method.item().name.clone();\n-                            match i.methods.iter().find(|m| m.name == n) {\n-                                Some(..) => continue,\n-                                None => {}\n-                            }\n-\n-                            try!(docmeth(w, method.item(), false));\n-                        }\n-                    }\n+                match cache_key.get().unwrap().traits.find(&did) {\n+                    Some(t) => try!(render_default_methods(w, t, i)),\n                     None => {}\n                 }\n                 Ok(())\n             })\n         }\n-        Some(..) => {}\n+        Some(..) | None => {}\n     }\n     try!(write!(w, \"</div>\"));\n     Ok(())\n@@ -1849,7 +1848,7 @@ impl<'a> fmt::Show for Sidebar<'a> {\n     }\n }\n \n-fn build_sidebar(m: &clean::Module) -> HashMap<StrBuf, Vec<StrBuf> > {\n+fn build_sidebar(m: &clean::Module) -> HashMap<StrBuf, Vec<StrBuf>> {\n     let mut map = HashMap::new();\n     for item in m.items.iter() {\n         let short = shortty(item).to_static_str();"}, {"sha": "a0d993dfe7d036262596d0c071a9d843ee6387fc", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8d50d6a93c8f408b54f887670f70726421a48f0a/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d50d6a93c8f408b54f887670f70726421a48f0a/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=8d50d6a93c8f408b54f887670f70726421a48f0a", "patch": "@@ -35,7 +35,7 @@ pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n             fn fold_item(&mut self, i: Item) -> Option<Item> {\n                 if i.is_hidden_from_doc() {\n                     debug!(\"found one in strip_hidden; removing\");\n-                    self.stripped.insert(i.id);\n+                    self.stripped.insert(i.def_id.node);\n \n                     // use a dedicated hidden item for given item type if any\n                     match i.inner {\n@@ -124,7 +124,8 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n             clean::TraitItem(..) | clean::FunctionItem(..) |\n             clean::VariantItem(..) | clean::MethodItem(..) |\n             clean::ForeignFunctionItem(..) | clean::ForeignStaticItem(..) => {\n-                if !self.exported_items.contains(&i.id) {\n+                if ast_util::is_local(i.def_id) &&\n+                   !self.exported_items.contains(&i.def_id.node) {\n                     return None;\n                 }\n             }\n@@ -173,7 +174,7 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n         };\n \n         let i = if fastreturn {\n-            self.retained.insert(i.id);\n+            self.retained.insert(i.def_id.node);\n             return Some(i);\n         } else {\n             self.fold_item_recur(i)\n@@ -188,7 +189,7 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n                            i.doc_value().is_none() => None,\n                     clean::ImplItem(ref i) if i.methods.len() == 0 => None,\n                     _ => {\n-                        self.retained.insert(i.id);\n+                        self.retained.insert(i.def_id.node);\n                         Some(i)\n                     }\n                 }"}, {"sha": "5b4a9bd27b76c83aabf487eb8532628a9e75a851", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d50d6a93c8f408b54f887670f70726421a48f0a/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d50d6a93c8f408b54f887670f70726421a48f0a/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=8d50d6a93c8f408b54f887670f70726421a48f0a", "patch": "@@ -76,6 +76,8 @@ pub fn run(input: &str,\n         maybe_typed: core::NotTyped(sess),\n         src: input_path,\n         external_paths: RefCell::new(Some(HashMap::new())),\n+        external_traits: RefCell::new(None),\n+        external_typarams: RefCell::new(None),\n     };\n     super::ctxtkey.replace(Some(ctx));\n "}]}