{"sha": "e2fd2dffde52a59f7d59d67460aeb2ebf33f77dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyZmQyZGZmZGU1MmE1OWY3ZDU5ZDY3NDYwYWViMmViZjMzZjc3ZGQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-27T23:25:49Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-28T02:03:18Z"}, "message": "std: Don't deadlock/panic on recursive prints\n\nPreviously a panic was generated for recursive prints due to a double-borrow of\na `RefCell`. This was solved by the second borrow's output being directed\ntowards the global stdout instead of the per-thread stdout (still experimental\nfunctionality).\n\nAfter this functionality was altered, however, recursive prints still deadlocked\ndue to the overridden `write_fmt` method which locked itself first and then\nwrote all the data. This was fixed by removing the override of the `write_fmt`\nmethod. This means that unlocked usage of `write!` on a `Stdout`/`Stderr` may be\nslower due to acquiring more locks, but it's easy to make more performant with a\ncall to `.lock()`.\n\nCloses #23781", "tree": {"sha": "1097838bfff9b82a5d1547e4d442316a3b08d747", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1097838bfff9b82a5d1547e4d442316a3b08d747"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2fd2dffde52a59f7d59d67460aeb2ebf33f77dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2fd2dffde52a59f7d59d67460aeb2ebf33f77dd", "html_url": "https://github.com/rust-lang/rust/commit/e2fd2dffde52a59f7d59d67460aeb2ebf33f77dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2fd2dffde52a59f7d59d67460aeb2ebf33f77dd/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "552080181c58beef03493a110b4a38b20b6b5da5", "url": "https://api.github.com/repos/rust-lang/rust/commits/552080181c58beef03493a110b4a38b20b6b5da5", "html_url": "https://github.com/rust-lang/rust/commit/552080181c58beef03493a110b4a38b20b6b5da5"}], "stats": {"total": 63, "additions": 52, "deletions": 11}, "files": [{"sha": "d361f17cbe41bc87bfafba0ee601edac29b9c2cf", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e2fd2dffde52a59f7d59d67460aeb2ebf33f77dd/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2fd2dffde52a59f7d59d67460aeb2ebf33f77dd/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=e2fd2dffde52a59f7d59d67460aeb2ebf33f77dd", "patch": "@@ -11,7 +11,7 @@\n use prelude::v1::*;\n use io::prelude::*;\n \n-use cell::RefCell;\n+use cell::{RefCell, BorrowState};\n use cmp;\n use fmt;\n use io::lazy::Lazy;\n@@ -264,9 +264,8 @@ impl Write for Stdout {\n     fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n         self.lock().write_all(buf)\n     }\n-    fn write_fmt(&mut self, fmt: fmt::Arguments) -> io::Result<()> {\n-        self.lock().write_fmt(fmt)\n-    }\n+    // Don't override write_fmt as it's possible to run arbitrary code during a\n+    // write_fmt, allowing the possibility of a recursive lock (aka deadlock)\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Write for StdoutLock<'a> {\n@@ -334,9 +333,7 @@ impl Write for Stderr {\n     fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n         self.lock().write_all(buf)\n     }\n-    fn write_fmt(&mut self, fmt: fmt::Arguments) -> io::Result<()> {\n-        self.lock().write_fmt(fmt)\n-    }\n+    // Don't override write_fmt for the same reasons as Stdout\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Write for StderrLock<'a> {\n@@ -395,10 +392,15 @@ pub fn set_print(sink: Box<Write + Send>) -> Option<Box<Write + Send>> {\n            reason = \"implementation detail which may disappear or be replaced at any time\")]\n #[doc(hidden)]\n pub fn _print(args: fmt::Arguments) {\n-    if let Err(e) = LOCAL_STDOUT.with(|s| match s.borrow_mut().as_mut() {\n-        Some(w) => w.write_fmt(args),\n-        None => stdout().write_fmt(args)\n-    }) {\n+    let result = LOCAL_STDOUT.with(|s| {\n+        if s.borrow_state() == BorrowState::Unused {\n+            if let Some(w) = s.borrow_mut().as_mut() {\n+                return w.write_fmt(args);\n+            }\n+        }\n+        stdout().write_fmt(args)\n+    });\n+    if let Err(e) = result {\n         panic!(\"failed printing to stdout: {}\", e);\n     }\n }"}, {"sha": "5f5f2fed567328a26fba2a8256d53bbe87e5b6ac", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e2fd2dffde52a59f7d59d67460aeb2ebf33f77dd/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2fd2dffde52a59f7d59d67460aeb2ebf33f77dd/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=e2fd2dffde52a59f7d59d67460aeb2ebf33f77dd", "patch": "@@ -127,6 +127,7 @@\n #![feature(str_char)]\n #![feature(into_cow)]\n #![feature(slice_patterns)]\n+#![feature(std_misc)]\n #![cfg_attr(test, feature(test, rustc_private, std_misc))]\n \n // Don't link to std. We are std."}, {"sha": "23ac8d2b782142ce493b38b8532134a995cc840e", "filename": "src/test/run-pass/issue-23781.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e2fd2dffde52a59f7d59d67460aeb2ebf33f77dd/src%2Ftest%2Frun-pass%2Fissue-23781.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2fd2dffde52a59f7d59d67460aeb2ebf33f77dd/src%2Ftest%2Frun-pass%2Fissue-23781.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-23781.rs?ref=e2fd2dffde52a59f7d59d67460aeb2ebf33f77dd", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt;\n+\n+struct Foo;\n+impl fmt::Debug for Foo {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        println!(\"<Foo as Debug>::fmt()\");\n+\n+        write!(fmt, \"\")\n+    }\n+}\n+\n+fn test1() {\n+    let foo_str = format!(\"{:?}\", Foo);\n+\n+    println!(\"{}\", foo_str);\n+}\n+\n+fn test2() {\n+    println!(\"{:?}\", Foo);\n+}\n+\n+fn main() {\n+    // This works fine\n+    test1();\n+\n+    // This fails\n+    test2();\n+}"}]}