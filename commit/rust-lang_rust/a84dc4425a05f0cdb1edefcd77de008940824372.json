{"sha": "a84dc4425a05f0cdb1edefcd77de008940824372", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4NGRjNDQyNWEwNWYwY2RiMWVkZWZjZDc3ZGUwMDg5NDA4MjQzNzI=", "commit": {"author": {"name": "vsrs", "email": "vit@conrlab.com", "date": "2020-07-24T13:26:50Z"}, "committer": {"name": "vsrs", "email": "vit@conrlab.com", "date": "2020-07-24T13:29:35Z"}, "message": "Always send experimental & semantic server caps.", "tree": {"sha": "56506adcad835803894bdd8755a434236df750b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56506adcad835803894bdd8755a434236df750b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a84dc4425a05f0cdb1edefcd77de008940824372", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a84dc4425a05f0cdb1edefcd77de008940824372", "html_url": "https://github.com/rust-lang/rust/commit/a84dc4425a05f0cdb1edefcd77de008940824372", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a84dc4425a05f0cdb1edefcd77de008940824372/comments", "author": {"login": "vsrs", "id": 62505555, "node_id": "MDQ6VXNlcjYyNTA1NTU1", "avatar_url": "https://avatars.githubusercontent.com/u/62505555?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vsrs", "html_url": "https://github.com/vsrs", "followers_url": "https://api.github.com/users/vsrs/followers", "following_url": "https://api.github.com/users/vsrs/following{/other_user}", "gists_url": "https://api.github.com/users/vsrs/gists{/gist_id}", "starred_url": "https://api.github.com/users/vsrs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vsrs/subscriptions", "organizations_url": "https://api.github.com/users/vsrs/orgs", "repos_url": "https://api.github.com/users/vsrs/repos", "events_url": "https://api.github.com/users/vsrs/events{/privacy}", "received_events_url": "https://api.github.com/users/vsrs/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vsrs", "id": 62505555, "node_id": "MDQ6VXNlcjYyNTA1NTU1", "avatar_url": "https://avatars.githubusercontent.com/u/62505555?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vsrs", "html_url": "https://github.com/vsrs", "followers_url": "https://api.github.com/users/vsrs/followers", "following_url": "https://api.github.com/users/vsrs/following{/other_user}", "gists_url": "https://api.github.com/users/vsrs/gists{/gist_id}", "starred_url": "https://api.github.com/users/vsrs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vsrs/subscriptions", "organizations_url": "https://api.github.com/users/vsrs/orgs", "repos_url": "https://api.github.com/users/vsrs/repos", "events_url": "https://api.github.com/users/vsrs/events{/privacy}", "received_events_url": "https://api.github.com/users/vsrs/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57b4ec4d5eaf56337f2d3080b02d93404dcb9dc3", "url": "https://api.github.com/repos/rust-lang/rust/commits/57b4ec4d5eaf56337f2d3080b02d93404dcb9dc3", "html_url": "https://github.com/rust-lang/rust/commit/57b4ec4d5eaf56337f2d3080b02d93404dcb9dc3"}], "stats": {"total": 108, "additions": 36, "deletions": 72}, "files": [{"sha": "37d695448420e1a7b860618383bb3beb7bb144c5", "filename": "crates/rust-analyzer/src/caps.rs", "status": "modified", "additions": 36, "deletions": 72, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/a84dc4425a05f0cdb1edefcd77de008940824372/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a84dc4425a05f0cdb1edefcd77de008940824372/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs?ref=a84dc4425a05f0cdb1edefcd77de008940824372", "patch": "@@ -7,18 +7,16 @@ use lsp_types::{\n     DocumentOnTypeFormattingOptions, FoldingRangeProviderCapability, HoverProviderCapability,\n     ImplementationProviderCapability, RenameOptions, RenameProviderCapability, SaveOptions,\n     SelectionRangeProviderCapability, SemanticTokensDocumentProvider, SemanticTokensLegend,\n-    SemanticTokensOptions, SemanticTokensServerCapabilities, ServerCapabilities,\n-    SignatureHelpOptions, TextDocumentSyncCapability, TextDocumentSyncKind,\n-    TextDocumentSyncOptions, TypeDefinitionProviderCapability, WorkDoneProgressOptions,\n+    SemanticTokensOptions, ServerCapabilities, SignatureHelpOptions, TextDocumentSyncCapability,\n+    TextDocumentSyncKind, TextDocumentSyncOptions, TypeDefinitionProviderCapability,\n+    WorkDoneProgressOptions,\n };\n-use serde_json::{json, Value};\n+use serde_json::json;\n \n use crate::semantic_tokens;\n \n pub fn server_capabilities(client_caps: &ClientCapabilities) -> ServerCapabilities {\n     let code_action_provider = code_action_capabilities(client_caps);\n-    let semantic_tokens_provider = semantic_tokens_capabilities(client_caps);\n-    let experimental = experimental_capabilities(client_caps);\n \n     ServerCapabilities {\n         text_document_sync: Some(TextDocumentSyncCapability::Options(TextDocumentSyncOptions {\n@@ -71,58 +69,29 @@ pub fn server_capabilities(client_caps: &ClientCapabilities) -> ServerCapabiliti\n         execute_command_provider: None,\n         workspace: None,\n         call_hierarchy_provider: Some(CallHierarchyServerCapability::Simple(true)),\n-        semantic_tokens_provider,\n-        experimental,\n-    }\n-}\n-\n-fn experimental_capabilities(client_caps: &ClientCapabilities) -> Option<Value> {\n-    client_caps.experimental.as_ref().and_then(|it| {\n-        it.as_object().map(|map| {\n-            let mut obj = json!({});\n-            let result = obj.as_object_mut().unwrap();\n-\n-            if map.contains_key(\"joinLines\") {\n-                result.insert(\"joinLines\".into(), true.into());\n-            }\n-\n-            if map.contains_key(\"ssr\") {\n-                result.insert(\"ssr\".into(), true.into());\n-            }\n-\n-            if map.contains_key(\"onEnter\") {\n-                result.insert(\"onEnter\".into(), true.into());\n-            }\n-\n-            if map.contains_key(\"parentModule\") {\n-                result.insert(\"parentModule\".into(), true.into());\n-            }\n+        semantic_tokens_provider: Some(\n+            SemanticTokensOptions {\n+                legend: SemanticTokensLegend {\n+                    token_types: semantic_tokens::SUPPORTED_TYPES.to_vec(),\n+                    token_modifiers: semantic_tokens::SUPPORTED_MODIFIERS.to_vec(),\n+                },\n \n-            if map.contains_key(\"runnables\") {\n-                result.insert(\"runnables\".into(), json!({ \"kinds\": [ \"cargo\" ] }));\n+                document_provider: Some(SemanticTokensDocumentProvider::Bool(true)),\n+                range_provider: Some(true),\n+                work_done_progress_options: Default::default(),\n             }\n-\n-            obj\n-        })\n-    })\n-}\n-\n-fn semantic_tokens_capabilities(\n-    client_caps: &ClientCapabilities,\n-) -> Option<SemanticTokensServerCapabilities> {\n-    client_caps.text_document.as_ref().and_then(|it| it.semantic_tokens.as_ref()).map(|_|\n-            // client supports semanticTokens\n-            SemanticTokensOptions {\n-            legend: SemanticTokensLegend {\n-                token_types: semantic_tokens::SUPPORTED_TYPES.to_vec(),\n-                token_modifiers: semantic_tokens::SUPPORTED_MODIFIERS.to_vec(),\n+            .into(),\n+        ),\n+        experimental: Some(json!({\n+            \"joinLines\": true,\n+            \"ssr\": true,\n+            \"onEnter\": true,\n+            \"parentModule\": true,\n+            \"runnables\": {\n+                \"kinds\": [ \"cargo\" ],\n             },\n-\n-            document_provider: Some(SemanticTokensDocumentProvider::Bool(true)),\n-            range_provider: Some(true),\n-            work_done_progress_options: Default::default(),\n-        }\n-        .into())\n+        })),\n+    }\n }\n \n fn code_action_capabilities(client_caps: &ClientCapabilities) -> CodeActionProviderCapability {\n@@ -131,24 +100,19 @@ fn code_action_capabilities(client_caps: &ClientCapabilities) -> CodeActionProvi\n         .as_ref()\n         .and_then(|it| it.code_action.as_ref())\n         .and_then(|it| it.code_action_literal_support.as_ref())\n-        .map_or(CodeActionProviderCapability::Simple(true), |caps| {\n-            let mut action_kinds = vec![\n-                CodeActionKind::EMPTY,\n-                CodeActionKind::QUICKFIX,\n-                CodeActionKind::REFACTOR,\n-                CodeActionKind::REFACTOR_EXTRACT,\n-                CodeActionKind::REFACTOR_INLINE,\n-                CodeActionKind::REFACTOR_REWRITE,\n-            ];\n-\n-            // Not all clients can fall back gracefully for unknown values.\n-            // Microsoft.VisualStudio.LanguageServer.Protocol.CodeActionKind does not support CodeActionKind::EMPTY\n-            // So have to filter out.\n-            action_kinds\n-                .retain(|it| caps.code_action_kind.value_set.contains(&it.as_str().to_owned()));\n-\n+        .map_or(CodeActionProviderCapability::Simple(true), |_| {\n             CodeActionProviderCapability::Options(CodeActionOptions {\n-                code_action_kinds: Some(action_kinds),\n+                // Advertise support for all built-in CodeActionKinds.\n+                // Ideally we would base this off of the client capabilities\n+                // but the client is supposed to fall back gracefully for unknown values.\n+                code_action_kinds: Some(vec![\n+                    CodeActionKind::EMPTY,\n+                    CodeActionKind::QUICKFIX,\n+                    CodeActionKind::REFACTOR,\n+                    CodeActionKind::REFACTOR_EXTRACT,\n+                    CodeActionKind::REFACTOR_INLINE,\n+                    CodeActionKind::REFACTOR_REWRITE,\n+                ]),\n                 work_done_progress_options: Default::default(),\n             })\n         })"}]}