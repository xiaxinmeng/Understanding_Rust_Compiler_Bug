{"sha": "fcba8d31c44f6c18121e3d37311b0797bbeb033f", "node_id": "C_kwDOAAsO6NoAKGZjYmE4ZDMxYzQ0ZjZjMTgxMjFlM2QzNzMxMWIwNzk3YmJlYjAzM2Y", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-01-27T14:41:28Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-02-02T15:40:11Z"}, "message": "Remove the `Instantiator` now that we don't recurse within it anymore", "tree": {"sha": "f0bdfe59440c6a8df7615f5d09ab20a40f3df443", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0bdfe59440c6a8df7615f5d09ab20a40f3df443"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fcba8d31c44f6c18121e3d37311b0797bbeb033f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fcba8d31c44f6c18121e3d37311b0797bbeb033f", "html_url": "https://github.com/rust-lang/rust/commit/fcba8d31c44f6c18121e3d37311b0797bbeb033f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fcba8d31c44f6c18121e3d37311b0797bbeb033f/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e03edd287e774e737add22fd957e1cf4c813e1ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/e03edd287e774e737add22fd957e1cf4c813e1ea", "html_url": "https://github.com/rust-lang/rust/commit/e03edd287e774e737add22fd957e1cf4c813e1ea"}], "stats": {"total": 47, "additions": 19, "deletions": 28}, "files": [{"sha": "4ac070a95e54c87a8630ad7d51998d89bd55f8a6", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 19, "deletions": 28, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/fcba8d31c44f6c18121e3d37311b0797bbeb033f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcba8d31c44f6c18121e3d37311b0797bbeb033f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=fcba8d31c44f6c18121e3d37311b0797bbeb033f", "patch": "@@ -86,8 +86,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 if !matches!(a.kind(), ty::Opaque(..)) {\n                     return None;\n                 }\n-                Instantiator { infcx: self, cause: cause.clone(), param_env }\n-                    .fold_opaque_ty_new(a, |_, _| b)\n+                self.fold_opaque_ty_new(a, cause.clone(), param_env, |_, _| b)\n             };\n             if let Some(res) = process(a, b) {\n                 res\n@@ -480,16 +479,12 @@ impl UseKind {\n     }\n }\n \n-struct Instantiator<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n-    cause: ObligationCause<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-}\n-\n-impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     fn fold_opaque_ty_new(\n-        &mut self,\n+        &self,\n         ty: Ty<'tcx>,\n+        cause: ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n         mk_ty: impl FnOnce(&InferCtxt<'_, 'tcx>, Span) -> Ty<'tcx>,\n     ) -> Option<InferResult<'tcx, ()>> {\n         // Check that this is `impl Trait` type is\n@@ -527,9 +522,8 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n         // }\n         // ```\n         let opaque_type_key = ty.expect_opaque_type();\n-        if let Some(origin) = self.infcx.opaque_type_origin(opaque_type_key.def_id, self.cause.span)\n-        {\n-            return Some(self.fold_opaque_ty(ty, opaque_type_key, origin, mk_ty));\n+        if let Some(origin) = self.opaque_type_origin(opaque_type_key.def_id, cause.span) {\n+            return Some(self.fold_opaque_ty(ty, cause, param_env, opaque_type_key, origin, mk_ty));\n         }\n \n         debug!(?ty, \"encountered opaque outside its definition scope\",);\n@@ -538,34 +532,35 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n \n     #[instrument(skip(self, mk_ty), level = \"debug\")]\n     fn fold_opaque_ty(\n-        &mut self,\n+        &self,\n         ty: Ty<'tcx>,\n+        cause: ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n         opaque_type_key: OpaqueTypeKey<'tcx>,\n         origin: hir::OpaqueTyOrigin,\n         mk_ty: impl FnOnce(&InferCtxt<'_, 'tcx>, Span) -> Ty<'tcx>,\n     ) -> InferResult<'tcx, ()> {\n-        let infcx = self.infcx;\n-        let tcx = infcx.tcx;\n+        let tcx = self.tcx;\n         let OpaqueTypeKey { def_id, substs } = opaque_type_key;\n \n-        let ty_var = mk_ty(infcx, self.cause.span);\n+        let ty_var = mk_ty(self, cause.span);\n \n         // Ideally, we'd get the span where *this specific `ty` came\n         // from*, but right now we just use the span from the overall\n         // value being folded. In simple cases like `-> impl Foo`,\n         // these are the same span, but not in cases like `-> (impl\n         // Foo, impl Bar)`.\n-        let span = self.cause.span;\n+        let span = cause.span;\n \n         let mut obligations = vec![];\n-        let prev = self.infcx.inner.borrow_mut().opaque_types().register(\n+        let prev = self.inner.borrow_mut().opaque_types().register(\n             OpaqueTypeKey { def_id, substs },\n             ty,\n             OpaqueHiddenType { ty: ty_var, span },\n             origin,\n         );\n         if let Some(prev) = prev {\n-            obligations = self.infcx.at(&self.cause, self.param_env).eq(prev, ty_var)?.obligations;\n+            obligations = self.at(&cause, param_env).eq(prev, ty_var)?.obligations;\n         }\n \n         debug!(\"generated new type inference var {:?}\", ty_var.kind());\n@@ -581,10 +576,10 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                 ty_op: |ty| match *ty.kind() {\n                     // We can't normalize associated types from `rustc_infer`,\n                     // but we can eagerly register inference variables for them.\n-                    ty::Projection(projection_ty) if !projection_ty.has_escaping_bound_vars() => infcx.infer_projection(\n-                        self.param_env,\n+                    ty::Projection(projection_ty) if !projection_ty.has_escaping_bound_vars() => self.infer_projection(\n+                        param_env,\n                         projection_ty,\n-                        self.cause.clone(),\n+                        cause.clone(),\n                         0,\n                         &mut obligations,\n                     ),\n@@ -608,11 +603,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n             }\n             // Require that the predicate holds for the concrete type.\n             debug!(?predicate);\n-            obligations.push(traits::Obligation::new(\n-                self.cause.clone(),\n-                self.param_env,\n-                predicate,\n-            ));\n+            obligations.push(traits::Obligation::new(cause.clone(), param_env, predicate));\n         }\n         Ok(InferOk { value: (), obligations })\n     }"}]}