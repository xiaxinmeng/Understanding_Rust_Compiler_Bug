{"sha": "cd93be0094a135c55533cb0eba342e5aa1324f00", "node_id": "C_kwDOAAsO6NoAKGNkOTNiZTAwOTRhMTM1YzU1NTMzY2IwZWJhMzQyZTVhYTEzMjRmMDA", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-15T10:28:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-15T10:28:25Z"}, "message": "Rollup merge of #92865 - jackh726:gats-outlives-no-static, r=nikomatsakis\n\nIgnore static lifetimes for GATs outlives lint\n\ncc https://github.com/rust-lang/rust/issues/87479#issuecomment-1010484170\n\nAlso included a bit of cleanup of `ty_known_to_outlive` and `region_known_to_outlive`\n\nr? `@nikomatsakis`", "tree": {"sha": "0b0bbf3ce48cd8099b03af10135faf4bb909de99", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b0bbf3ce48cd8099b03af10135faf4bb909de99"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd93be0094a135c55533cb0eba342e5aa1324f00", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh4qHKCRBK7hj4Ov3rIwAAV4IIABt4cQLzFsLgsSwBE2Mk+rgh\ntqcBhuBvAuL6greHdpswSmAGNc8ivo4VWSaqLcNzX1pBFD9JyeV7IUUNJQ+GcEQY\nvtUbuWSsxzQ02YYRELkm5blefIuCIWC1QSJm3dLEvhPDFKk3lFL/pMYd1ShxikYQ\nUJ/9nGbtiGTk2MgDWuZkAyPlGb4WsVttkMymErsNG0LDJqxFIsqWSwX4mrvIlkAO\nr8jPejTQyU6x7LmqflD/ZeBnHD2TupFS9FkU8xNrws+l7WiOjipWQeAIMwTB5tAI\nd+AytaC3sLH/n/fNp0q45vB5kcN4WdCNb/G/NVR2I9g+KIKhWSrrKkbv/ngRKuM=\n=BSRe\n-----END PGP SIGNATURE-----\n", "payload": "tree 0b0bbf3ce48cd8099b03af10135faf4bb909de99\nparent d878ad0559ed1be0d0a0e3cdc2a62a9480e42cb8\nparent e8e32e48c4c52a53d0885ddd8eb972829bbda8e5\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1642242505 +0100\ncommitter GitHub <noreply@github.com> 1642242505 +0100\n\nRollup merge of #92865 - jackh726:gats-outlives-no-static, r=nikomatsakis\n\nIgnore static lifetimes for GATs outlives lint\n\ncc https://github.com/rust-lang/rust/issues/87479#issuecomment-1010484170\n\nAlso included a bit of cleanup of `ty_known_to_outlive` and `region_known_to_outlive`\n\nr? `@nikomatsakis`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd93be0094a135c55533cb0eba342e5aa1324f00", "html_url": "https://github.com/rust-lang/rust/commit/cd93be0094a135c55533cb0eba342e5aa1324f00", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd93be0094a135c55533cb0eba342e5aa1324f00/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d878ad0559ed1be0d0a0e3cdc2a62a9480e42cb8", "url": "https://api.github.com/repos/rust-lang/rust/commits/d878ad0559ed1be0d0a0e3cdc2a62a9480e42cb8", "html_url": "https://github.com/rust-lang/rust/commit/d878ad0559ed1be0d0a0e3cdc2a62a9480e42cb8"}, {"sha": "e8e32e48c4c52a53d0885ddd8eb972829bbda8e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8e32e48c4c52a53d0885ddd8eb972829bbda8e5", "html_url": "https://github.com/rust-lang/rust/commit/e8e32e48c4c52a53d0885ddd8eb972829bbda8e5"}], "stats": {"total": 107, "additions": 61, "deletions": 46}, "files": [{"sha": "fbc446e3ea42e9cacd4c0ecd2019b04059f1658f", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 48, "deletions": 46, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/cd93be0094a135c55533cb0eba342e5aa1324f00/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd93be0094a135c55533cb0eba342e5aa1324f00/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=cd93be0094a135c55533cb0eba342e5aa1324f00", "patch": "@@ -14,8 +14,9 @@ use rustc_hir::lang_items::LangItem;\n use rustc_hir::ItemKind;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::outlives::obligations::TypeOutlives;\n-use rustc_infer::infer::TyCtxtInferExt;\n-use rustc_infer::infer::{self, RegionckMode, SubregionOrigin};\n+use rustc_infer::infer::region_constraints::GenericKind;\n+use rustc_infer::infer::{self, RegionckMode};\n+use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_middle::hir::map as hir_map;\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts, Subst};\n use rustc_middle::ty::trait_def::TraitSpecializationKind;\n@@ -332,6 +333,12 @@ fn check_gat_where_clauses(\n         // outlives relationship (`Self: 'a`), then we want to ensure that is\n         // reflected in a where clause on the GAT itself.\n         for (region, region_idx) in &regions {\n+            // Ignore `'static` lifetimes for the purpose of this lint: it's\n+            // because we know it outlives everything and so doesn't give meaninful\n+            // clues\n+            if let ty::ReStatic = region {\n+                continue;\n+            }\n             for (ty, ty_idx) in &types {\n                 // In our example, requires that Self: 'a\n                 if ty_known_to_outlive(tcx, id, param_env, &wf_tys, *ty, *region) {\n@@ -371,10 +378,19 @@ fn check_gat_where_clauses(\n         // outlives relationship, then we want to ensure that is\n         // reflected in a where clause on the GAT itself.\n         for (region_a, region_a_idx) in &regions {\n+            // Ignore `'static` lifetimes for the purpose of this lint: it's\n+            // because we know it outlives everything and so doesn't give meaninful\n+            // clues\n+            if let ty::ReStatic = region_a {\n+                continue;\n+            }\n             for (region_b, region_b_idx) in &regions {\n                 if region_a == region_b {\n                     continue;\n                 }\n+                if let ty::ReStatic = region_b {\n+                    continue;\n+                }\n \n                 if region_known_to_outlive(tcx, id, param_env, &wf_tys, *region_a, *region_b) {\n                     debug!(?region_a_idx, ?region_b_idx);\n@@ -502,8 +518,6 @@ fn check_gat_where_clauses(\n     }\n }\n \n-// FIXME(jackh726): refactor some of the shared logic between the two functions below\n-\n /// Given a known `param_env` and a set of well formed types, can we prove that\n /// `ty` outlives `region`.\n fn ty_known_to_outlive<'tcx>(\n@@ -514,54 +528,49 @@ fn ty_known_to_outlive<'tcx>(\n     ty: Ty<'tcx>,\n     region: ty::Region<'tcx>,\n ) -> bool {\n-    // Unfortunately, we have to use a new `InferCtxt` each call, because\n-    // region constraints get added and solved there and we need to test each\n-    // call individually.\n-    tcx.infer_ctxt().enter(|infcx| {\n-        let mut outlives_environment = OutlivesEnvironment::new(param_env);\n-        outlives_environment.add_implied_bounds(&infcx, wf_tys.clone(), id, DUMMY_SP);\n-        outlives_environment.save_implied_bounds(id);\n-        let region_bound_pairs = outlives_environment.region_bound_pairs_map().get(&id).unwrap();\n-\n-        let cause = ObligationCause::new(DUMMY_SP, id, ObligationCauseCode::MiscObligation);\n-\n-        let sup_type = ty;\n-        let sub_region = region;\n-\n-        let origin = SubregionOrigin::from_obligation_cause(&cause, || {\n-            infer::RelateParamBound(cause.span, sup_type, None)\n-        });\n-\n+    resolve_regions_with_wf_tys(tcx, id, param_env, &wf_tys, |infcx, region_bound_pairs| {\n+        let origin = infer::RelateParamBound(DUMMY_SP, ty, None);\n         let outlives = &mut TypeOutlives::new(\n-            &infcx,\n+            infcx,\n             tcx,\n-            &region_bound_pairs,\n+            region_bound_pairs,\n             Some(infcx.tcx.lifetimes.re_root_empty),\n             param_env,\n         );\n-        outlives.type_must_outlive(origin, sup_type, sub_region);\n-\n-        let errors = infcx.resolve_regions(\n-            id.expect_owner().to_def_id(),\n-            &outlives_environment,\n-            RegionckMode::default(),\n-        );\n-\n-        debug!(?errors, \"errors\");\n-\n-        // If we were able to prove that the type outlives the region without\n-        // an error, it must be because of the implied or explicit bounds...\n-        errors.is_empty()\n+        outlives.type_must_outlive(origin, ty, region);\n     })\n }\n \n+/// Given a known `param_env` and a set of well formed types, can we prove that\n+/// `region_a` outlives `region_b`\n fn region_known_to_outlive<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     id: hir::HirId,\n     param_env: ty::ParamEnv<'tcx>,\n     wf_tys: &FxHashSet<Ty<'tcx>>,\n     region_a: ty::Region<'tcx>,\n     region_b: ty::Region<'tcx>,\n+) -> bool {\n+    resolve_regions_with_wf_tys(tcx, id, param_env, &wf_tys, |mut infcx, _| {\n+        use rustc_infer::infer::outlives::obligations::TypeOutlivesDelegate;\n+        let origin = infer::RelateRegionParamBound(DUMMY_SP);\n+        // `region_a: region_b` -> `region_b <= region_a`\n+        infcx.push_sub_region_constraint(origin, region_b, region_a);\n+    })\n+}\n+\n+/// Given a known `param_env` and a set of well formed types, set up an\n+/// `InferCtxt`, call the passed function (to e.g. set up region constraints\n+/// to be tested), then resolve region and return errors\n+fn resolve_regions_with_wf_tys<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    id: hir::HirId,\n+    param_env: ty::ParamEnv<'tcx>,\n+    wf_tys: &FxHashSet<Ty<'tcx>>,\n+    add_constraints: impl for<'a> FnOnce(\n+        &'a InferCtxt<'a, 'tcx>,\n+        &'a Vec<(&'tcx ty::RegionKind, GenericKind<'tcx>)>,\n+    ),\n ) -> bool {\n     // Unfortunately, we have to use a new `InferCtxt` each call, because\n     // region constraints get added and solved there and we need to test each\n@@ -570,16 +579,9 @@ fn region_known_to_outlive<'tcx>(\n         let mut outlives_environment = OutlivesEnvironment::new(param_env);\n         outlives_environment.add_implied_bounds(&infcx, wf_tys.clone(), id, DUMMY_SP);\n         outlives_environment.save_implied_bounds(id);\n+        let region_bound_pairs = outlives_environment.region_bound_pairs_map().get(&id).unwrap();\n \n-        let cause = ObligationCause::new(DUMMY_SP, id, ObligationCauseCode::MiscObligation);\n-\n-        let origin = SubregionOrigin::from_obligation_cause(&cause, || {\n-            infer::RelateRegionParamBound(cause.span)\n-        });\n-\n-        use rustc_infer::infer::outlives::obligations::TypeOutlivesDelegate;\n-        // `region_a: region_b` -> `region_b <= region_a`\n-        (&infcx).push_sub_region_constraint(origin, region_b, region_a);\n+        add_constraints(&infcx, region_bound_pairs);\n \n         let errors = infcx.resolve_regions(\n             id.expect_owner().to_def_id(),"}, {"sha": "fcc53b4ede0cb65ceacc59a96c18bcdfdf0214d8", "filename": "src/test/ui/generic-associated-types/self-outlives-lint.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cd93be0094a135c55533cb0eba342e5aa1324f00/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd93be0094a135c55533cb0eba342e5aa1324f00/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.rs?ref=cd93be0094a135c55533cb0eba342e5aa1324f00", "patch": "@@ -189,4 +189,17 @@ trait Trait: 'static {\n     fn make_assoc(_: &u32) -> Self::Assoc<'_>;\n }\n \n+// We ignore `'static` lifetimes for any lints\n+trait StaticReturn<'a> {\n+    type Y<'b>;\n+    fn foo(&self) -> Self::Y<'static>;\n+}\n+\n+// Same as above, but with extra method that takes GAT - just make sure this works\n+trait StaticReturnAndTakes<'a> {\n+    type Y<'b>;\n+    fn foo(&self) -> Self::Y<'static>;\n+    fn bar<'b>(&self, arg: Self::Y<'b>);\n+}\n+\n fn main() {}"}]}