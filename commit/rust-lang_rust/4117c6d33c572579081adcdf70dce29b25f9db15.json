{"sha": "4117c6d33c572579081adcdf70dce29b25f9db15", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxMTdjNmQzM2M1NzI1NzkwODFhZGNkZjcwZGNlMjliMjVmOWRiMTU=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-05-16T21:31:07Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-05-16T21:31:07Z"}, "message": "Move some parser recovery methods to diagnostics", "tree": {"sha": "00c112e3589186f12c804b3edc4c10a03ca1cda8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00c112e3589186f12c804b3edc4c10a03ca1cda8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4117c6d33c572579081adcdf70dce29b25f9db15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4117c6d33c572579081adcdf70dce29b25f9db15", "html_url": "https://github.com/rust-lang/rust/commit/4117c6d33c572579081adcdf70dce29b25f9db15", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4117c6d33c572579081adcdf70dce29b25f9db15/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27a2881402f703b28d81d3001edeb28e18f7f4dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/27a2881402f703b28d81d3001edeb28e18f7f4dd", "html_url": "https://github.com/rust-lang/rust/commit/27a2881402f703b28d81d3001edeb28e18f7f4dd"}], "stats": {"total": 534, "additions": 271, "deletions": 263}, "files": [{"sha": "ab5f87fa7ca6eb69540cc6fca3823fcaba4f3e60", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 266, "deletions": 2, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/4117c6d33c572579081adcdf70dce29b25f9db15/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4117c6d33c572579081adcdf70dce29b25f9db15/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=4117c6d33c572579081adcdf70dce29b25f9db15", "patch": "@@ -1,14 +1,16 @@\n use crate::ast;\n use crate::ast::{BlockCheckMode, Expr, ExprKind, Item, ItemKind, Pat, PatKind, QSelf, Ty, TyKind};\n-use crate::parse::parser::PathStyle;\n+use crate::parse::parser::{BlockMode, PathStyle, TokenType, SemiColonMode};\n use crate::parse::token;\n use crate::parse::PResult;\n use crate::parse::Parser;\n use crate::print::pprust;\n use crate::ptr::P;\n+use crate::symbol::keywords;\n use crate::ThinVec;\n-use errors::Applicability;\n+use errors::{Applicability, DiagnosticBuilder};\n use syntax_pos::Span;\n+use log::debug;\n \n pub trait RecoverQPath: Sized + 'static {\n     const PATH_STYLE: PathStyle = PathStyle::Expr;\n@@ -261,4 +263,266 @@ impl<'a> Parser<'a> {\n             .emit();\n         Ok((sp, ExprKind::Await(ast::AwaitOrigin::FieldLike, expr)))\n     }\n+\n+    /// If encountering `future.await()`, consume and emit error.\n+    crate fn recover_from_await_method_call(&mut self) {\n+        if self.token == token::OpenDelim(token::Paren) &&\n+            self.look_ahead(1, |t| t == &token::CloseDelim(token::Paren))\n+        {\n+            // future.await()\n+            let lo = self.span;\n+            self.bump(); // (\n+            let sp = lo.to(self.span);\n+            self.bump(); // )\n+            let mut err = self.struct_span_err(sp, \"incorrect use of `await`\");\n+            err.span_suggestion(\n+                sp,\n+                \"`await` is not a method call, remove the parentheses\",\n+                String::new(),\n+                Applicability::MachineApplicable,\n+            );\n+            err.emit()\n+        }\n+    }\n+\n+    crate fn could_ascription_be_path(&self, node: &ast::ExprKind) -> bool {\n+        self.token.is_ident() &&\n+            if let ast::ExprKind::Path(..) = node { true } else { false } &&\n+            !self.token.is_reserved_ident() &&           // v `foo:bar(baz)`\n+            self.look_ahead(1, |t| t == &token::OpenDelim(token::Paren)) ||\n+            self.look_ahead(1, |t| t == &token::Lt) &&     // `foo:bar<baz`\n+            self.look_ahead(2, |t| t.is_ident()) ||\n+            self.look_ahead(1, |t| t == &token::Colon) &&  // `foo:bar:baz`\n+            self.look_ahead(2, |t| t.is_ident()) ||\n+            self.look_ahead(1, |t| t == &token::ModSep) &&  // `foo:bar::baz`\n+            self.look_ahead(2, |t| t.is_ident())\n+    }\n+\n+    crate fn bad_type_ascription(\n+        &self,\n+        err: &mut DiagnosticBuilder<'a>,\n+        lhs_span: Span,\n+        cur_op_span: Span,\n+        next_sp: Span,\n+        maybe_path: bool,\n+    ) {\n+        err.span_label(self.span, \"expecting a type here because of type ascription\");\n+        let cm = self.sess.source_map();\n+        let next_pos = cm.lookup_char_pos(next_sp.lo());\n+        let op_pos = cm.lookup_char_pos(cur_op_span.hi());\n+        if op_pos.line != next_pos.line {\n+            err.span_suggestion(\n+                cur_op_span,\n+                \"try using a semicolon\",\n+                \";\".to_string(),\n+                Applicability::MaybeIncorrect,\n+            );\n+        } else {\n+            if maybe_path {\n+                err.span_suggestion(\n+                    cur_op_span,\n+                    \"maybe you meant to write a path separator here\",\n+                    \"::\".to_string(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            } else {\n+                err.note(\"type ascription is a nightly-only feature that lets \\\n+                          you annotate an expression with a type: `<expr>: <type>`\");\n+                err.span_note(\n+                    lhs_span,\n+                    \"this expression expects an ascribed type after the colon\",\n+                );\n+                err.help(\"this might be indicative of a syntax error elsewhere\");\n+            }\n+        }\n+    }\n+\n+    crate fn recover_seq_parse_error(\n+        &mut self,\n+        delim: token::DelimToken,\n+        lo: Span,\n+        result: PResult<'a, P<Expr>>,\n+    ) -> P<Expr> {\n+        match result {\n+            Ok(x) => x,\n+            Err(mut err) => {\n+                err.emit();\n+                // recover from parse error\n+                self.consume_block(delim);\n+                self.mk_expr(lo.to(self.prev_span), ExprKind::Err, ThinVec::new())\n+            }\n+        }\n+    }\n+\n+    crate fn recover_closing_delimiter(\n+        &mut self,\n+        tokens: &[token::Token],\n+        mut err: DiagnosticBuilder<'a>,\n+    ) -> PResult<'a, bool> {\n+        let mut pos = None;\n+        // we want to use the last closing delim that would apply\n+        for (i, unmatched) in self.unclosed_delims.iter().enumerate().rev() {\n+            if tokens.contains(&token::CloseDelim(unmatched.expected_delim))\n+                && Some(self.span) > unmatched.unclosed_span\n+            {\n+                pos = Some(i);\n+            }\n+        }\n+        match pos {\n+            Some(pos) => {\n+                // Recover and assume that the detected unclosed delimiter was meant for\n+                // this location. Emit the diagnostic and act as if the delimiter was\n+                // present for the parser's sake.\n+\n+                 // Don't attempt to recover from this unclosed delimiter more than once.\n+                let unmatched = self.unclosed_delims.remove(pos);\n+                let delim = TokenType::Token(token::CloseDelim(unmatched.expected_delim));\n+\n+                 // We want to suggest the inclusion of the closing delimiter where it makes\n+                // the most sense, which is immediately after the last token:\n+                //\n+                //  {foo(bar {}}\n+                //      -      ^\n+                //      |      |\n+                //      |      help: `)` may belong here (FIXME: #58270)\n+                //      |\n+                //      unclosed delimiter\n+                if let Some(sp) = unmatched.unclosed_span {\n+                    err.span_label(sp, \"unclosed delimiter\");\n+                }\n+                err.span_suggestion_short(\n+                    self.sess.source_map().next_point(self.prev_span),\n+                    &format!(\"{} may belong here\", delim.to_string()),\n+                    delim.to_string(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+                err.emit();\n+                self.expected_tokens.clear();  // reduce errors\n+                Ok(true)\n+            }\n+            _ => Err(err),\n+        }\n+    }\n+\n+    /// Recover from `pub` keyword in places where it seems _reasonable_ but isn't valid.\n+    crate fn eat_bad_pub(&mut self) {\n+        if self.token.is_keyword(keywords::Pub) {\n+            match self.parse_visibility(false) {\n+                Ok(vis) => {\n+                    let mut err = self.diagnostic()\n+                        .struct_span_err(vis.span, \"unnecessary visibility qualifier\");\n+                    err.span_label(vis.span, \"`pub` not permitted here\");\n+                    err.emit();\n+                }\n+                Err(mut err) => err.emit(),\n+            }\n+        }\n+    }\n+\n+    // Eat tokens until we can be relatively sure we reached the end of the\n+    // statement. This is something of a best-effort heuristic.\n+    //\n+    // We terminate when we find an unmatched `}` (without consuming it).\n+    crate fn recover_stmt(&mut self) {\n+        self.recover_stmt_(SemiColonMode::Ignore, BlockMode::Ignore)\n+    }\n+\n+    // If `break_on_semi` is `Break`, then we will stop consuming tokens after\n+    // finding (and consuming) a `;` outside of `{}` or `[]` (note that this is\n+    // approximate - it can mean we break too early due to macros, but that\n+    // should only lead to sub-optimal recovery, not inaccurate parsing).\n+    //\n+    // If `break_on_block` is `Break`, then we will stop consuming tokens\n+    // after finding (and consuming) a brace-delimited block.\n+    crate fn recover_stmt_(&mut self, break_on_semi: SemiColonMode, break_on_block: BlockMode) {\n+        let mut brace_depth = 0;\n+        let mut bracket_depth = 0;\n+        let mut in_block = false;\n+        debug!(\"recover_stmt_ enter loop (semi={:?}, block={:?})\",\n+               break_on_semi, break_on_block);\n+        loop {\n+            debug!(\"recover_stmt_ loop {:?}\", self.token);\n+            match self.token {\n+                token::OpenDelim(token::DelimToken::Brace) => {\n+                    brace_depth += 1;\n+                    self.bump();\n+                    if break_on_block == BlockMode::Break &&\n+                       brace_depth == 1 &&\n+                       bracket_depth == 0 {\n+                        in_block = true;\n+                    }\n+                }\n+                token::OpenDelim(token::DelimToken::Bracket) => {\n+                    bracket_depth += 1;\n+                    self.bump();\n+                }\n+                token::CloseDelim(token::DelimToken::Brace) => {\n+                    if brace_depth == 0 {\n+                        debug!(\"recover_stmt_ return - close delim {:?}\", self.token);\n+                        break;\n+                    }\n+                    brace_depth -= 1;\n+                    self.bump();\n+                    if in_block && bracket_depth == 0 && brace_depth == 0 {\n+                        debug!(\"recover_stmt_ return - block end {:?}\", self.token);\n+                        break;\n+                    }\n+                }\n+                token::CloseDelim(token::DelimToken::Bracket) => {\n+                    bracket_depth -= 1;\n+                    if bracket_depth < 0 {\n+                        bracket_depth = 0;\n+                    }\n+                    self.bump();\n+                }\n+                token::Eof => {\n+                    debug!(\"recover_stmt_ return - Eof\");\n+                    break;\n+                }\n+                token::Semi => {\n+                    self.bump();\n+                    if break_on_semi == SemiColonMode::Break &&\n+                       brace_depth == 0 &&\n+                       bracket_depth == 0 {\n+                        debug!(\"recover_stmt_ return - Semi\");\n+                        break;\n+                    }\n+                }\n+                token::Comma => {\n+                    if break_on_semi == SemiColonMode::Comma &&\n+                       brace_depth == 0 &&\n+                       bracket_depth == 0 {\n+                        debug!(\"recover_stmt_ return - Semi\");\n+                        break;\n+                    } else {\n+                        self.bump();\n+                    }\n+                }\n+                _ => {\n+                    self.bump()\n+                }\n+            }\n+        }\n+    }\n+\n+    crate fn consume_block(&mut self, delim: token::DelimToken) {\n+        let mut brace_depth = 0;\n+        loop {\n+            if self.eat(&token::OpenDelim(delim)) {\n+                brace_depth += 1;\n+            } else if self.eat(&token::CloseDelim(delim)) {\n+                if brace_depth == 0 {\n+                    return;\n+                } else {\n+                    brace_depth -= 1;\n+                    continue;\n+                }\n+            } else if self.token == token::Eof || self.eat(&token::CloseDelim(token::NoDelim)) {\n+                return;\n+            } else {\n+                self.bump();\n+            }\n+        }\n+    }\n+\n }"}, {"sha": "b1c3e46adc0ecbe8d0271c7729a178bef3ba0518", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 5, "deletions": 261, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/4117c6d33c572579081adcdf70dce29b25f9db15/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4117c6d33c572579081adcdf70dce29b25f9db15/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=4117c6d33c572579081adcdf70dce29b25f9db15", "patch": "@@ -104,14 +104,14 @@ pub enum PathStyle {\n }\n \n #[derive(Clone, Copy, PartialEq, Debug)]\n-enum SemiColonMode {\n+crate enum SemiColonMode {\n     Break,\n     Ignore,\n     Comma,\n }\n \n #[derive(Clone, Copy, PartialEq, Debug)]\n-enum BlockMode {\n+crate enum BlockMode {\n     Break,\n     Ignore,\n }\n@@ -389,7 +389,7 @@ crate enum TokenType {\n }\n \n impl TokenType {\n-    fn to_string(&self) -> String {\n+    crate fn to_string(&self) -> String {\n         match *self {\n             TokenType::Token(ref t) => format!(\"`{}`\", pprust::token_to_string(t)),\n             TokenType::Keyword(kw) => format!(\"`{}`\", kw.name()),\n@@ -673,56 +673,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn recover_closing_delimiter(\n-        &mut self,\n-        tokens: &[token::Token],\n-        mut err: DiagnosticBuilder<'a>,\n-    ) -> PResult<'a, bool> {\n-        let mut pos = None;\n-        // we want to use the last closing delim that would apply\n-        for (i, unmatched) in self.unclosed_delims.iter().enumerate().rev() {\n-            if tokens.contains(&token::CloseDelim(unmatched.expected_delim))\n-                && Some(self.span) > unmatched.unclosed_span\n-            {\n-                pos = Some(i);\n-            }\n-        }\n-        match pos {\n-            Some(pos) => {\n-                // Recover and assume that the detected unclosed delimiter was meant for\n-                // this location. Emit the diagnostic and act as if the delimiter was\n-                // present for the parser's sake.\n-\n-                 // Don't attempt to recover from this unclosed delimiter more than once.\n-                let unmatched = self.unclosed_delims.remove(pos);\n-                let delim = TokenType::Token(token::CloseDelim(unmatched.expected_delim));\n-\n-                 // We want to suggest the inclusion of the closing delimiter where it makes\n-                // the most sense, which is immediately after the last token:\n-                //\n-                //  {foo(bar {}}\n-                //      -      ^\n-                //      |      |\n-                //      |      help: `)` may belong here (FIXME: #58270)\n-                //      |\n-                //      unclosed delimiter\n-                if let Some(sp) = unmatched.unclosed_span {\n-                    err.span_label(sp, \"unclosed delimiter\");\n-                }\n-                err.span_suggestion_short(\n-                    self.sess.source_map().next_point(self.prev_span),\n-                    &format!(\"{} may belong here\", delim.to_string()),\n-                    delim.to_string(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-                err.emit();\n-                self.expected_tokens.clear();  // reduce errors\n-                Ok(true)\n-            }\n-            _ => Err(err),\n-        }\n-    }\n-\n     /// Expect next token to be edible or inedible token.  If edible,\n     /// then consume it; if inedible, then return without consuming\n     /// anything.  Signal a fatal error if next token is unexpected.\n@@ -2343,7 +2293,7 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    fn mk_expr(&self, span: Span, node: ExprKind, attrs: ThinVec<Attribute>) -> P<Expr> {\n+    crate fn mk_expr(&self, span: Span, node: ExprKind, attrs: ThinVec<Attribute>) -> P<Expr> {\n         P(Expr { node, span, attrs, id: ast::DUMMY_NODE_ID })\n     }\n \n@@ -2936,23 +2886,7 @@ impl<'a> Parser<'a> {\n                 ExprKind::Await(ast::AwaitOrigin::FieldLike, self_arg),\n                 ThinVec::new(),\n             );\n-            if self.token == token::OpenDelim(token::Paren) &&\n-                self.look_ahead(1, |t| t == &token::CloseDelim(token::Paren))\n-            {\n-                // future.await()\n-                let lo = self.span;\n-                self.bump(); // (\n-                let sp = lo.to(self.span);\n-                self.bump(); // )\n-                let mut err = self.struct_span_err(sp, \"incorrect use of `await`\");\n-                err.span_suggestion(\n-                    sp,\n-                    \"`await` is not a method call, remove the parentheses\",\n-                    String::new(),\n-                    Applicability::MachineApplicable,\n-                );\n-                err.emit()\n-            }\n+            self.recover_from_await_method_call();\n             return Ok(await_expr);\n         }\n         let segment = self.parse_path_segment(PathStyle::Expr)?;\n@@ -3191,23 +3125,6 @@ impl<'a> Parser<'a> {\n         return Ok(e);\n     }\n \n-    fn recover_seq_parse_error(\n-        &mut self,\n-        delim: token::DelimToken,\n-        lo: Span,\n-        result: PResult<'a, P<Expr>>,\n-    ) -> P<Expr> {\n-        match result {\n-            Ok(x) => x,\n-            Err(mut err) => {\n-                err.emit();\n-                // recover from parse error\n-                self.consume_block(delim);\n-                self.mk_expr(lo.to(self.prev_span), ExprKind::Err, ThinVec::new())\n-            }\n-        }\n-    }\n-\n     crate fn process_potential_macro_variable(&mut self) {\n         let (token, span) = match self.token {\n             token::Dollar if self.span.ctxt() != syntax_pos::hygiene::SyntaxContext::empty() &&\n@@ -3610,58 +3527,6 @@ impl<'a> Parser<'a> {\n         Ok(lhs)\n     }\n \n-    fn could_ascription_be_path(&self, node: &ast::ExprKind) -> bool {\n-        self.token.is_ident() &&\n-            if let ast::ExprKind::Path(..) = node { true } else { false } &&\n-            !self.token.is_reserved_ident() &&           // v `foo:bar(baz)`\n-            self.look_ahead(1, |t| t == &token::OpenDelim(token::Paren)) ||\n-            self.look_ahead(1, |t| t == &token::Lt) &&     // `foo:bar<baz`\n-            self.look_ahead(2, |t| t.is_ident()) ||\n-            self.look_ahead(1, |t| t == &token::Colon) &&  // `foo:bar:baz`\n-            self.look_ahead(2, |t| t.is_ident()) ||\n-            self.look_ahead(1, |t| t == &token::ModSep) &&  // `foo:bar::baz`\n-            self.look_ahead(2, |t| t.is_ident())\n-    }\n-\n-    fn bad_type_ascription(\n-        &self,\n-        err: &mut DiagnosticBuilder<'a>,\n-        lhs_span: Span,\n-        cur_op_span: Span,\n-        next_sp: Span,\n-        maybe_path: bool,\n-    ) {\n-        err.span_label(self.span, \"expecting a type here because of type ascription\");\n-        let cm = self.sess.source_map();\n-        let next_pos = cm.lookup_char_pos(next_sp.lo());\n-        let op_pos = cm.lookup_char_pos(cur_op_span.hi());\n-        if op_pos.line != next_pos.line {\n-            err.span_suggestion(\n-                cur_op_span,\n-                \"try using a semicolon\",\n-                \";\".to_string(),\n-                Applicability::MaybeIncorrect,\n-            );\n-        } else {\n-            if maybe_path {\n-                err.span_suggestion(\n-                    cur_op_span,\n-                    \"maybe you meant to write a path separator here\",\n-                    \"::\".to_string(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-            } else {\n-                err.note(\"type ascription is a nightly-only feature that lets \\\n-                          you annotate an expression with a type: `<expr>: <type>`\");\n-                err.span_note(\n-                    lhs_span,\n-                    \"this expression expects an ascribed type after the colon\",\n-                );\n-                err.help(\"this might be indicative of a syntax error elsewhere\");\n-            }\n-        }\n-    }\n-\n     fn parse_assoc_op_cast(&mut self, lhs: P<Expr>, lhs_span: Span,\n                            expr_kind: fn(P<Expr>, P<Ty>) -> ExprKind)\n                            -> PResult<'a, P<Expr>> {\n@@ -4943,92 +4808,6 @@ impl<'a> Parser<'a> {\n         Ok(self.parse_stmt_(true))\n     }\n \n-    // Eat tokens until we can be relatively sure we reached the end of the\n-    // statement. This is something of a best-effort heuristic.\n-    //\n-    // We terminate when we find an unmatched `}` (without consuming it).\n-    fn recover_stmt(&mut self) {\n-        self.recover_stmt_(SemiColonMode::Ignore, BlockMode::Ignore)\n-    }\n-\n-    // If `break_on_semi` is `Break`, then we will stop consuming tokens after\n-    // finding (and consuming) a `;` outside of `{}` or `[]` (note that this is\n-    // approximate - it can mean we break too early due to macros, but that\n-    // should only lead to sub-optimal recovery, not inaccurate parsing).\n-    //\n-    // If `break_on_block` is `Break`, then we will stop consuming tokens\n-    // after finding (and consuming) a brace-delimited block.\n-    fn recover_stmt_(&mut self, break_on_semi: SemiColonMode, break_on_block: BlockMode) {\n-        let mut brace_depth = 0;\n-        let mut bracket_depth = 0;\n-        let mut in_block = false;\n-        debug!(\"recover_stmt_ enter loop (semi={:?}, block={:?})\",\n-               break_on_semi, break_on_block);\n-        loop {\n-            debug!(\"recover_stmt_ loop {:?}\", self.token);\n-            match self.token {\n-                token::OpenDelim(token::DelimToken::Brace) => {\n-                    brace_depth += 1;\n-                    self.bump();\n-                    if break_on_block == BlockMode::Break &&\n-                       brace_depth == 1 &&\n-                       bracket_depth == 0 {\n-                        in_block = true;\n-                    }\n-                }\n-                token::OpenDelim(token::DelimToken::Bracket) => {\n-                    bracket_depth += 1;\n-                    self.bump();\n-                }\n-                token::CloseDelim(token::DelimToken::Brace) => {\n-                    if brace_depth == 0 {\n-                        debug!(\"recover_stmt_ return - close delim {:?}\", self.token);\n-                        break;\n-                    }\n-                    brace_depth -= 1;\n-                    self.bump();\n-                    if in_block && bracket_depth == 0 && brace_depth == 0 {\n-                        debug!(\"recover_stmt_ return - block end {:?}\", self.token);\n-                        break;\n-                    }\n-                }\n-                token::CloseDelim(token::DelimToken::Bracket) => {\n-                    bracket_depth -= 1;\n-                    if bracket_depth < 0 {\n-                        bracket_depth = 0;\n-                    }\n-                    self.bump();\n-                }\n-                token::Eof => {\n-                    debug!(\"recover_stmt_ return - Eof\");\n-                    break;\n-                }\n-                token::Semi => {\n-                    self.bump();\n-                    if break_on_semi == SemiColonMode::Break &&\n-                       brace_depth == 0 &&\n-                       bracket_depth == 0 {\n-                        debug!(\"recover_stmt_ return - Semi\");\n-                        break;\n-                    }\n-                }\n-                token::Comma => {\n-                    if break_on_semi == SemiColonMode::Comma &&\n-                       brace_depth == 0 &&\n-                       bracket_depth == 0 {\n-                        debug!(\"recover_stmt_ return - Semi\");\n-                        break;\n-                    } else {\n-                        self.bump();\n-                    }\n-                }\n-                _ => {\n-                    self.bump()\n-                }\n-            }\n-        }\n-    }\n-\n     fn parse_stmt_(&mut self, macro_legacy_warnings: bool) -> Option<Stmt> {\n         self.parse_stmt_without_recovery(macro_legacy_warnings).unwrap_or_else(|mut e| {\n             e.emit();\n@@ -6932,26 +6711,6 @@ impl<'a> Parser<'a> {\n         Ok((class_name, ItemKind::Union(vdata, generics), None))\n     }\n \n-    fn consume_block(&mut self, delim: token::DelimToken) {\n-        let mut brace_depth = 0;\n-        loop {\n-            if self.eat(&token::OpenDelim(delim)) {\n-                brace_depth += 1;\n-            } else if self.eat(&token::CloseDelim(delim)) {\n-                if brace_depth == 0 {\n-                    return;\n-                } else {\n-                    brace_depth -= 1;\n-                    continue;\n-                }\n-            } else if self.token == token::Eof || self.eat(&token::CloseDelim(token::NoDelim)) {\n-                return;\n-            } else {\n-                self.bump();\n-            }\n-        }\n-    }\n-\n     fn parse_record_struct_body(\n         &mut self,\n     ) -> PResult<'a, (Vec<StructField>, /* recovered */ bool)> {\n@@ -8649,21 +8408,6 @@ impl<'a> Parser<'a> {\n         ).emit();\n     }\n \n-    /// Recover from `pub` keyword in places where it seems _reasonable_ but isn't valid.\n-    fn eat_bad_pub(&mut self) {\n-        if self.token.is_keyword(keywords::Pub) {\n-            match self.parse_visibility(false) {\n-                Ok(vis) => {\n-                    let mut err = self.diagnostic()\n-                        .struct_span_err(vis.span, \"unnecessary visibility qualifier\");\n-                    err.span_label(vis.span, \"`pub` not permitted here\");\n-                    err.emit();\n-                }\n-                Err(mut err) => err.emit(),\n-            }\n-        }\n-    }\n-\n     /// When lowering a `async fn` to the HIR, we need to move all of the arguments of the function\n     /// into the generated closure so that they are dropped when the future is polled and not when\n     /// it is created."}]}