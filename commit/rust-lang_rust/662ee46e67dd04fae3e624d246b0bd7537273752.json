{"sha": "662ee46e67dd04fae3e624d246b0bd7537273752", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2MmVlNDZlNjdkZDA0ZmFlM2U2MjRkMjQ2YjBiZDc1MzcyNzM3NTI=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-09-06T09:47:50Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-09-06T09:47:50Z"}, "message": "Use write_list() to format imports", "tree": {"sha": "f20b4c374bd8b4f06e9037a95fc4f1786759d94a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f20b4c374bd8b4f06e9037a95fc4f1786759d94a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/662ee46e67dd04fae3e624d246b0bd7537273752", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/662ee46e67dd04fae3e624d246b0bd7537273752", "html_url": "https://github.com/rust-lang/rust/commit/662ee46e67dd04fae3e624d246b0bd7537273752", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/662ee46e67dd04fae3e624d246b0bd7537273752/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af404b998c87bb28ffb0a36a2f779a7d8371a0d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/af404b998c87bb28ffb0a36a2f779a7d8371a0d1", "html_url": "https://github.com/rust-lang/rust/commit/af404b998c87bb28ffb0a36a2f779a7d8371a0d1"}], "stats": {"total": 196, "additions": 107, "deletions": 89}, "files": [{"sha": "7cfe5d8b6b9808f0b3e2e1122f4ef36caa93a3cd", "filename": "src/imports.rs", "status": "modified", "additions": 106, "deletions": 86, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/662ee46e67dd04fae3e624d246b0bd7537273752/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662ee46e67dd04fae3e624d246b0bd7537273752/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=662ee46e67dd04fae3e624d246b0bd7537273752", "patch": "@@ -8,20 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cmp::{self, Ordering};\n+use std::cmp::Ordering;\n \n use syntax::{ast, ptr};\n use syntax::codemap::{BytePos, Span};\n \n-use Shape;\n+use {Shape, Spanned};\n use codemap::SpanUtils;\n+use comment::combine_strs_with_missing_comments;\n use config::IndentStyle;\n use lists::{definitive_tactic, itemize_list, write_list, DefinitiveListTactic, ListFormatting,\n             ListItem, Separator, SeparatorPlace, SeparatorTactic};\n use rewrite::{Rewrite, RewriteContext};\n use types::{rewrite_path, PathContext};\n-use utils;\n-use visitor::FmtVisitor;\n+use utils::{format_visibility, mk_sp};\n+use visitor::{rewrite_extern_crate, FmtVisitor};\n \n fn path_of(a: &ast::ViewPath_) -> &ast::Path {\n     match *a {\n@@ -185,95 +186,115 @@ impl Rewrite for ast::ViewPath {\n     }\n }\n \n-impl<'a> FmtVisitor<'a> {\n-    pub fn format_imports(&mut self, use_items: &[ptr::P<ast::Item>]) {\n-        // Find the location immediately before the first use item in the run. This must not lie\n-        // before the current `self.last_pos`\n-        let pos_before_first_use_item = use_items\n-            .first()\n-            .map(|p_i| {\n-                cmp::max(\n-                    self.last_pos,\n-                    p_i.attrs\n-                        .iter()\n-                        .map(|attr| attr.span.lo())\n-                        .min()\n-                        .unwrap_or(p_i.span.lo()),\n-                )\n-            })\n-            .unwrap_or(self.last_pos);\n-        // Construct a list of pairs, each containing a `use` item and the start of span before\n-        // that `use` item.\n-        let mut last_pos_of_prev_use_item = pos_before_first_use_item;\n-        let mut ordered_use_items = use_items\n-            .iter()\n-            .map(|p_i| {\n-                let new_item = (&*p_i, last_pos_of_prev_use_item);\n-                last_pos_of_prev_use_item = p_i.span.hi();\n-                new_item\n-            })\n-            .collect::<Vec<_>>();\n-        let pos_after_last_use_item = last_pos_of_prev_use_item;\n-        // Order the imports by view-path & other import path properties\n-        ordered_use_items.sort_by(|a, b| {\n-            compare_use_items(&self.get_context(), a.0, b.0).unwrap()\n-        });\n-        // First, output the span before the first import\n-        let prev_span_str = self.snippet(utils::mk_sp(self.last_pos, pos_before_first_use_item));\n-        // Look for purely trailing space at the start of the prefix snippet before a linefeed, or\n-        // a prefix that's entirely horizontal whitespace.\n-        let prefix_span_start = match prev_span_str.find('\\n') {\n-            Some(offset) if prev_span_str[..offset].trim().is_empty() => {\n-                self.last_pos + BytePos(offset as u32)\n-            }\n-            None if prev_span_str.trim().is_empty() => pos_before_first_use_item,\n-            _ => self.last_pos,\n-        };\n-        // Look for indent (the line part preceding the use is all whitespace) and excise that\n-        // from the prefix\n-        let span_end = match prev_span_str.rfind('\\n') {\n-            Some(offset) if prev_span_str[offset..].trim().is_empty() => {\n-                self.last_pos + BytePos(offset as u32)\n+// Rewrite `use foo;` WITHOUT attributes.\n+fn rewrite_import(\n+    context: &RewriteContext,\n+    vis: &ast::Visibility,\n+    vp: &ast::ViewPath,\n+    attrs: &[ast::Attribute],\n+    shape: Shape,\n+) -> Option<String> {\n+    let vis = format_visibility(vis);\n+    // 4 = `use `, 1 = `;`\n+    let rw = shape\n+        .offset_left(vis.len() + 4)\n+        .and_then(|shape| shape.sub_width(1))\n+        .and_then(|shape| match vp.node {\n+            // If we have an empty path list with no attributes, we erase it\n+            ast::ViewPath_::ViewPathList(_, ref path_list)\n+                if path_list.is_empty() && attrs.is_empty() =>\n+            {\n+                Some(\"\".into())\n             }\n-            _ => pos_before_first_use_item,\n-        };\n+            _ => vp.rewrite(context, shape),\n+        });\n+    match rw {\n+        Some(ref s) if !s.is_empty() => Some(format!(\"{}use {};\", vis, s)),\n+        _ => rw,\n+    }\n+}\n \n-        self.last_pos = prefix_span_start;\n-        self.format_missing(span_end);\n-        for ordered in ordered_use_items {\n-            // Fake out the formatter by setting `self.last_pos` to the appropriate location before\n-            // each item before visiting it.\n-            self.last_pos = ordered.1;\n-            self.visit_item(ordered.0);\n+fn rewrite_imports(\n+    context: &RewriteContext,\n+    use_items: &[ptr::P<ast::Item>],\n+    shape: Shape,\n+    span: Span,\n+) -> Option<String> {\n+    let items = itemize_list(\n+        context.codemap,\n+        use_items.iter(),\n+        \"\",\n+        |item| item.span().lo(),\n+        |item| item.span().hi(),\n+        |item| {\n+            let attrs_str = try_opt!(item.attrs.rewrite(context, shape));\n+\n+            let missed_span = if item.attrs.is_empty() {\n+                mk_sp(item.span.lo(), item.span.lo())\n+            } else {\n+                mk_sp(item.attrs.last().unwrap().span.hi(), item.span.lo())\n+            };\n+\n+            let item_str = match item.node {\n+                ast::ItemKind::Use(ref vp) => {\n+                    try_opt!(rewrite_import(context, &item.vis, vp, &item.attrs, shape))\n+                }\n+                ast::ItemKind::ExternCrate(..) => try_opt!(rewrite_extern_crate(context, item)),\n+                _ => return None,\n+            };\n+\n+            combine_strs_with_missing_comments(\n+                context,\n+                &attrs_str,\n+                &item_str,\n+                missed_span,\n+                shape,\n+                false,\n+            )\n+        },\n+        span.lo(),\n+        span.hi(),\n+        false,\n+    );\n+    let mut item_pair_vec: Vec<_> = items.zip(use_items.iter()).collect();\n+    item_pair_vec.sort_by(|a, b| compare_use_items(context, a.1, b.1).unwrap());\n+    let item_vec: Vec<_> = item_pair_vec.into_iter().map(|pair| pair.0).collect();\n+\n+    let fmt = ListFormatting {\n+        tactic: DefinitiveListTactic::Vertical,\n+        separator: \"\",\n+        trailing_separator: SeparatorTactic::Never,\n+        separator_place: SeparatorPlace::Back,\n+        shape: shape,\n+        ends_with_newline: true,\n+        preserve_newline: false,\n+        config: context.config,\n+    };\n+\n+    write_list(&item_vec, &fmt)\n+}\n+\n+impl<'a> FmtVisitor<'a> {\n+    pub fn format_imports(&mut self, use_items: &[ptr::P<ast::Item>]) {\n+        if use_items.is_empty() {\n+            return;\n         }\n-        self.last_pos = pos_after_last_use_item;\n+\n+        let lo = use_items.first().unwrap().span().lo();\n+        let hi = use_items.last().unwrap().span().hi();\n+        let span = mk_sp(lo, hi);\n+        let rw = rewrite_imports(&self.get_context(), use_items, self.shape(), span);\n+        self.push_rewrite(span, rw);\n     }\n \n-    pub fn format_import(\n-        &mut self,\n-        vis: &ast::Visibility,\n-        vp: &ast::ViewPath,\n-        span: Span,\n-        attrs: &[ast::Attribute],\n-    ) {\n-        let vis = utils::format_visibility(vis);\n-        // 4 = `use `, 1 = `;`\n-        let rw = self.shape()\n-            .offset_left(vis.len() + 4)\n-            .and_then(|shape| shape.sub_width(1))\n-            .and_then(|shape| match vp.node {\n-                // If we have an empty path list with no attributes, we erase it\n-                ast::ViewPath_::ViewPathList(_, ref path_list)\n-                    if path_list.is_empty() && attrs.is_empty() =>\n-                {\n-                    Some(\"\".into())\n-                }\n-                _ => vp.rewrite(&self.get_context(), shape),\n-            });\n+    pub fn format_import(&mut self, item: &ast::Item, vp: &ast::ViewPath) {\n+        let span = item.span;\n+        let shape = self.shape();\n+        let rw = rewrite_import(&self.get_context(), &item.vis, vp, &item.attrs, shape);\n         match rw {\n             Some(ref s) if s.is_empty() => {\n                 // Format up to last newline\n-                let prev_span = utils::mk_sp(self.last_pos, source!(self, span).lo());\n+                let prev_span = mk_sp(self.last_pos, source!(self, span).lo());\n                 let span_end = match self.snippet(prev_span).rfind('\\n') {\n                     Some(offset) => self.last_pos + BytePos(offset as u32),\n                     None => source!(self, span).lo(),\n@@ -282,7 +303,6 @@ impl<'a> FmtVisitor<'a> {\n                 self.last_pos = source!(self, span).hi();\n             }\n             Some(ref s) => {\n-                let s = format!(\"{}use {};\", vis, s);\n                 self.format_missing_with_indent(source!(self, span).lo());\n                 self.buffer.push_str(&s);\n                 self.last_pos = source!(self, span).hi();"}, {"sha": "76f6e4914e20d55dbdba7f19939f7e8b0b6ab66b", "filename": "src/visitor.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/662ee46e67dd04fae3e624d246b0bd7537273752/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662ee46e67dd04fae3e624d246b0bd7537273752/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=662ee46e67dd04fae3e624d246b0bd7537273752", "patch": "@@ -342,9 +342,7 @@ impl<'a> FmtVisitor<'a> {\n         }\n \n         match item.node {\n-            ast::ItemKind::Use(ref vp) => {\n-                self.format_import(&item.vis, vp, item.span, &item.attrs);\n-            }\n+            ast::ItemKind::Use(ref vp) => self.format_import(&item, vp),\n             ast::ItemKind::Impl(..) => {\n                 self.format_missing_with_indent(source!(self, item.span).lo());\n                 let snippet = self.snippet(item.span);"}]}