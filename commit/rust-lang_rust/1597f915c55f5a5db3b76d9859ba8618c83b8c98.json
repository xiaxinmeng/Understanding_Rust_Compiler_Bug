{"sha": "1597f915c55f5a5db3b76d9859ba8618c83b8c98", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1OTdmOTE1YzU1ZjVhNWRiM2I3NmQ5ODU5YmE4NjE4YzgzYjhjOTg=", "commit": {"author": {"name": "Keegan McAllister", "email": "mcallister.keegan@gmail.com", "date": "2015-02-19T04:46:21Z"}, "committer": {"name": "Keegan McAllister", "email": "mcallister.keegan@gmail.com", "date": "2015-02-19T04:46:21Z"}, "message": "borrowck/README.md: Normalize types in examples", "tree": {"sha": "328ea7996411d9dfc5b4222697c863b5ae68738b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/328ea7996411d9dfc5b4222697c863b5ae68738b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1597f915c55f5a5db3b76d9859ba8618c83b8c98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1597f915c55f5a5db3b76d9859ba8618c83b8c98", "html_url": "https://github.com/rust-lang/rust/commit/1597f915c55f5a5db3b76d9859ba8618c83b8c98", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1597f915c55f5a5db3b76d9859ba8618c83b8c98/comments", "author": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f051e1323807b93fcb0d128a29dcdd0a0349bcf8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f051e1323807b93fcb0d128a29dcdd0a0349bcf8", "html_url": "https://github.com/rust-lang/rust/commit/f051e1323807b93fcb0d128a29dcdd0a0349bcf8"}], "stats": {"total": 74, "additions": 37, "deletions": 37}, "files": [{"sha": "08f0897e7617e918e320dedd16d3ae3201cdd45b", "filename": "src/librustc_borrowck/borrowck/README.md", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/1597f915c55f5a5db3b76d9859ba8618c83b8c98/src%2Flibrustc_borrowck%2Fborrowck%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/1597f915c55f5a5db3b76d9859ba8618c83b8c98/src%2Flibrustc_borrowck%2Fborrowck%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2FREADME.md?ref=1597f915c55f5a5db3b76d9859ba8618c83b8c98", "patch": "@@ -54,7 +54,7 @@ and `*LV` is a pointer dereference. There is no auto-deref or other\n niceties. This means that if you have a type like:\n \n ```rust\n-struct S { f: uint }\n+struct S { f: i32 }\n ```\n \n and a variable `a: Box<S>`, then the rust expression `a.f` would correspond\n@@ -63,7 +63,7 @@ to an `LV` of `(*a).f`.\n Here is the formal grammar for the types we'll consider:\n \n ```text\n-TY = () | S<'LT...> | Box<TY> | & 'LT MQ TY\n+TY = i32 | bool | S<'LT...> | Box<TY> | & 'LT MQ TY\n MQ = mut | imm\n ```\n \n@@ -83,7 +83,7 @@ SD = struct S<'LT...> { (f: TY)... }\n Now, imagine we had a program like this:\n \n ```rust\n-struct Foo { f: uint, g: uint }\n+struct Foo { f: i32, g: i32 }\n ...\n 'a: {\n     let mut x: Box<Foo> = ...;\n@@ -508,7 +508,7 @@ of the `&Ty` pointer. In simple cases, this clause is redundant, since\n the `LIFETIME()` function will already enforce the required rule:\n \n ```rust\n-fn foo(point: &'a Point) -> &'static f32 {\n+fn foo(point: &'a Point) -> &'static i32 {\n     &point.x // Error\n }\n ```\n@@ -518,7 +518,7 @@ but also by the basic `LIFETIME()` check. However, in more advanced\n examples involving multiple nested pointers, clause (1) is needed:\n \n ```rust\n-fn foo(point: &'a &'b mut Point) -> &'b f32 {\n+fn foo(point: &'a &'b mut Point) -> &'b i32 {\n     &point.x // Error\n }\n ```\n@@ -537,7 +537,7 @@ As a final twist, consider the case of two nested *immutable*\n pointers, rather than a mutable pointer within an immutable one:\n \n ```rust\n-fn foo(point: &'a &'b Point) -> &'b f32 {\n+fn foo(point: &'a &'b Point) -> &'b i32 {\n     &point.x // OK\n }\n ```\n@@ -559,7 +559,7 @@ create a borrowed pointer that outlives the memory it points at. So\n `LIFETIME` prevents a function like this:\n \n ```rust\n-fn get_1<'a>() -> &'a int {\n+fn get_1<'a>() -> &'a i32 {\n     let x = 1;\n     &x\n }\n@@ -579,7 +579,7 @@ mutate it. This distinction is important for type checking functions\n like this one:\n \n ```rust\n-fn inc_and_get<'a>(p: &'a mut Point) -> &'a int {\n+fn inc_and_get<'a>(p: &'a mut Point) -> &'a i32 {\n     p.x += 1;\n     &p.x\n }\n@@ -661,8 +661,8 @@ the old name. Here is an example:\n \n ```rust\n // src/test/compile-fail/borrowck-move-mut-base-ptr.rs\n-fn foo(t0: &mut int) {\n-    let p: &int = &*t0; // Freezes `*t0`\n+fn foo(t0: &mut i32) {\n+    let p: &i32 = &*t0; // Freezes `*t0`\n     let t1 = t0;        //~ ERROR cannot move out of `t0`\n     *t1 = 22;           // OK, not a write through `*t0`\n }\n@@ -681,9 +681,9 @@ another path to access the same data, as shown here:\n \n ```rust\n // src/test/compile-fail/borrowck-mut-borrow-of-mut-base-ptr.rs\n-fn foo<'a>(mut t0: &'a mut int,\n-           mut t1: &'a mut int) {\n-    let p: &int = &*t0;     // Freezes `*t0`\n+fn foo<'a>(mut t0: &'a mut i32,\n+           mut t1: &'a mut i32) {\n+    let p: &i32 = &*t0;     // Freezes `*t0`\n     let mut t2 = &mut t0;   //~ ERROR cannot borrow `t0`\n     **t2 += 1;              // Mutates `*t0`\n }\n@@ -702,9 +702,9 @@ value away to create a new path:\n \n ```rust\n // src/test/compile-fail/borrowck-swap-mut-base-ptr.rs\n-fn foo<'a>(mut t0: &'a mut int,\n-           mut t1: &'a mut int) {\n-    let p: &int = &*t0;     // Freezes `*t0`\n+fn foo<'a>(mut t0: &'a mut i32,\n+           mut t1: &'a mut i32) {\n+    let p: &i32 = &*t0;     // Freezes `*t0`\n     swap(&mut t0, &mut t1); //~ ERROR cannot borrow `t0`\n     *t1 = 22;\n }\n@@ -720,21 +720,21 @@ as shown in the following example:\n \n ```rust\n // src/test/compile-fail/borrowck-borrow-of-mut-base-ptr.rs\n-fn foo<'a>(mut t0: &'a mut int,\n-           mut t1: &'a mut int) {\n-    let p: &mut int = &mut *t0; // Claims `*t0`\n+fn foo<'a>(mut t0: &'a mut i32,\n+           mut t1: &'a mut i32) {\n+    let p: &mut i32 = &mut *t0; // Claims `*t0`\n     let mut t2 = &t0;           //~ ERROR cannot borrow `t0`\n-    let q: &int = &*t2;         // Freezes `*t0` but not through `*p`\n+    let q: &i32 = &*t2;         // Freezes `*t0` but not through `*p`\n     *p += 1;                    // violates type of `*q`\n }\n ```\n \n Here the problem is that `*t0` is claimed by `p`, and hence `p` wants\n to be the controlling pointer through which mutation or freezes occur.\n-But `t2` would -- if it were legal -- have the type `& &mut int`, and\n+But `t2` would -- if it were legal -- have the type `& &mut i32`, and\n hence would be a mutable pointer in an aliasable location, which is\n considered frozen (since no one can write to `**t2` as it is not a\n-unique path). Therefore, we could reasonably create a frozen `&int`\n+unique path). Therefore, we could reasonably create a frozen `&i32`\n pointer pointing at `*t0` that coexists with the mutable pointer `p`,\n which is clearly unsound.\n \n@@ -743,12 +743,12 @@ particular, if the referent is frozen, there is no harm in it:\n \n ```rust\n // src/test/run-pass/borrowck-borrow-of-mut-base-ptr-safe.rs\n-fn foo<'a>(mut t0: &'a mut int,\n-           mut t1: &'a mut int) {\n-    let p: &int = &*t0; // Freezes `*t0`\n+fn foo<'a>(mut t0: &'a mut i32,\n+           mut t1: &'a mut i32) {\n+    let p: &i32 = &*t0; // Freezes `*t0`\n     let mut t2 = &t0;\n-    let q: &int = &*t2; // Freezes `*t0`, but that's ok...\n-    let r: &int = &*t0; // ...after all, could do same thing directly.\n+    let q: &i32 = &*t2; // Freezes `*t0`, but that's ok...\n+    let r: &i32 = &*t0; // ...after all, could do same thing directly.\n }\n ```\n \n@@ -759,9 +759,9 @@ new alias `t2`, as demonstrated in this test case:\n \n ```rust\n // src/test/run-pass/borrowck-borrow-mut-base-ptr-in-aliasable-loc.rs\n-fn foo(t0: & &mut int) {\n+fn foo(t0: & &mut i32) {\n     let t1 = t0;\n-    let p: &int = &**t0;\n+    let p: &i32 = &**t0;\n     **t1 = 22; //~ ERROR cannot assign\n }\n ```\n@@ -831,8 +831,8 @@ moves/uninitializations of the variable that is being used.\n Let's look at a simple example:\n \n ```rust\n-fn foo(a: Box<int>) {\n-    let b: Box<int>;   // Gen bit 0.\n+fn foo(a: Box<i32>) {\n+    let b: Box<i32>;   // Gen bit 0.\n \n     if cond {          // Bits: 0\n         use(&*a);\n@@ -846,7 +846,7 @@ fn foo(a: Box<int>) {\n     use(&*b);          // Error.\n }\n \n-fn use(a: &int) { }\n+fn use(a: &i32) { }\n ```\n \n In this example, the variable `b` is created uninitialized. In one\n@@ -977,8 +977,8 @@ not) the destructor invocation for that path.\n A simple example of this is the following:\n \n ```rust\n-struct D { p: int }\n-impl D { fn new(x: int) -> D { ... }\n+struct D { p: i32 }\n+impl D { fn new(x: i32) -> D { ... }\n impl Drop for D { ... }\n \n fn foo(a: D, b: D, t: || -> bool) {\n@@ -1091,7 +1091,7 @@ the elements of an array that has been passed by value, such as\n the following:\n \n ```rust\n-fn foo(a: [D; 10], i: uint) -> D {\n+fn foo(a: [D; 10], i: i32) -> D {\n     a[i]\n }\n ```\n@@ -1107,7 +1107,7 @@ all-but-one element of the array.  A place where that distinction\n would arise is the following:\n \n ```rust\n-fn foo(a: [D; 10], b: [D; 10], i: uint, t: bool) -> D {\n+fn foo(a: [D; 10], b: [D; 10], i: i32, t: bool) -> D {\n     if t {\n         a[i]\n     } else {\n@@ -1122,7 +1122,7 @@ fn foo(a: [D; 10], b: [D; 10], i: uint, t: bool) -> D {\n \n There are a number of ways that the trans backend could choose to\n compile this (e.g. a `[bool; 10]` array for each such moved array;\n-or an `Option<uint>` for each moved array).  From the viewpoint of the\n+or an `Option<usize>` for each moved array).  From the viewpoint of the\n borrow-checker, the important thing is to record what kind of fragment\n is implied by the relevant moves.\n "}]}