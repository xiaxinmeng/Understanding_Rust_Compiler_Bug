{"sha": "d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2ZGNiY2Q0ZTExYTFiNzg3YTlkYjFmYTQzYTQ5OTA3ZThiY2NlY2Y=", "commit": {"author": {"name": "Donato Sciarra", "email": "sciarp@gmail.com", "date": "2018-08-18T10:13:52Z"}, "committer": {"name": "Donato Sciarra", "email": "sciarp@gmail.com", "date": "2018-08-19T21:00:59Z"}, "message": "mv FileMap SourceFile", "tree": {"sha": "37af96f2adba41bfc3ff98e45006918de702d44c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37af96f2adba41bfc3ff98e45006918de702d44c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf", "html_url": "https://github.com/rust-lang/rust/commit/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/comments", "author": {"login": "dsciarra", "id": 2036702, "node_id": "MDQ6VXNlcjIwMzY3MDI=", "avatar_url": "https://avatars.githubusercontent.com/u/2036702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dsciarra", "html_url": "https://github.com/dsciarra", "followers_url": "https://api.github.com/users/dsciarra/followers", "following_url": "https://api.github.com/users/dsciarra/following{/other_user}", "gists_url": "https://api.github.com/users/dsciarra/gists{/gist_id}", "starred_url": "https://api.github.com/users/dsciarra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dsciarra/subscriptions", "organizations_url": "https://api.github.com/users/dsciarra/orgs", "repos_url": "https://api.github.com/users/dsciarra/repos", "events_url": "https://api.github.com/users/dsciarra/events{/privacy}", "received_events_url": "https://api.github.com/users/dsciarra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dsciarra", "id": 2036702, "node_id": "MDQ6VXNlcjIwMzY3MDI=", "avatar_url": "https://avatars.githubusercontent.com/u/2036702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dsciarra", "html_url": "https://github.com/dsciarra", "followers_url": "https://api.github.com/users/dsciarra/followers", "following_url": "https://api.github.com/users/dsciarra/following{/other_user}", "gists_url": "https://api.github.com/users/dsciarra/gists{/gist_id}", "starred_url": "https://api.github.com/users/dsciarra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dsciarra/subscriptions", "organizations_url": "https://api.github.com/users/dsciarra/orgs", "repos_url": "https://api.github.com/users/dsciarra/repos", "events_url": "https://api.github.com/users/dsciarra/events{/privacy}", "received_events_url": "https://api.github.com/users/dsciarra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c65547337831babea8d9052b960649309263df36", "url": "https://api.github.com/repos/rust-lang/rust/commits/c65547337831babea8d9052b960649309263df36", "html_url": "https://github.com/rust-lang/rust/commit/c65547337831babea8d9052b960649309263df36"}], "stats": {"total": 252, "additions": 126, "deletions": 126}, "files": [{"sha": "50a613f86c2bf385da81f3f8c99bfcce8ae3f6ec", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf", "patch": "@@ -63,7 +63,7 @@ use syntax::errors::DiagnosticBuilder;\n use syntax::parse::{self, token};\n use syntax::symbol::Symbol;\n use syntax::tokenstream;\n-use syntax_pos::{FileMap, Pos, FileName};\n+use syntax_pos::{Pos, FileName};\n \n /// The main type provided by this crate, representing an abstract stream of\n /// tokens, or, more specifically, a sequence of token trees.\n@@ -308,7 +308,7 @@ impl Span {\n     #[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n     pub fn source_file(&self) -> SourceFile {\n         SourceFile {\n-            filemap: __internal::lookup_char_pos(self.0.lo()).file,\n+            source_file: __internal::lookup_char_pos(self.0.lo()).file,\n         }\n     }\n \n@@ -419,7 +419,7 @@ impl !Sync for LineColumn {}\n #[unstable(feature = \"proc_macro_span\", issue = \"38356\")]\n #[derive(Clone)]\n pub struct SourceFile {\n-    filemap: Lrc<FileMap>,\n+    source_file: Lrc<syntax_pos::SourceFile>,\n }\n \n #[unstable(feature = \"proc_macro_span\", issue = \"38356\")]"}, {"sha": "d8999e1e00f88bd48a6108a6ea7131cc2dbe15ad", "filename": "src/librustc/ich/caching_codemap_view.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs?ref=d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf", "patch": "@@ -10,15 +10,15 @@\n \n use rustc_data_structures::sync::Lrc;\n use syntax::codemap::SourceMap;\n-use syntax_pos::{BytePos, FileMap};\n+use syntax_pos::{BytePos, SourceFile};\n \n #[derive(Clone)]\n struct CacheEntry {\n     time_stamp: usize,\n     line_number: usize,\n     line_start: BytePos,\n     line_end: BytePos,\n-    file: Lrc<FileMap>,\n+    file: Lrc<SourceFile>,\n     file_index: usize,\n }\n \n@@ -51,7 +51,7 @@ impl<'cm> CachingCodemapView<'cm> {\n \n     pub fn byte_pos_to_line_and_col(&mut self,\n                                     pos: BytePos)\n-                                    -> Option<(Lrc<FileMap>, usize, BytePos)> {\n+                                    -> Option<(Lrc<SourceFile>, usize, BytePos)> {\n         self.time_stamp += 1;\n \n         // Check if the position is in one of the cached lines"}, {"sha": "5260d94168f34c2a436e2fdd00f7c8bb737cd6c8", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf", "patch": "@@ -309,7 +309,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for Span {\n     // Hash a span in a stable way. We can't directly hash the span's BytePos\n     // fields (that would be similar to hashing pointers, since those are just\n     // offsets into the SourceMap). Instead, we hash the (file name, line, column)\n-    // triple, which stays the same even if the containing FileMap has moved\n+    // triple, which stays the same even if the containing SourceFile has moved\n     // within the SourceMap.\n     // Also note that we are hashing byte offsets for the column, not unicode\n     // codepoint offsets. For the purpose of the hash that's sufficient."}, {"sha": "fd35713cc6f3360a65c0c7231b93bab0eea533a1", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf", "patch": "@@ -21,7 +21,7 @@ use syntax::feature_gate;\n use syntax::parse::token;\n use syntax::symbol::{InternedString, LocalInternedString};\n use syntax::tokenstream;\n-use syntax_pos::FileMap;\n+use syntax_pos::SourceFile;\n \n use hir::def_id::{DefId, CrateNum, CRATE_DEF_INDEX};\n \n@@ -427,11 +427,11 @@ impl_stable_hash_for!(enum ::syntax_pos::FileName {\n     Custom(s)\n });\n \n-impl<'a> HashStable<StableHashingContext<'a>> for FileMap {\n+impl<'a> HashStable<StableHashingContext<'a>> for SourceFile {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n-        let FileMap {\n+        let SourceFile {\n             name: _, // We hash the smaller name_hash instead of this\n             name_hash,\n             name_was_remapped,"}, {"sha": "2e5be214604f977bba307f293fea399e3fa8120f", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf", "patch": "@@ -27,7 +27,7 @@ use session::{CrateDisambiguator, Session};\n use std::mem;\n use syntax::ast::NodeId;\n use syntax::codemap::{SourceMap, StableFilemapId};\n-use syntax_pos::{BytePos, Span, DUMMY_SP, FileMap};\n+use syntax_pos::{BytePos, Span, DUMMY_SP, SourceFile};\n use syntax_pos::hygiene::{Mark, SyntaxContext, ExpnInfo};\n use ty;\n use ty::codec::{self as ty_codec, TyDecoder, TyEncoder};\n@@ -63,10 +63,10 @@ pub struct OnDiskCache<'sess> {\n     cnum_map: Once<IndexVec<CrateNum, Option<CrateNum>>>,\n \n     codemap: &'sess SourceMap,\n-    file_index_to_stable_id: FxHashMap<FileMapIndex, StableFilemapId>,\n+    file_index_to_stable_id: FxHashMap<SourceFileIndex, StableFilemapId>,\n \n     // These two fields caches that are populated lazily during decoding.\n-    file_index_to_file: Lock<FxHashMap<FileMapIndex, Lrc<FileMap>>>,\n+    file_index_to_file: Lock<FxHashMap<SourceFileIndex, Lrc<SourceFile>>>,\n     synthetic_expansion_infos: Lock<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n \n     // A map from dep-node to the position of the cached query result in\n@@ -83,7 +83,7 @@ pub struct OnDiskCache<'sess> {\n // This type is used only for (de-)serialization.\n #[derive(RustcEncodable, RustcDecodable)]\n struct Footer {\n-    file_index_to_stable_id: FxHashMap<FileMapIndex, StableFilemapId>,\n+    file_index_to_stable_id: FxHashMap<SourceFileIndex, StableFilemapId>,\n     prev_cnums: Vec<(u32, String, CrateDisambiguator)>,\n     query_result_index: EncodedQueryResultIndex,\n     diagnostics_index: EncodedQueryResultIndex,\n@@ -96,7 +96,7 @@ type EncodedDiagnosticsIndex = Vec<(SerializedDepNodeIndex, AbsoluteBytePos)>;\n type EncodedDiagnostics = Vec<Diagnostic>;\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n-struct FileMapIndex(u32);\n+struct SourceFileIndex(u32);\n \n #[derive(Copy, Clone, Debug, Hash, Eq, PartialEq, RustcEncodable, RustcDecodable)]\n struct AbsoluteBytePos(u32);\n@@ -173,14 +173,14 @@ impl<'sess> OnDiskCache<'sess> {\n      {\n         // Serializing the DepGraph should not modify it:\n         tcx.dep_graph.with_ignore(|| {\n-            // Allocate FileMapIndices\n+            // Allocate SourceFileIndices\n             let (file_to_file_index, file_index_to_stable_id) = {\n                 let mut file_to_file_index = FxHashMap();\n                 let mut file_index_to_stable_id = FxHashMap();\n \n                 for (index, file) in tcx.sess.codemap().files().iter().enumerate() {\n-                    let index = FileMapIndex(index as u32);\n-                    let file_ptr: *const FileMap = &**file as *const _;\n+                    let index = SourceFileIndex(index as u32);\n+                    let file_ptr: *const SourceFile = &**file as *const _;\n                     file_to_file_index.insert(file_ptr, index);\n                     file_index_to_stable_id.insert(index, StableFilemapId::new(&file));\n                 }\n@@ -478,13 +478,13 @@ struct CacheDecoder<'a, 'tcx: 'a, 'x> {\n     codemap: &'x SourceMap,\n     cnum_map: &'x IndexVec<CrateNum, Option<CrateNum>>,\n     synthetic_expansion_infos: &'x Lock<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n-    file_index_to_file: &'x Lock<FxHashMap<FileMapIndex, Lrc<FileMap>>>,\n-    file_index_to_stable_id: &'x FxHashMap<FileMapIndex, StableFilemapId>,\n+    file_index_to_file: &'x Lock<FxHashMap<SourceFileIndex, Lrc<SourceFile>>>,\n+    file_index_to_stable_id: &'x FxHashMap<SourceFileIndex, StableFilemapId>,\n     alloc_decoding_session: AllocDecodingSession<'x>,\n }\n \n impl<'a, 'tcx, 'x> CacheDecoder<'a, 'tcx, 'x> {\n-    fn file_index_to_file(&self, index: FileMapIndex) -> Lrc<FileMap> {\n+    fn file_index_to_file(&self, index: SourceFileIndex) -> Lrc<SourceFile> {\n         let CacheDecoder {\n             ref file_index_to_file,\n             ref file_index_to_stable_id,\n@@ -495,7 +495,7 @@ impl<'a, 'tcx, 'x> CacheDecoder<'a, 'tcx, 'x> {\n         file_index_to_file.borrow_mut().entry(index).or_insert_with(|| {\n             let stable_id = file_index_to_stable_id[&index];\n             codemap.filemap_by_stable_id(stable_id)\n-                   .expect(\"Failed to lookup FileMap in new context.\")\n+                   .expect(\"Failed to lookup SourceFile in new context.\")\n         }).clone()\n     }\n }\n@@ -617,7 +617,7 @@ impl<'a, 'tcx, 'x> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx, 'x> {\n             debug_assert_eq!(tag, TAG_VALID_SPAN);\n         }\n \n-        let file_lo_index = FileMapIndex::decode(self)?;\n+        let file_lo_index = SourceFileIndex::decode(self)?;\n         let line_lo = usize::decode(self)?;\n         let col_lo = BytePos::decode(self)?;\n         let len = BytePos::decode(self)?;\n@@ -771,14 +771,14 @@ struct CacheEncoder<'enc, 'a, 'tcx, E>\n     interpret_allocs: FxHashMap<interpret::AllocId, usize>,\n     interpret_allocs_inverse: Vec<interpret::AllocId>,\n     codemap: CachingCodemapView<'tcx>,\n-    file_to_file_index: FxHashMap<*const FileMap, FileMapIndex>,\n+    file_to_file_index: FxHashMap<*const SourceFile, SourceFileIndex>,\n }\n \n impl<'enc, 'a, 'tcx, E> CacheEncoder<'enc, 'a, 'tcx, E>\n     where E: 'enc + ty_codec::TyEncoder\n {\n-    fn filemap_index(&mut self, filemap: Lrc<FileMap>) -> FileMapIndex {\n-        self.file_to_file_index[&(&*filemap as *const FileMap)]\n+    fn filemap_index(&mut self, filemap: Lrc<SourceFile>) -> SourceFileIndex {\n+        self.file_to_file_index[&(&*filemap as *const SourceFile)]\n     }\n \n     /// Encode something with additional information that allows to do some"}, {"sha": "cac2ae0302e3ed72116de1030ef8d9d7409fa103", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf", "patch": "@@ -1745,7 +1745,7 @@ pub fn create_global_var_metadata(\n pub fn extend_scope_to_file(\n     cx: &CodegenCx<'ll, '_>,\n     scope_metadata: &'ll DIScope,\n-    file: &syntax_pos::FileMap,\n+    file: &syntax_pos::SourceFile,\n     defining_crate: CrateNum,\n ) -> &'ll DILexicalBlock {\n     let file_metadata = file_metadata(cx, &file.name, defining_crate);"}, {"sha": "ce3a19677f2b9d9eb7c22e6f81c4536ccec8eb60", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf", "patch": "@@ -10,7 +10,7 @@\n \n use self::Destination::*;\n \n-use syntax_pos::{FileMap, Span, MultiSpan};\n+use syntax_pos::{SourceFile, Span, MultiSpan};\n \n use {Level, CodeSuggestion, DiagnosticBuilder, SubDiagnostic, SourceMapperDyn, DiagnosticId};\n use snippet::{Annotation, AnnotationType, Line, MultilineAnnotation, StyledString, Style};\n@@ -127,7 +127,7 @@ pub struct EmitterWriter {\n }\n \n struct FileWithAnnotatedLines {\n-    file: Lrc<FileMap>,\n+    file: Lrc<SourceFile>,\n     lines: Vec<Line>,\n     multiline_depth: usize,\n }\n@@ -177,7 +177,7 @@ impl EmitterWriter {\n \n     fn preprocess_annotations(&mut self, msp: &MultiSpan) -> Vec<FileWithAnnotatedLines> {\n         fn add_annotation_to_file(file_vec: &mut Vec<FileWithAnnotatedLines>,\n-                                  file: Lrc<FileMap>,\n+                                  file: Lrc<SourceFile>,\n                                   line_index: usize,\n                                   ann: Annotation) {\n \n@@ -307,7 +307,7 @@ impl EmitterWriter {\n \n     fn render_source_line(&self,\n                           buffer: &mut StyledBuffer,\n-                          file: Lrc<FileMap>,\n+                          file: Lrc<SourceFile>,\n                           line: &Line,\n                           width_offset: usize,\n                           code_offset: usize) -> Vec<(usize, Style)> {"}, {"sha": "597b32164909c8b3e06c93e2d61c0c910eb90ccd", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf", "patch": "@@ -55,7 +55,7 @@ pub mod registry;\n mod styled_buffer;\n mod lock;\n \n-use syntax_pos::{BytePos, Loc, FileLinesResult, FileMap, FileName, MultiSpan, Span, NO_EXPANSION};\n+use syntax_pos::{BytePos, Loc, FileLinesResult, SourceFile, FileName, MultiSpan, Span, NO_EXPANSION};\n \n #[derive(Copy, Clone, Debug, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n pub enum Applicability {\n@@ -120,7 +120,7 @@ pub trait SourceMapper {\n     fn span_to_filename(&self, sp: Span) -> FileName;\n     fn merge_spans(&self, sp_lhs: Span, sp_rhs: Span) -> Option<Span>;\n     fn call_span_if_macro(&self, sp: Span) -> Span;\n-    fn ensure_filemap_source_present(&self, file_map: Lrc<FileMap>) -> bool;\n+    fn ensure_filemap_source_present(&self, file_map: Lrc<SourceFile>) -> bool;\n     fn doctest_offset_line(&self, line: usize) -> usize;\n }\n "}, {"sha": "2c95bd82432c7c936421510e33cfe23d4dcfd81b", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf", "patch": "@@ -41,15 +41,15 @@ pub use rustc_data_structures::sync::MetadataRef;\n \n pub struct MetadataBlob(pub MetadataRef);\n \n-/// Holds information about a syntax_pos::FileMap imported from another crate.\n+/// Holds information about a syntax_pos::SourceFile imported from another crate.\n /// See `imported_filemaps()` for more information.\n-pub struct ImportedFileMap {\n-    /// This FileMap's byte-offset within the codemap of its original crate\n+pub struct ImportedSourceFile {\n+    /// This SourceFile's byte-offset within the codemap of its original crate\n     pub original_start_pos: syntax_pos::BytePos,\n-    /// The end of this FileMap within the codemap of its original crate\n+    /// The end of this SourceFile within the codemap of its original crate\n     pub original_end_pos: syntax_pos::BytePos,\n-    /// The imported FileMap's representation within the local codemap\n-    pub translated_filemap: Lrc<syntax_pos::FileMap>,\n+    /// The imported SourceFile's representation within the local codemap\n+    pub translated_filemap: Lrc<syntax_pos::SourceFile>,\n }\n \n pub struct CrateMetadata {\n@@ -64,7 +64,7 @@ pub struct CrateMetadata {\n     pub cnum_map: CrateNumMap,\n     pub cnum: CrateNum,\n     pub dependencies: Lock<Vec<CrateNum>>,\n-    pub codemap_import_info: RwLock<Vec<ImportedFileMap>>,\n+    pub codemap_import_info: RwLock<Vec<ImportedSourceFile>>,\n \n     /// Used for decoding interpret::AllocIds in a cached & thread-safe manner.\n     pub alloc_decoding_state: AllocDecodingState,"}, {"sha": "00ed71c889142e1e190d1568284b7265e99e8ca5", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf", "patch": "@@ -1099,26 +1099,26 @@ impl<'a, 'tcx> CrateMetadata {\n     ///\n     /// The import algorithm works analogous to how AST items are inlined from an\n     /// external crate's metadata:\n-    /// For every FileMap in the external codemap an 'inline' copy is created in the\n+    /// For every SourceFile in the external codemap an 'inline' copy is created in the\n     /// local codemap. The correspondence relation between external and local\n-    /// FileMaps is recorded in the `ImportedFileMap` objects returned from this\n+    /// SourceFiles is recorded in the `ImportedSourceFile` objects returned from this\n     /// function. When an item from an external crate is later inlined into this\n     /// crate, this correspondence information is used to translate the span\n     /// information of the inlined item so that it refers the correct positions in\n     /// the local codemap (see `<decoder::DecodeContext as SpecializedDecoder<Span>>`).\n     ///\n-    /// The import algorithm in the function below will reuse FileMaps already\n-    /// existing in the local codemap. For example, even if the FileMap of some\n+    /// The import algorithm in the function below will reuse SourceFiles already\n+    /// existing in the local codemap. For example, even if the SourceFile of some\n     /// source file of libstd gets imported many times, there will only ever be\n-    /// one FileMap object for the corresponding file in the local codemap.\n+    /// one SourceFile object for the corresponding file in the local codemap.\n     ///\n-    /// Note that imported FileMaps do not actually contain the source code of the\n+    /// Note that imported SourceFiles do not actually contain the source code of the\n     /// file they represent, just information about length, line breaks, and\n     /// multibyte characters. This information is enough to generate valid debuginfo\n     /// for items inlined from other crates.\n     pub fn imported_filemaps(&'a self,\n                              local_codemap: &codemap::SourceMap)\n-                             -> ReadGuard<'a, Vec<cstore::ImportedFileMap>> {\n+                             -> ReadGuard<'a, Vec<cstore::ImportedSourceFile>> {\n         {\n             let filemaps = self.codemap_import_info.borrow();\n             if !filemaps.is_empty() {\n@@ -1137,9 +1137,9 @@ impl<'a, 'tcx> CrateMetadata {\n         let external_codemap = self.root.codemap.decode(self);\n \n         let imported_filemaps = external_codemap.map(|filemap_to_import| {\n-            // We can't reuse an existing FileMap, so allocate a new one\n+            // We can't reuse an existing SourceFile, so allocate a new one\n             // containing the information we need.\n-            let syntax_pos::FileMap { name,\n+            let syntax_pos::SourceFile { name,\n                                       name_was_remapped,\n                                       src_hash,\n                                       start_pos,\n@@ -1156,7 +1156,7 @@ impl<'a, 'tcx> CrateMetadata {\n             // position into frame of reference local to file.\n             // `SourceMap::new_imported_filemap()` will then translate those\n             // coordinates to their new global frame of reference when the\n-            // offset of the FileMap is known.\n+            // offset of the SourceFile is known.\n             for pos in &mut lines {\n                 *pos = *pos - start_pos;\n             }\n@@ -1182,7 +1182,7 @@ impl<'a, 'tcx> CrateMetadata {\n                    local_version.name, start_pos, end_pos,\n                    local_version.start_pos, local_version.end_pos);\n \n-            cstore::ImportedFileMap {\n+            cstore::ImportedSourceFile {\n                 original_start_pos: start_pos,\n                 original_end_pos: end_pos,\n                 translated_filemap: local_version,"}, {"sha": "925d765ca31f31d319b1add92df8d7873733ca5f", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf", "patch": "@@ -42,7 +42,7 @@ use syntax::ast::{self, CRATE_NODE_ID};\n use syntax::attr;\n use syntax::codemap::Spanned;\n use syntax::symbol::keywords;\n-use syntax_pos::{self, hygiene, FileName, FileMap, Span};\n+use syntax_pos::{self, hygiene, FileName, SourceFile, Span};\n \n use rustc::hir::{self, PatKind};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n@@ -62,7 +62,7 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n     interpret_allocs_inverse: Vec<interpret::AllocId>,\n \n     // This is used to speed up Span encoding.\n-    filemap_cache: Lrc<FileMap>,\n+    filemap_cache: Lrc<SourceFile>,\n }\n \n macro_rules! encoder_methods {\n@@ -337,7 +337,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.lazy(definitions.def_path_table())\n     }\n \n-    fn encode_codemap(&mut self) -> LazySeq<syntax_pos::FileMap> {\n+    fn encode_codemap(&mut self) -> LazySeq<syntax_pos::SourceFile> {\n         let codemap = self.tcx.sess.codemap();\n         let all_filemaps = codemap.files();\n \n@@ -350,7 +350,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 !filemap.is_imported()\n             })\n             .map(|filemap| {\n-                // When exporting FileMaps, we expand all paths to absolute\n+                // When exporting SourceFiles, we expand all paths to absolute\n                 // paths because any relative paths are potentially relative to\n                 // a wrong directory.\n                 // However, if a path has been modified via\n@@ -361,7 +361,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     FileName::Real(ref name) => {\n                         if filemap.name_was_remapped ||\n                         (name.is_relative() && working_dir_was_remapped) {\n-                            // This path of this FileMap has been modified by\n+                            // This path of this SourceFile has been modified by\n                             // path-remapping, so we use it verbatim (and avoid cloning\n                             // the whole map in the process).\n                             filemap.clone()"}, {"sha": "520273487a9cc836443748c372a84e982e519a0e", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf", "patch": "@@ -204,7 +204,7 @@ pub struct CrateRoot {\n     pub lang_items_missing: LazySeq<lang_items::LangItem>,\n     pub native_libraries: LazySeq<NativeLibrary>,\n     pub foreign_modules: LazySeq<ForeignModule>,\n-    pub codemap: LazySeq<syntax_pos::FileMap>,\n+    pub codemap: LazySeq<syntax_pos::SourceFile>,\n     pub def_path_table: Lazy<hir::map::definitions::DefPathTable>,\n     pub impls: LazySeq<TraitImpls>,\n     pub exported_symbols: EncodedExportedSymbols,"}, {"sha": "9e852a077bcbaa7b00b361dbfb8cb2c7cbc03d40", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf", "patch": "@@ -603,7 +603,7 @@ impl Clean<Item> for doctree::Module {\n                 // mod foo { ... }\n                 self.where_outer\n             } else {\n-                // mod foo; (and a separate FileMap for the contents)\n+                // mod foo; (and a separate SourceFile for the contents)\n                 self.where_inner\n             }\n         };"}, {"sha": "c9a9fbf4d7bb1dfe11ad5dc83dbc69db8036c19f", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf", "patch": "@@ -12,7 +12,7 @@\n //! from integer byte positions to the original source code location. Each bit\n //! of source parsed during crate parsing (typically files, in-memory strings,\n //! or various bits of macro expansion) cover a continuous range of bytes in the\n-//! SourceMap and are represented by FileMaps. Byte positions are stored in\n+//! SourceMap and are represented by SourceFiles. Byte positions are stored in\n //! `spans` and used pervasively in the compiler. They are absolute positions\n //! within the SourceMap, which upon request can be converted to line and column\n //! information, source code snippets, etc.\n@@ -62,7 +62,7 @@ pub fn dummy_spanned<T>(t: T) -> Spanned<T> {\n }\n \n // _____________________________________________________________________________\n-// FileMap, MultiByteChar, FileName, FileLines\n+// SourceFile, MultiByteChar, FileName, FileLines\n //\n \n /// An abstraction over the fs operations used by the Parser.\n@@ -102,14 +102,14 @@ impl FileLoader for RealFileLoader {\n     }\n }\n \n-// This is a FileMap identifier that is used to correlate FileMaps between\n+// This is a SourceFile identifier that is used to correlate SourceFiles between\n // subsequent compilation sessions (which is something we need to do during\n // incremental compilation).\n #[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub struct StableFilemapId(u128);\n \n impl StableFilemapId {\n-    pub fn new(filemap: &FileMap) -> StableFilemapId {\n+    pub fn new(filemap: &SourceFile) -> StableFilemapId {\n         let mut hasher = StableHasher::new();\n \n         filemap.name.hash(&mut hasher);\n@@ -125,15 +125,15 @@ impl StableFilemapId {\n //\n \n pub(super) struct SourceMapFiles {\n-    pub(super) file_maps: Vec<Lrc<FileMap>>,\n-    stable_id_to_filemap: FxHashMap<StableFilemapId, Lrc<FileMap>>\n+    pub(super) file_maps: Vec<Lrc<SourceFile>>,\n+    stable_id_to_filemap: FxHashMap<StableFilemapId, Lrc<SourceFile>>\n }\n \n pub struct SourceMap {\n     pub(super) files: Lock<SourceMapFiles>,\n     file_loader: Box<dyn FileLoader + Sync + Send>,\n     // This is used to apply the file path remapping as specified via\n-    // --remap-path-prefix to all FileMaps allocated within this SourceMap.\n+    // --remap-path-prefix to all SourceFiles allocated within this SourceMap.\n     path_mapping: FilePathMapping,\n     /// In case we are in a doctest, replace all file names with the PathBuf,\n     /// and add the given offsets to the line info\n@@ -184,7 +184,7 @@ impl SourceMap {\n         self.file_loader.file_exists(path)\n     }\n \n-    pub fn load_file(&self, path: &Path) -> io::Result<Lrc<FileMap>> {\n+    pub fn load_file(&self, path: &Path) -> io::Result<Lrc<SourceFile>> {\n         let src = self.file_loader.read_file(path)?;\n         let filename = if let Some((ref name, _)) = self.doctest_offset {\n             name.clone()\n@@ -194,11 +194,11 @@ impl SourceMap {\n         Ok(self.new_filemap(filename, src))\n     }\n \n-    pub fn files(&self) -> LockGuard<Vec<Lrc<FileMap>>> {\n+    pub fn files(&self) -> LockGuard<Vec<Lrc<SourceFile>>> {\n         LockGuard::map(self.files.borrow(), |files| &mut files.file_maps)\n     }\n \n-    pub fn filemap_by_stable_id(&self, stable_id: StableFilemapId) -> Option<Lrc<FileMap>> {\n+    pub fn filemap_by_stable_id(&self, stable_id: StableFilemapId) -> Option<Lrc<SourceFile>> {\n         self.files.borrow().stable_id_to_filemap.get(&stable_id).map(|fm| fm.clone())\n     }\n \n@@ -212,8 +212,8 @@ impl SourceMap {\n     }\n \n     /// Creates a new filemap.\n-    /// This does not ensure that only one FileMap exists per file name.\n-    pub fn new_filemap(&self, filename: FileName, src: String) -> Lrc<FileMap> {\n+    /// This does not ensure that only one SourceFile exists per file name.\n+    pub fn new_filemap(&self, filename: FileName, src: String) -> Lrc<SourceFile> {\n         let start_pos = self.next_start_pos();\n \n         // The path is used to determine the directory for loading submodules and\n@@ -230,7 +230,7 @@ impl SourceMap {\n             },\n             other => (other, false),\n         };\n-        let filemap = Lrc::new(FileMap::new(\n+        let filemap = Lrc::new(SourceFile::new(\n             filename,\n             was_remapped,\n             unmapped_path,\n@@ -246,7 +246,7 @@ impl SourceMap {\n         filemap\n     }\n \n-    /// Allocates a new FileMap representing a source file from an external\n+    /// Allocates a new SourceFile representing a source file from an external\n     /// crate. The source code of such an \"imported filemap\" is not available,\n     /// but we still know enough to generate accurate debuginfo location\n     /// information for things inlined from other crates.\n@@ -260,7 +260,7 @@ impl SourceMap {\n                                 mut file_local_lines: Vec<BytePos>,\n                                 mut file_local_multibyte_chars: Vec<MultiByteChar>,\n                                 mut file_local_non_narrow_chars: Vec<NonNarrowChar>)\n-                                -> Lrc<FileMap> {\n+                                -> Lrc<SourceFile> {\n         let start_pos = self.next_start_pos();\n \n         let end_pos = Pos::from_usize(start_pos + source_len);\n@@ -278,7 +278,7 @@ impl SourceMap {\n             *swc = *swc + start_pos;\n         }\n \n-        let filemap = Lrc::new(FileMap {\n+        let filemap = Lrc::new(SourceFile {\n             name: filename,\n             name_was_remapped,\n             unmapped_path: None,\n@@ -326,7 +326,7 @@ impl SourceMap {\n     pub fn lookup_char_pos(&self, pos: BytePos) -> Loc {\n         let chpos = self.bytepos_to_file_charpos(pos);\n         match self.lookup_line(pos) {\n-            Ok(FileMapAndLine { fm: f, line: a }) => {\n+            Ok(SourceFileAndLine { fm: f, line: a }) => {\n                 let line = a + 1; // Line numbers start at 1\n                 let linebpos = f.lines[a];\n                 let linechpos = self.bytepos_to_file_charpos(linebpos);\n@@ -386,13 +386,13 @@ impl SourceMap {\n     }\n \n     // If the relevant filemap is empty, we don't return a line number.\n-    pub fn lookup_line(&self, pos: BytePos) -> Result<FileMapAndLine, Lrc<FileMap>> {\n+    pub fn lookup_line(&self, pos: BytePos) -> Result<SourceFileAndLine, Lrc<SourceFile>> {\n         let idx = self.lookup_filemap_idx(pos);\n \n         let f = (*self.files.borrow().file_maps)[idx].clone();\n \n         match f.lookup_line(pos) {\n-            Some(line) => Ok(FileMapAndLine { fm: f, line: line }),\n+            Some(line) => Ok(SourceFileAndLine { fm: f, line: line }),\n             None => Err(f)\n         }\n     }\n@@ -463,7 +463,7 @@ impl SourceMap {\n \n     pub fn span_to_unmapped_path(&self, sp: Span) -> FileName {\n         self.lookup_char_pos(sp.lo()).file.unmapped_path.clone()\n-            .expect(\"SourceMap::span_to_unmapped_path called for imported FileMap?\")\n+            .expect(\"SourceMap::span_to_unmapped_path called for imported SourceFile?\")\n     }\n \n     pub fn is_multiline(&self, sp: Span) -> bool {\n@@ -798,7 +798,7 @@ impl SourceMap {\n         }\n     }\n \n-    pub fn get_filemap(&self, filename: &FileName) -> Option<Lrc<FileMap>> {\n+    pub fn get_filemap(&self, filename: &FileName) -> Option<Lrc<SourceFile>> {\n         for fm in self.files.borrow().file_maps.iter() {\n             if *filename == fm.name {\n                 return Some(fm.clone());\n@@ -807,20 +807,20 @@ impl SourceMap {\n         None\n     }\n \n-    /// For a global BytePos compute the local offset within the containing FileMap\n-    pub fn lookup_byte_offset(&self, bpos: BytePos) -> FileMapAndBytePos {\n+    /// For a global BytePos compute the local offset within the containing SourceFile\n+    pub fn lookup_byte_offset(&self, bpos: BytePos) -> SourceFileAndBytePos {\n         let idx = self.lookup_filemap_idx(bpos);\n         let fm = (*self.files.borrow().file_maps)[idx].clone();\n         let offset = bpos - fm.start_pos;\n-        FileMapAndBytePos {fm: fm, pos: offset}\n+        SourceFileAndBytePos {fm: fm, pos: offset}\n     }\n \n     /// Converts an absolute BytePos to a CharPos relative to the filemap.\n     pub fn bytepos_to_file_charpos(&self, bpos: BytePos) -> CharPos {\n         let idx = self.lookup_filemap_idx(bpos);\n         let map = &(*self.files.borrow().file_maps)[idx];\n \n-        // The number of extra bytes due to multibyte chars in the FileMap\n+        // The number of extra bytes due to multibyte chars in the SourceFile\n         let mut total_extra_bytes = 0;\n \n         for mbc in map.multibyte_chars.iter() {\n@@ -966,7 +966,7 @@ impl SourceMapper for SourceMap {\n         }\n         sp\n     }\n-    fn ensure_filemap_source_present(&self, file_map: Lrc<FileMap>) -> bool {\n+    fn ensure_filemap_source_present(&self, file_map: Lrc<SourceFile>) -> bool {\n         file_map.add_external_src(\n             || match file_map.name {\n                 FileName::Real(ref name) => self.file_loader.read_file(name).ok(),\n@@ -1192,7 +1192,7 @@ mod tests {\n     /// `substring` in `source_text`.\n     trait SourceMapExtension {\n         fn span_substr(&self,\n-                    file: &Lrc<FileMap>,\n+                    file: &Lrc<SourceFile>,\n                     source_text: &str,\n                     substring: &str,\n                     n: usize)\n@@ -1201,7 +1201,7 @@ mod tests {\n \n     impl SourceMapExtension for SourceMap {\n         fn span_substr(&self,\n-                    file: &Lrc<FileMap>,\n+                    file: &Lrc<SourceFile>,\n                     source_text: &str,\n                     substring: &str,\n                     n: usize)"}, {"sha": "a4b19681164b8047b4175b984227fad13e979a5a", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf", "patch": "@@ -802,7 +802,7 @@ fn mk_stmts_let(cx: &ExtCtxt, sp: Span) -> Vec<ast::Stmt> {\n     // they happen to have a compiler on hand). Over all, the phase distinction\n     // just makes quotes \"hard to attribute\". Possibly this could be fixed\n     // by recreating some of the original qq machinery in the tt regime\n-    // (pushing fake FileMaps onto the parser to account for original sites\n+    // (pushing fake SourceFiles onto the parser to account for original sites\n     // of quotes, for example) but at this point it seems not likely to be\n     // worth the hassle.\n "}, {"sha": "a090083f60831a8990ef2d5ccffbfabe02033cff", "filename": "src/libsyntax/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibsyntax%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibsyntax%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson.rs?ref=d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf", "patch": "@@ -340,7 +340,7 @@ impl DiagnosticSpan {\n }\n \n impl DiagnosticSpanLine {\n-    fn line_from_filemap(fm: &syntax_pos::FileMap,\n+    fn line_from_filemap(fm: &syntax_pos::SourceFile,\n                          index: usize,\n                          h_start: usize,\n                          h_end: usize)"}, {"sha": "654ac6923381e55d6bfeb31dfaa77d86d10d7ba1", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf", "patch": "@@ -49,7 +49,7 @@ pub struct StringReader<'a> {\n     pub pos: BytePos,\n     /// The current character (which has been read from self.pos)\n     pub ch: Option<char>,\n-    pub filemap: Lrc<syntax_pos::FileMap>,\n+    pub filemap: Lrc<syntax_pos::SourceFile>,\n     /// Stop reading src at this index.\n     pub end_src_index: usize,\n     // cached:\n@@ -180,7 +180,7 @@ impl<'a> StringReader<'a> {\n     }\n \n     /// For comments.rs, which hackily pokes into next_pos and ch\n-    fn new_raw(sess: &'a ParseSess, filemap: Lrc<syntax_pos::FileMap>, override_span: Option<Span>)\n+    fn new_raw(sess: &'a ParseSess, filemap: Lrc<syntax_pos::SourceFile>, override_span: Option<Span>)\n         -> Self\n     {\n         let mut sr = StringReader::new_raw_internal(sess, filemap, override_span);\n@@ -189,7 +189,7 @@ impl<'a> StringReader<'a> {\n         sr\n     }\n \n-    fn new_raw_internal(sess: &'a ParseSess, filemap: Lrc<syntax_pos::FileMap>,\n+    fn new_raw_internal(sess: &'a ParseSess, filemap: Lrc<syntax_pos::SourceFile>,\n         override_span: Option<Span>) -> Self\n     {\n         if filemap.src.is_none() {\n@@ -221,7 +221,7 @@ impl<'a> StringReader<'a> {\n         }\n     }\n \n-    pub fn new(sess: &'a ParseSess, filemap: Lrc<syntax_pos::FileMap>, override_span: Option<Span>)\n+    pub fn new(sess: &'a ParseSess, filemap: Lrc<syntax_pos::SourceFile>, override_span: Option<Span>)\n         -> Self\n     {\n         let mut sr = StringReader::new_raw(sess, filemap, override_span);\n@@ -468,7 +468,7 @@ impl<'a> StringReader<'a> {\n     }\n \n     /// Advance the StringReader by one character. If a newline is\n-    /// discovered, add it to the FileMap's list of line start offsets.\n+    /// discovered, add it to the SourceFile's list of line start offsets.\n     crate fn bump(&mut self) {\n         let next_src_index = self.src_index(self.next_pos);\n         if next_src_index < self.end_src_index {"}, {"sha": "65bab94c6bc2732a143e8d36b81854cecdd13ae4", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf", "patch": "@@ -14,7 +14,7 @@ use rustc_data_structures::sync::{Lrc, Lock};\n use ast::{self, CrateConfig, NodeId};\n use early_buffered_lints::{BufferedEarlyLint, BufferedEarlyLintId};\n use codemap::{SourceMap, FilePathMapping};\n-use syntax_pos::{Span, FileMap, FileName, MultiSpan};\n+use syntax_pos::{Span, SourceFile, FileName, MultiSpan};\n use errors::{Handler, ColorConfig, DiagnosticBuilder};\n use feature_gate::UnstableFeatures;\n use parse::parser::Parser;\n@@ -203,7 +203,7 @@ crate fn new_sub_parser_from_file<'a>(sess: &'a ParseSess,\n }\n \n /// Given a filemap and config, return a parser\n-fn filemap_to_parser(sess: & ParseSess, filemap: Lrc<FileMap>) -> Parser {\n+fn filemap_to_parser(sess: & ParseSess, filemap: Lrc<SourceFile>) -> Parser {\n     let end_pos = filemap.end_pos;\n     let mut parser = stream_to_parser(sess, filemap_to_stream(sess, filemap, None));\n \n@@ -226,7 +226,7 @@ pub fn new_parser_from_tts(sess: &ParseSess, tts: Vec<TokenTree>) -> Parser {\n /// Given a session and a path and an optional span (for error reporting),\n /// add the path to the session's codemap and return the new filemap.\n fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n-                   -> Lrc<FileMap> {\n+                   -> Lrc<SourceFile> {\n     match sess.codemap().load_file(path) {\n         Ok(filemap) => filemap,\n         Err(e) => {\n@@ -240,7 +240,7 @@ fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n }\n \n /// Given a filemap, produce a sequence of token-trees\n-pub fn filemap_to_stream(sess: &ParseSess, filemap: Lrc<FileMap>, override_span: Option<Span>)\n+pub fn filemap_to_stream(sess: &ParseSess, filemap: Lrc<SourceFile>, override_span: Option<Span>)\n                          -> TokenStream {\n     let mut srdr = lexer::StringReader::new(sess, filemap, override_span);\n     srdr.real_token();"}, {"sha": "b85fbae587a380b7919f5a01a1c52a7fcd6dcae7", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf", "patch": "@@ -20,7 +20,7 @@ use std::slice;\n use std::mem;\n use std::vec;\n use attr::{self, HasAttrs};\n-use syntax_pos::{self, DUMMY_SP, NO_EXPANSION, Span, FileMap, BytePos};\n+use syntax_pos::{self, DUMMY_SP, NO_EXPANSION, Span, SourceFile, BytePos};\n \n use codemap::{self, SourceMap, ExpnInfo, MacroAttribute, dummy_spanned};\n use errors;"}, {"sha": "6ae1ada51fd80508fa9468ca53f03c4348d07bb6", "filename": "src/libsyntax_pos/analyze_filemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibsyntax_pos%2Fanalyze_filemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibsyntax_pos%2Fanalyze_filemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fanalyze_filemap.rs?ref=d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf", "patch": "@@ -12,7 +12,7 @@ use unicode_width::UnicodeWidthChar;\n use super::*;\n \n /// Find all newlines, multi-byte characters, and non-narrow characters in a\n-/// FileMap.\n+/// SourceFile.\n ///\n /// This function will use an SSE2 enhanced implementation if hardware support\n /// is detected at runtime."}, {"sha": "5ab44b025e27dca06d29333aab805745fe2e1a52", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf", "patch": "@@ -163,7 +163,7 @@ impl FileName {\n \n /// Spans represent a region of code, used for error reporting. Positions in spans\n /// are *absolute* positions from the beginning of the codemap, not positions\n-/// relative to FileMaps. Methods on the SourceMap can be used to relate spans back\n+/// relative to SourceFiles. Methods on the SourceMap can be used to relate spans back\n /// to the original source.\n /// You must be careful if the span crosses more than one file - you will not be\n /// able to use many of the functions on spans in codemap and you cannot assume\n@@ -675,7 +675,7 @@ impl From<Vec<Span>> for MultiSpan {\n \n pub const NO_EXPANSION: SyntaxContext = SyntaxContext::empty();\n \n-/// Identifies an offset of a multi-byte character in a FileMap\n+/// Identifies an offset of a multi-byte character in a SourceFile\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Eq, PartialEq, Debug)]\n pub struct MultiByteChar {\n     /// The absolute offset of the character in the SourceMap\n@@ -684,7 +684,7 @@ pub struct MultiByteChar {\n     pub bytes: u8,\n }\n \n-/// Identifies an offset of a non-narrow character in a FileMap\n+/// Identifies an offset of a non-narrow character in a SourceFile\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Eq, PartialEq, Debug)]\n pub enum NonNarrowChar {\n     /// Represents a zero-width character\n@@ -748,7 +748,7 @@ impl Sub<BytePos> for NonNarrowChar {\n     }\n }\n \n-/// The state of the lazy external source loading mechanism of a FileMap.\n+/// The state of the lazy external source loading mechanism of a SourceFile.\n #[derive(PartialEq, Eq, Clone)]\n pub enum ExternalSource {\n     /// The external source has been loaded already.\n@@ -757,7 +757,7 @@ pub enum ExternalSource {\n     AbsentOk,\n     /// A failed attempt has been made to load the external source.\n     AbsentErr,\n-    /// No external source has to be loaded, since the FileMap represents a local crate.\n+    /// No external source has to be loaded, since the SourceFile represents a local crate.\n     Unneeded,\n }\n \n@@ -779,17 +779,17 @@ impl ExternalSource {\n \n /// A single source in the SourceMap.\n #[derive(Clone)]\n-pub struct FileMap {\n+pub struct SourceFile {\n     /// The name of the file that the source came from, source that doesn't\n     /// originate from files has names between angle brackets by convention,\n     /// e.g. `<anon>`\n     pub name: FileName,\n     /// True if the `name` field above has been modified by --remap-path-prefix\n     pub name_was_remapped: bool,\n     /// The unmapped path of the file that the source came from.\n-    /// Set to `None` if the FileMap was imported from an external crate.\n+    /// Set to `None` if the SourceFile was imported from an external crate.\n     pub unmapped_path: Option<FileName>,\n-    /// Indicates which crate this FileMap was imported from.\n+    /// Indicates which crate this SourceFile was imported from.\n     pub crate_of_origin: u32,\n     /// The complete source code\n     pub src: Option<Lrc<String>>,\n@@ -812,9 +812,9 @@ pub struct FileMap {\n     pub name_hash: u128,\n }\n \n-impl Encodable for FileMap {\n+impl Encodable for SourceFile {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_struct(\"FileMap\", 8, |s| {\n+        s.emit_struct(\"SourceFile\", 8, |s| {\n             s.emit_struct_field(\"name\", 0, |s| self.name.encode(s))?;\n             s.emit_struct_field(\"name_was_remapped\", 1, |s| self.name_was_remapped.encode(s))?;\n             s.emit_struct_field(\"src_hash\", 2, |s| self.src_hash.encode(s))?;\n@@ -879,10 +879,10 @@ impl Encodable for FileMap {\n     }\n }\n \n-impl Decodable for FileMap {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<FileMap, D::Error> {\n+impl Decodable for SourceFile {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<SourceFile, D::Error> {\n \n-        d.read_struct(\"FileMap\", 8, |d| {\n+        d.read_struct(\"SourceFile\", 8, |d| {\n             let name: FileName = d.read_struct_field(\"name\", 0, |d| Decodable::decode(d))?;\n             let name_was_remapped: bool =\n                 d.read_struct_field(\"name_was_remapped\", 1, |d| Decodable::decode(d))?;\n@@ -925,7 +925,7 @@ impl Decodable for FileMap {\n                 d.read_struct_field(\"non_narrow_chars\", 8, |d| Decodable::decode(d))?;\n             let name_hash: u128 =\n                 d.read_struct_field(\"name_hash\", 9, |d| Decodable::decode(d))?;\n-            Ok(FileMap {\n+            Ok(SourceFile {\n                 name,\n                 name_was_remapped,\n                 unmapped_path: None,\n@@ -947,18 +947,18 @@ impl Decodable for FileMap {\n     }\n }\n \n-impl fmt::Debug for FileMap {\n+impl fmt::Debug for SourceFile {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"FileMap({})\", self.name)\n+        write!(fmt, \"SourceFile({})\", self.name)\n     }\n }\n \n-impl FileMap {\n+impl SourceFile {\n     pub fn new(name: FileName,\n                name_was_remapped: bool,\n                unmapped_path: FileName,\n                mut src: String,\n-               start_pos: BytePos) -> FileMap {\n+               start_pos: BytePos) -> SourceFile {\n         remove_bom(&mut src);\n \n         let src_hash = {\n@@ -976,7 +976,7 @@ impl FileMap {\n         let (lines, multibyte_chars, non_narrow_chars) =\n             analyze_filemap::analyze_filemap(&src[..], start_pos);\n \n-        FileMap {\n+        SourceFile {\n             name,\n             name_was_remapped,\n             unmapped_path: Some(unmapped_path),\n@@ -1081,7 +1081,7 @@ impl FileMap {\n     }\n \n     /// Find the line containing the given position. The return value is the\n-    /// index into the `lines` array of this FileMap, not the 1-based line\n+    /// index into the `lines` array of this SourceFile, not the 1-based line\n     /// number. If the filemap is empty or the position is located before the\n     /// first line, None is returned.\n     pub fn lookup_line(&self, pos: BytePos) -> Option<usize> {\n@@ -1226,14 +1226,14 @@ impl Sub for CharPos {\n }\n \n // _____________________________________________________________________________\n-// Loc, LocWithOpt, FileMapAndLine, FileMapAndBytePos\n+// Loc, LocWithOpt, SourceFileAndLine, SourceFileAndBytePos\n //\n \n /// A source code location used for error reporting\n #[derive(Debug, Clone)]\n pub struct Loc {\n     /// Information about the original source\n-    pub file: Lrc<FileMap>,\n+    pub file: Lrc<SourceFile>,\n     /// The (1-based) line number\n     pub line: usize,\n     /// The (0-based) column offset\n@@ -1250,14 +1250,14 @@ pub struct LocWithOpt {\n     pub filename: FileName,\n     pub line: usize,\n     pub col: CharPos,\n-    pub file: Option<Lrc<FileMap>>,\n+    pub file: Option<Lrc<SourceFile>>,\n }\n \n // used to be structural records. Better names, anyone?\n #[derive(Debug)]\n-pub struct FileMapAndLine { pub fm: Lrc<FileMap>, pub line: usize }\n+pub struct SourceFileAndLine { pub fm: Lrc<SourceFile>, pub line: usize }\n #[derive(Debug)]\n-pub struct FileMapAndBytePos { pub fm: Lrc<FileMap>, pub pos: BytePos }\n+pub struct SourceFileAndBytePos { pub fm: Lrc<SourceFile>, pub pos: BytePos }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub struct LineInfo {\n@@ -1272,7 +1272,7 @@ pub struct LineInfo {\n }\n \n pub struct FileLines {\n-    pub file: Lrc<FileMap>,\n+    pub file: Lrc<SourceFile>,\n     pub lines: Vec<LineInfo>\n }\n "}, {"sha": "75fe6d9511cab3fc9798affec127e31d43db6725", "filename": "src/test/incremental/remove_source_file/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Ftest%2Fincremental%2Fremove_source_file%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf/src%2Ftest%2Fincremental%2Fremove_source_file%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fremove_source_file%2Fmain.rs?ref=d6dcbcd4e11a1b787a9db1fa43a49907e8bccecf", "patch": "@@ -13,7 +13,7 @@\n \n // revisions:cfail1 cfail2\n \n-// Note that we specify -g so that the FileMaps actually get referenced by the\n+// Note that we specify -g so that the SourceFiles actually get referenced by the\n // incr. comp. cache:\n // compile-flags: -Z query-dep-graph -g\n // compile-pass"}]}