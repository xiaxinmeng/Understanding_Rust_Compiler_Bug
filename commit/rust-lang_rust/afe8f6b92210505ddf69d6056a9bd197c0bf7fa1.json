{"sha": "afe8f6b92210505ddf69d6056a9bd197c0bf7fa1", "node_id": "C_kwDOAAsO6NoAKGFmZThmNmI5MjIxMDUwNWRkZjY5ZDYwNTZhOWJkMTk3YzBiZjdmYTE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-05T12:29:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-05T12:29:06Z"}, "message": "Auto merge of #13379 - DropDemBits:ide-assists-format-args-capture, r=Veykril\n\ninternal: Migrate `ide_assists::utils` and `ide_assists::handlers` to use format arg captures (part 1)\n\nThis not only serves as making future migration to mutable syntax trees easier, it also finds out what needs to be migrated in the first place.\n\n~~Aside from the first commit, subsequent commits are structured to only deal with one file/handler at a time.~~\n\nThis is the first of 3 PRs, migrating:\n\nUtils:\n\n- `gen_trait_fn_body`\n- `render_snippet`\n- `ReferenceConversion`\n  - `convert_type`\n  - `getter`\n\nHandlers:\n\n- `add_explicit_type`\n- `add_return_type`\n- `add_turbo_fish`\n- `apply_demorgan`\n- `auto_import`\n- `convert_comment_block`\n- `convert_integer_literal`\n- `convert_into_to_from`\n- `convert_iter_for_each_to_for`\n- `convert_let_else_to_match`\n- `convert_tuple_struct_to_named_struct`\n- `convert_two_arm_bool_match_to_matches_macro`\n- `destructure_tuple_binding`\n- `extract_function`\n- `extract_module`\n- `extract_struct_from_enum_variant`\n- `extract_type_alias`\n- `extract_variable`\n- `fix_visibility`", "tree": {"sha": "dba9e2b34b3b997b02c013e448aa06c4e0c9317b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dba9e2b34b3b997b02c013e448aa06c4e0c9317b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1", "html_url": "https://github.com/rust-lang/rust/commit/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c37e7d4afb60acbeb10808f245493e982a25651", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c37e7d4afb60acbeb10808f245493e982a25651", "html_url": "https://github.com/rust-lang/rust/commit/2c37e7d4afb60acbeb10808f245493e982a25651"}, {"sha": "d439fb2bc89581aef419114dffde693b44bf088f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d439fb2bc89581aef419114dffde693b44bf088f", "html_url": "https://github.com/rust-lang/rust/commit/d439fb2bc89581aef419114dffde693b44bf088f"}], "stats": {"total": 323, "additions": 158, "deletions": 165}, "files": [{"sha": "b5f99726fe1c8a815a5656e07e7dc73b57366b71", "filename": "crates/ide-assists/src/handlers/add_explicit_type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs?ref=afe8f6b92210505ddf69d6056a9bd197c0bf7fa1", "patch": "@@ -69,14 +69,14 @@ pub(crate) fn add_explicit_type(acc: &mut Assists, ctx: &AssistContext<'_>) -> O\n     let inferred_type = ty.display_source_code(ctx.db(), module.into()).ok()?;\n     acc.add(\n         AssistId(\"add_explicit_type\", AssistKind::RefactorRewrite),\n-        format!(\"Insert explicit type `{}`\", inferred_type),\n+        format!(\"Insert explicit type `{inferred_type}`\"),\n         pat_range,\n         |builder| match ascribed_ty {\n             Some(ascribed_ty) => {\n                 builder.replace(ascribed_ty.syntax().text_range(), inferred_type);\n             }\n             None => {\n-                builder.insert(pat_range.end(), format!(\": {}\", inferred_type));\n+                builder.insert(pat_range.end(), format!(\": {inferred_type}\"));\n             }\n         },\n     )"}, {"sha": "89040a8569e63cb200ae5986c59e903e5693313c", "filename": "crates/ide-assists/src/handlers/add_return_type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_return_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_return_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_return_type.rs?ref=afe8f6b92210505ddf69d6056a9bd197c0bf7fa1", "patch": "@@ -35,16 +35,16 @@ pub(crate) fn add_return_type(acc: &mut Assists, ctx: &AssistContext<'_>) -> Opt\n             match builder_edit_pos {\n                 InsertOrReplace::Insert(insert_pos, needs_whitespace) => {\n                     let preceeding_whitespace = if needs_whitespace { \" \" } else { \"\" };\n-                    builder.insert(insert_pos, &format!(\"{}-> {} \", preceeding_whitespace, ty))\n+                    builder.insert(insert_pos, &format!(\"{preceeding_whitespace}-> {ty} \"))\n                 }\n                 InsertOrReplace::Replace(text_range) => {\n-                    builder.replace(text_range, &format!(\"-> {}\", ty))\n+                    builder.replace(text_range, &format!(\"-> {ty}\"))\n                 }\n             }\n             if let FnType::Closure { wrap_expr: true } = fn_type {\n                 cov_mark::hit!(wrap_closure_non_block_expr);\n                 // `|x| x` becomes `|x| -> T x` which is invalid, so wrap it in a block\n-                builder.replace(tail_expr.syntax().text_range(), &format!(\"{{{}}}\", tail_expr));\n+                builder.replace(tail_expr.syntax().text_range(), &format!(\"{{{tail_expr}}}\"));\n             }\n         },\n     )"}, {"sha": "acf82e4b257943df6e974a934beb6f6f3d454feb", "filename": "crates/ide-assists/src/handlers/add_turbo_fish.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs?ref=afe8f6b92210505ddf69d6056a9bd197c0bf7fa1", "patch": "@@ -93,12 +93,13 @@ pub(crate) fn add_turbo_fish(acc: &mut Assists, ctx: &AssistContext<'_>) -> Opti\n             builder.trigger_signature_help();\n             match ctx.config.snippet_cap {\n                 Some(cap) => {\n-                    let snip = format!(\"::<{}>\", get_snippet_fish_head(number_of_arguments));\n+                    let fish_head = get_snippet_fish_head(number_of_arguments);\n+                    let snip = format!(\"::<{fish_head}>\");\n                     builder.insert_snippet(cap, ident.text_range().end(), snip)\n                 }\n                 None => {\n                     let fish_head = std::iter::repeat(\"_\").take(number_of_arguments).format(\", \");\n-                    let snip = format!(\"::<{}>\", fish_head);\n+                    let snip = format!(\"::<{fish_head}>\");\n                     builder.insert(ident.text_range().end(), snip);\n                 }\n             }\n@@ -109,7 +110,7 @@ pub(crate) fn add_turbo_fish(acc: &mut Assists, ctx: &AssistContext<'_>) -> Opti\n /// This will create a snippet string with tabstops marked\n fn get_snippet_fish_head(number_of_arguments: usize) -> String {\n     let mut fish_head = (1..number_of_arguments)\n-        .format_with(\"\", |i, f| f(&format_args!(\"${{{}:_}}, \", i)))\n+        .format_with(\"\", |i, f| f(&format_args!(\"${{{i}:_}}, \")))\n         .to_string();\n \n     // tabstop 0 is a special case and always the last one"}, {"sha": "57cfa17cc8e13ae7fe39b15347416f3d045bf553", "filename": "crates/ide-assists/src/handlers/apply_demorgan.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs?ref=afe8f6b92210505ddf69d6056a9bd197c0bf7fa1", "patch": "@@ -123,20 +123,20 @@ pub(crate) fn apply_demorgan(acc: &mut Assists, ctx: &AssistContext<'_>) -> Opti\n                     let lhs_range = lhs.syntax().text_range();\n                     let not_lhs = invert_boolean_expression(lhs);\n \n-                    edit.replace(lhs_range, format!(\"!({}\", not_lhs.syntax().text()));\n+                    edit.replace(lhs_range, format!(\"!({not_lhs}\"));\n                 }\n \n                 if let Some(rhs) = terms.pop_back() {\n                     let rhs_range = rhs.syntax().text_range();\n                     let not_rhs = invert_boolean_expression(rhs);\n \n-                    edit.replace(rhs_range, format!(\"{})\", not_rhs.syntax().text()));\n+                    edit.replace(rhs_range, format!(\"{not_rhs})\"));\n                 }\n \n                 for term in terms {\n                     let term_range = term.syntax().text_range();\n                     let not_term = invert_boolean_expression(term);\n-                    edit.replace(term_range, not_term.syntax().text());\n+                    edit.replace(term_range, not_term.to_string());\n                 }\n             }\n         },"}, {"sha": "a689270bc0915b13a62253c92fbe62623618ab42", "filename": "crates/ide-assists/src/handlers/auto_import.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=afe8f6b92210505ddf69d6056a9bd197c0bf7fa1", "patch": "@@ -127,18 +127,20 @@ pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<\n         .sort_by_key(|import| Reverse(relevance_score(ctx, import, current_module.as_ref())));\n \n     for import in proposed_imports {\n+        let import_path = import.import_path;\n+\n         acc.add_group(\n             &group_label,\n             AssistId(\"auto_import\", AssistKind::QuickFix),\n-            format!(\"Import `{}`\", import.import_path),\n+            format!(\"Import `{import_path}`\"),\n             range,\n             |builder| {\n                 let scope = match scope.clone() {\n                     ImportScope::File(it) => ImportScope::File(builder.make_mut(it)),\n                     ImportScope::Module(it) => ImportScope::Module(builder.make_mut(it)),\n                     ImportScope::Block(it) => ImportScope::Block(builder.make_mut(it)),\n                 };\n-                insert_use(&scope, mod_path_to_ast(&import.import_path), &ctx.config.insert_use);\n+                insert_use(&scope, mod_path_to_ast(&import_path), &ctx.config.insert_use);\n             },\n         );\n     }"}, {"sha": "312cb65abd2a1ce5d7699db05308bbb912c92981", "filename": "crates/ide-assists/src/handlers/convert_comment_block.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_comment_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_comment_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_comment_block.rs?ref=afe8f6b92210505ddf69d6056a9bd197c0bf7fa1", "patch": "@@ -54,16 +54,17 @@ fn block_to_line(acc: &mut Assists, comment: ast::Comment) -> Option<()> {\n \n             let indent_spaces = indentation.to_string();\n             let output = lines\n-                .map(|l| l.trim_start_matches(&indent_spaces))\n-                .map(|l| {\n+                .map(|line| {\n+                    let line = line.trim_start_matches(&indent_spaces);\n+\n                     // Don't introduce trailing whitespace\n-                    if l.is_empty() {\n+                    if line.is_empty() {\n                         line_prefix.to_string()\n                     } else {\n-                        format!(\"{} {}\", line_prefix, l.trim_start_matches(&indent_spaces))\n+                        format!(\"{line_prefix} {line}\")\n                     }\n                 })\n-                .join(&format!(\"\\n{}\", indent_spaces));\n+                .join(&format!(\"\\n{indent_spaces}\"));\n \n             edit.replace(target, output)\n         },\n@@ -96,7 +97,7 @@ fn line_to_block(acc: &mut Assists, comment: ast::Comment) -> Option<()> {\n             let block_prefix =\n                 CommentKind { shape: CommentShape::Block, ..comment.kind() }.prefix();\n \n-            let output = format!(\"{}\\n{}\\n{}*/\", block_prefix, block_comment_body, indentation);\n+            let output = format!(\"{block_prefix}\\n{block_comment_body}\\n{indentation}*/\");\n \n             edit.replace(target, output)\n         },"}, {"sha": "ff2195f7e6c4a2ebf6829889b3336eb52570c779", "filename": "crates/ide-assists/src/handlers/convert_integer_literal.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_integer_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_integer_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_integer_literal.rs?ref=afe8f6b92210505ddf69d6056a9bd197c0bf7fa1", "patch": "@@ -32,19 +32,19 @@ pub(crate) fn convert_integer_literal(acc: &mut Assists, ctx: &AssistContext<'_>\n         }\n \n         let mut converted = match target_radix {\n-            Radix::Binary => format!(\"0b{:b}\", value),\n-            Radix::Octal => format!(\"0o{:o}\", value),\n+            Radix::Binary => format!(\"0b{value:b}\"),\n+            Radix::Octal => format!(\"0o{value:o}\"),\n             Radix::Decimal => value.to_string(),\n-            Radix::Hexadecimal => format!(\"0x{:X}\", value),\n+            Radix::Hexadecimal => format!(\"0x{value:X}\"),\n         };\n \n-        let label = format!(\"Convert {} to {}{}\", literal, converted, suffix.unwrap_or_default());\n-\n         // Appends the type suffix back into the new literal if it exists.\n         if let Some(suffix) = suffix {\n             converted.push_str(suffix);\n         }\n \n+        let label = format!(\"Convert {literal} to {converted}\");\n+\n         acc.add_group(\n             &group_id,\n             AssistId(\"convert_integer_literal\", AssistKind::RefactorInline),"}, {"sha": "872b52c98fff2fbf5a3e56d1c27165eb2bdb61f9", "filename": "crates/ide-assists/src/handlers/convert_into_to_from.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_into_to_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_into_to_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_into_to_from.rs?ref=afe8f6b92210505ddf69d6056a9bd197c0bf7fa1", "patch": "@@ -86,9 +86,9 @@ pub(crate) fn convert_into_to_from(acc: &mut Assists, ctx: &AssistContext<'_>) -\n         impl_.syntax().text_range(),\n         |builder| {\n             builder.replace(src_type.syntax().text_range(), dest_type.to_string());\n-            builder.replace(ast_trait.syntax().text_range(), format!(\"From<{}>\", src_type));\n+            builder.replace(ast_trait.syntax().text_range(), format!(\"From<{src_type}>\"));\n             builder.replace(into_fn_return.syntax().text_range(), \"-> Self\");\n-            builder.replace(into_fn_params.syntax().text_range(), format!(\"(val: {})\", src_type));\n+            builder.replace(into_fn_params.syntax().text_range(), format!(\"(val: {src_type})\"));\n             builder.replace(into_fn_name.syntax().text_range(), \"from\");\n \n             for s in selfs {"}, {"sha": "80eecf4a09868980f94d68b7ed8854674bcd2eee", "filename": "crates/ide-assists/src/handlers/convert_iter_for_each_to_for.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs?ref=afe8f6b92210505ddf69d6056a9bd197c0bf7fa1", "patch": "@@ -119,19 +119,19 @@ pub(crate) fn convert_for_loop_with_for_each(\n             {\n                 // We have either \"for x in &col\" and col implements a method called iter\n                 //             or \"for x in &mut col\" and col implements a method called iter_mut\n-                format_to!(buf, \"{}.{}()\", expr_behind_ref, method);\n+                format_to!(buf, \"{expr_behind_ref}.{method}()\");\n             } else if let ast::Expr::RangeExpr(..) = iterable {\n                 // range expressions need to be parenthesized for the syntax to be correct\n-                format_to!(buf, \"({})\", iterable);\n+                format_to!(buf, \"({iterable})\");\n             } else if impls_core_iter(&ctx.sema, &iterable) {\n-                format_to!(buf, \"{}\", iterable);\n+                format_to!(buf, \"{iterable}\");\n             } else if let ast::Expr::RefExpr(_) = iterable {\n-                format_to!(buf, \"({}).into_iter()\", iterable);\n+                format_to!(buf, \"({iterable}).into_iter()\");\n             } else {\n-                format_to!(buf, \"{}.into_iter()\", iterable);\n+                format_to!(buf, \"{iterable}.into_iter()\");\n             }\n \n-            format_to!(buf, \".for_each(|{}| {});\", pat, body);\n+            format_to!(buf, \".for_each(|{pat}| {body});\");\n \n             builder.replace(for_loop.syntax().text_range(), buf)\n         },"}, {"sha": "c82a3b53032595217e7f7b69f12557829c644574", "filename": "crates/ide-assists/src/handlers/convert_let_else_to_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_let_else_to_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_let_else_to_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_let_else_to_match.rs?ref=afe8f6b92210505ddf69d6056a9bd197c0bf7fa1", "patch": "@@ -80,7 +80,7 @@ fn binders_to_str(binders: &[(Name, bool)], addmut: bool) -> String {\n         .map(\n             |(ident, ismut)| {\n                 if *ismut && addmut {\n-                    format!(\"mut {}\", ident)\n+                    format!(\"mut {ident}\")\n                 } else {\n                     ident.to_string()\n                 }\n@@ -93,7 +93,7 @@ fn binders_to_str(binders: &[(Name, bool)], addmut: bool) -> String {\n     } else if binders.len() == 1 {\n         vars\n     } else {\n-        format!(\"({})\", vars)\n+        format!(\"({vars})\")\n     }\n }\n \n@@ -153,7 +153,7 @@ pub(crate) fn convert_let_else_to_match(acc: &mut Assists, ctx: &AssistContext<'\n \n             let only_expr = let_else_block.statements().next().is_none();\n             let branch2 = match &let_else_block.tail_expr() {\n-                Some(tail) if only_expr => format!(\"{},\", tail.syntax().text()),\n+                Some(tail) if only_expr => format!(\"{tail},\"),\n                 _ => let_else_block.syntax().text().to_string(),\n             };\n             let replace = if binders.is_empty() {"}, {"sha": "92e091fca126c9ac3bbfe8da5a8de017f326fec8", "filename": "crates/ide-assists/src/handlers/convert_tuple_struct_to_named_struct.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs?ref=afe8f6b92210505ddf69d6056a9bd197c0bf7fa1", "patch": "@@ -226,7 +226,13 @@ fn edit_field_references(\n }\n \n fn generate_names(fields: impl Iterator<Item = ast::TupleField>) -> Vec<ast::Name> {\n-    fields.enumerate().map(|(i, _)| ast::make::name(&format!(\"field{}\", i + 1))).collect()\n+    fields\n+        .enumerate()\n+        .map(|(i, _)| {\n+            let idx = i + 1;\n+            ast::make::name(&format!(\"field{idx}\"))\n+        })\n+        .collect()\n }\n \n #[cfg(test)]"}, {"sha": "b1b0f587cd33d0edc338f93c7cdfcb66d0a7b61c", "filename": "crates/ide-assists/src/handlers/convert_two_arm_bool_match_to_matches_macro.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_two_arm_bool_match_to_matches_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_two_arm_bool_match_to_matches_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_two_arm_bool_match_to_matches_macro.rs?ref=afe8f6b92210505ddf69d6056a9bd197c0bf7fa1", "patch": "@@ -58,16 +58,16 @@ pub(crate) fn convert_two_arm_bool_match_to_matches_macro(\n         target_range,\n         |builder| {\n             let mut arm_str = String::new();\n-            if let Some(ref pat) = first_arm.pat() {\n+            if let Some(pat) = &first_arm.pat() {\n                 arm_str += &pat.to_string();\n             }\n-            if let Some(ref guard) = first_arm.guard() {\n-                arm_str += &format!(\" {}\", &guard.to_string());\n+            if let Some(guard) = &first_arm.guard() {\n+                arm_str += &format!(\" {guard}\");\n             }\n             if invert_matches {\n-                builder.replace(target_range, format!(\"!matches!({}, {})\", expr, arm_str));\n+                builder.replace(target_range, format!(\"!matches!({expr}, {arm_str})\"));\n             } else {\n-                builder.replace(target_range, format!(\"matches!({}, {})\", expr, arm_str));\n+                builder.replace(target_range, format!(\"matches!({expr}, {arm_str})\"));\n             }\n         },\n     )"}, {"sha": "31c2ce7c1b54ae93a6e16bbf4d34243b1e07d6f6", "filename": "crates/ide-assists/src/handlers/destructure_tuple_binding.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs?ref=afe8f6b92210505ddf69d6056a9bd197c0bf7fa1", "patch": "@@ -133,7 +133,7 @@ fn generate_name(\n     _usages: &Option<UsageSearchResult>,\n ) -> String {\n     // FIXME: detect if name already used\n-    format!(\"_{}\", index)\n+    format!(\"_{index}\")\n }\n \n enum RefType {\n@@ -168,12 +168,12 @@ fn edit_tuple_assignment(\n     let add_cursor = |text: &str| {\n         // place cursor on first tuple item\n         let first_tuple = &data.field_names[0];\n-        text.replacen(first_tuple, &format!(\"$0{}\", first_tuple), 1)\n+        text.replacen(first_tuple, &format!(\"$0{first_tuple}\"), 1)\n     };\n \n     // with sub_pattern: keep original tuple and add subpattern: `tup @ (_0, _1)`\n     if in_sub_pattern {\n-        let text = format!(\" @ {}\", tuple_pat);\n+        let text = format!(\" @ {tuple_pat}\");\n         match ctx.config.snippet_cap {\n             Some(cap) => {\n                 let snip = add_cursor(&text);\n@@ -314,9 +314,9 @@ struct RefData {\n impl RefData {\n     fn format(&self, field_name: &str) -> String {\n         match (self.needs_deref, self.needs_parentheses) {\n-            (true, true) => format!(\"(*{})\", field_name),\n-            (true, false) => format!(\"*{}\", field_name),\n-            (false, true) => format!(\"({})\", field_name),\n+            (true, true) => format!(\"(*{field_name})\"),\n+            (true, false) => format!(\"*{field_name}\"),\n+            (false, true) => format!(\"({field_name})\"),\n             (false, false) => field_name.to_string(),\n         }\n     }"}, {"sha": "0605883584922ee329ff9fcc879561a18b7a7c98", "filename": "crates/ide-assists/src/handlers/extract_function.rs", "status": "modified", "additions": 20, "deletions": 28, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=afe8f6b92210505ddf69d6056a9bd197c0bf7fa1", "patch": "@@ -181,7 +181,7 @@ fn make_function_name(semantics_scope: &hir::SemanticsScope<'_>) -> ast::NameRef\n     let mut counter = 0;\n     while names_in_scope.contains(&name) {\n         counter += 1;\n-        name = format!(\"{}{}\", &default_name, counter)\n+        name = format!(\"{default_name}{counter}\")\n     }\n     make::name_ref(&name)\n }\n@@ -1291,19 +1291,23 @@ fn make_call(ctx: &AssistContext<'_>, fun: &Function, indent: IndentLevel) -> St\n     match fun.outliving_locals.as_slice() {\n         [] => {}\n         [var] => {\n-            format_to!(buf, \"let {}{} = \", mut_modifier(var), var.local.name(ctx.db()))\n+            let modifier = mut_modifier(var);\n+            let name = var.local.name(ctx.db());\n+            format_to!(buf, \"let {modifier}{name} = \")\n         }\n         vars => {\n             buf.push_str(\"let (\");\n             let bindings = vars.iter().format_with(\", \", |local, f| {\n-                f(&format_args!(\"{}{}\", mut_modifier(local), local.local.name(ctx.db())))\n+                let modifier = mut_modifier(local);\n+                let name = local.local.name(ctx.db());\n+                f(&format_args!(\"{modifier}{name}\"))\n             });\n-            format_to!(buf, \"{}\", bindings);\n+            format_to!(buf, \"{bindings}\");\n             buf.push_str(\") = \");\n         }\n     }\n \n-    format_to!(buf, \"{}\", expr);\n+    format_to!(buf, \"{expr}\");\n     let insert_comma = fun\n         .body\n         .parent()\n@@ -1447,49 +1451,37 @@ fn format_function(\n     new_indent: IndentLevel,\n ) -> String {\n     let mut fn_def = String::new();\n+\n+    let fun_name = &fun.name;\n     let params = fun.make_param_list(ctx, module);\n     let ret_ty = fun.make_ret_ty(ctx, module);\n     let body = make_body(ctx, old_indent, new_indent, fun);\n     let const_kw = if fun.mods.is_const { \"const \" } else { \"\" };\n     let async_kw = if fun.control_flow.is_async { \"async \" } else { \"\" };\n     let unsafe_kw = if fun.control_flow.is_unsafe { \"unsafe \" } else { \"\" };\n     let (generic_params, where_clause) = make_generic_params_and_where_clause(ctx, fun);\n+\n+    format_to!(fn_def, \"\\n\\n{new_indent}{const_kw}{async_kw}{unsafe_kw}\");\n     match ctx.config.snippet_cap {\n-        Some(_) => format_to!(\n-            fn_def,\n-            \"\\n\\n{}{}{}{}fn $0{}\",\n-            new_indent,\n-            const_kw,\n-            async_kw,\n-            unsafe_kw,\n-            fun.name,\n-        ),\n-        None => format_to!(\n-            fn_def,\n-            \"\\n\\n{}{}{}{}fn {}\",\n-            new_indent,\n-            const_kw,\n-            async_kw,\n-            unsafe_kw,\n-            fun.name,\n-        ),\n+        Some(_) => format_to!(fn_def, \"fn $0{fun_name}\"),\n+        None => format_to!(fn_def, \"fn {fun_name}\"),\n     }\n \n     if let Some(generic_params) = generic_params {\n-        format_to!(fn_def, \"{}\", generic_params);\n+        format_to!(fn_def, \"{generic_params}\");\n     }\n \n-    format_to!(fn_def, \"{}\", params);\n+    format_to!(fn_def, \"{params}\");\n \n     if let Some(ret_ty) = ret_ty {\n-        format_to!(fn_def, \" {}\", ret_ty);\n+        format_to!(fn_def, \" {ret_ty}\");\n     }\n \n     if let Some(where_clause) = where_clause {\n-        format_to!(fn_def, \" {}\", where_clause);\n+        format_to!(fn_def, \" {where_clause}\");\n     }\n \n-    format_to!(fn_def, \" {}\", body);\n+    format_to!(fn_def, \" {body}\");\n \n     fn_def\n }"}, {"sha": "56834394aebaa8fbe7a125dc647280aa58920628", "filename": "crates/ide-assists/src/handlers/extract_module.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_module.rs?ref=afe8f6b92210505ddf69d6056a9bd197c0bf7fa1", "patch": "@@ -127,7 +127,7 @@ pub(crate) fn extract_module(acc: &mut Assists, ctx: &AssistContext<'_>) -> Opti\n             for item in items_to_be_processed {\n                 let item = item.indent(IndentLevel(1));\n                 let mut indented_item = String::new();\n-                format_to!(indented_item, \"{}{}\", new_item_indent, item.to_string());\n+                format_to!(indented_item, \"{new_item_indent}{item}\");\n                 body_items.push(indented_item);\n             }\n \n@@ -137,30 +137,28 @@ pub(crate) fn extract_module(acc: &mut Assists, ctx: &AssistContext<'_>) -> Opti\n                 let mut impl_body_def = String::new();\n \n                 if let Some(self_ty) = impl_.self_ty() {\n-                    format_to!(\n-                        impl_body_def,\n-                        \"{}impl {} {{\\n{}\\n{}}}\",\n-                        old_item_indent + 1,\n-                        self_ty.to_string(),\n-                        body,\n-                        old_item_indent + 1\n-                    );\n-\n+                    {\n+                        let impl_indent = old_item_indent + 1;\n+                        format_to!(\n+                            impl_body_def,\n+                            \"{impl_indent}impl {self_ty} {{\\n{body}\\n{impl_indent}}}\",\n+                        );\n+                    }\n                     body = impl_body_def;\n \n                     // Add the import for enum/struct corresponding to given impl block\n                     module.make_use_stmt_of_node_with_super(self_ty.syntax());\n                     for item in module.use_items {\n-                        let mut indented_item = String::new();\n-                        format_to!(indented_item, \"{}{}\", old_item_indent + 1, item.to_string());\n-                        body = format!(\"{}\\n\\n{}\", indented_item, body);\n+                        let item_indent = old_item_indent + 1;\n+                        body = format!(\"{item_indent}{item}\\n\\n{body}\");\n                     }\n                 }\n             }\n \n             let mut module_def = String::new();\n \n-            format_to!(module_def, \"mod {} {{\\n{}\\n{}}}\", module.name, body, old_item_indent);\n+            let module_name = module.name;\n+            format_to!(module_def, \"mod {module_name} {{\\n{body}\\n{old_item_indent}}}\");\n \n             let mut usages_to_be_updated_for_curr_file = vec![];\n             for usages_to_be_updated_for_file in usages_to_be_processed {\n@@ -199,7 +197,7 @@ pub(crate) fn extract_module(acc: &mut Assists, ctx: &AssistContext<'_>) -> Opti\n                     builder.delete(range);\n                 }\n \n-                builder.insert(impl_.syntax().text_range().end(), format!(\"\\n\\n{}\", module_def));\n+                builder.insert(impl_.syntax().text_range().end(), format!(\"\\n\\n{module_def}\"));\n             } else {\n                 builder.replace(module.text_range, module_def)\n             }\n@@ -343,9 +341,10 @@ impl Module {\n                 && !self.text_range.contains_range(desc.text_range())\n             {\n                 if let Some(name_ref) = ast::NameRef::cast(desc) {\n+                    let mod_name = self.name;\n                     return Some((\n                         name_ref.syntax().text_range(),\n-                        format!(\"{}::{}\", self.name, name_ref),\n+                        format!(\"{mod_name}::{name_ref}\"),\n                     ));\n                 }\n             }"}, {"sha": "b4e10667b07abe4a4bf196973bdcadd98018fe92", "filename": "crates/ide-assists/src/handlers/extract_struct_from_enum_variant.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs?ref=afe8f6b92210505ddf69d6056a9bd197c0bf7fa1", "patch": "@@ -296,10 +296,14 @@ fn create_struct_def(\n \n fn update_variant(variant: &ast::Variant, generics: Option<ast::GenericParamList>) -> Option<()> {\n     let name = variant.name()?;\n-    let ty = generics\n+    let generic_args = generics\n         .filter(|generics| generics.generic_params().count() > 0)\n-        .map(|generics| make::ty(&format!(\"{}{}\", &name.text(), generics.to_generic_args())))\n-        .unwrap_or_else(|| make::ty(&name.text()));\n+        .map(|generics| generics.to_generic_args());\n+    // FIXME: replace with a `ast::make` constructor\n+    let ty = match generic_args {\n+        Some(generic_args) => make::ty(&format!(\"{name}{generic_args}\")),\n+        None => make::ty(&name.text()),\n+    };\n \n     // change from a record to a tuple field list\n     let tuple_field = make::tuple_field(None, ty);"}, {"sha": "3116935fc5e7590c81b86632cc0ba618fc9b4ea1", "filename": "crates/ide-assists/src/handlers/extract_type_alias.rs", "status": "modified", "additions": 13, "deletions": 25, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_type_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_type_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_type_alias.rs?ref=afe8f6b92210505ddf69d6056a9bd197c0bf7fa1", "patch": "@@ -1,8 +1,7 @@\n use either::Either;\n use ide_db::syntax_helpers::node_ext::walk_ty;\n-use itertools::Itertools;\n use syntax::{\n-    ast::{self, edit::IndentLevel, AstNode, HasGenericParams, HasName},\n+    ast::{self, edit::IndentLevel, make, AstNode, HasGenericParams, HasName},\n     match_ast,\n };\n \n@@ -64,41 +63,29 @@ pub(crate) fn extract_type_alias(acc: &mut Assists, ctx: &AssistContext<'_>) ->\n                 known_generics.extend(it.generic_params());\n             }\n             let generics = collect_used_generics(&ty, &known_generics);\n+            let generic_params =\n+                generics.map(|it| make::generic_param_list(it.into_iter().cloned()));\n \n-            let replacement = if !generics.is_empty() {\n-                format!(\n-                    \"Type<{}>\",\n-                    generics.iter().format_with(\", \", |generic, f| {\n-                        match generic {\n-                            ast::GenericParam::ConstParam(cp) => f(&cp.name().unwrap()),\n-                            ast::GenericParam::LifetimeParam(lp) => f(&lp.lifetime().unwrap()),\n-                            ast::GenericParam::TypeParam(tp) => f(&tp.name().unwrap()),\n-                        }\n-                    })\n-                )\n-            } else {\n-                String::from(\"Type\")\n-            };\n+            let ty_args = generic_params\n+                .as_ref()\n+                .map_or(String::new(), |it| it.to_generic_args().to_string());\n+            let replacement = format!(\"Type{ty_args}\");\n             builder.replace(target, replacement);\n \n             let indent = IndentLevel::from_node(node);\n-            let generics = if !generics.is_empty() {\n-                format!(\"<{}>\", generics.iter().format(\", \"))\n-            } else {\n-                String::new()\n-            };\n+            let generic_params = generic_params.map_or(String::new(), |it| it.to_string());\n             match ctx.config.snippet_cap {\n                 Some(cap) => {\n                     builder.insert_snippet(\n                         cap,\n                         insert_pos,\n-                        format!(\"type $0Type{} = {};\\n\\n{}\", generics, ty, indent),\n+                        format!(\"type $0Type{generic_params} = {ty};\\n\\n{indent}\"),\n                     );\n                 }\n                 None => {\n                     builder.insert(\n                         insert_pos,\n-                        format!(\"type Type{} = {};\\n\\n{}\", generics, ty, indent),\n+                        format!(\"type Type{generic_params} = {ty};\\n\\n{indent}\"),\n                     );\n                 }\n             }\n@@ -109,7 +96,7 @@ pub(crate) fn extract_type_alias(acc: &mut Assists, ctx: &AssistContext<'_>) ->\n fn collect_used_generics<'gp>(\n     ty: &ast::Type,\n     known_generics: &'gp [ast::GenericParam],\n-) -> Vec<&'gp ast::GenericParam> {\n+) -> Option<Vec<&'gp ast::GenericParam>> {\n     // can't use a closure -> closure here cause lifetime inference fails for that\n     fn find_lifetime(text: &str) -> impl Fn(&&ast::GenericParam) -> bool + '_ {\n         move |gp: &&ast::GenericParam| match gp {\n@@ -198,7 +185,8 @@ fn collect_used_generics<'gp>(\n         ast::GenericParam::LifetimeParam(_) => 0,\n         ast::GenericParam::TypeParam(_) => 1,\n     });\n-    generics\n+\n+    Some(generics).filter(|it| it.len() > 0)\n }\n \n #[cfg(test)]"}, {"sha": "a738deffb95b302c5d02e23fc1199bb025329792", "filename": "crates/ide-assists/src/handlers/extract_variable.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_variable.rs?ref=afe8f6b92210505ddf69d6056a9bd197c0bf7fa1", "patch": "@@ -91,13 +91,13 @@ pub(crate) fn extract_variable(acc: &mut Assists, ctx: &AssistContext<'_>) -> Op\n \n             match anchor {\n                 Anchor::Before(_) | Anchor::Replace(_) => {\n-                    format_to!(buf, \"let {}{} = {}\", var_modifier, var_name, reference_modifier)\n+                    format_to!(buf, \"let {var_modifier}{var_name} = {reference_modifier}\")\n                 }\n                 Anchor::WrapInBlock(_) => {\n-                    format_to!(buf, \"{{ let {} = {}\", var_name, reference_modifier)\n+                    format_to!(buf, \"{{ let {var_name} = {reference_modifier}\")\n                 }\n             };\n-            format_to!(buf, \"{}\", to_extract.syntax());\n+            format_to!(buf, \"{to_extract}\");\n \n             if let Anchor::Replace(stmt) = anchor {\n                 cov_mark::hit!(test_extract_var_expr_stmt);\n@@ -107,8 +107,8 @@ pub(crate) fn extract_variable(acc: &mut Assists, ctx: &AssistContext<'_>) -> Op\n                 match ctx.config.snippet_cap {\n                     Some(cap) => {\n                         let snip = buf.replace(\n-                            &format!(\"let {}{}\", var_modifier, var_name),\n-                            &format!(\"let {}$0{}\", var_modifier, var_name),\n+                            &format!(\"let {var_modifier}{var_name}\"),\n+                            &format!(\"let {var_modifier}$0{var_name}\"),\n                         );\n                         edit.replace_snippet(cap, expr_range, snip)\n                     }\n@@ -135,8 +135,8 @@ pub(crate) fn extract_variable(acc: &mut Assists, ctx: &AssistContext<'_>) -> Op\n             match ctx.config.snippet_cap {\n                 Some(cap) => {\n                     let snip = buf.replace(\n-                        &format!(\"let {}{}\", var_modifier, var_name),\n-                        &format!(\"let {}$0{}\", var_modifier, var_name),\n+                        &format!(\"let {var_modifier}{var_name}\"),\n+                        &format!(\"let {var_modifier}$0{var_name}\"),\n                     );\n                     edit.insert_snippet(cap, offset, snip)\n                 }"}, {"sha": "8764543028706f9d37d068397d283d525b029d77", "filename": "crates/ide-assists/src/handlers/fix_visibility.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs?ref=afe8f6b92210505ddf69d6056a9bd197c0bf7fa1", "patch": "@@ -57,8 +57,8 @@ fn add_vis_to_referenced_module_def(acc: &mut Assists, ctx: &AssistContext<'_>)\n         if current_module.krate() == target_module.krate() { \"pub(crate)\" } else { \"pub\" };\n \n     let assist_label = match target_name {\n-        None => format!(\"Change visibility to {}\", missing_visibility),\n-        Some(name) => format!(\"Change visibility of {} to {}\", name, missing_visibility),\n+        None => format!(\"Change visibility to {missing_visibility}\"),\n+        Some(name) => format!(\"Change visibility of {name} to {missing_visibility}\"),\n     };\n \n     acc.add(AssistId(\"fix_visibility\", AssistKind::QuickFix), assist_label, target, |builder| {\n@@ -68,15 +68,15 @@ fn add_vis_to_referenced_module_def(acc: &mut Assists, ctx: &AssistContext<'_>)\n                 Some(current_visibility) => builder.replace_snippet(\n                     cap,\n                     current_visibility.syntax().text_range(),\n-                    format!(\"$0{}\", missing_visibility),\n+                    format!(\"$0{missing_visibility}\"),\n                 ),\n-                None => builder.insert_snippet(cap, offset, format!(\"$0{} \", missing_visibility)),\n+                None => builder.insert_snippet(cap, offset, format!(\"$0{missing_visibility} \")),\n             },\n             None => match current_visibility {\n                 Some(current_visibility) => {\n                     builder.replace(current_visibility.syntax().text_range(), missing_visibility)\n                 }\n-                None => builder.insert(offset, format!(\"{} \", missing_visibility)),\n+                None => builder.insert(offset, format!(\"{missing_visibility} \")),\n             },\n         }\n     })\n@@ -114,7 +114,7 @@ fn add_vis_to_referenced_record_field(acc: &mut Assists, ctx: &AssistContext<'_>\n \n     let target_name = record_field_def.name(ctx.db());\n     let assist_label =\n-        format!(\"Change visibility of {}.{} to {}\", parent_name, target_name, missing_visibility);\n+        format!(\"Change visibility of {parent_name}.{target_name} to {missing_visibility}\");\n \n     acc.add(AssistId(\"fix_visibility\", AssistKind::QuickFix), assist_label, target, |builder| {\n         builder.edit_file(target_file);\n@@ -123,15 +123,15 @@ fn add_vis_to_referenced_record_field(acc: &mut Assists, ctx: &AssistContext<'_>\n                 Some(current_visibility) => builder.replace_snippet(\n                     cap,\n                     current_visibility.syntax().text_range(),\n-                    format!(\"$0{}\", missing_visibility),\n+                    format!(\"$0{missing_visibility}\"),\n                 ),\n-                None => builder.insert_snippet(cap, offset, format!(\"$0{} \", missing_visibility)),\n+                None => builder.insert_snippet(cap, offset, format!(\"$0{missing_visibility} \")),\n             },\n             None => match current_visibility {\n                 Some(current_visibility) => {\n                     builder.replace(current_visibility.syntax().text_range(), missing_visibility)\n                 }\n-                None => builder.insert(offset, format!(\"{} \", missing_visibility)),\n+                None => builder.insert(offset, format!(\"{missing_visibility} \")),\n             },\n         }\n     })"}, {"sha": "307e67927056ba9a4eefce68b72bef495c63ac1a", "filename": "crates/ide-assists/src/utils.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Futils.rs?ref=afe8f6b92210505ddf69d6056a9bd197c0bf7fa1", "patch": "@@ -189,8 +189,8 @@ pub(crate) fn render_snippet(_cap: SnippetCap, node: &SyntaxNode, cursor: Cursor\n     let mut placeholder = cursor.node().to_string();\n     escape(&mut placeholder);\n     let tab_stop = match cursor {\n-        Cursor::Replace(placeholder) => format!(\"${{0:{}}}\", placeholder),\n-        Cursor::Before(placeholder) => format!(\"$0{}\", placeholder),\n+        Cursor::Replace(placeholder) => format!(\"${{0:{placeholder}}}\"),\n+        Cursor::Before(placeholder) => format!(\"$0{placeholder}\"),\n     };\n \n     let mut buf = node.to_string();\n@@ -539,37 +539,37 @@ impl ReferenceConversion {\n             ReferenceConversionType::AsRefSlice => {\n                 let type_argument_name =\n                     self.ty.type_arguments().next().unwrap().display(db).to_string();\n-                format!(\"&[{}]\", type_argument_name)\n+                format!(\"&[{type_argument_name}]\")\n             }\n             ReferenceConversionType::Dereferenced => {\n                 let type_argument_name =\n                     self.ty.type_arguments().next().unwrap().display(db).to_string();\n-                format!(\"&{}\", type_argument_name)\n+                format!(\"&{type_argument_name}\")\n             }\n             ReferenceConversionType::Option => {\n                 let type_argument_name =\n                     self.ty.type_arguments().next().unwrap().display(db).to_string();\n-                format!(\"Option<&{}>\", type_argument_name)\n+                format!(\"Option<&{type_argument_name}>\")\n             }\n             ReferenceConversionType::Result => {\n                 let mut type_arguments = self.ty.type_arguments();\n                 let first_type_argument_name =\n                     type_arguments.next().unwrap().display(db).to_string();\n                 let second_type_argument_name =\n                     type_arguments.next().unwrap().display(db).to_string();\n-                format!(\"Result<&{}, &{}>\", first_type_argument_name, second_type_argument_name)\n+                format!(\"Result<&{first_type_argument_name}, &{second_type_argument_name}>\")\n             }\n         }\n     }\n \n     pub(crate) fn getter(&self, field_name: String) -> String {\n         match self.conversion {\n-            ReferenceConversionType::Copy => format!(\"self.{}\", field_name),\n+            ReferenceConversionType::Copy => format!(\"self.{field_name}\"),\n             ReferenceConversionType::AsRefStr\n             | ReferenceConversionType::AsRefSlice\n             | ReferenceConversionType::Dereferenced\n             | ReferenceConversionType::Option\n-            | ReferenceConversionType::Result => format!(\"self.{}.as_ref()\", field_name),\n+            | ReferenceConversionType::Result => format!(\"self.{field_name}.as_ref()\"),\n         }\n     }\n }"}, {"sha": "6c87e66c134d72a28642c8e614d0e372e63073fc", "filename": "crates/ide-assists/src/utils/gen_trait_fn_body.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afe8f6b92210505ddf69d6056a9bd197c0bf7fa1/crates%2Fide-assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs?ref=afe8f6b92210505ddf69d6056a9bd197c0bf7fa1", "patch": "@@ -41,7 +41,7 @@ fn gen_clone_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n             let mut arms = vec![];\n             for variant in list.variants() {\n                 let name = variant.name()?;\n-                let variant_name = make::ext::path_from_idents([\"Self\", &format!(\"{}\", name)])?;\n+                let variant_name = make::ext::path_from_idents([\"Self\", &format!(\"{name}\")])?;\n \n                 match variant.field_list() {\n                     // => match self { Self::Name { x } => Self::Name { x: x.clone() } }\n@@ -70,7 +70,7 @@ fn gen_clone_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                         let mut pats = vec![];\n                         let mut fields = vec![];\n                         for (i, _) in list.fields().enumerate() {\n-                            let field_name = format!(\"arg{}\", i);\n+                            let field_name = format!(\"arg{i}\");\n                             let pat = make::ident_pat(false, false, make::name(&field_name));\n                             pats.push(pat.into());\n \n@@ -118,7 +118,7 @@ fn gen_clone_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                     let mut fields = vec![];\n                     for (i, _) in field_list.fields().enumerate() {\n                         let f_path = make::expr_path(make::ext::ident_path(\"self\"));\n-                        let target = make::expr_field(f_path, &format!(\"{}\", i));\n+                        let target = make::expr_field(f_path, &format!(\"{i}\"));\n                         fields.push(gen_clone_call(target));\n                     }\n                     let struct_name = make::expr_path(make::ext::ident_path(\"Self\"));\n@@ -151,15 +151,15 @@ fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n             let mut arms = vec![];\n             for variant in list.variants() {\n                 let name = variant.name()?;\n-                let variant_name = make::ext::path_from_idents([\"Self\", &format!(\"{}\", name)])?;\n+                let variant_name = make::ext::path_from_idents([\"Self\", &format!(\"{name}\")])?;\n                 let target = make::expr_path(make::ext::ident_path(\"f\"));\n \n                 match variant.field_list() {\n                     Some(ast::FieldList::RecordFieldList(list)) => {\n                         // => f.debug_struct(name)\n                         let target = make::expr_path(make::ext::ident_path(\"f\"));\n                         let method = make::name_ref(\"debug_struct\");\n-                        let struct_name = format!(\"\\\"{}\\\"\", name);\n+                        let struct_name = format!(\"\\\"{name}\\\"\");\n                         let args = make::arg_list(Some(make::expr_literal(&struct_name).into()));\n                         let mut expr = make::expr_method_call(target, method, args);\n \n@@ -173,8 +173,8 @@ fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n \n                             // => <expr>.field(\"field_name\", field)\n                             let method_name = make::name_ref(\"field\");\n-                            let name = make::expr_literal(&(format!(\"\\\"{}\\\"\", field_name))).into();\n-                            let path = &format!(\"{}\", field_name);\n+                            let name = make::expr_literal(&(format!(\"\\\"{field_name}\\\"\"))).into();\n+                            let path = &format!(\"{field_name}\");\n                             let path = make::expr_path(make::ext::ident_path(path));\n                             let args = make::arg_list(vec![name, path]);\n                             expr = make::expr_method_call(expr, method_name, args);\n@@ -192,13 +192,13 @@ fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                         // => f.debug_tuple(name)\n                         let target = make::expr_path(make::ext::ident_path(\"f\"));\n                         let method = make::name_ref(\"debug_tuple\");\n-                        let struct_name = format!(\"\\\"{}\\\"\", name);\n+                        let struct_name = format!(\"\\\"{name}\\\"\");\n                         let args = make::arg_list(Some(make::expr_literal(&struct_name).into()));\n                         let mut expr = make::expr_method_call(target, method, args);\n \n                         let mut pats = vec![];\n                         for (i, _) in list.fields().enumerate() {\n-                            let name = format!(\"arg{}\", i);\n+                            let name = format!(\"arg{i}\");\n \n                             // create a field pattern for use in `MyStruct(fields..)`\n                             let field_name = make::name(&name);\n@@ -222,7 +222,7 @@ fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                         arms.push(make::match_arm(Some(pat.into()), None, expr));\n                     }\n                     None => {\n-                        let fmt_string = make::expr_literal(&(format!(\"\\\"{}\\\"\", name))).into();\n+                        let fmt_string = make::expr_literal(&(format!(\"\\\"{name}\\\"\"))).into();\n                         let args = make::arg_list([target, fmt_string]);\n                         let macro_name = make::expr_path(make::ext::ident_path(\"write\"));\n                         let macro_call = make::expr_macro_call(macro_name, args);\n@@ -244,7 +244,7 @@ fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n         }\n \n         ast::Adt::Struct(strukt) => {\n-            let name = format!(\"\\\"{}\\\"\", annotated_name);\n+            let name = format!(\"\\\"{annotated_name}\\\"\");\n             let args = make::arg_list(Some(make::expr_literal(&name).into()));\n             let target = make::expr_path(make::ext::ident_path(\"f\"));\n \n@@ -258,10 +258,10 @@ fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                     let mut expr = make::expr_method_call(target, method, args);\n                     for field in field_list.fields() {\n                         let name = field.name()?;\n-                        let f_name = make::expr_literal(&(format!(\"\\\"{}\\\"\", name))).into();\n+                        let f_name = make::expr_literal(&(format!(\"\\\"{name}\\\"\"))).into();\n                         let f_path = make::expr_path(make::ext::ident_path(\"self\"));\n                         let f_path = make::expr_ref(f_path, false);\n-                        let f_path = make::expr_field(f_path, &format!(\"{}\", name));\n+                        let f_path = make::expr_field(f_path, &format!(\"{name}\"));\n                         let args = make::arg_list([f_name, f_path]);\n                         expr = make::expr_method_call(expr, make::name_ref(\"field\"), args);\n                     }\n@@ -275,7 +275,7 @@ fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                     for (i, _) in field_list.fields().enumerate() {\n                         let f_path = make::expr_path(make::ext::ident_path(\"self\"));\n                         let f_path = make::expr_ref(f_path, false);\n-                        let f_path = make::expr_field(f_path, &format!(\"{}\", i));\n+                        let f_path = make::expr_field(f_path, &format!(\"{i}\"));\n                         let method = make::name_ref(\"field\");\n                         expr = make::expr_method_call(expr, method, make::arg_list(Some(f_path)));\n                     }\n@@ -379,7 +379,7 @@ fn gen_hash_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                 let mut stmts = vec![];\n                 for (i, _) in field_list.fields().enumerate() {\n                     let base = make::expr_path(make::ext::ident_path(\"self\"));\n-                    let target = make::expr_field(base, &format!(\"{}\", i));\n+                    let target = make::expr_field(base, &format!(\"{i}\"));\n                     stmts.push(gen_hash_call(target));\n                 }\n                 make::block_expr(stmts, None).indent(ast::edit::IndentLevel(1))\n@@ -453,10 +453,10 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                         for field in list.fields() {\n                             let field_name = field.name()?.to_string();\n \n-                            let l_name = &format!(\"l_{}\", field_name);\n+                            let l_name = &format!(\"l_{field_name}\");\n                             l_fields.push(gen_record_pat_field(&field_name, l_name));\n \n-                            let r_name = &format!(\"r_{}\", field_name);\n+                            let r_name = &format!(\"r_{field_name}\");\n                             r_fields.push(gen_record_pat_field(&field_name, r_name));\n \n                             let lhs = make::expr_path(make::ext::ident_path(l_name));\n@@ -484,12 +484,12 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                         let mut r_fields = vec![];\n \n                         for (i, _) in list.fields().enumerate() {\n-                            let field_name = format!(\"{}\", i);\n+                            let field_name = format!(\"{i}\");\n \n-                            let l_name = format!(\"l{}\", field_name);\n+                            let l_name = format!(\"l{field_name}\");\n                             l_fields.push(gen_tuple_field(&l_name));\n \n-                            let r_name = format!(\"r{}\", field_name);\n+                            let r_name = format!(\"r{field_name}\");\n                             r_fields.push(gen_tuple_field(&r_name));\n \n                             let lhs = make::expr_path(make::ext::ident_path(&l_name));\n@@ -548,7 +548,7 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n             Some(ast::FieldList::TupleFieldList(field_list)) => {\n                 let mut expr = None;\n                 for (i, _) in field_list.fields().enumerate() {\n-                    let idx = format!(\"{}\", i);\n+                    let idx = format!(\"{i}\");\n                     let lhs = make::expr_path(make::ext::ident_path(\"self\"));\n                     let lhs = make::expr_field(lhs, &idx);\n                     let rhs = make::expr_path(make::ext::ident_path(\"other\"));\n@@ -628,7 +628,7 @@ fn gen_partial_ord(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n             Some(ast::FieldList::TupleFieldList(field_list)) => {\n                 let mut exprs = vec![];\n                 for (i, _) in field_list.fields().enumerate() {\n-                    let idx = format!(\"{}\", i);\n+                    let idx = format!(\"{i}\");\n                     let lhs = make::expr_path(make::ext::ident_path(\"self\"));\n                     let lhs = make::expr_field(lhs, &idx);\n                     let rhs = make::expr_path(make::ext::ident_path(\"other\"));"}]}