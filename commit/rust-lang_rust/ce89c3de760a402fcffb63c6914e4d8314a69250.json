{"sha": "ce89c3de760a402fcffb63c6914e4d8314a69250", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlODljM2RlNzYwYTQwMmZjZmZiNjNjNjkxNGU0ZDgzMTRhNjkyNTA=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-02-14T10:28:39Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-02-14T11:54:00Z"}, "message": "Rollup merge of #48035 - technicalguy:Early-exit-empty-hashmap-38880, r=arthurprs\n\nEarly exit for empty HashMap (issue #38880)\n\nAddresses issue #38880 by checking if the HashMap is empty before computing the value of the hash.\n\nBefore (integer keys)\n```\nrunning 4 tests\ntest empty_once ... bench:          13 ns/iter (+/- 0)\ntest empty_100  ... bench:       1,367 ns/iter (+/- 35)\ntest exist_once ... bench:          14 ns/iter (+/- 0)\ntest exist_100  ... bench:       1,518 ns/iter (+/- 40)\n```\n\nAfter\n```\nrunning 4 tests\ntest empty_once ... bench:           2 ns/iter (+/- 0)\ntest empty_100  ... bench:         221 ns/iter (+/- 0)\ntest exist_once ... bench:          15 ns/iter (+/- 0)\ntest exist_100  ... bench:       1,515 ns/iter (+/- 92)\n```\n\nWhen the HashMap is not empty, the performance remains the same, and when it is empty the performance is significantly improved.", "tree": {"sha": "9eafff1d9b6d8c9e35df38aed6e7aafa3c5f085d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9eafff1d9b6d8c9e35df38aed6e7aafa3c5f085d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce89c3de760a402fcffb63c6914e4d8314a69250", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAlqEI1kACgkQ/vbIBR0O\nATyQ3g/9FzVsuiwcXQBxLPUSHb9GnMhbgIK+4rLWxD7OYvO9Su/hXRRNfYzjlz48\n1Zlr47sZneV26aUZGUNEqJ6lZLel4Aj3RvmXpVIQ6EqcZoDRxjG6GuoLULhBnL5g\njR1ttpIEKl81IS8b9IwU2841PFSRAFPPofCYbm/JSk+fDNP/K2z+45bQyFUIB5nv\nSo5UiQU8xdXVt9H05qM1AOH77GLctqrkFFd2dK86vEDAuSE7lqZ7cK1qf05ix6gG\n6xiUXQ7KQVf5G/VI2Je4c4hc85gxJnj/PVHG5zCwOAHYeCNImUCRx0oZ46KW98Qn\nj4S4U2r4ZS2MxK4tD4KfmhGkbUL4FDWRRS54MEkZ8JGHEs2Kgo9Gnmuhlb507dRi\n0RzjUmMuQk8LqacZw3YRtkLFyY/1xKTrI+m8sQHDX6RYer/hRWJfccUipB/2Z1UD\njGLFV0cOYjo3VFAXSmD5rYA9PHlWG2fjpZarhe2nGOWlu82tvl5ETuAp1cql/KIT\nYGJCSJLWSVT9GrD1bkq596sQXh3kqpUePIDxlNWBGkdCUA1lSLKUlUiKrJjMggC1\nxws3XfNhZCM3HmN3z8lYEEPKqlHvCQqV8n7Yg6kODFG3ZupnaHxkp9slpcAjjJsv\nEDjmt7q7rzDIQyx6u6Uu525J2rvI2Jc72tpo7YEb5rcC6srYM8Y=\n=G7NS\n-----END PGP SIGNATURE-----", "payload": "tree 9eafff1d9b6d8c9e35df38aed6e7aafa3c5f085d\nparent 6436c44201711280615b84ed07f387c2d3fb10ea\nparent e034dddb32cd9814d9f71bb2b444f9863fba2dfc\nauthor kennytm <kennytm@gmail.com> 1518604119 +0800\ncommitter kennytm <kennytm@gmail.com> 1518609240 +0800\n\nRollup merge of #48035 - technicalguy:Early-exit-empty-hashmap-38880, r=arthurprs\n\nEarly exit for empty HashMap (issue #38880)\n\nAddresses issue #38880 by checking if the HashMap is empty before computing the value of the hash.\n\nBefore (integer keys)\n```\nrunning 4 tests\ntest empty_once ... bench:          13 ns/iter (+/- 0)\ntest empty_100  ... bench:       1,367 ns/iter (+/- 35)\ntest exist_once ... bench:          14 ns/iter (+/- 0)\ntest exist_100  ... bench:       1,518 ns/iter (+/- 40)\n```\n\nAfter\n```\nrunning 4 tests\ntest empty_once ... bench:           2 ns/iter (+/- 0)\ntest empty_100  ... bench:         221 ns/iter (+/- 0)\ntest exist_once ... bench:          15 ns/iter (+/- 0)\ntest exist_100  ... bench:       1,515 ns/iter (+/- 92)\n```\n\nWhen the HashMap is not empty, the performance remains the same, and when it is empty the performance is significantly improved.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce89c3de760a402fcffb63c6914e4d8314a69250", "html_url": "https://github.com/rust-lang/rust/commit/ce89c3de760a402fcffb63c6914e4d8314a69250", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce89c3de760a402fcffb63c6914e4d8314a69250/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6436c44201711280615b84ed07f387c2d3fb10ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/6436c44201711280615b84ed07f387c2d3fb10ea", "html_url": "https://github.com/rust-lang/rust/commit/6436c44201711280615b84ed07f387c2d3fb10ea"}, {"sha": "e034dddb32cd9814d9f71bb2b444f9863fba2dfc", "url": "https://api.github.com/repos/rust-lang/rust/commits/e034dddb32cd9814d9f71bb2b444f9863fba2dfc", "html_url": "https://github.com/rust-lang/rust/commit/e034dddb32cd9814d9f71bb2b444f9863fba2dfc"}], "stats": {"total": 64, "additions": 38, "deletions": 26}, "files": [{"sha": "a82ff915093c6ca0952bee2f672bb4cbb7e85df2", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 38, "deletions": 26, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/ce89c3de760a402fcffb63c6914e4d8314a69250/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce89c3de760a402fcffb63c6914e4d8314a69250/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=ce89c3de760a402fcffb63c6914e4d8314a69250", "patch": "@@ -398,8 +398,9 @@ pub struct HashMap<K, V, S = RandomState> {\n }\n \n /// Search for a pre-hashed key.\n+/// If you don't already know the hash, use search or search_mut instead\n #[inline]\n-fn search_hashed<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F) -> InternalEntry<K, V, M>\n+fn search_hashed<K, V, M, F>(table: M, hash: SafeHash, is_match: F) -> InternalEntry<K, V, M>\n     where M: Deref<Target = RawTable<K, V>>,\n           F: FnMut(&K) -> bool\n {\n@@ -410,6 +411,18 @@ fn search_hashed<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F) -> Inter\n         return InternalEntry::TableIsEmpty;\n     }\n \n+    search_hashed_nonempty(table, hash, is_match)\n+}\n+\n+/// Search for a pre-hashed key when the hash map is known to be non-empty.\n+#[inline]\n+fn search_hashed_nonempty<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F)\n+    -> InternalEntry<K, V, M>\n+    where M: Deref<Target = RawTable<K, V>>,\n+          F: FnMut(&K) -> bool\n+{\n+    // Do not check the capacity as an extra branch could slow the lookup.\n+\n     let size = table.size();\n     let mut probe = Bucket::new(table, hash);\n     let mut displacement = 0;\n@@ -543,24 +556,36 @@ impl<K, V, S> HashMap<K, V, S>\n     }\n \n     /// Search for a key, yielding the index if it's found in the hashtable.\n-    /// If you already have the hash for the key lying around, use\n-    /// search_hashed.\n+    /// If you already have the hash for the key lying around, or if you need an\n+    /// InternalEntry, use search_hashed or search_hashed_nonempty.\n     #[inline]\n-    fn search<'a, Q: ?Sized>(&'a self, q: &Q) -> InternalEntry<K, V, &'a RawTable<K, V>>\n+    fn search<'a, Q: ?Sized>(&'a self, q: &Q)\n+        -> Option<FullBucket<K, V, &'a RawTable<K, V>>>\n         where K: Borrow<Q>,\n               Q: Eq + Hash\n     {\n+        if self.is_empty() {\n+            return None;\n+        }\n+\n         let hash = self.make_hash(q);\n-        search_hashed(&self.table, hash, |k| q.eq(k.borrow()))\n+        search_hashed_nonempty(&self.table, hash, |k| q.eq(k.borrow()))\n+            .into_occupied_bucket()\n     }\n \n     #[inline]\n-    fn search_mut<'a, Q: ?Sized>(&'a mut self, q: &Q) -> InternalEntry<K, V, &'a mut RawTable<K, V>>\n+    fn search_mut<'a, Q: ?Sized>(&'a mut self, q: &Q)\n+        -> Option<FullBucket<K, V, &'a mut RawTable<K, V>>>\n         where K: Borrow<Q>,\n               Q: Eq + Hash\n     {\n+        if self.is_empty() {\n+            return None;\n+        }\n+\n         let hash = self.make_hash(q);\n-        search_hashed(&mut self.table, hash, |k| q.eq(k.borrow()))\n+        search_hashed_nonempty(&mut self.table, hash, |k| q.eq(k.borrow()))\n+            .into_occupied_bucket()\n     }\n \n     // The caller should ensure that invariants by Robin Hood Hashing hold\n@@ -1118,7 +1143,7 @@ impl<K, V, S> HashMap<K, V, S>\n         where K: Borrow<Q>,\n               Q: Hash + Eq\n     {\n-        self.search(k).into_occupied_bucket().map(|bucket| bucket.into_refs().1)\n+        self.search(k).map(|bucket| bucket.into_refs().1)\n     }\n \n     /// Returns true if the map contains a value for the specified key.\n@@ -1145,7 +1170,7 @@ impl<K, V, S> HashMap<K, V, S>\n         where K: Borrow<Q>,\n               Q: Hash + Eq\n     {\n-        self.search(k).into_occupied_bucket().is_some()\n+        self.search(k).is_some()\n     }\n \n     /// Returns a mutable reference to the value corresponding to the key.\n@@ -1174,7 +1199,7 @@ impl<K, V, S> HashMap<K, V, S>\n         where K: Borrow<Q>,\n               Q: Hash + Eq\n     {\n-        self.search_mut(k).into_occupied_bucket().map(|bucket| bucket.into_mut_refs().1)\n+        self.search_mut(k).map(|bucket| bucket.into_mut_refs().1)\n     }\n \n     /// Inserts a key-value pair into the map.\n@@ -1234,11 +1259,7 @@ impl<K, V, S> HashMap<K, V, S>\n         where K: Borrow<Q>,\n               Q: Hash + Eq\n     {\n-        if self.table.size() == 0 {\n-            return None;\n-        }\n-\n-        self.search_mut(k).into_occupied_bucket().map(|bucket| pop_internal(bucket).1)\n+        self.search_mut(k).map(|bucket| pop_internal(bucket).1)\n     }\n \n     /// Removes a key from the map, returning the stored key and value if the\n@@ -1269,12 +1290,7 @@ impl<K, V, S> HashMap<K, V, S>\n         where K: Borrow<Q>,\n               Q: Hash + Eq\n     {\n-        if self.table.size() == 0 {\n-            return None;\n-        }\n-\n         self.search_mut(k)\n-            .into_occupied_bucket()\n             .map(|bucket| {\n                 let (k, v, _) = pop_internal(bucket);\n                 (k, v)\n@@ -2632,15 +2648,11 @@ impl<K, S, Q: ?Sized> super::Recover<Q> for HashMap<K, (), S>\n \n     #[inline]\n     fn get(&self, key: &Q) -> Option<&K> {\n-        self.search(key).into_occupied_bucket().map(|bucket| bucket.into_refs().0)\n+        self.search(key).map(|bucket| bucket.into_refs().0)\n     }\n \n     fn take(&mut self, key: &Q) -> Option<K> {\n-        if self.table.size() == 0 {\n-            return None;\n-        }\n-\n-        self.search_mut(key).into_occupied_bucket().map(|bucket| pop_internal(bucket).0)\n+        self.search_mut(key).map(|bucket| pop_internal(bucket).0)\n     }\n \n     #[inline]"}]}