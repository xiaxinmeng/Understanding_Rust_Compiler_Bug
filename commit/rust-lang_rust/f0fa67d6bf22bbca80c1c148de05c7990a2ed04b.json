{"sha": "f0fa67d6bf22bbca80c1c148de05c7990a2ed04b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwZmE2N2Q2YmYyMmJiY2E4MGMxYzE0OGRlMDVjNzk5MGEyZWQwNGI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-11T03:08:07Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-11T05:24:55Z"}, "message": "doc: Fold information from the memory model interlude in the tutorial elsewhere", "tree": {"sha": "0e6e4ad52d218bb57c082e041d3c40b9bec08d60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e6e4ad52d218bb57c082e041d3c40b9bec08d60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0fa67d6bf22bbca80c1c148de05c7990a2ed04b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0fa67d6bf22bbca80c1c148de05c7990a2ed04b", "html_url": "https://github.com/rust-lang/rust/commit/f0fa67d6bf22bbca80c1c148de05c7990a2ed04b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0fa67d6bf22bbca80c1c148de05c7990a2ed04b/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039", "html_url": "https://github.com/rust-lang/rust/commit/ca71c6ec5bb8106121cbe33eec5a6a9ca7786039"}], "stats": {"total": 60, "additions": 51, "deletions": 9}, "files": [{"sha": "e26651508efc59763220a89d9b5a2b00009ee37c", "filename": "doc/tutorial.md", "status": "modified", "additions": 51, "deletions": 9, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/f0fa67d6bf22bbca80c1c148de05c7990a2ed04b/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/f0fa67d6bf22bbca80c1c148de05c7990a2ed04b/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=f0fa67d6bf22bbca80c1c148de05c7990a2ed04b", "patch": "@@ -863,11 +863,34 @@ allocating memory and indirecting through a pointer. But for big structs, or\n those with mutable fields, it can be useful to have a single copy on\n the stack or on the heap, and refer to that through a pointer.\n \n-Rust supports several types of pointers. The safe pointer types are\n-`@T`, for managed boxes allocated on the local heap, `~T`, for\n-uniquely-owned boxes allocated on the exchange heap, and `&T`, for\n-borrowed pointers, which may point to any memory, and whose lifetimes\n-are governed by the call stack.\n+Whenever memory is allocated on the heap, the program needs a strategy to\n+dispose of the memory when no longer needed. Most languages, such as Java or\n+Python, use *garbage collection* for this, a strategy in which the program\n+periodically searches for allocations that are no longer reachable in order\n+to dispose of them. Other languages, such as C, use *manual memory\n+management*, which relies on the programmer to specify when memory should be\n+reclaimed.\n+\n+Rust is in a different position. It differs from the garbage-collected\n+environments in that allows the programmer to choose the disposal\n+strategy on an object-by-object basis. Not only does this have benefits for\n+performance, but we will later see that this model has benefits for\n+concurrency as well, by making it possible for the Rust compiler to detect\n+data races at compile time. Rust also differs from the manually managed\n+languages in that it is *safe*\u2014it uses a [pointer lifetime\n+analysis][borrow] to ensure that manual memory management cannot cause memory\n+errors at runtime.\n+\n+[borrow]: tutorial-borrowed-ptr.html\n+\n+The cornerstone of Rust's memory management is the concept of a *smart\n+pointer*\u2014a pointer type that indicates the lifetime of the object it points\n+to. This solution is familiar to C++ programmers; Rust differs from C++,\n+however, in that a small set of smart pointers are built into the language.\n+The safe pointer types are `@T`, for *managed* boxes allocated on the *local\n+heap*, `~T`, for *uniquely-owned* boxes allocated on the *exchange\n+heap*, and `&T`, for *borrowed* pointers, which may point to any memory, and\n+whose lifetimes are governed by the call stack.\n \n All pointer types can be dereferenced with the `*` unary operator.\n \n@@ -919,7 +942,17 @@ node2.next = SomeNode(node3);\n node3.prev = SomeNode(node2);\n ~~~\n \n-Managed boxes never cross task boundaries.\n+Managed boxes never cross task boundaries. This has several benefits for\n+performance:\n+\n+* The Rust garbage collector does not need to stop multiple threads in order\n+  to collect garbage.\n+\n+* You can separate your application into \"real-time\" tasks that do not use\n+  the garbage collector and \"non-real-time\" tasks that do, and the real-time\n+  tasks will not be interrupted by the non-real-time tasks.\n+\n+C++ programmers will recognize `@T` as similar to `std::shared_ptr<T>`.\n \n > ***Note:*** Currently, the Rust compiler generates code to reclaim\n > managed boxes through reference counting and a cycle collector, but\n@@ -956,10 +989,19 @@ let z = *x + *y;\n assert z == 20;\n ~~~~\n \n-Owned boxes, when they do not contain any managed boxes, can be sent\n-to other tasks. The sending task will give up ownership of the box,\n+When they do not contain any managed boxes, owned boxes can be sent\n+to other tasks. The sending task will give up ownership of the box\n and won't be able to access it afterwards. The receiving task will\n-become the sole owner of the box.\n+become the sole owner of the box. This prevents *data races*\u2014errors\n+that could otherwise result from multiple tasks working on the same\n+data without synchronization.\n+\n+When an owned pointer goes out of scope or is overwritten, the object\n+it points to is immediately freed. Effective use of owned boxes can\n+therefore be an efficient alternative to garbage collection.\n+\n+C++ programmers will recognize `~T` as similar to `std::unique_ptr<T>`\n+(or `std::auto_ptr<T>` in C++03 and below).\n \n ## Borrowed pointers\n "}]}