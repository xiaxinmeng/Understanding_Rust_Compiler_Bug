{"sha": "bd979c1fbf11ffb5b3ff42ca31aa2bfae3082ec6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkOTc5YzFmYmYxMWZmYjViM2ZmNDJjYTMxYWEyYmZhZTMwODJlYzY=", "commit": {"author": {"name": "gareth", "email": "gareth@gareth-N56VM.(none)", "date": "2013-05-02T20:19:12Z"}, "committer": {"name": "gareth", "email": "gareth@gareth-N56VM.(none)", "date": "2013-05-02T20:19:12Z"}, "message": "Fix some issues with test_destroy_actually_kills:\n- it is now cross platform, instead of just unix\n- it now avoids sleeping (fixing issue #6156)\n- it now calls force_destroy() when force = true (was a bug)", "tree": {"sha": "fa28455e97055b3ce760427487a5c6b5e7622ee5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa28455e97055b3ce760427487a5c6b5e7622ee5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd979c1fbf11ffb5b3ff42ca31aa2bfae3082ec6", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd979c1fbf11ffb5b3ff42ca31aa2bfae3082ec6", "html_url": "https://github.com/rust-lang/rust/commit/bd979c1fbf11ffb5b3ff42ca31aa2bfae3082ec6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd979c1fbf11ffb5b3ff42ca31aa2bfae3082ec6/comments", "author": null, "committer": null, "parents": [{"sha": "23e97ae89303f7e8933dce0c42de08d214bad066", "url": "https://api.github.com/repos/rust-lang/rust/commits/23e97ae89303f7e8933dce0c42de08d214bad066", "html_url": "https://github.com/rust-lang/rust/commit/23e97ae89303f7e8933dce0c42de08d214bad066"}], "stats": {"total": 52, "additions": 38, "deletions": 14}, "files": [{"sha": "7e73b3a3f80be398244e4629b711538416c5f3b7", "filename": "src/libcore/run.rs", "status": "modified", "additions": 38, "deletions": 14, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/bd979c1fbf11ffb5b3ff42ca31aa2bfae3082ec6/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd979c1fbf11ffb5b3ff42ca31aa2bfae3082ec6/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=bd979c1fbf11ffb5b3ff42ca31aa2bfae3082ec6", "patch": "@@ -781,7 +781,6 @@ mod tests {\n     use libc;\n     use option::None;\n     use os;\n-    use path::Path;\n     use run::{readclose, writeclose};\n     use run;\n \n@@ -870,34 +869,59 @@ mod tests {\n         p.destroy(); // ...and nor should this (and nor should the destructor)\n     }\n \n-    #[cfg(unix)] // there is no way to sleep on windows from inside libcore...\n     fn test_destroy_actually_kills(force: bool) {\n-        let path = Path(fmt!(\"test/core-run-test-destroy-actually-kills-%?.tmp\", force));\n \n-        os::remove_file(&path);\n+        #[cfg(unix)]\n+        static BLOCK_COMMAND: &'static str = \"cat\";\n \n-        let cmd = fmt!(\"sleep 5 && echo MurderDeathKill > %s\", path.to_str());\n-        let mut p = run::start_program(\"sh\", [~\"-c\", cmd]);\n+        #[cfg(windows)]\n+        static BLOCK_COMMAND: &'static str = \"cmd\";\n \n-        p.destroy(); // destroy the program before it has a chance to echo its message\n+        #[cfg(unix)]\n+        fn process_exists(pid: libc::pid_t) -> bool {\n+            run::program_output(\"ps\", [~\"-p\", pid.to_str()]).out.contains(pid.to_str())\n+        }\n \n-        unsafe {\n-            // wait to ensure the program is really destroyed and not just waiting itself\n-            libc::sleep(10);\n+        #[cfg(windows)]\n+        fn process_exists(pid: libc::pid_t) -> bool {\n+\n+            use libc::types::os::arch::extra::DWORD;\n+            use libc::funcs::extra::kernel32::{CloseHandle, GetExitCodeProcess, OpenProcess};\n+            use libc::consts::os::extra::{FALSE, PROCESS_QUERY_INFORMATION, STILL_ACTIVE };\n+\n+            unsafe {\n+                let proc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pid as DWORD);\n+                if proc.is_null() {\n+                    return false;\n+                }\n+                // proc will be non-null if the process is alive, or if it died recently\n+                let mut status = 0;\n+                GetExitCodeProcess(proc, &mut status);\n+                CloseHandle(proc);\n+                return status == STILL_ACTIVE;\n+            }\n         }\n \n-        // the program should not have had chance to echo its message\n-        assert!(!path.exists());\n+        // this program will stay alive indefinitely trying to read from stdin\n+        let mut p = run::start_program(BLOCK_COMMAND, []);\n+\n+        assert!(process_exists(p.get_id()));\n+\n+        if force {\n+            p.force_destroy();\n+        } else {\n+            p.destroy();\n+        }\n+\n+        assert!(!process_exists(p.get_id()));\n     }\n \n     #[test]\n-    #[cfg(unix)]\n     fn test_unforced_destroy_actually_kills() {\n         test_destroy_actually_kills(false);\n     }\n \n     #[test]\n-    #[cfg(unix)]\n     fn test_forced_destroy_actually_kills() {\n         test_destroy_actually_kills(true);\n     }"}]}