{"sha": "f6f8723c78cffe7cebec5b3792fcff0c81586ab8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2Zjg3MjNjNzhjZmZlN2NlYmVjNWIzNzkyZmNmZjBjODE1ODZhYjg=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-01-13T16:34:44Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-01-13T16:34:44Z"}, "message": "Merge pull request #548 from mcarton/fixes\n\nFix #433 and doc", "tree": {"sha": "ddc12e1eee5411de15b7d2ba3536a4fefe38fb6b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ddc12e1eee5411de15b7d2ba3536a4fefe38fb6b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6f8723c78cffe7cebec5b3792fcff0c81586ab8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6f8723c78cffe7cebec5b3792fcff0c81586ab8", "html_url": "https://github.com/rust-lang/rust/commit/f6f8723c78cffe7cebec5b3792fcff0c81586ab8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6f8723c78cffe7cebec5b3792fcff0c81586ab8/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e24730cb846f0fd1f5c28f5336e38be6e0143c5e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e24730cb846f0fd1f5c28f5336e38be6e0143c5e", "html_url": "https://github.com/rust-lang/rust/commit/e24730cb846f0fd1f5c28f5336e38be6e0143c5e"}, {"sha": "6fa9bf64d73d90ec35f30dcbb7d77f7418fff071", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fa9bf64d73d90ec35f30dcbb7d77f7418fff071", "html_url": "https://github.com/rust-lang/rust/commit/6fa9bf64d73d90ec35f30dcbb7d77f7418fff071"}], "stats": {"total": 296, "additions": 162, "deletions": 134}, "files": [{"sha": "db5944ab9b4c00cb4533c5a02c4bd06238fb1bf9", "filename": "Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6f8723c78cffe7cebec5b3792fcff0c81586ab8/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f6f8723c78cffe7cebec5b3792fcff0c81586ab8/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=f6f8723c78cffe7cebec5b3792fcff0c81586ab8", "patch": "@@ -29,5 +29,4 @@ rustc-serialize = \"0.3\"\n \n [features]\n \n-structured_logging = []\n debugging = []"}, {"sha": "631c1d7f1d2b0141090ac1dd540ad70ddbd95b9b", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6f8723c78cffe7cebec5b3792fcff0c81586ab8/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6f8723c78cffe7cebec5b3792fcff0c81586ab8/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=f6f8723c78cffe7cebec5b3792fcff0c81586ab8", "patch": "@@ -32,7 +32,6 @@ name\n [explicit_iter_loop](https://github.com/Manishearth/rust-clippy/wiki#explicit_iter_loop)                       | warn    | for-looping over `_.iter()` or `_.iter_mut()` when `&_` or `&mut _` would do\n [filter_next](https://github.com/Manishearth/rust-clippy/wiki#filter_next)                                     | warn    | using `filter(p).next()`, which is more succinctly expressed as `.find(p)`\n [float_cmp](https://github.com/Manishearth/rust-clippy/wiki#float_cmp)                                         | warn    | using `==` or `!=` on float values (as floating-point operations usually involve rounding errors, it is always better to check for approximate equality within small bounds)\n-[hashmap_entry](https://github.com/Manishearth/rust-clippy/wiki#hashmap_entry)                                 | warn    | use of `contains_key` followed by `insert` on a `HashMap`\n [identity_op](https://github.com/Manishearth/rust-clippy/wiki#identity_op)                                     | warn    | using identity operations, e.g. `x + 0` or `y / 1`\n [ineffective_bit_mask](https://github.com/Manishearth/rust-clippy/wiki#ineffective_bit_mask)                   | warn    | expressions where a bit mask will be rendered useless by a comparison, e.g. `(x | 1) > 2`\n [inline_always](https://github.com/Manishearth/rust-clippy/wiki#inline_always)                                 | warn    | `#[inline(always)]` is a bad idea in most cases\n@@ -43,6 +42,7 @@ name\n [let_unit_value](https://github.com/Manishearth/rust-clippy/wiki#let_unit_value)                               | warn    | creating a let binding to a value of unit type, which usually can't be used afterwards\n [linkedlist](https://github.com/Manishearth/rust-clippy/wiki#linkedlist)                                       | warn    | usage of LinkedList, usually a vector is faster, or a more specialized data structure like a VecDeque\n [map_clone](https://github.com/Manishearth/rust-clippy/wiki#map_clone)                                         | warn    | using `.map(|x| x.clone())` to clone an iterator or option's contents (recommends `.cloned()` instead)\n+[map_entry](https://github.com/Manishearth/rust-clippy/wiki#map_entry)                                         | warn    | use of `contains_key` followed by `insert` on a `HashMap` or `BTreeMap`\n [match_bool](https://github.com/Manishearth/rust-clippy/wiki#match_bool)                                       | warn    | a match on boolean expression; recommends `if..else` block instead\n [match_overlapping_arm](https://github.com/Manishearth/rust-clippy/wiki#match_overlapping_arm)                 | warn    | a match has overlapping arms\n [match_ref_pats](https://github.com/Manishearth/rust-clippy/wiki#match_ref_pats)                               | warn    | a match or `if let` has all arms prefixed with `&`; the match expression can be dereferenced instead"}, {"sha": "d9fb7269be6b8f80f19094424745f729c24cb1bf", "filename": "src/entry.rs", "status": "renamed", "additions": 40, "deletions": 30, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f6f8723c78cffe7cebec5b3792fcff0c81586ab8/src%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f8723c78cffe7cebec5b3792fcff0c81586ab8/src%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fentry.rs?ref=f6f8723c78cffe7cebec5b3792fcff0c81586ab8", "patch": "@@ -1,12 +1,13 @@\n use rustc::lint::*;\n use rustc_front::hir::*;\n use syntax::codemap::Span;\n-use utils::{get_item_name, is_exp_equal, match_type, snippet, span_help_and_lint, walk_ptrs_ty};\n-use utils::HASHMAP_PATH;\n+use utils::{get_item_name, is_exp_equal, match_type, snippet, span_lint_and_then, walk_ptrs_ty};\n+use utils::{BTREEMAP_PATH, HASHMAP_PATH};\n \n-/// **What it does:** This lint checks for uses of `contains_key` + `insert` on `HashMap`.\n+/// **What it does:** This lint checks for uses of `contains_key` + `insert` on `HashMap` or\n+/// `BTreeMap`.\n ///\n-/// **Why is this bad?** Using `HashMap::entry` is more efficient.\n+/// **Why is this bad?** Using `entry` is more efficient.\n ///\n /// **Known problems:** Some false negatives, eg.:\n /// ```\n@@ -23,17 +24,17 @@ use utils::HASHMAP_PATH;\n /// m.entry(k).or_insert(v);\n /// ```\n declare_lint! {\n-    pub HASHMAP_ENTRY,\n+    pub MAP_ENTRY,\n     Warn,\n-    \"use of `contains_key` followed by `insert` on a `HashMap`\"\n+    \"use of `contains_key` followed by `insert` on a `HashMap` or `BTreeMap`\"\n }\n \n #[derive(Copy,Clone)]\n pub struct HashMapLint;\n \n impl LintPass for HashMapLint {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(HASHMAP_ENTRY)\n+        lint_array!(MAP_ENTRY)\n     }\n }\n \n@@ -55,25 +56,33 @@ impl LateLintPass for HashMapLint {\n                 let map = &params[0];\n                 let obj_ty = walk_ptrs_ty(cx.tcx.expr_ty(map));\n \n-                if match_type(cx, obj_ty, &HASHMAP_PATH) {\n-                    let sole_expr = if then.expr.is_some() { 1 } else { 0 } + then.stmts.len() == 1;\n+                let kind = if match_type(cx, obj_ty, &BTREEMAP_PATH) {\n+                    \"BTreeMap\"\n+                }\n+                else if match_type(cx, obj_ty, &HASHMAP_PATH) {\n+                    \"HashMap\"\n+                }\n+                else {\n+                    return\n+                };\n \n-                    if let Some(ref then) = then.expr {\n-                        check_for_insert(cx, expr.span, map, key, then, sole_expr);\n-                    }\n+                let sole_expr = if then.expr.is_some() { 1 } else { 0 } + then.stmts.len() == 1;\n \n-                    for stmt in &then.stmts {\n-                        if let StmtSemi(ref stmt, _) = stmt.node {\n-                            check_for_insert(cx, expr.span, map, key, stmt, sole_expr);\n-                        }\n+                if let Some(ref then) = then.expr {\n+                    check_for_insert(cx, expr.span, map, key, then, sole_expr, kind);\n+                }\n+\n+                for stmt in &then.stmts {\n+                    if let StmtSemi(ref stmt, _) = stmt.node {\n+                        check_for_insert(cx, expr.span, map, key, stmt, sole_expr, kind);\n                     }\n                 }\n             }\n         }\n     }\n }\n \n-fn check_for_insert(cx: &LateContext, span: Span, map: &Expr, key: &Expr, expr: &Expr, sole_expr: bool) {\n+fn check_for_insert(cx: &LateContext, span: Span, map: &Expr, key: &Expr, expr: &Expr, sole_expr: bool, kind: &str) {\n     if_let_chain! {\n         [\n             let ExprMethodCall(ref name, _, ref params) = expr.node,\n@@ -82,21 +91,22 @@ fn check_for_insert(cx: &LateContext, span: Span, map: &Expr, key: &Expr, expr:\n             get_item_name(cx, map) == get_item_name(cx, &*params[0]),\n             is_exp_equal(cx, key, &params[1])\n         ], {\n-            if sole_expr {\n-                span_help_and_lint(cx, HASHMAP_ENTRY, span,\n-                                   \"usage of `contains_key` followed by `insert` on `HashMap`\",\n-                                   &format!(\"Consider using `{}.entry({}).or_insert({})`\",\n-                                            snippet(cx, map.span, \"..\"),\n-                                            snippet(cx, params[1].span, \"..\"),\n-                                            snippet(cx, params[2].span, \"..\"))); \n+            let help = if sole_expr {\n+                format!(\"{}.entry({}).or_insert({})\",\n+                        snippet(cx, map.span, \"..\"),\n+                        snippet(cx, params[1].span, \"..\"),\n+                        snippet(cx, params[2].span, \"..\"))\n             }\n             else {\n-                span_help_and_lint(cx, HASHMAP_ENTRY, span,\n-                                   \"usage of `contains_key` followed by `insert` on `HashMap`\",\n-                                   &format!(\"Consider using `{}.entry({})`\",\n-                                            snippet(cx, map.span, \"..\"),\n-                                            snippet(cx, params[1].span, \"..\")));\n-            }\n+                format!(\"{}.entry({})\",\n+                        snippet(cx, map.span, \"..\"),\n+                        snippet(cx, params[1].span, \"..\"))\n+            };\n+\n+            span_lint_and_then(cx, MAP_ENTRY, span,\n+                               &format!(\"usage of `contains_key` followed by `insert` on `{}`\", kind), |db| {\n+                db.span_suggestion(span, \"Consider using\", help.clone());\n+            });\n         }\n     }\n }", "previous_filename": "src/hashmap.rs"}, {"sha": "9bb59693795c1fe1f7af37f063446a44fe81ce0a", "filename": "src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6f8723c78cffe7cebec5b3792fcff0c81586ab8/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f8723c78cffe7cebec5b3792fcff0c81586ab8/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=f6f8723c78cffe7cebec5b3792fcff0c81586ab8", "patch": "@@ -71,7 +71,7 @@ pub mod temporary_assignment;\n pub mod transmute;\n pub mod cyclomatic_complexity;\n pub mod escape;\n-pub mod hashmap;\n+pub mod entry;\n pub mod misc_early;\n pub mod array_indexing;\n pub mod panic;\n@@ -113,7 +113,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_late_lint_pass(box types::UnitCmp);\n     reg.register_late_lint_pass(box loops::LoopsPass);\n     reg.register_late_lint_pass(box lifetimes::LifetimePass);\n-    reg.register_late_lint_pass(box hashmap::HashMapLint);\n+    reg.register_late_lint_pass(box entry::HashMapLint);\n     reg.register_late_lint_pass(box ranges::StepByZero);\n     reg.register_late_lint_pass(box types::CastPass);\n     reg.register_late_lint_pass(box types::TypeComplexityPass);\n@@ -167,10 +167,10 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         block_in_if_condition::BLOCK_IN_IF_CONDITION_STMT,\n         collapsible_if::COLLAPSIBLE_IF,\n         cyclomatic_complexity::CYCLOMATIC_COMPLEXITY,\n+        entry::MAP_ENTRY,\n         eq_op::EQ_OP,\n         escape::BOXED_LOCAL,\n         eta_reduction::REDUNDANT_CLOSURE,\n-        hashmap::HASHMAP_ENTRY,\n         identity_op::IDENTITY_OP,\n         len_zero::LEN_WITHOUT_IS_EMPTY,\n         len_zero::LEN_ZERO,"}, {"sha": "53f83d6921acd224c04eb6e695ef9c10c287d8b0", "filename": "src/utils.rs", "status": "modified", "additions": 66, "deletions": 58, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/f6f8723c78cffe7cebec5b3792fcff0c81586ab8/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f8723c78cffe7cebec5b3792fcff0c81586ab8/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=f6f8723c78cffe7cebec5b3792fcff0c81586ab8", "patch": "@@ -19,17 +19,18 @@ use std::ops::{Deref, DerefMut};\n pub type MethodArgs = HirVec<P<Expr>>;\n \n // module DefPaths for certain structs/enums we check for\n+pub const BEGIN_UNWIND: [&'static str; 3] = [\"std\", \"rt\", \"begin_unwind\"];\n+pub const BTREEMAP_PATH: [&'static str; 4] = [\"collections\", \"btree\", \"map\", \"BTreeMap\"];\n+pub const CLONE_PATH: [&'static str; 2] = [\"Clone\", \"clone\"];\n+pub const COW_PATH: [&'static str; 3] = [\"collections\", \"borrow\", \"Cow\"];\n+pub const HASHMAP_PATH: [&'static str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\"];\n+pub const LL_PATH: [&'static str; 3] = [\"collections\", \"linked_list\", \"LinkedList\"];\n+pub const MUTEX_PATH: [&'static str; 4] = [\"std\", \"sync\", \"mutex\", \"Mutex\"];\n+pub const OPEN_OPTIONS_PATH: [&'static str; 3] = [\"std\", \"fs\", \"OpenOptions\"];\n pub const OPTION_PATH: [&'static str; 3] = [\"core\", \"option\", \"Option\"];\n pub const RESULT_PATH: [&'static str; 3] = [\"core\", \"result\", \"Result\"];\n pub const STRING_PATH: [&'static str; 3] = [\"collections\", \"string\", \"String\"];\n pub const VEC_PATH: [&'static str; 3] = [\"collections\", \"vec\", \"Vec\"];\n-pub const LL_PATH: [&'static str; 3] = [\"collections\", \"linked_list\", \"LinkedList\"];\n-pub const HASHMAP_PATH: [&'static str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\"];\n-pub const OPEN_OPTIONS_PATH: [&'static str; 3] = [\"std\", \"fs\", \"OpenOptions\"];\n-pub const MUTEX_PATH: [&'static str; 4] = [\"std\", \"sync\", \"mutex\", \"Mutex\"];\n-pub const CLONE_PATH: [&'static str; 2] = [\"Clone\", \"clone\"];\n-pub const BEGIN_UNWIND: [&'static str; 3] = [\"std\", \"rt\", \"begin_unwind\"];\n-pub const COW_PATH: [&'static str; 3] = [\"collections\", \"borrow\", \"Cow\"];\n \n /// Produce a nested chain of if-lets and ifs from the patterns:\n ///\n@@ -77,20 +78,21 @@ macro_rules! if_let_chain {\n     };\n }\n \n-/// Returns true if the two spans come from differing expansions (i.e. one is from a macro and one isn't)\n+/// Returns true if the two spans come from differing expansions (i.e. one is from a macro and one\n+/// isn't).\n pub fn differing_macro_contexts(sp1: Span, sp2: Span) -> bool {\n     sp1.expn_id != sp2.expn_id\n }\n-/// returns true if this expn_info was expanded by any macro\n+/// Returns true if this `expn_info` was expanded by any macro.\n pub fn in_macro<T: LintContext>(cx: &T, span: Span) -> bool {\n     cx.sess().codemap().with_expn_info(span.expn_id, |info| info.is_some())\n }\n \n-/// returns true if the macro that expanded the crate was outside of\n-/// the current crate or was a compiler plugin\n+/// Returns true if the macro that expanded the crate was outside of the current crate or was a\n+/// compiler plugin.\n pub fn in_external_macro<T: LintContext>(cx: &T, span: Span) -> bool {\n-    /// invokes in_macro with the expansion info of the given span\n-    /// slightly heavy, try to use this after other checks have already happened\n+    /// Invokes in_macro with the expansion info of the given span slightly heavy, try to use this\n+    /// after other checks have already happened.\n     fn in_macro_ext<T: LintContext>(cx: &T, opt_info: Option<&ExpnInfo>) -> bool {\n         // no ExpnInfo = no macro\n         opt_info.map_or(false, |info| {\n@@ -109,25 +111,28 @@ pub fn in_external_macro<T: LintContext>(cx: &T, span: Span) -> bool {\n     cx.sess().codemap().with_expn_info(span.expn_id, |info| in_macro_ext(cx, info))\n }\n \n-/// check if a DefId's path matches the given absolute type path\n-/// usage e.g. with\n-/// `match_def_path(cx, id, &[\"core\", \"option\", \"Option\"])`\n+/// Check if a `DefId`'s path matches the given absolute type path usage.\n+///\n+/// # Examples\n+/// ```\n+/// match_def_path(cx, id, &[\"core\", \"option\", \"Option\"])\n+/// ```\n pub fn match_def_path(cx: &LateContext, def_id: DefId, path: &[&str]) -> bool {\n     cx.tcx.with_path(def_id, |iter| {\n         iter.zip(path)\n             .all(|(nm, p)| nm.name().as_str() == *p)\n     })\n }\n \n-/// check if type is struct or enum type with given def path\n+/// Check if type is struct or enum type with given def path.\n pub fn match_type(cx: &LateContext, ty: ty::Ty, path: &[&str]) -> bool {\n     match ty.sty {\n         ty::TyEnum(ref adt, _) | ty::TyStruct(ref adt, _) => match_def_path(cx, adt.did, path),\n         _ => false,\n     }\n }\n \n-/// check if method call given in \"expr\" belongs to given trait\n+/// Check if the method call given in `expr` belongs to given trait.\n pub fn match_impl_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool {\n     let method_call = ty::MethodCall::expr(expr.id);\n \n@@ -144,9 +149,10 @@ pub fn match_impl_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool {\n     }\n }\n \n-/// check if method call given in \"expr\" belongs to given trait\n+/// Check if the method call given in `expr` belongs to given trait.\n pub fn match_trait_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool {\n     let method_call = ty::MethodCall::expr(expr.id);\n+\n     let trt_id = cx.tcx\n                    .tables\n                    .borrow()\n@@ -160,21 +166,31 @@ pub fn match_trait_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool\n     }\n }\n \n-/// match a Path against a slice of segment string literals, e.g.\n-/// `match_path(path, &[\"std\", \"rt\", \"begin_unwind\"])`\n+/// Match a `Path` against a slice of segment string literals.\n+///\n+/// # Examples\n+/// ```\n+/// match_path(path, &[\"std\", \"rt\", \"begin_unwind\"])\n+/// ```\n pub fn match_path(path: &Path, segments: &[&str]) -> bool {\n     path.segments.iter().rev().zip(segments.iter().rev()).all(|(a, b)| a.identifier.name.as_str() == *b)\n }\n \n-/// match a Path against a slice of segment string literals, e.g.\n-/// `match_path(path, &[\"std\", \"rt\", \"begin_unwind\"])`\n+/// Match a `Path` against a slice of segment string literals, e.g.\n+///\n+/// # Examples\n+/// ```\n+/// match_path(path, &[\"std\", \"rt\", \"begin_unwind\"])\n+/// ```\n pub fn match_path_ast(path: &ast::Path, segments: &[&str]) -> bool {\n     path.segments.iter().rev().zip(segments.iter().rev()).all(|(a, b)| a.identifier.name.as_str() == *b)\n }\n \n-/// match an Expr against a chain of methods, and return the matched Exprs. For example, if `expr`\n-/// represents the `.baz()` in `foo.bar().baz()`, `matched_method_chain(expr, &[\"bar\", \"baz\"])`\n-/// will return a Vec containing the Exprs for `.bar()` and `.baz()`\n+/// Match an `Expr` against a chain of methods, and return the matched `Expr`s.\n+///\n+/// For example, if `expr` represents the `.baz()` in `foo.bar().baz()`,\n+/// `matched_method_chain(expr, &[\"bar\", \"baz\"])` will return a `Vec` containing the `Expr`s for\n+/// `.bar()` and `.baz()`\n pub fn method_chain_args<'a>(expr: &'a Expr, methods: &[&str]) -> Option<Vec<&'a MethodArgs>> {\n     let mut current = expr;\n     let mut matched = Vec::with_capacity(methods.len());\n@@ -196,7 +212,7 @@ pub fn method_chain_args<'a>(expr: &'a Expr, methods: &[&str]) -> Option<Vec<&'a\n }\n \n \n-/// get the name of the item the expression is in, if available\n+/// Get the name of the item the expression is in, if available.\n pub fn get_item_name(cx: &LateContext, expr: &Expr) -> Option<Name> {\n     let parent_id = cx.tcx.map.get_parent(expr.id);\n     match cx.tcx.map.find(parent_id) {\n@@ -207,7 +223,7 @@ pub fn get_item_name(cx: &LateContext, expr: &Expr) -> Option<Name> {\n     }\n }\n \n-/// checks if a `let` decl is from a for loop desugaring\n+/// Checks if a `let` decl is from a `for` loop desugaring.\n pub fn is_from_for_desugar(decl: &Decl) -> bool {\n     if_let_chain! {\n         [\n@@ -221,31 +237,39 @@ pub fn is_from_for_desugar(decl: &Decl) -> bool {\n }\n \n \n-/// convert a span to a code snippet if available, otherwise use default, e.g.\n-/// `snippet(cx, expr.span, \"..\")`\n+/// Convert a span to a code snippet if available, otherwise use default.\n+///\n+/// # Example\n+/// ```\n+/// snippet(cx, expr.span, \"..\")\n+/// ```\n pub fn snippet<'a, T: LintContext>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n     cx.sess().codemap().span_to_snippet(span).map(From::from).unwrap_or(Cow::Borrowed(default))\n }\n \n-/// Converts a span to a code snippet. Returns None if not available.\n+/// Convert a span to a code snippet. Returns `None` if not available.\n pub fn snippet_opt<T: LintContext>(cx: &T, span: Span) -> Option<String> {\n     cx.sess().codemap().span_to_snippet(span).ok()\n }\n \n-/// convert a span (from a block) to a code snippet if available, otherwise use default, e.g.\n-/// `snippet(cx, expr.span, \"..\")`\n-/// This trims the code of indentation, except for the first line\n-/// Use it for blocks or block-like things which need to be printed as such\n+/// Convert a span (from a block) to a code snippet if available, otherwise use default.\n+/// This trims the code of indentation, except for the first line. Use it for blocks or block-like\n+/// things which need to be printed as such.\n+///\n+/// # Example\n+/// ```\n+/// snippet(cx, expr.span, \"..\")\n+/// ```\n pub fn snippet_block<'a, T: LintContext>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n     let snip = snippet(cx, span, default);\n     trim_multiline(snip, true)\n }\n \n-/// Like snippet_block, but add braces if the expr is not an ExprBlock\n-/// Also takes an Option<String> which can be put inside the braces\n+/// Like `snippet_block`, but add braces if the expr is not an `ExprBlock`.\n+/// Also takes an `Option<String>` which can be put inside the braces.\n pub fn expr_block<'a, T: LintContext>(cx: &T, expr: &Expr, option: Option<String>, default: &'a str) -> Cow<'a, str> {\n     let code = snippet_block(cx, expr.span, default);\n-    let string = option.map_or(\"\".to_owned(), |s| s);\n+    let string = option.unwrap_or_default();\n     if let ExprBlock(_) = expr.node {\n         Cow::Owned(format!(\"{}{}\", code, string))\n     } else if string.is_empty() {\n@@ -255,8 +279,7 @@ pub fn expr_block<'a, T: LintContext>(cx: &T, expr: &Expr, option: Option<String\n     }\n }\n \n-/// Trim indentation from a multiline string\n-/// with possibility of ignoring the first line\n+/// Trim indentation from a multiline string with possibility of ignoring the first line.\n pub fn trim_multiline(s: Cow<str>, ignore_first: bool) -> Cow<str> {\n     let s_space = trim_multiline_inner(s, ignore_first, ' ');\n     let s_tab = trim_multiline_inner(s_space, ignore_first, '\\t');\n@@ -296,7 +319,7 @@ fn trim_multiline_inner(s: Cow<str>, ignore_first: bool, ch: char) -> Cow<str> {\n     }\n }\n \n-/// get a parent expr if any \u2013 this is useful to constrain a lint\n+/// Get a parent expressions if any \u2013 this is useful to constrain a lint.\n pub fn get_parent_expr<'c>(cx: &'c LateContext, e: &Expr) -> Option<&'c Expr> {\n     let map = &cx.tcx.map;\n     let node_id: NodeId = e.id;\n@@ -349,22 +372,7 @@ impl<'a> Deref for DiagnosticWrapper<'a> {\n     }\n }\n \n-#[cfg(not(feature=\"structured_logging\"))]\n-pub fn span_lint<'a, T: LintContext>(cx: &'a T, lint: &'static Lint, sp: Span, msg: &str) -> DiagnosticWrapper<'a> {\n-    let mut db = cx.struct_span_lint(lint, sp, msg);\n-    if cx.current_level(lint) != Level::Allow {\n-        db.fileline_help(sp,\n-                         &format!(\"for further information visit https://github.com/Manishearth/rust-clippy/wiki#{}\",\n-                                  lint.name_lower()));\n-    }\n-    DiagnosticWrapper(db)\n-}\n-\n-#[cfg(feature=\"structured_logging\")]\n pub fn span_lint<'a, T: LintContext>(cx: &'a T, lint: &'static Lint, sp: Span, msg: &str) -> DiagnosticWrapper<'a> {\n-    // lint.name / lint.desc is can give details of the lint\n-    // cx.sess().codemap() has all these nice functions for line/column/snippet details\n-    // http://doc.rust-lang.org/syntax/codemap/struct.CodeMap.html#method.span_to_string\n     let mut db = cx.struct_span_lint(lint, sp, msg);\n     if cx.current_level(lint) != Level::Allow {\n         db.fileline_help(sp,\n@@ -418,15 +426,15 @@ pub fn span_lint_and_then<'a, T: LintContext, F>(cx: &'a T, lint: &'static Lint,\n     db\n }\n \n-/// return the base type for references and raw pointers\n+/// Return the base type for references and raw pointers.\n pub fn walk_ptrs_ty(ty: ty::Ty) -> ty::Ty {\n     match ty.sty {\n         ty::TyRef(_, ref tm) | ty::TyRawPtr(ref tm) => walk_ptrs_ty(tm.ty),\n         _ => ty,\n     }\n }\n \n-/// return the base type for references and raw pointers, and count reference depth\n+/// Return the base type for references and raw pointers, and count reference depth.\n pub fn walk_ptrs_ty_depth(ty: ty::Ty) -> (ty::Ty, usize) {\n     fn inner(ty: ty::Ty, depth: usize) -> (ty::Ty, usize) {\n         match ty.sty {"}, {"sha": "a746028200775828f882916507f2fd3c9eef6a0f", "filename": "tests/compile-fail/entry.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f6f8723c78cffe7cebec5b3792fcff0c81586ab8/tests%2Fcompile-fail%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f8723c78cffe7cebec5b3792fcff0c81586ab8/tests%2Fcompile-fail%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fentry.rs?ref=f6f8723c78cffe7cebec5b3792fcff0c81586ab8", "patch": "@@ -0,0 +1,52 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+#![allow(unused)]\n+\n+#![deny(map_entry)]\n+\n+use std::collections::{BTreeMap, HashMap};\n+use std::hash::Hash;\n+\n+fn foo() {}\n+\n+fn insert_if_absent0<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n+    if !m.contains_key(&k) { m.insert(k, v); }\n+    //~^ ERROR usage of `contains_key` followed by `insert` on `HashMap`\n+    //~| HELP Consider\n+    //~| SUGGESTION m.entry(k).or_insert(v)\n+}\n+\n+fn insert_if_absent1<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n+    if !m.contains_key(&k) { foo(); m.insert(k, v); }\n+    //~^ ERROR usage of `contains_key` followed by `insert` on `HashMap`\n+    //~| HELP Consider\n+    //~| SUGGESTION m.entry(k)\n+}\n+\n+fn insert_if_absent2<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n+    if !m.contains_key(&k) { m.insert(k, v) } else { None };\n+    //~^ ERROR usage of `contains_key` followed by `insert` on `HashMap`\n+    //~| HELP Consider\n+    //~| SUGGESTION m.entry(k).or_insert(v)\n+}\n+\n+fn insert_if_absent3<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n+    if !m.contains_key(&k) { foo(); m.insert(k, v) } else { None };\n+    //~^ ERROR usage of `contains_key` followed by `insert` on `HashMap`\n+    //~| HELP Consider\n+    //~| SUGGESTION m.entry(k)\n+}\n+\n+fn insert_in_btreemap<K: Ord, V>(m: &mut BTreeMap<K, V>, k: K, v: V) {\n+    if !m.contains_key(&k) { foo(); m.insert(k, v) } else { None };\n+    //~^ ERROR usage of `contains_key` followed by `insert` on `BTreeMap`\n+    //~| HELP Consider\n+    //~| SUGGESTION m.entry(k)\n+}\n+\n+fn insert_other_if_absent<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, o: K, v: V) {\n+    if !m.contains_key(&k) { m.insert(o, v); }\n+}\n+\n+fn main() {\n+}"}, {"sha": "a53566a794e8932fc493373f6f1dd60a196b7202", "filename": "tests/compile-fail/hashmap.rs", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e24730cb846f0fd1f5c28f5336e38be6e0143c5e/tests%2Fcompile-fail%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e24730cb846f0fd1f5c28f5336e38be6e0143c5e/tests%2Fcompile-fail%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fhashmap.rs?ref=e24730cb846f0fd1f5c28f5336e38be6e0143c5e", "patch": "@@ -1,41 +0,0 @@\n-#![feature(plugin)]\n-#![plugin(clippy)]\n-#![allow(unused)]\n-\n-#![deny(hashmap_entry)]\n-\n-use std::collections::HashMap;\n-use std::hash::Hash;\n-\n-fn foo() {}\n-\n-fn insert_if_absent0<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n-    if !m.contains_key(&k) { m.insert(k, v); }\n-    //~^ERROR: usage of `contains_key` followed by `insert` on `HashMap`\n-    //~^^HELP: Consider using `m.entry(k).or_insert(v)`\n-}\n-\n-fn insert_if_absent1<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n-    if !m.contains_key(&k) { foo(); m.insert(k, v); }\n-    //~^ERROR: usage of `contains_key` followed by `insert` on `HashMap`\n-    //~^^HELP: Consider using `m.entry(k)`\n-}\n-\n-fn insert_if_absent2<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n-    if !m.contains_key(&k) { m.insert(k, v) } else { None };\n-    //~^ERROR: usage of `contains_key` followed by `insert` on `HashMap`\n-    //~^^HELP: Consider using `m.entry(k).or_insert(v)`\n-}\n-\n-fn insert_if_absent3<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n-    if !m.contains_key(&k) { foo(); m.insert(k, v) } else { None };\n-    //~^ERROR: usage of `contains_key` followed by `insert` on `HashMap`\n-    //~^^HELP: Consider using `m.entry(k)`\n-}\n-\n-fn insert_other_if_absent<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, o: K, v: V) {\n-    if !m.contains_key(&k) { m.insert(o, v); }\n-}\n-\n-fn main() {\n-}"}]}