{"sha": "3b9daac6a27159bbe08e39fbc2722f40e91941d7", "node_id": "C_kwDOAAsO6NoAKDNiOWRhYWM2YTI3MTU5YmJlMDhlMzlmYmMyNzIyZjQwZTkxOTQxZDc", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-12-08T05:58:30Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-12-08T05:58:30Z"}, "message": "Move some suggestions from error_reporting to error_reporting::suggest", "tree": {"sha": "b0b6fd70bcf1e16822c7f7835390aac1043d8080", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0b6fd70bcf1e16822c7f7835390aac1043d8080"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b9daac6a27159bbe08e39fbc2722f40e91941d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b9daac6a27159bbe08e39fbc2722f40e91941d7", "html_url": "https://github.com/rust-lang/rust/commit/3b9daac6a27159bbe08e39fbc2722f40e91941d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b9daac6a27159bbe08e39fbc2722f40e91941d7/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25a6daccab2c8a266bea8a03091175ff21a9a465", "url": "https://api.github.com/repos/rust-lang/rust/commits/25a6daccab2c8a266bea8a03091175ff21a9a465", "html_url": "https://github.com/rust-lang/rust/commit/25a6daccab2c8a266bea8a03091175ff21a9a465"}], "stats": {"total": 1966, "additions": 1305, "deletions": 661}, "files": [{"sha": "afcdfef79fcc02ca315c94df4df089d8f84df1b1", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 660, "changes": 662, "blob_url": "https://github.com/rust-lang/rust/blob/3b9daac6a27159bbe08e39fbc2722f40e91941d7/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b9daac6a27159bbe08e39fbc2722f40e91941d7/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=3b9daac6a27159bbe08e39fbc2722f40e91941d7", "patch": "@@ -56,22 +56,17 @@ use crate::infer::ExpectedFound;\n use crate::traits::error_reporting::report_object_safety_error;\n use crate::traits::{\n     IfExpressionCause, MatchExpressionArmCause, ObligationCause, ObligationCauseCode,\n-    StatementAsExpression,\n };\n \n-use crate::errors::SuggAddLetForLetChains;\n-use hir::intravisit::{walk_expr, walk_stmt};\n use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n use rustc_errors::{pluralize, struct_span_err, Diagnostic, ErrorGuaranteed, IntoDiagnosticArg};\n use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString, MultiSpan};\n use rustc_hir as hir;\n-use rustc_hir::def::{CtorKind, DefKind};\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId};\n-use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::Node;\n use rustc_middle::dep_graph::DepContext;\n-use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::relate::{self, RelateResult, TypeRelation};\n use rustc_middle::ty::{\n     self, error::TypeError, List, Region, Ty, TyCtxt, TypeFoldable, TypeSuperVisitable,\n@@ -83,6 +78,7 @@ use std::ops::{ControlFlow, Deref};\n use std::{cmp, fmt, iter};\n \n mod note;\n+mod suggest;\n \n pub(crate) mod need_type_info;\n pub use need_type_info::TypeAnnotationNeeded;\n@@ -806,87 +802,6 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         }\n     }\n \n-    fn suggest_remove_semi_or_return_binding(\n-        &self,\n-        err: &mut Diagnostic,\n-        first_id: Option<hir::HirId>,\n-        first_ty: Ty<'tcx>,\n-        first_span: Span,\n-        second_id: Option<hir::HirId>,\n-        second_ty: Ty<'tcx>,\n-        second_span: Span,\n-    ) {\n-        let remove_semicolon = [\n-            (first_id, self.resolve_vars_if_possible(second_ty)),\n-            (second_id, self.resolve_vars_if_possible(first_ty)),\n-        ]\n-        .into_iter()\n-        .find_map(|(id, ty)| {\n-            let hir::Node::Block(blk) = self.tcx.hir().get(id?) else { return None };\n-            self.could_remove_semicolon(blk, ty)\n-        });\n-        match remove_semicolon {\n-            Some((sp, StatementAsExpression::NeedsBoxing)) => {\n-                err.multipart_suggestion(\n-                    \"consider removing this semicolon and boxing the expressions\",\n-                    vec![\n-                        (first_span.shrink_to_lo(), \"Box::new(\".to_string()),\n-                        (first_span.shrink_to_hi(), \")\".to_string()),\n-                        (second_span.shrink_to_lo(), \"Box::new(\".to_string()),\n-                        (second_span.shrink_to_hi(), \")\".to_string()),\n-                        (sp, String::new()),\n-                    ],\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-            Some((sp, StatementAsExpression::CorrectType)) => {\n-                err.span_suggestion_short(\n-                    sp,\n-                    \"consider removing this semicolon\",\n-                    \"\",\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-            None => {\n-                for (id, ty) in [(first_id, second_ty), (second_id, first_ty)] {\n-                    if let Some(id) = id\n-                        && let hir::Node::Block(blk) = self.tcx.hir().get(id)\n-                        && self.consider_returning_binding(blk, ty, err)\n-                    {\n-                        break;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    fn suggest_boxing_for_return_impl_trait(\n-        &self,\n-        err: &mut Diagnostic,\n-        return_sp: Span,\n-        arm_spans: impl Iterator<Item = Span>,\n-    ) {\n-        err.multipart_suggestion(\n-            \"you could change the return type to be a boxed trait object\",\n-            vec![\n-                (return_sp.with_hi(return_sp.lo() + BytePos(4)), \"Box<dyn\".to_string()),\n-                (return_sp.shrink_to_hi(), \">\".to_string()),\n-            ],\n-            Applicability::MaybeIncorrect,\n-        );\n-        let sugg = arm_spans\n-            .flat_map(|sp| {\n-                [(sp.shrink_to_lo(), \"Box::new(\".to_string()), (sp.shrink_to_hi(), \")\".to_string())]\n-                    .into_iter()\n-            })\n-            .collect::<Vec<_>>();\n-        err.multipart_suggestion(\n-            \"if you change the return type to expect trait objects, box the returned expressions\",\n-            sugg,\n-            Applicability::MaybeIncorrect,\n-        );\n-    }\n-\n     /// Given that `other_ty` is the same as a type argument for `name` in `sub`, populate `value`\n     /// highlighting `name` and every type argument that isn't at `pos` (which is `other_ty`), and\n     /// populate `other_value` with `other_ty`.\n@@ -1940,310 +1855,6 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         debug!(?diag);\n     }\n \n-    fn suggest_tuple_pattern(\n-        &self,\n-        cause: &ObligationCause<'tcx>,\n-        exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n-        diag: &mut Diagnostic,\n-    ) {\n-        // Heavily inspired by `FnCtxt::suggest_compatible_variants`, with\n-        // some modifications due to that being in typeck and this being in infer.\n-        if let ObligationCauseCode::Pattern { .. } = cause.code() {\n-            if let ty::Adt(expected_adt, substs) = exp_found.expected.kind() {\n-                let compatible_variants: Vec<_> = expected_adt\n-                    .variants()\n-                    .iter()\n-                    .filter(|variant| {\n-                        variant.fields.len() == 1 && variant.ctor_kind() == Some(CtorKind::Fn)\n-                    })\n-                    .filter_map(|variant| {\n-                        let sole_field = &variant.fields[0];\n-                        let sole_field_ty = sole_field.ty(self.tcx, substs);\n-                        if self.same_type_modulo_infer(sole_field_ty, exp_found.found) {\n-                            let variant_path =\n-                                with_no_trimmed_paths!(self.tcx.def_path_str(variant.def_id));\n-                            // FIXME #56861: DRYer prelude filtering\n-                            if let Some(path) = variant_path.strip_prefix(\"std::prelude::\") {\n-                                if let Some((_, path)) = path.split_once(\"::\") {\n-                                    return Some(path.to_string());\n-                                }\n-                            }\n-                            Some(variant_path)\n-                        } else {\n-                            None\n-                        }\n-                    })\n-                    .collect();\n-                match &compatible_variants[..] {\n-                    [] => {}\n-                    [variant] => {\n-                        diag.multipart_suggestion_verbose(\n-                            &format!(\"try wrapping the pattern in `{}`\", variant),\n-                            vec![\n-                                (cause.span.shrink_to_lo(), format!(\"{}(\", variant)),\n-                                (cause.span.shrink_to_hi(), \")\".to_string()),\n-                            ],\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                    _ => {\n-                        // More than one matching variant.\n-                        diag.multipart_suggestions(\n-                            &format!(\n-                                \"try wrapping the pattern in a variant of `{}`\",\n-                                self.tcx.def_path_str(expected_adt.did())\n-                            ),\n-                            compatible_variants.into_iter().map(|variant| {\n-                                vec![\n-                                    (cause.span.shrink_to_lo(), format!(\"{}(\", variant)),\n-                                    (cause.span.shrink_to_hi(), \")\".to_string()),\n-                                ]\n-                            }),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    /// A possible error is to forget to add `.await` when using futures:\n-    ///\n-    /// ```compile_fail,E0308\n-    /// async fn make_u32() -> u32 {\n-    ///     22\n-    /// }\n-    ///\n-    /// fn take_u32(x: u32) {}\n-    ///\n-    /// async fn foo() {\n-    ///     let x = make_u32();\n-    ///     take_u32(x);\n-    /// }\n-    /// ```\n-    ///\n-    /// This routine checks if the found type `T` implements `Future<Output=U>` where `U` is the\n-    /// expected type. If this is the case, and we are inside of an async body, it suggests adding\n-    /// `.await` to the tail of the expression.\n-    fn suggest_await_on_expect_found(\n-        &self,\n-        cause: &ObligationCause<'tcx>,\n-        exp_span: Span,\n-        exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n-        diag: &mut Diagnostic,\n-    ) {\n-        debug!(\n-            \"suggest_await_on_expect_found: exp_span={:?}, expected_ty={:?}, found_ty={:?}\",\n-            exp_span, exp_found.expected, exp_found.found,\n-        );\n-\n-        if let ObligationCauseCode::CompareImplItemObligation { .. } = cause.code() {\n-            return;\n-        }\n-\n-        match (\n-            self.get_impl_future_output_ty(exp_found.expected),\n-            self.get_impl_future_output_ty(exp_found.found),\n-        ) {\n-            (Some(exp), Some(found)) if self.same_type_modulo_infer(exp, found) => match cause\n-                .code()\n-            {\n-                ObligationCauseCode::IfExpression(box IfExpressionCause { then_id, .. }) => {\n-                    let then_span = self.find_block_span_from_hir_id(*then_id);\n-                    diag.multipart_suggestion(\n-                        \"consider `await`ing on both `Future`s\",\n-                        vec![\n-                            (then_span.shrink_to_hi(), \".await\".to_string()),\n-                            (exp_span.shrink_to_hi(), \".await\".to_string()),\n-                        ],\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-                ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n-                    prior_arms,\n-                    ..\n-                }) => {\n-                    if let [.., arm_span] = &prior_arms[..] {\n-                        diag.multipart_suggestion(\n-                            \"consider `await`ing on both `Future`s\",\n-                            vec![\n-                                (arm_span.shrink_to_hi(), \".await\".to_string()),\n-                                (exp_span.shrink_to_hi(), \".await\".to_string()),\n-                            ],\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    } else {\n-                        diag.help(\"consider `await`ing on both `Future`s\");\n-                    }\n-                }\n-                _ => {\n-                    diag.help(\"consider `await`ing on both `Future`s\");\n-                }\n-            },\n-            (_, Some(ty)) if self.same_type_modulo_infer(exp_found.expected, ty) => {\n-                diag.span_suggestion_verbose(\n-                    exp_span.shrink_to_hi(),\n-                    \"consider `await`ing on the `Future`\",\n-                    \".await\",\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n-            (Some(ty), _) if self.same_type_modulo_infer(ty, exp_found.found) => match cause.code()\n-            {\n-                ObligationCauseCode::Pattern { span: Some(then_span), .. } => {\n-                    diag.span_suggestion_verbose(\n-                        then_span.shrink_to_hi(),\n-                        \"consider `await`ing on the `Future`\",\n-                        \".await\",\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-                ObligationCauseCode::IfExpression(box IfExpressionCause { then_id, .. }) => {\n-                    let then_span = self.find_block_span_from_hir_id(*then_id);\n-                    diag.span_suggestion_verbose(\n-                        then_span.shrink_to_hi(),\n-                        \"consider `await`ing on the `Future`\",\n-                        \".await\",\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-                ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n-                    ref prior_arms,\n-                    ..\n-                }) => {\n-                    diag.multipart_suggestion_verbose(\n-                        \"consider `await`ing on the `Future`\",\n-                        prior_arms\n-                            .iter()\n-                            .map(|arm| (arm.shrink_to_hi(), \".await\".to_string()))\n-                            .collect(),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-                _ => {}\n-            },\n-            _ => {}\n-        }\n-    }\n-\n-    fn suggest_accessing_field_where_appropriate(\n-        &self,\n-        cause: &ObligationCause<'tcx>,\n-        exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n-        diag: &mut Diagnostic,\n-    ) {\n-        debug!(\n-            \"suggest_accessing_field_where_appropriate(cause={:?}, exp_found={:?})\",\n-            cause, exp_found\n-        );\n-        if let ty::Adt(expected_def, expected_substs) = exp_found.expected.kind() {\n-            if expected_def.is_enum() {\n-                return;\n-            }\n-\n-            if let Some((name, ty)) = expected_def\n-                .non_enum_variant()\n-                .fields\n-                .iter()\n-                .filter(|field| field.vis.is_accessible_from(field.did, self.tcx))\n-                .map(|field| (field.name, field.ty(self.tcx, expected_substs)))\n-                .find(|(_, ty)| self.same_type_modulo_infer(*ty, exp_found.found))\n-            {\n-                if let ObligationCauseCode::Pattern { span: Some(span), .. } = *cause.code() {\n-                    if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n-                        let suggestion = if expected_def.is_struct() {\n-                            format!(\"{}.{}\", snippet, name)\n-                        } else if expected_def.is_union() {\n-                            format!(\"unsafe {{ {}.{} }}\", snippet, name)\n-                        } else {\n-                            return;\n-                        };\n-                        diag.span_suggestion(\n-                            span,\n-                            &format!(\n-                                \"you might have meant to use field `{}` whose type is `{}`\",\n-                                name, ty\n-                            ),\n-                            suggestion,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    /// When encountering a case where `.as_ref()` on a `Result` or `Option` would be appropriate,\n-    /// suggests it.\n-    fn suggest_as_ref_where_appropriate(\n-        &self,\n-        span: Span,\n-        exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n-        diag: &mut Diagnostic,\n-    ) {\n-        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span)\n-            && let Some(msg) = self.should_suggest_as_ref(exp_found.expected, exp_found.found)\n-        {\n-            diag.span_suggestion(\n-                span,\n-                msg,\n-                // HACK: fix issue# 100605, suggesting convert from &Option<T> to Option<&T>, remove the extra `&`\n-                format!(\"{}.as_ref()\", snippet.trim_start_matches('&')),\n-                Applicability::MachineApplicable,\n-            );\n-        }\n-    }\n-\n-    pub fn should_suggest_as_ref(&self, expected: Ty<'tcx>, found: Ty<'tcx>) -> Option<&str> {\n-        if let (ty::Adt(exp_def, exp_substs), ty::Ref(_, found_ty, _)) =\n-            (expected.kind(), found.kind())\n-        {\n-            if let ty::Adt(found_def, found_substs) = *found_ty.kind() {\n-                if exp_def == &found_def {\n-                    let have_as_ref = &[\n-                        (\n-                            sym::Option,\n-                            \"you can convert from `&Option<T>` to `Option<&T>` using \\\n-                        `.as_ref()`\",\n-                        ),\n-                        (\n-                            sym::Result,\n-                            \"you can convert from `&Result<T, E>` to \\\n-                        `Result<&T, &E>` using `.as_ref()`\",\n-                        ),\n-                    ];\n-                    if let Some(msg) = have_as_ref.iter().find_map(|(name, msg)| {\n-                        self.tcx.is_diagnostic_item(*name, exp_def.did()).then_some(msg)\n-                    }) {\n-                        let mut show_suggestion = true;\n-                        for (exp_ty, found_ty) in\n-                            iter::zip(exp_substs.types(), found_substs.types())\n-                        {\n-                            match *exp_ty.kind() {\n-                                ty::Ref(_, exp_ty, _) => {\n-                                    match (exp_ty.kind(), found_ty.kind()) {\n-                                        (_, ty::Param(_))\n-                                        | (_, ty::Infer(_))\n-                                        | (ty::Param(_), _)\n-                                        | (ty::Infer(_), _) => {}\n-                                        _ if self.same_type_modulo_infer(exp_ty, found_ty) => {}\n-                                        _ => show_suggestion = false,\n-                                    };\n-                                }\n-                                ty::Param(_) | ty::Infer(_) => {}\n-                                _ => show_suggestion = false,\n-                            }\n-                        }\n-                        if show_suggestion {\n-                            return Some(*msg);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        None\n-    }\n-\n     pub fn report_and_explain_type_error(\n         &self,\n         trace: TypeTrace<'tcx>,\n@@ -2357,67 +1968,6 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         diag\n     }\n \n-    /// Try to find code with pattern `if Some(..) = expr`\n-    /// use a `visitor` to mark the `if` which its span contains given error span,\n-    /// and then try to find a assignment in the `cond` part, which span is equal with error span\n-    fn suggest_let_for_letchains(\n-        &self,\n-        err: &mut Diagnostic,\n-        cause: &ObligationCause<'_>,\n-        span: Span,\n-    ) {\n-        let hir = self.tcx.hir();\n-        let fn_hir_id = hir.get_parent_node(cause.body_id);\n-        if let Some(node) = self.tcx.hir().find(fn_hir_id) &&\n-            let hir::Node::Item(hir::Item {\n-                    kind: hir::ItemKind::Fn(_sig, _, body_id), ..\n-                }) = node {\n-        let body = hir.body(*body_id);\n-\n-        /// Find the if expression with given span\n-        struct IfVisitor {\n-            pub result: bool,\n-            pub found_if: bool,\n-            pub err_span: Span,\n-        }\n-\n-        impl<'v> Visitor<'v> for IfVisitor {\n-            fn visit_expr(&mut self, ex: &'v hir::Expr<'v>) {\n-                if self.result { return; }\n-                match ex.kind {\n-                    hir::ExprKind::If(cond, _, _) => {\n-                        self.found_if = true;\n-                        walk_expr(self, cond);\n-                        self.found_if = false;\n-                    }\n-                    _ => walk_expr(self, ex),\n-                }\n-            }\n-\n-            fn visit_stmt(&mut self, ex: &'v hir::Stmt<'v>) {\n-                if let hir::StmtKind::Local(hir::Local {\n-                        span, pat: hir::Pat{..}, ty: None, init: Some(_), ..\n-                    }) = &ex.kind\n-                    && self.found_if\n-                    && span.eq(&self.err_span) {\n-                        self.result = true;\n-                }\n-                walk_stmt(self, ex);\n-            }\n-\n-            fn visit_body(&mut self, body: &'v hir::Body<'v>) {\n-                hir::intravisit::walk_body(self, body);\n-            }\n-        }\n-\n-        let mut visitor = IfVisitor { err_span: span, found_if: false, result: false };\n-        visitor.visit_body(&body);\n-        if visitor.result {\n-                err.subdiagnostic(SuggAddLetForLetChains{span: span.shrink_to_lo()});\n-            }\n-        }\n-    }\n-\n     fn emit_tuple_wrap_err(\n         &self,\n         err: &mut Diagnostic,\n@@ -3228,211 +2778,3 @@ impl<'tcx> InferCtxt<'tcx> {\n         }\n     }\n }\n-\n-impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n-    /// Be helpful when the user wrote `{... expr; }` and taking the `;` off\n-    /// is enough to fix the error.\n-    pub fn could_remove_semicolon(\n-        &self,\n-        blk: &'tcx hir::Block<'tcx>,\n-        expected_ty: Ty<'tcx>,\n-    ) -> Option<(Span, StatementAsExpression)> {\n-        let blk = blk.innermost_block();\n-        // Do not suggest if we have a tail expr.\n-        if blk.expr.is_some() {\n-            return None;\n-        }\n-        let last_stmt = blk.stmts.last()?;\n-        let hir::StmtKind::Semi(ref last_expr) = last_stmt.kind else {\n-            return None;\n-        };\n-        let last_expr_ty = self.typeck_results.as_ref()?.expr_ty_opt(*last_expr)?;\n-        let needs_box = match (last_expr_ty.kind(), expected_ty.kind()) {\n-            _ if last_expr_ty.references_error() => return None,\n-            _ if self.same_type_modulo_infer(last_expr_ty, expected_ty) => {\n-                StatementAsExpression::CorrectType\n-            }\n-            (ty::Opaque(last_def_id, _), ty::Opaque(exp_def_id, _))\n-                if last_def_id == exp_def_id =>\n-            {\n-                StatementAsExpression::CorrectType\n-            }\n-            (ty::Opaque(last_def_id, last_bounds), ty::Opaque(exp_def_id, exp_bounds)) => {\n-                debug!(\n-                    \"both opaque, likely future {:?} {:?} {:?} {:?}\",\n-                    last_def_id, last_bounds, exp_def_id, exp_bounds\n-                );\n-\n-                let last_local_id = last_def_id.as_local()?;\n-                let exp_local_id = exp_def_id.as_local()?;\n-\n-                match (\n-                    &self.tcx.hir().expect_item(last_local_id).kind,\n-                    &self.tcx.hir().expect_item(exp_local_id).kind,\n-                ) {\n-                    (\n-                        hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds: last_bounds, .. }),\n-                        hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds: exp_bounds, .. }),\n-                    ) if iter::zip(*last_bounds, *exp_bounds).all(|(left, right)| {\n-                        match (left, right) {\n-                            (\n-                                hir::GenericBound::Trait(tl, ml),\n-                                hir::GenericBound::Trait(tr, mr),\n-                            ) if tl.trait_ref.trait_def_id() == tr.trait_ref.trait_def_id()\n-                                && ml == mr =>\n-                            {\n-                                true\n-                            }\n-                            (\n-                                hir::GenericBound::LangItemTrait(langl, _, _, argsl),\n-                                hir::GenericBound::LangItemTrait(langr, _, _, argsr),\n-                            ) if langl == langr => {\n-                                // FIXME: consider the bounds!\n-                                debug!(\"{:?} {:?}\", argsl, argsr);\n-                                true\n-                            }\n-                            _ => false,\n-                        }\n-                    }) =>\n-                    {\n-                        StatementAsExpression::NeedsBoxing\n-                    }\n-                    _ => StatementAsExpression::CorrectType,\n-                }\n-            }\n-            _ => return None,\n-        };\n-        let span = if last_stmt.span.from_expansion() {\n-            let mac_call = rustc_span::source_map::original_sp(last_stmt.span, blk.span);\n-            self.tcx.sess.source_map().mac_call_stmt_semi_span(mac_call)?\n-        } else {\n-            last_stmt.span.with_lo(last_stmt.span.hi() - BytePos(1))\n-        };\n-        Some((span, needs_box))\n-    }\n-\n-    /// Suggest returning a local binding with a compatible type if the block\n-    /// has no return expression.\n-    pub fn consider_returning_binding(\n-        &self,\n-        blk: &'tcx hir::Block<'tcx>,\n-        expected_ty: Ty<'tcx>,\n-        err: &mut Diagnostic,\n-    ) -> bool {\n-        let blk = blk.innermost_block();\n-        // Do not suggest if we have a tail expr.\n-        if blk.expr.is_some() {\n-            return false;\n-        }\n-        let mut shadowed = FxIndexSet::default();\n-        let mut candidate_idents = vec![];\n-        let mut find_compatible_candidates = |pat: &hir::Pat<'_>| {\n-            if let hir::PatKind::Binding(_, hir_id, ident, _) = &pat.kind\n-                && let Some(pat_ty) = self\n-                    .typeck_results\n-                    .as_ref()\n-                    .and_then(|typeck_results| typeck_results.node_type_opt(*hir_id))\n-            {\n-                let pat_ty = self.resolve_vars_if_possible(pat_ty);\n-                if self.same_type_modulo_infer(pat_ty, expected_ty)\n-                    && !(pat_ty, expected_ty).references_error()\n-                    && shadowed.insert(ident.name)\n-                {\n-                    candidate_idents.push((*ident, pat_ty));\n-                }\n-            }\n-            true\n-        };\n-\n-        let hir = self.tcx.hir();\n-        for stmt in blk.stmts.iter().rev() {\n-            let hir::StmtKind::Local(local) = &stmt.kind else { continue; };\n-            local.pat.walk(&mut find_compatible_candidates);\n-        }\n-        match hir.find(hir.get_parent_node(blk.hir_id)) {\n-            Some(hir::Node::Expr(hir::Expr { hir_id, .. })) => {\n-                match hir.find(hir.get_parent_node(*hir_id)) {\n-                    Some(hir::Node::Arm(hir::Arm { pat, .. })) => {\n-                        pat.walk(&mut find_compatible_candidates);\n-                    }\n-                    Some(\n-                        hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, _, body), .. })\n-                        | hir::Node::ImplItem(hir::ImplItem {\n-                            kind: hir::ImplItemKind::Fn(_, body),\n-                            ..\n-                        })\n-                        | hir::Node::TraitItem(hir::TraitItem {\n-                            kind: hir::TraitItemKind::Fn(_, hir::TraitFn::Provided(body)),\n-                            ..\n-                        })\n-                        | hir::Node::Expr(hir::Expr {\n-                            kind: hir::ExprKind::Closure(hir::Closure { body, .. }),\n-                            ..\n-                        }),\n-                    ) => {\n-                        for param in hir.body(*body).params {\n-                            param.pat.walk(&mut find_compatible_candidates);\n-                        }\n-                    }\n-                    Some(hir::Node::Expr(hir::Expr {\n-                        kind:\n-                            hir::ExprKind::If(\n-                                hir::Expr { kind: hir::ExprKind::Let(let_), .. },\n-                                then_block,\n-                                _,\n-                            ),\n-                        ..\n-                    })) if then_block.hir_id == *hir_id => {\n-                        let_.pat.walk(&mut find_compatible_candidates);\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        match &candidate_idents[..] {\n-            [(ident, _ty)] => {\n-                let sm = self.tcx.sess.source_map();\n-                if let Some(stmt) = blk.stmts.last() {\n-                    let stmt_span = sm.stmt_span(stmt.span, blk.span);\n-                    let sugg = if sm.is_multiline(blk.span)\n-                        && let Some(spacing) = sm.indentation_before(stmt_span)\n-                    {\n-                        format!(\"\\n{spacing}{ident}\")\n-                    } else {\n-                        format!(\" {ident}\")\n-                    };\n-                    err.span_suggestion_verbose(\n-                        stmt_span.shrink_to_hi(),\n-                        format!(\"consider returning the local binding `{ident}`\"),\n-                        sugg,\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                } else {\n-                    let sugg = if sm.is_multiline(blk.span)\n-                        && let Some(spacing) = sm.indentation_before(blk.span.shrink_to_lo())\n-                    {\n-                        format!(\"\\n{spacing}    {ident}\\n{spacing}\")\n-                    } else {\n-                        format!(\" {ident} \")\n-                    };\n-                    let left_span = sm.span_through_char(blk.span, '{').shrink_to_hi();\n-                    err.span_suggestion_verbose(\n-                        sm.span_extend_while(left_span, |c| c.is_whitespace()).unwrap_or(left_span),\n-                        format!(\"consider returning the local binding `{ident}`\"),\n-                        sugg,\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-                true\n-            }\n-            values if (1..3).contains(&values.len()) => {\n-                let spans = values.iter().map(|(ident, _)| ident.span).collect::<Vec<_>>();\n-                err.span_note(spans, \"consider returning one of these bindings\");\n-                true\n-            }\n-            _ => false,\n-        }\n-    }\n-}"}, {"sha": "41b115f3377ac879d7287aa3910dcdf492221fc7", "filename": "compiler/rustc_infer/src/infer/error_reporting/note_region.rs", "status": "added", "additions": 427, "deletions": 0, "changes": 427, "blob_url": "https://github.com/rust-lang/rust/blob/3b9daac6a27159bbe08e39fbc2722f40e91941d7/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b9daac6a27159bbe08e39fbc2722f40e91941d7/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_region.rs?ref=3b9daac6a27159bbe08e39fbc2722f40e91941d7", "patch": "@@ -0,0 +1,427 @@\n+use crate::errors::RegionOriginNote;\n+use crate::infer::error_reporting::{note_and_explain_region, TypeErrCtxt};\n+use crate::infer::{self, SubregionOrigin};\n+use rustc_errors::{\n+    fluent, struct_span_err, AddToDiagnostic, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n+};\n+use rustc_middle::traits::ObligationCauseCode;\n+use rustc_middle::ty::error::TypeError;\n+use rustc_middle::ty::{self, Region};\n+\n+use super::ObligationCauseAsDiagArg;\n+\n+impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n+    pub(super) fn note_region_origin(&self, err: &mut Diagnostic, origin: &SubregionOrigin<'tcx>) {\n+        match *origin {\n+            infer::Subtype(ref trace) => RegionOriginNote::WithRequirement {\n+                span: trace.cause.span,\n+                requirement: ObligationCauseAsDiagArg(trace.cause.clone()),\n+                expected_found: self.values_str(trace.values),\n+            }\n+            .add_to_diagnostic(err),\n+            infer::Reborrow(span) => {\n+                RegionOriginNote::Plain { span, msg: fluent::infer_reborrow }.add_to_diagnostic(err)\n+            }\n+            infer::ReborrowUpvar(span, ref upvar_id) => {\n+                let var_name = self.tcx.hir().name(upvar_id.var_path.hir_id);\n+                RegionOriginNote::WithName {\n+                    span,\n+                    msg: fluent::infer_reborrow,\n+                    name: &var_name.to_string(),\n+                    continues: false,\n+                }\n+                .add_to_diagnostic(err);\n+            }\n+            infer::RelateObjectBound(span) => {\n+                RegionOriginNote::Plain { span, msg: fluent::infer_relate_object_bound }\n+                    .add_to_diagnostic(err);\n+            }\n+            infer::DataBorrowed(ty, span) => {\n+                RegionOriginNote::WithName {\n+                    span,\n+                    msg: fluent::infer_data_borrowed,\n+                    name: &self.ty_to_string(ty),\n+                    continues: false,\n+                }\n+                .add_to_diagnostic(err);\n+            }\n+            infer::ReferenceOutlivesReferent(ty, span) => {\n+                RegionOriginNote::WithName {\n+                    span,\n+                    msg: fluent::infer_reference_outlives_referent,\n+                    name: &self.ty_to_string(ty),\n+                    continues: false,\n+                }\n+                .add_to_diagnostic(err);\n+            }\n+            infer::RelateParamBound(span, ty, opt_span) => {\n+                RegionOriginNote::WithName {\n+                    span,\n+                    msg: fluent::infer_relate_param_bound,\n+                    name: &self.ty_to_string(ty),\n+                    continues: opt_span.is_some(),\n+                }\n+                .add_to_diagnostic(err);\n+                if let Some(span) = opt_span {\n+                    RegionOriginNote::Plain { span, msg: fluent::infer_relate_param_bound_2 }\n+                        .add_to_diagnostic(err);\n+                }\n+            }\n+            infer::RelateRegionParamBound(span) => {\n+                RegionOriginNote::Plain { span, msg: fluent::infer_relate_region_param_bound }\n+                    .add_to_diagnostic(err);\n+            }\n+            infer::CompareImplItemObligation { span, .. } => {\n+                RegionOriginNote::Plain { span, msg: fluent::infer_compare_impl_item_obligation }\n+                    .add_to_diagnostic(err);\n+            }\n+            infer::CheckAssociatedTypeBounds { ref parent, .. } => {\n+                self.note_region_origin(err, &parent);\n+            }\n+            infer::AscribeUserTypeProvePredicate(span) => {\n+                RegionOriginNote::Plain {\n+                    span,\n+                    msg: fluent::infer_ascribe_user_type_prove_predicate,\n+                }\n+                .add_to_diagnostic(err);\n+            }\n+        }\n+    }\n+\n+    pub(super) fn report_concrete_failure(\n+        &self,\n+        origin: SubregionOrigin<'tcx>,\n+        sub: Region<'tcx>,\n+        sup: Region<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n+        match origin {\n+            infer::Subtype(box trace) => {\n+                let terr = TypeError::RegionsDoesNotOutlive(sup, sub);\n+                let mut err = self.report_and_explain_type_error(trace, terr);\n+                match (*sub, *sup) {\n+                    (ty::RePlaceholder(_), ty::RePlaceholder(_)) => {}\n+                    (ty::RePlaceholder(_), _) => {\n+                        note_and_explain_region(\n+                            self.tcx,\n+                            &mut err,\n+                            \"\",\n+                            sup,\n+                            \" doesn't meet the lifetime requirements\",\n+                            None,\n+                        );\n+                    }\n+                    (_, ty::RePlaceholder(_)) => {\n+                        note_and_explain_region(\n+                            self.tcx,\n+                            &mut err,\n+                            \"the required lifetime does not necessarily outlive \",\n+                            sub,\n+                            \"\",\n+                            None,\n+                        );\n+                    }\n+                    _ => {\n+                        note_and_explain_region(self.tcx, &mut err, \"\", sup, \"...\", None);\n+                        note_and_explain_region(\n+                            self.tcx,\n+                            &mut err,\n+                            \"...does not necessarily outlive \",\n+                            sub,\n+                            \"\",\n+                            None,\n+                        );\n+                    }\n+                }\n+                err\n+            }\n+            infer::Reborrow(span) => {\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    span,\n+                    E0312,\n+                    \"lifetime of reference outlives lifetime of borrowed content...\"\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"...the reference is valid for \",\n+                    sub,\n+                    \"...\",\n+                    None,\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"...but the borrowed content is only valid for \",\n+                    sup,\n+                    \"\",\n+                    None,\n+                );\n+                err\n+            }\n+            infer::ReborrowUpvar(span, ref upvar_id) => {\n+                let var_name = self.tcx.hir().name(upvar_id.var_path.hir_id);\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    span,\n+                    E0313,\n+                    \"lifetime of borrowed pointer outlives lifetime of captured variable `{}`...\",\n+                    var_name\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"...the borrowed pointer is valid for \",\n+                    sub,\n+                    \"...\",\n+                    None,\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    &format!(\"...but `{}` is only valid for \", var_name),\n+                    sup,\n+                    \"\",\n+                    None,\n+                );\n+                err\n+            }\n+            infer::RelateObjectBound(span) => {\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    span,\n+                    E0476,\n+                    \"lifetime of the source pointer does not outlive lifetime bound of the \\\n+                     object type\"\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"object type is valid for \",\n+                    sub,\n+                    \"\",\n+                    None,\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"source pointer is only valid for \",\n+                    sup,\n+                    \"\",\n+                    None,\n+                );\n+                err\n+            }\n+            infer::RelateParamBound(span, ty, opt_span) => {\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    span,\n+                    E0477,\n+                    \"the type `{}` does not fulfill the required lifetime\",\n+                    self.ty_to_string(ty)\n+                );\n+                match *sub {\n+                    ty::ReStatic => note_and_explain_region(\n+                        self.tcx,\n+                        &mut err,\n+                        \"type must satisfy \",\n+                        sub,\n+                        if opt_span.is_some() { \" as required by this binding\" } else { \"\" },\n+                        opt_span,\n+                    ),\n+                    _ => note_and_explain_region(\n+                        self.tcx,\n+                        &mut err,\n+                        \"type must outlive \",\n+                        sub,\n+                        if opt_span.is_some() { \" as required by this binding\" } else { \"\" },\n+                        opt_span,\n+                    ),\n+                }\n+                err\n+            }\n+            infer::RelateRegionParamBound(span) => {\n+                let mut err =\n+                    struct_span_err!(self.tcx.sess, span, E0478, \"lifetime bound not satisfied\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"lifetime parameter instantiated with \",\n+                    sup,\n+                    \"\",\n+                    None,\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"but lifetime parameter must outlive \",\n+                    sub,\n+                    \"\",\n+                    None,\n+                );\n+                err\n+            }\n+            infer::DataBorrowed(ty, span) => {\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    span,\n+                    E0490,\n+                    \"a value of type `{}` is borrowed for too long\",\n+                    self.ty_to_string(ty)\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"the type is valid for \",\n+                    sub,\n+                    \"\",\n+                    None,\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"but the borrow lasts for \",\n+                    sup,\n+                    \"\",\n+                    None,\n+                );\n+                err\n+            }\n+            infer::ReferenceOutlivesReferent(ty, span) => {\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    span,\n+                    E0491,\n+                    \"in type `{}`, reference has a longer lifetime than the data it references\",\n+                    self.ty_to_string(ty)\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"the pointer is valid for \",\n+                    sub,\n+                    \"\",\n+                    None,\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"but the referenced data is only valid for \",\n+                    sup,\n+                    \"\",\n+                    None,\n+                );\n+                err\n+            }\n+            infer::CompareImplItemObligation { span, impl_item_def_id, trait_item_def_id } => self\n+                .report_extra_impl_obligation(\n+                    span,\n+                    impl_item_def_id,\n+                    trait_item_def_id,\n+                    &format!(\"`{}: {}`\", sup, sub),\n+                ),\n+            infer::CheckAssociatedTypeBounds { impl_item_def_id, trait_item_def_id, parent } => {\n+                let mut err = self.report_concrete_failure(*parent, sub, sup);\n+\n+                let trait_item_span = self.tcx.def_span(trait_item_def_id);\n+                let item_name = self.tcx.item_name(impl_item_def_id.to_def_id());\n+                err.span_label(\n+                    trait_item_span,\n+                    format!(\"definition of `{}` from trait\", item_name),\n+                );\n+\n+                let trait_predicates = self.tcx.explicit_predicates_of(trait_item_def_id);\n+                let impl_predicates = self.tcx.explicit_predicates_of(impl_item_def_id);\n+\n+                let impl_predicates: rustc_data_structures::fx::FxHashSet<_> =\n+                    impl_predicates.predicates.into_iter().map(|(pred, _)| pred).collect();\n+                let clauses: Vec<_> = trait_predicates\n+                    .predicates\n+                    .into_iter()\n+                    .filter(|&(pred, _)| !impl_predicates.contains(pred))\n+                    .map(|(pred, _)| format!(\"{}\", pred))\n+                    .collect();\n+\n+                if !clauses.is_empty() {\n+                    let generics = self.tcx.hir().get_generics(impl_item_def_id).unwrap();\n+                    let where_clause_span = generics.tail_span_for_predicate_suggestion();\n+\n+                    let suggestion = format!(\n+                        \"{} {}\",\n+                        generics.add_where_or_trailing_comma(),\n+                        clauses.join(\", \"),\n+                    );\n+                    err.span_suggestion(\n+                        where_clause_span,\n+                        &format!(\n+                            \"try copying {} from the trait\",\n+                            if clauses.len() > 1 { \"these clauses\" } else { \"this clause\" }\n+                        ),\n+                        suggestion,\n+                        rustc_errors::Applicability::MaybeIncorrect,\n+                    );\n+                }\n+\n+                err\n+            }\n+            infer::AscribeUserTypeProvePredicate(span) => {\n+                let mut err =\n+                    struct_span_err!(self.tcx.sess, span, E0478, \"lifetime bound not satisfied\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"lifetime instantiated with \",\n+                    sup,\n+                    \"\",\n+                    None,\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"but lifetime must outlive \",\n+                    sub,\n+                    \"\",\n+                    None,\n+                );\n+                err\n+            }\n+        }\n+    }\n+\n+    pub(super) fn report_placeholder_failure(\n+        &self,\n+        placeholder_origin: SubregionOrigin<'tcx>,\n+        sub: Region<'tcx>,\n+        sup: Region<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n+        // I can't think how to do better than this right now. -nikomatsakis\n+        debug!(?placeholder_origin, ?sub, ?sup, \"report_placeholder_failure\");\n+        match placeholder_origin {\n+            infer::Subtype(box ref trace)\n+                if matches!(\n+                    &trace.cause.code().peel_derives(),\n+                    ObligationCauseCode::BindingObligation(..)\n+                        | ObligationCauseCode::ExprBindingObligation(..)\n+                ) =>\n+            {\n+                // Hack to get around the borrow checker because trace.cause has an `Rc`.\n+                if let ObligationCauseCode::BindingObligation(_, span)\n+                | ObligationCauseCode::ExprBindingObligation(_, span, ..) =\n+                    &trace.cause.code().peel_derives()\n+                {\n+                    let span = *span;\n+                    let mut err = self.report_concrete_failure(placeholder_origin, sub, sup);\n+                    err.span_note(span, \"the lifetime requirement is introduced here\");\n+                    err\n+                } else {\n+                    unreachable!()\n+                }\n+            }\n+            infer::Subtype(box trace) => {\n+                let terr = TypeError::RegionsPlaceholderMismatch;\n+                return self.report_and_explain_type_error(trace, terr);\n+            }\n+            _ => return self.report_concrete_failure(placeholder_origin, sub, sup),\n+        }\n+    }\n+}"}, {"sha": "73b5a2cc4ad233e6ba2c5a1b1750916e3dfc55b0", "filename": "compiler/rustc_infer/src/infer/error_reporting/suggest.rs", "status": "added", "additions": 672, "deletions": 0, "changes": 672, "blob_url": "https://github.com/rust-lang/rust/blob/3b9daac6a27159bbe08e39fbc2722f40e91941d7/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b9daac6a27159bbe08e39fbc2722f40e91941d7/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs?ref=3b9daac6a27159bbe08e39fbc2722f40e91941d7", "patch": "@@ -0,0 +1,672 @@\n+use hir::def::CtorKind;\n+use hir::intravisit::{walk_expr, walk_stmt, Visitor};\n+use rustc_data_structures::fx::FxIndexSet;\n+use rustc_errors::{Applicability, Diagnostic};\n+use rustc_hir as hir;\n+use rustc_middle::traits::{\n+    IfExpressionCause, MatchExpressionArmCause, ObligationCause, ObligationCauseCode,\n+    StatementAsExpression,\n+};\n+use rustc_middle::ty::print::with_no_trimmed_paths;\n+use rustc_middle::ty::{self as ty, Ty, TypeVisitable};\n+use rustc_span::{sym, BytePos, Span};\n+\n+use crate::errors::SuggAddLetForLetChains;\n+\n+use super::TypeErrCtxt;\n+\n+impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n+    pub(super) fn suggest_remove_semi_or_return_binding(\n+        &self,\n+        err: &mut Diagnostic,\n+        first_id: Option<hir::HirId>,\n+        first_ty: Ty<'tcx>,\n+        first_span: Span,\n+        second_id: Option<hir::HirId>,\n+        second_ty: Ty<'tcx>,\n+        second_span: Span,\n+    ) {\n+        let remove_semicolon = [\n+            (first_id, self.resolve_vars_if_possible(second_ty)),\n+            (second_id, self.resolve_vars_if_possible(first_ty)),\n+        ]\n+        .into_iter()\n+        .find_map(|(id, ty)| {\n+            let hir::Node::Block(blk) = self.tcx.hir().get(id?) else { return None };\n+            self.could_remove_semicolon(blk, ty)\n+        });\n+        match remove_semicolon {\n+            Some((sp, StatementAsExpression::NeedsBoxing)) => {\n+                err.multipart_suggestion(\n+                    \"consider removing this semicolon and boxing the expressions\",\n+                    vec![\n+                        (first_span.shrink_to_lo(), \"Box::new(\".to_string()),\n+                        (first_span.shrink_to_hi(), \")\".to_string()),\n+                        (second_span.shrink_to_lo(), \"Box::new(\".to_string()),\n+                        (second_span.shrink_to_hi(), \")\".to_string()),\n+                        (sp, String::new()),\n+                    ],\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            Some((sp, StatementAsExpression::CorrectType)) => {\n+                err.span_suggestion_short(\n+                    sp,\n+                    \"consider removing this semicolon\",\n+                    \"\",\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            None => {\n+                for (id, ty) in [(first_id, second_ty), (second_id, first_ty)] {\n+                    if let Some(id) = id\n+                        && let hir::Node::Block(blk) = self.tcx.hir().get(id)\n+                        && self.consider_returning_binding(blk, ty, err)\n+                    {\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    pub(super) fn suggest_boxing_for_return_impl_trait(\n+        &self,\n+        err: &mut Diagnostic,\n+        return_sp: Span,\n+        arm_spans: impl Iterator<Item = Span>,\n+    ) {\n+        err.multipart_suggestion(\n+            \"you could change the return type to be a boxed trait object\",\n+            vec![\n+                (return_sp.with_hi(return_sp.lo() + BytePos(4)), \"Box<dyn\".to_string()),\n+                (return_sp.shrink_to_hi(), \">\".to_string()),\n+            ],\n+            Applicability::MaybeIncorrect,\n+        );\n+        let sugg = arm_spans\n+            .flat_map(|sp| {\n+                [(sp.shrink_to_lo(), \"Box::new(\".to_string()), (sp.shrink_to_hi(), \")\".to_string())]\n+                    .into_iter()\n+            })\n+            .collect::<Vec<_>>();\n+        err.multipart_suggestion(\n+            \"if you change the return type to expect trait objects, box the returned expressions\",\n+            sugg,\n+            Applicability::MaybeIncorrect,\n+        );\n+    }\n+\n+    pub(super) fn suggest_tuple_pattern(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n+        diag: &mut Diagnostic,\n+    ) {\n+        // Heavily inspired by `FnCtxt::suggest_compatible_variants`, with\n+        // some modifications due to that being in typeck and this being in infer.\n+        if let ObligationCauseCode::Pattern { .. } = cause.code() {\n+            if let ty::Adt(expected_adt, substs) = exp_found.expected.kind() {\n+                let compatible_variants: Vec<_> = expected_adt\n+                    .variants()\n+                    .iter()\n+                    .filter(|variant| {\n+                        variant.fields.len() == 1 && variant.ctor_kind() == Some(CtorKind::Fn)\n+                    })\n+                    .filter_map(|variant| {\n+                        let sole_field = &variant.fields[0];\n+                        let sole_field_ty = sole_field.ty(self.tcx, substs);\n+                        if self.same_type_modulo_infer(sole_field_ty, exp_found.found) {\n+                            let variant_path =\n+                                with_no_trimmed_paths!(self.tcx.def_path_str(variant.def_id));\n+                            // FIXME #56861: DRYer prelude filtering\n+                            if let Some(path) = variant_path.strip_prefix(\"std::prelude::\") {\n+                                if let Some((_, path)) = path.split_once(\"::\") {\n+                                    return Some(path.to_string());\n+                                }\n+                            }\n+                            Some(variant_path)\n+                        } else {\n+                            None\n+                        }\n+                    })\n+                    .collect();\n+                match &compatible_variants[..] {\n+                    [] => {}\n+                    [variant] => {\n+                        diag.multipart_suggestion_verbose(\n+                            &format!(\"try wrapping the pattern in `{}`\", variant),\n+                            vec![\n+                                (cause.span.shrink_to_lo(), format!(\"{}(\", variant)),\n+                                (cause.span.shrink_to_hi(), \")\".to_string()),\n+                            ],\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                    _ => {\n+                        // More than one matching variant.\n+                        diag.multipart_suggestions(\n+                            &format!(\n+                                \"try wrapping the pattern in a variant of `{}`\",\n+                                self.tcx.def_path_str(expected_adt.did())\n+                            ),\n+                            compatible_variants.into_iter().map(|variant| {\n+                                vec![\n+                                    (cause.span.shrink_to_lo(), format!(\"{}(\", variant)),\n+                                    (cause.span.shrink_to_hi(), \")\".to_string()),\n+                                ]\n+                            }),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /// A possible error is to forget to add `.await` when using futures:\n+    ///\n+    /// ```compile_fail,E0308\n+    /// async fn make_u32() -> u32 {\n+    ///     22\n+    /// }\n+    ///\n+    /// fn take_u32(x: u32) {}\n+    ///\n+    /// async fn foo() {\n+    ///     let x = make_u32();\n+    ///     take_u32(x);\n+    /// }\n+    /// ```\n+    ///\n+    /// This routine checks if the found type `T` implements `Future<Output=U>` where `U` is the\n+    /// expected type. If this is the case, and we are inside of an async body, it suggests adding\n+    /// `.await` to the tail of the expression.\n+    pub(super) fn suggest_await_on_expect_found(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        exp_span: Span,\n+        exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n+        diag: &mut Diagnostic,\n+    ) {\n+        debug!(\n+            \"suggest_await_on_expect_found: exp_span={:?}, expected_ty={:?}, found_ty={:?}\",\n+            exp_span, exp_found.expected, exp_found.found,\n+        );\n+\n+        if let ObligationCauseCode::CompareImplItemObligation { .. } = cause.code() {\n+            return;\n+        }\n+\n+        match (\n+            self.get_impl_future_output_ty(exp_found.expected),\n+            self.get_impl_future_output_ty(exp_found.found),\n+        ) {\n+            (Some(exp), Some(found)) if self.same_type_modulo_infer(exp, found) => match cause\n+                .code()\n+            {\n+                ObligationCauseCode::IfExpression(box IfExpressionCause { then_id, .. }) => {\n+                    let then_span = self.find_block_span_from_hir_id(*then_id);\n+                    diag.multipart_suggestion(\n+                        \"consider `await`ing on both `Future`s\",\n+                        vec![\n+                            (then_span.shrink_to_hi(), \".await\".to_string()),\n+                            (exp_span.shrink_to_hi(), \".await\".to_string()),\n+                        ],\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n+                    prior_arms,\n+                    ..\n+                }) => {\n+                    if let [.., arm_span] = &prior_arms[..] {\n+                        diag.multipart_suggestion(\n+                            \"consider `await`ing on both `Future`s\",\n+                            vec![\n+                                (arm_span.shrink_to_hi(), \".await\".to_string()),\n+                                (exp_span.shrink_to_hi(), \".await\".to_string()),\n+                            ],\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    } else {\n+                        diag.help(\"consider `await`ing on both `Future`s\");\n+                    }\n+                }\n+                _ => {\n+                    diag.help(\"consider `await`ing on both `Future`s\");\n+                }\n+            },\n+            (_, Some(ty)) if self.same_type_modulo_infer(exp_found.expected, ty) => {\n+                diag.span_suggestion_verbose(\n+                    exp_span.shrink_to_hi(),\n+                    \"consider `await`ing on the `Future`\",\n+                    \".await\",\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+            (Some(ty), _) if self.same_type_modulo_infer(ty, exp_found.found) => match cause.code()\n+            {\n+                ObligationCauseCode::Pattern { span: Some(then_span), .. } => {\n+                    diag.span_suggestion_verbose(\n+                        then_span.shrink_to_hi(),\n+                        \"consider `await`ing on the `Future`\",\n+                        \".await\",\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                ObligationCauseCode::IfExpression(box IfExpressionCause { then_id, .. }) => {\n+                    let then_span = self.find_block_span_from_hir_id(*then_id);\n+                    diag.span_suggestion_verbose(\n+                        then_span.shrink_to_hi(),\n+                        \"consider `await`ing on the `Future`\",\n+                        \".await\",\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n+                    ref prior_arms,\n+                    ..\n+                }) => {\n+                    diag.multipart_suggestion_verbose(\n+                        \"consider `await`ing on the `Future`\",\n+                        prior_arms\n+                            .iter()\n+                            .map(|arm| (arm.shrink_to_hi(), \".await\".to_string()))\n+                            .collect(),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                _ => {}\n+            },\n+            _ => {}\n+        }\n+    }\n+\n+    pub(super) fn suggest_accessing_field_where_appropriate(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n+        diag: &mut Diagnostic,\n+    ) {\n+        debug!(\n+            \"suggest_accessing_field_where_appropriate(cause={:?}, exp_found={:?})\",\n+            cause, exp_found\n+        );\n+        if let ty::Adt(expected_def, expected_substs) = exp_found.expected.kind() {\n+            if expected_def.is_enum() {\n+                return;\n+            }\n+\n+            if let Some((name, ty)) = expected_def\n+                .non_enum_variant()\n+                .fields\n+                .iter()\n+                .filter(|field| field.vis.is_accessible_from(field.did, self.tcx))\n+                .map(|field| (field.name, field.ty(self.tcx, expected_substs)))\n+                .find(|(_, ty)| self.same_type_modulo_infer(*ty, exp_found.found))\n+            {\n+                if let ObligationCauseCode::Pattern { span: Some(span), .. } = *cause.code() {\n+                    if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n+                        let suggestion = if expected_def.is_struct() {\n+                            format!(\"{}.{}\", snippet, name)\n+                        } else if expected_def.is_union() {\n+                            format!(\"unsafe {{ {}.{} }}\", snippet, name)\n+                        } else {\n+                            return;\n+                        };\n+                        diag.span_suggestion(\n+                            span,\n+                            &format!(\n+                                \"you might have meant to use field `{}` whose type is `{}`\",\n+                                name, ty\n+                            ),\n+                            suggestion,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /// When encountering a case where `.as_ref()` on a `Result` or `Option` would be appropriate,\n+    /// suggests it.\n+    pub(super) fn suggest_as_ref_where_appropriate(\n+        &self,\n+        span: Span,\n+        exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n+        diag: &mut Diagnostic,\n+    ) {\n+        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span)\n+            && let Some(msg) = self.should_suggest_as_ref(exp_found.expected, exp_found.found)\n+        {\n+            diag.span_suggestion(\n+                span,\n+                msg,\n+                // HACK: fix issue# 100605, suggesting convert from &Option<T> to Option<&T>, remove the extra `&`\n+                format!(\"{}.as_ref()\", snippet.trim_start_matches('&')),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+\n+    pub fn should_suggest_as_ref(&self, expected: Ty<'tcx>, found: Ty<'tcx>) -> Option<&str> {\n+        if let (ty::Adt(exp_def, exp_substs), ty::Ref(_, found_ty, _)) =\n+            (expected.kind(), found.kind())\n+        {\n+            if let ty::Adt(found_def, found_substs) = *found_ty.kind() {\n+                if exp_def == &found_def {\n+                    let have_as_ref = &[\n+                        (\n+                            sym::Option,\n+                            \"you can convert from `&Option<T>` to `Option<&T>` using \\\n+                        `.as_ref()`\",\n+                        ),\n+                        (\n+                            sym::Result,\n+                            \"you can convert from `&Result<T, E>` to \\\n+                        `Result<&T, &E>` using `.as_ref()`\",\n+                        ),\n+                    ];\n+                    if let Some(msg) = have_as_ref.iter().find_map(|(name, msg)| {\n+                        self.tcx.is_diagnostic_item(*name, exp_def.did()).then_some(msg)\n+                    }) {\n+                        let mut show_suggestion = true;\n+                        for (exp_ty, found_ty) in\n+                            std::iter::zip(exp_substs.types(), found_substs.types())\n+                        {\n+                            match *exp_ty.kind() {\n+                                ty::Ref(_, exp_ty, _) => {\n+                                    match (exp_ty.kind(), found_ty.kind()) {\n+                                        (_, ty::Param(_))\n+                                        | (_, ty::Infer(_))\n+                                        | (ty::Param(_), _)\n+                                        | (ty::Infer(_), _) => {}\n+                                        _ if self.same_type_modulo_infer(exp_ty, found_ty) => {}\n+                                        _ => show_suggestion = false,\n+                                    };\n+                                }\n+                                ty::Param(_) | ty::Infer(_) => {}\n+                                _ => show_suggestion = false,\n+                            }\n+                        }\n+                        if show_suggestion {\n+                            return Some(*msg);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        None\n+    }\n+\n+    /// Try to find code with pattern `if Some(..) = expr`\n+    /// use a `visitor` to mark the `if` which its span contains given error span,\n+    /// and then try to find a assignment in the `cond` part, which span is equal with error span\n+    pub(super) fn suggest_let_for_letchains(\n+        &self,\n+        err: &mut Diagnostic,\n+        cause: &ObligationCause<'_>,\n+        span: Span,\n+    ) {\n+        let hir = self.tcx.hir();\n+        let fn_hir_id = hir.get_parent_node(cause.body_id);\n+        if let Some(node) = self.tcx.hir().find(fn_hir_id) &&\n+            let hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Fn(_sig, _, body_id), ..\n+                }) = node {\n+        let body = hir.body(*body_id);\n+\n+        /// Find the if expression with given span\n+        struct IfVisitor {\n+            pub result: bool,\n+            pub found_if: bool,\n+            pub err_span: Span,\n+        }\n+\n+        impl<'v> Visitor<'v> for IfVisitor {\n+            fn visit_expr(&mut self, ex: &'v hir::Expr<'v>) {\n+                if self.result { return; }\n+                match ex.kind {\n+                    hir::ExprKind::If(cond, _, _) => {\n+                        self.found_if = true;\n+                        walk_expr(self, cond);\n+                        self.found_if = false;\n+                    }\n+                    _ => walk_expr(self, ex),\n+                }\n+            }\n+\n+            fn visit_stmt(&mut self, ex: &'v hir::Stmt<'v>) {\n+                if let hir::StmtKind::Local(hir::Local {\n+                        span, pat: hir::Pat{..}, ty: None, init: Some(_), ..\n+                    }) = &ex.kind\n+                    && self.found_if\n+                    && span.eq(&self.err_span) {\n+                        self.result = true;\n+                }\n+                walk_stmt(self, ex);\n+            }\n+\n+            fn visit_body(&mut self, body: &'v hir::Body<'v>) {\n+                hir::intravisit::walk_body(self, body);\n+            }\n+        }\n+\n+        let mut visitor = IfVisitor { err_span: span, found_if: false, result: false };\n+        visitor.visit_body(&body);\n+        if visitor.result {\n+                err.subdiagnostic(SuggAddLetForLetChains{span: span.shrink_to_lo()});\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n+    /// Be helpful when the user wrote `{... expr; }` and taking the `;` off\n+    /// is enough to fix the error.\n+    pub fn could_remove_semicolon(\n+        &self,\n+        blk: &'tcx hir::Block<'tcx>,\n+        expected_ty: Ty<'tcx>,\n+    ) -> Option<(Span, StatementAsExpression)> {\n+        let blk = blk.innermost_block();\n+        // Do not suggest if we have a tail expr.\n+        if blk.expr.is_some() {\n+            return None;\n+        }\n+        let last_stmt = blk.stmts.last()?;\n+        let hir::StmtKind::Semi(ref last_expr) = last_stmt.kind else {\n+            return None;\n+        };\n+        let last_expr_ty = self.typeck_results.as_ref()?.expr_ty_opt(*last_expr)?;\n+        let needs_box = match (last_expr_ty.kind(), expected_ty.kind()) {\n+            _ if last_expr_ty.references_error() => return None,\n+            _ if self.same_type_modulo_infer(last_expr_ty, expected_ty) => {\n+                StatementAsExpression::CorrectType\n+            }\n+            (ty::Opaque(last_def_id, _), ty::Opaque(exp_def_id, _))\n+                if last_def_id == exp_def_id =>\n+            {\n+                StatementAsExpression::CorrectType\n+            }\n+            (ty::Opaque(last_def_id, last_bounds), ty::Opaque(exp_def_id, exp_bounds)) => {\n+                debug!(\n+                    \"both opaque, likely future {:?} {:?} {:?} {:?}\",\n+                    last_def_id, last_bounds, exp_def_id, exp_bounds\n+                );\n+\n+                let last_local_id = last_def_id.as_local()?;\n+                let exp_local_id = exp_def_id.as_local()?;\n+\n+                match (\n+                    &self.tcx.hir().expect_item(last_local_id).kind,\n+                    &self.tcx.hir().expect_item(exp_local_id).kind,\n+                ) {\n+                    (\n+                        hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds: last_bounds, .. }),\n+                        hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds: exp_bounds, .. }),\n+                    ) if std::iter::zip(*last_bounds, *exp_bounds).all(|(left, right)| {\n+                        match (left, right) {\n+                            (\n+                                hir::GenericBound::Trait(tl, ml),\n+                                hir::GenericBound::Trait(tr, mr),\n+                            ) if tl.trait_ref.trait_def_id() == tr.trait_ref.trait_def_id()\n+                                && ml == mr =>\n+                            {\n+                                true\n+                            }\n+                            (\n+                                hir::GenericBound::LangItemTrait(langl, _, _, argsl),\n+                                hir::GenericBound::LangItemTrait(langr, _, _, argsr),\n+                            ) if langl == langr => {\n+                                // FIXME: consider the bounds!\n+                                debug!(\"{:?} {:?}\", argsl, argsr);\n+                                true\n+                            }\n+                            _ => false,\n+                        }\n+                    }) =>\n+                    {\n+                        StatementAsExpression::NeedsBoxing\n+                    }\n+                    _ => StatementAsExpression::CorrectType,\n+                }\n+            }\n+            _ => return None,\n+        };\n+        let span = if last_stmt.span.from_expansion() {\n+            let mac_call = rustc_span::source_map::original_sp(last_stmt.span, blk.span);\n+            self.tcx.sess.source_map().mac_call_stmt_semi_span(mac_call)?\n+        } else {\n+            last_stmt.span.with_lo(last_stmt.span.hi() - BytePos(1))\n+        };\n+        Some((span, needs_box))\n+    }\n+\n+    /// Suggest returning a local binding with a compatible type if the block\n+    /// has no return expression.\n+    pub fn consider_returning_binding(\n+        &self,\n+        blk: &'tcx hir::Block<'tcx>,\n+        expected_ty: Ty<'tcx>,\n+        err: &mut Diagnostic,\n+    ) -> bool {\n+        let blk = blk.innermost_block();\n+        // Do not suggest if we have a tail expr.\n+        if blk.expr.is_some() {\n+            return false;\n+        }\n+        let mut shadowed = FxIndexSet::default();\n+        let mut candidate_idents = vec![];\n+        let mut find_compatible_candidates = |pat: &hir::Pat<'_>| {\n+            if let hir::PatKind::Binding(_, hir_id, ident, _) = &pat.kind\n+                && let Some(pat_ty) = self\n+                    .typeck_results\n+                    .as_ref()\n+                    .and_then(|typeck_results| typeck_results.node_type_opt(*hir_id))\n+            {\n+                let pat_ty = self.resolve_vars_if_possible(pat_ty);\n+                if self.same_type_modulo_infer(pat_ty, expected_ty)\n+                    && !(pat_ty, expected_ty).references_error()\n+                    && shadowed.insert(ident.name)\n+                {\n+                    candidate_idents.push((*ident, pat_ty));\n+                }\n+            }\n+            true\n+        };\n+\n+        let hir = self.tcx.hir();\n+        for stmt in blk.stmts.iter().rev() {\n+            let hir::StmtKind::Local(local) = &stmt.kind else { continue; };\n+            local.pat.walk(&mut find_compatible_candidates);\n+        }\n+        match hir.find(hir.get_parent_node(blk.hir_id)) {\n+            Some(hir::Node::Expr(hir::Expr { hir_id, .. })) => {\n+                match hir.find(hir.get_parent_node(*hir_id)) {\n+                    Some(hir::Node::Arm(hir::Arm { pat, .. })) => {\n+                        pat.walk(&mut find_compatible_candidates);\n+                    }\n+                    Some(\n+                        hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, _, body), .. })\n+                        | hir::Node::ImplItem(hir::ImplItem {\n+                            kind: hir::ImplItemKind::Fn(_, body),\n+                            ..\n+                        })\n+                        | hir::Node::TraitItem(hir::TraitItem {\n+                            kind: hir::TraitItemKind::Fn(_, hir::TraitFn::Provided(body)),\n+                            ..\n+                        })\n+                        | hir::Node::Expr(hir::Expr {\n+                            kind: hir::ExprKind::Closure(hir::Closure { body, .. }),\n+                            ..\n+                        }),\n+                    ) => {\n+                        for param in hir.body(*body).params {\n+                            param.pat.walk(&mut find_compatible_candidates);\n+                        }\n+                    }\n+                    Some(hir::Node::Expr(hir::Expr {\n+                        kind:\n+                            hir::ExprKind::If(\n+                                hir::Expr { kind: hir::ExprKind::Let(let_), .. },\n+                                then_block,\n+                                _,\n+                            ),\n+                        ..\n+                    })) if then_block.hir_id == *hir_id => {\n+                        let_.pat.walk(&mut find_compatible_candidates);\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        match &candidate_idents[..] {\n+            [(ident, _ty)] => {\n+                let sm = self.tcx.sess.source_map();\n+                if let Some(stmt) = blk.stmts.last() {\n+                    let stmt_span = sm.stmt_span(stmt.span, blk.span);\n+                    let sugg = if sm.is_multiline(blk.span)\n+                        && let Some(spacing) = sm.indentation_before(stmt_span)\n+                    {\n+                        format!(\"\\n{spacing}{ident}\")\n+                    } else {\n+                        format!(\" {ident}\")\n+                    };\n+                    err.span_suggestion_verbose(\n+                        stmt_span.shrink_to_hi(),\n+                        format!(\"consider returning the local binding `{ident}`\"),\n+                        sugg,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                } else {\n+                    let sugg = if sm.is_multiline(blk.span)\n+                        && let Some(spacing) = sm.indentation_before(blk.span.shrink_to_lo())\n+                    {\n+                        format!(\"\\n{spacing}    {ident}\\n{spacing}\")\n+                    } else {\n+                        format!(\" {ident} \")\n+                    };\n+                    let left_span = sm.span_through_char(blk.span, '{').shrink_to_hi();\n+                    err.span_suggestion_verbose(\n+                        sm.span_extend_while(left_span, |c| c.is_whitespace()).unwrap_or(left_span),\n+                        format!(\"consider returning the local binding `{ident}`\"),\n+                        sugg,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                true\n+            }\n+            values if (1..3).contains(&values.len()) => {\n+                let spans = values.iter().map(|(ident, _)| ident.span).collect::<Vec<_>>();\n+                err.span_note(spans, \"consider returning one of these bindings\");\n+                true\n+            }\n+            _ => false,\n+        }\n+    }\n+}"}, {"sha": "2ccbd164faaf16d1926814d2319190848bb0cee7", "filename": "compiler/rustc_infer/src/infer/note.rs", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/3b9daac6a27159bbe08e39fbc2722f40e91941d7/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b9daac6a27159bbe08e39fbc2722f40e91941d7/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnote.rs?ref=3b9daac6a27159bbe08e39fbc2722f40e91941d7", "patch": "@@ -0,0 +1,203 @@\n+impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n+    fn note_error_origin(\n+        &self,\n+        err: &mut Diagnostic,\n+        cause: &ObligationCause<'tcx>,\n+        exp_found: Option<ty::error::ExpectedFound<Ty<'tcx>>>,\n+        terr: TypeError<'tcx>,\n+    ) {\n+        match *cause.code() {\n+            ObligationCauseCode::Pattern { origin_expr: true, span: Some(span), root_ty } => {\n+                let ty = self.resolve_vars_if_possible(root_ty);\n+                if !matches!(ty.kind(), ty::Infer(ty::InferTy::TyVar(_) | ty::InferTy::FreshTy(_)))\n+                {\n+                    // don't show type `_`\n+                    if span.desugaring_kind() == Some(DesugaringKind::ForLoop)\n+                        && let ty::Adt(def, substs) = ty.kind()\n+                        && Some(def.did()) == self.tcx.get_diagnostic_item(sym::Option)\n+                    {\n+                        err.span_label(span, format!(\"this is an iterator with items of type `{}`\", substs.type_at(0)));\n+                    } else {\n+                    err.span_label(span, format!(\"this expression has type `{}`\", ty));\n+                }\n+                }\n+                if let Some(ty::error::ExpectedFound { found, .. }) = exp_found\n+                    && ty.is_box() && ty.boxed_ty() == found\n+                    && let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span)\n+                {\n+                    err.span_suggestion(\n+                        span,\n+                        \"consider dereferencing the boxed value\",\n+                        format!(\"*{}\", snippet),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n+            ObligationCauseCode::Pattern { origin_expr: false, span: Some(span), .. } => {\n+                err.span_label(span, \"expected due to this\");\n+            }\n+            ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n+                arm_block_id,\n+                arm_span,\n+                arm_ty,\n+                prior_arm_block_id,\n+                prior_arm_span,\n+                prior_arm_ty,\n+                source,\n+                ref prior_arms,\n+                scrut_hir_id,\n+                opt_suggest_box_span,\n+                scrut_span,\n+                ..\n+            }) => match source {\n+                hir::MatchSource::TryDesugar => {\n+                    if let Some(ty::error::ExpectedFound { expected, .. }) = exp_found {\n+                        let scrut_expr = self.tcx.hir().expect_expr(scrut_hir_id);\n+                        let scrut_ty = if let hir::ExprKind::Call(_, args) = &scrut_expr.kind {\n+                            let arg_expr = args.first().expect(\"try desugaring call w/out arg\");\n+                            self.typeck_results.as_ref().and_then(|typeck_results| {\n+                                typeck_results.expr_ty_opt(arg_expr)\n+                            })\n+                        } else {\n+                            bug!(\"try desugaring w/out call expr as scrutinee\");\n+                        };\n+\n+                        match scrut_ty {\n+                            Some(ty) if expected == ty => {\n+                                let source_map = self.tcx.sess.source_map();\n+                                err.span_suggestion(\n+                                    source_map.end_point(cause.span),\n+                                    \"try removing this `?`\",\n+                                    \"\",\n+                                    Applicability::MachineApplicable,\n+                                );\n+                            }\n+                            _ => {}\n+                        }\n+                    }\n+                }\n+                _ => {\n+                    // `prior_arm_ty` can be `!`, `expected` will have better info when present.\n+                    let t = self.resolve_vars_if_possible(match exp_found {\n+                        Some(ty::error::ExpectedFound { expected, .. }) => expected,\n+                        _ => prior_arm_ty,\n+                    });\n+                    let source_map = self.tcx.sess.source_map();\n+                    let mut any_multiline_arm = source_map.is_multiline(arm_span);\n+                    if prior_arms.len() <= 4 {\n+                        for sp in prior_arms {\n+                            any_multiline_arm |= source_map.is_multiline(*sp);\n+                            err.span_label(*sp, format!(\"this is found to be of type `{}`\", t));\n+                        }\n+                    } else if let Some(sp) = prior_arms.last() {\n+                        any_multiline_arm |= source_map.is_multiline(*sp);\n+                        err.span_label(\n+                            *sp,\n+                            format!(\"this and all prior arms are found to be of type `{}`\", t),\n+                        );\n+                    }\n+                    let outer_error_span = if any_multiline_arm {\n+                        // Cover just `match` and the scrutinee expression, not\n+                        // the entire match body, to reduce diagram noise.\n+                        cause.span.shrink_to_lo().to(scrut_span)\n+                    } else {\n+                        cause.span\n+                    };\n+                    let msg = \"`match` arms have incompatible types\";\n+                    err.span_label(outer_error_span, msg);\n+                    self.suggest_remove_semi_or_return_binding(\n+                        err,\n+                        prior_arm_block_id,\n+                        prior_arm_ty,\n+                        prior_arm_span,\n+                        arm_block_id,\n+                        arm_ty,\n+                        arm_span,\n+                    );\n+                    if let Some(ret_sp) = opt_suggest_box_span {\n+                        // Get return type span and point to it.\n+                        self.suggest_boxing_for_return_impl_trait(\n+                            err,\n+                            ret_sp,\n+                            prior_arms.iter().chain(std::iter::once(&arm_span)).map(|s| *s),\n+                        );\n+                    }\n+                }\n+            },\n+            ObligationCauseCode::IfExpression(box IfExpressionCause {\n+                then_id,\n+                else_id,\n+                then_ty,\n+                else_ty,\n+                outer_span,\n+                opt_suggest_box_span,\n+            }) => {\n+                let then_span = self.find_block_span_from_hir_id(then_id);\n+                let else_span = self.find_block_span_from_hir_id(else_id);\n+                err.span_label(then_span, \"expected because of this\");\n+                if let Some(sp) = outer_span {\n+                    err.span_label(sp, \"`if` and `else` have incompatible types\");\n+                }\n+                self.suggest_remove_semi_or_return_binding(\n+                    err,\n+                    Some(then_id),\n+                    then_ty,\n+                    then_span,\n+                    Some(else_id),\n+                    else_ty,\n+                    else_span,\n+                );\n+                if let Some(ret_sp) = opt_suggest_box_span {\n+                    self.suggest_boxing_for_return_impl_trait(\n+                        err,\n+                        ret_sp,\n+                        [then_span, else_span].into_iter(),\n+                    );\n+                }\n+            }\n+            ObligationCauseCode::LetElse => {\n+                err.help(\"try adding a diverging expression, such as `return` or `panic!(..)`\");\n+                err.help(\"...or use `match` instead of `let...else`\");\n+            }\n+            _ => {\n+                if let ObligationCauseCode::BindingObligation(_, span)\n+                | ObligationCauseCode::ExprBindingObligation(_, span, ..)\n+                = cause.code().peel_derives()\n+                    && let TypeError::RegionsPlaceholderMismatch = terr\n+                {\n+                    err.span_note( * span,\n+                    \"the lifetime requirement is introduced here\");\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> InferCtxt<'tcx> {\n+    /// Given a [`hir::Block`], get the span of its last expression or\n+    /// statement, peeling off any inner blocks.\n+    pub fn find_block_span(&self, block: &'tcx hir::Block<'tcx>) -> Span {\n+        let block = block.innermost_block();\n+        if let Some(expr) = &block.expr {\n+            expr.span\n+        } else if let Some(stmt) = block.stmts.last() {\n+            // possibly incorrect trailing `;` in the else arm\n+            stmt.span\n+        } else {\n+            // empty block; point at its entirety\n+            block.span\n+        }\n+    }\n+\n+    /// Given a [`hir::HirId`] for a block, get the span of its last expression\n+    /// or statement, peeling off any inner blocks.\n+    pub fn find_block_span_from_hir_id(&self, hir_id: hir::HirId) -> Span {\n+        match self.tcx.hir().get(hir_id) {\n+            hir::Node::Block(blk) => self.find_block_span(blk),\n+            // The parser was in a weird state if either of these happen, but\n+            // it's better not to panic.\n+            hir::Node::Expr(e) => e.span,\n+            _ => rustc_span::DUMMY_SP,\n+        }\n+    }\n+}"}, {"sha": "9aa26667e7bf461ef3059ade70551ccff81ee75e", "filename": "compiler/rustc_traits/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b9daac6a27159bbe08e39fbc2722f40e91941d7/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b9daac6a27159bbe08e39fbc2722f40e91941d7/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Flib.rs?ref=3b9daac6a27159bbe08e39fbc2722f40e91941d7", "patch": "@@ -12,13 +12,13 @@ extern crate tracing;\n extern crate rustc_middle;\n \n mod chalk;\n+mod codegen;\n mod dropck_outlives;\n mod evaluate_obligation;\n mod implied_outlives_bounds;\n mod normalize_erasing_regions;\n mod normalize_projection_ty;\n mod type_op;\n-mod codegen;\n \n pub use type_op::{type_op_ascribe_user_type_with_span, type_op_prove_predicate_with_cause};\n "}]}