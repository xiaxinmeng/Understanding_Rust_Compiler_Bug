{"sha": "ce5e910e602a46c7e18a6f2f731ddac971da8fdb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlNWU5MTBlNjAyYTQ2YzdlMThhNmYyZjczMWRkYWM5NzFkYThmZGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-03T17:13:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-03T17:13:09Z"}, "message": "Auto merge of #820 - RalfJung:intptrcast, r=RalfJung\n\nMake most tests work with Intptrcast\n\nThe one that still fails (amusingly, that's ptr_int_casts) requires some help from the librustc_mir side.", "tree": {"sha": "1f209515f9c4d46b56a4404a0cd5465f7496b23a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f209515f9c4d46b56a4404a0cd5465f7496b23a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce5e910e602a46c7e18a6f2f731ddac971da8fdb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce5e910e602a46c7e18a6f2f731ddac971da8fdb", "html_url": "https://github.com/rust-lang/rust/commit/ce5e910e602a46c7e18a6f2f731ddac971da8fdb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce5e910e602a46c7e18a6f2f731ddac971da8fdb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39c9e793b98d91e54c0d8da3c5cb08661ebae17e", "url": "https://api.github.com/repos/rust-lang/rust/commits/39c9e793b98d91e54c0d8da3c5cb08661ebae17e", "html_url": "https://github.com/rust-lang/rust/commit/39c9e793b98d91e54c0d8da3c5cb08661ebae17e"}, {"sha": "b29cb7d551cece20ec0fe0b378edaeb1318d702d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b29cb7d551cece20ec0fe0b378edaeb1318d702d", "html_url": "https://github.com/rust-lang/rust/commit/b29cb7d551cece20ec0fe0b378edaeb1318d702d"}], "stats": {"total": 172, "additions": 109, "deletions": 63}, "files": [{"sha": "69c66db52147ed4f6d56f8610537501c4c9c97cb", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce5e910e602a46c7e18a6f2f731ddac971da8fdb/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/ce5e910e602a46c7e18a6f2f731ddac971da8fdb/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=ce5e910e602a46c7e18a6f2f731ddac971da8fdb", "patch": "@@ -279,6 +279,8 @@ Several `-Z` flags are relevant for Miri:\n * `-Zalways-encode-mir` makes rustc dump MIR even for completely monomorphic\n   functions.  This is needed so that Miri can execute such functions, so Miri\n   sets this flag per default.\n+* `-Zmir-emit-retag` controls whether `Retag` statements are emitted. Miri\n+  enables this per default because it is needed for validation.\n \n Moreover, Miri recognizes some environment variables:\n "}, {"sha": "a1157af0e39b6d3103d5baf373a72f269167da8d", "filename": "src/eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce5e910e602a46c7e18a6f2f731ddac971da8fdb/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce5e910e602a46c7e18a6f2f731ddac971da8fdb/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=ce5e910e602a46c7e18a6f2f731ddac971da8fdb", "patch": "@@ -32,11 +32,11 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n     let mut ecx = InterpretCx::new(\n         tcx.at(syntax::source_map::DUMMY_SP),\n         ty::ParamEnv::reveal_all(),\n-        Evaluator::new(config.validate),\n+        Evaluator::new(),\n     );\n \n     // FIXME: InterpretCx::new should take an initial MemoryExtra\n-    ecx.memory_mut().extra = MemoryExtra::with_rng(config.seed.map(StdRng::seed_from_u64));\n+    ecx.memory_mut().extra = MemoryExtra::new(config.seed.map(StdRng::seed_from_u64), config.validate);\n     \n     let main_instance = ty::Instance::mono(ecx.tcx.tcx, main_id);\n     let main_mir = ecx.load_mir(main_instance.def)?;"}, {"sha": "16451fb8726a6fb49b26133f894b61b7d84f3995", "filename": "src/helpers.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ce5e910e602a46c7e18a6f2f731ddac971da8fdb/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce5e910e602a46c7e18a6f2f731ddac971da8fdb/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=ce5e910e602a46c7e18a6f2f731ddac971da8fdb", "patch": "@@ -58,6 +58,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             .map(|(size, _)| size)\n             .unwrap_or_else(|| place.layout.size)\n         );\n+        assert!(size.bytes() > 0);\n         // Store how far we proceeded into the place so far. Everything to the left of\n         // this offset has already been handled, in the sense that the frozen parts\n         // have had `action` called on them."}, {"sha": "5797895c54f809b888ad9615bd2f4269794cec7e", "filename": "src/intptrcast.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ce5e910e602a46c7e18a6f2f731ddac971da8fdb/src%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce5e910e602a46c7e18a6f2f731ddac971da8fdb/src%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintptrcast.rs?ref=ce5e910e602a46c7e18a6f2f731ddac971da8fdb", "patch": "@@ -4,7 +4,8 @@ use std::cmp::max;\n \n use rand::Rng;\n \n-use rustc_mir::interpret::{AllocId, Pointer, InterpResult, Memory, AllocCheck};\n+use rustc::ty::layout::HasDataLayout;\n+use rustc_mir::interpret::{AllocId, Pointer, InterpResult, Memory, AllocCheck, PointerArithmetic};\n use rustc_target::abi::Size;\n \n use crate::{Evaluator, Tag, STACK_ADDR};\n@@ -75,7 +76,9 @@ impl<'mir, 'tcx> GlobalState {\n         let mut global_state = memory.extra.intptrcast.borrow_mut();\n         let global_state = &mut *global_state;\n \n-        let (size, align) = memory.get_size_and_align(ptr.alloc_id, AllocCheck::Live)?;\n+        // There is nothing wrong with a raw pointer being cast to an integer only after\n+        // it became dangling.  Hence `MaybeDead`.\n+        let (size, align) = memory.get_size_and_align(ptr.alloc_id, AllocCheck::MaybeDead)?;\n \n         let base_addr = match global_state.base_addr.entry(ptr.alloc_id) {\n             Entry::Occupied(entry) => *entry.get(),\n@@ -107,7 +110,9 @@ impl<'mir, 'tcx> GlobalState {\n         };\n \n         debug_assert_eq!(base_addr % align.bytes(), 0); // sanity check\n-        Ok(base_addr + ptr.offset.bytes())\n+        // Add offset with the right kind of pointer-overflowing arithmetic.\n+        let dl = memory.data_layout();\n+        Ok(dl.overflowing_offset(base_addr, ptr.offset.bytes()).0)\n     }\n \n     /// Shifts `addr` to make it aligned with `align` by rounding `addr` to the smallest multiple"}, {"sha": "0ddb2d40b8e8575f0eabe9d9459a6fd480796983", "filename": "src/machine.rs", "status": "modified", "additions": 52, "deletions": 26, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/ce5e910e602a46c7e18a6f2f731ddac971da8fdb/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce5e910e602a46c7e18a6f2f731ddac971da8fdb/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=ce5e910e602a46c7e18a6f2f731ddac971da8fdb", "patch": "@@ -41,25 +41,31 @@ impl Into<MemoryKind<MiriMemoryKind>> for MiriMemoryKind {\n /// Extra per-allocation data\n #[derive(Debug, Clone)]\n pub struct AllocExtra {\n-    pub stacked_borrows: stacked_borrows::AllocExtra,\n+    /// Stacked Borrows state is only added if validation is enabled.\n+    pub stacked_borrows: Option<stacked_borrows::AllocExtra>,\n }\n \n /// Extra global memory data\n #[derive(Default, Clone, Debug)]\n pub struct MemoryExtra {\n     pub stacked_borrows: stacked_borrows::MemoryExtra,\n     pub intptrcast: intptrcast::MemoryExtra,\n+\n     /// The random number generator to use if Miri is running in non-deterministic mode and to\n     /// enable intptrcast\n-    pub(crate) rng: Option<RefCell<StdRng>>\n+    pub(crate) rng: Option<RefCell<StdRng>>,\n+\n+    /// Whether to enforce the validity invariant.\n+    pub(crate) validate: bool,\n }\n \n impl MemoryExtra {\n-    pub fn with_rng(rng: Option<StdRng>) -> Self {\n+    pub fn new(rng: Option<StdRng>, validate: bool) -> Self {\n         MemoryExtra {\n             stacked_borrows: Default::default(),\n             intptrcast: Default::default(),\n             rng: rng.map(RefCell::new),\n+            validate,\n         }\n     }\n }\n@@ -82,21 +88,17 @@ pub struct Evaluator<'tcx> {\n \n     /// TLS state.\n     pub(crate) tls: TlsData<'tcx>,\n-\n-    /// Whether to enforce the validity invariant.\n-    pub(crate) validate: bool,\n }\n \n impl<'tcx> Evaluator<'tcx> {\n-    pub(crate) fn new(validate: bool) -> Self {\n+    pub(crate) fn new() -> Self {\n         Evaluator {\n             env_vars: HashMap::default(),\n             argc: None,\n             argv: None,\n             cmd_line: None,\n             last_error: 0,\n             tls: TlsData::default(),\n-            validate,\n         }\n     }\n }\n@@ -135,7 +137,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n \n     #[inline(always)]\n     fn enforce_validity(ecx: &InterpretCx<'mir, 'tcx, Self>) -> bool {\n-        ecx.machine.validate\n+        ecx.memory().extra.validate\n     }\n \n     /// Returns `Ok()` when the function was handled; fail otherwise.\n@@ -251,12 +253,17 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     ) -> (Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>>, Self::PointerTag) {\n         let kind = kind.expect(\"we set our STATIC_KIND so this cannot be None\");\n         let alloc = alloc.into_owned();\n-        let (stacks, base_tag) = Stacks::new_allocation(\n-            id,\n-            Size::from_bytes(alloc.bytes.len() as u64),\n-            Rc::clone(&memory.extra.stacked_borrows),\n-            kind,\n-        );\n+        let (stacks, base_tag) = if !memory.extra.validate {\n+            (None, Tag::Untagged)\n+        } else {\n+            let (stacks, base_tag) = Stacks::new_allocation(\n+                id,\n+                Size::from_bytes(alloc.bytes.len() as u64),\n+                Rc::clone(&memory.extra.stacked_borrows),\n+                kind,\n+            );\n+            (Some(stacks), base_tag)\n+        };\n         if kind != MiriMemoryKind::Static.into() {\n             assert!(alloc.relocations.is_empty(), \"Only statics can come initialized with inner pointers\");\n             // Now we can rely on the inner pointers being static, too.\n@@ -268,7 +275,14 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n                 alloc.relocations.iter()\n                     // The allocations in the relocations (pointers stored *inside* this allocation)\n                     // all get the base pointer tag.\n-                    .map(|&(offset, ((), alloc))| (offset, (memory_extra.static_base_ptr(alloc), alloc)))\n+                    .map(|&(offset, ((), alloc))| {\n+                        let tag = if !memory.extra.validate {\n+                            Tag::Untagged\n+                        } else {\n+                            memory_extra.static_base_ptr(alloc)\n+                        };\n+                        (offset, (tag, alloc))\n+                    })\n                     .collect()\n             ),\n             undef_mask: alloc.undef_mask,\n@@ -286,7 +300,11 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         id: AllocId,\n         memory: &Memory<'mir, 'tcx, Self>,\n     ) -> Self::PointerTag {\n-        memory.extra.stacked_borrows.borrow_mut().static_base_ptr(id)\n+        if !memory.extra.validate {\n+            Tag::Untagged\n+        } else {\n+            memory.extra.stacked_borrows.borrow_mut().static_base_ptr(id)\n+        }\n     }\n \n     #[inline(always)]\n@@ -295,12 +313,8 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         kind: mir::RetagKind,\n         place: PlaceTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx> {\n-        if !ecx.tcx.sess.opts.debugging_opts.mir_emit_retag || !Self::enforce_validity(ecx) {\n-            // No tracking, or no retagging. The latter is possible because a dependency of ours\n-            // might be called with different flags than we are, so there are `Retag`\n-            // statements but we do not want to execute them.\n-            // Also, honor the whitelist in `enforce_validity` because otherwise we might retag\n-            // uninitialized data.\n+        if !Self::enforce_validity(ecx) {\n+            // No tracking.\n              Ok(())\n         } else {\n             ecx.retag(kind, place)\n@@ -354,7 +368,11 @@ impl AllocationExtra<Tag> for AllocExtra {\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> InterpResult<'tcx> {\n-        alloc.extra.stacked_borrows.memory_read(ptr, size)\n+        if let Some(ref stacked_borrows) = alloc.extra.stacked_borrows {\n+            stacked_borrows.memory_read(ptr, size)\n+        } else {\n+            Ok(())\n+        }\n     }\n \n     #[inline(always)]\n@@ -363,7 +381,11 @@ impl AllocationExtra<Tag> for AllocExtra {\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> InterpResult<'tcx> {\n-        alloc.extra.stacked_borrows.memory_written(ptr, size)\n+        if let Some(ref mut stacked_borrows) = alloc.extra.stacked_borrows {\n+            stacked_borrows.memory_written(ptr, size)\n+        } else {\n+            Ok(())\n+        }\n     }\n \n     #[inline(always)]\n@@ -372,7 +394,11 @@ impl AllocationExtra<Tag> for AllocExtra {\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> InterpResult<'tcx> {\n-        alloc.extra.stacked_borrows.memory_deallocated(ptr, size)\n+        if let Some(ref mut stacked_borrows) = alloc.extra.stacked_borrows {\n+            stacked_borrows.memory_deallocated(ptr, size)\n+        } else {\n+            Ok(())\n+        }\n     }\n }\n "}, {"sha": "df60acc661ed4a51899f34bbf1274a43cf1c9656", "filename": "src/operator.rs", "status": "modified", "additions": 31, "deletions": 19, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ce5e910e602a46c7e18a6f2f731ddac971da8fdb/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce5e910e602a46c7e18a6f2f731ddac971da8fdb/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=ce5e910e602a46c7e18a6f2f731ddac971da8fdb", "patch": "@@ -56,10 +56,12 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n \n         trace!(\"ptr_op: {:?} {:?} {:?}\", *left, bin_op, *right);\n \n-        // If intptrcast is enabled and the operation is not an offset\n-        // we can force the cast from pointers to integer addresses and\n-        // then dispatch to rustc binary operation method\n-        if self.memory().extra.rng.is_some() && bin_op != Offset {\n+        // If intptrcast is enabled, treat everything of integer *type* at integer *value*.\n+        if self.memory().extra.rng.is_some() && left.layout.ty.is_integral() {\n+            // This is actually an integer operation, so dispatch back to the core engine.\n+            // TODO: Once intptrcast is the default, librustc_mir should never even call us\n+            // for integer types.\n+            assert!(right.layout.ty.is_integral());\n             let l_bits = self.force_bits(left.imm.to_scalar()?, left.layout.size)?;\n             let r_bits = self.force_bits(right.imm.to_scalar()?, right.layout.size)?;\n             \n@@ -186,6 +188,13 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n         right: Scalar<Tag>,\n     ) -> InterpResult<'tcx, bool> {\n         let size = self.pointer_size();\n+        if self.memory().extra.rng.is_some() {\n+            // Just compare the integers.\n+            // TODO: Do we really want to *always* do that, even when comparing two live in-bounds pointers?\n+            let left = self.force_bits(left, size)?;\n+            let right = self.force_bits(right, size)?;\n+            return Ok(left == right);\n+        }\n         Ok(match (left, right) {\n             (Scalar::Raw { .. }, Scalar::Raw { .. }) =>\n                 left.to_bits(size)? == right.to_bits(size)?,\n@@ -388,21 +397,24 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n             .checked_mul(pointee_size)\n             .ok_or_else(|| InterpError::Overflow(mir::BinOp::Mul))?;\n         // Now let's see what kind of pointer this is.\n-        if let Scalar::Ptr(ptr) = ptr {\n-            // Both old and new pointer must be in-bounds of a *live* allocation.\n-            // (Of the same allocation, but that part is trivial with our representation.)\n-            self.pointer_inbounds(ptr)?;\n-            let ptr = ptr.signed_offset(offset, self)?;\n-            self.pointer_inbounds(ptr)?;\n-            Ok(Scalar::Ptr(ptr))\n-        } else {\n-            // An integer pointer. They can only be offset by 0, and we pretend there\n-            // is a little zero-sized allocation here.\n-            if offset == 0 {\n-                Ok(ptr)\n-            } else {\n-                err!(InvalidPointerMath)\n+        let ptr = if offset == 0 {\n+            match ptr {\n+                Scalar::Ptr(ptr) => ptr,\n+                Scalar::Raw { .. } => {\n+                    // Offset 0 on an integer. We accept that, pretending there is\n+                    // a little zero-sized allocation here.\n+                    return Ok(ptr);\n+                }\n             }\n-        }\n+        } else {\n+            // Offset > 0. We *require* a pointer.\n+            self.force_ptr(ptr)?\n+        };\n+        // Both old and new pointer must be in-bounds of a *live* allocation.\n+        // (Of the same allocation, but that part is trivial with our representation.)\n+        self.pointer_inbounds(ptr)?;\n+        let ptr = ptr.signed_offset(offset, self)?;\n+        self.pointer_inbounds(ptr)?;\n+        Ok(Scalar::Ptr(ptr))\n     }\n }"}, {"sha": "5c59066c475d225cfb101870623181508a3bbd35", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ce5e910e602a46c7e18a6f2f731ddac971da8fdb/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce5e910e602a46c7e18a6f2f731ddac971da8fdb/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=ce5e910e602a46c7e18a6f2f731ddac971da8fdb", "patch": "@@ -538,6 +538,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         // Get the allocation. It might not be mutable, so we cannot use `get_mut`.\n         let alloc = this.memory().get(ptr.alloc_id)?;\n+        let stacked_borrows = alloc.extra.stacked_borrows.as_ref().expect(\"we should have Stacked Borrows data\");\n         // Update the stacks.\n         // Make sure that raw pointers and mutable shared references are reborrowed \"weak\":\n         // There could be existing unique pointers reborrowed from them that should remain valid!\n@@ -553,14 +554,14 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     // We are only ever `SharedReadOnly` inside the frozen bits.\n                     let perm = if frozen { Permission::SharedReadOnly } else { Permission::SharedReadWrite };\n                     let item = Item { perm, tag: new_tag, protector };\n-                    alloc.extra.stacked_borrows.for_each(cur_ptr, size, |stack, global| {\n+                    stacked_borrows.for_each(cur_ptr, size, |stack, global| {\n                         stack.grant(cur_ptr.tag, item, global)\n                     })\n                 });\n             }\n         };\n         let item = Item { perm, tag: new_tag, protector };\n-        alloc.extra.stacked_borrows.for_each(ptr, size, |stack, global| {\n+        stacked_borrows.for_each(ptr, size, |stack, global| {\n             stack.grant(ptr.tag, item, global)\n         })\n     }"}, {"sha": "2d3282a0a97a0c95c72d355de2aacba96e76c89d", "filename": "tests/compile-fail/ptr_offset_int_plus_int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce5e910e602a46c7e18a6f2f731ddac971da8fdb/tests%2Fcompile-fail%2Fptr_offset_int_plus_int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce5e910e602a46c7e18a6f2f731ddac971da8fdb/tests%2Fcompile-fail%2Fptr_offset_int_plus_int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_offset_int_plus_int.rs?ref=ce5e910e602a46c7e18a6f2f731ddac971da8fdb", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern: invalid arithmetic on pointers\n+// error-pattern: tried to interpret some bytes as a pointer\n \n fn main() {\n     // Can't offset an integer pointer by non-zero offset."}, {"sha": "1d32d3a732440f822f3dd2857024c77b67fe030f", "filename": "tests/compiletest.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce5e910e602a46c7e18a6f2f731ddac971da8fdb/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce5e910e602a46c7e18a6f2f731ddac971da8fdb/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=ce5e910e602a46c7e18a6f2f731ddac971da8fdb", "patch": "@@ -69,7 +69,7 @@ fn compile_fail(path: &str, target: &str, opt: bool) {\n     run_tests(\"compile-fail\", path, target, flags);\n }\n \n-fn miri_pass(path: &str, target: &str, opt: bool) {\n+fn miri_pass(path: &str, target: &str, opt: bool, noseed: bool) {\n     let opt_str = if opt { \" with optimizations\" } else { \"\" };\n     eprintln!(\"{}\", format!(\n         \"## Running run-pass tests in {} against miri for target {}{}\",\n@@ -81,6 +81,9 @@ fn miri_pass(path: &str, target: &str, opt: bool) {\n     let mut flags = Vec::new();\n     if opt {\n         flags.push(\"-Zmir-opt-level=3\".to_owned());\n+    } else if !noseed {\n+        // Run with intptrcast.  Avoid test matrix explosion by doing either this or opt-level=3.\n+        flags.push(\"-Zmiri-seed=\".to_owned());\n     }\n \n     run_tests(\"ui\", path, target, flags);\n@@ -104,7 +107,8 @@ fn get_target() -> String {\n }\n \n fn run_pass_miri(opt: bool) {\n-    miri_pass(\"tests/run-pass\", &get_target(), opt);\n+    miri_pass(\"tests/run-pass\", &get_target(), opt, false);\n+    miri_pass(\"tests/run-pass-noseed\", &get_target(), opt, true);\n }\n \n fn compile_fail_miri(opt: bool) {"}, {"sha": "e249238d48cbff3893a0cc48cb415e1190612441", "filename": "tests/run-pass-noseed/hashmap.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ce5e910e602a46c7e18a6f2f731ddac971da8fdb/tests%2Frun-pass-noseed%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce5e910e602a46c7e18a6f2f731ddac971da8fdb/tests%2Frun-pass-noseed%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-noseed%2Fhashmap.rs?ref=ce5e910e602a46c7e18a6f2f731ddac971da8fdb", "previous_filename": "tests/run-pass/hashmap.rs"}, {"sha": "e7a609a7d98e97818f9b56e042e0241dab57552f", "filename": "tests/run-pass-noseed/heap_allocator.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ce5e910e602a46c7e18a6f2f731ddac971da8fdb/tests%2Frun-pass-noseed%2Fheap_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce5e910e602a46c7e18a6f2f731ddac971da8fdb/tests%2Frun-pass-noseed%2Fheap_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-noseed%2Fheap_allocator.rs?ref=ce5e910e602a46c7e18a6f2f731ddac971da8fdb", "previous_filename": "tests/run-pass/heap_allocator.rs"}, {"sha": "40b21f9a4729ee1510dd15dd1998d94be14de046", "filename": "tests/run-pass-noseed/intptrcast.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ce5e910e602a46c7e18a6f2f731ddac971da8fdb/tests%2Frun-pass-noseed%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce5e910e602a46c7e18a6f2f731ddac971da8fdb/tests%2Frun-pass-noseed%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-noseed%2Fintptrcast.rs?ref=ce5e910e602a46c7e18a6f2f731ddac971da8fdb", "previous_filename": "tests/run-pass/intptrcast.rs"}, {"sha": "c279024f35eabd442390b329f48867f0f1b191d4", "filename": "tests/run-pass-noseed/ptr_int_casts.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ce5e910e602a46c7e18a6f2f731ddac971da8fdb/tests%2Frun-pass-noseed%2Fptr_int_casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce5e910e602a46c7e18a6f2f731ddac971da8fdb/tests%2Frun-pass-noseed%2Fptr_int_casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-noseed%2Fptr_int_casts.rs?ref=ce5e910e602a46c7e18a6f2f731ddac971da8fdb", "previous_filename": "tests/run-pass/ptr_int_casts.rs"}, {"sha": "c0d3e9398dc5d4eebb0a9c4e12ebd08d85020887", "filename": "tests/run-pass/intptrcast_format.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39c9e793b98d91e54c0d8da3c5cb08661ebae17e/tests%2Frun-pass%2Fintptrcast_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39c9e793b98d91e54c0d8da3c5cb08661ebae17e/tests%2Frun-pass%2Fintptrcast_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fintptrcast_format.rs?ref=39c9e793b98d91e54c0d8da3c5cb08661ebae17e", "patch": "@@ -1,6 +0,0 @@\n-// compile-flags: -Zmiri-seed=\n-\n-fn main() {\n-    println!(\"Hello {}\", 13);\n-    println!(\"{:0<width$}\", \"hello\", width = 10);\n-}"}, {"sha": "3c9a55d0d4c1aeb35639cb8a39eb742dc3fc6cf1", "filename": "tests/run-pass/intptrcast_format.stdout", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39c9e793b98d91e54c0d8da3c5cb08661ebae17e/tests%2Frun-pass%2Fintptrcast_format.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/39c9e793b98d91e54c0d8da3c5cb08661ebae17e/tests%2Frun-pass%2Fintptrcast_format.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fintptrcast_format.stdout?ref=39c9e793b98d91e54c0d8da3c5cb08661ebae17e", "patch": "@@ -1,2 +0,0 @@\n-Hello 13\n-hello00000"}, {"sha": "27da44935b106c98cba3c37c50e79e40fb890810", "filename": "tests/run-pass/transmute_fat.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ce5e910e602a46c7e18a6f2f731ddac971da8fdb/tests%2Frun-pass%2Ftransmute_fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce5e910e602a46c7e18a6f2f731ddac971da8fdb/tests%2Frun-pass%2Ftransmute_fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ftransmute_fat.rs?ref=ce5e910e602a46c7e18a6f2f731ddac971da8fdb", "patch": "@@ -1,3 +1,6 @@\n+// Validation disallows this becuase the reference is never cast to a raw pointer.\n+// compile-flags: -Zmiri-disable-validation\n+\n fn main() {\n     // If we are careful, we can exploit data layout...\n     let raw = unsafe {"}]}