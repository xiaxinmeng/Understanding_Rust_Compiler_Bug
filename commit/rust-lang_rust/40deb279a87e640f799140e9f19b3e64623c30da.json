{"sha": "40deb279a87e640f799140e9f19b3e64623c30da", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwZGViMjc5YTg3ZTY0MGY3OTkxNDBlOWYxOWIzZTY0NjIzYzMwZGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-25T02:38:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-25T02:38:43Z"}, "message": "Auto merge of #32396 - nodakai:range-contains, r=alexcrichton\n\nAdd core::ops::Range*::contains() as per rust-lang/rust#32311", "tree": {"sha": "6cc6ddc96aa5b641db300a54c413f3faf5e75402", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6cc6ddc96aa5b641db300a54c413f3faf5e75402"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40deb279a87e640f799140e9f19b3e64623c30da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40deb279a87e640f799140e9f19b3e64623c30da", "html_url": "https://github.com/rust-lang/rust/commit/40deb279a87e640f799140e9f19b3e64623c30da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40deb279a87e640f799140e9f19b3e64623c30da/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7a71687ef1a9fa5665944608d5bad58d98a9684", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7a71687ef1a9fa5665944608d5bad58d98a9684", "html_url": "https://github.com/rust-lang/rust/commit/d7a71687ef1a9fa5665944608d5bad58d98a9684"}, {"sha": "a21c5f267a722b6c80790a559bf272942b946cd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/a21c5f267a722b6c80790a559bf272942b946cd4", "html_url": "https://github.com/rust-lang/rust/commit/a21c5f267a722b6c80790a559bf272942b946cd4"}], "stats": {"total": 214, "additions": 208, "deletions": 6}, "files": [{"sha": "44c498ef6d4e0836fb88b5c3c39aa6a0835473f4", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 208, "deletions": 6, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/40deb279a87e640f799140e9f19b3e64623c30da/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40deb279a87e640f799140e9f19b3e64623c30da/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=40deb279a87e640f799140e9f19b3e64623c30da", "patch": "@@ -1446,7 +1446,24 @@ pub trait IndexMut<Idx: ?Sized>: Index<Idx> {\n     fn index_mut(&mut self, index: Idx) -> &mut Self::Output;\n }\n \n-/// An unbounded range.\n+/// An unbounded range. Use `..` (two dots) for its shorthand.\n+///\n+/// Its primary use case is slicing index. It cannot serve as an iterator\n+/// because it doesn't have a starting point.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// fn main() {\n+///     assert_eq!((..), std::ops::RangeFull);\n+///\n+///     let arr = [0, 1, 2, 3];\n+///     assert_eq!(arr[ .. ], [0,1,2,3]);  // RangeFull\n+///     assert_eq!(arr[ ..3], [0,1,2  ]);\n+///     assert_eq!(arr[1.. ], [  1,2,3]);\n+///     assert_eq!(arr[1..3], [  1,2  ]);\n+/// }\n+/// ```\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeFull;\n@@ -1458,7 +1475,26 @@ impl fmt::Debug for RangeFull {\n     }\n }\n \n-/// A (half-open) range which is bounded at both ends.\n+/// A (half-open) range which is bounded at both ends: { x | start <= x < end }.\n+/// Use `start..end` (two dots) for its shorthand.\n+///\n+/// See the [`contains()`](#method.contains) method for its characterization.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(iter_arith)]\n+/// fn main() {\n+///     assert_eq!((3..5), std::ops::Range{ start: 3, end: 5 });\n+///     assert_eq!(3+4+5, (3..6).sum());\n+///\n+///     let arr = [0, 1, 2, 3];\n+///     assert_eq!(arr[ .. ], [0,1,2,3]);\n+///     assert_eq!(arr[ ..3], [0,1,2  ]);\n+///     assert_eq!(arr[1.. ], [  1,2,3]);\n+///     assert_eq!(arr[1..3], [  1,2  ]);  // Range\n+/// }\n+/// ```\n #[derive(Clone, PartialEq, Eq)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Range<Idx> {\n@@ -1477,7 +1513,47 @@ impl<Idx: fmt::Debug> fmt::Debug for Range<Idx> {\n     }\n }\n \n-/// A range which is only bounded below.\n+#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+impl<Idx: PartialOrd<Idx>> Range<Idx> {\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(range_contains)]\n+    /// fn main() {\n+    ///     assert!( ! (3..5).contains(2));\n+    ///     assert!(   (3..5).contains(3));\n+    ///     assert!(   (3..5).contains(4));\n+    ///     assert!( ! (3..5).contains(5));\n+    ///\n+    ///     assert!( ! (3..3).contains(3));\n+    ///     assert!( ! (3..2).contains(3));\n+    /// }\n+    /// ```\n+    pub fn contains(&self, item: Idx) -> bool {\n+        (self.start <= item) && (item < self.end)\n+    }\n+}\n+\n+/// A range which is only bounded below: { x | start <= x }.\n+/// Use `start..` for its shorthand.\n+///\n+/// See the [`contains()`](#method.contains) method for its characterization.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(iter_arith)]\n+/// fn main() {\n+///     assert_eq!((2..), std::ops::RangeFrom{ start: 2 });\n+///     assert_eq!(2+3+4, (2..).take(3).sum());\n+///\n+///     let arr = [0, 1, 2, 3];\n+///     assert_eq!(arr[ .. ], [0,1,2,3]);\n+///     assert_eq!(arr[ ..3], [0,1,2  ]);\n+///     assert_eq!(arr[1.. ], [  1,2,3]);  // RangeFrom\n+///     assert_eq!(arr[1..3], [  1,2  ]);\n+/// }\n+/// ```\n #[derive(Clone, PartialEq, Eq)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeFrom<Idx> {\n@@ -1493,7 +1569,40 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeFrom<Idx> {\n     }\n }\n \n-/// A range which is only bounded above.\n+#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+impl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(range_contains)]\n+    /// fn main() {\n+    ///     assert!( ! (3..).contains(2));\n+    ///     assert!(   (3..).contains(3));\n+    ///     assert!(   (3..).contains(1_000_000_000));\n+    /// }\n+    /// ```\n+    pub fn contains(&self, item: Idx) -> bool {\n+        (self.start <= item)\n+    }\n+}\n+\n+/// A range which is only bounded above: { x | x < end }.\n+/// Use `..end` (two dots) for its shorthand.\n+///\n+/// See the [`contains()`](#method.contains) method for its characterization.\n+///\n+/// It cannot serve as an iterator because it doesn't have a starting point.\n+/// ```\n+/// fn main() {\n+///     assert_eq!((..5), std::ops::RangeTo{ end: 5 });\n+///\n+///     let arr = [0, 1, 2, 3];\n+///     assert_eq!(arr[ .. ], [0,1,2,3]);\n+///     assert_eq!(arr[ ..3], [0,1,2  ]);  // RangeTo\n+///     assert_eq!(arr[1.. ], [  1,2,3]);\n+///     assert_eq!(arr[1..3], [  1,2  ]);\n+/// }\n+/// ```\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeTo<Idx> {\n@@ -1509,7 +1618,41 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeTo<Idx> {\n     }\n }\n \n-/// An inclusive range which is bounded at both ends.\n+#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(range_contains)]\n+    /// fn main() {\n+    ///     assert!(   (..5).contains(-1_000_000_000));\n+    ///     assert!(   (..5).contains(4));\n+    ///     assert!( ! (..5).contains(5));\n+    /// }\n+    /// ```\n+    pub fn contains(&self, item: Idx) -> bool {\n+        (item < self.end)\n+    }\n+}\n+\n+/// An inclusive range which is bounded at both ends: { x | start <= x <= end }.\n+/// Use `start...end` (three dots) for its shorthand.\n+///\n+/// See the [`contains()`](#method.contains) method for its characterization.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(inclusive_range,inclusive_range_syntax,iter_arith)]\n+/// fn main() {\n+///     assert_eq!((3...5), std::ops::RangeInclusive::NonEmpty{ start: 3, end: 5 });\n+///     assert_eq!(3+4+5, (3...5).sum());\n+///\n+///     let arr = [0, 1, 2, 3];\n+///     assert_eq!(arr[ ...2], [0,1,2  ]);\n+///     assert_eq!(arr[1...2], [  1,2  ]);  // RangeInclusive\n+/// }\n+/// ```\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n pub enum RangeInclusive<Idx> {\n@@ -1572,7 +1715,49 @@ impl<Idx: PartialOrd + One + Sub<Output=Idx>> From<Range<Idx>> for RangeInclusiv\n     }\n }\n \n-/// An inclusive range which is only bounded above.\n+#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(range_contains,inclusive_range_syntax)]\n+    /// fn main() {\n+    ///     assert!( ! (3...5).contains(2));\n+    ///     assert!(   (3...5).contains(3));\n+    ///     assert!(   (3...5).contains(4));\n+    ///     assert!(   (3...5).contains(5));\n+    ///     assert!( ! (3...5).contains(6));\n+    ///\n+    ///     assert!(   (3...3).contains(3));\n+    ///     assert!( ! (3...2).contains(3));\n+    /// }\n+    /// ```\n+    pub fn contains(&self, item: Idx) -> bool {\n+        if let &RangeInclusive::NonEmpty{ref start, ref end} = self {\n+            (*start <= item) && (item <= *end)\n+        } else { false }\n+    }\n+}\n+\n+/// An inclusive range which is only bounded above: { x | x <= end }.\n+/// Use `...end` (three dots) for its shorthand.\n+///\n+/// See the [`contains()`](#method.contains) method for its characterization.\n+///\n+/// It cannot serve as an iterator because it doesn't have a starting point.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(inclusive_range,inclusive_range_syntax)]\n+/// fn main() {\n+///     assert_eq!((...5), std::ops::RangeToInclusive{ end: 5 });\n+///\n+///     let arr = [0, 1, 2, 3];\n+///     assert_eq!(arr[ ...2], [0,1,2  ]);  // RangeToInclusive\n+///     assert_eq!(arr[1...2], [  1,2  ]);\n+/// }\n+/// ```\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n pub struct RangeToInclusive<Idx> {\n@@ -1590,6 +1775,23 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeToInclusive<Idx> {\n     }\n }\n \n+#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+impl<Idx: PartialOrd<Idx>> RangeToInclusive<Idx> {\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(range_contains,inclusive_range_syntax)]\n+    /// fn main() {\n+    ///     assert!(   (...5).contains(-1_000_000_000));\n+    ///     assert!(   (...5).contains(5));\n+    ///     assert!( ! (...5).contains(6));\n+    /// }\n+    /// ```\n+    pub fn contains(&self, item: Idx) -> bool {\n+        (item <= self.end)\n+    }\n+}\n+\n // RangeToInclusive<Idx> cannot impl From<RangeTo<Idx>>\n // because underflow would be possible with (..0).into()\n "}]}