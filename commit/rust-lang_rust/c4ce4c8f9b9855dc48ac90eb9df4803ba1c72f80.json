{"sha": "c4ce4c8f9b9855dc48ac90eb9df4803ba1c72f80", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0Y2U0YzhmOWI5ODU1ZGM0OGFjOTBlYjlkZjQ4MDNiYTFjNzJmODA=", "commit": {"author": {"name": "Jonas Hietala", "email": "tradet.h@gmail.com", "date": "2014-07-24T13:03:01Z"}, "committer": {"name": "Jonas Hietala", "email": "tradet.h@gmail.com", "date": "2014-07-24T14:25:19Z"}, "message": "Cleanup HashMap documentation.\n\nLink to mentioned methods. Use `# Failure` tags to describe failure.\nMake `pop_equiv`, `find_equiv` and `get_copy` standalone.", "tree": {"sha": "6e0f839d107cace3c1915661321574537811f994", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e0f839d107cace3c1915661321574537811f994"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4ce4c8f9b9855dc48ac90eb9df4803ba1c72f80", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4ce4c8f9b9855dc48ac90eb9df4803ba1c72f80", "html_url": "https://github.com/rust-lang/rust/commit/c4ce4c8f9b9855dc48ac90eb9df4803ba1c72f80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4ce4c8f9b9855dc48ac90eb9df4803ba1c72f80/comments", "author": {"login": "treeman", "id": 162027, "node_id": "MDQ6VXNlcjE2MjAyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162027?v=4", "gravatar_id": "", "url": "https://api.github.com/users/treeman", "html_url": "https://github.com/treeman", "followers_url": "https://api.github.com/users/treeman/followers", "following_url": "https://api.github.com/users/treeman/following{/other_user}", "gists_url": "https://api.github.com/users/treeman/gists{/gist_id}", "starred_url": "https://api.github.com/users/treeman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/treeman/subscriptions", "organizations_url": "https://api.github.com/users/treeman/orgs", "repos_url": "https://api.github.com/users/treeman/repos", "events_url": "https://api.github.com/users/treeman/events{/privacy}", "received_events_url": "https://api.github.com/users/treeman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "treeman", "id": 162027, "node_id": "MDQ6VXNlcjE2MjAyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162027?v=4", "gravatar_id": "", "url": "https://api.github.com/users/treeman", "html_url": "https://github.com/treeman", "followers_url": "https://api.github.com/users/treeman/followers", "following_url": "https://api.github.com/users/treeman/following{/other_user}", "gists_url": "https://api.github.com/users/treeman/gists{/gist_id}", "starred_url": "https://api.github.com/users/treeman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/treeman/subscriptions", "organizations_url": "https://api.github.com/users/treeman/orgs", "repos_url": "https://api.github.com/users/treeman/repos", "events_url": "https://api.github.com/users/treeman/events{/privacy}", "received_events_url": "https://api.github.com/users/treeman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7028b3fda90fd9f8603457622fe20bf9474f73db", "url": "https://api.github.com/repos/rust-lang/rust/commits/7028b3fda90fd9f8603457622fe20bf9474f73db", "html_url": "https://github.com/rust-lang/rust/commit/7028b3fda90fd9f8603457622fe20bf9474f73db"}], "stats": {"total": 121, "additions": 68, "deletions": 53}, "files": [{"sha": "e825dc3a8b5fd2a95d66e8e4cc955d885059aa4e", "filename": "src/libstd/collections/hashmap.rs", "status": "modified", "additions": 68, "deletions": 53, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/c4ce4c8f9b9855dc48ac90eb9df4803ba1c72f80/src%2Flibstd%2Fcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4ce4c8f9b9855dc48ac90eb9df4803ba1c72f80/src%2Flibstd%2Fcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap.rs?ref=c4ce4c8f9b9855dc48ac90eb9df4803ba1c72f80", "patch": "@@ -731,7 +731,7 @@ impl DefaultResizePolicy {\n /// ```\n ///\n /// The easiest way to use `HashMap` with a custom type is to derive `Eq` and `Hash`.\n-/// We must also derive `PartialEq`, but this will in the future be implied by `Eq`.\n+/// We must also derive `PartialEq`.\n ///\n /// ```\n /// use std::collections::HashMap;\n@@ -1056,7 +1056,7 @@ impl<K: Hash + Eq, V> HashMap<K, V, RandomSipHasher> {\n     ///\n     /// ```\n     /// use std::collections::HashMap;\n-    /// let mut map: HashMap<&str, int> = HashMap::with_capacity(10u);\n+    /// let mut map: HashMap<&str, int> = HashMap::with_capacity(10);\n     /// ```\n     #[inline]\n     pub fn with_capacity(capacity: uint) -> HashMap<K, V, RandomSipHasher> {\n@@ -1100,7 +1100,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// use std::hash::sip::SipHasher;\n     ///\n     /// let h = SipHasher::new();\n-    /// let mut map = HashMap::with_capacity_and_hasher(10u, h);\n+    /// let mut map = HashMap::with_capacity_and_hasher(10, h);\n     /// map.insert(1i, 2u);\n     /// ```\n     #[inline]\n@@ -1123,7 +1123,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// ```\n     /// use std::collections::HashMap;\n     /// let mut map: HashMap<&str, int> = HashMap::new();\n-    /// map.reserve(10u);\n+    /// map.reserve(10);\n     /// ```\n     pub fn reserve(&mut self, new_minimum_capacity: uint) {\n         let cap = num::next_power_of_two(\n@@ -1297,10 +1297,10 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// let mut map = HashMap::new();\n     ///\n     /// // Insert 1i with key \"a\"\n-    /// assert_eq!(*map.find_or_insert(\"a\", 1i), 1i);\n+    /// assert_eq!(*map.find_or_insert(\"a\", 1i), 1);\n     ///\n     /// // Find the existing key\n-    /// assert_eq!(*map.find_or_insert(\"a\", -2i), 1i);\n+    /// assert_eq!(*map.find_or_insert(\"a\", -2), 1);\n     /// ```\n     pub fn find_or_insert<'a>(&'a mut self, k: K, v: V) -> &'a mut V {\n         self.find_with_or_insert_with(k, v, |_k, _v, _a| (), |_k, a| a)\n@@ -1315,11 +1315,11 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// use std::collections::HashMap;\n     /// let mut map = HashMap::new();\n     ///\n-    /// // Insert 10u with key 2i\n-    /// assert_eq!(*map.find_or_insert_with(2i, |&key| { 5 * key as uint }), 10u);\n+    /// // Insert 10 with key 2\n+    /// assert_eq!(*map.find_or_insert_with(2i, |&key| 5 * key as uint), 10u);\n     ///\n     /// // Find the existing key\n-    /// assert_eq!(*map.find_or_insert_with(2i, |&key| { key as uint }), 10u);\n+    /// assert_eq!(*map.find_or_insert_with(2, |&key| key as uint), 10);\n     /// ```\n     pub fn find_or_insert_with<'a>(&'a mut self, k: K, f: |&K| -> V)\n                                -> &'a mut V {\n@@ -1336,12 +1336,12 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// use std::collections::HashMap;\n     /// let mut map = HashMap::new();\n     ///\n-    /// // Insert 2u with key \"a\"\n-    /// assert_eq!(*map.insert_or_update_with(\"a\", 2u, |key, val| { *val = 3u; }), 2u);\n+    /// // Insert 2 with key \"a\"\n+    /// assert_eq!(*map.insert_or_update_with(\"a\", 2u, |_key, val| *val = 3), 2);\n     ///\n     /// // Update and return the existing value\n-    /// assert_eq!(*map.insert_or_update_with(\"a\", 9u, |key, val| { *val = 7u; }), 7u);\n-    /// assert_eq!(map.get(&\"a\"), &7u);\n+    /// assert_eq!(*map.insert_or_update_with(\"a\", 9, |_key, val| *val = 7), 7);\n+    /// assert_eq!(map.get(&\"a\"), &7);\n     /// ```\n     pub fn insert_or_update_with<'a>(\n                                  &'a mut self,\n@@ -1356,9 +1356,11 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// insert and return a new value if it doesn't exist.\n     ///\n     /// This method allows for all insertion behaviours of a hashmap;\n-    /// see methods like `insert`, `find_or_insert` and\n-    /// `insert_or_update_with` for less general and more friendly\n-    /// variations of this.\n+    /// see methods like\n+    /// [`insert`](../trait.MutableMap.html#tymethod.insert),\n+    /// [`find_or_insert`](#method.find_or_insert) and\n+    /// [`insert_or_update_with`](#method.insert_or_update_with)\n+    /// for less general and more friendly variations of this.\n     ///\n     /// # Example\n     ///\n@@ -1414,8 +1416,12 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         }\n     }\n \n-    /// Retrieves a value for the given key, failing if the key is not present.\n-    /// See `find` for a non-failing alternative.\n+    /// Retrieves a value for the given key.\n+    /// See [`find`](../trait.Map.html#tymethod.find) for a non-failing alternative.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the key is not present.\n     ///\n     /// # Example\n     ///\n@@ -1424,7 +1430,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     ///\n     /// let mut map = HashMap::new();\n     /// map.insert(\"a\", 1i);\n-    /// assert_eq!(map.get(&\"a\"), &1i);\n+    /// assert_eq!(map.get(&\"a\"), &1);\n     /// ```\n     pub fn get<'a>(&'a self, k: &K) -> &'a V {\n         match self.find(k) {\n@@ -1433,8 +1439,12 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         }\n     }\n \n-    /// Retrieves a (mutable) value for the given key, failing if the key is not present.\n-    /// See `find_mut` for a non-failing alternative.\n+    /// Retrieves a mutable value for the given key.\n+    /// See [`find_mut`](../trait.MutableMap.html#tymethod.find_mut) for a non-failing alternative.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the key is not present.\n     ///\n     /// # Example\n     ///\n@@ -1444,15 +1454,15 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// let mut map = HashMap::new();\n     /// map.insert(\"a\", 1i);\n     /// {\n-    ///     // val will freeze map to prevent usage during it's lifetime\n+    ///     // val will freeze map to prevent usage during its lifetime\n     ///     let val = map.get_mut(&\"a\");\n-    ///     *val = 40i;\n+    ///     *val = 40;\n     /// }\n-    /// assert_eq!(map.get(&\"a\"), &40i);\n+    /// assert_eq!(map.get(&\"a\"), &40);\n     ///\n     /// // A more direct way could be:\n-    /// *map.get_mut(&\"a\") = -2i;\n-    /// assert_eq!(map.get(&\"a\"), &-2i);\n+    /// *map.get_mut(&\"a\") = -2;\n+    /// assert_eq!(map.get(&\"a\"), &-2);\n     /// ```\n     pub fn get_mut<'a>(&'a mut self, k: &K) -> &'a mut V {\n         match self.find_mut(k) {\n@@ -1483,12 +1493,13 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         }\n     }\n \n-    /// Like `pop`, but can operate on any type that is equivalent to a key.\n+    /// Remove an equivalent key from the map, returning the value at the\n+    /// key if the key was previously in the map.\n     ///\n     /// # Example\n     ///\n     /// This is a slightly silly example where we define the number's parity as\n-    /// the equivilance class. It is important that the values hash the same,\n+    /// the equivalence class. It is important that the values hash the same,\n     /// which is why we override `Hash`.\n     ///\n     /// ```\n@@ -1515,16 +1526,16 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// }\n     ///\n     /// let mut map = HashMap::new();\n-    /// map.insert(EvenOrOdd { num: 3u }, \"foo\");\n+    /// map.insert(EvenOrOdd { num: 3 }, \"foo\");\n     ///\n-    /// assert!(map.contains_key_equiv(&EvenOrOdd { num: 1u }));\n-    /// assert!(!map.contains_key_equiv(&EvenOrOdd { num: 4u }));\n+    /// assert!(map.contains_key_equiv(&EvenOrOdd { num: 1 }));\n+    /// assert!(!map.contains_key_equiv(&EvenOrOdd { num: 4 }));\n     ///\n-    /// assert_eq!(map.find_equiv(&EvenOrOdd { num: 5u }), Some(&\"foo\"));\n-    /// assert_eq!(map.find_equiv(&EvenOrOdd { num: 2u }), None);\n+    /// assert_eq!(map.find_equiv(&EvenOrOdd { num: 5 }), Some(&\"foo\"));\n+    /// assert_eq!(map.find_equiv(&EvenOrOdd { num: 2 }), None);\n     ///\n-    /// assert_eq!(map.pop_equiv(&EvenOrOdd { num: 1u }), Some(\"foo\"));\n-    /// assert_eq!(map.pop_equiv(&EvenOrOdd { num: 2u }), None);\n+    /// assert_eq!(map.pop_equiv(&EvenOrOdd { num: 1 }), Some(\"foo\"));\n+    /// assert_eq!(map.pop_equiv(&EvenOrOdd { num: 2 }), None);\n     ///\n     /// ```\n     #[experimental]\n@@ -1545,7 +1556,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     }\n \n     /// An iterator visiting all keys in arbitrary order.\n-    /// Iterator element type is &'a K.\n+    /// Iterator element type is `&'a K`.\n     ///\n     /// # Example\n     ///\n@@ -1554,8 +1565,8 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     ///\n     /// let mut map = HashMap::new();\n     /// map.insert(\"a\", 1i);\n-    /// map.insert(\"b\", 2i);\n-    /// map.insert(\"c\", 3i);\n+    /// map.insert(\"b\", 2);\n+    /// map.insert(\"c\", 3);\n     ///\n     /// for key in map.keys() {\n     ///     println!(\"{}\", key);\n@@ -1566,7 +1577,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     }\n \n     /// An iterator visiting all values in arbitrary order.\n-    /// Iterator element type is &'a V.\n+    /// Iterator element type is `&'a V`.\n     ///\n     /// # Example\n     ///\n@@ -1575,8 +1586,8 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     ///\n     /// let mut map = HashMap::new();\n     /// map.insert(\"a\", 1i);\n-    /// map.insert(\"b\", 2i);\n-    /// map.insert(\"c\", 3i);\n+    /// map.insert(\"b\", 2);\n+    /// map.insert(\"c\", 3);\n     ///\n     /// for key in map.values() {\n     ///     println!(\"{}\", key);\n@@ -1587,7 +1598,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     }\n \n     /// An iterator visiting all key-value pairs in arbitrary order.\n-    /// Iterator element type is (&'a K, &'a V).\n+    /// Iterator element type is `(&'a K, &'a V)`.\n     ///\n     /// # Example\n     ///\n@@ -1596,8 +1607,8 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     ///\n     /// let mut map = HashMap::new();\n     /// map.insert(\"a\", 1i);\n-    /// map.insert(\"b\", 2i);\n-    /// map.insert(\"c\", 3i);\n+    /// map.insert(\"b\", 2);\n+    /// map.insert(\"c\", 3);\n     ///\n     /// for (key, val) in map.iter() {\n     ///     println!(\"key: {} val: {}\", key, val);\n@@ -1609,7 +1620,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n \n     /// An iterator visiting all key-value pairs in arbitrary order,\n     /// with mutable references to the values.\n-    /// Iterator element type is (&'a K, &'a mut V).\n+    /// Iterator element type is `(&'a K, &'a mut V)`.\n     ///\n     /// # Example\n     ///\n@@ -1618,8 +1629,8 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     ///\n     /// let mut map = HashMap::new();\n     /// map.insert(\"a\", 1i);\n-    /// map.insert(\"b\", 2i);\n-    /// map.insert(\"c\", 3i);\n+    /// map.insert(\"b\", 2);\n+    /// map.insert(\"c\", 3);\n     ///\n     /// // Update all values\n     /// for (_, val) in map.mut_iter() {\n@@ -1645,8 +1656,8 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     ///\n     /// let mut map = HashMap::new();\n     /// map.insert(\"a\", 1i);\n-    /// map.insert(\"b\", 2i);\n-    /// map.insert(\"c\", 3i);\n+    /// map.insert(\"b\", 2);\n+    /// map.insert(\"c\", 3);\n     ///\n     /// // Not possible with .iter()\n     /// let vec: Vec<(&str, int)> = map.move_iter().collect();\n@@ -1657,7 +1668,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n }\n \n impl<K: Eq + Hash<S>, V: Clone, S, H: Hasher<S>> HashMap<K, V, H> {\n-    /// Like `find`, but returns a copy of the value.\n+    /// Return a copy of the value corresponding to the key.\n     ///\n     /// # Example\n     ///\n@@ -1666,13 +1677,17 @@ impl<K: Eq + Hash<S>, V: Clone, S, H: Hasher<S>> HashMap<K, V, H> {\n     ///\n     /// let mut map: HashMap<uint, String> = HashMap::new();\n     /// map.insert(1u, \"foo\".to_string());\n-    /// let s: String = map.find_copy(&1u).unwrap();\n+    /// let s: String = map.find_copy(&1).unwrap();\n     /// ```\n     pub fn find_copy(&self, k: &K) -> Option<V> {\n         self.find(k).map(|v| (*v).clone())\n     }\n \n-    /// Like `get`, but returns a copy of the value.\n+    /// Return a copy of the value corresponding to the key.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the key is not present.\n     ///\n     /// # Example\n     ///\n@@ -1681,7 +1696,7 @@ impl<K: Eq + Hash<S>, V: Clone, S, H: Hasher<S>> HashMap<K, V, H> {\n     ///\n     /// let mut map: HashMap<uint, String> = HashMap::new();\n     /// map.insert(1u, \"foo\".to_string());\n-    /// let s: String = map.get_copy(&1u);\n+    /// let s: String = map.get_copy(&1);\n     /// ```\n     pub fn get_copy(&self, k: &K) -> V {\n         (*self.get(k)).clone()"}]}