{"sha": "4fd0aa316ee7d640e8085b7e620cd3161ff4a679", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmZDBhYTMxNmVlN2Q2NDBlODA4NWI3ZTYyMGNkMzE2MWZmNGE2Nzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-31T09:10:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-31T09:10:19Z"}, "message": "Auto merge of #1441 - RalfJung:sync-cleanup, r=RalfJung\n\nSynchronization primitive cleanup\n\nMake some methods infallible, move a bit more work into the platform-independent `sync.rs`, and fix a bug in rwlock unlocking.", "tree": {"sha": "eabc330077888ebed5e49349f9c0235efd1f9a3f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eabc330077888ebed5e49349f9c0235efd1f9a3f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4fd0aa316ee7d640e8085b7e620cd3161ff4a679", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4fd0aa316ee7d640e8085b7e620cd3161ff4a679", "html_url": "https://github.com/rust-lang/rust/commit/4fd0aa316ee7d640e8085b7e620cd3161ff4a679", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4fd0aa316ee7d640e8085b7e620cd3161ff4a679/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "177d5f861f278135d0544aea9a30ae13e5fd1e66", "url": "https://api.github.com/repos/rust-lang/rust/commits/177d5f861f278135d0544aea9a30ae13e5fd1e66", "html_url": "https://github.com/rust-lang/rust/commit/177d5f861f278135d0544aea9a30ae13e5fd1e66"}, {"sha": "0b6ec575b9d0c683b854ba4ea3da726620c209b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b6ec575b9d0c683b854ba4ea3da726620c209b9", "html_url": "https://github.com/rust-lang/rust/commit/0b6ec575b9d0c683b854ba4ea3da726620c209b9"}], "stats": {"total": 297, "additions": 176, "deletions": 121}, "files": [{"sha": "b2738bb062aa2d90331b69ec6cb1faacf0da2b82", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fd0aa316ee7d640e8085b7e620cd3161ff4a679/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/4fd0aa316ee7d640e8085b7e620cd3161ff4a679/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=4fd0aa316ee7d640e8085b7e620cd3161ff4a679", "patch": "@@ -112,7 +112,7 @@ There is no way to list all the infinite things Miri cannot do, but the\n interpreter will explicitly tell you when it finds something unsupported:\n \n ```\n-error: unsupported operation: Miri does not support threading\n+error: unsupported operation: can't call foreign function: bind\n     ...\n     = help: this is likely not a bug in the program; it indicates that the program \\\n             performed an operation that the interpreter does not support"}, {"sha": "77f0c5b9fbd61fb67d0b080a84a138429a871311", "filename": "src/shims/foreign_items/posix.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fd0aa316ee7d640e8085b7e620cd3161ff4a679/src%2Fshims%2Fforeign_items%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd0aa316ee7d640e8085b7e620cd3161ff4a679/src%2Fshims%2Fforeign_items%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fposix.rs?ref=4fd0aa316ee7d640e8085b7e620cd3161ff4a679", "patch": "@@ -254,14 +254,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"pthread_getspecific\" => {\n                 let &[key] = check_arg_count(args)?;\n                 let key = this.force_bits(this.read_scalar(key)?.not_undef()?, key.layout.size)?;\n-                let active_thread = this.get_active_thread()?;\n+                let active_thread = this.get_active_thread();\n                 let ptr = this.machine.tls.load_tls(key, active_thread, this)?;\n                 this.write_scalar(ptr, dest)?;\n             }\n             \"pthread_setspecific\" => {\n                 let &[key, new_ptr] = check_arg_count(args)?;\n                 let key = this.force_bits(this.read_scalar(key)?.not_undef()?, key.layout.size)?;\n-                let active_thread = this.get_active_thread()?;\n+                let active_thread = this.get_active_thread();\n                 let new_ptr = this.read_scalar(new_ptr)?.not_undef()?;\n                 this.machine.tls.store_tls(key, active_thread, this.test_null(new_ptr)?)?;\n "}, {"sha": "fb50e4d918173838ce3c50269b3f1f81c61b1ed6", "filename": "src/shims/foreign_items/posix/macos.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fd0aa316ee7d640e8085b7e620cd3161ff4a679/src%2Fshims%2Fforeign_items%2Fposix%2Fmacos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd0aa316ee7d640e8085b7e620cd3161ff4a679/src%2Fshims%2Fforeign_items%2Fposix%2Fmacos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fposix%2Fmacos.rs?ref=4fd0aa316ee7d640e8085b7e620cd3161ff4a679", "patch": "@@ -98,7 +98,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let dtor = this.read_scalar(dtor)?.not_undef()?;\n                 let dtor = this.memory.get_fn(dtor)?.as_instance()?;\n                 let data = this.read_scalar(data)?.not_undef()?;\n-                let active_thread = this.get_active_thread()?;\n+                let active_thread = this.get_active_thread();\n                 this.machine.tls.set_macos_thread_dtor(active_thread, dtor, data)?;\n             }\n "}, {"sha": "2a30a23489970576bbea67681d8ac77bb3a0c1ce", "filename": "src/shims/foreign_items/windows.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4fd0aa316ee7d640e8085b7e620cd3161ff4a679/src%2Fshims%2Fforeign_items%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd0aa316ee7d640e8085b7e620cd3161ff4a679/src%2Fshims%2Fforeign_items%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fwindows.rs?ref=4fd0aa316ee7d640e8085b7e620cd3161ff4a679", "patch": "@@ -163,14 +163,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"TlsGetValue\" => {\n                 let &[key] = check_arg_count(args)?;\n                 let key = u128::from(this.read_scalar(key)?.to_u32()?);\n-                let active_thread = this.get_active_thread()?;\n+                let active_thread = this.get_active_thread();\n                 let ptr = this.machine.tls.load_tls(key, active_thread, this)?;\n                 this.write_scalar(ptr, dest)?;\n             }\n             \"TlsSetValue\" => {\n                 let &[key, new_ptr] = check_arg_count(args)?;\n                 let key = u128::from(this.read_scalar(key)?.to_u32()?);\n-                let active_thread = this.get_active_thread()?;\n+                let active_thread = this.get_active_thread();\n                 let new_ptr = this.read_scalar(new_ptr)?.not_undef()?;\n                 this.machine.tls.store_tls(key, active_thread, this.test_null(new_ptr)?)?;\n \n@@ -291,7 +291,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") => {\n                 #[allow(non_snake_case)]\n                 let &[_lpCriticalSection] = check_arg_count(args)?;\n-                assert_eq!(this.get_total_thread_count()?, 1, \"concurrency on Windows not supported\");\n+                assert_eq!(this.get_total_thread_count(), 1, \"concurrency on Windows not supported\");\n                 // Nothing to do, not even a return value.\n                 // (Windows locks are reentrant, and we have only 1 thread,\n                 // so not doing any futher checks here is at least not incorrect.)\n@@ -300,7 +300,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") => {\n                 #[allow(non_snake_case)]\n                 let &[_lpCriticalSection] = check_arg_count(args)?;\n-                assert_eq!(this.get_total_thread_count()?, 1, \"concurrency on Windows not supported\");\n+                assert_eq!(this.get_total_thread_count(), 1, \"concurrency on Windows not supported\");\n                 // There is only one thread, so this always succeeds and returns TRUE\n                 this.write_scalar(Scalar::from_i32(1), dest)?;\n             }"}, {"sha": "8986455a14fcdad1c487c92c35ccac44dc1c4174", "filename": "src/shims/sync.rs", "status": "modified", "additions": 35, "deletions": 39, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/4fd0aa316ee7d640e8085b7e620cd3161ff4a679/src%2Fshims%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd0aa316ee7d640e8085b7e620cd3161ff4a679/src%2Fshims%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fsync.rs?ref=4fd0aa316ee7d640e8085b7e620cd3161ff4a679", "patch": "@@ -1,5 +1,6 @@\n use std::convert::TryInto;\n use std::time::{Duration, SystemTime};\n+use std::ops::Not;\n \n use rustc_middle::ty::{layout::TyAndLayout, TyKind, TypeAndMut};\n use rustc_target::abi::{LayoutOf, Size};\n@@ -284,15 +285,16 @@ fn reacquire_cond_mutex<'mir, 'tcx: 'mir>(\n     thread: ThreadId,\n     mutex: MutexId,\n ) -> InterpResult<'tcx> {\n+    ecx.unblock_thread(thread);\n     if ecx.mutex_is_locked(mutex) {\n-        ecx.mutex_enqueue(mutex, thread);\n+        ecx.mutex_enqueue_and_block(mutex, thread);\n     } else {\n         ecx.mutex_lock(mutex, thread);\n-        ecx.unblock_thread(thread)?;\n     }\n     Ok(())\n }\n \n+/// After a thread waiting on a condvar was signalled:\n /// Reacquire the conditional variable and remove the timeout callback if any\n /// was registered.\n fn post_cond_signal<'mir, 'tcx: 'mir>(\n@@ -303,24 +305,25 @@ fn post_cond_signal<'mir, 'tcx: 'mir>(\n     reacquire_cond_mutex(ecx, thread, mutex)?;\n     // Waiting for the mutex is not included in the waiting time because we need\n     // to acquire the mutex always even if we get a timeout.\n-    ecx.unregister_timeout_callback_if_exists(thread)\n+    ecx.unregister_timeout_callback_if_exists(thread);\n+    Ok(())\n }\n \n /// Release the mutex associated with the condition variable because we are\n /// entering the waiting state.\n-fn release_cond_mutex<'mir, 'tcx: 'mir>(\n+fn release_cond_mutex_and_block<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n     active_thread: ThreadId,\n     mutex: MutexId,\n ) -> InterpResult<'tcx> {\n-    if let Some(old_locked_count) = ecx.mutex_unlock(mutex, active_thread)? {\n+    if let Some(old_locked_count) = ecx.mutex_unlock(mutex, active_thread) {\n         if old_locked_count != 1 {\n             throw_unsup_format!(\"awaiting on a lock acquired multiple times is not supported\");\n         }\n     } else {\n         throw_ub_format!(\"awaiting on unlocked or owned by a different thread mutex\");\n     }\n-    ecx.block_thread(active_thread)?;\n+    ecx.block_thread(active_thread);\n     Ok(())\n }\n \n@@ -411,14 +414,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let kind = mutex_get_kind(this, mutex_op)?.not_undef()?;\n         let id = mutex_get_or_create_id(this, mutex_op)?;\n-        let active_thread = this.get_active_thread()?;\n+        let active_thread = this.get_active_thread();\n \n         if this.mutex_is_locked(id) {\n             let owner_thread = this.mutex_get_owner(id);\n             if owner_thread != active_thread {\n-                // Block the active thread.\n-                this.block_thread(active_thread)?;\n-                this.mutex_enqueue(id, active_thread);\n+                // Enqueue the active thread.\n+                this.mutex_enqueue_and_block(id, active_thread);\n                 Ok(0)\n             } else {\n                 // Trying to acquire the same mutex again.\n@@ -449,7 +451,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let kind = mutex_get_kind(this, mutex_op)?.not_undef()?;\n         let id = mutex_get_or_create_id(this, mutex_op)?;\n-        let active_thread = this.get_active_thread()?;\n+        let active_thread = this.get_active_thread();\n \n         if this.mutex_is_locked(id) {\n             let owner_thread = this.mutex_get_owner(id);\n@@ -482,9 +484,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let kind = mutex_get_kind(this, mutex_op)?.not_undef()?;\n         let id = mutex_get_or_create_id(this, mutex_op)?;\n-        let active_thread = this.get_active_thread()?;\n+        let active_thread = this.get_active_thread();\n \n-        if let Some(_old_locked_count) = this.mutex_unlock(id, active_thread)? {\n+        if let Some(_old_locked_count) = this.mutex_unlock(id, active_thread) {\n             // The mutex was locked by the current thread.\n             Ok(0)\n         } else {\n@@ -528,10 +530,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         let id = rwlock_get_or_create_id(this, rwlock_op)?;\n-        let active_thread = this.get_active_thread()?;\n+        let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_write_locked(id) {\n-            this.rwlock_enqueue_and_block_reader(id, active_thread)?;\n+            this.rwlock_enqueue_and_block_reader(id, active_thread);\n             Ok(0)\n         } else {\n             this.rwlock_reader_lock(id, active_thread);\n@@ -543,7 +545,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         let id = rwlock_get_or_create_id(this, rwlock_op)?;\n-        let active_thread = this.get_active_thread()?;\n+        let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_write_locked(id) {\n             this.eval_libc_i32(\"EBUSY\")\n@@ -557,22 +559,22 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         let id = rwlock_get_or_create_id(this, rwlock_op)?;\n-        let active_thread = this.get_active_thread()?;\n+        let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_locked(id) {\n             // Note: this will deadlock if the lock is already locked by this\n             // thread in any way.\n             //\n             // Relevant documentation:\n             // https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_rwlock_wrlock.html\n-            // An in depth discussion on this topic:\n+            // An in-depth discussion on this topic:\n             // https://github.com/rust-lang/rust/issues/53127\n             //\n             // FIXME: Detect and report the deadlock proactively. (We currently\n             // report the deadlock only when no thread can continue execution,\n             // but we could detect that this lock is already locked and report\n             // an error.)\n-            this.rwlock_enqueue_and_block_writer(id, active_thread)?;\n+            this.rwlock_enqueue_and_block_writer(id, active_thread);\n         } else {\n             this.rwlock_writer_lock(id, active_thread);\n         }\n@@ -584,7 +586,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         let id = rwlock_get_or_create_id(this, rwlock_op)?;\n-        let active_thread = this.get_active_thread()?;\n+        let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_locked(id) {\n             this.eval_libc_i32(\"EBUSY\")\n@@ -598,17 +600,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         let id = rwlock_get_or_create_id(this, rwlock_op)?;\n-        let active_thread = this.get_active_thread()?;\n+        let active_thread = this.get_active_thread();\n \n         if this.rwlock_reader_unlock(id, active_thread) {\n             // The thread was a reader.\n-            if this.rwlock_is_locked(id) {\n+            if this.rwlock_is_locked(id).not() {\n                 // No more readers owning the lock. Give it to a writer if there\n                 // is any.\n-                if let Some(writer) = this.rwlock_dequeue_writer(id) {\n-                    this.unblock_thread(writer)?;\n-                    this.rwlock_writer_lock(id, writer);\n-                }\n+                this.rwlock_dequeue_and_lock_writer(id);\n             }\n             Ok(0)\n         } else if Some(active_thread) == this.rwlock_writer_unlock(id) {\n@@ -617,15 +616,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // We are prioritizing writers here against the readers. As a\n             // result, not only readers can starve writers, but also writers can\n             // starve readers.\n-            if let Some(writer) = this.rwlock_dequeue_writer(id) {\n-                // Give the lock to another writer.\n-                this.unblock_thread(writer)?;\n-                this.rwlock_writer_lock(id, writer);\n+            if this.rwlock_dequeue_and_lock_writer(id) {\n+                // Someone got the write lock, nice.\n             } else {\n                 // Give the lock to all readers.\n-                while let Some(reader) = this.rwlock_dequeue_reader(id) {\n-                    this.unblock_thread(reader)?;\n-                    this.rwlock_reader_lock(id, reader);\n+                while this.rwlock_dequeue_and_lock_reader(id) {\n+                    // Rinse and repeat.\n                 }\n             }\n             Ok(0)\n@@ -753,9 +749,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let id = cond_get_or_create_id(this, cond_op)?;\n         let mutex_id = mutex_get_or_create_id(this, mutex_op)?;\n-        let active_thread = this.get_active_thread()?;\n+        let active_thread = this.get_active_thread();\n \n-        release_cond_mutex(this, active_thread, mutex_id)?;\n+        release_cond_mutex_and_block(this, active_thread, mutex_id)?;\n         this.condvar_wait(id, active_thread, mutex_id);\n \n         Ok(0)\n@@ -774,9 +770,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let id = cond_get_or_create_id(this, cond_op)?;\n         let mutex_id = mutex_get_or_create_id(this, mutex_op)?;\n-        let active_thread = this.get_active_thread()?;\n+        let active_thread = this.get_active_thread();\n \n-        release_cond_mutex(this, active_thread, mutex_id)?;\n+        release_cond_mutex_and_block(this, active_thread, mutex_id)?;\n         this.condvar_wait(id, active_thread, mutex_id);\n \n         // We return success for now and override it in the timeout callback.\n@@ -823,7 +819,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n                 Ok(())\n             }),\n-        )?;\n+        );\n \n         Ok(())\n     }\n@@ -833,7 +829,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let id = cond_get_or_create_id(this, cond_op)?;\n         if this.condvar_is_awaited(id) {\n-            throw_ub_format!(\"destroyed an awaited conditional variable\");\n+            throw_ub_format!(\"destroying an awaited conditional variable\");\n         }\n         cond_set_id(this, cond_op, ScalarMaybeUninit::Uninit)?;\n         cond_set_clock_id(this, cond_op, ScalarMaybeUninit::Uninit)?;"}, {"sha": "e5d3a9f0d6f8789f8b5d7bb4e1f11ab03d824f48", "filename": "src/shims/thread.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4fd0aa316ee7d640e8085b7e620cd3161ff4a679/src%2Fshims%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd0aa316ee7d640e8085b7e620cd3161ff4a679/src%2Fshims%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fthread.rs?ref=4fd0aa316ee7d640e8085b7e620cd3161ff4a679", "patch": "@@ -19,9 +19,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n              For example, Miri does not detect data races yet.\",\n         );\n \n-        let new_thread_id = this.create_thread()?;\n+        let new_thread_id = this.create_thread();\n         // Also switch to new thread so that we can push the first stackframe.\n-        let old_thread_id = this.set_active_thread(new_thread_id)?;\n+        let old_thread_id = this.set_active_thread(new_thread_id);\n \n         let thread_info_place = this.deref_operand(thread)?;\n         this.write_scalar(\n@@ -47,7 +47,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             StackPopCleanup::None { cleanup: true },\n         )?;\n \n-        this.set_active_thread(old_thread_id)?;\n+        this.set_active_thread(old_thread_id);\n \n         Ok(0)\n     }\n@@ -82,7 +82,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn pthread_self(&mut self, dest: PlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n-        let thread_id = this.get_active_thread()?;\n+        let thread_id = this.get_active_thread();\n         this.write_scalar(Scalar::from_uint(thread_id.to_u32(), dest.layout.size), dest)\n     }\n \n@@ -105,10 +105,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // byte. Since `read_c_str` returns the string without the null\n             // byte, we need to truncate to 15.\n             name.truncate(15);\n-            this.set_active_thread_name(name)?;\n+            this.set_active_thread_name(name);\n         } else if option == this.eval_libc_i32(\"PR_GET_NAME\")? {\n             let address = this.read_scalar(arg2)?.not_undef()?;\n-            let mut name = this.get_active_thread_name()?.to_vec();\n+            let mut name = this.get_active_thread_name().to_vec();\n             name.push(0u8);\n             assert!(name.len() <= 16);\n             this.memory.write_bytes(address, name)?;\n@@ -127,15 +127,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.assert_target_os(\"macos\", \"pthread_setname_np\");\n \n         let name = this.memory.read_c_str(name)?.to_owned();\n-        this.set_active_thread_name(name)?;\n+        this.set_active_thread_name(name);\n \n         Ok(())\n     }\n \n     fn sched_yield(&mut self) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        this.yield_active_thread()?;\n+        this.yield_active_thread();\n \n         Ok(0)\n     }"}, {"sha": "695614633682a481351ceecd85fe0b74b781b9f6", "filename": "src/shims/tls.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4fd0aa316ee7d640e8085b7e620cd3161ff4a679/src%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd0aa316ee7d640e8085b7e620cd3161ff4a679/src%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftls.rs?ref=4fd0aa316ee7d640e8085b7e620cd3161ff4a679", "patch": "@@ -232,8 +232,8 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// yet.\n     fn schedule_windows_tls_dtors(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let active_thread = this.get_active_thread()?;\n-        assert_eq!(this.get_total_thread_count()?, 1, \"concurrency on Windows not supported\");\n+        let active_thread = this.get_active_thread();\n+        assert_eq!(this.get_total_thread_count(), 1, \"concurrency on Windows not supported\");\n         // Windows has a special magic linker section that is run on certain events.\n         // Instead of searching for that section and supporting arbitrary hooks in there\n         // (that would be basically https://github.com/rust-lang/miri/issues/450),\n@@ -252,7 +252,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             StackPopCleanup::None { cleanup: true },\n         )?;\n \n-        this.enable_thread(active_thread)?;\n+        this.enable_thread(active_thread);\n         Ok(())\n     }\n \n@@ -262,7 +262,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// Note: It is safe to call this function also on other Unixes.\n     fn schedule_macos_tls_dtor(&mut self) -> InterpResult<'tcx, bool> {\n         let this = self.eval_context_mut();\n-        let thread_id = this.get_active_thread()?;\n+        let thread_id = this.get_active_thread();\n         if let Some((instance, data)) = this.machine.tls.macos_thread_dtors.remove(&thread_id) {\n             trace!(\"Running macos dtor {:?} on {:?} at {:?}\", instance, data, thread_id);\n \n@@ -278,7 +278,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // we just scheduled. Since we deleted the destructor, it is\n             // guaranteed that we will schedule it again. The `dtors_running`\n             // flag will prevent the code from adding the destructor again.\n-            this.enable_thread(thread_id)?;\n+            this.enable_thread(thread_id);\n             Ok(true)\n         } else {\n             Ok(false)\n@@ -289,9 +289,9 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// a destructor to schedule, and `false` otherwise.\n     fn schedule_next_pthread_tls_dtor(&mut self) -> InterpResult<'tcx, bool> {\n         let this = self.eval_context_mut();\n-        let active_thread = this.get_active_thread()?;\n+        let active_thread = this.get_active_thread();\n \n-        assert!(this.has_terminated(active_thread)?, \"running TLS dtors for non-terminated thread\");\n+        assert!(this.has_terminated(active_thread), \"running TLS dtors for non-terminated thread\");\n         // Fetch next dtor after `key`.\n         let last_key = this.machine.tls.dtors_running[&active_thread].last_dtor_key.clone();\n         let dtor = match this.machine.tls.fetch_tls_dtor(last_key, active_thread) {\n@@ -314,7 +314,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 StackPopCleanup::None { cleanup: true },\n             )?;\n \n-            this.enable_thread(active_thread)?;\n+            this.enable_thread(active_thread);\n             return Ok(true);\n         }\n         this.machine.tls.dtors_running.get_mut(&active_thread).unwrap().last_dtor_key = None;\n@@ -340,7 +340,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// https://github.com/rust-lang/rust/issues/28129.\n     fn schedule_next_tls_dtor_for_active_thread(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let active_thread = this.get_active_thread()?;\n+        let active_thread = this.get_active_thread();\n \n         if !this.machine.tls.set_dtors_running_for_thread(active_thread) {\n             // This is the first time we got asked to schedule a destructor. The"}, {"sha": "0d4b4d6b7c1cb1b57a3f364a570bb85dd6453c58", "filename": "src/sync.rs", "status": "modified", "additions": 45, "deletions": 29, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/4fd0aa316ee7d640e8085b7e620cd3161ff4a679/src%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd0aa316ee7d640e8085b7e620cd3161ff4a679/src%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsync.rs?ref=4fd0aa316ee7d640e8085b7e620cd3161ff4a679", "patch": "@@ -145,25 +145,22 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         mutex.lock_count = mutex.lock_count.checked_add(1).unwrap();\n     }\n \n-    /// Try unlocking by decreasing the lock count and returning the old owner\n-    /// and the old lock count. If the lock count reaches 0, release the lock\n-    /// and potentially give to a new owner. If the lock was not locked, return\n-    /// `None`.\n-    ///\n-    /// Note: It is the caller's responsibility to check that the thread that\n-    /// unlocked the lock actually is the same one, which owned it.\n+    /// Try unlocking by decreasing the lock count and returning the old lock\n+    /// count. If the lock count reaches 0, release the lock and potentially\n+    /// give to a new owner. If the lock was not locked by `expected_owner`,\n+    /// return `None`.\n     fn mutex_unlock(\n         &mut self,\n         id: MutexId,\n         expected_owner: ThreadId,\n-    ) -> InterpResult<'tcx, Option<usize>> {\n+    ) -> Option<usize> {\n         let this = self.eval_context_mut();\n         let mutex = &mut this.machine.threads.sync.mutexes[id];\n         if let Some(current_owner) = mutex.owner {\n             // Mutex is locked.\n             if current_owner != expected_owner {\n                 // Only the owner can unlock the mutex.\n-                return Ok(None);\n+                return None;\n             }\n             let old_lock_count = mutex.lock_count;\n             mutex.lock_count = old_lock_count\n@@ -173,31 +170,36 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 mutex.owner = None;\n                 // The mutex is completely unlocked. Try transfering ownership\n                 // to another thread.\n-                if let Some(new_owner) = this.mutex_dequeue(id) {\n-                    this.mutex_lock(id, new_owner);\n-                    this.unblock_thread(new_owner)?;\n-                }\n+                this.mutex_dequeue_and_lock(id);\n             }\n-            Ok(Some(old_lock_count))\n+            Some(old_lock_count)\n         } else {\n             // Mutex is unlocked.\n-            Ok(None)\n+            None\n         }\n     }\n \n     #[inline]\n-    /// Put the thread into the queue waiting for the lock.\n-    fn mutex_enqueue(&mut self, id: MutexId, thread: ThreadId) {\n+    /// Put the thread into the queue waiting for the mutex.\n+    fn mutex_enqueue_and_block(&mut self, id: MutexId, thread: ThreadId) {\n         let this = self.eval_context_mut();\n         assert!(this.mutex_is_locked(id), \"queing on unlocked mutex\");\n         this.machine.threads.sync.mutexes[id].queue.push_back(thread);\n+        this.block_thread(thread);\n     }\n \n     #[inline]\n-    /// Take a thread out of the queue waiting for the lock.\n-    fn mutex_dequeue(&mut self, id: MutexId) -> Option<ThreadId> {\n+    /// Take a thread out of the queue waiting for the mutex, and lock\n+    /// the mutex for it. Returns `true` if some thread has the mutex now.\n+    fn mutex_dequeue_and_lock(&mut self, id: MutexId) -> bool {\n         let this = self.eval_context_mut();\n-        this.machine.threads.sync.mutexes[id].queue.pop_front()\n+        if let Some(thread) = this.machine.threads.sync.mutexes[id].queue.pop_front() {\n+            this.unblock_thread(thread);\n+            this.mutex_lock(id, thread);\n+            true\n+        } else {\n+            false\n+        }\n     }\n \n     #[inline]\n@@ -255,25 +257,32 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         id: RwLockId,\n         reader: ThreadId,\n-    ) -> InterpResult<'tcx> {\n+    ) {\n         let this = self.eval_context_mut();\n         assert!(this.rwlock_is_write_locked(id), \"queueing on not write locked lock\");\n         this.machine.threads.sync.rwlocks[id].reader_queue.push_back(reader);\n-        this.block_thread(reader)\n+        this.block_thread(reader);\n     }\n \n     #[inline]\n     /// Take a reader out the queue waiting for the lock.\n-    fn rwlock_dequeue_reader(&mut self, id: RwLockId) -> Option<ThreadId> {\n+    /// Returns `true` if some thread got the rwlock.\n+    fn rwlock_dequeue_and_lock_reader(&mut self, id: RwLockId) -> bool {\n         let this = self.eval_context_mut();\n-        this.machine.threads.sync.rwlocks[id].reader_queue.pop_front()\n+        if let Some(reader) = this.machine.threads.sync.rwlocks[id].reader_queue.pop_front() {\n+            this.unblock_thread(reader);\n+            this.rwlock_reader_lock(id, reader);\n+            true\n+        } else {\n+            false\n+        }\n     }\n \n     #[inline]\n     /// Lock by setting the writer that owns the lock.\n     fn rwlock_writer_lock(&mut self, id: RwLockId, writer: ThreadId) {\n         let this = self.eval_context_mut();\n-        assert!(!this.rwlock_is_locked(id), \"the lock is already locked\");\n+        assert!(!this.rwlock_is_locked(id), \"the rwlock is already locked\");\n         this.machine.threads.sync.rwlocks[id].writer = Some(writer);\n     }\n \n@@ -290,18 +299,25 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         id: RwLockId,\n         writer: ThreadId,\n-    ) -> InterpResult<'tcx> {\n+    ) {\n         let this = self.eval_context_mut();\n         assert!(this.rwlock_is_locked(id), \"queueing on unlocked lock\");\n         this.machine.threads.sync.rwlocks[id].writer_queue.push_back(writer);\n-        this.block_thread(writer)\n+        this.block_thread(writer);\n     }\n \n     #[inline]\n     /// Take the writer out the queue waiting for the lock.\n-    fn rwlock_dequeue_writer(&mut self, id: RwLockId) -> Option<ThreadId> {\n+    /// Returns `true` if some thread got the rwlock.\n+    fn rwlock_dequeue_and_lock_writer(&mut self, id: RwLockId) -> bool {\n         let this = self.eval_context_mut();\n-        this.machine.threads.sync.rwlocks[id].writer_queue.pop_front()\n+        if let Some(writer) = this.machine.threads.sync.rwlocks[id].writer_queue.pop_front() {\n+            this.unblock_thread(writer);\n+            this.rwlock_writer_lock(id, writer);\n+            true\n+        } else {\n+            false\n+        }\n     }\n \n     #[inline]"}, {"sha": "246a383d178b072a148a2eff0a0f8d76855fc647", "filename": "src/thread.rs", "status": "modified", "additions": 24, "deletions": 28, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/4fd0aa316ee7d640e8085b7e620cd3161ff4a679/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd0aa316ee7d640e8085b7e620cd3161ff4a679/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=4fd0aa316ee7d640e8085b7e620cd3161ff4a679", "patch": "@@ -581,9 +581,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     #[inline]\n-    fn create_thread(&mut self) -> InterpResult<'tcx, ThreadId> {\n+    fn create_thread(&mut self) -> ThreadId {\n         let this = self.eval_context_mut();\n-        Ok(this.machine.threads.create_thread())\n+        this.machine.threads.create_thread()\n     }\n \n     #[inline]\n@@ -599,34 +599,33 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     #[inline]\n-    fn set_active_thread(&mut self, thread_id: ThreadId) -> InterpResult<'tcx, ThreadId> {\n+    fn set_active_thread(&mut self, thread_id: ThreadId) -> ThreadId {\n         let this = self.eval_context_mut();\n-        Ok(this.machine.threads.set_active_thread_id(thread_id))\n+        this.machine.threads.set_active_thread_id(thread_id)\n     }\n \n     #[inline]\n-    fn get_active_thread(&self) -> InterpResult<'tcx, ThreadId> {\n+    fn get_active_thread(&self) -> ThreadId {\n         let this = self.eval_context_ref();\n-        Ok(this.machine.threads.get_active_thread_id())\n+        this.machine.threads.get_active_thread_id()\n     }\n \n     #[inline]\n-    fn get_total_thread_count(&self) -> InterpResult<'tcx, usize> {\n+    fn get_total_thread_count(&self) -> usize {\n         let this = self.eval_context_ref();\n-        Ok(this.machine.threads.get_total_thread_count())\n+        this.machine.threads.get_total_thread_count()\n     }\n \n     #[inline]\n-    fn has_terminated(&self, thread_id: ThreadId) -> InterpResult<'tcx, bool> {\n+    fn has_terminated(&self, thread_id: ThreadId) -> bool {\n         let this = self.eval_context_ref();\n-        Ok(this.machine.threads.has_terminated(thread_id))\n+        this.machine.threads.has_terminated(thread_id)\n     }\n \n     #[inline]\n-    fn enable_thread(&mut self, thread_id: ThreadId) -> InterpResult<'tcx> {\n+    fn enable_thread(&mut self, thread_id: ThreadId) {\n         let this = self.eval_context_mut();\n         this.machine.threads.enable_thread(thread_id);\n-        Ok(())\n     }\n \n     #[inline]\n@@ -642,37 +641,36 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     #[inline]\n-    fn set_active_thread_name(&mut self, new_thread_name: Vec<u8>) -> InterpResult<'tcx, ()> {\n+    fn set_active_thread_name(&mut self, new_thread_name: Vec<u8>) {\n         let this = self.eval_context_mut();\n-        Ok(this.machine.threads.set_thread_name(new_thread_name))\n+        this.machine.threads.set_thread_name(new_thread_name);\n     }\n \n     #[inline]\n-    fn get_active_thread_name<'c>(&'c self) -> InterpResult<'tcx, &'c [u8]>\n+    fn get_active_thread_name<'c>(&'c self) -> &'c [u8]\n     where\n         'mir: 'c,\n     {\n         let this = self.eval_context_ref();\n-        Ok(this.machine.threads.get_thread_name())\n+        this.machine.threads.get_thread_name()\n     }\n \n     #[inline]\n-    fn block_thread(&mut self, thread: ThreadId) -> InterpResult<'tcx> {\n+    fn block_thread(&mut self, thread: ThreadId) {\n         let this = self.eval_context_mut();\n-        Ok(this.machine.threads.block_thread(thread))\n+        this.machine.threads.block_thread(thread);\n     }\n \n     #[inline]\n-    fn unblock_thread(&mut self, thread: ThreadId) -> InterpResult<'tcx> {\n+    fn unblock_thread(&mut self, thread: ThreadId) {\n         let this = self.eval_context_mut();\n-        Ok(this.machine.threads.unblock_thread(thread))\n+        this.machine.threads.unblock_thread(thread);\n     }\n \n     #[inline]\n-    fn yield_active_thread(&mut self) -> InterpResult<'tcx> {\n+    fn yield_active_thread(&mut self) {\n         let this = self.eval_context_mut();\n         this.machine.threads.yield_active_thread();\n-        Ok(())\n     }\n \n     #[inline]\n@@ -681,17 +679,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         thread: ThreadId,\n         call_time: Time,\n         callback: TimeoutCallback<'mir, 'tcx>,\n-    ) -> InterpResult<'tcx> {\n+    ) {\n         let this = self.eval_context_mut();\n         this.machine.threads.register_timeout_callback(thread, call_time, callback);\n-        Ok(())\n     }\n \n     #[inline]\n-    fn unregister_timeout_callback_if_exists(&mut self, thread: ThreadId) -> InterpResult<'tcx> {\n+    fn unregister_timeout_callback_if_exists(&mut self, thread: ThreadId) {\n         let this = self.eval_context_mut();\n         this.machine.threads.unregister_timeout_callback_if_exists(thread);\n-        Ok(())\n     }\n \n     /// Execute a timeout callback on the callback's thread.\n@@ -706,9 +702,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         //    thread.\n         // 2. Make the scheduler the only place that can change the active\n         //    thread.\n-        let old_thread = this.set_active_thread(thread)?;\n+        let old_thread = this.set_active_thread(thread);\n         callback(this)?;\n-        this.set_active_thread(old_thread)?;\n+        this.set_active_thread(old_thread);\n         Ok(())\n     }\n "}, {"sha": "e36c79491f91e691806bf05a833f255e803c9edb", "filename": "tests/run-pass/concurrency/sync.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/4fd0aa316ee7d640e8085b7e620cd3161ff4a679/tests%2Frun-pass%2Fconcurrency%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fd0aa316ee7d640e8085b7e620cd3161ff4a679/tests%2Frun-pass%2Fconcurrency%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fsync.rs?ref=4fd0aa316ee7d640e8085b7e620cd3161ff4a679", "patch": "@@ -267,6 +267,51 @@ fn check_once() {\n     }\n }\n \n+fn check_rwlock_unlock_bug1() {\n+    // There was a bug where when un-read-locking an rwlock that still has other\n+    // readers waiting, we'd accidentally also let a writer in.\n+    // That caused an ICE.\n+    let l = Arc::new(RwLock::new(0));\n+\n+    let r1 = l.read().unwrap();\n+    let r2 = l.read().unwrap();\n+\n+    // Make a waiting writer.\n+    let l2 = l.clone();\n+    thread::spawn(move || {\n+        let mut w = l2.write().unwrap();\n+        *w += 1;\n+    });\n+    thread::yield_now();\n+\n+    drop(r1);\n+    assert_eq!(*r2, 0);\n+    thread::yield_now();\n+    thread::yield_now();\n+    thread::yield_now();\n+    assert_eq!(*r2, 0);\n+    drop(r2);\n+}\n+\n+fn check_rwlock_unlock_bug2() {\n+    // There was a bug where when un-read-locking an rwlock by letting the last reader leaver,\n+    // we'd forget to wake up a writer.\n+    // That meant the writer thread could never run again.\n+    let l = Arc::new(RwLock::new(0));\n+\n+    let r = l.read().unwrap();\n+\n+    // Make a waiting writer.\n+    let l2 = l.clone();\n+    let h = thread::spawn(move || {\n+        let _w = l2.write().unwrap();\n+    });\n+    thread::yield_now();\n+\n+    drop(r);\n+    h.join().unwrap();\n+}\n+\n fn main() {\n     check_barriers();\n     check_conditional_variables_notify_one();\n@@ -280,4 +325,6 @@ fn main() {\n     multiple_send();\n     send_on_sync();\n     check_once();\n+    check_rwlock_unlock_bug1();\n+    check_rwlock_unlock_bug2();\n }"}]}