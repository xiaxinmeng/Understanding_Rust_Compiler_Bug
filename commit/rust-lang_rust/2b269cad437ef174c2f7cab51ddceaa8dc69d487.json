{"sha": "2b269cad437ef174c2f7cab51ddceaa8dc69d487", "node_id": "C_kwDOAAsO6NoAKDJiMjY5Y2FkNDM3ZWYxNzRjMmY3Y2FiNTFkZGNlYWE4ZGM2OWQ0ODc", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-20T20:34:24Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-20T20:34:24Z"}, "message": "miri: prune some atomic operation details from stacktrace", "tree": {"sha": "8432fa7e0b46fa974ecf425514ca5e5638d12cd9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8432fa7e0b46fa974ecf425514ca5e5638d12cd9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b269cad437ef174c2f7cab51ddceaa8dc69d487", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b269cad437ef174c2f7cab51ddceaa8dc69d487", "html_url": "https://github.com/rust-lang/rust/commit/2b269cad437ef174c2f7cab51ddceaa8dc69d487", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b269cad437ef174c2f7cab51ddceaa8dc69d487/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d60d88fe5cd55496b9ccb1511a9af4994b7c43d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/d60d88fe5cd55496b9ccb1511a9af4994b7c43d0", "html_url": "https://github.com/rust-lang/rust/commit/d60d88fe5cd55496b9ccb1511a9af4994b7c43d0"}], "stats": {"total": 58, "additions": 58, "deletions": 0}, "files": [{"sha": "5e2e0c4d8cc1b24cc33b2f91d48d4ea50fe92415", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/2b269cad437ef174c2f7cab51ddceaa8dc69d487/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b269cad437ef174c2f7cab51ddceaa8dc69d487/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=2b269cad437ef174c2f7cab51ddceaa8dc69d487", "patch": "@@ -449,6 +449,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn load(&self, order: Ordering) -> bool {\n         // SAFETY: any data races are prevented by atomic intrinsics and the raw\n         // pointer passed in is valid because we got it from a reference.\n@@ -476,6 +477,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn store(&self, val: bool, order: Ordering) {\n         // SAFETY: any data races are prevented by atomic intrinsics and the raw\n         // pointer passed in is valid because we got it from a reference.\n@@ -507,6 +509,7 @@ impl AtomicBool {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[cfg(target_has_atomic = \"8\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn swap(&self, val: bool, order: Ordering) -> bool {\n         // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe { atomic_swap(self.v.get(), val as u8, order) != 0 }\n@@ -563,6 +566,7 @@ impl AtomicBool {\n         note = \"Use `compare_exchange` or `compare_exchange_weak` instead\"\n     )]\n     #[cfg(target_has_atomic = \"8\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn compare_and_swap(&self, current: bool, new: bool, order: Ordering) -> bool {\n         match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {\n             Ok(x) => x,\n@@ -610,6 +614,7 @@ impl AtomicBool {\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n     #[doc(alias = \"compare_and_swap\")]\n     #[cfg(target_has_atomic = \"8\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn compare_exchange(\n         &self,\n         current: bool,\n@@ -664,6 +669,7 @@ impl AtomicBool {\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n     #[doc(alias = \"compare_and_swap\")]\n     #[cfg(target_has_atomic = \"8\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn compare_exchange_weak(\n         &self,\n         current: bool,\n@@ -715,6 +721,7 @@ impl AtomicBool {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[cfg(target_has_atomic = \"8\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn fetch_and(&self, val: bool, order: Ordering) -> bool {\n         // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe { atomic_and(self.v.get(), val as u8, order) != 0 }\n@@ -756,6 +763,7 @@ impl AtomicBool {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[cfg(target_has_atomic = \"8\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn fetch_nand(&self, val: bool, order: Ordering) -> bool {\n         // We can't use atomic_nand here because it can result in a bool with\n         // an invalid value. This happens because the atomic operation is done\n@@ -807,6 +815,7 @@ impl AtomicBool {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[cfg(target_has_atomic = \"8\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn fetch_or(&self, val: bool, order: Ordering) -> bool {\n         // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe { atomic_or(self.v.get(), val as u8, order) != 0 }\n@@ -847,6 +856,7 @@ impl AtomicBool {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[cfg(target_has_atomic = \"8\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool {\n         // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe { atomic_xor(self.v.get(), val as u8, order) != 0 }\n@@ -884,6 +894,7 @@ impl AtomicBool {\n     #[inline]\n     #[unstable(feature = \"atomic_bool_fetch_not\", issue = \"98485\")]\n     #[cfg(target_has_atomic = \"8\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn fetch_not(&self, order: Ordering) -> bool {\n         self.fetch_xor(true, order)\n     }\n@@ -958,6 +969,7 @@ impl AtomicBool {\n     #[inline]\n     #[stable(feature = \"atomic_fetch_update\", since = \"1.53.0\")]\n     #[cfg(target_has_atomic = \"8\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn fetch_update<F>(\n         &self,\n         set_order: Ordering,\n@@ -1165,6 +1177,7 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn load(&self, order: Ordering) -> *mut T {\n         // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe { atomic_load(self.p.get(), order) }\n@@ -1193,6 +1206,7 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn store(&self, ptr: *mut T, order: Ordering) {\n         // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe {\n@@ -1225,6 +1239,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[cfg(target_has_atomic = \"ptr\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T {\n         // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe { atomic_swap(self.p.get(), ptr, order) }\n@@ -1280,6 +1295,7 @@ impl<T> AtomicPtr<T> {\n         note = \"Use `compare_exchange` or `compare_exchange_weak` instead\"\n     )]\n     #[cfg(target_has_atomic = \"ptr\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn compare_and_swap(&self, current: *mut T, new: *mut T, order: Ordering) -> *mut T {\n         match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {\n             Ok(x) => x,\n@@ -1319,6 +1335,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n     #[cfg(target_has_atomic = \"ptr\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn compare_exchange(\n         &self,\n         current: *mut T,\n@@ -1367,6 +1384,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n     #[cfg(target_has_atomic = \"ptr\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn compare_exchange_weak(\n         &self,\n         current: *mut T,\n@@ -1427,6 +1445,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable(feature = \"atomic_fetch_update\", since = \"1.53.0\")]\n     #[cfg(target_has_atomic = \"ptr\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn fetch_update<F>(\n         &self,\n         set_order: Ordering,\n@@ -1482,6 +1501,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[cfg(target_has_atomic = \"ptr\")]\n     #[unstable(feature = \"strict_provenance_atomic_ptr\", issue = \"99108\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn fetch_ptr_add(&self, val: usize, order: Ordering) -> *mut T {\n         self.fetch_byte_add(val.wrapping_mul(core::mem::size_of::<T>()), order)\n     }\n@@ -1526,6 +1546,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[cfg(target_has_atomic = \"ptr\")]\n     #[unstable(feature = \"strict_provenance_atomic_ptr\", issue = \"99108\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn fetch_ptr_sub(&self, val: usize, order: Ordering) -> *mut T {\n         self.fetch_byte_sub(val.wrapping_mul(core::mem::size_of::<T>()), order)\n     }\n@@ -1561,6 +1582,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[cfg(target_has_atomic = \"ptr\")]\n     #[unstable(feature = \"strict_provenance_atomic_ptr\", issue = \"99108\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn fetch_byte_add(&self, val: usize, order: Ordering) -> *mut T {\n         #[cfg(not(bootstrap))]\n         // SAFETY: data races are prevented by atomic intrinsics.\n@@ -1604,6 +1626,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[cfg(target_has_atomic = \"ptr\")]\n     #[unstable(feature = \"strict_provenance_atomic_ptr\", issue = \"99108\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn fetch_byte_sub(&self, val: usize, order: Ordering) -> *mut T {\n         #[cfg(not(bootstrap))]\n         // SAFETY: data races are prevented by atomic intrinsics.\n@@ -1662,6 +1685,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[cfg(target_has_atomic = \"ptr\")]\n     #[unstable(feature = \"strict_provenance_atomic_ptr\", issue = \"99108\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn fetch_or(&self, val: usize, order: Ordering) -> *mut T {\n         #[cfg(not(bootstrap))]\n         // SAFETY: data races are prevented by atomic intrinsics.\n@@ -1719,6 +1743,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[cfg(target_has_atomic = \"ptr\")]\n     #[unstable(feature = \"strict_provenance_atomic_ptr\", issue = \"99108\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn fetch_and(&self, val: usize, order: Ordering) -> *mut T {\n         #[cfg(not(bootstrap))]\n         // SAFETY: data races are prevented by atomic intrinsics.\n@@ -1774,6 +1799,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[cfg(target_has_atomic = \"ptr\")]\n     #[unstable(feature = \"strict_provenance_atomic_ptr\", issue = \"99108\")]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub fn fetch_xor(&self, val: usize, order: Ordering) -> *mut T {\n         #[cfg(not(bootstrap))]\n         // SAFETY: data races are prevented by atomic intrinsics.\n@@ -2085,6 +2111,7 @@ macro_rules! atomic_int {\n             /// ```\n             #[inline]\n             #[$stable]\n+            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n             pub fn load(&self, order: Ordering) -> $int_type {\n                 // SAFETY: data races are prevented by atomic intrinsics.\n                 unsafe { atomic_load(self.v.get(), order) }\n@@ -2111,6 +2138,7 @@ macro_rules! atomic_int {\n             /// ```\n             #[inline]\n             #[$stable]\n+            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n             pub fn store(&self, val: $int_type, order: Ordering) {\n                 // SAFETY: data races are prevented by atomic intrinsics.\n                 unsafe { atomic_store(self.v.get(), val, order); }\n@@ -2138,6 +2166,7 @@ macro_rules! atomic_int {\n             #[inline]\n             #[$stable]\n             #[$cfg_cas]\n+            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n             pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {\n                 // SAFETY: data races are prevented by atomic intrinsics.\n                 unsafe { atomic_swap(self.v.get(), val, order) }\n@@ -2195,6 +2224,7 @@ macro_rules! atomic_int {\n                 note = \"Use `compare_exchange` or `compare_exchange_weak` instead\")\n             ]\n             #[$cfg_cas]\n+            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n             pub fn compare_and_swap(&self,\n                                     current: $int_type,\n                                     new: $int_type,\n@@ -2248,6 +2278,7 @@ macro_rules! atomic_int {\n             #[inline]\n             #[$stable_cxchg]\n             #[$cfg_cas]\n+            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n             pub fn compare_exchange(&self,\n                                     current: $int_type,\n                                     new: $int_type,\n@@ -2296,6 +2327,7 @@ macro_rules! atomic_int {\n             #[inline]\n             #[$stable_cxchg]\n             #[$cfg_cas]\n+            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n             pub fn compare_exchange_weak(&self,\n                                          current: $int_type,\n                                          new: $int_type,\n@@ -2331,6 +2363,7 @@ macro_rules! atomic_int {\n             #[inline]\n             #[$stable]\n             #[$cfg_cas]\n+            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n             pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {\n                 // SAFETY: data races are prevented by atomic intrinsics.\n                 unsafe { atomic_add(self.v.get(), val, order) }\n@@ -2360,6 +2393,7 @@ macro_rules! atomic_int {\n             #[inline]\n             #[$stable]\n             #[$cfg_cas]\n+            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n             pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {\n                 // SAFETY: data races are prevented by atomic intrinsics.\n                 unsafe { atomic_sub(self.v.get(), val, order) }\n@@ -2392,6 +2426,7 @@ macro_rules! atomic_int {\n             #[inline]\n             #[$stable]\n             #[$cfg_cas]\n+            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n             pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {\n                 // SAFETY: data races are prevented by atomic intrinsics.\n                 unsafe { atomic_and(self.v.get(), val, order) }\n@@ -2424,6 +2459,7 @@ macro_rules! atomic_int {\n             #[inline]\n             #[$stable_nand]\n             #[$cfg_cas]\n+            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n             pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {\n                 // SAFETY: data races are prevented by atomic intrinsics.\n                 unsafe { atomic_nand(self.v.get(), val, order) }\n@@ -2456,6 +2492,7 @@ macro_rules! atomic_int {\n             #[inline]\n             #[$stable]\n             #[$cfg_cas]\n+            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n             pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {\n                 // SAFETY: data races are prevented by atomic intrinsics.\n                 unsafe { atomic_or(self.v.get(), val, order) }\n@@ -2488,6 +2525,7 @@ macro_rules! atomic_int {\n             #[inline]\n             #[$stable]\n             #[$cfg_cas]\n+            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n             pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {\n                 // SAFETY: data races are prevented by atomic intrinsics.\n                 unsafe { atomic_xor(self.v.get(), val, order) }\n@@ -2528,6 +2566,7 @@ macro_rules! atomic_int {\n             #[inline]\n             #[stable(feature = \"no_more_cas\", since = \"1.45.0\")]\n             #[$cfg_cas]\n+            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n             pub fn fetch_update<F>(&self,\n                                    set_order: Ordering,\n                                    fetch_order: Ordering,\n@@ -2581,6 +2620,7 @@ macro_rules! atomic_int {\n             #[inline]\n             #[stable(feature = \"atomic_min_max\", since = \"1.45.0\")]\n             #[$cfg_cas]\n+            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n             pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {\n                 // SAFETY: data races are prevented by atomic intrinsics.\n                 unsafe { $max_fn(self.v.get(), val, order) }\n@@ -2626,6 +2666,7 @@ macro_rules! atomic_int {\n             #[inline]\n             #[stable(feature = \"atomic_min_max\", since = \"1.45.0\")]\n             #[$cfg_cas]\n+            #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n             pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {\n                 // SAFETY: data races are prevented by atomic intrinsics.\n                 unsafe { $min_fn(self.v.get(), val, order) }\n@@ -2939,6 +2980,7 @@ fn strongest_failure_ordering(order: Ordering) -> Ordering {\n }\n \n #[inline]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_store<T: Copy>(dst: *mut T, val: T, order: Ordering) {\n     // SAFETY: the caller must uphold the safety contract for `atomic_store`.\n     unsafe {\n@@ -2953,6 +2995,7 @@ unsafe fn atomic_store<T: Copy>(dst: *mut T, val: T, order: Ordering) {\n }\n \n #[inline]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_load<T: Copy>(dst: *const T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_load`.\n     unsafe {\n@@ -2968,6 +3011,7 @@ unsafe fn atomic_load<T: Copy>(dst: *const T, order: Ordering) -> T {\n \n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_swap<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_swap`.\n     unsafe {\n@@ -2984,6 +3028,7 @@ unsafe fn atomic_swap<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n /// Returns the previous value (like __sync_fetch_and_add).\n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_add<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_add`.\n     unsafe {\n@@ -3000,6 +3045,7 @@ unsafe fn atomic_add<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n /// Returns the previous value (like __sync_fetch_and_sub).\n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_sub<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_sub`.\n     unsafe {\n@@ -3015,6 +3061,7 @@ unsafe fn atomic_sub<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n \n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_compare_exchange<T: Copy>(\n     dst: *mut T,\n     old: T,\n@@ -3057,6 +3104,7 @@ unsafe fn atomic_compare_exchange<T: Copy>(\n \n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_compare_exchange_weak<T: Copy>(\n     dst: *mut T,\n     old: T,\n@@ -3099,6 +3147,7 @@ unsafe fn atomic_compare_exchange_weak<T: Copy>(\n \n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_and<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_and`\n     unsafe {\n@@ -3114,6 +3163,7 @@ unsafe fn atomic_and<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n \n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_nand<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_nand`\n     unsafe {\n@@ -3129,6 +3179,7 @@ unsafe fn atomic_nand<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n \n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_or<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_or`\n     unsafe {\n@@ -3144,6 +3195,7 @@ unsafe fn atomic_or<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n \n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_xor<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_xor`\n     unsafe {\n@@ -3160,6 +3212,7 @@ unsafe fn atomic_xor<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n /// returns the max value (signed comparison)\n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_max<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_max`\n     unsafe {\n@@ -3176,6 +3229,7 @@ unsafe fn atomic_max<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n /// returns the min value (signed comparison)\n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_min<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_min`\n     unsafe {\n@@ -3192,6 +3246,7 @@ unsafe fn atomic_min<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n /// returns the max value (unsigned comparison)\n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_umax<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_umax`\n     unsafe {\n@@ -3208,6 +3263,7 @@ unsafe fn atomic_umax<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n /// returns the min value (unsigned comparison)\n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_umin<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_umin`\n     unsafe {\n@@ -3298,6 +3354,7 @@ unsafe fn atomic_umin<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_diagnostic_item = \"fence\"]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n pub fn fence(order: Ordering) {\n     // SAFETY: using an atomic fence is safe.\n     unsafe {\n@@ -3380,6 +3437,7 @@ pub fn fence(order: Ordering) {\n #[inline]\n #[stable(feature = \"compiler_fences\", since = \"1.21.0\")]\n #[rustc_diagnostic_item = \"compiler_fence\"]\n+#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n pub fn compiler_fence(order: Ordering) {\n     // SAFETY: using an atomic fence is safe.\n     unsafe {"}]}