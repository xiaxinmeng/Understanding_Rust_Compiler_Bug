{"sha": "6ee8595375dadeaff743c848f298e8408f0bb5e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlZTg1OTUzNzVkYWRlYWZmNzQzYzg0OGYyOThlODQwOGYwYmI1ZTk=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2017-03-14T16:49:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-03-14T16:49:40Z"}, "message": "Merge pull request #147 from oli-obk/rustup\n\nrustup to rustc 1.17.0-nightly (60a0edc6c 2017-02-26)", "tree": {"sha": "e6c30020ae7c6f3d13e28a352d427079ff205fda", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6c30020ae7c6f3d13e28a352d427079ff205fda"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ee8595375dadeaff743c848f298e8408f0bb5e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ee8595375dadeaff743c848f298e8408f0bb5e9", "html_url": "https://github.com/rust-lang/rust/commit/6ee8595375dadeaff743c848f298e8408f0bb5e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ee8595375dadeaff743c848f298e8408f0bb5e9/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed0feee07f9e9712029305f85c9f42f7f9d72e84", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed0feee07f9e9712029305f85c9f42f7f9d72e84", "html_url": "https://github.com/rust-lang/rust/commit/ed0feee07f9e9712029305f85c9f42f7f9d72e84"}, {"sha": "80be25e705b0c9b3e8cb43bc0fb4fae3108172bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/80be25e705b0c9b3e8cb43bc0fb4fae3108172bf", "html_url": "https://github.com/rust-lang/rust/commit/80be25e705b0c9b3e8cb43bc0fb4fae3108172bf"}], "stats": {"total": 533, "additions": 357, "deletions": 176}, "files": [{"sha": "370d59e5a3a39cafa010aeed9c30eea26495329b", "filename": "src/error.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6ee8595375dadeaff743c848f298e8408f0bb5e9/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee8595375dadeaff743c848f298e8408f0bb5e9/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=6ee8595375dadeaff743c848f298e8408f0bb5e9", "patch": "@@ -1,15 +1,14 @@\n use std::error::Error;\n use std::fmt;\n use rustc::mir;\n-use rustc::ty::{BareFnTy, Ty, FnSig, layout};\n-use syntax::abi::Abi;\n+use rustc::ty::{FnSig, Ty, layout};\n use memory::{Pointer, Function};\n use rustc_const_math::ConstMathErr;\n use syntax::codemap::Span;\n \n #[derive(Clone, Debug)]\n pub enum EvalError<'tcx> {\n-    FunctionPointerTyMismatch(Abi, &'tcx FnSig<'tcx>, &'tcx BareFnTy<'tcx>),\n+    FunctionPointerTyMismatch(FnSig<'tcx>, FnSig<'tcx>),\n     NoMirFor(String),\n     UnterminatedCString(Pointer),\n     DanglingPointerDeref,\n@@ -151,8 +150,8 @@ impl<'tcx> fmt::Display for EvalError<'tcx> {\n                        ptr.offset, ptr.offset + size, ptr.alloc_id, allocation_size)\n             },\n             EvalError::NoMirFor(ref func) => write!(f, \"no mir for `{}`\", func),\n-            EvalError::FunctionPointerTyMismatch(abi, sig, got) =>\n-                write!(f, \"tried to call a function with abi {:?} and sig {:?} through a function pointer of type {:?}\", abi, sig, got),\n+            EvalError::FunctionPointerTyMismatch(sig, got) =>\n+                write!(f, \"tried to call a function with sig {} through a function pointer of type {}\", sig, got),\n             EvalError::ArrayIndexOutOfBounds(span, len, index) =>\n                 write!(f, \"index out of bounds: the len is {} but the index is {} at {:?}\", len, index, span),\n             EvalError::Math(span, ref err) =>"}, {"sha": "549530265ee6264e201fb8bf959715d543536db9", "filename": "src/eval_context.rs", "status": "modified", "additions": 31, "deletions": 16, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/6ee8595375dadeaff743c848f298e8408f0bb5e9/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee8595375dadeaff743c848f298e8408f0bb5e9/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=6ee8595375dadeaff743c848f298e8408f0bb5e9", "patch": "@@ -9,7 +9,7 @@ use rustc::mir;\n use rustc::traits::Reveal;\n use rustc::ty::layout::{self, Layout, Size};\n use rustc::ty::subst::{self, Subst, Substs};\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable, Binder};\n use rustc_data_structures::indexed_vec::Idx;\n use syntax::codemap::{self, DUMMY_SP};\n \n@@ -181,8 +181,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Float(ConstFloat::F32(f)) => PrimVal::from_f32(f),\n             Float(ConstFloat::F64(f)) => PrimVal::from_f64(f),\n-            Float(ConstFloat::FInfer { .. }) =>\n-                bug!(\"uninferred constants only exist before typeck\"),\n \n             Bool(b) => PrimVal::from_bool(b),\n             Char(c) => PrimVal::from_char(c),\n@@ -196,7 +194,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Struct(_)    => unimplemented!(),\n             Tuple(_)     => unimplemented!(),\n-            Function(_)  => unimplemented!(),\n+            Function(_, _)  => unimplemented!(),\n             Array(_)     => unimplemented!(),\n             Repeat(_, _) => unimplemented!(),\n         };\n@@ -227,6 +225,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.tcx.normalize_associated_type(&substituted)\n     }\n \n+    pub fn erase_lifetimes<T>(&self, value: &Binder<T>) -> T\n+        where T : TypeFoldable<'tcx>\n+    {\n+        let value = self.tcx.erase_late_bound_regions(value);\n+        self.tcx.erase_regions(&value)\n+    }\n+\n     pub(super) fn type_size(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<u64>> {\n         self.type_size_with_substs(ty, self.substs())\n     }\n@@ -457,7 +462,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                     General { discr, ref variants, .. } => {\n                         if let mir::AggregateKind::Adt(adt_def, variant, _, _) = *kind {\n-                            let discr_val = adt_def.variants[variant].disr_val;\n+                            let discr_val = adt_def.discriminants(self.tcx)\n+                                .nth(variant)\n+                                .expect(\"broken mir: Adt variant id invalid\")\n+                                .to_u128_unchecked();\n                             let discr_size = discr.size().bytes();\n                             if variants[variant].packed {\n                                 let ptr = self.force_allocation(dest)?.to_ptr_and_extra().0;\n@@ -530,7 +538,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     CEnum { .. } => {\n                         assert_eq!(operands.len(), 0);\n                         if let mir::AggregateKind::Adt(adt_def, variant, _, _) = *kind {\n-                            let n = adt_def.variants[variant].disr_val;\n+                            let n = adt_def.discriminants(self.tcx)\n+                                .nth(variant)\n+                                .expect(\"broken mir: Adt variant index invalid\")\n+                                .to_u128_unchecked();\n                             self.write_primval(dest, PrimVal::Bytes(n), dest_ty)?;\n                         } else {\n                             bug!(\"tried to assign {:?} to Layout::CEnum\", kind);\n@@ -640,25 +651,29 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n \n                     ReifyFnPointer => match self.operand_ty(operand).sty {\n-                        ty::TyFnDef(def_id, substs, fn_ty) => {\n-                            let fn_ty = self.tcx.erase_regions(&fn_ty);\n-                            let fn_ptr = self.memory.create_fn_ptr(self.tcx,def_id, substs, fn_ty);\n+                        ty::TyFnDef(def_id, substs, sig) => {\n+                            let fn_ptr = self.memory.create_fn_ptr(def_id, substs, sig);\n                             self.write_value(Value::ByVal(PrimVal::Ptr(fn_ptr)), dest, dest_ty)?;\n                         },\n                         ref other => bug!(\"reify fn pointer on {:?}\", other),\n                     },\n \n                     UnsafeFnPointer => match dest_ty.sty {\n-                        ty::TyFnPtr(unsafe_fn_ty) => {\n+                        ty::TyFnPtr(_) => {\n                             let src = self.eval_operand(operand)?;\n-                            let ptr = src.read_ptr(&self.memory)?;\n-                            let fn_def = self.memory.get_fn(ptr.alloc_id)?.expect_concrete()?;\n-                            let unsafe_fn_ty = self.tcx.erase_regions(&unsafe_fn_ty);\n-                            let fn_ptr = self.memory.create_fn_ptr(self.tcx, fn_def.def_id, fn_def.substs, unsafe_fn_ty);\n-                            self.write_value(Value::ByVal(PrimVal::Ptr(fn_ptr)), dest, dest_ty)?;\n+                            self.write_value(src, dest, dest_ty)?;\n                         },\n                         ref other => bug!(\"fn to unsafe fn cast on {:?}\", other),\n                     },\n+\n+                    ClosureFnPointer => match self.operand_ty(operand).sty {\n+                        ty::TyClosure(def_id, substs) => {\n+                            let fn_ty = self.tcx.closure_type(def_id);\n+                            let fn_ptr = self.memory.create_fn_ptr_from_noncapture_closure(def_id, substs, fn_ty);\n+                            self.write_value(Value::ByVal(PrimVal::Ptr(fn_ptr)), dest, dest_ty)?;\n+                        },\n+                        ref other => bug!(\"reify fn pointer on {:?}\", other),\n+                    },\n                 }\n             }\n \n@@ -668,7 +683,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ptr = self.force_allocation(lval)?.to_ptr();\n                 let discr_val = self.read_discriminant_value(ptr, ty)?;\n                 if let ty::TyAdt(adt_def, _) = ty.sty {\n-                    if adt_def.variants.iter().all(|v| discr_val != v.disr_val) {\n+                    if adt_def.discriminants(self.tcx).all(|v| discr_val != v.to_u128_unchecked()) {\n                         return Err(EvalError::InvalidDiscriminant);\n                     }\n                 } else {"}, {"sha": "afdb5b392d6c280d7807654ade019285a5c5b465", "filename": "src/lvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ee8595375dadeaff743c848f298e8408f0bb5e9/src%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee8595375dadeaff743c848f298e8408f0bb5e9/src%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flvalue.rs?ref=6ee8595375dadeaff743c848f298e8408f0bb5e9", "patch": "@@ -137,9 +137,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Local(mir::RETURN_POINTER) => self.frame().return_lvalue,\n             Local(local) => Lvalue::Local { frame: self.stack.len() - 1, local, field: None },\n \n-            Static(def_id) => {\n+            Static(ref static_) => {\n                 let substs = self.tcx.intern_substs(&[]);\n-                Lvalue::Global(GlobalId { def_id, substs, promoted: None })\n+                Lvalue::Global(GlobalId { def_id: static_.def_id, substs, promoted: None })\n             }\n \n             Projection(ref proj) => return self.eval_lvalue_projection(proj),"}, {"sha": "44959ea6728607d6c73c2656bd9d571549c8ff15", "filename": "src/memory.rs", "status": "modified", "additions": 26, "deletions": 41, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/6ee8595375dadeaff743c848f298e8408f0bb5e9/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee8595375dadeaff743c848f298e8408f0bb5e9/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=6ee8595375dadeaff743c848f298e8408f0bb5e9", "patch": "@@ -3,12 +3,10 @@ use std::collections::{btree_map, BTreeMap, HashMap, HashSet, VecDeque, BTreeSet\n use std::{fmt, iter, ptr, mem, io};\n \n use rustc::hir::def_id::DefId;\n-use rustc::ty::{self, BareFnTy, ClosureTy, ClosureSubsts, TyCtxt};\n+use rustc::ty::{self, PolyFnSig, ClosureSubsts};\n use rustc::ty::subst::Substs;\n use rustc::ty::layout::{self, TargetDataLayout};\n \n-use syntax::abi::Abi;\n-\n use error::{EvalError, EvalResult};\n use value::PrimVal;\n \n@@ -109,8 +107,7 @@ impl Pointer {\n pub struct FunctionDefinition<'tcx> {\n     pub def_id: DefId,\n     pub substs: &'tcx Substs<'tcx>,\n-    pub abi: Abi,\n-    pub sig: &'tcx ty::FnSig<'tcx>,\n+    pub sig: PolyFnSig<'tcx>,\n }\n \n /// Either a concrete function, or a glue function\n@@ -127,18 +124,14 @@ pub enum Function<'tcx> {\n     DropGlue(ty::Ty<'tcx>),\n     /// Glue required to treat the ptr part of a fat pointer\n     /// as a function pointer\n-    FnPtrAsTraitObject(&'tcx ty::FnSig<'tcx>),\n+    FnPtrAsTraitObject(PolyFnSig<'tcx>),\n     /// Glue for Closures\n     Closure(FunctionDefinition<'tcx>),\n+    /// Glue for noncapturing closures casted to function pointers\n+    NonCaptureClosureAsFnPtr(FunctionDefinition<'tcx>),\n }\n \n impl<'tcx> Function<'tcx> {\n-    pub fn expect_concrete(self) -> EvalResult<'tcx, FunctionDefinition<'tcx>> {\n-        match self {\n-            Function::Concrete(fn_def) => Ok(fn_def),\n-            other => Err(EvalError::ExpectedConcreteFunction(other)),\n-        }\n-    }\n     pub fn expect_drop_glue_real_ty(self) -> EvalResult<'tcx, ty::Ty<'tcx>> {\n         match self {\n             Function::DropGlue(real_ty) => Ok(real_ty),\n@@ -221,50 +214,43 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         self.alloc_map.iter()\n     }\n \n-    pub fn create_closure_ptr(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId, substs: ClosureSubsts<'tcx>, fn_ty: ClosureTy<'tcx>) -> Pointer {\n-        // FIXME: this is a hack\n-        let fn_ty = tcx.mk_bare_fn(ty::BareFnTy {\n-            unsafety: fn_ty.unsafety,\n-            abi: fn_ty.abi,\n-            sig: fn_ty.sig,\n-        });\n+    pub fn create_closure_ptr(&mut self, def_id: DefId, substs: ClosureSubsts<'tcx>, sig: PolyFnSig<'tcx>) -> Pointer {\n         self.create_fn_alloc(Function::Closure(FunctionDefinition {\n             def_id,\n             substs: substs.substs,\n-            abi: fn_ty.abi,\n-            // FIXME: why doesn't this compile?\n-            //sig: tcx.erase_late_bound_regions(&fn_ty.sig),\n-            sig: fn_ty.sig.skip_binder(),\n+            sig,\n+        }))\n+    }\n+\n+    pub fn create_fn_ptr_from_noncapture_closure(&mut self, def_id: DefId, substs: ClosureSubsts<'tcx>, sig: PolyFnSig<'tcx>) -> Pointer {\n+        self.create_fn_alloc(Function::NonCaptureClosureAsFnPtr(FunctionDefinition {\n+            def_id,\n+            substs: substs.substs,\n+            sig,\n         }))\n     }\n \n-    pub fn create_fn_as_trait_glue(&mut self, _tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId, substs: &'tcx Substs<'tcx>, fn_ty: &'tcx BareFnTy<'tcx>) -> Pointer {\n+    pub fn create_fn_as_trait_glue(&mut self, def_id: DefId, substs: &'tcx Substs, sig: PolyFnSig<'tcx>) -> Pointer {\n         self.create_fn_alloc(Function::FnDefAsTraitObject(FunctionDefinition {\n             def_id,\n             substs,\n-            abi: fn_ty.abi,\n-            // FIXME: why doesn't this compile?\n-            //sig: tcx.erase_late_bound_regions(&fn_ty.sig),\n-            sig: fn_ty.sig.skip_binder(),\n+            sig,\n         }))\n     }\n \n-    pub fn create_fn_ptr_as_trait_glue(&mut self, fn_ty: &'tcx BareFnTy<'tcx>) -> Pointer {\n-        self.create_fn_alloc(Function::FnPtrAsTraitObject(fn_ty.sig.skip_binder()))\n+    pub fn create_fn_ptr_as_trait_glue(&mut self, sig: PolyFnSig<'tcx>) -> Pointer {\n+        self.create_fn_alloc(Function::FnPtrAsTraitObject(sig))\n     }\n \n     pub fn create_drop_glue(&mut self, ty: ty::Ty<'tcx>) -> Pointer {\n         self.create_fn_alloc(Function::DropGlue(ty))\n     }\n \n-    pub fn create_fn_ptr(&mut self, _tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId, substs: &'tcx Substs<'tcx>, fn_ty: &'tcx BareFnTy<'tcx>) -> Pointer {\n+    pub fn create_fn_ptr(&mut self, def_id: DefId, substs: &'tcx Substs, sig: PolyFnSig<'tcx>) -> Pointer {\n         self.create_fn_alloc(Function::Concrete(FunctionDefinition {\n             def_id,\n             substs,\n-            abi: fn_ty.abi,\n-            // FIXME: why doesn't this compile?\n-            //sig: tcx.erase_late_bound_regions(&fn_ty.sig),\n-            sig: fn_ty.sig.skip_binder(),\n+            sig,\n         }))\n     }\n \n@@ -535,6 +521,10 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n                     trace!(\"{} closure glue for {}\", msg, dump_fn_def(fn_def));\n                     continue;\n                 },\n+                (None, Some(&Function::NonCaptureClosureAsFnPtr(fn_def))) => {\n+                    trace!(\"{} non-capture closure as fn ptr glue for {}\", msg, dump_fn_def(fn_def));\n+                    continue;\n+                },\n                 (None, None) => {\n                     trace!(\"{} (deallocated)\", msg);\n                     continue;\n@@ -606,12 +596,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n fn dump_fn_def<'tcx>(fn_def: FunctionDefinition<'tcx>) -> String {\n     let name = ty::tls::with(|tcx| tcx.item_path_str(fn_def.def_id));\n-    let abi = if fn_def.abi == Abi::Rust {\n-        format!(\"\")\n-    } else {\n-        format!(\"extern {} \", fn_def.abi)\n-    };\n-    format!(\"function pointer: {}: {}{}\", name, abi, fn_def.sig)\n+    format!(\"function pointer: {}: {}\", name, fn_def.sig.skip_binder())\n }\n \n /// Byte accessors"}, {"sha": "23f0142a7f53ffaf8eb74072fa6c7ad1958fddef", "filename": "src/step.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6ee8595375dadeaff743c848f298e8408f0bb5e9/src%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee8595375dadeaff743c848f298e8408f0bb5e9/src%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstep.rs?ref=6ee8595375dadeaff743c848f298e8408f0bb5e9", "patch": "@@ -242,7 +242,8 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n         location: mir::Location\n     ) {\n         self.super_lvalue(lvalue, context, location);\n-        if let mir::Lvalue::Static(def_id) = *lvalue {\n+        if let mir::Lvalue::Static(ref static_) = *lvalue {\n+            let def_id = static_.def_id;\n             let substs = self.ecx.tcx.intern_substs(&[]);\n             let span = self.span;\n             if let Some(node_item) = self.ecx.tcx.hir.get_if_local(def_id) {"}, {"sha": "efa415679328c46461ed4b090c6bdb049383c126", "filename": "src/terminator/drop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ee8595375dadeaff743c848f298e8408f0bb5e9/src%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee8595375dadeaff743c848f298e8408f0bb5e9/src%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fdrop.rs?ref=6ee8595375dadeaff743c848f298e8408f0bb5e9", "patch": "@@ -97,7 +97,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let (adt_ptr, extra) = lval.to_ptr_and_extra();\n \n                 // run drop impl before the fields' drop impls\n-                if let Some(drop_def_id) = adt_def.destructor() {\n+                if let Some(destructor) = adt_def.destructor(self.tcx) {\n                     let trait_ref = ty::Binder(ty::TraitRef {\n                         def_id: self.tcx.lang_items.drop_trait().unwrap(),\n                         substs: self.tcx.mk_substs_trait(ty, &[]),\n@@ -112,7 +112,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         LvalueExtra::Length(n) => Value::ByValPair(PrimVal::Ptr(adt_ptr), PrimVal::from_u128(n as u128)),\n                         LvalueExtra::Vtable(vtable) => Value::ByValPair(PrimVal::Ptr(adt_ptr), PrimVal::Ptr(vtable)),\n                     };\n-                    drop.push((drop_def_id, val, vtable.substs));\n+                    drop.push((destructor.did, val, vtable.substs));\n                 }\n \n                 let layout = self.type_layout(ty)?;\n@@ -121,7 +121,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Layout::General { .. } => {\n                         let discr_val = self.read_discriminant_value(adt_ptr, ty)? as u128;\n                         let ptr = self.force_allocation(lval)?.to_ptr();\n-                        match adt_def.variants.iter().position(|v| discr_val == v.disr_val) {\n+                        match adt_def.discriminants(self.tcx).position(|v| discr_val == v.to_u128_unchecked()) {\n                             Some(i) => {\n                                 lval = Lvalue::Ptr {\n                                     ptr,"}, {"sha": "79682723118cb4ac8cca4fe91285f4cf7df915e4", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 154, "deletions": 93, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/6ee8595375dadeaff743c848f298e8408f0bb5e9/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee8595375dadeaff743c848f298e8408f0bb5e9/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=6ee8595375dadeaff743c848f298e8408f0bb5e9", "patch": "@@ -2,14 +2,16 @@ use rustc::hir::def_id::DefId;\n use rustc::mir;\n use rustc::ty::layout::Layout;\n use rustc::ty::subst::Substs;\n-use rustc::ty::{self, Ty, BareFnTy};\n+use rustc::ty::{self, Ty};\n+use rustc_const_math::ConstInt;\n use syntax::codemap::Span;\n use syntax::attr;\n+use syntax::abi::Abi;\n \n use error::{EvalError, EvalResult};\n use eval_context::{EvalContext, IntegerExt, StackPopCleanup, is_inhabited};\n use lvalue::Lvalue;\n-use memory::{Pointer, FunctionDefinition};\n+use memory::{Pointer, FunctionDefinition, Function};\n use value::PrimVal;\n use value::Value;\n \n@@ -61,35 +63,53 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 };\n \n                 let func_ty = self.operand_ty(func);\n-                match func_ty.sty {\n-                    ty::TyFnPtr(bare_fn_ty) => {\n+                let fn_def = match func_ty.sty {\n+                    ty::TyFnPtr(bare_sig) => {\n+                        let bare_sig = self.erase_lifetimes(&bare_sig);\n                         let fn_ptr = self.eval_operand_to_primval(func)?.to_ptr()?;\n-                        let FunctionDefinition {def_id, substs, abi, sig} = self.memory.get_fn(fn_ptr.alloc_id)?.expect_concrete()?;\n-                        let bare_sig = self.tcx.erase_late_bound_regions_and_normalize(&bare_fn_ty.sig);\n-                        let bare_sig = self.tcx.erase_regions(&bare_sig);\n-                        // transmuting function pointers in miri is fine as long as the number of\n-                        // arguments and the abi don't change.\n-                        // FIXME: also check the size of the arguments' type and the return type\n-                        // Didn't get it to work, since that triggers an assertion in rustc which\n-                        // checks whether the type has escaping regions\n-                        if abi != bare_fn_ty.abi ||\n-                           sig.variadic != bare_sig.variadic ||\n-                           sig.inputs().len() != bare_sig.inputs().len() {\n-                            return Err(EvalError::FunctionPointerTyMismatch(abi, sig, bare_fn_ty));\n+                        let fn_def = self.memory.get_fn(fn_ptr.alloc_id)?;\n+                        match fn_def {\n+                            Function::Concrete(fn_def) => {\n+                                // transmuting function pointers in miri is fine as long as the number of\n+                                // arguments and the abi don't change.\n+                                let sig = self.erase_lifetimes(&fn_def.sig);\n+                                if sig.abi != bare_sig.abi ||\n+                                    sig.variadic != bare_sig.variadic ||\n+                                    sig.inputs_and_output != bare_sig.inputs_and_output {\n+                                    return Err(EvalError::FunctionPointerTyMismatch(sig, bare_sig));\n+                                }\n+                            },\n+                            Function::NonCaptureClosureAsFnPtr(fn_def) => {\n+                                let sig = self.erase_lifetimes(&fn_def.sig);\n+                                assert_eq!(sig.abi, Abi::RustCall);\n+                                if sig.variadic != bare_sig.variadic ||\n+                                    sig.inputs().len() != 1 {\n+                                    return Err(EvalError::FunctionPointerTyMismatch(sig, bare_sig));\n+                                }\n+                                if let ty::TyTuple(fields, _) = sig.inputs()[0].sty {\n+                                    if **fields != *bare_sig.inputs() {\n+                                        return Err(EvalError::FunctionPointerTyMismatch(sig, bare_sig));\n+                                    }\n+                                } else {\n+                                    return Err(EvalError::FunctionPointerTyMismatch(sig, bare_sig));\n+                                }\n+                            },\n+                            other => return Err(EvalError::ExpectedConcreteFunction(other)),\n                         }\n-                        self.eval_fn_call(def_id, substs, bare_fn_ty, destination, args,\n-                                          terminator.source_info.span)?\n+                        self.memory.get_fn(fn_ptr.alloc_id)?\n                     },\n-                    ty::TyFnDef(def_id, substs, fn_ty) => {\n-                        self.eval_fn_call(def_id, substs, fn_ty, destination, args,\n-                                          terminator.source_info.span)?\n-                    }\n+                    ty::TyFnDef(def_id, substs, fn_ty) => Function::Concrete(FunctionDefinition {\n+                        def_id,\n+                        substs,\n+                        sig: fn_ty,\n+                    }),\n \n                     _ => {\n                         let msg = format!(\"can't handle callee of type {:?}\", func_ty);\n                         return Err(EvalError::Unimplemented(msg));\n                     }\n-                }\n+                };\n+                self.eval_fn_call(fn_def, destination, args, terminator.source_info.span)?;\n             }\n \n             Drop { ref location, target, .. } => {\n@@ -138,17 +158,17 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     fn eval_fn_call(\n         &mut self,\n-        def_id: DefId,\n-        substs: &'tcx Substs<'tcx>,\n-        fn_ty: &'tcx BareFnTy,\n+        fn_def: Function<'tcx>,\n         destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n         arg_operands: &[mir::Operand<'tcx>],\n         span: Span,\n     ) -> EvalResult<'tcx> {\n         use syntax::abi::Abi;\n-        match fn_ty.abi {\n-            Abi::RustIntrinsic => {\n-                let ty = fn_ty.sig.0.output();\n+        match fn_def {\n+            // Intrinsics can only be addressed directly\n+            Function::Concrete(FunctionDefinition { def_id, substs, sig }) if sig.abi() == Abi::RustIntrinsic => {\n+                let sig = self.erase_lifetimes(&sig);\n+                let ty = sig.output();\n                 let layout = self.type_layout(ty)?;\n                 let (ret, target) = match destination {\n                     Some(dest) if is_inhabited(self.tcx, ty) => dest,\n@@ -157,18 +177,19 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.call_intrinsic(def_id, substs, arg_operands, ret, ty, layout, target)?;\n                 self.dump_local(ret);\n                 Ok(())\n-            }\n-\n-            Abi::C => {\n-                let ty = fn_ty.sig.0.output();\n+            },\n+            // C functions can only be addressed directly\n+            Function::Concrete(FunctionDefinition { def_id, sig, ..}) if sig.abi() == Abi::C => {\n+                let sig = self.erase_lifetimes(&sig);\n+                let ty = sig.output();\n                 let (ret, target) = destination.unwrap();\n                 self.call_c_abi(def_id, arg_operands, ret, ty)?;\n                 self.dump_local(ret);\n                 self.goto_block(target);\n                 Ok(())\n-            }\n-\n-            Abi::Rust | Abi::RustCall => {\n+            },\n+            Function::DropGlue(_) => Err(EvalError::ManuallyCalledDropGlue),\n+            Function::Concrete(FunctionDefinition { def_id, sig, substs }) if sig.abi() == Abi::Rust || sig.abi() == Abi::RustCall => {\n                 let mut args = Vec::new();\n                 for arg in arg_operands {\n                     let arg_val = self.eval_operand(arg)?;\n@@ -185,20 +206,20 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     };\n \n                 // FIXME(eddyb) Detect ADT constructors more efficiently.\n-                if let Some(adt_def) = fn_ty.sig.skip_binder().output().ty_adt_def() {\n-                    if let Some(v) = adt_def.variants.iter().find(|v| resolved_def_id == v.did) {\n+                if let Some(adt_def) = sig.output().skip_binder().ty_adt_def() {\n+                    let dids = adt_def.variants.iter().map(|v| v.did);\n+                    let discrs = adt_def.discriminants(self.tcx).map(ConstInt::to_u128_unchecked);\n+                    if let Some((_, disr_val)) = dids.zip(discrs).find(|&(did, _)| resolved_def_id == did) {\n                         let (lvalue, target) = destination.expect(\"tuple struct constructors can't diverge\");\n                         let dest_ty = self.tcx.item_type(adt_def.did);\n                         let dest_layout = self.type_layout(dest_ty)?;\n                         trace!(\"layout({:?}) = {:#?}\", dest_ty, dest_layout);\n                         match *dest_layout {\n                             Layout::Univariant { .. } => {\n-                                let disr_val = v.disr_val;\n                                 assert_eq!(disr_val, 0);\n                                 self.assign_fields(lvalue, dest_ty, args)?;\n                             },\n                             Layout::General { discr, ref variants, .. } => {\n-                                let disr_val = v.disr_val;\n                                 let discr_size = discr.size().bytes();\n                                 self.assign_discr_and_fields(\n                                     lvalue,\n@@ -211,7 +232,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                 )?;\n                             },\n                             Layout::StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n-                                let disr_val = v.disr_val;\n                                 if nndiscr as u128 == disr_val {\n                                     self.assign_fields(lvalue, dest_ty, args)?;\n                                 } else {\n@@ -240,66 +260,107 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         return Ok(());\n                     }\n                 }\n-\n-                let mir = match self.load_mir(resolved_def_id) {\n-                    Ok(mir) => mir,\n-                    Err(EvalError::NoMirFor(path)) => {\n-                        match &path[..] {\n-                            // let's just ignore all output for now\n-                            \"std::io::_print\" => {\n-                                self.goto_block(destination.unwrap().1);\n-                                return Ok(());\n-                            },\n-                            \"std::thread::Builder::new\" => return Err(EvalError::Unimplemented(\"miri does not support threading\".to_owned())),\n-                            \"std::env::args\" => return Err(EvalError::Unimplemented(\"miri does not support program arguments\".to_owned())),\n-                            \"std::panicking::rust_panic_with_hook\" |\n-                            \"std::rt::begin_panic_fmt\" => return Err(EvalError::Panic),\n-                            \"std::panicking::panicking\" |\n-                            \"std::rt::panicking\" => {\n-                                let (lval, block) = destination.expect(\"std::rt::panicking does not diverge\");\n-                                // we abort on panic -> `std::rt::panicking` always returns false\n-                                let bool = self.tcx.types.bool;\n-                                self.write_primval(lval, PrimVal::from_bool(false), bool)?;\n-                                self.goto_block(block);\n-                                return Ok(());\n-                            }\n-                            _ => {},\n-                        }\n-                        return Err(EvalError::NoMirFor(path));\n-                    },\n-                    Err(other) => return Err(other),\n-                };\n-                let (return_lvalue, return_to_block) = match destination {\n-                    Some((lvalue, block)) => (lvalue, StackPopCleanup::Goto(block)),\n-                    None => {\n-                        // FIXME(solson)\n-                        let lvalue = Lvalue::from_ptr(Pointer::never_ptr());\n-                        (lvalue, StackPopCleanup::None)\n-                    }\n-                };\n-\n-                self.push_stack_frame(\n+                self.eval_fn_call_inner(\n                     resolved_def_id,\n-                    span,\n-                    mir,\n                     resolved_substs,\n-                    return_lvalue,\n-                    return_to_block,\n+                    destination,\n+                    args,\n                     temporaries,\n-                )?;\n-\n-                let arg_locals = self.frame().mir.args_iter();\n-                assert_eq!(self.frame().mir.arg_count, args.len());\n-                for (arg_local, (arg_val, arg_ty)) in arg_locals.zip(args) {\n-                    let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n-                    self.write_value(arg_val, dest, arg_ty)?;\n+                    span,\n+                )\n+            },\n+            Function::NonCaptureClosureAsFnPtr(FunctionDefinition { def_id, substs, sig }) if sig.abi() == Abi::RustCall => {\n+                let sig = self.erase_lifetimes(&sig);\n+                let mut args = Vec::new();\n+                for arg in arg_operands {\n+                    let arg_val = self.eval_operand(arg)?;\n+                    let arg_ty = self.operand_ty(arg);\n+                    args.push((arg_val, arg_ty));\n                 }\n+                args.insert(0, (\n+                    Value::ByVal(PrimVal::Undef),\n+                    sig.inputs()[0],\n+                ));\n+                self.eval_fn_call_inner(\n+                    def_id,\n+                    substs,\n+                    destination,\n+                    args,\n+                    Vec::new(),\n+                    span,\n+                )\n+            }\n+            Function::Concrete(fn_def) => Err(EvalError::Unimplemented(format!(\"can't handle function with {:?} ABI\", fn_def.sig.abi()))),\n+            other => Err(EvalError::Unimplemented(format!(\"can't call function kind {:#?}\", other))),\n+        }\n+    }\n \n-                Ok(())\n+    fn eval_fn_call_inner(\n+        &mut self,\n+        resolved_def_id: DefId,\n+        resolved_substs: &'tcx Substs,\n+        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        args: Vec<(Value, Ty<'tcx>)>,\n+        temporaries: Vec<(Pointer, Ty<'tcx>)>,\n+        span: Span,\n+    ) -> EvalResult<'tcx> {\n+        trace!(\"eval_fn_call_inner: {:#?}, {:#?}, {:#?}\", args, temporaries, destination);\n+\n+        let mir = match self.load_mir(resolved_def_id) {\n+            Ok(mir) => mir,\n+            Err(EvalError::NoMirFor(path)) => {\n+                match &path[..] {\n+                    // let's just ignore all output for now\n+                    \"std::io::_print\" => {\n+                        self.goto_block(destination.unwrap().1);\n+                        return Ok(());\n+                    },\n+                    \"std::thread::Builder::new\" => return Err(EvalError::Unimplemented(\"miri does not support threading\".to_owned())),\n+                    \"std::env::args\" => return Err(EvalError::Unimplemented(\"miri does not support program arguments\".to_owned())),\n+                    \"std::panicking::rust_panic_with_hook\" |\n+                    \"std::rt::begin_panic_fmt\" => return Err(EvalError::Panic),\n+                    \"std::panicking::panicking\" |\n+                    \"std::rt::panicking\" => {\n+                        let (lval, block) = destination.expect(\"std::rt::panicking does not diverge\");\n+                        // we abort on panic -> `std::rt::panicking` always returns false\n+                        let bool = self.tcx.types.bool;\n+                        self.write_primval(lval, PrimVal::from_bool(false), bool)?;\n+                        self.goto_block(block);\n+                        return Ok(());\n+                    }\n+                    _ => {},\n+                }\n+                return Err(EvalError::NoMirFor(path));\n+            },\n+            Err(other) => return Err(other),\n+        };\n+        let (return_lvalue, return_to_block) = match destination {\n+            Some((lvalue, block)) => (lvalue, StackPopCleanup::Goto(block)),\n+            None => {\n+                // FIXME(solson)\n+                let lvalue = Lvalue::from_ptr(Pointer::never_ptr());\n+                (lvalue, StackPopCleanup::None)\n             }\n+        };\n \n-            abi => Err(EvalError::Unimplemented(format!(\"can't handle function with {:?} ABI\", abi))),\n+        self.push_stack_frame(\n+            resolved_def_id,\n+            span,\n+            mir,\n+            resolved_substs,\n+            return_lvalue,\n+            return_to_block,\n+            temporaries,\n+        )?;\n+\n+        let arg_locals = self.frame().mir.args_iter();\n+        assert_eq!(self.frame().mir.arg_count, args.len());\n+        for (arg_local, (arg_val, arg_ty)) in arg_locals.zip(args) {\n+            let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n+            self.write_value(arg_val, dest, arg_ty)?;\n         }\n+\n+        Ok(())\n     }\n \n     pub fn read_discriminant_value(&self, adt_ptr: Pointer, adt_ty: Ty<'tcx>) -> EvalResult<'tcx, u128> {"}, {"sha": "72de17801d5eba13499db45ea71e2e83a915f17e", "filename": "src/traits.rs", "status": "modified", "additions": 37, "deletions": 12, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/6ee8595375dadeaff743c848f298e8408f0bb5e9/src%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee8595375dadeaff743c848f298e8408f0bb5e9/src%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftraits.rs?ref=6ee8595375dadeaff743c848f298e8408f0bb5e9", "patch": "@@ -113,7 +113,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 match self.memory.get_fn(fn_ptr.alloc_id)? {\n                     Function::FnDefAsTraitObject(fn_def) => {\n                         trace!(\"sig: {:#?}\", fn_def.sig);\n-                        assert!(fn_def.abi != abi::Abi::RustCall);\n+                        assert!(fn_def.sig.abi() != abi::Abi::RustCall);\n                         assert_eq!(args.len(), 2);\n                         // a function item turned into a closure trait object\n                         // the first arg is just there to give use the vtable\n@@ -123,25 +123,49 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     },\n                     Function::DropGlue(_) => Err(EvalError::ManuallyCalledDropGlue),\n                     Function::Concrete(fn_def) => {\n-                        trace!(\"sig: {:#?}\", fn_def.sig);\n+                        let sig = self.erase_lifetimes(&fn_def.sig);\n+                        trace!(\"sig: {:#?}\", sig);\n                         args[0] = (\n                             Value::ByVal(PrimVal::Ptr(self_ptr)),\n-                            fn_def.sig.inputs()[0],\n+                            sig.inputs()[0],\n                         );\n                         Ok((fn_def.def_id, fn_def.substs, Vec::new()))\n                     },\n+                    Function::NonCaptureClosureAsFnPtr(fn_def) => {\n+                        let sig = self.erase_lifetimes(&fn_def.sig);\n+                        args.insert(0, (\n+                            Value::ByVal(PrimVal::Undef),\n+                            sig.inputs()[0],\n+                        ));\n+                        Ok((fn_def.def_id, fn_def.substs, Vec::new()))\n+                    }\n                     Function::Closure(fn_def) => {\n                         self.unpack_fn_args(args)?;\n                         Ok((fn_def.def_id, fn_def.substs, Vec::new()))\n                     }\n                     Function::FnPtrAsTraitObject(sig) => {\n+                        let sig = self.erase_lifetimes(&sig);\n                         trace!(\"sig: {:#?}\", sig);\n                         // the first argument was the fat ptr\n                         args.remove(0);\n                         self.unpack_fn_args(args)?;\n                         let fn_ptr = self.memory.read_ptr(self_ptr)?;\n-                        let fn_def = self.memory.get_fn(fn_ptr.alloc_id)?.expect_concrete()?;\n-                        assert_eq!(sig, fn_def.sig);\n+                        let fn_def = match self.memory.get_fn(fn_ptr.alloc_id)? {\n+                            Function::Concrete(fn_def) => {\n+                                let fn_def_sig = self.erase_lifetimes(&fn_def.sig);\n+                                assert_eq!(sig, fn_def_sig);\n+                                fn_def\n+                            },\n+                            Function::NonCaptureClosureAsFnPtr(fn_def) => {\n+                                let fn_def_sig = self.erase_lifetimes(&fn_def.sig);\n+                                args.insert(0, (\n+                                    Value::ByVal(PrimVal::Undef),\n+                                    fn_def_sig.inputs()[0],\n+                                ));\n+                                fn_def\n+                            },\n+                            other => bug!(\"FnPtrAsTraitObject for {:?}\", other),\n+                        };\n                         Ok((fn_def.def_id, fn_def.substs, Vec::new()))\n                     }\n                 }\n@@ -201,7 +225,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                 _ => bug!(\"bad function type: {}\", fn_ty),\n                             };\n                             let fn_ty = self.tcx.erase_regions(&fn_ty);\n-                            self.memory.create_fn_ptr(self.tcx, mth.method.def_id, mth.substs, fn_ty)\n+                            self.memory.create_fn_ptr(mth.method.def_id, mth.substs, fn_ty)\n                         }))\n                         .collect::<Vec<_>>()\n                         .into_iter()\n@@ -214,15 +238,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         ..\n                     }\n                 ) => {\n-                    let closure_type = self.tcx.closure_type(closure_def_id, substs);\n-                    vec![Some(self.memory.create_closure_ptr(self.tcx, closure_def_id, substs, closure_type))].into_iter()\n+                    let closure_type = self.tcx.closure_type(closure_def_id);\n+                    vec![Some(self.memory.create_closure_ptr(closure_def_id, substs, closure_type))].into_iter()\n                 }\n \n                 // turn a function definition into a Fn trait object\n                 traits::VtableFnPointer(traits::VtableFnPointerData { fn_ty, .. }) => {\n                     match fn_ty.sty {\n                         ty::TyFnDef(did, substs, bare_fn_ty) => {\n-                            vec![Some(self.memory.create_fn_as_trait_glue(self.tcx, did, substs, bare_fn_ty))].into_iter()\n+                            vec![Some(self.memory.create_fn_as_trait_glue(did, substs, bare_fn_ty))].into_iter()\n                         },\n                         ty::TyFnPtr(bare_fn_ty) => {\n                             vec![Some(self.memory.create_fn_ptr_as_trait_glue(bare_fn_ty))].into_iter()\n@@ -256,13 +280,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         // in case there is no drop function to be called, this still needs to be initialized\n         self.memory.write_usize(vtable, 0)?;\n         if let ty::TyAdt(adt_def, substs) = trait_ref.self_ty().sty {\n-            if let Some(drop_def_id) = adt_def.destructor() {\n-                let fn_ty = match self.tcx.item_type(drop_def_id).sty {\n+            if let Some(destructor) = adt_def.destructor(self.tcx) {\n+                let fn_ty = match self.tcx.item_type(destructor.did).sty {\n                     ty::TyFnDef(_, _, fn_ty) => self.tcx.erase_regions(&fn_ty),\n                     _ => bug!(\"drop method is not a TyFnDef\"),\n                 };\n+                let fn_ty = self.erase_lifetimes(&fn_ty);\n                 // The real type is taken from the self argument in `fn drop(&mut self)`\n-                let real_ty = match fn_ty.sig.skip_binder().inputs()[0].sty {\n+                let real_ty = match fn_ty.inputs()[0].sty {\n                     ty::TyRef(_, mt) => self.monomorphize(mt.ty, substs),\n                     _ => bug!(\"first argument of Drop::drop must be &mut T\"),\n                 };"}, {"sha": "7509ae6ed77cb5de14fc77cc85aea86d432d7b60", "filename": "tests/compile-fail/cast_fn_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ee8595375dadeaff743c848f298e8408f0bb5e9/tests%2Fcompile-fail%2Fcast_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee8595375dadeaff743c848f298e8408f0bb5e9/tests%2Fcompile-fail%2Fcast_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_fn_ptr.rs?ref=6ee8595375dadeaff743c848f298e8408f0bb5e9", "patch": "@@ -5,5 +5,5 @@ fn main() {\n         std::mem::transmute::<fn(), fn(i32)>(f)\n     };\n \n-    g(42) //~ ERROR tried to call a function with abi Rust and sig\n+    g(42) //~ ERROR tried to call a function with sig fn() through a function pointer of type fn(i32)\n }"}, {"sha": "6f73a3d09dda7aa5b835a04f33c32c7db43faa97", "filename": "tests/run-pass/non_capture_closure_to_fn_ptr.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6ee8595375dadeaff743c848f298e8408f0bb5e9/tests%2Frun-pass%2Fnon_capture_closure_to_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee8595375dadeaff743c848f298e8408f0bb5e9/tests%2Frun-pass%2Fnon_capture_closure_to_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fnon_capture_closure_to_fn_ptr.rs?ref=6ee8595375dadeaff743c848f298e8408f0bb5e9", "patch": "@@ -0,0 +1,16 @@\n+#![feature(closure_to_fn_coercion)]\n+\n+// allow(const_err) to work around a bug in warnings\n+#[allow(const_err)]\n+static FOO: fn() = || { assert_ne!(42, 43) };\n+#[allow(const_err)]\n+static BAR: fn(i32, i32) = |a, b| { assert_ne!(a, b) };\n+\n+fn main() {\n+    FOO();\n+    BAR(44, 45);\n+    let bar: unsafe fn(i32, i32) = BAR;\n+    unsafe { bar(46, 47) };\n+    let boo: &Fn(i32, i32) = &BAR;\n+    boo(48, 49);\n+}"}, {"sha": "77f2902917a1c21e22be8376ce8c82a2e5950332", "filename": "tests/run-pass/recursive_static.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ee8595375dadeaff743c848f298e8408f0bb5e9/tests%2Frun-pass%2Frecursive_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee8595375dadeaff743c848f298e8408f0bb5e9/tests%2Frun-pass%2Frecursive_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Frecursive_static.rs?ref=6ee8595375dadeaff743c848f298e8408f0bb5e9", "patch": "@@ -1,5 +1,3 @@\n-#![feature(static_recursion)]\n-\n struct S(&'static S);\n static S1: S = S(&S2);\n static S2: S = S(&S1);"}, {"sha": "0ee523a5be00ac9ac8712633c20cec40399dc6ae", "filename": "tests/run-pass/rfc1623.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/6ee8595375dadeaff743c848f298e8408f0bb5e9/tests%2Frun-pass%2Frfc1623.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ee8595375dadeaff743c848f298e8408f0bb5e9/tests%2Frun-pass%2Frfc1623.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Frfc1623.rs?ref=6ee8595375dadeaff743c848f298e8408f0bb5e9", "patch": "@@ -0,0 +1,81 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+// very simple test for a 'static static with default lifetime\n+static STATIC_STR: &str = \"&'static str\";\n+const CONST_STR: &str = \"&'static str\";\n+\n+// this should be the same as without default:\n+static EXPLICIT_STATIC_STR: &'static str = \"&'static str\";\n+const EXPLICIT_CONST_STR: &'static str = \"&'static str\";\n+\n+// a function that elides to an unbound lifetime for both in- and output\n+fn id_u8_slice(arg: &[u8]) -> &[u8] {\n+    arg\n+}\n+\n+// one with a function, argument elided\n+static STATIC_SIMPLE_FN: &fn(&[u8]) -> &[u8] = &(id_u8_slice as fn(&[u8]) -> &[u8]);\n+const CONST_SIMPLE_FN: &fn(&[u8]) -> &[u8] = &(id_u8_slice as fn(&[u8]) -> &[u8]);\n+\n+// this should be the same as without elision\n+static STATIC_NON_ELIDED_FN: &for<'a> fn(&'a [u8]) -> &'a [u8] =\n+    &(id_u8_slice as for<'a> fn(&'a [u8]) -> &'a [u8]);\n+const CONST_NON_ELIDED_FN: &for<'a> fn(&'a [u8]) -> &'a [u8] =\n+    &(id_u8_slice as for<'a> fn(&'a [u8]) -> &'a [u8]);\n+\n+// another function that elides, each to a different unbound lifetime\n+fn multi_args(_a: &u8, _b: &u8, _c: &u8) {}\n+\n+static STATIC_MULTI_FN: &fn(&u8, &u8, &u8) = &(multi_args as fn(&u8, &u8, &u8));\n+const CONST_MULTI_FN: &fn(&u8, &u8, &u8) = &(multi_args as fn(&u8, &u8, &u8));\n+\n+struct Foo<'a> {\n+    bools: &'a [bool],\n+}\n+\n+static STATIC_FOO: Foo = Foo { bools: &[true, false] };\n+const CONST_FOO: Foo = Foo { bools: &[true, false] };\n+\n+type Bar<'a> = Foo<'a>;\n+\n+static STATIC_BAR: Bar = Bar { bools: &[true, false] };\n+const CONST_BAR: Bar = Bar { bools: &[true, false] };\n+\n+type Baz<'a> = fn(&'a [u8]) -> Option<u8>;\n+\n+fn baz(e: &[u8]) -> Option<u8> {\n+    e.first().map(|x| *x)\n+}\n+\n+static STATIC_BAZ: &Baz = &(baz as Baz);\n+const CONST_BAZ: &Baz = &(baz as Baz);\n+\n+static BYTES: &[u8] = &[1, 2, 3];\n+\n+fn main() {\n+    // make sure that the lifetime is actually elided (and not defaulted)\n+    let x = &[1u8, 2, 3];\n+    STATIC_SIMPLE_FN(x);\n+    CONST_SIMPLE_FN(x);\n+\n+    STATIC_BAZ(BYTES); // neees static lifetime\n+    CONST_BAZ(BYTES);\n+\n+    // make sure this works with different lifetimes\n+    let a = &1;\n+    {\n+        let b = &2;\n+        let c = &3;\n+        CONST_MULTI_FN(a, b, c);\n+    }\n+}"}]}