{"sha": "1c6868aa21981b37cbd3fc95828ee3b0ac22d494", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjNjg2OGFhMjE5ODFiMzdjYmQzZmM5NTgyOGVlM2IwYWMyMmQ0OTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-27T21:14:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-27T21:14:55Z"}, "message": "Auto merge of #84568 - andoriyu:libtest/junit_formatter, r=yaahc\n\nfeat(libtest): Add JUnit formatter\n\ntracking issue: https://github.com/rust-lang/rust/issues/85563\n\nAdd an alternative formatter to `libtest`. Formatter produces valid xml that later can be interpreted as JUnit report.\n\nCaveats:\n\n- `timestamp` is required by schema, but every viewer/parser ignores it. Attribute is not set to avoid depending on chrono;\n- Running all \"suits\" (unit tests, doc-tests and integration tests) will produce a mess;\n- I couldn't find a way to get integration test binary name, so it's just goes by \"integration\";\n\nSample output for unit tests (pretty printed by 3rd party tool):\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<testsuites>\n  <testsuite name=\"test\" package=\"test\" id=\"0\" errors=\"0\" failures=\"0\" tests=\"13\" skipped=\"1\">\n    <testcase classname=\"results::tests\" name=\"test_completed_bad\" time=\"0\"/>\n    <testcase classname=\"results::tests\" name=\"suite_started\" time=\"0\"/>\n    <testcase classname=\"results::tests\" name=\"suite_ended_ok\" time=\"0\"/>\n    <testcase classname=\"results::tests\" name=\"suite_ended_bad\" time=\"0\"/>\n    <testcase classname=\"junit::tests\" name=\"test_failed_output\" time=\"0\"/>\n    <testcase classname=\"junit::tests\" name=\"test_simple_output\" time=\"0\"/>\n    <testcase classname=\"junit::tests\" name=\"test_multiple_outputs\" time=\"0\"/>\n    <testcase classname=\"results::tests\" name=\"test_completed_ok\" time=\"0\"/>\n    <testcase classname=\"results::tests\" name=\"test_stared\" time=\"0\"/>\n    <testcase classname=\"junit::tests\" name=\"test_generate_xml_no_error_single_testsuite\" time=\"0\"/>\n    <testcase classname=\"results::tests\" name=\"test_simple_output\" time=\"0\"/>\n    <testcase classname=\"test\" name=\"should_panic\" time=\"0\"/>\n    <system-out/>\n    <system-err/>\n  </testsuite>\n</testsuites>\n```\n\nSample output for integration tests (pretty printed by 3rd party tool):\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<testsuites>\n  <testsuite name=\"test\" package=\"test\" id=\"0\" errors=\"0\" failures=\"0\" tests=\"1\" skipped=\"0\">\n    <testcase classname=\"integration\" name=\"test_add\" time=\"0\"/>\n    <system-out/>\n    <system-err/>\n  </testsuite>\n</testsuites>\n```\n\nSample output for Doc-tests (pretty printed by 3rd party tool):\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<testsuites>\n  <testsuite name=\"test\" package=\"test\" id=\"0\" errors=\"0\" failures=\"0\" tests=\"1\" skipped=\"0\">\n    <testcase classname=\"src/lib.rs\" name=\"(line 2)\" time=\"0\"/>\n    <system-out/>\n    <system-err/>\n  </testsuite>\n</testsuites>\n```", "tree": {"sha": "efa2770eecc3605da8b0e5a4e0609a602f96f99c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efa2770eecc3605da8b0e5a4e0609a602f96f99c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c6868aa21981b37cbd3fc95828ee3b0ac22d494", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c6868aa21981b37cbd3fc95828ee3b0ac22d494", "html_url": "https://github.com/rust-lang/rust/commit/1c6868aa21981b37cbd3fc95828ee3b0ac22d494", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c6868aa21981b37cbd3fc95828ee3b0ac22d494/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e51830b90afd339332892a8f20db1957d43bf086", "url": "https://api.github.com/repos/rust-lang/rust/commits/e51830b90afd339332892a8f20db1957d43bf086", "html_url": "https://github.com/rust-lang/rust/commit/e51830b90afd339332892a8f20db1957d43bf086"}, {"sha": "9f83e2290a978ef448567e55548a192f8b8f1f69", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f83e2290a978ef448567e55548a192f8b8f1f69", "html_url": "https://github.com/rust-lang/rust/commit/9f83e2290a978ef448567e55548a192f8b8f1f69"}], "stats": {"total": 195, "additions": 190, "deletions": 5}, "files": [{"sha": "84874a2d2254ac310bdb11819261a90cd9da6326", "filename": "library/test/src/cli.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1c6868aa21981b37cbd3fc95828ee3b0ac22d494/library%2Ftest%2Fsrc%2Fcli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c6868aa21981b37cbd3fc95828ee3b0ac22d494/library%2Ftest%2Fsrc%2Fcli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fcli.rs?ref=1c6868aa21981b37cbd3fc95828ee3b0ac22d494", "patch": "@@ -95,8 +95,9 @@ fn optgroups() -> getopts::Options {\n             \"Configure formatting of output:\n             pretty = Print verbose output;\n             terse  = Display one character per test;\n-            json   = Output a json document\",\n-            \"pretty|terse|json\",\n+            json   = Output a json document;\n+            junit  = Output a JUnit document\",\n+            \"pretty|terse|json|junit\",\n         )\n         .optflag(\"\", \"show-output\", \"Show captured stdout of successful tests\")\n         .optopt(\n@@ -336,10 +337,15 @@ fn get_format(\n             }\n             OutputFormat::Json\n         }\n-\n+        Some(\"junit\") => {\n+            if !allow_unstable {\n+                return Err(\"The \\\"junit\\\" format is only accepted on the nightly compiler\".into());\n+            }\n+            OutputFormat::Junit\n+        }\n         Some(v) => {\n             return Err(format!(\n-                \"argument for --format must be pretty, terse, or json (was \\\n+                \"argument for --format must be pretty, terse, json or junit (was \\\n                  {})\",\n                 v\n             ));"}, {"sha": "9cfc7eaf4bcf459af5f471f963e1fa4b27bfd1ab", "filename": "library/test/src/console.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1c6868aa21981b37cbd3fc95828ee3b0ac22d494/library%2Ftest%2Fsrc%2Fconsole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c6868aa21981b37cbd3fc95828ee3b0ac22d494/library%2Ftest%2Fsrc%2Fconsole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fconsole.rs?ref=1c6868aa21981b37cbd3fc95828ee3b0ac22d494", "patch": "@@ -10,7 +10,7 @@ use super::{\n     cli::TestOpts,\n     event::{CompletedTest, TestEvent},\n     filter_tests,\n-    formatters::{JsonFormatter, OutputFormatter, PrettyFormatter, TerseFormatter},\n+    formatters::{JsonFormatter, JunitFormatter, OutputFormatter, PrettyFormatter, TerseFormatter},\n     helpers::{concurrency::get_concurrency, metrics::MetricMap},\n     options::{Options, OutputFormat},\n     run_tests,\n@@ -277,6 +277,7 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n             Box::new(TerseFormatter::new(output, opts.use_color(), max_name_len, is_multithreaded))\n         }\n         OutputFormat::Json => Box::new(JsonFormatter::new(output)),\n+        OutputFormat::Junit => Box::new(JunitFormatter::new(output)),\n     };\n     let mut st = ConsoleTestState::new(opts)?;\n "}, {"sha": "ec66fc1219ff7fd4df997f8209432f658abb882b", "filename": "library/test/src/formatters/junit.rs", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/1c6868aa21981b37cbd3fc95828ee3b0ac22d494/library%2Ftest%2Fsrc%2Fformatters%2Fjunit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c6868aa21981b37cbd3fc95828ee3b0ac22d494/library%2Ftest%2Fsrc%2Fformatters%2Fjunit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fformatters%2Fjunit.rs?ref=1c6868aa21981b37cbd3fc95828ee3b0ac22d494", "patch": "@@ -0,0 +1,174 @@\n+use std::io::{self, prelude::Write};\n+use std::time::Duration;\n+\n+use super::OutputFormatter;\n+use crate::{\n+    console::{ConsoleTestState, OutputLocation},\n+    test_result::TestResult,\n+    time,\n+    types::{TestDesc, TestType},\n+};\n+\n+pub struct JunitFormatter<T> {\n+    out: OutputLocation<T>,\n+    results: Vec<(TestDesc, TestResult, Duration)>,\n+}\n+\n+impl<T: Write> JunitFormatter<T> {\n+    pub fn new(out: OutputLocation<T>) -> Self {\n+        Self { out, results: Vec::new() }\n+    }\n+\n+    fn write_message(&mut self, s: &str) -> io::Result<()> {\n+        assert!(!s.contains('\\n'));\n+\n+        self.out.write_all(s.as_ref())\n+    }\n+}\n+\n+impl<T: Write> OutputFormatter for JunitFormatter<T> {\n+    fn write_run_start(&mut self, _test_count: usize) -> io::Result<()> {\n+        // We write xml header on run start\n+        self.write_message(&\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\")\n+    }\n+\n+    fn write_test_start(&mut self, _desc: &TestDesc) -> io::Result<()> {\n+        // We do not output anything on test start.\n+        Ok(())\n+    }\n+\n+    fn write_timeout(&mut self, _desc: &TestDesc) -> io::Result<()> {\n+        // We do not output anything on test timeout.\n+        Ok(())\n+    }\n+\n+    fn write_result(\n+        &mut self,\n+        desc: &TestDesc,\n+        result: &TestResult,\n+        exec_time: Option<&time::TestExecTime>,\n+        _stdout: &[u8],\n+        _state: &ConsoleTestState,\n+    ) -> io::Result<()> {\n+        // Because the testsuit node holds some of the information as attributes, we can't write it\n+        // until all of the tests has ran. Instead of writting every result as they come in, we add\n+        // them to a Vec and write them all at once when run is complete.\n+        let duration = exec_time.map(|t| t.0.clone()).unwrap_or_default();\n+        self.results.push((desc.clone(), result.clone(), duration));\n+        Ok(())\n+    }\n+    fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool> {\n+        self.write_message(\"<testsuites>\")?;\n+\n+        self.write_message(&*format!(\n+            \"<testsuite name=\\\"test\\\" package=\\\"test\\\" id=\\\"0\\\" \\\n+             errors=\\\"0\\\" \\\n+             failures=\\\"{}\\\" \\\n+             tests=\\\"{}\\\" \\\n+             skipped=\\\"{}\\\" \\\n+             >\",\n+            state.failed, state.total, state.ignored\n+        ))?;\n+        for (desc, result, duration) in std::mem::replace(&mut self.results, Vec::new()) {\n+            let (class_name, test_name) = parse_class_name(&desc);\n+            match result {\n+                TestResult::TrIgnored => { /* no-op */ }\n+                TestResult::TrFailed => {\n+                    self.write_message(&*format!(\n+                        \"<testcase classname=\\\"{}\\\" \\\n+                         name=\\\"{}\\\" time=\\\"{}\\\">\",\n+                        class_name,\n+                        test_name,\n+                        duration.as_secs()\n+                    ))?;\n+                    self.write_message(\"<failure type=\\\"assert\\\"/>\")?;\n+                    self.write_message(\"</testcase>\")?;\n+                }\n+\n+                TestResult::TrFailedMsg(ref m) => {\n+                    self.write_message(&*format!(\n+                        \"<testcase classname=\\\"{}\\\" \\\n+                         name=\\\"{}\\\" time=\\\"{}\\\">\",\n+                        class_name,\n+                        test_name,\n+                        duration.as_secs()\n+                    ))?;\n+                    self.write_message(&*format!(\"<failure message=\\\"{}\\\" type=\\\"assert\\\"/>\", m))?;\n+                    self.write_message(\"</testcase>\")?;\n+                }\n+\n+                TestResult::TrTimedFail => {\n+                    self.write_message(&*format!(\n+                        \"<testcase classname=\\\"{}\\\" \\\n+                         name=\\\"{}\\\" time=\\\"{}\\\">\",\n+                        class_name,\n+                        test_name,\n+                        duration.as_secs()\n+                    ))?;\n+                    self.write_message(\"<failure type=\\\"timeout\\\"/>\")?;\n+                    self.write_message(\"</testcase>\")?;\n+                }\n+\n+                TestResult::TrBench(ref b) => {\n+                    self.write_message(&*format!(\n+                        \"<testcase classname=\\\"benchmark::{}\\\" \\\n+                         name=\\\"{}\\\" time=\\\"{}\\\" />\",\n+                        class_name, test_name, b.ns_iter_summ.sum\n+                    ))?;\n+                }\n+\n+                TestResult::TrOk | TestResult::TrAllowedFail => {\n+                    self.write_message(&*format!(\n+                        \"<testcase classname=\\\"{}\\\" \\\n+                         name=\\\"{}\\\" time=\\\"{}\\\"/>\",\n+                        class_name,\n+                        test_name,\n+                        duration.as_secs()\n+                    ))?;\n+                }\n+            }\n+        }\n+        self.write_message(\"<system-out/>\")?;\n+        self.write_message(\"<system-err/>\")?;\n+        self.write_message(\"</testsuite>\")?;\n+        self.write_message(\"</testsuites>\")?;\n+\n+        Ok(state.failed == 0)\n+    }\n+}\n+\n+fn parse_class_name(desc: &TestDesc) -> (String, String) {\n+    match desc.test_type {\n+        TestType::UnitTest => parse_class_name_unit(desc),\n+        TestType::DocTest => parse_class_name_doc(desc),\n+        TestType::IntegrationTest => parse_class_name_integration(desc),\n+        TestType::Unknown => (String::from(\"unknown\"), String::from(desc.name.as_slice())),\n+    }\n+}\n+\n+fn parse_class_name_unit(desc: &TestDesc) -> (String, String) {\n+    // Module path => classname\n+    // Function name => name\n+    let module_segments: Vec<&str> = desc.name.as_slice().split(\"::\").collect();\n+    let (class_name, test_name) = match module_segments[..] {\n+        [test] => (String::from(\"crate\"), String::from(test)),\n+        [ref path @ .., test] => (path.join(\"::\"), String::from(test)),\n+        [..] => unreachable!(),\n+    };\n+    (class_name, test_name)\n+}\n+\n+fn parse_class_name_doc(desc: &TestDesc) -> (String, String) {\n+    // File path => classname\n+    // Line # => test name\n+    let segments: Vec<&str> = desc.name.as_slice().split(\" - \").collect();\n+    let (class_name, test_name) = match segments[..] {\n+        [file, line] => (String::from(file.trim()), String::from(line.trim())),\n+        [..] => unreachable!(),\n+    };\n+    (class_name, test_name)\n+}\n+\n+fn parse_class_name_integration(desc: &TestDesc) -> (String, String) {\n+    (String::from(\"integration\"), String::from(desc.name.as_slice()))\n+}"}, {"sha": "2e03581b3af3a2112f99288a14400350e115b9b8", "filename": "library/test/src/formatters/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c6868aa21981b37cbd3fc95828ee3b0ac22d494/library%2Ftest%2Fsrc%2Fformatters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c6868aa21981b37cbd3fc95828ee3b0ac22d494/library%2Ftest%2Fsrc%2Fformatters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fformatters%2Fmod.rs?ref=1c6868aa21981b37cbd3fc95828ee3b0ac22d494", "patch": "@@ -8,10 +8,12 @@ use crate::{\n };\n \n mod json;\n+mod junit;\n mod pretty;\n mod terse;\n \n pub(crate) use self::json::JsonFormatter;\n+pub(crate) use self::junit::JunitFormatter;\n pub(crate) use self::pretty::PrettyFormatter;\n pub(crate) use self::terse::TerseFormatter;\n "}, {"sha": "baf36b5f1d85edf2fb330872946e4cfcada4db70", "filename": "library/test/src/options.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c6868aa21981b37cbd3fc95828ee3b0ac22d494/library%2Ftest%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c6868aa21981b37cbd3fc95828ee3b0ac22d494/library%2Ftest%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Foptions.rs?ref=1c6868aa21981b37cbd3fc95828ee3b0ac22d494", "patch": "@@ -39,6 +39,8 @@ pub enum OutputFormat {\n     Terse,\n     /// JSON output\n     Json,\n+    /// JUnit output\n+    Junit,\n }\n \n /// Whether ignored test should be run or not"}]}