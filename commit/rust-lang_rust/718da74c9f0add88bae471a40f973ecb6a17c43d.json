{"sha": "718da74c9f0add88bae471a40f973ecb6a17c43d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxOGRhNzRjOWYwYWRkODhiYWU0NzFhNDBmOTczZWNiNmExN2M0M2Q=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-09-01T16:55:19Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-09-01T16:55:19Z"}, "message": "Merge pull request #272 from birkenfeld/conventions\n\nnew lint: self conventions for certain method names (fixes #267)", "tree": {"sha": "00dcf3fdff285adb3f664d5b53cccc48a1b44647", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00dcf3fdff285adb3f664d5b53cccc48a1b44647"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/718da74c9f0add88bae471a40f973ecb6a17c43d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/718da74c9f0add88bae471a40f973ecb6a17c43d", "html_url": "https://github.com/rust-lang/rust/commit/718da74c9f0add88bae471a40f973ecb6a17c43d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/718da74c9f0add88bae471a40f973ecb6a17c43d/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77fcca00f032fed19246b0939b57ad35c9db31cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/77fcca00f032fed19246b0939b57ad35c9db31cc", "html_url": "https://github.com/rust-lang/rust/commit/77fcca00f032fed19246b0939b57ad35c9db31cc"}, {"sha": "100786419807ac5365185b659d46acc67f5b1ccf", "url": "https://api.github.com/repos/rust-lang/rust/commits/100786419807ac5365185b659d46acc67f5b1ccf", "html_url": "https://github.com/rust-lang/rust/commit/100786419807ac5365185b659d46acc67f5b1ccf"}], "stats": {"total": 75, "additions": 60, "deletions": 15}, "files": [{"sha": "1232f5268754395bbf5666a747c87c7760c9efb0", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/718da74c9f0add88bae471a40f973ecb6a17c43d/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/718da74c9f0add88bae471a40f973ecb6a17c43d/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=718da74c9f0add88bae471a40f973ecb6a17c43d", "patch": "@@ -4,7 +4,7 @@\n A collection of lints that give helpful tips to newbies and catch oversights.\n \n ##Lints\n-There are 52 lints included in this crate:\n+There are 53 lints included in this crate:\n \n name                                                                                                 | default | meaning\n -----------------------------------------------------------------------------------------------------|---------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -59,6 +59,7 @@ name\n [unit_cmp](https://github.com/Manishearth/rust-clippy/wiki#unit_cmp)                                 | warn    | comparing unit values (which is always `true` or `false`, respectively)\n [unused_collect](https://github.com/Manishearth/rust-clippy/wiki#unused_collect)                     | warn    | `collect()`ing an iterator without using the result; this is usually better written as a for loop\n [while_let_loop](https://github.com/Manishearth/rust-clippy/wiki#while_let_loop)                     | warn    | `loop { if let { ... } else break }` can be written as a `while let` loop\n+[wrong_self_convention](https://github.com/Manishearth/rust-clippy/wiki#wrong_self_convention)       | warn    | defining a method named with an established prefix (like \"into_\") that takes `self` with the wrong convention\n [zero_width_space](https://github.com/Manishearth/rust-clippy/wiki#zero_width_space)                 | deny    | using a zero-width space in a string literal, which is confusing\n \n More to come, please [file an issue](https://github.com/Manishearth/rust-clippy/issues) if you have ideas!"}, {"sha": "e51732818bae79ccdd95e5e4e780ac0f94d49484", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/718da74c9f0add88bae471a40f973ecb6a17c43d/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/718da74c9f0add88bae471a40f973ecb6a17c43d/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=718da74c9f0add88bae471a40f973ecb6a17c43d", "patch": "@@ -114,6 +114,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         methods::SHOULD_IMPLEMENT_TRAIT,\n         methods::STR_TO_STRING,\n         methods::STRING_TO_STRING,\n+        methods::WRONG_SELF_CONVENTION,\n         misc::CMP_NAN,\n         misc::CMP_OWNED,\n         misc::FLOAT_CMP,"}, {"sha": "5a20ba0683135820af528cff64f4a5ceb00e68e5", "filename": "src/methods.rs", "status": "modified", "additions": 54, "deletions": 14, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/718da74c9f0add88bae471a40f973ecb6a17c43d/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/718da74c9f0add88bae471a40f973ecb6a17c43d/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=718da74c9f0add88bae471a40f973ecb6a17c43d", "patch": "@@ -23,11 +23,14 @@ declare_lint!(pub STRING_TO_STRING, Warn,\n               \"calling `String.to_string()` which is a no-op\");\n declare_lint!(pub SHOULD_IMPLEMENT_TRAIT, Warn,\n               \"defining a method that should be implementing a std trait\");\n+declare_lint!(pub WRONG_SELF_CONVENTION, Warn,\n+              \"defining a method named with an established prefix (like \\\"into_\\\") that takes \\\n+               `self` with the wrong convention\");\n \n impl LintPass for MethodsPass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(OPTION_UNWRAP_USED, RESULT_UNWRAP_USED, STR_TO_STRING, STRING_TO_STRING,\n-                    SHOULD_IMPLEMENT_TRAIT)\n+                    SHOULD_IMPLEMENT_TRAIT, WRONG_SELF_CONVENTION)\n     }\n \n     fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n@@ -68,18 +71,28 @@ impl LintPass for MethodsPass {\n         if let ItemImpl(_, _, _, None, _, ref items) = item.node {\n             for item in items {\n                 let name = item.ident.name;\n-                for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n-                    if_let_chain! {\n-                        [\n-                            name == method_name,\n-                            let MethodImplItem(ref sig, _) = item.node,\n-                            sig.decl.inputs.len() == n_args,\n-                            out_type.matches(&sig.decl.output),\n-                            self_kind.matches(&sig.explicit_self.node)\n-                        ], {\n-                            span_lint(cx, SHOULD_IMPLEMENT_TRAIT, item.span, &format!(\n-                                \"defining a method called `{}` on this type; consider implementing \\\n-                                 the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n+                if let MethodImplItem(ref sig, _) = item.node {\n+                    // check missing trait implementations\n+                    for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n+                        if_let_chain! {\n+                            [\n+                                name == method_name,\n+                                sig.decl.inputs.len() == n_args,\n+                                out_type.matches(&sig.decl.output),\n+                                self_kind.matches(&sig.explicit_self.node)\n+                            ], {\n+                                span_lint(cx, SHOULD_IMPLEMENT_TRAIT, item.span, &format!(\n+                                    \"defining a method called `{}` on this type; consider implementing \\\n+                                     the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n+                            }\n+                        }\n+                    }\n+                    // check conventions w.r.t. conversion method names and predicates\n+                    for &(prefix, self_kind) in &CONVENTIONS {\n+                        if name.as_str().starts_with(prefix) && !self_kind.matches(&sig.explicit_self.node) {\n+                            span_lint(cx, WRONG_SELF_CONVENTION, sig.explicit_self.span, &format!(\n+                                \"methods called `{}*` usually take {}; consider choosing a less \\\n+                                 ambiguous name\", prefix, self_kind.description()));\n                         }\n                     }\n                 }\n@@ -88,6 +101,14 @@ impl LintPass for MethodsPass {\n     }\n }\n \n+const CONVENTIONS: [(&'static str, SelfKind); 5] = [\n+    (\"into_\", ValueSelf),\n+    (\"to_\", RefSelf),\n+    (\"as_\", RefSelf),\n+    (\"is_\", RefSelf),\n+    (\"from_\", NoSelf),\n+];\n+\n const TRAIT_METHODS: [(&'static str, usize, SelfKind, OutType, &'static str); 30] = [\n     (\"add\",        2, ValueSelf,  AnyType,  \"std::ops::Add`\"),\n     (\"sub\",        2, ValueSelf,  AnyType,  \"std::ops::Sub\"),\n@@ -126,7 +147,7 @@ enum SelfKind {\n     ValueSelf,\n     RefSelf,\n     RefMutSelf,\n-    NoSelf\n+    NoSelf,\n }\n \n impl SelfKind {\n@@ -136,9 +157,28 @@ impl SelfKind {\n             (&RefSelf, &SelfRegion(_, Mutability::MutImmutable, _)) => true,\n             (&RefMutSelf, &SelfRegion(_, Mutability::MutMutable, _)) => true,\n             (&NoSelf, &SelfStatic) => true,\n+            (_, &SelfExplicit(ref ty, _)) => self.matches_explicit_type(ty),\n             _ => false\n         }\n     }\n+\n+    fn matches_explicit_type(&self, ty: &Ty) -> bool {\n+        match (self, &ty.node) {\n+            (&ValueSelf, &TyPath(..)) => true,\n+            (&RefSelf, &TyRptr(_, MutTy { mutbl: Mutability::MutImmutable, .. })) => true,\n+            (&RefMutSelf, &TyRptr(_, MutTy { mutbl: Mutability::MutMutable, .. })) => true,\n+            _ => false\n+        }\n+    }\n+\n+    fn description(&self) -> &'static str {\n+        match *self {\n+            ValueSelf => \"self by value\",\n+            RefSelf => \"self by reference\",\n+            RefMutSelf => \"self by mutable reference\",\n+            NoSelf => \"no self\",\n+        }\n+    }\n }\n \n #[derive(Clone, Copy)]"}, {"sha": "560f36a9d5dfcdffee28dc6c3b5758e31cc00690", "filename": "tests/compile-fail/methods.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/718da74c9f0add88bae471a40f973ecb6a17c43d/tests%2Fcompile-fail%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/718da74c9f0add88bae471a40f973ecb6a17c43d/tests%2Fcompile-fail%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmethods.rs?ref=718da74c9f0add88bae471a40f973ecb6a17c43d", "patch": "@@ -15,6 +15,9 @@ impl T {\n     fn sub(&self, other: T) -> &T { self } // no error, self is a ref\n     fn div(self) -> T { self } // no error, different #arguments\n     fn rem(self, other: T) { } // no error, wrong return type\n+\n+    fn into_u32(self) -> u32 { 0 } // fine\n+    fn into_u16(&self) -> u16 { 0 } //~ERROR methods called `into_*` usually take self by value\n }\n \n impl Mul<T> for T {"}]}