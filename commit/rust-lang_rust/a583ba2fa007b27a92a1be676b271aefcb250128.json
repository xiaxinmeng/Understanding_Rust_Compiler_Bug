{"sha": "a583ba2fa007b27a92a1be676b271aefcb250128", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1ODNiYTJmYTAwN2IyN2E5MmExYmU2NzZiMjcxYWVmY2IyNTAxMjg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-03T18:30:02Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-25T12:04:07Z"}, "message": "Remove `McResult` from the mem-categorization interface.", "tree": {"sha": "fa97a1e9d2514dbb7fd37de3e7bd3b05bb0403c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa97a1e9d2514dbb7fd37de3e7bd3b05bb0403c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a583ba2fa007b27a92a1be676b271aefcb250128", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a583ba2fa007b27a92a1be676b271aefcb250128", "html_url": "https://github.com/rust-lang/rust/commit/a583ba2fa007b27a92a1be676b271aefcb250128", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a583ba2fa007b27a92a1be676b271aefcb250128/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f770f10b2740ff1fb2be938f37ef4f35f8bf4ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f770f10b2740ff1fb2be938f37ef4f35f8bf4ca", "html_url": "https://github.com/rust-lang/rust/commit/8f770f10b2740ff1fb2be938f37ef4f35f8bf4ca"}], "stats": {"total": 337, "additions": 135, "deletions": 202}, "files": [{"sha": "e3f4d7056bd633e53e5164d517be7620b7aa800e", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 35, "deletions": 65, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/a583ba2fa007b27a92a1be676b271aefcb250128/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a583ba2fa007b27a92a1be676b271aefcb250128/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=a583ba2fa007b27a92a1be676b271aefcb250128", "patch": "@@ -302,22 +302,6 @@ pub struct ExprUseVisitor<'d,'t,'tcx,TYPER:'t> {\n     param_env: ParameterEnvironment<'tcx>,\n }\n \n-// If the TYPER results in an error, it's because the type check\n-// failed (or will fail, when the error is uncovered and reported\n-// during writeback). In this case, we just ignore this part of the\n-// code.\n-//\n-// Note that this macro appears similar to try!(), but, unlike try!(),\n-// it does not propagate the error.\n-macro_rules! return_if_err {\n-    ($inp: expr) => (\n-        match $inp {\n-            Ok(v) => v,\n-            Err(()) => return\n-        }\n-    )\n-}\n-\n /// Whether the elements of an overloaded operation are passed by value or by reference\n enum PassArgs {\n     ByValue,\n@@ -348,7 +332,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                          decl: &ast::FnDecl,\n                          body: &ast::Block) {\n         for arg in decl.inputs.iter() {\n-            let arg_ty = return_if_err!(self.typer.node_ty(arg.pat.id));\n+            let arg_ty = self.typer.node_ty(arg.pat.id);\n \n             let fn_body_scope = region::CodeExtent::from_node_id(body.id);\n             let arg_cmt = self.mc.cat_rvalue(\n@@ -385,7 +369,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     pub fn consume_expr(&mut self, expr: &ast::Expr) {\n         debug!(\"consume_expr(expr={})\", expr.repr(self.tcx()));\n \n-        let cmt = return_if_err!(self.mc.cat_expr(expr));\n+        let cmt = self.mc.cat_expr(expr);\n         self.delegate_consume(expr.id, expr.span, cmt);\n         self.walk_expr(expr);\n     }\n@@ -394,7 +378,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                    assignment_expr: &ast::Expr,\n                    expr: &ast::Expr,\n                    mode: MutateMode) {\n-        let cmt = return_if_err!(self.mc.cat_expr(expr));\n+        let cmt = self.mc.cat_expr(expr);\n         self.delegate.mutate(assignment_expr.id, assignment_expr.span, cmt, mode);\n         self.walk_expr(expr);\n     }\n@@ -407,7 +391,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         debug!(\"borrow_expr(expr={}, r={}, bk={})\",\n                expr.repr(self.tcx()), r.repr(self.tcx()), bk.repr(self.tcx()));\n \n-        let cmt = return_if_err!(self.mc.cat_expr(expr));\n+        let cmt = self.mc.cat_expr(expr);\n         self.delegate.borrow(expr.id, expr.span, cmt, r, bk, cause);\n \n         // Note: Unlike consume, we can ignore ExprParen. cat_expr\n@@ -500,7 +484,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             }\n \n             ast::ExprMatch(ref discr, ref arms, _) => {\n-                let discr_cmt = return_if_err!(self.mc.cat_expr(&**discr));\n+                let discr_cmt = self.mc.cat_expr(&**discr);\n                 self.borrow_expr(&**discr, ty::ReEmpty, ty::ImmBorrow, MatchDiscriminant);\n \n                 // treatment of the discriminant is handled while walking the arms.\n@@ -559,7 +543,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n \n                 // Fetch the type of the value that the iteration yields to\n                 // produce the pattern's categorized mutable type.\n-                let pattern_type = return_if_err!(self.typer.node_ty(pat.id));\n+                let pattern_type = self.typer.node_ty(pat.id);\n                 let blk_scope = region::CodeExtent::from_node_id(blk.id);\n                 let pat_cmt = self.mc.cat_rvalue(pat.id,\n                                                  pat.span,\n@@ -647,7 +631,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     }\n \n     fn walk_callee(&mut self, call: &ast::Expr, callee: &ast::Expr) {\n-        let callee_ty = return_if_err!(self.typer.expr_ty_adjusted(callee));\n+        let callee_ty = self.typer.expr_ty_adjusted(callee);\n         debug!(\"walk_callee: callee={} callee_ty={}\",\n                callee.repr(self.tcx()), callee_ty.repr(self.tcx()));\n         let call_scope = region::CodeExtent::from_node_id(call.id);\n@@ -747,7 +731,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 // \"assigns\", which is handled by\n                 // `walk_pat`:\n                 self.walk_expr(&**expr);\n-                let init_cmt = return_if_err!(self.mc.cat_expr(&**expr));\n+                let init_cmt = self.mc.cat_expr(&**expr);\n                 self.walk_irrefutable_pat(init_cmt, &*local.pat);\n             }\n         }\n@@ -781,7 +765,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             None => { return; }\n         };\n \n-        let with_cmt = return_if_err!(self.mc.cat_expr(&*with_expr));\n+        let with_cmt = self.mc.cat_expr(&*with_expr);\n \n         // Select just those fields of the `with`\n         // expression that will actually be used\n@@ -836,7 +820,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         // rvalue.\n                         debug!(\"walk_adjustment(AutoAddEnv|AdjustReifyFnPointer)\");\n                         let cmt_unadjusted =\n-                            return_if_err!(self.mc.cat_expr_unadjusted(expr));\n+                            self.mc.cat_expr_unadjusted(expr);\n                         self.delegate_consume(expr.id, expr.span, cmt_unadjusted);\n                     }\n                     ty::AdjustDerefRef(ty::AutoDerefRef {\n@@ -870,7 +854,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             match self.typer.node_method_ty(deref_id) {\n                 None => {}\n                 Some(method_ty) => {\n-                    let cmt = return_if_err!(self.mc.cat_expr_autoderefd(expr, i));\n+                    let cmt = self.mc.cat_expr_autoderefd(expr, i);\n                     let self_ty = ty::ty_fn_args(method_ty)[0];\n                     let (m, r) = match self_ty.sty {\n                         ty::ty_rptr(r, ref m) => (m.mutbl, r),\n@@ -900,15 +884,14 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 assert!(n == 1, format!(\"Expected exactly 1 deref with Uniq \\\n                                          AutoRefs, found: {}\", n));\n                 let cmt_unadjusted =\n-                    return_if_err!(self.mc.cat_expr_unadjusted(expr));\n+                    self.mc.cat_expr_unadjusted(expr);\n                 self.delegate_consume(expr.id, expr.span, cmt_unadjusted);\n                 return;\n             }\n             _ => {}\n         }\n \n-        let cmt_derefd = return_if_err!(\n-            self.mc.cat_expr_autoderefd(expr, n));\n+        let cmt_derefd = self.mc.cat_expr_autoderefd(expr, n);\n         debug!(\"walk_adjustment: cmt_derefd={}\",\n                cmt_derefd.repr(self.tcx()));\n \n@@ -1001,7 +984,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                                mode: &mut TrackMatchMode<Span>) {\n         debug!(\"determine_pat_move_mode cmt_discr={} pat={}\", cmt_discr.repr(self.tcx()),\n                pat.repr(self.tcx()));\n-        return_if_err!(self.mc.cat_pattern(cmt_discr, pat, |_mc, cmt_pat, pat| {\n+        self.mc.cat_pattern(cmt_discr, pat, |_mc, cmt_pat, pat| {\n             let tcx = self.typer.tcx();\n             let def_map = &self.typer.tcx().def_map;\n             if pat_util::pat_is_binding(def_map, pat) {\n@@ -1024,7 +1007,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                     }\n                 }\n             }\n-        }));\n+        });\n     }\n \n     /// The core driver for walking a pattern; `match_mode` must be\n@@ -1039,11 +1022,11 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n \n         let mc = &self.mc;\n         let typer = self.typer;\n-        let tcx = typer.tcx();\n         let def_map = &self.typer.tcx().def_map;\n         let delegate = &mut self.delegate;\n         let param_env = &mut self.param_env;\n-        return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |mc, cmt_pat, pat| {\n+\n+        mc.cat_pattern(cmt_discr.clone(), pat, |mc, cmt_pat, pat| {\n             if pat_util::pat_is_binding(def_map, pat) {\n                 let tcx = typer.tcx();\n \n@@ -1053,17 +1036,13 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                        match_mode);\n \n                 // pat_ty: the type of the binding being produced.\n-                let pat_ty = return_if_err!(typer.node_ty(pat.id));\n+                let pat_ty = typer.node_ty(pat.id);\n \n                 // Each match binding is effectively an assignment to the\n                 // binding being produced.\n                 let def = def_map.borrow()[pat.id].clone();\n-                match mc.cat_def(pat.id, pat.span, pat_ty, def) {\n-                    Ok(binding_cmt) => {\n-                        delegate.mutate(pat.id, pat.span, binding_cmt, Init);\n-                    }\n-                    Err(_) => { }\n-                }\n+                let binding_cmt = mc.cat_def(pat.id, pat.span, pat_ty, def);\n+                delegate.mutate(pat.id, pat.span, binding_cmt, Init);\n \n                 // It is also a borrow or copy/move of the value being matched.\n                 match pat.node {\n@@ -1097,15 +1076,8 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         // borrow of the elements of the vector being\n                         // matched.\n \n-                        let (slice_cmt, slice_mutbl, slice_r) = {\n-                            match mc.cat_slice_pattern(cmt_pat, &**slice_pat) {\n-                                Ok(v) => v,\n-                                Err(()) => {\n-                                    tcx.sess.span_bug(slice_pat.span,\n-                                                      \"Err from mc\")\n-                                }\n-                            }\n-                        };\n+                        let (slice_cmt, slice_mutbl, slice_r) =\n+                            mc.cat_slice_pattern(cmt_pat, &**slice_pat);\n \n                         // Note: We declare here that the borrow\n                         // occurs upon entering the `[...]`\n@@ -1135,13 +1107,13 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                     _ => { }\n                 }\n             }\n-        }));\n+        });\n \n         // Do a second pass over the pattern, calling `matched_pat` on\n         // the interior nodes (enum variants and structs), as opposed\n         // to the above loop's visit of than the bindings that form\n         // the leaves of the pattern tree structure.\n-        return_if_err!(mc.cat_pattern(cmt_discr, pat, |mc, cmt_pat, pat| {\n+        mc.cat_pattern(cmt_discr, pat, |mc, cmt_pat, pat| {\n             let def_map = def_map.borrow();\n             let tcx = typer.tcx();\n \n@@ -1222,7 +1194,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                     // cases either.\n                 }\n             }\n-        }));\n+        });\n     }\n \n     fn walk_captures(&mut self, closure_expr: &ast::Expr) {\n@@ -1246,9 +1218,9 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                             freevars: &[ty::Freevar]) {\n         for freevar in freevars.iter() {\n             let id_var = freevar.def.def_id().node;\n-            let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.id,\n-                                                               closure_expr.span,\n-                                                               freevar.def));\n+            let cmt_var = self.cat_captured_var(closure_expr.id,\n+                                                closure_expr.span,\n+                                                freevar.def);\n \n             // Lookup the kind of borrow the callee requires, as\n             // inferred by regionbk\n@@ -1269,13 +1241,11 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                               closure_expr: &ast::Expr,\n                               freevars: &[ty::Freevar]) {\n         for freevar in freevars.iter() {\n-            let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.id,\n-                                                               closure_expr.span,\n-                                                               freevar.def));\n-            let mode = copy_or_move(self.tcx(),\n-                                    cmt_var.ty,\n-                                    &self.param_env,\n-                                    CaptureMove);\n+            let cmt_var = self.cat_captured_var(closure_expr.id,\n+                                                closure_expr.span,\n+                                                freevar.def);\n+            let mode = copy_or_move(self.tcx(), cmt_var.ty,\n+                                    &self.param_env, CaptureMove);\n             self.delegate.consume(closure_expr.id, freevar.span, cmt_var, mode);\n         }\n     }\n@@ -1284,11 +1254,11 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         closure_id: ast::NodeId,\n                         closure_span: Span,\n                         upvar_def: def::Def)\n-                        -> mc::McResult<mc::cmt<'tcx>> {\n+                        -> mc::cmt<'tcx> {\n         // Create the cmt for the variable being borrowed, from the\n         // caller's perspective\n         let var_id = upvar_def.def_id().node;\n-        let var_ty = try!(self.typer.node_ty(var_id));\n+        let var_ty = self.typer.node_ty(var_id);\n         self.mc.cat_def(closure_id, closure_span, var_ty, upvar_def)\n     }\n }"}, {"sha": "eff5433c3e52beb16d8f48152574068cf2452945", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 70, "deletions": 85, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/a583ba2fa007b27a92a1be676b271aefcb250128/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a583ba2fa007b27a92a1be676b271aefcb250128/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=a583ba2fa007b27a92a1be676b271aefcb250128", "patch": "@@ -264,8 +264,6 @@ pub struct MemCategorizationContext<'t,TYPER:'t> {\n \n impl<'t,TYPER:'t> Copy for MemCategorizationContext<'t,TYPER> {}\n \n-pub type McResult<T> = Result<T, ()>;\n-\n /// The `Typer` trait provides the interface for the mem-categorization\n /// module to the results of the type check. It can be used to query\n /// the type assigned to an expression node, to inquire after adjustments,\n@@ -284,8 +282,8 @@ pub type McResult<T> = Result<T, ()>;\n /// can be sure that only `Ok` results will occur.\n pub trait Typer<'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n-    fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>>;\n-    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>>;\n+    fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx>;\n+    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> Ty<'tcx>;\n     fn node_method_ty(&self, method_call: ty::MethodCall) -> Option<Ty<'tcx>>;\n     fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment<'tcx>>>;\n     fn is_method_call(&self, id: ast::NodeId) -> bool;\n@@ -375,15 +373,6 @@ impl MutabilityCategory {\n     }\n }\n \n-macro_rules! if_ok {\n-    ($inp: expr) => (\n-        match $inp {\n-            Ok(v) => { v }\n-            Err(e) => { return Err(e); }\n-        }\n-    )\n-}\n-\n impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     pub fn new(typer: &'t TYPER) -> MemCategorizationContext<'t,TYPER> {\n         MemCategorizationContext { typer: typer }\n@@ -393,22 +382,22 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         self.typer.tcx()\n     }\n \n-    fn expr_ty(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>> {\n+    fn expr_ty(&self, expr: &ast::Expr) -> Ty<'tcx> {\n         self.typer.node_ty(expr.id)\n     }\n \n-    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>> {\n-        let unadjusted_ty = if_ok!(self.expr_ty(expr));\n-        Ok(ty::adjust_ty(self.tcx(), expr.span, expr.id, unadjusted_ty,\n-                         self.typer.adjustments().borrow().get(&expr.id),\n-                         |method_call| self.typer.node_method_ty(method_call)))\n+    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> Ty<'tcx> {\n+        let unadjusted_ty = self.expr_ty(expr);\n+        ty::adjust_ty(self.tcx(), expr.span, expr.id, unadjusted_ty,\n+                      self.typer.adjustments().borrow().get(&expr.id),\n+                      |method_call| self.typer.node_method_ty(method_call))\n     }\n \n-    fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n+    fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx> {\n         self.typer.node_ty(id)\n     }\n \n-    fn pat_ty(&self, pat: &ast::Pat) -> McResult<Ty<'tcx>> {\n+    fn pat_ty(&self, pat: &ast::Pat) -> Ty<'tcx> {\n         let tcx = self.typer.tcx();\n         let base_ty = self.typer.node_ty(pat.id);\n         // FIXME (Issue #18207): This code detects whether we are\n@@ -420,11 +409,9 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 // a bind-by-ref means that the base_ty will be the type of the ident itself,\n                 // but what we want here is the type of the underlying value being borrowed.\n                 // So peel off one-level, turning the &T into T.\n-                base_ty.map(|t| {\n-                    ty::deref(t, false).unwrap_or_else(|| {\n-                        panic!(\"encountered BindByRef with non &-type\");\n-                    }).ty\n-                })\n+                ty::deref(base_ty, false).unwrap_or_else(|| {\n+                    panic!(\"encountered BindByRef with non &-type\");\n+                }).ty\n             }\n             _ => base_ty,\n         };\n@@ -433,7 +420,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         ret_ty\n     }\n \n-    pub fn cat_expr(&self, expr: &ast::Expr) -> McResult<cmt<'tcx>> {\n+    pub fn cat_expr(&self, expr: &ast::Expr) -> cmt<'tcx> {\n         match self.typer.adjustments().borrow().get(&expr.id) {\n             None => {\n                 // No adjustments.\n@@ -447,8 +434,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                expr.repr(self.tcx()));\n                         // Convert a bare fn to a closure by adding NULL env.\n                         // Result is an rvalue.\n-                        let expr_ty = if_ok!(self.expr_ty_adjusted(expr));\n-                        Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n+                        let expr_ty = self.expr_ty_adjusted(expr);\n+                        self.cat_rvalue_node(expr.id(), expr.span(), expr_ty)\n                     }\n \n                     ty::AdjustDerefRef(\n@@ -458,8 +445,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                expr.repr(self.tcx()));\n                         // Equivalent to &*expr or something similar.\n                         // Result is an rvalue.\n-                        let expr_ty = if_ok!(self.expr_ty_adjusted(expr));\n-                        Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n+                        let expr_ty = self.expr_ty_adjusted(expr);\n+                        self.cat_rvalue_node(expr.id(), expr.span(), expr_ty)\n                     }\n \n                     ty::AdjustDerefRef(\n@@ -476,39 +463,39 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     pub fn cat_expr_autoderefd(&self,\n                                expr: &ast::Expr,\n                                autoderefs: uint)\n-                               -> McResult<cmt<'tcx>> {\n-        let mut cmt = if_ok!(self.cat_expr_unadjusted(expr));\n+                               -> cmt<'tcx> {\n+        let mut cmt = self.cat_expr_unadjusted(expr);\n         debug!(\"cat_expr_autoderefd: autoderefs={}, cmt={}\",\n                autoderefs,\n                cmt.repr(self.tcx()));\n         for deref in range(1u, autoderefs + 1) {\n             cmt = self.cat_deref(expr, cmt, deref, false);\n         }\n-        return Ok(cmt);\n+        return cmt;\n     }\n \n-    pub fn cat_expr_unadjusted(&self, expr: &ast::Expr) -> McResult<cmt<'tcx>> {\n+    pub fn cat_expr_unadjusted(&self, expr: &ast::Expr) -> cmt<'tcx> {\n         debug!(\"cat_expr: id={} expr={}\", expr.id, expr.repr(self.tcx()));\n \n-        let expr_ty = if_ok!(self.expr_ty(expr));\n+        let expr_ty = self.expr_ty(expr);\n         match expr.node {\n           ast::ExprUnary(ast::UnDeref, ref e_base) => {\n-            let base_cmt = if_ok!(self.cat_expr(&**e_base));\n-            Ok(self.cat_deref(expr, base_cmt, 0, false))\n+            let base_cmt = self.cat_expr(&**e_base);\n+            self.cat_deref(expr, base_cmt, 0, false)\n           }\n \n           ast::ExprField(ref base, f_name) => {\n-            let base_cmt = if_ok!(self.cat_expr(&**base));\n+            let base_cmt = self.cat_expr(&**base);\n             debug!(\"cat_expr(cat_field): id={} expr={} base={}\",\n                    expr.id,\n                    expr.repr(self.tcx()),\n                    base_cmt.repr(self.tcx()));\n-            Ok(self.cat_field(expr, base_cmt, f_name.node.name, expr_ty))\n+            self.cat_field(expr, base_cmt, f_name.node.name, expr_ty)\n           }\n \n           ast::ExprTupField(ref base, idx) => {\n-            let base_cmt = if_ok!(self.cat_expr(&**base));\n-            Ok(self.cat_tup_field(expr, base_cmt, idx.node, expr_ty))\n+            let base_cmt = self.cat_expr(&**base);\n+            self.cat_tup_field(expr, base_cmt, idx.node, expr_ty)\n           }\n \n           ast::ExprIndex(ref base, _) => {\n@@ -518,14 +505,14 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                     // If this is an index implemented by a method call, then it will\n                     // include an implicit deref of the result.\n                     let ret_ty = ty::ty_fn_ret(method_ty).unwrap();\n-                    Ok(self.cat_deref(expr,\n-                                      self.cat_rvalue_node(expr.id(),\n-                                                           expr.span(),\n-                                                           ret_ty), 1, true))\n+                    self.cat_deref(expr,\n+                                   self.cat_rvalue_node(expr.id(),\n+                                                        expr.span(),\n+                                                        ret_ty), 1, true)\n                 }\n                 None => {\n-                    let base_cmt = if_ok!(self.cat_expr(&**base));\n-                    Ok(self.cat_index(expr, base_cmt))\n+                    let base_cmt = self.cat_expr(&**base);\n+                    self.cat_index(expr, base_cmt)\n                 }\n             }\n           }\n@@ -551,7 +538,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           ast::ExprAgain(..) | ast::ExprStruct(..) | ast::ExprRepeat(..) |\n           ast::ExprInlineAsm(..) | ast::ExprBox(..) |\n           ast::ExprForLoop(..) => {\n-            Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n+            self.cat_rvalue_node(expr.id(), expr.span(), expr_ty)\n           }\n \n           ast::ExprIfLet(..) => {\n@@ -568,43 +555,43 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                    span: Span,\n                    expr_ty: Ty<'tcx>,\n                    def: def::Def)\n-                   -> McResult<cmt<'tcx>> {\n+                   -> cmt<'tcx> {\n         debug!(\"cat_def: id={} expr={} def={}\",\n                id, expr_ty.repr(self.tcx()), def);\n \n         match def {\n           def::DefStruct(..) | def::DefVariant(..) | def::DefFn(..) |\n           def::DefStaticMethod(..) | def::DefConst(..) => {\n-                Ok(self.cat_rvalue_node(id, span, expr_ty))\n+                self.cat_rvalue_node(id, span, expr_ty)\n           }\n           def::DefMod(_) | def::DefForeignMod(_) | def::DefUse(_) |\n           def::DefTrait(_) | def::DefTy(..) | def::DefPrimTy(_) |\n           def::DefTyParam(..) | def::DefTyParamBinder(..) | def::DefRegion(_) |\n           def::DefLabel(_) | def::DefSelfTy(..) | def::DefMethod(..) |\n           def::DefAssociatedTy(..) | def::DefAssociatedPath(..)=> {\n-              Ok(Rc::new(cmt_ {\n+              Rc::new(cmt_ {\n                   id:id,\n                   span:span,\n                   cat:cat_static_item,\n                   mutbl: McImmutable,\n                   ty:expr_ty,\n                   note: NoteNone\n-              }))\n+              })\n           }\n \n           def::DefStatic(_, mutbl) => {\n-              Ok(Rc::new(cmt_ {\n+              Rc::new(cmt_ {\n                   id:id,\n                   span:span,\n                   cat:cat_static_item,\n                   mutbl: if mutbl { McDeclared } else { McImmutable},\n                   ty:expr_ty,\n                   note: NoteNone\n-              }))\n+              })\n           }\n \n           def::DefUpvar(var_id, fn_node_id, _) => {\n-              let ty = if_ok!(self.node_ty(fn_node_id));\n+              let ty = self.node_ty(fn_node_id);\n               match ty.sty {\n                   ty::ty_closure(ref closure_ty) => {\n                       // Translate old closure type info into unboxed\n@@ -642,14 +629,14 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           }\n \n           def::DefLocal(vid) => {\n-            Ok(Rc::new(cmt_ {\n+            Rc::new(cmt_ {\n                 id: id,\n                 span: span,\n                 cat: cat_local(vid),\n                 mutbl: MutabilityCategory::from_local(self.tcx(), vid),\n                 ty: expr_ty,\n                 note: NoteNone\n-            }))\n+            })\n           }\n         }\n     }\n@@ -664,7 +651,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                  kind: ty::UnboxedClosureKind,\n                  mode: ast::CaptureClause,\n                  is_unboxed: bool)\n-                 -> McResult<cmt<'tcx>> {\n+                 -> cmt<'tcx> {\n         // An upvar can have up to 3 components.  The base is a\n         // `cat_upvar`.  Next, we add a deref through the implicit\n         // environment pointer with an anonymous free region 'env and\n@@ -686,7 +673,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         // FnOnce         | copied               | upvar -> &'up bk\n         // old stack      | N/A                  | upvar -> &'env mut -> &'up bk\n         // old proc/once  | copied               | N/A\n-        let var_ty = if_ok!(self.node_ty(var_id));\n+        let var_ty = self.node_ty(var_id);\n \n         let upvar_id = ty::UpvarId { var_id: var_id,\n                                      closure_expr_id: fn_node_id };\n@@ -734,7 +721,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         });\n \n         // First, switch by capture mode\n-        Ok(match mode {\n+        match mode {\n             ast::CaptureByValue => {\n                 let mut base = cmt_ {\n                     id: id,\n@@ -816,7 +803,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                     note: NoteUpvarRef(upvar_id)\n                 })\n             }\n-        })\n+        }\n     }\n \n     pub fn cat_rvalue_node(&self,\n@@ -1065,13 +1052,13 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     pub fn cat_slice_pattern(&self,\n                              vec_cmt: cmt<'tcx>,\n                              slice_pat: &ast::Pat)\n-                             -> McResult<(cmt<'tcx>, ast::Mutability, ty::Region)> {\n-        let slice_ty = if_ok!(self.node_ty(slice_pat.id));\n+                             -> (cmt<'tcx>, ast::Mutability, ty::Region) {\n+        let slice_ty = self.node_ty(slice_pat.id);\n         let (slice_mutbl, slice_r) = vec_slice_info(self.tcx(),\n                                                     slice_pat,\n                                                     slice_ty);\n         let cmt_slice = self.cat_index(slice_pat, self.deref_vec(slice_pat, vec_cmt));\n-        return Ok((cmt_slice, slice_mutbl, slice_r));\n+        return (cmt_slice, slice_mutbl, slice_r);\n \n         /// In a pattern like [a, b, ..c], normally `c` has slice type, but if you have [a, b,\n         /// ..ref c], then the type of `ref c` will be `&&[]`, so to extract the slice details we\n@@ -1131,7 +1118,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                        cmt: cmt<'tcx>,\n                        pat: &ast::Pat,\n                        op: |&MemCategorizationContext<'t, TYPER>, cmt<'tcx>, &ast::Pat|)\n-                       -> McResult<()> {\n+    {\n         // Here, `cmt` is the categorization for the value being\n         // matched and pat is the pattern it is being matched against.\n         //\n@@ -1211,30 +1198,30 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 Some(&def::DefVariant(..)) => {\n                     // variant(x, y, z)\n                     for (i, subpat) in subpats.iter().enumerate() {\n-                        let subpat_ty = if_ok!(self.pat_ty(&**subpat)); // see (*2)\n+                        let subpat_ty = self.pat_ty(&**subpat); // see (*2)\n \n                         let subcmt =\n                             self.cat_imm_interior(\n                                 pat, cmt.clone(), subpat_ty,\n                                 InteriorField(PositionalField(i)));\n \n-                        if_ok!(self.cat_pattern(subcmt, &**subpat, |x,y,z| op(x,y,z)));\n+                        self.cat_pattern(subcmt, &**subpat, |x,y,z| op(x,y,z));\n                     }\n                 }\n                 Some(&def::DefStruct(..)) => {\n                     for (i, subpat) in subpats.iter().enumerate() {\n-                        let subpat_ty = if_ok!(self.pat_ty(&**subpat)); // see (*2)\n+                        let subpat_ty = self.pat_ty(&**subpat); // see (*2)\n                         let cmt_field =\n                             self.cat_imm_interior(\n                                 pat, cmt.clone(), subpat_ty,\n                                 InteriorField(PositionalField(i)));\n-                        if_ok!(self.cat_pattern(cmt_field, &**subpat,\n-                                                |x,y,z| op(x,y,z)));\n+                        self.cat_pattern(cmt_field, &**subpat,\n+                                         |x,y,z| op(x,y,z));\n                     }\n                 }\n                 Some(&def::DefConst(..)) => {\n                     for subpat in subpats.iter() {\n-                        if_ok!(self.cat_pattern(cmt.clone(), &**subpat, |x,y,z| op(x,y,z)));\n+                        self.cat_pattern(cmt.clone(), &**subpat, |x,y,z| op(x,y,z));\n                     }\n                 }\n                 _ => {\n@@ -1246,7 +1233,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           }\n \n           ast::PatIdent(_, _, Some(ref subpat)) => {\n-              if_ok!(self.cat_pattern(cmt, &**subpat, op));\n+              self.cat_pattern(cmt, &**subpat, op);\n           }\n \n           ast::PatIdent(_, _, None) => {\n@@ -1256,43 +1243,43 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           ast::PatStruct(_, ref field_pats, _) => {\n             // {f1: p1, ..., fN: pN}\n             for fp in field_pats.iter() {\n-                let field_ty = if_ok!(self.pat_ty(&*fp.node.pat)); // see (*2)\n+                let field_ty = self.pat_ty(&*fp.node.pat); // see (*2)\n                 let cmt_field = self.cat_field(pat, cmt.clone(), fp.node.ident.name, field_ty);\n-                if_ok!(self.cat_pattern(cmt_field, &*fp.node.pat, |x,y,z| op(x,y,z)));\n+                self.cat_pattern(cmt_field, &*fp.node.pat, |x,y,z| op(x,y,z));\n             }\n           }\n \n           ast::PatTup(ref subpats) => {\n             // (p1, ..., pN)\n             for (i, subpat) in subpats.iter().enumerate() {\n-                let subpat_ty = if_ok!(self.pat_ty(&**subpat)); // see (*2)\n+                let subpat_ty = self.pat_ty(&**subpat); // see (*2)\n                 let subcmt =\n                     self.cat_imm_interior(\n                         pat, cmt.clone(), subpat_ty,\n                         InteriorField(PositionalField(i)));\n-                if_ok!(self.cat_pattern(subcmt, &**subpat, |x,y,z| op(x,y,z)));\n+                self.cat_pattern(subcmt, &**subpat, |x,y,z| op(x,y,z));\n             }\n           }\n \n           ast::PatBox(ref subpat) | ast::PatRegion(ref subpat) => {\n             // @p1, ~p1, ref p1\n             let subcmt = self.cat_deref(pat, cmt, 0, false);\n-            if_ok!(self.cat_pattern(subcmt, &**subpat, op));\n+            self.cat_pattern(subcmt, &**subpat, op);\n           }\n \n           ast::PatVec(ref before, ref slice, ref after) => {\n               let elt_cmt = self.cat_index(pat, self.deref_vec(pat, cmt));\n               for before_pat in before.iter() {\n-                  if_ok!(self.cat_pattern(elt_cmt.clone(), &**before_pat,\n-                                          |x,y,z| op(x,y,z)));\n+                  self.cat_pattern(elt_cmt.clone(), &**before_pat,\n+                                   |x,y,z| op(x,y,z));\n               }\n               for slice_pat in slice.iter() {\n-                  let slice_ty = if_ok!(self.pat_ty(&**slice_pat));\n+                  let slice_ty = self.pat_ty(&**slice_pat);\n                   let slice_cmt = self.cat_rvalue_node(pat.id(), pat.span(), slice_ty);\n-                  if_ok!(self.cat_pattern(slice_cmt, &**slice_pat, |x,y,z| op(x,y,z)));\n+                  self.cat_pattern(slice_cmt, &**slice_pat, |x,y,z| op(x,y,z));\n               }\n               for after_pat in after.iter() {\n-                  if_ok!(self.cat_pattern(elt_cmt.clone(), &**after_pat, |x,y,z| op(x,y,z)));\n+                  self.cat_pattern(elt_cmt.clone(), &**after_pat, |x,y,z| op(x,y,z));\n               }\n           }\n \n@@ -1304,8 +1291,6 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n               self.tcx().sess.span_bug(pat.span, \"unexpanded macro\");\n           }\n         }\n-\n-        Ok(())\n     }\n \n     pub fn cmt_to_string(&self, cmt: &cmt_<'tcx>) -> String {"}, {"sha": "5ee6dec7830b299b45f9dea7a31ff4828971df47", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a583ba2fa007b27a92a1be676b271aefcb250128/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a583ba2fa007b27a92a1be676b271aefcb250128/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=a583ba2fa007b27a92a1be676b271aefcb250128", "patch": "@@ -1228,8 +1228,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             .iter()\n                             .map(|freevar| {\n                                 let freevar_def_id = freevar.def.def_id();\n-                                self.typer.node_ty(freevar_def_id.node)\n-                                    .unwrap_or(ty::mk_err()).subst(self.tcx(), substs)\n+                                self.typer.node_ty(freevar_def_id.node).subst(self.tcx(), substs)\n                             })\n                             .collect();\n                         Ok(If(tys))"}, {"sha": "7add505e0eb3dfbf7db7b2dd17a18161cc772bf8", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a583ba2fa007b27a92a1be676b271aefcb250128/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a583ba2fa007b27a92a1be676b271aefcb250128/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=a583ba2fa007b27a92a1be676b271aefcb250128", "patch": "@@ -6165,12 +6165,12 @@ impl<'tcx> mc::Typer<'tcx> for ty::ctxt<'tcx> {\n         self\n     }\n \n-    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<Ty<'tcx>> {\n-        Ok(ty::node_id_to_type(self, id))\n+    fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx> {\n+        ty::node_id_to_type(self, id)\n     }\n \n-    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> mc::McResult<Ty<'tcx>> {\n-        Ok(ty::expr_ty_adjusted(self, expr))\n+    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> Ty<'tcx> {\n+        ty::expr_ty_adjusted(self, expr)\n     }\n \n     fn node_method_ty(&self, method_call: ty::MethodCall) -> Option<Ty<'tcx>> {"}, {"sha": "b57b76d66f719e176d5daa3eb741b6af1198d56b", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a583ba2fa007b27a92a1be676b271aefcb250128/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a583ba2fa007b27a92a1be676b271aefcb250128/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=a583ba2fa007b27a92a1be676b271aefcb250128", "patch": "@@ -516,12 +516,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     }\n \n     pub fn cat_expr(&self, expr: &ast::Expr) -> mc::cmt<'tcx> {\n-        match self.mc().cat_expr(expr) {\n-            Ok(c) => c,\n-            Err(()) => {\n-                self.tcx.sess.span_bug(expr.span, \"error in mem categorization\");\n-            }\n-        }\n+        self.mc().cat_expr(expr)\n     }\n \n     pub fn report(&self, err: BckError<'tcx>) {"}, {"sha": "64ab94487952d7e298f1e9f8b33dec689ff4f428", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a583ba2fa007b27a92a1be676b271aefcb250128/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a583ba2fa007b27a92a1be676b271aefcb250128/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=a583ba2fa007b27a92a1be676b271aefcb250128", "patch": "@@ -463,12 +463,12 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n         self.tcx()\n     }\n \n-    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<Ty<'tcx>> {\n-        Ok(node_id_type(self, id))\n+    fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx> {\n+        node_id_type(self, id)\n     }\n \n-    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> mc::McResult<Ty<'tcx>> {\n-        Ok(expr_ty_adjusted(self, expr))\n+    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> Ty<'tcx> {\n+        expr_ty_adjusted(self, expr)\n     }\n \n     fn node_method_ty(&self, method_call: ty::MethodCall) -> Option<Ty<'tcx>> {"}, {"sha": "b046b39b283bb504fedc1c6e7bfa6d9c22125e10", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a583ba2fa007b27a92a1be676b271aefcb250128/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a583ba2fa007b27a92a1be676b271aefcb250128/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a583ba2fa007b27a92a1be676b271aefcb250128", "patch": "@@ -86,7 +86,7 @@ use check::_match::pat_ctxt;\n use middle::{const_eval, def};\n use middle::infer;\n use middle::lang_items::IteratorItem;\n-use middle::mem_categorization::{mod, McResult};\n+use middle::mem_categorization as mc;\n use middle::pat_util::{mod, pat_id_map};\n use middle::region::CodeExtent;\n use middle::subst::{mod, Subst, Substs, VecPerParamSpace, ParamSpace};\n@@ -282,24 +282,24 @@ pub struct FnCtxt<'a, 'tcx: 'a> {\n     ccx: &'a CrateCtxt<'a, 'tcx>,\n }\n \n-impl<'a, 'tcx> mem_categorization::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> mc::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> {\n         self.ccx.tcx\n     }\n-    fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n+    fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx> {\n         let ty = self.node_ty(id);\n-        Ok(self.infcx().resolve_type_vars_if_possible(ty))\n+        self.infcx().resolve_type_vars_if_possible(&ty)\n     }\n-    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>> {\n+    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> Ty<'tcx> {\n         let ty = self.expr_ty_adjusted(expr);\n-        Ok(self.infcx().resolve_type_vars_if_possible(ty))\n+        self.infcx().resolve_type_vars_if_possible(&ty)\n     }\n     fn node_method_ty(&self, method_call: ty::MethodCall)\n                       -> Option<Ty<'tcx>> {\n         self.inh.method_map.borrow()\n                            .get(&method_call)\n                            .map(|method| method.ty)\n-                           .map(|ty| self.infcx().resolve_type_vars_if_possible(ty))\n+                           .map(|ty| self.infcx().resolve_type_vars_if_possible(&ty))\n     }\n     fn adjustments(&self) -> &RefCell<NodeMap<ty::AutoAdjustment<'tcx>>> {\n         &self.inh.adjustments"}, {"sha": "429eee87026a70be3c253a5934da5ab4e76724ed", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 13, "deletions": 29, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a583ba2fa007b27a92a1be676b271aefcb250128/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a583ba2fa007b27a92a1be676b271aefcb250128/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=a583ba2fa007b27a92a1be676b271aefcb250128", "patch": "@@ -193,19 +193,6 @@ pub fn regionck_ensure_component_tys_wf<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n ///////////////////////////////////////////////////////////////////////////\n // INTERNALS\n \n-// If mem categorization results in an error, it's because the type\n-// check failed (or will fail, when the error is uncovered and\n-// reported during writeback). In this case, we just ignore this part\n-// of the code and don't try to add any more region constraints.\n-macro_rules! ignore_err {\n-    ($inp: expr) => (\n-        match $inp {\n-            Ok(v) => v,\n-            Err(()) => return\n-        }\n-    )\n-}\n-\n // Stores parameters for a potential call to link_region()\n // to perform if an upvar reference is marked unique/mutable after\n // it has already been processed before.\n@@ -1040,7 +1027,7 @@ fn constrain_callee(rcx: &mut Rcx,\n                     // While we're here, link the closure's region with a unique\n                     // immutable borrow (gathered later in borrowck)\n                     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n-                    let expr_cmt = ignore_err!(mc.cat_expr(callee_expr));\n+                    let expr_cmt = mc.cat_expr(callee_expr);\n                     link_region(rcx, callee_expr.span, call_region,\n                                 ty::UniqueImmBorrow, expr_cmt);\n                     r\n@@ -1149,7 +1136,7 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                 };\n                 {\n                     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n-                    let self_cmt = ignore_err!(mc.cat_expr_autoderefd(deref_expr, i));\n+                    let self_cmt = mc.cat_expr_autoderefd(deref_expr, i);\n                     link_region(rcx, deref_expr.span, r,\n                                 ty::BorrowKind::from_mutbl(m), self_cmt);\n                 }\n@@ -1245,7 +1232,7 @@ fn link_addr_of(rcx: &mut Rcx, expr: &ast::Expr,\n \n     let cmt = {\n         let mc = mc::MemCategorizationContext::new(rcx.fcx);\n-        ignore_err!(mc.cat_expr(base))\n+        mc.cat_expr(base)\n     };\n     link_region_from_node_type(rcx, expr.span, expr.id, mutability, cmt);\n }\n@@ -1260,7 +1247,7 @@ fn link_local(rcx: &Rcx, local: &ast::Local) {\n         Some(ref expr) => &**expr,\n     };\n     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n-    let discr_cmt = ignore_err!(mc.cat_expr(init_expr));\n+    let discr_cmt = mc.cat_expr(init_expr);\n     link_pattern(rcx, mc, discr_cmt, &*local.pat);\n }\n \n@@ -1270,7 +1257,7 @@ fn link_local(rcx: &Rcx, local: &ast::Local) {\n fn link_match(rcx: &Rcx, discr: &ast::Expr, arms: &[ast::Arm]) {\n     debug!(\"regionck::for_match()\");\n     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n-    let discr_cmt = ignore_err!(mc.cat_expr(discr));\n+    let discr_cmt = mc.cat_expr(discr);\n     debug!(\"discr_cmt={}\", discr_cmt.repr(rcx.tcx()));\n     for arm in arms.iter() {\n         for root_pat in arm.pats.iter() {\n@@ -1316,14 +1303,11 @@ fn link_pattern<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n \n                 // `[_, ..slice, _]` pattern\n                 ast::PatVec(_, Some(ref slice_pat), _) => {\n-                    match mc.cat_slice_pattern(sub_cmt, &**slice_pat) {\n-                        Ok((slice_cmt, slice_mutbl, slice_r)) => {\n-                            link_region(rcx, sub_pat.span, slice_r,\n-                                        ty::BorrowKind::from_mutbl(slice_mutbl),\n-                                        slice_cmt);\n-                        }\n-                        Err(()) => {}\n-                    }\n+                    let (slice_cmt, slice_mutbl, slice_r) =\n+                        mc.cat_slice_pattern(sub_cmt, &**slice_pat);\n+                    link_region(rcx, sub_pat.span, slice_r,\n+                                ty::BorrowKind::from_mutbl(slice_mutbl),\n+                                slice_cmt);\n                 }\n                 _ => {}\n             }\n@@ -1339,7 +1323,7 @@ fn link_autoref(rcx: &Rcx,\n \n     debug!(\"link_autoref(autoref={})\", autoref);\n     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n-    let expr_cmt = ignore_err!(mc.cat_expr_autoderefd(expr, autoderefs));\n+    let expr_cmt = mc.cat_expr_autoderefd(expr, autoderefs);\n     debug!(\"expr_cmt={}\", expr_cmt.repr(rcx.tcx()));\n \n     match *autoref {\n@@ -1361,7 +1345,7 @@ fn link_by_ref(rcx: &Rcx,\n     debug!(\"link_by_ref(expr={}, callee_scope={})\",\n            expr.repr(tcx), callee_scope);\n     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n-    let expr_cmt = ignore_err!(mc.cat_expr(expr));\n+    let expr_cmt = mc.cat_expr(expr);\n     let borrow_region = ty::ReScope(callee_scope);\n     link_region(rcx, expr.span, borrow_region, ty::ImmBorrow, expr_cmt);\n }\n@@ -1629,7 +1613,7 @@ fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n fn adjust_borrow_kind_for_assignment_lhs(rcx: &Rcx,\n                                          lhs: &ast::Expr) {\n     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n-    let cmt = ignore_err!(mc.cat_expr(lhs));\n+    let cmt = mc.cat_expr(lhs);\n     adjust_upvar_borrow_kind_for_mut(rcx, cmt);\n }\n "}]}