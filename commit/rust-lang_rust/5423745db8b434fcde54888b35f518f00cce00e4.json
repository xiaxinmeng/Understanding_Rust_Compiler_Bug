{"sha": "5423745db8b434fcde54888b35f518f00cce00e4", "node_id": "C_kwDOAAsO6NoAKDU0MjM3NDVkYjhiNDM0ZmNkZTU0ODg4YjM1ZjUxOGYwMGNjZTAwZTQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-01T12:32:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-01T12:32:57Z"}, "message": "Auto merge of #105871 - llogiq:option-as-slice, r=scottmcm\n\nAdd `Option::as_`(`mut_`)`slice`\n\nThis adds the following functions:\n\n* `Option<T>::as_slice(&self) -> &[T]`\n* `Option<T>::as_mut_slice(&mut self) -> &[T]`\n\nThe `as_slice` and `as_mut_slice_mut` functions benefit from an optimization that makes them completely branch-free. ~~Unfortunately, this optimization is not available on by-value Options, therefore the `into_slice` implementations use the plain `match` + `slice::from_ref` approach.~~\n\nNote that the optimization's soundness hinges on the fact that either the niche optimization makes the offset of the `Some(_)` contents zero or the mempory layout of `Option<T>` is equal to that of `Option<MaybeUninit<T>>`.\n\nThe idea has been discussed on [Zulip](https://rust-lang.zulipchat.com/#narrow/stream/219381-t-libs/topic/Option.3A.3Aas_slice). Notably the idea for the `as_slice_mut` and `into_slice\u00b4 methods came from `@cuviper` and `@Sp00ph` hardened the optimization against niche-optimized Options.\n\nThe [rust playground](https://play.rust-lang.org/?version=nightly&mode=release&edition=2021&gist=74f8e4239a19f454c183aaf7b4a969e0) shows that the generated assembly of the optimized method is basically only a copy while the naive method generates code containing a `test dx, dx` on x86_64.\n\n---\n\nEDIT from reviewer: ACP is https://github.com/rust-lang/libs-team/issues/150", "tree": {"sha": "ba3c035908e0393161f335a5fb45f5800c801972", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba3c035908e0393161f335a5fb45f5800c801972"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5423745db8b434fcde54888b35f518f00cce00e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5423745db8b434fcde54888b35f518f00cce00e4", "html_url": "https://github.com/rust-lang/rust/commit/5423745db8b434fcde54888b35f518f00cce00e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5423745db8b434fcde54888b35f518f00cce00e4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64165aac68af780182ff89a6eb3982e3c262266e", "url": "https://api.github.com/repos/rust-lang/rust/commits/64165aac68af780182ff89a6eb3982e3c262266e", "html_url": "https://github.com/rust-lang/rust/commit/64165aac68af780182ff89a6eb3982e3c262266e"}, {"sha": "41da875faef58e618cafc7dfdc5f3985a58f1e98", "url": "https://api.github.com/repos/rust-lang/rust/commits/41da875faef58e618cafc7dfdc5f3985a58f1e98", "html_url": "https://github.com/rust-lang/rust/commit/41da875faef58e618cafc7dfdc5f3985a58f1e98"}], "stats": {"total": 148, "additions": 148, "deletions": 0}, "files": [{"sha": "bcfed726fdfea900a20717b21917733ea46e9364", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5423745db8b434fcde54888b35f518f00cce00e4/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5423745db8b434fcde54888b35f518f00cce00e4/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=5423745db8b434fcde54888b35f518f00cce00e4", "patch": "@@ -136,6 +136,7 @@\n #![feature(const_option)]\n #![feature(const_option_ext)]\n #![feature(const_pin)]\n+#![feature(const_pointer_byte_offsets)]\n #![feature(const_pointer_is_aligned)]\n #![feature(const_ptr_sub_ptr)]\n #![feature(const_replace)]"}, {"sha": "994c08d1fb50d19c1655b70481e742088511f3ca", "filename": "library/core/src/option.rs", "status": "modified", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/5423745db8b434fcde54888b35f518f00cce00e4/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5423745db8b434fcde54888b35f518f00cce00e4/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=5423745db8b434fcde54888b35f518f00cce00e4", "patch": "@@ -553,6 +553,7 @@ use crate::pin::Pin;\n use crate::{\n     cmp, convert, hint, mem,\n     ops::{self, ControlFlow, Deref, DerefMut},\n+    slice,\n };\n \n /// The `Option` type. See [the module level documentation](self) for more.\n@@ -734,6 +735,124 @@ impl<T> Option<T> {\n         }\n     }\n \n+    const fn get_some_offset() -> isize {\n+        if mem::size_of::<Option<T>>() == mem::size_of::<T>() {\n+            // niche optimization means the `T` is always stored at the same position as the Option.\n+            0\n+        } else {\n+            assert!(mem::size_of::<Option<T>>() == mem::size_of::<Option<mem::MaybeUninit<T>>>());\n+            let some_uninit = Some(mem::MaybeUninit::<T>::uninit());\n+            // SAFETY: This gets the byte offset of the `Some(_)` value following the fact that\n+            // niche optimization is not active, and thus Option<T> and Option<MaybeUninit<t>> share\n+            // the same layout.\n+            unsafe {\n+                (some_uninit.as_ref().unwrap() as *const mem::MaybeUninit<T>)\n+                    .byte_offset_from(&some_uninit as *const Option<mem::MaybeUninit<T>>)\n+            }\n+        }\n+    }\n+\n+    /// Returns a slice of the contained value, if any. If this is `None`, an\n+    /// empty slice is returned. This can be useful to have a single type of\n+    /// iterator over an `Option` or slice.\n+    ///\n+    /// Note: Should you have an `Option<&T>` and wish to get a slice of `T`,\n+    /// you can unpack it via `opt.map_or(&[], std::slice::from_ref)`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// #![feature(option_as_slice)]\n+    ///\n+    /// assert_eq!(\n+    ///     [Some(1234).as_slice(), None.as_slice()],\n+    ///     [&[1234][..], &[][..]],\n+    /// );\n+    /// ```\n+    ///\n+    /// The inverse of this function is (discounting\n+    /// borrowing) [`[_]::first`](slice::first):\n+    ///\n+    /// ```rust\n+    /// #![feature(option_as_slice)]\n+    ///\n+    /// for i in [Some(1234_u16), None] {\n+    ///     assert_eq!(i.as_ref(), i.as_slice().first());\n+    /// }\n+    /// ```\n+    #[inline]\n+    #[must_use]\n+    #[unstable(feature = \"option_as_slice\", issue = \"108545\")]\n+    pub fn as_slice(&self) -> &[T] {\n+        // SAFETY: This is sound as long as `get_some_offset` returns the\n+        // correct offset. Though in the `None` case, the slice may be located\n+        // at a pointer pointing into padding, the fact that the slice is\n+        // empty, and the padding is at a properly aligned position for a\n+        // value of that type makes it sound.\n+        unsafe {\n+            slice::from_raw_parts(\n+                (self as *const Option<T>).wrapping_byte_offset(Self::get_some_offset())\n+                    as *const T,\n+                self.is_some() as usize,\n+            )\n+        }\n+    }\n+\n+    /// Returns a mutable slice of the contained value, if any. If this is\n+    /// `None`, an empty slice is returned. This can be useful to have a\n+    /// single type of iterator over an `Option` or slice.\n+    ///\n+    /// Note: Should you have an `Option<&mut T>` instead of a\n+    /// `&mut Option<T>`, which this method takes, you can obtain a mutable\n+    /// slice via `opt.map_or(&mut [], std::slice::from_mut)`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// #![feature(option_as_slice)]\n+    ///\n+    /// assert_eq!(\n+    ///     [Some(1234).as_mut_slice(), None.as_mut_slice()],\n+    ///     [&mut [1234][..], &mut [][..]],\n+    /// );\n+    /// ```\n+    ///\n+    /// The result is a mutable slice of zero or one items that points into\n+    /// our original `Option`:\n+    ///\n+    /// ```rust\n+    /// #![feature(option_as_slice)]\n+    ///\n+    /// let mut x = Some(1234);\n+    /// x.as_mut_slice()[0] += 1;\n+    /// assert_eq!(x, Some(1235));\n+    /// ```\n+    ///\n+    /// The inverse of this method (discounting borrowing)\n+    /// is [`[_]::first_mut`](slice::first_mut):\n+    ///\n+    /// ```rust\n+    /// #![feature(option_as_slice)]\n+    ///\n+    /// assert_eq!(Some(123).as_mut_slice().first_mut(), Some(&mut 123))\n+    /// ```\n+    #[inline]\n+    #[must_use]\n+    #[unstable(feature = \"option_as_slice\", issue = \"108545\")]\n+    pub fn as_mut_slice(&mut self) -> &mut [T] {\n+        // SAFETY: This is sound as long as `get_some_offset` returns the\n+        // correct offset. Though in the `None` case, the slice may be located\n+        // at a pointer pointing into padding, the fact that the slice is\n+        // empty, and the padding is at a properly aligned position for a\n+        // value of that type makes it sound.\n+        unsafe {\n+            slice::from_raw_parts_mut(\n+                (self as *mut Option<T>).wrapping_byte_offset(Self::get_some_offset()) as *mut T,\n+                self.is_some() as usize,\n+            )\n+        }\n+    }\n+\n     /////////////////////////////////////////////////////////////////////////\n     // Getting to contained values\n     /////////////////////////////////////////////////////////////////////////"}, {"sha": "d5077dbf6ccd98adc8e08d742457f6ab51e775c4", "filename": "tests/codegen/option-as-slice.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5423745db8b434fcde54888b35f518f00cce00e4/tests%2Fcodegen%2Foption-as-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5423745db8b434fcde54888b35f518f00cce00e4/tests%2Fcodegen%2Foption-as-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Foption-as-slice.rs?ref=5423745db8b434fcde54888b35f518f00cce00e4", "patch": "@@ -0,0 +1,28 @@\n+// compile-flags: -O\n+// only-x86_64\n+\n+#![crate_type = \"lib\"]\n+#![feature(option_as_slice)]\n+\n+extern crate core;\n+\n+use core::num::NonZeroU64;\n+use core::option::Option;\n+\n+// CHECK-LABEL: @u64_opt_as_slice\n+#[no_mangle]\n+pub fn u64_opt_as_slice(o: &Option<u64>) -> &[u64] {\n+    // CHECK: start:\n+    // CHECK-NOT: select\n+    // CHECK: ret\n+    o.as_slice()\n+}\n+\n+// CHECK-LABEL: @nonzero_u64_opt_as_slice\n+#[no_mangle]\n+pub fn nonzero_u64_opt_as_slice(o: &Option<NonZeroU64>) -> &[NonZeroU64] {\n+    // CHECK: start:\n+    // CHECK-NOT: select\n+    // CHECK: ret\n+    o.as_slice()\n+}"}]}