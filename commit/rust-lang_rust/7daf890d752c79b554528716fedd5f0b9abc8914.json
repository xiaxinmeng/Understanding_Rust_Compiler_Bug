{"sha": "7daf890d752c79b554528716fedd5f0b9abc8914", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkYWY4OTBkNzUyYzc5YjU1NDUyODcxNmZlZGQ1ZjBiOWFiYzg5MTQ=", "commit": {"author": {"name": "newpavlov", "email": "newpavlov@gmail.com", "date": "2019-08-20T16:04:16Z"}, "committer": {"name": "newpavlov", "email": "newpavlov@gmail.com", "date": "2019-08-20T16:04:16Z"}, "message": "Merge branch 'master' into wasi", "tree": {"sha": "4d04c68033ea897a51ea0bab86688baac59179d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d04c68033ea897a51ea0bab86688baac59179d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7daf890d752c79b554528716fedd5f0b9abc8914", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7daf890d752c79b554528716fedd5f0b9abc8914", "html_url": "https://github.com/rust-lang/rust/commit/7daf890d752c79b554528716fedd5f0b9abc8914", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7daf890d752c79b554528716fedd5f0b9abc8914/comments", "author": {"login": "newpavlov", "id": 329626, "node_id": "MDQ6VXNlcjMyOTYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/329626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/newpavlov", "html_url": "https://github.com/newpavlov", "followers_url": "https://api.github.com/users/newpavlov/followers", "following_url": "https://api.github.com/users/newpavlov/following{/other_user}", "gists_url": "https://api.github.com/users/newpavlov/gists{/gist_id}", "starred_url": "https://api.github.com/users/newpavlov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/newpavlov/subscriptions", "organizations_url": "https://api.github.com/users/newpavlov/orgs", "repos_url": "https://api.github.com/users/newpavlov/repos", "events_url": "https://api.github.com/users/newpavlov/events{/privacy}", "received_events_url": "https://api.github.com/users/newpavlov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "newpavlov", "id": 329626, "node_id": "MDQ6VXNlcjMyOTYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/329626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/newpavlov", "html_url": "https://github.com/newpavlov", "followers_url": "https://api.github.com/users/newpavlov/followers", "following_url": "https://api.github.com/users/newpavlov/following{/other_user}", "gists_url": "https://api.github.com/users/newpavlov/gists{/gist_id}", "starred_url": "https://api.github.com/users/newpavlov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/newpavlov/subscriptions", "organizations_url": "https://api.github.com/users/newpavlov/orgs", "repos_url": "https://api.github.com/users/newpavlov/repos", "events_url": "https://api.github.com/users/newpavlov/events{/privacy}", "received_events_url": "https://api.github.com/users/newpavlov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "744442d19a76c4dd39f5fa2a2bbd74638e8569ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/744442d19a76c4dd39f5fa2a2bbd74638e8569ec", "html_url": "https://github.com/rust-lang/rust/commit/744442d19a76c4dd39f5fa2a2bbd74638e8569ec"}, {"sha": "14890954ce17c44d944eda988c5a64bb4c5ec9eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/14890954ce17c44d944eda988c5a64bb4c5ec9eb", "html_url": "https://github.com/rust-lang/rust/commit/14890954ce17c44d944eda988c5a64bb4c5ec9eb"}], "stats": {"total": 6881, "additions": 3827, "deletions": 3054}, "files": [{"sha": "9e7dd54e13532fe96db18df57c494c7d5d71236e", "filename": "Cargo.lock", "status": "modified", "additions": 1895, "deletions": 1896, "changes": 3791, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7daf890d752c79b554528716fedd5f0b9abc8914"}, {"sha": "dfd8e9db3c5c9cacb236c7d1cacc84791649920f", "filename": "src/doc/rustc-ux-guidelines.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Fdoc%2Frustc-ux-guidelines.md", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Fdoc%2Frustc-ux-guidelines.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-ux-guidelines.md?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -70,7 +70,7 @@ for details on how to format and write long error codes.\n   [librustc_privacy](https://github.com/rust-lang/rust/blob/master/src/librustc_privacy/error_codes.rs),\n   [librustc_resolve](https://github.com/rust-lang/rust/blob/master/src/librustc_resolve/error_codes.rs),\n   [librustc_codegen_llvm](https://github.com/rust-lang/rust/blob/master/src/librustc_codegen_llvm/error_codes.rs),\n-  [librustc_plugin](https://github.com/rust-lang/rust/blob/master/src/librustc_plugin/error_codes.rs),\n+  [librustc_plugin_impl](https://github.com/rust-lang/rust/blob/master/src/librustc_plugin/error_codes.rs),\n   [librustc_typeck](https://github.com/rust-lang/rust/blob/master/src/librustc_typeck/error_codes.rs).\n * Explanations have full markdown support. Use it, especially to highlight\n code with backticks."}, {"sha": "8ebacb44d37cc2151f4883020e499d23f9bab0ef", "filename": "src/doc/unstable-book/src/language-features/or-patterns.md", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2For-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2For-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2For-patterns.md?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -0,0 +1,36 @@\n+# `or_patterns`\n+\n+The tracking issue for this feature is: [#54883]\n+\n+[#54883]: https://github.com/rust-lang/rust/issues/54883\n+\n+------------------------\n+\n+The `or_pattern` language feature allows `|` to be arbitrarily nested within\n+a pattern, for example, `Some(A(0) | B(1 | 2))` becomes a valid pattern.\n+\n+## Examples\n+\n+```rust,ignore\n+#![feature(or_patterns)]\n+\n+pub enum Foo {\n+    Bar,\n+    Baz,\n+    Quux,\n+}\n+\n+pub fn example(maybe_foo: Option<Foo>) {\n+    match maybe_foo {\n+        Some(Foo::Bar | Foo::Baz) => {\n+            println!(\"The value contained `Bar` or `Baz`\");\n+        }\n+        Some(_) => {\n+            println!(\"The value did not contain `Bar` or `Baz`\");\n+        }\n+        None => {\n+            println!(\"The value was `None`\");\n+        }\n+    }\n+}\n+```"}, {"sha": "53e8393ec52e462a8a7d1bbcae839dbd91b4d3c1", "filename": "src/doc/unstable-book/src/language-features/plugin.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -18,7 +18,7 @@ extend the compiler's behavior with new syntax extensions, lint checks, etc.\n A plugin is a dynamic library crate with a designated *registrar* function that\n registers extensions with `rustc`. Other crates can load these extensions using\n the crate attribute `#![plugin(...)]`.  See the\n-`rustc_plugin` documentation for more about the\n+`rustc_driver::plugin` documentation for more about the\n mechanics of defining and loading a plugin.\n \n If present, arguments passed as `#![plugin(foo(... args ...))]` are not\n@@ -54,13 +54,13 @@ that implements Roman numeral integer literals.\n extern crate syntax;\n extern crate syntax_pos;\n extern crate rustc;\n-extern crate rustc_plugin;\n+extern crate rustc_driver;\n \n use syntax::parse::token::{self, Token};\n use syntax::tokenstream::TokenTree;\n use syntax::ext::base::{ExtCtxt, MacResult, DummyResult, MacEager};\n use syntax_pos::Span;\n-use rustc_plugin::Registry;\n+use rustc_driver::plugin::Registry;\n \n fn expand_rn(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n         -> Box<dyn MacResult + 'static> {\n@@ -180,11 +180,11 @@ extern crate syntax;\n // Load rustc as a plugin to get macros\n #[macro_use]\n extern crate rustc;\n-extern crate rustc_plugin;\n+extern crate rustc_driver;\n \n use rustc::lint::{EarlyContext, LintContext, LintPass, EarlyLintPass,\n                   EarlyLintPassObject, LintArray};\n-use rustc_plugin::Registry;\n+use rustc_driver::plugin::Registry;\n use syntax::ast;\n \n declare_lint!(TEST_LINT, Warn, \"Warn about items named 'lintme'\");"}, {"sha": "7315963cc8b1dd6db5128d0a7c3ab8d6c04f2a8a", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -1199,6 +1199,31 @@ impl<T> VecDeque<T> {\n         }\n     }\n \n+    /// Removes the last element from the `VecDeque` and returns it, or `None` if\n+    /// it is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut buf = VecDeque::new();\n+    /// assert_eq!(buf.pop_back(), None);\n+    /// buf.push_back(1);\n+    /// buf.push_back(3);\n+    /// assert_eq!(buf.pop_back(), Some(3));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn pop_back(&mut self) -> Option<T> {\n+        if self.is_empty() {\n+            None\n+        } else {\n+            self.head = self.wrap_sub(self.head, 1);\n+            let head = self.head;\n+            unsafe { Some(self.buffer_read(head)) }\n+        }\n+    }\n+\n     /// Prepends an element to the `VecDeque`.\n     ///\n     /// # Examples\n@@ -1243,38 +1268,13 @@ impl<T> VecDeque<T> {\n         unsafe { self.buffer_write(head, value) }\n     }\n \n-    /// Removes the last element from the `VecDeque` and returns it, or `None` if\n-    /// it is empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::VecDeque;\n-    ///\n-    /// let mut buf = VecDeque::new();\n-    /// assert_eq!(buf.pop_back(), None);\n-    /// buf.push_back(1);\n-    /// buf.push_back(3);\n-    /// assert_eq!(buf.pop_back(), Some(3));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn pop_back(&mut self) -> Option<T> {\n-        if self.is_empty() {\n-            None\n-        } else {\n-            self.head = self.wrap_sub(self.head, 1);\n-            let head = self.head;\n-            unsafe { Some(self.buffer_read(head)) }\n-        }\n-    }\n-\n     #[inline]\n     fn is_contiguous(&self) -> bool {\n         self.tail <= self.head\n     }\n \n-    /// Removes an element from anywhere in the `VecDeque` and returns it, replacing it with the\n-    /// last element.\n+    /// Removes an element from anywhere in the `VecDeque` and returns it,\n+    /// replacing it with the first element.\n     ///\n     /// This does not preserve ordering, but is O(1).\n     ///\n@@ -1288,28 +1288,28 @@ impl<T> VecDeque<T> {\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf = VecDeque::new();\n-    /// assert_eq!(buf.swap_remove_back(0), None);\n+    /// assert_eq!(buf.swap_remove_front(0), None);\n     /// buf.push_back(1);\n     /// buf.push_back(2);\n     /// buf.push_back(3);\n     /// assert_eq!(buf, [1, 2, 3]);\n     ///\n-    /// assert_eq!(buf.swap_remove_back(0), Some(1));\n-    /// assert_eq!(buf, [3, 2]);\n+    /// assert_eq!(buf.swap_remove_front(2), Some(3));\n+    /// assert_eq!(buf, [2, 1]);\n     /// ```\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n-    pub fn swap_remove_back(&mut self, index: usize) -> Option<T> {\n+    pub fn swap_remove_front(&mut self, index: usize) -> Option<T> {\n         let length = self.len();\n-        if length > 0 && index < length - 1 {\n-            self.swap(index, length - 1);\n+        if length > 0 && index < length && index != 0 {\n+            self.swap(index, 0);\n         } else if index >= length {\n             return None;\n         }\n-        self.pop_back()\n+        self.pop_front()\n     }\n \n-    /// Removes an element from anywhere in the `VecDeque` and returns it,\n-    /// replacing it with the first element.\n+    /// Removes an element from anywhere in the `VecDeque` and returns it, replacing it with the\n+    /// last element.\n     ///\n     /// This does not preserve ordering, but is O(1).\n     ///\n@@ -1323,24 +1323,24 @@ impl<T> VecDeque<T> {\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf = VecDeque::new();\n-    /// assert_eq!(buf.swap_remove_front(0), None);\n+    /// assert_eq!(buf.swap_remove_back(0), None);\n     /// buf.push_back(1);\n     /// buf.push_back(2);\n     /// buf.push_back(3);\n     /// assert_eq!(buf, [1, 2, 3]);\n     ///\n-    /// assert_eq!(buf.swap_remove_front(2), Some(3));\n-    /// assert_eq!(buf, [2, 1]);\n+    /// assert_eq!(buf.swap_remove_back(0), Some(1));\n+    /// assert_eq!(buf, [3, 2]);\n     /// ```\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n-    pub fn swap_remove_front(&mut self, index: usize) -> Option<T> {\n+    pub fn swap_remove_back(&mut self, index: usize) -> Option<T> {\n         let length = self.len();\n-        if length > 0 && index < length && index != 0 {\n-            self.swap(index, 0);\n+        if length > 0 && index < length - 1 {\n+            self.swap(index, length - 1);\n         } else if index >= length {\n             return None;\n         }\n-        self.pop_front()\n+        self.pop_back()\n     }\n \n     /// Inserts an element at `index` within the `VecDeque`, shifting all elements with indices"}, {"sha": "9ffc1673e5ab8e43954374a2f68a70a935c69baa", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -107,10 +107,6 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// // a, b, and foo are all Arcs that point to the same memory location\n /// ```\n ///\n-/// The [`Arc::clone(&from)`] syntax is the most idiomatic because it conveys more explicitly\n-/// the meaning of the code. In the example above, this syntax makes it easier to see that\n-/// this code is creating a new reference rather than copying the whole content of foo.\n-///\n /// ## `Deref` behavior\n ///\n /// `Arc<T>` automatically dereferences to `T` (via the [`Deref`][deref] trait),"}, {"sha": "5c543165bc2b19da1a271b65aa7331da77300b00", "filename": "src/libproc_macro/bridge/client.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibproc_macro%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibproc_macro%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fclient.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -468,6 +468,14 @@ pub enum ProcMacro {\n }\n \n impl ProcMacro {\n+    pub fn name(&self) -> &'static str {\n+        match self {\n+            ProcMacro::CustomDerive { trait_name, .. } => trait_name,\n+            ProcMacro::Attr { name, .. } => name,\n+            ProcMacro::Bang { name, ..} => name\n+        }\n+    }\n+\n     pub const fn custom_derive(\n         trait_name: &'static str,\n         attributes: &'static [&'static str],"}, {"sha": "0dad2dda837b53f236a86499a3fa97db7af725cb", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -140,6 +140,11 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.add_ast_node(pat.hir_id.local_id, &[pats_exit])\n             }\n \n+            PatKind::Or(ref pats) => {\n+                let branches: Vec<_> = pats.iter().map(|p| self.pat(p, pred)).collect();\n+                self.add_ast_node(pat.hir_id.local_id, &branches)\n+            }\n+\n             PatKind::Slice(ref pre, ref vec, ref post) => {\n                 let pre_exit = self.pats_all(pre.iter(), pred);\n                 let vec_exit = self.pats_all(vec.iter(), pre_exit);"}, {"sha": "c91ad7858d0bb742e6870fded4f8f11dd2a2f850", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -1,5 +1,4 @@\n use crate::ty::{self, TyCtxt};\n-use crate::hir::map::definitions::FIRST_FREE_DEF_INDEX;\n use rustc_data_structures::indexed_vec::Idx;\n use std::fmt;\n use std::u32;\n@@ -102,31 +101,6 @@ newtype_index! {\n     }\n }\n \n-impl DefIndex {\n-    // Proc macros from a proc-macro crate have a kind of virtual DefIndex. This\n-    // function maps the index of the macro within the crate (which is also the\n-    // index of the macro in the CrateMetadata::proc_macros array) to the\n-    // corresponding DefIndex.\n-    pub fn from_proc_macro_index(proc_macro_index: usize) -> DefIndex {\n-        // DefIndex for proc macros start from FIRST_FREE_DEF_INDEX,\n-        // because the first FIRST_FREE_DEF_INDEX indexes are reserved\n-        // for internal use.\n-        let def_index = DefIndex::from(\n-            proc_macro_index.checked_add(FIRST_FREE_DEF_INDEX)\n-                .expect(\"integer overflow adding `proc_macro_index`\"));\n-        assert!(def_index != CRATE_DEF_INDEX);\n-        def_index\n-    }\n-\n-    // This function is the reverse of from_proc_macro_index() above.\n-    pub fn to_proc_macro_index(self: DefIndex) -> usize {\n-        self.index().checked_sub(FIRST_FREE_DEF_INDEX)\n-            .unwrap_or_else(|| {\n-                bug!(\"using local index {:?} as proc-macro index\", self)\n-            })\n-    }\n-}\n-\n impl rustc_serialize::UseSpecializedEncodable for DefIndex {}\n impl rustc_serialize::UseSpecializedDecodable for DefIndex {}\n "}, {"sha": "fa274f831b7950267332d6440b6c8cc86567ce96", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -433,6 +433,7 @@ pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime\n         LifetimeName::Static |\n         LifetimeName::Error |\n         LifetimeName::Implicit |\n+        LifetimeName::ImplicitObjectLifetimeDefault |\n         LifetimeName::Underscore => {}\n     }\n }\n@@ -709,6 +710,7 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n                 visitor.visit_pat(&field.pat)\n             }\n         }\n+        PatKind::Or(ref pats) => walk_list!(visitor, visit_pat, pats),\n         PatKind::Tuple(ref tuple_elements, _) => {\n             walk_list!(visitor, visit_pat, tuple_elements);\n         }"}, {"sha": "7ec321061372782c16a3330fb026d1a71339ca7d", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 75, "deletions": 25, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -72,7 +72,7 @@ use syntax::symbol::{kw, sym, Symbol};\n use syntax::tokenstream::{TokenStream, TokenTree};\n use syntax::parse::token::{self, Token};\n use syntax::visit::{self, Visitor};\n-use syntax_pos::{DUMMY_SP, Span};\n+use syntax_pos::Span;\n \n const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n \n@@ -322,7 +322,7 @@ enum ParenthesizedGenericArgs {\n /// `resolve_lifetime` module. Often we \"fallthrough\" to that code by generating\n /// an \"elided\" or \"underscore\" lifetime name. In the future, we probably want to move\n /// everything into HIR lowering.\n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n enum AnonymousLifetimeMode {\n     /// For **Modern** cases, create a new anonymous region parameter\n     /// and reference that.\n@@ -715,10 +715,16 @@ impl<'a> LoweringContext<'a> {\n         anonymous_lifetime_mode: AnonymousLifetimeMode,\n         op: impl FnOnce(&mut Self) -> R,\n     ) -> R {\n+        debug!(\n+            \"with_anonymous_lifetime_mode(anonymous_lifetime_mode={:?})\",\n+            anonymous_lifetime_mode,\n+        );\n         let old_anonymous_lifetime_mode = self.anonymous_lifetime_mode;\n         self.anonymous_lifetime_mode = anonymous_lifetime_mode;\n         let result = op(self);\n         self.anonymous_lifetime_mode = old_anonymous_lifetime_mode;\n+        debug!(\"with_anonymous_lifetime_mode: restoring anonymous_lifetime_mode={:?}\",\n+               old_anonymous_lifetime_mode);\n         result\n     }\n \n@@ -1033,13 +1039,14 @@ impl<'a> LoweringContext<'a> {\n     /// ```\n     ///\n     /// returns a `hir::TypeBinding` representing `Item`.\n-    fn lower_assoc_ty_constraint(&mut self,\n-                                 c: &AssocTyConstraint,\n-                                 itctx: ImplTraitContext<'_>)\n-                                 -> hir::TypeBinding {\n-        debug!(\"lower_assoc_ty_constraint(constraint={:?}, itctx={:?})\", c, itctx);\n+    fn lower_assoc_ty_constraint(\n+        &mut self,\n+        constraint: &AssocTyConstraint,\n+        itctx: ImplTraitContext<'_>,\n+    ) -> hir::TypeBinding {\n+        debug!(\"lower_assoc_ty_constraint(constraint={:?}, itctx={:?})\", constraint, itctx);\n \n-        let kind = match c.kind {\n+        let kind = match constraint.kind {\n             AssocTyConstraintKind::Equality { ref ty } => hir::TypeBindingKind::Equality {\n                 ty: self.lower_ty(ty, itctx)\n             },\n@@ -1094,15 +1101,15 @@ impl<'a> LoweringContext<'a> {\n                         impl_trait_node_id,\n                         DefPathData::ImplTrait,\n                         ExpnId::root(),\n-                        DUMMY_SP\n+                        constraint.span,\n                     );\n \n                     self.with_dyn_type_scope(false, |this| {\n                         let ty = this.lower_ty(\n                             &Ty {\n                                 id: this.sess.next_node_id(),\n                                 node: TyKind::ImplTrait(impl_trait_node_id, bounds.clone()),\n-                                span: DUMMY_SP,\n+                                span: constraint.span,\n                             },\n                             itctx,\n                         );\n@@ -1124,10 +1131,10 @@ impl<'a> LoweringContext<'a> {\n         };\n \n         hir::TypeBinding {\n-            hir_id: self.lower_node_id(c.id),\n-            ident: c.ident,\n+            hir_id: self.lower_node_id(constraint.id),\n+            ident: constraint.ident,\n             kind,\n-            span: c.span,\n+            span: constraint.span,\n         }\n     }\n \n@@ -1355,6 +1362,13 @@ impl<'a> LoweringContext<'a> {\n         opaque_ty_node_id: NodeId,\n         lower_bounds: impl FnOnce(&mut LoweringContext<'_>) -> hir::GenericBounds,\n     ) -> hir::TyKind {\n+        debug!(\n+            \"lower_opaque_impl_trait(fn_def_id={:?}, opaque_ty_node_id={:?}, span={:?})\",\n+            fn_def_id,\n+            opaque_ty_node_id,\n+            span,\n+        );\n+\n         // Make sure we know that some funky desugaring has been going on here.\n         // This is a first: there is code in other places like for loop\n         // desugaring that explicitly states that we don't want to track that.\n@@ -1382,6 +1396,14 @@ impl<'a> LoweringContext<'a> {\n             &hir_bounds,\n         );\n \n+        debug!(\n+            \"lower_opaque_impl_trait: lifetimes={:#?}\", lifetimes,\n+        );\n+\n+        debug!(\n+            \"lower_opaque_impl_trait: lifetime_defs={:#?}\", lifetime_defs,\n+        );\n+\n         self.with_hir_id_owner(opaque_ty_node_id, |lctx| {\n             let opaque_ty_item = hir::OpaqueTy {\n                 generics: hir::Generics {\n@@ -1397,7 +1419,7 @@ impl<'a> LoweringContext<'a> {\n                 origin: hir::OpaqueTyOrigin::FnReturn,\n             };\n \n-            trace!(\"exist ty from impl trait def-index: {:#?}\", opaque_ty_def_index);\n+            trace!(\"lower_opaque_impl_trait: {:#?}\", opaque_ty_def_index);\n             let opaque_ty_id = lctx.generate_opaque_type(\n                 opaque_ty_node_id,\n                 opaque_ty_item,\n@@ -1445,6 +1467,13 @@ impl<'a> LoweringContext<'a> {\n         parent_index: DefIndex,\n         bounds: &hir::GenericBounds,\n     ) -> (HirVec<hir::GenericArg>, HirVec<hir::GenericParam>) {\n+        debug!(\n+            \"lifetimes_from_impl_trait_bounds(opaque_ty_id={:?}, \\\n+             parent_index={:?}, \\\n+             bounds={:#?})\",\n+            opaque_ty_id, parent_index, bounds,\n+        );\n+\n         // This visitor walks over `impl Trait` bounds and creates defs for all lifetimes that\n         // appear in the bounds, excluding lifetimes that are created within the bounds.\n         // E.g., `'a`, `'b`, but not `'c` in `impl for<'c> SomeTrait<'a, 'b, 'c>`.\n@@ -1532,6 +1561,11 @@ impl<'a> LoweringContext<'a> {\n                         }\n                     }\n                     hir::LifetimeName::Param(_) => lifetime.name,\n+\n+                    // Refers to some other lifetime that is \"in\n+                    // scope\" within the type.\n+                    hir::LifetimeName::ImplicitObjectLifetimeDefault => return,\n+\n                     hir::LifetimeName::Error | hir::LifetimeName::Static => return,\n                 };\n \n@@ -2182,6 +2216,14 @@ impl<'a> LoweringContext<'a> {\n         fn_def_id: DefId,\n         opaque_ty_node_id: NodeId,\n     ) -> hir::FunctionRetTy {\n+        debug!(\n+            \"lower_async_fn_ret_ty(\\\n+             output={:?}, \\\n+             fn_def_id={:?}, \\\n+             opaque_ty_node_id={:?})\",\n+            output, fn_def_id, opaque_ty_node_id,\n+        );\n+\n         let span = output.span();\n \n         let opaque_ty_span = self.mark_span_with_reason(\n@@ -2264,6 +2306,8 @@ impl<'a> LoweringContext<'a> {\n                 ),\n             );\n \n+            debug!(\"lower_async_fn_ret_ty: future_bound={:#?}\", future_bound);\n+\n             // Calculate all the lifetimes that should be captured\n             // by the opaque type. This should include all in-scope\n             // lifetime parameters, including those defined in-band.\n@@ -2512,6 +2556,12 @@ impl<'a> LoweringContext<'a> {\n                     hir::LifetimeName::Implicit\n                         | hir::LifetimeName::Underscore\n                         | hir::LifetimeName::Static => hir::ParamName::Plain(lt.name.ident()),\n+                    hir::LifetimeName::ImplicitObjectLifetimeDefault => {\n+                        span_bug!(\n+                            param.ident.span,\n+                            \"object-lifetime-default should not occur here\",\n+                        );\n+                    }\n                     hir::LifetimeName::Error => ParamName::Error,\n                 };\n \n@@ -2524,15 +2574,6 @@ impl<'a> LoweringContext<'a> {\n                 (param_name, kind)\n             }\n             GenericParamKind::Type { ref default, .. } => {\n-                // Don't expose `Self` (recovered \"keyword used as ident\" parse error).\n-                // `rustc::ty` expects `Self` to be only used for a trait's `Self`.\n-                // Instead, use `gensym(\"Self\")` to create a distinct name that looks the same.\n-                let ident = if param.ident.name == kw::SelfUpper {\n-                    param.ident.gensym()\n-                } else {\n-                    param.ident\n-                };\n-\n                 let add_bounds = add_bounds.get(&param.id).map_or(&[][..], |x| &x);\n                 if !add_bounds.is_empty() {\n                     let params = self.lower_param_bounds(add_bounds, itctx.reborrow()).into_iter();\n@@ -2551,7 +2592,7 @@ impl<'a> LoweringContext<'a> {\n                                           .next(),\n                 };\n \n-                (hir::ParamName::Plain(ident), kind)\n+                (hir::ParamName::Plain(param.ident), kind)\n             }\n             GenericParamKind::Const { ref ty } => {\n                 (hir::ParamName::Plain(param.ident), hir::GenericParamKind::Const {\n@@ -2669,6 +2710,9 @@ impl<'a> LoweringContext<'a> {\n                 let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple struct\");\n                 hir::PatKind::TupleStruct(qpath, pats, ddpos)\n             }\n+            PatKind::Or(ref pats) => {\n+                hir::PatKind::Or(pats.iter().map(|x| self.lower_pat(x)).collect())\n+            }\n             PatKind::Path(ref qself, ref path) => {\n                 let qpath = self.lower_qpath(\n                     p.id,\n@@ -3261,7 +3305,13 @@ impl<'a> LoweringContext<'a> {\n             AnonymousLifetimeMode::PassThrough => {}\n         }\n \n-        self.new_implicit_lifetime(span)\n+        let r = hir::Lifetime {\n+            hir_id: self.next_id(),\n+            span,\n+            name: hir::LifetimeName::ImplicitObjectLifetimeDefault,\n+        };\n+        debug!(\"elided_dyn_bound: r={:?}\", r);\n+        r\n     }\n \n     fn new_implicit_lifetime(&mut self, span: Span) -> hir::Lifetime {"}, {"sha": "6dc3c7038f5696c625ae4601e4eb9a634d0ba40e", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -411,10 +411,6 @@ impl Definitions {\n     }\n \n     /// Adds a root definition (no parent) and a few other reserved definitions.\n-    ///\n-    /// After the initial definitions are created the first `FIRST_FREE_DEF_INDEX` indexes\n-    /// are taken, so the \"user\" indexes will be allocated starting with `FIRST_FREE_DEF_INDEX`\n-    /// in ascending order.\n     pub fn create_root_def(&mut self,\n                            crate_name: &str,\n                            crate_disambiguator: CrateDisambiguator)\n@@ -589,19 +585,6 @@ impl DefPathData {\n     }\n }\n \n-/// Evaluates to the number of tokens passed to it.\n-///\n-/// Logarithmic counting: every one or two recursive expansions, the number of\n-/// tokens to count is divided by two, instead of being reduced by one.\n-/// Therefore, the recursion depth is the binary logarithm of the number of\n-/// tokens to count, and the expanded tree is likewise very small.\n-macro_rules! count {\n-    ()                     => (0usize);\n-    ($one:tt)              => (1usize);\n-    ($($pairs:tt $_p:tt)*) => (count!($($pairs)*) << 1usize);\n-    ($odd:tt $($rest:tt)*) => (count!($($rest)*) | 1usize);\n-}\n-\n // We define the GlobalMetaDataKind enum with this macro because we want to\n // make sure that we exhaustively iterate over all variants when registering\n // the corresponding DefIndices in the DefTable.\n@@ -614,8 +597,6 @@ macro_rules! define_global_metadata_kind {\n             $($variant),*\n         }\n \n-        pub const FIRST_FREE_DEF_INDEX: usize = 1 + count!($($variant)*);\n-\n         impl GlobalMetaDataKind {\n             fn allocate_def_indices(definitions: &mut Definitions) {\n                 $({"}, {"sha": "983048188527fd12f9e34aeaaa9050982ac88cc0", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -221,6 +221,19 @@ pub enum LifetimeName {\n     /// User wrote nothing (e.g., the lifetime in `&u32`).\n     Implicit,\n \n+    /// Implicit lifetime in a context like `dyn Foo`. This is\n+    /// distinguished from implicit lifetimes elsewhere because the\n+    /// lifetime that they default to must appear elsewhere within the\n+    /// enclosing type.  This means that, in an `impl Trait` context, we\n+    /// don't have to create a parameter for them. That is, `impl\n+    /// Trait<Item = &u32>` expands to an opaque type like `type\n+    /// Foo<'a> = impl Trait<Item = &'a u32>`, but `impl Trait<item =\n+    /// dyn Bar>` expands to `type Foo = impl Trait<Item = dyn Bar +\n+    /// 'static>`. The latter uses `ImplicitObjectLifetimeDefault` so\n+    /// that surrounding code knows not to create a lifetime\n+    /// parameter.\n+    ImplicitObjectLifetimeDefault,\n+\n     /// Indicates an error during lowering (usually `'_` in wrong place)\n     /// that was already reported.\n     Error,\n@@ -235,7 +248,9 @@ pub enum LifetimeName {\n impl LifetimeName {\n     pub fn ident(&self) -> Ident {\n         match *self {\n-            LifetimeName::Implicit | LifetimeName::Error => Ident::invalid(),\n+            LifetimeName::ImplicitObjectLifetimeDefault\n+                | LifetimeName::Implicit\n+                | LifetimeName::Error => Ident::invalid(),\n             LifetimeName::Underscore => Ident::with_dummy_span(kw::UnderscoreLifetime),\n             LifetimeName::Static => Ident::with_dummy_span(kw::StaticLifetime),\n             LifetimeName::Param(param_name) => param_name.ident(),\n@@ -244,7 +259,9 @@ impl LifetimeName {\n \n     pub fn is_elided(&self) -> bool {\n         match self {\n-            LifetimeName::Implicit | LifetimeName::Underscore => true,\n+            LifetimeName::ImplicitObjectLifetimeDefault\n+            | LifetimeName::Implicit\n+            | LifetimeName::Underscore => true,\n \n             // It might seem surprising that `Fresh(_)` counts as\n             // *not* elided -- but this is because, as far as the code\n@@ -881,6 +898,7 @@ impl Pat {\n             PatKind::TupleStruct(_, ref s, _) | PatKind::Tuple(ref s, _) => {\n                 s.iter().all(|p| p.walk_(it))\n             }\n+            PatKind::Or(ref pats) => pats.iter().all(|p| p.walk_(it)),\n             PatKind::Box(ref s) | PatKind::Ref(ref s, _) => {\n                 s.walk_(it)\n             }\n@@ -975,6 +993,10 @@ pub enum PatKind {\n     /// `0 <= position <= subpats.len()`\n     TupleStruct(QPath, HirVec<P<Pat>>, Option<usize>),\n \n+    /// An or-pattern `A | B | C`.\n+    /// Invariant: `pats.len() >= 2`.\n+    Or(HirVec<P<Pat>>),\n+\n     /// A path pattern for an unit struct/variant or a (maybe-associated) constant.\n     Path(QPath),\n "}, {"sha": "632a13f9183b2c7c7f3b0feb172497cfd54f6972", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -1687,6 +1687,9 @@ impl<'a> State<'a> {\n                 self.s.space();\n                 self.s.word(\"}\");\n             }\n+            PatKind::Or(ref pats) => {\n+                self.strsep(\"|\", true, Inconsistent, &pats[..], |s, p| s.print_pat(&p));\n+            }\n             PatKind::Tuple(ref elts, ddpos) => {\n                 self.popen();\n                 if let Some(ddpos) = ddpos {"}, {"sha": "84687b8cab5c0b9160103167a97ab4a149c7efe6", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -1329,15 +1329,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     let generics = self.tcx.generics_of(did);\n                     // Account for the case where `did` corresponds to `Self`, which doesn't have\n                     // the expected type argument.\n-                    if !param.is_self() {\n+                    if !(generics.has_self && param.index == 0) {\n                         let type_param = generics.type_param(param, self.tcx);\n                         let hir = &self.tcx.hir();\n                         hir.as_local_hir_id(type_param.def_id).map(|id| {\n                             // Get the `hir::Param` to verify whether it already has any bounds.\n                             // We do this to avoid suggesting code that ends up as `T: 'a'b`,\n                             // instead we suggest `T: 'a + 'b` in that case.\n                             let mut has_bounds = false;\n-                            if let Node::GenericParam(ref param) = hir.get(id) {\n+                            if let Node::GenericParam(param) = hir.get(id) {\n                                 has_bounds = !param.bounds.is_empty();\n                             }\n                             let sp = hir.span(id);"}, {"sha": "c9fd3392a962d2df8e4f22b663576f51ac3348d2", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -127,8 +127,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ) -> InferOk<'tcx, (T, OpaqueTypeMap<'tcx>)> {\n         debug!(\n             \"instantiate_opaque_types(value={:?}, parent_def_id={:?}, body_id={:?}, \\\n-             param_env={:?})\",\n-            value, parent_def_id, body_id, param_env,\n+             param_env={:?}, value_span={:?})\",\n+            value, parent_def_id, body_id, param_env, value_span,\n         );\n         let mut instantiator = Instantiator {\n             infcx: self,\n@@ -1108,9 +1108,11 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n         // Use the same type variable if the exact same opaque type appears more\n         // than once in the return type (e.g., if it's passed to a type alias).\n         if let Some(opaque_defn) = self.opaque_types.get(&def_id) {\n+            debug!(\"instantiate_opaque_types: returning concrete ty {:?}\", opaque_defn.concrete_ty);\n             return opaque_defn.concrete_ty;\n         }\n         let span = tcx.def_span(def_id);\n+        debug!(\"fold_opaque_ty {:?} {:?}\", self.value_span, span);\n         let ty_var = infcx\n             .next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::TypeInference, span });\n "}, {"sha": "73ca981bbe868513cebb0039080d23097c323509", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -1290,6 +1290,12 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                 }\n             }\n \n+            PatKind::Or(ref pats) => {\n+                for pat in pats {\n+                    self.cat_pattern_(cmt.clone(), &pat, op)?;\n+                }\n+            }\n+\n             PatKind::Binding(.., Some(ref subpat)) => {\n                 self.cat_pattern_(cmt, &subpat, op)?;\n             }"}, {"sha": "f5b0af61693be6eba33db255fedb9b9a45f9065c", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 92, "deletions": 1, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -5,6 +5,8 @@\n //! used between functions, and they operate in a purely top-down\n //! way. Therefore, we break lifetime name resolution into a separate pass.\n \n+// ignore-tidy-filelength\n+\n use crate::hir::def::{Res, DefKind};\n use crate::hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use crate::hir::map::Map;\n@@ -556,6 +558,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         debug!(\"visit_ty: id={:?} ty={:?}\", ty.hir_id, ty);\n+        debug!(\"visit_ty: ty.node={:?}\", ty.node);\n         match ty.node {\n             hir::TyKind::BareFn(ref c) => {\n                 let next_early_index = self.next_early_index();\n@@ -585,11 +588,20 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 self.is_in_fn_syntax = was_in_fn_syntax;\n             }\n             hir::TyKind::TraitObject(ref bounds, ref lifetime) => {\n+                debug!(\"visit_ty: TraitObject(bounds={:?}, lifetime={:?})\", bounds, lifetime);\n                 for bound in bounds {\n                     self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n                 }\n                 match lifetime.name {\n                     LifetimeName::Implicit => {\n+                        // For types like `dyn Foo`, we should\n+                        // generate a special form of elided.\n+                        span_bug!(\n+                            ty.span,\n+                            \"object-lifetime-default expected, not implict\",\n+                        );\n+                    }\n+                    LifetimeName::ImplicitObjectLifetimeDefault => {\n                         // If the user does not write *anything*, we\n                         // use the object lifetime defaulting\n                         // rules. So e.g., `Box<dyn Debug>` becomes\n@@ -897,6 +909,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n+        debug!(\"visit_lifetime(lifetime_ref={:?})\", lifetime_ref);\n         if lifetime_ref.is_elided() {\n             self.resolve_elided_lifetimes(vec![lifetime_ref]);\n             return;\n@@ -1911,6 +1924,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_segment_args(&mut self, res: Res, depth: usize, generic_args: &'tcx hir::GenericArgs) {\n+        debug!(\n+            \"visit_segment_args(res={:?}, depth={:?}, generic_args={:?})\",\n+            res,\n+            depth,\n+            generic_args,\n+        );\n+\n         if generic_args.parenthesized {\n             let was_in_fn_syntax = self.is_in_fn_syntax;\n             self.is_in_fn_syntax = true;\n@@ -1964,6 +1984,23 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             _ => None,\n         };\n \n+        debug!(\"visit_segment_args: type_def_id={:?}\", type_def_id);\n+\n+        // Compute a vector of defaults, one for each type parameter,\n+        // per the rules given in RFCs 599 and 1156. Example:\n+        //\n+        // ```rust\n+        // struct Foo<'a, T: 'a, U> { }\n+        // ```\n+        //\n+        // If you have `Foo<'x, dyn Bar, dyn Baz>`, we want to default\n+        // `dyn Bar` to `dyn Bar + 'x` (because of the `T: 'a` bound)\n+        // and `dyn Baz` to `dyn Baz + 'static` (because there is no\n+        // such bound).\n+        //\n+        // Therefore, we would compute `object_lifetime_defaults` to a\n+        // vector like `['x, 'static]`. Note that the vector only\n+        // includes type parameters.\n         let object_lifetime_defaults = type_def_id.map_or(vec![], |def_id| {\n             let in_body = {\n                 let mut scope = self.scope;\n@@ -2003,6 +2040,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             .collect()\n                     })\n             };\n+            debug!(\"visit_segment_args: unsubst={:?}\", unsubst);\n             unsubst\n                 .iter()\n                 .map(|set| match *set {\n@@ -2023,6 +2061,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 .collect()\n         });\n \n+        debug!(\"visit_segment_args: object_lifetime_defaults={:?}\", object_lifetime_defaults);\n+\n         let mut i = 0;\n         for arg in &generic_args.args {\n             match arg {\n@@ -2045,8 +2085,49 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n         }\n \n+        // Hack: when resolving the type `XX` in binding like `dyn\n+        // Foo<'b, Item = XX>`, the current object-lifetime default\n+        // would be to examine the trait `Foo` to check whether it has\n+        // a lifetime bound declared on `Item`. e.g., if `Foo` is\n+        // declared like so, then the default object lifetime bound in\n+        // `XX` should be `'b`:\n+        //\n+        // ```rust\n+        // trait Foo<'a> {\n+        //   type Item: 'a;\n+        // }\n+        // ```\n+        //\n+        // but if we just have `type Item;`, then it would be\n+        // `'static`. However, we don't get all of this logic correct.\n+        //\n+        // Instead, we do something hacky: if there are no lifetime parameters\n+        // to the trait, then we simply use a default object lifetime\n+        // bound of `'static`, because there is no other possibility. On the other hand,\n+        // if there ARE lifetime parameters, then we require the user to give an\n+        // explicit bound for now.\n+        //\n+        // This is intended to leave room for us to implement the\n+        // correct behavior in the future.\n+        let has_lifetime_parameter = generic_args\n+            .args\n+            .iter()\n+            .any(|arg| match arg {\n+                GenericArg::Lifetime(_) => true,\n+                _ => false,\n+            });\n+\n+        // Resolve lifetimes found in the type `XX` from `Item = XX` bindings.\n         for b in &generic_args.bindings {\n-            self.visit_assoc_type_binding(b);\n+            let scope = Scope::ObjectLifetimeDefault {\n+                lifetime: if has_lifetime_parameter {\n+                    None\n+                } else {\n+                    Some(Region::Static)\n+                },\n+                s: self.scope,\n+            };\n+            self.with(scope, |_, this| this.visit_assoc_type_binding(b));\n         }\n     }\n \n@@ -2347,6 +2428,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     }\n \n     fn resolve_elided_lifetimes(&mut self, lifetime_refs: Vec<&'tcx hir::Lifetime>) {\n+        debug!(\"resolve_elided_lifetimes(lifetime_refs={:?})\", lifetime_refs);\n+\n         if lifetime_refs.is_empty() {\n             return;\n         }\n@@ -2539,6 +2622,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     }\n \n     fn resolve_object_lifetime_default(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n+        debug!(\"resolve_object_lifetime_default(lifetime_ref={:?})\", lifetime_ref);\n         let mut late_depth = 0;\n         let mut scope = self.scope;\n         let lifetime = loop {\n@@ -2638,6 +2722,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         hir::LifetimeName::Param(_) | hir::LifetimeName::Implicit => {\n                             self.resolve_lifetime_ref(lt);\n                         }\n+                        hir::LifetimeName::ImplicitObjectLifetimeDefault => {\n+                            self.tcx.sess.delay_span_bug(\n+                                lt.span,\n+                                \"lowering generated `ImplicitObjectLifetimeDefault` \\\n+                                 outside of an object type\",\n+                            )\n+                        }\n                         hir::LifetimeName::Error => {\n                             // No need to do anything, error already reported.\n                         }"}, {"sha": "3da5a65c37932d154d755115770bce84db91a32a", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -530,7 +530,7 @@ impl<'tcx, Tag> ScalarMaybeUndef<Tag> {\n     pub fn not_undef(self) -> InterpResult<'static, Scalar<Tag>> {\n         match self {\n             ScalarMaybeUndef::Scalar(scalar) => Ok(scalar),\n-            ScalarMaybeUndef::Undef => throw_unsup!(ReadUndefBytes(Size::from_bytes(0))),\n+            ScalarMaybeUndef::Undef => throw_unsup!(ReadUndefBytes(Size::ZERO)),\n         }\n     }\n "}, {"sha": "c1de4939c1d9154a567b4ea8c12342968f8d28b8", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -248,10 +248,10 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n     /// This is always inlined, despite its size, because it has a single\n     /// callsite and it is called *very* frequently.\n     #[inline(always)]\n-    fn process_obligation(&mut self,\n-                          pending_obligation: &mut Self::Obligation)\n-                          -> ProcessResult<Self::Obligation, Self::Error>\n-    {\n+    fn process_obligation(\n+        &mut self,\n+        pending_obligation: &mut Self::Obligation,\n+    ) -> ProcessResult<Self::Obligation, Self::Error> {\n         // if we were stalled on some unresolved variables, first check\n         // whether any of them have been resolved; if not, don't bother\n         // doing more work yet\n@@ -277,7 +277,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 self.selcx.infcx().resolve_vars_if_possible(&obligation.predicate);\n         }\n \n-        debug!(\"process_obligation: obligation = {:?}\", obligation);\n+        debug!(\"process_obligation: obligation = {:?} cause = {:?}\", obligation, obligation.cause);\n \n         match obligation.predicate {\n             ty::Predicate::Trait(ref data) => {\n@@ -425,10 +425,13 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n             }\n \n             ty::Predicate::WellFormed(ty) => {\n-                match ty::wf::obligations(self.selcx.infcx(),\n-                                          obligation.param_env,\n-                                          obligation.cause.body_id,\n-                                          ty, obligation.cause.span) {\n+                match ty::wf::obligations(\n+                    self.selcx.infcx(),\n+                    obligation.param_env,\n+                    obligation.cause.body_id,\n+                    ty,\n+                    obligation.cause.span,\n+                ) {\n                     None => {\n                         pending_obligation.stalled_on = vec![ty];\n                         ProcessResult::Unchanged"}, {"sha": "7ea7bf0257cf7d56344833ef458d638c51dbeea7", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 57, "deletions": 52, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -91,6 +91,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn astconv_object_safety_violations(self, trait_def_id: DefId)\n                                             -> Vec<ObjectSafetyViolation>\n     {\n+        debug_assert!(self.generics_of(trait_def_id).has_self);\n         let violations = traits::supertrait_def_ids(self, trait_def_id)\n             .filter(|&def_id| self.predicates_reference_self(def_id, true))\n             .map(|_| ObjectSafetyViolation::SupertraitSelf)\n@@ -106,16 +107,33 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn object_safety_violations(self, trait_def_id: DefId)\n                                     -> Vec<ObjectSafetyViolation>\n     {\n+        debug_assert!(self.generics_of(trait_def_id).has_self);\n         debug!(\"object_safety_violations: {:?}\", trait_def_id);\n \n         traits::supertrait_def_ids(self, trait_def_id)\n             .flat_map(|def_id| self.object_safety_violations_for_trait(def_id))\n             .collect()\n     }\n \n-    fn object_safety_violations_for_trait(self, trait_def_id: DefId)\n-                                          -> Vec<ObjectSafetyViolation>\n-    {\n+    /// We say a method is *vtable safe* if it can be invoked on a trait\n+    /// object.  Note that object-safe traits can have some\n+    /// non-vtable-safe methods, so long as they require `Self:Sized` or\n+    /// otherwise ensure that they cannot be used when `Self=Trait`.\n+    pub fn is_vtable_safe_method(self, trait_def_id: DefId, method: &ty::AssocItem) -> bool {\n+        debug_assert!(self.generics_of(trait_def_id).has_self);\n+        debug!(\"is_vtable_safe_method({:?}, {:?})\", trait_def_id, method);\n+        // Any method that has a `Self : Sized` requisite can't be called.\n+        if self.generics_require_sized_self(method.def_id) {\n+            return false;\n+        }\n+\n+        match self.virtual_call_violation_for_method(trait_def_id, method) {\n+            None | Some(MethodViolationCode::WhereClauseReferencesSelf(_)) => true,\n+            Some(_) => false,\n+        }\n+    }\n+\n+    fn object_safety_violations_for_trait(self, trait_def_id: DefId) -> Vec<ObjectSafetyViolation> {\n         // Check methods for violations.\n         let mut violations: Vec<_> = self.associated_items(trait_def_id)\n             .filter(|item| item.kind == ty::AssocKind::Method)\n@@ -163,14 +181,16 @@ impl<'tcx> TyCtxt<'tcx> {\n     fn predicates_reference_self(\n         self,\n         trait_def_id: DefId,\n-        supertraits_only: bool) -> bool\n-    {\n+        supertraits_only: bool,\n+    ) -> bool {\n         let trait_ref = ty::Binder::dummy(ty::TraitRef::identity(self, trait_def_id));\n         let predicates = if supertraits_only {\n             self.super_predicates_of(trait_def_id)\n         } else {\n             self.predicates_of(trait_def_id)\n         };\n+        let self_ty = self.types.self_param;\n+        let has_self_ty = |t: Ty<'tcx>| t.walk().any(|t| t == self_ty);\n         predicates\n             .predicates\n             .iter()\n@@ -179,7 +199,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 match predicate {\n                     ty::Predicate::Trait(ref data) => {\n                         // In the case of a trait predicate, we can skip the \"self\" type.\n-                        data.skip_binder().input_types().skip(1).any(|t| t.has_self_ty())\n+                        data.skip_binder().input_types().skip(1).any(has_self_ty)\n                     }\n                     ty::Predicate::Projection(ref data) => {\n                         // And similarly for projections. This should be redundant with\n@@ -199,7 +219,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                             .trait_ref(self)\n                             .input_types()\n                             .skip(1)\n-                            .any(|t| t.has_self_ty())\n+                            .any(has_self_ty)\n                     }\n                     ty::Predicate::WellFormed(..) |\n                     ty::Predicate::ObjectSafe(..) |\n@@ -229,11 +249,11 @@ impl<'tcx> TyCtxt<'tcx> {\n         let predicates = predicates.instantiate_identity(self).predicates;\n         elaborate_predicates(self, predicates)\n             .any(|predicate| match predicate {\n-                ty::Predicate::Trait(ref trait_pred) if trait_pred.def_id() == sized_def_id => {\n-                    trait_pred.skip_binder().self_ty().is_self()\n+                ty::Predicate::Trait(ref trait_pred) => {\n+                    trait_pred.def_id() == sized_def_id\n+                        && trait_pred.skip_binder().self_ty().is_param(0)\n                 }\n                 ty::Predicate::Projection(..) |\n-                ty::Predicate::Trait(..) |\n                 ty::Predicate::Subtype(..) |\n                 ty::Predicate::RegionOutlives(..) |\n                 ty::Predicate::WellFormed(..) |\n@@ -248,11 +268,11 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Returns `Some(_)` if this method makes the containing trait not object safe.\n-    fn object_safety_violation_for_method(self,\n-                                          trait_def_id: DefId,\n-                                          method: &ty::AssocItem)\n-                                          -> Option<MethodViolationCode>\n-    {\n+    fn object_safety_violation_for_method(\n+        self,\n+        trait_def_id: DefId,\n+        method: &ty::AssocItem,\n+    ) -> Option<MethodViolationCode> {\n         debug!(\"object_safety_violation_for_method({:?}, {:?})\", trait_def_id, method);\n         // Any method that has a `Self : Sized` requisite is otherwise\n         // exempt from the regulations.\n@@ -263,36 +283,15 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.virtual_call_violation_for_method(trait_def_id, method)\n     }\n \n-    /// We say a method is *vtable safe* if it can be invoked on a trait\n-    /// object.  Note that object-safe traits can have some\n-    /// non-vtable-safe methods, so long as they require `Self:Sized` or\n-    /// otherwise ensure that they cannot be used when `Self=Trait`.\n-    pub fn is_vtable_safe_method(self,\n-                                 trait_def_id: DefId,\n-                                 method: &ty::AssocItem)\n-                                 -> bool\n-    {\n-        debug!(\"is_vtable_safe_method({:?}, {:?})\", trait_def_id, method);\n-        // Any method that has a `Self : Sized` requisite can't be called.\n-        if self.generics_require_sized_self(method.def_id) {\n-            return false;\n-        }\n-\n-        match self.virtual_call_violation_for_method(trait_def_id, method) {\n-            None | Some(MethodViolationCode::WhereClauseReferencesSelf(_)) => true,\n-            Some(_) => false,\n-        }\n-    }\n-\n     /// Returns `Some(_)` if this method cannot be called on a trait\n     /// object; this does not necessarily imply that the enclosing trait\n     /// is not object safe, because the method might have a where clause\n     /// `Self:Sized`.\n-    fn virtual_call_violation_for_method(self,\n-                                         trait_def_id: DefId,\n-                                         method: &ty::AssocItem)\n-                                         -> Option<MethodViolationCode>\n-    {\n+    fn virtual_call_violation_for_method(\n+        self,\n+        trait_def_id: DefId,\n+        method: &ty::AssocItem,\n+    ) -> Option<MethodViolationCode> {\n         // The method's first parameter must be named `self`\n         if !method.method_has_self_argument {\n             return Some(MethodViolationCode::StaticMethod);\n@@ -323,7 +322,9 @@ impl<'tcx> TyCtxt<'tcx> {\n                 .collect::<Vec<_>>()\n                 // Do a shallow visit so that `contains_illegal_self_type_reference`\n                 // may apply it's custom visiting.\n-                .visit_tys_shallow(|t| self.contains_illegal_self_type_reference(trait_def_id, t)) {\n+                .visit_tys_shallow(|t| {\n+                    self.contains_illegal_self_type_reference(trait_def_id, t)\n+                }) {\n             let span = self.def_span(method.def_id);\n             return Some(MethodViolationCode::WhereClauseReferencesSelf(span));\n         }\n@@ -337,7 +338,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         // However, this is already considered object-safe. We allow it as a special case here.\n         // FIXME(mikeyhew) get rid of this `if` statement once `receiver_is_dispatchable` allows\n         // `Receiver: Unsize<Receiver[Self => dyn Trait]>`\n-        if receiver_ty != self.mk_self_type() {\n+        if receiver_ty != self.types.self_param {\n             if !self.receiver_is_dispatchable(method, receiver_ty) {\n                 return Some(MethodViolationCode::UndispatchableReceiver);\n             } else {\n@@ -404,7 +405,10 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Performs a type substitution to produce the version of receiver_ty when `Self = self_ty`\n     /// e.g., for receiver_ty = `Rc<Self>` and self_ty = `Foo`, returns `Rc<Foo>`.\n     fn receiver_for_self_ty(\n-        self, receiver_ty: Ty<'tcx>, self_ty: Ty<'tcx>, method_def_id: DefId\n+        self,\n+        receiver_ty: Ty<'tcx>,\n+        self_ty: Ty<'tcx>,\n+        method_def_id: DefId,\n     ) -> Ty<'tcx> {\n         debug!(\"receiver_for_self_ty({:?}, {:?}, {:?})\", receiver_ty, self_ty, method_def_id);\n         let substs = InternalSubsts::for_item(self, method_def_id, |param, _| {\n@@ -555,7 +559,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             // Self: Unsize<U>\n             let unsize_predicate = ty::TraitRef {\n                 def_id: unsize_did,\n-                substs: self.mk_substs_trait(self.mk_self_type(), &[unsized_self_ty.into()]),\n+                substs: self.mk_substs_trait(self.types.self_param, &[unsized_self_ty.into()]),\n             }.to_predicate();\n \n             // U: Trait<Arg1, ..., ArgN>\n@@ -608,11 +612,11 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n-    fn contains_illegal_self_type_reference(self,\n-                                            trait_def_id: DefId,\n-                                            ty: Ty<'tcx>)\n-                                            -> bool\n-    {\n+    fn contains_illegal_self_type_reference(\n+        self,\n+        trait_def_id: DefId,\n+        ty: Ty<'tcx>,\n+     ) -> bool {\n         // This is somewhat subtle. In general, we want to forbid\n         // references to `Self` in the argument and return types,\n         // since the value of `Self` is erased. However, there is one\n@@ -654,10 +658,11 @@ impl<'tcx> TyCtxt<'tcx> {\n \n         let mut supertraits: Option<Vec<ty::PolyTraitRef<'tcx>>> = None;\n         let mut error = false;\n+        let self_ty = self.types.self_param;\n         ty.maybe_walk(|ty| {\n             match ty.sty {\n-                ty::Param(ref param_ty) => {\n-                    if param_ty.is_self() {\n+                ty::Param(_) => {\n+                    if ty == self_ty {\n                         error = true;\n                     }\n "}, {"sha": "e72efdb057ab10f08d3d1a59ea229c28880750d8", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -173,6 +173,7 @@ pub struct CommonTypes<'tcx> {\n     pub f32: Ty<'tcx>,\n     pub f64: Ty<'tcx>,\n     pub never: Ty<'tcx>,\n+    pub self_param: Ty<'tcx>,\n     pub err: Ty<'tcx>,\n \n     /// Dummy type used for the `Self` of a `TraitRef` created for converting\n@@ -915,6 +916,10 @@ impl<'tcx> CommonTypes<'tcx> {\n             u128: mk(Uint(ast::UintTy::U128)),\n             f32: mk(Float(ast::FloatTy::F32)),\n             f64: mk(Float(ast::FloatTy::F64)),\n+            self_param: mk(ty::Param(ty::ParamTy {\n+                index: 0,\n+                name: kw::SelfUpper.as_interned_str(),\n+            })),\n \n             trait_object_dummy_self: mk(Infer(ty::FreshTy(0))),\n         }\n@@ -2566,10 +2571,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n-    #[inline]\n-    pub fn mk_self_type(self) -> Ty<'tcx> {\n-        self.mk_ty_param(0, kw::SelfUpper.as_interned_str())\n-    }\n \n     pub fn mk_param_from_def(self, param: &ty::GenericParamDef) -> Kind<'tcx> {\n         match param.kind {"}, {"sha": "d6d17a67e01e95ef54529bfdd4eddd790321a612", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -239,13 +239,7 @@ impl<'tcx> ty::TyS<'tcx> {\n             ty::Infer(ty::FreshFloatTy(_)) => \"fresh floating-point type\".into(),\n             ty::Projection(_) => \"associated type\".into(),\n             ty::UnnormalizedProjection(_) => \"non-normalized associated type\".into(),\n-            ty::Param(ref p) => {\n-                if p.is_self() {\n-                    \"Self\".into()\n-                } else {\n-                    \"type parameter\".into()\n-                }\n-            }\n+            ty::Param(_) => \"type parameter\".into(),\n             ty::Opaque(..) => \"opaque type\".into(),\n             ty::Error => \"type error\".into(),\n         }"}, {"sha": "b2d74f963b0b3db24c494d7505ce3b773ae5edd3", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -1,5 +1,5 @@\n use crate::ty::subst::{SubstsRef, UnpackedKind};\n-use crate::ty::{self, Ty, TypeFlags, TypeFoldable, InferConst};\n+use crate::ty::{self, Ty, TypeFlags, InferConst};\n use crate::mir::interpret::ConstValue;\n \n #[derive(Debug)]\n@@ -86,13 +86,9 @@ impl FlagComputation {\n                 self.add_flags(TypeFlags::HAS_TY_ERR)\n             }\n \n-            &ty::Param(ref p) => {\n+            &ty::Param(_) => {\n                 self.add_flags(TypeFlags::HAS_FREE_LOCAL_NAMES);\n-                if p.is_self() {\n-                    self.add_flags(TypeFlags::HAS_SELF);\n-                } else {\n-                    self.add_flags(TypeFlags::HAS_PARAMS);\n-                }\n+                self.add_flags(TypeFlags::HAS_PARAMS);\n             }\n \n             &ty::Generator(_, ref substs, _) => {\n@@ -143,11 +139,6 @@ impl FlagComputation {\n             }\n \n             &ty::Projection(ref data) => {\n-                // currently we can't normalize projections that\n-                // include bound regions, so track those separately.\n-                if !data.has_escaping_bound_vars() {\n-                    self.add_flags(TypeFlags::HAS_NORMALIZABLE_PROJECTION);\n-                }\n                 self.add_flags(TypeFlags::HAS_PROJECTION);\n                 self.add_projection_ty(data);\n             }\n@@ -243,7 +234,7 @@ impl FlagComputation {\n         match c.val {\n             ConstValue::Unevaluated(_, substs) => {\n                 self.add_substs(substs);\n-                self.add_flags(TypeFlags::HAS_NORMALIZABLE_PROJECTION | TypeFlags::HAS_PROJECTION);\n+                self.add_flags(TypeFlags::HAS_PROJECTION);\n             },\n             ConstValue::Infer(infer) => {\n                 self.add_flags(TypeFlags::HAS_FREE_LOCAL_NAMES | TypeFlags::HAS_CT_INFER);"}, {"sha": "4b30412b41954e98355d645fa988dfd3dbaacac2", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -85,9 +85,6 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     fn has_param_types(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_PARAMS)\n     }\n-    fn has_self_ty(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_SELF)\n-    }\n     fn has_infer_types(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_TY_INFER)\n     }"}, {"sha": "c71e1ea4e585989d763de4195328aab4fadc272a", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -298,8 +298,9 @@ impl<'tcx> Instance<'tcx> {\n     ) -> Option<Instance<'tcx>> {\n         debug!(\"resolve(def_id={:?}, substs={:?})\", def_id, substs);\n         let fn_sig = tcx.fn_sig(def_id);\n-        let is_vtable_shim =\n-            fn_sig.inputs().skip_binder().len() > 0 && fn_sig.input(0).skip_binder().is_self();\n+        let is_vtable_shim = fn_sig.inputs().skip_binder().len() > 0\n+            && fn_sig.input(0).skip_binder().is_param(0)\n+            && tcx.generics_of(def_id).has_self;\n         if is_vtable_shim {\n             debug!(\" => associated item with unsizeable self: Self\");\n             Some(Instance {"}, {"sha": "8febcfd0754c9e2fefef2474da0b0c3a412c89c3", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -1601,7 +1601,6 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         // resulting from the final codegen session.\n         if\n             layout.ty.has_param_types() ||\n-            layout.ty.has_self_ty() ||\n             !self.param_env.caller_bounds.is_empty()\n         {\n             return;\n@@ -1767,7 +1766,7 @@ impl<'tcx> SizeSkeleton<'tcx> {\n                 let tail = tcx.struct_tail_erasing_lifetimes(pointee, param_env);\n                 match tail.sty {\n                     ty::Param(_) | ty::Projection(_) => {\n-                        debug_assert!(tail.has_param_types() || tail.has_self_ty());\n+                        debug_assert!(tail.has_param_types());\n                         Ok(SizeSkeleton::Pointer {\n                             non_zero,\n                             tail: tcx.erase_regions(&tail)"}, {"sha": "0b81f193df4098c737b51c3ff8c6a5c986662f6d", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 15, "deletions": 23, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -414,61 +414,53 @@ pub struct CReaderCacheKey {\n bitflags! {\n     pub struct TypeFlags: u32 {\n         const HAS_PARAMS         = 1 << 0;\n-        const HAS_SELF           = 1 << 1;\n-        const HAS_TY_INFER       = 1 << 2;\n-        const HAS_RE_INFER       = 1 << 3;\n-        const HAS_RE_PLACEHOLDER = 1 << 4;\n+        const HAS_TY_INFER       = 1 << 1;\n+        const HAS_RE_INFER       = 1 << 2;\n+        const HAS_RE_PLACEHOLDER = 1 << 3;\n \n         /// Does this have any `ReEarlyBound` regions? Used to\n         /// determine whether substitition is required, since those\n         /// represent regions that are bound in a `ty::Generics` and\n         /// hence may be substituted.\n-        const HAS_RE_EARLY_BOUND = 1 << 5;\n+        const HAS_RE_EARLY_BOUND = 1 << 4;\n \n         /// Does this have any region that \"appears free\" in the type?\n         /// Basically anything but `ReLateBound` and `ReErased`.\n-        const HAS_FREE_REGIONS   = 1 << 6;\n+        const HAS_FREE_REGIONS   = 1 << 5;\n \n         /// Is an error type reachable?\n-        const HAS_TY_ERR         = 1 << 7;\n-        const HAS_PROJECTION     = 1 << 8;\n+        const HAS_TY_ERR         = 1 << 6;\n+        const HAS_PROJECTION     = 1 << 7;\n \n         // FIXME: Rename this to the actual property since it's used for generators too\n-        const HAS_TY_CLOSURE     = 1 << 9;\n+        const HAS_TY_CLOSURE     = 1 << 8;\n \n         /// `true` if there are \"names\" of types and regions and so forth\n         /// that are local to a particular fn\n-        const HAS_FREE_LOCAL_NAMES    = 1 << 10;\n+        const HAS_FREE_LOCAL_NAMES    = 1 << 9;\n \n         /// Present if the type belongs in a local type context.\n         /// Only set for Infer other than Fresh.\n-        const KEEP_IN_LOCAL_TCX  = 1 << 11;\n-\n-        // Is there a projection that does not involve a bound region?\n-        // Currently we can't normalize projections w/ bound regions.\n-        const HAS_NORMALIZABLE_PROJECTION = 1 << 12;\n+        const KEEP_IN_LOCAL_TCX  = 1 << 10;\n \n         /// Does this have any `ReLateBound` regions? Used to check\n         /// if a global bound is safe to evaluate.\n-        const HAS_RE_LATE_BOUND = 1 << 13;\n+        const HAS_RE_LATE_BOUND = 1 << 11;\n \n-        const HAS_TY_PLACEHOLDER = 1 << 14;\n+        const HAS_TY_PLACEHOLDER = 1 << 12;\n \n-        const HAS_CT_INFER = 1 << 15;\n-        const HAS_CT_PLACEHOLDER = 1 << 16;\n+        const HAS_CT_INFER = 1 << 13;\n+        const HAS_CT_PLACEHOLDER = 1 << 14;\n \n         const NEEDS_SUBST        = TypeFlags::HAS_PARAMS.bits |\n-                                   TypeFlags::HAS_SELF.bits |\n                                    TypeFlags::HAS_RE_EARLY_BOUND.bits;\n \n         /// Flags representing the nominal content of a type,\n         /// computed by FlagsComputation. If you add a new nominal\n         /// flag, it should be added here too.\n         const NOMINAL_FLAGS     = TypeFlags::HAS_PARAMS.bits |\n-                                  TypeFlags::HAS_SELF.bits |\n                                   TypeFlags::HAS_TY_INFER.bits |\n                                   TypeFlags::HAS_RE_INFER.bits |\n-                                  TypeFlags::HAS_CT_INFER.bits |\n                                   TypeFlags::HAS_RE_PLACEHOLDER.bits |\n                                   TypeFlags::HAS_RE_EARLY_BOUND.bits |\n                                   TypeFlags::HAS_FREE_REGIONS.bits |\n@@ -479,6 +471,7 @@ bitflags! {\n                                   TypeFlags::KEEP_IN_LOCAL_TCX.bits |\n                                   TypeFlags::HAS_RE_LATE_BOUND.bits |\n                                   TypeFlags::HAS_TY_PLACEHOLDER.bits |\n+                                  TypeFlags::HAS_CT_INFER.bits |\n                                   TypeFlags::HAS_CT_PLACEHOLDER.bits;\n     }\n }\n@@ -1734,7 +1727,6 @@ impl<'tcx> ParamEnv<'tcx> {\n                 if value.has_placeholders()\n                     || value.needs_infer()\n                     || value.has_param_types()\n-                    || value.has_self_ty()\n                 {\n                     ParamEnvAnd {\n                         param_env: self,"}, {"sha": "2b173068b38e4a610e32c546d502a9c6d3c0a5ad", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -1141,13 +1141,6 @@ impl<'tcx> ParamTy {\n     pub fn to_ty(self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         tcx.mk_ty_param(self.index, self.name)\n     }\n-\n-    pub fn is_self(&self) -> bool {\n-        // FIXME(#50125): Ignoring `Self` with `index != 0` might lead to weird behavior elsewhere,\n-        // but this should only be possible when using `-Z continue-parse-after-error` like\n-        // `compile-fail/issue-36638.rs`.\n-        self.name.as_symbol() == kw::SelfUpper && self.index == 0\n-    }\n }\n \n #[derive(Copy, Clone, Hash, RustcEncodable, RustcDecodable,\n@@ -1789,14 +1782,6 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n-    #[inline]\n-    pub fn is_self(&self) -> bool {\n-        match self.sty {\n-            Param(ref p) => p.is_self(),\n-            _ => false,\n-        }\n-    }\n-\n     #[inline]\n     pub fn is_slice(&self) -> bool {\n         match self.sty {"}, {"sha": "19f18088579b33172594c31e835da33a7443702b", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -333,15 +333,21 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         offset: Size,\n     ) -> PlaceRef<'tcx, &'ll Value> {\n         assert_eq!(alloc.align, layout.align.abi);\n-        let init = const_alloc_to_llvm(self, alloc);\n-        let base_addr = self.static_addr_of(init, alloc.align, None);\n-\n-        let llval = unsafe { llvm::LLVMConstInBoundsGEP(\n-            self.const_bitcast(base_addr, self.type_i8p()),\n-            &self.const_usize(offset.bytes()),\n-            1,\n-        )};\n-        let llval = self.const_bitcast(llval, self.type_ptr_to(layout.llvm_type(self)));\n+        let llty = self.type_ptr_to(layout.llvm_type(self));\n+        let llval = if layout.size == Size::ZERO {\n+            let llval = self.const_usize(alloc.align.bytes());\n+            unsafe { llvm::LLVMConstIntToPtr(llval, llty) }\n+        } else {\n+            let init = const_alloc_to_llvm(self, alloc);\n+            let base_addr = self.static_addr_of(init, alloc.align, None);\n+\n+            let llval = unsafe { llvm::LLVMConstInBoundsGEP(\n+                self.const_bitcast(base_addr, self.type_i8p()),\n+                &self.const_usize(offset.bytes()),\n+                1,\n+            )};\n+            self.const_bitcast(llval, llty)\n+        };\n         PlaceRef::new_sized(llval, layout, alloc.align)\n     }\n "}, {"sha": "f7a423092acbd52f602aa2dd42bfeb609b2022f0", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -20,6 +20,7 @@ rustc_data_structures = { path = \"../librustc_data_structures\" }\n errors = { path = \"../librustc_errors\", package = \"rustc_errors\" }\n rustc_metadata = { path = \"../librustc_metadata\" }\n rustc_mir = { path = \"../librustc_mir\" }\n+rustc_plugin_impl = { path = \"../librustc_plugin\" }\n rustc_save_analysis = { path = \"../librustc_save_analysis\" }\n rustc_codegen_utils = { path = \"../librustc_codegen_utils\" }\n rustc_interface = { path = \"../librustc_interface\" }"}, {"sha": "b19ea513b7575d0ceb369030894e49ce81c8b044", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -22,6 +22,8 @@ extern crate libc;\n #[macro_use]\n extern crate log;\n \n+pub extern crate rustc_plugin_impl as plugin;\n+\n use pretty::{PpMode, UserIdentifiedItem};\n \n //use rustc_resolve as resolve;"}, {"sha": "16b377d5bccea240fcc991c63f182d00add2758e", "filename": "src/librustc_interface/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2FCargo.toml?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -30,7 +30,7 @@ rustc_passes = { path = \"../librustc_passes\" }\n rustc_typeck = { path = \"../librustc_typeck\" }\n rustc_lint = { path = \"../librustc_lint\" }\n rustc_errors = { path = \"../librustc_errors\" }\n-rustc_plugin = { path = \"../librustc_plugin\" }\n+rustc_plugin = { path = \"../librustc_plugin\", package = \"rustc_plugin_impl\" }\n rustc_privacy = { path = \"../librustc_privacy\" }\n rustc_resolve = { path = \"../librustc_resolve\" }\n tempfile = \"3.0.5\""}, {"sha": "41b47befaf1412241a088087a166e6f0036f82f3", "filename": "src/librustc_lexer/src/lib.rs", "status": "modified", "additions": 14, "deletions": 164, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Flib.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -23,9 +23,6 @@ pub enum TokenKind {\n     Lifetime { starts_with_number: bool },\n     Semi,\n     Comma,\n-    DotDotDot,\n-    DotDotEq,\n-    DotDot,\n     Dot,\n     OpenParen,\n     CloseParen,\n@@ -37,41 +34,19 @@ pub enum TokenKind {\n     Pound,\n     Tilde,\n     Question,\n-    ColonColon,\n     Colon,\n     Dollar,\n-    EqEq,\n     Eq,\n-    FatArrow,\n-    Ne,\n     Not,\n-    Le,\n-    LArrow,\n     Lt,\n-    ShlEq,\n-    Shl,\n-    Ge,\n     Gt,\n-    ShrEq,\n-    Shr,\n-    RArrow,\n     Minus,\n-    MinusEq,\n     And,\n-    AndAnd,\n-    AndEq,\n     Or,\n-    OrOr,\n-    OrEq,\n-    PlusEq,\n     Plus,\n-    StarEq,\n     Star,\n-    SlashEq,\n     Slash,\n-    CaretEq,\n     Caret,\n-    PercentEq,\n     Percent,\n     Unknown,\n }\n@@ -135,13 +110,7 @@ impl Cursor<'_> {\n             '/' => match self.nth_char(0) {\n                 '/' => self.line_comment(),\n                 '*' => self.block_comment(),\n-                _ => {\n-                    if self.eat_assign() {\n-                        SlashEq\n-                    } else {\n-                        Slash\n-                    }\n-                }\n+                _ => Slash,\n             },\n             c if character_properties::is_whitespace(c) => self.whitespace(),\n             'r' => match (self.nth_char(0), self.nth_char(1)) {\n@@ -199,22 +168,7 @@ impl Cursor<'_> {\n             }\n             ';' => Semi,\n             ',' => Comma,\n-            '.' => {\n-                if self.nth_char(0) == '.' {\n-                    self.bump();\n-                    if self.nth_char(0) == '.' {\n-                        self.bump();\n-                        DotDotDot\n-                    } else if self.nth_char(0) == '=' {\n-                        self.bump();\n-                        DotDotEq\n-                    } else {\n-                        DotDot\n-                    }\n-                } else {\n-                    Dot\n-                }\n-            }\n+            '.' => Dot,\n             '(' => OpenParen,\n             ')' => CloseParen,\n             '{' => OpenBrace,\n@@ -225,112 +179,19 @@ impl Cursor<'_> {\n             '#' => Pound,\n             '~' => Tilde,\n             '?' => Question,\n-            ':' => {\n-                if self.nth_char(0) == ':' {\n-                    self.bump();\n-                    ColonColon\n-                } else {\n-                    Colon\n-                }\n-            }\n+            ':' => Colon,\n             '$' => Dollar,\n-            '=' => {\n-                if self.nth_char(0) == '=' {\n-                    self.bump();\n-                    EqEq\n-                } else if self.nth_char(0) == '>' {\n-                    self.bump();\n-                    FatArrow\n-                } else {\n-                    Eq\n-                }\n-            }\n-            '!' => {\n-                if self.nth_char(0) == '=' {\n-                    self.bump();\n-                    Ne\n-                } else {\n-                    Not\n-                }\n-            }\n-            '<' => match self.nth_char(0) {\n-                '=' => {\n-                    self.bump();\n-                    Le\n-                }\n-                '<' => {\n-                    self.bump();\n-                    if self.eat_assign() { ShlEq } else { Shl }\n-                }\n-                '-' => {\n-                    self.bump();\n-                    LArrow\n-                }\n-                _ => Lt,\n-            },\n-            '>' => match self.nth_char(0) {\n-                '=' => {\n-                    self.bump();\n-                    Ge\n-                }\n-                '>' => {\n-                    self.bump();\n-                    if self.eat_assign() { ShrEq } else { Shr }\n-                }\n-                _ => Gt,\n-            },\n-            '-' => {\n-                if self.nth_char(0) == '>' {\n-                    self.bump();\n-                    RArrow\n-                } else {\n-                    if self.eat_assign() { MinusEq } else { Minus }\n-                }\n-            }\n-            '&' => {\n-                if self.nth_char(0) == '&' {\n-                    self.bump();\n-                    AndAnd\n-                } else {\n-                    if self.eat_assign() { AndEq } else { And }\n-                }\n-            }\n-            '|' => {\n-                if self.nth_char(0) == '|' {\n-                    self.bump();\n-                    OrOr\n-                } else {\n-                    if self.eat_assign() { OrEq } else { Or }\n-                }\n-            }\n-            '+' => {\n-                if self.eat_assign() {\n-                    PlusEq\n-                } else {\n-                    Plus\n-                }\n-            }\n-            '*' => {\n-                if self.eat_assign() {\n-                    StarEq\n-                } else {\n-                    Star\n-                }\n-            }\n-            '^' => {\n-                if self.eat_assign() {\n-                    CaretEq\n-                } else {\n-                    Caret\n-                }\n-            }\n-            '%' => {\n-                if self.eat_assign() {\n-                    PercentEq\n-                } else {\n-                    Percent\n-                }\n-            }\n+            '=' => Eq,\n+            '!' => Not,\n+            '<' => Lt,\n+            '>' => Gt,\n+            '-' => Minus,\n+            '&' => And,\n+            '|' => Or,\n+            '+' => Plus,\n+            '*' => Star,\n+            '^' => Caret,\n+            '%' => Percent,\n             '\\'' => self.lifetime_or_char(),\n             '\"' => {\n                 let terminated = self.double_quoted_string();\n@@ -352,7 +213,6 @@ impl Cursor<'_> {\n         loop {\n             match self.nth_char(0) {\n                 '\\n' => break,\n-                '\\r' if self.nth_char(1) == '\\n' => break,\n                 EOF_CHAR if self.is_eof() => break,\n                 _ => {\n                     self.bump();\n@@ -525,7 +385,6 @@ impl Cursor<'_> {\n             match self.nth_char(0) {\n                 '/' if !first => break,\n                 '\\n' if self.nth_char(1) != '\\'' => break,\n-                '\\r' if self.nth_char(1) == '\\n' => break,\n                 EOF_CHAR if self.is_eof() => break,\n                 '\\'' => {\n                     self.bump();\n@@ -645,15 +504,6 @@ impl Cursor<'_> {\n             self.bump();\n         }\n     }\n-\n-    fn eat_assign(&mut self) -> bool {\n-        if self.nth_char(0) == '=' {\n-            self.bump();\n-            true\n-        } else {\n-            false\n-        }\n-    }\n }\n \n pub mod character_properties {"}, {"sha": "c709b7526082f6a3c18ba057cbed48a0bb4a0e11", "filename": "src/librustc_lexer/src/unescape.rs", "status": "modified", "additions": 8, "deletions": 28, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_lexer%2Fsrc%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_lexer%2Fsrc%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Funescape.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -128,11 +128,7 @@ fn scan_escape(first_char: char, chars: &mut Chars<'_>, mode: Mode) -> Result<ch\n     if first_char != '\\\\' {\n         return match first_char {\n             '\\t' | '\\n' => Err(EscapeError::EscapeOnlyChar),\n-            '\\r' => Err(if chars.clone().next() == Some('\\n') {\n-                EscapeError::EscapeOnlyChar\n-            } else {\n-                EscapeError::BareCarriageReturn\n-            }),\n+            '\\r' => Err(EscapeError::BareCarriageReturn),\n             '\\'' if mode.in_single_quotes() => Err(EscapeError::EscapeOnlyChar),\n             '\"' if mode.in_double_quotes() => Err(EscapeError::EscapeOnlyChar),\n             _ => {\n@@ -244,27 +240,15 @@ where\n \n         let unescaped_char = match first_char {\n             '\\\\' => {\n-                let (second_char, third_char) = {\n-                    let mut chars = chars.clone();\n-                    (chars.next(), chars.next())\n-                };\n-                match (second_char, third_char) {\n-                    (Some('\\n'), _) | (Some('\\r'), Some('\\n')) => {\n+                let second_char = chars.clone().next();\n+                match second_char {\n+                    Some('\\n') => {\n                         skip_ascii_whitespace(&mut chars);\n                         continue;\n                     }\n                     _ => scan_escape(first_char, &mut chars, mode),\n                 }\n             }\n-            '\\r' => {\n-                let second_char = chars.clone().next();\n-                if second_char == Some('\\n') {\n-                    chars.next();\n-                    Ok('\\n')\n-                } else {\n-                    scan_escape(first_char, &mut chars, mode)\n-                }\n-            }\n             '\\n' => Ok('\\n'),\n             '\\t' => Ok('\\t'),\n             _ => scan_escape(first_char, &mut chars, mode),\n@@ -298,15 +282,11 @@ where\n     while let Some(curr) = chars.next() {\n         let start = initial_len - chars.as_str().len() - curr.len_utf8();\n \n-        let result = match (curr, chars.clone().next()) {\n-            ('\\r', Some('\\n')) => {\n-                chars.next();\n-                Ok('\\n')\n-            },\n-            ('\\r', _) => Err(EscapeError::BareCarriageReturnInRawString),\n-            (c, _) if mode.is_bytes() && !c.is_ascii() =>\n+        let result = match curr {\n+            '\\r' => Err(EscapeError::BareCarriageReturnInRawString),\n+            c if mode.is_bytes() && !c.is_ascii() =>\n                 Err(EscapeError::NonAsciiCharInByteString),\n-            (c, _) => Ok(c),\n+            c => Ok(c),\n         };\n         let end = initial_len - chars.as_str().len();\n "}, {"sha": "e7b1ff6479d88dc4f60888bbd8ccf62fe5e9ff94", "filename": "src/librustc_lexer/src/unescape/tests.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_lexer%2Fsrc%2Funescape%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_lexer%2Fsrc%2Funescape%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Funescape%2Ftests.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -11,7 +11,6 @@ fn test_unescape_char_bad() {\n     check(r\"\\\", EscapeError::LoneSlash);\n \n     check(\"\\n\", EscapeError::EscapeOnlyChar);\n-    check(\"\\r\\n\", EscapeError::EscapeOnlyChar);\n     check(\"\\t\", EscapeError::EscapeOnlyChar);\n     check(\"'\", EscapeError::EscapeOnlyChar);\n     check(\"\\r\", EscapeError::BareCarriageReturn);\n@@ -31,6 +30,7 @@ fn test_unescape_char_bad() {\n     check(r\"\\v\", EscapeError::InvalidEscape);\n     check(r\"\\\ud83d\udca9\", EscapeError::InvalidEscape);\n     check(r\"\\\u25cf\", EscapeError::InvalidEscape);\n+    check(\"\\\\\\r\", EscapeError::InvalidEscape);\n \n     check(r\"\\x\", EscapeError::TooShortHexEscape);\n     check(r\"\\x0\", EscapeError::TooShortHexEscape);\n@@ -116,10 +116,9 @@ fn test_unescape_str_good() {\n \n     check(\"foo\", \"foo\");\n     check(\"\", \"\");\n-    check(\" \\t\\n\\r\\n\", \" \\t\\n\\n\");\n+    check(\" \\t\\n\", \" \\t\\n\");\n \n     check(\"hello \\\\\\n     world\", \"hello world\");\n-    check(\"hello \\\\\\r\\n     world\", \"hello world\");\n     check(\"thread's\", \"thread's\")\n }\n \n@@ -134,7 +133,6 @@ fn test_unescape_byte_bad() {\n     check(r\"\\\", EscapeError::LoneSlash);\n \n     check(\"\\n\", EscapeError::EscapeOnlyChar);\n-    check(\"\\r\\n\", EscapeError::EscapeOnlyChar);\n     check(\"\\t\", EscapeError::EscapeOnlyChar);\n     check(\"'\", EscapeError::EscapeOnlyChar);\n     check(\"\\r\", EscapeError::BareCarriageReturn);\n@@ -238,10 +236,9 @@ fn test_unescape_byte_str_good() {\n \n     check(\"foo\", b\"foo\");\n     check(\"\", b\"\");\n-    check(\" \\t\\n\\r\\n\", b\" \\t\\n\\n\");\n+    check(\" \\t\\n\", b\" \\t\\n\");\n \n     check(\"hello \\\\\\n     world\", b\"hello world\");\n-    check(\"hello \\\\\\r\\n     world\", b\"hello world\");\n     check(\"thread's\", b\"thread's\")\n }\n \n@@ -253,7 +250,6 @@ fn test_unescape_raw_str() {\n         assert_eq!(unescaped, expected);\n     }\n \n-    check(\"\\r\\n\", &[(0..2, Ok('\\n'))]);\n     check(\"\\r\", &[(0..1, Err(EscapeError::BareCarriageReturnInRawString))]);\n     check(\"\\rx\", &[(0..1, Err(EscapeError::BareCarriageReturnInRawString)), (1..2, Ok('x'))]);\n }\n@@ -266,7 +262,6 @@ fn test_unescape_raw_byte_str() {\n         assert_eq!(unescaped, expected);\n     }\n \n-    check(\"\\r\\n\", &[(0..2, Ok(byte_from_char('\\n')))]);\n     check(\"\\r\", &[(0..1, Err(EscapeError::BareCarriageReturnInRawString))]);\n     check(\"\ud83e\udd80\", &[(0..4, Err(EscapeError::NonAsciiCharInByteString))]);\n     check("}, {"sha": "27833161ef23d7b6cf4020828ac08f41042b94e8", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -3,7 +3,7 @@\n //! This currently only contains the definitions and implementations\n //! of most of the lints that `rustc` supports directly, it does not\n //! contain the infrastructure for defining/registering lints. That is\n-//! available in `rustc::lint` and `rustc_plugin` respectively.\n+//! available in `rustc::lint` and `rustc_driver::plugin` respectively.\n //!\n //! ## Note\n //!"}, {"sha": "af41b6a4c857f092101cac0c8286eaeda6e7e136", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 25, "deletions": 64, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -2,8 +2,7 @@\n \n use crate::cstore::{self, CStore, CrateSource, MetadataBlob};\n use crate::locator::{self, CratePaths};\n-use crate::decoder::proc_macro_def_path_table;\n-use crate::schema::CrateRoot;\n+use crate::schema::{CrateRoot};\n use rustc_data_structures::sync::{Lrc, RwLock, Lock};\n \n use rustc::hir::def_id::CrateNum;\n@@ -26,11 +25,11 @@ use std::{cmp, fs};\n use syntax::ast;\n use syntax::attr;\n use syntax::ext::allocator::{global_allocator_spans, AllocatorKind};\n-use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n use syntax::symbol::{Symbol, sym};\n use syntax::{span_err, span_fatal};\n use syntax_pos::{Span, DUMMY_SP};\n use log::{debug, info, log_enabled};\n+use proc_macro::bridge::client::ProcMacro;\n \n pub struct Library {\n     pub dylib: Option<(PathBuf, PathKind)>,\n@@ -230,24 +229,13 @@ impl<'a> CrateLoader<'a> {\n \n         let dependencies: Vec<CrateNum> = cnum_map.iter().cloned().collect();\n \n-        let proc_macros = crate_root.proc_macro_decls_static.map(|_| {\n+        let raw_proc_macros =  crate_root.proc_macro_data.map(|_| {\n             if self.sess.opts.debugging_opts.dual_proc_macros {\n-                let host_lib = host_lib.unwrap();\n-                self.load_derive_macros(\n-                    &host_lib.metadata.get_root(),\n-                    host_lib.dylib.map(|p| p.0),\n-                    span\n-                )\n+                let host_lib = host_lib.as_ref().unwrap();\n+                self.dlsym_proc_macros(host_lib.dylib.as_ref().map(|p| p.0.clone()),\n+                                       &host_lib.metadata.get_root(), span)\n             } else {\n-                self.load_derive_macros(&crate_root, dylib.clone().map(|p| p.0), span)\n-            }\n-        });\n-\n-        let def_path_table = record_time(&self.sess.perf_stats.decode_def_path_tables_time, || {\n-            if let Some(proc_macros) = &proc_macros {\n-                proc_macro_def_path_table(&crate_root, proc_macros)\n-            } else {\n-                crate_root.def_path_table.decode((&metadata, self.sess))\n+                self.dlsym_proc_macros(dylib.clone().map(|p| p.0), &crate_root, span)\n             }\n         });\n \n@@ -260,13 +248,16 @@ impl<'a> CrateLoader<'a> {\n             .map(|trait_impls| (trait_impls.trait_id, trait_impls.impls))\n             .collect();\n \n+        let def_path_table = record_time(&self.sess.perf_stats.decode_def_path_tables_time, || {\n+            crate_root.def_path_table.decode((&metadata, self.sess))\n+        });\n+\n         let cmeta = cstore::CrateMetadata {\n             name: crate_root.name,\n             imported_name: ident,\n             extern_crate: Lock::new(None),\n             def_path_table: Lrc::new(def_path_table),\n             trait_impls,\n-            proc_macros,\n             root: crate_root,\n             blob: metadata,\n             cnum_map,\n@@ -280,7 +271,10 @@ impl<'a> CrateLoader<'a> {\n                 rlib,\n                 rmeta,\n             },\n-            private_dep\n+            private_dep,\n+            span,\n+            host_lib,\n+            raw_proc_macros\n         };\n \n         let cmeta = Lrc::new(cmeta);\n@@ -389,7 +383,7 @@ impl<'a> CrateLoader<'a> {\n         match result {\n             (LoadResult::Previous(cnum), None) => {\n                 let data = self.cstore.get_crate_data(cnum);\n-                if data.root.proc_macro_decls_static.is_some() {\n+                if data.root.proc_macro_data.is_some() {\n                     dep_kind = DepKind::UnexportedMacrosOnly;\n                 }\n                 data.dep_kind.with_lock(|data_dep_kind| {\n@@ -482,7 +476,7 @@ impl<'a> CrateLoader<'a> {\n                           dep_kind: DepKind)\n                           -> cstore::CrateNumMap {\n         debug!(\"resolving deps of external crate\");\n-        if crate_root.proc_macro_decls_static.is_some() {\n+        if crate_root.proc_macro_data.is_some() {\n             return cstore::CrateNumMap::new();\n         }\n \n@@ -574,19 +568,13 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    /// Loads custom derive macros.\n-    ///\n-    /// Note that this is intentionally similar to how we load plugins today,\n-    /// but also intentionally separate. Plugins are likely always going to be\n-    /// implemented as dynamic libraries, but we have a possible future where\n-    /// custom derive (and other macro-1.1 style features) are implemented via\n-    /// executables and custom IPC.\n-    fn load_derive_macros(&mut self, root: &CrateRoot<'_>, dylib: Option<PathBuf>, span: Span)\n-                          -> Vec<(ast::Name, Lrc<SyntaxExtension>)> {\n-        use std::{env, mem};\n+    fn dlsym_proc_macros(&self,\n+                         dylib: Option<PathBuf>,\n+                         root: &CrateRoot<'_>,\n+                         span: Span\n+    ) -> &'static [ProcMacro] {\n+        use std::env;\n         use crate::dynamic_lib::DynamicLibrary;\n-        use proc_macro::bridge::client::ProcMacro;\n-        use syntax::ext::proc_macro::{BangProcMacro, AttrProcMacro, ProcMacroDerive};\n \n         let path = match dylib {\n             Some(dylib) => dylib,\n@@ -608,38 +596,11 @@ impl<'a> CrateLoader<'a> {\n             *(sym as *const &[ProcMacro])\n         };\n \n-        let extensions = decls.iter().map(|&decl| {\n-            let (name, kind, helper_attrs) = match decl {\n-                ProcMacro::CustomDerive { trait_name, attributes, client } => {\n-                    let helper_attrs =\n-                        attributes.iter().cloned().map(Symbol::intern).collect::<Vec<_>>();\n-                    (\n-                        trait_name,\n-                        SyntaxExtensionKind::Derive(Box::new(ProcMacroDerive {\n-                            client, attrs: helper_attrs.clone()\n-                        })),\n-                        helper_attrs,\n-                    )\n-                }\n-                ProcMacro::Attr { name, client } => (\n-                    name, SyntaxExtensionKind::Attr(Box::new(AttrProcMacro { client })), Vec::new()\n-                ),\n-                ProcMacro::Bang { name, client } => (\n-                    name, SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client })), Vec::new()\n-                )\n-            };\n-\n-            (Symbol::intern(name), Lrc::new(SyntaxExtension {\n-                helper_attrs,\n-                ..SyntaxExtension::default(kind, root.edition)\n-            }))\n-        }).collect();\n-\n         // Intentionally leak the dynamic library. We can't ever unload it\n         // since the library can make things that will live arbitrarily long.\n-        mem::forget(lib);\n+        std::mem::forget(lib);\n \n-        extensions\n+        decls\n     }\n \n     /// Look for a plugin registrar. Returns library path, crate"}, {"sha": "792922a18372225ad2d0060eef53c606f19b8050", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -28,6 +28,9 @@ pub use crate::cstore_impl::{provide, provide_extern};\n pub type CrateNumMap = IndexVec<CrateNum, CrateNum>;\n \n pub use rustc_data_structures::sync::MetadataRef;\n+use crate::creader::Library;\n+use syntax_pos::Span;\n+use proc_macro::bridge::client::ProcMacro;\n \n pub struct MetadataBlob(pub MetadataRef);\n \n@@ -82,11 +85,19 @@ pub struct CrateMetadata {\n     pub dep_kind: Lock<DepKind>,\n     pub source: CrateSource,\n \n-    pub proc_macros: Option<Vec<(ast::Name, Lrc<SyntaxExtension>)>>,\n-\n     /// Whether or not this crate should be consider a private dependency\n     /// for purposes of the 'exported_private_dependencies' lint\n-    pub private_dep: bool\n+    pub private_dep: bool,\n+\n+    pub host_lib: Option<Library>,\n+    pub span: Span,\n+\n+    pub raw_proc_macros: Option<&'static [ProcMacro]>,\n+}\n+\n+pub struct FullProcMacro {\n+    pub name: ast::Name,\n+    pub ext: Lrc<SyntaxExtension>\n }\n \n pub struct CStore {"}, {"sha": "a66da32fa4d7560ef79d4931cb35438ae8c077dd", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -426,8 +426,8 @@ impl cstore::CStore {\n \n     pub fn load_macro_untracked(&self, id: DefId, sess: &Session) -> LoadedMacro {\n         let data = self.get_crate_data(id.krate);\n-        if let Some(ref proc_macros) = data.proc_macros {\n-            return LoadedMacro::ProcMacro(proc_macros[id.index.to_proc_macro_index()].1.clone());\n+        if data.is_proc_macro_crate() {\n+            return LoadedMacro::ProcMacro(data.get_proc_macro(id.index, sess).ext);\n         } else if data.name == sym::proc_macro && data.item_name(id.index) == sym::quote {\n             let client = proc_macro::bridge::client::Client::expand1(proc_macro::quote);\n             let kind = SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client }));\n@@ -439,7 +439,8 @@ impl cstore::CStore {\n         }\n \n         let def = data.get_macro(id.index);\n-        let macro_full_name = data.def_path(id.index).to_string_friendly(|_| data.imported_name);\n+        let macro_full_name = data.def_path(id.index)\n+            .to_string_friendly(|_| data.imported_name);\n         let source_name = FileName::Macros(macro_full_name);\n \n         let source_file = sess.parse_sess.source_map().new_source_file(source_name, def.body);"}, {"sha": "d29592a5d686997cf8e4dc4777c1f5805f48eec3", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 113, "deletions": 71, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -1,16 +1,15 @@\n // Decoding metadata from a single crate's metadata\n \n-use crate::cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary, ForeignModule};\n+use crate::cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary, ForeignModule, FullProcMacro};\n use crate::schema::*;\n \n use rustc_data_structures::sync::{Lrc, ReadGuard};\n-use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash, Definitions};\n+use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash};\n use rustc::hir;\n use rustc::middle::cstore::LinkagePreference;\n use rustc::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use rustc::hir::def::{self, Res, DefKind, CtorOf, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use rustc::hir::map::definitions::DefPathTable;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc::middle::lang_items;\n use rustc::mir::{self, interpret};\n@@ -30,10 +29,11 @@ use syntax::attr;\n use syntax::ast::{self, Ident};\n use syntax::source_map;\n use syntax::symbol::{Symbol, sym};\n-use syntax::ext::base::{MacroKind, SyntaxExtension};\n-use syntax::ext::hygiene::ExpnId;\n-use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP};\n+use syntax::ext::base::{MacroKind, SyntaxExtensionKind, SyntaxExtension};\n+use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP, symbol::{InternedString}};\n use log::debug;\n+use proc_macro::bridge::client::ProcMacro;\n+use syntax::ext::proc_macro::{AttrProcMacro, ProcMacroDerive, BangProcMacro};\n \n pub struct DecodeContext<'a, 'tcx> {\n     opaque: opaque::Decoder<'a>,\n@@ -138,7 +138,7 @@ impl<'a: 'x, 'tcx: 'x, 'x, T: Decodable> LazySeq<T> {\n     pub fn decode<M: Metadata<'a, 'tcx>>(\n         self,\n         meta: M,\n-    ) -> impl Iterator<Item = T> + Captures<'a> + Captures<'tcx> + 'x {\n+    ) -> impl ExactSizeIterator<Item = T> + Captures<'a> + Captures<'tcx> + 'x {\n         let mut dcx = meta.decoder(self.position);\n         dcx.lazy_state = LazyState::NodeStart(self.position);\n         (0..self.len).map(move |_| T::decode(&mut dcx).unwrap())\n@@ -442,46 +442,16 @@ impl<'tcx> EntryKind<'tcx> {\n     }\n }\n \n-/// Creates the \"fake\" DefPathTable for a given proc macro crate.\n-///\n-/// The DefPathTable is as follows:\n-///\n-/// CRATE_ROOT (DefIndex 0:0)\n-///  |- GlobalMetaDataKind data (DefIndex 1:0 .. DefIndex 1:N)\n-///  |- proc macro #0 (DefIndex 1:N)\n-///  |- proc macro #1 (DefIndex 1:N+1)\n-///  \\- ...\n-crate fn proc_macro_def_path_table(crate_root: &CrateRoot<'_>,\n-                                   proc_macros: &[(ast::Name, Lrc<SyntaxExtension>)])\n-                                   -> DefPathTable\n-{\n-    let mut definitions = Definitions::default();\n-\n-    let name = crate_root.name.as_str();\n-    let disambiguator = crate_root.disambiguator;\n-    debug!(\"creating proc macro def path table for {:?}/{:?}\", name, disambiguator);\n-    let crate_root = definitions.create_root_def(&name, disambiguator);\n-    for (index, (name, _)) in proc_macros.iter().enumerate() {\n-        let def_index = definitions.create_def_with_parent(\n-            crate_root,\n-            ast::DUMMY_NODE_ID,\n-            DefPathData::MacroNs(name.as_interned_str()),\n-            ExpnId::root(),\n-            DUMMY_SP);\n-        debug!(\"definition for {:?} is {:?}\", name, def_index);\n-        assert_eq!(def_index, DefIndex::from_proc_macro_index(index));\n-    }\n-\n-    definitions.def_path_table().clone()\n-}\n-\n impl<'a, 'tcx> CrateMetadata {\n+    pub fn is_proc_macro_crate(&self) -> bool {\n+        self.root.proc_macro_decls_static.is_some()\n+    }\n     fn is_proc_macro(&self, id: DefIndex) -> bool {\n-        self.proc_macros.is_some() && id != CRATE_DEF_INDEX\n+        self.is_proc_macro_crate() &&\n+            self.root.proc_macro_data.unwrap().decode(self).find(|x| *x == id).is_some()\n     }\n \n     fn maybe_entry(&self, item_id: DefIndex) -> Option<Lazy<Entry<'tcx>>> {\n-        assert!(!self.is_proc_macro(item_id));\n         self.root.entries_index.lookup(self.blob.raw_bytes(), item_id)\n     }\n \n@@ -504,29 +474,89 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n+    fn raw_proc_macro(&self, id: DefIndex) -> &ProcMacro {\n+        // DefIndex's in root.proc_macro_data have a one-to-one correspondence\n+        // with items in 'raw_proc_macros'\n+        let pos = self.root.proc_macro_data.unwrap().decode(self).position(|i| i == id).unwrap();\n+        &self.raw_proc_macros.unwrap()[pos]\n+    }\n+\n     pub fn item_name(&self, item_index: DefIndex) -> Symbol {\n-        self.def_key(item_index)\n-            .disambiguated_data\n-            .data\n-            .get_opt_name()\n-            .expect(\"no name in item_name\")\n-            .as_symbol()\n+        if !self.is_proc_macro(item_index) {\n+            self.def_key(item_index)\n+                .disambiguated_data\n+                .data\n+                .get_opt_name()\n+                .expect(\"no name in item_name\")\n+                .as_symbol()\n+        } else {\n+            Symbol::intern(self.raw_proc_macro(item_index).name())\n+        }\n     }\n \n     pub fn def_kind(&self, index: DefIndex) -> Option<DefKind> {\n         if !self.is_proc_macro(index) {\n             self.entry(index).kind.def_kind()\n         } else {\n             Some(DefKind::Macro(\n-                self.proc_macros.as_ref().unwrap()[index.to_proc_macro_index()].1.macro_kind()\n+                macro_kind(self.raw_proc_macro(index))\n             ))\n         }\n     }\n \n     pub fn get_span(&self, index: DefIndex, sess: &Session) -> Span {\n-        match self.is_proc_macro(index) {\n-            true => DUMMY_SP,\n-            false => self.entry(index).span.decode((self, sess)),\n+        self.entry(index).span.decode((self, sess))\n+    }\n+\n+\n+    pub fn get_proc_macro(&self, id: DefIndex, sess: &Session) -> FullProcMacro {\n+        if sess.opts.debugging_opts.dual_proc_macros {\n+            let host_lib = self.host_lib.as_ref().unwrap();\n+            self.load_proc_macro(\n+                &host_lib.metadata.get_root(),\n+                id,\n+                sess\n+            )\n+        } else {\n+            self.load_proc_macro(&self.root, id, sess)\n+        }\n+    }\n+\n+    fn load_proc_macro(&self, root: &CrateRoot<'_>,\n+                        id: DefIndex,\n+                        sess: &Session)\n+                        -> FullProcMacro {\n+\n+        let raw_macro = self.raw_proc_macro(id);\n+        let (name, kind, helper_attrs) = match *raw_macro {\n+            ProcMacro::CustomDerive { trait_name, attributes, client } => {\n+                let helper_attrs =\n+                    attributes.iter().cloned().map(Symbol::intern).collect::<Vec<_>>();\n+                (\n+                    trait_name,\n+                    SyntaxExtensionKind::Derive(Box::new(ProcMacroDerive {\n+                        client, attrs: helper_attrs.clone()\n+                    })),\n+                    helper_attrs,\n+                )\n+            }\n+            ProcMacro::Attr { name, client } => (\n+                name, SyntaxExtensionKind::Attr(Box::new(AttrProcMacro { client })), Vec::new()\n+            ),\n+            ProcMacro::Bang { name, client } => (\n+                name, SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client })), Vec::new()\n+            )\n+        };\n+\n+        let span = self.get_span(id, sess);\n+\n+        FullProcMacro {\n+            name: Symbol::intern(name),\n+            ext: Lrc::new(SyntaxExtension {\n+                span,\n+                helper_attrs,\n+                ..SyntaxExtension::default(kind, root.edition)\n+            })\n         }\n     }\n \n@@ -723,7 +753,7 @@ impl<'a, 'tcx> CrateMetadata {\n \n     /// Iterates over the language items in the given crate.\n     pub fn get_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(DefId, usize)] {\n-        if self.proc_macros.is_some() {\n+        if self.is_proc_macro_crate() {\n             // Proc macro crates do not export any lang-items to the target.\n             &[]\n         } else {\n@@ -738,18 +768,18 @@ impl<'a, 'tcx> CrateMetadata {\n     pub fn each_child_of_item<F>(&self, id: DefIndex, mut callback: F, sess: &Session)\n         where F: FnMut(def::Export<hir::HirId>)\n     {\n-        if let Some(ref proc_macros) = self.proc_macros {\n+        if let Some(proc_macros_ids) = self.root.proc_macro_data.map(|d| d.decode(self)) {\n             /* If we are loading as a proc macro, we want to return the view of this crate\n-             * as a proc macro crate, not as a Rust crate. See `proc_macro_def_path_table`\n-             * for the DefPathTable we are corresponding to.\n+             * as a proc macro crate.\n              */\n             if id == CRATE_DEF_INDEX {\n-                for (id, &(name, ref ext)) in proc_macros.iter().enumerate() {\n+                for def_index in proc_macros_ids {\n+                    let raw_macro = self.raw_proc_macro(def_index);\n                     let res = Res::Def(\n-                        DefKind::Macro(ext.macro_kind()),\n-                        self.local_def_id(DefIndex::from_proc_macro_index(id)),\n+                        DefKind::Macro(macro_kind(raw_macro)),\n+                        self.local_def_id(def_index),\n                     );\n-                    let ident = Ident::with_dummy_span(name);\n+                    let ident = Ident::from_str(raw_macro.name());\n                     callback(def::Export {\n                         ident: ident,\n                         res: res,\n@@ -960,11 +990,8 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_item_attrs(&self, node_id: DefIndex, sess: &Session) -> Lrc<[ast::Attribute]> {\n-        if self.is_proc_macro(node_id) {\n-            return Lrc::new([]);\n-        }\n \n+    pub fn get_item_attrs(&self, node_id: DefIndex, sess: &Session) -> Lrc<[ast::Attribute]> {\n         // The attributes for a tuple struct/variant are attached to the definition, not the ctor;\n         // we assume that someone passing in a tuple struct ctor is actually wanting to\n         // look at the definition\n@@ -1022,7 +1049,7 @@ impl<'a, 'tcx> CrateMetadata {\n         tcx: TyCtxt<'tcx>,\n         filter: Option<DefId>,\n     ) -> &'tcx [DefId] {\n-        if self.proc_macros.is_some() {\n+        if self.is_proc_macro_crate() {\n             // proc-macro crates export no trait impls.\n             return &[]\n         }\n@@ -1066,7 +1093,7 @@ impl<'a, 'tcx> CrateMetadata {\n \n \n     pub fn get_native_libraries(&self, sess: &Session) -> Vec<NativeLibrary> {\n-        if self.proc_macros.is_some() {\n+        if self.is_proc_macro_crate() {\n             // Proc macro crates do not have any *target* native libraries.\n             vec![]\n         } else {\n@@ -1075,7 +1102,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn get_foreign_modules(&self, tcx: TyCtxt<'tcx>) -> &'tcx [ForeignModule] {\n-        if self.proc_macros.is_some() {\n+        if self.is_proc_macro_crate() {\n             // Proc macro crates do not have any *target* foreign modules.\n             &[]\n         } else {\n@@ -1098,7 +1125,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn get_missing_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [lang_items::LangItem] {\n-        if self.proc_macros.is_some() {\n+        if self.is_proc_macro_crate() {\n             // Proc macro crates do not depend on any target weak lang-items.\n             &[]\n         } else {\n@@ -1122,7 +1149,7 @@ impl<'a, 'tcx> CrateMetadata {\n         &self,\n         tcx: TyCtxt<'tcx>,\n     ) -> Vec<(ExportedSymbol<'tcx>, SymbolExportLevel)> {\n-        if self.proc_macros.is_some() {\n+        if self.is_proc_macro_crate() {\n             // If this crate is a custom derive crate, then we're not even going to\n             // link those in so we skip those crates.\n             vec![]\n@@ -1191,13 +1218,18 @@ impl<'a, 'tcx> CrateMetadata {\n \n     #[inline]\n     pub fn def_key(&self, index: DefIndex) -> DefKey {\n-        self.def_path_table.def_key(index)\n+        let mut key = self.def_path_table.def_key(index);\n+        if self.is_proc_macro(index) {\n+            let name = self.raw_proc_macro(index).name();\n+            key.disambiguated_data.data = DefPathData::MacroNs(InternedString::intern(name));\n+        }\n+        key\n     }\n \n     // Returns the path leading to the thing with this `id`.\n     pub fn def_path(&self, id: DefIndex) -> DefPath {\n         debug!(\"def_path(cnum={:?}, id={:?})\", self.cnum, id);\n-        DefPath::make(self.cnum, id, |parent| self.def_path_table.def_key(parent))\n+        DefPath::make(self.cnum, id, |parent| self.def_key(parent))\n     }\n \n     #[inline]\n@@ -1310,3 +1342,13 @@ impl<'a, 'tcx> CrateMetadata {\n         self.source_map_import_info.borrow()\n     }\n }\n+\n+// Cannot be implemented on 'ProcMacro', as libproc_macro\n+// does not depend on libsyntax\n+fn macro_kind(raw: &ProcMacro) -> MacroKind {\n+    match raw {\n+        ProcMacro::CustomDerive { .. } => MacroKind::Derive,\n+        ProcMacro::Attr { .. } => MacroKind::Attr,\n+        ProcMacro::Bang { .. } => MacroKind::Bang\n+    }\n+}"}, {"sha": "6058ae99cf4f82372c8d2378f327413d0cc23d5b", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -30,6 +30,7 @@ use rustc_data_structures::sync::Lrc;\n use std::u32;\n use syntax::ast;\n use syntax::attr;\n+use syntax::ext::proc_macro::is_proc_macro_attr;\n use syntax::source_map::Spanned;\n use syntax::symbol::{kw, sym, Ident};\n use syntax_pos::{self, FileName, SourceFile, Span};\n@@ -383,6 +384,8 @@ impl<'tcx> EncodeContext<'tcx> {\n     }\n \n     fn encode_crate_root(&mut self) -> Lazy<CrateRoot<'tcx>> {\n+        let is_proc_macro = self.tcx.sess.crate_types.borrow().contains(&CrateType::ProcMacro);\n+\n         let mut i = self.position();\n \n         let crate_deps = self.encode_crate_deps();\n@@ -463,16 +466,23 @@ impl<'tcx> EncodeContext<'tcx> {\n             self.lazy_seq(interpret_alloc_index)\n         };\n \n+\n         i = self.position();\n         let entries_index = self.entries_index.write_index(&mut self.opaque);\n         let entries_index_bytes = self.position() - i;\n \n+        // Encode the proc macro data\n+        i = self.position();\n+        let proc_macro_data = self.encode_proc_macros();\n+        let proc_macro_data_bytes = self.position() - i;\n+\n+\n         let attrs = tcx.hir().krate_attrs();\n-        let is_proc_macro = tcx.sess.crate_types.borrow().contains(&CrateType::ProcMacro);\n         let has_default_lib_allocator = attr::contains_name(&attrs, sym::default_lib_allocator);\n         let has_global_allocator = *tcx.sess.has_global_allocator.get();\n         let has_panic_handler = *tcx.sess.has_panic_handler.try_get().unwrap_or(&false);\n \n+\n         let root = self.lazy(&CrateRoot {\n             name: tcx.crate_name(LOCAL_CRATE),\n             extra_filename: tcx.sess.opts.cg.extra_filename.clone(),\n@@ -491,6 +501,7 @@ impl<'tcx> EncodeContext<'tcx> {\n             } else {\n                 None\n             },\n+            proc_macro_data,\n             proc_macro_stability: if is_proc_macro {\n                 tcx.lookup_stability(DefId::local(CRATE_DEF_INDEX)).map(|stab| stab.clone())\n             } else {\n@@ -539,6 +550,7 @@ impl<'tcx> EncodeContext<'tcx> {\n             println!(\"            impl bytes: {}\", impl_bytes);\n             println!(\"    exp. symbols bytes: {}\", exported_symbols_bytes);\n             println!(\"  def-path table bytes: {}\", def_path_table_bytes);\n+            println!(\" proc-macro-data-bytes: {}\", proc_macro_data_bytes);\n             println!(\"            item bytes: {}\", item_bytes);\n             println!(\"   entries index bytes: {}\", entries_index_bytes);\n             println!(\"            zero bytes: {}\", zero_bytes);\n@@ -1470,6 +1482,22 @@ impl EncodeContext<'tcx> {\n         self.lazy_seq(foreign_modules.iter().cloned())\n     }\n \n+    fn encode_proc_macros(&mut self) -> Option<LazySeq<DefIndex>> {\n+        let is_proc_macro = self.tcx.sess.crate_types.borrow().contains(&CrateType::ProcMacro);\n+        if is_proc_macro {\n+            let proc_macros: Vec<_> = self.tcx.hir().krate().items.values().filter_map(|item| {\n+                if item.attrs.iter().any(|attr| is_proc_macro_attr(attr)) {\n+                    Some(item.hir_id.owner)\n+                } else {\n+                    None\n+                }\n+            }).collect();\n+            Some(self.lazy_seq(proc_macros))\n+        } else {\n+            None\n+        }\n+    }\n+\n     fn encode_crate_deps(&mut self) -> LazySeq<CrateDep> {\n         let crates = self.tcx.crates();\n "}, {"sha": "ceba7cf0fe031c94324f06469b8d6edb33739f0c", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -716,7 +716,9 @@ impl<'a> Context<'a> {\n \n         let root = metadata.get_root();\n         if let Some(is_proc_macro) = self.is_proc_macro {\n-            if root.proc_macro_decls_static.is_some() != is_proc_macro {\n+            if root.proc_macro_data.is_some() != is_proc_macro {\n+                info!(\"Rejecting via proc macro: expected {} got {}\",\n+                      is_proc_macro, root.proc_macro_data.is_some());\n                 return None;\n             }\n         }"}, {"sha": "13c599cf997b65a5f400d0f7104e43ea42db7e3b", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -182,6 +182,10 @@ pub struct CrateRoot<'tcx> {\n \n     pub entries_index: LazySeq<index::Index<'tcx>>,\n \n+    /// The DefIndex's of any proc macros delcared by\n+    /// this crate\n+    pub proc_macro_data: Option<LazySeq<DefIndex>>,\n+\n     pub compiler_builtins: bool,\n     pub needs_allocator: bool,\n     pub needs_panic_runtime: bool,"}, {"sha": "247783c420e251d6d32b79835fba3e1dbb303379", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -1190,7 +1190,16 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         );\n \n         let suggestion = match tcx.sess.source_map().span_to_snippet(args_span) {\n-            Ok(string) => format!(\"move {}\", string),\n+            Ok(mut string) => {\n+                if string.starts_with(\"async \") {\n+                    string.insert_str(6, \"move \");\n+                } else if string.starts_with(\"async|\") {\n+                    string.insert_str(5, \" move\");\n+                } else {\n+                    string.insert_str(0, \"move \");\n+                };\n+                string\n+            },\n             Err(_) => \"move |<args>| <body>\".to_string()\n         };\n "}, {"sha": "ca68b9e31b6b91337e4fa2b555d7c53f0de24f12", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -578,7 +578,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 })\n             }\n \n-            hir::LifetimeName::Implicit => {\n+            hir::LifetimeName::ImplicitObjectLifetimeDefault\n+            | hir::LifetimeName::Implicit => {\n                 // In this case, the user left off the lifetime; so\n                 // they wrote something like:\n                 //"}, {"sha": "94323b15b696fb3ba91aa1460317ea2eddec56b1", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -657,6 +657,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     self.visit_bindings(&subpattern.pattern, subpattern_user_ty, f);\n                 }\n             }\n+            PatternKind::Or { ref pats } => {\n+                for pat in pats {\n+                    self.visit_bindings(&pat, pattern_user_ty.clone(), f);\n+                }\n+            }\n         }\n     }\n }"}, {"sha": "8d049b53988a9197f78c2e4aedd4f839f7a079e9", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -195,6 +195,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 candidate.match_pairs.push(MatchPair::new(place, subpattern));\n                 Ok(())\n             }\n+\n+            PatternKind::Or { .. } => {\n+                Err(match_pair)\n+            }\n         }\n     }\n }"}, {"sha": "ec85daccd476eb49efa6a7c729dcea23c0a5ad17", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -87,6 +87,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             PatternKind::AscribeUserType { .. } |\n             PatternKind::Array { .. } |\n             PatternKind::Wild |\n+            PatternKind::Or { .. } |\n             PatternKind::Binding { .. } |\n             PatternKind::Leaf { .. } |\n             PatternKind::Deref { .. } => {\n@@ -130,6 +131,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             PatternKind::Slice { .. } |\n             PatternKind::Array { .. } |\n             PatternKind::Wild |\n+            PatternKind::Or { .. } |\n             PatternKind::Binding { .. } |\n             PatternKind::AscribeUserType { .. } |\n             PatternKind::Leaf { .. } |"}, {"sha": "222750e602df92f5ff30b37c5230b3c94086e105", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -1359,6 +1359,9 @@ fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt<'_, 'tcx>,\n                 Some(vec![Slice(pat_len)])\n             }\n         }\n+        PatternKind::Or { .. } => {\n+            bug!(\"support for or-patterns has not been fully implemented yet.\");\n+        }\n     }\n }\n \n@@ -1884,6 +1887,10 @@ fn specialize<'p, 'a: 'p, 'tcx>(\n                     \"unexpected ctor {:?} for slice pat\", constructor)\n             }\n         }\n+\n+        PatternKind::Or { .. } => {\n+            bug!(\"support for or-patterns has not been fully implemented yet.\");\n+        }\n     };\n     debug!(\"specialize({:#?}, {:#?}) = {:#?}\", r[0], wild_patterns, head);\n "}, {"sha": "6caccfddfa422f6724180e8199b5d1824edae489", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 37, "deletions": 11, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -175,6 +175,12 @@ pub enum PatternKind<'tcx> {\n         slice: Option<Pattern<'tcx>>,\n         suffix: Vec<Pattern<'tcx>>,\n     },\n+\n+    /// An or-pattern, e.g. `p | q`.\n+    /// Invariant: `pats.len() >= 2`.\n+    Or {\n+        pats: Vec<Pattern<'tcx>>,\n+    },\n }\n \n #[derive(Copy, Clone, Debug, PartialEq)]\n@@ -186,6 +192,18 @@ pub struct PatternRange<'tcx> {\n \n impl<'tcx> fmt::Display for Pattern<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // Printing lists is a chore.\n+        let mut first = true;\n+        let mut start_or_continue = |s| {\n+            if first {\n+                first = false;\n+                \"\"\n+            } else {\n+                s\n+            }\n+        };\n+        let mut start_or_comma = || start_or_continue(\", \");\n+\n         match *self.kind {\n             PatternKind::Wild => write!(f, \"_\"),\n             PatternKind::AscribeUserType { ref subpattern, .. } =>\n@@ -224,9 +242,6 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n                     }\n                 };\n \n-                let mut first = true;\n-                let mut start_or_continue = || if first { first = false; \"\" } else { \", \" };\n-\n                 if let Some(variant) = variant {\n                     write!(f, \"{}\", variant.ident)?;\n \n@@ -241,12 +256,12 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n                                 continue;\n                             }\n                             let name = variant.fields[p.field.index()].ident;\n-                            write!(f, \"{}{}: {}\", start_or_continue(), name, p.pattern)?;\n+                            write!(f, \"{}{}: {}\", start_or_comma(), name, p.pattern)?;\n                             printed += 1;\n                         }\n \n                         if printed < variant.fields.len() {\n-                            write!(f, \"{}..\", start_or_continue())?;\n+                            write!(f, \"{}..\", start_or_comma())?;\n                         }\n \n                         return write!(f, \" }}\");\n@@ -257,7 +272,7 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n                 if num_fields != 0 || variant.is_none() {\n                     write!(f, \"(\")?;\n                     for i in 0..num_fields {\n-                        write!(f, \"{}\", start_or_continue())?;\n+                        write!(f, \"{}\", start_or_comma())?;\n \n                         // Common case: the field is where we expect it.\n                         if let Some(p) = subpatterns.get(i) {\n@@ -305,25 +320,29 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n             }\n             PatternKind::Slice { ref prefix, ref slice, ref suffix } |\n             PatternKind::Array { ref prefix, ref slice, ref suffix } => {\n-                let mut first = true;\n-                let mut start_or_continue = || if first { first = false; \"\" } else { \", \" };\n                 write!(f, \"[\")?;\n                 for p in prefix {\n-                    write!(f, \"{}{}\", start_or_continue(), p)?;\n+                    write!(f, \"{}{}\", start_or_comma(), p)?;\n                 }\n                 if let Some(ref slice) = *slice {\n-                    write!(f, \"{}\", start_or_continue())?;\n+                    write!(f, \"{}\", start_or_comma())?;\n                     match *slice.kind {\n                         PatternKind::Wild => {}\n                         _ => write!(f, \"{}\", slice)?\n                     }\n                     write!(f, \"..\")?;\n                 }\n                 for p in suffix {\n-                    write!(f, \"{}{}\", start_or_continue(), p)?;\n+                    write!(f, \"{}{}\", start_or_comma(), p)?;\n                 }\n                 write!(f, \"]\")\n             }\n+            PatternKind::Or { ref pats } => {\n+                for pat in pats {\n+                    write!(f, \"{}{}\", start_or_continue(\" | \"), pat)?;\n+                }\n+                Ok(())\n+            }\n         }\n     }\n }\n@@ -655,6 +674,12 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n \n                 self.lower_variant_or_leaf(res, pat.hir_id, pat.span, ty, subpatterns)\n             }\n+\n+            PatKind::Or(ref pats) => {\n+                PatternKind::Or {\n+                    pats: pats.iter().map(|p| self.lower_pattern(p)).collect(),\n+                }\n+            }\n         };\n \n         Pattern {\n@@ -1436,6 +1461,7 @@ impl<'tcx> PatternFoldable<'tcx> for PatternKind<'tcx> {\n                 slice: slice.fold_with(folder),\n                 suffix: suffix.fold_with(folder)\n             },\n+            PatternKind::Or { ref pats } => PatternKind::Or { pats: pats.fold_with(folder) },\n         }\n     }\n }"}, {"sha": "210647ac1e9a3de60307d4490cdd7a26c2000812", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -1,4 +1,4 @@\n-use rustc::ty::{self, Ty, TypeAndMut};\n+use rustc::ty::{self, Ty, TypeAndMut, TypeFoldable};\n use rustc::ty::layout::{self, TyLayout, Size};\n use rustc::ty::adjustment::{PointerCast};\n use syntax::ast::FloatTy;\n@@ -36,15 +36,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // The src operand does not matter, just its type\n                 match src.layout.ty.sty {\n                     ty::FnDef(def_id, substs) => {\n+                        // All reifications must be monomorphic, bail out otherwise.\n+                        if src.layout.ty.needs_subst() {\n+                            throw_inval!(TooGeneric);\n+                        }\n+\n                         if self.tcx.has_attr(def_id, sym::rustc_args_required_const) {\n                             bug!(\"reifying a fn ptr that requires const arguments\");\n                         }\n-                        let instance = ty::Instance::resolve(\n-                            *self.tcx,\n-                            self.param_env,\n-                            def_id,\n-                            substs,\n-                        ).ok_or_else(|| err_inval!(TooGeneric))?;\n+                        let instance = self.resolve(def_id, substs)?;\n                         let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance));\n                         self.write_scalar(Scalar::Ptr(fn_ptr.into()), dest)?;\n                     }\n@@ -67,7 +67,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // The src operand does not matter, just its type\n                 match src.layout.ty.sty {\n                     ty::Closure(def_id, substs) => {\n-                        let substs = self.subst_and_normalize_erasing_regions(substs)?;\n+                        // All reifications must be monomorphic, bail out otherwise.\n+                        if src.layout.ty.needs_subst() {\n+                            throw_inval!(TooGeneric);\n+                        }\n+\n                         let instance = ty::Instance::resolve_closure(\n                             *self.tcx,\n                             def_id,"}, {"sha": "6f48396cdd7cfeca0af170637f00b6ccb23d3d5d", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 29, "deletions": 60, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -9,7 +9,7 @@ use rustc::mir;\n use rustc::ty::layout::{\n     self, Size, Align, HasDataLayout, LayoutOf, TyLayout\n };\n-use rustc::ty::subst::{Subst, SubstsRef};\n+use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::query::TyCtxtAt;\n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -291,41 +291,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         ty.is_freeze(*self.tcx, self.param_env, DUMMY_SP)\n     }\n \n-    pub(super) fn subst_and_normalize_erasing_regions<T: TypeFoldable<'tcx>>(\n-        &self,\n-        substs: T,\n-    ) -> InterpResult<'tcx, T> {\n-        match self.stack.last() {\n-            Some(frame) => Ok(self.tcx.subst_and_normalize_erasing_regions(\n-                frame.instance.substs,\n-                self.param_env,\n-                &substs,\n-            )),\n-            None => if substs.needs_subst() {\n-                throw_inval!(TooGeneric)\n-            } else {\n-                Ok(substs)\n-            },\n-        }\n-    }\n-\n-    pub(super) fn resolve(\n-        &self,\n-        def_id: DefId,\n-        substs: SubstsRef<'tcx>\n-    ) -> InterpResult<'tcx, ty::Instance<'tcx>> {\n-        trace!(\"resolve: {:?}, {:#?}\", def_id, substs);\n-        trace!(\"param_env: {:#?}\", self.param_env);\n-        let substs = self.subst_and_normalize_erasing_regions(substs)?;\n-        trace!(\"substs: {:#?}\", substs);\n-        ty::Instance::resolve(\n-            *self.tcx,\n-            self.param_env,\n-            def_id,\n-            substs,\n-        ).ok_or_else(|| err_inval!(TooGeneric).into())\n-    }\n-\n     pub fn load_mir(\n         &self,\n         instance: ty::InstanceDef<'tcx>,\n@@ -349,34 +314,34 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n     }\n \n-    pub(super) fn monomorphize<T: TypeFoldable<'tcx> + Subst<'tcx>>(\n+    /// Call this on things you got out of the MIR (so it is as generic as the current\n+    /// stack frame), to bring it into the proper environment for this interpreter.\n+    pub(super) fn subst_from_frame_and_normalize_erasing_regions<T: TypeFoldable<'tcx>>(\n         &self,\n-        t: T,\n-    ) -> InterpResult<'tcx, T> {\n-        match self.stack.last() {\n-            Some(frame) => Ok(self.monomorphize_with_substs(t, frame.instance.substs)?),\n-            None => if t.needs_subst() {\n-                throw_inval!(TooGeneric)\n-            } else {\n-                Ok(t)\n-            },\n-        }\n+        value: T,\n+    ) -> T {\n+        self.tcx.subst_and_normalize_erasing_regions(\n+            self.frame().instance.substs,\n+            self.param_env,\n+            &value,\n+        )\n     }\n \n-    fn monomorphize_with_substs<T: TypeFoldable<'tcx> + Subst<'tcx>>(\n+    /// The `substs` are assumed to already be in our interpreter \"universe\" (param_env).\n+    pub(super) fn resolve(\n         &self,\n-        t: T,\n+        def_id: DefId,\n         substs: SubstsRef<'tcx>\n-    ) -> InterpResult<'tcx, T> {\n-        // miri doesn't care about lifetimes, and will choke on some crazy ones\n-        // let's simply get rid of them\n-        let substituted = t.subst(*self.tcx, substs);\n-\n-        if substituted.needs_subst() {\n-            throw_inval!(TooGeneric)\n-        }\n-\n-        Ok(self.tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), substituted))\n+    ) -> InterpResult<'tcx, ty::Instance<'tcx>> {\n+        trace!(\"resolve: {:?}, {:#?}\", def_id, substs);\n+        trace!(\"param_env: {:#?}\", self.param_env);\n+        trace!(\"substs: {:#?}\", substs);\n+        ty::Instance::resolve(\n+            *self.tcx,\n+            self.param_env,\n+            def_id,\n+            substs,\n+        ).ok_or_else(|| err_inval!(TooGeneric).into())\n     }\n \n     pub fn layout_of_local(\n@@ -391,7 +356,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             None => {\n                 let layout = crate::interpret::operand::from_known_layout(layout, || {\n                     let local_ty = frame.body.local_decls[local].ty;\n-                    let local_ty = self.monomorphize_with_substs(local_ty, frame.instance.substs)?;\n+                    let local_ty = self.tcx.subst_and_normalize_erasing_regions(\n+                        frame.instance.substs,\n+                        self.param_env,\n+                        &local_ty,\n+                    );\n                     self.layout_of(local_ty)\n                 })?;\n                 if let Some(state) = frame.locals.get(local) {"}, {"sha": "7a545e8ad6f792abbee4190061bf46eed0ac56fd", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -522,7 +522,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Move(ref place) =>\n                 self.eval_place_to_op(place, layout)?,\n \n-            Constant(ref constant) => self.eval_const_to_op(constant.literal, layout)?,\n+            Constant(ref constant) => {\n+                let val = self.subst_from_frame_and_normalize_erasing_regions(constant.literal);\n+                self.eval_const_to_op(val, layout)?\n+            }\n         };\n         trace!(\"{:?}: {:?}\", mir_op, *op);\n         Ok(op)\n@@ -540,6 +543,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     // Used when the miri-engine runs into a constant and for extracting information from constants\n     // in patterns via the `const_eval` module\n+    /// The `val` and `layout` are assumed to already be in our interpreter\n+    /// \"universe\" (param_env).\n     crate fn eval_const_to_op(\n         &self,\n         val: &'tcx ty::Const<'tcx>,\n@@ -552,7 +557,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Early-return cases.\n         match val.val {\n             ConstValue::Param(_) =>\n-                // FIXME(oli-obk): try to monomorphize\n                 throw_inval!(TooGeneric),\n             ConstValue::Unevaluated(def_id, substs) => {\n                 let instance = self.resolve(def_id, substs)?;\n@@ -565,7 +569,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n         // Other cases need layout.\n         let layout = from_known_layout(layout, || {\n-            self.layout_of(self.monomorphize(val.ty)?)\n+            self.layout_of(val.ty)\n         })?;\n         let op = match val.val {\n             ConstValue::ByRef { alloc, offset } => {"}, {"sha": "85f9cbd37589ab2260f0d66211e44d5539759128", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -640,8 +640,11 @@ where\n                         // their layout on return.\n                         PlaceTy {\n                             place: *return_place,\n-                            layout: self\n-                                .layout_of(self.monomorphize(self.frame().body.return_ty())?)?,\n+                            layout: self.layout_of(\n+                                self.subst_from_frame_and_normalize_erasing_regions(\n+                                    self.frame().body.return_ty()\n+                                )\n+                            )?,\n                         }\n                     }\n                     None => throw_unsup!(InvalidNullPointerUsage),"}, {"sha": "ca4da451a1f2d58f9f57879c683073b107fcb980", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -254,7 +254,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n \n             NullaryOp(mir::NullOp::SizeOf, ty) => {\n-                let ty = self.monomorphize(ty)?;\n+                let ty = self.subst_from_frame_and_normalize_erasing_regions(ty);\n                 let layout = self.layout_of(ty)?;\n                 assert!(!layout.is_unsized(),\n                         \"SizeOf nullary MIR operator called for unsized type\");"}, {"sha": "a2fc75739ffa0ae34ffe672fb06c6c395a483fbf", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -1,4 +1,4 @@\n-use rustc::ty::{self, Ty, Instance};\n+use rustc::ty::{self, Ty, Instance, TypeFoldable};\n use rustc::ty::layout::{Size, Align, LayoutOf};\n use rustc::mir::interpret::{Scalar, Pointer, InterpResult, PointerArithmetic,};\n \n@@ -20,6 +20,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         let (ty, poly_trait_ref) = self.tcx.erase_regions(&(ty, poly_trait_ref));\n \n+        // All vtables must be monomorphic, bail out otherwise.\n+        if ty.needs_subst() || poly_trait_ref.needs_subst() {\n+            throw_inval!(TooGeneric);\n+        }\n+\n         if let Some(&vtable) = self.vtables.get(&(ty, poly_trait_ref)) {\n             // This means we guarantee that there are no duplicate vtables, we will\n             // always use the same vtable for the same (Type, Trait) combination.\n@@ -77,7 +82,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         for (i, method) in methods.iter().enumerate() {\n             if let Some((def_id, substs)) = *method {\n                 // resolve for vtable: insert shims where needed\n-                let substs = self.subst_and_normalize_erasing_regions(substs)?;\n                 let instance = ty::Instance::resolve_for_vtable(\n                     *self.tcx,\n                     self.param_env,"}, {"sha": "3e02f6c3725fdba6e48f359b88de5daea397a73c", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -708,7 +708,7 @@ fn build_call_shim<'tcx>(\n         Adjustment::DerefMove => {\n             // fn(Self, ...) -> fn(*mut Self, ...)\n             let arg_ty = local_decls[rcvr_arg].ty;\n-            assert!(arg_ty.is_self());\n+            debug_assert!(tcx.generics_of(def_id).has_self && arg_ty == tcx.types.self_param);\n             local_decls[rcvr_arg].ty = tcx.mk_mut_ptr(arg_ty);\n \n             Operand::Move(rcvr_l.deref())"}, {"sha": "1547e607b9c61a2842471530b9025d72e2195023", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -7,7 +7,7 @@ use rustc::ty::TyCtxt;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::Map;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use rustc::hir::{self, Node, Destination};\n+use rustc::hir::{self, Node, Destination, GeneratorMovability};\n use syntax::struct_span_err;\n use syntax_pos::Span;\n use errors::Applicability;\n@@ -17,6 +17,7 @@ enum Context {\n     Normal,\n     Loop(hir::LoopSource),\n     Closure,\n+    AsyncClosure,\n     LabeledBlock,\n     AnonConst,\n }\n@@ -57,9 +58,14 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n             hir::ExprKind::Loop(ref b, _, source) => {\n                 self.with_context(Loop(source), |v| v.visit_block(&b));\n             }\n-            hir::ExprKind::Closure(_, ref function_decl, b, _, _) => {\n+            hir::ExprKind::Closure(_, ref function_decl, b, _, movability) => {\n+                let cx = if let Some(GeneratorMovability::Static) = movability {\n+                    AsyncClosure\n+                } else {\n+                    Closure\n+                };\n                 self.visit_fn_decl(&function_decl);\n-                self.with_context(Closure, |v| v.visit_nested_body(b));\n+                self.with_context(cx, |v| v.visit_nested_body(b));\n             }\n             hir::ExprKind::Block(ref b, Some(_label)) => {\n                 self.with_context(LabeledBlock, |v| v.visit_block(&b));\n@@ -171,6 +177,11 @@ impl<'a, 'hir> CheckLoopVisitor<'a, 'hir> {\n                 .span_label(span, \"cannot break inside of a closure\")\n                 .emit();\n             }\n+            AsyncClosure => {\n+                struct_span_err!(self.sess, span, E0267, \"`{}` inside of an async block\", name)\n+                    .span_label(span, \"cannot break inside of an async block\")\n+                    .emit();\n+            }\n             Normal | AnonConst => {\n                 struct_span_err!(self.sess, span, E0268, \"`{}` outside of loop\", name)\n                 .span_label(span, \"cannot break outside of a loop\")"}, {"sha": "84a743ed1ad7d0d11752f3237463a4106a401dcf", "filename": "src/librustc_plugin/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_plugin%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_plugin%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2FCargo.toml?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -1,12 +1,12 @@\n [package]\n authors = [\"The Rust Project Developers\"]\n-name = \"rustc_plugin\"\n+name = \"rustc_plugin_impl\"\n version = \"0.0.0\"\n build = false\n edition = \"2018\"\n \n [lib]\n-name = \"rustc_plugin\"\n+name = \"rustc_plugin_impl\"\n path = \"lib.rs\"\n doctest = false\n "}, {"sha": "cc75f7b9ab20d1e8e20a20c3af6cd46539307554", "filename": "src/librustc_plugin/deprecated/Cargo.toml", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_plugin%2Fdeprecated%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_plugin%2Fdeprecated%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fdeprecated%2FCargo.toml?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -0,0 +1,14 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_plugin\"\n+version = \"0.0.0\"\n+build = false\n+edition = \"2018\"\n+\n+[lib]\n+name = \"rustc_plugin\"\n+path = \"lib.rs\"\n+doctest = false\n+\n+[dependencies]\n+rustc_plugin_impl = { path = \"..\" }"}, {"sha": "5fb18066759c638212258d4dce436f2a67849d3e", "filename": "src/librustc_plugin/deprecated/lib.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_plugin%2Fdeprecated%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_plugin%2Fdeprecated%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fdeprecated%2Flib.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -0,0 +1,8 @@\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![feature(staged_api)]\n+#![unstable(feature = \"rustc_plugin\", issue = \"29597\")]\n+#![rustc_deprecated(since = \"1.38.0\", reason = \"\\\n+    import this through `rustc_driver::plugin` instead to make TLS work correctly. \\\n+    See https://github.com/rust-lang/rust/issues/62717\")]\n+\n+pub use rustc_plugin_impl::*;"}, {"sha": "952bc9fff6a712dd436918856740606270066a18", "filename": "src/librustc_plugin/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_plugin%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_plugin%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Flib.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -16,12 +16,11 @@\n //! #![feature(plugin_registrar)]\n //! #![feature(rustc_private)]\n //!\n-//! extern crate rustc_plugin;\n //! extern crate rustc_driver;\n //! extern crate syntax;\n //! extern crate syntax_pos;\n //!\n-//! use rustc_plugin::Registry;\n+//! use rustc_driver::plugin::Registry;\n //! use syntax::ext::base::{ExtCtxt, MacResult};\n //! use syntax_pos::Span;\n //! use syntax::tokenstream::TokenTree;"}, {"sha": "9e52eae88ef45fbdf411a0ad5794b59dad58f42e", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -635,8 +635,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         });\n         let default_needs_object_self = |param: &ty::GenericParamDef| {\n             if let GenericParamDefKind::Type { has_default, .. } = param.kind {\n-                if is_object && has_default {\n-                    if tcx.at(span).type_of(param.def_id).has_self_ty() {\n+                if is_object && has_default && has_self {\n+                    let self_param = tcx.types.self_param;\n+                    if tcx.at(span).type_of(param.def_id).walk().any(|ty| ty == self_param) {\n                         // There is no suitable inference default for a type parameter\n                         // that references self, in an object type.\n                         return true;\n@@ -2030,7 +2031,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // `Self` in trait or type alias.\n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_generics(&path.segments);\n-                tcx.mk_self_type()\n+                tcx.types.self_param\n             }\n             Res::SelfTy(_, Some(def_id)) => {\n                 // `Self` in impl (we know the concrete type)."}, {"sha": "fc25eb44cbd888888c1b01b47622e16472754230", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -53,6 +53,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let is_non_ref_pat = match pat.node {\n             PatKind::Struct(..) |\n             PatKind::TupleStruct(..) |\n+            PatKind::Or(_) |\n             PatKind::Tuple(..) |\n             PatKind::Box(_) |\n             PatKind::Range(..) |\n@@ -309,6 +310,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             PatKind::Struct(ref qpath, ref fields, etc) => {\n                 self.check_pat_struct(pat, qpath, fields, etc, expected, def_bm, discrim_span)\n             }\n+            PatKind::Or(ref pats) => {\n+                let expected_ty = self.structurally_resolved_type(pat.span, expected);\n+                for pat in pats {\n+                    self.check_pat_walk(pat, expected, def_bm, discrim_span);\n+                }\n+                expected_ty\n+            }\n             PatKind::Tuple(ref elements, ddpos) => {\n                 let mut expected_len = elements.len();\n                 if ddpos.is_some() {"}, {"sha": "8e187b7e05b51ab0e10a0b7729be4ce1b947cd57", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -518,7 +518,7 @@ fn compare_self_type<'tcx>(\n     let self_string = |method: &ty::AssocItem| {\n         let untransformed_self_ty = match method.container {\n             ty::ImplContainer(_) => impl_trait_ref.self_ty(),\n-            ty::TraitContainer(_) => tcx.mk_self_type()\n+            ty::TraitContainer(_) => tcx.types.self_param\n         };\n         let self_arg_ty = *tcx.fn_sig(method.def_id).input(0).skip_binder();\n         let param_env = ty::ParamEnv::reveal_all();"}, {"sha": "9c6ea7d30ccf980830c33f22f9815c02cbd5a521", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -191,7 +191,7 @@ fn check_associated_item(\n         let item = fcx.tcx.associated_item(fcx.tcx.hir().local_def_id(item_id));\n \n         let (mut implied_bounds, self_ty) = match item.container {\n-            ty::TraitContainer(_) => (vec![], fcx.tcx.mk_self_type()),\n+            ty::TraitContainer(_) => (vec![], fcx.tcx.types.self_param),\n             ty::ImplContainer(def_id) => (fcx.impl_implied_bounds(def_id, span),\n                                           fcx.tcx.type_of(def_id))\n         };"}, {"sha": "312a598af02bf20962c6a67e6abe8f725afec00f", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -716,7 +716,7 @@ fn super_predicates_of(\n     let icx = ItemCtxt::new(tcx, trait_def_id);\n \n     // Convert the bounds that follow the colon, e.g., `Bar + Zed` in `trait Foo: Bar + Zed`.\n-    let self_param_ty = tcx.mk_self_type();\n+    let self_param_ty = tcx.types.self_param;\n     let superbounds1 = AstConv::compute_bounds(&icx, self_param_ty, bounds, SizedByDefault::No,\n         item.span);\n \n@@ -900,6 +900,20 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n             let parent_id = tcx.hir().get_parent_item(hir_id);\n             Some(tcx.hir().local_def_id(parent_id))\n         }\n+        // FIXME(#43408) enable this in all cases when we get lazy normalization.\n+        Node::AnonConst(&anon_const) => {\n+            // HACK(eddyb) this provides the correct generics when the workaround\n+            // for a const parameter `AnonConst` is being used elsewhere, as then\n+            // there won't be the kind of cyclic dependency blocking #43408.\n+            let expr = &tcx.hir().body(anon_const.body).value;\n+            let icx = ItemCtxt::new(tcx, def_id);\n+            if AstConv::const_param_def_id(&icx, expr).is_some() {\n+                let parent_id = tcx.hir().get_parent_item(hir_id);\n+                Some(tcx.hir().local_def_id(parent_id))\n+            } else {\n+                None\n+            }\n+        }\n         Node::Expr(&hir::Expr {\n             node: hir::ExprKind::Closure(..),\n             ..\n@@ -1014,13 +1028,6 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n                         synthetic,\n                         ..\n                     } => {\n-                        if param.name.ident().name == kw::SelfUpper {\n-                            span_bug!(\n-                                param.span,\n-                                \"`Self` should not be the name of a regular parameter\"\n-                            );\n-                        }\n-\n                         if !allow_defaults && default.is_some() {\n                             if !tcx.features().default_type_parameter_fallback {\n                                 tcx.lint_hir(\n@@ -1044,13 +1051,6 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n                         }\n                     }\n                     GenericParamKind::Const { .. } => {\n-                        if param.name.ident().name == kw::SelfUpper {\n-                            span_bug!(\n-                                param.span,\n-                                \"`Self` should not be the name of a regular parameter\",\n-                            );\n-                        }\n-\n                         ty::GenericParamDefKind::Const\n                     }\n                     _ => return None,\n@@ -1567,7 +1567,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                                     &format!(\n                                         \"defining opaque type use restricts opaque \\\n                                          type by using the generic parameter `{}` twice\",\n-                                        p.name\n+                                        p,\n                                     ),\n                                 );\n                                 return;"}, {"sha": "644d723ded5d96e60a3369ea7fb4d6aff0ac114a", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -3,7 +3,6 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::ty::subst::{Kind, Subst, UnpackedKind};\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::fold::TypeFoldable;\n use rustc::util::nodemap::FxHashMap;\n \n use super::explicit::ExplicitPredicatesMap;\n@@ -178,11 +177,11 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                 // let _: () = substs.region_at(0);\n                 check_explicit_predicates(\n                     tcx,\n-                    &def.did,\n+                    def.did,\n                     substs,\n                     required_predicates,\n                     explicit_map,\n-                    IgnoreSelfTy(false),\n+                    None,\n                 );\n             }\n \n@@ -208,11 +207,11 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                         .substs;\n                     check_explicit_predicates(\n                         tcx,\n-                        &ex_trait_ref.skip_binder().def_id,\n+                        ex_trait_ref.skip_binder().def_id,\n                         substs,\n                         required_predicates,\n                         explicit_map,\n-                        IgnoreSelfTy(true),\n+                        Some(tcx.types.self_param),\n                     );\n                 }\n             }\n@@ -223,11 +222,11 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                 debug!(\"Projection\");\n                 check_explicit_predicates(\n                     tcx,\n-                    &tcx.associated_item(obj.item_def_id).container.id(),\n+                    tcx.associated_item(obj.item_def_id).container.id(),\n                     obj.substs,\n                     required_predicates,\n                     explicit_map,\n-                    IgnoreSelfTy(false),\n+                    None,\n                 );\n             }\n \n@@ -236,9 +235,6 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n     }\n }\n \n-#[derive(Debug)]\n-pub struct IgnoreSelfTy(bool);\n-\n /// We also have to check the explicit predicates\n /// declared on the type.\n ///\n@@ -256,25 +252,25 @@ pub struct IgnoreSelfTy(bool);\n /// applying the substitution as above.\n pub fn check_explicit_predicates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    def_id: &DefId,\n+    def_id: DefId,\n     substs: &[Kind<'tcx>],\n     required_predicates: &mut RequiredPredicates<'tcx>,\n     explicit_map: &mut ExplicitPredicatesMap<'tcx>,\n-    ignore_self_ty: IgnoreSelfTy,\n+    ignored_self_ty: Option<Ty<'tcx>>,\n ) {\n     debug!(\n         \"check_explicit_predicates(def_id={:?}, \\\n          substs={:?}, \\\n          explicit_map={:?}, \\\n          required_predicates={:?}, \\\n-         ignore_self_ty={:?})\",\n+         ignored_self_ty={:?})\",\n         def_id,\n         substs,\n         explicit_map,\n         required_predicates,\n-        ignore_self_ty,\n+        ignored_self_ty,\n     );\n-    let explicit_predicates = explicit_map.explicit_predicates_of(tcx, *def_id);\n+    let explicit_predicates = explicit_map.explicit_predicates_of(tcx, def_id);\n \n     for outlives_predicate in explicit_predicates.iter() {\n         debug!(\"outlives_predicate = {:?}\", &outlives_predicate);\n@@ -313,9 +309,9 @@ pub fn check_explicit_predicates<'tcx>(\n         // = X` binding from the object type (there must be such a\n         // binding) and thus infer an outlives requirement that `X:\n         // 'b`.\n-        if ignore_self_ty.0 {\n+        if let Some(self_ty) = ignored_self_ty {\n             if let UnpackedKind::Type(ty) = outlives_predicate.0.unpack() {\n-                if ty.has_self_ty() {\n+                if ty.walk().any(|ty| ty == self_ty) {\n                     debug!(\"skipping self ty = {:?}\", &ty);\n                     continue;\n                 }"}, {"sha": "9b4803ce41e290718ebb9ef7a609b4cccf5a7564", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -2303,7 +2303,7 @@ impl Clean<Item> for ty::AssocItem {\n                         ty::ImplContainer(def_id) => {\n                             cx.tcx.type_of(def_id)\n                         }\n-                        ty::TraitContainer(_) => cx.tcx.mk_self_type()\n+                        ty::TraitContainer(_) => cx.tcx.types.self_param,\n                     };\n                     let self_arg_ty = *sig.input(0).skip_binder();\n                     if self_arg_ty == self_ty {\n@@ -4107,6 +4107,9 @@ fn name_from_pat(p: &hir::Pat) -> String {\n                 if etc { \", ..\" } else { \"\" }\n             )\n         }\n+        PatKind::Or(ref pats) => {\n+            pats.iter().map(|p| name_from_pat(&**p)).collect::<Vec<String>>().join(\" | \")\n+        }\n         PatKind::Tuple(ref elts, _) => format!(\"({})\", elts.iter().map(|p| name_from_pat(&**p))\n                                             .collect::<Vec<String>>().join(\", \")),\n         PatKind::Box(ref p) => name_from_pat(&**p),"}, {"sha": "3801c42307fc6f00099bfb01217c258dfa809dda", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -149,9 +149,11 @@ fn trait_is_same_or_supertrait(cx: &DocContext<'_>, child: DefId,\n         return true\n     }\n     let predicates = cx.tcx.super_predicates_of(child);\n+    debug_assert!(cx.tcx.generics_of(child).has_self);\n+    let self_ty = cx.tcx.types.self_param;\n     predicates.predicates.iter().filter_map(|(pred, _)| {\n         if let ty::Predicate::Trait(ref pred) = *pred {\n-            if pred.skip_binder().trait_ref.self_ty().is_self() {\n+            if pred.skip_binder().trait_ref.self_ty() == self_ty {\n                 Some(pred.def_id())\n             } else {\n                 None"}, {"sha": "bb77a5bdea493e1eb2d820e6fe5824981dbca4a6", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -26,7 +26,7 @@ unwind = { path = \"../libunwind\" }\n hashbrown = { version = \"0.5.0\", features = ['rustc-dep-of-std'] }\n \n [dependencies.backtrace]\n-version = \"0.3.34\"\n+version = \"0.3.35\"\n default-features = false # don't use coresymbolication on OSX\n features = [\n   \"rustc-dep-of-std\", # enable build support for integrating into libstd"}, {"sha": "ba797354a7380f30935297b4dcf3110571e51f6d", "filename": "src/libstd/sys/vxworks/process/process_common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -155,7 +155,7 @@ impl Command {\n         _f: Box<dyn FnMut() -> io::Result<()> + Send + Sync>,\n     ) {\n         // Fork() is not supported in vxWorks so no way to run the closure in the new procecss.\n-        unimplemented!();;\n+        unimplemented!();\n     }\n \n     pub fn stdin(&mut self, stdin: Stdio) {"}, {"sha": "50e428ea0cca6ce1702303a1453033182e5a6922", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -572,9 +572,10 @@ impl Pat {\n         match &self.node {\n             PatKind::Ident(_, _, Some(p)) => p.walk(it),\n             PatKind::Struct(_, fields, _) => fields.iter().all(|field| field.pat.walk(it)),\n-            PatKind::TupleStruct(_, s) | PatKind::Tuple(s) | PatKind::Slice(s) => {\n-                s.iter().all(|p| p.walk(it))\n-            }\n+            PatKind::TupleStruct(_, s)\n+            | PatKind::Tuple(s)\n+            | PatKind::Slice(s)\n+            | PatKind::Or(s) => s.iter().all(|p| p.walk(it)),\n             PatKind::Box(s) | PatKind::Ref(s, _) | PatKind::Paren(s) => s.walk(it),\n             PatKind::Wild\n             | PatKind::Rest\n@@ -648,6 +649,10 @@ pub enum PatKind {\n     /// A tuple struct/variant pattern (`Variant(x, y, .., z)`).\n     TupleStruct(Path, Vec<P<Pat>>),\n \n+    /// An or-pattern `A | B | C`.\n+    /// Invariant: `pats.len() >= 2`.\n+    Or(Vec<P<Pat>>),\n+\n     /// A possibly qualified path pattern.\n     /// Unqualified path patterns `A::B::C` can legally refer to variants, structs, constants\n     /// or associated constants. Qualified path patterns `<A>::B::C`/`<A as Trait>::B::C` can"}, {"sha": "bbc3ae28225587491bc700aa5633de2eb25736d8", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -559,6 +559,9 @@ declare_features! (\n     // Allows `impl Trait` to be used inside type aliases (RFC 2515).\n     (active, type_alias_impl_trait, \"1.38.0\", Some(63063), None),\n \n+    // Allows the use of or-patterns, e.g. `0 | 1`.\n+    (active, or_patterns, \"1.38.0\", Some(54883), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------\n@@ -571,6 +574,7 @@ pub const INCOMPLETE_FEATURES: &[Symbol] = &[\n     sym::impl_trait_in_bindings,\n     sym::generic_associated_types,\n     sym::const_generics,\n+    sym::or_patterns,\n     sym::let_chains,\n ];\n \n@@ -2443,6 +2447,7 @@ pub fn check_crate(krate: &ast::Crate,\n     gate_all!(let_chains_spans, let_chains, \"`let` expressions in this position are experimental\");\n     gate_all!(async_closure_spans, async_closure, \"async closures are unstable\");\n     gate_all!(yield_spans, generators, \"yield syntax is experimental\");\n+    gate_all!(or_pattern_spans, or_patterns, \"or-patterns syntax is experimental\");\n \n     let visitor = &mut PostExpansionVisitor {\n         context: &ctx,"}, {"sha": "9785f8e2de0980e2f4e5ebe9e3f95226d33da5c9", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -1050,15 +1050,16 @@ pub fn noop_visit_pat<T: MutVisitor>(pat: &mut P<Pat>, vis: &mut T) {\n                 vis.visit_span(span);\n             };\n         }\n-        PatKind::Tuple(elems) => visit_vec(elems, |elem| vis.visit_pat(elem)),\n         PatKind::Box(inner) => vis.visit_pat(inner),\n         PatKind::Ref(inner, _mutbl) => vis.visit_pat(inner),\n         PatKind::Range(e1, e2, Spanned { span: _, node: _ }) => {\n             vis.visit_expr(e1);\n             vis.visit_expr(e2);\n             vis.visit_span(span);\n         }\n-        PatKind::Slice(elems) => visit_vec(elems, |elem| vis.visit_pat(elem)),\n+        PatKind::Tuple(elems)\n+        | PatKind::Slice(elems)\n+        | PatKind::Or(elems) => visit_vec(elems, |elem| vis.visit_pat(elem)),\n         PatKind::Paren(inner) => vis.visit_pat(inner),\n         PatKind::Mac(mac) => vis.visit_mac(mac),\n     }"}, {"sha": "66add869359d800f030ddf5308351f3b794fb87c", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 15, "deletions": 91, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -8,9 +8,7 @@ use syntax_pos::{BytePos, Pos, Span};\n use rustc_lexer::Base;\n use rustc_lexer::unescape;\n \n-use std::borrow::Cow;\n use std::char;\n-use std::iter;\n use std::convert::TryInto;\n use rustc_data_structures::sync::Lrc;\n use log::debug;\n@@ -181,18 +179,7 @@ impl<'a> StringReader<'a> {\n                 let string = self.str_from(start);\n                 // comments with only more \"/\"s are not doc comments\n                 let tok = if is_doc_comment(string) {\n-                    let mut idx = 0;\n-                    loop {\n-                        idx = match string[idx..].find('\\r') {\n-                            None => break,\n-                            Some(it) => idx + it + 1\n-                        };\n-                        if string[idx..].chars().next() != Some('\\n') {\n-                            self.err_span_(start + BytePos(idx as u32 - 1),\n-                                            start + BytePos(idx as u32),\n-                                            \"bare CR not allowed in doc-comment\");\n-                        }\n-                    }\n+                    self.forbid_bare_cr(start, string, \"bare CR not allowed in doc-comment\");\n                     token::DocComment(Symbol::intern(string))\n                 } else {\n                     token::Comment\n@@ -217,15 +204,10 @@ impl<'a> StringReader<'a> {\n                 }\n \n                 let tok = if is_doc_comment {\n-                    let has_cr = string.contains('\\r');\n-                    let string = if has_cr {\n-                        self.translate_crlf(start,\n-                                            string,\n-                                            \"bare CR not allowed in block doc-comment\")\n-                    } else {\n-                        string.into()\n-                    };\n-                    token::DocComment(Symbol::intern(&string[..]))\n+                    self.forbid_bare_cr(start,\n+                                        string,\n+                                        \"bare CR not allowed in block doc-comment\");\n+                    token::DocComment(Symbol::intern(string))\n                 } else {\n                     token::Comment\n                 };\n@@ -291,9 +273,6 @@ impl<'a> StringReader<'a> {\n             }\n             rustc_lexer::TokenKind::Semi => token::Semi,\n             rustc_lexer::TokenKind::Comma => token::Comma,\n-            rustc_lexer::TokenKind::DotDotDot => token::DotDotDot,\n-            rustc_lexer::TokenKind::DotDotEq => token::DotDotEq,\n-            rustc_lexer::TokenKind::DotDot => token::DotDot,\n             rustc_lexer::TokenKind::Dot => token::Dot,\n             rustc_lexer::TokenKind::OpenParen => token::OpenDelim(token::Paren),\n             rustc_lexer::TokenKind::CloseParen => token::CloseDelim(token::Paren),\n@@ -305,42 +284,20 @@ impl<'a> StringReader<'a> {\n             rustc_lexer::TokenKind::Pound => token::Pound,\n             rustc_lexer::TokenKind::Tilde => token::Tilde,\n             rustc_lexer::TokenKind::Question => token::Question,\n-            rustc_lexer::TokenKind::ColonColon => token::ModSep,\n             rustc_lexer::TokenKind::Colon => token::Colon,\n             rustc_lexer::TokenKind::Dollar => token::Dollar,\n-            rustc_lexer::TokenKind::EqEq => token::EqEq,\n             rustc_lexer::TokenKind::Eq => token::Eq,\n-            rustc_lexer::TokenKind::FatArrow => token::FatArrow,\n-            rustc_lexer::TokenKind::Ne => token::Ne,\n             rustc_lexer::TokenKind::Not => token::Not,\n-            rustc_lexer::TokenKind::Le => token::Le,\n-            rustc_lexer::TokenKind::LArrow => token::LArrow,\n             rustc_lexer::TokenKind::Lt => token::Lt,\n-            rustc_lexer::TokenKind::ShlEq => token::BinOpEq(token::Shl),\n-            rustc_lexer::TokenKind::Shl => token::BinOp(token::Shl),\n-            rustc_lexer::TokenKind::Ge => token::Ge,\n             rustc_lexer::TokenKind::Gt => token::Gt,\n-            rustc_lexer::TokenKind::ShrEq => token::BinOpEq(token::Shr),\n-            rustc_lexer::TokenKind::Shr => token::BinOp(token::Shr),\n-            rustc_lexer::TokenKind::RArrow => token::RArrow,\n             rustc_lexer::TokenKind::Minus => token::BinOp(token::Minus),\n-            rustc_lexer::TokenKind::MinusEq => token::BinOpEq(token::Minus),\n             rustc_lexer::TokenKind::And => token::BinOp(token::And),\n-            rustc_lexer::TokenKind::AndEq => token::BinOpEq(token::And),\n-            rustc_lexer::TokenKind::AndAnd => token::AndAnd,\n             rustc_lexer::TokenKind::Or => token::BinOp(token::Or),\n-            rustc_lexer::TokenKind::OrEq => token::BinOpEq(token::Or),\n-            rustc_lexer::TokenKind::OrOr => token::OrOr,\n             rustc_lexer::TokenKind::Plus => token::BinOp(token::Plus),\n-            rustc_lexer::TokenKind::PlusEq => token::BinOpEq(token::Plus),\n             rustc_lexer::TokenKind::Star => token::BinOp(token::Star),\n-            rustc_lexer::TokenKind::StarEq => token::BinOpEq(token::Star),\n             rustc_lexer::TokenKind::Slash => token::BinOp(token::Slash),\n-            rustc_lexer::TokenKind::SlashEq => token::BinOpEq(token::Slash),\n             rustc_lexer::TokenKind::Caret => token::BinOp(token::Caret),\n-            rustc_lexer::TokenKind::CaretEq => token::BinOpEq(token::Caret),\n             rustc_lexer::TokenKind::Percent => token::BinOp(token::Percent),\n-            rustc_lexer::TokenKind::PercentEq => token::BinOpEq(token::Percent),\n \n             rustc_lexer::TokenKind::Unknown => {\n                 let c = self.str_from(start).chars().next().unwrap();\n@@ -516,49 +473,16 @@ impl<'a> StringReader<'a> {\n         &self.src[self.src_index(start)..self.src_index(end)]\n     }\n \n-    /// Converts CRLF to LF in the given string, raising an error on bare CR.\n-    fn translate_crlf<'b>(&self, start: BytePos, s: &'b str, errmsg: &'b str) -> Cow<'b, str> {\n-        let mut chars = s.char_indices().peekable();\n-        while let Some((i, ch)) = chars.next() {\n-            if ch == '\\r' {\n-                if let Some((lf_idx, '\\n')) = chars.peek() {\n-                    return translate_crlf_(self, start, s, *lf_idx, chars, errmsg).into();\n-                }\n-                let pos = start + BytePos(i as u32);\n-                let end_pos = start + BytePos((i + ch.len_utf8()) as u32);\n-                self.err_span_(pos, end_pos, errmsg);\n-            }\n-        }\n-        return s.into();\n-\n-        fn translate_crlf_(rdr: &StringReader<'_>,\n-                           start: BytePos,\n-                           s: &str,\n-                           mut j: usize,\n-                           mut chars: iter::Peekable<impl Iterator<Item = (usize, char)>>,\n-                           errmsg: &str)\n-                           -> String {\n-            let mut buf = String::with_capacity(s.len());\n-            // Skip first CR\n-            buf.push_str(&s[.. j - 1]);\n-            while let Some((i, ch)) = chars.next() {\n-                if ch == '\\r' {\n-                    if j < i {\n-                        buf.push_str(&s[j..i]);\n-                    }\n-                    let next = i + ch.len_utf8();\n-                    j = next;\n-                    if chars.peek().map(|(_, ch)| *ch) != Some('\\n') {\n-                        let pos = start + BytePos(i as u32);\n-                        let end_pos = start + BytePos(next as u32);\n-                        rdr.err_span_(pos, end_pos, errmsg);\n-                    }\n-                }\n-            }\n-            if j < s.len() {\n-                buf.push_str(&s[j..]);\n-            }\n-            buf\n+    fn forbid_bare_cr(&self, start: BytePos, s: &str, errmsg: &str) {\n+        let mut idx = 0;\n+        loop {\n+            idx = match s[idx..].find('\\r') {\n+                None => break,\n+                Some(it) => idx + it + 1\n+            };\n+            self.err_span_(start + BytePos(idx as u32 - 1),\n+                           start + BytePos(idx as u32),\n+                           errmsg);\n         }\n     }\n "}, {"sha": "a915aa42fd15ab2da80ed65d109b697f50c2e204", "filename": "src/libsyntax/parse/lexer/tests.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibsyntax%2Fparse%2Flexer%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibsyntax%2Fparse%2Flexer%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Ftests.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -75,42 +75,50 @@ fn mk_lit(kind: token::LitKind, symbol: &str, suffix: Option<&str>) -> TokenKind\n }\n \n #[test]\n-fn doublecolonparsing() {\n+fn doublecolon_parsing() {\n     with_default_globals(|| {\n         let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(sm.clone());\n-        check_tokenization(setup(&sm, &sh, \"a b\".to_string()),\n-                        vec![mk_ident(\"a\"), token::Whitespace, mk_ident(\"b\")]);\n+        check_tokenization(\n+            setup(&sm, &sh, \"a b\".to_string()),\n+            vec![mk_ident(\"a\"), token::Whitespace, mk_ident(\"b\")],\n+        );\n     })\n }\n \n #[test]\n-fn dcparsing_2() {\n+fn doublecolon_parsing_2() {\n     with_default_globals(|| {\n         let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(sm.clone());\n-        check_tokenization(setup(&sm, &sh, \"a::b\".to_string()),\n-                        vec![mk_ident(\"a\"), token::ModSep, mk_ident(\"b\")]);\n+        check_tokenization(\n+            setup(&sm, &sh, \"a::b\".to_string()),\n+            vec![mk_ident(\"a\"), token::Colon, token::Colon, mk_ident(\"b\")],\n+        );\n     })\n }\n \n #[test]\n-fn dcparsing_3() {\n+fn doublecolon_parsing_3() {\n     with_default_globals(|| {\n         let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(sm.clone());\n-        check_tokenization(setup(&sm, &sh, \"a ::b\".to_string()),\n-                        vec![mk_ident(\"a\"), token::Whitespace, token::ModSep, mk_ident(\"b\")]);\n+        check_tokenization(\n+            setup(&sm, &sh, \"a ::b\".to_string()),\n+            vec![mk_ident(\"a\"), token::Whitespace, token::Colon, token::Colon, mk_ident(\"b\")],\n+        );\n     })\n }\n \n #[test]\n-fn dcparsing_4() {\n+fn doublecolon_parsing_4() {\n     with_default_globals(|| {\n         let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(sm.clone());\n-        check_tokenization(setup(&sm, &sh, \"a:: b\".to_string()),\n-                        vec![mk_ident(\"a\"), token::ModSep, token::Whitespace, mk_ident(\"b\")]);\n+        check_tokenization(\n+            setup(&sm, &sh, \"a:: b\".to_string()),\n+            vec![mk_ident(\"a\"), token::Colon, token::Colon, token::Whitespace, mk_ident(\"b\")],\n+        );\n     })\n }\n "}, {"sha": "e5ba7e45309dda964ca6e42699720070e00a49b6", "filename": "src/libsyntax/parse/lexer/tokentrees.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -39,29 +39,29 @@ struct TokenTreesReader<'a> {\n impl<'a> TokenTreesReader<'a> {\n     // Parse a stream of tokens into a list of `TokenTree`s, up to an `Eof`.\n     fn parse_all_token_trees(&mut self) -> PResult<'a, TokenStream> {\n-        let mut tts = Vec::new();\n+        let mut buf = TokenStreamBuilder::default();\n \n         self.real_token();\n         while self.token != token::Eof {\n-            tts.push(self.parse_token_tree()?);\n+            buf.push(self.parse_token_tree()?);\n         }\n \n-        Ok(TokenStream::new(tts))\n+        Ok(buf.into_token_stream())\n     }\n \n     // Parse a stream of tokens into a list of `TokenTree`s, up to a `CloseDelim`.\n     fn parse_token_trees_until_close_delim(&mut self) -> TokenStream {\n-        let mut tts = vec![];\n+        let mut buf = TokenStreamBuilder::default();\n         loop {\n             if let token::CloseDelim(..) = self.token.kind {\n-                return TokenStream::new(tts);\n+                return buf.into_token_stream();\n             }\n \n             match self.parse_token_tree() {\n-                Ok(tree) => tts.push(tree),\n+                Ok(tree) => buf.push(tree),\n                 Err(mut e) => {\n                     e.emit();\n-                    return TokenStream::new(tts);\n+                    return buf.into_token_stream();\n                 }\n             }\n         }\n@@ -223,8 +223,32 @@ impl<'a> TokenTreesReader<'a> {\n                 _ => {\n                     self.token = token;\n                     return;\n-                },\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Default)]\n+struct TokenStreamBuilder {\n+    buf: Vec<TreeAndJoint>,\n+}\n+\n+impl TokenStreamBuilder {\n+    fn push(&mut self, (tree, joint): TreeAndJoint) {\n+        if let Some((TokenTree::Token(prev_token), Joint)) = self.buf.last() {\n+            if let TokenTree::Token(token) = &tree {\n+                if let Some(glued) = prev_token.glue(token) {\n+                    self.buf.pop();\n+                    self.buf.push((TokenTree::Token(glued), joint));\n+                    return;\n+                }\n             }\n         }\n+        self.buf.push((tree, joint))\n+    }\n+\n+    fn into_token_stream(self) -> TokenStream {\n+        TokenStream::new(self.buf)\n     }\n }"}, {"sha": "b1f3612a839a2cb41bbe106053a9187257ef7ae6", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -66,6 +66,8 @@ pub struct ParseSess {\n     // Places where `yield e?` exprs were used and should be feature gated.\n     pub yield_spans: Lock<Vec<Span>>,\n     pub injected_crate_name: Once<Symbol>,\n+    // Places where or-patterns e.g. `Some(Foo | Bar)` were used and should be feature gated.\n+    pub or_pattern_spans: Lock<Vec<Span>>,\n }\n \n impl ParseSess {\n@@ -96,6 +98,7 @@ impl ParseSess {\n             async_closure_spans: Lock::new(Vec::new()),\n             yield_spans: Lock::new(Vec::new()),\n             injected_crate_name: Once::new(),\n+            or_pattern_spans: Lock::new(Vec::new()),\n         }\n     }\n "}, {"sha": "fd458aec743315792463c1e3d0024734b6d3a5a3", "filename": "src/libsyntax/parse/parser/pat.rs", "status": "modified", "additions": 37, "deletions": 4, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -14,7 +14,10 @@ use errors::{Applicability, DiagnosticBuilder};\n \n impl<'a> Parser<'a> {\n     /// Parses a pattern.\n-    pub fn parse_pat(&mut self, expected: Option<&'static str>) -> PResult<'a, P<Pat>> {\n+    pub fn parse_pat(\n+        &mut self,\n+        expected: Option<&'static str>\n+    ) -> PResult<'a, P<Pat>> {\n         self.parse_pat_with_range_pat(true, expected)\n     }\n \n@@ -97,6 +100,34 @@ impl<'a> Parser<'a> {\n         Ok(())\n     }\n \n+    /// Parses a pattern, that may be a or-pattern (e.g. `Some(Foo | Bar)`).\n+    fn parse_pat_with_or(&mut self, expected: Option<&'static str>) -> PResult<'a, P<Pat>> {\n+        // Parse the first pattern.\n+        let first_pat = self.parse_pat(expected)?;\n+\n+        // If the next token is not a `|`, this is not an or-pattern and\n+        // we should exit here.\n+        if !self.check(&token::BinOp(token::Or)) {\n+            return Ok(first_pat)\n+        }\n+\n+        let lo = first_pat.span;\n+\n+        let mut pats = vec![first_pat];\n+\n+        while self.eat(&token::BinOp(token::Or)) {\n+            pats.push(self.parse_pat_with_range_pat(\n+                true, expected\n+            )?);\n+        }\n+\n+        let or_pattern_span = lo.to(self.prev_span);\n+\n+        self.sess.or_pattern_spans.borrow_mut().push(or_pattern_span);\n+\n+        Ok(self.mk_pat(or_pattern_span, PatKind::Or(pats)))\n+    }\n+\n     /// Parses a pattern, with a setting whether modern range patterns (e.g., `a..=b`, `a..b` are\n     /// allowed).\n     fn parse_pat_with_range_pat(\n@@ -240,7 +271,9 @@ impl<'a> Parser<'a> {\n \n     /// Parse a tuple or parenthesis pattern.\n     fn parse_pat_tuple_or_parens(&mut self) -> PResult<'a, PatKind> {\n-        let (fields, trailing_comma) = self.parse_paren_comma_seq(|p| p.parse_pat(None))?;\n+        let (fields, trailing_comma) = self.parse_paren_comma_seq(|p| {\n+            p.parse_pat_with_or(None)\n+        })?;\n \n         // Here, `(pat,)` is a tuple pattern.\n         // For backward compatibility, `(..)` is a tuple pattern as well.\n@@ -483,7 +516,7 @@ impl<'a> Parser<'a> {\n             err.span_label(self.token.span, msg);\n             return Err(err);\n         }\n-        let (fields, _) = self.parse_paren_comma_seq(|p| p.parse_pat(None))?;\n+        let (fields, _) = self.parse_paren_comma_seq(|p| p.parse_pat_with_or(None))?;\n         Ok(PatKind::TupleStruct(path, fields))\n     }\n \n@@ -627,7 +660,7 @@ impl<'a> Parser<'a> {\n             // Parsing a pattern of the form \"fieldname: pat\"\n             let fieldname = self.parse_field_name()?;\n             self.bump();\n-            let pat = self.parse_pat(None)?;\n+            let pat = self.parse_pat_with_or(None)?;\n             hi = pat.span;\n             (pat, fieldname, false)\n         } else {"}, {"sha": "1865f925165bdaeb64d916d7793991ec215afe5e", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -551,7 +551,7 @@ impl Token {\n         }\n     }\n \n-    crate fn glue(self, joint: Token) -> Option<Token> {\n+    crate fn glue(&self, joint: &Token) -> Option<Token> {\n         let kind = match self.kind {\n             Eq => match joint.kind {\n                 Eq => EqEq,"}, {"sha": "4dc00af486013c6973958a3d3eac9d9618eb1afa", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -436,18 +436,30 @@ pub trait PrintState<'a>: std::ops::Deref<Target=pp::Printer> + std::ops::DerefM\n     fn print_ident(&mut self, ident: ast::Ident);\n     fn print_generic_args(&mut self, args: &ast::GenericArgs, colons_before_params: bool);\n \n-    fn commasep<T, F>(&mut self, b: Breaks, elts: &[T], mut op: F)\n+    fn strsep<T, F>(&mut self, sep: &'static str, space_before: bool,\n+                    b: Breaks, elts: &[T], mut op: F)\n         where F: FnMut(&mut Self, &T),\n     {\n         self.rbox(0, b);\n-        let mut first = true;\n-        for elt in elts {\n-            if first { first = false; } else { self.word_space(\",\"); }\n-            op(self, elt);\n+        if let Some((first, rest)) = elts.split_first() {\n+            op(self, first);\n+            for elt in rest {\n+                if space_before {\n+                    self.space();\n+                }\n+                self.word_space(sep);\n+                op(self, elt);\n+            }\n         }\n         self.end();\n     }\n \n+    fn commasep<T, F>(&mut self, b: Breaks, elts: &[T], op: F)\n+        where F: FnMut(&mut Self, &T),\n+    {\n+        self.strsep(\",\", false, b, elts, op)\n+    }\n+\n     fn maybe_print_comment(&mut self, pos: BytePos) {\n         while let Some(ref cmnt) = self.next_comment() {\n             if cmnt.pos < pos {\n@@ -2353,6 +2365,9 @@ impl<'a> State<'a> {\n                 self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(p));\n                 self.pclose();\n             }\n+            PatKind::Or(ref pats) => {\n+                self.strsep(\"|\", true, Inconsistent, &pats[..], |s, p| s.print_pat(p));\n+            }\n             PatKind::Path(None, ref path) => {\n                 self.print_path(path, true, 0);\n             }\n@@ -2429,16 +2444,7 @@ impl<'a> State<'a> {\n     }\n \n     fn print_pats(&mut self, pats: &[P<ast::Pat>]) {\n-        let mut first = true;\n-        for p in pats {\n-            if first {\n-                first = false;\n-            } else {\n-                self.s.space();\n-                self.word_space(\"|\");\n-            }\n-            self.print_pat(p);\n-        }\n+        self.strsep(\"|\", true, Inconsistent, pats, |s, p| s.print_pat(p));\n     }\n \n     fn print_arm(&mut self, arm: &ast::Arm) {"}, {"sha": "09a1b93c7bb195819e188147ba927e476be3c642", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -414,7 +414,7 @@ impl TokenStreamBuilder {\n         let last_tree_if_joint = self.0.last().and_then(TokenStream::last_tree_if_joint);\n         if let Some(TokenTree::Token(last_token)) = last_tree_if_joint {\n             if let Some((TokenTree::Token(token), is_joint)) = stream.first_tree_and_joint() {\n-                if let Some(glued_tok) = last_token.glue(token) {\n+                if let Some(glued_tok) = last_token.glue(&token) {\n                     let last_stream = self.0.pop().unwrap();\n                     self.push_all_but_last_tree(&last_stream);\n                     let glued_tt = TokenTree::Token(glued_tok);"}, {"sha": "91b92d84a811fde2a3336ca6e4c2000bb1391264", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -447,9 +447,6 @@ pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) {\n                 visitor.visit_pat(&field.pat)\n             }\n         }\n-        PatKind::Tuple(ref elems) => {\n-            walk_list!(visitor, visit_pat, elems);\n-        }\n         PatKind::Box(ref subpattern) |\n         PatKind::Ref(ref subpattern, _) |\n         PatKind::Paren(ref subpattern) => {\n@@ -465,7 +462,9 @@ pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) {\n             visitor.visit_expr(upper_bound);\n         }\n         PatKind::Wild | PatKind::Rest => {},\n-        PatKind::Slice(ref elems) => {\n+        PatKind::Tuple(ref elems)\n+        | PatKind::Slice(ref elems)\n+        | PatKind::Or(ref elems) => {\n             walk_list!(visitor, visit_pat, elems);\n         }\n         PatKind::Mac(ref mac) => visitor.visit_mac(mac),"}, {"sha": "a17cd7625fb1907ec1b398c27c3d696df9679e75", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -1043,6 +1043,7 @@ impl SourceFile {\n                mut src: String,\n                start_pos: BytePos) -> Result<SourceFile, OffsetOverflowError> {\n         remove_bom(&mut src);\n+        normalize_newlines(&mut src);\n \n         let src_hash = {\n             let mut hasher: StableHasher<u128> = StableHasher::new();\n@@ -1210,6 +1211,61 @@ fn remove_bom(src: &mut String) {\n     }\n }\n \n+\n+/// Replaces `\\r\\n` with `\\n` in-place in `src`.\n+///\n+/// Returns error if there's a lone `\\r` in the string\n+fn normalize_newlines(src: &mut String) {\n+    if !src.as_bytes().contains(&b'\\r') {\n+        return;\n+    }\n+\n+    // We replace `\\r\\n` with `\\n` in-place, which doesn't break utf-8 encoding.\n+    // While we *can* call `as_mut_vec` and do surgery on the live string\n+    // directly, let's rather steal the contents of `src`. This makes the code\n+    // safe even if a panic occurs.\n+\n+    let mut buf = std::mem::replace(src, String::new()).into_bytes();\n+    let mut gap_len = 0;\n+    let mut tail = buf.as_mut_slice();\n+    loop {\n+        let idx = match find_crlf(&tail[gap_len..]) {\n+            None => tail.len(),\n+            Some(idx) => idx + gap_len,\n+        };\n+        tail.copy_within(gap_len..idx, 0);\n+        tail = &mut tail[idx - gap_len..];\n+        if tail.len() == gap_len {\n+            break;\n+        }\n+        gap_len += 1;\n+    }\n+\n+    // Account for removed `\\r`.\n+    // After `set_len`, `buf` is guaranteed to contain utf-8 again.\n+    let new_len = buf.len() - gap_len;\n+    unsafe {\n+        buf.set_len(new_len);\n+        *src = String::from_utf8_unchecked(buf);\n+    }\n+\n+    fn find_crlf(src: &[u8]) -> Option<usize> {\n+        let mut search_idx = 0;\n+        while let Some(idx) = find_cr(&src[search_idx..]) {\n+            if src[search_idx..].get(idx + 1) != Some(&b'\\n') {\n+                search_idx += idx + 1;\n+                continue;\n+            }\n+            return Some(search_idx + idx);\n+        }\n+        None\n+    }\n+\n+    fn find_cr(src: &[u8]) -> Option<usize> {\n+        src.iter().position(|&b| b == b'\\r')\n+    }\n+}\n+\n // _____________________________________________________________________________\n // Pos, BytePos, CharPos\n //"}, {"sha": "0b8f16bbc3b990859a99d426cf1f654443d0ce58", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -470,6 +470,7 @@ symbols! {\n         option_env,\n         opt_out_copy,\n         or,\n+        or_patterns,\n         Ord,\n         Ordering,\n         Output,"}, {"sha": "6bd6016020a27a94ed6d9f75e7022b961389abc9", "filename": "src/libsyntax_pos/tests.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibsyntax_pos%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Flibsyntax_pos%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Ftests.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -16,3 +16,23 @@ fn test_lookup_line() {\n     assert_eq!(lookup_line(lines, BytePos(28)), 2);\n     assert_eq!(lookup_line(lines, BytePos(29)), 2);\n }\n+\n+#[test]\n+fn test_normalize_newlines() {\n+    fn check(before: &str, after: &str) {\n+        let mut actual = before.to_string();\n+        normalize_newlines(&mut actual);\n+        assert_eq!(actual.as_str(), after);\n+    }\n+    check(\"\", \"\");\n+    check(\"\\n\", \"\\n\");\n+    check(\"\\r\", \"\\r\");\n+    check(\"\\r\\r\", \"\\r\\r\");\n+    check(\"\\r\\n\", \"\\n\");\n+    check(\"hello world\", \"hello world\");\n+    check(\"hello\\nworld\", \"hello\\nworld\");\n+    check(\"hello\\r\\nworld\", \"hello\\nworld\");\n+    check(\"\\r\\nhello\\r\\nworld\\r\\n\", \"\\nhello\\nworld\\n\");\n+    check(\"\\r\\r\\n\", \"\\r\\n\");\n+    check(\"hello\\rworld\", \"hello\\rworld\");\n+}"}, {"sha": "c053c715248769649c14dffdf83342b47ae3d22e", "filename": "src/test/ui-fulldeps/auxiliary/attr-plugin-test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fattr-plugin-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fattr-plugin-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fattr-plugin-test.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -4,10 +4,9 @@\n #![feature(rustc_private)]\n \n extern crate rustc_driver;\n-extern crate rustc_plugin;\n extern crate syntax;\n \n-use rustc_plugin::Registry;\n+use rustc_driver::plugin::Registry;\n use syntax::ext::base::SyntaxExtension;\n use syntax::feature_gate::AttributeType;\n use syntax::symbol::Symbol;"}, {"sha": "6fb99b2c98361dec7155763b48e04fefb5cda351", "filename": "src/test/ui-fulldeps/auxiliary/issue-40001-plugin.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -3,11 +3,10 @@\n \n #[macro_use]\n extern crate rustc;\n-extern crate rustc_plugin;\n extern crate rustc_driver;\n extern crate syntax;\n \n-use rustc_plugin::Registry;\n+use rustc_driver::plugin::Registry;\n use syntax::attr;\n use syntax::ext::base::*;\n use syntax::feature_gate::AttributeType::Whitelisted;"}, {"sha": "17386d7e1aa5fe46e7cbd559c8cc8eba6412e5b7", "filename": "src/test/ui-fulldeps/auxiliary/lint-for-crate-rpass.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -4,12 +4,11 @@\n #![feature(box_syntax)]\n \n #[macro_use] extern crate rustc;\n-extern crate rustc_plugin;\n extern crate rustc_driver;\n extern crate syntax;\n \n use rustc::lint::{LateContext, LintContext, LintPass, LateLintPass, LateLintPassObject, LintArray};\n-use rustc_plugin::Registry;\n+use rustc_driver::plugin::Registry;\n use rustc::hir;\n use syntax::attr;\n use syntax::symbol::Symbol;"}, {"sha": "000e10392e827118438a665fa41e69b91c47cd65", "filename": "src/test/ui-fulldeps/auxiliary/lint-for-crate.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -4,12 +4,11 @@\n #![feature(box_syntax)]\n \n #[macro_use] extern crate rustc;\n-extern crate rustc_plugin;\n extern crate rustc_driver;\n extern crate syntax;\n \n use rustc::lint::{LateContext, LintContext, LintPass, LateLintPass, LateLintPassObject, LintArray};\n-use rustc_plugin::Registry;\n+use rustc_driver::plugin::Registry;\n use rustc::hir;\n use syntax::attr;\n use syntax::symbol::Symbol;"}, {"sha": "a377b07bd3dd21562cd4ad475d14829568608aac", "filename": "src/test/ui-fulldeps/auxiliary/lint-group-plugin-test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-group-plugin-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-group-plugin-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-group-plugin-test.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -6,12 +6,11 @@\n // Load rustc as a plugin to get macros.\n #[macro_use]\n extern crate rustc;\n-extern crate rustc_plugin;\n extern crate rustc_driver;\n \n use rustc::hir;\n use rustc::lint::{LateContext, LintContext, LintPass, LateLintPass, LateLintPassObject, LintArray};\n-use rustc_plugin::Registry;\n+use rustc_driver::plugin::Registry;\n \n declare_lint!(TEST_LINT, Warn, \"Warn about items named 'lintme'\");\n "}, {"sha": "02675191f785ea7366d24e8b476722b4375ea8f3", "filename": "src/test/ui-fulldeps/auxiliary/lint-plugin-test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-plugin-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-plugin-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-plugin-test.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -8,12 +8,11 @@ extern crate syntax;\n // Load rustc as a plugin to get macros\n #[macro_use]\n extern crate rustc;\n-extern crate rustc_plugin;\n extern crate rustc_driver;\n \n use rustc::lint::{EarlyContext, LintContext, LintPass, EarlyLintPass,\n                   EarlyLintPassObject, LintArray};\n-use rustc_plugin::Registry;\n+use rustc_driver::plugin::Registry;\n use syntax::ast;\n declare_lint!(TEST_LINT, Warn, \"Warn about items named 'lintme'\");\n "}, {"sha": "40f8d490ac87cec58f98939ebd5bda79789b1537", "filename": "src/test/ui-fulldeps/auxiliary/lint-tool-test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-tool-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-tool-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-tool-test.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -6,11 +6,10 @@ extern crate syntax;\n // Load rustc as a plugin to get macros\n #[macro_use]\n extern crate rustc;\n-extern crate rustc_plugin;\n extern crate rustc_driver;\n \n use rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintContext, LintPass};\n-use rustc_plugin::Registry;\n+use rustc_driver::plugin::Registry;\n use syntax::ast;\n declare_tool_lint!(pub clippy::TEST_LINT, Warn, \"Warn about stuff\");\n declare_tool_lint!("}, {"sha": "2ff1c2e363d50c86ddeb3c3cdf4f529dea716c82", "filename": "src/test/ui-fulldeps/auxiliary/llvm-pass-plugin.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fllvm-pass-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fllvm-pass-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fllvm-pass-plugin.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -4,10 +4,9 @@\n #![feature(rustc_private)]\n \n extern crate rustc;\n-extern crate rustc_plugin;\n extern crate rustc_driver;\n \n-use rustc_plugin::Registry;\n+use rustc_driver::plugin::Registry;\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {"}, {"sha": "89bc9a2b9dbf490ad5b1f3cb117a95ace50051ac", "filename": "src/test/ui-fulldeps/auxiliary/lto-syntax-extension-plugin.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flto-syntax-extension-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flto-syntax-extension-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flto-syntax-extension-plugin.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -4,10 +4,9 @@\n #![feature(rustc_private)]\n \n extern crate rustc;\n-extern crate rustc_plugin;\n extern crate rustc_driver;\n \n-use rustc_plugin::Registry;\n+use rustc_driver::plugin::Registry;\n \n #[plugin_registrar]\n pub fn plugin_registrar(_reg: &mut Registry) {}"}, {"sha": "ee82c0adc86042a9ca72a8be0d601e7d2deab4b3", "filename": "src/test/ui-fulldeps/auxiliary/macro-crate-test.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fmacro-crate-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fmacro-crate-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fmacro-crate-test.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -6,7 +6,6 @@\n \n extern crate syntax;\n extern crate rustc;\n-extern crate rustc_plugin;\n extern crate rustc_driver;\n extern crate syntax_pos;\n extern crate proc_macro;"}, {"sha": "e5c4f5b8f7a664a57926a67e55f837ef9aa62bde", "filename": "src/test/ui-fulldeps/auxiliary/outlive-expansion-phase.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Foutlive-expansion-phase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Foutlive-expansion-phase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Foutlive-expansion-phase.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -4,12 +4,11 @@\n #![feature(box_syntax, rustc_private)]\n \n extern crate rustc;\n-extern crate rustc_plugin;\n extern crate rustc_driver;\n \n use std::any::Any;\n use std::cell::RefCell;\n-use rustc_plugin::Registry;\n+use rustc_driver::plugin::Registry;\n \n struct Foo {\n     foo: isize"}, {"sha": "5ff24cff23c558aae7bee040c8c298b32e9dcd93", "filename": "src/test/ui-fulldeps/auxiliary/plugin-args.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fplugin-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fplugin-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fplugin-args.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -6,7 +6,6 @@\n extern crate syntax;\n extern crate syntax_pos;\n extern crate rustc;\n-extern crate rustc_plugin;\n extern crate rustc_driver;\n \n use std::borrow::ToOwned;\n@@ -17,7 +16,7 @@ use syntax::print::pprust;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use syntax::tokenstream::TokenStream;\n-use rustc_plugin::Registry;\n+use rustc_driver::plugin::Registry;\n \n struct Expander {\n     args: Vec<ast::NestedMetaItem>,"}, {"sha": "1c0de98da56f21faa30af030d0a7bcc05bd9430a", "filename": "src/test/ui-fulldeps/auxiliary/rlib-crate-test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Frlib-crate-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Frlib-crate-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Frlib-crate-test.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -4,10 +4,9 @@\n #![feature(plugin_registrar, rustc_private)]\n \n extern crate rustc;\n-extern crate rustc_plugin;\n extern crate rustc_driver;\n \n-use rustc_plugin::Registry;\n+use rustc_driver::plugin::Registry;\n \n #[plugin_registrar]\n pub fn plugin_registrar(_: &mut Registry) {}"}, {"sha": "027025b72b31bff52fd0bb71d444fc7ce6b47c64", "filename": "src/test/ui-fulldeps/auxiliary/roman-numerals.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Froman-numerals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Froman-numerals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Froman-numerals.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -12,14 +12,13 @@\n extern crate syntax;\n extern crate syntax_pos;\n extern crate rustc;\n-extern crate rustc_plugin;\n extern crate rustc_driver;\n \n use syntax::parse::token::{self, Token};\n use syntax::tokenstream::TokenTree;\n use syntax::ext::base::{ExtCtxt, MacResult, DummyResult, MacEager};\n use syntax_pos::Span;\n-use rustc_plugin::Registry;\n+use rustc_driver::plugin::Registry;\n \n fn expand_rn(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n         -> Box<dyn MacResult + 'static> {"}, {"sha": "a58cec53421427b972603994a504677f27b8e752", "filename": "src/test/ui/associated-type-bounds/assoc-type-eq-with-dyn-atb-fail.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -0,0 +1,32 @@\n+// This test documents that `type Out = Box<dyn Bar<Assoc: Copy>>;`\n+// is allowed and will correctly reject an opaque `type Out` which\n+// does not satisfy the bound `<TheType as Bar>::Assoc: Copy`.\n+//\n+// FIXME(rust-lang/lang): I think this behavior is logical if we want to allow\n+// `dyn Trait<Assoc: Bound>` but we should decide if we want that. // Centril\n+//\n+// Additionally, as reported in https://github.com/rust-lang/rust/issues/63594,\n+// we check that the spans for the error message are sane here.\n+\n+#![feature(associated_type_bounds)]\n+\n+fn main() {}\n+\n+trait Bar { type Assoc; }\n+\n+trait Thing {\n+    type Out;\n+    fn func() -> Self::Out;\n+}\n+\n+struct AssocNoCopy;\n+impl Bar for AssocNoCopy { type Assoc = String; }\n+\n+impl Thing for AssocNoCopy {\n+    type Out = Box<dyn Bar<Assoc: Copy>>;\n+    //~^ ERROR the trait bound `std::string::String: std::marker::Copy` is not satisfied\n+\n+    fn func() -> Self::Out {\n+        Box::new(AssocNoCopy)\n+    }\n+}"}, {"sha": "b6b49c2e903508d75e01d7def22695f2975e15ad", "filename": "src/test/ui/associated-type-bounds/assoc-type-eq-with-dyn-atb-fail.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.stderr?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -0,0 +1,11 @@\n+error[E0277]: the trait bound `std::string::String: std::marker::Copy` is not satisfied\n+  --> $DIR/assoc-type-eq-with-dyn-atb-fail.rs:26:28\n+   |\n+LL |     type Out = Box<dyn Bar<Assoc: Copy>>;\n+   |                            ^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `std::string::String`\n+   |\n+   = note: the return type of a function must have a statically known size\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "a89fd9807da8f0ee9f970eb48621909622c79926", "filename": "src/test/ui/associated-type-bounds/duplicate.rs", "status": "modified", "additions": 94, "deletions": 71, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -1,161 +1,184 @@\n // compile-fail\n // ignore-tidy-linelength\n-// error-pattern:could not find defining uses\n \n #![feature(associated_type_bounds)]\n #![feature(type_alias_impl_trait)]\n-#![feature(impl_trait_in_bindings)]\n+#![feature(impl_trait_in_bindings)] //~ WARN the feature `impl_trait_in_bindings` is incomplete and may cause the compiler to crash [incomplete_features]\n #![feature(untagged_unions)]\n \n use std::iter;\n \n struct SI1<T: Iterator<Item: Copy, Item: Send>> { f: T }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n struct SI2<T: Iterator<Item: Copy, Item: Copy>> { f: T }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n struct SI3<T: Iterator<Item: 'static, Item: 'static>> { f: T }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n struct SW1<T> where T: Iterator<Item: Copy, Item: Send> { f: T }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n struct SW2<T> where T: Iterator<Item: Copy, Item: Copy> { f: T }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n struct SW3<T> where T: Iterator<Item: 'static, Item: 'static> { f: T }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n \n enum EI1<T: Iterator<Item: Copy, Item: Send>> { V(T) }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n enum EI2<T: Iterator<Item: Copy, Item: Copy>> { V(T) }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n enum EI3<T: Iterator<Item: 'static, Item: 'static>> { V(T) }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n enum EW1<T> where T: Iterator<Item: Copy, Item: Send> { V(T) }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n enum EW2<T> where T: Iterator<Item: Copy, Item: Copy> { V(T) }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n enum EW3<T> where T: Iterator<Item: 'static, Item: 'static> { V(T) }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n \n union UI1<T: Iterator<Item: Copy, Item: Send>> { f: T }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n union UI2<T: Iterator<Item: Copy, Item: Copy>> { f: T }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n union UI3<T: Iterator<Item: 'static, Item: 'static>> { f: T }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n union UW1<T> where T: Iterator<Item: Copy, Item: Send> { f: T }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n union UW2<T> where T: Iterator<Item: Copy, Item: Copy> { f: T }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n union UW3<T> where T: Iterator<Item: 'static, Item: 'static> { f: T }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n \n fn FI1<T: Iterator<Item: Copy, Item: Send>>() {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n fn FI2<T: Iterator<Item: Copy, Item: Copy>>() {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n fn FI3<T: Iterator<Item: 'static, Item: 'static>>() {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n fn FW1<T>() where T: Iterator<Item: Copy, Item: Send> {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n fn FW2<T>() where T: Iterator<Item: Copy, Item: Copy> {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n fn FW3<T>() where T: Iterator<Item: 'static, Item: 'static> {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n \n fn FRPIT1() -> impl Iterator<Item: Copy, Item: Send> { iter::empty() }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n fn FRPIT2() -> impl Iterator<Item: Copy, Item: Copy> { iter::empty() }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n fn FRPIT3() -> impl Iterator<Item: 'static, Item: 'static> { iter::empty() }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n fn FAPIT1(_: impl Iterator<Item: Copy, Item: Send>) {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n fn FAPIT2(_: impl Iterator<Item: Copy, Item: Copy>) {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n fn FAPIT3(_: impl Iterator<Item: 'static, Item: 'static>) {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n \n const CIT1: impl Iterator<Item: Copy, Item: Send> = iter::empty();\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n const CIT2: impl Iterator<Item: Copy, Item: Copy> = iter::empty();\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n const CIT3: impl Iterator<Item: 'static, Item: 'static> = iter::empty();\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n static SIT1: impl Iterator<Item: Copy, Item: Send> = iter::empty();\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n static SIT2: impl Iterator<Item: Copy, Item: Copy> = iter::empty();\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n static SIT3: impl Iterator<Item: 'static, Item: 'static> = iter::empty();\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n \n fn lit1() { let _: impl Iterator<Item: Copy, Item: Send> = iter::empty(); }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n fn lit2() { let _: impl Iterator<Item: Copy, Item: Copy> = iter::empty(); }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n fn lit3() { let _: impl Iterator<Item: 'static, Item: 'static> = iter::empty(); }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n \n type TAI1<T: Iterator<Item: Copy, Item: Send>> = T;\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n type TAI2<T: Iterator<Item: Copy, Item: Copy>> = T;\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n type TAI3<T: Iterator<Item: 'static, Item: 'static>> = T;\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n type TAW1<T> where T: Iterator<Item: Copy, Item: Send> = T;\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n type TAW2<T> where T: Iterator<Item: Copy, Item: Copy> = T;\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n type TAW3<T> where T: Iterator<Item: 'static, Item: 'static> = T;\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n \n type ETAI1<T: Iterator<Item: Copy, Item: Send>> = impl Copy;\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~| ERROR could not find defining uses\n+//~| ERROR could not find defining uses\n+//~| ERROR could not find defining uses\n type ETAI2<T: Iterator<Item: Copy, Item: Copy>> = impl Copy;\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~| ERROR could not find defining uses\n+//~| ERROR could not find defining uses\n+//~| ERROR could not find defining uses\n type ETAI3<T: Iterator<Item: 'static, Item: 'static>> = impl Copy;\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~| ERROR could not find defining uses\n+//~| ERROR could not find defining uses\n+//~| ERROR could not find defining uses\n type ETAI4 = impl Iterator<Item: Copy, Item: Send>;\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~| ERROR could not find defining uses\n+//~| ERROR could not find defining uses\n+//~| ERROR could not find defining uses\n type ETAI5 = impl Iterator<Item: Copy, Item: Copy>;\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~| ERROR could not find defining uses\n+//~| ERROR could not find defining uses\n+//~| ERROR could not find defining uses\n type ETAI6 = impl Iterator<Item: 'static, Item: 'static>;\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~| ERROR could not find defining uses\n+//~| ERROR could not find defining uses\n+//~| ERROR could not find defining uses\n \n trait TRI1<T: Iterator<Item: Copy, Item: Send>> {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n trait TRI2<T: Iterator<Item: Copy, Item: Copy>> {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n trait TRI3<T: Iterator<Item: 'static, Item: 'static>> {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n trait TRS1: Iterator<Item: Copy, Item: Send> {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n trait TRS2: Iterator<Item: Copy, Item: Copy> {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n trait TRS3: Iterator<Item: 'static, Item: 'static> {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n trait TRW1<T> where T: Iterator<Item: Copy, Item: Send> {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n trait TRW2<T> where T: Iterator<Item: Copy, Item: Copy> {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n trait TRW3<T> where T: Iterator<Item: 'static, Item: 'static> {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n trait TRSW1 where Self: Iterator<Item: Copy, Item: Send> {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n trait TRSW2 where Self: Iterator<Item: Copy, Item: Copy> {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n trait TRSW3 where Self: Iterator<Item: 'static, Item: 'static> {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n trait TRA1 { type A: Iterator<Item: Copy, Item: Send>; }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n trait TRA2 { type A: Iterator<Item: Copy, Item: Copy>; }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n trait TRA3 { type A: Iterator<Item: 'static, Item: 'static>; }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n \n type TADyn1 = dyn Iterator<Item: Copy, Item: Send>;\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~| ERROR could not find defining uses\n+//~| ERROR could not find defining uses\n type TADyn2 = Box<dyn Iterator<Item: Copy, Item: Copy>>;\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~| ERROR could not find defining uses\n+//~| ERROR could not find defining uses\n type TADyn3 = dyn Iterator<Item: 'static, Item: 'static>;\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~| ERROR could not find defining uses\n+//~| ERROR could not find defining uses\n \n fn main() {}"}, {"sha": "e5e85d6856fd315aafc6259e271dec85b7b138b8", "filename": "src/test/ui/associated-type-bounds/duplicate.stderr", "status": "modified", "additions": 148, "deletions": 76, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.stderr?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -1,634 +1,706 @@\n warning: the feature `impl_trait_in_bindings` is incomplete and may cause the compiler to crash\n-  --> $DIR/duplicate.rs:7:12\n+  --> $DIR/duplicate.rs:6:12\n    |\n LL | #![feature(impl_trait_in_bindings)]\n    |            ^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:12:36\n+  --> $DIR/duplicate.rs:11:36\n    |\n LL | struct SI1<T: Iterator<Item: Copy, Item: Send>> { f: T }\n    |                        ----------  ^^^^^^^^^^ re-bound here\n    |                        |\n    |                        `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:14:36\n+  --> $DIR/duplicate.rs:13:36\n    |\n LL | struct SI2<T: Iterator<Item: Copy, Item: Copy>> { f: T }\n    |                        ----------  ^^^^^^^^^^ re-bound here\n    |                        |\n    |                        `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:16:39\n+  --> $DIR/duplicate.rs:15:39\n    |\n LL | struct SI3<T: Iterator<Item: 'static, Item: 'static>> { f: T }\n    |                        -------------  ^^^^^^^^^^^^^ re-bound here\n    |                        |\n    |                        `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:18:45\n+  --> $DIR/duplicate.rs:17:45\n    |\n LL | struct SW1<T> where T: Iterator<Item: Copy, Item: Send> { f: T }\n    |                                 ----------  ^^^^^^^^^^ re-bound here\n    |                                 |\n    |                                 `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:20:45\n+  --> $DIR/duplicate.rs:19:45\n    |\n LL | struct SW2<T> where T: Iterator<Item: Copy, Item: Copy> { f: T }\n    |                                 ----------  ^^^^^^^^^^ re-bound here\n    |                                 |\n    |                                 `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:22:48\n+  --> $DIR/duplicate.rs:21:48\n    |\n LL | struct SW3<T> where T: Iterator<Item: 'static, Item: 'static> { f: T }\n    |                                 -------------  ^^^^^^^^^^^^^ re-bound here\n    |                                 |\n    |                                 `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:25:34\n+  --> $DIR/duplicate.rs:24:34\n    |\n LL | enum EI1<T: Iterator<Item: Copy, Item: Send>> { V(T) }\n    |                      ----------  ^^^^^^^^^^ re-bound here\n    |                      |\n    |                      `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:27:34\n+  --> $DIR/duplicate.rs:26:34\n    |\n LL | enum EI2<T: Iterator<Item: Copy, Item: Copy>> { V(T) }\n    |                      ----------  ^^^^^^^^^^ re-bound here\n    |                      |\n    |                      `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:29:37\n+  --> $DIR/duplicate.rs:28:37\n    |\n LL | enum EI3<T: Iterator<Item: 'static, Item: 'static>> { V(T) }\n    |                      -------------  ^^^^^^^^^^^^^ re-bound here\n    |                      |\n    |                      `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:31:43\n+  --> $DIR/duplicate.rs:30:43\n    |\n LL | enum EW1<T> where T: Iterator<Item: Copy, Item: Send> { V(T) }\n    |                               ----------  ^^^^^^^^^^ re-bound here\n    |                               |\n    |                               `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:33:43\n+  --> $DIR/duplicate.rs:32:43\n    |\n LL | enum EW2<T> where T: Iterator<Item: Copy, Item: Copy> { V(T) }\n    |                               ----------  ^^^^^^^^^^ re-bound here\n    |                               |\n    |                               `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:35:46\n+  --> $DIR/duplicate.rs:34:46\n    |\n LL | enum EW3<T> where T: Iterator<Item: 'static, Item: 'static> { V(T) }\n    |                               -------------  ^^^^^^^^^^^^^ re-bound here\n    |                               |\n    |                               `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:38:35\n+  --> $DIR/duplicate.rs:37:35\n    |\n LL | union UI1<T: Iterator<Item: Copy, Item: Send>> { f: T }\n    |                       ----------  ^^^^^^^^^^ re-bound here\n    |                       |\n    |                       `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:40:35\n+  --> $DIR/duplicate.rs:39:35\n    |\n LL | union UI2<T: Iterator<Item: Copy, Item: Copy>> { f: T }\n    |                       ----------  ^^^^^^^^^^ re-bound here\n    |                       |\n    |                       `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:42:38\n+  --> $DIR/duplicate.rs:41:38\n    |\n LL | union UI3<T: Iterator<Item: 'static, Item: 'static>> { f: T }\n    |                       -------------  ^^^^^^^^^^^^^ re-bound here\n    |                       |\n    |                       `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:44:44\n+  --> $DIR/duplicate.rs:43:44\n    |\n LL | union UW1<T> where T: Iterator<Item: Copy, Item: Send> { f: T }\n    |                                ----------  ^^^^^^^^^^ re-bound here\n    |                                |\n    |                                `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:46:44\n+  --> $DIR/duplicate.rs:45:44\n    |\n LL | union UW2<T> where T: Iterator<Item: Copy, Item: Copy> { f: T }\n    |                                ----------  ^^^^^^^^^^ re-bound here\n    |                                |\n    |                                `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:48:47\n+  --> $DIR/duplicate.rs:47:47\n    |\n LL | union UW3<T> where T: Iterator<Item: 'static, Item: 'static> { f: T }\n    |                                -------------  ^^^^^^^^^^^^^ re-bound here\n    |                                |\n    |                                `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:51:32\n+  --> $DIR/duplicate.rs:50:32\n    |\n LL | fn FI1<T: Iterator<Item: Copy, Item: Send>>() {}\n    |                    ----------  ^^^^^^^^^^ re-bound here\n    |                    |\n    |                    `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:53:32\n+  --> $DIR/duplicate.rs:52:32\n    |\n LL | fn FI2<T: Iterator<Item: Copy, Item: Copy>>() {}\n    |                    ----------  ^^^^^^^^^^ re-bound here\n    |                    |\n    |                    `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:55:35\n+  --> $DIR/duplicate.rs:54:35\n    |\n LL | fn FI3<T: Iterator<Item: 'static, Item: 'static>>() {}\n    |                    -------------  ^^^^^^^^^^^^^ re-bound here\n    |                    |\n    |                    `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:57:43\n+  --> $DIR/duplicate.rs:56:43\n    |\n LL | fn FW1<T>() where T: Iterator<Item: Copy, Item: Send> {}\n    |                               ----------  ^^^^^^^^^^ re-bound here\n    |                               |\n    |                               `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:59:43\n+  --> $DIR/duplicate.rs:58:43\n    |\n LL | fn FW2<T>() where T: Iterator<Item: Copy, Item: Copy> {}\n    |                               ----------  ^^^^^^^^^^ re-bound here\n    |                               |\n    |                               `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:61:46\n+  --> $DIR/duplicate.rs:60:46\n    |\n LL | fn FW3<T>() where T: Iterator<Item: 'static, Item: 'static> {}\n    |                               -------------  ^^^^^^^^^^^^^ re-bound here\n    |                               |\n    |                               `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:70:40\n+  --> $DIR/duplicate.rs:69:40\n    |\n LL | fn FAPIT1(_: impl Iterator<Item: Copy, Item: Send>) {}\n    |                            ----------  ^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:72:40\n+  --> $DIR/duplicate.rs:71:40\n    |\n LL | fn FAPIT2(_: impl Iterator<Item: Copy, Item: Copy>) {}\n    |                            ----------  ^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:74:43\n+  --> $DIR/duplicate.rs:73:43\n    |\n LL | fn FAPIT3(_: impl Iterator<Item: 'static, Item: 'static>) {}\n    |                            -------------  ^^^^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:64:42\n+  --> $DIR/duplicate.rs:63:42\n    |\n LL | fn FRPIT1() -> impl Iterator<Item: Copy, Item: Send> { iter::empty() }\n    |                              ----------  ^^^^^^^^^^ re-bound here\n    |                              |\n    |                              `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:66:42\n+  --> $DIR/duplicate.rs:65:42\n    |\n LL | fn FRPIT2() -> impl Iterator<Item: Copy, Item: Copy> { iter::empty() }\n    |                              ----------  ^^^^^^^^^^ re-bound here\n    |                              |\n    |                              `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:68:45\n+  --> $DIR/duplicate.rs:67:45\n    |\n LL | fn FRPIT3() -> impl Iterator<Item: 'static, Item: 'static> { iter::empty() }\n    |                              -------------  ^^^^^^^^^^^^^ re-bound here\n    |                              |\n    |                              `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:77:39\n+  --> $DIR/duplicate.rs:76:39\n    |\n LL | const CIT1: impl Iterator<Item: Copy, Item: Send> = iter::empty();\n    |                           ----------  ^^^^^^^^^^ re-bound here\n    |                           |\n    |                           `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:79:39\n+  --> $DIR/duplicate.rs:78:39\n    |\n LL | const CIT2: impl Iterator<Item: Copy, Item: Copy> = iter::empty();\n    |                           ----------  ^^^^^^^^^^ re-bound here\n    |                           |\n    |                           `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:81:42\n+  --> $DIR/duplicate.rs:80:42\n    |\n LL | const CIT3: impl Iterator<Item: 'static, Item: 'static> = iter::empty();\n    |                           -------------  ^^^^^^^^^^^^^ re-bound here\n    |                           |\n    |                           `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:83:40\n+  --> $DIR/duplicate.rs:82:40\n    |\n LL | static SIT1: impl Iterator<Item: Copy, Item: Send> = iter::empty();\n    |                            ----------  ^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:85:40\n+  --> $DIR/duplicate.rs:84:40\n    |\n LL | static SIT2: impl Iterator<Item: Copy, Item: Copy> = iter::empty();\n    |                            ----------  ^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:87:43\n+  --> $DIR/duplicate.rs:86:43\n    |\n LL | static SIT3: impl Iterator<Item: 'static, Item: 'static> = iter::empty();\n    |                            -------------  ^^^^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:90:46\n+  --> $DIR/duplicate.rs:89:46\n    |\n LL | fn lit1() { let _: impl Iterator<Item: Copy, Item: Send> = iter::empty(); }\n    |                                  ----------  ^^^^^^^^^^ re-bound here\n    |                                  |\n    |                                  `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:92:46\n+  --> $DIR/duplicate.rs:91:46\n    |\n LL | fn lit2() { let _: impl Iterator<Item: Copy, Item: Copy> = iter::empty(); }\n    |                                  ----------  ^^^^^^^^^^ re-bound here\n    |                                  |\n    |                                  `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:94:49\n+  --> $DIR/duplicate.rs:93:49\n    |\n LL | fn lit3() { let _: impl Iterator<Item: 'static, Item: 'static> = iter::empty(); }\n    |                                  -------------  ^^^^^^^^^^^^^ re-bound here\n    |                                  |\n    |                                  `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:97:35\n+  --> $DIR/duplicate.rs:96:35\n    |\n LL | type TAI1<T: Iterator<Item: Copy, Item: Send>> = T;\n    |                       ----------  ^^^^^^^^^^ re-bound here\n    |                       |\n    |                       `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:99:35\n+  --> $DIR/duplicate.rs:98:35\n    |\n LL | type TAI2<T: Iterator<Item: Copy, Item: Copy>> = T;\n    |                       ----------  ^^^^^^^^^^ re-bound here\n    |                       |\n    |                       `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:101:38\n+  --> $DIR/duplicate.rs:100:38\n    |\n LL | type TAI3<T: Iterator<Item: 'static, Item: 'static>> = T;\n    |                       -------------  ^^^^^^^^^^^^^ re-bound here\n    |                       |\n    |                       `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:103:44\n+  --> $DIR/duplicate.rs:102:44\n    |\n LL | type TAW1<T> where T: Iterator<Item: Copy, Item: Send> = T;\n    |                                ----------  ^^^^^^^^^^ re-bound here\n    |                                |\n    |                                `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:105:44\n+  --> $DIR/duplicate.rs:104:44\n    |\n LL | type TAW2<T> where T: Iterator<Item: Copy, Item: Copy> = T;\n    |                                ----------  ^^^^^^^^^^ re-bound here\n    |                                |\n    |                                `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:107:47\n+  --> $DIR/duplicate.rs:106:47\n    |\n LL | type TAW3<T> where T: Iterator<Item: 'static, Item: 'static> = T;\n    |                                -------------  ^^^^^^^^^^^^^ re-bound here\n    |                                |\n    |                                `Item` bound here first\n \n error: could not find defining uses\n-  --> $DIR/duplicate.rs:110:1\n+  --> $DIR/duplicate.rs:109:1\n    |\n LL | type ETAI1<T: Iterator<Item: Copy, Item: Send>> = impl Copy;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:110:36\n+  --> $DIR/duplicate.rs:109:36\n    |\n LL | type ETAI1<T: Iterator<Item: Copy, Item: Send>> = impl Copy;\n    |                        ----------  ^^^^^^^^^^ re-bound here\n    |                        |\n    |                        `Item` bound here first\n \n error: could not find defining uses\n-  --> $DIR/duplicate.rs:112:1\n+  --> $DIR/duplicate.rs:114:1\n    |\n LL | type ETAI2<T: Iterator<Item: Copy, Item: Copy>> = impl Copy;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:112:36\n+  --> $DIR/duplicate.rs:114:36\n    |\n LL | type ETAI2<T: Iterator<Item: Copy, Item: Copy>> = impl Copy;\n    |                        ----------  ^^^^^^^^^^ re-bound here\n    |                        |\n    |                        `Item` bound here first\n \n error: could not find defining uses\n-  --> $DIR/duplicate.rs:114:1\n+  --> $DIR/duplicate.rs:119:1\n    |\n LL | type ETAI3<T: Iterator<Item: 'static, Item: 'static>> = impl Copy;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:114:39\n+  --> $DIR/duplicate.rs:119:39\n    |\n LL | type ETAI3<T: Iterator<Item: 'static, Item: 'static>> = impl Copy;\n    |                        -------------  ^^^^^^^^^^^^^ re-bound here\n    |                        |\n    |                        `Item` bound here first\n \n error: could not find defining uses\n-  --> $DIR/duplicate.rs:116:1\n+  --> $DIR/duplicate.rs:124:1\n    |\n LL | type ETAI4 = impl Iterator<Item: Copy, Item: Send>;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:116:40\n+  --> $DIR/duplicate.rs:124:40\n    |\n LL | type ETAI4 = impl Iterator<Item: Copy, Item: Send>;\n    |                            ----------  ^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n error: could not find defining uses\n-  --> $DIR/duplicate.rs:118:1\n+  --> $DIR/duplicate.rs:129:1\n    |\n LL | type ETAI5 = impl Iterator<Item: Copy, Item: Copy>;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:118:40\n+  --> $DIR/duplicate.rs:129:40\n    |\n LL | type ETAI5 = impl Iterator<Item: Copy, Item: Copy>;\n    |                            ----------  ^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n error: could not find defining uses\n-  --> $DIR/duplicate.rs:120:1\n+  --> $DIR/duplicate.rs:134:1\n    |\n LL | type ETAI6 = impl Iterator<Item: 'static, Item: 'static>;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:120:43\n+  --> $DIR/duplicate.rs:134:43\n    |\n LL | type ETAI6 = impl Iterator<Item: 'static, Item: 'static>;\n    |                            -------------  ^^^^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:123:36\n+  --> $DIR/duplicate.rs:140:36\n    |\n LL | trait TRI1<T: Iterator<Item: Copy, Item: Send>> {}\n    |                        ----------  ^^^^^^^^^^ re-bound here\n    |                        |\n    |                        `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:125:36\n+  --> $DIR/duplicate.rs:142:36\n    |\n LL | trait TRI2<T: Iterator<Item: Copy, Item: Copy>> {}\n    |                        ----------  ^^^^^^^^^^ re-bound here\n    |                        |\n    |                        `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:127:39\n+  --> $DIR/duplicate.rs:144:39\n    |\n LL | trait TRI3<T: Iterator<Item: 'static, Item: 'static>> {}\n    |                        -------------  ^^^^^^^^^^^^^ re-bound here\n    |                        |\n    |                        `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:129:34\n+  --> $DIR/duplicate.rs:146:34\n    |\n LL | trait TRS1: Iterator<Item: Copy, Item: Send> {}\n    |                      ----------  ^^^^^^^^^^ re-bound here\n    |                      |\n    |                      `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:131:34\n+  --> $DIR/duplicate.rs:148:34\n    |\n LL | trait TRS2: Iterator<Item: Copy, Item: Copy> {}\n    |                      ----------  ^^^^^^^^^^ re-bound here\n    |                      |\n    |                      `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:133:37\n+  --> $DIR/duplicate.rs:150:37\n    |\n LL | trait TRS3: Iterator<Item: 'static, Item: 'static> {}\n    |                      -------------  ^^^^^^^^^^^^^ re-bound here\n    |                      |\n    |                      `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:135:45\n+  --> $DIR/duplicate.rs:152:45\n    |\n LL | trait TRW1<T> where T: Iterator<Item: Copy, Item: Send> {}\n    |                                 ----------  ^^^^^^^^^^ re-bound here\n    |                                 |\n    |                                 `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:137:45\n+  --> $DIR/duplicate.rs:154:45\n    |\n LL | trait TRW2<T> where T: Iterator<Item: Copy, Item: Copy> {}\n    |                                 ----------  ^^^^^^^^^^ re-bound here\n    |                                 |\n    |                                 `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:139:48\n+  --> $DIR/duplicate.rs:156:48\n    |\n LL | trait TRW3<T> where T: Iterator<Item: 'static, Item: 'static> {}\n    |                                 -------------  ^^^^^^^^^^^^^ re-bound here\n    |                                 |\n    |                                 `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:141:46\n+  --> $DIR/duplicate.rs:158:46\n    |\n LL | trait TRSW1 where Self: Iterator<Item: Copy, Item: Send> {}\n    |                                  ----------  ^^^^^^^^^^ re-bound here\n    |                                  |\n    |                                  `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:143:46\n+  --> $DIR/duplicate.rs:160:46\n    |\n LL | trait TRSW2 where Self: Iterator<Item: Copy, Item: Copy> {}\n    |                                  ----------  ^^^^^^^^^^ re-bound here\n    |                                  |\n    |                                  `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:145:49\n+  --> $DIR/duplicate.rs:162:49\n    |\n LL | trait TRSW3 where Self: Iterator<Item: 'static, Item: 'static> {}\n    |                                  -------------  ^^^^^^^^^^^^^ re-bound here\n    |                                  |\n    |                                  `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:147:43\n+  --> $DIR/duplicate.rs:164:43\n    |\n LL | trait TRA1 { type A: Iterator<Item: Copy, Item: Send>; }\n    |                               ----------  ^^^^^^^^^^ re-bound here\n    |                               |\n    |                               `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:149:43\n+  --> $DIR/duplicate.rs:166:43\n    |\n LL | trait TRA2 { type A: Iterator<Item: Copy, Item: Copy>; }\n    |                               ----------  ^^^^^^^^^^ re-bound here\n    |                               |\n    |                               `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:151:46\n+  --> $DIR/duplicate.rs:168:46\n    |\n LL | trait TRA3 { type A: Iterator<Item: 'static, Item: 'static>; }\n    |                               -------------  ^^^^^^^^^^^^^ re-bound here\n    |                               |\n    |                               `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:154:40\n+  --> $DIR/duplicate.rs:171:40\n    |\n LL | type TADyn1 = dyn Iterator<Item: Copy, Item: Send>;\n    |                            ----------  ^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:156:44\n+  --> $DIR/duplicate.rs:175:44\n    |\n LL | type TADyn2 = Box<dyn Iterator<Item: Copy, Item: Copy>>;\n    |                                ----------  ^^^^^^^^^^ re-bound here\n    |                                |\n    |                                `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:158:43\n+  --> $DIR/duplicate.rs:179:43\n    |\n LL | type TADyn3 = dyn Iterator<Item: 'static, Item: 'static>;\n    |                            -------------  ^^^^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n error: could not find defining uses\n+  --> $DIR/duplicate.rs:109:24\n+   |\n+LL | type ETAI1<T: Iterator<Item: Copy, Item: Send>> = impl Copy;\n+   |                        ^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/duplicate.rs:109:36\n+   |\n+LL | type ETAI1<T: Iterator<Item: Copy, Item: Send>> = impl Copy;\n+   |                                    ^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/duplicate.rs:114:24\n+   |\n+LL | type ETAI2<T: Iterator<Item: Copy, Item: Copy>> = impl Copy;\n+   |                        ^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/duplicate.rs:114:36\n+   |\n+LL | type ETAI2<T: Iterator<Item: Copy, Item: Copy>> = impl Copy;\n+   |                                    ^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/duplicate.rs:119:24\n+   |\n+LL | type ETAI3<T: Iterator<Item: 'static, Item: 'static>> = impl Copy;\n+   |                        ^^^^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/duplicate.rs:119:39\n+   |\n+LL | type ETAI3<T: Iterator<Item: 'static, Item: 'static>> = impl Copy;\n+   |                                       ^^^^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/duplicate.rs:124:28\n+   |\n+LL | type ETAI4 = impl Iterator<Item: Copy, Item: Send>;\n+   |                            ^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/duplicate.rs:124:40\n+   |\n+LL | type ETAI4 = impl Iterator<Item: Copy, Item: Send>;\n+   |                                        ^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/duplicate.rs:129:28\n+   |\n+LL | type ETAI5 = impl Iterator<Item: Copy, Item: Copy>;\n+   |                            ^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/duplicate.rs:129:40\n+   |\n+LL | type ETAI5 = impl Iterator<Item: Copy, Item: Copy>;\n+   |                                        ^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/duplicate.rs:134:28\n+   |\n+LL | type ETAI6 = impl Iterator<Item: 'static, Item: 'static>;\n+   |                            ^^^^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/duplicate.rs:134:43\n+   |\n+LL | type ETAI6 = impl Iterator<Item: 'static, Item: 'static>;\n+   |                                           ^^^^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/duplicate.rs:171:28\n+   |\n+LL | type TADyn1 = dyn Iterator<Item: Copy, Item: Send>;\n+   |                            ^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/duplicate.rs:171:40\n+   |\n+LL | type TADyn1 = dyn Iterator<Item: Copy, Item: Send>;\n+   |                                        ^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/duplicate.rs:175:32\n+   |\n+LL | type TADyn2 = Box<dyn Iterator<Item: Copy, Item: Copy>>;\n+   |                                ^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/duplicate.rs:175:44\n+   |\n+LL | type TADyn2 = Box<dyn Iterator<Item: Copy, Item: Copy>>;\n+   |                                            ^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/duplicate.rs:179:28\n+   |\n+LL | type TADyn3 = dyn Iterator<Item: 'static, Item: 'static>;\n+   |                            ^^^^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/duplicate.rs:179:43\n+   |\n+LL | type TADyn3 = dyn Iterator<Item: 'static, Item: 'static>;\n+   |                                           ^^^^^^^^^^^^^\n \n error: aborting due to 93 previous errors\n "}, {"sha": "83a60825d84cdcabcaa2177f29f6001e319966b9", "filename": "src/test/ui/associated-type-bounds/inside-adt.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fassociated-type-bounds%2Finside-adt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fassociated-type-bounds%2Finside-adt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Finside-adt.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -1,36 +1,33 @@\n // compile-fail\n-// ignore-tidy-linelength\n-// error-pattern:could not find defining uses\n-\n #![feature(associated_type_bounds)]\n #![feature(untagged_unions)]\n \n struct S1 { f: dyn Iterator<Item: Copy> }\n-//~^ associated type bounds are not allowed within structs, enums, or unions\n-//~| the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified [E0191]\n+//~^ ERROR associated type bounds are not allowed within structs, enums, or unions\n+//~| ERROR could not find defining uses\n struct S2 { f: Box<dyn Iterator<Item: Copy>> }\n-//~^ associated type bounds are not allowed within structs, enums, or unions\n-//~| the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified [E0191]\n+//~^ ERROR associated type bounds are not allowed within structs, enums, or unions\n+//~| ERROR could not find defining uses\n struct S3 { f: dyn Iterator<Item: 'static> }\n-//~^ associated type bounds are not allowed within structs, enums, or unions\n-//~| the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified [E0191]\n+//~^ ERROR associated type bounds are not allowed within structs, enums, or unions\n+//~| ERROR could not find defining uses\n \n enum E1 { V(dyn Iterator<Item: Copy>) }\n-//~^ associated type bounds are not allowed within structs, enums, or unions\n-//~| the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified [E0191]\n+//~^ ERROR associated type bounds are not allowed within structs, enums, or unions\n+//~| ERROR could not find defining uses\n enum E2 { V(Box<dyn Iterator<Item: Copy>>) }\n-//~^ associated type bounds are not allowed within structs, enums, or unions\n-//~| the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified [E0191]\n+//~^ ERROR associated type bounds are not allowed within structs, enums, or unions\n+//~| ERROR could not find defining uses\n enum E3 { V(dyn Iterator<Item: 'static>) }\n-//~^ associated type bounds are not allowed within structs, enums, or unions\n-//~| the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified [E0191]\n+//~^ ERROR associated type bounds are not allowed within structs, enums, or unions\n+//~| ERROR could not find defining uses\n \n union U1 { f: dyn Iterator<Item: Copy> }\n-//~^ associated type bounds are not allowed within structs, enums, or unions\n-//~| the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified [E0191]\n+//~^ ERROR associated type bounds are not allowed within structs, enums, or unions\n+//~| ERROR could not find defining uses\n union U2 { f: Box<dyn Iterator<Item: Copy>> }\n-//~^ associated type bounds are not allowed within structs, enums, or unions\n-//~| the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified [E0191]\n+//~^ ERROR associated type bounds are not allowed within structs, enums, or unions\n+//~| ERROR could not find defining uses\n union U3 { f: dyn Iterator<Item: 'static> }\n-//~^ associated type bounds are not allowed within structs, enums, or unions\n-//~| the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified [E0191]\n+//~^ ERROR associated type bounds are not allowed within structs, enums, or unions\n+//~| ERROR could not find defining uses"}, {"sha": "d0e0ceccd37253a3931eb2cb905ef7bc24e57e52", "filename": "src/test/ui/associated-type-bounds/inside-adt.stderr", "status": "modified", "additions": 45, "deletions": 9, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fassociated-type-bounds%2Finside-adt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fassociated-type-bounds%2Finside-adt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Finside-adt.stderr?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -1,53 +1,53 @@\n error: associated type bounds are not allowed within structs, enums, or unions\n-  --> $DIR/inside-adt.rs:8:29\n+  --> $DIR/inside-adt.rs:5:29\n    |\n LL | struct S1 { f: dyn Iterator<Item: Copy> }\n    |                             ^^^^^^^^^^\n \n error: associated type bounds are not allowed within structs, enums, or unions\n-  --> $DIR/inside-adt.rs:11:33\n+  --> $DIR/inside-adt.rs:8:33\n    |\n LL | struct S2 { f: Box<dyn Iterator<Item: Copy>> }\n    |                                 ^^^^^^^^^^\n \n error: associated type bounds are not allowed within structs, enums, or unions\n-  --> $DIR/inside-adt.rs:14:29\n+  --> $DIR/inside-adt.rs:11:29\n    |\n LL | struct S3 { f: dyn Iterator<Item: 'static> }\n    |                             ^^^^^^^^^^^^^\n \n error: associated type bounds are not allowed within structs, enums, or unions\n-  --> $DIR/inside-adt.rs:18:26\n+  --> $DIR/inside-adt.rs:15:26\n    |\n LL | enum E1 { V(dyn Iterator<Item: Copy>) }\n    |                          ^^^^^^^^^^\n \n error: associated type bounds are not allowed within structs, enums, or unions\n-  --> $DIR/inside-adt.rs:21:30\n+  --> $DIR/inside-adt.rs:18:30\n    |\n LL | enum E2 { V(Box<dyn Iterator<Item: Copy>>) }\n    |                              ^^^^^^^^^^\n \n error: associated type bounds are not allowed within structs, enums, or unions\n-  --> $DIR/inside-adt.rs:24:26\n+  --> $DIR/inside-adt.rs:21:26\n    |\n LL | enum E3 { V(dyn Iterator<Item: 'static>) }\n    |                          ^^^^^^^^^^^^^\n \n error: associated type bounds are not allowed within structs, enums, or unions\n-  --> $DIR/inside-adt.rs:28:28\n+  --> $DIR/inside-adt.rs:25:28\n    |\n LL | union U1 { f: dyn Iterator<Item: Copy> }\n    |                            ^^^^^^^^^^\n \n error: associated type bounds are not allowed within structs, enums, or unions\n-  --> $DIR/inside-adt.rs:31:32\n+  --> $DIR/inside-adt.rs:28:32\n    |\n LL | union U2 { f: Box<dyn Iterator<Item: Copy>> }\n    |                                ^^^^^^^^^^\n \n error: associated type bounds are not allowed within structs, enums, or unions\n-  --> $DIR/inside-adt.rs:34:28\n+  --> $DIR/inside-adt.rs:31:28\n    |\n LL | union U3 { f: dyn Iterator<Item: 'static> }\n    |                            ^^^^^^^^^^^^^\n@@ -57,22 +57,58 @@ error[E0601]: `main` function not found in crate `inside_adt`\n    = note: consider adding a `main` function to `$DIR/inside-adt.rs`\n \n error: could not find defining uses\n+  --> $DIR/inside-adt.rs:5:29\n+   |\n+LL | struct S1 { f: dyn Iterator<Item: Copy> }\n+   |                             ^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/inside-adt.rs:8:33\n+   |\n+LL | struct S2 { f: Box<dyn Iterator<Item: Copy>> }\n+   |                                 ^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/inside-adt.rs:11:29\n+   |\n+LL | struct S3 { f: dyn Iterator<Item: 'static> }\n+   |                             ^^^^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/inside-adt.rs:15:26\n+   |\n+LL | enum E1 { V(dyn Iterator<Item: Copy>) }\n+   |                          ^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/inside-adt.rs:18:30\n+   |\n+LL | enum E2 { V(Box<dyn Iterator<Item: Copy>>) }\n+   |                              ^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/inside-adt.rs:21:26\n+   |\n+LL | enum E3 { V(dyn Iterator<Item: 'static>) }\n+   |                          ^^^^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/inside-adt.rs:25:28\n+   |\n+LL | union U1 { f: dyn Iterator<Item: Copy> }\n+   |                            ^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/inside-adt.rs:28:32\n+   |\n+LL | union U2 { f: Box<dyn Iterator<Item: Copy>> }\n+   |                                ^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/inside-adt.rs:31:28\n+   |\n+LL | union U3 { f: dyn Iterator<Item: 'static> }\n+   |                            ^^^^^^^^^^^^^\n \n error: aborting due to 19 previous errors\n "}, {"sha": "4ddcdcac822823f6a701d605e78f5d161ded3add", "filename": "src/test/ui/async-await/async-block-control-flow-static-semantics.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -32,15 +32,14 @@ async fn return_targets_async_block_not_async_fn() -> u8 {\n \n fn no_break_in_async_block() {\n     async {\n-        break 0u8; //~ ERROR `break` inside of a closure\n-        // FIXME: This diagnostic is pretty bad.\n+        break 0u8; //~ ERROR `break` inside of an async block\n     };\n }\n \n fn no_break_in_async_block_even_with_outer_loop() {\n     loop {\n         async {\n-            break 0u8; //~ ERROR `break` inside of a closure\n+            break 0u8; //~ ERROR `break` inside of an async block\n         };\n     }\n }"}, {"sha": "a0a5ac63d84270204d1c2c54c84ae6261bb1fb02", "filename": "src/test/ui/async-await/async-block-control-flow-static-semantics.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -1,14 +1,14 @@\n-error[E0267]: `break` inside of a closure\n+error[E0267]: `break` inside of an async block\n   --> $DIR/async-block-control-flow-static-semantics.rs:35:9\n    |\n LL |         break 0u8;\n-   |         ^^^^^^^^^ cannot break inside of a closure\n+   |         ^^^^^^^^^ cannot break inside of an async block\n \n-error[E0267]: `break` inside of a closure\n-  --> $DIR/async-block-control-flow-static-semantics.rs:43:13\n+error[E0267]: `break` inside of an async block\n+  --> $DIR/async-block-control-flow-static-semantics.rs:42:13\n    |\n LL |             break 0u8;\n-   |             ^^^^^^^^^ cannot break inside of a closure\n+   |             ^^^^^^^^^ cannot break inside of an async block\n \n error[E0308]: mismatched types\n   --> $DIR/async-block-control-flow-static-semantics.rs:15:43\n@@ -52,7 +52,7 @@ LL | async fn return_targets_async_block_not_async_fn() -> u8 {\n    = note: the return type of a function must have a statically known size\n \n error[E0308]: mismatched types\n-  --> $DIR/async-block-control-flow-static-semantics.rs:51:44\n+  --> $DIR/async-block-control-flow-static-semantics.rs:50:44\n    |\n LL | fn rethrow_targets_async_block_not_fn() -> Result<u8, MyErr> {\n    |    ----------------------------------      ^^^^^^^^^^^^^^^^^ expected enum `std::result::Result`, found ()\n@@ -63,7 +63,7 @@ LL | fn rethrow_targets_async_block_not_fn() -> Result<u8, MyErr> {\n               found type `()`\n \n error[E0308]: mismatched types\n-  --> $DIR/async-block-control-flow-static-semantics.rs:60:50\n+  --> $DIR/async-block-control-flow-static-semantics.rs:59:50\n    |\n LL | fn rethrow_targets_async_block_not_async_fn() -> Result<u8, MyErr> {\n    |    ----------------------------------------      ^^^^^^^^^^^^^^^^^ expected enum `std::result::Result`, found ()"}, {"sha": "d2fa5d0a3d0f189b5507dd4c6c1566f866fbba5c", "filename": "src/test/ui/async-await/async-borrowck-escaping-closure-error.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fasync-await%2Fasync-borrowck-escaping-closure-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fasync-await%2Fasync-borrowck-escaping-closure-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-borrowck-escaping-closure-error.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -0,0 +1,10 @@\n+// edition:2018\n+#![feature(async_closure,async_await)]\n+fn foo() -> Box<dyn std::future::Future<Output = u32>> {\n+    let x = 0u32;\n+    Box::new((async || x)())\n+    //~^ ERROR E0373\n+}\n+\n+fn main() {\n+}"}, {"sha": "8bcfcf989208e05fbdbd5eba66d2176e1f09c824", "filename": "src/test/ui/async-await/async-borrowck-escaping-closure-error.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fasync-await%2Fasync-borrowck-escaping-closure-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fasync-await%2Fasync-borrowck-escaping-closure-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-borrowck-escaping-closure-error.stderr?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -0,0 +1,21 @@\n+error[E0373]: closure may outlive the current function, but it borrows `x`, which is owned by the current function\n+  --> $DIR/async-borrowck-escaping-closure-error.rs:5:15\n+   |\n+LL |     Box::new((async || x)())\n+   |               ^^^^^^^^ - `x` is borrowed here\n+   |               |\n+   |               may outlive borrowed value `x`\n+   |\n+note: closure is returned here\n+  --> $DIR/async-borrowck-escaping-closure-error.rs:5:5\n+   |\n+LL |     Box::new((async || x)())\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+help: to force the closure to take ownership of `x` (and any other referenced variables), use the `move` keyword\n+   |\n+LL |     Box::new((async move || x)())\n+   |               ^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0373`."}, {"sha": "5955d9751afbbf3afe57767893c046c1eaa2a590", "filename": "src/test/ui/async-await/issues/issue-62517-1.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62517-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62517-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62517-1.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -0,0 +1,23 @@\n+// Regression test for #62517. We used to ICE when you had an `async\n+// fn` with an `impl Trait` return that mentioned a `dyn Bar` with no\n+// explicit lifetime bound.\n+//\n+// edition:2018\n+// check-pass\n+\n+#![feature(async_await)]\n+\n+trait FirstTrait {}\n+trait SecondTrait {\n+    type Item: ?Sized;\n+}\n+\n+async fn foo(x: &str) -> impl SecondTrait<Item = dyn FirstTrait> {\n+}\n+\n+\n+impl<T> SecondTrait for T {\n+    type Item = dyn FirstTrait;\n+}\n+\n+fn main() { }"}, {"sha": "17fac408151eaeb359771c8c9e8c55b957dd2517", "filename": "src/test/ui/async-await/issues/issue-62517-2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62517-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62517-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62517-2.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -0,0 +1,18 @@\n+// Regression test for #62517. We used to ICE when you had an `async\n+// fn` with an `impl Trait` return that mentioned a `dyn Bar` with no\n+// explicit lifetime bound.\n+//\n+// edition:2018\n+// check-pass\n+\n+#![feature(async_await)]\n+\n+trait Object {}\n+\n+trait Alpha<Param: ?Sized> {}\n+\n+async fn foo<'a>(_: &'a ()) -> impl Alpha<dyn Object> {}\n+\n+impl<T> Alpha<dyn Object> for T { }\n+\n+fn main() { }"}, {"sha": "832095ce542062b89c2d76fd8332bfb7eae21950", "filename": "src/test/ui/const-generics/issue-61432.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61432.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61432.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61432.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -0,0 +1,17 @@\n+// run-pass\n+\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+fn promote<const N: i32>() {\n+    // works:\n+    //\n+    // let n = N;\n+    // &n;\n+\n+    &N;\n+}\n+\n+fn main() {\n+    promote::<0>();\n+}"}, {"sha": "33f77b028104eb40ab44c3c247d56d2221db237f", "filename": "src/test/ui/const-generics/issue-61432.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61432.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61432.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61432.stderr?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -0,0 +1,8 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/issue-61432.rs:3:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+"}, {"sha": "7a299169bc4e19e59a5c0d63749140049a14fe9a", "filename": "src/test/ui/consts/too_generic_eval_ice.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -0,0 +1,13 @@\n+pub struct Foo<A, B>(A, B);\n+\n+impl<A, B> Foo<A, B> {\n+    const HOST_SIZE: usize = std::mem::size_of::<B>();\n+\n+    pub fn crash() -> bool {\n+        [5; Self::HOST_SIZE] == [6; 0] //~ ERROR no associated item named `HOST_SIZE`\n+        //~^ the size for values of type `A` cannot be known\n+        //~| the size for values of type `B` cannot be known\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "eef79421270ce6c917c774a9ef08648acb0201ce", "filename": "src/test/ui/consts/too_generic_eval_ice.stderr", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.stderr?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -0,0 +1,47 @@\n+error[E0599]: no associated item named `HOST_SIZE` found for type `Foo<A, B>` in the current scope\n+  --> $DIR/too_generic_eval_ice.rs:7:19\n+   |\n+LL | pub struct Foo<A, B>(A, B);\n+   | --------------------------- associated item `HOST_SIZE` not found for this\n+...\n+LL |         [5; Self::HOST_SIZE] == [6; 0]\n+   |                   ^^^^^^^^^ associated item not found in `Foo<A, B>`\n+   |\n+   = note: the method `HOST_SIZE` exists but the following trait bounds were not satisfied:\n+           `A : std::marker::Sized`\n+           `B : std::marker::Sized`\n+\n+error[E0277]: the size for values of type `A` cannot be known at compilation time\n+  --> $DIR/too_generic_eval_ice.rs:7:13\n+   |\n+LL |         [5; Self::HOST_SIZE] == [6; 0]\n+   |             ^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `A`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+   = help: consider adding a `where A: std::marker::Sized` bound\n+note: required by `Foo`\n+  --> $DIR/too_generic_eval_ice.rs:1:1\n+   |\n+LL | pub struct Foo<A, B>(A, B);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0277]: the size for values of type `B` cannot be known at compilation time\n+  --> $DIR/too_generic_eval_ice.rs:7:13\n+   |\n+LL |         [5; Self::HOST_SIZE] == [6; 0]\n+   |             ^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `B`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+   = help: consider adding a `where B: std::marker::Sized` bound\n+note: required by `Foo`\n+  --> $DIR/too_generic_eval_ice.rs:1:1\n+   |\n+LL | pub struct Foo<A, B>(A, B);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0277, E0599.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "5d779355400ccf6c0ee8040a568776999191c96a", "filename": "src/test/ui/consts/zst_no_llvm_alloc.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fconsts%2Fzst_no_llvm_alloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fconsts%2Fzst_no_llvm_alloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fzst_no_llvm_alloc.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -0,0 +1,19 @@\n+// run-pass\n+\n+#[repr(align(4))]\n+struct Foo;\n+\n+static FOO: Foo = Foo;\n+\n+fn main() {\n+    let x: &'static () = &();\n+    assert_eq!(x as *const () as usize, 1);\n+    let x: &'static Foo = &Foo;\n+    assert_eq!(x as *const Foo as usize, 4);\n+\n+    // statics must have a unique address\n+    assert_ne!(&FOO as *const Foo as usize, 4);\n+\n+    assert_eq!(<Vec<i32>>::new().as_ptr(), <&[i32]>::default().as_ptr());\n+    assert_eq!(<Box<[i32]>>::default().as_ptr(), (&[]).as_ptr());\n+}"}, {"sha": "036a6095965bdd0c6689284b0db25d832d60d375", "filename": "src/test/ui/feature-gate/feature-gate-or_patterns.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Ffeature-gate%2Ffeature-gate-or_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Ffeature-gate%2Ffeature-gate-or_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Ffeature-gate-or_patterns.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -0,0 +1,9 @@\n+#![crate_type=\"lib\"]\n+\n+pub fn example(x: Option<usize>) {\n+    match x {\n+        Some(0 | 1 | 2) => {}\n+        //~^ ERROR: or-patterns syntax is experimental\n+        _ => {}\n+    }\n+}"}, {"sha": "aaabb54c1f017914a818f45d9f2f3516b51a8fa0", "filename": "src/test/ui/feature-gate/feature-gate-or_patterns.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Ffeature-gate%2Ffeature-gate-or_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Ffeature-gate%2Ffeature-gate-or_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Ffeature-gate-or_patterns.stderr?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -0,0 +1,12 @@\n+error[E0658]: or-patterns syntax is experimental\n+  --> $DIR/feature-gate-or_patterns.rs:5:14\n+   |\n+LL |         Some(0 | 1 | 2) => {}\n+   |              ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/54883\n+   = help: add `#![feature(or_patterns)]` to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "3b7141573847f6fe39c554ef505553b6f824d488", "filename": "src/test/ui/impl-trait/dyn-trait-elided-two-inputs-assoc.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-elided-two-inputs-assoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-elided-two-inputs-assoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-elided-two-inputs-assoc.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -0,0 +1,16 @@\n+// Test that we don't get an error with `dyn Bar` in an impl Trait\n+// when there are multiple inputs.  The `dyn Bar` should default to `+\n+// 'static`. This used to erroneously generate an error (cc #62517).\n+//\n+// check-pass\n+\n+trait Foo { type Item: ?Sized; }\n+trait Bar { }\n+\n+impl<T> Foo for T {\n+    type Item = dyn Bar;\n+}\n+\n+fn foo(x: &str, y: &str) -> impl Foo<Item = dyn Bar> { () }\n+\n+fn main() { }"}, {"sha": "e8da52aad0eac01b8a9ddfb16875dcdb3d3b77e3", "filename": "src/test/ui/impl-trait/dyn-trait-elided-two-inputs-param.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-elided-two-inputs-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-elided-two-inputs-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-elided-two-inputs-param.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -0,0 +1,11 @@\n+// Test that we don't get an error with `dyn Object` in an impl Trait\n+// when there are multiple inputs.  The `dyn Object` should default to `+\n+// 'static`. This used to erroneously generate an error (cc #62517).\n+//\n+// check-pass\n+\n+trait Alpha<Item: ?Sized> {}\n+trait Object {}\n+impl<T> Alpha<dyn Object> for T {}\n+fn alpha(x: &str, y: &str) -> impl Alpha<dyn Object> { () }\n+fn main() { }"}, {"sha": "aad9d89fe2433ecaaa4479c7cc2d1e6672d99dd0", "filename": "src/test/ui/impl-trait/dyn-trait-elided-two-inputs-ref-assoc.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-elided-two-inputs-ref-assoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-elided-two-inputs-ref-assoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-elided-two-inputs-ref-assoc.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -0,0 +1,27 @@\n+// Test that we don't get an error with `dyn Bar` in an impl Trait\n+// when there are multiple inputs.  The `dyn Bar` should default to `+\n+// 'static`. This used to erroneously generate an error (cc #62517).\n+//\n+// check-pass\n+\n+trait Foo {\n+    type Item: ?Sized;\n+\n+    fn item(&self) -> Box<Self::Item> { panic!() }\n+}\n+\n+trait Bar { }\n+\n+impl<T> Foo for T {\n+    type Item = dyn Bar;\n+}\n+\n+fn is_static<T>(_: T) where T: 'static { }\n+\n+fn bar(x: &str) -> &impl Foo<Item = dyn Bar> { &() }\n+\n+fn main() {\n+    let s = format!(\"foo\");\n+    let r = bar(&s);\n+    is_static(r.item());\n+}"}, {"sha": "8d34c1b6c2af7a90bcddd6ba5c29384fd7193e6a", "filename": "src/test/ui/impl-trait/dyn-trait-elided-two-inputs-ref-param.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-elided-two-inputs-ref-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-elided-two-inputs-ref-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-elided-two-inputs-ref-param.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -0,0 +1,23 @@\n+// Test that `impl Alpha<dyn Object>` resets the object-lifetime\n+// default to `'static`.\n+//\n+// check-pass\n+\n+trait Alpha<Item: ?Sized> {\n+    fn item(&self) -> Box<Item> {\n+        panic!()\n+    }\n+}\n+\n+trait Object {}\n+impl<T> Alpha<dyn Object> for T {}\n+fn alpha(x: &str, y: &str) -> impl Alpha<dyn Object> { () }\n+fn is_static<T>(_: T) where T: 'static { }\n+\n+fn bar(x: &str) -> &impl Alpha<dyn Object> { &() }\n+\n+fn main() {\n+    let s = format!(\"foo\");\n+    let r = bar(&s);\n+    is_static(r.item());\n+}"}, {"sha": "ea0d0ccbc553270c9fc290f10065a3080571377d", "filename": "src/test/ui/lifetimes/lifetime-elision-return-type-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -6,7 +6,7 @@ trait Future {\n use std::error::Error;\n \n fn foo() -> impl Future<Item=(), Error=Box<dyn Error>> {\n-//~^ ERROR missing lifetime\n+//~^ ERROR not satisfied\n     Ok(())\n }\n "}, {"sha": "228582d0001daafdf6bca1198a862316cc9e1da0", "filename": "src/test/ui/lifetimes/lifetime-elision-return-type-trait.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.stderr?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -1,11 +1,11 @@\n-error[E0106]: missing lifetime specifier\n-  --> $DIR/lifetime-elision-return-type-trait.rs:8:44\n+error[E0277]: the trait bound `std::result::Result<(), _>: Future` is not satisfied\n+  --> $DIR/lifetime-elision-return-type-trait.rs:8:13\n    |\n LL | fn foo() -> impl Future<Item=(), Error=Box<dyn Error>> {\n-   |                                            ^^^^^^^^^ help: consider giving it a 'static lifetime: `dyn Error + 'static`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Future` is not implemented for `std::result::Result<(), _>`\n    |\n-   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+   = note: the return type of a function must have a statically known size\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0106`.\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "250773a1853ec32a18745ead74d89516ba14e4f8", "filename": "src/test/ui/macros/same-sequence-span.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.stderr?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -18,15 +18,21 @@ error: `$x:expr` may be followed by `$y:tt`, which is not allowed for `expr` fra\n   --> $DIR/same-sequence-span.rs:20:1\n    |\n LL | proc_macro_sequence::make_foo!();\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not allowed after `expr` fragments\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | |\n+   | not allowed after `expr` fragments\n+   | in this macro invocation\n    |\n    = note: allowed there are: `=>`, `,` or `;`\n \n error: `$x:expr` may be followed by `=`, which is not allowed for `expr` fragments\n   --> $DIR/same-sequence-span.rs:20:1\n    |\n LL | proc_macro_sequence::make_foo!();\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not allowed after `expr` fragments\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | |\n+   | not allowed after `expr` fragments\n+   | in this macro invocation\n    |\n    = note: allowed there are: `=>`, `,` or `;`\n "}, {"sha": "7337383e2978425a83715e9fe4a978bc38eb04e0", "filename": "src/test/ui/object-lifetime/object-lifetime-default-dyn-binding-nonstatic1.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic1.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -0,0 +1,27 @@\n+// Test that `dyn Bar<Item = XX>` uses `'static` as the default object\n+// lifetime bound for the type `XX`.\n+\n+trait Foo<'a> {\n+    type Item: ?Sized;\n+\n+    fn item(&self) -> Box<Self::Item> { panic!() }\n+}\n+\n+trait Bar { }\n+\n+impl<T> Foo<'_> for T {\n+    type Item = dyn Bar;\n+}\n+\n+fn is_static<T>(_: T) where T: 'static { }\n+\n+// Here, we should default to `dyn Bar + 'static`, but the current\n+// code forces us into a conservative, hacky path.\n+fn bar<'a>(x: &'a str) -> &'a dyn Foo<'a, Item = dyn Bar> { &() }\n+//~^ ERROR please supply an explicit bound\n+\n+fn main() {\n+    let s = format!(\"foo\");\n+    let r = bar(&s);\n+    is_static(r.item());\n+}"}, {"sha": "9dbf7a78ed7a7406ace2e3185c9b1db8a3742d83", "filename": "src/test/ui/object-lifetime/object-lifetime-default-dyn-binding-nonstatic1.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic1.stderr?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -0,0 +1,8 @@\n+error[E0228]: the lifetime bound for this object type cannot be deduced from context; please supply an explicit bound\n+  --> $DIR/object-lifetime-default-dyn-binding-nonstatic1.rs:20:50\n+   |\n+LL | fn bar<'a>(x: &'a str) -> &'a dyn Foo<'a, Item = dyn Bar> { &() }\n+   |                                                  ^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "2a7415174f8a0ca20f3df9378520953e77da2216", "filename": "src/test/ui/object-lifetime/object-lifetime-default-dyn-binding-nonstatic2.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic2.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -0,0 +1,30 @@\n+// Test that `dyn Bar<Item = XX>` uses `'static` as the default object\n+// lifetime bound for the type `XX`.\n+\n+trait Foo<'a> {\n+    type Item: 'a + ?Sized;\n+\n+    fn item(&self) -> Box<Self::Item> { panic!() }\n+}\n+\n+trait Bar { }\n+\n+impl<T> Foo<'_> for T {\n+    type Item = dyn Bar;\n+}\n+\n+fn is_static<T>(_: T) where T: 'static { }\n+\n+// Here, we default to `dyn Bar + 'a`.  Or, we *should*, but the\n+// current code forces us into a conservative, hacky path.\n+fn bar<'a>(x: &'a str) -> &'a dyn Foo<'a, Item = dyn Bar> { &() }\n+//~^ ERROR please supply an explicit bound\n+\n+fn main() {\n+    let s = format!(\"foo\");\n+    let r = bar(&s);\n+\n+    // If it weren't for the conservative path above, we'd expect an\n+    // error here.\n+    is_static(r.item());\n+}"}, {"sha": "d069f52ce47db4ef1cb13fff4d4ca2bf33b910de", "filename": "src/test/ui/object-lifetime/object-lifetime-default-dyn-binding-nonstatic2.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic2.stderr?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -0,0 +1,8 @@\n+error[E0228]: the lifetime bound for this object type cannot be deduced from context; please supply an explicit bound\n+  --> $DIR/object-lifetime-default-dyn-binding-nonstatic2.rs:20:50\n+   |\n+LL | fn bar<'a>(x: &'a str) -> &'a dyn Foo<'a, Item = dyn Bar> { &() }\n+   |                                                  ^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "51be999a6329d09f85cda3e7a804827eba0765cc", "filename": "src/test/ui/object-lifetime/object-lifetime-default-dyn-binding-nonstatic3.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic3.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -0,0 +1,23 @@\n+// Test that `dyn Bar<Item = XX>` uses `'static` as the default object\n+// lifetime bound for the type `XX`.\n+\n+trait Foo<'a> {\n+    type Item: ?Sized;\n+\n+    fn item(&self) -> Box<Self::Item> { panic!() }\n+}\n+\n+trait Bar { }\n+\n+fn is_static<T>(_: T) where T: 'static { }\n+\n+// Here, we should default to `dyn Bar + 'static`, but the current\n+// code forces us into a conservative, hacky path.\n+fn bar(x: &str) -> &dyn Foo<Item = dyn Bar> { &() }\n+//~^ ERROR please supply an explicit bound\n+\n+fn main() {\n+    let s = format!(\"foo\");\n+    let r = bar(&s);\n+    is_static(r.item());\n+}"}, {"sha": "9c7b6b98f2e3620375fca614ca63f47114dc634b", "filename": "src/test/ui/object-lifetime/object-lifetime-default-dyn-binding-nonstatic3.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic3.stderr?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -0,0 +1,8 @@\n+error[E0228]: the lifetime bound for this object type cannot be deduced from context; please supply an explicit bound\n+  --> $DIR/object-lifetime-default-dyn-binding-nonstatic3.rs:16:36\n+   |\n+LL | fn bar(x: &str) -> &dyn Foo<Item = dyn Bar> { &() }\n+   |                                    ^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "339f3356bd71ea66f2a1dc1df6130ac63f8cbf30", "filename": "src/test/ui/object-lifetime/object-lifetime-default-dyn-binding-static.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-static.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -0,0 +1,28 @@\n+// Test that `dyn Bar<Item = XX>` uses `'static` as the default object\n+// lifetime bound for the type `XX`.\n+//\n+// check-pass\n+\n+trait Foo {\n+    type Item: ?Sized;\n+\n+    fn item(&self) -> Box<Self::Item> { panic!() }\n+}\n+\n+trait Bar { }\n+\n+impl<T> Foo for T {\n+    type Item = dyn Bar;\n+}\n+\n+fn is_static<T>(_: T) where T: 'static { }\n+\n+// Here, we default to `dyn Bar + 'static`, and not `&'x dyn Foo<Item\n+// = dyn Bar + 'x>`.\n+fn bar(x: &str) -> &dyn Foo<Item = dyn Bar> { &() }\n+\n+fn main() {\n+    let s = format!(\"foo\");\n+    let r = bar(&s);\n+    is_static(r.item());\n+}"}, {"sha": "f27caa5d78c8eaf42be834c1f8963dbadea97f53", "filename": "src/test/ui/parser/pat-lt-bracket-6.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fparser%2Fpat-lt-bracket-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fparser%2Fpat-lt-bracket-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpat-lt-bracket-6.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -2,8 +2,9 @@ fn main() {\n     struct Test(&'static u8, [u8; 0]);\n     let x = Test(&0, []);\n \n-    let Test(&desc[..]) = x; //~ ERROR: expected one of `)`, `,`, or `@`, found `[`\n-    //~^ ERROR subslice patterns are unstable\n+    let Test(&desc[..]) = x;\n+    //~^ ERROR: expected one of `)`, `,`, `@`, or `|`, found `[`\n+    //~^^ ERROR subslice patterns are unstable\n }\n \n const RECOVERY_WITNESS: () = 0; //~ ERROR mismatched types"}, {"sha": "6f08f0a9d95ef117bf83899a3b28a08e725f7ada", "filename": "src/test/ui/parser/pat-lt-bracket-6.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fparser%2Fpat-lt-bracket-6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fparser%2Fpat-lt-bracket-6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpat-lt-bracket-6.stderr?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `)`, `,`, or `@`, found `[`\n+error: expected one of `)`, `,`, `@`, or `|`, found `[`\n   --> $DIR/pat-lt-bracket-6.rs:5:19\n    |\n LL |     let Test(&desc[..]) = x;\n-   |                   ^ expected one of `)`, `,`, or `@` here\n+   |                   ^ expected one of `)`, `,`, `@`, or `|` here\n \n error[E0658]: subslice patterns are unstable\n   --> $DIR/pat-lt-bracket-6.rs:5:20\n@@ -14,7 +14,7 @@ LL |     let Test(&desc[..]) = x;\n    = help: add `#![feature(slice_patterns)]` to the crate attributes to enable\n \n error[E0308]: mismatched types\n-  --> $DIR/pat-lt-bracket-6.rs:9:30\n+  --> $DIR/pat-lt-bracket-6.rs:10:30\n    |\n LL | const RECOVERY_WITNESS: () = 0;\n    |                              ^ expected (), found integer"}, {"sha": "327aef5ad15703cd16770ccdcd00dd8803c5e0ea", "filename": "src/test/ui/parser/pat-lt-bracket-7.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fparser%2Fpat-lt-bracket-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fparser%2Fpat-lt-bracket-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpat-lt-bracket-7.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -2,7 +2,8 @@ fn main() {\n     struct Thing(u8, [u8; 0]);\n     let foo = core::iter::empty();\n \n-    for Thing(x[]) in foo {} //~ ERROR: expected one of `)`, `,`, or `@`, found `[`\n+    for Thing(x[]) in foo {}\n+    //~^ ERROR: expected one of `)`, `,`, `@`, or `|`, found `[`\n }\n \n const RECOVERY_WITNESS: () = 0; //~ ERROR mismatched types"}, {"sha": "196f1c0ae914f51b5f1a963e9bbd723277c8333c", "filename": "src/test/ui/parser/pat-lt-bracket-7.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fparser%2Fpat-lt-bracket-7.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fparser%2Fpat-lt-bracket-7.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpat-lt-bracket-7.stderr?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -1,11 +1,11 @@\n-error: expected one of `)`, `,`, or `@`, found `[`\n+error: expected one of `)`, `,`, `@`, or `|`, found `[`\n   --> $DIR/pat-lt-bracket-7.rs:5:16\n    |\n LL |     for Thing(x[]) in foo {}\n-   |                ^ expected one of `)`, `,`, or `@` here\n+   |                ^ expected one of `)`, `,`, `@`, or `|` here\n \n error[E0308]: mismatched types\n-  --> $DIR/pat-lt-bracket-7.rs:8:30\n+  --> $DIR/pat-lt-bracket-7.rs:9:30\n    |\n LL | const RECOVERY_WITNESS: () = 0;\n    |                              ^ expected (), found integer"}, {"sha": "c6be2c90667c2626242fb4ea62b3dabd365023f5", "filename": "src/test/ui/parser/recover-for-loop-parens-around-head.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fparser%2Frecover-for-loop-parens-around-head.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fparser%2Frecover-for-loop-parens-around-head.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-for-loop-parens-around-head.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -8,7 +8,7 @@ fn main() {\n     let vec = vec![1, 2, 3];\n \n     for ( elem in vec ) {\n-        //~^ ERROR expected one of `)`, `,`, or `@`, found `in`\n+        //~^ ERROR expected one of `)`, `,`, `@`, or `|`, found `in`\n         //~| ERROR unexpected closing `)`\n         const RECOVERY_WITNESS: () = 0; //~ ERROR mismatched types\n     }"}, {"sha": "1b5b6cca09243a63f1746cf1d836933148611bd5", "filename": "src/test/ui/parser/recover-for-loop-parens-around-head.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fparser%2Frecover-for-loop-parens-around-head.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fparser%2Frecover-for-loop-parens-around-head.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-for-loop-parens-around-head.stderr?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `)`, `,`, or `@`, found `in`\n+error: expected one of `)`, `,`, `@`, or `|`, found `in`\n   --> $DIR/recover-for-loop-parens-around-head.rs:10:16\n    |\n LL |     for ( elem in vec ) {\n-   |                ^^ expected one of `)`, `,`, or `@` here\n+   |                ^^ expected one of `)`, `,`, `@`, or `|` here\n \n error: unexpected closing `)`\n   --> $DIR/recover-for-loop-parens-around-head.rs:10:23"}, {"sha": "829d8bf4c81dae86f65e7061d5919ca1252c552c", "filename": "src/test/ui/proc-macro/generate-mod.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fproc-macro%2Fgenerate-mod.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fproc-macro%2Fgenerate-mod.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fgenerate-mod.stderr?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -2,13 +2,19 @@ error[E0412]: cannot find type `FromOutside` in this scope\n   --> $DIR/generate-mod.rs:9:1\n    |\n LL | generate_mod::check!();\n-   | ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n+   | ^^^^^^^^^^^^^^^^^^^^^^^\n+   | |\n+   | not found in this scope\n+   | in this macro invocation\n \n error[E0412]: cannot find type `Outer` in this scope\n   --> $DIR/generate-mod.rs:9:1\n    |\n LL | generate_mod::check!();\n-   | ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n+   | ^^^^^^^^^^^^^^^^^^^^^^^\n+   | |\n+   | not found in this scope\n+   | in this macro invocation\n \n error[E0412]: cannot find type `FromOutside` in this scope\n   --> $DIR/generate-mod.rs:12:1"}, {"sha": "65e40172ef539b24a03e36abaffff8ce6b25d736", "filename": "src/test/ui/proc-macro/invalid-punct-ident-4.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-4.stderr?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -2,7 +2,10 @@ error: unexpected close delimiter: `)`\n   --> $DIR/invalid-punct-ident-4.rs:6:1\n    |\n LL | lexer_failure!();\n-   | ^^^^^^^^^^^^^^^^^ unexpected close delimiter\n+   | ^^^^^^^^^^^^^^^^^\n+   | |\n+   | unexpected close delimiter\n+   | in this macro invocation\n \n error: proc macro panicked\n   --> $DIR/invalid-punct-ident-4.rs:6:1"}, {"sha": "f28b8c9fb73e9650b650668779a9581dfd9b685b", "filename": "src/test/ui/proc-macro/lints_in_proc_macros.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fproc-macro%2Flints_in_proc_macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fproc-macro%2Flints_in_proc_macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Flints_in_proc_macros.stderr?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -2,7 +2,10 @@ error[E0425]: cannot find value `foobar2` in this scope\n   --> $DIR/lints_in_proc_macros.rs:12:5\n    |\n LL |     bang_proc_macro2!();\n-   |     ^^^^^^^^^^^^^^^^^^^^ help: a local variable with a similar name exists: `foobar`\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+   |     |\n+   |     help: a local variable with a similar name exists: `foobar`\n+   |     in this macro invocation\n \n error: aborting due to previous error\n "}, {"sha": "a0c1f9cd5c05f9dcd2d387e0cddf347f5d1c1990", "filename": "src/test/ui/proc-macro/multispan.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fproc-macro%2Fmultispan.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fproc-macro%2Fmultispan.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmultispan.stderr?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -2,7 +2,7 @@ error: hello to you, too!\n   --> $DIR/multispan.rs:14:5\n    |\n LL |     hello!(hi);\n-   |     ^^^^^^^^^^^\n+   |     ^^^^^^^^^^^ in this macro invocation\n    |\n note: found these 'hi's\n   --> $DIR/multispan.rs:14:12\n@@ -14,7 +14,7 @@ error: hello to you, too!\n   --> $DIR/multispan.rs:17:5\n    |\n LL |     hello!(hi hi);\n-   |     ^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: found these 'hi's\n   --> $DIR/multispan.rs:17:12\n@@ -26,7 +26,7 @@ error: hello to you, too!\n   --> $DIR/multispan.rs:20:5\n    |\n LL |     hello!(hi hi hi);\n-   |     ^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: found these 'hi's\n   --> $DIR/multispan.rs:20:12\n@@ -38,7 +38,7 @@ error: hello to you, too!\n   --> $DIR/multispan.rs:23:5\n    |\n LL |     hello!(hi hey hi yo hi beep beep hi hi);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: found these 'hi's\n   --> $DIR/multispan.rs:23:12\n@@ -50,7 +50,7 @@ error: hello to you, too!\n   --> $DIR/multispan.rs:24:5\n    |\n LL |     hello!(hi there, hi how are you? hi... hi.);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: found these 'hi's\n   --> $DIR/multispan.rs:24:12\n@@ -62,7 +62,7 @@ error: hello to you, too!\n   --> $DIR/multispan.rs:25:5\n    |\n LL |     hello!(whoah. hi di hi di ho);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: found these 'hi's\n   --> $DIR/multispan.rs:25:19\n@@ -74,7 +74,7 @@ error: hello to you, too!\n   --> $DIR/multispan.rs:26:5\n    |\n LL |     hello!(hi good hi and good bye);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: found these 'hi's\n   --> $DIR/multispan.rs:26:12"}, {"sha": "06715c197bc5975c2a7894c88398281a79c0480c", "filename": "src/test/ui/proc-macro/subspan.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fproc-macro%2Fsubspan.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fproc-macro%2Fsubspan.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fsubspan.stderr?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -2,7 +2,7 @@ error: found 'hi's\n   --> $DIR/subspan.rs:11:1\n    |\n LL | subspan!(\"hi\");\n-   | ^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: here\n   --> $DIR/subspan.rs:11:11\n@@ -14,7 +14,7 @@ error: found 'hi's\n   --> $DIR/subspan.rs:14:1\n    |\n LL | subspan!(\"hihi\");\n-   | ^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: here\n   --> $DIR/subspan.rs:14:11\n@@ -26,7 +26,7 @@ error: found 'hi's\n   --> $DIR/subspan.rs:17:1\n    |\n LL | subspan!(\"hihihi\");\n-   | ^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: here\n   --> $DIR/subspan.rs:17:11\n@@ -38,7 +38,7 @@ error: found 'hi's\n   --> $DIR/subspan.rs:20:1\n    |\n LL | subspan!(\"why I hide? hi!\");\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: here\n   --> $DIR/subspan.rs:20:17\n@@ -50,7 +50,7 @@ error: found 'hi's\n   --> $DIR/subspan.rs:21:1\n    |\n LL | subspan!(\"hey, hi, hidy, hidy, hi hi\");\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: here\n   --> $DIR/subspan.rs:21:16\n@@ -62,7 +62,7 @@ error: found 'hi's\n   --> $DIR/subspan.rs:22:1\n    |\n LL | subspan!(\"this is a hi, and this is another hi\");\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: here\n   --> $DIR/subspan.rs:22:12\n@@ -74,7 +74,7 @@ error: found 'hi's\n   --> $DIR/subspan.rs:23:1\n    |\n LL | subspan!(\"how are you this evening\");\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: here\n   --> $DIR/subspan.rs:23:24\n@@ -86,7 +86,7 @@ error: found 'hi's\n   --> $DIR/subspan.rs:24:1\n    |\n LL | subspan!(\"this is highly eradic\");\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: here\n   --> $DIR/subspan.rs:24:12"}, {"sha": "0a6cbe13098a8c20f849b09962dcc5c4b5b8b05b", "filename": "src/test/ui/proc-macro/three-equals.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fproc-macro%2Fthree-equals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fproc-macro%2Fthree-equals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fthree-equals.stderr?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -2,7 +2,7 @@ error: found 2 equal signs, need exactly 3\n   --> $DIR/three-equals.rs:15:5\n    |\n LL |     three_equals!(==);\n-   |     ^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n    = help: input must be: `===`\n "}, {"sha": "c938ce8dad98d69a9beef006d41fb432d1b04d49", "filename": "src/test/ui/structs/struct-path-self.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -3,13 +3,13 @@ struct S;\n trait Tr {\n     fn f() {\n         let s = Self {};\n-        //~^ ERROR expected struct, variant or union type, found Self\n+        //~^ ERROR expected struct, variant or union type, found type parameter\n         let z = Self::<u8> {};\n-        //~^ ERROR expected struct, variant or union type, found Self\n+        //~^ ERROR expected struct, variant or union type, found type parameter\n         //~| ERROR type arguments are not allowed for this type\n         match s {\n             Self { .. } => {}\n-            //~^ ERROR expected struct, variant or union type, found Self\n+            //~^ ERROR expected struct, variant or union type, found type parameter\n         }\n     }\n }"}, {"sha": "8c88cacc69e315f8607e7e91de664c50908bbef7", "filename": "src/test/ui/structs/struct-path-self.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.stderr?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -1,4 +1,4 @@\n-error[E0071]: expected struct, variant or union type, found Self\n+error[E0071]: expected struct, variant or union type, found type parameter\n   --> $DIR/struct-path-self.rs:5:17\n    |\n LL |         let s = Self {};\n@@ -10,13 +10,13 @@ error[E0109]: type arguments are not allowed for this type\n LL |         let z = Self::<u8> {};\n    |                        ^^ type argument not allowed\n \n-error[E0071]: expected struct, variant or union type, found Self\n+error[E0071]: expected struct, variant or union type, found type parameter\n   --> $DIR/struct-path-self.rs:7:17\n    |\n LL |         let z = Self::<u8> {};\n    |                 ^^^^^^^^^^ not a struct\n \n-error[E0071]: expected struct, variant or union type, found Self\n+error[E0071]: expected struct, variant or union type, found type parameter\n   --> $DIR/struct-path-self.rs:11:13\n    |\n LL |             Self { .. } => {}"}, {"sha": "71fb7f380aeac6e72a36a6f6c8371bfc82f50ecb", "filename": "src/test/ui/type/type-params-in-different-spaces-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-1.rs?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -5,7 +5,7 @@ trait BrokenAdd: Copy + Add<Output=Self> {\n         *self + rhs //~  ERROR mismatched types\n                     //~| expected type `Self`\n                     //~| found type `T`\n-                    //~| expected Self, found type parameter\n+                    //~| expected type parameter, found a different type parameter\n     }\n }\n "}, {"sha": "0448a28ea8e2721b7722fa7ab09c2dd484f89bd9", "filename": "src/test/ui/type/type-params-in-different-spaces-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-1.stderr?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/type-params-in-different-spaces-1.rs:5:17\n    |\n LL |         *self + rhs\n-   |                 ^^^ expected Self, found type parameter\n+   |                 ^^^ expected type parameter, found a different type parameter\n    |\n    = note: expected type `Self`\n               found type `T`"}, {"sha": "e25f79947c73233c0128a9f253b06fe9c42219f2", "filename": "src/test/ui/type/type-params-in-different-spaces-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7daf890d752c79b554528716fedd5f0b9abc8914/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-3.stderr?ref=7daf890d752c79b554528716fedd5f0b9abc8914", "patch": "@@ -4,7 +4,7 @@ error[E0308]: mismatched types\n LL |     fn test<X>(u: X) -> Self {\n    |                         ---- expected `Self` because of return type\n LL |         u\n-   |         ^ expected Self, found type parameter\n+   |         ^ expected type parameter, found a different type parameter\n    |\n    = note: expected type `Self`\n               found type `X`"}]}