{"sha": "3ac89737ca60913c6777ef8a000e6aefb9f183c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhYzg5NzM3Y2E2MDkxM2M2Nzc3ZWY4YTAwMGU2YWVmYjlmMTgzYzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-21T08:21:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-21T08:21:51Z"}, "message": "auto merge of #5465 : sanxiyn/rust/remove-oldmap, r=sanxiyn\n\nImproves resolve by 20% as measured by time-passes on rustc.", "tree": {"sha": "bf5b22e7001506bfa95b687761171054c6a126b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf5b22e7001506bfa95b687761171054c6a126b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ac89737ca60913c6777ef8a000e6aefb9f183c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ac89737ca60913c6777ef8a000e6aefb9f183c9", "html_url": "https://github.com/rust-lang/rust/commit/3ac89737ca60913c6777ef8a000e6aefb9f183c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ac89737ca60913c6777ef8a000e6aefb9f183c9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9814d0d4128b07d4c40dc721c977f9216fd55e91", "url": "https://api.github.com/repos/rust-lang/rust/commits/9814d0d4128b07d4c40dc721c977f9216fd55e91", "html_url": "https://github.com/rust-lang/rust/commit/9814d0d4128b07d4c40dc721c977f9216fd55e91"}, {"sha": "f68f2282c10aa7bb8452906ecf98d13c716d5586", "url": "https://api.github.com/repos/rust-lang/rust/commits/f68f2282c10aa7bb8452906ecf98d13c716d5586", "html_url": "https://github.com/rust-lang/rust/commit/f68f2282c10aa7bb8452906ecf98d13c716d5586"}], "stats": {"total": 74, "additions": 37, "deletions": 37}, "files": [{"sha": "2bba9a0df2e076971f2f50e24e7fd0b35de7e060", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/3ac89737ca60913c6777ef8a000e6aefb9f183c9/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac89737ca60913c6777ef8a000e6aefb9f183c9/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=3ac89737ca60913c6777ef8a000e6aefb9f183c9", "patch": "@@ -77,6 +77,7 @@ use syntax::opt_vec::OptVec;\n \n use core::option::{Some, get, is_some, is_none};\n use core::str::{connect, split_str};\n+use core::hashmap::linear::LinearMap;\n use std::oldmap::HashMap;\n \n // Definition mapping\n@@ -456,7 +457,7 @@ pub struct Module {\n     def_id: Option<def_id>,\n     kind: ModuleKind,\n \n-    children: @HashMap<ident,@mut NameBindings>,\n+    children: @mut LinearMap<ident, @mut NameBindings>,\n     imports: @mut ~[@ImportDirective],\n \n     // The anonymous children of this node. Anonymous children are pseudo-\n@@ -477,7 +478,7 @@ pub struct Module {\n     anonymous_children: @HashMap<node_id,@mut Module>,\n \n     // The status of resolving each import in this module.\n-    import_resolutions: @HashMap<ident,@mut ImportResolution>,\n+    import_resolutions: @mut LinearMap<ident, @mut ImportResolution>,\n \n     // The number of unresolved globs that this module exports.\n     glob_count: uint,\n@@ -494,10 +495,10 @@ pub fn Module(parent_link: ParentLink,\n         parent_link: parent_link,\n         def_id: def_id,\n         kind: kind,\n-        children: @HashMap(),\n+        children: @mut LinearMap::new(),\n         imports: @mut ~[],\n         anonymous_children: @HashMap(),\n-        import_resolutions: @HashMap(),\n+        import_resolutions: @mut LinearMap::new(),\n         glob_count: 0,\n         resolved_import_count: 0\n     }\n@@ -1024,7 +1025,7 @@ pub impl Resolver {\n                                   *self.session.str_of(name)));\n                     }\n                 }\n-                return (child, new_parent);\n+                return (*child, new_parent);\n             }\n         }\n     }\n@@ -1614,7 +1615,7 @@ pub impl Resolver {\n                         let name_bindings = parent_module.children.get(\n                             &ident);\n                         resolution.type_target =\n-                            Some(Target(parent_module, name_bindings));\n+                            Some(Target(parent_module, *name_bindings));\n                       }\n                     }\n \n@@ -2168,13 +2169,13 @@ pub impl Resolver {\n                 // Continue.\n             }\n             Some(child_name_bindings) => {\n-                if (*child_name_bindings).defined_in_namespace(ValueNS) {\n+                if child_name_bindings.defined_in_namespace(ValueNS) {\n                     value_result = BoundResult(containing_module,\n-                                               child_name_bindings);\n+                                               *child_name_bindings);\n                 }\n-                if (*child_name_bindings).defined_in_namespace(TypeNS) {\n+                if child_name_bindings.defined_in_namespace(TypeNS) {\n                     type_result = BoundResult(containing_module,\n-                                              child_name_bindings);\n+                                              *child_name_bindings);\n                 }\n             }\n         }\n@@ -2244,11 +2245,11 @@ pub impl Resolver {\n                         // The name is an import which has been fully\n                         // resolved. We can, therefore, just follow it.\n                         if value_result.is_unknown() {\n-                            value_result = get_binding(import_resolution,\n+                            value_result = get_binding(*import_resolution,\n                                                        ValueNS);\n                         }\n                         if type_result.is_unknown() {\n-                            type_result = get_binding(import_resolution,\n+                            type_result = get_binding(*import_resolution,\n                                                       TypeNS);\n                         }\n                     }\n@@ -2355,9 +2356,9 @@ pub impl Resolver {\n                 // Continue.\n             }\n             Some(child_name_bindings) => {\n-                if (*child_name_bindings).defined_in_namespace(TypeNS) {\n+                if child_name_bindings.defined_in_namespace(TypeNS) {\n                     module_result = BoundResult(containing_module,\n-                                                child_name_bindings);\n+                                                *child_name_bindings);\n                 }\n             }\n         }\n@@ -2486,15 +2487,15 @@ pub impl Resolver {\n \n         // Add all resolved imports from the containing module.\n         for containing_module.import_resolutions.each\n-                |&ident, &target_import_resolution| {\n+                |&(ident, target_import_resolution)| {\n \n             debug!(\"(resolving glob import) writing module resolution \\\n                     %? into `%s`\",\n                    is_none(&mut target_import_resolution.type_target),\n                    self.module_to_str(module_));\n \n             // Here we merge two import resolutions.\n-            match module_.import_resolutions.find(&ident) {\n+            match module_.import_resolutions.find(ident) {\n                 None if target_import_resolution.privacy == Public => {\n                     // Simple: just copy the old import resolution.\n                     let new_import_resolution =\n@@ -2507,7 +2508,7 @@ pub impl Resolver {\n                         copy target_import_resolution.type_target;\n \n                     module_.import_resolutions.insert\n-                        (ident, new_import_resolution);\n+                        (*ident, new_import_resolution);\n                 }\n                 None => { /* continue ... */ }\n                 Some(dest_import_resolution) => {\n@@ -2537,39 +2538,39 @@ pub impl Resolver {\n         }\n \n         // Add all children from the containing module.\n-        for containing_module.children.each |&ident, &name_bindings| {\n+        for containing_module.children.each |&(ident, name_bindings)| {\n             let mut dest_import_resolution;\n-            match module_.import_resolutions.find(&ident) {\n+            match module_.import_resolutions.find(ident) {\n                 None => {\n                     // Create a new import resolution from this child.\n                     dest_import_resolution = @mut ImportResolution(privacy,\n                                                                    span,\n                                                                    state);\n                     module_.import_resolutions.insert\n-                        (ident, dest_import_resolution);\n+                        (*ident, dest_import_resolution);\n                 }\n                 Some(existing_import_resolution) => {\n-                    dest_import_resolution = existing_import_resolution;\n+                    dest_import_resolution = *existing_import_resolution;\n                 }\n             }\n \n             debug!(\"(resolving glob import) writing resolution `%s` in `%s` \\\n                     to `%s`, privacy=%?\",\n-                   *self.session.str_of(ident),\n+                   *self.session.str_of(*ident),\n                    self.module_to_str(containing_module),\n                    self.module_to_str(module_),\n                    copy dest_import_resolution.privacy);\n \n             // Merge the child item into the import resolution.\n-            if (*name_bindings).defined_in_public_namespace(ValueNS) {\n+            if name_bindings.defined_in_public_namespace(ValueNS) {\n                 debug!(\"(resolving glob import) ... for value target\");\n                 dest_import_resolution.value_target =\n-                    Some(Target(containing_module, name_bindings));\n+                    Some(Target(containing_module, *name_bindings));\n             }\n-            if (*name_bindings).defined_in_public_namespace(TypeNS) {\n+            if name_bindings.defined_in_public_namespace(TypeNS) {\n                 debug!(\"(resolving glob import) ... for type target\");\n                 dest_import_resolution.type_target =\n-                    Some(Target(containing_module, name_bindings));\n+                    Some(Target(containing_module, *name_bindings));\n             }\n         }\n \n@@ -2763,8 +2764,8 @@ pub impl Resolver {\n \n         match module_.children.find(&name) {\n             Some(name_bindings)\n-                    if (*name_bindings).defined_in_namespace(namespace) => {\n-                return Success(Target(module_, name_bindings));\n+                    if name_bindings.defined_in_namespace(namespace) => {\n+                return Success(Target(module_, *name_bindings));\n             }\n             Some(_) | None => { /* Not found; continue. */ }\n         }\n@@ -3008,10 +3009,9 @@ pub impl Resolver {\n         // First, check the direct children of the module.\n         match module_.children.find(&name) {\n             Some(name_bindings)\n-                    if (*name_bindings).defined_in_namespace(namespace) => {\n-\n+                    if name_bindings.defined_in_namespace(namespace) => {\n                 debug!(\"(resolving name in module) found node as child\");\n-                return Success(Target(module_, name_bindings));\n+                return Success(Target(module_, *name_bindings));\n             }\n             Some(_) | None => {\n                 // Continue.\n@@ -3193,7 +3193,7 @@ pub impl Resolver {\n     fn add_exports_for_module(@mut self,\n                               exports2: &mut ~[Export2],\n                               module_: @mut Module) {\n-        for module_.children.each |ident, namebindings| {\n+        for module_.children.each |&(ident, namebindings)| {\n             debug!(\"(computing exports) maybe export '%s'\",\n                    *self.session.str_of(*ident));\n             self.add_exports_of_namebindings(&mut *exports2,\n@@ -3208,7 +3208,7 @@ pub impl Resolver {\n                                              false);\n         }\n \n-        for module_.import_resolutions.each |ident, importresolution| {\n+        for module_.import_resolutions.each |&(ident, importresolution)| {\n             if importresolution.privacy != Public {\n                 debug!(\"(computing exports) not reexporting private `%s`\",\n                        *self.session.str_of(*ident));\n@@ -5311,9 +5311,9 @@ pub impl Resolver {\n         }\n \n         debug!(\"Import resolutions:\");\n-        for module_.import_resolutions.each |&name, &import_resolution| {\n+        for module_.import_resolutions.each |&(name, import_resolution)| {\n             let mut value_repr;\n-            match (*import_resolution).target_for_namespace(ValueNS) {\n+            match import_resolution.target_for_namespace(ValueNS) {\n                 None => { value_repr = ~\"\"; }\n                 Some(_) => {\n                     value_repr = ~\" value:?\";\n@@ -5322,15 +5322,15 @@ pub impl Resolver {\n             }\n \n             let mut type_repr;\n-            match (*import_resolution).target_for_namespace(TypeNS) {\n+            match import_resolution.target_for_namespace(TypeNS) {\n                 None => { type_repr = ~\"\"; }\n                 Some(_) => {\n                     type_repr = ~\" type:?\";\n                     // FIXME #4954\n                 }\n             }\n \n-            debug!(\"* %s:%s%s\", *self.session.str_of(name),\n+            debug!(\"* %s:%s%s\", *self.session.str_of(*name),\n                    value_repr, type_repr);\n         }\n     }"}]}