{"sha": "a6fad3f620ac14f57da080863dabcdc6b78005b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2ZmFkM2Y2MjBhYzE0ZjU3ZGEwODA4NjNkYWJjZGM2Yjc4MDA1YjE=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2018-09-13T20:35:24Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2018-09-24T22:33:13Z"}, "message": "Add more fake borrows to matches", "tree": {"sha": "4b58199b79835f6aade5116b0a163fa6886b96c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b58199b79835f6aade5116b0a163fa6886b96c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6fad3f620ac14f57da080863dabcdc6b78005b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6fad3f620ac14f57da080863dabcdc6b78005b1", "html_url": "https://github.com/rust-lang/rust/commit/a6fad3f620ac14f57da080863dabcdc6b78005b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6fad3f620ac14f57da080863dabcdc6b78005b1/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b55bb2e918560509418a8b79f8ce5aa2c0d5aaff", "url": "https://api.github.com/repos/rust-lang/rust/commits/b55bb2e918560509418a8b79f8ce5aa2c0d5aaff", "html_url": "https://github.com/rust-lang/rust/commit/b55bb2e918560509418a8b79f8ce5aa2c0d5aaff"}], "stats": {"total": 229, "additions": 171, "deletions": 58}, "files": [{"sha": "ec54613d1dbacfd41871ab4a6166e298549e561f", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6fad3f620ac14f57da080863dabcdc6b78005b1/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6fad3f620ac14f57da080863dabcdc6b78005b1/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=a6fad3f620ac14f57da080863dabcdc6b78005b1", "patch": "@@ -273,7 +273,7 @@ for mir::StatementKind<'gcx> {\n     }\n }\n \n-impl_stable_hash_for!(enum mir::FakeReadCause { ForMatch, ForLet });\n+impl_stable_hash_for!(enum mir::FakeReadCause { ForMatchGuard, ForMatchedPlace, ForLet });\n \n impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>>\n     for mir::ValidationOperand<'gcx, T>"}, {"sha": "f856475c3376ddbc9bdecee7c311e24c8dc78f45", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a6fad3f620ac14f57da080863dabcdc6b78005b1/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6fad3f620ac14f57da080863dabcdc6b78005b1/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=a6fad3f620ac14f57da080863dabcdc6b78005b1", "patch": "@@ -451,7 +451,7 @@ impl From<Mutability> for hir::Mutability {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable)]\n pub enum BorrowKind {\n     /// Data must be immutable and is aliasable.\n     Shared,\n@@ -1693,7 +1693,11 @@ pub enum FakeReadCause {\n     ///\n     /// This should ensure that you cannot change the variant for an enum\n     /// while you are in the midst of matching on it.\n-    ForMatch,\n+    ForMatchGuard,\n+\n+    /// `let x: !; match x {}` doesn't generate any read of x so we need to\n+    /// generate a read of x to check that it is initialized and safe.\n+    ForMatchedPlace,\n \n     /// Officially, the semantics of\n     ///\n@@ -1794,7 +1798,7 @@ impl<'tcx> Debug for Statement<'tcx> {\n \n /// A path to a value; something that can be evaluated without\n /// changing or disturbing program state.\n-#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub enum Place<'tcx> {\n     /// local variable\n     Local(Local),\n@@ -1811,7 +1815,7 @@ pub enum Place<'tcx> {\n \n /// The def-id of a static, along with its normalized type (which is\n /// stored to avoid requiring normalization when reading MIR).\n-#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct Static<'tcx> {\n     pub def_id: DefId,\n     pub ty: Ty<'tcx>,\n@@ -1826,13 +1830,13 @@ impl_stable_hash_for!(struct Static<'tcx> {\n /// or `*B` or `B[index]`. Note that it is parameterized because it is\n /// shared between `Constant` and `Place`. See the aliases\n /// `PlaceProjection` etc below.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct Projection<'tcx, B, V, T> {\n     pub base: B,\n     pub elem: ProjectionElem<'tcx, V, T>,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub enum ProjectionElem<'tcx, V, T> {\n     Deref,\n     Field(Field, T),"}, {"sha": "e40ed51f7d3544677832cf48b6fd564b6b90b4ec", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 160, "deletions": 51, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/a6fad3f620ac14f57da080863dabcdc6b78005b1/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6fad3f620ac14f57da080863dabcdc6b78005b1/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=a6fad3f620ac14f57da080863dabcdc6b78005b1", "patch": "@@ -57,39 +57,22 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // See issue #47412 for this hole being discovered in the wild.\n         //\n         // HACK(eddyb) Work around the above issue by adding a dummy inspection\n-        // of `discriminant_place`, specifically by applying `Rvalue::Discriminant`\n-        // (which will work regardless of type) and storing the result in a temp.\n+        // of `discriminant_place`, specifically by applying `ReadForMatch`.\n         //\n-        // NOTE: Under NLL, the above issue should no longer occur because it\n-        // injects a borrow of the matched input, which should have the same effect\n-        // as eddyb's hack. Once NLL is the default, we can remove the hack.\n-\n-        let dummy_source_info = self.source_info(discriminant_span);\n-        let dummy_access = Rvalue::Discriminant(discriminant_place.clone());\n-        let dummy_ty = dummy_access.ty(&self.local_decls, tcx);\n-        let dummy_temp = self.temp(dummy_ty, dummy_source_info.span);\n-        self.cfg\n-            .push_assign(block, dummy_source_info, &dummy_temp, dummy_access);\n+        // NOTE: ReadForMatch also checks that the discriminant is initialized.\n+        // This is currently needed to not allow matching on an uninitialized,\n+        // uninhabited value. If we get never patterns, those will check that\n+        // the place is initialized, and so this read would only be used to\n+        // check safety.\n \n         let source_info = self.source_info(discriminant_span);\n-        let borrowed_input_temp = if tcx.generate_borrow_of_any_match_input() {\n-            // The region is unknown at this point; we rely on NLL\n-            // inference to find an appropriate one. Therefore you can\n-            // only use this when NLL is turned on.\n-            assert!(tcx.use_mir_borrowck());\n-            let borrowed_input = Rvalue::Ref(\n-                tcx.types.re_empty,\n-                BorrowKind::Shared,\n+        self.cfg.push(block, Statement {\n+            source_info,\n+            kind: StatementKind::FakeRead(\n+                FakeReadCause::ForMatchedPlace,\n                 discriminant_place.clone(),\n-            );\n-            let borrowed_input_ty = borrowed_input.ty(&self.local_decls, tcx);\n-            let borrowed_input_temp = self.temp(borrowed_input_ty, span);\n-            self.cfg\n-                .push_assign(block, source_info, &borrowed_input_temp, borrowed_input);\n-            Some(borrowed_input_temp)\n-        } else {\n-            None\n-        };\n+            ),\n+        });\n \n         let mut arm_blocks = ArmBlocks {\n             blocks: arms.iter().map(|_| self.cfg.start_new_block()).collect(),\n@@ -118,6 +101,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             .map(|_| self.cfg.start_new_block())\n             .collect();\n \n+        let mut has_guard = false;\n+\n         // assemble a list of candidates: there is one candidate per\n         // pattern, which means there may be more than one candidate\n         // *per arm*. These candidates are kept sorted such that the\n@@ -140,24 +125,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             .map(\n                 |(\n                     (arm_index, pat_index, pattern, guard),\n-                    (pre_binding_block, next_candidate_pre_binding_block),\n+                    (pre_binding_block, next_candidate_pre_binding_block)\n                 )| {\n-                    if let (true, Some(borrow_temp)) =\n-                        (tcx.emit_read_for_match(), borrowed_input_temp.clone())\n-                    {\n-                        // Inject a fake read, see comments on `FakeReadCause::ForMatch`.\n-                        let pattern_source_info = self.source_info(pattern.span);\n-                        self.cfg.push(\n-                            *pre_binding_block,\n-                            Statement {\n-                                source_info: pattern_source_info,\n-                                kind: StatementKind::FakeRead(\n-                                    FakeReadCause::ForMatch,\n-                                    borrow_temp.clone(),\n-                                ),\n-                            },\n-                        );\n-                    }\n+                    has_guard |= guard.is_some();\n \n                     // One might ask: why not build up the match pair such that it\n                     // matches via `borrowed_input_temp.deref()` instead of\n@@ -202,9 +172,31 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             TerminatorKind::Unreachable,\n         );\n \n+        // Maps a place to the kind of Fake borrow that we want to perform on\n+        // it: either Shallow or Shared, depending on whether the place is\n+        // bound in the match, or just switched on.\n+        // If there are no match guards then we don't need any fake borrows,\n+        // so don't track them.\n+        let mut fake_borrows = if has_guard && tcx.generate_borrow_of_any_match_input() {\n+            Some(FxHashMap())\n+        } else {\n+            None\n+        };\n+\n+        let pre_binding_blocks: Vec<_> = candidates\n+            .iter()\n+            .map(|cand| (cand.pre_binding_block, cand.span))\n+            .collect();\n+\n         // this will generate code to test discriminant_place and\n         // branch to the appropriate arm block\n-        let otherwise = self.match_candidates(span, &mut arm_blocks, candidates, block);\n+        let otherwise = self.match_candidates(\n+            discriminant_span,\n+            &mut arm_blocks,\n+            candidates,\n+            block,\n+            &mut fake_borrows,\n+        );\n \n         if !otherwise.is_empty() {\n             // All matches are exhaustive. However, because some matches\n@@ -224,6 +216,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n         }\n \n+        if let Some(fake_borrows) = fake_borrows {\n+            self.add_fake_borrows(&pre_binding_blocks, fake_borrows, source_info, block);\n+        }\n+\n         // all the arm blocks will rejoin here\n         let end_block = self.cfg.start_new_block();\n \n@@ -714,12 +710,16 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// up the list of candidates and recurse with a non-exhaustive\n     /// list. This is important to keep the size of the generated code\n     /// under control. See `test_candidates` for more details.\n+    ///\n+    /// If `add_fake_borrows` is true, then places which need fake borrows\n+    /// will be added to it.\n     fn match_candidates<'pat>(\n         &mut self,\n         span: Span,\n         arm_blocks: &mut ArmBlocks,\n         mut candidates: Vec<Candidate<'pat, 'tcx>>,\n         mut block: BasicBlock,\n+        fake_borrows: &mut Option<FxHashMap<Place<'tcx>, BorrowKind>>,\n     ) -> Vec<BasicBlock> {\n         debug!(\n             \"matched_candidate(span={:?}, block={:?}, candidates={:?})\",\n@@ -747,6 +747,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         );\n         let mut unmatched_candidates = candidates.split_off(fully_matched);\n \n+        // Insert a *Shared* borrow of any places that are bound.\n+        if let Some(fake_borrows) = fake_borrows {\n+            for Binding { source, .. }\n+                in candidates.iter().flat_map(|candidate| &candidate.bindings)\n+            {\n+                fake_borrows.insert(source.clone(), BorrowKind::Shared);\n+            }\n+        }\n+\n         let fully_matched_with_guard = candidates.iter().take_while(|c| c.guard.is_some()).count();\n \n         let unreachable_candidates = if fully_matched_with_guard + 1 < candidates.len() {\n@@ -783,7 +792,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     return vec![];\n                 } else {\n                     let target = self.cfg.start_new_block();\n-                    return self.match_candidates(span, arm_blocks, unmatched_candidates, target);\n+                    return self.match_candidates(\n+                        span,\n+                        arm_blocks,\n+                        unmatched_candidates,\n+                        target,\n+                        &mut None,\n+                    );\n                 }\n             }\n         }\n@@ -796,7 +811,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         // Test candidates where possible.\n         let (otherwise, tested_candidates) =\n-            self.test_candidates(span, arm_blocks, &unmatched_candidates, block);\n+            self.test_candidates(span, arm_blocks, &unmatched_candidates, block, fake_borrows);\n \n         // If the target candidates were exhaustive, then we are done.\n         // But for borrowck continue build decision tree.\n@@ -810,7 +825,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         // Otherwise, let's process those remaining candidates.\n         let join_block = self.join_otherwise_blocks(span, otherwise);\n-        self.match_candidates(span, arm_blocks, untested_candidates, join_block)\n+        self.match_candidates(span, arm_blocks, untested_candidates, join_block, &mut None)\n     }\n \n     fn join_otherwise_blocks(&mut self, span: Span, mut otherwise: Vec<BasicBlock>) -> BasicBlock {\n@@ -950,6 +965,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         arm_blocks: &mut ArmBlocks,\n         candidates: &[Candidate<'pat, 'tcx>],\n         block: BasicBlock,\n+        fake_borrows: &mut Option<FxHashMap<Place<'tcx>, BorrowKind>>,\n     ) -> (Vec<BasicBlock>, usize) {\n         // extract the match-pair from the highest priority candidate\n         let match_pair = &candidates.first().unwrap().match_pairs[0];\n@@ -990,6 +1006,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             _ => {}\n         }\n \n+        // Insert a Shallow borrow of any places that is switched on.\n+        fake_borrows.as_mut().map(|fb| {\n+            fb.entry(match_pair.place.clone()).or_insert(BorrowKind::Shallow)\n+        });\n+\n         // perform the test, branching to one of N blocks. For each of\n         // those N possible outcomes, create a (initially empty)\n         // vector of candidates. Those are the candidates that still\n@@ -1026,7 +1047,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             .into_iter()\n             .zip(target_candidates)\n             .flat_map(|(target_block, target_candidates)| {\n-                self.match_candidates(span, arm_blocks, target_candidates, target_block)\n+                self.match_candidates(\n+                    span,\n+                    arm_blocks,\n+                    target_candidates,\n+                    target_block,\n+                    fake_borrows,\n+                )\n             })\n             .collect();\n \n@@ -1504,4 +1531,86 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         debug!(\"declare_binding: vars={:?}\", locals);\n         self.var_indices.insert(var_id, locals);\n     }\n+\n+    // Determine the fake borrows that are needed to ensure that the place\n+    // will evaluate to the same thing until an arm has been chosen.\n+    fn add_fake_borrows<'pat>(\n+        &mut self,\n+        pre_binding_blocks: &[(BasicBlock, Span)],\n+        fake_borrows: FxHashMap<Place<'tcx>, BorrowKind>,\n+        source_info: SourceInfo,\n+        start_block: BasicBlock,\n+    ) {\n+        let tcx = self.hir.tcx();\n+\n+        debug!(\"add_fake_borrows pre_binding_blocks = {:?}, fake_borrows = {:?}\",\n+               pre_binding_blocks, fake_borrows);\n+\n+        let mut all_fake_borrows = Vec::with_capacity(fake_borrows.len());\n+\n+        // Insert a Shallow borrow of the prefixes of any fake borrows.\n+        for (place, borrow_kind) in fake_borrows\n+        {\n+            {\n+                let mut prefix_cursor = &place;\n+                while let Place::Projection(box Projection { base, elem }) = prefix_cursor {\n+                    if let ProjectionElem::Deref = elem {\n+                        // Insert a shallow borrow after a deref. For other\n+                        // projections the borrow of prefix_cursor will\n+                        // conflict with any mutation of base.\n+                        all_fake_borrows.push((base.clone(), BorrowKind::Shallow));\n+                    }\n+                    prefix_cursor = base;\n+                }\n+            }\n+\n+            all_fake_borrows.push((place, borrow_kind));\n+        }\n+\n+        // Deduplicate and ensure a deterministic order.\n+        all_fake_borrows.sort();\n+        all_fake_borrows.dedup();\n+\n+        debug!(\"add_fake_borrows all_fake_borrows = {:?}\", all_fake_borrows);\n+\n+        // Add fake borrows to the start of the match and reads of them before\n+        // the start of each arm.\n+        let mut borrowed_input_temps = Vec::with_capacity(all_fake_borrows.len());\n+\n+        for (matched_place, borrow_kind) in all_fake_borrows {\n+            let borrowed_input =\n+                Rvalue::Ref(tcx.types.re_empty, borrow_kind, matched_place.clone());\n+            let borrowed_input_ty = borrowed_input.ty(&self.local_decls, tcx);\n+            let borrowed_input_temp = self.temp(borrowed_input_ty, source_info.span);\n+            self.cfg.push_assign(\n+                start_block,\n+                source_info,\n+                &borrowed_input_temp,\n+                borrowed_input\n+            );\n+            borrowed_input_temps.push(borrowed_input_temp);\n+        }\n+\n+        // FIXME: This could be a lot of reads (#fake borrows * #patterns).\n+        // The false edges that we currently generate would allow us to only do\n+        // this on the last Candidate, but it's possible that there might not be\n+        // so many false edges in the future, so we read for all Candidates for\n+        // now.\n+        // Another option would be to make our own block and add our own false\n+        // edges to it.\n+        if tcx.emit_read_for_match() {\n+            for &(pre_binding_block, span) in pre_binding_blocks {\n+                let pattern_source_info = self.source_info(span);\n+                for temp in &borrowed_input_temps {\n+                    self.cfg.push(pre_binding_block, Statement {\n+                        source_info: pattern_source_info,\n+                        kind: StatementKind::FakeRead(\n+                            FakeReadCause::ForMatchGuard,\n+                            temp.clone(),\n+                        ),\n+                    });\n+                }\n+            }\n+        }\n+    }\n }"}]}