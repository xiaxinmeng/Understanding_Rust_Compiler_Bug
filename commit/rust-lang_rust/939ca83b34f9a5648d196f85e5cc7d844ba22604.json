{"sha": "939ca83b34f9a5648d196f85e5cc7d844ba22604", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzOWNhODNiMzRmOWE1NjQ4ZDE5NmY4NWU1Y2M3ZDg0NGJhMjI2MDQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-01-09T13:09:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-09T13:09:15Z"}, "message": "Merge #7216\n\n7216: Highlighting improvements r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "a007952a8870e4d8c0b5fa1e0e0a088b399a8c8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a007952a8870e4d8c0b5fa1e0e0a088b399a8c8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/939ca83b34f9a5648d196f85e5cc7d844ba22604", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJf+ar7CRBK7hj4Ov3rIwAAdHIIAFQPoJtMm7FCad1GzUJL9ATY\npfJ8SFJ60Pm6viD3QHCAG374ZERLDDbxVTa/Cbcu4i8Dya7YmBABQX/vicaT3Wr/\nhKX5hpxoou8U5EopU5AOavqX9NpqiiuAE1HaZih6zxM7uWRCFVhw06hTJprNy+7G\ng2cOBkt40qs1a+C4ghH5Ka3W2v8e7QJyTOQ4AiGRwp9i146HVHfdR1xk5L1TEaRc\nva+PVRBzDqvMu+WURW8KSTTQB7ygi/uKLfYTqU83wRBzyxFAOdfBN9lEErGWB/qF\nZpG2bWu6v/14A9r1rrlLrXAYxaXBitIWmMoHD6crlJeIv9ccPV1u0H+1zVvmVvE=\n=lPPa\n-----END PGP SIGNATURE-----\n", "payload": "tree a007952a8870e4d8c0b5fa1e0e0a088b399a8c8d\nparent 625ec9e1ae69168f194cbc5bf20846870f03e149\nparent 4a8d2c098d88da6f36f3cf95f424b471987c5daa\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1610197755 +0000\ncommitter GitHub <noreply@github.com> 1610197755 +0000\n\nMerge #7216\n\n7216: Highlighting improvements r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/939ca83b34f9a5648d196f85e5cc7d844ba22604", "html_url": "https://github.com/rust-lang/rust/commit/939ca83b34f9a5648d196f85e5cc7d844ba22604", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/939ca83b34f9a5648d196f85e5cc7d844ba22604/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "625ec9e1ae69168f194cbc5bf20846870f03e149", "url": "https://api.github.com/repos/rust-lang/rust/commits/625ec9e1ae69168f194cbc5bf20846870f03e149", "html_url": "https://github.com/rust-lang/rust/commit/625ec9e1ae69168f194cbc5bf20846870f03e149"}, {"sha": "4a8d2c098d88da6f36f3cf95f424b471987c5daa", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a8d2c098d88da6f36f3cf95f424b471987c5daa", "html_url": "https://github.com/rust-lang/rust/commit/4a8d2c098d88da6f36f3cf95f424b471987c5daa"}], "stats": {"total": 718, "additions": 329, "deletions": 389}, "files": [{"sha": "409507bd0b7125d665eb86196a451ab633e77fac", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/939ca83b34f9a5648d196f85e5cc7d844ba22604/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/939ca83b34f9a5648d196f85e5cc7d844ba22604/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=939ca83b34f9a5648d196f85e5cc7d844ba22604", "patch": "@@ -76,8 +76,8 @@ pub use crate::{\n     references::{rename::RenameError, Declaration, ReferenceSearchResult},\n     runnables::{Runnable, RunnableKind, TestId},\n     syntax_highlighting::{\n-        tags::{Highlight, HighlightModifier, HighlightModifiers, HighlightTag},\n-        HighlightedRange,\n+        tags::{Highlight, HlMod, HlMods, HlTag},\n+        HlRange,\n     },\n };\n pub use assists::{Assist, AssistConfig, AssistId, AssistKind, InsertUseConfig};\n@@ -449,12 +449,12 @@ impl Analysis {\n     }\n \n     /// Computes syntax highlighting for the given file\n-    pub fn highlight(&self, file_id: FileId) -> Cancelable<Vec<HighlightedRange>> {\n+    pub fn highlight(&self, file_id: FileId) -> Cancelable<Vec<HlRange>> {\n         self.with_db(|db| syntax_highlighting::highlight(db, file_id, None, false))\n     }\n \n     /// Computes syntax highlighting for the given file range.\n-    pub fn highlight_range(&self, frange: FileRange) -> Cancelable<Vec<HighlightedRange>> {\n+    pub fn highlight_range(&self, frange: FileRange) -> Cancelable<Vec<HlRange>> {\n         self.with_db(|db| {\n             syntax_highlighting::highlight(db, frange.file_id, Some(frange.range), false)\n         })"}, {"sha": "ad456bc0011a790a7e2e1b68f2083cbd098991fd", "filename": "crates/ide/src/syntax_highlighting.rs", "status": "modified", "additions": 125, "deletions": 142, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/939ca83b34f9a5648d196f85e5cc7d844ba22604/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/939ca83b34f9a5648d196f85e5cc7d844ba22604/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs?ref=939ca83b34f9a5648d196f85e5cc7d844ba22604", "patch": "@@ -1,11 +1,13 @@\n+pub(crate) mod tags;\n+\n mod highlights;\n mod injector;\n \n mod format;\n-mod html;\n mod injection;\n mod macro_rules;\n-pub(crate) mod tags;\n+\n+mod html;\n #[cfg(test)]\n mod tests;\n \n@@ -26,13 +28,13 @@ use crate::{\n     syntax_highlighting::{\n         format::FormatStringHighlighter, macro_rules::MacroRulesHighlighter, tags::Highlight,\n     },\n-    FileId, HighlightModifier, HighlightTag, SymbolKind,\n+    FileId, HlMod, HlTag, SymbolKind,\n };\n \n pub(crate) use html::highlight_as_html;\n \n-#[derive(Debug, Clone)]\n-pub struct HighlightedRange {\n+#[derive(Debug, Clone, Copy)]\n+pub struct HlRange {\n     pub range: TextRange,\n     pub highlight: Highlight,\n     pub binding_hash: Option<u64>,\n@@ -52,7 +54,7 @@ pub(crate) fn highlight(\n     file_id: FileId,\n     range_to_highlight: Option<TextRange>,\n     syntactic_name_ref_highlighting: bool,\n-) -> Vec<HighlightedRange> {\n+) -> Vec<HlRange> {\n     let _p = profile::span(\"highlight\");\n     let sema = Semantics::new(db);\n \n@@ -72,7 +74,7 @@ pub(crate) fn highlight(\n     };\n \n     let mut bindings_shadow_count: FxHashMap<Name, u32> = FxHashMap::default();\n-    let mut stack = highlights::Highlights::new(range_to_highlight);\n+    let mut hl = highlights::Highlights::new(range_to_highlight);\n \n     let mut current_macro_call: Option<ast::MacroCall> = None;\n     let mut current_macro_rules: Option<ast::MacroRules> = None;\n@@ -96,9 +98,9 @@ pub(crate) fn highlight(\n         match event.clone().map(|it| it.into_node().and_then(ast::MacroCall::cast)) {\n             WalkEvent::Enter(Some(mc)) => {\n                 if let Some(range) = macro_call_range(&mc) {\n-                    stack.add(HighlightedRange {\n+                    hl.add(HlRange {\n                         range,\n-                        highlight: HighlightTag::Symbol(SymbolKind::Macro).into(),\n+                        highlight: HlTag::Symbol(SymbolKind::Macro).into(),\n                         binding_hash: None,\n                     });\n                 }\n@@ -134,7 +136,7 @@ pub(crate) fn highlight(\n                     inside_attribute = false\n                 }\n                 if let Some((new_comments, inj)) = injection::extract_doc_comments(node) {\n-                    injection::highlight_doc_comment(new_comments, inj, &mut stack);\n+                    injection::highlight_doc_comment(new_comments, inj, &mut hl);\n                 }\n             }\n             WalkEvent::Enter(NodeOrToken::Node(node)) if ast::Attr::can_cast(node.kind()) => {\n@@ -179,7 +181,7 @@ pub(crate) fn highlight(\n         if let Some(token) = element.as_token().cloned().and_then(ast::String::cast) {\n             if token.is_raw() {\n                 let expanded = element_to_highlight.as_token().unwrap().clone();\n-                if injection::highlight_injection(&mut stack, &sema, token, expanded).is_some() {\n+                if injection::highlight_injection(&mut hl, &sema, token, expanded).is_some() {\n                     continue;\n                 }\n             }\n@@ -192,24 +194,24 @@ pub(crate) fn highlight(\n             element_to_highlight.clone(),\n         ) {\n             if inside_attribute {\n-                highlight = highlight | HighlightModifier::Attribute;\n+                highlight = highlight | HlMod::Attribute;\n             }\n \n             if macro_rules_highlighter.highlight(element_to_highlight.clone()).is_none() {\n-                stack.add(HighlightedRange { range, highlight, binding_hash });\n+                hl.add(HlRange { range, highlight, binding_hash });\n             }\n \n             if let Some(string) =\n                 element_to_highlight.as_token().cloned().and_then(ast::String::cast)\n             {\n-                format_string_highlighter.highlight_format_string(&mut stack, &string, range);\n+                format_string_highlighter.highlight_format_string(&mut hl, &string, range);\n                 // Highlight escape sequences\n                 if let Some(char_ranges) = string.char_ranges() {\n                     for (piece_range, _) in char_ranges.iter().filter(|(_, char)| char.is_ok()) {\n                         if string.text()[piece_range.start().into()..].starts_with('\\\\') {\n-                            stack.add(HighlightedRange {\n+                            hl.add(HlRange {\n                                 range: piece_range + range.start(),\n-                                highlight: HighlightTag::EscapeSequence.into(),\n+                                highlight: HlTag::EscapeSequence.into(),\n                                 binding_hash: None,\n                             });\n                         }\n@@ -219,7 +221,7 @@ pub(crate) fn highlight(\n         }\n     }\n \n-    stack.to_vec()\n+    hl.to_vec()\n }\n \n fn macro_call_range(macro_call: &ast::MacroCall) -> Option<TextRange> {\n@@ -292,39 +294,35 @@ fn highlight_element(\n             };\n \n             match name_kind {\n-                Some(NameClass::ExternCrate(_)) => HighlightTag::Symbol(SymbolKind::Module).into(),\n-                Some(NameClass::Definition(def)) => {\n-                    highlight_def(db, def) | HighlightModifier::Definition\n-                }\n+                Some(NameClass::ExternCrate(_)) => HlTag::Symbol(SymbolKind::Module).into(),\n+                Some(NameClass::Definition(def)) => highlight_def(db, def) | HlMod::Definition,\n                 Some(NameClass::ConstReference(def)) => highlight_def(db, def),\n                 Some(NameClass::PatFieldShorthand { field_ref, .. }) => {\n-                    let mut h = HighlightTag::Symbol(SymbolKind::Field).into();\n+                    let mut h = HlTag::Symbol(SymbolKind::Field).into();\n                     if let Definition::Field(field) = field_ref {\n                         if let VariantDef::Union(_) = field.parent_def(db) {\n-                            h |= HighlightModifier::Unsafe;\n+                            h |= HlMod::Unsafe;\n                         }\n                     }\n \n                     h\n                 }\n-                None => highlight_name_by_syntax(name) | HighlightModifier::Definition,\n+                None => highlight_name_by_syntax(name) | HlMod::Definition,\n             }\n         }\n \n         // Highlight references like the definitions they resolve to\n         NAME_REF if element.ancestors().any(|it| it.kind() == ATTR) => {\n             // even though we track whether we are in an attribute or not we still need this special case\n             // as otherwise we would emit unresolved references for name refs inside attributes\n-            Highlight::from(HighlightTag::Symbol(SymbolKind::Function))\n+            Highlight::from(HlTag::Symbol(SymbolKind::Function))\n         }\n         NAME_REF => {\n             let name_ref = element.into_node().and_then(ast::NameRef::cast).unwrap();\n             highlight_func_by_name_ref(sema, &name_ref).unwrap_or_else(|| {\n                 match NameRefClass::classify(sema, &name_ref) {\n                     Some(name_kind) => match name_kind {\n-                        NameRefClass::ExternCrate(_) => {\n-                            HighlightTag::Symbol(SymbolKind::Module).into()\n-                        }\n+                        NameRefClass::ExternCrate(_) => HlTag::Symbol(SymbolKind::Module).into(),\n                         NameRefClass::Definition(def) => {\n                             if let Definition::Local(local) = &def {\n                                 if let Some(name) = local.name(db) {\n@@ -338,15 +336,15 @@ fn highlight_element(\n \n                             if let Definition::Local(local) = &def {\n                                 if is_consumed_lvalue(name_ref.syntax().clone().into(), local, db) {\n-                                    h |= HighlightModifier::Consuming;\n+                                    h |= HlMod::Consuming;\n                                 }\n                             }\n \n                             if let Some(parent) = name_ref.syntax().parent() {\n                                 if matches!(parent.kind(), FIELD_EXPR | RECORD_PAT_FIELD) {\n                                     if let Definition::Field(field) = def {\n                                         if let VariantDef::Union(_) = field.parent_def(db) {\n-                                            h |= HighlightModifier::Unsafe;\n+                                            h |= HlMod::Unsafe;\n                                         }\n                                     }\n                                 }\n@@ -355,121 +353,106 @@ fn highlight_element(\n                             h\n                         }\n                         NameRefClass::FieldShorthand { .. } => {\n-                            HighlightTag::Symbol(SymbolKind::Field).into()\n+                            HlTag::Symbol(SymbolKind::Field).into()\n                         }\n                     },\n                     None if syntactic_name_ref_highlighting => {\n                         highlight_name_ref_by_syntax(name_ref, sema)\n                     }\n-                    None => HighlightTag::UnresolvedReference.into(),\n+                    None => HlTag::UnresolvedReference.into(),\n                 }\n             })\n         }\n \n         // Simple token-based highlighting\n         COMMENT => {\n             let comment = element.into_token().and_then(ast::Comment::cast)?;\n-            let h = HighlightTag::Comment;\n+            let h = HlTag::Comment;\n             match comment.kind().doc {\n-                Some(_) => h | HighlightModifier::Documentation,\n+                Some(_) => h | HlMod::Documentation,\n                 None => h.into(),\n             }\n         }\n-        STRING | BYTE_STRING => HighlightTag::StringLiteral.into(),\n-        ATTR => HighlightTag::Attribute.into(),\n-        INT_NUMBER | FLOAT_NUMBER => HighlightTag::NumericLiteral.into(),\n-        BYTE => HighlightTag::ByteLiteral.into(),\n-        CHAR => HighlightTag::CharLiteral.into(),\n-        QUESTION => Highlight::new(HighlightTag::Operator) | HighlightModifier::ControlFlow,\n+        STRING | BYTE_STRING => HlTag::StringLiteral.into(),\n+        ATTR => HlTag::Attribute.into(),\n+        INT_NUMBER | FLOAT_NUMBER => HlTag::NumericLiteral.into(),\n+        BYTE => HlTag::ByteLiteral.into(),\n+        CHAR => HlTag::CharLiteral.into(),\n+        QUESTION => Highlight::new(HlTag::Operator) | HlMod::ControlFlow,\n         LIFETIME => {\n             let lifetime = element.into_node().and_then(ast::Lifetime::cast).unwrap();\n \n             match NameClass::classify_lifetime(sema, &lifetime) {\n-                Some(NameClass::Definition(def)) => {\n-                    highlight_def(db, def) | HighlightModifier::Definition\n-                }\n+                Some(NameClass::Definition(def)) => highlight_def(db, def) | HlMod::Definition,\n                 None => match NameRefClass::classify_lifetime(sema, &lifetime) {\n                     Some(NameRefClass::Definition(def)) => highlight_def(db, def),\n-                    _ => Highlight::new(HighlightTag::Symbol(SymbolKind::LifetimeParam)),\n+                    _ => Highlight::new(HlTag::Symbol(SymbolKind::LifetimeParam)),\n                 },\n-                _ => {\n-                    Highlight::new(HighlightTag::Symbol(SymbolKind::LifetimeParam))\n-                        | HighlightModifier::Definition\n-                }\n+                _ => Highlight::new(HlTag::Symbol(SymbolKind::LifetimeParam)) | HlMod::Definition,\n             }\n         }\n         p if p.is_punct() => match p {\n             T![&] => {\n-                let h = HighlightTag::Operator.into();\n+                let h = HlTag::Operator.into();\n                 let is_unsafe = element\n                     .parent()\n                     .and_then(ast::RefExpr::cast)\n                     .map(|ref_expr| sema.is_unsafe_ref_expr(&ref_expr))\n                     .unwrap_or(false);\n                 if is_unsafe {\n-                    h | HighlightModifier::Unsafe\n+                    h | HlMod::Unsafe\n                 } else {\n                     h\n                 }\n             }\n-            T![::] | T![->] | T![=>] | T![..] | T![=] | T![@] | T![.] => {\n-                HighlightTag::Operator.into()\n-            }\n+            T![::] | T![->] | T![=>] | T![..] | T![=] | T![@] | T![.] => HlTag::Operator.into(),\n             T![!] if element.parent().and_then(ast::MacroCall::cast).is_some() => {\n-                HighlightTag::Symbol(SymbolKind::Macro).into()\n+                HlTag::Symbol(SymbolKind::Macro).into()\n             }\n             T![!] if element.parent().and_then(ast::NeverType::cast).is_some() => {\n-                HighlightTag::BuiltinType.into()\n+                HlTag::BuiltinType.into()\n             }\n             T![*] if element.parent().and_then(ast::PtrType::cast).is_some() => {\n-                HighlightTag::Keyword.into()\n+                HlTag::Keyword.into()\n             }\n             T![*] if element.parent().and_then(ast::PrefixExpr::cast).is_some() => {\n                 let prefix_expr = element.parent().and_then(ast::PrefixExpr::cast)?;\n \n                 let expr = prefix_expr.expr()?;\n                 let ty = sema.type_of_expr(&expr)?;\n                 if ty.is_raw_ptr() {\n-                    HighlightTag::Operator | HighlightModifier::Unsafe\n+                    HlTag::Operator | HlMod::Unsafe\n                 } else if let Some(ast::PrefixOp::Deref) = prefix_expr.op_kind() {\n-                    HighlightTag::Operator.into()\n+                    HlTag::Operator.into()\n                 } else {\n-                    HighlightTag::Punctuation.into()\n+                    HlTag::Punctuation.into()\n                 }\n             }\n             T![-] if element.parent().and_then(ast::PrefixExpr::cast).is_some() => {\n                 let prefix_expr = element.parent().and_then(ast::PrefixExpr::cast)?;\n \n                 let expr = prefix_expr.expr()?;\n                 match expr {\n-                    ast::Expr::Literal(_) => HighlightTag::NumericLiteral,\n-                    _ => HighlightTag::Operator,\n+                    ast::Expr::Literal(_) => HlTag::NumericLiteral,\n+                    _ => HlTag::Operator,\n                 }\n                 .into()\n             }\n             _ if element.parent().and_then(ast::PrefixExpr::cast).is_some() => {\n-                HighlightTag::Operator.into()\n-            }\n-            _ if element.parent().and_then(ast::BinExpr::cast).is_some() => {\n-                HighlightTag::Operator.into()\n+                HlTag::Operator.into()\n             }\n+            _ if element.parent().and_then(ast::BinExpr::cast).is_some() => HlTag::Operator.into(),\n             _ if element.parent().and_then(ast::RangeExpr::cast).is_some() => {\n-                HighlightTag::Operator.into()\n-            }\n-            _ if element.parent().and_then(ast::RangePat::cast).is_some() => {\n-                HighlightTag::Operator.into()\n-            }\n-            _ if element.parent().and_then(ast::RestPat::cast).is_some() => {\n-                HighlightTag::Operator.into()\n-            }\n-            _ if element.parent().and_then(ast::Attr::cast).is_some() => {\n-                HighlightTag::Attribute.into()\n+                HlTag::Operator.into()\n             }\n-            _ => HighlightTag::Punctuation.into(),\n+            _ if element.parent().and_then(ast::RangePat::cast).is_some() => HlTag::Operator.into(),\n+            _ if element.parent().and_then(ast::RestPat::cast).is_some() => HlTag::Operator.into(),\n+            _ if element.parent().and_then(ast::Attr::cast).is_some() => HlTag::Attribute.into(),\n+            _ => HlTag::Punctuation.into(),\n         },\n \n         k if k.is_keyword() => {\n-            let h = Highlight::new(HighlightTag::Keyword);\n+            let h = Highlight::new(HlTag::Keyword);\n             match k {\n                 T![break]\n                 | T![continue]\n@@ -479,10 +462,10 @@ fn highlight_element(\n                 | T![match]\n                 | T![return]\n                 | T![while]\n-                | T![in] => h | HighlightModifier::ControlFlow,\n-                T![for] if !is_child_of_impl(&element) => h | HighlightModifier::ControlFlow,\n-                T![unsafe] => h | HighlightModifier::Unsafe,\n-                T![true] | T![false] => HighlightTag::BoolLiteral.into(),\n+                | T![in] => h | HlMod::ControlFlow,\n+                T![for] if !is_child_of_impl(&element) => h | HlMod::ControlFlow,\n+                T![unsafe] => h | HlMod::Unsafe,\n+                T![true] | T![false] => HlTag::BoolLiteral.into(),\n                 T![self] => {\n                     let self_param_is_mut = element\n                         .parent()\n@@ -495,20 +478,20 @@ fn highlight_element(\n                         .and_then(SyntaxNode::parent)\n                         .and_then(ast::Path::cast)\n                         .and_then(|p| sema.resolve_path(&p));\n-                    let mut h = HighlightTag::Symbol(SymbolKind::SelfParam).into();\n+                    let mut h = HlTag::Symbol(SymbolKind::SelfParam).into();\n                     if self_param_is_mut\n                         || matches!(self_path,\n                             Some(hir::PathResolution::Local(local))\n                                 if local.is_self(db)\n                                     && (local.is_mut(db) || local.ty(db).is_mutable_reference())\n                         )\n                     {\n-                        h |= HighlightModifier::Mutable\n+                        h |= HlMod::Mutable\n                     }\n \n                     if let Some(hir::PathResolution::Local(local)) = self_path {\n                         if is_consumed_lvalue(element, &local, db) {\n-                            h |= HighlightModifier::Consuming;\n+                            h |= HlMod::Consuming;\n                         }\n                     }\n \n@@ -519,7 +502,7 @@ fn highlight_element(\n                     .and_then(ast::IdentPat::cast)\n                     .and_then(|ident_pat| {\n                         if sema.is_unsafe_ident_pat(&ident_pat) {\n-                            Some(HighlightModifier::Unsafe)\n+                            Some(HlMod::Unsafe)\n                         } else {\n                             None\n                         }\n@@ -568,21 +551,21 @@ fn highlight_method_call(\n     method_call: &ast::MethodCallExpr,\n ) -> Option<Highlight> {\n     let func = sema.resolve_method_call(&method_call)?;\n-    let mut h = HighlightTag::Symbol(SymbolKind::Function).into();\n-    h |= HighlightModifier::Associated;\n+    let mut h = HlTag::Symbol(SymbolKind::Function).into();\n+    h |= HlMod::Associated;\n     if func.is_unsafe(sema.db) || sema.is_unsafe_method_call(&method_call) {\n-        h |= HighlightModifier::Unsafe;\n+        h |= HlMod::Unsafe;\n     }\n     if let Some(self_param) = func.self_param(sema.db) {\n         match self_param.access(sema.db) {\n             hir::Access::Shared => (),\n-            hir::Access::Exclusive => h |= HighlightModifier::Mutable,\n+            hir::Access::Exclusive => h |= HlMod::Mutable,\n             hir::Access::Owned => {\n                 if let Some(receiver_ty) =\n                     method_call.receiver().and_then(|it| sema.type_of_expr(&it))\n                 {\n                     if !receiver_ty.is_copy(sema.db) {\n-                        h |= HighlightModifier::Consuming\n+                        h |= HlMod::Consuming\n                     }\n                 }\n             }\n@@ -593,106 +576,106 @@ fn highlight_method_call(\n \n fn highlight_def(db: &RootDatabase, def: Definition) -> Highlight {\n     match def {\n-        Definition::Macro(_) => HighlightTag::Symbol(SymbolKind::Macro),\n-        Definition::Field(_) => HighlightTag::Symbol(SymbolKind::Field),\n+        Definition::Macro(_) => HlTag::Symbol(SymbolKind::Macro),\n+        Definition::Field(_) => HlTag::Symbol(SymbolKind::Field),\n         Definition::ModuleDef(def) => match def {\n-            hir::ModuleDef::Module(_) => HighlightTag::Symbol(SymbolKind::Module),\n+            hir::ModuleDef::Module(_) => HlTag::Symbol(SymbolKind::Module),\n             hir::ModuleDef::Function(func) => {\n-                let mut h = Highlight::new(HighlightTag::Symbol(SymbolKind::Function));\n+                let mut h = Highlight::new(HlTag::Symbol(SymbolKind::Function));\n                 if func.as_assoc_item(db).is_some() {\n-                    h |= HighlightModifier::Associated;\n+                    h |= HlMod::Associated;\n                     if func.self_param(db).is_none() {\n-                        h |= HighlightModifier::Static\n+                        h |= HlMod::Static\n                     }\n                 }\n                 if func.is_unsafe(db) {\n-                    h |= HighlightModifier::Unsafe;\n+                    h |= HlMod::Unsafe;\n                 }\n                 return h;\n             }\n-            hir::ModuleDef::Adt(hir::Adt::Struct(_)) => HighlightTag::Symbol(SymbolKind::Struct),\n-            hir::ModuleDef::Adt(hir::Adt::Enum(_)) => HighlightTag::Symbol(SymbolKind::Enum),\n-            hir::ModuleDef::Adt(hir::Adt::Union(_)) => HighlightTag::Symbol(SymbolKind::Union),\n-            hir::ModuleDef::Variant(_) => HighlightTag::Symbol(SymbolKind::Variant),\n+            hir::ModuleDef::Adt(hir::Adt::Struct(_)) => HlTag::Symbol(SymbolKind::Struct),\n+            hir::ModuleDef::Adt(hir::Adt::Enum(_)) => HlTag::Symbol(SymbolKind::Enum),\n+            hir::ModuleDef::Adt(hir::Adt::Union(_)) => HlTag::Symbol(SymbolKind::Union),\n+            hir::ModuleDef::Variant(_) => HlTag::Symbol(SymbolKind::Variant),\n             hir::ModuleDef::Const(konst) => {\n-                let mut h = Highlight::new(HighlightTag::Symbol(SymbolKind::Const));\n+                let mut h = Highlight::new(HlTag::Symbol(SymbolKind::Const));\n                 if konst.as_assoc_item(db).is_some() {\n-                    h |= HighlightModifier::Associated\n+                    h |= HlMod::Associated\n                 }\n                 return h;\n             }\n-            hir::ModuleDef::Trait(_) => HighlightTag::Symbol(SymbolKind::Trait),\n+            hir::ModuleDef::Trait(_) => HlTag::Symbol(SymbolKind::Trait),\n             hir::ModuleDef::TypeAlias(type_) => {\n-                let mut h = Highlight::new(HighlightTag::Symbol(SymbolKind::TypeAlias));\n+                let mut h = Highlight::new(HlTag::Symbol(SymbolKind::TypeAlias));\n                 if type_.as_assoc_item(db).is_some() {\n-                    h |= HighlightModifier::Associated\n+                    h |= HlMod::Associated\n                 }\n                 return h;\n             }\n-            hir::ModuleDef::BuiltinType(_) => HighlightTag::BuiltinType,\n+            hir::ModuleDef::BuiltinType(_) => HlTag::BuiltinType,\n             hir::ModuleDef::Static(s) => {\n-                let mut h = Highlight::new(HighlightTag::Symbol(SymbolKind::Static));\n+                let mut h = Highlight::new(HlTag::Symbol(SymbolKind::Static));\n                 if s.is_mut(db) {\n-                    h |= HighlightModifier::Mutable;\n-                    h |= HighlightModifier::Unsafe;\n+                    h |= HlMod::Mutable;\n+                    h |= HlMod::Unsafe;\n                 }\n                 return h;\n             }\n         },\n-        Definition::SelfType(_) => HighlightTag::Symbol(SymbolKind::Impl),\n-        Definition::TypeParam(_) => HighlightTag::Symbol(SymbolKind::TypeParam),\n-        Definition::ConstParam(_) => HighlightTag::Symbol(SymbolKind::ConstParam),\n+        Definition::SelfType(_) => HlTag::Symbol(SymbolKind::Impl),\n+        Definition::TypeParam(_) => HlTag::Symbol(SymbolKind::TypeParam),\n+        Definition::ConstParam(_) => HlTag::Symbol(SymbolKind::ConstParam),\n         Definition::Local(local) => {\n             let tag = if local.is_param(db) {\n-                HighlightTag::Symbol(SymbolKind::ValueParam)\n+                HlTag::Symbol(SymbolKind::ValueParam)\n             } else {\n-                HighlightTag::Symbol(SymbolKind::Local)\n+                HlTag::Symbol(SymbolKind::Local)\n             };\n             let mut h = Highlight::new(tag);\n             if local.is_mut(db) || local.ty(db).is_mutable_reference() {\n-                h |= HighlightModifier::Mutable;\n+                h |= HlMod::Mutable;\n             }\n             if local.ty(db).as_callable(db).is_some() || local.ty(db).impls_fnonce(db) {\n-                h |= HighlightModifier::Callable;\n+                h |= HlMod::Callable;\n             }\n             return h;\n         }\n-        Definition::LifetimeParam(_) => HighlightTag::Symbol(SymbolKind::LifetimeParam),\n-        Definition::Label(_) => HighlightTag::Symbol(SymbolKind::Label),\n+        Definition::LifetimeParam(_) => HlTag::Symbol(SymbolKind::LifetimeParam),\n+        Definition::Label(_) => HlTag::Symbol(SymbolKind::Label),\n     }\n     .into()\n }\n \n fn highlight_name_by_syntax(name: ast::Name) -> Highlight {\n-    let default = HighlightTag::UnresolvedReference;\n+    let default = HlTag::UnresolvedReference;\n \n     let parent = match name.syntax().parent() {\n         Some(it) => it,\n         _ => return default.into(),\n     };\n \n     let tag = match parent.kind() {\n-        STRUCT => HighlightTag::Symbol(SymbolKind::Struct),\n-        ENUM => HighlightTag::Symbol(SymbolKind::Enum),\n-        VARIANT => HighlightTag::Symbol(SymbolKind::Variant),\n-        UNION => HighlightTag::Symbol(SymbolKind::Union),\n-        TRAIT => HighlightTag::Symbol(SymbolKind::Trait),\n-        TYPE_ALIAS => HighlightTag::Symbol(SymbolKind::TypeAlias),\n-        TYPE_PARAM => HighlightTag::Symbol(SymbolKind::TypeParam),\n-        RECORD_FIELD => HighlightTag::Symbol(SymbolKind::Field),\n-        MODULE => HighlightTag::Symbol(SymbolKind::Module),\n-        FN => HighlightTag::Symbol(SymbolKind::Function),\n-        CONST => HighlightTag::Symbol(SymbolKind::Const),\n-        STATIC => HighlightTag::Symbol(SymbolKind::Static),\n-        IDENT_PAT => HighlightTag::Symbol(SymbolKind::Local),\n+        STRUCT => HlTag::Symbol(SymbolKind::Struct),\n+        ENUM => HlTag::Symbol(SymbolKind::Enum),\n+        VARIANT => HlTag::Symbol(SymbolKind::Variant),\n+        UNION => HlTag::Symbol(SymbolKind::Union),\n+        TRAIT => HlTag::Symbol(SymbolKind::Trait),\n+        TYPE_ALIAS => HlTag::Symbol(SymbolKind::TypeAlias),\n+        TYPE_PARAM => HlTag::Symbol(SymbolKind::TypeParam),\n+        RECORD_FIELD => HlTag::Symbol(SymbolKind::Field),\n+        MODULE => HlTag::Symbol(SymbolKind::Module),\n+        FN => HlTag::Symbol(SymbolKind::Function),\n+        CONST => HlTag::Symbol(SymbolKind::Const),\n+        STATIC => HlTag::Symbol(SymbolKind::Static),\n+        IDENT_PAT => HlTag::Symbol(SymbolKind::Local),\n         _ => default,\n     };\n \n     tag.into()\n }\n \n fn highlight_name_ref_by_syntax(name: ast::NameRef, sema: &Semantics<RootDatabase>) -> Highlight {\n-    let default = HighlightTag::UnresolvedReference;\n+    let default = HlTag::UnresolvedReference;\n \n     let parent = match name.syntax().parent() {\n         Some(it) => it,\n@@ -703,10 +686,10 @@ fn highlight_name_ref_by_syntax(name: ast::NameRef, sema: &Semantics<RootDatabas\n         METHOD_CALL_EXPR => {\n             return ast::MethodCallExpr::cast(parent)\n                 .and_then(|method_call| highlight_method_call(sema, &method_call))\n-                .unwrap_or_else(|| HighlightTag::Symbol(SymbolKind::Function).into());\n+                .unwrap_or_else(|| HlTag::Symbol(SymbolKind::Function).into());\n         }\n         FIELD_EXPR => {\n-            let h = HighlightTag::Symbol(SymbolKind::Field);\n+            let h = HlTag::Symbol(SymbolKind::Field);\n             let is_union = ast::FieldExpr::cast(parent)\n                 .and_then(|field_expr| {\n                     let field = sema.resolve_field(&field_expr)?;\n@@ -718,7 +701,7 @@ fn highlight_name_ref_by_syntax(name: ast::NameRef, sema: &Semantics<RootDatabas\n                 })\n                 .unwrap_or(false);\n             if is_union {\n-                h | HighlightModifier::Unsafe\n+                h | HlMod::Unsafe\n             } else {\n                 h.into()\n             }\n@@ -733,9 +716,9 @@ fn highlight_name_ref_by_syntax(name: ast::NameRef, sema: &Semantics<RootDatabas\n                 _ => {\n                     // within path, decide whether it is module or adt by checking for uppercase name\n                     return if name.text().chars().next().unwrap_or_default().is_uppercase() {\n-                        HighlightTag::Symbol(SymbolKind::Struct)\n+                        HlTag::Symbol(SymbolKind::Struct)\n                     } else {\n-                        HighlightTag::Symbol(SymbolKind::Module)\n+                        HlTag::Symbol(SymbolKind::Module)\n                     }\n                     .into();\n                 }\n@@ -746,11 +729,11 @@ fn highlight_name_ref_by_syntax(name: ast::NameRef, sema: &Semantics<RootDatabas\n             };\n \n             match parent.kind() {\n-                CALL_EXPR => HighlightTag::Symbol(SymbolKind::Function).into(),\n+                CALL_EXPR => HlTag::Symbol(SymbolKind::Function).into(),\n                 _ => if name.text().chars().next().unwrap_or_default().is_uppercase() {\n-                    HighlightTag::Symbol(SymbolKind::Struct)\n+                    HlTag::Symbol(SymbolKind::Struct)\n                 } else {\n-                    HighlightTag::Symbol(SymbolKind::Const)\n+                    HlTag::Symbol(SymbolKind::Const)\n                 }\n                 .into(),\n             }"}, {"sha": "d807ad0ad5c33f7b3ec5491799117323dd1baa13", "filename": "crates/ide/src/syntax_highlighting/format.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/939ca83b34f9a5648d196f85e5cc7d844ba22604/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/939ca83b34f9a5648d196f85e5cc7d844ba22604/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fformat.rs?ref=939ca83b34f9a5648d196f85e5cc7d844ba22604", "patch": "@@ -4,7 +4,7 @@ use syntax::{\n     AstNode, AstToken, SyntaxElement, SyntaxKind, SyntaxNode, TextRange,\n };\n \n-use crate::{HighlightTag, HighlightedRange, SymbolKind};\n+use crate::{HlRange, HlTag, SymbolKind};\n \n use super::highlights::Highlights;\n \n@@ -46,7 +46,7 @@ impl FormatStringHighlighter {\n         if self.format_string.as_ref() == Some(&SyntaxElement::from(string.syntax().clone())) {\n             string.lex_format_specifier(|piece_range, kind| {\n                 if let Some(highlight) = highlight_format_specifier(kind) {\n-                    stack.add(HighlightedRange {\n+                    stack.add(HlRange {\n                         range: piece_range + range.start(),\n                         highlight: highlight.into(),\n                         binding_hash: None,\n@@ -57,7 +57,7 @@ impl FormatStringHighlighter {\n     }\n }\n \n-fn highlight_format_specifier(kind: FormatSpecifier) -> Option<HighlightTag> {\n+fn highlight_format_specifier(kind: FormatSpecifier) -> Option<HlTag> {\n     Some(match kind {\n         FormatSpecifier::Open\n         | FormatSpecifier::Close\n@@ -69,8 +69,8 @@ fn highlight_format_specifier(kind: FormatSpecifier) -> Option<HighlightTag> {\n         | FormatSpecifier::DollarSign\n         | FormatSpecifier::Dot\n         | FormatSpecifier::Asterisk\n-        | FormatSpecifier::QuestionMark => HighlightTag::FormatSpecifier,\n-        FormatSpecifier::Integer | FormatSpecifier::Zero => HighlightTag::NumericLiteral,\n-        FormatSpecifier::Identifier => HighlightTag::Symbol(SymbolKind::Local),\n+        | FormatSpecifier::QuestionMark => HlTag::FormatSpecifier,\n+        FormatSpecifier::Integer | FormatSpecifier::Zero => HlTag::NumericLiteral,\n+        FormatSpecifier::Identifier => HlTag::Symbol(SymbolKind::Local),\n     })\n }"}, {"sha": "11c11ed288700561d490500c14526f0e7055b321", "filename": "crates/ide/src/syntax_highlighting/highlights.rs", "status": "modified", "additions": 26, "deletions": 35, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/939ca83b34f9a5648d196f85e5cc7d844ba22604/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlights.rs", "raw_url": "https://github.com/rust-lang/rust/raw/939ca83b34f9a5648d196f85e5cc7d844ba22604/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlights.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlights.rs?ref=939ca83b34f9a5648d196f85e5cc7d844ba22604", "patch": "@@ -4,93 +4,84 @@ use std::{cmp::Ordering, iter};\n use stdx::equal_range_by;\n use syntax::TextRange;\n \n-use crate::{HighlightTag, HighlightedRange};\n+use crate::{HlRange, HlTag};\n \n pub(super) struct Highlights {\n     root: Node,\n }\n \n struct Node {\n-    highlighted_range: HighlightedRange,\n+    hl_range: HlRange,\n     nested: Vec<Node>,\n }\n \n impl Highlights {\n     pub(super) fn new(range: TextRange) -> Highlights {\n         Highlights {\n-            root: Node::new(HighlightedRange {\n-                range,\n-                highlight: HighlightTag::Dummy.into(),\n-                binding_hash: None,\n-            }),\n+            root: Node::new(HlRange { range, highlight: HlTag::None.into(), binding_hash: None }),\n         }\n     }\n \n-    pub(super) fn add(&mut self, highlighted_range: HighlightedRange) {\n-        self.root.add(highlighted_range);\n+    pub(super) fn add(&mut self, hl_range: HlRange) {\n+        self.root.add(hl_range);\n     }\n \n-    pub(super) fn to_vec(self) -> Vec<HighlightedRange> {\n+    pub(super) fn to_vec(self) -> Vec<HlRange> {\n         let mut res = Vec::new();\n         self.root.flatten(&mut res);\n         res\n     }\n }\n \n impl Node {\n-    fn new(highlighted_range: HighlightedRange) -> Node {\n-        Node { highlighted_range, nested: Vec::new() }\n+    fn new(hl_range: HlRange) -> Node {\n+        Node { hl_range, nested: Vec::new() }\n     }\n \n-    fn add(&mut self, highlighted_range: HighlightedRange) {\n-        assert!(self.highlighted_range.range.contains_range(highlighted_range.range));\n+    fn add(&mut self, hl_range: HlRange) {\n+        assert!(self.hl_range.range.contains_range(hl_range.range));\n \n         // Fast path\n         if let Some(last) = self.nested.last_mut() {\n-            if last.highlighted_range.range.contains_range(highlighted_range.range) {\n-                return last.add(highlighted_range);\n+            if last.hl_range.range.contains_range(hl_range.range) {\n+                return last.add(hl_range);\n             }\n-            if last.highlighted_range.range.end() <= highlighted_range.range.start() {\n-                return self.nested.push(Node::new(highlighted_range));\n+            if last.hl_range.range.end() <= hl_range.range.start() {\n+                return self.nested.push(Node::new(hl_range));\n             }\n         }\n \n-        let (start, len) = equal_range_by(&self.nested, |n| {\n-            ordering(n.highlighted_range.range, highlighted_range.range)\n-        });\n+        let (start, len) =\n+            equal_range_by(&self.nested, |n| ordering(n.hl_range.range, hl_range.range));\n \n-        if len == 1\n-            && self.nested[start].highlighted_range.range.contains_range(highlighted_range.range)\n-        {\n-            return self.nested[start].add(highlighted_range);\n+        if len == 1 && self.nested[start].hl_range.range.contains_range(hl_range.range) {\n+            return self.nested[start].add(hl_range);\n         }\n \n         let nested = self\n             .nested\n-            .splice(start..start + len, iter::once(Node::new(highlighted_range)))\n+            .splice(start..start + len, iter::once(Node::new(hl_range)))\n             .collect::<Vec<_>>();\n         self.nested[start].nested = nested;\n     }\n \n-    fn flatten(&self, acc: &mut Vec<HighlightedRange>) {\n-        let mut start = self.highlighted_range.range.start();\n+    fn flatten(&self, acc: &mut Vec<HlRange>) {\n+        let mut start = self.hl_range.range.start();\n         let mut nested = self.nested.iter();\n         loop {\n             let next = nested.next();\n-            let end = next.map_or(self.highlighted_range.range.end(), |it| {\n-                it.highlighted_range.range.start()\n-            });\n+            let end = next.map_or(self.hl_range.range.end(), |it| it.hl_range.range.start());\n             if start < end {\n-                acc.push(HighlightedRange {\n+                acc.push(HlRange {\n                     range: TextRange::new(start, end),\n-                    highlight: self.highlighted_range.highlight,\n-                    binding_hash: self.highlighted_range.binding_hash,\n+                    highlight: self.hl_range.highlight,\n+                    binding_hash: self.hl_range.binding_hash,\n                 });\n             }\n             start = match next {\n                 Some(child) => {\n                     child.flatten(acc);\n-                    child.highlighted_range.range.end()\n+                    child.hl_range.range.end()\n                 }\n                 None => break,\n             }"}, {"sha": "0ee7bc96e21c62f0aa69b22ebb83f3f26317d05a", "filename": "crates/ide/src/syntax_highlighting/html.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/939ca83b34f9a5648d196f85e5cc7d844ba22604/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/939ca83b34f9a5648d196f85e5cc7d844ba22604/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs?ref=939ca83b34f9a5648d196f85e5cc7d844ba22604", "patch": "@@ -20,26 +20,26 @@ pub(crate) fn highlight_as_html(db: &RootDatabase, file_id: FileId, rainbow: boo\n         )\n     }\n \n-    let ranges = highlight(db, file_id, None, false);\n+    let hl_ranges = highlight(db, file_id, None, false);\n     let text = parse.tree().syntax().to_string();\n     let mut buf = String::new();\n     buf.push_str(&STYLE);\n     buf.push_str(\"<pre><code>\");\n-    for range in &ranges {\n-        let curr = &text[range.range];\n-        if range.highlight.is_empty() {\n-            format_to!(buf, \"{}\", html_escape(curr));\n+    for r in &hl_ranges {\n+        let chunk = html_escape(&text[r.range]);\n+        if r.highlight.is_empty() {\n+            format_to!(buf, \"{}\", chunk);\n             continue;\n         }\n \n-        let class = range.highlight.to_string().replace('.', \" \");\n-        let color = match (rainbow, range.binding_hash) {\n+        let class = r.highlight.to_string().replace('.', \" \");\n+        let color = match (rainbow, r.binding_hash) {\n             (true, Some(hash)) => {\n                 format!(\" data-binding-hash=\\\"{}\\\" style=\\\"color: {};\\\"\", hash, rainbowify(hash))\n             }\n             _ => \"\".into(),\n         };\n-        format_to!(buf, \"<span class=\\\"{}\\\"{}>{}</span>\", class, color, html_escape(curr));\n+        format_to!(buf, \"<span class=\\\"{}\\\"{}>{}</span>\", class, color, chunk);\n     }\n     buf.push_str(\"</code></pre>\");\n     buf"}, {"sha": "008d5ce244dbb0ecdf556ccbb657c1b247f1363c", "filename": "crates/ide/src/syntax_highlighting/injection.rs", "status": "modified", "additions": 39, "deletions": 66, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/939ca83b34f9a5648d196f85e5cc7d844ba22604/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finjection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/939ca83b34f9a5648d196f85e5cc7d844ba22604/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finjection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finjection.rs?ref=939ca83b34f9a5648d196f85e5cc7d844ba22604", "patch": "@@ -7,12 +7,12 @@ use ide_db::call_info::ActiveParameter;\n use itertools::Itertools;\n use syntax::{ast, AstToken, SyntaxNode, SyntaxToken, TextRange, TextSize};\n \n-use crate::{Analysis, HighlightModifier, HighlightTag, HighlightedRange, RootDatabase};\n+use crate::{Analysis, HlMod, HlRange, HlTag, RootDatabase};\n \n use super::{highlights::Highlights, injector::Injector};\n \n pub(super) fn highlight_injection(\n-    acc: &mut Highlights,\n+    hl: &mut Highlights,\n     sema: &Semantics<RootDatabase>,\n     literal: ast::String,\n     expanded: SyntaxToken,\n@@ -22,80 +22,53 @@ pub(super) fn highlight_injection(\n         return None;\n     }\n     let value = literal.value()?;\n-    let marker_info = MarkerInfo::new(&*value);\n-    let (analysis, tmp_file_id) = Analysis::from_single_file(marker_info.cleaned_text.clone());\n \n     if let Some(range) = literal.open_quote_text_range() {\n-        acc.add(HighlightedRange {\n-            range,\n-            highlight: HighlightTag::StringLiteral.into(),\n-            binding_hash: None,\n-        })\n+        hl.add(HlRange { range, highlight: HlTag::StringLiteral.into(), binding_hash: None })\n     }\n \n-    for mut h in analysis.highlight(tmp_file_id).unwrap() {\n-        let range = marker_info.map_range_up(h.range);\n-        if let Some(range) = literal.map_range_up(range) {\n-            h.range = range;\n-            acc.add(h);\n-        }\n-    }\n+    let mut inj = Injector::default();\n \n-    if let Some(range) = literal.close_quote_text_range() {\n-        acc.add(HighlightedRange {\n-            range,\n-            highlight: HighlightTag::StringLiteral.into(),\n-            binding_hash: None,\n-        })\n-    }\n+    let mut text = &*value;\n+    let mut offset: TextSize = 0.into();\n \n-    Some(())\n-}\n+    while !text.is_empty() {\n+        let marker = \"$0\";\n+        let idx = text.find(marker).unwrap_or(text.len());\n+        let (chunk, next) = text.split_at(idx);\n+        inj.add(chunk, TextRange::at(offset, TextSize::of(chunk)));\n \n-/// Data to remove `$0` from string and map ranges\n-#[derive(Default, Debug)]\n-struct MarkerInfo {\n-    cleaned_text: String,\n-    markers: Vec<TextRange>,\n-}\n+        text = next;\n+        offset += TextSize::of(chunk);\n \n-impl MarkerInfo {\n-    fn new(mut text: &str) -> Self {\n-        let marker = \"$0\";\n+        if let Some(next) = text.strip_prefix(marker) {\n+            if let Some(range) = literal.map_range_up(TextRange::at(offset, TextSize::of(marker))) {\n+                hl.add(HlRange { range, highlight: HlTag::Keyword.into(), binding_hash: None });\n+            }\n \n-        let mut res = MarkerInfo::default();\n-        let mut offset: TextSize = 0.into();\n-        while !text.is_empty() {\n-            let idx = text.find(marker).unwrap_or(text.len());\n-            let (chunk, next) = text.split_at(idx);\n             text = next;\n-            res.cleaned_text.push_str(chunk);\n-            offset += TextSize::of(chunk);\n-\n-            if let Some(next) = text.strip_prefix(marker) {\n-                text = next;\n \n-                let marker_len = TextSize::of(marker);\n-                res.markers.push(TextRange::at(offset, marker_len));\n-                offset += marker_len;\n-            }\n+            let marker_len = TextSize::of(marker);\n+            offset += marker_len;\n         }\n-        res\n     }\n-    fn map_range_up(&self, range: TextRange) -> TextRange {\n-        TextRange::new(\n-            self.map_offset_up(range.start(), true),\n-            self.map_offset_up(range.end(), false),\n-        )\n-    }\n-    fn map_offset_up(&self, mut offset: TextSize, start: bool) -> TextSize {\n-        for r in &self.markers {\n-            if r.start() < offset || (start && r.start() == offset) {\n-                offset += r.len()\n+\n+    let (analysis, tmp_file_id) = Analysis::from_single_file(inj.text().to_string());\n+\n+    for mut hl_range in analysis.highlight(tmp_file_id).unwrap() {\n+        for range in inj.map_range_up(hl_range.range) {\n+            if let Some(range) = literal.map_range_up(range) {\n+                hl_range.range = range;\n+                hl.add(hl_range.clone());\n             }\n         }\n-        offset\n     }\n+\n+    if let Some(range) = literal.close_quote_text_range() {\n+        hl.add(HlRange { range, highlight: HlTag::StringLiteral.into(), binding_hash: None })\n+    }\n+\n+    Some(())\n }\n \n const RUSTDOC_FENCE: &'static str = \"```\";\n@@ -116,7 +89,7 @@ const RUSTDOC_FENCE_TOKENS: &[&'static str] = &[\n /// Lastly, a vector of new comment highlight ranges (spanning only the\n /// comment prefix) is returned which is used in the syntax highlighting\n /// injection to replace the previous (line-spanning) comment ranges.\n-pub(super) fn extract_doc_comments(node: &SyntaxNode) -> Option<(Vec<HighlightedRange>, Injector)> {\n+pub(super) fn extract_doc_comments(node: &SyntaxNode) -> Option<(Vec<HlRange>, Injector)> {\n     let mut inj = Injector::default();\n     // wrap the doctest into function body to get correct syntax highlighting\n     let prefix = \"fn doctest() {\\n\";\n@@ -166,12 +139,12 @@ pub(super) fn extract_doc_comments(node: &SyntaxNode) -> Option<(Vec<Highlighted\n                 pos\n             };\n \n-            new_comments.push(HighlightedRange {\n+            new_comments.push(HlRange {\n                 range: TextRange::new(\n                     range.start(),\n                     range.start() + TextSize::try_from(pos).unwrap(),\n                 ),\n-                highlight: HighlightTag::Comment | HighlightModifier::Documentation,\n+                highlight: HlTag::Comment | HlMod::Documentation,\n                 binding_hash: None,\n             });\n             line_start += range.len() - TextSize::try_from(pos).unwrap();\n@@ -196,7 +169,7 @@ pub(super) fn extract_doc_comments(node: &SyntaxNode) -> Option<(Vec<Highlighted\n \n /// Injection of syntax highlighting of doctests.\n pub(super) fn highlight_doc_comment(\n-    new_comments: Vec<HighlightedRange>,\n+    new_comments: Vec<HlRange>,\n     inj: Injector,\n     stack: &mut Highlights,\n ) {\n@@ -207,9 +180,9 @@ pub(super) fn highlight_doc_comment(\n \n     for h in analysis.with_db(|db| super::highlight(db, tmp_file_id, None, true)).unwrap() {\n         for r in inj.map_range_up(h.range) {\n-            stack.add(HighlightedRange {\n+            stack.add(HlRange {\n                 range: r,\n-                highlight: h.highlight | HighlightModifier::Injected,\n+                highlight: h.highlight | HlMod::Injected,\n                 binding_hash: h.binding_hash,\n             });\n         }"}, {"sha": "e8f17eb69f6087c8b7938e9fdad6ce12951df9a9", "filename": "crates/ide/src/syntax_highlighting/injector.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/939ca83b34f9a5648d196f85e5cc7d844ba22604/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finjector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/939ca83b34f9a5648d196f85e5cc7d844ba22604/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finjector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finjector.rs?ref=939ca83b34f9a5648d196f85e5cc7d844ba22604", "patch": "@@ -17,17 +17,15 @@ impl Injector {\n     pub(super) fn add(&mut self, text: &str, source_range: TextRange) {\n         let len = TextSize::of(text);\n         assert_eq!(len, source_range.len());\n-\n-        let target_range = TextRange::at(TextSize::of(&self.buf), len);\n-        self.ranges\n-            .push((target_range, Some(Delta::new(target_range.start(), source_range.start()))));\n-        self.buf.push_str(text);\n+        self.add_impl(text, Some(source_range.start()));\n     }\n     pub(super) fn add_unmapped(&mut self, text: &str) {\n+        self.add_impl(text, None);\n+    }\n+    fn add_impl(&mut self, text: &str, source: Option<TextSize>) {\n         let len = TextSize::of(text);\n-\n         let target_range = TextRange::at(TextSize::of(&self.buf), len);\n-        self.ranges.push((target_range, None));\n+        self.ranges.push((target_range, source.map(|it| Delta::new(target_range.start(), it))));\n         self.buf.push_str(text);\n     }\n "}, {"sha": "21d8a98350e33d78966561a01e88e6fafa7a8474", "filename": "crates/ide/src/syntax_highlighting/macro_rules.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/939ca83b34f9a5648d196f85e5cc7d844ba22604/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/939ca83b34f9a5648d196f85e5cc7d844ba22604/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fmacro_rules.rs?ref=939ca83b34f9a5648d196f85e5cc7d844ba22604", "patch": "@@ -1,7 +1,7 @@\n //! Syntax highlighting for macro_rules!.\n use syntax::{SyntaxElement, SyntaxKind, SyntaxToken, TextRange, T};\n \n-use crate::{HighlightTag, HighlightedRange};\n+use crate::{HlRange, HlTag};\n \n #[derive(Default)]\n pub(super) struct MacroRulesHighlighter {\n@@ -19,13 +19,13 @@ impl MacroRulesHighlighter {\n         }\n     }\n \n-    pub(super) fn highlight(&self, element: SyntaxElement) -> Option<HighlightedRange> {\n+    pub(super) fn highlight(&self, element: SyntaxElement) -> Option<HlRange> {\n         if let Some(state) = self.state.as_ref() {\n             if matches!(state.rule_state, RuleState::Matcher | RuleState::Expander) {\n                 if let Some(range) = is_metavariable(element) {\n-                    return Some(HighlightedRange {\n+                    return Some(HlRange {\n                         range,\n-                        highlight: HighlightTag::UnresolvedReference.into(),\n+                        highlight: HlTag::UnresolvedReference.into(),\n                         binding_hash: None,\n                     });\n                 }"}, {"sha": "2f39bcc8e2f4e7c069be0b1bf908c2fec00e7011", "filename": "crates/ide/src/syntax_highlighting/tags.rs", "status": "modified", "additions": 69, "deletions": 69, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/939ca83b34f9a5648d196f85e5cc7d844ba22604/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/939ca83b34f9a5648d196f85e5cc7d844ba22604/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs?ref=939ca83b34f9a5648d196f85e5cc7d844ba22604", "patch": "@@ -7,15 +7,15 @@ use crate::SymbolKind;\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n pub struct Highlight {\n-    pub tag: HighlightTag,\n-    pub modifiers: HighlightModifiers,\n+    pub tag: HlTag,\n+    pub mods: HlMods,\n }\n \n #[derive(Default, Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n-pub struct HighlightModifiers(u32);\n+pub struct HlMods(u32);\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n-pub enum HighlightTag {\n+pub enum HlTag {\n     Symbol(SymbolKind),\n \n     BoolLiteral,\n@@ -33,13 +33,13 @@ pub enum HighlightTag {\n     Operator,\n     UnresolvedReference,\n \n-    // For things which don't have proper Tag, but want to use modifiers.\n-    Dummy,\n+    // For things which don't have a specific highlight.\n+    None,\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n #[repr(u8)]\n-pub enum HighlightModifier {\n+pub enum HlMod {\n     /// Used to differentiate individual elements within attributes.\n     Attribute = 0,\n     /// Used with keywords like `if` and `break`.\n@@ -61,10 +61,10 @@ pub enum HighlightModifier {\n     Unsafe,\n }\n \n-impl HighlightTag {\n+impl HlTag {\n     fn as_str(self) -> &'static str {\n         match self {\n-            HighlightTag::Symbol(symbol) => match symbol {\n+            HlTag::Symbol(symbol) => match symbol {\n                 SymbolKind::Const => \"constant\",\n                 SymbolKind::Static => \"static\",\n                 SymbolKind::Enum => \"enum\",\n@@ -86,59 +86,59 @@ impl HighlightTag {\n                 SymbolKind::SelfParam => \"self_keyword\",\n                 SymbolKind::Impl => \"self_type\",\n             },\n-            HighlightTag::Attribute => \"attribute\",\n-            HighlightTag::BoolLiteral => \"bool_literal\",\n-            HighlightTag::BuiltinType => \"builtin_type\",\n-            HighlightTag::ByteLiteral => \"byte_literal\",\n-            HighlightTag::CharLiteral => \"char_literal\",\n-            HighlightTag::Comment => \"comment\",\n-            HighlightTag::EscapeSequence => \"escape_sequence\",\n-            HighlightTag::FormatSpecifier => \"format_specifier\",\n-            HighlightTag::Keyword => \"keyword\",\n-            HighlightTag::Punctuation => \"punctuation\",\n-            HighlightTag::NumericLiteral => \"numeric_literal\",\n-            HighlightTag::Operator => \"operator\",\n-            HighlightTag::StringLiteral => \"string_literal\",\n-            HighlightTag::UnresolvedReference => \"unresolved_reference\",\n-            HighlightTag::Dummy => \"dummy\",\n+            HlTag::Attribute => \"attribute\",\n+            HlTag::BoolLiteral => \"bool_literal\",\n+            HlTag::BuiltinType => \"builtin_type\",\n+            HlTag::ByteLiteral => \"byte_literal\",\n+            HlTag::CharLiteral => \"char_literal\",\n+            HlTag::Comment => \"comment\",\n+            HlTag::EscapeSequence => \"escape_sequence\",\n+            HlTag::FormatSpecifier => \"format_specifier\",\n+            HlTag::Keyword => \"keyword\",\n+            HlTag::Punctuation => \"punctuation\",\n+            HlTag::NumericLiteral => \"numeric_literal\",\n+            HlTag::Operator => \"operator\",\n+            HlTag::StringLiteral => \"string_literal\",\n+            HlTag::UnresolvedReference => \"unresolved_reference\",\n+            HlTag::None => \"none\",\n         }\n     }\n }\n \n-impl fmt::Display for HighlightTag {\n+impl fmt::Display for HlTag {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Display::fmt(self.as_str(), f)\n     }\n }\n \n-impl HighlightModifier {\n-    const ALL: &'static [HighlightModifier; HighlightModifier::Unsafe as u8 as usize + 1] = &[\n-        HighlightModifier::Attribute,\n-        HighlightModifier::ControlFlow,\n-        HighlightModifier::Definition,\n-        HighlightModifier::Documentation,\n-        HighlightModifier::Injected,\n-        HighlightModifier::Mutable,\n-        HighlightModifier::Consuming,\n-        HighlightModifier::Callable,\n-        HighlightModifier::Static,\n-        HighlightModifier::Associated,\n-        HighlightModifier::Unsafe,\n+impl HlMod {\n+    const ALL: &'static [HlMod; HlMod::Unsafe as u8 as usize + 1] = &[\n+        HlMod::Attribute,\n+        HlMod::ControlFlow,\n+        HlMod::Definition,\n+        HlMod::Documentation,\n+        HlMod::Injected,\n+        HlMod::Mutable,\n+        HlMod::Consuming,\n+        HlMod::Callable,\n+        HlMod::Static,\n+        HlMod::Associated,\n+        HlMod::Unsafe,\n     ];\n \n     fn as_str(self) -> &'static str {\n         match self {\n-            HighlightModifier::Attribute => \"attribute\",\n-            HighlightModifier::ControlFlow => \"control\",\n-            HighlightModifier::Definition => \"declaration\",\n-            HighlightModifier::Documentation => \"documentation\",\n-            HighlightModifier::Injected => \"injected\",\n-            HighlightModifier::Mutable => \"mutable\",\n-            HighlightModifier::Consuming => \"consuming\",\n-            HighlightModifier::Unsafe => \"unsafe\",\n-            HighlightModifier::Callable => \"callable\",\n-            HighlightModifier::Static => \"static\",\n-            HighlightModifier::Associated => \"associated\",\n+            HlMod::Attribute => \"attribute\",\n+            HlMod::ControlFlow => \"control\",\n+            HlMod::Definition => \"declaration\",\n+            HlMod::Documentation => \"documentation\",\n+            HlMod::Injected => \"injected\",\n+            HlMod::Mutable => \"mutable\",\n+            HlMod::Consuming => \"consuming\",\n+            HlMod::Unsafe => \"unsafe\",\n+            HlMod::Callable => \"callable\",\n+            HlMod::Static => \"static\",\n+            HlMod::Associated => \"associated\",\n         }\n     }\n \n@@ -147,7 +147,7 @@ impl HighlightModifier {\n     }\n }\n \n-impl fmt::Display for HighlightModifier {\n+impl fmt::Display for HlMod {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Display::fmt(self.as_str(), f)\n     }\n@@ -156,63 +156,63 @@ impl fmt::Display for HighlightModifier {\n impl fmt::Display for Highlight {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"{}\", self.tag)?;\n-        for modifier in self.modifiers.iter() {\n+        for modifier in self.mods.iter() {\n             write!(f, \".{}\", modifier)?\n         }\n         Ok(())\n     }\n }\n \n-impl From<HighlightTag> for Highlight {\n-    fn from(tag: HighlightTag) -> Highlight {\n+impl From<HlTag> for Highlight {\n+    fn from(tag: HlTag) -> Highlight {\n         Highlight::new(tag)\n     }\n }\n \n impl Highlight {\n-    pub(crate) fn new(tag: HighlightTag) -> Highlight {\n-        Highlight { tag, modifiers: HighlightModifiers::default() }\n+    pub(crate) fn new(tag: HlTag) -> Highlight {\n+        Highlight { tag, mods: HlMods::default() }\n     }\n     pub fn is_empty(&self) -> bool {\n-        self.tag == HighlightTag::Dummy && self.modifiers == HighlightModifiers::default()\n+        self.tag == HlTag::None && self.mods == HlMods::default()\n     }\n }\n \n-impl ops::BitOr<HighlightModifier> for HighlightTag {\n+impl ops::BitOr<HlMod> for HlTag {\n     type Output = Highlight;\n \n-    fn bitor(self, rhs: HighlightModifier) -> Highlight {\n+    fn bitor(self, rhs: HlMod) -> Highlight {\n         Highlight::new(self) | rhs\n     }\n }\n \n-impl ops::BitOrAssign<HighlightModifier> for HighlightModifiers {\n-    fn bitor_assign(&mut self, rhs: HighlightModifier) {\n+impl ops::BitOrAssign<HlMod> for HlMods {\n+    fn bitor_assign(&mut self, rhs: HlMod) {\n         self.0 |= rhs.mask();\n     }\n }\n \n-impl ops::BitOrAssign<HighlightModifier> for Highlight {\n-    fn bitor_assign(&mut self, rhs: HighlightModifier) {\n-        self.modifiers |= rhs;\n+impl ops::BitOrAssign<HlMod> for Highlight {\n+    fn bitor_assign(&mut self, rhs: HlMod) {\n+        self.mods |= rhs;\n     }\n }\n \n-impl ops::BitOr<HighlightModifier> for Highlight {\n+impl ops::BitOr<HlMod> for Highlight {\n     type Output = Highlight;\n \n-    fn bitor(mut self, rhs: HighlightModifier) -> Highlight {\n+    fn bitor(mut self, rhs: HlMod) -> Highlight {\n         self |= rhs;\n         self\n     }\n }\n \n-impl HighlightModifiers {\n-    pub fn contains(self, m: HighlightModifier) -> bool {\n+impl HlMods {\n+    pub fn contains(self, m: HlMod) -> bool {\n         self.0 & m.mask() == m.mask()\n     }\n \n-    pub fn iter(self) -> impl Iterator<Item = HighlightModifier> {\n-        HighlightModifier::ALL.iter().copied().filter(move |it| self.0 & it.mask() == it.mask())\n+    pub fn iter(self) -> impl Iterator<Item = HlMod> {\n+        HlMod::ALL.iter().copied().filter(move |it| self.0 & it.mask() == it.mask())\n     }\n }"}, {"sha": "7d1d2a839925a74aabe1ec472de7f8ac81c7811b", "filename": "crates/ide/src/syntax_highlighting/test_data/highlight_doctest.html", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/939ca83b34f9a5648d196f85e5cc7d844ba22604/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_doctest.html", "raw_url": "https://github.com/rust-lang/rust/raw/939ca83b34f9a5648d196f85e5cc7d844ba22604/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_doctest.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_doctest.html?ref=939ca83b34f9a5648d196f85e5cc7d844ba22604", "patch": "@@ -37,15 +37,15 @@\n .unresolved_reference { color: #FC5555; text-decoration: wavy underline; }\n </style>\n <pre><code><span class=\"comment documentation\">/// ```</span>\n-<span class=\"comment documentation\">/// </span><span class=\"keyword injected\">let</span><span class=\"dummy injected\"> </span><span class=\"punctuation injected\">_</span><span class=\"dummy injected\"> </span><span class=\"operator injected\">=</span><span class=\"dummy injected\"> </span><span class=\"string_literal injected\">\"early doctests should not go boom\"</span><span class=\"punctuation injected\">;</span>\n+<span class=\"comment documentation\">/// </span><span class=\"keyword injected\">let</span><span class=\"none injected\"> </span><span class=\"punctuation injected\">_</span><span class=\"none injected\"> </span><span class=\"operator injected\">=</span><span class=\"none injected\"> </span><span class=\"string_literal injected\">\"early doctests should not go boom\"</span><span class=\"punctuation injected\">;</span>\n <span class=\"comment documentation\">/// ```</span>\n <span class=\"keyword\">struct</span> <span class=\"struct declaration\">Foo</span> <span class=\"punctuation\">{</span>\n     <span class=\"field declaration\">bar</span><span class=\"punctuation\">:</span> <span class=\"builtin_type\">bool</span><span class=\"punctuation\">,</span>\n <span class=\"punctuation\">}</span>\n \n <span class=\"keyword\">impl</span> <span class=\"struct\">Foo</span> <span class=\"punctuation\">{</span>\n     <span class=\"comment documentation\">/// ```</span>\n-    <span class=\"comment documentation\">/// </span><span class=\"keyword injected\">let</span><span class=\"dummy injected\"> </span><span class=\"punctuation injected\">_</span><span class=\"dummy injected\"> </span><span class=\"operator injected\">=</span><span class=\"dummy injected\"> </span><span class=\"string_literal injected\">\"Call me</span>\n+    <span class=\"comment documentation\">/// </span><span class=\"keyword injected\">let</span><span class=\"none injected\"> </span><span class=\"punctuation injected\">_</span><span class=\"none injected\"> </span><span class=\"operator injected\">=</span><span class=\"none injected\"> </span><span class=\"string_literal injected\">\"Call me</span>\n     <span class=\"comment\">//    KILLER WHALE</span>\n     <span class=\"comment documentation\">/// </span><span class=\"string_literal injected\">    Ishmael.\"</span><span class=\"punctuation injected\">;</span>\n     <span class=\"comment documentation\">/// ```</span>\n@@ -56,8 +56,8 @@\n     <span class=\"comment documentation\">/// # Examples</span>\n     <span class=\"comment documentation\">///</span>\n     <span class=\"comment documentation\">/// ```</span>\n-    <span class=\"comment documentation\">/// #</span><span class=\"dummy injected\"> </span><span class=\"attribute attribute injected\">#</span><span class=\"attribute attribute injected\">!</span><span class=\"attribute attribute injected\">[</span><span class=\"function attribute injected\">allow</span><span class=\"punctuation attribute injected\">(</span><span class=\"attribute attribute injected\">unused_mut</span><span class=\"punctuation attribute injected\">)</span><span class=\"attribute attribute injected\">]</span>\n-    <span class=\"comment documentation\">/// </span><span class=\"keyword injected\">let</span><span class=\"dummy injected\"> </span><span class=\"keyword injected\">mut</span><span class=\"dummy injected\"> </span><span class=\"variable declaration injected mutable\">foo</span><span class=\"punctuation injected\">:</span><span class=\"dummy injected\"> </span><span class=\"struct injected\">Foo</span><span class=\"dummy injected\"> </span><span class=\"operator injected\">=</span><span class=\"dummy injected\"> </span><span class=\"struct injected\">Foo</span><span class=\"operator injected\">::</span><span class=\"function injected\">new</span><span class=\"punctuation injected\">(</span><span class=\"punctuation injected\">)</span><span class=\"punctuation injected\">;</span>\n+    <span class=\"comment documentation\">/// #</span><span class=\"none injected\"> </span><span class=\"attribute attribute injected\">#</span><span class=\"attribute attribute injected\">!</span><span class=\"attribute attribute injected\">[</span><span class=\"function attribute injected\">allow</span><span class=\"punctuation attribute injected\">(</span><span class=\"attribute attribute injected\">unused_mut</span><span class=\"punctuation attribute injected\">)</span><span class=\"attribute attribute injected\">]</span>\n+    <span class=\"comment documentation\">/// </span><span class=\"keyword injected\">let</span><span class=\"none injected\"> </span><span class=\"keyword injected\">mut</span><span class=\"none injected\"> </span><span class=\"variable declaration injected mutable\">foo</span><span class=\"punctuation injected\">:</span><span class=\"none injected\"> </span><span class=\"struct injected\">Foo</span><span class=\"none injected\"> </span><span class=\"operator injected\">=</span><span class=\"none injected\"> </span><span class=\"struct injected\">Foo</span><span class=\"operator injected\">::</span><span class=\"function injected\">new</span><span class=\"punctuation injected\">(</span><span class=\"punctuation injected\">)</span><span class=\"punctuation injected\">;</span>\n     <span class=\"comment documentation\">/// ```</span>\n     <span class=\"keyword\">pub</span> <span class=\"keyword\">const</span> <span class=\"keyword\">fn</span> <span class=\"function declaration static associated\">new</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"struct\">Foo</span> <span class=\"punctuation\">{</span>\n         <span class=\"struct\">Foo</span> <span class=\"punctuation\">{</span> <span class=\"field\">bar</span><span class=\"punctuation\">:</span> <span class=\"bool_literal\">true</span> <span class=\"punctuation\">}</span>\n@@ -68,26 +68,26 @@\n     <span class=\"comment documentation\">/// # Examples</span>\n     <span class=\"comment documentation\">///</span>\n     <span class=\"comment documentation\">/// ```</span>\n-    <span class=\"comment documentation\">/// </span><span class=\"keyword injected\">use</span><span class=\"dummy injected\"> </span><span class=\"module injected\">x</span><span class=\"operator injected\">::</span><span class=\"module injected\">y</span><span class=\"punctuation injected\">;</span>\n+    <span class=\"comment documentation\">/// </span><span class=\"keyword injected\">use</span><span class=\"none injected\"> </span><span class=\"module injected\">x</span><span class=\"operator injected\">::</span><span class=\"module injected\">y</span><span class=\"punctuation injected\">;</span>\n     <span class=\"comment documentation\">///</span>\n-    <span class=\"comment documentation\">/// </span><span class=\"keyword injected\">let</span><span class=\"dummy injected\"> </span><span class=\"variable declaration injected\">foo</span><span class=\"dummy injected\"> </span><span class=\"operator injected\">=</span><span class=\"dummy injected\"> </span><span class=\"struct injected\">Foo</span><span class=\"operator injected\">::</span><span class=\"function injected\">new</span><span class=\"punctuation injected\">(</span><span class=\"punctuation injected\">)</span><span class=\"punctuation injected\">;</span>\n+    <span class=\"comment documentation\">/// </span><span class=\"keyword injected\">let</span><span class=\"none injected\"> </span><span class=\"variable declaration injected\">foo</span><span class=\"none injected\"> </span><span class=\"operator injected\">=</span><span class=\"none injected\"> </span><span class=\"struct injected\">Foo</span><span class=\"operator injected\">::</span><span class=\"function injected\">new</span><span class=\"punctuation injected\">(</span><span class=\"punctuation injected\">)</span><span class=\"punctuation injected\">;</span>\n     <span class=\"comment documentation\">///</span>\n     <span class=\"comment documentation\">/// </span><span class=\"comment injected\">// calls bar on foo</span>\n-    <span class=\"comment documentation\">/// </span><span class=\"macro injected\">assert!</span><span class=\"punctuation injected\">(</span><span class=\"dummy injected\">foo</span><span class=\"operator injected\">.</span><span class=\"dummy injected\">bar</span><span class=\"punctuation injected\">(</span><span class=\"punctuation injected\">)</span><span class=\"punctuation injected\">)</span><span class=\"punctuation injected\">;</span>\n+    <span class=\"comment documentation\">/// </span><span class=\"macro injected\">assert!</span><span class=\"punctuation injected\">(</span><span class=\"none injected\">foo</span><span class=\"operator injected\">.</span><span class=\"none injected\">bar</span><span class=\"punctuation injected\">(</span><span class=\"punctuation injected\">)</span><span class=\"punctuation injected\">)</span><span class=\"punctuation injected\">;</span>\n     <span class=\"comment documentation\">///</span>\n-    <span class=\"comment documentation\">/// </span><span class=\"keyword injected\">let</span><span class=\"dummy injected\"> </span><span class=\"variable declaration injected\">bar</span><span class=\"dummy injected\"> </span><span class=\"operator injected\">=</span><span class=\"dummy injected\"> </span><span class=\"variable injected\">foo</span><span class=\"operator injected\">.</span><span class=\"field injected\">bar</span><span class=\"dummy injected\"> </span><span class=\"operator injected\">||</span><span class=\"dummy injected\"> </span><span class=\"struct injected\">Foo</span><span class=\"operator injected\">::</span><span class=\"constant injected\">bar</span><span class=\"punctuation injected\">;</span>\n+    <span class=\"comment documentation\">/// </span><span class=\"keyword injected\">let</span><span class=\"none injected\"> </span><span class=\"variable declaration injected\">bar</span><span class=\"none injected\"> </span><span class=\"operator injected\">=</span><span class=\"none injected\"> </span><span class=\"variable injected\">foo</span><span class=\"operator injected\">.</span><span class=\"field injected\">bar</span><span class=\"none injected\"> </span><span class=\"operator injected\">||</span><span class=\"none injected\"> </span><span class=\"struct injected\">Foo</span><span class=\"operator injected\">::</span><span class=\"constant injected\">bar</span><span class=\"punctuation injected\">;</span>\n     <span class=\"comment documentation\">///</span>\n     <span class=\"comment documentation\">/// </span><span class=\"comment injected\">/* multi-line</span>\n     <span class=\"comment documentation\">/// </span><span class=\"comment injected\">       comment */</span>\n     <span class=\"comment documentation\">///</span>\n-    <span class=\"comment documentation\">/// </span><span class=\"keyword injected\">let</span><span class=\"dummy injected\"> </span><span class=\"variable declaration injected\">multi_line_string</span><span class=\"dummy injected\"> </span><span class=\"operator injected\">=</span><span class=\"dummy injected\"> </span><span class=\"string_literal injected\">\"Foo</span>\n+    <span class=\"comment documentation\">/// </span><span class=\"keyword injected\">let</span><span class=\"none injected\"> </span><span class=\"variable declaration injected\">multi_line_string</span><span class=\"none injected\"> </span><span class=\"operator injected\">=</span><span class=\"none injected\"> </span><span class=\"string_literal injected\">\"Foo</span>\n     <span class=\"comment documentation\">/// </span><span class=\"string_literal injected\">  bar</span>\n     <span class=\"comment documentation\">/// </span><span class=\"string_literal injected\">         \"</span><span class=\"punctuation injected\">;</span>\n     <span class=\"comment documentation\">///</span>\n     <span class=\"comment documentation\">/// ```</span>\n     <span class=\"comment documentation\">///</span>\n     <span class=\"comment documentation\">/// ```rust,no_run</span>\n-    <span class=\"comment documentation\">/// </span><span class=\"keyword injected\">let</span><span class=\"dummy injected\"> </span><span class=\"variable declaration injected\">foobar</span><span class=\"dummy injected\"> </span><span class=\"operator injected\">=</span><span class=\"dummy injected\"> </span><span class=\"struct injected\">Foo</span><span class=\"operator injected\">::</span><span class=\"function injected\">new</span><span class=\"punctuation injected\">(</span><span class=\"punctuation injected\">)</span><span class=\"operator injected\">.</span><span class=\"function injected\">bar</span><span class=\"punctuation injected\">(</span><span class=\"punctuation injected\">)</span><span class=\"punctuation injected\">;</span>\n+    <span class=\"comment documentation\">/// </span><span class=\"keyword injected\">let</span><span class=\"none injected\"> </span><span class=\"variable declaration injected\">foobar</span><span class=\"none injected\"> </span><span class=\"operator injected\">=</span><span class=\"none injected\"> </span><span class=\"struct injected\">Foo</span><span class=\"operator injected\">::</span><span class=\"function injected\">new</span><span class=\"punctuation injected\">(</span><span class=\"punctuation injected\">)</span><span class=\"operator injected\">.</span><span class=\"function injected\">bar</span><span class=\"punctuation injected\">(</span><span class=\"punctuation injected\">)</span><span class=\"punctuation injected\">;</span>\n     <span class=\"comment documentation\">/// ```</span>\n     <span class=\"comment documentation\">///</span>\n     <span class=\"comment documentation\">/// ```sh</span>"}, {"sha": "6703a84e5db33474703a673cd0e7444f05c1ee7c", "filename": "crates/ide/src/syntax_highlighting/test_data/injection.html", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/939ca83b34f9a5648d196f85e5cc7d844ba22604/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Finjection.html", "raw_url": "https://github.com/rust-lang/rust/raw/939ca83b34f9a5648d196f85e5cc7d844ba22604/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Finjection.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Finjection.html?ref=939ca83b34f9a5648d196f85e5cc7d844ba22604", "patch": "@@ -40,9 +40,9 @@\n <span class=\"keyword\">fn</span> <span class=\"function declaration\">main</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span> <span class=\"punctuation\">{</span>\n     <span class=\"function\">f</span><span class=\"punctuation\">(</span><span class=\"string_literal\">r\"</span>\n <span class=\"keyword\">fn</span> <span class=\"function declaration\">foo</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span> <span class=\"punctuation\">{</span>\n-    <span class=\"function\">foo</span><span class=\"punctuation\">(</span>$0<span class=\"punctuation\">{</span>\n+    <span class=\"function\">foo</span><span class=\"punctuation\">(</span><span class=\"keyword\">$0</span><span class=\"punctuation\">{</span>\n         <span class=\"numeric_literal\">92</span>\n-    <span class=\"punctuation\">}</span>$0<span class=\"punctuation\">)</span>\n+    <span class=\"punctuation\">}</span><span class=\"keyword\">$0</span><span class=\"punctuation\">)</span>\n <span class=\"punctuation\">}</span><span class=\"string_literal\">\"</span><span class=\"punctuation\">)</span><span class=\"punctuation\">;</span>\n <span class=\"punctuation\">}</span>\n     </code></pre>\n\\ No newline at end of file"}, {"sha": "d6bf60cde2ae4db5a7d59272b21a4fdcf2056e21", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 31, "deletions": 36, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/939ca83b34f9a5648d196f85e5cc7d844ba22604/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/939ca83b34f9a5648d196f85e5cc7d844ba22604/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=939ca83b34f9a5648d196f85e5cc7d844ba22604", "patch": "@@ -6,10 +6,9 @@ use std::{\n \n use ide::{\n     Assist, AssistKind, CallInfo, CompletionItem, CompletionItemKind, Documentation, FileId,\n-    FileRange, FileSystemEdit, Fold, FoldKind, Highlight, HighlightModifier, HighlightTag,\n-    HighlightedRange, Indel, InlayHint, InlayKind, InsertTextFormat, LineIndex, Markup,\n-    NavigationTarget, ReferenceAccess, Runnable, Severity, SourceChange, SourceFileEdit,\n-    SymbolKind, TextEdit, TextRange, TextSize,\n+    FileRange, FileSystemEdit, Fold, FoldKind, Highlight, HlMod, HlRange, HlTag, Indel, InlayHint,\n+    InlayKind, InsertTextFormat, LineIndex, Markup, NavigationTarget, ReferenceAccess, Runnable,\n+    Severity, SourceChange, SourceFileEdit, SymbolKind, TextEdit, TextRange, TextSize,\n };\n use itertools::Itertools;\n \n@@ -337,7 +336,7 @@ static TOKEN_RESULT_COUNTER: AtomicU32 = AtomicU32::new(1);\n pub(crate) fn semantic_tokens(\n     text: &str,\n     line_index: &LineIndex,\n-    highlights: Vec<HighlightedRange>,\n+    highlights: Vec<HlRange>,\n ) -> lsp_types::SemanticTokens {\n     let id = TOKEN_RESULT_COUNTER.fetch_add(1, Ordering::SeqCst).to_string();\n     let mut builder = semantic_tokens::SemanticTokensBuilder::new(id);\n@@ -377,7 +376,7 @@ fn semantic_token_type_and_modifiers(\n ) -> (lsp_types::SemanticTokenType, semantic_tokens::ModifierSet) {\n     let mut mods = semantic_tokens::ModifierSet::default();\n     let type_ = match highlight.tag {\n-        HighlightTag::Symbol(symbol) => match symbol {\n+        HlTag::Symbol(symbol) => match symbol {\n             SymbolKind::Module => lsp_types::SemanticTokenType::NAMESPACE,\n             SymbolKind::Impl => lsp_types::SemanticTokenType::TYPE,\n             SymbolKind::Field => lsp_types::SemanticTokenType::PROPERTY,\n@@ -389,7 +388,7 @@ fn semantic_token_type_and_modifiers(\n             SymbolKind::SelfParam => semantic_tokens::SELF_KEYWORD,\n             SymbolKind::Local => lsp_types::SemanticTokenType::VARIABLE,\n             SymbolKind::Function => {\n-                if highlight.modifiers.contains(HighlightModifier::Associated) {\n+                if highlight.mods.contains(HlMod::Associated) {\n                     lsp_types::SemanticTokenType::METHOD\n                 } else {\n                     lsp_types::SemanticTokenType::FUNCTION\n@@ -412,38 +411,34 @@ fn semantic_token_type_and_modifiers(\n             SymbolKind::Trait => lsp_types::SemanticTokenType::INTERFACE,\n             SymbolKind::Macro => lsp_types::SemanticTokenType::MACRO,\n         },\n-        HighlightTag::BuiltinType => semantic_tokens::BUILTIN_TYPE,\n-        HighlightTag::Dummy => semantic_tokens::GENERIC,\n-        HighlightTag::ByteLiteral | HighlightTag::NumericLiteral => {\n-            lsp_types::SemanticTokenType::NUMBER\n-        }\n-        HighlightTag::BoolLiteral => semantic_tokens::BOOLEAN,\n-        HighlightTag::CharLiteral | HighlightTag::StringLiteral => {\n-            lsp_types::SemanticTokenType::STRING\n-        }\n-        HighlightTag::Comment => lsp_types::SemanticTokenType::COMMENT,\n-        HighlightTag::Attribute => semantic_tokens::ATTRIBUTE,\n-        HighlightTag::Keyword => lsp_types::SemanticTokenType::KEYWORD,\n-        HighlightTag::UnresolvedReference => semantic_tokens::UNRESOLVED_REFERENCE,\n-        HighlightTag::FormatSpecifier => semantic_tokens::FORMAT_SPECIFIER,\n-        HighlightTag::Operator => lsp_types::SemanticTokenType::OPERATOR,\n-        HighlightTag::EscapeSequence => semantic_tokens::ESCAPE_SEQUENCE,\n-        HighlightTag::Punctuation => semantic_tokens::PUNCTUATION,\n+        HlTag::BuiltinType => semantic_tokens::BUILTIN_TYPE,\n+        HlTag::None => semantic_tokens::GENERIC,\n+        HlTag::ByteLiteral | HlTag::NumericLiteral => lsp_types::SemanticTokenType::NUMBER,\n+        HlTag::BoolLiteral => semantic_tokens::BOOLEAN,\n+        HlTag::CharLiteral | HlTag::StringLiteral => lsp_types::SemanticTokenType::STRING,\n+        HlTag::Comment => lsp_types::SemanticTokenType::COMMENT,\n+        HlTag::Attribute => semantic_tokens::ATTRIBUTE,\n+        HlTag::Keyword => lsp_types::SemanticTokenType::KEYWORD,\n+        HlTag::UnresolvedReference => semantic_tokens::UNRESOLVED_REFERENCE,\n+        HlTag::FormatSpecifier => semantic_tokens::FORMAT_SPECIFIER,\n+        HlTag::Operator => lsp_types::SemanticTokenType::OPERATOR,\n+        HlTag::EscapeSequence => semantic_tokens::ESCAPE_SEQUENCE,\n+        HlTag::Punctuation => semantic_tokens::PUNCTUATION,\n     };\n \n-    for modifier in highlight.modifiers.iter() {\n+    for modifier in highlight.mods.iter() {\n         let modifier = match modifier {\n-            HighlightModifier::Attribute => semantic_tokens::ATTRIBUTE_MODIFIER,\n-            HighlightModifier::Definition => lsp_types::SemanticTokenModifier::DECLARATION,\n-            HighlightModifier::Documentation => lsp_types::SemanticTokenModifier::DOCUMENTATION,\n-            HighlightModifier::Injected => semantic_tokens::INJECTED,\n-            HighlightModifier::ControlFlow => semantic_tokens::CONTROL_FLOW,\n-            HighlightModifier::Mutable => semantic_tokens::MUTABLE,\n-            HighlightModifier::Consuming => semantic_tokens::CONSUMING,\n-            HighlightModifier::Unsafe => semantic_tokens::UNSAFE,\n-            HighlightModifier::Callable => semantic_tokens::CALLABLE,\n-            HighlightModifier::Static => lsp_types::SemanticTokenModifier::STATIC,\n-            HighlightModifier::Associated => continue,\n+            HlMod::Attribute => semantic_tokens::ATTRIBUTE_MODIFIER,\n+            HlMod::Definition => lsp_types::SemanticTokenModifier::DECLARATION,\n+            HlMod::Documentation => lsp_types::SemanticTokenModifier::DOCUMENTATION,\n+            HlMod::Injected => semantic_tokens::INJECTED,\n+            HlMod::ControlFlow => semantic_tokens::CONTROL_FLOW,\n+            HlMod::Mutable => semantic_tokens::MUTABLE,\n+            HlMod::Consuming => semantic_tokens::CONSUMING,\n+            HlMod::Unsafe => semantic_tokens::UNSAFE,\n+            HlMod::Callable => semantic_tokens::CALLABLE,\n+            HlMod::Static => lsp_types::SemanticTokenModifier::STATIC,\n+            HlMod::Associated => continue,\n         };\n         mods |= modifier;\n     }"}]}