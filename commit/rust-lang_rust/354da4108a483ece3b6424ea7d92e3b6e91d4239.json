{"sha": "354da4108a483ece3b6424ea7d92e3b6e91d4239", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1NGRhNDEwOGE0ODNlY2UzYjY0MjRlYTdkOTJlM2I2ZTkxZDQyMzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-16T02:53:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-16T02:53:18Z"}, "message": "auto merge of #4799 : graydon/rust/rustpkg, r=graydon\n\nTaking over where #4610 left off. Much rebasing and tidying.", "tree": {"sha": "086b516f606d598da7d2fee28193e550ace8fbbf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/086b516f606d598da7d2fee28193e550ace8fbbf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/354da4108a483ece3b6424ea7d92e3b6e91d4239", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/354da4108a483ece3b6424ea7d92e3b6e91d4239", "html_url": "https://github.com/rust-lang/rust/commit/354da4108a483ece3b6424ea7d92e3b6e91d4239", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/354da4108a483ece3b6424ea7d92e3b6e91d4239/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e97cce27d55bb123fbf8c69f4bb2bd0a3ba9c08", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e97cce27d55bb123fbf8c69f4bb2bd0a3ba9c08", "html_url": "https://github.com/rust-lang/rust/commit/3e97cce27d55bb123fbf8c69f4bb2bd0a3ba9c08"}, {"sha": "585d6f7b00eab09099504924e70837966f5fe678", "url": "https://api.github.com/repos/rust-lang/rust/commits/585d6f7b00eab09099504924e70837966f5fe678", "html_url": "https://github.com/rust-lang/rust/commit/585d6f7b00eab09099504924e70837966f5fe678"}], "stats": {"total": 4669, "additions": 2477, "deletions": 2192}, "files": [{"sha": "92903a26093f97e342b09300513a82f67d6d1e1c", "filename": "AUTHORS.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/354da4108a483ece3b6424ea7d92e3b6e91d4239/AUTHORS.txt", "raw_url": "https://github.com/rust-lang/rust/raw/354da4108a483ece3b6424ea7d92e3b6e91d4239/AUTHORS.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/AUTHORS.txt?ref=354da4108a483ece3b6424ea7d92e3b6e91d4239", "patch": "@@ -161,4 +161,4 @@ Wade Mealing <wmealing@gmail.com>\n William Ting <william.h.ting@gmail.com>\n Yasuhiro Fujii <y-fujii@mimosa-pudica.net>\n Youngsoo Son <ysson83@gmail.com>\n-Zack Corr <zackcorr95@gmail.com>\n+Zack Corr <zack@z0w0.me>"}, {"sha": "cf6fcd42021ed02ecc2abdb672ddfaebaeed44f6", "filename": "Makefile.in", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/354da4108a483ece3b6424ea7d92e3b6e91d4239/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/354da4108a483ece3b6424ea7d92e3b6e91d4239/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=354da4108a483ece3b6424ea7d92e3b6e91d4239", "patch": "@@ -131,7 +131,7 @@ CFG_STDLIB :=$(call CFG_LIB_NAME,std)\n CFG_LIBRUSTC :=$(call CFG_LIB_NAME,rustc)\n CFG_LIBSYNTAX :=$(call CFG_LIB_NAME,syntax)\n CFG_LIBFUZZER :=$(call CFG_LIB_NAME,fuzzer)\n-CFG_LIBCARGO :=$(call CFG_LIB_NAME,cargo)\n+CFG_LIBRUSTPKG :=$(call CFG_LIB_NAME,rustpkg)\n CFG_LIBRUSTDOC :=$(call CFG_LIB_NAME,rustdoc)\n CFG_LIBRUSTI :=$(call CFG_LIB_NAME,rusti)\n \n@@ -140,15 +140,15 @@ CORELIB_GLOB :=$(call CFG_LIB_GLOB,core)\n LIBRUSTC_GLOB :=$(call CFG_LIB_GLOB,rustc)\n LIBSYNTAX_GLOB :=$(call CFG_LIB_GLOB,syntax)\n LIBFUZZER_GLOB :=$(call CFG_LIB_GLOB,fuzzer)\n-LIBCARGO_GLOB :=$(call CFG_LIB_GLOB,cargo)\n+LIBRUSTPKG_GLOB :=$(call CFG_LIB_GLOB,rustpkg)\n LIBRUSTDOC_GLOB :=$(call CFG_LIB_GLOB,rustdoc)\n LIBRUSTI_GLOB :=$(call CFG_LIB_GLOB,rusti)\n STDLIB_DSYM_GLOB :=$(call CFG_LIB_DSYM_GLOB,std)\n CORELIB_DSYM_GLOB :=$(call CFG_LIB_DSYM_GLOB,core)\n LIBRUSTC_DSYM_GLOB :=$(call CFG_LIB_DSYM_GLOB,rustc)\n LIBSYNTAX_DSYM_GLOB :=$(call CFG_LIB_DSYM_GLOB,syntax)\n LIBFUZZER_DSYM_GLOB :=$(call CFG_LIB_DSYM_GLOB,fuzzer)\n-LIBCARGO_DSYM_GLOB :=$(call CFG_LIB_DSYM_GLOB,cargo)\n+LIBRUSTPKG_DSYM_GLOB :=$(call CFG_LIB_DSYM_GLOB,rustpkg)\n LIBRUSTDOC_DSYM_GLOB :=$(call CFG_LIB_DSYM_GLOB,rustdoc)\n LIBRUSTI_DSYM_GLOB :=$(call CFG_LIB_DSYM_GLOB,rusti)\n \n@@ -371,19 +371,19 @@ SREQ$(1)_T_$(2)_H_$(3) = \\\n CSREQ$(1)_T_$(2)_H_$(3) = \\\n \t$$(TSREQ$(1)_T_$(2)_H_$(3)) \\\n \t$$(HBIN$(1)_H_$(3))/fuzzer$$(X) \\\n-\t$$(HBIN$(1)_H_$(3))/cargo$$(X) \\\n+\t$$(HBIN$(1)_H_$(3))/rustpkg$$(X) \\\n \t$$(HBIN$(1)_H_$(3))/rustdoc$$(X) \\\n \t$$(HBIN$(1)_H_$(3))/rusti$$(X) \\\n \t$$(HLIB$(1)_H_$(3))/$$(CFG_LIBFUZZER) \\\n-\t$$(HLIB$(1)_H_$(3))/$$(CFG_LIBCARGO) \\\n+\t$$(HLIB$(1)_H_$(3))/$$(CFG_LIBRUSTPKG) \\\n \t$$(HLIB$(1)_H_$(3))/$$(CFG_LIBRUSTDOC) \\\n \t$$(HLIB$(1)_H_$(3))/$$(CFG_LIBRUSTI) \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_CORELIB) \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_STDLIB)  \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBSYNTAX)  \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBRUSTC) \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBFUZZER) \\\n-\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBCARGO) \\\n+\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBRUSTPKG) \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBRUSTDOC) \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBRUSTI)\n "}, {"sha": "a34f8814f020d15a555f4cbfe4a9f7dc5bd2244b", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/354da4108a483ece3b6424ea7d92e3b6e91d4239/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/354da4108a483ece3b6424ea7d92e3b6e91d4239/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=354da4108a483ece3b6424ea7d92e3b6e91d4239", "patch": "@@ -56,7 +56,7 @@ for more information on them.\n \n When complete, `make install` will place several programs into\n `/usr/local/bin`: `rustc`, the Rust compiler; `rustdoc`, the\n-API-documentation tool, and `cargo`, the Rust package manager.\n+API-documentation tool, and `rustpkg`, the Rust package manager and build system.\n \n [wiki-start]: https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust\n [tarball]: http://static.rust-lang.org/dist/rust-0.5.tar.gz"}, {"sha": "3b35071c818e9390ffdfcf855a6fdfc84923f6d7", "filename": "mk/clean.mk", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/354da4108a483ece3b6424ea7d92e3b6e91d4239/mk%2Fclean.mk", "raw_url": "https://github.com/rust-lang/rust/raw/354da4108a483ece3b6424ea7d92e3b6e91d4239/mk%2Fclean.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fclean.mk?ref=354da4108a483ece3b6424ea7d92e3b6e91d4239", "patch": "@@ -64,12 +64,12 @@ define CLEAN_HOST_STAGE_N\n clean$(1)_H_$(2):\n \t$(Q)rm -f $$(HBIN$(1)_H_$(2))/rustc$(X)\n \t$(Q)rm -f $$(HBIN$(1)_H_$(2))/fuzzer$(X)\n-\t$(Q)rm -f $$(HBIN$(1)_H_$(2))/cargo$(X)\n+\t$(Q)rm -f $$(HBIN$(1)_H_$(2))/rustpkg$(X)\n \t$(Q)rm -f $$(HBIN$(1)_H_$(2))/serializer$(X)\n \t$(Q)rm -f $$(HBIN$(1)_H_$(2))/rustdoc$(X)\n \t$(Q)rm -f $$(HBIN$(1)_H_$(2))/rusti$(X)\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_LIBFUZZER)\n-\t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_LIBCARGO)\n+\t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_LIBRUSTPKG)\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_LIBRUSTDOC)\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_RUNTIME)\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_CORELIB)\n@@ -82,7 +82,7 @@ clean$(1)_H_$(2):\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBRUSTC_GLOB)\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBSYNTAX_GLOB)\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBFUZZER_GLOB)\n-\t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBCARGO_GLOB)\n+\t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBRUSTPKG_GLOB)\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBRUSTDOC_GLOB)\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBRUSTI_GLOB)\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_RUSTLLVM)\n@@ -99,11 +99,11 @@ define CLEAN_TARGET_STAGE_N\n clean$(1)_T_$(2)_H_$(3):\n \t$(Q)rm -f $$(TBIN$(1)_T_$(2)_H_$(3))/rustc$(X)\n \t$(Q)rm -f $$(TBIN$(1)_T_$(2)_H_$(3))/fuzzer$(X)\n-\t$(Q)rm -f $$(TBIN$(1)_T_$(2)_H_$(3))/cargo$(X)\n+\t$(Q)rm -f $$(TBIN$(1)_T_$(2)_H_$(3))/rustpkg$(X)\n \t$(Q)rm -f $$(TBIN$(1)_T_$(2)_H_$(3))/serializer$(X)\n \t$(Q)rm -f $$(TBIN$(1)_T_$(2)_H_$(3))/rustdoc$(X)\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBFUZZER)\n-\t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBCARGO)\n+\t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTPKG)\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTDOC)\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_RUNTIME)\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_CORELIB)\n@@ -115,7 +115,7 @@ clean$(1)_T_$(2)_H_$(3):\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBRUSTC_GLOB)\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBSYNTAX_GLOB)\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBFUZZER_GLOB)\n-\t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBCARGO_GLOB)\n+\t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBRUSTPKG_GLOB)\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBRUSTDOC_GLOB)\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_RUSTLLVM)\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/libstd.rlib"}, {"sha": "5b6740461e6e5847cd2f7af79494b6e11eeb3e9a", "filename": "mk/dist.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/354da4108a483ece3b6424ea7d92e3b6e91d4239/mk%2Fdist.mk", "raw_url": "https://github.com/rust-lang/rust/raw/354da4108a483ece3b6424ea7d92e3b6e91d4239/mk%2Fdist.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdist.mk?ref=354da4108a483ece3b6424ea7d92e3b6e91d4239", "patch": "@@ -25,7 +25,7 @@ PKG_FILES := \\\n     $(addprefix $(S)src/,                      \\\n       README.txt                               \\\n       driver                                   \\\n-      libcargo                                 \\\n+      librustpkg                               \\\n       librusti                                 \\\n       librustc                                 \\\n       compiletest                              \\"}, {"sha": "7f3ec816e02066dd966c54d8a556ce7d3f1451eb", "filename": "mk/install.mk", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/354da4108a483ece3b6424ea7d92e3b6e91d4239/mk%2Finstall.mk", "raw_url": "https://github.com/rust-lang/rust/raw/354da4108a483ece3b6424ea7d92e3b6e91d4239/mk%2Finstall.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Finstall.mk?ref=354da4108a483ece3b6424ea7d92e3b6e91d4239", "patch": "@@ -55,7 +55,7 @@ install-target-$(1)-host-$(2): $$(CSREQ$$(ISTAGE)_T_$(1)_H_$(2))\n \t$$(Q)$$(call INSTALL_LIB, \\\n \t\t$$(TL$(1)$(2)),$$(PTL$(1)$(2)),$$(LIBSYNTAX_GLOB))\n \t$$(Q)$$(call INSTALL_LIB, \\\n-\t\t$$(TL$(1)$(2)),$$(PTL$(1)$(2)),$$(LIBCARGO_GLOB))\n+\t\t$$(TL$(1)$(2)),$$(PTL$(1)$(2)),$$(LIBRUSTPKG_GLOB))\n \t$$(Q)$$(call INSTALL_LIB, \\\n \t\t$$(TL$(1)$(2)),$$(PTL$(1)$(2)),$$(LIBRUSTDOC_GLOB))\n \t$$(Q)$$(call INSTALL_LIB, \\\n@@ -87,11 +87,11 @@ install-host: $(CSREQ$(ISTAGE)_T_$(CFG_HOST_TRIPLE)_H_$(CFG_HOST_TRIPLE))\n \t$(Q)mkdir -p $(PREFIX_LIB)\n \t$(Q)mkdir -p $(PREFIX_ROOT)/share/man/man1\n \t$(Q)$(call INSTALL,$(HB2),$(PHB),rustc$(X))\n-\t$(Q)$(call INSTALL,$(HB2),$(PHB),cargo$(X))\n+\t$(Q)$(call INSTALL,$(HB2),$(PHB),rustpkg$(X))\n \t$(Q)$(call INSTALL,$(HB2),$(PHB),rustdoc$(X))\n \t$(Q)$(call INSTALL,$(HB2),$(PHB),rusti$(X))\n \t$(Q)$(call INSTALL,$(HL),$(PHL),$(CFG_LIBRUSTC))\n-\t$(Q)$(call INSTALL,$(HL),$(PHL),$(CFG_LIBCARGO))\n+\t$(Q)$(call INSTALL,$(HL),$(PHL),$(CFG_LIBRUSTPKG))\n \t$(Q)$(call INSTALL,$(HL),$(PHL),$(CFG_LIBRUSTDOC))\n \t$(Q)$(call INSTALL,$(HL),$(PHL),$(CFG_LIBRUSTI))\n \t$(Q)$(call INSTALL_LIB,$(HL),$(PHL),$(CORELIB_GLOB))\n@@ -112,11 +112,11 @@ HOST_LIB_FROM_HL_GLOB = \\\n \n uninstall:\n \t$(Q)rm -f $(PHB)/rustc$(X)\n-\t$(Q)rm -f $(PHB)/cargo$(X)\n+\t$(Q)rm -f $(PHB)/rustpkg$(X)\n \t$(Q)rm -f $(PHB)/rusti$(X)\n \t$(Q)rm -f $(PHB)/rustdoc$(X)\n \t$(Q)rm -f $(PHL)/$(CFG_RUSTLLVM)\n-\t$(Q)rm -f $(PHL)/$(CFG_LIBCARGO)\n+\t$(Q)rm -f $(PHL)/$(CFG_LIBRUSTPKG)\n \t$(Q)rm -f $(PHL)/$(CFG_LIBRUSTC)\n \t$(Q)rm -f $(PHL)/$(CFG_LIBRUSTDOC)\n \t$(Q)rm -f $(PHL)/$(CFG_LIBRUSTI)\n@@ -126,7 +126,7 @@ uninstall:\n           $(call HOST_LIB_FROM_HL_GLOB,$(STDLIB_GLOB)) \\\n           $(call HOST_LIB_FROM_HL_GLOB,$(LIBRUSTC_GLOB)) \\\n           $(call HOST_LIB_FROM_HL_GLOB,$(LIBSYNTAX_GLOB)) \\\n-          $(call HOST_LIB_FROM_HL_GLOB,$(LIBCARGO_GLOB)) \\\n+          $(call HOST_LIB_FROM_HL_GLOB,$(LIBRUSTPKG_GLOB)) \\\n           $(call HOST_LIB_FROM_HL_GLOB,$(LIBRUSTDOC_GLOB)) \\\n           $(call HOST_LIB_FROM_HL_GLOB,$(LIBRUSTI_GLOB)) \\\n         ; \\"}, {"sha": "772365b1058194fd2f3bb062ec712eacafc55c61", "filename": "mk/pp.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/354da4108a483ece3b6424ea7d92e3b6e91d4239/mk%2Fpp.mk", "raw_url": "https://github.com/rust-lang/rust/raw/354da4108a483ece3b6424ea7d92e3b6e91d4239/mk%2Fpp.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fpp.mk?ref=354da4108a483ece3b6424ea7d92e3b6e91d4239", "patch": "@@ -18,7 +18,7 @@ else\n               $(wildcard $(S)src/test/*/*.rs    \\\n                          $(S)src/test/*/*/*.rs) \\\n               $(wildcard $(S)src/fuzzer/*.rs)   \\\n-              $(wildcard $(S)src/cargo/*.rs) \\\n+              $(wildcard $(S)src/rustpkg/*.rs) \\\n               $(wildcard $(S)src/rusti/*.rs)\n \n   PP_INPUTS_FILTERED = $(shell echo $(PP_INPUTS) | xargs grep -L \\"}, {"sha": "8bcf5d5ad10ca7de5e8f290c5ba94909c78f801d", "filename": "mk/tests.mk", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/354da4108a483ece3b6424ea7d92e3b6e91d4239/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/354da4108a483ece3b6424ea7d92e3b6e91d4239/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=354da4108a483ece3b6424ea7d92e3b6e91d4239", "patch": "@@ -14,7 +14,7 @@\n ######################################################################\n \n # The names of crates that must be tested\n-TEST_CRATES = core std syntax rustc rustdoc rusti cargo\n+TEST_CRATES = core std syntax rustc rustdoc rusti rustpkg\n \n # Markdown files under doc/ that should have their code extracted and run\n DOC_TEST_NAMES = tutorial tutorial-ffi tutorial-macros tutorial-borrowed-ptr tutorial-tasks rust\n@@ -229,8 +229,8 @@ $(3)/test/rustctest.stage$(1)-$(2)$$(X):\t\t\t\t\t\\\n \t@$$(call E, compile_and_link: $$@)\n \t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< --test\n \n-$(3)/test/cargotest.stage$(1)-$(2)$$(X):\t\t\t\t\t\\\n-\t\t$$(CARGO_LIB) $$(CARGO_INPUTS)\t\t\\\n+$(3)/test/rustpkgtest.stage$(1)-$(2)$$(X):\t\t\t\t\t\\\n+\t\t$$(RUSTPKG_LIB) $$(RUSTPKG_INPUTS)\t\t\\\n \t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBRUSTC)\n \t@$$(call E, compile_and_link: $$@)\n \t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< --test"}, {"sha": "1554d760a49cc897e6c33d7adfbbd13c0e59d147", "filename": "mk/tools.mk", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/354da4108a483ece3b6424ea7d92e3b6e91d4239/mk%2Ftools.mk", "raw_url": "https://github.com/rust-lang/rust/raw/354da4108a483ece3b6424ea7d92e3b6e91d4239/mk%2Ftools.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftools.mk?ref=354da4108a483ece3b6424ea7d92e3b6e91d4239", "patch": "@@ -14,13 +14,13 @@\n FUZZER_LIB := $(S)src/libfuzzer/fuzzer.rc\n FUZZER_INPUTS := $(wildcard $(addprefix $(S)src/libfuzzer/, *.rs))\n \n-# The test runner that runs the cfail/rfail/rpass and bench tests\n+# The test runner that runs the cfail/rfail/rpass and bxench tests\n COMPILETEST_CRATE := $(S)src/compiletest/compiletest.rc\n COMPILETEST_INPUTS := $(wildcard $(S)src/compiletest/*rs)\n \n-# Cargo, the package manager\n-CARGO_LIB := $(S)src/libcargo/cargo.rc\n-CARGO_INPUTS := $(wildcard $(S)src/libcargo/*rs)\n+# Rustpkg, the package manager and build system\n+RUSTPKG_LIB := $(S)src/librustpkg/rustpkg.rc\n+RUSTPKG_INPUTS := $(wildcard $(S)src/librustpkg/*rs)\n \n # Rustdoc, the documentation tool\n RUSTDOC_LIB := $(S)src/librustdoc/rustdoc.rc\n@@ -57,20 +57,20 @@ $$(TBIN$(1)_T_$(4)_H_$(3))/compiletest$$(X):\t\t\t\\\n \t@$$(call E, compile_and_link: $$@)\n \t$$(STAGE$(1)_T_$(4)_H_$(3)) -o $$@ $$<\n \n-$$(TLIB$(1)_T_$(4)_H_$(3))/$$(CFG_LIBCARGO):\t\t\\\n-\t\t$$(CARGO_LIB) $$(CARGO_INPUTS)\t\t\t\t\\\n+$$(TLIB$(1)_T_$(4)_H_$(3))/$$(CFG_LIBRUSTPKG):\t\t\\\n+\t\t$$(RUSTPKG_LIB) $$(RUSTPKG_INPUTS)\t\t    \\\n \t\t$$(TSREQ$(1)_T_$(4)_H_$(3))\t\t\t\t\t\\\n \t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$$(CFG_CORELIB)\t\\\n \t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$$(CFG_STDLIB)\t\\\n \t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$$(CFG_LIBRUSTC)\n \t@$$(call E, compile_and_link: $$@)\n \t$$(STAGE$(1)_T_$(4)_H_$(3)) -o $$@ $$< && touch $$@\n \n-$$(TBIN$(1)_T_$(4)_H_$(3))/cargo$$(X):\t\t\t\t\\\n+$$(TBIN$(1)_T_$(4)_H_$(3))/rustpkg$$(X):\t\t\t\t\\\n \t\t$$(DRIVER_CRATE) \t\t\t\t\t\t\t\\\n-\t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$$(CFG_LIBCARGO)\n+\t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$$(CFG_LIBRUSTPKG)\n \t@$$(call E, compile_and_link: $$@)\n-\t$$(STAGE$(1)_T_$(4)_H_$(3)) --cfg cargo -o $$@ $$<\n+\t$$(STAGE$(1)_T_$(4)_H_$(3)) --cfg rustpkg -o $$@ $$<\n \n $$(TLIB$(1)_T_$(4)_H_$(3))/$$(CFG_LIBRUSTDOC):\t\t\\\n \t\t$$(RUSTDOC_LIB) $$(RUSTDOC_INPUTS)\t\t\t\\\n@@ -134,19 +134,19 @@ $$(HBIN$(2)_H_$(4))/compiletest$$(X):\t\t\t\t\\\n \t$$(Q)cp $$< $$@\n \n \n-$$(HLIB$(2)_H_$(4))/$$(CFG_LIBCARGO):\t\t\t\t\\\n-\t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$$(CFG_LIBCARGO)\t\\\n+$$(HLIB$(2)_H_$(4))/$$(CFG_LIBRUSTPKG):\t\t\t\t\\\n+\t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$$(CFG_LIBRUSTPKG)\t\\\n \t\t$$(HLIB$(2)_H_$(4))/$$(CFG_LIBRUSTC)\t\t\\\n \t\t$$(HSREQ$(2)_H_$(4))\n \t@$$(call E, cp: $$@)\n \t$$(Q)cp $$< $$@\n-\t$$(Q)cp -R $$(TLIB$(1)_T_$(4)_H_$(3))/$(LIBCARGO_GLOB) \\\n-\t\t$$(wildcard $$(TLIB$(1)_T_$(4)_H_$(3))/$(LIBCARGO_DSYM_GLOB)) \\\n+\t$$(Q)cp -R $$(TLIB$(1)_T_$(4)_H_$(3))/$(LIBRUSTPKG_GLOB) \\\n+\t\t$$(wildcard $$(TLIB$(1)_T_$(4)_H_$(3))/$(LIBRUSTPKG_DSYM_GLOB)) \\\n \t        $$(HLIB$(2)_H_$(4))\n \n-$$(HBIN$(2)_H_$(4))/cargo$$(X):\t\t\t\t\t\\\n-\t\t$$(TBIN$(1)_T_$(4)_H_$(3))/cargo$$(X)\t\\\n-\t\t$$(HLIB$(2)_H_$(4))/$$(CFG_LIBCARGO)\t\\\n+$$(HBIN$(2)_H_$(4))/rustpkg$$(X):\t\t\t\t\\\n+\t\t$$(TBIN$(1)_T_$(4)_H_$(3))/rustpkg$$(X)\t\\\n+\t\t$$(HLIB$(2)_H_$(4))/$$(CFG_LIBRUSTPKG)\t\\\n \t\t$$(HSREQ$(2)_H_$(4))\n \t@$$(call E, cp: $$@)\n \t$$(Q)cp $$< $$@"}, {"sha": "1b06c4259fc6f0649b47ec8aa54dc3082d55d791", "filename": "src/README.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/354da4108a483ece3b6424ea7d92e3b6e91d4239/src%2FREADME.txt", "raw_url": "https://github.com/rust-lang/rust/raw/354da4108a483ece3b6424ea7d92e3b6e91d4239/src%2FREADME.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FREADME.txt?ref=354da4108a483ece3b6424ea7d92e3b6e91d4239", "patch": "@@ -29,7 +29,7 @@ test/auxiliary     - Dependencies of tests\n \n compiletest/       The test runner\n \n-libcargo/          The package manager\n+librustpkg/        The package manager and build system\n \n librusti/          The JIT REPL\n "}, {"sha": "b2c4f69d3029b218635fa68a291843a287380c1b", "filename": "src/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/354da4108a483ece3b6424ea7d92e3b6e91d4239/src%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/354da4108a483ece3b6424ea7d92e3b6e91d4239/src%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fdriver.rs?ref=354da4108a483ece3b6424ea7d92e3b6e91d4239", "patch": "@@ -11,8 +11,8 @@\n #[no_core];\n extern mod core(vers = \"0.6\");\n \n-#[cfg(cargo)]\n-extern mod this(name = \"cargo\", vers = \"0.6\");\n+#[cfg(rustpkg)]\n+extern mod this(name = \"rustpkg\", vers = \"0.6\");\n \n #[cfg(fuzzer)]\n extern mod this(name = \"fuzzer\", vers = \"0.6\");"}, {"sha": "dceeb96800fd19e4cabcc1ab8261ebf7a15d3410", "filename": "src/libcargo/cargo.rc", "status": "removed", "additions": 0, "deletions": 1981, "changes": 1981, "blob_url": "https://github.com/rust-lang/rust/blob/3e97cce27d55bb123fbf8c69f4bb2bd0a3ba9c08/src%2Flibcargo%2Fcargo.rc", "raw_url": "https://github.com/rust-lang/rust/raw/3e97cce27d55bb123fbf8c69f4bb2bd0a3ba9c08/src%2Flibcargo%2Fcargo.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcargo%2Fcargo.rc?ref=3e97cce27d55bb123fbf8c69f4bb2bd0a3ba9c08", "patch": "@@ -1,1981 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-// cargo.rs - Rust package manager\n-\n-// Local Variables:\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-\n-#[link(name = \"cargo\",\n-       vers = \"0.6\",\n-       uuid = \"9ff87a04-8fed-4295-9ff8-f99bb802650b\",\n-       url = \"https://github.com/mozilla/rust/tree/master/src/cargo\")];\n-\n-#[crate_type = \"lib\"];\n-\n-#[no_core];\n-\n-#[legacy_modes];\n-\n-#[allow(vecs_implicitly_copyable,\n-        non_implicitly_copyable_typarams)];\n-#[allow(non_camel_case_types)];\n-#[allow(deprecated_mode)];\n-#[allow(deprecated_pattern)];\n-#[allow(deprecated_self)];\n-\n-extern mod core(vers = \"0.6\");\n-extern mod std(vers = \"0.6\");\n-extern mod rustc(vers = \"0.6\");\n-extern mod syntax(vers = \"0.6\");\n-\n-mod pgp;\n-\n-use rustc::metadata::filesearch::{get_cargo_root, get_cargo_root_nearest};\n-use rustc::metadata::filesearch::{get_cargo_sysroot, libdir};\n-\n-use core::*;\n-\n-use core::dvec::DVec;\n-use core::io::WriterUtil;\n-use core::result::{Ok, Err};\n-use core::hashmap::linear::LinearMap;\n-use std::getopts::{optflag, optopt, opt_present};\n-use std::oldmap::HashMap;\n-use std::{oldmap, json, tempfile, term, sort, getopts};\n-use syntax::codemap::span;\n-use syntax::diagnostic::span_handler;\n-use syntax::diagnostic;\n-use syntax::{ast, codemap, parse, visit, attr};\n-\n-pub struct Package {\n-    name: ~str,\n-    uuid: ~str,\n-    url: ~str,\n-    method: ~str,\n-    description: ~str,\n-    reference: Option<~str>,\n-    tags: ~[~str],\n-    versions: ~[(~str, ~str)]\n-}\n-\n-pub impl cmp::Ord for Package {\n-    pure fn lt(&self, other: &Package) -> bool {\n-        if (*self).name.lt(&(*other).name) { return true; }\n-        if (*other).name.lt(&(*self).name) { return false; }\n-        if (*self).uuid.lt(&(*other).uuid) { return true; }\n-        if (*other).uuid.lt(&(*self).uuid) { return false; }\n-        if (*self).url.lt(&(*other).url) { return true; }\n-        if (*other).url.lt(&(*self).url) { return false; }\n-        if (*self).method.lt(&(*other).method) { return true; }\n-        if (*other).method.lt(&(*self).method) { return false; }\n-        if (*self).description.lt(&(*other).description) { return true; }\n-        if (*other).description.lt(&(*self).description) { return false; }\n-        if (*self).tags.lt(&(*other).tags) { return true; }\n-        if (*other).tags.lt(&(*self).tags) { return false; }\n-        if (*self).versions.lt(&(*other).versions) { return true; }\n-        return false;\n-    }\n-    pure fn le(&self, other: &Package) -> bool { !(*other).lt(&(*self)) }\n-    pure fn ge(&self, other: &Package) -> bool { !(*self).lt(other)     }\n-    pure fn gt(&self, other: &Package) -> bool { (*other).lt(&(*self))  }\n-}\n-\n-pub struct Source {\n-    name: ~str,\n-    mut url: ~str,\n-    mut method: ~str,\n-    mut key: Option<~str>,\n-    mut keyfp: Option<~str>,\n-    packages: DVec<Package>\n-}\n-\n-pub struct Cargo {\n-    pgp: bool,\n-    root: Path,\n-    installdir: Path,\n-    bindir: Path,\n-    libdir: Path,\n-    workdir: Path,\n-    sourcedir: Path,\n-    sources: oldmap::HashMap<~str, @Source>,\n-    mut current_install: ~str,\n-    dep_cache: oldmap::HashMap<~str, bool>,\n-    opts: Options\n-}\n-\n-pub struct Crate {\n-    name: ~str,\n-    vers: ~str,\n-    uuid: ~str,\n-    desc: Option<~str>,\n-    sigs: Option<~str>,\n-    crate_type: Option<~str>,\n-    deps: ~[~str]\n-}\n-\n-pub struct Options {\n-    test: bool,\n-    mode: Mode,\n-    free: ~[~str],\n-    help: bool,\n-}\n-\n-#[deriving_eq]\n-pub enum Mode { SystemMode, UserMode, LocalMode }\n-\n-pub fn opts() -> ~[getopts::Opt] {\n-    ~[optflag(~\"g\"), optflag(~\"G\"), optflag(~\"test\"),\n-     optflag(~\"h\"), optflag(~\"help\")]\n-}\n-\n-pub fn info(msg: ~str) {\n-    let out = io::stdout();\n-\n-    if term::color_supported() {\n-        term::fg(out, term::color_green);\n-        out.write_str(~\"info: \");\n-        term::reset(out);\n-        out.write_line(msg);\n-    } else { out.write_line(~\"info: \" + msg); }\n-}\n-\n-pub fn warn(msg: ~str) {\n-    let out = io::stdout();\n-\n-    if term::color_supported() {\n-        term::fg(out, term::color_yellow);\n-        out.write_str(~\"warning: \");\n-        term::reset(out);\n-        out.write_line(msg);\n-    }else { out.write_line(~\"warning: \" + msg); }\n-}\n-\n-pub fn error(msg: ~str) {\n-    let out = io::stdout();\n-\n-    if term::color_supported() {\n-        term::fg(out, term::color_red);\n-        out.write_str(~\"error: \");\n-        term::reset(out);\n-        out.write_line(msg);\n-    }\n-    else { out.write_line(~\"error: \" + msg); }\n-}\n-\n-pub fn is_uuid(id: ~str) -> bool {\n-    let parts = str::split_str(id, ~\"-\");\n-    if vec::len(parts) == 5u {\n-        let mut correct = 0u;\n-        for vec::eachi(parts) |i, part| {\n-            fn is_hex_digit(+ch: char) -> bool {\n-                ('0' <= ch && ch <= '9') ||\n-                ('a' <= ch && ch <= 'f') ||\n-                ('A' <= ch && ch <= 'F')\n-            }\n-\n-            if !part.all(is_hex_digit) {\n-                return false;\n-            }\n-\n-            match i {\n-                0u => {\n-                    if part.len() == 8u {\n-                        correct += 1u;\n-                    }\n-                }\n-                1u | 2u | 3u => {\n-                    if part.len() == 4u {\n-                        correct += 1u;\n-                    }\n-                }\n-                4u => {\n-                    if part.len() == 12u {\n-                        correct += 1u;\n-                    }\n-                }\n-                _ => { }\n-            }\n-        }\n-        if correct >= 5u {\n-            return true;\n-        }\n-    }\n-    return false;\n-}\n-\n-#[test]\n-pub fn test_is_uuid() {\n-    assert is_uuid(~\"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaafAF09\");\n-    assert !is_uuid(~\"aaaaaaaa-aaaa-aaaa-aaaaa-aaaaaaaaaaaa\");\n-    assert !is_uuid(~\"\");\n-    assert !is_uuid(~\"aaaaaaaa-aaa -aaaa-aaaa-aaaaaaaaaaaa\");\n-    assert !is_uuid(~\"aaaaaaaa-aaa!-aaaa-aaaa-aaaaaaaaaaaa\");\n-    assert !is_uuid(~\"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa-a\");\n-    assert !is_uuid(~\"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaa\u0e1b\");\n-}\n-\n-// FIXME (#2661): implement url/URL parsing so we don't have to resort\n-// to weak checks\n-\n-pub fn has_archive_extension(p: ~str) -> bool {\n-    str::ends_with(p, ~\".tar\") ||\n-    str::ends_with(p, ~\".tar.gz\") ||\n-    str::ends_with(p, ~\".tar.bz2\") ||\n-    str::ends_with(p, ~\".tar.Z\") ||\n-    str::ends_with(p, ~\".tar.lz\") ||\n-    str::ends_with(p, ~\".tar.xz\") ||\n-    str::ends_with(p, ~\".tgz\") ||\n-    str::ends_with(p, ~\".tbz\") ||\n-    str::ends_with(p, ~\".tbz2\") ||\n-    str::ends_with(p, ~\".tb2\") ||\n-    str::ends_with(p, ~\".taz\") ||\n-    str::ends_with(p, ~\".tlz\") ||\n-    str::ends_with(p, ~\".txz\")\n-}\n-\n-pub fn is_archive_path(u: ~str) -> bool {\n-    has_archive_extension(u) && os::path_exists(&Path(u))\n-}\n-\n-pub fn is_archive_url(u: ~str) -> bool {\n-    // FIXME (#2661): this requires the protocol bit - if we had proper\n-    // url parsing, we wouldn't need it\n-\n-    match str::find_str(u, ~\"://\") {\n-        option::Some(_) => has_archive_extension(u),\n-        _ => false\n-    }\n-}\n-\n-pub fn is_git_url(url: ~str) -> bool {\n-    if str::ends_with(url, ~\"/\") { str::ends_with(url, ~\".git/\") }\n-    else {\n-        str::starts_with(url, ~\"git://\") || str::ends_with(url, ~\".git\")\n-    }\n-}\n-\n-pub fn assume_source_method(url: ~str) -> ~str {\n-    if is_git_url(url) {\n-        return ~\"git\";\n-    }\n-    if str::starts_with(url, ~\"file://\") || os::path_exists(&Path(url)) {\n-        return ~\"file\";\n-    }\n-\n-    ~\"curl\"\n-}\n-\n-pub fn load_link(mis: ~[@ast::meta_item]) -> (Option<~str>,\n-                                              Option<~str>,\n-                                              Option<~str>) {\n-    let mut name = None;\n-    let mut vers = None;\n-    let mut uuid = None;\n-    for mis.each |a| {\n-        match a.node {\n-            ast::meta_name_value(v, codemap::spanned { node: ast::lit_str(s),\n-                                                   _ }) => {\n-                match v {\n-                    ~\"name\" => name = Some(*s),\n-                    ~\"vers\" => vers = Some(*s),\n-                    ~\"uuid\" => uuid = Some(*s),\n-                    _ => { }\n-                }\n-            }\n-            _ => fail!(~\"load_link: meta items must be name-values\")\n-        }\n-    }\n-    (name, vers, uuid)\n-}\n-\n-pub fn load_crate(filename: &Path) -> Option<Crate> {\n-    let sess = parse::new_parse_sess(None);\n-    let c = parse::parse_crate_from_file(filename, ~[], sess);\n-\n-    let mut name = None;\n-    let mut vers = None;\n-    let mut uuid = None;\n-    let mut desc = None;\n-    let mut sigs = None;\n-    let mut crate_type = None;\n-\n-    for c.node.attrs.each |a| {\n-        match a.node.value.node {\n-            ast::meta_name_value(v, codemap::spanned { node: ast::lit_str(_),\n-                                                   _ }) => {\n-                match v {\n-                    ~\"desc\" => desc = Some(v),\n-                    ~\"sigs\" => sigs = Some(v),\n-                    ~\"crate_type\" => crate_type = Some(v),\n-                    _ => { }\n-                }\n-            }\n-            ast::meta_list(v, mis) => {\n-                if v == ~\"link\" {\n-                    let (n, v, u) = load_link(mis);\n-                    name = n;\n-                    vers = v;\n-                    uuid = u;\n-                }\n-            }\n-            _ => {\n-                fail!(~\"crate attributes may not contain \" +\n-                     ~\"meta_words\");\n-            }\n-        }\n-    }\n-\n-    struct Env {\n-        mut deps: ~[~str]\n-    }\n-\n-    fn goto_view_item(ps: syntax::parse::parse_sess, e: @Env,\n-                      i: @ast::view_item) {\n-        match i.node {\n-            ast::view_item_use(ident, metas, _) => {\n-                let name_items =\n-                    attr::find_meta_items_by_name(metas, ~\"name\");\n-                let m = if name_items.is_empty() {\n-                    metas + ~[attr::mk_name_value_item_str(\n-                        ~\"name\", *ps.interner.get(ident))]\n-                } else {\n-                    metas\n-                };\n-                let mut attr_name = ident;\n-                let mut attr_vers = ~\"\";\n-                let mut attr_from = ~\"\";\n-\n-              for m.each |item| {\n-                    match attr::get_meta_item_value_str(*item) {\n-                        Some(value) => {\n-                            let name = attr::get_meta_item_name(*item);\n-\n-                            match name {\n-                                ~\"vers\" => attr_vers = value,\n-                                ~\"from\" => attr_from = value,\n-                                _ => ()\n-                            }\n-                        }\n-                        None => ()\n-                    }\n-                }\n-\n-                let query = if !str::is_empty(attr_from) {\n-                    attr_from\n-                } else {\n-                    if !str::is_empty(attr_vers) {\n-                        ps.interner.get(attr_name) + ~\"@\" + attr_vers\n-                    } else { *ps.interner.get(attr_name) }\n-                };\n-\n-                match *ps.interner.get(attr_name) {\n-                    ~\"std\" | ~\"core\" => (),\n-                    _ => e.deps.push(query)\n-                }\n-            }\n-            _ => ()\n-        }\n-    }\n-    fn goto_item(_e: @Env, _i: @ast::item) {\n-    }\n-\n-    let e = @Env {\n-        mut deps: ~[]\n-    };\n-    let v = visit::mk_simple_visitor(@visit::SimpleVisitor {\n-        visit_view_item: |a| goto_view_item(sess, e, a),\n-        visit_item: |a| goto_item(e, a),\n-        .. *visit::default_simple_visitor()\n-    });\n-\n-    visit::visit_crate(*c, (), v);\n-\n-    let deps = copy e.deps;\n-\n-    match (name, vers, uuid) {\n-        (Some(name0), Some(vers0), Some(uuid0)) => {\n-            Some(Crate {\n-                name: name0,\n-                vers: vers0,\n-                uuid: uuid0,\n-                desc: desc,\n-                sigs: sigs,\n-                crate_type: crate_type,\n-                deps: deps })\n-        }\n-        _ => return None\n-    }\n-}\n-\n-pub fn print(s: ~str) {\n-    io::stdout().write_line(s);\n-}\n-\n-pub fn rest(s: ~str, start: uint) -> ~str {\n-    if (start >= str::len(s)) {\n-        ~\"\"\n-    } else {\n-        str::slice(s, start, str::len(s))\n-    }\n-}\n-\n-pub fn need_dir(s: &Path) {\n-    if os::path_is_dir(s) { return; }\n-    if !os::make_dir(s, 493_i32 /* oct: 755 */) {\n-        fail!(fmt!(\"can't make_dir %s\", s.to_str()));\n-    }\n-}\n-\n-pub fn valid_pkg_name(s: &str) -> bool {\n-    fn is_valid_digit(+c: char) -> bool {\n-        ('0' <= c && c <= '9') ||\n-        ('a' <= c && c <= 'z') ||\n-        ('A' <= c && c <= 'Z') ||\n-        c == '-' ||\n-        c == '_'\n-    }\n-\n-    s.all(is_valid_digit)\n-}\n-\n-pub fn parse_source(name: ~str, j: &json::Json) -> @Source {\n-    if !valid_pkg_name(name) {\n-        fail!(fmt!(\"'%s' is an invalid source name\", name));\n-    }\n-\n-    match *j {\n-        json::Object(ref j) => {\n-            let mut url = match j.find(&~\"url\") {\n-                Some(&json::String(u)) => copy u,\n-                _ => fail!(~\"needed 'url' field in source\")\n-            };\n-            let method = match j.find(&~\"method\") {\n-                Some(&json::String(u)) => copy u,\n-                _ => assume_source_method(url)\n-            };\n-            let key = match j.find(&~\"key\") {\n-                Some(&json::String(u)) => Some(copy u),\n-                _ => None\n-            };\n-            let keyfp = match j.find(&~\"keyfp\") {\n-                Some(&json::String(u)) => Some(copy u),\n-                _ => None\n-            };\n-            if method == ~\"file\" {\n-                url = os::make_absolute(&Path(url)).to_str();\n-            }\n-            return @Source {\n-                name: name,\n-                mut url: url,\n-                mut method: method,\n-                mut key: key,\n-                mut keyfp: keyfp,\n-                packages: DVec() };\n-        }\n-        _ => fail!(~\"needed dict value in source\")\n-    };\n-}\n-\n-pub fn try_parse_sources(filename: &Path,\n-                         sources: oldmap::HashMap<~str, @Source>) {\n-    if !os::path_exists(filename)  { return; }\n-    let c = io::read_whole_file_str(filename);\n-    match json::from_str(c.get()) {\n-        Ok(json::Object(j)) => {\n-            for j.each |&(k, v)| {\n-                sources.insert(copy *k, parse_source(*k, v));\n-                debug!(\"source: %s\", *k);\n-            }\n-        }\n-        Ok(_) => fail!(~\"malformed sources.json\"),\n-        Err(e) => fail!(fmt!(\"%s:%s\", filename.to_str(), e.to_str()))\n-    }\n-}\n-\n-pub fn load_one_source_package(src: @Source, p: &json::Object) {\n-    let name = match p.find(&~\"name\") {\n-        Some(&json::String(n)) => {\n-            if !valid_pkg_name(n) {\n-                warn(~\"malformed source json: \"\n-                     + src.name + ~\", '\" + n + ~\"'\"+\n-                     ~\" is an invalid name (alphanumeric, underscores and\" +\n-                     ~\" dashes only)\");\n-                return;\n-            }\n-            n\n-        }\n-        _ => {\n-            warn(~\"malformed source json: \" + src.name + ~\" (missing name)\");\n-            return;\n-        }\n-    };\n-\n-    let uuid = match p.find(&~\"uuid\") {\n-        Some(&json::String(n)) => {\n-            if !is_uuid(n) {\n-                warn(~\"malformed source json: \"\n-                     + src.name + ~\", '\" + n + ~\"'\"+\n-                     ~\" is an invalid uuid\");\n-                return;\n-            }\n-            copy n\n-        }\n-        _ => {\n-            warn(~\"malformed source json: \" + src.name + ~\" (missing uuid)\");\n-            return;\n-        }\n-    };\n-\n-    let url = match p.find(&~\"url\") {\n-        Some(&json::String(n)) => copy n,\n-        _ => {\n-            warn(~\"malformed source json: \" + src.name + ~\" (missing url)\");\n-            return;\n-        }\n-    };\n-\n-    let method = match p.find(&~\"method\") {\n-        Some(&json::String(n)) => copy n,\n-        _ => {\n-            warn(~\"malformed source json: \"\n-                 + src.name + ~\" (missing method)\");\n-            return;\n-        }\n-    };\n-\n-    let reference = match p.find(&~\"ref\") {\n-        Some(&json::String(n)) => Some(copy n),\n-        _ => None\n-    };\n-\n-    let mut tags = ~[];\n-    match p.find(&~\"tags\") {\n-        Some(&json::List(ref js)) => {\n-          for js.each |j| {\n-                match *j {\n-                    json::String(ref j) => tags.grow(1u, j),\n-                    _ => ()\n-                }\n-            }\n-        }\n-        _ => ()\n-    }\n-\n-    let description = match p.find(&~\"description\") {\n-        Some(&json::String(n)) => copy n,\n-        _ => {\n-            warn(~\"malformed source json: \" + src.name\n-                 + ~\" (missing description)\");\n-            return;\n-        }\n-    };\n-\n-    let newpkg = Package {\n-        name: name,\n-        uuid: uuid,\n-        url: url,\n-        method: method,\n-        description: description,\n-        reference: reference,\n-        tags: tags,\n-        versions: ~[]\n-    };\n-\n-    match src.packages.position(|pkg| pkg.uuid == uuid) {\n-        Some(idx) => {\n-            src.packages.set_elt(idx, newpkg);\n-            log(debug, ~\"  updated package: \" + src.name + ~\"/\" + name);\n-        }\n-        None => {\n-            src.packages.push(newpkg);\n-        }\n-    }\n-\n-    log(debug, ~\"  loaded package: \" + src.name + ~\"/\" + name);\n-}\n-\n-pub fn load_source_info(c: &Cargo, src: @Source) {\n-    let dir = c.sourcedir.push(src.name);\n-    let srcfile = dir.push(\"source.json\");\n-    if !os::path_exists(&srcfile) { return; }\n-    let srcstr = io::read_whole_file_str(&srcfile);\n-    match json::from_str(srcstr.get()) {\n-        Ok(ref json @ json::Object(_)) => {\n-            let o = parse_source(src.name, json);\n-\n-            src.key = o.key;\n-            src.keyfp = o.keyfp;\n-        }\n-        Ok(_) => {\n-            warn(~\"malformed source.json: \" + src.name +\n-                 ~\"(source info is not a dict)\");\n-        }\n-        Err(e) => {\n-            warn(fmt!(\"%s:%s\", src.name, e.to_str()));\n-        }\n-    };\n-}\n-pub fn load_source_packages(c: &Cargo, src: @Source) {\n-    log(debug, ~\"loading source: \" + src.name);\n-    let dir = c.sourcedir.push(src.name);\n-    let pkgfile = dir.push(\"packages.json\");\n-    if !os::path_exists(&pkgfile) { return; }\n-    let pkgstr = io::read_whole_file_str(&pkgfile);\n-    match json::from_str(pkgstr.get()) {\n-        Ok(json::List(ref js)) => {\n-          for js.each |j| {\n-                match *j {\n-                    json::Object(ref p) => {\n-                        load_one_source_package(src, *p);\n-                    }\n-                    _ => {\n-                        warn(~\"malformed source json: \" + src.name +\n-                             ~\" (non-dict pkg)\");\n-                    }\n-                }\n-            }\n-        }\n-        Ok(_) => {\n-            warn(~\"malformed packages.json: \" + src.name +\n-                 ~\"(packages is not a list)\");\n-        }\n-        Err(e) => {\n-            warn(fmt!(\"%s:%s\", src.name, e.to_str()));\n-        }\n-    };\n-}\n-\n-pub fn build_cargo_options(argv: ~[~str]) -> Options {\n-    let matches = &match getopts::getopts(argv, opts()) {\n-        result::Ok(m) => m,\n-        result::Err(f) => {\n-            fail!(fmt!(\"%s\", getopts::fail_str(f)));\n-        }\n-    };\n-\n-    let test = opt_present(matches, ~\"test\");\n-    let G    = opt_present(matches, ~\"G\");\n-    let g    = opt_present(matches, ~\"g\");\n-    let help = opt_present(matches, ~\"h\") || opt_present(matches, ~\"help\");\n-    let len  = vec::len(matches.free);\n-\n-    let is_install = len > 1u && matches.free[1] == ~\"install\";\n-    let is_uninstall = len > 1u && matches.free[1] == ~\"uninstall\";\n-\n-    if G && g { fail!(~\"-G and -g both provided\"); }\n-\n-    if !is_install && !is_uninstall && (g || G) {\n-        fail!(~\"-g and -G are only valid for `install` and `uninstall|rm`\");\n-    }\n-\n-    let mode =\n-        if (!is_install && !is_uninstall) || g { UserMode }\n-        else if G { SystemMode }\n-        else { LocalMode };\n-\n-    Options {test: test, mode: mode, free: matches.free, help: help}\n-}\n-\n-pub fn configure(opts: Options) -> Cargo {\n-    let home = match get_cargo_root() {\n-        Ok(home) => home,\n-        Err(_err) => get_cargo_sysroot().get()\n-    };\n-\n-    let get_cargo_dir = match opts.mode {\n-        SystemMode => get_cargo_sysroot,\n-        UserMode => get_cargo_root,\n-        LocalMode => get_cargo_root_nearest\n-    };\n-\n-    let p = get_cargo_dir().get();\n-\n-    let sources = HashMap();\n-    try_parse_sources(&home.push(\"sources.json\"), sources);\n-    try_parse_sources(&home.push(\"local-sources.json\"), sources);\n-\n-    let dep_cache = HashMap();\n-\n-    let mut c = Cargo {\n-        pgp: pgp::supported(),\n-        root: home,\n-        installdir: p,\n-        bindir: p.push(\"bin\"),\n-        libdir: p.push(\"lib\"),\n-        workdir: p.push(\"work\"),\n-        sourcedir: home.push(\"sources\"),\n-        sources: sources,\n-        mut current_install: ~\"\",\n-        dep_cache: dep_cache,\n-        opts: opts\n-    };\n-\n-    need_dir(&c.root);\n-    need_dir(&c.installdir);\n-    need_dir(&c.sourcedir);\n-    need_dir(&c.workdir);\n-    need_dir(&c.libdir);\n-    need_dir(&c.bindir);\n-\n-    for sources.each_key |&k| {\n-        let mut s = sources.get(&k);\n-        load_source_packages(&c, s);\n-        sources.insert(k, s);\n-    }\n-\n-    if c.pgp {\n-        pgp::init(&c.root);\n-    } else {\n-        warn(~\"command `gpg` was not found\");\n-        warn(~\"you have to install gpg from source \" +\n-             ~\" or package manager to get it to work correctly\");\n-    }\n-\n-    c\n-}\n-\n-pub fn for_each_package(c: &Cargo, b: fn(s: @Source, p: &Package)) {\n-    for c.sources.each_value |&v| {\n-        for v.packages.each |p| {\n-            b(v, p);\n-        }\n-    }\n-}\n-\n-// Runs all programs in directory <buildpath>\n-pub fn run_programs(buildpath: &Path) {\n-    let newv = os::list_dir_path(buildpath);\n-    for newv.each |ct| {\n-        run::run_program(ct.to_str(), ~[]);\n-    }\n-}\n-\n-// Runs rustc in <path + subdir> with the given flags\n-// and returns <patho + subdir>\n-pub fn run_in_buildpath(what: &str, path: &Path, subdir: &Path, cf: &Path,\n-                        extra_flags: ~[~str]) -> Option<Path> {\n-    let buildpath = path.push_rel(subdir);\n-    need_dir(&buildpath);\n-    debug!(\"%s: %s -> %s\", what, cf.to_str(), buildpath.to_str());\n-    let p = run::program_output(rustc_sysroot(),\n-                                ~[~\"--out-dir\",\n-                                  buildpath.to_str(),\n-                                  cf.to_str()] + extra_flags);\n-    if p.status != 0 {\n-        error(fmt!(\"rustc failed: %d\\n%s\\n%s\", p.status, p.err, p.out));\n-        return None;\n-    }\n-    Some(buildpath)\n-}\n-\n-pub fn test_one_crate(_c: &Cargo, path: &Path, cf: &Path) {\n-    let buildpath = match run_in_buildpath(~\"testing\", path,\n-                                           &Path(\"test\"),\n-                                           cf,\n-                                           ~[ ~\"--test\"]) {\n-      None => return,\n-    Some(bp) => bp\n-  };\n-  run_programs(&buildpath);\n-}\n-\n-pub fn install_one_crate(c: &Cargo, path: &Path, cf: &Path) {\n-    let buildpath = match run_in_buildpath(~\"installing\", path,\n-                                           &Path(\"build\"),\n-                                           cf, ~[]) {\n-      None => return,\n-      Some(bp) => bp\n-    };\n-    let newv = os::list_dir_path(&buildpath);\n-    let exec_suffix = str::from_slice(os::EXE_SUFFIX);\n-    for newv.each |ct| {\n-        if (exec_suffix != ~\"\" && str::ends_with(ct.to_str(),\n-                                                 exec_suffix)) ||\n-            (exec_suffix == ~\"\" &&\n-             !str::starts_with(ct.filename().get(),\n-                               ~\"lib\")) {\n-            debug!(\"  bin: %s\", ct.to_str());\n-            install_to_dir(*ct, &c.bindir);\n-            if c.opts.mode == SystemMode {\n-                // FIXME (#2662): Put this file in PATH / symlink it so it can\n-                // be used as a generic executable\n-                // `cargo install -G rustray` and `rustray file.obj`\n-            }\n-        } else {\n-            debug!(\"  lib: %s\", ct.to_str());\n-            install_to_dir(*ct, &c.libdir);\n-        }\n-    }\n-}\n-\n-\n-pub fn rustc_sysroot() -> ~str {\n-    match os::self_exe_path() {\n-        Some(path) => {\n-            let rustc = path.push_many([~\"..\", ~\"bin\", ~\"rustc\"]);\n-            debug!(\"  rustc: %s\", rustc.to_str());\n-            rustc.to_str()\n-        }\n-        None => ~\"rustc\"\n-    }\n-}\n-\n-pub fn install_source(c: &mut Cargo, path: &Path) {\n-    debug!(\"source: %s\", path.to_str());\n-    os::change_dir(path);\n-\n-    let mut cratefiles = ~[];\n-    for os::walk_dir(&Path(\".\")) |p| {\n-        if p.filetype() == Some(~\".rc\") {\n-            cratefiles.push(*p);\n-        }\n-    }\n-\n-    if vec::is_empty(cratefiles) {\n-        fail!(~\"this doesn't look like a rust package (no .rc files)\");\n-    }\n-\n-    for cratefiles.each |cf| {\n-        match load_crate(cf) {\n-            None => loop,\n-            Some(crate) => {\n-              for crate.deps.each |query| {\n-                    // FIXME (#1356): handle cyclic dependencies\n-                    // (n.b. #1356 says \"Cyclic dependency is an error\n-                    // condition\")\n-\n-                    let wd = get_temp_workdir(c);\n-                    install_query(c, &wd, *query);\n-                }\n-\n-                os::change_dir(path);\n-\n-                if c.opts.test {\n-                    test_one_crate(c, path, cf);\n-                }\n-                install_one_crate(c, path, cf);\n-            }\n-        }\n-    }\n-}\n-\n-pub fn install_git(c: &mut Cargo, wd: &Path, url: ~str,\n-                   reference: Option<~str>) {\n-    run::program_output(~\"git\", ~[~\"clone\", url, wd.to_str()]);\n-    if reference.is_some() {\n-        let r = reference.get();\n-        os::change_dir(wd);\n-        run::run_program(~\"git\", ~[~\"checkout\", r]);\n-    }\n-\n-    install_source(c, wd);\n-}\n-\n-pub fn install_curl(c: &mut Cargo, wd: &Path, url: ~str) {\n-    let tarpath = wd.push(\"pkg.tar\");\n-    let p = run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\", ~\"-o\",\n-                                         tarpath.to_str(), url]);\n-    if p.status != 0 {\n-        fail!(fmt!(\"fetch of %s failed: %s\", url, p.err));\n-    }\n-    run::run_program(~\"tar\", ~[~\"-x\", ~\"--strip-components=1\",\n-                               ~\"-C\", wd.to_str(),\n-                               ~\"-f\", tarpath.to_str()]);\n-    install_source(c, wd);\n-}\n-\n-pub fn install_file(c: &mut Cargo, wd: &Path, path: &Path) {\n-    run::program_output(~\"tar\", ~[~\"-x\", ~\"--strip-components=1\",\n-                                  ~\"-C\", wd.to_str(),\n-                                  ~\"-f\", path.to_str()]);\n-    install_source(c, wd);\n-}\n-\n-pub fn install_package(c: &mut Cargo, src: ~str, wd: &Path, pkg: Package) {\n-    let url = copy pkg.url;\n-    let method = match pkg.method {\n-        ~\"git\" => ~\"git\",\n-        ~\"file\" => ~\"file\",\n-        _ => ~\"curl\"\n-    };\n-\n-    info(fmt!(\"installing %s/%s via %s...\", src, pkg.name, method));\n-\n-    match method {\n-        ~\"git\" => install_git(c, wd, url, copy pkg.reference),\n-        ~\"file\" => install_file(c, wd, &Path(url)),\n-        ~\"curl\" => install_curl(c, wd, url),\n-        _ => ()\n-    }\n-}\n-\n-pub fn cargo_suggestion(c: &Cargo, fallback: fn()) {\n-    if c.sources.is_empty() {\n-        error(~\"no sources defined - you may wish to run \" +\n-              ~\"`cargo init`\");\n-        return;\n-    }\n-    fallback();\n-}\n-\n-pub fn install_uuid(c: &mut Cargo, wd: &Path, uuid: ~str) {\n-    let mut ps = ~[];\n-    for_each_package(c, |s, p| {\n-        if p.uuid == uuid {\n-            vec::push(&mut ps, (s.name, copy *p));\n-        }\n-    });\n-    if vec::len(ps) == 1u {\n-        let (sname, p) = copy ps[0];\n-        install_package(c, sname, wd, p);\n-        return;\n-    } else if vec::len(ps) == 0u {\n-        cargo_suggestion(c, || {\n-            error(~\"can't find package: \" + uuid);\n-        });\n-        return;\n-    }\n-    error(~\"found multiple packages:\");\n-    for ps.each |elt| {\n-        let (sname,p) = copy *elt;\n-        info(~\"  \" + sname + ~\"/\" + p.uuid + ~\" (\" + p.name + ~\")\");\n-    }\n-}\n-\n-pub fn install_named(c: &mut Cargo, wd: &Path, name: ~str) {\n-    let mut ps = ~[];\n-    for_each_package(c, |s, p| {\n-        if p.name == name {\n-            vec::push(&mut ps, (s.name, copy *p));\n-        }\n-    });\n-    if vec::len(ps) == 1u {\n-        let (sname, p) = copy ps[0];\n-        install_package(c, sname, wd, p);\n-        return;\n-    } else if vec::len(ps) == 0u {\n-        cargo_suggestion(c, || {\n-            error(~\"can't find package: \" + name);\n-        });\n-        return;\n-    }\n-    error(~\"found multiple packages:\");\n-    for ps.each |elt| {\n-        let (sname,p) = copy *elt;\n-        info(~\"  \" + sname + ~\"/\" + p.uuid + ~\" (\" + p.name + ~\")\");\n-    }\n-}\n-\n-pub fn install_uuid_specific(c: &mut Cargo, wd: &Path, src: ~str,\n-                             uuid: ~str) {\n-    match c.sources.find(&src) {\n-        Some(s) => {\n-            for s.packages.each |p| {\n-                if p.uuid == uuid {\n-                    install_package(c, src, wd, *p);\n-                    return;\n-                }\n-            }\n-        }\n-        _ => ()\n-    }\n-    error(~\"can't find package: \" + src + ~\"/\" + uuid);\n-}\n-\n-pub fn install_named_specific(c: &mut Cargo, wd: &Path, src: ~str,\n-                              name: ~str) {\n-    match c.sources.find(&src) {\n-        Some(s) => {\n-            for s.packages.each |p| {\n-                if p.name == name {\n-                    install_package(c, src, wd, *p);\n-                    return;\n-                }\n-            }\n-        }\n-        _ => ()\n-    }\n-    error(~\"can't find package: \" + src + ~\"/\" + name);\n-}\n-\n-pub fn cmd_uninstall(c: &Cargo) {\n-    if vec::len(c.opts.free) < 3u {\n-        cmd_usage();\n-        return;\n-    }\n-\n-    let lib = &c.libdir;\n-    let bin = &c.bindir;\n-    let target = c.opts.free[2u];\n-\n-    // FIXME (#2662): needs stronger pattern matching\n-    // FIXME (#2662): needs to uninstall from a specified location in a\n-    // cache instead of looking for it (binaries can be uninstalled by\n-    // name only)\n-\n-    fn try_uninstall(p: &Path) -> bool {\n-        if os::remove_file(p) {\n-            info(~\"uninstalled: '\" + p.to_str() + ~\"'\");\n-            true\n-        } else {\n-            error(~\"could not uninstall: '\" +\n-                  p.to_str() + ~\"'\");\n-            false\n-        }\n-    }\n-\n-    if is_uuid(target) {\n-        for os::list_dir(lib).each |file| {\n-            match str::find_str(*file, ~\"-\" + target + ~\"-\") {\n-              Some(_) => if !try_uninstall(&lib.push(*file)) { return },\n-              None => ()\n-            }\n-        }\n-        error(~\"can't find package with uuid: \" + target);\n-    } else {\n-        for os::list_dir(lib).each |file| {\n-            match str::find_str(*file, ~\"lib\" + target + ~\"-\") {\n-              Some(_) => if !try_uninstall(&lib.push(*file)) { return },\n-              None => ()\n-            }\n-        }\n-        for os::list_dir(bin).each |file| {\n-            match str::find_str(*file, target) {\n-              Some(_) => if !try_uninstall(&lib.push(*file)) { return },\n-              None => ()\n-            }\n-        }\n-\n-        error(~\"can't find package with name: \" + target);\n-    }\n-}\n-\n-pub fn install_query(c: &mut Cargo, wd: &Path, target: ~str) {\n-    match c.dep_cache.find(&target) {\n-        Some(inst) => {\n-            if inst {\n-                return;\n-            }\n-        }\n-        None => ()\n-    }\n-\n-    c.dep_cache.insert(target, true);\n-\n-    if is_archive_path(target) {\n-        install_file(c, wd, &Path(target));\n-        return;\n-    } else if is_git_url(target) {\n-        let reference = if c.opts.free.len() >= 4u {\n-            Some(c.opts.free[3u])\n-        } else {\n-            None\n-        };\n-        install_git(c, wd, target, reference);\n-    } else if !valid_pkg_name(target) && has_archive_extension(target) {\n-        install_curl(c, wd, target);\n-        return;\n-    } else {\n-        let mut ps = copy target;\n-\n-        match str::find_char(ps, '/') {\n-            option::Some(idx) => {\n-                let source = str::slice(ps, 0u, idx);\n-                ps = str::slice(ps, idx + 1u, str::len(ps));\n-                if is_uuid(ps) {\n-                    install_uuid_specific(c, wd, source, ps);\n-                } else {\n-                    install_named_specific(c, wd, source, ps);\n-                }\n-            }\n-            option::None => {\n-                if is_uuid(ps) {\n-                    install_uuid(c, wd, ps);\n-                } else {\n-                    install_named(c, wd, ps);\n-                }\n-            }\n-        }\n-    }\n-\n-    // FIXME (#2662): This whole dep_cache and current_install thing is\n-    // a bit of a hack. It should be cleaned up in the future.\n-\n-    if target == c.current_install {\n-        c.dep_cache.clear();\n-        c.current_install = ~\"\";\n-    }\n-}\n-\n-pub fn get_temp_workdir(c: &Cargo) -> Path {\n-    match tempfile::mkdtemp(&c.workdir, \"cargo\") {\n-      Some(wd) => wd,\n-      None => fail!(fmt!(\"needed temp dir: %s\",\n-                        c.workdir.to_str()))\n-    }\n-}\n-\n-pub fn cmd_install(c: &mut Cargo) {\n-    unsafe {\n-        let wd = get_temp_workdir(c);\n-\n-        if vec::len(c.opts.free) == 2u {\n-            let cwd = os::getcwd();\n-            let status = run::run_program(~\"cp\", ~[~\"-R\", cwd.to_str(),\n-                                                   wd.to_str()]);\n-\n-            if status != 0 {\n-                fail!(fmt!(\"could not copy directory: %s\", cwd.to_str()));\n-            }\n-\n-            install_source(c, &wd);\n-            return;\n-        }\n-\n-        sync(c);\n-\n-        let query = c.opts.free[2];\n-        c.current_install = query.to_str();\n-\n-        install_query(c, &wd, query);\n-    }\n-}\n-\n-pub fn sync(c: &Cargo) {\n-    for c.sources.each_key |&k| {\n-        let mut s = c.sources.get(&k);\n-        sync_one(c, s);\n-        c.sources.insert(k, s);\n-    }\n-}\n-\n-pub fn sync_one_file(c: &Cargo, dir: &Path, src: @Source) -> bool {\n-    let name = src.name;\n-    let srcfile = dir.push(\"source.json.new\");\n-    let destsrcfile = dir.push(\"source.json\");\n-    let pkgfile = dir.push(\"packages.json.new\");\n-    let destpkgfile = dir.push(\"packages.json\");\n-    let keyfile = dir.push(\"key.gpg\");\n-    let srcsigfile = dir.push(\"source.json.sig\");\n-    let sigfile = dir.push(\"packages.json.sig\");\n-    let url = Path(src.url);\n-    let mut has_src_file = false;\n-\n-    if !os::copy_file(&url.push(\"packages.json\"), &pkgfile) {\n-        error(fmt!(\"fetch for source %s (url %s) failed\",\n-                   name, url.to_str()));\n-        return false;\n-    }\n-\n-    if os::copy_file(&url.push(\"source.json\"), &srcfile) {\n-        has_src_file = false;\n-    }\n-\n-    os::copy_file(&url.push(\"source.json.sig\"), &srcsigfile);\n-    os::copy_file(&url.push(\"packages.json.sig\"), &sigfile);\n-\n-    match copy src.key {\n-        Some(u) => {\n-            let p = run::program_output(~\"curl\",\n-                                        ~[~\"-f\", ~\"-s\",\n-                                          ~\"-o\", keyfile.to_str(), u]);\n-            if p.status != 0 {\n-                error(fmt!(\"fetch for source %s (key %s) failed\", name, u));\n-                return false;\n-            }\n-            pgp::add(&c.root, &keyfile);\n-        }\n-        _ => ()\n-    }\n-    match (src.key, src.keyfp) {\n-        (Some(_), Some(f)) => {\n-            let r = pgp::verify(&c.root, &pkgfile, &sigfile);\n-\n-            if !r {\n-                error(fmt!(\"signature verification failed for source %s with \\\n-                            key %s\", name, f));\n-                return false;\n-            }\n-\n-            if has_src_file {\n-                let e = pgp::verify(&c.root, &srcfile, &srcsigfile);\n-\n-                if !e {\n-                    error(fmt!(\"signature verification failed for source %s \\\n-                                with key %s\", name, f));\n-                    return false;\n-                }\n-            }\n-        }\n-        _ => ()\n-    }\n-\n-    copy_warn(&pkgfile, &destpkgfile);\n-\n-    if has_src_file {\n-        copy_warn(&srcfile, &destsrcfile);\n-    }\n-\n-    os::remove_file(&keyfile);\n-    os::remove_file(&srcfile);\n-    os::remove_file(&srcsigfile);\n-    os::remove_file(&pkgfile);\n-    os::remove_file(&sigfile);\n-\n-    info(fmt!(\"synced source: %s\", name));\n-\n-    return true;\n-}\n-\n-pub fn sync_one_git(c: &Cargo, dir: &Path, src: @Source) -> bool {\n-    let name = src.name;\n-    let srcfile = dir.push(\"source.json\");\n-    let pkgfile = dir.push(\"packages.json\");\n-    let keyfile = dir.push(\"key.gpg\");\n-    let srcsigfile = dir.push(\"source.json.sig\");\n-    let sigfile = dir.push(\"packages.json.sig\");\n-    let url = src.url;\n-\n-    fn rollback(name: ~str, dir: &Path, insecure: bool) {\n-        fn msg(name: ~str, insecure: bool) {\n-            error(fmt!(\"could not rollback source: %s\", name));\n-\n-            if insecure {\n-                warn(~\"a past security check failed on source \" +\n-                     name + ~\" and rolling back the source failed -\"\n-                     + ~\" this source may be compromised\");\n-            }\n-        }\n-\n-        if !os::change_dir(dir) {\n-            msg(name, insecure);\n-        }\n-        else {\n-            let p = run::program_output(~\"git\", ~[~\"reset\", ~\"--hard\",\n-                                                ~\"HEAD@{1}\"]);\n-\n-            if p.status != 0 {\n-                msg(name, insecure);\n-            }\n-        }\n-    }\n-\n-    if !os::path_exists(&dir.push(\".git\")) {\n-        let p = run::program_output(~\"git\", ~[~\"clone\", url, dir.to_str()]);\n-\n-        if p.status != 0 {\n-            error(fmt!(\"fetch for source %s (url %s) failed\", name, url));\n-            return false;\n-        }\n-    }\n-    else {\n-        if !os::change_dir(dir) {\n-            error(fmt!(\"fetch for source %s (url %s) failed\", name, url));\n-            return false;\n-        }\n-\n-        let p = run::program_output(~\"git\", ~[~\"pull\"]);\n-\n-        if p.status != 0 {\n-            error(fmt!(\"fetch for source %s (url %s) failed\", name, url));\n-            return false;\n-        }\n-    }\n-\n-    let has_src_file = os::path_exists(&srcfile);\n-\n-    match copy src.key {\n-        Some(u) => {\n-            let p = run::program_output(~\"curl\",\n-                                        ~[~\"-f\", ~\"-s\",\n-                                          ~\"-o\", keyfile.to_str(), u]);\n-            if p.status != 0 {\n-                error(fmt!(\"fetch for source %s (key %s) failed\", name, u));\n-                rollback(name, dir, false);\n-                return false;\n-            }\n-            pgp::add(&c.root, &keyfile);\n-        }\n-        _ => ()\n-    }\n-    match (src.key, src.keyfp) {\n-        (Some(_), Some(f)) => {\n-            let r = pgp::verify(&c.root, &pkgfile, &sigfile);\n-\n-            if !r {\n-                error(fmt!(\"signature verification failed for source %s with \\\n-                            key %s\", name, f));\n-                rollback(name, dir, false);\n-                return false;\n-            }\n-\n-            if has_src_file {\n-                let e = pgp::verify(&c.root, &srcfile, &srcsigfile);\n-\n-                if !e {\n-                    error(fmt!(\"signature verification failed for source %s \\\n-                                with key %s\", name, f));\n-                    rollback(name, dir, false);\n-                    return false;\n-                }\n-            }\n-        }\n-        _ => ()\n-    }\n-\n-    os::remove_file(&keyfile);\n-\n-    info(fmt!(\"synced source: %s\", name));\n-\n-    return true;\n-}\n-\n-pub fn sync_one_curl(c: &Cargo, dir: &Path, src: @Source) -> bool {\n-    let name = src.name;\n-    let srcfile = dir.push(\"source.json.new\");\n-    let destsrcfile = dir.push(\"source.json\");\n-    let pkgfile = dir.push(\"packages.json.new\");\n-    let destpkgfile = dir.push(\"packages.json\");\n-    let keyfile = dir.push(\"key.gpg\");\n-    let srcsigfile = dir.push(\"source.json.sig\");\n-    let sigfile = dir.push(\"packages.json.sig\");\n-    let mut url = src.url;\n-    let smart = !str::ends_with(src.url, ~\"packages.json\");\n-    let mut has_src_file = false;\n-\n-    if smart {\n-        url += ~\"/packages.json\";\n-    }\n-\n-    let p = run::program_output(~\"curl\",\n-                                ~[~\"-f\", ~\"-s\",\n-                                  ~\"-o\", pkgfile.to_str(), url]);\n-\n-    if p.status != 0 {\n-        error(fmt!(\"fetch for source %s (url %s) failed\", name, url));\n-        return false;\n-    }\n-    if smart {\n-        url = src.url + ~\"/source.json\";\n-        let p =\n-            run::program_output(~\"curl\",\n-                                ~[~\"-f\", ~\"-s\",\n-                                  ~\"-o\", srcfile.to_str(), url]);\n-\n-        if p.status == 0 {\n-            has_src_file = true;\n-        }\n-    }\n-\n-    match copy src.key {\n-       Some(u) => {\n-            let p = run::program_output(~\"curl\",\n-                                        ~[~\"-f\", ~\"-s\",\n-                                          ~\"-o\", keyfile.to_str(), u]);\n-            if p.status != 0 {\n-                error(fmt!(\"fetch for source %s (key %s) failed\", name, u));\n-                return false;\n-            }\n-            pgp::add(&c.root, &keyfile);\n-        }\n-        _ => ()\n-    }\n-    match (src.key, src.keyfp) {\n-        (Some(_), Some(f)) => {\n-            if smart {\n-                url = src.url + ~\"/packages.json.sig\";\n-            }\n-            else {\n-                url = src.url + ~\".sig\";\n-            }\n-\n-            let mut p = run::program_output(~\"curl\",\n-                                            ~[~\"-f\", ~\"-s\", ~\"-o\",\n-                                              sigfile.to_str(), url]);\n-            if p.status != 0 {\n-                error(fmt!(\"fetch for source %s (sig %s) failed\", name, url));\n-                return false;\n-            }\n-\n-            let r = pgp::verify(&c.root, &pkgfile, &sigfile);\n-\n-            if !r {\n-                error(fmt!(\"signature verification failed for source %s with \\\n-                            key %s\", name, f));\n-                return false;\n-            }\n-\n-            if smart && has_src_file {\n-                url = src.url + ~\"/source.json.sig\";\n-\n-                p = run::program_output(~\"curl\",\n-                                        ~[~\"-f\", ~\"-s\", ~\"-o\",\n-                                          srcsigfile.to_str(), url]);\n-                if p.status != 0 {\n-                    error(fmt!(\"fetch for source %s (sig %s) failed\",\n-                          name, url));\n-                    return false;\n-                }\n-\n-                let e = pgp::verify(&c.root, &srcfile, &srcsigfile);\n-\n-                if !e {\n-                    error(~\"signature verification failed for \" +\n-                          ~\"source \" + name + ~\" with key \" + f);\n-                    return false;\n-                }\n-            }\n-        }\n-        _ => ()\n-    }\n-\n-    copy_warn(&pkgfile, &destpkgfile);\n-\n-    if smart && has_src_file {\n-        copy_warn(&srcfile, &destsrcfile);\n-    }\n-\n-    os::remove_file(&keyfile);\n-    os::remove_file(&srcfile);\n-    os::remove_file(&srcsigfile);\n-    os::remove_file(&pkgfile);\n-    os::remove_file(&sigfile);\n-\n-    info(fmt!(\"synced source: %s\", name));\n-\n-    return true;\n-}\n-\n-pub fn sync_one(c: &Cargo, src: @Source) {\n-    let name = src.name;\n-    let dir = c.sourcedir.push(name);\n-\n-    info(fmt!(\"syncing source: %s...\", name));\n-\n-    need_dir(&dir);\n-\n-    let result = match src.method {\n-        ~\"git\" => sync_one_git(c, &dir, src),\n-        ~\"file\" => sync_one_file(c, &dir, src),\n-        _ => sync_one_curl(c, &dir, src)\n-    };\n-\n-    if result {\n-        load_source_info(c, src);\n-        load_source_packages(c, src);\n-    }\n-}\n-\n-pub fn cmd_init(c: &Cargo) {\n-    let srcurl = ~\"http://www.rust-lang.org/cargo/sources.json\";\n-    let sigurl = ~\"http://www.rust-lang.org/cargo/sources.json.sig\";\n-\n-    let srcfile = c.root.push(\"sources.json.new\");\n-    let sigfile = c.root.push(\"sources.json.sig\");\n-    let destsrcfile = c.root.push(\"sources.json\");\n-\n-    let p =\n-        run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\",\n-                                       ~\"-o\", srcfile.to_str(), srcurl]);\n-    if p.status != 0 {\n-        error(fmt!(\"fetch of sources.json failed: %s\", p.out));\n-        return;\n-    }\n-\n-    let p =\n-        run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\",\n-                                       ~\"-o\", sigfile.to_str(), sigurl]);\n-    if p.status != 0 {\n-        error(fmt!(\"fetch of sources.json.sig failed: %s\", p.out));\n-        return;\n-    }\n-\n-    let r = pgp::verify(&c.root, &srcfile, &sigfile);\n-    if !r {\n-        error(fmt!(\"signature verification failed for '%s'\",\n-                   srcfile.to_str()));\n-        return;\n-    }\n-\n-    copy_warn(&srcfile, &destsrcfile);\n-    os::remove_file(&srcfile);\n-    os::remove_file(&sigfile);\n-\n-    info(fmt!(\"initialized .cargo in %s\", c.root.to_str()));\n-}\n-\n-pub fn print_pkg(s: @Source, p: &Package) {\n-    let mut m = s.name + ~\"/\" + p.name + ~\" (\" + p.uuid + ~\")\";\n-    if vec::len(p.tags) > 0u {\n-        m = m + ~\" [\" + str::connect(p.tags, ~\", \") + ~\"]\";\n-    }\n-    info(m);\n-    if p.description != ~\"\" {\n-        print(~\"   >> \" + p.description + ~\"\\n\")\n-    }\n-}\n-\n-pub fn print_source(s: @Source) {\n-    info(s.name + ~\" (\" + s.url + ~\")\");\n-\n-    let pks = sort::merge_sort(s.packages.get(), sys::shape_lt);\n-    let l = vec::len(pks);\n-\n-    print(io::with_str_writer(|writer| {\n-        let mut list = ~\"   >> \";\n-\n-        for vec::eachi(pks) |i, pk| {\n-            if str::len(list) > 78u {\n-                writer.write_line(list);\n-                list = ~\"   >> \";\n-            }\n-            list += pk.name + (if l - 1u == i { ~\"\" } else { ~\", \" });\n-        }\n-\n-        writer.write_line(list);\n-    }));\n-}\n-\n-pub fn cmd_list(c: &Cargo) {\n-    sync(c);\n-\n-    if vec::len(c.opts.free) >= 3u {\n-        let v = vec::slice(c.opts.free, 2u, vec::len(c.opts.free));\n-        for vec::each(v) |name| {\n-            if !valid_pkg_name(*name) {\n-                error(fmt!(\"'%s' is an invalid source name\", *name));\n-            } else {\n-                match c.sources.find(name) {\n-                    Some(source) => {\n-                        print_source(source);\n-                    }\n-                    None => {\n-                        error(fmt!(\"no such source: %s\", *name));\n-                    }\n-                }\n-            }\n-        }\n-    } else {\n-        for c.sources.each_value |&v| {\n-            print_source(v);\n-        }\n-    }\n-}\n-\n-pub fn cmd_search(c: &Cargo) {\n-    if vec::len(c.opts.free) < 3u {\n-        cmd_usage();\n-        return;\n-    }\n-\n-    sync(c);\n-\n-    let mut n = 0;\n-    let name = c.opts.free[2];\n-    let tags = vec::slice(c.opts.free, 3u, vec::len(c.opts.free));\n-    for_each_package(c, |s, p| {\n-        if (str::contains(p.name, name) || name == ~\"*\") &&\n-            vec::all(tags, |t| vec::contains(p.tags, t) ) {\n-            print_pkg(s, p);\n-            n += 1;\n-        }\n-    });\n-    info(fmt!(\"found %d packages\", n));\n-}\n-\n-pub fn install_to_dir(srcfile: &Path, destdir: &Path) {\n-    let newfile = destdir.push(srcfile.filename().get());\n-\n-    let status = run::run_program(~\"cp\", ~[~\"-r\", srcfile.to_str(),\n-                                           newfile.to_str()]);\n-    if status == 0 {\n-        info(fmt!(\"installed: '%s'\", newfile.to_str()));\n-    } else {\n-        error(fmt!(\"could not install: '%s'\", newfile.to_str()));\n-    }\n-}\n-\n-pub fn dump_cache(c: &Cargo) {\n-    need_dir(&c.root);\n-\n-    let out = c.root.push(\"cache.json\");\n-    let _root = json::Object(~LinearMap::new());\n-\n-    if os::path_exists(&out) {\n-        copy_warn(&out, &c.root.push(\"cache.json.old\"));\n-    }\n-}\n-\n-pub fn dump_sources(c: &Cargo) {\n-    if c.sources.is_empty() {\n-        return;\n-    }\n-\n-    need_dir(&c.root);\n-\n-    let out = c.root.push(\"sources.json\");\n-\n-    if os::path_exists(&out) {\n-        copy_warn(&out, &c.root.push(\"sources.json.old\"));\n-    }\n-\n-    match io::buffered_file_writer(&out) {\n-        result::Ok(writer) => {\n-            let mut hash = ~LinearMap::new();\n-\n-            for c.sources.each |&k, &v| {\n-                let mut chash = ~LinearMap::new();\n-\n-                chash.insert(~\"url\", json::String(v.url));\n-                chash.insert(~\"method\", json::String(v.method));\n-\n-                match copy v.key {\n-                    Some(key) => {\n-                        chash.insert(~\"key\", json::String(copy key));\n-                    }\n-                    _ => ()\n-                }\n-                match copy v.keyfp {\n-                    Some(keyfp) => {\n-                        chash.insert(~\"keyfp\", json::String(copy keyfp));\n-                    }\n-                    _ => ()\n-                }\n-\n-                hash.insert(copy k, json::Object(chash));\n-            }\n-\n-            json::to_writer(writer, &json::Object(hash))\n-        }\n-        result::Err(e) => {\n-            error(fmt!(\"could not dump sources: %s\", e));\n-        }\n-    }\n-}\n-\n-pub fn copy_warn(srcfile: &Path, destfile: &Path) {\n-    if !os::copy_file(srcfile, destfile) {\n-        warn(fmt!(\"copying %s to %s failed\",\n-                  srcfile.to_str(), destfile.to_str()));\n-    }\n-}\n-\n-pub fn cmd_sources(c: &Cargo) {\n-    if vec::len(c.opts.free) < 3u {\n-        for c.sources.each_value |&v| {\n-            info(fmt!(\"%s (%s) via %s\",\n-                      v.name, v.url, v.method));\n-        }\n-        return;\n-    }\n-\n-    let action = c.opts.free[2u];\n-\n-    match action {\n-        ~\"clear\" => {\n-          for c.sources.each_key |&k| {\n-                c.sources.remove(&k);\n-            }\n-\n-            info(~\"cleared sources\");\n-        }\n-        ~\"add\" => {\n-            if vec::len(c.opts.free) < 5u {\n-                cmd_usage();\n-                return;\n-            }\n-\n-            let name = c.opts.free[3u];\n-            let url = c.opts.free[4u];\n-\n-            if !valid_pkg_name(name) {\n-                error(fmt!(\"'%s' is an invalid source name\", name));\n-                return;\n-            }\n-\n-            if c.sources.contains_key(&name) {\n-                error(fmt!(\"source already exists: %s\", name));\n-            } else {\n-                c.sources.insert(name, @Source {\n-                    name: name,\n-                    mut url: url,\n-                    mut method: assume_source_method(url),\n-                    mut key: None,\n-                    mut keyfp: None,\n-                    packages: DVec()\n-                });\n-                info(fmt!(\"added source: %s\", name));\n-            }\n-        }\n-        ~\"remove\" => {\n-            if vec::len(c.opts.free) < 4u {\n-                cmd_usage();\n-                return;\n-            }\n-\n-            let name = c.opts.free[3u];\n-\n-            if !valid_pkg_name(name) {\n-                error(fmt!(\"'%s' is an invalid source name\", name));\n-                return;\n-            }\n-\n-            if c.sources.contains_key(&name) {\n-                c.sources.remove(&name);\n-                info(fmt!(\"removed source: %s\", name));\n-            } else {\n-                error(fmt!(\"no such source: %s\", name));\n-            }\n-        }\n-        ~\"set-url\" => {\n-            if vec::len(c.opts.free) < 5u {\n-                cmd_usage();\n-                return;\n-            }\n-\n-            let name = c.opts.free[3u];\n-            let url = c.opts.free[4u];\n-\n-            if !valid_pkg_name(name) {\n-                error(fmt!(\"'%s' is an invalid source name\", name));\n-                return;\n-            }\n-\n-            match c.sources.find(&name) {\n-                Some(source) => {\n-                    let old = copy source.url;\n-                    let method = assume_source_method(url);\n-\n-                    source.url = url;\n-                    source.method = method;\n-\n-                    c.sources.insert(name, source);\n-\n-                    info(fmt!(\"changed source url: '%s' to '%s'\", old, url));\n-                }\n-                None => {\n-                    error(fmt!(\"no such source: %s\", name));\n-                }\n-            }\n-        }\n-        ~\"set-method\" => {\n-            if vec::len(c.opts.free) < 5u {\n-                cmd_usage();\n-                return;\n-            }\n-\n-            let name = c.opts.free[3u];\n-            let method = c.opts.free[4u];\n-\n-            if !valid_pkg_name(name) {\n-                error(fmt!(\"'%s' is an invalid source name\", name));\n-                return;\n-            }\n-\n-            match c.sources.find(&name) {\n-                Some(source) => {\n-                    let old = copy source.method;\n-\n-                    source.method = match method {\n-                        ~\"git\" => ~\"git\",\n-                        ~\"file\" => ~\"file\",\n-                        _ => ~\"curl\"\n-                    };\n-\n-                    c.sources.insert(name, source);\n-\n-                    info(fmt!(\"changed source method: '%s' to '%s'\", old,\n-                         method));\n-                }\n-                None => {\n-                    error(fmt!(\"no such source: %s\", name));\n-                }\n-            }\n-        }\n-        ~\"rename\" => {\n-            if vec::len(c.opts.free) < 5u {\n-                cmd_usage();\n-                return;\n-            }\n-\n-            let name = c.opts.free[3u];\n-            let newn = c.opts.free[4u];\n-\n-            if !valid_pkg_name(name) {\n-                error(fmt!(\"'%s' is an invalid source name\", name));\n-                return;\n-            }\n-            if !valid_pkg_name(newn) {\n-                error(fmt!(\"'%s' is an invalid source name\", newn));\n-                return;\n-            }\n-\n-            match c.sources.find(&name) {\n-                Some(source) => {\n-                    c.sources.remove(&name);\n-                    c.sources.insert(newn, source);\n-                    info(fmt!(\"renamed source: %s to %s\", name, newn));\n-                }\n-                None => {\n-                    error(fmt!(\"no such source: %s\", name));\n-                }\n-            }\n-        }\n-        _ => cmd_usage()\n-    }\n-}\n-\n-pub fn cmd_usage() {\n-    print(~\"Usage: cargo <cmd> [options] [args..]\n-e.g. cargo install <name>\n-\n-Where <cmd> is one of:\n-    init, install, list, search, sources,\n-    uninstall, usage\n-\n-Options:\n-\n-    -h, --help                  Display this message\n-    <cmd> -h, <cmd> --help      Display help for <cmd>\n-\");\n-}\n-\n-pub fn cmd_usage_init() {\n-    print(~\"cargo init\n-\n-Re-initialize cargo in ~/.cargo. Clears all sources and then adds the\n-default sources from <www.rust-lang.org/sources.json>.\");\n-}\n-\n-pub fn cmd_usage_install() {\n-    print(~\"cargo install\n-cargo install [source/]<name>[@version]\n-cargo install [source/]<uuid>[@version]\n-cargo install <git url> [ref]\n-cargo install <tarball url>\n-cargo install <tarball file>\n-\n-Options:\n-    --test      Run crate tests before installing\n-    -g          Install to the user level (~/.cargo/bin/ instead of\n-                locally in ./.cargo/bin/ by default)\n-    -G          Install to the system level (/usr/local/lib/cargo/bin/)\n-\n-Install a crate. If no arguments are supplied, it installs from\n-the current working directory. If a source is provided, only install\n-from that source, otherwise it installs from any source.\");\n-}\n-\n-pub fn cmd_usage_uninstall() {\n-    print(~\"cargo uninstall [source/]<name>[@version]\n-cargo uninstall [source/]<uuid>[@version]\n-cargo uninstall <meta-name>[@version]\n-cargo uninstall <meta-uuid>[@version]\n-\n-Options:\n-    -g          Remove from the user level (~/.cargo/bin/ instead of\n-                locally in ./.cargo/bin/ by default)\n-    -G          Remove from the system level (/usr/local/lib/cargo/bin/)\n-\n-Remove a crate. If a source is provided, only remove\n-from that source, otherwise it removes from any source.\n-If a crate was installed directly (git, tarball, etc.), you can remove\n-it by metadata.\");\n-}\n-\n-pub fn cmd_usage_list() {\n-    print(~\"cargo list [sources..]\n-\n-If no arguments are provided, list all sources and their packages.\n-If source names are provided, list those sources and their packages.\n-\");\n-}\n-\n-pub fn cmd_usage_search() {\n-    print(~\"cargo search <query | '*'> [tags..]\n-\n-Search packages.\");\n-}\n-\n-pub fn cmd_usage_sources() {\n-    print(~\"cargo sources\n-cargo sources add <name> <url>\n-cargo sources remove <name>\n-cargo sources rename <name> <new>\n-cargo sources set-url <name> <url>\n-cargo sources set-method <name> <method>\n-\n-If no arguments are supplied, list all sources (but not their packages).\n-\n-Commands:\n-    add             Add a source. The source method will be guessed\n-                    from the URL.\n-    remove          Remove a source.\n-    rename          Rename a source.\n-    set-url         Change the URL for a source.\n-    set-method      Change the method for a source.\");\n-}\n-\n-pub fn main() {\n-    let argv = os::args();\n-    let o = build_cargo_options(argv);\n-\n-    if vec::len(o.free) < 2u {\n-        cmd_usage();\n-        return;\n-    }\n-    if o.help {\n-        match o.free[1] {\n-            ~\"init\" => cmd_usage_init(),\n-            ~\"install\" => cmd_usage_install(),\n-            ~\"uninstall\" => cmd_usage_uninstall(),\n-            ~\"list\" => cmd_usage_list(),\n-            ~\"search\" => cmd_usage_search(),\n-            ~\"sources\" => cmd_usage_sources(),\n-            _ => cmd_usage()\n-        }\n-        return;\n-    }\n-    if o.free[1] == ~\"usage\" {\n-        cmd_usage();\n-        return;\n-    }\n-\n-    let mut c = configure(o);\n-    let home = c.root;\n-    let first_time = os::path_exists(&home.push(\"sources.json\"));\n-\n-    if !first_time && o.free[1] != ~\"init\" {\n-        cmd_init(&c);\n-\n-        // FIXME (#2662): shouldn't need to reconfigure\n-        c = configure(o);\n-    }\n-\n-    match o.free[1] {\n-        ~\"init\" => cmd_init(&c),\n-        ~\"install\" => cmd_install(&mut c),\n-        ~\"uninstall\" => cmd_uninstall(&c),\n-        ~\"list\" => cmd_list(&c),\n-        ~\"search\" => cmd_search(&c),\n-        ~\"sources\" => cmd_sources(&c),\n-        _ => cmd_usage()\n-    }\n-\n-    dump_cache(&c);\n-    dump_sources(&c);\n-}\n-"}, {"sha": "364effcd32f48d3795e87a6d89c38281a6fd02e8", "filename": "src/libcargo/pgp.rs", "status": "removed", "additions": 0, "deletions": 115, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/3e97cce27d55bb123fbf8c69f4bb2bd0a3ba9c08/src%2Flibcargo%2Fpgp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e97cce27d55bb123fbf8c69f4bb2bd0a3ba9c08/src%2Flibcargo%2Fpgp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcargo%2Fpgp.rs?ref=3e97cce27d55bb123fbf8c69f4bb2bd0a3ba9c08", "patch": "@@ -1,115 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use core::os;\n-use core::path::Path;\n-use core::run;\n-\n-pub fn gpgv(args: ~[~str]) -> run::ProgramOutput {\n-    return run::program_output(~\"gpgv\", args);\n-}\n-\n-pub fn signing_key() -> ~str {\n-    ~\"\n------BEGIN PGP PUBLIC KEY BLOCK-----\n-Version: SKS 1.1.0\n-\n-mQINBE7dQY0BEADYs5pHqXQugXjmgRTj0AzE3F4HAEJAiUBechVOmCgNcnW4dyb6bgj7Ctqs\n-Td/ZDSZkFwmsIqpwfGxMr+s9VA3PW+sEMDZPY+p8w3kvFPo/L2eRjSnQ+cPffdUPo+IXl96d\n-N/49iXs6/d7PHw+pYszdgCfpPAAo4TtLJLVCWRs1ETSbZBIUOFywgE5P71egYVMgYKndRM5K\n-cY0ZUsGUX9InpItuD3R7vFwDL9cUHBonOJoax+rYeM7eLQvNncl4YAwJsUKOVDBy28QK2wmz\n-R6MsBTX8+vRkj3ZTCnP1+RBNllViYnq6absnAgHFdQ6OL4T2wKhAaYhukE1foFTNNI1wAm4s\n-iYAI20Me+54xMQZa3QvrokL/Wf9+qeajEDOTZWs1T3Sn+H3Dg3T25b8WOH3ULZE7R4FPr0Id\n-5u95nxKG2D2fkMXDwc0BeG+VWh3lCdjOBn2kyT+6TwM9d+/VQmY4vZdZFhI6nCUlxeKEg4wk\n-HW6kad5QPcUlS/3flNHM0bVLPrmNDb61bm+2sYPpgw0iy7JA5m8MceG57jS7q6Mo001cIya8\n-EqrfBLZ0/0eLyIH81/RjFYwEoI54+QWe0ovdsqNTVnQsCcZnIRFTbMQqdInuCqrROIn+00xe\n-L0KNMh0iQO4zRaG0XhQaUxt2mIbkA0PuntsM8+I9DUIAqXgttwARAQABtERSdXN0IExhbmd1\n-YWdlIChUYWcgYW5kIFJlbGVhc2UgU2lnbmluZyBLZXkpIDxydXN0LWtleUBydXN0LWxhbmcu\n-b3JnPokCPgQTAQIAKAUCTt1BjQIbAwUJAeEzgAYLCQgHAwIGFQgCCQoLBBYCAwECHgECF4AA\n-CgkQCy1qKDAzY3azFg//V+IoiCurdYyS4nckMbr9gTn5SKaAtQUqMWAoJty3/lZ2jLq/9zO0\n-TO9Zw0rcoVUORpl4VsGsUu0QIA53KJJLOto4hHGvDBsASm4x1o06Ftsp37YrMozRN+4capIR\n-Kx5uM3whSUTGponOQplj9ED3zw/FkFWF4ni2KAZMfRJQy6berIBBHNWbMtY/vneTwv0YZOah\n-sS23AQ958mVhOfDYYnmpEzHza9kl6le9RjmxuFX0bOOB+bHE4T3X0OmB2q4RJetwd18qRGGY\n-dy/e5xON13Y708gV2v4t3ZC3X+XT/+dwHHjoa6nWIxI5OU59AfnjBJIs09pHq2VYUCfdZiHL\n-YRTrMQkUyapjOwWV5tbCtYnCufjILk2vk1YBqj1vjco0tMH7llsEoQ4seg8NrwkZYZ8jccN9\n-Aymb0ObZZgSVJCFN3akUESfh9wPDAQjmLjqWAOMNDSpnElIVAxLX1O/HNgRv7tl0Te14Goul\n-lhrWzTg5vPpOhSe+1SVUAUVcBwHcZl1opXCHQHfW2vkfe9w1hRBqEMOmr54TBXufxneNc/te\n-NuV+ZA4l9QvirmGtmQee4LQwz7d//IFGVxidsbOTVOU9hbijm/USJCK1BPqF36I2rB/8ve7h\n-qTwTVbvMRb8qWS2YhwRHsYrngXbun1vwwFouiW2KV5NEFNMt3pj+Rcu5Ag0ETt1BjQEQAMOf\n-6oCHj5ASMHCdKzSGF+ofIG3OWH7SUVRDKtJck75LyjbW/14SxNQCF6UvyjwhVWnnGmXiCED6\n-cCOo9UdMhF46ojWe//mszSJRZTc0OvUpq9AIe3UA7mLHve4A+8fXBd1mpgciG8qD4vifdO4T\n-yvkb4dwxW+hpsenKHaM4hvQJFB1c33loEeGdfE/9svZyCO9T4FA6tdj5niLdtGtcJ6eC/6rp\n-53kcg4RLz9hOH39ouitqIHVqO/j+TW2M8kYgh1niBCGQm2kV5jeh7QUMe7TA3KHksAVqAKcJ\n-4TO538KswbC8MLz4+cdHpXf+kSUNnRzyndazjIF31XSyT8cDZHdfFHFkCA/4Xr7ebp+gub6R\n-qbCeCbds/UQ8L7NOqze9/qGuRBLTarXmvZ0AgELu/z4bPF6GyKcJjFYkMZQoAzYZfFc2pNW+\n-WhWCusAz0aw+6NoZVI6bYhfY2w+kf3vebpzuKdD0Qublk5cKFCU9bV6BYqI9PbgBkErUgrgp\n-Zrjkc2c2u6uje0sKRxihdczr75Kikhb3M4BKQx3V5GyKdvo+61MhYurwWtyTylgMvlyL+3Bn\n-r0bg/vFbdwO4wgdNjR9UkjjABjuTExdnAqvf2+eBnYkuzxG60TH5At3CRTBshNUO9N0q1SGH\n-tGJkDOOxEZwAnUmE9jAG9CdeWxJNaUa5ABEBAAGJAiUEGAECAA8FAk7dQY0CGwwFCQHhM4AA\n-CgkQCy1qKDAzY3a9NBAAqpQKlFBCJV2h8GJU68OzFdxYIelhzH0KcInm6QREiUtU2+WAAyli\n-IbvsEL3c0hH0xykhwZx0wPmj7QQW7h5geOTvfLhNe/XMLsnlIRXBCSZKmlsZ8HfOVAXZTY61\n-LM0v11eI6w0lCUC6GqWfzpph+uxUQjJ6YrGomj7nDrvj8Dp4S4UYaJc+1pcVPjO/XmZrZkb1\n-6KnTm4RJcIW0iO61g7SDn8JZCmrDf9Ur+9NmRdynEeiWn9DUkbAXTKj09NiRyV+8mVmSGw4F\n-Jylqtk+X4WTu7qCm9C0S3ROuSSJOkCQGcE552GaS5RN9wdL/cG1PfqQjSaY0HMQzpBzV+nXa\n-2eFk3Bg2/qi4OghjR00Y3SQftDWI4K3opwVdsF7u9YH6PQoX4jl5DJIvtdIwwQJVaHLjVF4r\n-koV3ryFlL4Oq70TLwBSUlUhYoii5pokr3GdzloUWuuBa8AK5sM0RG/pybUPWK1PQnDlJJg6H\n-JyEC4EFfBWv2+nwt1K+vIRuCX9ZSd5YP9F4RbQjsnz7dimo5ooy3Wj7Fv7lQnQGkaUev0+hs\n-t9H7RfQEyREukTMxzXjKEW9EO4lJ20cif3l7Be+bw6OzKaEkVE3reZRnKxO6SejUYA7reye1\n-HI1jilzwKSXuV2EmyBk3tKh9NwscT/A78pr30FxxPUg3v72raNgusTo=\n-=2z6P\n------END PGP PUBLIC KEY BLOCK-----\n-\"\n-}\n-\n-pub fn signing_key_fp() -> ~str {\n-    ~\"FE79 EDB0 3DEF B0D8 27D2  6C41 0B2D 6A28 3033 6376\"\n-}\n-\n-pub fn supported() -> bool {\n-    let r = gpgv(~[~\"--version\"]);\n-    r.status == 0\n-}\n-\n-pub fn init(root: &Path) {\n-    let p = root.push(\"gpg\");\n-    if !os::path_is_dir(&p) {\n-        os::make_dir(&p, 0x1c0i32);\n-        let mut p = run::start_program(~\"gpg\", ~[~\"--homedir\",\n-                                                 p.to_str(),\n-                                                 ~\"--import\"]);\n-        p.input().write_str(signing_key());\n-        let s = p.finish();\n-        if s != 0 {\n-            fail!(~\"pgp init failed\");\n-        }\n-    }\n-}\n-\n-pub fn add(root: &Path, key: &Path) {\n-    let path = root.push(\"gpg\");\n-    let p =\n-        run::program_output(~\"gpg\", ~[~\"--homedir\", path.to_str(),\n-                                      ~\"--import\", key.to_str()]);\n-    if p.status != 0 {\n-        fail!(~\"pgp add failed: \" + p.out);\n-    }\n-}\n-\n-pub fn verify(root: &Path, data: &Path, sig: &Path) -> bool {\n-    let path = root.push(\"gpg\");\n-    let res = gpgv(~[~\"--homedir\", path.to_str(),\n-                  ~\"--keyring\", ~\"pubring.gpg\",\n-                  ~\"--verbose\",\n-                 sig.to_str(), data.to_str()]);\n-    if res.status != 0 {\n-        return false;\n-    }\n-    return true;\n-}"}, {"sha": "66e14f9eff7d4d45716d88aad3d0ea5f1d27ab85", "filename": "src/libcargo/sources.json", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3e97cce27d55bb123fbf8c69f4bb2bd0a3ba9c08/src%2Flibcargo%2Fsources.json", "raw_url": "https://github.com/rust-lang/rust/raw/3e97cce27d55bb123fbf8c69f4bb2bd0a3ba9c08/src%2Flibcargo%2Fsources.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcargo%2Fsources.json?ref=3e97cce27d55bb123fbf8c69f4bb2bd0a3ba9c08", "patch": "@@ -1,14 +0,0 @@\n-{\n-\t\"central\": {\n-\t\t\"url\": \"https://raw.github.com/mozilla/cargo-central/master/packages.json\"\n-\t},\n-\t\"elly\": {\n-\t\t\"url\": \"https://raw.github.com/elly/rust-packages/master/packages.json\",\n-\t\t\"sig\": \"https://raw.github.com/elly/rust-packages/master/packages.json.sig\",\n-\t\t\"key\": \"https://raw.github.com/elly/rust-packages/master/signing-key.gpg\",\n-\t\t\"keyfp\": \"4107 21C0 FF32 858F 61FF  33F6 E595 8E36 FDC8 EA00\"\n-\t},\n-\t\"erickt\": {\n-\t\t\"url\": \"https://raw.github.com/erickt/rust-packages/master/packages.json\"\n-\t}\n-}"}, {"sha": "da13145b9f60f2ce87d5ef412fbe7304d031fa45", "filename": "src/libcore/core.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/354da4108a483ece3b6424ea7d92e3b6e91d4239/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/354da4108a483ece3b6424ea7d92e3b6e91d4239/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=354da4108a483ece3b6424ea7d92e3b6e91d4239", "patch": "@@ -170,7 +170,6 @@ pub mod condition;\n pub mod logging;\n pub mod util;\n \n-\n /* Reexported core operators */\n \n pub use kinds::{Const, Copy, Owned, Durable};"}, {"sha": "13d4ec6e10df66c9dc6daadc2f2811a89fd08b7a", "filename": "src/libcore/option.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/354da4108a483ece3b6424ea7d92e3b6e91d4239/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/354da4108a483ece3b6424ea7d92e3b6e91d4239/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=354da4108a483ece3b6424ea7d92e3b6e91d4239", "patch": "@@ -41,7 +41,7 @@ let unwrapped_msg = match msg {\n \n */\n \n-use cmp::Eq;\n+use cmp::{Eq,Ord};\n use kinds::Copy;\n use option;\n use ptr;\n@@ -56,6 +56,34 @@ pub enum Option<T> {\n     Some(T),\n }\n \n+pub impl<T:Ord> Ord for Option<T> {\n+    pure fn lt(&self, other: &Option<T>) -> bool {\n+        match (self, other) {\n+            (&None, &None) => false,\n+            (&None, &Some(_)) => true,\n+            (&Some(_), &None) => false,\n+            (&Some(ref a), &Some(ref b)) => *a < *b\n+        }\n+    }\n+\n+    pure fn le(&self, other: &Option<T>) -> bool {\n+        match (self, other) {\n+            (&None, &None) => true,\n+            (&None, &Some(_)) => true,\n+            (&Some(_), &None) => false,\n+            (&Some(ref a), &Some(ref b)) => *a <= *b\n+        }\n+    }\n+\n+    pure fn ge(&self, other: &Option<T>) -> bool {\n+        ! (self < other)\n+    }\n+\n+    pure fn gt(&self, other: &Option<T>) -> bool {\n+        ! (self <= other)\n+    }\n+}\n+\n #[inline(always)]\n pub pure fn get<T: Copy>(opt: Option<T>) -> T {\n     /*!"}, {"sha": "5fc284bc9fc49f30224ded62e48a15ae12bbdd7f", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/354da4108a483ece3b6424ea7d92e3b6e91d4239/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/354da4108a483ece3b6424ea7d92e3b6e91d4239/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=354da4108a483ece3b6424ea7d92e3b6e91d4239", "patch": "@@ -184,14 +184,14 @@ pub enum compile_upto {\n     cu_everything,\n }\n \n-pub fn compile_upto(sess: Session, cfg: ast::crate_cfg,\n-                    input: input, upto: compile_upto,\n-                    outputs: Option<output_filenames>)\n-                 -> {crate: @ast::crate, tcx: Option<ty::ctxt>} {\n+// For continuing compilation after a parsed crate has been\n+// modified\n+pub fn compile_rest(sess: Session, cfg: ast::crate_cfg,\n+                    upto: compile_upto, outputs: Option<output_filenames>,\n+                    curr: Option<@ast::crate>)\n+    -> {crate: @ast::crate, tcx: Option<ty::ctxt>} {\n     let time_passes = sess.time_passes();\n-    let mut crate = time(time_passes, ~\"parsing\",\n-                         || parse_input(sess, copy cfg, input) );\n-    if upto == cu_parse { return {crate: crate, tcx: None}; }\n+    let mut crate = curr.get();\n \n     *sess.building_library = session::building_library(\n         sess.opts.crate_type, crate, sess.opts.test);\n@@ -322,7 +322,6 @@ pub fn compile_upto(sess: Session, cfg: ast::crate_cfg,\n \n     };\n \n-\n     time(time_passes, ~\"LLVM passes\", ||\n         link::write::run_passes(sess, llmod,\n                                 &outputs.obj_filename));\n@@ -342,9 +341,20 @@ pub fn compile_upto(sess: Session, cfg: ast::crate_cfg,\n     return {crate: crate, tcx: None};\n }\n \n+pub fn compile_upto(sess: Session, +cfg: ast::crate_cfg,\n+                input: input, upto: compile_upto,\n+                outputs: Option<output_filenames>)\n+    -> {crate: @ast::crate, tcx: Option<ty::ctxt>} {\n+    let time_passes = sess.time_passes();\n+    let mut crate = time(time_passes, ~\"parsing\",\n+                         || parse_input(sess, copy cfg, input) );\n+    if upto == cu_parse { return {crate: crate, tcx: None}; }\n+\n+    compile_rest(sess, cfg, upto, outputs, Some(crate))\n+}\n+\n pub fn compile_input(sess: Session, +cfg: ast::crate_cfg, input: input,\n                      outdir: &Option<Path>, output: &Option<Path>) {\n-\n     let upto = if sess.opts.parse_only { cu_parse }\n                else if sess.opts.no_trans { cu_no_trans }\n                else { cu_everything };"}, {"sha": "f5cc44867a5d178fe9db1822c8a9886702a96eac", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/354da4108a483ece3b6424ea7d92e3b6e91d4239/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/354da4108a483ece3b6424ea7d92e3b6e91d4239/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=354da4108a483ece3b6424ea7d92e3b6e91d4239", "patch": "@@ -49,11 +49,11 @@ pub fn mk_filesearch(maybe_sysroot: Option<Path>,\n             paths.push(\n                 make_target_lib_path(&self.sysroot,\n                                      self.target_triple));\n-            match get_cargo_lib_path_nearest() {\n+            match get_rustpkg_lib_path_nearest() {\n               result::Ok(ref p) => paths.push((/*bad*/copy *p)),\n               result::Err(_) => ()\n             }\n-            match get_cargo_lib_path() {\n+            match get_rustpkg_lib_path() {\n               result::Ok(ref p) => paths.push((/*bad*/copy *p)),\n               result::Err(_) => ()\n             }\n@@ -119,54 +119,54 @@ fn get_sysroot(maybe_sysroot: Option<Path>) -> Path {\n     }\n }\n \n-pub fn get_cargo_sysroot() -> Result<Path, ~str> {\n-    result::Ok(get_or_default_sysroot().push_many([libdir(), ~\"cargo\"]))\n+pub fn get_rustpkg_sysroot() -> Result<Path, ~str> {\n+    result::Ok(get_or_default_sysroot().push_many([libdir(), ~\"rustpkg\"]))\n }\n \n-pub fn get_cargo_root() -> Result<Path, ~str> {\n-    match os::getenv(~\"CARGO_ROOT\") {\n+pub fn get_rustpkg_root() -> Result<Path, ~str> {\n+    match os::getenv(~\"RUSTPKG_ROOT\") {\n         Some(ref _p) => result::Ok(Path((*_p))),\n         None => match os::homedir() {\n-          Some(ref _q) => result::Ok((*_q).push(\".cargo\")),\n-          None => result::Err(~\"no CARGO_ROOT or home directory\")\n+          Some(ref _q) => result::Ok((*_q).push(\".rustpkg\")),\n+          None => result::Err(~\"no RUSTPKG_ROOT or home directory\")\n         }\n     }\n }\n \n-pub fn get_cargo_root_nearest() -> Result<Path, ~str> {\n-    do result::chain(get_cargo_root()) |p| {\n+pub fn get_rustpkg_root_nearest() -> Result<Path, ~str> {\n+    do result::chain(get_rustpkg_root()) |p| {\n         let cwd = os::getcwd();\n-        let cwd_cargo = cwd.push(\".cargo\");\n-        let cargo_is_non_root_file =\n-            !os::path_is_dir(&cwd_cargo) && cwd_cargo != p;\n-        let mut par_cargo = cwd.pop().push(\".cargo\");\n-        let mut rslt = result::Ok(cwd_cargo);\n-\n-        if cargo_is_non_root_file {\n-            while par_cargo != p {\n-                if os::path_is_dir(&par_cargo) {\n-                    rslt = result::Ok(par_cargo);\n+        let cwd_rustpkg = cwd.push(\".rustpkg\");\n+        let rustpkg_is_non_root_file =\n+            !os::path_is_dir(&cwd_rustpkg) && cwd_rustpkg != p;\n+        let mut par_rustpkg = cwd.pop().push(\".rustpkg\");\n+        let mut rslt = result::Ok(cwd_rustpkg);\n+\n+        if rustpkg_is_non_root_file {\n+            while par_rustpkg != p {\n+                if os::path_is_dir(&par_rustpkg) {\n+                    rslt = result::Ok(par_rustpkg);\n                     break;\n                 }\n-                if par_cargo.components.len() == 1 {\n-                    // We just checked /.cargo, stop now.\n+                if par_rustpkg.components.len() == 1 {\n+                    // We just checked /.rustpkg, stop now.\n                     break;\n                 }\n-                par_cargo = par_cargo.pop().pop().push(\".cargo\");\n+                par_rustpkg = par_rustpkg.pop().pop().push(\".rustpkg\");\n             }\n         }\n         rslt\n     }\n }\n \n-fn get_cargo_lib_path() -> Result<Path, ~str> {\n-    do result::chain(get_cargo_root()) |p| {\n+fn get_rustpkg_lib_path() -> Result<Path, ~str> {\n+    do result::chain(get_rustpkg_root()) |p| {\n         result::Ok(p.push(libdir()))\n     }\n }\n \n-fn get_cargo_lib_path_nearest() -> Result<Path, ~str> {\n-    do result::chain(get_cargo_root_nearest()) |p| {\n+fn get_rustpkg_lib_path_nearest() -> Result<Path, ~str> {\n+    do result::chain(get_rustpkg_root_nearest()) |p| {\n         result::Ok(p.push(libdir()))\n     }\n }"}, {"sha": "5b610bbb1f8ea0c6dbf9105a3cc9f048af210c66", "filename": "src/librustpkg/rustpkg.rc", "status": "added", "additions": 1038, "deletions": 0, "changes": 1038, "blob_url": "https://github.com/rust-lang/rust/blob/354da4108a483ece3b6424ea7d92e3b6e91d4239/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/354da4108a483ece3b6424ea7d92e3b6e91d4239/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=354da4108a483ece3b6424ea7d92e3b6e91d4239", "patch": "@@ -0,0 +1,1038 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// rustpkg - a purely function package manager and build system\n+\n+#[link(name = \"rustpkg\",\n+       vers = \"0.6\",\n+       uuid = \"25de5e6e-279e-4a20-845c-4cabae92daaf\",\n+       url = \"https://github.com/mozilla/rust/tree/master/src/librustpkg\")];\n+\n+#[crate_type = \"lib\"];\n+#[no_core];\n+#[allow(vecs_implicitly_copyable,\n+        non_implicitly_copyable_typarams)];\n+\n+#[legacy_records];\n+\n+extern mod core(vers = \"0.6\");\n+extern mod std(vers = \"0.6\");\n+extern mod rustc(vers = \"0.6\");\n+extern mod syntax(vers = \"0.6\");\n+\n+use core::*;\n+use io::{ReaderUtil, WriterUtil};\n+use std::{json, semver, getopts};\n+use std::net::url;\n+use hashmap::linear::LinearMap;\n+use rustc::metadata::filesearch;\n+use rustc::driver::{driver, session};\n+use syntax::{ast, attr, codemap, diagnostic, parse, visit};\n+use syntax::codemap::spanned;\n+\n+mod usage;\n+mod util;\n+\n+use util::Package;\n+\n+struct PackageScript {\n+    id: ~str,\n+    name: ~str,\n+    vers: semver::Version,\n+    crates: ~[~str],\n+    deps: ~[(~str, Option<~str>)],\n+    input: driver::input,\n+    sess: session::Session,\n+    cfg: ast::crate_cfg,\n+    crate: @ast::crate,\n+    custom: bool\n+}\n+\n+impl PackageScript {\n+    static fn parse(parent: &Path) -> Result<PackageScript, ~str> {\n+        let script = parent.push(~\"pkg.rs\");\n+\n+        if !os::path_exists(&script) {\n+            return result::Err(~\"no pkg.rs file\");\n+        }\n+\n+        let binary = os::args()[0];\n+        let options: @session::options = @{\n+            binary: binary,\n+            crate_type: session::bin_crate,\n+            .. *session::basic_options()\n+        };\n+        let input = driver::file_input(script);\n+        let sess = driver::build_session(options, diagnostic::emit);\n+        let cfg = driver::build_configuration(sess, binary, input);\n+        let {crate, _} = driver::compile_upto(sess, cfg, input,\n+                                              driver::cu_parse, None);\n+        let mut id = None;\n+        let mut vers = None;\n+        let mut crates = ~[];\n+        let mut deps = ~[];\n+\n+        fn load_pkg_attr(mis: ~[@ast::meta_item]) -> (Option<~str>,\n+                                                      Option<~str>) {\n+            let mut id = None;\n+            let mut vers = None;\n+\n+            for mis.each |a| {\n+                match a.node {\n+                    ast::meta_name_value(v, spanned {\n+                                                node: ast::lit_str(s),\n+                                                span: _}) => {\n+                        match v {\n+                            ~\"id\" => id = Some(*s),\n+                            ~\"vers\" => vers = Some(*s),\n+                            _ => ()\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+\n+            (id, vers)\n+        }\n+\n+        fn load_pkg_dep_attr(mis: ~[@ast::meta_item]) -> (Option<~str>,\n+                                                          Option<~str>) {\n+            let mut url = None;\n+            let mut target = None;\n+\n+            for mis.each |a| {\n+                match a.node {\n+                    ast::meta_name_value(v, spanned {\n+                                                node: ast::lit_str(s),\n+                                                span: _}) => {\n+                        match v {\n+                            ~\"url\" => url = Some(*s),\n+                            ~\"target\" => target = Some(*s),\n+                            _ => ()\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+\n+            (url, target)\n+        }\n+\n+        fn load_pkg_crate_attr(mis: ~[@ast::meta_item]) -> Option<~str> {\n+            let mut file = None;\n+\n+            for mis.each |a| {\n+                match a.node {\n+                    ast::meta_name_value(v, spanned {\n+                                                node: ast::lit_str(s),\n+                                                span: _}) => {\n+                        match v {\n+                            ~\"file\" => file = Some(*s),\n+                            _ => ()\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+\n+            file\n+        }\n+\n+        for crate.node.attrs.each |a| {\n+            match a.node.value.node {\n+                ast::meta_list(v, mis) => {\n+                    match v {\n+                        ~\"pkg\" => {\n+                            let (i, v) = load_pkg_attr(mis);\n+\n+                            id = i;\n+                            vers = v;\n+                        }\n+                        ~\"pkg_dep\" => {\n+                            let (u, t) = load_pkg_dep_attr(mis);\n+\n+                            if u.is_none() {\n+                                fail!(~\"pkg_dep attr without a url value\");\n+                            }\n+\n+                            deps.push((u.get(), t));\n+                        }\n+                        ~\"pkg_crate\" => {\n+                            let f = load_pkg_crate_attr(mis);\n+\n+                            if f.is_none() {\n+                                fail!(~\"pkg_file attr without a file value\");\n+                            }\n+\n+                            crates.push(f.get());\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        let mut custom = false;\n+\n+        // If we hit a function, we assume they want to use\n+        // the build API.\n+        for crate.node.module.items.each |i| {\n+            match i.node {\n+                ast::item_fn(_, _, _, _) => {\n+                    custom = true;\n+\n+                    break;\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        if id.is_none() || vers.is_none() {\n+            return result::Err(~\"pkg attr without (id, vers) values\");\n+        }\n+\n+        let id = id.get();\n+        let name = match util::parse_name(id) {\n+            result::Ok(name) => name,\n+            result::Err(err) => return result::Err(err)\n+        };\n+        let vers = match util::parse_vers(vers.get()) {\n+            result::Ok(vers) => vers,\n+            result::Err(err) => return result::Err(err)\n+        };\n+\n+        result::Ok(PackageScript {\n+            id: id,\n+            name: name,\n+            vers: vers,\n+            crates: crates,\n+            deps: deps,\n+            input: input,\n+            sess: sess,\n+            cfg: cfg,\n+            crate: crate,\n+            custom: custom\n+        })\n+    }\n+\n+    // Build the bootstrap and run a command\n+    // FIXME (#4432): Use workcache to only compile the script when changed\n+    fn run(&self, cmd: ~str, test: bool) -> int {\n+        let work_dir = self.work_dir();\n+        let input = self.input;\n+        let sess = self.sess;\n+        let cfg = self.cfg;\n+        let crate = util::ready_crate(sess, self.crate);\n+        let outputs = driver::build_output_filenames(input, &Some(work_dir),\n+                                                     &None, sess);\n+        let exe = work_dir.push(~\"pkg\" + util::exe_suffix());\n+        let root = filesearch::get_rustpkg_sysroot().get().pop().pop();\n+\n+        driver::compile_rest(sess, cfg, driver::cu_parse,\n+                             Some(outputs), Some(crate));\n+        run::run_program(exe.to_str(), ~[root.to_str(), cmd, test.to_str()])\n+    }\n+\n+    fn hash(&self) -> ~str {\n+        fmt!(\"%s-%s-%s\", self.name, util::hash(self.id + self.vers.to_str()),\n+                         self.vers.to_str())\n+    }\n+\n+    fn work_dir(&self) -> Path {\n+        util::root().push(~\"work\").push(self.hash())\n+    }\n+}\n+\n+struct Ctx {\n+    cfgs: ~[~str],\n+    json: bool,\n+    mut dep_cache: LinearMap<~str, bool>\n+}\n+\n+impl Ctx {\n+    fn run(&self, cmd: ~str, args: ~[~str]) {\n+        let root = util::root();\n+\n+        util::need_dir(&root);\n+        util::need_dir(&root.push(~\"work\"));\n+        util::need_dir(&root.push(~\"lib\"));\n+        util::need_dir(&root.push(~\"bin\"));\n+        util::need_dir(&root.push(~\"tmp\"));\n+\n+        fn sep_name_vers(in: ~str) -> (Option<~str>, Option<~str>) {\n+            let mut name = None;\n+            let mut vers = None;\n+            let parts = str::split_char(in, '@');\n+\n+            if parts.len() >= 1 {\n+                name = Some(parts[0]);\n+\n+                if parts.len() >= 2 {\n+                    vers = Some(parts[1]);\n+                }\n+            }\n+\n+            (name, vers)\n+        }\n+\n+        match cmd {\n+            ~\"build\" => {\n+                self.build(&os::getcwd(), true, false, false);\n+            }\n+            ~\"clean\" => {\n+                self.clean();\n+            }\n+            ~\"do\" => {\n+                if args.len() < 1 {\n+                    return usage::do_cmd();\n+                }\n+\n+                self.do_cmd(args[0]);\n+            }\n+            ~\"info\" => {\n+                self.info();\n+            }\n+            ~\"install\" => {\n+                self.install(if args.len() >= 1 { Some(args[0]) }\n+                             else { None },\n+                             if args.len() >= 2 { Some(args[1]) }\n+                             else { None }, false);\n+            }\n+            ~\"prefer\" => {\n+                if args.len() < 1 {\n+                    return usage::uninstall();\n+                }\n+\n+                let (name, vers) = sep_name_vers(args[0]);\n+\n+                self.prefer(name.get(), vers);\n+            }\n+            ~\"test\" => {\n+                self.test();\n+            }\n+            ~\"uninstall\" => {\n+                if args.len() < 1 {\n+                    return usage::uninstall();\n+                }\n+\n+                let (name, vers) = sep_name_vers(args[0]);\n+\n+                self.uninstall(name.get(), vers);\n+            }\n+            ~\"unprefer\" => {\n+                if args.len() < 1 {\n+                    return usage::uninstall();\n+                }\n+\n+                let (name, vers) = sep_name_vers(args[0]);\n+\n+                self.unprefer(name.get(), vers);\n+            }\n+            _ => fail!(~\"reached an unhandled command\")\n+        }\n+    }\n+\n+    fn do_cmd(&self, cmd: ~str) -> bool {\n+        match cmd {\n+            ~\"build\" | ~\"test\" => {\n+                util::error(~\"that command cannot be manually called\");\n+\n+                return false;\n+            }\n+            _ => {}\n+        }\n+\n+        let cwd = &os::getcwd();\n+        let script = match PackageScript::parse(cwd) {\n+            result::Ok(script) => script,\n+            result::Err(err) => {\n+                util::error(err);\n+\n+                return false;\n+            }\n+        };\n+        let status = script.run(cmd, false);\n+\n+        if status == 42 {\n+            util::error(~\"no fns are listening for that cmd\");\n+\n+            return false;\n+        }\n+\n+        status == 0\n+    }\n+\n+    fn build(&self, dir: &Path, verbose: bool, opt: bool,\n+             test: bool) -> Option<PackageScript> {\n+        let cwd = &os::getcwd();\n+        let script = match PackageScript::parse(dir) {\n+            result::Ok(script) => script,\n+            result::Err(err) => {\n+                util::error(err);\n+\n+                return None;\n+            }\n+        };\n+        let work_dir = script.work_dir();\n+        let mut success = true;\n+\n+        util::need_dir(&work_dir);\n+\n+        if script.deps.len() >= 1 {\n+            util::note(~\"installing dependencies\");\n+\n+            for script.deps.each |&dep| {\n+                let (url, target) = dep;\n+\n+                success = self.install(Some(url), target, true);\n+\n+                if !success { break; }\n+            }\n+\n+\n+            if !success {\n+                util::error(\n+                    fmt!(\"building %s v%s failed: a dep wasn't installed\",\n+                         script.name, script.vers.to_str()));\n+\n+                return None;\n+            }\n+\n+            util::note(~\"installed dependencies\");\n+        }\n+\n+        // Build imperative crates\n+        os::change_dir(dir);\n+\n+        if script.custom {\n+            let status = script.run(~\"build\", test);\n+\n+            if status != 0 && status != 42 {\n+                util::error(\n+                    fmt!(\"building %s v%s failed: custom logic failed (%d)\",\n+                         script.name, script.vers.to_str(), status));\n+\n+                return None;\n+            }\n+        }\n+\n+        os::change_dir(cwd);\n+\n+        for script.crates.each |&crate| {\n+            let crate = &dir.push_rel(&Path(crate)).normalize();\n+\n+            util::note(fmt!(\"compiling %s\", crate.to_str()));\n+\n+            success = self.compile(crate, &work_dir, ~[],\n+                                   ~[], opt, test);\n+\n+            if !success { break; }\n+        }\n+\n+        if !success {\n+            util::error(\n+                fmt!(\"building %s v%s failed: a crate failed to compile\",\n+                     script.name, script.vers.to_str()));\n+\n+            return None;\n+        }\n+\n+        if verbose {\n+            util::note(fmt!(\"built %s v%s\", script.name,\n+                            script.vers.to_str()));\n+        }\n+\n+        Some(script)\n+    }\n+\n+    fn compile(&self, crate: &Path, dir: &Path, flags: ~[~str],\n+               cfgs: ~[~str], opt: bool, test: bool) -> bool {\n+        util::compile_crate(None, crate, dir, flags, cfgs, opt, test)\n+    }\n+\n+    fn clean(&self) -> bool {\n+        let script = match PackageScript::parse(&os::getcwd()) {\n+            result::Ok(script) => script,\n+            result::Err(err) => {\n+                util::error(err);\n+\n+                return false;\n+            }\n+        };\n+        let dir = script.work_dir();\n+\n+        util::note(fmt!(\"cleaning %s v%s (%s)\", script.name,\n+                        script.vers.to_str(), script.id));\n+\n+        if os::path_exists(&dir) {\n+            util::remove_dir_r(&dir);\n+            util::note(fmt!(\"removed %s\", dir.to_str()));\n+        }\n+\n+        util::note(fmt!(\"cleaned %s v%s\", script.name,\n+                                          script.vers.to_str()));\n+\n+        true\n+    }\n+\n+    fn info(&self) {\n+        if self.json {\n+            match PackageScript::parse(&os::getcwd()) {\n+                result::Ok(script) => {\n+                    let mut map = ~LinearMap::new();\n+\n+                    map.insert(~\"id\", json::String(script.id));\n+                    map.insert(~\"name\", json::String(script.name));\n+                    map.insert(~\"vers\", json::String(script.vers.to_str()));\n+                    map.insert(~\"deps\", json::List(do script.deps.map |&dep| {\n+                        let (url, target) = dep;\n+                        let mut inner = ~LinearMap::new();\n+\n+                        inner.insert(~\"url\", json::String(url));\n+\n+                        if !target.is_none() {\n+                            inner.insert(~\"target\",\n+                                         json::String(target.get()));\n+                        }\n+\n+                        json::Object(inner)\n+                    }));\n+\n+                    io::println(json::to_pretty_str(&json::Object(map)));\n+                }\n+                result::Err(_) => io::println(~\"{}\")\n+            }\n+        } else {\n+            let script = match PackageScript::parse(&os::getcwd()) {\n+                result::Ok(script) => script,\n+                result::Err(err) => {\n+                    util::error(err);\n+\n+                    return;\n+                }\n+            };\n+\n+            util::note(fmt!(\"id: %s\", script.id));\n+            util::note(fmt!(\"name: %s\", script.name));\n+            util::note(fmt!(\"vers: %s\", script.vers.to_str()));\n+            util::note(fmt!(\"deps: %s\",\n+                            if script.deps.len() > 0 {\n+                                ~\"\"\n+                            } else {\n+                                ~\"none\"\n+                            }));\n+\n+            for script.deps.each |&dep| {\n+                let (url, target) = dep;\n+\n+                util::note(fmt!(\"  <%s> (%s)\", url, match target {\n+                    Some(target) => target,\n+                    None => ~\"\"\n+                }));\n+            }\n+        }\n+    }\n+\n+    fn install(&self, url: Option<~str>,\n+               target: Option<~str>, cache: bool) -> bool {\n+        let mut success;\n+        let mut dir;\n+\n+        if url.is_none() {\n+            util::note(~\"installing from the cwd\");\n+\n+            dir = os::getcwd();\n+        } else {\n+            let url = url.get();\n+            let hash = util::hash(if !target.is_none() { url + target.get() }\n+                                  else { url });\n+\n+            if self.dep_cache.contains_key(&hash) {\n+                util::warn(~\"already installed dep this run\");\n+\n+                return true;\n+            }\n+\n+            self.dep_cache.insert(hash, true);\n+\n+            dir = util::root().push(~\"tmp\").push(hash);\n+\n+            if cache && os::path_exists(&dir) {\n+                return true;\n+            }\n+\n+            success = self.fetch(&dir, url, target);\n+\n+            if !success {\n+                return false;\n+            }\n+        }\n+\n+        let script = match self.build(&dir, false, true, false) {\n+            Some(script) => script,\n+            None => {\n+                return false;\n+            }\n+        };\n+        let work_dir = script.work_dir();\n+        let from_bin_dir = work_dir.push(~\"bin\");\n+        let from_lib_dir = work_dir.push(~\"lib\");\n+        let to_bin_dir = util::root().push(~\"bin\");\n+        let to_lib_dir = util::root().push(~\"lib\");\n+        let mut bins = ~[];\n+        let mut libs = ~[];\n+\n+        for os::walk_dir(&from_bin_dir) |bin| {\n+            let to = to_bin_dir.push_rel(&bin.file_path());\n+\n+            os::copy_file(bin, &to);\n+            bins.push(to.to_str());\n+        }\n+\n+        for os::walk_dir(&from_lib_dir) |lib| {\n+            let to = to_lib_dir.push_rel(&lib.file_path());\n+\n+            os::copy_file(lib, &to);\n+            libs.push(to.to_str());\n+        }\n+\n+        let package = Package {\n+            id: script.id,\n+            vers: script.vers,\n+            bins: bins,\n+            libs: libs\n+        };\n+\n+        util::note(fmt!(\"installed %s v%s\", script.name,\n+                                            script.vers.to_str()));\n+        util::add_pkg(&package);\n+\n+        true\n+    }\n+\n+    fn fetch(&self, dir: &Path, url: ~str, target: Option<~str>) -> bool {\n+        let url = if str::find_str(url, \"://\").is_none() {\n+            ~\"http://\" + url }\n+        else { url };\n+        let url = match url::from_str(url) {\n+            result::Ok(url) => url,\n+            result::Err(err) => {\n+                util::error(fmt!(\"failed parsing %s\", err.to_lower()));\n+\n+                return false;\n+            }\n+        };\n+        let str = url.to_str();\n+\n+        match Path(url.path).filetype() {\n+            Some(ext) => {\n+                if ext == ~\".git\" {\n+                    return self.fetch_git(dir, str, target);\n+                }\n+            }\n+            None => {}\n+        }\n+\n+        match url.scheme {\n+            ~\"git\" => self.fetch_git(dir, str, target),\n+            ~\"http\" | ~\"ftp\" | ~\"file\" => self.fetch_curl(dir, str),\n+            _ => {\n+                util::warn(~\"unknown url scheme to fetch, using curl\");\n+                self.fetch_curl(dir, str)\n+            }\n+        }\n+    }\n+\n+    fn fetch_curl(&self, dir: &Path, url: ~str) -> bool {\n+        util::note(fmt!(\"fetching from %s using curl\", url));\n+\n+        let tar = dir.dir_path().push(&dir.file_path().to_str() + ~\".tar\");\n+\n+        if run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\",\n+                                          ~\"-o\", tar.to_str(),\n+                                          url]).status != 0 {\n+            util::error(~\"fetching failed: downloading using curl failed\");\n+\n+            return false;\n+        }\n+\n+        if run::program_output(~\"tar\", ~[~\"-x\", ~\"--strip-components=1\",\n+                                         ~\"-C\", dir.to_str(), ~\"-f\",\n+                                         tar.to_str()]).status != 0 {\n+            util::error(~\"fetching failed: extracting using tar failed\" +\n+                        ~\"(is it a valid tar archive?)\");\n+\n+            return false;\n+        }\n+\n+        true\n+    }\n+\n+    fn fetch_git(&self, dir: &Path, url: ~str, target: Option<~str>) -> bool {\n+        util::note(fmt!(\"fetching from %s using git\", url));\n+\n+        // Git can't clone into a non-empty directory\n+        util::remove_dir_r(dir);\n+\n+        if run::program_output(~\"git\", ~[~\"clone\", url,\n+                                         dir.to_str()]).status != 0 {\n+            util::error(~\"fetching failed: can't clone repository\");\n+\n+            return false;\n+        }\n+\n+        if !target.is_none() {\n+            let mut success = true;\n+\n+            do util::temp_change_dir(dir) {\n+                success = run::program_output(~\"git\",\n+                                              ~[~\"checkout\",\n+                                                target.get()]).status != 0\n+            }\n+\n+            if !success {\n+                util::error(~\"fetching failed: can't checkout target\");\n+\n+                return false;\n+            }\n+        }\n+\n+        true\n+    }\n+\n+    fn prefer(&self, id: ~str, vers: Option<~str>) -> bool {\n+        let package = match util::get_pkg(id, vers) {\n+            result::Ok(package) => package,\n+            result::Err(err) => {\n+                util::error(err);\n+\n+                return false;\n+            }\n+        };\n+        let name = match util::parse_name(package.id) {\n+            result::Ok(name) => name,\n+            result::Err(err) => {\n+                util::error(err);\n+\n+                return false;\n+            }\n+        };\n+\n+        util::note(fmt!(\"preferring %s v%s (%s)\", name, package.vers.to_str(),\n+                                                  package.id));\n+\n+        let bin_dir = util::root().push(~\"bin\");\n+\n+        for package.bins.each |&bin| {\n+            let path = Path(bin);\n+            let name = str::split_char(path.file_path().to_str(), '-')[0];\n+            let out = bin_dir.push(name);\n+\n+            util::link_exe(&path, &out);\n+            util::note(fmt!(\"linked %s\", out.to_str()));\n+        }\n+\n+        util::note(fmt!(\"preferred %s v%s\", name, package.vers.to_str()));\n+\n+        true\n+    }\n+\n+    fn test(&self) -> bool {\n+        let script = match self.build(&os::getcwd(), false, false, true) {\n+            Some(script) => script,\n+            None => {\n+                return false;\n+            }\n+        };\n+        let work_dir = script.work_dir();\n+        let test_dir = work_dir.push(~\"test\");\n+\n+        for os::walk_dir(&test_dir) |test| {\n+            util::note(fmt!(\"running %s\", test.to_str()));\n+\n+            let status = run::run_program(test.to_str(), ~[]);\n+\n+            if status != 0 {\n+                os::set_exit_status(status);\n+            }\n+        }\n+\n+        // Run custom test listener\n+        if script.custom {\n+            let status = script.run(~\"test\", false);\n+\n+            if status != 0 && status != 42 {\n+                util::error(\n+                    fmt!(\"testing %s v%s failed: custom logic failed (%d)\",\n+                         script.name, script.vers.to_str(), status));\n+\n+                os::set_exit_status(status);\n+            }\n+        }\n+\n+        util::note(fmt!(\"tested %s v%s\", script.name, script.vers.to_str()));\n+\n+        true\n+    }\n+\n+    fn uninstall(&self, id: ~str, vers: Option<~str>) -> bool {\n+        let package = match util::get_pkg(id, vers) {\n+            result::Ok(package) => package,\n+            result::Err(err) => {\n+                util::error(err);\n+\n+                return false;\n+            }\n+        };\n+        let name = match util::parse_name(package.id) {\n+            result::Ok(name) => name,\n+            result::Err(err) => {\n+                util::error(err);\n+\n+                return false;\n+            }\n+        };\n+\n+        util::note(fmt!(\"uninstalling %s v%s (%s)\", name,\n+                        package.vers.to_str(), package.id));\n+\n+        for vec::append(package.bins, package.libs).each |&file| {\n+            let path = Path(file);\n+\n+            if os::path_exists(&path) {\n+                if os::remove_file(&path) {\n+                    util::note(fmt!(\"removed %s\", path.to_str()));\n+                } else {\n+                    util::error(fmt!(\"could not remove %s\", path.to_str()));\n+                }\n+            }\n+        }\n+\n+        util::note(fmt!(\"uninstalled %s v%s\", name, package.vers.to_str()));\n+        util::remove_pkg(&package);\n+\n+        true\n+    }\n+\n+    fn unprefer(&self, id: ~str, vers: Option<~str>) -> bool {\n+        let package = match util::get_pkg(id, vers) {\n+            result::Ok(package) => package,\n+            result::Err(err) => {\n+                util::error(err);\n+\n+                return false;\n+            }\n+        };\n+        let name = match util::parse_name(package.id) {\n+            result::Ok(name) => name,\n+            result::Err(err) => {\n+                util::error(err);\n+\n+                return false;\n+            }\n+        };\n+\n+        util::note(fmt!(\"unpreferring %s v%s (%s)\", name,\n+                        package.vers.to_str(), package.id));\n+\n+        let bin_dir = util::root().push(~\"bin\");\n+\n+        for package.bins.each |&bin| {\n+            let path = Path(bin);\n+            let name = str::split_char(path.file_path().to_str(), '-')[0];\n+            let out = bin_dir.push(name);\n+\n+            if os::path_exists(&out) {\n+                if os::remove_file(&out) {\n+                    util::note(fmt!(\"unlinked %s\", out.to_str()));\n+                } else {\n+                    util::error(fmt!(\"could not unlink %s\", out.to_str()));\n+                }\n+            }\n+        }\n+\n+        util::note(fmt!(\"unpreferred %s v%s\", name, package.vers.to_str()));\n+\n+        true\n+    }\n+}\n+\n+pub fn main() {\n+    let args = os::args();\n+    let opts = ~[getopts::optflag(~\"h\"), getopts::optflag(~\"help\"),\n+                 getopts::optflag(~\"j\"), getopts::optflag(~\"json\"),\n+                 getopts::optmulti(~\"c\"), getopts::optmulti(~\"cfg\")];\n+    let matches = &match getopts::getopts(args, opts) {\n+        result::Ok(m) => m,\n+        result::Err(f) => {\n+            util::error(fmt!(\"%s\", getopts::fail_str(f)));\n+\n+            return;\n+        }\n+    };\n+    let help = getopts::opt_present(matches, ~\"h\") ||\n+               getopts::opt_present(matches, ~\"help\");\n+    let json = getopts::opt_present(matches, ~\"j\") ||\n+               getopts::opt_present(matches, ~\"json\");\n+    let cfgs = vec::append(getopts::opt_strs(matches, ~\"cfg\"),\n+                           getopts::opt_strs(matches, ~\"c\"));\n+    let mut args = copy matches.free;\n+\n+    args.shift();\n+\n+    if (args.len() < 1) {\n+        return usage::general();\n+    }\n+\n+    let cmd = args.shift();\n+\n+    if !util::is_cmd(cmd) {\n+        return usage::general();\n+    } else if help {\n+        return match cmd {\n+            ~\"build\" => usage::build(),\n+            ~\"clean\" => usage::clean(),\n+            ~\"do\" => usage::do_cmd(),\n+            ~\"info\" => usage::info(),\n+            ~\"install\" => usage::install(),\n+            ~\"prefer\" => usage::prefer(),\n+            ~\"test\" => usage::test(),\n+            ~\"uninstall\" => usage::uninstall(),\n+            ~\"unprefer\" => usage::unprefer(),\n+            _ => usage::general()\n+        };\n+    }\n+\n+    Ctx {\n+        cfgs: cfgs,\n+        json: json,\n+        mut dep_cache: LinearMap::new()\n+    }.run(cmd, args);\n+}\n+\n+/// A crate is a unit of Rust code to be compiled into a binary or library\n+pub struct Crate {\n+    file: ~str,\n+    flags: ~[~str],\n+    cfgs: ~[~str]\n+}\n+\n+pub struct Listener {\n+    cmds: ~[~str],\n+    cb: fn~()\n+}\n+\n+pub fn run(listeners: ~[Listener]) {\n+    let rcmd = os::args()[2];\n+    let mut found = false;\n+\n+    for listeners.each |listener| {\n+        for listener.cmds.each |&cmd| {\n+            if cmd == rcmd {\n+                (listener.cb)();\n+\n+                found = true;\n+\n+                break;\n+            }\n+        }\n+    }\n+\n+    if !found {\n+        os::set_exit_status(42);\n+    }\n+}\n+\n+pub impl Crate {\n+    pub fn flag(&self, flag: ~str) -> Crate {\n+        Crate {\n+            flags: vec::append(copy self.flags, ~[flag]),\n+            .. copy *self\n+        }\n+    }\n+\n+    pub fn flags(&self, flags: ~[~str]) -> Crate {\n+        Crate {\n+            flags: vec::append(copy self.flags, flags),\n+            .. copy *self\n+        }\n+    }\n+\n+    pub fn cfg(&self, cfg: ~str) -> Crate {\n+        Crate {\n+            cfgs: vec::append(copy self.cfgs, ~[cfg]),\n+            .. copy *self\n+        }\n+    }\n+\n+    pub fn cfgs(&self, cfgs: ~[~str]) -> Crate {\n+        Crate {\n+            cfgs: vec::append(copy self.cfgs, cfgs),\n+            .. copy *self\n+        }\n+    }\n+}\n+\n+/// Create a crate target from a source file\n+pub fn Crate(file: ~str) -> Crate {\n+    Crate {\n+        file: file,\n+        flags: ~[],\n+        cfgs: ~[]\n+    }\n+}\n+\n+/**\n+ * Get the working directory of the package script.\n+ * Assumes that the package script has been compiled\n+ * in is the working directory.\n+ */\n+pub fn work_dir() -> Path {\n+    os::self_exe_path().get()\n+}\n+\n+/**\n+ * Get the source directory of the package (i.e.\n+ * where the crates are located). Assumes\n+ * that the cwd is changed to it before\n+ * running this executable.\n+ */\n+pub fn src_dir() -> Path {\n+    os::getcwd()\n+}\n+\n+/// Build a set of crates, should be called once\n+pub fn build(crates: ~[Crate]) -> bool {\n+    let args = os::args();\n+    let dir = src_dir();\n+    let work_dir = work_dir();\n+    let mut success = true;\n+    let sysroot = Path(args[1]);\n+    let test = args[3] == ~\"true\";\n+\n+    for crates.each |&crate| {\n+        let path = &dir.push_rel(&Path(crate.file)).normalize();\n+\n+        util::note(fmt!(\"compiling %s\", path.to_str()));\n+\n+        success = util::compile_crate(Some(sysroot), path, &work_dir,\n+                                      crate.flags, crate.cfgs,\n+                                      false, test);\n+\n+        if !success { break; }\n+    }\n+\n+    if !success {\n+        os::set_exit_status(101);\n+    }\n+\n+    success\n+}"}, {"sha": "cfda56f777ab2779240573ac6039ec8a826a8cd0", "filename": "src/librustpkg/usage.rs", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/354da4108a483ece3b6424ea7d92e3b6e91d4239/src%2Flibrustpkg%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/354da4108a483ece3b6424ea7d92e3b6e91d4239/src%2Flibrustpkg%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fusage.rs?ref=354da4108a483ece3b6424ea7d92e3b6e91d4239", "patch": "@@ -0,0 +1,121 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::io;\n+\n+pub fn general() {\n+    io::println(~\"Usage: rustpkg [options] <cmd> [args..]\n+\n+Where <cmd> is one of:\n+    build, clean, do, info, install, prefer, test, uninstall, unprefer\n+\n+Options:\n+\n+    -h, --help                  Display this message\n+    <cmd> -h, <cmd> --help      Display help for <cmd>\");\n+}\n+\n+pub fn build() {\n+    io::println(~\"rustpkg [options..] build\n+\n+Build all targets described in the package script in the current\n+directory.\n+\n+Options:\n+    -c, --cfg      Pass a cfg flag to the package script\");\n+}\n+\n+pub fn clean() {\n+    io::println(~\"rustpkg clean\n+\n+Remove all build files in the work cache for the package in the current\n+directory.\");\n+}\n+\n+pub fn do_cmd() {\n+    io::println(~\"rustpkg do <cmd>\n+\n+Runs a command in the package script. You can listen to a command\n+by tagging a function with the attribute `#[pkg_do(cmd)]`.\");\n+}\n+\n+pub fn info() {\n+    io::println(~\"rustpkg [options..] info\n+\n+Probe the package script in the current directory for information.\n+\n+Options:\n+    -j, --json      Output the result as JSON\");\n+}\n+\n+pub fn install() {\n+    io::println(~\"rustpkg [options..] install [url] [target]\n+\n+Install a package from a URL by Git or cURL (FTP, HTTP, etc.).\n+If target is provided, Git will checkout the branch or tag before\n+continuing. If the URL is a TAR file (with or without compression),\n+extract it before installing. If a URL isn't provided, the package will\n+be built and installed from the current directory (which is\n+functionally the same as `rustpkg build` and installing the result).\n+\n+Examples:\n+    rustpkg install\n+    rustpkg install git://github.com/mozilla/servo.git\n+    rustpkg install git://github.com/mozilla/servo.git v0.1.2\n+    rustpkg install http://rust-lang.org/servo-0.1.2.tar.gz\n+\n+Options:\n+    -c, --cfg      Pass a cfg flag to the package script\");\n+}\n+\n+pub fn uninstall() {\n+    io::println(~\"rustpkg uninstall <id|name>[@version]\n+\n+Remove a package by id or name and optionally version. If the package(s)\n+is/are depended on by another package then they cannot be removed.\");\n+}\n+\n+pub fn prefer() {\n+    io::println(~\"rustpkg [options..] prefer <id|name>[@version]\n+\n+By default all binaries are given a unique name so that multiple versions can\n+coexist. The prefer command will symlink the uniquely named binary to\n+the binary directory under its bare name. If version is not supplied, the\n+latest version of the package will be preferred.\n+\n+Example:\n+    export PATH=$PATH:/home/user/.rustpkg/bin\n+    rustpkg prefer machine@1.2.4\n+    machine -v\n+    ==> v1.2.4\n+    rustpkg prefer machine@0.4.6\n+    machine -v\n+    ==> v0.4.6\");\n+}\n+\n+pub fn unprefer() {\n+    io::println(~\"rustpkg [options..] unprefer <id|name>[@version]\n+\n+Remove all symlinks from the store to the binary directory for a package\n+name and optionally version. If version is not supplied, the latest version\n+of the package will be unpreferred. See `rustpkg prefer -h` for more\n+information.\");\n+}\n+\n+pub fn test() {\n+    io::println(~\"rustpkg [options..] test\n+\n+Build all targets described in the package script in the current directory\n+with the test flag. The test bootstraps will be run afterwards and the output\n+and exit code will be redirected.\n+\n+Options:\n+    -c, --cfg      Pass a cfg flag to the package script\");\n+}"}, {"sha": "1ad706742a8f6ec31b4ce44ba059ce2fe337f565", "filename": "src/librustpkg/util.rs", "status": "added", "additions": 803, "deletions": 0, "changes": 803, "blob_url": "https://github.com/rust-lang/rust/blob/354da4108a483ece3b6424ea7d92e3b6e91d4239/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/354da4108a483ece3b6424ea7d92e3b6e91d4239/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=354da4108a483ece3b6424ea7d92e3b6e91d4239", "patch": "@@ -0,0 +1,803 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::*;\n+use hashmap::linear::LinearMap;\n+use rustc::metadata::filesearch;\n+use rustc::driver::{driver, session};\n+use syntax::ast_util::*;\n+use syntax::{ast, attr, codemap, diagnostic, fold, parse, visit};\n+use codemap::{span, dummy_sp, spanned};\n+use std::semver;\n+use std::{json, term, sort, getopts};\n+use getopts::groups::getopts;\n+use Listener;\n+\n+use syntax::ext::base::{mk_ctxt, ext_ctxt};\n+use syntax::ext::build;\n+\n+pub struct Package {\n+    id: ~str,\n+    vers: semver::Version,\n+    bins: ~[~str],\n+    libs: ~[~str],\n+}\n+\n+pub fn root() -> Path {\n+    match filesearch::get_rustpkg_root() {\n+        result::Ok(path) => path,\n+        result::Err(err) => fail!(err)\n+    }\n+}\n+\n+pub fn is_cmd(cmd: ~str) -> bool {\n+    let cmds = &[~\"build\", ~\"clean\", ~\"do\", ~\"info\", ~\"install\", ~\"prefer\",\n+                 ~\"test\", ~\"uninstall\", ~\"unprefer\"];\n+\n+    vec::contains(cmds, &cmd)\n+}\n+\n+pub fn parse_name(id: ~str) -> result::Result<~str, ~str> {\n+    let parts = str::split_char(id, '.');\n+\n+    for parts.each |&part| {\n+        for str::chars(part).each |&char| {\n+            if char::is_whitespace(char) {\n+                return result::Err(\n+                    ~\"could not parse id: contains whitespace\");\n+            } else if char::is_uppercase(char) {\n+                return result::Err(\n+                    ~\"could not parse id: should be all lowercase\");\n+            }\n+        }\n+    }\n+\n+    result::Ok(parts.last())\n+}\n+\n+struct ListenerFn {\n+    cmds: ~[~str],\n+    span: codemap::span,\n+    path: ~[ast::ident]\n+}\n+\n+struct ReadyCtx {\n+    sess: session::Session,\n+    crate: @ast::crate,\n+    ext_cx: ext_ctxt,\n+    mut path: ~[ast::ident],\n+    mut fns: ~[ListenerFn]\n+}\n+\n+fn fold_mod(_ctx: @ReadyCtx, m: ast::_mod,\n+            fold: fold::ast_fold) -> ast::_mod {\n+    fn strip_main(item: @ast::item) -> @ast::item {\n+        @ast::item {\n+            attrs: do item.attrs.filtered |attr| {\n+                attr::get_attr_name(*attr) != ~\"main\"\n+            },\n+            .. copy *item\n+        }\n+    }\n+\n+    fold::noop_fold_mod(ast::_mod {\n+        items: do vec::map(m.items) |item| {\n+            strip_main(*item)\n+        },\n+        .. m\n+    }, fold)\n+}\n+\n+fn fold_item(ctx: @ReadyCtx, item: @ast::item,\n+             fold: fold::ast_fold) -> Option<@ast::item> {\n+\n+    ctx.path.push(item.ident);\n+\n+    let attrs = attr::find_attrs_by_name(item.attrs, ~\"pkg_do\");\n+\n+    if attrs.len() > 0 {\n+        let mut cmds = ~[];\n+\n+        for attrs.each |attr| {\n+            match attr.node.value.node {\n+                ast::meta_list(_, mis) => {\n+                    for mis.each |mi| {\n+                        match mi.node {\n+                            ast::meta_word(cmd) => cmds.push(cmd),\n+                            _ => {}\n+                        };\n+                    }\n+                }\n+                _ => cmds.push(~\"build\")\n+            };\n+        }\n+\n+        ctx.fns.push(ListenerFn {\n+            cmds: cmds,\n+            span: item.span,\n+            path: /*bad*/copy ctx.path\n+        });\n+    }\n+\n+    let res = fold::noop_fold_item(item, fold);\n+\n+    ctx.path.pop();\n+\n+    res\n+}\n+\n+fn add_pkg_module(ctx: @ReadyCtx, m: ast::_mod) -> ast::_mod {\n+    let listeners = mk_listener_vec(ctx);\n+    let ext_cx = ctx.ext_cx;\n+    let item = quote_item! (\n+        mod __pkg {\n+            extern mod rustpkg (vers=\"0.6\");\n+            const listeners : &[rustpkg::Listener] = $listeners;\n+            #[main]\n+            fn main() {\n+                rustpkg::run(listeners);\n+            }\n+        }\n+    );\n+    ast::_mod {\n+        items: vec::append_one(/*bad*/copy m.items, item.get()),\n+        .. m\n+    }\n+}\n+\n+fn mk_listener_vec(ctx: @ReadyCtx) -> @ast::expr {\n+    let fns = ctx.fns;\n+    let descs = do fns.map |listener| {\n+        mk_listener_rec(ctx, *listener)\n+    };\n+    build::mk_slice_vec_e(ctx.ext_cx, dummy_sp(), descs)\n+}\n+\n+fn mk_listener_rec(ctx: @ReadyCtx, listener: ListenerFn) -> @ast::expr {\n+\n+    let span = listener.span;\n+    let cmds = do listener.cmds.map |&cmd| {\n+        build::mk_base_str(ctx.ext_cx, span, cmd)\n+    };\n+\n+    let cmds_expr = build::mk_slice_vec_e(ctx.ext_cx, span, cmds);\n+    let cb_expr = build::mk_path(ctx.ext_cx, span, copy listener.path);\n+    let ext_cx = ctx.ext_cx;\n+\n+    quote_expr!(\n+        Listener {\n+            cmds: $cmds_expr,\n+            cb: $cb_expr\n+        }\n+    )\n+}\n+\n+/// Generate/filter main function, add the list of commands, etc.\n+pub fn ready_crate(sess: session::Session,\n+                   crate: @ast::crate) -> @ast::crate {\n+    let ctx = @ReadyCtx {\n+        sess: sess,\n+        crate: crate,\n+        ext_cx: mk_ctxt(sess.parse_sess, copy sess.opts.cfg),\n+        mut path: ~[],\n+        mut fns: ~[]\n+    };\n+    let precursor = @fold::AstFoldFns {\n+        // fold_crate: fold::wrap(|a, b| fold_crate(ctx, a, b)),\n+        fold_item: |a, b| fold_item(ctx, a, b),\n+        fold_mod: |a, b| fold_mod(ctx, a, b),\n+        .. *fold::default_ast_fold()\n+    };\n+\n+    let fold = fold::make_fold(precursor);\n+\n+    @fold.fold_crate(*crate)\n+}\n+\n+pub fn parse_vers(vers: ~str) -> result::Result<semver::Version, ~str> {\n+    match semver::parse(vers) {\n+        Some(vers) => result::Ok(vers),\n+        None => result::Err(~\"could not parse version: invalid\")\n+    }\n+}\n+\n+pub fn need_dir(s: &Path) {\n+    if !os::path_is_dir(s) && !os::make_dir(s, 493_i32) {\n+        fail!(fmt!(\"can't create dir: %s\", s.to_str()));\n+    }\n+}\n+\n+pub fn note(msg: ~str) {\n+    let out = io::stdout();\n+\n+    if term::color_supported() {\n+        term::fg(out, term::color_green);\n+        out.write_str(~\"note: \");\n+        term::reset(out);\n+        out.write_line(msg);\n+    } else {\n+        out.write_line(~\"note: \" + msg);\n+    }\n+}\n+\n+pub fn warn(msg: ~str) {\n+    let out = io::stdout();\n+\n+    if term::color_supported() {\n+        term::fg(out, term::color_yellow);\n+        out.write_str(~\"warning: \");\n+        term::reset(out);\n+        out.write_line(msg);\n+    } else {\n+        out.write_line(~\"warning: \" + msg);\n+    }\n+}\n+\n+pub fn error(msg: ~str) {\n+    let out = io::stdout();\n+\n+    if term::color_supported() {\n+        term::fg(out, term::color_red);\n+        out.write_str(~\"error: \");\n+        term::reset(out);\n+        out.write_line(msg);\n+    } else {\n+        out.write_line(~\"error: \" + msg);\n+    }\n+}\n+\n+pub fn hash(data: ~str) -> ~str {\n+    let hasher = hash::default_state();\n+\n+    hasher.write_str(data);\n+    hasher.result_str()\n+}\n+\n+pub fn temp_change_dir<T>(dir: &Path, cb: fn() -> T) {\n+    let cwd = os::getcwd();\n+\n+    os::change_dir(dir);\n+    cb();\n+    os::change_dir(&cwd);\n+}\n+\n+pub fn touch(path: &Path) {\n+    match io::mk_file_writer(path, ~[io::Create]) {\n+        result::Ok(writer) => writer.write_line(~\"\"),\n+        _ => {}\n+    }\n+}\n+\n+pub fn remove_dir_r(path: &Path) {\n+    for os::walk_dir(path) |&file| {\n+        let mut cdir = file;\n+\n+        loop {\n+            if os::path_is_dir(&cdir) {\n+                os::remove_dir(&cdir);\n+            } else {\n+                os::remove_file(&cdir);\n+            }\n+\n+            cdir = cdir.dir_path();\n+\n+            if cdir == *path { break; }\n+        }\n+    }\n+\n+    os::remove_dir(path);\n+}\n+\n+pub fn wait_for_lock(path: &Path) {\n+    if os::path_exists(path) {\n+        warn(fmt!(\"the database appears locked, please wait (or rm %s)\",\n+                        path.to_str()));\n+\n+        loop {\n+            if !os::path_exists(path) { break; }\n+        }\n+    }\n+}\n+\n+fn _add_pkg(packages: ~[json::Json], pkg: &Package) -> ~[json::Json] {\n+    for packages.each |&package| {\n+        match &package {\n+            &json::Object(ref map) => {\n+                let mut has_id = false;\n+\n+                match map.get(&~\"id\") {\n+                    &json::String(ref str) => {\n+                        if pkg.id == *str {\n+                            has_id = true;\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+\n+                match map.get(&~\"vers\") {\n+                    &json::String(ref str) => {\n+                        if has_id && pkg.vers.to_str() == *str {\n+                            return copy packages;\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    let mut map = ~LinearMap::new();\n+\n+    map.insert(~\"id\", json::String(pkg.id));\n+    map.insert(~\"vers\", json::String(pkg.vers.to_str()));\n+    map.insert(~\"bins\", json::List(do pkg.bins.map |&bin| {\n+        json::String(bin)\n+    }));\n+    map.insert(~\"libs\", json::List(do pkg.libs.map |&lib| {\n+        json::String(lib)\n+    }));\n+\n+    vec::append(packages, ~[json::Object(map)])\n+}\n+\n+fn _rm_pkg(packages: ~[json::Json], pkg: &Package) -> ~[json::Json] {\n+    do packages.filter_mapped |&package| {\n+        match &package {\n+            &json::Object(ref map) => {\n+                let mut has_id = false;\n+\n+                match map.get(&~\"id\") {\n+                    &json::String(str) => {\n+                        if pkg.id == str {\n+                            has_id = true;\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+\n+                match map.get(&~\"vers\") {\n+                    &json::String(ref str) => {\n+                        if has_id && pkg.vers.to_str() == *str {\n+                            None\n+                        } else {\n+                            Some(copy package)\n+                        }\n+                    }\n+                    _ => { Some(copy package) }\n+                }\n+            }\n+            _ => { Some(copy package) }\n+        }\n+    }\n+}\n+\n+pub fn load_pkgs() -> result::Result<~[json::Json], ~str> {\n+    let root = root();\n+    let db = root.push(~\"db.json\");\n+    let db_lock = root.push(~\"db.json.lck\");\n+\n+    wait_for_lock(&db_lock);\n+    touch(&db_lock);\n+\n+    let packages = if os::path_exists(&db) {\n+        match io::read_whole_file_str(&db) {\n+            result::Ok(str) => {\n+                match json::from_str(str) {\n+                    result::Ok(json) => {\n+                        match json {\n+                            json::List(list) => list,\n+                            _ => {\n+                                os::remove_file(&db_lock);\n+\n+                                return result::Err(\n+                                    ~\"package db's json is not a list\");\n+                            }\n+                        }\n+                    }\n+                    result::Err(err) => {\n+                        os::remove_file(&db_lock);\n+\n+                        return result::Err(\n+                            fmt!(\"failed to parse package db: %s\",\n+                            err.to_str()));\n+                    }\n+                }\n+            }\n+            result::Err(err) => {\n+                os::remove_file(&db_lock);\n+\n+                return result::Err(fmt!(\"failed to read package db: %s\",\n+                                        err));\n+            }\n+        }\n+    } else { ~[] };\n+\n+    os::remove_file(&db_lock);\n+\n+    result::Ok(packages)\n+}\n+\n+pub fn get_pkg(id: ~str,\n+               vers: Option<~str>) -> result::Result<Package, ~str> {\n+    let name = match parse_name(id) {\n+        result::Ok(name) => name,\n+        result::Err(err) => return result::Err(err)\n+    };\n+    let packages = match load_pkgs() {\n+        result::Ok(packages) => packages,\n+        result::Err(err) => return result::Err(err)\n+    };\n+    let mut sel = None;\n+    let mut possibs = ~[];\n+    let mut err = None;\n+\n+    for packages.each |&package| {\n+        match package {\n+            json::Object(map) => {\n+                let pid = match map.get(&~\"id\") {\n+                    &json::String(str) => str,\n+                    _ => loop\n+                };\n+                let pname = match parse_name(pid) {\n+                    result::Ok(pname) => pname,\n+                    result::Err(perr) => {\n+                        err = Some(perr);\n+\n+                        break;\n+                    }\n+                };\n+                let pvers = match map.get(&~\"vers\") {\n+                    &json::String(str) => str,\n+                    _ => loop\n+                };\n+                if pid == id || pname == name {\n+                    let bins = match map.get(&~\"bins\") {\n+                        &json::List(ref list) => {\n+                            do list.map |&bin| {\n+                                match bin {\n+                                    json::String(str) => str,\n+                                    _ => ~\"\"\n+                                }\n+                            }\n+                        }\n+                        _ => ~[]\n+                    };\n+                    let libs = match map.get(&~\"libs\") {\n+                        &json::List(ref list) => {\n+                            do list.map |&lib| {\n+                                match lib {\n+                                    json::String(str) => str,\n+                                    _ => ~\"\"\n+                                }\n+                            }\n+                        }\n+                        _ => ~[]\n+                    };\n+                    let package = Package {\n+                        id: pid,\n+                        vers: match parse_vers(pvers) {\n+                            result::Ok(vers) => vers,\n+                            result::Err(verr) => {\n+                                err = Some(verr);\n+\n+                                break;\n+                            }\n+                        },\n+                        bins: bins,\n+                        libs: libs\n+                    };\n+\n+                    if !vers.is_none() && vers.get() == pvers {\n+                        sel = Some(package);\n+                    }\n+                    else {\n+                        possibs.push(package);\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    if !err.is_none() {\n+        return result::Err(err.get());\n+    }\n+    if !sel.is_none() {\n+        return result::Ok(sel.get());\n+    }\n+    if !vers.is_none() || possibs.len() < 1 {\n+        return result::Err(~\"package not found\");\n+    }\n+\n+    result::Ok(sort::merge_sort(possibs, |v1, v2| {\n+        v1.vers <= v2.vers\n+    }).last())\n+}\n+\n+pub fn add_pkg(pkg: &Package) -> bool {\n+    let root = root();\n+    let db = root.push(~\"db.json\");\n+    let db_lock = root.push(~\"db.json.lck\");\n+    let packages = match load_pkgs() {\n+        result::Ok(packages) => packages,\n+        result::Err(err) => {\n+            error(err);\n+\n+            return false;\n+        }\n+    };\n+\n+    wait_for_lock(&db_lock);\n+    touch(&db_lock);\n+    os::remove_file(&db);\n+\n+    match io::mk_file_writer(&db, ~[io::Create]) {\n+        result::Ok(writer) => {\n+            writer.write_line(json::to_pretty_str(&json::List(\n+                _add_pkg(packages, pkg))));\n+        }\n+        result::Err(err) => {\n+            error(fmt!(\"failed to dump package db: %s\", err));\n+            os::remove_file(&db_lock);\n+\n+            return false;\n+        }\n+    }\n+\n+    os::remove_file(&db_lock);\n+\n+    true\n+}\n+\n+pub fn remove_pkg(pkg: &Package) -> bool {\n+    let root = root();\n+    let db = root.push(~\"db.json\");\n+    let db_lock = root.push(~\"db.json.lck\");\n+    let packages = match load_pkgs() {\n+        result::Ok(packages) => packages,\n+        result::Err(err) => {\n+            error(err);\n+\n+            return false;\n+        }\n+    };\n+\n+    wait_for_lock(&db_lock);\n+    touch(&db_lock);\n+    os::remove_file(&db);\n+\n+    match io::mk_file_writer(&db, ~[io::Create]) {\n+        result::Ok(writer) => {\n+            writer.write_line(json::to_pretty_str(&json::List(\n+                _rm_pkg(packages, pkg))));\n+        }\n+        result::Err(err) => {\n+            error(fmt!(\"failed to dump package db: %s\", err));\n+            os::remove_file(&db_lock);\n+\n+            return false;\n+        }\n+    }\n+\n+    os::remove_file(&db_lock);\n+\n+    true\n+}\n+\n+pub fn compile_input(sysroot: Option<Path>, input: driver::input, dir: &Path,\n+               flags: ~[~str], cfgs: ~[~str], opt: bool, test: bool) -> bool {\n+    let lib_dir = dir.push(~\"lib\");\n+    let bin_dir = dir.push(~\"bin\");\n+    let test_dir = dir.push(~\"test\");\n+    let binary = os::args()[0];\n+    let matches = getopts(flags, driver::optgroups()).get();\n+    let options = @{\n+        crate_type: session::unknown_crate,\n+        optimize: if opt { session::Aggressive } else { session::No },\n+        test: test,\n+        maybe_sysroot: sysroot,\n+        .. *driver::build_session_options(binary, &matches, diagnostic::emit)\n+    };\n+    let mut crate_cfg = options.cfg;\n+\n+    for cfgs.each |&cfg| {\n+        crate_cfg.push(attr::mk_word_item(cfg));\n+    }\n+\n+    let options = @{\n+        cfg: vec::append(options.cfg, crate_cfg),\n+        .. *options\n+    };\n+    let sess = driver::build_session(options, diagnostic::emit);\n+    let cfg = driver::build_configuration(sess, binary, input);\n+    let mut outputs = driver::build_output_filenames(input, &None, &None,\n+                                                     sess);\n+    let {crate, _} = driver::compile_upto(sess, cfg, input, driver::cu_parse,\n+                                          Some(outputs));\n+\n+    let mut name = None;\n+    let mut vers = None;\n+    let mut uuid = None;\n+    let mut crate_type = None;\n+\n+    fn load_link_attr(mis: ~[@ast::meta_item]) -> (Option<~str>,\n+                                                   Option<~str>,\n+                                                   Option<~str>) {\n+        let mut name = None;\n+        let mut vers = None;\n+        let mut uuid = None;\n+\n+        for mis.each |a| {\n+            match a.node {\n+                ast::meta_name_value(v, spanned {node: ast::lit_str(s),\n+                                         span: _}) => {\n+                    match v {\n+                        ~\"name\" => name = Some(*s),\n+                        ~\"vers\" => vers = Some(*s),\n+                        ~\"uuid\" => uuid = Some(*s),\n+                        _ => { }\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        (name, vers, uuid)\n+    }\n+\n+    for crate.node.attrs.each |a| {\n+        match a.node.value.node {\n+            ast::meta_name_value(v, spanned {node: ast::lit_str(s),\n+                                     span: _}) => {\n+                match v {\n+                    ~\"crate_type\" => crate_type = Some(*s),\n+                    _ => {}\n+                }\n+            }\n+            ast::meta_list(v, mis) => {\n+                match v {\n+                    ~\"link\" => {\n+                        let (n, v, u) = load_link_attr(mis);\n+\n+                        name = n;\n+                        vers = v;\n+                        uuid = u;\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    if name.is_none() || vers.is_none() || uuid.is_none() {\n+        error(~\"link attr without (name, vers, uuid) values\");\n+\n+        return false;\n+    }\n+\n+    let name = name.get();\n+    let vers = vers.get();\n+    let uuid = uuid.get();\n+\n+    let is_bin = match crate_type {\n+        Some(crate_type) => {\n+            match crate_type {\n+                ~\"bin\" => true,\n+                ~\"lib\" => false,\n+                _ => {\n+                    warn(~\"unknown crate_type, falling back to lib\");\n+\n+                    false\n+                }\n+            }\n+        }\n+        None => {\n+            warn(~\"missing crate_type attr, assuming lib\");\n+\n+            false\n+        }\n+    };\n+\n+    if test {\n+        need_dir(&test_dir);\n+\n+        outputs = driver::build_output_filenames(input, &Some(test_dir),\n+                                                 &None, sess)\n+    }\n+    else if is_bin {\n+        need_dir(&bin_dir);\n+\n+        let path = bin_dir.push(fmt!(\"%s-%s-%s%s\", name,\n+                                                   hash(name + uuid + vers),\n+                                                   vers, exe_suffix()));\n+        outputs = driver::build_output_filenames(input, &None, &Some(path),\n+                                                 sess);\n+    } else {\n+        need_dir(&lib_dir);\n+\n+        outputs = driver::build_output_filenames(input, &Some(lib_dir),\n+                                                 &None, sess)\n+    }\n+\n+    driver::compile_rest(sess, cfg, driver::cu_everything,\n+                         Some(outputs), Some(crate));\n+\n+    true\n+}\n+\n+#[cfg(windows)]\n+pub fn exe_suffix() -> ~str { ~\".exe\" }\n+\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"android\")]\n+#[cfg(target_os = \"freebsd\")]\n+#[cfg(target_os = \"macos\")]\n+pub fn exe_suffix() -> ~str { ~\"\" }\n+\n+\n+// FIXME (#4432): Use workcache to only compile when needed\n+pub fn compile_crate(sysroot: Option<Path>, crate: &Path, dir: &Path,\n+                     flags: ~[~str], cfgs: ~[~str], opt: bool,\n+                     test: bool) -> bool {\n+    compile_input(sysroot, driver::file_input(*crate), dir, flags, cfgs,\n+                  opt, test)\n+}\n+\n+pub fn compile_str(sysroot: Option<Path>, code: ~str, dir: &Path,\n+                   flags: ~[~str], cfgs: ~[~str], opt: bool,\n+                   test: bool) -> bool {\n+    compile_input(sysroot, driver::str_input(code), dir, flags, cfgs,\n+                  opt, test)\n+}\n+\n+#[cfg(windows)]\n+pub fn link_exe(_src: &Path, _dest: &Path) -> bool {\n+    /* FIXME (#1768): Investigate how to do this on win32\n+       Node wraps symlinks by having a .bat,\n+       but that won't work with minGW. */\n+\n+    false\n+}\n+\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"android\")]\n+#[cfg(target_os = \"freebsd\")]\n+#[cfg(target_os = \"macos\")]\n+pub fn link_exe(src: &Path, dest: &Path) -> bool {\n+    unsafe {\n+        do str::as_c_str(src.to_str()) |src_buf| {\n+            do str::as_c_str(dest.to_str()) |dest_buf| {\n+                libc::link(src_buf, dest_buf) == 0 as libc::c_int &&\n+                    libc::chmod(dest_buf, 755) == 0 as libc::c_int\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_is_cmd() {\n+    assert is_cmd(~\"build\");\n+    assert is_cmd(~\"clean\");\n+    assert is_cmd(~\"do\");\n+    assert is_cmd(~\"info\");\n+    assert is_cmd(~\"install\");\n+    assert is_cmd(~\"prefer\");\n+    assert is_cmd(~\"test\");\n+    assert is_cmd(~\"uninstall\");\n+    assert is_cmd(~\"unprefer\");\n+}\n+\n+#[test]\n+fn test_parse_name() {\n+    assert parse_name(~\"org.mozilla.servo\").get() == ~\"servo\";\n+    assert parse_name(~\"org. mozilla.servo 2131\").is_err();\n+}"}, {"sha": "97c60330a7e31d60f290e73ec0a4340678074b03", "filename": "src/libstd/semver.rs", "status": "added", "additions": 395, "deletions": 0, "changes": 395, "blob_url": "https://github.com/rust-lang/rust/blob/354da4108a483ece3b6424ea7d92e3b6e91d4239/src%2Flibstd%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/354da4108a483ece3b6424ea7d92e3b6e91d4239/src%2Flibstd%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsemver.rs?ref=354da4108a483ece3b6424ea7d92e3b6e91d4239", "patch": "@@ -0,0 +1,395 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Semver parsing and logic\n+\n+use io;\n+use io::{ReaderUtil};\n+use option::{Option, Some, None};\n+use uint;\n+use str;\n+use to_str::ToStr;\n+use char;\n+use core::cmp;\n+\n+#[deriving_eq]\n+pub enum Identifier {\n+    Numeric(uint),\n+    AlphaNumeric(~str)\n+}\n+\n+impl cmp::Ord for Identifier {\n+    #[inline(always)]\n+    pure fn lt(&self, other: &Identifier) -> bool {\n+        match (self, other) {\n+            (&Numeric(a), &Numeric(b)) => a < b,\n+            (&Numeric(_), _) => true,\n+            (&AlphaNumeric(ref a), &AlphaNumeric(ref b)) => *a < *b,\n+            (&AlphaNumeric(_), _) => false\n+        }\n+    }\n+    #[inline(always)]\n+    pure fn le(&self, other: &Identifier) -> bool {\n+        ! (other < self)\n+    }\n+    #[inline(always)]\n+    pure fn gt(&self, other: &Identifier) -> bool {\n+        other < self\n+    }\n+    #[inline(always)]\n+    pure fn ge(&self, other: &Identifier) -> bool {\n+        ! (self < other)\n+    }\n+}\n+\n+impl ToStr for Identifier {\n+    #[inline(always)]\n+    pure fn to_str(&self) -> ~str {\n+        match self {\n+            &Numeric(n) => n.to_str(),\n+            &AlphaNumeric(ref s) => s.to_str()\n+        }\n+    }\n+}\n+\n+\n+#[deriving_eq]\n+pub struct Version {\n+    major: uint,\n+    minor: uint,\n+    patch: uint,\n+    pre: ~[Identifier],\n+    build: ~[Identifier],\n+}\n+\n+impl ToStr for Version {\n+    #[inline(always)]\n+    pure fn to_str(&self) -> ~str {\n+        let s = fmt!(\"%u.%u.%u\", self.major, self.minor, self.patch);\n+        let s = if self.pre.is_empty() {\n+            s\n+        } else {\n+            s + \"-\" + str::connect(self.pre.map(|i| i.to_str()), \".\")\n+        };\n+        if self.build.is_empty() {\n+            s\n+        } else {\n+            s + \"+\" + str::connect(self.build.map(|i| i.to_str()), \".\")\n+        }\n+    }\n+}\n+\n+impl cmp::Ord for Version {\n+    #[inline(always)]\n+    pure fn lt(&self, other: &Version) -> bool {\n+\n+        self.major < other.major ||\n+\n+            (self.major == other.major &&\n+             self.minor < other.minor) ||\n+\n+            (self.major == other.major &&\n+             self.minor == other.minor &&\n+             self.patch < other.patch) ||\n+\n+            (self.major == other.major &&\n+             self.minor == other.minor &&\n+             self.patch == other.patch &&\n+             // NB: semver spec says 0.0.0-pre < 0.0.0\n+             // but the version of ord defined for vec\n+             // says that [] < [pre], so we alter it\n+             // here.\n+             (match (self.pre.len(), other.pre.len()) {\n+                 (0, 0) => false,\n+                 (0, _) => false,\n+                 (_, 0) => true,\n+                 (_, _) => self.pre < other.pre\n+             })) ||\n+\n+            (self.major == other.major &&\n+             self.minor == other.minor &&\n+             self.patch == other.patch &&\n+             self.pre == other.pre &&\n+             self.build < other.build)\n+    }\n+\n+    #[inline(always)]\n+    pure fn le(&self, other: &Version) -> bool {\n+        ! (other < self)\n+    }\n+    #[inline(always)]\n+    pure fn gt(&self, other: &Version) -> bool {\n+        other < self\n+    }\n+    #[inline(always)]\n+    pure fn ge(&self, other: &Version) -> bool {\n+        ! (self < other)\n+    }\n+}\n+\n+condition! {\n+    bad_parse: () -> ();\n+}\n+\n+fn take_nonempty_prefix(rdr: io::Reader,\n+                        ch: char,\n+                        pred: fn(char) -> bool) -> (~str, char) {\n+    let mut buf = ~\"\";\n+    let mut ch = ch;\n+    while pred(ch) {\n+        str::push_char(&mut buf, ch);\n+        ch = rdr.read_char();\n+    }\n+    if buf.is_empty() {\n+        bad_parse::cond.raise(())\n+    }\n+    debug!(\"extracted nonempty prefix: %s\", buf);\n+    (buf, ch)\n+}\n+\n+fn take_num(rdr: io::Reader, ch: char) -> (uint, char) {\n+    let (s, ch) = take_nonempty_prefix(rdr, ch, char::is_digit);\n+    match uint::from_str(s) {\n+        None => { bad_parse::cond.raise(()); (0, ch) },\n+        Some(i) => (i, ch)\n+    }\n+}\n+\n+fn take_ident(rdr: io::Reader, ch: char) -> (Identifier, char) {\n+    let (s,ch) = take_nonempty_prefix(rdr, ch, char::is_alphanumeric);\n+    if s.all(char::is_digit) {\n+        match uint::from_str(s) {\n+            None => { bad_parse::cond.raise(()); (Numeric(0), ch) },\n+            Some(i) => (Numeric(i), ch)\n+        }\n+    } else {\n+        (AlphaNumeric(s), ch)\n+    }\n+}\n+\n+fn expect(ch: char, c: char) {\n+    if ch != c {\n+        bad_parse::cond.raise(())\n+    }\n+}\n+\n+fn parse_reader(rdr: io::Reader) -> Version {\n+\n+    let (major, ch) = take_num(rdr, rdr.read_char());\n+    expect(ch, '.');\n+    let (minor, ch) = take_num(rdr, rdr.read_char());\n+    expect(ch, '.');\n+    let (patch, ch) = take_num(rdr, rdr.read_char());\n+\n+    let mut pre = ~[];\n+    let mut build = ~[];\n+\n+    let mut ch = ch;\n+    if ch == '-' {\n+        loop {\n+            let (id, c) = take_ident(rdr, rdr.read_char());\n+            pre.push(id);\n+            ch = c;\n+            if ch != '.' { break; }\n+        }\n+    }\n+\n+    if ch == '+' {\n+        loop {\n+            let (id, c) = take_ident(rdr, rdr.read_char());\n+            build.push(id);\n+            ch = c;\n+            if ch != '.' { break; }\n+        }\n+    }\n+\n+    Version {\n+        major: major,\n+        minor: minor,\n+        patch: patch,\n+        pre: pre,\n+        build: build,\n+    }\n+}\n+\n+\n+pub fn parse(s: &str) -> Option<Version> {\n+    if ! str::is_ascii(s) {\n+        return None;\n+    }\n+    let s = s.trim();\n+    let mut bad = false;\n+    do bad_parse::cond.trap(|_| { debug!(\"bad\"); bad = true }).in {\n+        do io::with_str_reader(s) |rdr| {\n+            let v = parse_reader(rdr);\n+            if bad || v.to_str() != s {\n+                None\n+            } else {\n+                Some(v)\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_parse() {\n+    assert parse(\"\") == None;\n+    assert parse(\"  \") == None;\n+    assert parse(\"1\") == None;\n+    assert parse(\"1.2\") == None;\n+    assert parse(\"1.2\") == None;\n+    assert parse(\"1\") == None;\n+    assert parse(\"1.2\") == None;\n+    assert parse(\"1.2.3-\") == None;\n+    assert parse(\"a.b.c\") == None;\n+    assert parse(\"1.2.3 abc\") == None;\n+\n+    assert parse(\"1.2.3\") == Some(Version {\n+        major: 1u,\n+        minor: 2u,\n+        patch: 3u,\n+        pre: ~[],\n+        build: ~[],\n+    });\n+    assert parse(\"  1.2.3  \") == Some(Version {\n+        major: 1u,\n+        minor: 2u,\n+        patch: 3u,\n+        pre: ~[],\n+        build: ~[],\n+    });\n+    assert parse(\"1.2.3-alpha1\") == Some(Version {\n+        major: 1u,\n+        minor: 2u,\n+        patch: 3u,\n+        pre: ~[AlphaNumeric(~\"alpha1\")],\n+        build: ~[]\n+    });\n+    assert parse(\"  1.2.3-alpha1  \") == Some(Version {\n+        major: 1u,\n+        minor: 2u,\n+        patch: 3u,\n+        pre: ~[AlphaNumeric(~\"alpha1\")],\n+        build: ~[]\n+    });\n+    assert parse(\"1.2.3+build5\") == Some(Version {\n+        major: 1u,\n+        minor: 2u,\n+        patch: 3u,\n+        pre: ~[],\n+        build: ~[AlphaNumeric(~\"build5\")]\n+    });\n+    assert parse(\"  1.2.3+build5  \") == Some(Version {\n+        major: 1u,\n+        minor: 2u,\n+        patch: 3u,\n+        pre: ~[],\n+        build: ~[AlphaNumeric(~\"build5\")]\n+    });\n+    assert parse(\"1.2.3-alpha1+build5\") == Some(Version {\n+        major: 1u,\n+        minor: 2u,\n+        patch: 3u,\n+        pre: ~[AlphaNumeric(~\"alpha1\")],\n+        build: ~[AlphaNumeric(~\"build5\")]\n+    });\n+    assert parse(\"  1.2.3-alpha1+build5  \") == Some(Version {\n+        major: 1u,\n+        minor: 2u,\n+        patch: 3u,\n+        pre: ~[AlphaNumeric(~\"alpha1\")],\n+        build: ~[AlphaNumeric(~\"build5\")]\n+    });\n+    assert parse(\"1.2.3-1.alpha1.9+build5.7.3aedf  \") == Some(Version {\n+        major: 1u,\n+        minor: 2u,\n+        patch: 3u,\n+        pre: ~[Numeric(1),AlphaNumeric(~\"alpha1\"),Numeric(9)],\n+        build: ~[AlphaNumeric(~\"build5\"),\n+                 Numeric(7),\n+                 AlphaNumeric(~\"3aedf\")]\n+    });\n+\n+}\n+\n+#[test]\n+fn test_eq() {\n+    assert parse(\"1.2.3\")        == parse(\"1.2.3\");\n+    assert parse(\"1.2.3-alpha1\") == parse(\"1.2.3-alpha1\");\n+}\n+\n+#[test]\n+fn test_ne() {\n+    assert parse(\"0.0.0\")       != parse(\"0.0.1\");\n+    assert parse(\"0.0.0\")       != parse(\"0.1.0\");\n+    assert parse(\"0.0.0\")       != parse(\"1.0.0\");\n+    assert parse(\"1.2.3-alpha\") != parse(\"1.2.3-beta\");\n+}\n+\n+#[test]\n+fn test_lt() {\n+    assert parse(\"0.0.0\")        < parse(\"1.2.3-alpha2\");\n+    assert parse(\"1.0.0\")        < parse(\"1.2.3-alpha2\");\n+    assert parse(\"1.2.0\")        < parse(\"1.2.3-alpha2\");\n+    assert parse(\"1.2.3-alpha1\") < parse(\"1.2.3\");\n+    assert parse(\"1.2.3-alpha1\") < parse(\"1.2.3-alpha2\");\n+    assert !(parse(\"1.2.3-alpha2\") < parse(\"1.2.3-alpha2\"));\n+}\n+\n+#[test]\n+fn test_le() {\n+    assert parse(\"0.0.0\")        <= parse(\"1.2.3-alpha2\");\n+    assert parse(\"1.0.0\")        <= parse(\"1.2.3-alpha2\");\n+    assert parse(\"1.2.0\")        <= parse(\"1.2.3-alpha2\");\n+    assert parse(\"1.2.3-alpha1\") <= parse(\"1.2.3-alpha2\");\n+    assert parse(\"1.2.3-alpha2\") <= parse(\"1.2.3-alpha2\");\n+}\n+\n+#[test]\n+fn test_gt() {\n+    assert parse(\"1.2.3-alpha2\") > parse(\"0.0.0\");\n+    assert parse(\"1.2.3-alpha2\") > parse(\"1.0.0\");\n+    assert parse(\"1.2.3-alpha2\") > parse(\"1.2.0\");\n+    assert parse(\"1.2.3-alpha2\") > parse(\"1.2.3-alpha1\");\n+    assert parse(\"1.2.3\")        > parse(\"1.2.3-alpha2\");\n+    assert !(parse(\"1.2.3-alpha2\") > parse(\"1.2.3-alpha2\"));\n+}\n+\n+#[test]\n+fn test_ge() {\n+    assert parse(\"1.2.3-alpha2\") >= parse(\"0.0.0\");\n+    assert parse(\"1.2.3-alpha2\") >= parse(\"1.0.0\");\n+    assert parse(\"1.2.3-alpha2\") >= parse(\"1.2.0\");\n+    assert parse(\"1.2.3-alpha2\") >= parse(\"1.2.3-alpha1\");\n+    assert parse(\"1.2.3-alpha2\") >= parse(\"1.2.3-alpha2\");\n+}\n+\n+#[test]\n+fn test_spec_order() {\n+\n+    let vs = [\"1.0.0-alpha\",\n+              \"1.0.0-alpha.1\",\n+              \"1.0.0-beta.2\",\n+              \"1.0.0-beta.11\",\n+              \"1.0.0-rc.1\",\n+              \"1.0.0-rc.1+build.1\",\n+              \"1.0.0\",\n+              \"1.0.0+0.3.7\",\n+              \"1.3.7+build\",\n+              \"1.3.7+build.2.b8f12d7\",\n+              \"1.3.7+build.11.e0f985a\"];\n+    let mut i = 1;\n+    while i < vs.len() {\n+        let a = parse(vs[i-1]).get();\n+        let b = parse(vs[i]).get();\n+        assert a < b;\n+        i += 1;\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "b0756104fe5324a4a582e30341bbdeef0cf51987", "filename": "src/libstd/std.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/354da4108a483ece3b6424ea7d92e3b6e91d4239/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/354da4108a483ece3b6424ea7d92e3b6e91d4239/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=354da4108a483ece3b6424ea7d92e3b6e91d4239", "patch": "@@ -99,6 +99,7 @@ pub mod rl;\n pub mod workcache;\n pub mod bigint;\n pub mod stats;\n+pub mod semver;\n \n #[cfg(unicode)]\n mod unicode;"}]}