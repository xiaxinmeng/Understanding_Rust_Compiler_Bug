{"sha": "e1eca0a1103afa6ba87ee3e23a921ed8faf4c130", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxZWNhMGExMTAzYWZhNmJhODdlZTNlMjNhOTIxZWQ4ZmFmNGMxMzA=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-04-21T13:15:56Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-07T04:19:10Z"}, "message": "Translate constants from MIR instead of going through trans::expr/consts.", "tree": {"sha": "52efbea83fa398f4bc3faa116544cd7268b18334", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52efbea83fa398f4bc3faa116544cd7268b18334"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1eca0a1103afa6ba87ee3e23a921ed8faf4c130", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1eca0a1103afa6ba87ee3e23a921ed8faf4c130", "html_url": "https://github.com/rust-lang/rust/commit/e1eca0a1103afa6ba87ee3e23a921ed8faf4c130", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1eca0a1103afa6ba87ee3e23a921ed8faf4c130/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4639128d4099352345f3226ed8e664acdad7e8c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/4639128d4099352345f3226ed8e664acdad7e8c9", "html_url": "https://github.com/rust-lang/rust/commit/4639128d4099352345f3226ed8e664acdad7e8c9"}], "stats": {"total": 1009, "additions": 858, "deletions": 151}, "files": [{"sha": "09d38e8946bbdc5e090e5aec803680e3d875fbac", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/e1eca0a1103afa6ba87ee3e23a921ed8faf4c130/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1eca0a1103afa6ba87ee3e23a921ed8faf4c130/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=e1eca0a1103afa6ba87ee3e23a921ed8faf4c130", "patch": "@@ -39,7 +39,7 @@ use rustc::ty::adjustment::{AdjustUnsafeFnPointer, AdjustMutToConstPointer};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::cast::{CastTy,IntTy};\n use util::nodemap::NodeMap;\n-use rustc_const_math::{ConstInt, ConstMathErr, ConstUsize, ConstIsize};\n+use rustc_const_math::{ConstInt, ConstUsize, ConstIsize};\n \n use rustc::hir;\n \n@@ -48,6 +48,7 @@ use std::borrow::Cow;\n use libc::c_uint;\n use syntax::ast::{self, LitKind};\n use syntax::attr::{self, AttrMetaMethods};\n+use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::ptr::P;\n \n@@ -110,11 +111,11 @@ pub fn ptrcast(val: ValueRef, ty: Type) -> ValueRef {\n     }\n }\n \n-fn addr_of_mut(ccx: &CrateContext,\n-               cv: ValueRef,\n-               align: machine::llalign,\n-               kind: &str)\n-               -> ValueRef {\n+pub fn addr_of_mut(ccx: &CrateContext,\n+                   cv: ValueRef,\n+                   align: machine::llalign,\n+                   kind: &str)\n+                    -> ValueRef {\n     unsafe {\n         // FIXME: this totally needs a better name generation scheme, perhaps a simple global\n         // counter? Also most other uses of gensym in trans.\n@@ -158,13 +159,13 @@ pub fn addr_of(ccx: &CrateContext,\n }\n \n /// Deref a constant pointer\n-fn load_const(cx: &CrateContext, v: ValueRef, t: Ty) -> ValueRef {\n+pub fn load_const(cx: &CrateContext, v: ValueRef, t: Ty) -> ValueRef {\n     let v = match cx.const_unsized().borrow().get(&v) {\n         Some(&v) => v,\n         None => v\n     };\n     let d = unsafe { llvm::LLVMGetInitializer(v) };\n-    if t.is_bool() {\n+    if !d.is_null() && t.is_bool() {\n         unsafe { llvm::LLVMConstTrunc(d, Type::i1(cx).to_ref()) }\n     } else {\n         d\n@@ -466,16 +467,12 @@ fn check_unary_expr_validity(cx: &CrateContext, e: &hir::Expr, t: Ty,\n             Some(v) => v,\n             None => return Ok(()),\n         };\n-        match -cval {\n-            Ok(_) => return Ok(()),\n-            Err(err) => const_err(cx, e, Err(err), trueconst),\n-        }\n-    } else {\n-        Ok(())\n+        const_err(cx, e.span, (-cval).map_err(ErrKind::Math), trueconst)?;\n     }\n+    Ok(())\n }\n \n-fn to_const_int(value: ValueRef, t: Ty, tcx: &TyCtxt) -> Option<ConstInt> {\n+pub fn to_const_int(value: ValueRef, t: Ty, tcx: &TyCtxt) -> Option<ConstInt> {\n     match t.sty {\n         ty::TyInt(int_type) => const_to_opt_int(value).and_then(|input| match int_type {\n             ast::IntTy::I8 => {\n@@ -523,24 +520,21 @@ fn to_const_int(value: ValueRef, t: Ty, tcx: &TyCtxt) -> Option<ConstInt> {\n     }\n }\n \n-fn const_err(cx: &CrateContext,\n-             e: &hir::Expr,\n-             result: Result<ConstInt, ConstMathErr>,\n-             trueconst: TrueConst)\n-             -> Result<(), ConstEvalFailure> {\n+pub fn const_err<T>(cx: &CrateContext,\n+                    span: Span,\n+                    result: Result<T, ErrKind>,\n+                    trueconst: TrueConst)\n+                    -> Result<T, ConstEvalFailure> {\n     match (result, trueconst) {\n-        (Ok(_), _) => {\n-            // We do not actually care about a successful result.\n-            Ok(())\n-        },\n+        (Ok(x), _) => Ok(x),\n         (Err(err), TrueConst::Yes) => {\n-            let err = ConstEvalErr{ span: e.span, kind: ErrKind::Math(err) };\n-            cx.tcx().sess.span_err(e.span, &err.description());\n+            let err = ConstEvalErr{ span: span, kind: err };\n+            cx.tcx().sess.span_err(span, &err.description());\n             Err(Compiletime(err))\n         },\n         (Err(err), TrueConst::No) => {\n-            let err = ConstEvalErr{ span: e.span, kind: ErrKind::Math(err) };\n-            cx.tcx().sess.span_warn(e.span, &err.description());\n+            let err = ConstEvalErr{ span: span, kind: err };\n+            cx.tcx().sess.span_warn(span, &err.description());\n             Err(Runtime(err))\n         },\n     }\n@@ -564,7 +558,8 @@ fn check_binary_expr_validity(cx: &CrateContext, e: &hir::Expr, t: Ty,\n         hir::BiShr => lhs >> rhs,\n         _ => return Ok(()),\n     };\n-    const_err(cx, e, result, trueconst)\n+    const_err(cx, e.span, result.map_err(ErrKind::Math), trueconst)?;\n+    Ok(())\n }\n \n fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n@@ -719,8 +714,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             if iv >= len {\n                 // FIXME #3170: report this earlier on in the const-eval\n                 // pass. Reporting here is a bit late.\n-                span_err!(cx.sess(), e.span, E0515,\n-                          \"const index-expr is out of bounds\");\n+                const_err(cx, e.span, Err(ErrKind::IndexOutOfBounds), trueconst)?;\n                 C_undef(val_ty(arr).element_type())\n             } else {\n                 const_get_elt(arr, &[iv as c_uint])\n@@ -1128,6 +1122,7 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n     };\n \n     ccx.instances().borrow_mut().insert(instance, g);\n+    ccx.statics().borrow_mut().insert(g, def_id);\n     Datum::new(g, ty, Lvalue::new(\"static\"))\n }\n \n@@ -1147,14 +1142,20 @@ pub fn trans_static(ccx: &CrateContext,\n         let def_id = ccx.tcx().map.local_def_id(id);\n         let datum = get_static(ccx, def_id);\n \n-        let empty_substs = ccx.tcx().mk_substs(Substs::empty());\n-        let (v, _) = const_expr(\n-            ccx,\n-            expr,\n-            empty_substs,\n-            None,\n-            TrueConst::Yes,\n-        ).map_err(|e| e.into_inner())?;\n+        let check_attrs = |attrs: &[ast::Attribute]| {\n+            let default_to_mir = ccx.sess().opts.debugging_opts.orbit;\n+            let invert = if default_to_mir { \"rustc_no_mir\" } else { \"rustc_mir\" };\n+            default_to_mir ^ attrs.iter().any(|item| item.check_name(invert))\n+        };\n+        let use_mir = check_attrs(ccx.tcx().map.attrs(id));\n+\n+        let v = if use_mir {\n+            ::mir::trans_static_initializer(ccx, def_id)\n+        } else {\n+            let empty_substs = ccx.tcx().mk_substs(Substs::empty());\n+            const_expr(ccx, expr, empty_substs, None, TrueConst::Yes)\n+                .map(|(v, _)| v)\n+        }.map_err(|e| e.into_inner())?;\n \n         // boolean SSA values are i1, but they have to be stored in i8 slots,\n         // otherwise some LLVM optimization passes don't work as expected"}, {"sha": "2ee880fa3d8500c96d2d03641b14fe76a8d817a7", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1eca0a1103afa6ba87ee3e23a921ed8faf4c130/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1eca0a1103afa6ba87ee3e23a921ed8faf4c130/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=e1eca0a1103afa6ba87ee3e23a921ed8faf4c130", "patch": "@@ -131,6 +131,9 @@ pub struct LocalCrateContext<'tcx> {\n     /// Cache of external const values\n     extern_const_values: RefCell<DefIdMap<ValueRef>>,\n \n+    /// Mapping from static definitions to their DefId's.\n+    statics: RefCell<FnvHashMap<ValueRef, DefId>>,\n+\n     impl_method_cache: RefCell<FnvHashMap<(DefId, ast::Name), DefId>>,\n \n     /// Cache of closure wrappers for bare fn's.\n@@ -495,6 +498,7 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 const_globals: RefCell::new(FnvHashMap()),\n                 const_values: RefCell::new(FnvHashMap()),\n                 extern_const_values: RefCell::new(DefIdMap()),\n+                statics: RefCell::new(FnvHashMap()),\n                 impl_method_cache: RefCell::new(FnvHashMap()),\n                 closure_bare_wrapper_cache: RefCell::new(FnvHashMap()),\n                 statics_to_rauw: RefCell::new(Vec::new()),\n@@ -699,6 +703,10 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.extern_const_values\n     }\n \n+    pub fn statics<'a>(&'a self) -> &'a RefCell<FnvHashMap<ValueRef, DefId>> {\n+        &self.local.statics\n+    }\n+\n     pub fn impl_method_cache<'a>(&'a self)\n             -> &'a RefCell<FnvHashMap<(DefId, ast::Name), DefId>> {\n         &self.local.impl_method_cache"}, {"sha": "d9de673db27caba2d9dbc5d46e29b2b827095863", "filename": "src/librustc_trans/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e1eca0a1103afa6ba87ee3e23a921ed8faf4c130/src%2Flibrustc_trans%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1eca0a1103afa6ba87ee3e23a921ed8faf4c130/src%2Flibrustc_trans%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdiagnostics.rs?ref=e1eca0a1103afa6ba87ee3e23a921ed8faf4c130", "patch": "@@ -82,19 +82,4 @@ extern \"platform-intrinsic\" {\n unsafe { simd_add(i32x1(0), i32x1(1)); } // ok!\n ```\n \"##,\n-\n-E0515: r##\"\n-A constant index expression was out of bounds. Erroneous code example:\n-\n-```compile_fail\n-let x = &[0, 1, 2][7]; // error: const index-expr is out of bounds\n-```\n-\n-Please specify a valid index (not inferior to 0 or superior to array length).\n-Example:\n-\n-```\n-let x = &[0, 1, 2][2]; // ok\n-```\n-\"##,\n }"}, {"sha": "d2e47a5f92bb462bd566048ef8d81da03cc16e5d", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e1eca0a1103afa6ba87ee3e23a921ed8faf4c130/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1eca0a1103afa6ba87ee3e23a921ed8faf4c130/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=e1eca0a1103afa6ba87ee3e23a921ed8faf4c130", "patch": "@@ -114,9 +114,16 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let discr = bcx.with_block(|bcx| base::to_immediate(bcx, discr, switch_ty));\n                 let switch = bcx.switch(discr, self.llblock(*otherwise), values.len());\n                 for (value, target) in values.iter().zip(targets) {\n-                    let llval = self.trans_constval(&bcx, value, switch_ty).immediate();\n+                    let constant = mir::Constant {\n+                        literal: mir::Literal::Value {\n+                            value: value.clone()\n+                        },\n+                        ty: switch_ty,\n+                        span: terminator.span\n+                    };\n+                    let val = self.trans_constant(&bcx, &constant).immediate();\n                     let llbb = self.llblock(*target);\n-                    build::AddCase(switch, llval, llbb)\n+                    build::AddCase(switch, val, llbb)\n                 }\n             }\n "}, {"sha": "22e4ab1dd89509d40ab95af492a18fee68225543", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 765, "deletions": 65, "changes": 830, "blob_url": "https://github.com/rust-lang/rust/blob/e1eca0a1103afa6ba87ee3e23a921ed8faf4c130/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1eca0a1103afa6ba87ee3e23a921ed8faf4c130/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=e1eca0a1103afa6ba87ee3e23a921ed8faf4c130", "patch": "@@ -8,62 +8,59 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::ValueRef;\n-use rustc::ty::{Ty, TypeFoldable};\n+use llvm::{self, ValueRef};\n use rustc::middle::const_val::ConstVal;\n+use rustc_const_eval::ErrKind;\n use rustc_const_math::ConstInt::*;\n-use rustc_const_eval::lookup_const_by_id;\n+use rustc::hir::def_id::DefId;\n use rustc::mir::repr as mir;\n-use abi;\n-use common::{self, BlockAndBuilder, C_bool, C_bytes, C_floating_f64, C_integral,\n-                    C_str_slice, C_undef};\n-use consts;\n-use datum;\n-use expr;\n+use rustc::mir::tcx::LvalueTy;\n+use rustc::traits;\n+use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::cast::{CastTy, IntTy};\n+use rustc::ty::subst::Substs;\n+use {abi, adt, base, Disr};\n+use callee::Callee;\n+use common::{self, BlockAndBuilder, CrateContext, const_get_elt, val_ty};\n+use common::{C_array, C_bool, C_bytes, C_floating_f64, C_integral};\n+use common::{C_null, C_struct, C_str_slice, C_undef, C_uint};\n+use consts::{self, ConstEvalFailure, TrueConst, to_const_int};\n+use monomorphize::{self, Instance};\n use type_of;\n use type_::Type;\n+use value::Value;\n \n-use super::operand::{OperandRef, OperandValue};\n-use super::MirContext;\n+use syntax::codemap::{Span, DUMMY_SP};\n \n+use std::ptr;\n \n-impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n-    pub fn trans_constval(&mut self,\n-                          bcx: &BlockAndBuilder<'bcx, 'tcx>,\n-                          cv: &ConstVal,\n-                          ty: Ty<'tcx>)\n-                          -> OperandRef<'tcx>\n-    {\n-        let ccx = bcx.ccx();\n-        let val = self.trans_constval_inner(bcx, cv, ty);\n-        let val = if common::type_is_immediate(ccx, ty) {\n-            OperandValue::Immediate(val)\n-        } else if common::type_is_fat_ptr(bcx.tcx(), ty) {\n-            let data = common::const_get_elt(val, &[abi::FAT_PTR_ADDR as u32]);\n-            let extra = common::const_get_elt(val, &[abi::FAT_PTR_EXTRA as u32]);\n-            OperandValue::FatPtr(data, extra)\n-        } else {\n-            OperandValue::Ref(val)\n-        };\n+use super::operand::{OperandRef, OperandValue};\n+use super::{CachedMir, MirContext};\n \n-        assert!(!ty.has_erasable_regions());\n+/// A sized constant rvalue.\n+/// The LLVM type might not be the same for a single Rust type,\n+/// e.g. each enum variant would have its own LLVM struct type.\n+#[derive(Copy, Clone)]\n+struct Const<'tcx> {\n+    llval: ValueRef,\n+    ty: Ty<'tcx>\n+}\n \n-        OperandRef {\n-            ty: ty,\n-            val: val\n+impl<'tcx> Const<'tcx> {\n+    fn new(llval: ValueRef, ty: Ty<'tcx>) -> Const<'tcx> {\n+        Const {\n+            llval: llval,\n+            ty: ty\n         }\n     }\n \n-    /// Translate ConstVal into a bare LLVM ValueRef.\n-    fn trans_constval_inner(&mut self,\n-                            bcx: &BlockAndBuilder<'bcx, 'tcx>,\n-                            cv: &ConstVal,\n-                            ty: Ty<'tcx>)\n-                            -> ValueRef\n-    {\n-        let ccx = bcx.ccx();\n+    /// Translate ConstVal into a LLVM constant value.\n+    fn from_constval<'a>(ccx: &CrateContext<'a, 'tcx>,\n+                         cv: ConstVal,\n+                         ty: Ty<'tcx>)\n+                         -> Const<'tcx> {\n         let llty = type_of::type_of(ccx, ty);\n-        match *cv {\n+        let val = match cv {\n             ConstVal::Float(v) => C_floating_f64(v, llty),\n             ConstVal::Bool(v) => C_bool(ccx, v),\n             ConstVal::Integral(I8(v)) => C_integral(Type::i8(ccx), v as u64, true),\n@@ -93,51 +90,754 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n             ConstVal::Char(c) => C_integral(Type::char(ccx), c as u64, false),\n             ConstVal::Dummy => bug!(),\n+        };\n+\n+        assert!(!ty.has_erasable_regions());\n+\n+        Const::new(val, ty)\n+    }\n+\n+    fn get_fat_ptr(&self) -> (ValueRef, ValueRef) {\n+        (const_get_elt(self.llval, &[abi::FAT_PTR_ADDR as u32]),\n+         const_get_elt(self.llval, &[abi::FAT_PTR_EXTRA as u32]))\n+    }\n+\n+    fn as_lvalue(&self) -> ConstLvalue<'tcx> {\n+        ConstLvalue {\n+            base: Base::Value(self.llval),\n+            llextra: ptr::null_mut(),\n+            ty: self.ty\n+        }\n+    }\n+\n+    fn to_operand<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> OperandRef<'tcx> {\n+        let llty = type_of::immediate_type_of(ccx, self.ty);\n+        let llvalty = val_ty(self.llval);\n+\n+        let val = if common::type_is_fat_ptr(ccx.tcx(), self.ty) {\n+            let (data, extra) = self.get_fat_ptr();\n+            OperandValue::FatPtr(data, extra)\n+        } else if common::type_is_immediate(ccx, self.ty) && llty == llvalty {\n+            // If the types match, we can use the value directly.\n+            OperandValue::Immediate(self.llval)\n+        } else {\n+            // Otherwise, or if the value is not immediate, we create\n+            // a constant LLVM global and cast its address if necessary.\n+            let align = type_of::align_of(ccx, self.ty);\n+            let ptr = consts::addr_of(ccx, self.llval, align, \"const\");\n+            OperandValue::Ref(consts::ptrcast(ptr, llty.ptr_to()))\n+        };\n+\n+        OperandRef {\n+            val: val,\n+            ty: self.ty\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+enum Base {\n+    /// A constant value without an unique address.\n+    Value(ValueRef),\n+\n+    /// The address of a static.\n+    Static(ValueRef)\n+}\n+\n+/// An lvalue as seen from a constant.\n+#[derive(Copy, Clone)]\n+struct ConstLvalue<'tcx> {\n+    base: Base,\n+    llextra: ValueRef,\n+    ty: Ty<'tcx>\n+}\n+\n+impl<'tcx> ConstLvalue<'tcx> {\n+    fn to_const(&self, span: Span) -> Const<'tcx> {\n+        match self.base {\n+            Base::Value(val) => Const::new(val, self.ty),\n+            Base::Static(val) => {\n+                span_bug!(span, \"loading from `static` ({:?}) in constant\",\n+                          Value(val))\n+            }\n+        }\n+    }\n+\n+    pub fn len<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> ValueRef {\n+        match self.ty.sty {\n+            ty::TyArray(_, n) => C_uint(ccx, n),\n+            ty::TySlice(_) | ty::TyStr => {\n+                assert!(self.llextra != ptr::null_mut());\n+                self.llextra\n+            }\n+            _ => bug!(\"unexpected type `{}` in ConstLvalue::len\", self.ty)\n+        }\n+    }\n+}\n+\n+/// Machinery for translating a constant's MIR to LLVM values.\n+/// FIXME(eddyb) use miri and lower its allocations to LLVM.\n+struct MirConstContext<'a, 'tcx: 'a> {\n+    ccx: &'a CrateContext<'a, 'tcx>,\n+    mir: CachedMir<'a, 'tcx>,\n+\n+    /// Type parameters for const fn and associated constants.\n+    substs: &'tcx Substs<'tcx>,\n+\n+    /// Arguments passed to a const fn.\n+    args: Vec<Const<'tcx>>,\n+\n+    /// Variable values - specifically, argument bindings of a const fn.\n+    vars: Vec<Option<Const<'tcx>>>,\n+\n+    /// Temp values.\n+    temps: Vec<Option<Const<'tcx>>>,\n+\n+    /// Value assigned to Return, which is the resulting constant.\n+    return_value: Option<Const<'tcx>>\n+}\n+\n+\n+impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n+    fn new(ccx: &'a CrateContext<'a, 'tcx>,\n+           mut instance: Instance<'tcx>,\n+           args: Vec<Const<'tcx>>)\n+           -> MirConstContext<'a, 'tcx> {\n+\n+        // Try to resolve associated constants.\n+        if instance.substs.self_ty().is_some() {\n+            // Only trait items can have a Self parameter.\n+            let trait_item = ccx.tcx().impl_or_trait_item(instance.def);\n+            let trait_id = trait_item.container().id();\n+            let substs = instance.substs;\n+            let trait_ref = ty::Binder(substs.to_trait_ref(ccx.tcx(), trait_id));\n+            let vtable = common::fulfill_obligation(ccx, DUMMY_SP, trait_ref);\n+            if let traits::VtableImpl(vtable_impl) = vtable {\n+                let name = ccx.tcx().item_name(instance.def);\n+                for ac in ccx.tcx().associated_consts(vtable_impl.impl_def_id) {\n+                    if ac.name == name {\n+                        instance = Instance::new(ac.def_id, vtable_impl.substs);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        let mir = ccx.get_mir(instance.def).unwrap_or_else(|| {\n+            bug!(\"missing constant MIR for {}\", instance)\n+        });\n+        MirConstContext {\n+            ccx: ccx,\n+            substs: instance.substs,\n+            args: args,\n+            vars: vec![None; mir.var_decls.len()],\n+            temps: vec![None; mir.temp_decls.len()],\n+            return_value: None,\n+            mir: mir\n+        }\n+    }\n+\n+    fn monomorphize<T>(&self, value: &T) -> T\n+        where T : TypeFoldable<'tcx>\n+    {\n+        monomorphize::apply_param_substs(self.ccx.tcx(),\n+                                         self.substs,\n+                                         value)\n+    }\n+\n+    fn trans(&mut self) -> Result<Const<'tcx>, ConstEvalFailure> {\n+        let tcx = self.ccx.tcx();\n+        let mir = self.mir.clone();\n+        let mut bb = mir::START_BLOCK;\n+        loop {\n+            let data = mir.basic_block_data(bb);\n+            for statement in &data.statements {\n+                match statement.kind {\n+                    mir::StatementKind::Assign(ref dest, ref rvalue) => {\n+                        let ty = self.mir.lvalue_ty(tcx, dest);\n+                        let ty = self.monomorphize(&ty).to_ty(tcx);\n+                        let value = self.const_rvalue(rvalue, ty, statement.span)?;\n+                        self.store(dest, value, statement.span);\n+                    }\n+                }\n+            }\n+\n+            let terminator = data.terminator();\n+            let span = terminator.span;\n+            bb = match terminator.kind {\n+                mir::TerminatorKind::Drop { target, .. } | // No dropping.\n+                mir::TerminatorKind::Goto { target } => target,\n+                mir::TerminatorKind::Return => {\n+                    return Ok(self.return_value.unwrap_or_else(|| {\n+                        span_bug!(span, \"no returned value in constant\");\n+                    }))\n+                }\n+\n+                // This is only supported to make bounds checking work.\n+                mir::TerminatorKind::If { ref cond, targets: (true_bb, false_bb) } => {\n+                    let cond = self.const_operand(cond, span)?;\n+                    if common::const_to_uint(cond.llval) != 0 {\n+                        true_bb\n+                    } else {\n+                        false_bb\n+                    }\n+                }\n+\n+                mir::TerminatorKind::Call { ref func, ref args, ref destination, .. } => {\n+                    let fn_ty = mir.operand_ty(tcx, func);\n+                    let fn_ty = self.monomorphize(&fn_ty);\n+                    let instance = match fn_ty.sty {\n+                        ty::TyFnDef(def_id, substs, _) => {\n+                            Instance::new(def_id, substs)\n+                        }\n+                        _ => span_bug!(span, \"calling {:?} (of type {}) in constant\",\n+                                       func, fn_ty)\n+                    };\n+\n+                    // Indexing OOB doesn't call a const fn, handle it.\n+                    if Some(instance.def) == tcx.lang_items.panic_bounds_check_fn() {\n+                        consts::const_err(self.ccx, span,\n+                                          Err(ErrKind::IndexOutOfBounds),\n+                                          TrueConst::Yes)?;\n+                    }\n+\n+                    let args = args.iter().map(|arg| {\n+                        self.const_operand(arg, span)\n+                    }).collect::<Result<Vec<_>, _>>()?;\n+                    let value = MirConstContext::new(self.ccx, instance, args).trans()?;\n+                    if let Some((ref dest, target)) = *destination {\n+                        self.store(dest, value, span);\n+                        target\n+                    } else {\n+                        span_bug!(span, \"diverging {:?} in constant\", terminator.kind)\n+                    }\n+                }\n+                _ => span_bug!(span, \"{:?} in constant\", terminator.kind)\n+            };\n+        }\n+    }\n+\n+    fn store(&mut self, dest: &mir::Lvalue<'tcx>, value: Const<'tcx>, span: Span) {\n+        let dest = match *dest {\n+            mir::Lvalue::Var(index) => &mut self.vars[index as usize],\n+            mir::Lvalue::Temp(index) => &mut self.temps[index as usize],\n+            mir::Lvalue::ReturnPointer => &mut self.return_value,\n+            _ => span_bug!(span, \"assignment to {:?} in constant\", dest)\n+        };\n+        *dest = Some(value);\n+    }\n+\n+    fn const_lvalue(&self, lvalue: &mir::Lvalue<'tcx>, span: Span)\n+                    -> Result<ConstLvalue<'tcx>, ConstEvalFailure> {\n+        let tcx = self.ccx.tcx();\n+        let lvalue = match *lvalue {\n+            mir::Lvalue::Var(index) => {\n+                self.vars[index as usize].unwrap_or_else(|| {\n+                    span_bug!(span, \"var{} not initialized\", index)\n+                }).as_lvalue()\n+            }\n+            mir::Lvalue::Temp(index) => {\n+                self.temps[index as usize].unwrap_or_else(|| {\n+                    span_bug!(span, \"tmp{} not initialized\", index)\n+                }).as_lvalue()\n+            }\n+            mir::Lvalue::Arg(index) => self.args[index as usize].as_lvalue(),\n+            mir::Lvalue::Static(def_id) => {\n+                ConstLvalue {\n+                    base: Base::Static(consts::get_static(self.ccx, def_id).val),\n+                    llextra: ptr::null_mut(),\n+                    ty: self.mir.lvalue_ty(tcx, lvalue).to_ty(tcx)\n+                }\n+            }\n+            mir::Lvalue::ReturnPointer => {\n+                span_bug!(span, \"accessing Lvalue::ReturnPointer in constant\")\n+            }\n+            mir::Lvalue::Projection(ref projection) => {\n+                let tr_base = self.const_lvalue(&projection.base, span)?;\n+                let projected_ty = LvalueTy::Ty { ty: tr_base.ty }\n+                    .projection_ty(tcx, &projection.elem);\n+                let base = tr_base.to_const(span);\n+                let projected_ty = self.monomorphize(&projected_ty).to_ty(tcx);\n+                let is_sized = common::type_is_sized(tcx, projected_ty);\n+\n+                let (projected, llextra) = match projection.elem {\n+                    mir::ProjectionElem::Deref => {\n+                        let (base, extra) = if is_sized {\n+                            (base.llval, ptr::null_mut())\n+                        } else {\n+                            base.get_fat_ptr()\n+                        };\n+                        if self.ccx.statics().borrow().contains_key(&base) {\n+                            (Base::Static(base), extra)\n+                        } else {\n+                            let val = consts::load_const(self.ccx, base, projected_ty);\n+                            if val.is_null() {\n+                                span_bug!(span, \"dereference of non-constant pointer `{:?}`\",\n+                                          Value(base));\n+                            }\n+                            (Base::Value(val), extra)\n+                        }\n+                    }\n+                    mir::ProjectionElem::Field(ref field, _) => {\n+                        let base_repr = adt::represent_type(self.ccx, tr_base.ty);\n+                        let llprojected = adt::const_get_field(&base_repr, base.llval,\n+                                                               Disr(0), field.index());\n+                        let llextra = if is_sized {\n+                            ptr::null_mut()\n+                        } else {\n+                            tr_base.llextra\n+                        };\n+                        (Base::Value(llprojected), llextra)\n+                    }\n+                    mir::ProjectionElem::Index(ref index) => {\n+                        let llindex = self.const_operand(index, span)?.llval;\n+\n+                        let iv = if let Some(iv) = common::const_to_opt_uint(llindex) {\n+                            iv\n+                        } else {\n+                            span_bug!(span, \"index is not an integer-constant expression\")\n+                        };\n+                        (Base::Value(const_get_elt(base.llval, &[iv as u32])),\n+                         ptr::null_mut())\n+                    }\n+                    _ => span_bug!(span, \"{:?} in constant\", projection.elem)\n+                };\n+                ConstLvalue {\n+                    base: projected,\n+                    llextra: llextra,\n+                    ty: projected_ty\n+                }\n+            }\n+        };\n+        Ok(lvalue)\n+    }\n+\n+    fn const_operand(&self, operand: &mir::Operand<'tcx>, span: Span)\n+                     -> Result<Const<'tcx>, ConstEvalFailure> {\n+        match *operand {\n+            mir::Operand::Consume(ref lvalue) => {\n+                Ok(self.const_lvalue(lvalue, span)?.to_const(span))\n+            }\n+\n+            mir::Operand::Constant(ref constant) => {\n+                let ty = self.monomorphize(&constant.ty);\n+                match constant.literal.clone() {\n+                    mir::Literal::Item { def_id, substs } => {\n+                        // Shortcut for zero-sized types, including function item\n+                        // types, which would not work with MirConstContext.\n+                        if common::type_is_zero_size(self.ccx, ty) {\n+                            let llty = type_of::type_of(self.ccx, ty);\n+                            return Ok(Const::new(C_null(llty), ty));\n+                        }\n+\n+                        let substs = self.ccx.tcx().mk_substs(self.monomorphize(substs));\n+                        let instance = Instance::new(def_id, substs);\n+                        MirConstContext::new(self.ccx, instance, vec![]).trans()\n+                    }\n+                    mir::Literal::Value { value } => {\n+                        Ok(Const::from_constval(self.ccx, value, ty))\n+                    }\n+                }\n+            }\n         }\n     }\n \n+    fn const_rvalue(&self, rvalue: &mir::Rvalue<'tcx>,\n+                    dest_ty: Ty<'tcx>, span: Span)\n+                    -> Result<Const<'tcx>, ConstEvalFailure> {\n+        let tcx = self.ccx.tcx();\n+        let val = match *rvalue {\n+            mir::Rvalue::Use(ref operand) => self.const_operand(operand, span)?,\n+\n+            mir::Rvalue::Repeat(ref elem, ref count) => {\n+                let elem = self.const_operand(elem, span)?;\n+                let size = count.value.as_u64(tcx.sess.target.uint_type);\n+                let fields = vec![elem.llval; size as usize];\n+\n+                let llunitty = type_of::type_of(self.ccx, elem.ty);\n+                // If the array contains enums, an LLVM array won't work.\n+                let val = if val_ty(elem.llval) == llunitty {\n+                    C_array(llunitty, &fields)\n+                } else {\n+                    C_struct(self.ccx, &fields, false)\n+                };\n+                Const::new(val, dest_ty)\n+            }\n+\n+            mir::Rvalue::Aggregate(ref kind, ref operands) => {\n+                let fields = operands.iter().map(|operand| {\n+                    Ok(self.const_operand(operand, span)?.llval)\n+                }).collect::<Result<Vec<_>, _>>()?;\n+\n+                // FIXME Shouldn't need to manually trigger closure instantiations.\n+                if let mir::AggregateKind::Closure(def_id, substs) = *kind {\n+                    use rustc::hir;\n+                    use syntax::ast::DUMMY_NODE_ID;\n+                    use syntax::ptr::P;\n+                    use closure;\n+\n+                    closure::trans_closure_expr(closure::Dest::Ignore(self.ccx),\n+                                                &hir::FnDecl {\n+                                                    inputs: P::new(),\n+                                                    output: hir::NoReturn(DUMMY_SP),\n+                                                    variadic: false\n+                                                },\n+                                                &hir::Block {\n+                                                    stmts: P::new(),\n+                                                    expr: None,\n+                                                    id: DUMMY_NODE_ID,\n+                                                    rules: hir::DefaultBlock,\n+                                                    span: DUMMY_SP\n+                                                },\n+                                                DUMMY_NODE_ID, def_id,\n+                                                &self.monomorphize(substs));\n+                }\n+\n+                let val = if let mir::AggregateKind::Adt(adt_def, index, _) = *kind {\n+                    let repr = adt::represent_type(self.ccx, dest_ty);\n+                    let disr = Disr::from(adt_def.variants[index].disr_val);\n+                    adt::trans_const(self.ccx, &repr, disr, &fields)\n+                } else if let ty::TyArray(elem_ty, _) = dest_ty.sty {\n+                    let llunitty = type_of::type_of(self.ccx, elem_ty);\n+                    // If the array contains enums, an LLVM array won't work.\n+                    if fields.iter().all(|&f| val_ty(f) == llunitty) {\n+                        C_array(llunitty, &fields)\n+                    } else {\n+                        C_struct(self.ccx, &fields, false)\n+                    }\n+                } else {\n+                    C_struct(self.ccx, &fields, false)\n+                };\n+                Const::new(val, dest_ty)\n+            }\n+\n+            mir::Rvalue::Cast(ref kind, ref source, cast_ty) => {\n+                let operand = self.const_operand(source, span)?;\n+                let cast_ty = self.monomorphize(&cast_ty);\n+\n+                let val = match *kind {\n+                    mir::CastKind::ReifyFnPointer => {\n+                        match operand.ty.sty {\n+                            ty::TyFnDef(def_id, substs, _) => {\n+                                Callee::def(self.ccx, def_id, substs)\n+                                    .reify(self.ccx).val\n+                            }\n+                            _ => {\n+                                span_bug!(span, \"{} cannot be reified to a fn ptr\",\n+                                          operand.ty)\n+                            }\n+                        }\n+                    }\n+                    mir::CastKind::UnsafeFnPointer => {\n+                        // this is a no-op at the LLVM level\n+                        operand.llval\n+                    }\n+                    mir::CastKind::Unsize => {\n+                        // unsize targets other than to a fat pointer currently\n+                        // can't be in constants.\n+                        assert!(common::type_is_fat_ptr(tcx, cast_ty));\n+\n+                        let pointee_ty = operand.ty.builtin_deref(true, ty::NoPreference)\n+                            .expect(\"consts: unsizing got non-pointer type\").ty;\n+                        let (base, old_info) = if !common::type_is_sized(tcx, pointee_ty) {\n+                            // Normally, the source is a thin pointer and we are\n+                            // adding extra info to make a fat pointer. The exception\n+                            // is when we are upcasting an existing object fat pointer\n+                            // to use a different vtable. In that case, we want to\n+                            // load out the original data pointer so we can repackage\n+                            // it.\n+                            let (base, extra) = operand.get_fat_ptr();\n+                            (base, Some(extra))\n+                        } else {\n+                            (operand.llval, None)\n+                        };\n+\n+                        let unsized_ty = cast_ty.builtin_deref(true, ty::NoPreference)\n+                            .expect(\"consts: unsizing got non-pointer target type\").ty;\n+                        let ptr_ty = type_of::in_memory_type_of(self.ccx, unsized_ty).ptr_to();\n+                        let base = consts::ptrcast(base, ptr_ty);\n+                        let info = base::unsized_info(self.ccx, pointee_ty,\n+                                                      unsized_ty, old_info);\n+\n+                        if old_info.is_none() {\n+                            let prev_const = self.ccx.const_unsized().borrow_mut()\n+                                                     .insert(base, operand.llval);\n+                            assert!(prev_const.is_none() || prev_const == Some(operand.llval));\n+                        }\n+                        assert_eq!(abi::FAT_PTR_ADDR, 0);\n+                        assert_eq!(abi::FAT_PTR_EXTRA, 1);\n+                        C_struct(self.ccx, &[base, info], false)\n+                    }\n+                    mir::CastKind::Misc if common::type_is_immediate(self.ccx, operand.ty) => {\n+                        debug_assert!(common::type_is_immediate(self.ccx, cast_ty));\n+                        let r_t_in = CastTy::from_ty(operand.ty).expect(\"bad input type for cast\");\n+                        let r_t_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n+                        let ll_t_out = type_of::immediate_type_of(self.ccx, cast_ty);\n+                        let llval = operand.llval;\n+                        let signed = if let CastTy::Int(IntTy::CEnum) = r_t_in {\n+                            let repr = adt::represent_type(self.ccx, operand.ty);\n+                            adt::is_discr_signed(&repr)\n+                        } else {\n+                            operand.ty.is_signed()\n+                        };\n+\n+                        unsafe {\n+                            match (r_t_in, r_t_out) {\n+                                (CastTy::Int(_), CastTy::Int(_)) => {\n+                                    let s = signed as llvm::Bool;\n+                                    llvm::LLVMConstIntCast(llval, ll_t_out.to_ref(), s)\n+                                }\n+                                (CastTy::Int(_), CastTy::Float) => {\n+                                    if signed {\n+                                        llvm::LLVMConstSIToFP(llval, ll_t_out.to_ref())\n+                                    } else {\n+                                        llvm::LLVMConstUIToFP(llval, ll_t_out.to_ref())\n+                                    }\n+                                }\n+                                (CastTy::Float, CastTy::Float) => {\n+                                    llvm::LLVMConstFPCast(llval, ll_t_out.to_ref())\n+                                }\n+                                (CastTy::Float, CastTy::Int(IntTy::I)) => {\n+                                    llvm::LLVMConstFPToSI(llval, ll_t_out.to_ref())\n+                                }\n+                                (CastTy::Float, CastTy::Int(_)) => {\n+                                    llvm::LLVMConstFPToUI(llval, ll_t_out.to_ref())\n+                                }\n+                                (CastTy::Ptr(_), CastTy::Ptr(_)) |\n+                                (CastTy::FnPtr, CastTy::Ptr(_)) |\n+                                (CastTy::RPtr(_), CastTy::Ptr(_)) => {\n+                                    consts::ptrcast(llval, ll_t_out)\n+                                }\n+                                (CastTy::Int(_), CastTy::Ptr(_)) => {\n+                                    llvm::LLVMConstIntToPtr(llval, ll_t_out.to_ref())\n+                                }\n+                                (CastTy::Ptr(_), CastTy::Int(_)) |\n+                                (CastTy::FnPtr, CastTy::Int(_)) => {\n+                                    llvm::LLVMConstPtrToInt(llval, ll_t_out.to_ref())\n+                                }\n+                                _ => bug!(\"unsupported cast: {:?} to {:?}\", operand.ty, cast_ty)\n+                            }\n+                        }\n+                    }\n+                    mir::CastKind::Misc => { // Casts from a fat-ptr.\n+                        let ll_cast_ty = type_of::immediate_type_of(self.ccx, cast_ty);\n+                        let ll_from_ty = type_of::immediate_type_of(self.ccx, operand.ty);\n+                        if common::type_is_fat_ptr(tcx, operand.ty) {\n+                            let (data_ptr, meta_ptr) = operand.get_fat_ptr();\n+                            if common::type_is_fat_ptr(tcx, cast_ty) {\n+                                let ll_cft = ll_cast_ty.field_types();\n+                                let ll_fft = ll_from_ty.field_types();\n+                                let data_cast = consts::ptrcast(data_ptr, ll_cft[0]);\n+                                assert_eq!(ll_cft[1].kind(), ll_fft[1].kind());\n+                                C_struct(self.ccx, &[data_cast, meta_ptr], false)\n+                            } else { // cast to thin-ptr\n+                                // Cast of fat-ptr to thin-ptr is an extraction of data-ptr and\n+                                // pointer-cast of that pointer to desired pointer type.\n+                                consts::ptrcast(data_ptr, ll_cast_ty)\n+                            }\n+                        } else {\n+                            bug!(\"Unexpected non-FatPtr operand\")\n+                        }\n+                    }\n+                };\n+                Const::new(val, cast_ty)\n+            }\n+\n+            mir::Rvalue::Ref(_, bk, ref lvalue) => {\n+                let tr_lvalue = self.const_lvalue(lvalue, span)?;\n+\n+                let ty = tr_lvalue.ty;\n+                let ref_ty = tcx.mk_ref(tcx.mk_region(ty::ReStatic),\n+                    ty::TypeAndMut { ty: ty, mutbl: bk.to_mutbl_lossy() });\n+\n+                let base = match tr_lvalue.base {\n+                    Base::Value(llval) => {\n+                        let align = type_of::align_of(self.ccx, ty);\n+                        if bk == mir::BorrowKind::Mut {\n+                            consts::addr_of_mut(self.ccx, llval, align, \"ref_mut\")\n+                        } else {\n+                            consts::addr_of(self.ccx, llval, align, \"ref\")\n+                        }\n+                    }\n+                    Base::Static(llval) => llval\n+                };\n+\n+                let ptr = if common::type_is_sized(tcx, ty) {\n+                    base\n+                } else {\n+                    C_struct(self.ccx, &[base, tr_lvalue.llextra], false)\n+                };\n+                Const::new(ptr, ref_ty)\n+            }\n+\n+            mir::Rvalue::Len(ref lvalue) => {\n+                let tr_lvalue = self.const_lvalue(lvalue, span)?;\n+                Const::new(tr_lvalue.len(self.ccx), tcx.types.usize)\n+            }\n+\n+            mir::Rvalue::BinaryOp(op, ref lhs, ref rhs) => {\n+                let lhs = self.const_operand(lhs, span)?;\n+                let rhs = self.const_operand(rhs, span)?;\n+                let ty = lhs.ty;\n+                let binop_ty = self.mir.binop_ty(tcx, op, lhs.ty, rhs.ty);\n+                let (lhs, rhs) = (lhs.llval, rhs.llval);\n+                assert!(!ty.is_simd());\n+                let is_float = ty.is_fp();\n+                let signed = ty.is_signed();\n+\n+                if let (Some(lhs), Some(rhs)) = (to_const_int(lhs, ty, tcx),\n+                                                 to_const_int(rhs, ty, tcx)) {\n+                    let result = match op {\n+                        mir::BinOp::Add => lhs + rhs,\n+                        mir::BinOp::Sub => lhs - rhs,\n+                        mir::BinOp::Mul => lhs * rhs,\n+                        mir::BinOp::Div => lhs / rhs,\n+                        mir::BinOp::Rem => lhs % rhs,\n+                        mir::BinOp::Shl => lhs << rhs,\n+                        mir::BinOp::Shr => lhs >> rhs,\n+                        _ => Ok(lhs)\n+                    };\n+                    consts::const_err(self.ccx, span,\n+                                      result.map_err(ErrKind::Math),\n+                                      TrueConst::Yes)?;\n+                }\n+\n+                let llval = unsafe {\n+                    match op {\n+                        mir::BinOp::Add if is_float => llvm::LLVMConstFAdd(lhs, rhs),\n+                        mir::BinOp::Add             => llvm::LLVMConstAdd(lhs, rhs),\n+\n+                        mir::BinOp::Sub if is_float => llvm::LLVMConstFSub(lhs, rhs),\n+                        mir::BinOp::Sub             => llvm::LLVMConstSub(lhs, rhs),\n+\n+                        mir::BinOp::Mul if is_float => llvm::LLVMConstFMul(lhs, rhs),\n+                        mir::BinOp::Mul             => llvm::LLVMConstMul(lhs, rhs),\n+\n+                        mir::BinOp::Div if is_float => llvm::LLVMConstFDiv(lhs, rhs),\n+                        mir::BinOp::Div if signed   => llvm::LLVMConstSDiv(lhs, rhs),\n+                        mir::BinOp::Div             => llvm::LLVMConstUDiv(lhs, rhs),\n+\n+                        mir::BinOp::Rem if is_float => llvm::LLVMConstFRem(lhs, rhs),\n+                        mir::BinOp::Rem if signed   => llvm::LLVMConstSRem(lhs, rhs),\n+                        mir::BinOp::Rem             => llvm::LLVMConstURem(lhs, rhs),\n+\n+                        mir::BinOp::BitXor => llvm::LLVMConstXor(lhs, rhs),\n+                        mir::BinOp::BitAnd => llvm::LLVMConstAnd(lhs, rhs),\n+                        mir::BinOp::BitOr  => llvm::LLVMConstOr(lhs, rhs),\n+                        mir::BinOp::Shl    => {\n+                            let rhs = base::cast_shift_const_rhs(op.to_hir_binop(), lhs, rhs);\n+                            llvm::LLVMConstShl(lhs, rhs)\n+                        }\n+                        mir::BinOp::Shr    => {\n+                            let rhs = base::cast_shift_const_rhs(op.to_hir_binop(), lhs, rhs);\n+                            if signed { llvm::LLVMConstAShr(lhs, rhs) }\n+                            else      { llvm::LLVMConstLShr(lhs, rhs) }\n+                        }\n+                        mir::BinOp::Eq | mir::BinOp::Ne |\n+                        mir::BinOp::Lt | mir::BinOp::Le |\n+                        mir::BinOp::Gt | mir::BinOp::Ge => {\n+                            if is_float {\n+                                let cmp = base::bin_op_to_fcmp_predicate(op.to_hir_binop());\n+                                llvm::ConstFCmp(cmp, lhs, rhs)\n+                            } else {\n+                                let cmp = base::bin_op_to_icmp_predicate(op.to_hir_binop(),\n+                                                                         signed);\n+                                llvm::ConstICmp(cmp, lhs, rhs)\n+                            }\n+                        }\n+                    }\n+                };\n+                Const::new(llval, binop_ty)\n+            }\n+\n+            mir::Rvalue::UnaryOp(op, ref operand) => {\n+                let operand = self.const_operand(operand, span)?;\n+                let lloperand = operand.llval;\n+                let llval = match op {\n+                    mir::UnOp::Not => {\n+                        unsafe {\n+                            llvm::LLVMConstNot(lloperand)\n+                        }\n+                    }\n+                    mir::UnOp::Neg => {\n+                        if let Some(cval) = to_const_int(lloperand, operand.ty, tcx) {\n+                            consts::const_err(self.ccx, span,\n+                                              (-cval).map_err(ErrKind::Math),\n+                                              TrueConst::Yes)?;\n+                        }\n+                        let is_float = operand.ty.is_fp();\n+                        unsafe {\n+                            if is_float {\n+                                llvm::LLVMConstFNeg(lloperand)\n+                            } else {\n+                                llvm::LLVMConstNeg(lloperand)\n+                            }\n+                        }\n+                    }\n+                };\n+                Const::new(llval, operand.ty)\n+            }\n+\n+            _ => span_bug!(span, \"{:?} in constant\", rvalue)\n+        };\n+\n+        Ok(val)\n+    }\n+}\n+\n+impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_constant(&mut self,\n                           bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                           constant: &mir::Constant<'tcx>)\n                           -> OperandRef<'tcx>\n     {\n         let ty = bcx.monomorphize(&constant.ty);\n-        match constant.literal {\n+        let val = match constant.literal.clone() {\n             mir::Literal::Item { def_id, substs } => {\n                 // Shortcut for zero-sized types, including function item\n-                // types, which would not work with lookup_const_by_id.\n+                // types, which would not work with MirConstContext.\n                 if common::type_is_zero_size(bcx.ccx(), ty) {\n                     let llty = type_of::type_of(bcx.ccx(), ty);\n                     return OperandRef {\n-                        val: OperandValue::Immediate(C_undef(llty)),\n+                        val: OperandValue::Immediate(C_null(llty)),\n                         ty: ty\n                     };\n                 }\n \n-                let substs = Some(bcx.monomorphize(substs));\n-                let expr = lookup_const_by_id(bcx.tcx(), def_id, substs)\n-                            .expect(\"def was const, but lookup_const_by_id failed\").0;\n-                // FIXME: this is falling back to translating from HIR. This is not easy to fix,\n-                // because we would have somehow adapt const_eval to work on MIR rather than HIR.\n-                let d = bcx.with_block(|bcx| {\n-                    expr::trans(bcx, expr)\n-                });\n-\n-                let datum = d.datum.to_rvalue_datum(d.bcx, \"\").datum;\n-\n-                match datum.kind.mode {\n-                    datum::RvalueMode::ByValue => {\n-                        OperandRef {\n-                            ty: datum.ty,\n-                            val: OperandValue::Immediate(datum.val)\n-                        }\n+                let substs = bcx.tcx().mk_substs(bcx.monomorphize(substs));\n+                let instance = Instance::new(def_id, substs);\n+                match MirConstContext::new(bcx.ccx(), instance, vec![]).trans() {\n+                    Ok(v) => v,\n+                    Err(ConstEvalFailure::Compiletime(_)) => {\n+                        // We've errored, so we don't have to produce working code.\n+                        let llty = type_of::type_of(bcx.ccx(), ty);\n+                        Const::new(C_undef(llty), ty)\n+                    }\n+                    Err(ConstEvalFailure::Runtime(err)) => {\n+                        span_bug!(constant.span,\n+                                  \"MIR constant {:?} results in runtime panic: {}\",\n+                                  constant, err.description())\n                     }\n-                    datum::RvalueMode::ByRef => self.trans_load(bcx, datum.val, datum.ty)\n                 }\n             }\n-            mir::Literal::Value { ref value } => {\n-                self.trans_constval(bcx, value, ty)\n+            mir::Literal::Value { value } => {\n+                Const::from_constval(bcx.ccx(), value, ty)\n             }\n+        };\n+\n+        let operand = val.to_operand(bcx.ccx());\n+        if let OperandValue::Ref(ptr) = operand.val {\n+            // If this is a OperandValue::Ref to an immediate constant, load it.\n+            self.trans_load(bcx, ptr, operand.ty)\n+        } else {\n+            operand\n         }\n     }\n }\n+\n+\n+pub fn trans_static_initializer(ccx: &CrateContext, def_id: DefId)\n+                                -> Result<ValueRef, ConstEvalFailure> {\n+    let instance = Instance::mono(ccx.tcx(), def_id);\n+    MirConstContext::new(ccx, instance, vec![]).trans().map(|c| c.llval)\n+}"}, {"sha": "e57a5cbc5b8b969c19fde829d946671d6245bf90", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e1eca0a1103afa6ba87ee3e23a921ed8faf4c130/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1eca0a1103afa6ba87ee3e23a921ed8faf4c130/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=e1eca0a1103afa6ba87ee3e23a921ed8faf4c130", "patch": "@@ -16,7 +16,7 @@ use abi;\n use adt;\n use base;\n use builder::Builder;\n-use common::{self, BlockAndBuilder, C_uint};\n+use common::{self, BlockAndBuilder, CrateContext, C_uint};\n use consts;\n use machine;\n use mir::drop;\n@@ -56,6 +56,18 @@ impl<'tcx> LvalueRef<'tcx> {\n         }\n         LvalueRef::new_sized(lltemp, LvalueTy::from_ty(ty))\n     }\n+\n+    pub fn len<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> ValueRef {\n+        let ty = self.ty.to_ty(ccx.tcx());\n+        match ty.sty {\n+            ty::TyArray(_, n) => common::C_uint(ccx, n),\n+            ty::TySlice(_) | ty::TyStr => {\n+                assert!(self.llextra != ptr::null_mut());\n+                self.llextra\n+            }\n+            _ => bug!(\"unexpected type `{}` in LvalueRef::len\", ty)\n+        }\n+    }\n }\n \n pub fn get_meta(b: &Builder, fat_ptr: ValueRef) -> ValueRef {\n@@ -71,20 +83,6 @@ pub fn load_fat_ptr(b: &Builder, fat_ptr: ValueRef) -> (ValueRef, ValueRef) {\n }\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n-    pub fn lvalue_len(&mut self,\n-                      bcx: &BlockAndBuilder<'bcx, 'tcx>,\n-                      lvalue: LvalueRef<'tcx>)\n-                      -> ValueRef {\n-        match lvalue.ty.to_ty(bcx.tcx()).sty {\n-            ty::TyArray(_, n) => common::C_uint(bcx.ccx(), n),\n-            ty::TySlice(_) | ty::TyStr => {\n-                assert!(lvalue.llextra != ptr::null_mut());\n-                lvalue.llextra\n-            }\n-            _ => bug!(\"unexpected type in lvalue_len\"),\n-        }\n-    }\n-\n     pub fn trans_lvalue(&mut self,\n                         bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                         lvalue: &mir::Lvalue<'tcx>)\n@@ -190,7 +188,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                                          from_end: true,\n                                                          min_length: _ } => {\n                         let lloffset = C_uint(bcx.ccx(), offset);\n-                        let lllen = self.lvalue_len(bcx, tr_base);\n+                        let lllen = tr_base.len(bcx.ccx());\n                         let llindex = bcx.sub(lllen, lloffset);\n                         project_index(self.prepare_index(bcx, llindex))\n                     }"}, {"sha": "b98e04e51c007d41e2a4f37c8b52de176438e1f9", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1eca0a1103afa6ba87ee3e23a921ed8faf4c130/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1eca0a1103afa6ba87ee3e23a921ed8faf4c130/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=e1eca0a1103afa6ba87ee3e23a921ed8faf4c130", "patch": "@@ -31,6 +31,8 @@ use basic_block::BasicBlock;\n \n use rustc_data_structures::bitvec::BitVector;\n \n+pub use self::constant::trans_static_initializer;\n+\n use self::lvalue::{LvalueRef, get_dataptr, get_meta};\n use rustc_mir::traversal;\n "}, {"sha": "1236100a4d51c08a1bfe4dab4243984e6352ee03", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1eca0a1103afa6ba87ee3e23a921ed8faf4c130/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1eca0a1103afa6ba87ee3e23a921ed8faf4c130/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=e1eca0a1103afa6ba87ee3e23a921ed8faf4c130", "patch": "@@ -11,8 +11,6 @@\n use llvm::ValueRef;\n use rustc::ty::{self, Ty};\n use rustc::ty::cast::{CastTy, IntTy};\n-use middle::const_val::ConstVal;\n-use rustc_const_math::ConstInt;\n use rustc::mir::repr as mir;\n \n use asm;\n@@ -100,8 +98,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n             mir::Rvalue::Repeat(ref elem, ref count) => {\n                 let tr_elem = self.trans_operand(&bcx, elem);\n-                let count = ConstVal::Integral(ConstInt::Usize(count.value));\n-                let size = self.trans_constval(&bcx, &count, bcx.tcx().types.usize).immediate();\n+                let size = count.value.as_u64(bcx.tcx().sess.target.uint_type);\n+                let size = C_uint(bcx.ccx(), size);\n                 let base = get_dataptr(&bcx, dest.llval);\n                 let bcx = bcx.map_block(|block| {\n                     tvec::iter_vec_raw(block, base, tr_elem.ty, size, |block, llslot, _| {\n@@ -405,7 +403,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             mir::Rvalue::Len(ref lvalue) => {\n                 let tr_lvalue = self.trans_lvalue(&bcx, lvalue);\n                 let operand = OperandRef {\n-                    val: OperandValue::Immediate(self.lvalue_len(&bcx, tr_lvalue)),\n+                    val: OperandValue::Immediate(tr_lvalue.len(bcx.ccx())),\n                     ty: bcx.tcx().types.usize,\n                 };\n                 (bcx, operand)"}, {"sha": "1134dbfd1c46c9e74bf5c6e70eadbc5d5ce1b3b2", "filename": "src/test/compile-fail/array_const_index-0.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e1eca0a1103afa6ba87ee3e23a921ed8faf4c130/src%2Ftest%2Fcompile-fail%2Farray_const_index-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1eca0a1103afa6ba87ee3e23a921ed8faf4c130/src%2Ftest%2Fcompile-fail%2Farray_const_index-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farray_const_index-0.rs?ref=e1eca0a1103afa6ba87ee3e23a921ed8faf4c130", "patch": "@@ -8,8 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-static A: &'static [i32] = &[];\n-static B: i32 = (&A)[1]; //~ ERROR: const index-expr is out of bounds\n+const A: &'static [i32] = &[];\n+const B: i32 = (&A)[1];\n+//~^ ERROR: array index out of bounds\n \n fn main() {\n     let _ = B;"}, {"sha": "e59895cda442ae1adab9a2a493d2ac7efdf88b28", "filename": "src/test/compile-fail/array_const_index-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1eca0a1103afa6ba87ee3e23a921ed8faf4c130/src%2Ftest%2Fcompile-fail%2Farray_const_index-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1eca0a1103afa6ba87ee3e23a921ed8faf4c130/src%2Ftest%2Fcompile-fail%2Farray_const_index-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farray_const_index-1.rs?ref=e1eca0a1103afa6ba87ee3e23a921ed8faf4c130", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n const A: [i32; 0] = [];\n-const B: i32 = A[1]; //~ ERROR: const index-expr is out of bounds\n+const B: i32 = A[1]; //~ ERROR: array index out of bounds\n \n fn main() {\n     let _ = B;"}, {"sha": "a25255c010caf4c5bb6f938d6c52c9882704af30", "filename": "src/test/compile-fail/const-err.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e1eca0a1103afa6ba87ee3e23a921ed8faf4c130/src%2Ftest%2Fcompile-fail%2Fconst-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1eca0a1103afa6ba87ee3e23a921ed8faf4c130/src%2Ftest%2Fcompile-fail%2Fconst-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-err.rs?ref=e1eca0a1103afa6ba87ee3e23a921ed8faf4c130", "patch": "@@ -19,6 +19,11 @@ fn black_box<T>(_: T) {\n     unimplemented!()\n }\n \n+// Make sure that the two uses get two errors.\n+const FOO: u8 = [5u8][1];\n+//~^ ERROR array index out of bounds\n+//~^^ ERROR array index out of bounds\n+\n #[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     let a = -std::i8::MIN;\n@@ -31,9 +36,11 @@ fn main() {\n     let d = 42u8 - (42u8 + 1);\n     //~^ WARN attempted to subtract with overflow\n     let _e = [5u8][1];\n-    //~^ ERROR const index-expr is out of bounds\n+    //~^ WARN array index out of bounds\n     black_box(a);\n     black_box(b);\n     black_box(c);\n     black_box(d);\n+\n+    black_box((FOO, FOO));\n }"}, {"sha": "b50468c33fd8bf85c4829edbf9f458c2c746ef70", "filename": "src/test/compile-fail/const-slice-oob.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1eca0a1103afa6ba87ee3e23a921ed8faf4c130/src%2Ftest%2Fcompile-fail%2Fconst-slice-oob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1eca0a1103afa6ba87ee3e23a921ed8faf4c130/src%2Ftest%2Fcompile-fail%2Fconst-slice-oob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-slice-oob.rs?ref=e1eca0a1103afa6ba87ee3e23a921ed8faf4c130", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n const FOO: &'static[u32] = &[1, 2, 3];\n-const BAR: u32 = FOO[5]; //~ ERROR const index-expr is out of bounds\n+const BAR: u32 = FOO[5]; //~ ERROR array index out of bounds\n \n fn main() {\n     let _ = BAR;"}, {"sha": "6b3970e4f1997adbdf6b6f43ebef601bc421cd53", "filename": "src/test/run-pass/const-autoderef.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1eca0a1103afa6ba87ee3e23a921ed8faf4c130/src%2Ftest%2Frun-pass%2Fconst-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1eca0a1103afa6ba87ee3e23a921ed8faf4c130/src%2Ftest%2Frun-pass%2Fconst-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-autoderef.rs?ref=e1eca0a1103afa6ba87ee3e23a921ed8faf4c130", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n \n-static A: [u8; 1] = ['h' as u8];\n-static B: u8 = (&A)[0];\n-static C: &'static &'static &'static &'static [u8; 1] = & & & &A;\n-static D: u8 = (&C)[0];\n+const A: [u8; 1] = ['h' as u8];\n+const B: u8 = (&A)[0];\n+const C: &'static &'static &'static &'static [u8; 1] = & & & &A;\n+const D: u8 = (&C)[0];\n \n pub fn main() {\n     assert_eq!(B, A[0]);"}]}