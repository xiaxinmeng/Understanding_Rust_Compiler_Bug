{"sha": "3c8e13aff1ea5e57c0d843a4e76b533318ca68c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjOGUxM2FmZjFlYTVlNTdjMGQ4NDNhNGU3NmI1MzMzMThjYTY4YzU=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2021-02-02T23:42:39Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2021-02-05T16:23:54Z"}, "message": "Remove unused cache argument", "tree": {"sha": "90f7d4ccd78f7693828793881d02343a7ac9b1f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90f7d4ccd78f7693828793881d02343a7ac9b1f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c8e13aff1ea5e57c0d843a4e76b533318ca68c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c8e13aff1ea5e57c0d843a4e76b533318ca68c5", "html_url": "https://github.com/rust-lang/rust/commit/3c8e13aff1ea5e57c0d843a4e76b533318ca68c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c8e13aff1ea5e57c0d843a4e76b533318ca68c5/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "076fa6342483aad940219b8533cbace444e262ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/076fa6342483aad940219b8533cbace444e262ca", "html_url": "https://github.com/rust-lang/rust/commit/076fa6342483aad940219b8533cbace444e262ca"}], "stats": {"total": 21, "additions": 9, "deletions": 12}, "files": [{"sha": "a21cf5266fe1ffacfe4fdaa781735f44cefeb68f", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3c8e13aff1ea5e57c0d843a4e76b533318ca68c5/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c8e13aff1ea5e57c0d843a4e76b533318ca68c5/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=3c8e13aff1ea5e57c0d843a4e76b533318ca68c5", "patch": "@@ -173,9 +173,9 @@ crate fn get_index_search_type<'tcx>(\n     tcx: TyCtxt<'tcx>,\n ) -> Option<IndexItemFunctionType> {\n     let (all_types, ret_types) = match *item.kind {\n-        clean::FunctionItem(ref f) => get_all_types(&f.generics, &f.decl, tcx, &cache),\n-        clean::MethodItem(ref m, _) => get_all_types(&m.generics, &m.decl, tcx, &cache),\n-        clean::TyMethodItem(ref m) => get_all_types(&m.generics, &m.decl, tcx, &cache),\n+        clean::FunctionItem(ref f) => get_all_types(&f.generics, &f.decl, tcx),\n+        clean::MethodItem(ref m, _) => get_all_types(&m.generics, &m.decl, tcx),\n+        clean::TyMethodItem(ref m) => get_all_types(&m.generics, &m.decl, tcx),\n         _ => return None,\n     };\n \n@@ -257,7 +257,6 @@ crate fn get_real_types<'tcx>(\n     arg: &Type,\n     tcx: TyCtxt<'tcx>,\n     recurse: i32,\n-    cache: &Cache,\n     res: &mut FxHashSet<(Type, TypeKind)>,\n ) -> usize {\n     fn insert(res: &mut FxHashSet<(Type, TypeKind)>, tcx: TyCtxt<'_>, ty: Type) -> usize {\n@@ -279,8 +278,7 @@ crate fn get_real_types<'tcx>(\n     }\n     let mut nb_added = 0;\n \n-    if arg.is_full_generic() {\n-        let arg_s = Symbol::intern(&arg.print(cache).to_string());\n+    if let &Type::Generic(arg_s) = arg {\n         if let Some(where_pred) = generics.where_predicates.iter().find(|g| match g {\n             WherePredicate::BoundPredicate { ty, .. } => ty.def_id() == arg.def_id(),\n             _ => false,\n@@ -293,7 +291,7 @@ crate fn get_real_types<'tcx>(\n                             continue;\n                         }\n                         if let Some(ty) = x.get_type() {\n-                            let adds = get_real_types(generics, &ty, tcx, recurse + 1, cache, res);\n+                            let adds = get_real_types(generics, &ty, tcx, recurse + 1, res);\n                             nb_added += adds;\n                             if adds == 0 && !ty.is_full_generic() {\n                                 nb_added += insert(res, tcx, ty);\n@@ -306,7 +304,7 @@ crate fn get_real_types<'tcx>(\n         if let Some(bound) = generics.params.iter().find(|g| g.is_type() && g.name == arg_s) {\n             for bound in bound.get_bounds().unwrap_or(&[]) {\n                 if let Some(ty) = bound.get_trait_type() {\n-                    let adds = get_real_types(generics, &ty, tcx, recurse + 1, cache, res);\n+                    let adds = get_real_types(generics, &ty, tcx, recurse + 1, res);\n                     nb_added += adds;\n                     if adds == 0 && !ty.is_full_generic() {\n                         nb_added += insert(res, tcx, ty);\n@@ -319,7 +317,7 @@ crate fn get_real_types<'tcx>(\n         if let Some(gens) = arg.generics() {\n             for gen in gens.iter() {\n                 if gen.is_full_generic() {\n-                    nb_added += get_real_types(generics, gen, tcx, recurse + 1, cache, res);\n+                    nb_added += get_real_types(generics, gen, tcx, recurse + 1, res);\n                 } else {\n                     nb_added += insert(res, tcx, (*gen).clone());\n                 }\n@@ -337,15 +335,14 @@ crate fn get_all_types<'tcx>(\n     generics: &Generics,\n     decl: &FnDecl,\n     tcx: TyCtxt<'tcx>,\n-    cache: &Cache,\n ) -> (Vec<(Type, TypeKind)>, Vec<(Type, TypeKind)>) {\n     let mut all_types = FxHashSet::default();\n     for arg in decl.inputs.values.iter() {\n         if arg.type_.is_self_type() {\n             continue;\n         }\n         let mut args = FxHashSet::default();\n-        get_real_types(generics, &arg.type_, tcx, 0, cache, &mut args);\n+        get_real_types(generics, &arg.type_, tcx, 0, &mut args);\n         if !args.is_empty() {\n             all_types.extend(args);\n         } else {\n@@ -358,7 +355,7 @@ crate fn get_all_types<'tcx>(\n     let ret_types = match decl.output {\n         FnRetTy::Return(ref return_type) => {\n             let mut ret = FxHashSet::default();\n-            get_real_types(generics, &return_type, tcx, 0, cache, &mut ret);\n+            get_real_types(generics, &return_type, tcx, 0, &mut ret);\n             if ret.is_empty() {\n                 if let Some(kind) = return_type.def_id().map(|did| tcx.def_kind(did).into()) {\n                     ret.insert((return_type.clone(), kind));"}]}