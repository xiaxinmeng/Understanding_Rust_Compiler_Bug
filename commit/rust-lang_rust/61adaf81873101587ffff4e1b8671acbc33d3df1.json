{"sha": "61adaf81873101587ffff4e1b8671acbc33d3df1", "node_id": "C_kwDOAAsO6NoAKDYxYWRhZjgxODczMTAxNTg3ZmZmZjRlMWI4NjcxYWNiYzMzZDNkZjE", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-11-26T21:51:55Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-12-13T17:48:55Z"}, "message": "Combine projection and opaque into alias", "tree": {"sha": "7687aacda07f91463a43012ee10e0a5894557ac4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7687aacda07f91463a43012ee10e0a5894557ac4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61adaf81873101587ffff4e1b8671acbc33d3df1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61adaf81873101587ffff4e1b8671acbc33d3df1", "html_url": "https://github.com/rust-lang/rust/commit/61adaf81873101587ffff4e1b8671acbc33d3df1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61adaf81873101587ffff4e1b8671acbc33d3df1/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c13bd83528da223fa073e9c7e5fdc435254baab6", "url": "https://api.github.com/repos/rust-lang/rust/commits/c13bd83528da223fa073e9c7e5fdc435254baab6", "html_url": "https://github.com/rust-lang/rust/commit/c13bd83528da223fa073e9c7e5fdc435254baab6"}], "stats": {"total": 768, "additions": 387, "deletions": 381}, "files": [{"sha": "a92cb6bb38d4766ac9c919e07a732e84aa65d5cd", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -697,7 +697,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     .map_bound(|p| p.predicates),\n                 None,\n             ),\n-            ty::Opaque(ty::AliasTy { def_id, substs }) => {\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) => {\n                 find_fn_kind_from_did(tcx.bound_explicit_item_bounds(*def_id), Some(*substs))\n             }\n             ty::Closure(_, substs) => match substs.as_closure().kind() {"}, {"sha": "e6520301818d82beb2bb99c754fa3b6f7eedf945", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -504,7 +504,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let ErrorConstraintInfo { outlived_fr, span, .. } = errci;\n \n         let mut output_ty = self.regioncx.universal_regions().unnormalized_output_ty;\n-        if let ty::Opaque(ty::AliasTy { def_id, substs: _ }) = *output_ty.kind() {\n+        if let ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }) = *output_ty.kind() {\n             output_ty = self.infcx.tcx.type_of(def_id)\n         };\n "}, {"sha": "c260de699ced81b88f65e283b37ec60a9f6b9da2", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -411,9 +411,9 @@ fn push_debuginfo_type_name<'tcx>(\n         ty::Error(_)\n         | ty::Infer(_)\n         | ty::Placeholder(..)\n-        | ty::Projection(..)\n+        | ty::Alias(ty::Projection, ..)\n         | ty::Bound(..)\n-        | ty::Opaque(..)\n+        | ty::Alias(ty::Opaque, ..)\n         | ty::GeneratorWitness(..) => {\n             bug!(\n                 \"debuginfo: Trying to create type name for \\"}, {"sha": "5cc9ff8f85539183728ce30cdfb72b00616b28e3", "filename": "compiler/rustc_const_eval/src/const_eval/valtrees.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -142,12 +142,12 @@ pub(crate) fn const_to_valtree_inner<'tcx>(\n         | ty::Foreign(..)\n         | ty::Infer(ty::FreshIntTy(_))\n         | ty::Infer(ty::FreshFloatTy(_))\n-        | ty::Projection(..)\n+        | ty::Alias(ty::Projection, ..)\n         | ty::Param(_)\n         | ty::Bound(..)\n         | ty::Placeholder(..)\n         // FIXME(oli-obk): we could look behind opaque types\n-        | ty::Opaque(..)\n+        | ty::Alias(ty::Opaque, ..)\n         | ty::Infer(_)\n         // FIXME(oli-obk): we can probably encode closures just like structs\n         | ty::Closure(..)\n@@ -307,11 +307,11 @@ pub fn valtree_to_const_value<'tcx>(\n         | ty::Foreign(..)\n         | ty::Infer(ty::FreshIntTy(_))\n         | ty::Infer(ty::FreshFloatTy(_))\n-        | ty::Projection(..)\n+        | ty::Alias(ty::Projection, ..)\n         | ty::Param(_)\n         | ty::Bound(..)\n         | ty::Placeholder(..)\n-        | ty::Opaque(..)\n+        | ty::Alias(ty::Opaque, ..)\n         | ty::Infer(_)\n         | ty::Closure(..)\n         | ty::Generator(..)"}, {"sha": "4fc664b70f8d7bdd030514c91c910a0b2dcfe47f", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -82,8 +82,8 @@ pub(crate) fn eval_nullary_intrinsic<'tcx>(\n             ty::Adt(ref adt, _) => {\n                 ConstValue::from_machine_usize(adt.variants().len() as u64, &tcx)\n             }\n-            ty::Projection(_)\n-            | ty::Opaque(ty::AliasTy { def_id: _, substs: _ })\n+            ty::Alias(ty::Projection, _)\n+            | ty::Alias(ty::Opaque, ty::AliasTy { def_id: _, substs: _ })\n             | ty::Param(_)\n             | ty::Placeholder(_)\n             | ty::Infer(_) => throw_inval!(TooGeneric),"}, {"sha": "b7dd2517d69ee1a18ab18c038ed44e954f6794cd", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -601,8 +601,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             | ty::Placeholder(..)\n             | ty::Bound(..)\n             | ty::Param(..)\n-            | ty::Opaque(..)\n-            | ty::Projection(..)\n+            | ty::Alias(ty::Opaque, ..)\n+            | ty::Alias(ty::Projection, ..)\n             | ty::GeneratorWitness(..) => bug!(\"Encountered invalid type {:?}\", ty),\n         }\n     }"}, {"sha": "b070ca9b0b778d72e52ec0b6f9cb007339710acf", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -241,7 +241,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 };\n \n                 let kind = match parent_ty.ty.kind() {\n-                    &ty::Opaque(ty::AliasTy { def_id, substs }) => {\n+                    &ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) => {\n                         self.tcx.bound_type_of(def_id).subst(self.tcx, substs).kind()\n                     }\n                     kind => kind,\n@@ -652,7 +652,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                     self.fail(location, \"`SetDiscriminant`is not allowed until deaggregation\");\n                 }\n                 let pty = place.ty(&self.body.local_decls, self.tcx).ty.kind();\n-                if !matches!(pty, ty::Adt(..) | ty::Generator(..) | ty::Opaque(..)) {\n+                if !matches!(pty, ty::Adt(..) | ty::Generator(..) | ty::Alias(ty::Opaque, ..)) {\n                     self.fail(\n                         location,\n                         format!("}, {"sha": "c31cd94699063d6073cfcf7f442a4d85ef062cf5", "filename": "compiler/rustc_const_eval/src/util/type_name.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Ftype_name.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -58,8 +58,8 @@ impl<'tcx> Printer<'tcx> for AbsolutePathPrinter<'tcx> {\n             // Types with identity (print the module path).\n             ty::Adt(ty::AdtDef(Interned(&ty::AdtDefData { did: def_id, .. }, _)), substs)\n             | ty::FnDef(def_id, substs)\n-            | ty::Opaque(ty::AliasTy { def_id, substs })\n-            | ty::Projection(ty::AliasTy { def_id, substs })\n+            | ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs })\n+            | ty::Alias(ty::Projection, ty::AliasTy { def_id, substs })\n             | ty::Closure(def_id, substs)\n             | ty::Generator(def_id, substs, _) => self.print_def_path(def_id, substs),\n             ty::Foreign(def_id) => self.print_def_path(def_id, &[]),"}, {"sha": "c8c10385f0cd60c4d035985c1931e1277e6f8f1a", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -1241,7 +1241,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 //\n                 // Calling `skip_binder` is okay, because `add_bounds` expects the `param_ty`\n                 // parameter to have a skipped binder.\n-                let param_ty = tcx.mk_ty(ty::Projection(projection_ty.skip_binder()));\n+                let param_ty = tcx.mk_ty(ty::Alias(ty::Projection, projection_ty.skip_binder()));\n                 self.add_bounds(param_ty, ast_bounds.iter(), bounds, candidate.bound_vars());\n             }\n         }"}, {"sha": "dd841707b29069e3510d38db347891b553afa1c5", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -1440,7 +1440,7 @@ fn opaque_type_cycle_error(tcx: TyCtxt<'_>, def_id: LocalDefId, span: Span) -> E\n                 impl<'tcx> ty::visit::TypeVisitor<'tcx> for OpaqueTypeCollector {\n                     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n                         match *t.kind() {\n-                            ty::Opaque(ty::AliasTy { def_id: def, substs: _ }) => {\n+                            ty::Alias(ty::Opaque, ty::AliasTy { def_id: def, substs: _ }) => {\n                                 self.0.push(def);\n                                 ControlFlow::CONTINUE\n                             }"}, {"sha": "ba7d31cea2e2f3e778702c331738ca93ab9dffc7", "filename": "compiler/rustc_hir_analysis/src/check/compare_method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -571,7 +571,7 @@ impl<'tcx> TypeFolder<'tcx> for ImplTraitInTraitCollector<'_, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        if let ty::Projection(proj) = ty.kind()\n+        if let ty::Alias(ty::Projection, proj) = ty.kind()\n             && self.tcx().def_kind(proj.def_id) == DefKind::ImplTraitPlaceholder\n         {\n             if let Some((ty, _)) = self.types.get(&proj.def_id) {\n@@ -1734,7 +1734,7 @@ pub fn check_type_bounds<'tcx>(\n     let normalize_param_env = {\n         let mut predicates = param_env.caller_bounds().iter().collect::<Vec<_>>();\n         match impl_ty_value.kind() {\n-            ty::Projection(proj)\n+            ty::Alias(ty::Projection, proj)\n                 if proj.def_id == trait_ty.def_id && proj.substs == rebased_substs =>\n             {\n                 // Don't include this predicate if the projected type is"}, {"sha": "94d333c336ef3f2768267d1ea3ce72147dd57e25", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -759,7 +759,7 @@ impl<'tcx> TypeVisitor<'tcx> for GATSubstCollector<'tcx> {\n \n     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         match t.kind() {\n-            ty::Projection(p) if p.def_id == self.gat => {\n+            ty::Alias(ty::Projection, p) if p.def_id == self.gat => {\n                 for (idx, subst) in p.substs.iter().enumerate() {\n                     match subst.unpack() {\n                         GenericArgKind::Lifetime(lt) if !lt.is_late_bound() => {\n@@ -1592,7 +1592,7 @@ fn check_return_position_impl_trait_in_trait_bounds<'tcx>(\n     {\n         for arg in fn_output.walk() {\n             if let ty::GenericArgKind::Type(ty) = arg.unpack()\n-                && let ty::Projection(proj) = ty.kind()\n+                && let ty::Alias(ty::Projection, proj) = ty.kind()\n                 && tcx.def_kind(proj.def_id) == DefKind::ImplTraitPlaceholder\n                 && tcx.impl_trait_in_trait_parent(proj.def_id) == fn_def_id.to_def_id()\n             {"}, {"sha": "32c3e95688b87c470006dde0b3ba83f69f94ead2", "filename": "compiler/rustc_hir_analysis/src/coherence/inherent_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -223,7 +223,7 @@ impl<'tcx> InherentCollect<'tcx> {\n             | ty::Tuple(..) => {\n                 self.check_primitive_impl(item.owner_id.def_id, self_ty, items, ty.span)\n             }\n-            ty::Projection(..) | ty::Opaque(..) | ty::Param(_) => {\n+            ty::Alias(ty::Projection, ..) | ty::Alias(ty::Opaque, ..) | ty::Param(_) => {\n                 let mut err = struct_span_err!(\n                     self.tcx.sess,\n                     ty.span,"}, {"sha": "b4ad3467e7d87ac67cac22c7705cedb92ea5cccf", "filename": "compiler/rustc_hir_analysis/src/collect/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -1749,7 +1749,7 @@ fn is_late_bound_map(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<&FxIndexSet<\n                 ty::Param(param_ty) => {\n                     self.arg_is_constrained[param_ty.index as usize] = true;\n                 }\n-                ty::Projection(_) => return ControlFlow::Continue(()),\n+                ty::Alias(ty::Projection, _) => return ControlFlow::Continue(()),\n                 _ => (),\n             }\n             t.super_visit_with(self)"}, {"sha": "776bfe9c53ae284a19ade042f07e25d12ab62380", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -411,7 +411,7 @@ pub(super) fn explicit_predicates_of<'tcx>(\n             //       substs are the same as the trait's.\n             // * It must be an associated type for this trait (*not* a\n             //   supertrait).\n-            if let ty::Projection(projection) = ty.kind() {\n+            if let ty::Alias(ty::Projection, projection) = ty.kind() {\n                 projection.substs == trait_identity_substs\n                     && tcx.associated_item(projection.def_id).container_id(tcx) == def_id\n             } else {"}, {"sha": "b678990f94e918ba6f9f26ad160b9771b19366b7", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -52,7 +52,7 @@ pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<\n             // Using the ItemCtxt convert the HIR for the unresolved assoc type into a\n             // ty which is a fully resolved projection.\n             // For the code example above, this would mean converting Self::Assoc<3>\n-            // into a ty::Projection(<Self as Foo>::Assoc<3>)\n+            // into a ty::Alias(ty::Projection, <Self as Foo>::Assoc<3>)\n             let item_hir_id = tcx\n                 .hir()\n                 .parent_iter(hir_id)\n@@ -68,7 +68,7 @@ pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<\n             // the def_id that this query was called with. We filter to only type and const args here\n             // as a precaution for if it's ever allowed to elide lifetimes in GAT's. It currently isn't\n             // but it can't hurt to be safe ^^\n-            if let ty::Projection(projection) = ty.kind() {\n+            if let ty::Alias(ty::Projection, projection) = ty.kind() {\n                 let generics = tcx.generics_of(projection.def_id);\n \n                 let arg_index = segment"}, {"sha": "95c971c0d7845eee2d63668b8527c419b67eb4e6", "filename": "compiler/rustc_hir_analysis/src/constrained_generic_params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_analysis%2Fsrc%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_analysis%2Fsrc%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fconstrained_generic_params.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -59,7 +59,7 @@ struct ParameterCollector {\n impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         match *t.kind() {\n-            ty::Projection(..) if !self.include_nonconstraining => {\n+            ty::Alias(ty::Projection, ..) if !self.include_nonconstraining => {\n                 // projections are not injective\n                 return ControlFlow::CONTINUE;\n             }"}, {"sha": "af8d7e8515865583d84f4769944025e7d6483ded", "filename": "compiler/rustc_hir_analysis/src/outlives/implicit_infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -196,7 +196,7 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                 }\n             }\n \n-            ty::Projection(obj) => {\n+            ty::Alias(ty::Projection, obj) => {\n                 // This corresponds to `<T as Foo<'a>>::Bar`. In this case, we should use the\n                 // explicit predicates as well.\n                 debug!(\"Projection\");"}, {"sha": "75bb7abf0ed2e6d7da380ab41dfa7dc54e5bfad9", "filename": "compiler/rustc_hir_analysis/src/variance/constraints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fconstraints.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -249,11 +249,11 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.add_constraints_from_substs(current, def.did(), substs, variance);\n             }\n \n-            ty::Projection(ref data) => {\n+            ty::Alias(ty::Projection, ref data) => {\n                 self.add_constraints_from_invariant_substs(current, data.substs, variance);\n             }\n \n-            ty::Opaque(ty::AliasTy { def_id: _, substs }) => {\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id: _, substs }) => {\n                 self.add_constraints_from_invariant_substs(current, substs, variance);\n             }\n "}, {"sha": "feb49ed1e30fe08a519d336342f670d9638ffd58", "filename": "compiler/rustc_hir_analysis/src/variance/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -112,8 +112,8 @@ fn variance_of_opaque(tcx: TyCtxt<'_>, item_def_id: LocalDefId) -> &[ty::Varianc\n         fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n             // FIXME(alias): merge these\n             match t.kind() {\n-                ty::Opaque(ty::AliasTy { def_id, substs }) => self.visit_opaque(*def_id, substs),\n-                ty::Projection(proj)\n+                ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) => self.visit_opaque(*def_id, substs),\n+                ty::Alias(ty::Projection, proj)\n                     if self.tcx.def_kind(proj.def_id) == DefKind::ImplTraitPlaceholder =>\n                 {\n                     self.visit_opaque(proj.def_id, proj.substs)"}, {"sha": "a86bd80a668b03d74aed8daed979d3679f264765", "filename": "compiler/rustc_hir_typeck/src/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -212,7 +212,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.can_coerce(arm_ty, ret_ty)\n                     && prior_arm.map_or(true, |(_, ty, _)| self.can_coerce(ty, ret_ty))\n                     // The match arms need to unify for the case of `impl Trait`.\n-                    && !matches!(ret_ty.kind(), ty::Opaque(..))\n+                    && !matches!(ret_ty.kind(), ty::Alias(ty::Opaque, ..))\n             }\n             _ => false,\n         };\n@@ -518,7 +518,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 let substs = sig.output().walk().find_map(|arg| {\n                     if let ty::GenericArgKind::Type(ty) = arg.unpack()\n-                        && let ty::Opaque(ty::AliasTy { def_id, substs }) = *ty.kind()\n+                        && let ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) = *ty.kind()\n                         && def_id == rpit_def_id\n                     {\n                         Some(substs)"}, {"sha": "235e9c661a909609b3d2a96d6476c21b003c3618", "filename": "compiler/rustc_hir_typeck/src/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -118,8 +118,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Pointers to foreign types are thin, despite being unsized\n             ty::Foreign(..) => Some(PointerKind::Thin),\n             // We should really try to normalize here.\n-            ty::Projection(pi) => Some(PointerKind::OfProjection(pi)),\n-            ty::Opaque(ty::AliasTy { def_id, substs }) => {\n+            ty::Alias(ty::Projection, pi) => Some(PointerKind::OfProjection(pi)),\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) => {\n                 Some(PointerKind::OfOpaque(def_id, substs))\n             }\n             ty::Param(p) => Some(PointerKind::OfParam(p)),"}, {"sha": "a96d27868a6d50d128ec8f1230c5a0825c7b91fa", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -167,9 +167,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected_ty: Ty<'tcx>,\n     ) -> (Option<ExpectedSig<'tcx>>, Option<ty::ClosureKind>) {\n         match *expected_ty.kind() {\n-            ty::Opaque(ty::AliasTy { def_id, substs }) => self.deduce_signature_from_predicates(\n-                self.tcx.bound_explicit_item_bounds(def_id).subst_iter_copied(self.tcx, substs),\n-            ),\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) => self\n+                .deduce_signature_from_predicates(\n+                    self.tcx.bound_explicit_item_bounds(def_id).subst_iter_copied(self.tcx, substs),\n+                ),\n             ty::Dynamic(ref object_type, ..) => {\n                 let sig = object_type.projection_bounds().find_map(|pb| {\n                     let pb = pb.with_self_ty(self.tcx, self.tcx.types.trait_object_dummy_self);\n@@ -677,13 +678,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     get_future_output(obligation.predicate, obligation.cause.span)\n                 })?\n             }\n-            ty::Opaque(ty::AliasTy { def_id, substs }) => self\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) => self\n                 .tcx\n                 .bound_explicit_item_bounds(def_id)\n                 .subst_iter_copied(self.tcx, substs)\n                 .find_map(|(p, s)| get_future_output(p, s))?,\n             ty::Error(_) => return None,\n-            ty::Projection(proj)\n+            ty::Alias(ty::Projection, proj)\n                 if self.tcx.def_kind(proj.def_id) == DefKind::ImplTraitPlaceholder =>\n             {\n                 self.tcx"}, {"sha": "a4ca7571142b6b1ea2c165521d834c01c3fa8377", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -1805,7 +1805,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         {\n             let ty = <dyn AstConv<'_>>::ast_ty_to_ty(fcx, ty);\n             // Get the `impl Trait`'s `DefId`.\n-            if let ty::Opaque(ty::AliasTy { def_id, substs: _ }) = ty.kind()\n+            if let ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }) = ty.kind()\n                 // Get the `impl Trait`'s `Item` so that we can get its trait bounds and\n                 // get the `Trait`'s `DefId`.\n                 && let hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds, .. }) ="}, {"sha": "4e2a78562240710741f64a61f99c76a75550fb4b", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -2391,7 +2391,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty::Param(param_ty) => {\n                 self.point_at_param_definition(&mut err, param_ty);\n             }\n-            ty::Opaque(ty::AliasTy { def_id: _, substs: _ }) => {\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id: _, substs: _ }) => {\n                 self.suggest_await_on_field_access(&mut err, ident, base, base_ty.peel_refs());\n             }\n             _ => {}"}, {"sha": "c8ea8ba5ab0655837ce7c16617890516e8c25e01", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -716,7 +716,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if formal_ret.has_infer_types() {\n             for ty in ret_ty.walk() {\n                 if let ty::subst::GenericArgKind::Type(ty) = ty.unpack()\n-                    && let ty::Opaque(ty::AliasTy { def_id, substs: _ }) = *ty.kind()\n+                    && let ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }) = *ty.kind()\n                     && let Some(def_id) = def_id.as_local()\n                     && self.opaque_type_origin(def_id, DUMMY_SP).is_some() {\n                     return None;"}, {"sha": "615f374b2ec0b8e3f2c34d63247424d4a4f9dd12", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -2124,7 +2124,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n                     }\n                 }\n-                ty::Opaque(ty::AliasTy { def_id: new_def_id, substs: _ })\n+                ty::Alias(ty::Opaque, ty::AliasTy { def_id: new_def_id, substs: _ })\n                 | ty::Closure(new_def_id, _)\n                 | ty::FnDef(new_def_id, _) => {\n                     def_id = new_def_id;\n@@ -2217,7 +2217,7 @@ fn find_param_in_ty<'tcx>(ty: Ty<'tcx>, param_to_point_at: ty::GenericArg<'tcx>)\n         if arg == param_to_point_at {\n             return true;\n         } else if let ty::GenericArgKind::Type(ty) = arg.unpack()\n-            && let ty::Projection(..) = ty.kind()\n+            && let ty::Alias(ty::Projection, ..) = ty.kind()\n         {\n             // This logic may seem a bit strange, but typically when\n             // we have a projection type in a function signature, the"}, {"sha": "e6e1098e33d74057a0615355aaacc1f7a497c3a8", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -174,7 +174,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let fn_sig = substs.as_closure().sig();\n                     Some((DefIdOrName::DefId(def_id), fn_sig.output(), fn_sig.inputs().map_bound(|inputs| &inputs[1..])))\n                 }\n-                ty::Opaque(ty::AliasTy { def_id, substs }) => {\n+                ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) => {\n                     self.tcx.bound_item_bounds(def_id).subst(self.tcx, substs).iter().find_map(|pred| {\n                         if let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) = pred.kind().skip_binder()\n                         && Some(proj.projection_ty.def_id) == self.tcx.lang_items().fn_once_output()"}, {"sha": "d83b9eb995d2b687e2502191122f00e4e91ffd8c", "filename": "compiler/rustc_hir_typeck/src/generator_interior/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -563,7 +563,7 @@ fn check_must_not_suspend_ty<'tcx>(\n         }\n         ty::Adt(def, _) => check_must_not_suspend_def(fcx.tcx, def.did(), hir_id, data),\n         // FIXME: support adding the attribute to TAITs\n-        ty::Opaque(ty::AliasTy { def_id: def, substs: _ }) => {\n+        ty::Alias(ty::Opaque, ty::AliasTy { def_id: def, substs: _ }) => {\n             let mut has_emitted = false;\n             for &(predicate, _) in fcx.tcx.explicit_item_bounds(def) {\n                 // We only look at the `DefId`, so it is safe to skip the binder here."}, {"sha": "c8be8c2721ffa168f07d4d96d5d0cadc68e9f35f", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -1969,7 +1969,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         | ty::Float(_)\n                         | ty::Adt(_, _)\n                         | ty::Str\n-                        | ty::Projection(_)\n+                        | ty::Alias(ty::Projection, _)\n                         | ty::Param(_) => format!(\"{deref_ty}\"),\n                         // we need to test something like  <&[_]>::len or <(&[u32])>::len\n                         // and Vec::function();"}, {"sha": "d25d9672c36d05ef7e638be2860812a0cfe671a3", "filename": "compiler/rustc_hir_typeck/src/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -546,7 +546,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             impl<'tcx> ty::TypeVisitor<'tcx> for RecursionChecker {\n                 type BreakTy = ();\n                 fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-                    if let ty::Opaque(ty::AliasTy { def_id, substs: _ }) = *t.kind() {\n+                    if let ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }) = *t.kind() {\n                         if def_id == self.def_id.to_def_id() {\n                             return ControlFlow::Break(());\n                         }"}, {"sha": "79a55c5883acc34a4c3ac15d5a21a6dd4470b0a5", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -453,10 +453,10 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n             | ty::Dynamic(..)\n             | ty::Never\n             | ty::Tuple(..)\n-            | ty::Projection(..)\n+            | ty::Alias(ty::Projection, ..)\n             | ty::Foreign(..)\n             | ty::Param(..)\n-            | ty::Opaque(..) => {\n+            | ty::Alias(ty::Opaque, ..) => {\n                 if t.flags().intersects(self.needs_canonical_flags) {\n                     t.super_fold_with(self)\n                 } else {"}, {"sha": "316077f69d99b65ffc8fb15c4bd43c1853b60c34", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -675,7 +675,7 @@ impl<'tcx> TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                 // relatable.\n                 Ok(t)\n             }\n-            ty::Opaque(ty::AliasTy { def_id, substs }) => {\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) => {\n                 let s = self.relate(substs, substs)?;\n                 Ok(if s == substs { t } else { self.infcx.tcx.mk_opaque(def_id, s) })\n             }"}, {"sha": "9fd4bdee096ac81dc36862ab93218da4d7019b07", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -101,13 +101,13 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n             }\n \n             (\n-                &ty::Opaque(ty::AliasTy { def_id: a_def_id, substs: _ }),\n-                &ty::Opaque(ty::AliasTy { def_id: b_def_id, substs: _ }),\n+                &ty::Alias(ty::Opaque, ty::AliasTy { def_id: a_def_id, substs: _ }),\n+                &ty::Alias(ty::Opaque, ty::AliasTy { def_id: b_def_id, substs: _ }),\n             ) if a_def_id == b_def_id => {\n                 self.fields.infcx.super_combine_tys(self, a, b)?;\n             }\n-            (&ty::Opaque(ty::AliasTy { def_id, substs: _ }), _)\n-            | (_, &ty::Opaque(ty::AliasTy { def_id, substs: _ }))\n+            (&ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }), _)\n+            | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }))\n                 if self.fields.define_opaque_types && def_id.is_local() =>\n             {\n                 self.fields.obligations.extend("}, {"sha": "7079322a4a4609830716c4deddf4e4d771176793", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -340,8 +340,8 @@ impl<'tcx> InferCtxt<'tcx> {\n     pub fn get_impl_future_output_ty(&self, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n         // FIXME(alias): Merge these\n         let (def_id, substs) = match *ty.kind() {\n-            ty::Opaque(ty::AliasTy { def_id, substs }) => (def_id, substs),\n-            ty::Projection(data)\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) => (def_id, substs),\n+            ty::Alias(ty::Projection, data)\n                 if self.tcx.def_kind(data.def_id) == DefKind::ImplTraitPlaceholder =>\n             {\n                 (data.def_id, data.substs)\n@@ -1732,7 +1732,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     let sort_string = |ty: Ty<'tcx>, path: Option<PathBuf>| {\n                         // FIXME(alias): Merge these\n                         let mut s = match (extra, ty.kind()) {\n-                            (true, ty::Opaque(ty::AliasTy { def_id, .. })) => {\n+                            (true, ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. })) => {\n                                 let sm = self.tcx.sess.source_map();\n                                 let pos = sm.lookup_char_pos(self.tcx.def_span(*def_id).lo());\n                                 format!(\n@@ -1742,7 +1742,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                                     pos.col.to_usize() + 1,\n                                 )\n                             }\n-                            (true, ty::Projection(proj))\n+                            (true, ty::Alias(ty::Projection, proj))\n                                 if self.tcx.def_kind(proj.def_id)\n                                     == DefKind::ImplTraitPlaceholder =>\n                             {\n@@ -2385,10 +2385,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                         // fn get_later<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n                         // suggest:\n                         // fn get_later<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n-                        ty::Closure(_, _substs)\n-                        | ty::Opaque(ty::AliasTy { def_id: _, substs: _substs })\n-                            if return_impl_trait =>\n-                        {\n+                        ty::Closure(..) | ty::Alias(ty::Opaque, ..) if return_impl_trait => {\n                             new_binding_suggestion(&mut err, type_param_span);\n                         }\n                         _ => {\n@@ -2770,7 +2767,9 @@ impl TyCategory {\n     pub fn from_ty(tcx: TyCtxt<'_>, ty: Ty<'_>) -> Option<(Self, DefId)> {\n         match *ty.kind() {\n             ty::Closure(def_id, _) => Some((Self::Closure, def_id)),\n-            ty::Opaque(ty::AliasTy { def_id, substs: _ }) => Some((Self::Opaque, def_id)),\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }) => {\n+                Some((Self::Opaque, def_id))\n+            }\n             ty::Generator(def_id, ..) => {\n                 Some((Self::Generator(tcx.generator_kind(def_id).unwrap()), def_id))\n             }"}, {"sha": "4f9e069c1763d08789c78175be6c926fe3e3d8fa", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -852,7 +852,10 @@ impl<'a, 'tcx> FindInferSourceVisitor<'a, 'tcx> {\n             match inner.unpack() {\n                 GenericArgKind::Lifetime(_) => {}\n                 GenericArgKind::Type(ty) => {\n-                    if matches!(ty.kind(), ty::Opaque(..) | ty::Closure(..) | ty::Generator(..)) {\n+                    if matches!(\n+                        ty.kind(),\n+                        ty::Alias(ty::Opaque, ..) | ty::Closure(..) | ty::Generator(..)\n+                    ) {\n                         // Opaque types can't be named by the user right now.\n                         //\n                         // Both the generic arguments of closures and generators can"}, {"sha": "62655d11ca309fd448cd44c8c7dfc4c85e4585fd", "filename": "compiler/rustc_infer/src/infer/error_reporting/suggest.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -487,12 +487,12 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 StatementAsExpression::CorrectType\n             }\n             (\n-                ty::Opaque(ty::AliasTy { def_id: last_def_id, substs: _ }),\n-                ty::Opaque(ty::AliasTy { def_id: exp_def_id, substs: _ }),\n+                ty::Alias(ty::Opaque, ty::AliasTy { def_id: last_def_id, substs: _ }),\n+                ty::Alias(ty::Opaque, ty::AliasTy { def_id: exp_def_id, substs: _ }),\n             ) if last_def_id == exp_def_id => StatementAsExpression::CorrectType,\n             (\n-                ty::Opaque(ty::AliasTy { def_id: last_def_id, substs: last_bounds }),\n-                ty::Opaque(ty::AliasTy { def_id: exp_def_id, substs: exp_bounds }),\n+                ty::Alias(ty::Opaque, ty::AliasTy { def_id: last_def_id, substs: last_bounds }),\n+                ty::Alias(ty::Opaque, ty::AliasTy { def_id: exp_def_id, substs: exp_bounds }),\n             ) => {\n                 debug!(\n                     \"both opaque, likely future {:?} {:?} {:?} {:?}\","}, {"sha": "8f53b1ccdf45829c758721072cf55d1063f730ff", "filename": "compiler/rustc_infer/src/infer/freshen.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -205,12 +205,11 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n             | ty::Dynamic(..)\n             | ty::Never\n             | ty::Tuple(..)\n-            | ty::Projection(..)\n+            | ty::Alias(..)\n             | ty::Foreign(..)\n             | ty::Param(..)\n             | ty::Closure(..)\n-            | ty::GeneratorWitness(..)\n-            | ty::Opaque(..) => t.super_fold_with(self),\n+            | ty::GeneratorWitness(..) => t.super_fold_with(self),\n \n             ty::Placeholder(..) | ty::Bound(..) => bug!(\"unexpected type {:?}\", t),\n         }"}, {"sha": "47d76dc5bdf02904cebcff63dd042038284cd0d4", "filename": "compiler/rustc_infer/src/infer/lattice.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -106,11 +106,11 @@ where\n         }\n \n         (\n-            &ty::Opaque(ty::AliasTy { def_id: a_def_id, substs: _ }),\n-            &ty::Opaque(ty::AliasTy { def_id: b_def_id, substs: _ }),\n+            &ty::Alias(ty::Opaque, ty::AliasTy { def_id: a_def_id, substs: _ }),\n+            &ty::Alias(ty::Opaque, ty::AliasTy { def_id: b_def_id, substs: _ }),\n         ) if a_def_id == b_def_id => infcx.super_combine_tys(this, a, b),\n-        (&ty::Opaque(ty::AliasTy { def_id, substs: _ }), _)\n-        | (_, &ty::Opaque(ty::AliasTy { def_id, substs: _ }))\n+        (&ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }), _)\n+        | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }))\n             if this.define_opaque_types() && def_id.is_local() =>\n         {\n             this.add_obligations("}, {"sha": "3b9683e5b59333542f09347aaeaf123bd9b7295a", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -281,7 +281,7 @@ where\n         use rustc_span::DUMMY_SP;\n \n         match *value_ty.kind() {\n-            ty::Projection(other_projection_ty) => {\n+            ty::Alias(ty::Projection, other_projection_ty) => {\n                 let var = self.infcx.next_ty_var(TypeVariableOrigin {\n                     kind: TypeVariableOriginKind::MiscVariable,\n                     span: DUMMY_SP,\n@@ -335,7 +335,9 @@ where\n                 return Ok(value_ty);\n             }\n \n-            ty::Projection(projection_ty) if D::normalization() == NormalizationStrategy::Lazy => {\n+            ty::Alias(ty::Projection, projection_ty)\n+                if D::normalization() == NormalizationStrategy::Lazy =>\n+            {\n                 return Ok(self.relate_projection_ty(projection_ty, self.infcx.tcx.mk_ty_var(vid)));\n             }\n \n@@ -406,8 +408,8 @@ where\n             }\n         };\n         let (a, b) = match (a.kind(), b.kind()) {\n-            (&ty::Opaque(..), _) => (a, generalize(b, false)?),\n-            (_, &ty::Opaque(..)) => (generalize(a, true)?, b),\n+            (&ty::Alias(ty::Opaque, ..), _) => (a, generalize(b, false)?),\n+            (_, &ty::Alias(ty::Opaque, ..)) => (generalize(a, true)?, b),\n             _ => unreachable!(),\n         };\n         let cause = ObligationCause::dummy_with_span(self.delegate.span());\n@@ -609,29 +611,29 @@ where\n             (&ty::Infer(ty::TyVar(vid)), _) => self.relate_ty_var((vid, b)),\n \n             (\n-                &ty::Opaque(ty::AliasTy { def_id: a_def_id, substs: _ }),\n-                &ty::Opaque(ty::AliasTy { def_id: b_def_id, substs: _ }),\n+                &ty::Alias(ty::Opaque, ty::AliasTy { def_id: a_def_id, substs: _ }),\n+                &ty::Alias(ty::Opaque, ty::AliasTy { def_id: b_def_id, substs: _ }),\n             ) if a_def_id == b_def_id => infcx.super_combine_tys(self, a, b).or_else(|err| {\n                 self.tcx().sess.delay_span_bug(\n                     self.delegate.span(),\n                     \"failure to relate an opaque to itself should result in an error later on\",\n                 );\n                 if a_def_id.is_local() { self.relate_opaques(a, b) } else { Err(err) }\n             }),\n-            (&ty::Opaque(ty::AliasTy { def_id, substs: _ }), _)\n-            | (_, &ty::Opaque(ty::AliasTy { def_id, substs: _ }))\n+            (&ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }), _)\n+            | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }))\n                 if def_id.is_local() =>\n             {\n                 self.relate_opaques(a, b)\n             }\n \n-            (&ty::Projection(projection_ty), _)\n+            (&ty::Alias(ty::Projection, projection_ty), _)\n                 if D::normalization() == NormalizationStrategy::Lazy =>\n             {\n                 Ok(self.relate_projection_ty(projection_ty, b))\n             }\n \n-            (_, &ty::Projection(projection_ty))\n+            (_, &ty::Alias(ty::Projection, projection_ty))\n                 if D::normalization() == NormalizationStrategy::Lazy =>\n             {\n                 Ok(self.relate_projection_ty(projection_ty, a))"}, {"sha": "98f08e831735caa036a885641561dcf1fa33acb6", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -66,7 +66,7 @@ impl<'tcx> InferCtxt<'tcx> {\n             lt_op: |lt| lt,\n             ct_op: |ct| ct,\n             ty_op: |ty| match *ty.kind() {\n-                ty::Opaque(ty::AliasTy { def_id, substs: _substs })\n+                ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ })\n                     if replace_opaque_type(def_id) =>\n                 {\n                     let def_span = self.tcx.def_span(def_id);\n@@ -106,7 +106,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         }\n         let (a, b) = if a_is_expected { (a, b) } else { (b, a) };\n         let process = |a: Ty<'tcx>, b: Ty<'tcx>, a_is_expected| match *a.kind() {\n-            ty::Opaque(ty::AliasTy { def_id, substs }) if def_id.is_local() => {\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) if def_id.is_local() => {\n                 let def_id = def_id.expect_local();\n                 let origin = match self.defining_use_anchor {\n                     DefiningAnchor::Bind(_) => {\n@@ -149,7 +149,9 @@ impl<'tcx> InferCtxt<'tcx> {\n                     DefiningAnchor::Bubble => self.opaque_ty_origin_unchecked(def_id, cause.span),\n                     DefiningAnchor::Error => return None,\n                 };\n-                if let ty::Opaque(ty::AliasTy { def_id: b_def_id, substs: _ }) = *b.kind() {\n+                if let ty::Alias(ty::Opaque, ty::AliasTy { def_id: b_def_id, substs: _ }) =\n+                    *b.kind()\n+                {\n                     // We could accept this, but there are various ways to handle this situation, and we don't\n                     // want to make a decision on it right now. Likely this case is so super rare anyway, that\n                     // no one encounters it in practice.\n@@ -478,7 +480,7 @@ where\n                 substs.as_generator().resume_ty().visit_with(self);\n             }\n \n-            ty::Opaque(ty::AliasTy { def_id, ref substs }) => {\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, ref substs }) => {\n                 // Skip lifetime paramters that are not captures.\n                 let variances = self.tcx.variances_of(*def_id);\n \n@@ -489,7 +491,7 @@ where\n                 }\n             }\n \n-            ty::Projection(proj)\n+            ty::Alias(ty::Projection, proj)\n                 if self.tcx.def_kind(proj.def_id) == DefKind::ImplTraitPlaceholder =>\n             {\n                 // Skip lifetime paramters that are not captures.\n@@ -566,7 +568,7 @@ impl<'tcx> InferCtxt<'tcx> {\n                     // We can't normalize associated types from `rustc_infer`,\n                     // but we can eagerly register inference variables for them.\n                     // FIXME(RPITIT): Don't replace RPITITs with inference vars.\n-                    ty::Projection(projection_ty)\n+                    ty::Alias(ty::Projection, projection_ty)\n                         if !projection_ty.has_escaping_bound_vars()\n                             && tcx.def_kind(projection_ty.def_id)\n                                 != DefKind::ImplTraitPlaceholder =>\n@@ -581,13 +583,13 @@ impl<'tcx> InferCtxt<'tcx> {\n                     }\n                     // Replace all other mentions of the same opaque type with the hidden type,\n                     // as the bounds must hold on the hidden type after all.\n-                    ty::Opaque(ty::AliasTy { def_id: def_id2, substs: substs2 })\n+                    ty::Alias(ty::Opaque, ty::AliasTy { def_id: def_id2, substs: substs2 })\n                         if def_id.to_def_id() == def_id2 && substs == substs2 =>\n                     {\n                         hidden_ty\n                     }\n                     // FIXME(RPITIT): This can go away when we move to associated types\n-                    ty::Projection(proj)\n+                    ty::Alias(ty::Projection, proj)\n                         if def_id.to_def_id() == proj.def_id && substs == proj.substs =>\n                     {\n                         hidden_ty"}, {"sha": "984bbe169e6cf7ae110549236f2c6145de2dc3d4", "filename": "compiler/rustc_infer/src/infer/outlives/components.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -130,7 +130,7 @@ fn compute_components<'tcx>(\n             // outlives any other lifetime, which is unsound.\n             // See https://github.com/rust-lang/rust/issues/84305 for\n             // more details.\n-            ty::Opaque(ty::AliasTy { def_id, substs }) => {\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) => {\n                 out.push(Component::Opaque(def_id, substs));\n             },\n \n@@ -142,7 +142,7 @@ fn compute_components<'tcx>(\n             // trait-ref. Therefore, if we see any higher-ranked regions,\n             // we simply fallback to the most restrictive rule, which\n             // requires that `Pi: 'a` for all `i`.\n-            ty::Projection(ref data) => {\n+            ty::Alias(ty::Projection, ref data) => {\n                 if !data.has_escaping_bound_vars() {\n                     // best case: no escaping regions, so push the\n                     // projection and skip the subtree (thus generating no"}, {"sha": "da85de60199324b2d236e386699b3f235324b657", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -338,7 +338,7 @@ where\n             substs,\n             true,\n             |ty| match *ty.kind() {\n-                ty::Opaque(ty::AliasTy { def_id, substs }) => (def_id, substs),\n+                ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) => (def_id, substs),\n                 _ => bug!(\"expected only projection types from env, not {:?}\", ty),\n             },\n         );\n@@ -359,7 +359,9 @@ where\n             projection_ty.substs,\n             false,\n             |ty| match ty.kind() {\n-                ty::Projection(projection_ty) => (projection_ty.def_id, projection_ty.substs),\n+                ty::Alias(ty::Projection, projection_ty) => {\n+                    (projection_ty.def_id, projection_ty.substs)\n+                }\n                 _ => bug!(\"expected only projection types from env, not {:?}\", ty),\n             },\n         );"}, {"sha": "58e27f8b21d6366337fe89ecb46c8b5eb255f467", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -131,14 +131,14 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n             }\n \n             (\n-                &ty::Opaque(ty::AliasTy { def_id: a_def_id, substs: _ }),\n-                &ty::Opaque(ty::AliasTy { def_id: b_def_id, substs: _ }),\n+                &ty::Alias(ty::Opaque, ty::AliasTy { def_id: a_def_id, substs: _ }),\n+                &ty::Alias(ty::Opaque, ty::AliasTy { def_id: b_def_id, substs: _ }),\n             ) if a_def_id == b_def_id => {\n                 self.fields.infcx.super_combine_tys(self, a, b)?;\n                 Ok(a)\n             }\n-            (&ty::Opaque(ty::AliasTy { def_id, substs: _ }), _)\n-            | (_, &ty::Opaque(ty::AliasTy { def_id, substs: _ }))\n+            (&ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }), _)\n+            | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }))\n                 if self.fields.define_opaque_types && def_id.is_local() =>\n             {\n                 self.fields.obligations.extend("}, {"sha": "43862570e80954aa8c11dbd80e4aa4e060e66ed9", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -3016,8 +3016,8 @@ impl ClashingExternDeclarations {\n                         | (Closure(..), Closure(..))\n                         | (Generator(..), Generator(..))\n                         | (GeneratorWitness(..), GeneratorWitness(..))\n-                        | (Projection(..), Projection(..))\n-                        | (Opaque(..), Opaque(..)) => false,\n+                        | (Alias(ty::Projection, ..), Alias(ty::Projection, ..))\n+                        | (Alias(ty::Opaque, ..), Alias(ty::Opaque, ..)) => false,\n \n                         // These definitely should have been caught above.\n                         (Bool, Bool) | (Char, Char) | (Never, Never) | (Str, Str) => unreachable!(),"}, {"sha": "3808d308186c0ee104b8f6a41d4fbd17f621bb17", "filename": "compiler/rustc_lint/src/opaque_hidden_inferred_bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -117,7 +117,7 @@ impl<'tcx> LateLintPass<'tcx> for OpaqueHiddenInferredBound {\n                     // then we can emit a suggestion to add the bound.\n                     let add_bound = match (proj_term.kind(), assoc_pred.kind().skip_binder()) {\n                         (\n-                            ty::Opaque(ty::AliasTy { def_id, substs: _ }),\n+                            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }),\n                             ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)),\n                         ) => Some(AddBound {\n                             suggest_span: cx.tcx.def_span(*def_id).shrink_to_hi(),"}, {"sha": "8e27bc03c489aeedf8ab0b5d2cd15776c8cff157", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -1139,18 +1139,20 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n             // While opaque types are checked for earlier, if a projection in a struct field\n             // normalizes to an opaque type, then it will reach this branch.\n-            ty::Opaque(..) => {\n+            ty::Alias(ty::Opaque, ..) => {\n                 FfiUnsafe { ty, reason: fluent::lint_improper_ctypes_opaque, help: None }\n             }\n \n             // `extern \"C\" fn` functions can have type parameters, which may or may not be FFI-safe,\n             //  so they are currently ignored for the purposes of this lint.\n-            ty::Param(..) | ty::Projection(..) if matches!(self.mode, CItemKind::Definition) => {\n+            ty::Param(..) | ty::Alias(ty::Projection, ..)\n+                if matches!(self.mode, CItemKind::Definition) =>\n+            {\n                 FfiSafe\n             }\n \n             ty::Param(..)\n-            | ty::Projection(..)\n+            | ty::Alias(ty::Projection, ..)\n             | ty::Infer(..)\n             | ty::Bound(..)\n             | ty::Error(_)\n@@ -1205,7 +1207,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                     return ControlFlow::CONTINUE;\n                 }\n \n-                if let ty::Opaque(..) = ty.kind() {\n+                if let ty::Alias(ty::Opaque, ..) = ty.kind() {\n                     ControlFlow::Break(ty)\n                 } else {\n                     ty.super_visit_with(self)"}, {"sha": "fb2c8b1ef647c85d3e9a4679b393703be441bd9f", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -96,7 +96,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n \n         if let hir::ExprKind::Match(await_expr, _arms, hir::MatchSource::AwaitDesugar) = expr.kind\n             && let ty = cx.typeck_results().expr_ty(&await_expr)\n-            && let ty::Opaque(ty::AliasTy { def_id: future_def_id, substs: _ }) = ty.kind()\n+            && let ty::Alias(ty::Opaque, ty::AliasTy { def_id: future_def_id, substs: _ }) = ty.kind()\n             && cx.tcx.ty_is_opaque_future(ty)\n             // FIXME: This also includes non-async fns that return `impl Future`.\n             && let async_fn_def_id = cx.tcx.parent(*future_def_id)\n@@ -251,7 +251,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                         .map(|inner| MustUsePath::Boxed(Box::new(inner)))\n                 }\n                 ty::Adt(def, _) => is_def_must_use(cx, def.did(), span),\n-                ty::Opaque(ty::AliasTy { def_id: def, substs: _ }) => {\n+                ty::Alias(ty::Opaque, ty::AliasTy { def_id: def, substs: _ }) => {\n                     elaborate_predicates_with_span(\n                         cx.tcx,\n                         cx.tcx.explicit_item_bounds(def).iter().cloned(),"}, {"sha": "856f5bc4645fdd34d691e7ab3a824ef603da15d1", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -1111,7 +1111,7 @@ fn should_encode_trait_impl_trait_tys<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) ->\n     // associated types.\n     tcx.fn_sig(trait_item_def_id).skip_binder().output().walk().any(|arg| {\n         if let ty::GenericArgKind::Type(ty) = arg.unpack()\n-            && let ty::Projection(data) = ty.kind()\n+            && let ty::Alias(ty::Projection, data) = ty.kind()\n             && tcx.def_kind(data.def_id) == DefKind::ImplTraitPlaceholder\n         {\n             true"}, {"sha": "dc333b4702f39e1a2a658c88f8ddce14966db3b6", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -115,8 +115,7 @@ impl<'tcx> Interner for TyCtxt<'tcx> {\n     type ListBinderExistentialPredicate = &'tcx List<PolyExistentialPredicate<'tcx>>;\n     type BinderListTy = Binder<'tcx, &'tcx List<Ty<'tcx>>>;\n     type ListTy = &'tcx List<Ty<'tcx>>;\n-    type ProjectionTy = ty::AliasTy<'tcx>;\n-    type OpaqueTy = ty::AliasTy<'tcx>;\n+    type AliasTy = ty::AliasTy<'tcx>;\n     type ParamTy = ParamTy;\n     type BoundTy = ty::BoundTy;\n     type PlaceholderType = ty::PlaceholderType;\n@@ -2145,8 +2144,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                     Bound,\n                     Param,\n                     Infer,\n-                    Projection,\n-                    Opaque,\n+                    Alias,\n                     Foreign\n                 )?;\n \n@@ -2323,7 +2321,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Given a `ty`, return whether it's an `impl Future<...>`.\n     pub fn ty_is_opaque_future(self, ty: Ty<'_>) -> bool {\n-        let ty::Opaque(ty::AliasTy { def_id, substs: _ }) = ty.kind() else { return false };\n+        let ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }) = ty.kind() else { return false };\n         let future_trait = self.require_lang_item(LangItem::Future, None);\n \n         self.explicit_item_bounds(def_id).iter().any(|(predicate, _)| {\n@@ -2598,7 +2596,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             substs.len(),\n             \"wrong number of generic parameters for {item_def_id:?}: {substs:?}\",\n         );\n-        self.mk_ty(Projection(AliasTy { def_id: item_def_id, substs }))\n+        self.mk_ty(Alias(ty::Projection, AliasTy { def_id: item_def_id, substs }))\n     }\n \n     #[inline]\n@@ -2668,7 +2666,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn mk_opaque(self, def_id: DefId, substs: SubstsRef<'tcx>) -> Ty<'tcx> {\n-        self.mk_ty(Opaque(ty::AliasTy { def_id, substs }))\n+        self.mk_ty(Alias(ty::Opaque, ty::AliasTy { def_id, substs }))\n     }\n \n     pub fn mk_place_field(self, place: Place<'tcx>, f: Field, ty: Ty<'tcx>) -> Place<'tcx> {"}, {"sha": "d7880a32ea9cd8f141b70ecadad0c5fca95836bd", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -4,7 +4,7 @@ use std::ops::ControlFlow;\n \n use crate::ty::{\n     visit::TypeVisitable, AliasTy, Const, ConstKind, DefIdTree, ExistentialPredicate, InferConst,\n-    InferTy, PolyTraitPredicate, Ty, TyCtxt, TypeSuperVisitable, TypeVisitor,\n+    InferTy, Opaque, PolyTraitPredicate, Ty, TyCtxt, TypeSuperVisitable, TypeVisitor,\n };\n \n use rustc_data_structures::fx::FxHashMap;\n@@ -457,10 +457,10 @@ impl<'tcx> TypeVisitor<'tcx> for IsSuggestableVisitor<'tcx> {\n                 return ControlFlow::Break(());\n             }\n \n-            Opaque(AliasTy { def_id, substs: _ }) => {\n+            Alias(Opaque, AliasTy { def_id, substs: _ }) => {\n                 let parent = self.tcx.parent(*def_id);\n                 if let hir::def::DefKind::TyAlias | hir::def::DefKind::AssocTy = self.tcx.def_kind(parent)\n-                    && let Opaque(AliasTy { def_id: parent_opaque_def_id, substs: _ }) = self.tcx.type_of(parent).kind()\n+                    && let Alias(Opaque, AliasTy { def_id: parent_opaque_def_id, substs: _ }) = self.tcx.type_of(parent).kind()\n                     && parent_opaque_def_id == def_id\n                 {\n                     // Okay"}, {"sha": "22dc921aba1ca13fd53a7604c6eafeb9b6eb6f08", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -337,9 +337,9 @@ impl<'tcx> Ty<'tcx> {\n             ty::Infer(ty::FreshTy(_)) => \"fresh type\".into(),\n             ty::Infer(ty::FreshIntTy(_)) => \"fresh integral type\".into(),\n             ty::Infer(ty::FreshFloatTy(_)) => \"fresh floating-point type\".into(),\n-            ty::Projection(_) => \"associated type\".into(),\n+            ty::Alias(ty::Projection, _) => \"associated type\".into(),\n             ty::Param(p) => format!(\"type parameter `{}`\", p).into(),\n-            ty::Opaque(..) => \"opaque type\".into(),\n+            ty::Alias(ty::Opaque, ..) => \"opaque type\".into(),\n             ty::Error(_) => \"type error\".into(),\n         }\n     }\n@@ -375,9 +375,9 @@ impl<'tcx> Ty<'tcx> {\n             ty::Tuple(..) => \"tuple\".into(),\n             ty::Placeholder(..) => \"higher-ranked type\".into(),\n             ty::Bound(..) => \"bound type variable\".into(),\n-            ty::Projection(_) => \"associated type\".into(),\n+            ty::Alias(ty::Projection, _) => \"associated type\".into(),\n             ty::Param(_) => \"type parameter\".into(),\n-            ty::Opaque(..) => \"opaque type\".into(),\n+            ty::Alias(ty::Opaque, ..) => \"opaque type\".into(),\n         }\n     }\n }\n@@ -400,7 +400,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                         diag.note(\"no two closures, even if identical, have the same type\");\n                         diag.help(\"consider boxing your closure and/or using it as a trait object\");\n                     }\n-                    (ty::Opaque(..), ty::Opaque(..)) => {\n+                    (ty::Alias(ty::Opaque, ..), ty::Alias(ty::Opaque, ..)) => {\n                         // Issue #63167\n                         diag.note(\"distinct uses of `impl Trait` result in different opaque types\");\n                     }\n@@ -439,10 +439,10 @@ impl<'tcx> TyCtxt<'tcx> {\n                              #traits-as-parameters\",\n                         );\n                     }\n-                    (ty::Projection(_), ty::Projection(_)) => {\n+                    (ty::Alias(ty::Projection, _), ty::Alias(ty::Projection, _)) => {\n                         diag.note(\"an associated type was expected, but a different one was found\");\n                     }\n-                    (ty::Param(p), ty::Projection(proj)) | (ty::Projection(proj), ty::Param(p))\n+                    (ty::Param(p), ty::Alias(ty::Projection, proj)) | (ty::Alias(ty::Projection, proj), ty::Param(p))\n                         if self.def_kind(proj.def_id) != DefKind::ImplTraitPlaceholder =>\n                     {\n                         let generics = self.generics_of(body_owner_def_id);\n@@ -493,8 +493,8 @@ impl<'tcx> TyCtxt<'tcx> {\n                             diag.note(\"you might be missing a type parameter or trait bound\");\n                         }\n                     }\n-                    (ty::Param(p), ty::Dynamic(..) | ty::Opaque(..))\n-                    | (ty::Dynamic(..) | ty::Opaque(..), ty::Param(p)) => {\n+                    (ty::Param(p), ty::Dynamic(..) | ty::Alias(ty::Opaque, ..))\n+                    | (ty::Dynamic(..) | ty::Alias(ty::Opaque, ..), ty::Param(p)) => {\n                         let generics = self.generics_of(body_owner_def_id);\n                         let p_span = self.def_span(generics.type_param(p, self).def_id);\n                         if !sp.contains(p_span) {\n@@ -553,7 +553,7 @@ impl<T> Trait<T> for X {\n                             diag.span_label(p_span, \"this type parameter\");\n                         }\n                     }\n-                    (ty::Projection(proj_ty), _) if self.def_kind(proj_ty.def_id) != DefKind::ImplTraitPlaceholder => {\n+                    (ty::Alias(ty::Projection, proj_ty), _) if self.def_kind(proj_ty.def_id) != DefKind::ImplTraitPlaceholder => {\n                         self.expected_projection(\n                             diag,\n                             proj_ty,\n@@ -562,7 +562,7 @@ impl<T> Trait<T> for X {\n                             cause.code(),\n                         );\n                     }\n-                    (_, ty::Projection(proj_ty)) if self.def_kind(proj_ty.def_id) != DefKind::ImplTraitPlaceholder => {\n+                    (_, ty::Alias(ty::Projection, proj_ty)) if self.def_kind(proj_ty.def_id) != DefKind::ImplTraitPlaceholder => {\n                         let msg = format!(\n                             \"consider constraining the associated type `{}` to `{}`\",\n                             values.found, values.expected,\n@@ -779,7 +779,8 @@ fn foo(&self) -> Self::T { String::new() }\n         ty: Ty<'tcx>,\n     ) -> bool {\n         let assoc = self.associated_item(proj_ty.def_id);\n-        if let ty::Opaque(ty::AliasTy { def_id, substs: _ }) = *proj_ty.self_ty().kind() {\n+        if let ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }) = *proj_ty.self_ty().kind()\n+        {\n             let opaque_local_def_id = def_id.as_local();\n             let opaque_hir_ty = if let Some(opaque_local_def_id) = opaque_local_def_id {\n                 match &self.hir().expect_item(opaque_local_def_id).kind {\n@@ -828,7 +829,7 @@ fn foo(&self) -> Self::T { String::new() }\n             .filter_map(|(_, item)| {\n                 let method = self.fn_sig(item.def_id);\n                 match *method.output().skip_binder().kind() {\n-                    ty::Projection(ty::AliasTy { def_id: item_def_id, .. })\n+                    ty::Alias(ty::Projection, ty::AliasTy { def_id: item_def_id, .. })\n                         if item_def_id == proj_ty_item_def_id =>\n                     {\n                         Some(("}, {"sha": "2771eb51a9b186f60d7779f0add3e78205830996", "filename": "compiler/rustc_middle/src/ty/fast_reject.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -126,7 +126,7 @@ pub fn simplify_type<'tcx>(\n             TreatParams::AsPlaceholder => Some(PlaceholderSimplifiedType),\n             TreatParams::AsInfer => None,\n         },\n-        ty::Opaque(..) | ty::Projection(_) => match treat_params {\n+        ty::Alias(ty::Opaque, ..) | ty::Alias(ty::Projection, _) => match treat_params {\n             // When treating `ty::Param` as a placeholder, projections also\n             // don't unify with anything else as long as they are fully normalized.\n             //\n@@ -225,7 +225,10 @@ impl DeepRejectCtxt {\n         match impl_ty.kind() {\n             // Start by checking whether the type in the impl may unify with\n             // pretty much everything. Just return `true` in that case.\n-            ty::Param(_) | ty::Projection(_) | ty::Error(_) | ty::Opaque(..) => return true,\n+            ty::Param(_)\n+            | ty::Alias(ty::Projection, _)\n+            | ty::Error(_)\n+            | ty::Alias(ty::Opaque, ..) => return true,\n             // These types only unify with inference variables or their own\n             // variant.\n             ty::Bool\n@@ -323,7 +326,7 @@ impl DeepRejectCtxt {\n                 _ => false,\n             },\n \n-            ty::Opaque(..) => true,\n+            ty::Alias(ty::Opaque, ..) => true,\n \n             // Impls cannot contain these types as these cannot be named directly.\n             ty::FnDef(..) | ty::Closure(..) | ty::Generator(..) => false,\n@@ -344,7 +347,7 @@ impl DeepRejectCtxt {\n             // projections can unify with other stuff.\n             //\n             // Looking forward to lazy normalization this is the safer strategy anyways.\n-            ty::Projection(_) => true,\n+            ty::Alias(ty::Projection, _) => true,\n \n             ty::Error(_) => true,\n "}, {"sha": "174ac74fc9e61f6e5b3cdaec8fc1b54491605092", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -155,12 +155,12 @@ impl FlagComputation {\n                 self.add_substs(substs);\n             }\n \n-            &ty::Projection(data) => {\n+            &ty::Alias(ty::Projection, data) => {\n                 self.add_flags(TypeFlags::HAS_TY_PROJECTION);\n                 self.add_projection_ty(data);\n             }\n \n-            &ty::Opaque(ty::AliasTy { def_id: _, substs }) => {\n+            &ty::Alias(ty::Opaque, ty::AliasTy { def_id: _, substs }) => {\n                 self.add_flags(TypeFlags::HAS_TY_OPAQUE);\n                 self.add_substs(substs);\n             }"}, {"sha": "5d5089cec82a696d105c196e45d16808e20569c5", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -112,7 +112,7 @@ impl<'tcx> Ty<'tcx> {\n                 InhabitedPredicate::True\n             }\n             Never => InhabitedPredicate::False,\n-            Param(_) | Projection(_) => InhabitedPredicate::GenericType(self),\n+            Param(_) | Alias(ty::Projection, _) => InhabitedPredicate::GenericType(self),\n             Tuple(tys) if tys.is_empty() => InhabitedPredicate::True,\n             // use a query for more complex cases\n             Adt(..) | Array(..) | Tuple(_) => tcx.inhabited_predicate_type(self),"}, {"sha": "40297492bb642f0336796a933d502c9e8eaf6cb1", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -271,7 +271,7 @@ impl<'tcx> SizeSkeleton<'tcx> {\n                 let non_zero = !ty.is_unsafe_ptr();\n                 let tail = tcx.struct_tail_erasing_lifetimes(pointee, param_env);\n                 match tail.kind() {\n-                    ty::Param(_) | ty::Projection(_) => {\n+                    ty::Param(_) | ty::Alias(ty::Projection, _) => {\n                         debug_assert!(tail.has_non_region_param());\n                         Ok(SizeSkeleton::Pointer { non_zero, tail: tcx.erase_regions(tail) })\n                     }\n@@ -349,7 +349,7 @@ impl<'tcx> SizeSkeleton<'tcx> {\n                 }\n             }\n \n-            ty::Projection(_) | ty::Opaque(..) => {\n+            ty::Alias(ty::Projection, _) | ty::Alias(ty::Opaque, ..) => {\n                 let normalized = tcx.normalize_erasing_regions(param_env, ty);\n                 if ty == normalized {\n                     Err(err)\n@@ -757,10 +757,10 @@ where\n                     }\n                 }\n \n-                ty::Projection(_)\n+                ty::Alias(ty::Projection, _)\n                 | ty::Bound(..)\n                 | ty::Placeholder(..)\n-                | ty::Opaque(..)\n+                | ty::Alias(ty::Opaque, ..)\n                 | ty::Param(_)\n                 | ty::Infer(_)\n                 | ty::Error(_) => bug!(\"TyAndLayout::field: unexpected type `{}`\", this.ty),"}, {"sha": "6cb28a0fd8077984dc8a3306034962b647cbd00c", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -64,6 +64,7 @@ use std::ops::ControlFlow;\n use std::{fmt, str};\n \n pub use crate::ty::diagnostics::*;\n+pub use rustc_type_ir::AliasKind::*;\n pub use rustc_type_ir::DynKind::*;\n pub use rustc_type_ir::InferTy::*;\n pub use rustc_type_ir::RegionKind::*;"}, {"sha": "8de8fd5246c48c072b7a98e4b057a712d50d55c9", "filename": "compiler/rustc_middle/src/ty/print/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -275,10 +275,10 @@ fn characteristic_def_id_of_type_cached<'a>(\n         | ty::Uint(_)\n         | ty::Str\n         | ty::FnPtr(_)\n-        | ty::Projection(_)\n+        | ty::Alias(ty::Projection, _)\n         | ty::Placeholder(..)\n         | ty::Param(_)\n-        | ty::Opaque(..)\n+        | ty::Alias(ty::Opaque, ..)\n         | ty::Infer(_)\n         | ty::Bound(..)\n         | ty::Error(_)"}, {"sha": "6acc2dc65d36942c7f7e53b5f8d28e12952af228", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -718,7 +718,7 @@ pub trait PrettyPrinter<'tcx>:\n             ty::Foreign(def_id) => {\n                 p!(print_def_path(def_id, &[]));\n             }\n-            ty::Projection(ref data) => {\n+            ty::Alias(ty::Projection, ref data) => {\n                 if !(self.should_print_verbose() || NO_QUERIES.with(|q| q.get()))\n                     && self.tcx().def_kind(data.def_id) == DefKind::ImplTraitPlaceholder\n                 {\n@@ -728,7 +728,7 @@ pub trait PrettyPrinter<'tcx>:\n                 }\n             }\n             ty::Placeholder(placeholder) => p!(write(\"Placeholder({:?})\", placeholder)),\n-            ty::Opaque(ty::AliasTy { def_id, substs }) => {\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) => {\n                 // FIXME(eddyb) print this with `print_def_path`.\n                 // We use verbose printing in 'NO_QUERIES' mode, to\n                 // avoid needing to call `predicates_of`. This should\n@@ -743,7 +743,7 @@ pub trait PrettyPrinter<'tcx>:\n                 let parent = self.tcx().parent(def_id);\n                 match self.tcx().def_kind(parent) {\n                     DefKind::TyAlias | DefKind::AssocTy => {\n-                        if let ty::Opaque(ty::AliasTy { def_id: d, substs: _ }) =\n+                        if let ty::Alias(ty::Opaque, ty::AliasTy { def_id: d, substs: _ }) =\n                             *self.tcx().type_of(parent).kind()\n                         {\n                             if d == def_id {\n@@ -1021,7 +1021,7 @@ pub trait PrettyPrinter<'tcx>:\n                         // Skip printing `<[generator@] as Generator<_>>::Return` from async blocks,\n                         // unless we can find out what generator return type it comes from.\n                         let term = if let Some(ty) = term.skip_binder().ty()\n-                            && let ty::Projection(proj) = ty.kind()\n+                            && let ty::Alias(ty::Projection, proj) = ty.kind()\n                             && let Some(assoc) = tcx.opt_associated_item(proj.def_id)\n                             && assoc.trait_container(tcx) == tcx.lang_items().gen_trait()\n                             && assoc.name == rustc_span::sym::Return"}, {"sha": "1eac8859ca93487bed32fdf2d088805b2603431d", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -551,14 +551,14 @@ pub fn super_relate_tys<'tcx, R: TypeRelation<'tcx>>(\n         }\n \n         // these two are already handled downstream in case of lazy normalization\n-        (&ty::Projection(a_data), &ty::Projection(b_data)) => {\n+        (&ty::Alias(ty::Projection, a_data), &ty::Alias(ty::Projection, b_data)) => {\n             let projection_ty = relation.relate(a_data, b_data)?;\n             Ok(tcx.mk_projection(projection_ty.def_id, projection_ty.substs))\n         }\n \n         (\n-            &ty::Opaque(ty::AliasTy { def_id: a_def_id, substs: a_substs }),\n-            &ty::Opaque(ty::AliasTy { def_id: b_def_id, substs: b_substs }),\n+            &ty::Alias(ty::Opaque, ty::AliasTy { def_id: a_def_id, substs: a_substs }),\n+            &ty::Alias(ty::Opaque, ty::AliasTy { def_id: b_def_id, substs: b_substs }),\n         ) if a_def_id == b_def_id => {\n             if relation.intercrate() {\n                 // During coherence, opaque types should be treated as equal to each other, even if their generic params"}, {"sha": "3d85ae3584ba8f2a08c9017eb963191f11225e37", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -651,9 +651,11 @@ impl<'tcx> TypeSuperFoldable<'tcx> for Ty<'tcx> {\n             }\n             ty::GeneratorWitness(types) => ty::GeneratorWitness(types.try_fold_with(folder)?),\n             ty::Closure(did, substs) => ty::Closure(did, substs.try_fold_with(folder)?),\n-            ty::Projection(data) => ty::Projection(data.try_fold_with(folder)?),\n-            ty::Opaque(ty::AliasTy { def_id, substs }) => {\n-                ty::Opaque(ty::AliasTy { def_id, substs: substs.try_fold_with(folder)? })\n+            ty::Alias(ty::Projection, data) => {\n+                ty::Alias(ty::Projection, data.try_fold_with(folder)?)\n+            }\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) => {\n+                ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: substs.try_fold_with(folder)? })\n             }\n \n             ty::Bool\n@@ -699,8 +701,10 @@ impl<'tcx> TypeSuperVisitable<'tcx> for Ty<'tcx> {\n             ty::Generator(_did, ref substs, _) => substs.visit_with(visitor),\n             ty::GeneratorWitness(ref types) => types.visit_with(visitor),\n             ty::Closure(_did, ref substs) => substs.visit_with(visitor),\n-            ty::Projection(ref data) => data.visit_with(visitor),\n-            ty::Opaque(ty::AliasTy { def_id: _, ref substs }) => substs.visit_with(visitor),\n+            ty::Alias(ty::Projection, ref data) => data.visit_with(visitor),\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id: _, ref substs }) => {\n+                substs.visit_with(visitor)\n+            }\n \n             ty::Bool\n             | ty::Char"}, {"sha": "a1c15f4044cf9210aababb764f1626ce07b032a3", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -1980,7 +1980,7 @@ impl<'tcx> Ty<'tcx> {\n \n     #[inline]\n     pub fn is_impl_trait(self) -> bool {\n-        matches!(self.kind(), Opaque(..))\n+        matches!(self.kind(), Alias(ty::Opaque, ..))\n     }\n \n     #[inline]\n@@ -2047,7 +2047,10 @@ impl<'tcx> Ty<'tcx> {\n             ty::Adt(adt, _) if adt.is_enum() => adt.repr().discr_type().to_ty(tcx),\n             ty::Generator(_, substs, _) => substs.as_generator().discr_ty(tcx),\n \n-            ty::Param(_) | ty::Projection(_) | ty::Opaque(..) | ty::Infer(ty::TyVar(_)) => {\n+            ty::Param(_)\n+            | ty::Alias(ty::Projection, _)\n+            | ty::Alias(ty::Opaque, ..)\n+            | ty::Infer(ty::TyVar(_)) => {\n                 let assoc_items = tcx.associated_item_def_ids(\n                     tcx.require_lang_item(hir::LangItem::DiscriminantKind, None),\n                 );\n@@ -2127,7 +2130,7 @@ impl<'tcx> Ty<'tcx> {\n \n             // type parameters only have unit metadata if they're sized, so return true\n             // to make sure we double check this during confirmation\n-            ty::Param(_) |  ty::Projection(_) | ty::Opaque(..) => (tcx.types.unit, true),\n+            ty::Param(_) |  ty::Alias(ty::Projection, _) | ty::Alias(ty::Opaque, ..) => (tcx.types.unit, true),\n \n             ty::Infer(ty::TyVar(_))\n             | ty::Bound(..)\n@@ -2203,7 +2206,7 @@ impl<'tcx> Ty<'tcx> {\n \n             ty::Adt(def, _substs) => def.sized_constraint(tcx).0.is_empty(),\n \n-            ty::Projection(_) | ty::Param(_) | ty::Opaque(..) => false,\n+            ty::Alias(ty::Projection, _) | ty::Param(_) | ty::Alias(ty::Opaque, ..) => false,\n \n             ty::Infer(ty::TyVar(_)) => false,\n \n@@ -2259,9 +2262,9 @@ impl<'tcx> Ty<'tcx> {\n             ty::Generator(..) | ty::GeneratorWitness(..) => false,\n \n             // Might be, but not \"trivial\" so just giving the safe answer.\n-            ty::Adt(..) | ty::Closure(..) | ty::Opaque(..) => false,\n+            ty::Adt(..) | ty::Closure(..) | ty::Alias(ty::Opaque, ..) => false,\n \n-            ty::Projection(..) | ty::Param(..) | ty::Infer(..) | ty::Error(..) => false,\n+            ty::Alias(ty::Projection, ..) | ty::Param(..) | ty::Infer(..) | ty::Error(..) => false,\n \n             ty::Bound(..) | ty::Placeholder(..) => {\n                 bug!(\"`is_trivially_pure_clone_copy` applied to unexpected type: {:?}\", self);"}, {"sha": "cf35240f165bd13a719e7791398a0df774c0a9e6", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -259,7 +259,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n                 ty::Tuple(_) => break,\n \n-                ty::Projection(_) | ty::Opaque(..) => {\n+                ty::Alias(ty::Projection, _) | ty::Alias(ty::Opaque, ..) => {\n                     let normalized = normalize(ty);\n                     if ty == normalized {\n                         return ty;\n@@ -332,8 +332,8 @@ impl<'tcx> TyCtxt<'tcx> {\n                         break;\n                     }\n                 }\n-                (ty::Projection(_) | ty::Opaque(..), _)\n-                | (_, ty::Projection(_) | ty::Opaque(..)) => {\n+                (ty::Alias(ty::Projection, _) | ty::Alias(ty::Opaque, ..), _)\n+                | (_, ty::Alias(ty::Projection, _) | ty::Alias(ty::Opaque, ..)) => {\n                     // If either side is a projection, attempt to\n                     // progress via normalization. (Should be safe to\n                     // apply to both sides as normalization is\n@@ -826,7 +826,7 @@ impl<'tcx> TypeFolder<'tcx> for OpaqueTypeExpander<'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if let ty::Opaque(ty::AliasTy { def_id, substs }) = *t.kind() {\n+        if let ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) = *t.kind() {\n             self.expand_opaque_ty(def_id, substs).unwrap_or(t)\n         } else if t.has_opaque_types() {\n             t.super_fold_with(self)\n@@ -938,10 +938,10 @@ impl<'tcx> Ty<'tcx> {\n             | ty::Generator(..)\n             | ty::GeneratorWitness(_)\n             | ty::Infer(_)\n-            | ty::Opaque(..)\n+            | ty::Alias(ty::Opaque, ..)\n             | ty::Param(_)\n             | ty::Placeholder(_)\n-            | ty::Projection(_) => false,\n+            | ty::Alias(ty::Projection, _) => false,\n         }\n     }\n \n@@ -978,10 +978,10 @@ impl<'tcx> Ty<'tcx> {\n             | ty::Generator(..)\n             | ty::GeneratorWitness(_)\n             | ty::Infer(_)\n-            | ty::Opaque(..)\n+            | ty::Alias(ty::Opaque, ..)\n             | ty::Param(_)\n             | ty::Placeholder(_)\n-            | ty::Projection(_) => false,\n+            | ty::Alias(ty::Projection, _) => false,\n         }\n     }\n \n@@ -1101,8 +1101,8 @@ impl<'tcx> Ty<'tcx> {\n             //\n             // FIXME(ecstaticmorse): Maybe we should `bug` here? This should probably only be\n             // called for known, fully-monomorphized types.\n-            ty::Projection(_)\n-            | ty::Opaque(..)\n+            ty::Alias(ty::Projection, _)\n+            | ty::Alias(ty::Opaque, ..)\n             | ty::Param(_)\n             | ty::Bound(..)\n             | ty::Placeholder(_)\n@@ -1237,11 +1237,11 @@ pub fn needs_drop_components<'tcx>(\n \n         // These require checking for `Copy` bounds or `Adt` destructors.\n         ty::Adt(..)\n-        | ty::Projection(..)\n+        | ty::Alias(ty::Projection, ..)\n         | ty::Param(_)\n         | ty::Bound(..)\n         | ty::Placeholder(..)\n-        | ty::Opaque(..)\n+        | ty::Alias(ty::Opaque, ..)\n         | ty::Infer(_)\n         | ty::Closure(..)\n         | ty::Generator(..) => Ok(smallvec![ty]),\n@@ -1265,13 +1265,13 @@ pub fn is_trivially_const_drop<'tcx>(ty: Ty<'tcx>) -> bool {\n         | ty::Never\n         | ty::Foreign(_) => true,\n \n-        ty::Opaque(..)\n+        ty::Alias(ty::Opaque, ..)\n         | ty::Dynamic(..)\n         | ty::Error(_)\n         | ty::Bound(..)\n         | ty::Param(_)\n         | ty::Placeholder(_)\n-        | ty::Projection(_)\n+        | ty::Alias(ty::Projection, _)\n         | ty::Infer(_) => false,\n \n         // Not trivial because they have components, and instead of looking inside,"}, {"sha": "085232a47cc5723b8791570c44bd13f4bf63307c", "filename": "compiler/rustc_middle/src/ty/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -654,7 +654,7 @@ impl<'tcx> TypeVisitor<'tcx> for LateBoundRegionsCollector {\n         // ignore the inputs to a projection, as they may not appear\n         // in the normalized form\n         if self.just_constrained {\n-            if let ty::Projection(..) | ty::Opaque(..) = t.kind() {\n+            if let ty::Alias(ty::Projection, ..) | ty::Alias(ty::Opaque, ..) = t.kind() {\n                 return ControlFlow::CONTINUE;\n             }\n         }"}, {"sha": "f4876d019cee01e81e9057f93e6c1c2a1e504aa5", "filename": "compiler/rustc_middle/src/ty/walk.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -165,7 +165,7 @@ fn push_inner<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent: GenericArg<'tcx>)\n                 stack.push(ty.into());\n                 stack.push(lt.into());\n             }\n-            ty::Projection(data) => {\n+            ty::Alias(ty::Projection, data) => {\n                 stack.extend(data.substs.iter().rev());\n             }\n             ty::Dynamic(obj, lt, _) => {\n@@ -188,7 +188,7 @@ fn push_inner<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent: GenericArg<'tcx>)\n                 }));\n             }\n             ty::Adt(_, substs)\n-            | ty::Opaque(ty::AliasTy { def_id: _, substs })\n+            | ty::Alias(ty::Opaque, ty::AliasTy { def_id: _, substs })\n             | ty::Closure(_, substs)\n             | ty::Generator(_, substs, _)\n             | ty::FnDef(_, substs) => {"}, {"sha": "6e39f1d3a97bf26eb3cacc3bb1341297cd36fe3c", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -373,7 +373,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // the case of `!`, no return value is required, as the block will never return.\n             // Opaque types of empty bodies also need this unit assignment, in order to infer that their\n             // type is actually unit. Otherwise there will be no defining use found in the MIR.\n-            if destination_ty.is_unit() || matches!(destination_ty.kind(), ty::Opaque(..)) {\n+            if destination_ty.is_unit()\n+                || matches!(destination_ty.kind(), ty::Alias(ty::Opaque, ..))\n+            {\n                 // We only want to assign an implicit `()` as the return value of the block if the\n                 // block does not diverge. (Otherwise, we may try to assign a unit to a `!`-type.)\n                 this.cfg.push_assign_unit(block, source_info, destination, this.tcx);"}, {"sha": "7e1f708b0d6a1685f01257e69c479cb20097bbc9", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -121,7 +121,7 @@ impl<'tcx> ConstToPat<'tcx> {\n                 ty::Dynamic(..) => {\n                     \"trait objects cannot be used in patterns\".to_string()\n                 }\n-                ty::Opaque(..) => {\n+                ty::Alias(ty::Opaque, ..) => {\n                     \"opaque types cannot be used in patterns\".to_string()\n                 }\n                 ty::Closure(..) => {"}, {"sha": "8f80cb95e58e70ff3512a5c95c93977c3e3490af", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -845,7 +845,7 @@ fn is_useful<'p, 'tcx>(\n \n         // Opaque types can't get destructured/split, but the patterns can\n         // actually hint at hidden types, so we use the patterns' types instead.\n-        if let ty::Opaque(..) = ty.kind() {\n+        if let ty::Alias(ty::Opaque, ..) = ty.kind() {\n             if let Some(row) = rows.first() {\n                 ty = row.head().ty();\n             }"}, {"sha": "ef7589d3ef2315f9bbf21e9c880c5f03e4e39122", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -849,7 +849,7 @@ impl<'tcx> Visitor<'tcx> for CostChecker<'_, 'tcx> {\n             };\n \n             let kind = match parent_ty.ty.kind() {\n-                &ty::Opaque(ty::AliasTy { def_id, substs }) => {\n+                &ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) => {\n                     self.tcx.bound_type_of(def_id).subst(self.tcx, substs).kind()\n                 }\n                 kind => kind,"}, {"sha": "6cabef92d8c2190e7f31514eb319eee727dcc9c2", "filename": "compiler/rustc_mir_transform/src/remove_zsts.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_zsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_zsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_zsts.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -52,7 +52,11 @@ impl<'tcx> MirPass<'tcx> for RemoveZsts {\n fn maybe_zst(ty: Ty<'_>) -> bool {\n     match ty.kind() {\n         // maybe ZST (could be more precise)\n-        ty::Adt(..) | ty::Array(..) | ty::Closure(..) | ty::Tuple(..) | ty::Opaque(..) => true,\n+        ty::Adt(..)\n+        | ty::Array(..)\n+        | ty::Closure(..)\n+        | ty::Tuple(..)\n+        | ty::Alias(ty::Opaque, ..) => true,\n         // definitely ZST\n         ty::FnDef(..) | ty::Never => true,\n         // unreachable or can't be ZST"}, {"sha": "deaeec9a80e4646c9e28be8685e2885002ea2146", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -208,7 +208,7 @@ where\n                     }\n                 }\n             }\n-            ty::Projection(proj) => {\n+            ty::Alias(ty::Projection, proj) => {\n                 if self.def_id_visitor.skip_assoc_tys() {\n                     // Visitors searching for minimal visibility/reachability want to\n                     // conservatively approximate associated types like `<Type as Trait>::Alias`\n@@ -235,7 +235,7 @@ where\n                     self.def_id_visitor.visit_def_id(def_id, \"trait\", &trait_ref)?;\n                 }\n             }\n-            ty::Opaque(ty::AliasTy { def_id, substs: _ }) => {\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }) => {\n                 // Skip repeated `Opaque`s to avoid infinite recursion.\n                 if self.visited_opaque_tys.insert(def_id) {\n                     // The intent is to treat `impl Trait1 + Trait2` identically to"}, {"sha": "a82fee8cf4bdf3d64167cccca2e0260219d40db2", "filename": "compiler/rustc_symbol_mangling/src/legacy.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -216,8 +216,8 @@ impl<'tcx> Printer<'tcx> for &mut SymbolPrinter<'tcx> {\n         match *ty.kind() {\n             // Print all nominal types as paths (unlike `pretty_print_type`).\n             ty::FnDef(def_id, substs)\n-            | ty::Opaque(ty::AliasTy { def_id, substs })\n-            | ty::Projection(ty::AliasTy { def_id, substs })\n+            | ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs })\n+            | ty::Alias(ty::Projection, ty::AliasTy { def_id, substs })\n             | ty::Closure(def_id, substs)\n             | ty::Generator(def_id, substs, _) => self.print_def_path(def_id, substs),\n \n@@ -287,11 +287,7 @@ impl<'tcx> Printer<'tcx> for &mut SymbolPrinter<'tcx> {\n         // Similar to `pretty_path_qualified`, but for the other\n         // types that are printed as paths (see `print_type` above).\n         match self_ty.kind() {\n-            ty::FnDef(..)\n-            | ty::Opaque(..)\n-            | ty::Projection(_)\n-            | ty::Closure(..)\n-            | ty::Generator(..)\n+            ty::FnDef(..) | ty::Alias(..) | ty::Closure(..) | ty::Generator(..)\n                 if trait_ref.is_none() =>\n             {\n                 self.print_type(self_ty)"}, {"sha": "cff6a276eecef5c44619e0692667599c3cf9afd0", "filename": "compiler/rustc_symbol_mangling/src/typeid/typeid_itanium_cxx_abi.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -646,10 +646,10 @@ fn encode_ty<'tcx>(\n         | ty::Error(..)\n         | ty::GeneratorWitness(..)\n         | ty::Infer(..)\n-        | ty::Opaque(..)\n+        | ty::Alias(ty::Opaque, ..)\n         | ty::Param(..)\n         | ty::Placeholder(..)\n-        | ty::Projection(..) => {\n+        | ty::Alias(ty::Projection, ..) => {\n             bug!(\"encode_ty: unexpected `{:?}`\", ty.kind());\n         }\n     };\n@@ -799,10 +799,10 @@ fn transform_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, options: TransformTyOptio\n         | ty::Error(..)\n         | ty::GeneratorWitness(..)\n         | ty::Infer(..)\n-        | ty::Opaque(..)\n+        | ty::Alias(ty::Opaque, ..)\n         | ty::Param(..)\n         | ty::Placeholder(..)\n-        | ty::Projection(..) => {\n+        | ty::Alias(ty::Projection, ..) => {\n             bug!(\"transform_ty: unexpected `{:?}`\", ty.kind());\n         }\n     }"}, {"sha": "175367ad41436ad6d592194a8c27f3ed4d261524", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -439,8 +439,8 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n             // Mangle all nominal types as paths.\n             ty::Adt(ty::AdtDef(Interned(&ty::AdtDefData { did: def_id, .. }, _)), substs)\n             | ty::FnDef(def_id, substs)\n-            | ty::Opaque(ty::AliasTy { def_id, substs })\n-            | ty::Projection(ty::AliasTy { def_id, substs })\n+            | ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs })\n+            | ty::Alias(ty::Projection, ty::AliasTy { def_id, substs })\n             | ty::Closure(def_id, substs)\n             | ty::Generator(def_id, substs, _) => {\n                 self = self.print_def_path(def_id, substs)?;"}, {"sha": "aef2f8ff9911cc90b565bf27c02d946d0ffcd766", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -579,14 +579,14 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n     pub fn is_of_param(&self, ty: Ty<'_>) -> bool {\n         match ty.kind() {\n             ty::Param(_) => true,\n-            ty::Projection(p) => self.is_of_param(p.self_ty()),\n+            ty::Alias(ty::Projection, p) => self.is_of_param(p.self_ty()),\n             _ => false,\n         }\n     }\n \n     fn is_self_referential_projection(&self, p: ty::PolyProjectionPredicate<'_>) -> bool {\n         if let Some(ty) = p.term().skip_binder().ty() {\n-            matches!(ty.kind(), ty::Projection(proj) if proj == &p.skip_binder().projection_ty)\n+            matches!(ty.kind(), ty::Alias(ty::Projection, proj) if proj == &p.skip_binder().projection_ty)\n         } else {\n             false\n         }"}, {"sha": "7c569621cfeb85ab3b64cd2c2bc05c3b045180f5", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -659,7 +659,7 @@ impl<'tcx> TypeVisitor<'tcx> for OrphanChecker<'tcx> {\n             | ty::RawPtr(..)\n             | ty::Never\n             | ty::Tuple(..)\n-            | ty::Projection(..) => self.found_non_local_ty(ty),\n+            | ty::Alias(ty::Projection, ..) => self.found_non_local_ty(ty),\n \n             ty::Param(..) => self.found_param_ty(ty),\n \n@@ -704,7 +704,7 @@ impl<'tcx> TypeVisitor<'tcx> for OrphanChecker<'tcx> {\n                 );\n                 ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(ty))\n             }\n-            ty::Opaque(..) => {\n+            ty::Alias(ty::Opaque, ..) => {\n                 // This merits some explanation.\n                 // Normally, opaque types are not involved when performing\n                 // coherence checking, since it is illegal to directly"}, {"sha": "e8d964dd17209433b5f6f1a1a78607c30b46bb5d", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -1787,8 +1787,8 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 ty::Closure(..) => Some(9),\n                 ty::Tuple(..) => Some(10),\n                 ty::Param(..) => Some(11),\n-                ty::Projection(..) => Some(12),\n-                ty::Opaque(..) => Some(13),\n+                ty::Alias(ty::Projection, ..) => Some(12),\n+                ty::Alias(ty::Opaque, ..) => Some(13),\n                 ty::Never => Some(14),\n                 ty::Adt(..) => Some(15),\n                 ty::Generator(..) => Some(16),"}, {"sha": "313ac28d2203e3f1aab8397065853f02952a5484", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -495,7 +495,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         let self_ty = trait_pred.skip_binder().self_ty();\n         let (param_ty, projection) = match self_ty.kind() {\n             ty::Param(_) => (true, None),\n-            ty::Projection(projection) => (false, Some(projection)),\n+            ty::Alias(ty::Projection, projection) => (false, Some(projection)),\n             _ => (false, None),\n         };\n \n@@ -855,7 +855,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     fn_sig.inputs().map_bound(|inputs| &inputs[1..]),\n                 ))\n             }\n-            ty::Opaque(ty::AliasTy { def_id, substs }) => {\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) => {\n                 self.tcx.bound_item_bounds(def_id).subst(self.tcx, substs).iter().find_map(|pred| {\n                     if let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) = pred.kind().skip_binder()\n                     && Some(proj.projection_ty.def_id) == self.tcx.lang_items().fn_once_output()\n@@ -2644,7 +2644,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                                 Some(ident) => err.span_note(ident.span, &msg),\n                                 None => err.note(&msg),\n                             },\n-                            ty::Opaque(ty::AliasTy { def_id, substs: _ }) => {\n+                            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }) => {\n                                 // Avoid printing the future from `core::future::identity_future`, it's not helpful\n                                 if tcx.parent(*def_id) == identity_future {\n                                     break 'print;\n@@ -3221,7 +3221,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             let ocx = ObligationCtxt::new_in_snapshot(self.infcx);\n             for diff in &type_diffs {\n                 let Sorts(expected_found) = diff else { continue; };\n-                let ty::Projection(proj) = expected_found.expected.kind() else { continue; };\n+                let ty::Alias(ty::Projection, proj) = expected_found.expected.kind() else { continue; };\n \n                 let origin =\n                     TypeVariableOrigin { kind: TypeVariableOriginKind::TypeInference, span };"}, {"sha": "3e85ea69635e645c953b4e3eec401e1f3390e318", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -794,13 +794,13 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeVisitable<'tcx>>(\n                         ControlFlow::CONTINUE\n                     }\n                 }\n-                ty::Projection(ref data)\n+                ty::Alias(ty::Projection, ref data)\n                     if self.tcx.def_kind(data.def_id) == DefKind::ImplTraitPlaceholder =>\n                 {\n                     // We'll deny these later in their own pass\n                     ControlFlow::CONTINUE\n                 }\n-                ty::Projection(ref data) => {\n+                ty::Alias(ty::Projection, ref data) => {\n                     // This is a projected type `<Foo as SomeTrait>::X`.\n \n                     // Compute supertraits of current trait lazily.\n@@ -861,7 +861,7 @@ pub fn contains_illegal_impl_trait_in_trait<'tcx>(\n     // FIXME(RPITIT): Perhaps we should use a visitor here?\n     ty.skip_binder().walk().find_map(|arg| {\n         if let ty::GenericArgKind::Type(ty) = arg.unpack()\n-            && let ty::Projection(proj) = ty.kind()\n+            && let ty::Alias(ty::Projection, proj) = ty.kind()\n             && tcx.def_kind(proj.def_id) == DefKind::ImplTraitPlaceholder\n         {\n             Some(MethodViolationCode::ReferencesImplTraitInTrait(tcx.def_span(proj.def_id)))"}, {"sha": "6e3a83f2a3479a136ed56d6607701eb8385e1cf3", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -496,7 +496,9 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n             // This is really important. While we *can* handle this, this has\n             // severe performance implications for large opaque types with\n             // late-bound regions. See `issue-88862` benchmark.\n-            ty::Opaque(ty::AliasTy { def_id, substs }) if !substs.has_escaping_bound_vars() => {\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs })\n+                if !substs.has_escaping_bound_vars() =>\n+            {\n                 // Only normalize `impl Trait` outside of type inference, usually in codegen.\n                 match self.param_env.reveal() {\n                     Reveal::UserFacing => ty.super_fold_with(self),\n@@ -523,7 +525,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                 }\n             }\n \n-            ty::Projection(data) if !data.has_escaping_bound_vars() => {\n+            ty::Alias(ty::Projection, data) if !data.has_escaping_bound_vars() => {\n                 // This branch is *mostly* just an optimization: when we don't\n                 // have escaping bound vars, we don't need to replace them with\n                 // placeholders (see branch below). *Also*, we know that we can\n@@ -562,7 +564,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                 normalized_ty.ty().unwrap()\n             }\n \n-            ty::Projection(data) => {\n+            ty::Alias(ty::Projection, data) => {\n                 // If there are escaping bound vars, we temporarily replace the\n                 // bound vars with placeholders. Note though, that in the case\n                 // that we still can't project for whatever reason (e.g. self\n@@ -1375,8 +1377,10 @@ fn assemble_candidates_from_trait_def<'cx, 'tcx>(\n     // Check whether the self-type is itself a projection.\n     // If so, extract what we know from the trait and try to come up with a good answer.\n     let bounds = match *obligation.predicate.self_ty().kind() {\n-        ty::Projection(ref data) => tcx.bound_item_bounds(data.def_id).subst(tcx, data.substs),\n-        ty::Opaque(ty::AliasTy { def_id, substs }) => {\n+        ty::Alias(ty::Projection, ref data) => {\n+            tcx.bound_item_bounds(data.def_id).subst(tcx, data.substs)\n+        }\n+        ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) => {\n             tcx.bound_item_bounds(def_id).subst(tcx, substs)\n         }\n         ty::Infer(ty::TyVar(_)) => {\n@@ -1616,8 +1620,8 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                          // type parameters, opaques, and unnormalized projections have pointer\n                         // metadata if they're known (e.g. by the param_env) to be sized\n                         ty::Param(_)\n-                        | ty::Projection(..)\n-                        | ty::Opaque(..)\n+                        | ty::Alias(ty::Projection, ..)\n+                        | ty::Alias(ty::Opaque, ..)\n                         | ty::Bound(..)\n                         | ty::Placeholder(..)\n                         | ty::Infer(..)\n@@ -1671,7 +1675,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n \n                         // type parameters, opaques, and unnormalized projections have pointer\n                         // metadata if they're known (e.g. by the param_env) to be sized\n-                        ty::Param(_) | ty::Projection(..) | ty::Opaque(..)\n+                        ty::Param(_) | ty::Alias(ty::Projection, ..) | ty::Alias(ty::Opaque, ..)\n                             if selcx.infcx.predicate_must_hold_modulo_regions(\n                                 &obligation.with(\n                                     selcx.tcx(),\n@@ -1687,8 +1691,8 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n \n                         // FIXME(compiler-errors): are Bound and Placeholder types ever known sized?\n                         ty::Param(_)\n-                        | ty::Projection(..)\n-                        | ty::Opaque(..)\n+                        | ty::Alias(ty::Projection, ..)\n+                        | ty::Alias(ty::Opaque, ..)\n                         | ty::Bound(..)\n                         | ty::Placeholder(..)\n                         | ty::Infer(..)"}, {"sha": "03558f04ed295beb824e8879a9decf3e9a05aa19", "filename": "compiler/rustc_trait_selection/src/traits/query/dropck_outlives.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -62,9 +62,9 @@ pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n \n         // The following *might* require a destructor: needs deeper inspection.\n         ty::Dynamic(..)\n-        | ty::Projection(..)\n+        | ty::Alias(ty::Projection, ..)\n         | ty::Param(_)\n-        | ty::Opaque(..)\n+        | ty::Alias(ty::Opaque, ..)\n         | ty::Placeholder(..)\n         | ty::Infer(_)\n         | ty::Bound(..)"}, {"sha": "777de195895b89de6c9f1e50c422de074b842bed", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -205,7 +205,9 @@ impl<'cx, 'tcx> FallibleTypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n             // This is really important. While we *can* handle this, this has\n             // severe performance implications for large opaque types with\n             // late-bound regions. See `issue-88862` benchmark.\n-            ty::Opaque(ty::AliasTy { def_id, substs }) if !substs.has_escaping_bound_vars() => {\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs })\n+                if !substs.has_escaping_bound_vars() =>\n+            {\n                 // Only normalize `impl Trait` outside of type inference, usually in codegen.\n                 match self.param_env.reveal() {\n                     Reveal::UserFacing => ty.try_super_fold_with(self),\n@@ -242,7 +244,7 @@ impl<'cx, 'tcx> FallibleTypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                 }\n             }\n \n-            ty::Projection(data) if !data.has_escaping_bound_vars() => {\n+            ty::Alias(ty::Projection, data) if !data.has_escaping_bound_vars() => {\n                 // This branch is just an optimization: when we don't have escaping bound vars,\n                 // we don't need to replace them with placeholders (see branch below).\n \n@@ -291,7 +293,7 @@ impl<'cx, 'tcx> FallibleTypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                 }\n             }\n \n-            ty::Projection(data) => {\n+            ty::Alias(ty::Projection, data) => {\n                 // See note in `rustc_trait_selection::traits::project`\n \n                 let tcx = self.infcx.tcx;"}, {"sha": "db8c73a880765f4a4e84d81a8d40bf7af5458cdf", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -138,7 +138,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // Before we go into the whole placeholder thing, just\n         // quickly check if the self-type is a projection at all.\n         match obligation.predicate.skip_binder().trait_ref.self_ty().kind() {\n-            ty::Projection(_) | ty::Opaque(..) => {}\n+            ty::Alias(ty::Projection, _) | ty::Alias(ty::Opaque, ..) => {}\n             ty::Infer(ty::TyVar(_)) => {\n                 span_bug!(\n                     obligation.cause.span,\n@@ -394,7 +394,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     // still be provided by a manual implementation for\n                     // this trait and type.\n                 }\n-                ty::Param(..) | ty::Projection(..) => {\n+                ty::Param(..) | ty::Alias(ty::Projection, ..) => {\n                     // In these cases, we don't know what the actual\n                     // type is.  Therefore, we cannot break it down\n                     // into its constituent types. So we don't\n@@ -734,13 +734,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n         match self_ty.skip_binder().kind() {\n-            ty::Opaque(..)\n+            ty::Alias(ty::Opaque, ..)\n             | ty::Dynamic(..)\n             | ty::Error(_)\n             | ty::Bound(..)\n             | ty::Param(_)\n             | ty::Placeholder(_)\n-            | ty::Projection(_) => {\n+            | ty::Alias(ty::Projection, _) => {\n                 // We don't know if these are `~const Destruct`, at least\n                 // not structurally... so don't push a candidate.\n             }\n@@ -826,8 +826,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             | ty::Generator(_, _, _)\n             | ty::GeneratorWitness(_)\n             | ty::Never\n-            | ty::Projection(_)\n-            | ty::Opaque(ty::AliasTy { def_id: _, substs: _ })\n+            | ty::Alias(ty::Projection, _)\n+            | ty::Alias(ty::Opaque, ty::AliasTy { def_id: _, substs: _ })\n             | ty::Param(_)\n             | ty::Bound(_, _)\n             | ty::Error(_)"}, {"sha": "96c56905f8ae1d16deeff3e14301397d47ca57c1", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -155,8 +155,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let placeholder_self_ty = placeholder_trait_predicate.self_ty();\n         let placeholder_trait_predicate = ty::Binder::dummy(placeholder_trait_predicate);\n         let (def_id, substs) = match *placeholder_self_ty.kind() {\n-            ty::Projection(proj) => (proj.def_id, proj.substs),\n-            ty::Opaque(ty::AliasTy { def_id, substs }) => (def_id, substs),\n+            ty::Alias(ty::Projection, proj) => (proj.def_id, proj.substs),\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) => (def_id, substs),\n             _ => bug!(\"projection candidate for unexpected type: {:?}\", placeholder_self_ty),\n         };\n \n@@ -184,7 +184,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 .map_err(|_| Unimplemented)\n         })?);\n \n-        if let ty::Projection(..) = placeholder_self_ty.kind() {\n+        if let ty::Alias(ty::Projection, ..) = placeholder_self_ty.kind() {\n             let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs).predicates;\n             debug!(?predicates, \"projection predicates\");\n             for predicate in predicates {\n@@ -1279,7 +1279,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                 // If we have a projection type, make sure to normalize it so we replace it\n                 // with a fresh infer variable\n-                ty::Projection(..) => {\n+                ty::Alias(ty::Projection, ..) => {\n                     let predicate = normalize_with_depth_to(\n                         self,\n                         obligation.param_env,"}, {"sha": "1f078bef310d5b974ef11cf486a968b2145f0bea", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -1595,8 +1595,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let tcx = self.infcx.tcx;\n         let (def_id, substs) = match *placeholder_trait_predicate.trait_ref.self_ty().kind() {\n-            ty::Projection(ref data) => (data.def_id, data.substs),\n-            ty::Opaque(ty::AliasTy { def_id, substs }) => (def_id, substs),\n+            ty::Alias(ty::Projection, ref data) => (data.def_id, data.substs),\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) => (def_id, substs),\n             _ => {\n                 span_bug!(\n                     obligation.cause.span,\n@@ -2067,7 +2067,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }))\n             }\n \n-            ty::Projection(_) | ty::Param(_) | ty::Opaque(..) => None,\n+            ty::Alias(ty::Projection, _) | ty::Param(_) | ty::Alias(ty::Opaque, ..) => None,\n             ty::Infer(ty::TyVar(_)) => Ambiguous,\n \n             ty::Placeholder(..)\n@@ -2167,7 +2167,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            ty::Adt(..) | ty::Projection(..) | ty::Param(..) | ty::Opaque(..) => {\n+            ty::Adt(..)\n+            | ty::Alias(ty::Projection, ..)\n+            | ty::Param(..)\n+            | ty::Alias(ty::Opaque, ..) => {\n                 // Fallback to whatever user-defined impls exist in this case.\n                 None\n             }\n@@ -2220,7 +2223,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             | ty::Dynamic(..)\n             | ty::Param(..)\n             | ty::Foreign(..)\n-            | ty::Projection(..)\n+            | ty::Alias(ty::Projection, ..)\n             | ty::Bound(..)\n             | ty::Infer(ty::TyVar(_) | ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {\n                 bug!(\"asked to assemble constituent types of unexpected type: {:?}\", t);\n@@ -2260,7 +2263,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 t.rebind(def.all_fields().map(|f| f.ty(self.tcx(), substs)).collect())\n             }\n \n-            ty::Opaque(ty::AliasTy { def_id, substs }) => {\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) => {\n                 // We can resolve the `impl Trait` to its concrete type,\n                 // which enforces a DAG between the functions requiring\n                 // the auto trait bounds in question."}, {"sha": "62881b67f5ec2f4ddee40b37d296e2fd66fa33d2", "filename": "compiler/rustc_trait_selection/src/traits/structural_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -95,10 +95,10 @@ impl<'tcx> TypeVisitor<'tcx> for Search<'tcx> {\n             ty::Foreign(_) => {\n                 return ControlFlow::Break(ty);\n             }\n-            ty::Opaque(..) => {\n+            ty::Alias(ty::Opaque, ..) => {\n                 return ControlFlow::Break(ty);\n             }\n-            ty::Projection(..) => {\n+            ty::Alias(ty::Projection, ..) => {\n                 return ControlFlow::Break(ty);\n             }\n             ty::Closure(..) => {"}, {"sha": "74c4ae8854c34e4d9fb628808f5523a4f4707c65", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -234,7 +234,7 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n             // projection coming from another associated type. See\n             // `src/test/ui/associated-types/point-at-type-on-obligation-failure.rs` and\n             // `traits-assoc-type-in-supertrait-bad.rs`.\n-            if let Some(ty::Projection(projection_ty)) = proj.term.ty().map(|ty| ty.kind())\n+            if let Some(ty::Alias(ty::Projection, projection_ty)) = proj.term.ty().map(|ty| ty.kind())\n                 && let Some(&impl_item_id) =\n                     tcx.impl_item_implementor_ids(impl_def_id).get(&projection_ty.def_id)\n                 && let Some(impl_item_span) = items\n@@ -249,7 +249,7 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n             // An associated item obligation born out of the `trait` failed to be met. An example\n             // can be seen in `ui/associated-types/point-at-type-on-obligation-failure-2.rs`.\n             debug!(\"extended_cause_with_original_assoc_item_obligation trait proj {:?}\", pred);\n-            if let ty::Projection(ty::AliasTy { def_id, .. }) = *pred.self_ty().kind()\n+            if let ty::Alias(ty::Projection, ty::AliasTy { def_id, .. }) = *pred.self_ty().kind()\n                 && let Some(&impl_item_id) =\n                     tcx.impl_item_implementor_ids(impl_def_id).get(&def_id)\n                 && let Some(impl_item_span) = items\n@@ -556,7 +556,7 @@ impl<'tcx> WfPredicates<'tcx> {\n                     // Simple cases that are WF if their type args are WF.\n                 }\n \n-                ty::Projection(data) => {\n+                ty::Alias(ty::Projection, data) => {\n                     walker.skip_current_subtree(); // Subtree handled by compute_projection.\n                     self.compute_projection(data);\n                 }\n@@ -648,7 +648,7 @@ impl<'tcx> WfPredicates<'tcx> {\n                     // types appearing in the fn signature\n                 }\n \n-                ty::Opaque(ty::AliasTy { def_id, substs }) => {\n+                ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) => {\n                     // All of the requirements on type parameters\n                     // have already been checked for `impl Trait` in\n                     // return position. We do need to check type-alias-impl-trait though."}, {"sha": "53bafde0ea20e9fdcc52f63b587bb4d223185ea2", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -432,9 +432,10 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n                         (ast::Mutability::Not, chalk_ir::Mutability::Not) => true,\n                     }\n                 }\n-                (&ty::Opaque(ty::AliasTy { def_id, substs: _ }), OpaqueType(opaque_ty_id, ..)) => {\n-                    def_id == opaque_ty_id.0\n-                }\n+                (\n+                    &ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }),\n+                    OpaqueType(opaque_ty_id, ..),\n+                ) => def_id == opaque_ty_id.0,\n                 (&ty::FnDef(def_id, ..), FnDef(fn_def_id, ..)) => def_id == fn_def_id.0,\n                 (&ty::Str, Str) => true,\n                 (&ty::Never, Never) => true,\n@@ -788,7 +789,7 @@ impl<'tcx> ty::TypeFolder<'tcx> for ReplaceOpaqueTyFolder<'tcx> {\n     }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        if let ty::Opaque(ty::AliasTy { def_id, substs }) = *ty.kind() {\n+        if let ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) = *ty.kind() {\n             if def_id == self.opaque_ty_id.0 && substs == self.identity_substs {\n                 return self.tcx.mk_ty(ty::Bound(\n                     self.binder_index,"}, {"sha": "7fbf3270627dcf6449dac4a2f6f009958e3ba561", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -353,8 +353,8 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n             ty::Tuple(types) => {\n                 chalk_ir::TyKind::Tuple(types.len(), types.as_substs().lower_into(interner))\n             }\n-            ty::Projection(proj) => chalk_ir::TyKind::Alias(proj.lower_into(interner)),\n-            ty::Opaque(ty::AliasTy { def_id, substs }) => {\n+            ty::Alias(ty::Projection, proj) => chalk_ir::TyKind::Alias(proj.lower_into(interner)),\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) => {\n                 chalk_ir::TyKind::Alias(chalk_ir::AliasTy::Opaque(chalk_ir::OpaqueTy {\n                     opaque_ty_id: chalk_ir::OpaqueTyId(def_id),\n                     substitution: substs.lower_into(interner),\n@@ -442,29 +442,35 @@ impl<'tcx> LowerInto<'tcx, Ty<'tcx>> for &chalk_ir::Ty<RustInterner<'tcx>> {\n                 mutbl.lower_into(interner),\n             ),\n             TyKind::Str => ty::Str,\n-            TyKind::OpaqueType(opaque_ty, substitution) => ty::Opaque(ty::AliasTy {\n-                def_id: opaque_ty.0,\n-                substs: substitution.lower_into(interner),\n-            }),\n-            TyKind::AssociatedType(assoc_ty, substitution) => ty::Projection(ty::AliasTy {\n-                substs: substitution.lower_into(interner),\n-                def_id: assoc_ty.0,\n-            }),\n+            TyKind::OpaqueType(opaque_ty, substitution) => ty::Alias(\n+                ty::Opaque,\n+                ty::AliasTy { def_id: opaque_ty.0, substs: substitution.lower_into(interner) },\n+            ),\n+            TyKind::AssociatedType(assoc_ty, substitution) => ty::Alias(\n+                ty::Projection,\n+                ty::AliasTy { substs: substitution.lower_into(interner), def_id: assoc_ty.0 },\n+            ),\n             TyKind::Foreign(def_id) => ty::Foreign(def_id.0),\n             TyKind::Error => return interner.tcx.ty_error(),\n             TyKind::Placeholder(placeholder) => ty::Placeholder(ty::Placeholder {\n                 universe: ty::UniverseIndex::from_usize(placeholder.ui.counter),\n                 name: ty::BoundVar::from_usize(placeholder.idx),\n             }),\n             TyKind::Alias(alias_ty) => match alias_ty {\n-                chalk_ir::AliasTy::Projection(projection) => ty::Projection(ty::AliasTy {\n-                    def_id: projection.associated_ty_id.0,\n-                    substs: projection.substitution.lower_into(interner),\n-                }),\n-                chalk_ir::AliasTy::Opaque(opaque) => ty::Opaque(ty::AliasTy {\n-                    def_id: opaque.opaque_ty_id.0,\n-                    substs: opaque.substitution.lower_into(interner),\n-                }),\n+                chalk_ir::AliasTy::Projection(projection) => ty::Alias(\n+                    ty::Projection,\n+                    ty::AliasTy {\n+                        def_id: projection.associated_ty_id.0,\n+                        substs: projection.substitution.lower_into(interner),\n+                    },\n+                ),\n+                chalk_ir::AliasTy::Opaque(opaque) => ty::Alias(\n+                    ty::Opaque,\n+                    ty::AliasTy {\n+                        def_id: opaque.opaque_ty_id.0,\n+                        substs: opaque.substitution.lower_into(interner),\n+                    },\n+                ),\n             },\n             TyKind::Function(_quantified_ty) => unimplemented!(),\n             TyKind::BoundVar(_bound) => ty::Bound("}, {"sha": "f9503fae94c24e3b5125200174f6fc3860d054fb", "filename": "compiler/rustc_traits/src/dropck_outlives.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -112,7 +112,7 @@ fn dropck_outlives<'tcx>(\n \n                     // A projection that we couldn't resolve - it\n                     // might have a destructor.\n-                    ty::Projection(..) | ty::Opaque(..) => {\n+                    ty::Alias(ty::Projection, ..) | ty::Alias(ty::Opaque, ..) => {\n                         result.kinds.push(ty.into());\n                     }\n \n@@ -268,7 +268,7 @@ fn dtorck_constraint_for_ty<'tcx>(\n         }\n \n         // Types that can't be resolved. Pass them forward.\n-        ty::Projection(..) | ty::Opaque(..) | ty::Param(..) => {\n+        ty::Alias(ty::Projection, ..) | ty::Alias(ty::Opaque, ..) | ty::Param(..) => {\n             constraints.dtorck_types.push(ty);\n         }\n "}, {"sha": "3d5fa2de579309cfb41477f687f8664c133dd9dd", "filename": "compiler/rustc_ty_utils/src/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -444,7 +444,7 @@ fn layout_of_uncached<'tcx>(\n         }\n \n         // Types with no meaningful known layout.\n-        ty::Projection(_) | ty::Opaque(..) => {\n+        ty::Alias(ty::Projection, _) | ty::Alias(ty::Opaque, ..) => {\n             // NOTE(eddyb) `layout_of` query should've normalized these away,\n             // if that was possible, so there's no reason to try again here.\n             return Err(LayoutError::Unknown(ty));"}, {"sha": "3f17715a5ebb4575845cd273dab5839407531c63", "filename": "compiler/rustc_ty_utils/src/needs_drop.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -152,7 +152,10 @@ where\n                             queue_type(self, required);\n                         }\n                     }\n-                    ty::Array(..) | ty::Opaque(..) | ty::Projection(..) | ty::Param(_) => {\n+                    ty::Array(..)\n+                    | ty::Alias(ty::Opaque, ..)\n+                    | ty::Alias(ty::Projection, ..)\n+                    | ty::Param(_) => {\n                         if ty == component {\n                             // Return the type to the caller: they may be able\n                             // to normalize further than we can."}, {"sha": "5279fc69a31b3cb6a72b1cd2e665efff89fbd316", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -37,7 +37,7 @@ fn sized_constraint_for_ty<'tcx>(\n                 .collect()\n         }\n \n-        Projection(..) | Opaque(..) => {\n+        Alias(..) => {\n             // must calculate explicitly.\n             // FIXME: consider special-casing always-Sized projections\n             vec![ty]"}, {"sha": "c992dbccd62d5656439cc6ca72578f8656200075", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -42,9 +42,8 @@ pub trait Interner {\n     type ListBinderExistentialPredicate: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n     type BinderListTy: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n     type ListTy: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n-    type ProjectionTy: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type AliasTy: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n     type ParamTy: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n-    type OpaqueTy: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n     type BoundTy: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n     type PlaceholderType: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n     type InferTy: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;"}, {"sha": "96c53392449dc5c38610919b754100f05ff54eaf", "filename": "compiler/rustc_type_ir/src/sty.rs", "status": "modified", "additions": 32, "deletions": 60, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -19,19 +19,8 @@ use rustc_data_structures::stable_hasher::HashStable;\n use rustc_serialize::{Decodable, Decoder, Encodable};\n \n /// Specifies how a trait object is represented.\n-#[derive(\n-    Clone,\n-    Copy,\n-    PartialEq,\n-    Eq,\n-    PartialOrd,\n-    Ord,\n-    Hash,\n-    Debug,\n-    Encodable,\n-    Decodable,\n-    HashStable_Generic\n-)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+#[derive(Encodable, Decodable, HashStable_Generic)]\n pub enum DynKind {\n     /// An unsized `dyn Trait` object\n     Dyn,\n@@ -46,6 +35,13 @@ pub enum DynKind {\n     DynStar,\n }\n \n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+#[derive(Encodable, Decodable, HashStable_Generic)]\n+pub enum AliasKind {\n+    Projection,\n+    Opaque,\n+}\n+\n /// Defines the kinds of types used by the type system.\n ///\n /// Types written by the user start out as `hir::TyKind` and get\n@@ -171,19 +167,7 @@ pub enum TyKind<I: Interner> {\n     Tuple(I::ListTy),\n \n     /// A projection or opaque type. Both of these types\n-    Projection(I::ProjectionTy),\n-\n-    /// Opaque (`impl Trait`) type found in a return type.\n-    ///\n-    /// The `DefId` comes either from\n-    /// * the `impl Trait` ast::Ty node,\n-    /// * or the `type Foo = impl Trait` declaration\n-    ///\n-    /// For RPIT the substitutions are for the generics of the function,\n-    /// while for TAIT it is used for the generic parameters of the alias.\n-    ///\n-    /// During codegen, `tcx.type_of(def_id)` can be used to get the underlying type.\n-    Opaque(I::OpaqueTy),\n+    Alias(AliasKind, I::AliasTy),\n \n     /// A type parameter; for example, `T` in `fn f<T>(x: T) {}`.\n     Param(I::ParamTy),\n@@ -251,13 +235,12 @@ const fn tykind_discriminant<I: Interner>(value: &TyKind<I>) -> usize {\n         GeneratorWitness(_) => 17,\n         Never => 18,\n         Tuple(_) => 19,\n-        Projection(_) => 20,\n-        Opaque(_) => 21,\n-        Param(_) => 22,\n-        Bound(_, _) => 23,\n-        Placeholder(_) => 24,\n-        Infer(_) => 25,\n-        Error(_) => 26,\n+        Alias(_, _) => 20,\n+        Param(_) => 21,\n+        Bound(_, _) => 22,\n+        Placeholder(_) => 23,\n+        Infer(_) => 24,\n+        Error(_) => 25,\n     }\n }\n \n@@ -285,8 +268,7 @@ impl<I: Interner> Clone for TyKind<I> {\n             GeneratorWitness(g) => GeneratorWitness(g.clone()),\n             Never => Never,\n             Tuple(t) => Tuple(t.clone()),\n-            Projection(p) => Projection(p.clone()),\n-            Opaque(o) => Opaque(o.clone()),\n+            Alias(k, p) => Alias(*k, p.clone()),\n             Param(p) => Param(p.clone()),\n             Bound(d, b) => Bound(d.clone(), b.clone()),\n             Placeholder(p) => Placeholder(p.clone()),\n@@ -322,8 +304,7 @@ impl<I: Interner> PartialEq for TyKind<I> {\n                 }\n                 (GeneratorWitness(a_g), GeneratorWitness(b_g)) => a_g == b_g,\n                 (Tuple(a_t), Tuple(b_t)) => a_t == b_t,\n-                (Projection(a_p), Projection(b_p)) => a_p == b_p,\n-                (Opaque(a_o), Opaque(b_o)) => a_o == b_o,\n+                (Alias(a_i, a_p), Alias(b_i, b_p)) => a_i == b_i && a_p == b_p,\n                 (Param(a_p), Param(b_p)) => a_p == b_p,\n                 (Bound(a_d, a_b), Bound(b_d, b_b)) => a_d == b_d && a_b == b_b,\n                 (Placeholder(a_p), Placeholder(b_p)) => a_p == b_p,\n@@ -380,8 +361,7 @@ impl<I: Interner> Ord for TyKind<I> {\n                 }\n                 (GeneratorWitness(a_g), GeneratorWitness(b_g)) => a_g.cmp(b_g),\n                 (Tuple(a_t), Tuple(b_t)) => a_t.cmp(b_t),\n-                (Projection(a_p), Projection(b_p)) => a_p.cmp(b_p),\n-                (Opaque(a_o), Opaque(b_o)) => a_o.cmp(b_o),\n+                (Alias(a_i, a_p), Alias(b_i, b_p)) => a_i.cmp(b_i).then_with(|| a_p.cmp(b_p)),\n                 (Param(a_p), Param(b_p)) => a_p.cmp(b_p),\n                 (Bound(a_d, a_b), Bound(b_d, b_b)) => a_d.cmp(b_d).then_with(|| a_b.cmp(b_b)),\n                 (Placeholder(a_p), Placeholder(b_p)) => a_p.cmp(b_p),\n@@ -442,9 +422,9 @@ impl<I: Interner> hash::Hash for TyKind<I> {\n             }\n             GeneratorWitness(g) => g.hash(state),\n             Tuple(t) => t.hash(state),\n-            Projection(p) => p.hash(state),\n-            Opaque(o) => {\n-                o.hash(state);\n+            Alias(i, p) => {\n+                i.hash(state);\n+                p.hash(state);\n             }\n             Param(p) => p.hash(state),\n             Bound(d, b) => {\n@@ -483,8 +463,7 @@ impl<I: Interner> fmt::Debug for TyKind<I> {\n             GeneratorWitness(g) => f.debug_tuple_field1_finish(\"GeneratorWitness\", g),\n             Never => f.write_str(\"Never\"),\n             Tuple(t) => f.debug_tuple_field1_finish(\"Tuple\", t),\n-            Projection(p) => f.debug_tuple_field1_finish(\"Projection\", p),\n-            Opaque(o) => f.debug_tuple_field1_finish(\"Opaque\", o),\n+            Alias(i, a) => f.debug_tuple_field2_finish(\"Alias\", i, a),\n             Param(p) => f.debug_tuple_field1_finish(\"Param\", p),\n             Bound(d, b) => f.debug_tuple_field2_finish(\"Bound\", d, b),\n             Placeholder(p) => f.debug_tuple_field1_finish(\"Placeholder\", p),\n@@ -511,9 +490,8 @@ where\n     I::ListBinderExistentialPredicate: Encodable<E>,\n     I::BinderListTy: Encodable<E>,\n     I::ListTy: Encodable<E>,\n-    I::ProjectionTy: Encodable<E>,\n+    I::AliasTy: Encodable<E>,\n     I::ParamTy: Encodable<E>,\n-    I::OpaqueTy: Encodable<E>,\n     I::BoundTy: Encodable<E>,\n     I::PlaceholderType: Encodable<E>,\n     I::InferTy: Encodable<E>,\n@@ -585,12 +563,10 @@ where\n             Tuple(substs) => e.emit_enum_variant(disc, |e| {\n                 substs.encode(e);\n             }),\n-            Projection(p) => e.emit_enum_variant(disc, |e| {\n+            Alias(k, p) => e.emit_enum_variant(disc, |e| {\n+                k.encode(e);\n                 p.encode(e);\n             }),\n-            Opaque(o) => e.emit_enum_variant(disc, |e| {\n-                o.encode(e);\n-            }),\n             Param(p) => e.emit_enum_variant(disc, |e| {\n                 p.encode(e);\n             }),\n@@ -628,9 +604,9 @@ where\n     I::ListBinderExistentialPredicate: Decodable<D>,\n     I::BinderListTy: Decodable<D>,\n     I::ListTy: Decodable<D>,\n-    I::ProjectionTy: Decodable<D>,\n+    I::AliasTy: Decodable<D>,\n     I::ParamTy: Decodable<D>,\n-    I::OpaqueTy: Decodable<D>,\n+    I::AliasTy: Decodable<D>,\n     I::BoundTy: Decodable<D>,\n     I::PlaceholderType: Decodable<D>,\n     I::InferTy: Decodable<D>,\n@@ -659,8 +635,7 @@ where\n             17 => GeneratorWitness(Decodable::decode(d)),\n             18 => Never,\n             19 => Tuple(Decodable::decode(d)),\n-            20 => Projection(Decodable::decode(d)),\n-            21 => Opaque(Decodable::decode(d)),\n+            20 => Alias(Decodable::decode(d), Decodable::decode(d)),\n             22 => Param(Decodable::decode(d)),\n             23 => Bound(Decodable::decode(d), Decodable::decode(d)),\n             24 => Placeholder(Decodable::decode(d)),\n@@ -694,10 +669,9 @@ where\n     I::Mutability: HashStable<CTX>,\n     I::BinderListTy: HashStable<CTX>,\n     I::ListTy: HashStable<CTX>,\n-    I::ProjectionTy: HashStable<CTX>,\n+    I::AliasTy: HashStable<CTX>,\n     I::BoundTy: HashStable<CTX>,\n     I::ParamTy: HashStable<CTX>,\n-    I::OpaqueTy: HashStable<CTX>,\n     I::PlaceholderType: HashStable<CTX>,\n     I::InferTy: HashStable<CTX>,\n     I::ErrorGuaranteed: HashStable<CTX>,\n@@ -772,12 +746,10 @@ where\n             Tuple(substs) => {\n                 substs.hash_stable(__hcx, __hasher);\n             }\n-            Projection(p) => {\n+            Alias(k, p) => {\n+                k.hash_stable(__hcx, __hasher);\n                 p.hash_stable(__hcx, __hasher);\n             }\n-            Opaque(o) => {\n-                o.hash_stable(__hcx, __hasher);\n-            }\n             Param(p) => {\n                 p.hash_stable(__hcx, __hasher);\n             }"}, {"sha": "4a4dc899ba9a379279fa6e0e1d7ea50002dee894", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -1487,7 +1487,9 @@ fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type\n         hir::QPath::TypeRelative(qself, segment) => {\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n             let res = match ty.kind() {\n-                ty::Projection(proj) => Res::Def(DefKind::Trait, proj.trait_ref(cx.tcx).def_id),\n+                ty::Alias(ty::Projection, proj) => {\n+                    Res::Def(DefKind::Trait, proj.trait_ref(cx.tcx).def_id)\n+                }\n                 // Rustdoc handles `ty::Error`s by turning them into `Type::Infer`s.\n                 ty::Error(_) => return Type::Infer,\n                 // Otherwise, this is an inherent associated type.\n@@ -1823,7 +1825,7 @@ pub(crate) fn clean_middle_ty<'tcx>(\n             Tuple(t.iter().map(|t| clean_middle_ty(bound_ty.rebind(t), cx, None)).collect())\n         }\n \n-        ty::Projection(ref data) => clean_projection(bound_ty.rebind(*data), cx, def_id),\n+        ty::Alias(ty::Projection, ref data) => clean_projection(bound_ty.rebind(*data), cx, def_id),\n \n         ty::Param(ref p) => {\n             if let Some(bounds) = cx.impl_trait_bounds.remove(&p.index.into()) {\n@@ -1833,7 +1835,7 @@ pub(crate) fn clean_middle_ty<'tcx>(\n             }\n         }\n \n-        ty::Opaque(ty::AliasTy { def_id, substs }) => {\n+        ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs }) => {\n             // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n             // by looking up the bounds associated with the def_id.\n             let bounds = cx"}, {"sha": "4f0eb8b8076e5fae8214dfb8a71ace1658385d36", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -538,11 +538,10 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             ty::Adt(ty::AdtDef(Interned(&ty::AdtDefData { did, .. }, _)), _) | ty::Foreign(did) => {\n                 Res::from_def_id(self.cx.tcx, did)\n             }\n-            ty::Projection(_)\n+            ty::Alias(..)\n             | ty::Closure(..)\n             | ty::Generator(..)\n             | ty::GeneratorWitness(_)\n-            | ty::Opaque(..)\n             | ty::Dynamic(..)\n             | ty::Param(_)\n             | ty::Bound(..)"}, {"sha": "3f7429a5fccf83cef8b9f289ac2b1d1c36527125", "filename": "src/test/ui-fulldeps/internal-lints/ty_tykind_usage.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -33,8 +33,7 @@ fn main() {\n         TyKind::GeneratorWitness(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n         TyKind::Never => (),                //~ ERROR usage of `ty::TyKind::<kind>`\n         TyKind::Tuple(..) => (),            //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Projection(..) => (),       //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Opaque(..) => (),           //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Alias(..) => (),            //~ ERROR usage of `ty::TyKind::<kind>`\n         TyKind::Param(..) => (),            //~ ERROR usage of `ty::TyKind::<kind>`\n         TyKind::Bound(..) => (),            //~ ERROR usage of `ty::TyKind::<kind>`\n         TyKind::Placeholder(..) => (),      //~ ERROR usage of `ty::TyKind::<kind>`"}, {"sha": "1f49d6b64646f0282b4d214c63f6ecd69f0e1a60", "filename": "src/test/ui-fulldeps/internal-lints/ty_tykind_usage.stderr", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.stderr?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -133,82 +133,76 @@ LL |         TyKind::Tuple(..) => (),\n error: usage of `ty::TyKind::<kind>`\n   --> $DIR/ty_tykind_usage.rs:36:9\n    |\n-LL |         TyKind::Projection(..) => (),\n+LL |         TyKind::Alias(..) => (),\n    |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n   --> $DIR/ty_tykind_usage.rs:37:9\n    |\n-LL |         TyKind::Opaque(..) => (),\n-   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n-\n-error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:38:9\n-   |\n LL |         TyKind::Param(..) => (),\n    |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:39:9\n+  --> $DIR/ty_tykind_usage.rs:38:9\n    |\n LL |         TyKind::Bound(..) => (),\n    |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:40:9\n+  --> $DIR/ty_tykind_usage.rs:39:9\n    |\n LL |         TyKind::Placeholder(..) => (),\n    |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:41:9\n+  --> $DIR/ty_tykind_usage.rs:40:9\n    |\n LL |         TyKind::Infer(..) => (),\n    |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:42:9\n+  --> $DIR/ty_tykind_usage.rs:41:9\n    |\n LL |         TyKind::Error(_) => (),\n    |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:47:12\n+  --> $DIR/ty_tykind_usage.rs:46:12\n    |\n LL |     if let TyKind::Int(int_ty) = kind {}\n    |            ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind`\n-  --> $DIR/ty_tykind_usage.rs:49:24\n+  --> $DIR/ty_tykind_usage.rs:48:24\n    |\n LL |     fn ty_kind(ty_bad: TyKind<'_>, ty_good: Ty<'_>) {}\n    |                        ^^^^^^^^^^\n    |\n    = help: try using `Ty` instead\n \n error: usage of `ty::TyKind`\n-  --> $DIR/ty_tykind_usage.rs:51:37\n+  --> $DIR/ty_tykind_usage.rs:50:37\n    |\n LL |     fn ir_ty_kind<I: Interner>(bad: IrTyKind<I>) -> IrTyKind<I> {\n    |                                     ^^^^^^^^^^^\n    |\n    = help: try using `Ty` instead\n \n error: usage of `ty::TyKind`\n-  --> $DIR/ty_tykind_usage.rs:51:53\n+  --> $DIR/ty_tykind_usage.rs:50:53\n    |\n LL |     fn ir_ty_kind<I: Interner>(bad: IrTyKind<I>) -> IrTyKind<I> {\n    |                                                     ^^^^^^^^^^^\n    |\n    = help: try using `Ty` instead\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:54:9\n+  --> $DIR/ty_tykind_usage.rs:53:9\n    |\n LL |         IrTyKind::Bool\n    |         --------^^^^^^\n    |         |\n    |         help: try using `ty::<kind>` directly: `ty`\n \n-error: aborting due to 33 previous errors\n+error: aborting due to 32 previous errors\n "}, {"sha": "31183266acfcba44236911f54cd37d25113dc8ef", "filename": "src/tools/clippy/clippy_lints/src/dereference.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -1244,7 +1244,7 @@ fn is_mixed_projection_predicate<'tcx>(\n         let mut projection_ty = projection_predicate.projection_ty;\n         loop {\n             match projection_ty.self_ty().kind() {\n-                ty::Projection(inner_projection_ty) => {\n+                ty::Alias(ty::Projection, inner_projection_ty) => {\n                     projection_ty = *inner_projection_ty;\n                 }\n                 ty::Param(param_ty) => {\n@@ -1390,8 +1390,8 @@ fn ty_auto_deref_stability<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, precedenc\n                 continue;\n             },\n             ty::Param(_) => TyPosition::new_deref_stable_for_result(precedence, ty),\n-            ty::Projection(_) if ty.has_non_region_param() => TyPosition::new_deref_stable_for_result(precedence, ty),\n-            ty::Infer(_) | ty::Error(_) | ty::Bound(..) | ty::Opaque(..) | ty::Placeholder(_) | ty::Dynamic(..) => {\n+            ty::Alias(ty::Projection, _) if ty.has_non_region_param() => TyPosition::new_deref_stable_for_result(precedence, ty),\n+            ty::Infer(_) | ty::Error(_) | ty::Bound(..) | ty::Alias(ty::Opaque, ..) | ty::Placeholder(_) | ty::Dynamic(..) => {\n                 Position::ReborrowStable(precedence).into()\n             },\n             ty::Adt(..) if ty.has_placeholders() || ty.has_opaque_types() => {\n@@ -1417,7 +1417,7 @@ fn ty_auto_deref_stability<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, precedenc\n             | ty::Closure(..)\n             | ty::Never\n             | ty::Tuple(_)\n-            | ty::Projection(_) => {\n+            | ty::Alias(ty::Projection, _) => {\n                 Position::DerefStable(precedence, ty.is_sized(cx.tcx, cx.param_env.without_caller_bounds())).into()\n             },\n         };"}, {"sha": "fcdac90fc237ae1a1a18bd7ffcf3e722e53bb545", "filename": "src/tools/clippy/clippy_lints/src/future_not_send.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -4,7 +4,7 @@ use rustc_hir::intravisit::FnKind;\n use rustc_hir::{Body, FnDecl, HirId};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{AliasTy, Clause, EarlyBinder, Opaque, PredicateKind};\n+use rustc_middle::ty::{self, AliasTy, Clause, EarlyBinder, PredicateKind};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{sym, Span};\n use rustc_trait_selection::traits::error_reporting::suggestions::TypeErrCtxtExt;\n@@ -62,7 +62,7 @@ impl<'tcx> LateLintPass<'tcx> for FutureNotSend {\n             return;\n         }\n         let ret_ty = return_ty(cx, hir_id);\n-        if let Opaque(AliasTy { def_id, substs }) = *ret_ty.kind() {\n+        if let ty::Alias(ty::Opaque, AliasTy { def_id, substs }) = *ret_ty.kind() {\n             let preds = cx.tcx.explicit_item_bounds(def_id);\n             let mut is_future = false;\n             for &(p, _span) in preds {"}, {"sha": "73841f9aa9a2112a626dd86e95b34779d90b33ff", "filename": "src/tools/clippy/clippy_lints/src/len_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -493,7 +493,7 @@ fn has_is_empty(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n                 .filter_by_name_unhygienic(is_empty)\n                 .any(|item| is_is_empty(cx, item))\n         }),\n-        ty::Projection(ref proj) => has_is_empty_impl(cx, proj.def_id),\n+        ty::Alias(ty::Projection, ref proj) => has_is_empty_impl(cx, proj.def_id),\n         ty::Adt(id, _) => has_is_empty_impl(cx, id.did()),\n         ty::Array(..) | ty::Slice(..) | ty::Str => true,\n         _ => false,"}, {"sha": "8bf542ada04dd80ace50f751c29337d8ecdd71d4", "filename": "src/tools/clippy/clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -82,7 +82,7 @@ fn check_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, span: Span) -> McfResult {\n             ty::Ref(_, _, hir::Mutability::Mut) => {\n                 return Err((span, \"mutable references in const fn are unstable\".into()));\n             },\n-            ty::Opaque(..) => return Err((span, \"`impl Trait` in const fn is unstable\".into())),\n+            ty::Alias(ty::Opaque, ..) => return Err((span, \"`impl Trait` in const fn is unstable\".into())),\n             ty::FnPtr(..) => {\n                 return Err((span, \"function pointers in const fn are unstable\".into()));\n             },"}, {"sha": "33f3b3af3dc02d125223da58b3c9fc694805def0", "filename": "src/tools/clippy/clippy_utils/src/ty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61adaf81873101587ffff4e1b8671acbc33d3df1/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61adaf81873101587ffff4e1b8671acbc33d3df1/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs?ref=61adaf81873101587ffff4e1b8671acbc33d3df1", "patch": "@@ -79,7 +79,7 @@ pub fn contains_ty_adt_constructor_opaque<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'\n                 return true;\n             }\n \n-            if let ty::Opaque(ty::AliasTy { def_id, substs: _ }) = *inner_ty.kind() {\n+            if let ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }) = *inner_ty.kind() {\n                 for &(predicate, _span) in cx.tcx.explicit_item_bounds(def_id) {\n                     match predicate.kind().skip_binder() {\n                         // For `impl Trait<U>`, it will register a predicate of `T: Trait<U>`, so we go through\n@@ -250,7 +250,7 @@ pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n             is_must_use_ty(cx, *ty)\n         },\n         ty::Tuple(substs) => substs.iter().any(|ty| is_must_use_ty(cx, ty)),\n-        ty::Opaque(ty::AliasTy { def_id, substs: _ }) => {\n+        ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }) => {\n             for (predicate, _) in cx.tcx.explicit_item_bounds(*def_id) {\n                 if let ty::PredicateKind::Clause(ty::Clause::Trait(trait_predicate)) = predicate.kind().skip_binder() {\n                     if cx.tcx.has_attr(trait_predicate.trait_ref.def_id, sym::must_use) {\n@@ -631,7 +631,7 @@ pub fn ty_sig<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<ExprFnSig<'t\n             Some(ExprFnSig::Closure(decl, subs.as_closure().sig()))\n         },\n         ty::FnDef(id, subs) => Some(ExprFnSig::Sig(cx.tcx.bound_fn_sig(id).subst(cx.tcx, subs), Some(id))),\n-        ty::Opaque(ty::AliasTy { def_id, substs: _ }) => sig_from_bounds(cx, ty, cx.tcx.item_bounds(def_id), cx.tcx.opt_parent(def_id)),\n+        ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs: _ }) => sig_from_bounds(cx, ty, cx.tcx.item_bounds(def_id), cx.tcx.opt_parent(def_id)),\n         ty::FnPtr(sig) => Some(ExprFnSig::Sig(sig, None)),\n         ty::Dynamic(bounds, _, _) => {\n             let lang_items = cx.tcx.lang_items();\n@@ -650,7 +650,7 @@ pub fn ty_sig<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<ExprFnSig<'t\n                 _ => None,\n             }\n         },\n-        ty::Projection(proj) => match cx.tcx.try_normalize_erasing_regions(cx.param_env, ty) {\n+        ty::Alias(ty::Projection, proj) => match cx.tcx.try_normalize_erasing_regions(cx.param_env, ty) {\n             Ok(normalized_ty) if normalized_ty != ty => ty_sig(cx, normalized_ty),\n             _ => sig_for_projection(cx, proj).or_else(|| sig_from_bounds(cx, ty, cx.param_env.caller_bounds(), None)),\n         },"}]}