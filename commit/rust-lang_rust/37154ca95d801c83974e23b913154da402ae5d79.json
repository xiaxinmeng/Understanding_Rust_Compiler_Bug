{"sha": "37154ca95d801c83974e23b913154da402ae5d79", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3MTU0Y2E5NWQ4MDFjODM5NzRlMjNiOTEzMTU0ZGE0MDJhZTVkNzk=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-08-17T00:52:18Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-08-18T03:13:42Z"}, "message": "Refactor `unresolved_imports` -> `indeterminate_imports`.", "tree": {"sha": "867035cd29e6034f255395de7c2a945f855307a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/867035cd29e6034f255395de7c2a945f855307a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37154ca95d801c83974e23b913154da402ae5d79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37154ca95d801c83974e23b913154da402ae5d79", "html_url": "https://github.com/rust-lang/rust/commit/37154ca95d801c83974e23b913154da402ae5d79", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37154ca95d801c83974e23b913154da402ae5d79/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c64cd86be866242a88bb1c103dfddf407ebdadde", "url": "https://api.github.com/repos/rust-lang/rust/commits/c64cd86be866242a88bb1c103dfddf407ebdadde", "html_url": "https://github.com/rust-lang/rust/commit/c64cd86be866242a88bb1c103dfddf407ebdadde"}], "stats": {"total": 124, "additions": 47, "deletions": 77}, "files": [{"sha": "2dac64ad2bba98f513493133817a31629248120f", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37154ca95d801c83974e23b913154da402ae5d79/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37154ca95d801c83974e23b913154da402ae5d79/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=37154ca95d801c83974e23b913154da402ae5d79", "patch": "@@ -131,7 +131,6 @@ impl<'b> Resolver<'b> {\n                         let subclass = ImportDirectiveSubclass::single(binding.name, source_name);\n                         let span = view_path.span;\n                         self.add_import_directive(module_path, subclass, span, item.id, vis);\n-                        self.unresolved_imports += 1;\n                     }\n                     ViewPathList(_, ref source_items) => {\n                         // Make sure there's at most one `mod` import in the list.\n@@ -177,14 +176,12 @@ impl<'b> Resolver<'b> {\n                             let subclass = ImportDirectiveSubclass::single(rename, name);\n                             let (span, id) = (source_item.span, source_item.node.id());\n                             self.add_import_directive(module_path, subclass, span, id, vis);\n-                            self.unresolved_imports += 1;\n                         }\n                     }\n                     ViewPathGlob(_) => {\n                         let subclass = GlobImport { is_prelude: is_prelude };\n                         let span = view_path.span;\n                         self.add_import_directive(module_path, subclass, span, item.id, vis);\n-                        self.unresolved_imports += 1;\n                     }\n                 }\n             }"}, {"sha": "1660a270cbd4fcbe8ea2b7e29319e90b1d1bd076", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37154ca95d801c83974e23b913154da402ae5d79/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37154ca95d801c83974e23b913154da402ae5d79/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=37154ca95d801c83974e23b913154da402ae5d79", "patch": "@@ -752,7 +752,6 @@ pub struct ModuleS<'a> {\n     extern_crate_id: Option<NodeId>,\n \n     resolutions: RefCell<HashMap<(Name, Namespace), &'a RefCell<NameResolution<'a>>>>,\n-    unresolved_imports: RefCell<Vec<&'a ImportDirective<'a>>>,\n \n     no_implicit_prelude: Cell<bool>,\n \n@@ -782,7 +781,6 @@ impl<'a> ModuleS<'a> {\n             def: def,\n             extern_crate_id: None,\n             resolutions: RefCell::new(HashMap::new()),\n-            unresolved_imports: RefCell::new(Vec::new()),\n             no_implicit_prelude: Cell::new(false),\n             glob_importers: RefCell::new(Vec::new()),\n             globs: RefCell::new((Vec::new())),\n@@ -965,8 +963,8 @@ pub struct Resolver<'a> {\n \n     structs: FnvHashMap<DefId, Vec<Name>>,\n \n-    // The number of imports that are currently unresolved.\n-    unresolved_imports: usize,\n+    // All indeterminate imports (i.e. imports not known to succeed or fail).\n+    indeterminate_imports: Vec<&'a ImportDirective<'a>>,\n \n     // The module that represents the current item scope.\n     current_module: Module<'a>,\n@@ -1153,7 +1151,7 @@ impl<'a> Resolver<'a> {\n             trait_item_map: FnvHashMap(),\n             structs: FnvHashMap(),\n \n-            unresolved_imports: 0,\n+            indeterminate_imports: Vec::new(),\n \n             current_module: graph_root,\n             value_ribs: vec![Rib::new(ModuleRibKind(graph_root))],"}, {"sha": "23a5b3c4990111232879bf64ba82a57b6a9653cb", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 44, "deletions": 69, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/37154ca95d801c83974e23b913154da402ae5d79/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37154ca95d801c83974e23b913154da402ae5d79/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=37154ca95d801c83974e23b913154da402ae5d79", "patch": "@@ -233,7 +233,7 @@ impl<'a> Resolver<'a> {\n             vis: vis,\n         });\n \n-        self.current_module.unresolved_imports.borrow_mut().push(directive);\n+        self.indeterminate_imports.push(directive);\n         match directive.subclass {\n             SingleImport { target, .. } => {\n                 for &ns in &[ValueNS, TypeNS] {\n@@ -360,43 +360,52 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n     /// point iteration.\n     fn resolve_imports(&mut self) {\n         let mut i = 0;\n-        let mut prev_unresolved_imports = 0;\n+        let mut prev_num_indeterminates = self.indeterminate_imports.len() + 1;\n         let mut errors = Vec::new();\n \n-        loop {\n-            debug!(\"(resolving imports) iteration {}, {} imports left\", i, self.unresolved_imports);\n-\n-            // Attempt to resolve imports in all local modules.\n-            for module in self.arenas.local_modules().iter() {\n-                self.current_module = module;\n-                self.resolve_imports_in_current_module(&mut errors);\n-            }\n-\n-            if self.unresolved_imports == 0 {\n-                debug!(\"(resolving imports) success\");\n-                for module in self.arenas.local_modules().iter() {\n-                    self.finalize_resolutions_in(module, false);\n+        while self.indeterminate_imports.len() < prev_num_indeterminates {\n+            prev_num_indeterminates = self.indeterminate_imports.len();\n+            debug!(\"(resolving imports) iteration {}, {} imports left\", i, prev_num_indeterminates);\n+\n+            let mut imports = Vec::new();\n+            ::std::mem::swap(&mut imports, &mut self.indeterminate_imports);\n+\n+            for import in imports {\n+                match self.resolve_import(&import) {\n+                    Failed(err) => {\n+                        let (span, help) = match err {\n+                            Some((span, msg)) => (span, format!(\". {}\", msg)),\n+                            None => (import.span, String::new()),\n+                        };\n+                        errors.push(ImportResolvingError {\n+                            import_directive: import,\n+                            span: span,\n+                            help: help,\n+                        });\n+                    }\n+                    Indeterminate => self.indeterminate_imports.push(import),\n+                    Success(()) => {}\n                 }\n-                break;\n             }\n \n-            if self.unresolved_imports == prev_unresolved_imports {\n-                // resolving failed\n-                // Report unresolved imports only if no hard error was already reported\n-                // to avoid generating multiple errors on the same import.\n-                // Imports that are still indeterminate at this point are actually blocked\n-                // by errored imports, so there is no point reporting them.\n-                for module in self.arenas.local_modules().iter() {\n-                    self.finalize_resolutions_in(module, errors.len() == 0);\n-                }\n-                for e in errors {\n-                    self.import_resolving_error(e)\n-                }\n-                break;\n+            i += 1;\n+        }\n+\n+        for module in self.arenas.local_modules().iter() {\n+            self.finalize_resolutions_in(module);\n+        }\n+\n+        // Report unresolved imports only if no hard error was already reported\n+        // to avoid generating multiple errors on the same import.\n+        if errors.len() == 0 {\n+            if let Some(import) = self.indeterminate_imports.iter().next() {\n+                let error = ResolutionError::UnresolvedImport(None);\n+                resolve_error(self.resolver, import.span, error);\n             }\n+        }\n \n-            i += 1;\n-            prev_unresolved_imports = self.unresolved_imports;\n+        for e in errors {\n+            self.import_resolving_error(e)\n         }\n     }\n \n@@ -429,35 +438,6 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                       ResolutionError::UnresolvedImport(Some((&path, &e.help))));\n     }\n \n-    /// Attempts to resolve imports for the given module only.\n-    fn resolve_imports_in_current_module(&mut self, errors: &mut Vec<ImportResolvingError<'b>>) {\n-        let mut imports = Vec::new();\n-        let mut unresolved_imports = self.current_module.unresolved_imports.borrow_mut();\n-        ::std::mem::swap(&mut imports, &mut unresolved_imports);\n-\n-        for import_directive in imports {\n-            match self.resolve_import(&import_directive) {\n-                Failed(err) => {\n-                    let (span, help) = match err {\n-                        Some((span, msg)) => (span, format!(\". {}\", msg)),\n-                        None => (import_directive.span, String::new()),\n-                    };\n-                    errors.push(ImportResolvingError {\n-                        import_directive: import_directive,\n-                        span: span,\n-                        help: help,\n-                    });\n-                }\n-                Indeterminate => unresolved_imports.push(import_directive),\n-                Success(()) => {\n-                    // Decrement the count of unresolved imports.\n-                    assert!(self.unresolved_imports >= 1);\n-                    self.unresolved_imports -= 1;\n-                }\n-            }\n-        }\n-    }\n-\n     /// Attempts to resolve the given import. The return value indicates\n     /// failure if we're certain the name does not exist, indeterminate if we\n     /// don't know whether the name exists at the moment due to other\n@@ -468,6 +448,9 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                names_to_string(&directive.module_path),\n                module_to_string(self.current_module));\n \n+        let module = directive.parent;\n+        self.current_module = module;\n+\n         let target_module = match directive.target_module.get() {\n             Some(module) => module,\n             _ => match self.resolve_module_path(&directive.module_path,\n@@ -490,7 +473,6 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         let value_result = self.resolve_name_in_module(target_module, source, ValueNS, false, true);\n         let type_result = self.resolve_name_in_module(target_module, source, TypeNS, false, true);\n \n-        let module = self.current_module;\n         let mut privacy_error = true;\n         for &(ns, result, determined) in &[(ValueNS, &value_result, value_determined),\n                                            (TypeNS, &type_result, type_determined)] {\n@@ -658,7 +640,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n \n     // Miscellaneous post-processing, including recording reexports, reporting conflicts,\n     // reporting the PRIVATE_IN_PUBLIC lint, and reporting unresolved imports.\n-    fn finalize_resolutions_in(&mut self, module: Module<'b>, report_unresolved_imports: bool) {\n+    fn finalize_resolutions_in(&mut self, module: Module<'b>) {\n         // Since import resolution is finished, globs will not define any more names.\n         *module.globs.borrow_mut() = Vec::new();\n \n@@ -706,13 +688,6 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 self.export_map.insert(node_id, reexports);\n             }\n         }\n-\n-        if report_unresolved_imports {\n-            for import in module.unresolved_imports.borrow().iter() {\n-                resolve_error(self.resolver, import.span, ResolutionError::UnresolvedImport(None));\n-                break;\n-            }\n-        }\n     }\n }\n "}]}