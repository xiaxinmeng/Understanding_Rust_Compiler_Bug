{"sha": "4c07f5e457102d52042735e277959f7e1a55491e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjMDdmNWU0NTcxMDJkNTIwNDI3MzVlMjc3OTU5ZjdlMWE1NTQ5MWU=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2013-04-26T00:22:08Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2013-04-26T00:22:08Z"}, "message": "Add Int, Uint and Float traits for primitive numbers", "tree": {"sha": "17afd8d4a8acb73ac65748817549dbc18fff077f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17afd8d4a8acb73ac65748817549dbc18fff077f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c07f5e457102d52042735e277959f7e1a55491e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c07f5e457102d52042735e277959f7e1a55491e", "html_url": "https://github.com/rust-lang/rust/commit/4c07f5e457102d52042735e277959f7e1a55491e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c07f5e457102d52042735e277959f7e1a55491e/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b62421000c8e0e9b08590b81af03e05c6edd3c10", "url": "https://api.github.com/repos/rust-lang/rust/commits/b62421000c8e0e9b08590b81af03e05c6edd3c10", "html_url": "https://github.com/rust-lang/rust/commit/b62421000c8e0e9b08590b81af03e05c6edd3c10"}], "stats": {"total": 170, "additions": 122, "deletions": 48}, "files": [{"sha": "55cabad7412c33d4a7eec0563a829f8ab03a8661", "filename": "src/libcore/core.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c07f5e457102d52042735e277959f7e1a55491e/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/4c07f5e457102d52042735e277959f7e1a55491e/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=4c07f5e457102d52042735e277959f7e1a55491e", "patch": "@@ -108,6 +108,7 @@ pub use num::{Signed, Unsigned, Integer};\n pub use num::{Round, Fractional, Real, RealExt};\n pub use num::{Bitwise, Bounded};\n pub use num::{Primitive, PrimitiveInt};\n+pub use num::{Int, Uint, Float};\n pub use ptr::Ptr;\n pub use to_str::ToStr;\n pub use clone::Clone;"}, {"sha": "f6330df9f9ea55f97a1e94af6914ca8bba7261da", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 32, "deletions": 18, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4c07f5e457102d52042735e277959f7e1a55491e/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c07f5e457102d52042735e277959f7e1a55491e/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=4c07f5e457102d52042735e277959f7e1a55491e", "patch": "@@ -114,9 +114,6 @@ pub static infinity: f32 = 1.0_f32/0.0_f32;\n \n pub static neg_infinity: f32 = -1.0_f32/0.0_f32;\n \n-#[inline(always)]\n-pub fn is_NaN(f: f32) -> bool { f != f }\n-\n #[inline(always)]\n pub fn add(x: f32, y: f32) -> f32 { return x + y; }\n \n@@ -154,18 +151,6 @@ pub fn gt(x: f32, y: f32) -> bool { return x > y; }\n // FIXME (#1999): replace the predicates below with llvm intrinsics or\n // calls to the libmath macros in the rust runtime for performance.\n \n-/// Returns true if `x`is an infinite number\n-#[inline(always)]\n-pub fn is_infinite(x: f32) -> bool {\n-    return x == infinity || x == neg_infinity;\n-}\n-\n-/// Returns true if `x`is a finite number\n-#[inline(always)]\n-pub fn is_finite(x: f32) -> bool {\n-    return !(is_NaN(x) || is_infinite(x));\n-}\n-\n // FIXME (#1999): add is_normal, is_subnormal, and fpclassify.\n \n /* Module: consts */\n@@ -313,7 +298,7 @@ impl Signed for f32 {\n     ///\n     #[inline(always)]\n     fn signum(&self) -> f32 {\n-        if is_NaN(*self) { NaN } else { copysign(1.0, *self) }\n+        if self.is_NaN() { NaN } else { copysign(1.0, *self) }\n     }\n \n     /// Returns `true` if the number is positive, including `+0.0` and `infinity`\n@@ -517,6 +502,35 @@ impl Primitive for f32 {\n     fn bytes() -> uint { Primitive::bits::<f32>() / 8 }\n }\n \n+impl Float for f32 {\n+    #[inline(always)]\n+    fn NaN() -> f32 { 0.0 / 0.0 }\n+\n+    #[inline(always)]\n+    fn infinity() -> f32 { 1.0 / 0.0 }\n+\n+    #[inline(always)]\n+    fn neg_infinity() -> f32 { -1.0 / 0.0 }\n+\n+    #[inline(always)]\n+    fn neg_zero() -> f32 { -0.0 }\n+\n+    #[inline(always)]\n+    fn is_NaN(&self) -> bool { *self != *self }\n+\n+    /// Returns `true` if the number is infinite\n+    #[inline(always)]\n+    fn is_infinite(&self) -> bool {\n+        *self == Float::infinity() || *self == Float::neg_infinity()\n+    }\n+\n+    /// Returns `true` if the number is finite\n+    #[inline(always)]\n+    fn is_finite(&self) -> bool {\n+        !(self.is_NaN() || self.is_infinite())\n+    }\n+}\n+\n //\n // Section: String Conversions\n //\n@@ -852,7 +866,7 @@ mod tests {\n         assert_eq!((-1f32).abs(), 1f32);\n         assert_eq!(neg_infinity.abs(), infinity);\n         assert_eq!((1f32/neg_infinity).abs(), 0f32);\n-        assert!(is_NaN(NaN.abs()));\n+        assert!(NaN.abs().is_NaN());\n \n         assert_eq!(infinity.signum(), 1f32);\n         assert_eq!(1f32.signum(), 1f32);\n@@ -861,7 +875,7 @@ mod tests {\n         assert_eq!((-1f32).signum(), -1f32);\n         assert_eq!(neg_infinity.signum(), -1f32);\n         assert_eq!((1f32/neg_infinity).signum(), -1f32);\n-        assert!(is_NaN(NaN.signum()));\n+        assert!(NaN.signum().is_NaN());\n \n         assert!(infinity.is_positive());\n         assert!(1f32.is_positive());"}, {"sha": "d40c402b464d95dba4b9cdebc5dc2e408b938d3e", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 32, "deletions": 18, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4c07f5e457102d52042735e277959f7e1a55491e/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c07f5e457102d52042735e277959f7e1a55491e/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=4c07f5e457102d52042735e277959f7e1a55491e", "patch": "@@ -138,9 +138,6 @@ pub static infinity: f64 = 1.0_f64/0.0_f64;\n \n pub static neg_infinity: f64 = -1.0_f64/0.0_f64;\n \n-#[inline(always)]\n-pub fn is_NaN(f: f64) -> bool { f != f }\n-\n #[inline(always)]\n pub fn add(x: f64, y: f64) -> f64 { return x + y; }\n \n@@ -174,18 +171,6 @@ pub fn ge(x: f64, y: f64) -> bool { return x >= y; }\n #[inline(always)]\n pub fn gt(x: f64, y: f64) -> bool { return x > y; }\n \n-/// Returns true if `x`is an infinite number\n-#[inline(always)]\n-pub fn is_infinite(x: f64) -> bool {\n-    return x == infinity || x == neg_infinity;\n-}\n-\n-/// Returns true if `x` is a finite number\n-#[inline(always)]\n-pub fn is_finite(x: f64) -> bool {\n-    return !(is_NaN(x) || is_infinite(x));\n-}\n-\n \n // FIXME (#1999): add is_normal, is_subnormal, and fpclassify\n \n@@ -323,7 +308,7 @@ impl Signed for f64 {\n     ///\n     #[inline(always)]\n     fn signum(&self) -> f64 {\n-        if is_NaN(*self) { NaN } else { copysign(1.0, *self) }\n+        if self.is_NaN() { NaN } else { copysign(1.0, *self) }\n     }\n \n     /// Returns `true` if the number is positive, including `+0.0` and `infinity`\n@@ -557,6 +542,35 @@ impl Primitive for f64 {\n     fn bytes() -> uint { Primitive::bits::<f64>() / 8 }\n }\n \n+impl Float for f64 {\n+    #[inline(always)]\n+    fn NaN() -> f64 { 0.0 / 0.0 }\n+\n+    #[inline(always)]\n+    fn infinity() -> f64 { 1.0 / 0.0 }\n+\n+    #[inline(always)]\n+    fn neg_infinity() -> f64 { -1.0 / 0.0 }\n+\n+    #[inline(always)]\n+    fn neg_zero() -> f64 { -0.0 }\n+\n+    #[inline(always)]\n+    fn is_NaN(&self) -> bool { *self != *self }\n+\n+    /// Returns `true` if the number is infinite\n+    #[inline(always)]\n+    fn is_infinite(&self) -> bool {\n+        *self == Float::infinity() || *self == Float::neg_infinity()\n+    }\n+\n+    /// Returns `true` if the number is finite\n+    #[inline(always)]\n+    fn is_finite(&self) -> bool {\n+        !(self.is_NaN() || self.is_infinite())\n+    }\n+}\n+\n //\n // Section: String Conversions\n //\n@@ -893,7 +907,7 @@ mod tests {\n         assert_eq!((-1f64).abs(), 1f64);\n         assert_eq!(neg_infinity.abs(), infinity);\n         assert_eq!((1f64/neg_infinity).abs(), 0f64);\n-        assert!(is_NaN(NaN.abs()));\n+        assert!(NaN.abs().is_NaN());\n \n         assert_eq!(infinity.signum(), 1f64);\n         assert_eq!(1f64.signum(), 1f64);\n@@ -902,7 +916,7 @@ mod tests {\n         assert_eq!((-1f64).signum(), -1f64);\n         assert_eq!(neg_infinity.signum(), -1f64);\n         assert_eq!((1f64/neg_infinity).signum(), -1f64);\n-        assert!(is_NaN(NaN.signum()));\n+        assert!(NaN.signum().is_NaN());\n \n         assert!(infinity.is_positive());\n         assert!(1f64.is_positive());"}, {"sha": "9852e05c0b829d631cc3874ac045f359198f3f77", "filename": "src/libcore/num/float.rs", "status": "modified", "additions": 34, "deletions": 12, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4c07f5e457102d52042735e277959f7e1a55491e/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c07f5e457102d52042735e277959f7e1a55491e/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=4c07f5e457102d52042735e277959f7e1a55491e", "patch": "@@ -337,13 +337,6 @@ pub fn pow_with_uint(base: uint, pow: uint) -> float {\n     return total;\n }\n \n-#[inline(always)]\n-pub fn is_infinite(x: float) -> bool { f64::is_infinite(x as f64) }\n-#[inline(always)]\n-pub fn is_finite(x: float) -> bool { f64::is_finite(x as f64) }\n-#[inline(always)]\n-pub fn is_NaN(x: float) -> bool { f64::is_NaN(x as f64) }\n-\n #[inline(always)]\n pub fn abs(x: float) -> float {\n     f64::abs(x as f64) as float\n@@ -677,7 +670,7 @@ impl Signed for float {\n     ///\n     #[inline(always)]\n     fn signum(&self) -> float {\n-        if is_NaN(*self) { NaN } else { f64::copysign(1.0, *self as f64) as float }\n+        if self.is_NaN() { NaN } else { f64::copysign(1.0, *self as f64) as float }\n     }\n \n     /// Returns `true` if the number is positive, including `+0.0` and `infinity`\n@@ -697,6 +690,35 @@ impl Primitive for float {\n     fn bytes() -> uint { Primitive::bytes::<f64>() }\n }\n \n+impl Float for float {\n+    #[inline(always)]\n+    fn NaN() -> float { 0.0 / 0.0 }\n+\n+    #[inline(always)]\n+    fn infinity() -> float { 1.0 / 0.0 }\n+\n+    #[inline(always)]\n+    fn neg_infinity() -> float { -1.0 / 0.0 }\n+\n+    #[inline(always)]\n+    fn neg_zero() -> float { -0.0 }\n+\n+    #[inline(always)]\n+    fn is_NaN(&self) -> bool { *self != *self }\n+\n+    /// Returns `true` if the number is infinite\n+    #[inline(always)]\n+    fn is_infinite(&self) -> bool {\n+        *self == Float::infinity() || *self == Float::neg_infinity()\n+    }\n+\n+    /// Returns `true` if the number is finite\n+    #[inline(always)]\n+    fn is_finite(&self) -> bool {\n+        !(self.is_NaN() || self.is_infinite())\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n@@ -814,7 +836,7 @@ mod tests {\n         assert_eq!((-1f).abs(), 1f);\n         assert_eq!(neg_infinity.abs(), infinity);\n         assert_eq!((1f/neg_infinity).abs(), 0f);\n-        assert!(is_NaN(NaN.abs()));\n+        assert!(NaN.abs().is_NaN());\n \n         assert_eq!(infinity.signum(), 1f);\n         assert_eq!(1f.signum(), 1f);\n@@ -823,7 +845,7 @@ mod tests {\n         assert_eq!((-1f).signum(), -1f);\n         assert_eq!(neg_infinity.signum(), -1f);\n         assert_eq!((1f/neg_infinity).signum(), -1f);\n-        assert!(is_NaN(NaN.signum()));\n+        assert!(NaN.signum().is_NaN());\n \n         assert!(infinity.is_positive());\n         assert!(1f.is_positive());\n@@ -878,7 +900,7 @@ mod tests {\n         assert_eq!(from_str(~\"-inf\"), Some(neg_infinity));\n         // note: NaN != NaN, hence this slightly complex test\n         match from_str(~\"NaN\") {\n-            Some(f) => assert!(is_NaN(f)),\n+            Some(f) => assert!(f.is_NaN()),\n             None => fail!()\n         }\n         // note: -0 == 0, hence these slightly more complex tests\n@@ -925,7 +947,7 @@ mod tests {\n         assert_eq!(from_str_hex(~\"-inf\"), Some(neg_infinity));\n         // note: NaN != NaN, hence this slightly complex test\n         match from_str_hex(~\"NaN\") {\n-            Some(f) => assert!(is_NaN(f)),\n+            Some(f) => assert!(f.is_NaN()),\n             None => fail!()\n         }\n         // note: -0 == 0, hence these slightly more complex tests"}, {"sha": "877767b5cbf6a096bd2e5e02ca2edef6bce5af2e", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c07f5e457102d52042735e277959f7e1a55491e/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c07f5e457102d52042735e277959f7e1a55491e/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=4c07f5e457102d52042735e277959f7e1a55491e", "patch": "@@ -447,6 +447,8 @@ impl Bounded for T {\n \n impl PrimitiveInt for T {}\n \n+impl Int for T {}\n+\n // String conversion functions and impl str -> num\n \n /// Parse a string as a number in base 10."}, {"sha": "8e6128ceb9763bb921d63627eaaa5d6aefe9ebde", "filename": "src/libcore/num/num.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4c07f5e457102d52042735e277959f7e1a55491e/src%2Flibcore%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c07f5e457102d52042735e277959f7e1a55491e/src%2Flibcore%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fnum.rs?ref=4c07f5e457102d52042735e277959f7e1a55491e", "patch": "@@ -228,6 +228,24 @@ pub trait Uint: PrimitiveInt\n pub trait Int: PrimitiveInt\n              + Signed {}\n \n+///\n+/// Primitive floating point numbers. This trait should only be implemented\n+/// for the `f32`, `f64`, and `float` types.\n+///\n+pub trait Float: Real\n+               + Signed\n+               + Primitive {\n+    // FIXME (#5527): These should be associated constants\n+    fn NaN() -> Self;\n+    fn infinity() -> Self;\n+    fn neg_infinity() -> Self;\n+    fn neg_zero() -> Self;\n+\n+    fn is_NaN(&self) -> bool;\n+    fn is_infinite(&self) -> bool;\n+    fn is_finite(&self) -> bool;\n+}\n+\n ///\n /// Cast from one machine scalar to another\n ///"}, {"sha": "67a930c72a4676f2e731980e041df7915e7df935", "filename": "src/libcore/num/uint-template.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c07f5e457102d52042735e277959f7e1a55491e/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c07f5e457102d52042735e277959f7e1a55491e/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=4c07f5e457102d52042735e277959f7e1a55491e", "patch": "@@ -279,6 +279,8 @@ impl Bounded for T {\n \n impl PrimitiveInt for T {}\n \n+impl Uint for T {}\n+\n // String conversion functions and impl str -> num\n \n /// Parse a string as a number in base 10."}, {"sha": "fdae5298d7cc6a61781c1a0a5f5350b776ce444c", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c07f5e457102d52042735e277959f7e1a55491e/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c07f5e457102d52042735e277959f7e1a55491e/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=4c07f5e457102d52042735e277959f7e1a55491e", "patch": "@@ -42,6 +42,7 @@ pub use num::{Signed, Unsigned, Integer};\n pub use num::{Round, Fractional, Real, RealExt};\n pub use num::{Bitwise, Bounded};\n pub use num::{Primitive, PrimitiveInt};\n+pub use num::{Int, Uint, Float};\n pub use path::GenericPath;\n pub use path::Path;\n pub use path::PosixPath;"}]}