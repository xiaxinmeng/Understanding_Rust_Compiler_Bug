{"sha": "bf5c62da9ecd12fbbd255731add216bf90d3239a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmNWM2MmRhOWVjZDEyZmJiZDI1NTczMWFkZDIxNmJmOTBkMzIzOWE=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-05-25T20:33:21Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-06-03T12:49:35Z"}, "message": "move confirmation into submodule", "tree": {"sha": "7e83f753127d99980ce40a1e560a783227db4e84", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e83f753127d99980ce40a1e560a783227db4e84"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf5c62da9ecd12fbbd255731add216bf90d3239a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf5c62da9ecd12fbbd255731add216bf90d3239a", "html_url": "https://github.com/rust-lang/rust/commit/bf5c62da9ecd12fbbd255731add216bf90d3239a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf5c62da9ecd12fbbd255731add216bf90d3239a/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8172ec405515372da895c7c4bfe4f32b9af81a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8172ec405515372da895c7c4bfe4f32b9af81a0", "html_url": "https://github.com/rust-lang/rust/commit/b8172ec405515372da895c7c4bfe4f32b9af81a0"}], "stats": {"total": 1631, "additions": 827, "deletions": 804}, "files": [{"sha": "65bb9b7cda93748338c5c9732b2f7a20d4302135", "filename": "src/librustc_trait_selection/traits/select/confirmation.rs", "status": "added", "additions": 820, "deletions": 0, "changes": 820, "blob_url": "https://github.com/rust-lang/rust/blob/bf5c62da9ecd12fbbd255731add216bf90d3239a/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf5c62da9ecd12fbbd255731add216bf90d3239a/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fconfirmation.rs?ref=bf5c62da9ecd12fbbd255731add216bf90d3239a", "patch": "@@ -0,0 +1,820 @@\n+//! Confirmation.\n+//!\n+//! Confirmation unifies the output type parameters of the trait\n+//! with the values found in the obligation, possibly yielding a\n+//! type error.  See the [rustc dev guide] for more details.\n+//!\n+//! [rustc dev guide]:\n+//! https://rustc-dev-guide.rust-lang.org/traits/resolution.html#confirmation\n+use rustc_data_structures::stack::ensure_sufficient_stack;\n+use rustc_hir::lang_items;\n+use rustc_index::bit_set::GrowableBitSet;\n+use rustc_infer::infer::InferOk;\n+use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst, SubstsRef};\n+use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty::{ToPolyTraitRef, ToPredicate, WithConstness};\n+use rustc_span::def_id::DefId;\n+\n+use crate::traits::project::{self, normalize_with_depth};\n+use crate::traits::select::TraitObligationExt;\n+use crate::traits::util;\n+use crate::traits::util::{closure_trait_ref_and_return_type, predicate_for_trait_def};\n+use crate::traits::Normalized;\n+use crate::traits::OutputTypeParameterMismatch;\n+use crate::traits::Selection;\n+use crate::traits::TraitNotObjectSafe;\n+use crate::traits::{BuiltinDerivedObligation, ImplDerivedObligation};\n+use crate::traits::{ObjectCastObligation, PredicateObligation, TraitObligation};\n+use crate::traits::{Obligation, ObligationCause};\n+use crate::traits::{SelectionError, Unimplemented};\n+use crate::traits::{\n+    VtableAutoImpl, VtableBuiltin, VtableClosure, VtableDiscriminantKind, VtableFnPointer,\n+    VtableGenerator, VtableImpl, VtableObject, VtableParam, VtableTraitAlias,\n+};\n+use crate::traits::{\n+    VtableAutoImplData, VtableBuiltinData, VtableClosureData, VtableDiscriminantKindData,\n+    VtableFnPointerData, VtableGeneratorData, VtableImplData, VtableObjectData,\n+    VtableTraitAliasData,\n+};\n+\n+use super::BuiltinImplConditions;\n+use super::SelectionCandidate::{self, *};\n+use super::SelectionContext;\n+\n+use std::iter;\n+\n+impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n+    pub(super) fn confirm_candidate(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        candidate: SelectionCandidate<'tcx>,\n+    ) -> Result<Selection<'tcx>, SelectionError<'tcx>> {\n+        debug!(\"confirm_candidate({:?}, {:?})\", obligation, candidate);\n+\n+        match candidate {\n+            BuiltinCandidate { has_nested } => {\n+                let data = self.confirm_builtin_candidate(obligation, has_nested);\n+                Ok(VtableBuiltin(data))\n+            }\n+\n+            ParamCandidate(param) => {\n+                let obligations = self.confirm_param_candidate(obligation, param);\n+                Ok(VtableParam(obligations))\n+            }\n+\n+            ImplCandidate(impl_def_id) => {\n+                Ok(VtableImpl(self.confirm_impl_candidate(obligation, impl_def_id)))\n+            }\n+\n+            AutoImplCandidate(trait_def_id) => {\n+                let data = self.confirm_auto_impl_candidate(obligation, trait_def_id);\n+                Ok(VtableAutoImpl(data))\n+            }\n+\n+            ProjectionCandidate => {\n+                self.confirm_projection_candidate(obligation);\n+                Ok(VtableParam(Vec::new()))\n+            }\n+\n+            ClosureCandidate => {\n+                let vtable_closure = self.confirm_closure_candidate(obligation)?;\n+                Ok(VtableClosure(vtable_closure))\n+            }\n+\n+            GeneratorCandidate => {\n+                let vtable_generator = self.confirm_generator_candidate(obligation)?;\n+                Ok(VtableGenerator(vtable_generator))\n+            }\n+\n+            FnPointerCandidate => {\n+                let data = self.confirm_fn_pointer_candidate(obligation)?;\n+                Ok(VtableFnPointer(data))\n+            }\n+\n+            DiscriminantKindCandidate => Ok(VtableDiscriminantKind(VtableDiscriminantKindData)),\n+\n+            TraitAliasCandidate(alias_def_id) => {\n+                let data = self.confirm_trait_alias_candidate(obligation, alias_def_id);\n+                Ok(VtableTraitAlias(data))\n+            }\n+\n+            ObjectCandidate => {\n+                let data = self.confirm_object_candidate(obligation);\n+                Ok(VtableObject(data))\n+            }\n+\n+            BuiltinObjectCandidate => {\n+                // This indicates something like `Trait + Send: Send`. In this case, we know that\n+                // this holds because that's what the object type is telling us, and there's really\n+                // no additional obligations to prove and no types in particular to unify, etc.\n+                Ok(VtableParam(Vec::new()))\n+            }\n+\n+            BuiltinUnsizeCandidate => {\n+                let data = self.confirm_builtin_unsize_candidate(obligation)?;\n+                Ok(VtableBuiltin(data))\n+            }\n+        }\n+    }\n+\n+    fn confirm_projection_candidate(&mut self, obligation: &TraitObligation<'tcx>) {\n+        self.infcx.commit_unconditionally(|snapshot| {\n+            let result =\n+                self.match_projection_obligation_against_definition_bounds(obligation, snapshot);\n+            assert!(result);\n+        })\n+    }\n+\n+    fn confirm_param_candidate(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        param: ty::PolyTraitRef<'tcx>,\n+    ) -> Vec<PredicateObligation<'tcx>> {\n+        debug!(\"confirm_param_candidate({:?},{:?})\", obligation, param);\n+\n+        // During evaluation, we already checked that this\n+        // where-clause trait-ref could be unified with the obligation\n+        // trait-ref. Repeat that unification now without any\n+        // transactional boundary; it should not fail.\n+        match self.match_where_clause_trait_ref(obligation, param) {\n+            Ok(obligations) => obligations,\n+            Err(()) => {\n+                bug!(\n+                    \"Where clause `{:?}` was applicable to `{:?}` but now is not\",\n+                    param,\n+                    obligation\n+                );\n+            }\n+        }\n+    }\n+\n+    fn confirm_builtin_candidate(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        has_nested: bool,\n+    ) -> VtableBuiltinData<PredicateObligation<'tcx>> {\n+        debug!(\"confirm_builtin_candidate({:?}, {:?})\", obligation, has_nested);\n+\n+        let lang_items = self.tcx().lang_items();\n+        let obligations = if has_nested {\n+            let trait_def = obligation.predicate.def_id();\n+            let conditions = if Some(trait_def) == lang_items.sized_trait() {\n+                self.sized_conditions(obligation)\n+            } else if Some(trait_def) == lang_items.copy_trait() {\n+                self.copy_clone_conditions(obligation)\n+            } else if Some(trait_def) == lang_items.clone_trait() {\n+                self.copy_clone_conditions(obligation)\n+            } else {\n+                bug!(\"unexpected builtin trait {:?}\", trait_def)\n+            };\n+            let nested = match conditions {\n+                BuiltinImplConditions::Where(nested) => nested,\n+                _ => bug!(\"obligation {:?} had matched a builtin impl but now doesn't\", obligation),\n+            };\n+\n+            let cause = obligation.derived_cause(BuiltinDerivedObligation);\n+            ensure_sufficient_stack(|| {\n+                self.collect_predicates_for_types(\n+                    obligation.param_env,\n+                    cause,\n+                    obligation.recursion_depth + 1,\n+                    trait_def,\n+                    nested,\n+                )\n+            })\n+        } else {\n+            vec![]\n+        };\n+\n+        debug!(\"confirm_builtin_candidate: obligations={:?}\", obligations);\n+\n+        VtableBuiltinData { nested: obligations }\n+    }\n+\n+    /// This handles the case where a `auto trait Foo` impl is being used.\n+    /// The idea is that the impl applies to `X : Foo` if the following conditions are met:\n+    ///\n+    /// 1. For each constituent type `Y` in `X`, `Y : Foo` holds\n+    /// 2. For each where-clause `C` declared on `Foo`, `[Self => X] C` holds.\n+    fn confirm_auto_impl_candidate(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        trait_def_id: DefId,\n+    ) -> VtableAutoImplData<PredicateObligation<'tcx>> {\n+        debug!(\"confirm_auto_impl_candidate({:?}, {:?})\", obligation, trait_def_id);\n+\n+        let types = obligation.predicate.map_bound(|inner| {\n+            let self_ty = self.infcx.shallow_resolve(inner.self_ty());\n+            self.constituent_types_for_ty(self_ty)\n+        });\n+        self.vtable_auto_impl(obligation, trait_def_id, types)\n+    }\n+\n+    /// See `confirm_auto_impl_candidate`.\n+    fn vtable_auto_impl(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        trait_def_id: DefId,\n+        nested: ty::Binder<Vec<Ty<'tcx>>>,\n+    ) -> VtableAutoImplData<PredicateObligation<'tcx>> {\n+        debug!(\"vtable_auto_impl: nested={:?}\", nested);\n+        ensure_sufficient_stack(|| {\n+            let cause = obligation.derived_cause(BuiltinDerivedObligation);\n+            let mut obligations = self.collect_predicates_for_types(\n+                obligation.param_env,\n+                cause,\n+                obligation.recursion_depth + 1,\n+                trait_def_id,\n+                nested,\n+            );\n+\n+            let trait_obligations: Vec<PredicateObligation<'_>> =\n+                self.infcx.commit_unconditionally(|_| {\n+                    let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n+                    let (trait_ref, _) =\n+                        self.infcx.replace_bound_vars_with_placeholders(&poly_trait_ref);\n+                    let cause = obligation.derived_cause(ImplDerivedObligation);\n+                    self.impl_or_trait_obligations(\n+                        cause,\n+                        obligation.recursion_depth + 1,\n+                        obligation.param_env,\n+                        trait_def_id,\n+                        &trait_ref.substs,\n+                    )\n+                });\n+\n+            // Adds the predicates from the trait.  Note that this contains a `Self: Trait`\n+            // predicate as usual.  It won't have any effect since auto traits are coinductive.\n+            obligations.extend(trait_obligations);\n+\n+            debug!(\"vtable_auto_impl: obligations={:?}\", obligations);\n+\n+            VtableAutoImplData { trait_def_id, nested: obligations }\n+        })\n+    }\n+\n+    fn confirm_impl_candidate(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        impl_def_id: DefId,\n+    ) -> VtableImplData<'tcx, PredicateObligation<'tcx>> {\n+        debug!(\"confirm_impl_candidate({:?},{:?})\", obligation, impl_def_id);\n+\n+        // First, create the substitutions by matching the impl again,\n+        // this time not in a probe.\n+        self.infcx.commit_unconditionally(|snapshot| {\n+            let substs = self.rematch_impl(impl_def_id, obligation, snapshot);\n+            debug!(\"confirm_impl_candidate: substs={:?}\", substs);\n+            let cause = obligation.derived_cause(ImplDerivedObligation);\n+            ensure_sufficient_stack(|| {\n+                self.vtable_impl(\n+                    impl_def_id,\n+                    substs,\n+                    cause,\n+                    obligation.recursion_depth + 1,\n+                    obligation.param_env,\n+                )\n+            })\n+        })\n+    }\n+\n+    fn vtable_impl(\n+        &mut self,\n+        impl_def_id: DefId,\n+        mut substs: Normalized<'tcx, SubstsRef<'tcx>>,\n+        cause: ObligationCause<'tcx>,\n+        recursion_depth: usize,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> VtableImplData<'tcx, PredicateObligation<'tcx>> {\n+        debug!(\n+            \"vtable_impl(impl_def_id={:?}, substs={:?}, recursion_depth={})\",\n+            impl_def_id, substs, recursion_depth,\n+        );\n+\n+        let mut impl_obligations = self.impl_or_trait_obligations(\n+            cause,\n+            recursion_depth,\n+            param_env,\n+            impl_def_id,\n+            &substs.value,\n+        );\n+\n+        debug!(\n+            \"vtable_impl: impl_def_id={:?} impl_obligations={:?}\",\n+            impl_def_id, impl_obligations\n+        );\n+\n+        // Because of RFC447, the impl-trait-ref and obligations\n+        // are sufficient to determine the impl substs, without\n+        // relying on projections in the impl-trait-ref.\n+        //\n+        // e.g., `impl<U: Tr, V: Iterator<Item=U>> Foo<<U as Tr>::T> for V`\n+        impl_obligations.append(&mut substs.obligations);\n+\n+        VtableImplData { impl_def_id, substs: substs.value, nested: impl_obligations }\n+    }\n+\n+    fn confirm_object_candidate(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+    ) -> VtableObjectData<'tcx, PredicateObligation<'tcx>> {\n+        debug!(\"confirm_object_candidate({:?})\", obligation);\n+\n+        // FIXME(nmatsakis) skipping binder here seems wrong -- we should\n+        // probably flatten the binder from the obligation and the binder\n+        // from the object. Have to try to make a broken test case that\n+        // results.\n+        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n+        let poly_trait_ref = match self_ty.kind {\n+            ty::Dynamic(ref data, ..) => data\n+                .principal()\n+                .unwrap_or_else(|| {\n+                    span_bug!(obligation.cause.span, \"object candidate with no principal\")\n+                })\n+                .with_self_ty(self.tcx(), self_ty),\n+            _ => span_bug!(obligation.cause.span, \"object candidate with non-object\"),\n+        };\n+\n+        let mut upcast_trait_ref = None;\n+        let mut nested = vec![];\n+        let vtable_base;\n+\n+        {\n+            let tcx = self.tcx();\n+\n+            // We want to find the first supertrait in the list of\n+            // supertraits that we can unify with, and do that\n+            // unification. We know that there is exactly one in the list\n+            // where we can unify, because otherwise select would have\n+            // reported an ambiguity. (When we do find a match, also\n+            // record it for later.)\n+            let nonmatching = util::supertraits(tcx, poly_trait_ref).take_while(|&t| {\n+                match self.infcx.commit_if_ok(|_| self.match_poly_trait_ref(obligation, t)) {\n+                    Ok(obligations) => {\n+                        upcast_trait_ref = Some(t);\n+                        nested.extend(obligations);\n+                        false\n+                    }\n+                    Err(_) => true,\n+                }\n+            });\n+\n+            // Additionally, for each of the non-matching predicates that\n+            // we pass over, we sum up the set of number of vtable\n+            // entries, so that we can compute the offset for the selected\n+            // trait.\n+            vtable_base = nonmatching.map(|t| super::util::count_own_vtable_entries(tcx, t)).sum();\n+        }\n+\n+        VtableObjectData { upcast_trait_ref: upcast_trait_ref.unwrap(), vtable_base, nested }\n+    }\n+\n+    fn confirm_fn_pointer_candidate(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+    ) -> Result<VtableFnPointerData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n+        debug!(\"confirm_fn_pointer_candidate({:?})\", obligation);\n+\n+        // Okay to skip binder; it is reintroduced below.\n+        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n+        let sig = self_ty.fn_sig(self.tcx());\n+        let trait_ref = closure_trait_ref_and_return_type(\n+            self.tcx(),\n+            obligation.predicate.def_id(),\n+            self_ty,\n+            sig,\n+            util::TupleArgumentsFlag::Yes,\n+        )\n+        .map_bound(|(trait_ref, _)| trait_ref);\n+\n+        let Normalized { value: trait_ref, obligations } = ensure_sufficient_stack(|| {\n+            project::normalize_with_depth(\n+                self,\n+                obligation.param_env,\n+                obligation.cause.clone(),\n+                obligation.recursion_depth + 1,\n+                &trait_ref,\n+            )\n+        });\n+\n+        self.confirm_poly_trait_refs(\n+            obligation.cause.clone(),\n+            obligation.param_env,\n+            obligation.predicate.to_poly_trait_ref(),\n+            trait_ref,\n+        )?;\n+        Ok(VtableFnPointerData { fn_ty: self_ty, nested: obligations })\n+    }\n+\n+    fn confirm_trait_alias_candidate(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        alias_def_id: DefId,\n+    ) -> VtableTraitAliasData<'tcx, PredicateObligation<'tcx>> {\n+        debug!(\"confirm_trait_alias_candidate({:?}, {:?})\", obligation, alias_def_id);\n+\n+        self.infcx.commit_unconditionally(|_| {\n+            let (predicate, _) =\n+                self.infcx().replace_bound_vars_with_placeholders(&obligation.predicate);\n+            let trait_ref = predicate.trait_ref;\n+            let trait_def_id = trait_ref.def_id;\n+            let substs = trait_ref.substs;\n+\n+            let trait_obligations = self.impl_or_trait_obligations(\n+                obligation.cause.clone(),\n+                obligation.recursion_depth,\n+                obligation.param_env,\n+                trait_def_id,\n+                &substs,\n+            );\n+\n+            debug!(\n+                \"confirm_trait_alias_candidate: trait_def_id={:?} trait_obligations={:?}\",\n+                trait_def_id, trait_obligations\n+            );\n+\n+            VtableTraitAliasData { alias_def_id, substs, nested: trait_obligations }\n+        })\n+    }\n+\n+    fn confirm_generator_candidate(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+    ) -> Result<VtableGeneratorData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n+        // Okay to skip binder because the substs on generator types never\n+        // touch bound regions, they just capture the in-scope\n+        // type/region parameters.\n+        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n+        let (generator_def_id, substs) = match self_ty.kind {\n+            ty::Generator(id, substs, _) => (id, substs),\n+            _ => bug!(\"closure candidate for non-closure {:?}\", obligation),\n+        };\n+\n+        debug!(\"confirm_generator_candidate({:?},{:?},{:?})\", obligation, generator_def_id, substs);\n+\n+        let trait_ref = self.generator_trait_ref_unnormalized(obligation, substs);\n+        let Normalized { value: trait_ref, mut obligations } = ensure_sufficient_stack(|| {\n+            normalize_with_depth(\n+                self,\n+                obligation.param_env,\n+                obligation.cause.clone(),\n+                obligation.recursion_depth + 1,\n+                &trait_ref,\n+            )\n+        });\n+\n+        debug!(\n+            \"confirm_generator_candidate(generator_def_id={:?}, \\\n+             trait_ref={:?}, obligations={:?})\",\n+            generator_def_id, trait_ref, obligations\n+        );\n+\n+        obligations.extend(self.confirm_poly_trait_refs(\n+            obligation.cause.clone(),\n+            obligation.param_env,\n+            obligation.predicate.to_poly_trait_ref(),\n+            trait_ref,\n+        )?);\n+\n+        Ok(VtableGeneratorData { generator_def_id, substs, nested: obligations })\n+    }\n+\n+    fn confirm_closure_candidate(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+    ) -> Result<VtableClosureData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n+        debug!(\"confirm_closure_candidate({:?})\", obligation);\n+\n+        let kind = self\n+            .tcx()\n+            .fn_trait_kind_from_lang_item(obligation.predicate.def_id())\n+            .unwrap_or_else(|| bug!(\"closure candidate for non-fn trait {:?}\", obligation));\n+\n+        // Okay to skip binder because the substs on closure types never\n+        // touch bound regions, they just capture the in-scope\n+        // type/region parameters.\n+        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n+        let (closure_def_id, substs) = match self_ty.kind {\n+            ty::Closure(id, substs) => (id, substs),\n+            _ => bug!(\"closure candidate for non-closure {:?}\", obligation),\n+        };\n+\n+        let trait_ref = self.closure_trait_ref_unnormalized(obligation, substs);\n+        let Normalized { value: trait_ref, mut obligations } = ensure_sufficient_stack(|| {\n+            normalize_with_depth(\n+                self,\n+                obligation.param_env,\n+                obligation.cause.clone(),\n+                obligation.recursion_depth + 1,\n+                &trait_ref,\n+            )\n+        });\n+\n+        debug!(\n+            \"confirm_closure_candidate(closure_def_id={:?}, trait_ref={:?}, obligations={:?})\",\n+            closure_def_id, trait_ref, obligations\n+        );\n+\n+        obligations.extend(self.confirm_poly_trait_refs(\n+            obligation.cause.clone(),\n+            obligation.param_env,\n+            obligation.predicate.to_poly_trait_ref(),\n+            trait_ref,\n+        )?);\n+\n+        // FIXME: Chalk\n+\n+        if !self.tcx().sess.opts.debugging_opts.chalk {\n+            obligations.push(Obligation::new(\n+                obligation.cause.clone(),\n+                obligation.param_env,\n+                ty::PredicateKind::ClosureKind(closure_def_id, substs, kind)\n+                    .to_predicate(self.tcx()),\n+            ));\n+        }\n+\n+        Ok(VtableClosureData { closure_def_id, substs, nested: obligations })\n+    }\n+\n+    /// In the case of closure types and fn pointers,\n+    /// we currently treat the input type parameters on the trait as\n+    /// outputs. This means that when we have a match we have only\n+    /// considered the self type, so we have to go back and make sure\n+    /// to relate the argument types too. This is kind of wrong, but\n+    /// since we control the full set of impls, also not that wrong,\n+    /// and it DOES yield better error messages (since we don't report\n+    /// errors as if there is no applicable impl, but rather report\n+    /// errors are about mismatched argument types.\n+    ///\n+    /// Here is an example. Imagine we have a closure expression\n+    /// and we desugared it so that the type of the expression is\n+    /// `Closure`, and `Closure` expects an int as argument. Then it\n+    /// is \"as if\" the compiler generated this impl:\n+    ///\n+    ///     impl Fn(int) for Closure { ... }\n+    ///\n+    /// Now imagine our obligation is `Fn(usize) for Closure`. So far\n+    /// we have matched the self type `Closure`. At this point we'll\n+    /// compare the `int` to `usize` and generate an error.\n+    ///\n+    /// Note that this checking occurs *after* the impl has selected,\n+    /// because these output type parameters should not affect the\n+    /// selection of the impl. Therefore, if there is a mismatch, we\n+    /// report an error to the user.\n+    fn confirm_poly_trait_refs(\n+        &mut self,\n+        obligation_cause: ObligationCause<'tcx>,\n+        obligation_param_env: ty::ParamEnv<'tcx>,\n+        obligation_trait_ref: ty::PolyTraitRef<'tcx>,\n+        expected_trait_ref: ty::PolyTraitRef<'tcx>,\n+    ) -> Result<Vec<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n+        self.infcx\n+            .at(&obligation_cause, obligation_param_env)\n+            .sup(obligation_trait_ref, expected_trait_ref)\n+            .map(|InferOk { obligations, .. }| obligations)\n+            .map_err(|e| OutputTypeParameterMismatch(expected_trait_ref, obligation_trait_ref, e))\n+    }\n+\n+    fn confirm_builtin_unsize_candidate(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+    ) -> Result<VtableBuiltinData<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n+        let tcx = self.tcx();\n+\n+        // `assemble_candidates_for_unsizing` should ensure there are no late-bound\n+        // regions here. See the comment there for more details.\n+        let source = self.infcx.shallow_resolve(obligation.self_ty().no_bound_vars().unwrap());\n+        let target = obligation.predicate.skip_binder().trait_ref.substs.type_at(1);\n+        let target = self.infcx.shallow_resolve(target);\n+\n+        debug!(\"confirm_builtin_unsize_candidate(source={:?}, target={:?})\", source, target);\n+\n+        let mut nested = vec![];\n+        match (&source.kind, &target.kind) {\n+            // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n+            (&ty::Dynamic(ref data_a, r_a), &ty::Dynamic(ref data_b, r_b)) => {\n+                // See `assemble_candidates_for_unsizing` for more info.\n+                let existential_predicates = data_a.map_bound(|data_a| {\n+                    let iter = data_a\n+                        .principal()\n+                        .map(ty::ExistentialPredicate::Trait)\n+                        .into_iter()\n+                        .chain(data_a.projection_bounds().map(ty::ExistentialPredicate::Projection))\n+                        .chain(data_b.auto_traits().map(ty::ExistentialPredicate::AutoTrait));\n+                    tcx.mk_existential_predicates(iter)\n+                });\n+                let source_trait = tcx.mk_dynamic(existential_predicates, r_b);\n+\n+                // Require that the traits involved in this upcast are **equal**;\n+                // only the **lifetime bound** is changed.\n+                //\n+                // FIXME: This condition is arguably too strong -- it would\n+                // suffice for the source trait to be a *subtype* of the target\n+                // trait. In particular, changing from something like\n+                // `for<'a, 'b> Foo<'a, 'b>` to `for<'a> Foo<'a, 'a>` should be\n+                // permitted. And, indeed, in the in commit\n+                // 904a0bde93f0348f69914ee90b1f8b6e4e0d7cbc, this\n+                // condition was loosened. However, when the leak check was\n+                // added back, using subtype here actually guides the coercion\n+                // code in such a way that it accepts `old-lub-glb-object.rs`.\n+                // This is probably a good thing, but I've modified this to `.eq`\n+                // because I want to continue rejecting that test (as we have\n+                // done for quite some time) before we are firmly comfortable\n+                // with what our behavior should be there. -nikomatsakis\n+                let InferOk { obligations, .. } = self\n+                    .infcx\n+                    .at(&obligation.cause, obligation.param_env)\n+                    .eq(target, source_trait) // FIXME -- see below\n+                    .map_err(|_| Unimplemented)?;\n+                nested.extend(obligations);\n+\n+                // Register one obligation for 'a: 'b.\n+                let cause = ObligationCause::new(\n+                    obligation.cause.span,\n+                    obligation.cause.body_id,\n+                    ObjectCastObligation(target),\n+                );\n+                let outlives = ty::OutlivesPredicate(r_a, r_b);\n+                nested.push(Obligation::with_depth(\n+                    cause,\n+                    obligation.recursion_depth + 1,\n+                    obligation.param_env,\n+                    ty::Binder::bind(outlives).to_predicate(tcx),\n+                ));\n+            }\n+\n+            // `T` -> `Trait`\n+            (_, &ty::Dynamic(ref data, r)) => {\n+                let mut object_dids = data.auto_traits().chain(data.principal_def_id());\n+                if let Some(did) = object_dids.find(|did| !tcx.is_object_safe(*did)) {\n+                    return Err(TraitNotObjectSafe(did));\n+                }\n+\n+                let cause = ObligationCause::new(\n+                    obligation.cause.span,\n+                    obligation.cause.body_id,\n+                    ObjectCastObligation(target),\n+                );\n+\n+                let predicate_to_obligation = |predicate| {\n+                    Obligation::with_depth(\n+                        cause.clone(),\n+                        obligation.recursion_depth + 1,\n+                        obligation.param_env,\n+                        predicate,\n+                    )\n+                };\n+\n+                // Create obligations:\n+                //  - Casting `T` to `Trait`\n+                //  - For all the various builtin bounds attached to the object cast. (In other\n+                //  words, if the object type is `Foo + Send`, this would create an obligation for\n+                //  the `Send` check.)\n+                //  - Projection predicates\n+                nested.extend(\n+                    data.iter().map(|predicate| {\n+                        predicate_to_obligation(predicate.with_self_ty(tcx, source))\n+                    }),\n+                );\n+\n+                // We can only make objects from sized types.\n+                let tr = ty::TraitRef::new(\n+                    tcx.require_lang_item(lang_items::SizedTraitLangItem, None),\n+                    tcx.mk_substs_trait(source, &[]),\n+                );\n+                nested.push(predicate_to_obligation(tr.without_const().to_predicate(tcx)));\n+\n+                // If the type is `Foo + 'a`, ensure that the type\n+                // being cast to `Foo + 'a` outlives `'a`:\n+                let outlives = ty::OutlivesPredicate(source, r);\n+                nested.push(predicate_to_obligation(ty::Binder::dummy(outlives).to_predicate(tcx)));\n+            }\n+\n+            // `[T; n]` -> `[T]`\n+            (&ty::Array(a, _), &ty::Slice(b)) => {\n+                let InferOk { obligations, .. } = self\n+                    .infcx\n+                    .at(&obligation.cause, obligation.param_env)\n+                    .eq(b, a)\n+                    .map_err(|_| Unimplemented)?;\n+                nested.extend(obligations);\n+            }\n+\n+            // `Struct<T>` -> `Struct<U>`\n+            (&ty::Adt(def, substs_a), &ty::Adt(_, substs_b)) => {\n+                let maybe_unsizing_param_idx = |arg: GenericArg<'tcx>| match arg.unpack() {\n+                    GenericArgKind::Type(ty) => match ty.kind {\n+                        ty::Param(p) => Some(p.index),\n+                        _ => None,\n+                    },\n+\n+                    // Lifetimes aren't allowed to change during unsizing.\n+                    GenericArgKind::Lifetime(_) => None,\n+\n+                    GenericArgKind::Const(ct) => match ct.val {\n+                        ty::ConstKind::Param(p) => Some(p.index),\n+                        _ => None,\n+                    },\n+                };\n+\n+                // The last field of the structure has to exist and contain type/const parameters.\n+                let (tail_field, prefix_fields) =\n+                    def.non_enum_variant().fields.split_last().ok_or(Unimplemented)?;\n+                let tail_field_ty = tcx.type_of(tail_field.did);\n+\n+                let mut unsizing_params = GrowableBitSet::new_empty();\n+                let mut found = false;\n+                for arg in tail_field_ty.walk() {\n+                    if let Some(i) = maybe_unsizing_param_idx(arg) {\n+                        unsizing_params.insert(i);\n+                        found = true;\n+                    }\n+                }\n+                if !found {\n+                    return Err(Unimplemented);\n+                }\n+\n+                // Ensure none of the other fields mention the parameters used\n+                // in unsizing.\n+                // FIXME(eddyb) cache this (including computing `unsizing_params`)\n+                // by putting it in a query; it would only need the `DefId` as it\n+                // looks at declared field types, not anything substituted.\n+                for field in prefix_fields {\n+                    for arg in tcx.type_of(field.did).walk() {\n+                        if let Some(i) = maybe_unsizing_param_idx(arg) {\n+                            if unsizing_params.contains(i) {\n+                                return Err(Unimplemented);\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // Extract `TailField<T>` and `TailField<U>` from `Struct<T>` and `Struct<U>`.\n+                let source_tail = tail_field_ty.subst(tcx, substs_a);\n+                let target_tail = tail_field_ty.subst(tcx, substs_b);\n+\n+                // Check that the source struct with the target's\n+                // unsizing parameters is equal to the target.\n+                let substs = tcx.mk_substs(substs_a.iter().enumerate().map(|(i, k)| {\n+                    if unsizing_params.contains(i as u32) { substs_b[i] } else { k }\n+                }));\n+                let new_struct = tcx.mk_adt(def, substs);\n+                let InferOk { obligations, .. } = self\n+                    .infcx\n+                    .at(&obligation.cause, obligation.param_env)\n+                    .eq(target, new_struct)\n+                    .map_err(|_| Unimplemented)?;\n+                nested.extend(obligations);\n+\n+                // Construct the nested `TailField<T>: Unsize<TailField<U>>` predicate.\n+                nested.push(predicate_for_trait_def(\n+                    tcx,\n+                    obligation.param_env,\n+                    obligation.cause.clone(),\n+                    obligation.predicate.def_id(),\n+                    obligation.recursion_depth + 1,\n+                    source_tail,\n+                    &[target_tail.into()],\n+                ));\n+            }\n+\n+            // `(.., T)` -> `(.., U)`\n+            (&ty::Tuple(tys_a), &ty::Tuple(tys_b)) => {\n+                assert_eq!(tys_a.len(), tys_b.len());\n+\n+                // The last field of the tuple has to exist.\n+                let (&a_last, a_mid) = tys_a.split_last().ok_or(Unimplemented)?;\n+                let &b_last = tys_b.last().unwrap();\n+\n+                // Check that the source tuple with the target's\n+                // last element is equal to the target.\n+                let new_tuple = tcx.mk_tup(\n+                    a_mid.iter().map(|k| k.expect_ty()).chain(iter::once(b_last.expect_ty())),\n+                );\n+                let InferOk { obligations, .. } = self\n+                    .infcx\n+                    .at(&obligation.cause, obligation.param_env)\n+                    .eq(target, new_tuple)\n+                    .map_err(|_| Unimplemented)?;\n+                nested.extend(obligations);\n+\n+                // Construct the nested `T: Unsize<U>` predicate.\n+                nested.push(ensure_sufficient_stack(|| {\n+                    predicate_for_trait_def(\n+                        tcx,\n+                        obligation.param_env,\n+                        obligation.cause.clone(),\n+                        obligation.predicate.def_id(),\n+                        obligation.recursion_depth + 1,\n+                        a_last.expect_ty(),\n+                        &[b_last],\n+                    )\n+                }));\n+            }\n+\n+            _ => bug!(),\n+        };\n+\n+        Ok(VtableBuiltinData { nested })\n+    }\n+}"}, {"sha": "ef123318d7e81d80c825e1a274c6f876deb5377b", "filename": "src/librustc_trait_selection/traits/select/mod.rs", "status": "modified", "additions": 7, "deletions": 804, "changes": 811, "blob_url": "https://github.com/rust-lang/rust/blob/bf5c62da9ecd12fbbd255731add216bf90d3239a/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf5c62da9ecd12fbbd255731add216bf90d3239a/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs?ref=bf5c62da9ecd12fbbd255731add216bf90d3239a", "patch": "@@ -9,29 +9,19 @@ use self::SelectionCandidate::*;\n \n use super::coherence::{self, Conflict};\n use super::project;\n-use super::project::{normalize_with_depth, normalize_with_depth_to};\n+use super::project::normalize_with_depth_to;\n use super::util;\n use super::util::{closure_trait_ref_and_return_type, predicate_for_trait_def};\n use super::wf;\n use super::DerivedObligationCause;\n+use super::Obligation;\n+use super::ObligationCauseCode;\n use super::Selection;\n use super::SelectionResult;\n-use super::TraitNotObjectSafe;\n use super::TraitQueryMode;\n-use super::{BuiltinDerivedObligation, ImplDerivedObligation, ObligationCauseCode};\n use super::{Normalized, ProjectionCacheKey};\n-use super::{ObjectCastObligation, Obligation};\n use super::{ObligationCause, PredicateObligation, TraitObligation};\n-use super::{OutputTypeParameterMismatch, Overflow, SelectionError, Unimplemented};\n-use super::{\n-    VtableAutoImpl, VtableBuiltin, VtableClosure, VtableDiscriminantKind, VtableFnPointer,\n-    VtableGenerator, VtableImpl, VtableObject, VtableParam, VtableTraitAlias,\n-};\n-use super::{\n-    VtableAutoImplData, VtableBuiltinData, VtableClosureData, VtableDiscriminantKindData,\n-    VtableFnPointerData, VtableGeneratorData, VtableImplData, VtableObjectData,\n-    VtableTraitAliasData,\n-};\n+use super::{Overflow, SelectionError, Unimplemented};\n \n use crate::infer::{CombinedSnapshot, InferCtxt, InferOk, PlaceholderMap, TypeFreshener};\n use crate::traits::error_reporting::InferCtxtExt;\n@@ -42,16 +32,12 @@ use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::lang_items;\n-use rustc_index::bit_set::GrowableBitSet;\n use rustc_middle::dep_graph::{DepKind, DepNodeIndex};\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::fast_reject;\n use rustc_middle::ty::relate::TypeRelation;\n-use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst, SubstsRef};\n-use rustc_middle::ty::{\n-    self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n-};\n+use rustc_middle::ty::subst::{GenericArgKind, Subst, SubstsRef};\n+use rustc_middle::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable};\n use rustc_span::symbol::sym;\n \n use std::cell::{Cell, RefCell};\n@@ -63,6 +49,7 @@ use std::rc::Rc;\n pub use rustc_middle::traits::select::*;\n \n mod candidate_assembly;\n+mod confirmation;\n \n pub struct SelectionContext<'cx, 'tcx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n@@ -1808,790 +1795,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .collect()\n     }\n \n-    ///////////////////////////////////////////////////////////////////////////\n-    // CONFIRMATION\n-    //\n-    // Confirmation unifies the output type parameters of the trait\n-    // with the values found in the obligation, possibly yielding a\n-    // type error.  See the [rustc dev guide] for more details.\n-    //\n-    // [rustc dev guide]:\n-    // https://rustc-dev-guide.rust-lang.org/traits/resolution.html#confirmation\n-\n-    fn confirm_candidate(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-        candidate: SelectionCandidate<'tcx>,\n-    ) -> Result<Selection<'tcx>, SelectionError<'tcx>> {\n-        debug!(\"confirm_candidate({:?}, {:?})\", obligation, candidate);\n-\n-        match candidate {\n-            BuiltinCandidate { has_nested } => {\n-                let data = self.confirm_builtin_candidate(obligation, has_nested);\n-                Ok(VtableBuiltin(data))\n-            }\n-\n-            ParamCandidate(param) => {\n-                let obligations = self.confirm_param_candidate(obligation, param);\n-                Ok(VtableParam(obligations))\n-            }\n-\n-            ImplCandidate(impl_def_id) => {\n-                Ok(VtableImpl(self.confirm_impl_candidate(obligation, impl_def_id)))\n-            }\n-\n-            AutoImplCandidate(trait_def_id) => {\n-                let data = self.confirm_auto_impl_candidate(obligation, trait_def_id);\n-                Ok(VtableAutoImpl(data))\n-            }\n-\n-            ProjectionCandidate => {\n-                self.confirm_projection_candidate(obligation);\n-                Ok(VtableParam(Vec::new()))\n-            }\n-\n-            ClosureCandidate => {\n-                let vtable_closure = self.confirm_closure_candidate(obligation)?;\n-                Ok(VtableClosure(vtable_closure))\n-            }\n-\n-            GeneratorCandidate => {\n-                let vtable_generator = self.confirm_generator_candidate(obligation)?;\n-                Ok(VtableGenerator(vtable_generator))\n-            }\n-\n-            FnPointerCandidate => {\n-                let data = self.confirm_fn_pointer_candidate(obligation)?;\n-                Ok(VtableFnPointer(data))\n-            }\n-\n-            DiscriminantKindCandidate => Ok(VtableDiscriminantKind(VtableDiscriminantKindData)),\n-\n-            TraitAliasCandidate(alias_def_id) => {\n-                let data = self.confirm_trait_alias_candidate(obligation, alias_def_id);\n-                Ok(VtableTraitAlias(data))\n-            }\n-\n-            ObjectCandidate => {\n-                let data = self.confirm_object_candidate(obligation);\n-                Ok(VtableObject(data))\n-            }\n-\n-            BuiltinObjectCandidate => {\n-                // This indicates something like `Trait + Send: Send`. In this case, we know that\n-                // this holds because that's what the object type is telling us, and there's really\n-                // no additional obligations to prove and no types in particular to unify, etc.\n-                Ok(VtableParam(Vec::new()))\n-            }\n-\n-            BuiltinUnsizeCandidate => {\n-                let data = self.confirm_builtin_unsize_candidate(obligation)?;\n-                Ok(VtableBuiltin(data))\n-            }\n-        }\n-    }\n-\n-    fn confirm_projection_candidate(&mut self, obligation: &TraitObligation<'tcx>) {\n-        self.infcx.commit_unconditionally(|snapshot| {\n-            let result =\n-                self.match_projection_obligation_against_definition_bounds(obligation, snapshot);\n-            assert!(result);\n-        })\n-    }\n-\n-    fn confirm_param_candidate(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-        param: ty::PolyTraitRef<'tcx>,\n-    ) -> Vec<PredicateObligation<'tcx>> {\n-        debug!(\"confirm_param_candidate({:?},{:?})\", obligation, param);\n-\n-        // During evaluation, we already checked that this\n-        // where-clause trait-ref could be unified with the obligation\n-        // trait-ref. Repeat that unification now without any\n-        // transactional boundary; it should not fail.\n-        match self.match_where_clause_trait_ref(obligation, param) {\n-            Ok(obligations) => obligations,\n-            Err(()) => {\n-                bug!(\n-                    \"Where clause `{:?}` was applicable to `{:?}` but now is not\",\n-                    param,\n-                    obligation\n-                );\n-            }\n-        }\n-    }\n-\n-    fn confirm_builtin_candidate(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-        has_nested: bool,\n-    ) -> VtableBuiltinData<PredicateObligation<'tcx>> {\n-        debug!(\"confirm_builtin_candidate({:?}, {:?})\", obligation, has_nested);\n-\n-        let lang_items = self.tcx().lang_items();\n-        let obligations = if has_nested {\n-            let trait_def = obligation.predicate.def_id();\n-            let conditions = if Some(trait_def) == lang_items.sized_trait() {\n-                self.sized_conditions(obligation)\n-            } else if Some(trait_def) == lang_items.copy_trait() {\n-                self.copy_clone_conditions(obligation)\n-            } else if Some(trait_def) == lang_items.clone_trait() {\n-                self.copy_clone_conditions(obligation)\n-            } else {\n-                bug!(\"unexpected builtin trait {:?}\", trait_def)\n-            };\n-            let nested = match conditions {\n-                BuiltinImplConditions::Where(nested) => nested,\n-                _ => bug!(\"obligation {:?} had matched a builtin impl but now doesn't\", obligation),\n-            };\n-\n-            let cause = obligation.derived_cause(BuiltinDerivedObligation);\n-            ensure_sufficient_stack(|| {\n-                self.collect_predicates_for_types(\n-                    obligation.param_env,\n-                    cause,\n-                    obligation.recursion_depth + 1,\n-                    trait_def,\n-                    nested,\n-                )\n-            })\n-        } else {\n-            vec![]\n-        };\n-\n-        debug!(\"confirm_builtin_candidate: obligations={:?}\", obligations);\n-\n-        VtableBuiltinData { nested: obligations }\n-    }\n-\n-    /// This handles the case where a `auto trait Foo` impl is being used.\n-    /// The idea is that the impl applies to `X : Foo` if the following conditions are met:\n-    ///\n-    /// 1. For each constituent type `Y` in `X`, `Y : Foo` holds\n-    /// 2. For each where-clause `C` declared on `Foo`, `[Self => X] C` holds.\n-    fn confirm_auto_impl_candidate(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-        trait_def_id: DefId,\n-    ) -> VtableAutoImplData<PredicateObligation<'tcx>> {\n-        debug!(\"confirm_auto_impl_candidate({:?}, {:?})\", obligation, trait_def_id);\n-\n-        let types = obligation.predicate.map_bound(|inner| {\n-            let self_ty = self.infcx.shallow_resolve(inner.self_ty());\n-            self.constituent_types_for_ty(self_ty)\n-        });\n-        self.vtable_auto_impl(obligation, trait_def_id, types)\n-    }\n-\n-    /// See `confirm_auto_impl_candidate`.\n-    fn vtable_auto_impl(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-        trait_def_id: DefId,\n-        nested: ty::Binder<Vec<Ty<'tcx>>>,\n-    ) -> VtableAutoImplData<PredicateObligation<'tcx>> {\n-        debug!(\"vtable_auto_impl: nested={:?}\", nested);\n-        ensure_sufficient_stack(|| {\n-            let cause = obligation.derived_cause(BuiltinDerivedObligation);\n-            let mut obligations = self.collect_predicates_for_types(\n-                obligation.param_env,\n-                cause,\n-                obligation.recursion_depth + 1,\n-                trait_def_id,\n-                nested,\n-            );\n-\n-            let trait_obligations: Vec<PredicateObligation<'_>> =\n-                self.infcx.commit_unconditionally(|_| {\n-                    let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n-                    let (trait_ref, _) =\n-                        self.infcx.replace_bound_vars_with_placeholders(&poly_trait_ref);\n-                    let cause = obligation.derived_cause(ImplDerivedObligation);\n-                    self.impl_or_trait_obligations(\n-                        cause,\n-                        obligation.recursion_depth + 1,\n-                        obligation.param_env,\n-                        trait_def_id,\n-                        &trait_ref.substs,\n-                    )\n-                });\n-\n-            // Adds the predicates from the trait.  Note that this contains a `Self: Trait`\n-            // predicate as usual.  It won't have any effect since auto traits are coinductive.\n-            obligations.extend(trait_obligations);\n-\n-            debug!(\"vtable_auto_impl: obligations={:?}\", obligations);\n-\n-            VtableAutoImplData { trait_def_id, nested: obligations }\n-        })\n-    }\n-\n-    fn confirm_impl_candidate(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-        impl_def_id: DefId,\n-    ) -> VtableImplData<'tcx, PredicateObligation<'tcx>> {\n-        debug!(\"confirm_impl_candidate({:?},{:?})\", obligation, impl_def_id);\n-\n-        // First, create the substitutions by matching the impl again,\n-        // this time not in a probe.\n-        self.infcx.commit_unconditionally(|snapshot| {\n-            let substs = self.rematch_impl(impl_def_id, obligation, snapshot);\n-            debug!(\"confirm_impl_candidate: substs={:?}\", substs);\n-            let cause = obligation.derived_cause(ImplDerivedObligation);\n-            ensure_sufficient_stack(|| {\n-                self.vtable_impl(\n-                    impl_def_id,\n-                    substs,\n-                    cause,\n-                    obligation.recursion_depth + 1,\n-                    obligation.param_env,\n-                )\n-            })\n-        })\n-    }\n-\n-    fn vtable_impl(\n-        &mut self,\n-        impl_def_id: DefId,\n-        mut substs: Normalized<'tcx, SubstsRef<'tcx>>,\n-        cause: ObligationCause<'tcx>,\n-        recursion_depth: usize,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) -> VtableImplData<'tcx, PredicateObligation<'tcx>> {\n-        debug!(\n-            \"vtable_impl(impl_def_id={:?}, substs={:?}, recursion_depth={})\",\n-            impl_def_id, substs, recursion_depth,\n-        );\n-\n-        let mut impl_obligations = self.impl_or_trait_obligations(\n-            cause,\n-            recursion_depth,\n-            param_env,\n-            impl_def_id,\n-            &substs.value,\n-        );\n-\n-        debug!(\n-            \"vtable_impl: impl_def_id={:?} impl_obligations={:?}\",\n-            impl_def_id, impl_obligations\n-        );\n-\n-        // Because of RFC447, the impl-trait-ref and obligations\n-        // are sufficient to determine the impl substs, without\n-        // relying on projections in the impl-trait-ref.\n-        //\n-        // e.g., `impl<U: Tr, V: Iterator<Item=U>> Foo<<U as Tr>::T> for V`\n-        impl_obligations.append(&mut substs.obligations);\n-\n-        VtableImplData { impl_def_id, substs: substs.value, nested: impl_obligations }\n-    }\n-\n-    fn confirm_object_candidate(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-    ) -> VtableObjectData<'tcx, PredicateObligation<'tcx>> {\n-        debug!(\"confirm_object_candidate({:?})\", obligation);\n-\n-        // FIXME(nmatsakis) skipping binder here seems wrong -- we should\n-        // probably flatten the binder from the obligation and the binder\n-        // from the object. Have to try to make a broken test case that\n-        // results.\n-        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n-        let poly_trait_ref = match self_ty.kind {\n-            ty::Dynamic(ref data, ..) => data\n-                .principal()\n-                .unwrap_or_else(|| {\n-                    span_bug!(obligation.cause.span, \"object candidate with no principal\")\n-                })\n-                .with_self_ty(self.tcx(), self_ty),\n-            _ => span_bug!(obligation.cause.span, \"object candidate with non-object\"),\n-        };\n-\n-        let mut upcast_trait_ref = None;\n-        let mut nested = vec![];\n-        let vtable_base;\n-\n-        {\n-            let tcx = self.tcx();\n-\n-            // We want to find the first supertrait in the list of\n-            // supertraits that we can unify with, and do that\n-            // unification. We know that there is exactly one in the list\n-            // where we can unify, because otherwise select would have\n-            // reported an ambiguity. (When we do find a match, also\n-            // record it for later.)\n-            let nonmatching = util::supertraits(tcx, poly_trait_ref).take_while(|&t| {\n-                match self.infcx.commit_if_ok(|_| self.match_poly_trait_ref(obligation, t)) {\n-                    Ok(obligations) => {\n-                        upcast_trait_ref = Some(t);\n-                        nested.extend(obligations);\n-                        false\n-                    }\n-                    Err(_) => true,\n-                }\n-            });\n-\n-            // Additionally, for each of the non-matching predicates that\n-            // we pass over, we sum up the set of number of vtable\n-            // entries, so that we can compute the offset for the selected\n-            // trait.\n-            vtable_base = nonmatching.map(|t| super::util::count_own_vtable_entries(tcx, t)).sum();\n-        }\n-\n-        VtableObjectData { upcast_trait_ref: upcast_trait_ref.unwrap(), vtable_base, nested }\n-    }\n-\n-    fn confirm_fn_pointer_candidate(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-    ) -> Result<VtableFnPointerData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n-        debug!(\"confirm_fn_pointer_candidate({:?})\", obligation);\n-\n-        // Okay to skip binder; it is reintroduced below.\n-        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n-        let sig = self_ty.fn_sig(self.tcx());\n-        let trait_ref = closure_trait_ref_and_return_type(\n-            self.tcx(),\n-            obligation.predicate.def_id(),\n-            self_ty,\n-            sig,\n-            util::TupleArgumentsFlag::Yes,\n-        )\n-        .map_bound(|(trait_ref, _)| trait_ref);\n-\n-        let Normalized { value: trait_ref, obligations } = ensure_sufficient_stack(|| {\n-            project::normalize_with_depth(\n-                self,\n-                obligation.param_env,\n-                obligation.cause.clone(),\n-                obligation.recursion_depth + 1,\n-                &trait_ref,\n-            )\n-        });\n-\n-        self.confirm_poly_trait_refs(\n-            obligation.cause.clone(),\n-            obligation.param_env,\n-            obligation.predicate.to_poly_trait_ref(),\n-            trait_ref,\n-        )?;\n-        Ok(VtableFnPointerData { fn_ty: self_ty, nested: obligations })\n-    }\n-\n-    fn confirm_trait_alias_candidate(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-        alias_def_id: DefId,\n-    ) -> VtableTraitAliasData<'tcx, PredicateObligation<'tcx>> {\n-        debug!(\"confirm_trait_alias_candidate({:?}, {:?})\", obligation, alias_def_id);\n-\n-        self.infcx.commit_unconditionally(|_| {\n-            let (predicate, _) =\n-                self.infcx().replace_bound_vars_with_placeholders(&obligation.predicate);\n-            let trait_ref = predicate.trait_ref;\n-            let trait_def_id = trait_ref.def_id;\n-            let substs = trait_ref.substs;\n-\n-            let trait_obligations = self.impl_or_trait_obligations(\n-                obligation.cause.clone(),\n-                obligation.recursion_depth,\n-                obligation.param_env,\n-                trait_def_id,\n-                &substs,\n-            );\n-\n-            debug!(\n-                \"confirm_trait_alias_candidate: trait_def_id={:?} trait_obligations={:?}\",\n-                trait_def_id, trait_obligations\n-            );\n-\n-            VtableTraitAliasData { alias_def_id, substs, nested: trait_obligations }\n-        })\n-    }\n-\n-    fn confirm_generator_candidate(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-    ) -> Result<VtableGeneratorData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n-        // Okay to skip binder because the substs on generator types never\n-        // touch bound regions, they just capture the in-scope\n-        // type/region parameters.\n-        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n-        let (generator_def_id, substs) = match self_ty.kind {\n-            ty::Generator(id, substs, _) => (id, substs),\n-            _ => bug!(\"closure candidate for non-closure {:?}\", obligation),\n-        };\n-\n-        debug!(\"confirm_generator_candidate({:?},{:?},{:?})\", obligation, generator_def_id, substs);\n-\n-        let trait_ref = self.generator_trait_ref_unnormalized(obligation, substs);\n-        let Normalized { value: trait_ref, mut obligations } = ensure_sufficient_stack(|| {\n-            normalize_with_depth(\n-                self,\n-                obligation.param_env,\n-                obligation.cause.clone(),\n-                obligation.recursion_depth + 1,\n-                &trait_ref,\n-            )\n-        });\n-\n-        debug!(\n-            \"confirm_generator_candidate(generator_def_id={:?}, \\\n-             trait_ref={:?}, obligations={:?})\",\n-            generator_def_id, trait_ref, obligations\n-        );\n-\n-        obligations.extend(self.confirm_poly_trait_refs(\n-            obligation.cause.clone(),\n-            obligation.param_env,\n-            obligation.predicate.to_poly_trait_ref(),\n-            trait_ref,\n-        )?);\n-\n-        Ok(VtableGeneratorData { generator_def_id, substs, nested: obligations })\n-    }\n-\n-    fn confirm_closure_candidate(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-    ) -> Result<VtableClosureData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n-        debug!(\"confirm_closure_candidate({:?})\", obligation);\n-\n-        let kind = self\n-            .tcx()\n-            .fn_trait_kind_from_lang_item(obligation.predicate.def_id())\n-            .unwrap_or_else(|| bug!(\"closure candidate for non-fn trait {:?}\", obligation));\n-\n-        // Okay to skip binder because the substs on closure types never\n-        // touch bound regions, they just capture the in-scope\n-        // type/region parameters.\n-        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n-        let (closure_def_id, substs) = match self_ty.kind {\n-            ty::Closure(id, substs) => (id, substs),\n-            _ => bug!(\"closure candidate for non-closure {:?}\", obligation),\n-        };\n-\n-        let trait_ref = self.closure_trait_ref_unnormalized(obligation, substs);\n-        let Normalized { value: trait_ref, mut obligations } = ensure_sufficient_stack(|| {\n-            normalize_with_depth(\n-                self,\n-                obligation.param_env,\n-                obligation.cause.clone(),\n-                obligation.recursion_depth + 1,\n-                &trait_ref,\n-            )\n-        });\n-\n-        debug!(\n-            \"confirm_closure_candidate(closure_def_id={:?}, trait_ref={:?}, obligations={:?})\",\n-            closure_def_id, trait_ref, obligations\n-        );\n-\n-        obligations.extend(self.confirm_poly_trait_refs(\n-            obligation.cause.clone(),\n-            obligation.param_env,\n-            obligation.predicate.to_poly_trait_ref(),\n-            trait_ref,\n-        )?);\n-\n-        // FIXME: Chalk\n-\n-        if !self.tcx().sess.opts.debugging_opts.chalk {\n-            obligations.push(Obligation::new(\n-                obligation.cause.clone(),\n-                obligation.param_env,\n-                ty::PredicateKind::ClosureKind(closure_def_id, substs, kind)\n-                    .to_predicate(self.tcx()),\n-            ));\n-        }\n-\n-        Ok(VtableClosureData { closure_def_id, substs, nested: obligations })\n-    }\n-\n-    /// In the case of closure types and fn pointers,\n-    /// we currently treat the input type parameters on the trait as\n-    /// outputs. This means that when we have a match we have only\n-    /// considered the self type, so we have to go back and make sure\n-    /// to relate the argument types too. This is kind of wrong, but\n-    /// since we control the full set of impls, also not that wrong,\n-    /// and it DOES yield better error messages (since we don't report\n-    /// errors as if there is no applicable impl, but rather report\n-    /// errors are about mismatched argument types.\n-    ///\n-    /// Here is an example. Imagine we have a closure expression\n-    /// and we desugared it so that the type of the expression is\n-    /// `Closure`, and `Closure` expects an int as argument. Then it\n-    /// is \"as if\" the compiler generated this impl:\n-    ///\n-    ///     impl Fn(int) for Closure { ... }\n-    ///\n-    /// Now imagine our obligation is `Fn(usize) for Closure`. So far\n-    /// we have matched the self type `Closure`. At this point we'll\n-    /// compare the `int` to `usize` and generate an error.\n-    ///\n-    /// Note that this checking occurs *after* the impl has selected,\n-    /// because these output type parameters should not affect the\n-    /// selection of the impl. Therefore, if there is a mismatch, we\n-    /// report an error to the user.\n-    fn confirm_poly_trait_refs(\n-        &mut self,\n-        obligation_cause: ObligationCause<'tcx>,\n-        obligation_param_env: ty::ParamEnv<'tcx>,\n-        obligation_trait_ref: ty::PolyTraitRef<'tcx>,\n-        expected_trait_ref: ty::PolyTraitRef<'tcx>,\n-    ) -> Result<Vec<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n-        self.infcx\n-            .at(&obligation_cause, obligation_param_env)\n-            .sup(obligation_trait_ref, expected_trait_ref)\n-            .map(|InferOk { obligations, .. }| obligations)\n-            .map_err(|e| OutputTypeParameterMismatch(expected_trait_ref, obligation_trait_ref, e))\n-    }\n-\n-    fn confirm_builtin_unsize_candidate(\n-        &mut self,\n-        obligation: &TraitObligation<'tcx>,\n-    ) -> Result<VtableBuiltinData<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n-        let tcx = self.tcx();\n-\n-        // `assemble_candidates_for_unsizing` should ensure there are no late-bound\n-        // regions here. See the comment there for more details.\n-        let source = self.infcx.shallow_resolve(obligation.self_ty().no_bound_vars().unwrap());\n-        let target = obligation.predicate.skip_binder().trait_ref.substs.type_at(1);\n-        let target = self.infcx.shallow_resolve(target);\n-\n-        debug!(\"confirm_builtin_unsize_candidate(source={:?}, target={:?})\", source, target);\n-\n-        let mut nested = vec![];\n-        match (&source.kind, &target.kind) {\n-            // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n-            (&ty::Dynamic(ref data_a, r_a), &ty::Dynamic(ref data_b, r_b)) => {\n-                // See `assemble_candidates_for_unsizing` for more info.\n-                let existential_predicates = data_a.map_bound(|data_a| {\n-                    let iter = data_a\n-                        .principal()\n-                        .map(ty::ExistentialPredicate::Trait)\n-                        .into_iter()\n-                        .chain(data_a.projection_bounds().map(ty::ExistentialPredicate::Projection))\n-                        .chain(data_b.auto_traits().map(ty::ExistentialPredicate::AutoTrait));\n-                    tcx.mk_existential_predicates(iter)\n-                });\n-                let source_trait = tcx.mk_dynamic(existential_predicates, r_b);\n-\n-                // Require that the traits involved in this upcast are **equal**;\n-                // only the **lifetime bound** is changed.\n-                //\n-                // FIXME: This condition is arguably too strong -- it would\n-                // suffice for the source trait to be a *subtype* of the target\n-                // trait. In particular, changing from something like\n-                // `for<'a, 'b> Foo<'a, 'b>` to `for<'a> Foo<'a, 'a>` should be\n-                // permitted. And, indeed, in the in commit\n-                // 904a0bde93f0348f69914ee90b1f8b6e4e0d7cbc, this\n-                // condition was loosened. However, when the leak check was\n-                // added back, using subtype here actually guides the coercion\n-                // code in such a way that it accepts `old-lub-glb-object.rs`.\n-                // This is probably a good thing, but I've modified this to `.eq`\n-                // because I want to continue rejecting that test (as we have\n-                // done for quite some time) before we are firmly comfortable\n-                // with what our behavior should be there. -nikomatsakis\n-                let InferOk { obligations, .. } = self\n-                    .infcx\n-                    .at(&obligation.cause, obligation.param_env)\n-                    .eq(target, source_trait) // FIXME -- see below\n-                    .map_err(|_| Unimplemented)?;\n-                nested.extend(obligations);\n-\n-                // Register one obligation for 'a: 'b.\n-                let cause = ObligationCause::new(\n-                    obligation.cause.span,\n-                    obligation.cause.body_id,\n-                    ObjectCastObligation(target),\n-                );\n-                let outlives = ty::OutlivesPredicate(r_a, r_b);\n-                nested.push(Obligation::with_depth(\n-                    cause,\n-                    obligation.recursion_depth + 1,\n-                    obligation.param_env,\n-                    ty::Binder::bind(outlives).to_predicate(tcx),\n-                ));\n-            }\n-\n-            // `T` -> `Trait`\n-            (_, &ty::Dynamic(ref data, r)) => {\n-                let mut object_dids = data.auto_traits().chain(data.principal_def_id());\n-                if let Some(did) = object_dids.find(|did| !tcx.is_object_safe(*did)) {\n-                    return Err(TraitNotObjectSafe(did));\n-                }\n-\n-                let cause = ObligationCause::new(\n-                    obligation.cause.span,\n-                    obligation.cause.body_id,\n-                    ObjectCastObligation(target),\n-                );\n-\n-                let predicate_to_obligation = |predicate| {\n-                    Obligation::with_depth(\n-                        cause.clone(),\n-                        obligation.recursion_depth + 1,\n-                        obligation.param_env,\n-                        predicate,\n-                    )\n-                };\n-\n-                // Create obligations:\n-                //  - Casting `T` to `Trait`\n-                //  - For all the various builtin bounds attached to the object cast. (In other\n-                //  words, if the object type is `Foo + Send`, this would create an obligation for\n-                //  the `Send` check.)\n-                //  - Projection predicates\n-                nested.extend(\n-                    data.iter().map(|predicate| {\n-                        predicate_to_obligation(predicate.with_self_ty(tcx, source))\n-                    }),\n-                );\n-\n-                // We can only make objects from sized types.\n-                let tr = ty::TraitRef::new(\n-                    tcx.require_lang_item(lang_items::SizedTraitLangItem, None),\n-                    tcx.mk_substs_trait(source, &[]),\n-                );\n-                nested.push(predicate_to_obligation(tr.without_const().to_predicate(tcx)));\n-\n-                // If the type is `Foo + 'a`, ensure that the type\n-                // being cast to `Foo + 'a` outlives `'a`:\n-                let outlives = ty::OutlivesPredicate(source, r);\n-                nested.push(predicate_to_obligation(ty::Binder::dummy(outlives).to_predicate(tcx)));\n-            }\n-\n-            // `[T; n]` -> `[T]`\n-            (&ty::Array(a, _), &ty::Slice(b)) => {\n-                let InferOk { obligations, .. } = self\n-                    .infcx\n-                    .at(&obligation.cause, obligation.param_env)\n-                    .eq(b, a)\n-                    .map_err(|_| Unimplemented)?;\n-                nested.extend(obligations);\n-            }\n-\n-            // `Struct<T>` -> `Struct<U>`\n-            (&ty::Adt(def, substs_a), &ty::Adt(_, substs_b)) => {\n-                let maybe_unsizing_param_idx = |arg: GenericArg<'tcx>| match arg.unpack() {\n-                    GenericArgKind::Type(ty) => match ty.kind {\n-                        ty::Param(p) => Some(p.index),\n-                        _ => None,\n-                    },\n-\n-                    // Lifetimes aren't allowed to change during unsizing.\n-                    GenericArgKind::Lifetime(_) => None,\n-\n-                    GenericArgKind::Const(ct) => match ct.val {\n-                        ty::ConstKind::Param(p) => Some(p.index),\n-                        _ => None,\n-                    },\n-                };\n-\n-                // The last field of the structure has to exist and contain type/const parameters.\n-                let (tail_field, prefix_fields) =\n-                    def.non_enum_variant().fields.split_last().ok_or(Unimplemented)?;\n-                let tail_field_ty = tcx.type_of(tail_field.did);\n-\n-                let mut unsizing_params = GrowableBitSet::new_empty();\n-                let mut found = false;\n-                for arg in tail_field_ty.walk() {\n-                    if let Some(i) = maybe_unsizing_param_idx(arg) {\n-                        unsizing_params.insert(i);\n-                        found = true;\n-                    }\n-                }\n-                if !found {\n-                    return Err(Unimplemented);\n-                }\n-\n-                // Ensure none of the other fields mention the parameters used\n-                // in unsizing.\n-                // FIXME(eddyb) cache this (including computing `unsizing_params`)\n-                // by putting it in a query; it would only need the `DefId` as it\n-                // looks at declared field types, not anything substituted.\n-                for field in prefix_fields {\n-                    for arg in tcx.type_of(field.did).walk() {\n-                        if let Some(i) = maybe_unsizing_param_idx(arg) {\n-                            if unsizing_params.contains(i) {\n-                                return Err(Unimplemented);\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                // Extract `TailField<T>` and `TailField<U>` from `Struct<T>` and `Struct<U>`.\n-                let source_tail = tail_field_ty.subst(tcx, substs_a);\n-                let target_tail = tail_field_ty.subst(tcx, substs_b);\n-\n-                // Check that the source struct with the target's\n-                // unsizing parameters is equal to the target.\n-                let substs = tcx.mk_substs(substs_a.iter().enumerate().map(|(i, k)| {\n-                    if unsizing_params.contains(i as u32) { substs_b[i] } else { k }\n-                }));\n-                let new_struct = tcx.mk_adt(def, substs);\n-                let InferOk { obligations, .. } = self\n-                    .infcx\n-                    .at(&obligation.cause, obligation.param_env)\n-                    .eq(target, new_struct)\n-                    .map_err(|_| Unimplemented)?;\n-                nested.extend(obligations);\n-\n-                // Construct the nested `TailField<T>: Unsize<TailField<U>>` predicate.\n-                nested.push(predicate_for_trait_def(\n-                    tcx,\n-                    obligation.param_env,\n-                    obligation.cause.clone(),\n-                    obligation.predicate.def_id(),\n-                    obligation.recursion_depth + 1,\n-                    source_tail,\n-                    &[target_tail.into()],\n-                ));\n-            }\n-\n-            // `(.., T)` -> `(.., U)`\n-            (&ty::Tuple(tys_a), &ty::Tuple(tys_b)) => {\n-                assert_eq!(tys_a.len(), tys_b.len());\n-\n-                // The last field of the tuple has to exist.\n-                let (&a_last, a_mid) = tys_a.split_last().ok_or(Unimplemented)?;\n-                let &b_last = tys_b.last().unwrap();\n-\n-                // Check that the source tuple with the target's\n-                // last element is equal to the target.\n-                let new_tuple = tcx.mk_tup(\n-                    a_mid.iter().map(|k| k.expect_ty()).chain(iter::once(b_last.expect_ty())),\n-                );\n-                let InferOk { obligations, .. } = self\n-                    .infcx\n-                    .at(&obligation.cause, obligation.param_env)\n-                    .eq(target, new_tuple)\n-                    .map_err(|_| Unimplemented)?;\n-                nested.extend(obligations);\n-\n-                // Construct the nested `T: Unsize<U>` predicate.\n-                nested.push(ensure_sufficient_stack(|| {\n-                    predicate_for_trait_def(\n-                        tcx,\n-                        obligation.param_env,\n-                        obligation.cause.clone(),\n-                        obligation.predicate.def_id(),\n-                        obligation.recursion_depth + 1,\n-                        a_last.expect_ty(),\n-                        &[b_last],\n-                    )\n-                }));\n-            }\n-\n-            _ => bug!(),\n-        };\n-\n-        Ok(VtableBuiltinData { nested })\n-    }\n-\n     ///////////////////////////////////////////////////////////////////////////\n     // Matching\n     //"}]}