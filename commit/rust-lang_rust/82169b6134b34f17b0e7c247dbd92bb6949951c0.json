{"sha": "82169b6134b34f17b0e7c247dbd92bb6949951c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyMTY5YjYxMzRiMzRmMTdiMGU3YzI0N2RiZDkyYmI2OTQ5OTUxYzA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-19T22:32:43Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-26T17:18:27Z"}, "message": "convert query-type-op to create query-region-constraint directly", "tree": {"sha": "b88687335417912da041d4ceb8cbd61c7f6b794b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b88687335417912da041d4ceb8cbd61c7f6b794b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82169b6134b34f17b0e7c247dbd92bb6949951c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82169b6134b34f17b0e7c247dbd92bb6949951c0", "html_url": "https://github.com/rust-lang/rust/commit/82169b6134b34f17b0e7c247dbd92bb6949951c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82169b6134b34f17b0e7c247dbd92bb6949951c0/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a583269af57e6acce6d9c2ffe4c0ce2b4f2e1ab9", "url": "https://api.github.com/repos/rust-lang/rust/commits/a583269af57e6acce6d9c2ffe4c0ce2b4f2e1ab9", "html_url": "https://github.com/rust-lang/rust/commit/a583269af57e6acce6d9c2ffe4c0ce2b4f2e1ab9"}], "stats": {"total": 366, "additions": 179, "deletions": 187}, "files": [{"sha": "8a3784fe088225c5b27406c5cd048b9c7df4d917", "filename": "src/librustc/infer/canonical/query_result.rs", "status": "modified", "additions": 46, "deletions": 39, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/82169b6134b34f17b0e7c247dbd92bb6949951c0/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82169b6134b34f17b0e7c247dbd92bb6949951c0/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs?ref=82169b6134b34f17b0e7c247dbd92bb6949951c0", "patch": "@@ -17,7 +17,6 @@\n //!\n //! [c]: https://rust-lang-nursery.github.io/rustc-guide/traits/canonicalization.html\n \n-use either::Either;\n use infer::canonical::substitute::substitute_value;\n use infer::canonical::{\n     Canonical, CanonicalVarKind, CanonicalVarValues, CanonicalizedQueryResult, Certainty,\n@@ -29,7 +28,6 @@ use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::sync::Lrc;\n use std::fmt::Debug;\n-use std::iter::once;\n use syntax::ast;\n use traits::query::NoSolution;\n use traits::{FulfillmentContext, TraitEngine};\n@@ -191,9 +189,11 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     pub fn instantiate_nll_query_result_and_region_obligations<R>(\n         &self,\n         cause: &ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n         original_values: &CanonicalVarValues<'tcx>,\n         query_result: &Canonical<'tcx, QueryResult<'tcx, R>>,\n-    ) -> Vec<QueryRegionConstraint<'tcx>>\n+        output_query_region_constraints: &mut Vec<QueryRegionConstraint<'tcx>>,\n+    ) -> InferResult<'tcx, R>\n     where\n         R: Debug + TypeFoldable<'tcx>,\n     {\n@@ -210,52 +210,59 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         // Compute `QueryRegionConstraint` values that unify each of\n         // the original values `v_o` that was canonicalized into a\n         // variable...\n-        let qrc_from_unify = original_values.var_values.iter_enumerated().flat_map(\n-            |(index, original_value)| {\n-                // ...with the value `v_r` of that variable from the query.\n-                let result_value =\n-                    query_result\n-                        .substitute_projected(self.tcx, &result_subst, |v| &v.var_values[index]);\n-                match (original_value.unpack(), result_value.unpack()) {\n-                    (\n-                        UnpackedKind::Lifetime(ty::ReErased),\n-                        UnpackedKind::Lifetime(ty::ReErased),\n-                    ) => {\n-                        // no action needed\n-                        Either::Left(None.into_iter())\n-                    }\n+        let mut obligations = vec![];\n+\n+        for (index, original_value) in original_values.var_values.iter_enumerated() {\n+            // ...with the value `v_r` of that variable from the query.\n+            let result_value = query_result\n+                .substitute_projected(self.tcx, &result_subst, |v| &v.var_values[index]);\n+            match (original_value.unpack(), result_value.unpack()) {\n+                (UnpackedKind::Lifetime(ty::ReErased), UnpackedKind::Lifetime(ty::ReErased)) => {\n+                    // no action needed\n+                }\n \n-                    (UnpackedKind::Lifetime(v_o), UnpackedKind::Lifetime(v_r)) => {\n-                        // To make `v_o = v_r`, we emit `v_o: v_r` and `v_r: v_o`.\n-                        Either::Right(\n-                            once(ty::OutlivesPredicate(v_o.into(), v_r))\n-                                .chain(once(ty::OutlivesPredicate(v_r.into(), v_o)))\n-                                .map(ty::Binder::dummy),\n-                        )\n+                (UnpackedKind::Lifetime(v_o), UnpackedKind::Lifetime(v_r)) => {\n+                    // To make `v_o = v_r`, we emit `v_o: v_r` and `v_r: v_o`.\n+                    if v_o != v_r {\n+                        output_query_region_constraints\n+                            .push(ty::Binder::dummy(ty::OutlivesPredicate(v_o.into(), v_r)));\n+                        output_query_region_constraints\n+                            .push(ty::Binder::dummy(ty::OutlivesPredicate(v_r.into(), v_o)));\n                     }\n+                }\n \n-                    (UnpackedKind::Type(_), _) | (_, UnpackedKind::Type(_)) => {\n-                        // in NLL queries, we do not expect `type` results.\n-                        bug!(\n-                            \"unexpected type in NLL query: cannot unify {:?} and {:?}\",\n-                            original_value,\n-                            result_value,\n-                        );\n-                    }\n+                (UnpackedKind::Type(v1), UnpackedKind::Type(v2)) => {\n+                    let ok = self.at(cause, param_env).eq(v1, v2)?;\n+                    obligations.extend(ok.into_obligations());\n                 }\n-            },\n-        );\n+\n+                _ => {\n+                    bug!(\n+                        \"kind mismatch, cannot unify {:?} and {:?}\",\n+                        original_value,\n+                        result_value\n+                    );\n+                }\n+            }\n+        }\n \n         // ...also include the other query region constraints from the query.\n-        let qrc_from_result = query_result.value.region_constraints.iter().map(|r_c| {\n-            r_c.map_bound(|ty::OutlivesPredicate(k1, r2)| {\n+        output_query_region_constraints.reserve(query_result.value.region_constraints.len());\n+        for r_c in query_result.value.region_constraints.iter() {\n+            output_query_region_constraints.push(r_c.map_bound(|ty::OutlivesPredicate(k1, r2)| {\n                 let k1 = substitute_value(self.tcx, &result_subst, &k1);\n                 let r2 = substitute_value(self.tcx, &result_subst, &r2);\n                 ty::OutlivesPredicate(k1, r2)\n-            })\n-        });\n+            }));\n+        }\n \n-        qrc_from_unify.chain(qrc_from_result).collect()\n+        let user_result: R =\n+            query_result.substitute_projected(self.tcx, &result_subst, |q_r| &q_r.value);\n+\n+        Ok(InferOk {\n+            value: user_result,\n+            obligations,\n+        })\n     }\n \n     /// Given the original values and the (canonicalized) result from"}, {"sha": "90ea276a0944995460e55b256bccac673d1b960e", "filename": "src/librustc/traits/query/type_op/custom.rs", "status": "modified", "additions": 50, "deletions": 7, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/82169b6134b34f17b0e7c247dbd92bb6949951c0/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82169b6134b34f17b0e7c247dbd92bb6949951c0/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs?ref=82169b6134b34f17b0e7c247dbd92bb6949951c0", "patch": "@@ -9,9 +9,14 @@\n // except according to those terms.\n \n use infer::{InferCtxt, InferOk};\n-use traits::query::Fallible;\n-use ty::TyCtxt;\n use std::fmt;\n+use traits::query::Fallible;\n+\n+use infer::canonical::query_result;\n+use infer::canonical::QueryRegionConstraint;\n+use std::rc::Rc;\n+use syntax::codemap::DUMMY_SP;\n+use traits::{ObligationCause, TraitEngine};\n \n pub struct CustomTypeOp<F, G> {\n     closure: F,\n@@ -38,12 +43,18 @@ where\n {\n     type Output = R;\n \n-    fn trivial_noop(self, _tcx: TyCtxt<'_, 'gcx, 'tcx>) -> Result<Self::Output, Self> {\n-        Err(self)\n-    }\n+    /// Processes the operation and all resulting obligations,\n+    /// returning the final result along with any region constraints\n+    /// (they will be given over to the NLL region solver).\n+    fn fully_perform(\n+        self,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+    ) -> Fallible<(Self::Output, Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>)> {\n+        if cfg!(debug_assertions) {\n+            info!(\"fully_perform({:?})\", self);\n+        }\n \n-    fn perform(self, infcx: &InferCtxt<'_, 'gcx, 'tcx>) -> Fallible<InferOk<'tcx, R>> {\n-        Ok((self.closure)(infcx)?)\n+        scrape_region_constraints(infcx, || Ok((self.closure)(infcx)?))\n     }\n }\n \n@@ -55,3 +66,35 @@ where\n         write!(f, \"{}\", (self.description)())\n     }\n }\n+\n+/// Executes `op` and then scrapes out all the \"old style\" region\n+/// constraints that result, creating query-region-constraints.\n+fn scrape_region_constraints<'gcx, 'tcx, R>(\n+    infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+    op: impl FnOnce() -> Fallible<InferOk<'tcx, R>>,\n+) -> Fallible<(R, Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>)> {\n+    let mut fulfill_cx = TraitEngine::new(infcx.tcx);\n+    let dummy_body_id = ObligationCause::dummy().body_id;\n+    let InferOk { value, obligations } = infcx.commit_if_ok(|_| op())?;\n+    debug_assert!(obligations.iter().all(|o| o.cause.body_id == dummy_body_id));\n+    fulfill_cx.register_predicate_obligations(infcx, obligations);\n+    if let Err(e) = fulfill_cx.select_all_or_error(infcx) {\n+        infcx.tcx.sess.diagnostic().delay_span_bug(\n+            DUMMY_SP,\n+            &format!(\"errors selecting obligation during MIR typeck: {:?}\", e),\n+        );\n+    }\n+\n+    let region_obligations = infcx.take_registered_region_obligations();\n+\n+    let region_constraint_data = infcx.take_and_reset_region_constraints();\n+\n+    let outlives =\n+        query_result::make_query_outlives(infcx.tcx, region_obligations, &region_constraint_data);\n+\n+    if outlives.is_empty() {\n+        Ok((value, None))\n+    } else {\n+        Ok((value, Some(Rc::new(outlives))))\n+    }\n+}"}, {"sha": "04d256a93e12a5141c6b01cff153ed7612c14286", "filename": "src/librustc/traits/query/type_op/eq.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/82169b6134b34f17b0e7c247dbd92bb6949951c0/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82169b6134b34f17b0e7c247dbd92bb6949951c0/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs?ref=82169b6134b34f17b0e7c247dbd92bb6949951c0", "patch": "@@ -10,7 +10,7 @@\n \n use infer::canonical::{Canonical, CanonicalizedQueryResult, QueryResult};\n use traits::query::Fallible;\n-use ty::{self, ParamEnv, Ty, TyCtxt};\n+use ty::{ParamEnv, Ty, TyCtxt};\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub struct Eq<'tcx> {\n@@ -29,20 +29,16 @@ impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for Eq<'tcx> {\n     type QueryKey = Self;\n     type QueryResult = ();\n \n-    fn trivial_noop(self, _tcx: TyCtxt<'_, 'gcx, 'tcx>) -> Result<Self::QueryResult, Self> {\n+    fn prequery(self, _tcx: TyCtxt<'_, 'gcx, 'tcx>) -> Result<Self::QueryResult, Self> {\n         if self.a == self.b {\n             Ok(())\n         } else {\n             Err(self)\n         }\n     }\n \n-    fn into_query_key(self) -> Self {\n-        self\n-    }\n-\n-    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n-        self.param_env\n+    fn param_env(key: &Self::QueryKey) -> ParamEnv<'tcx> {\n+        key.param_env\n     }\n \n     fn perform_query("}, {"sha": "16280885c12ad551c9509e1412f78e8bb8fe44ae", "filename": "src/librustc/traits/query/type_op/mod.rs", "status": "modified", "additions": 66, "deletions": 104, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/82169b6134b34f17b0e7c247dbd92bb6949951c0/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82169b6134b34f17b0e7c247dbd92bb6949951c0/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=82169b6134b34f17b0e7c247dbd92bb6949951c0", "patch": "@@ -8,16 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use infer::canonical::query_result;\n use infer::canonical::{\n     Canonical, Canonicalized, CanonicalizedQueryResult, QueryRegionConstraint, QueryResult,\n };\n use infer::{InferCtxt, InferOk};\n use std::fmt;\n use std::rc::Rc;\n-use syntax::codemap::DUMMY_SP;\n use traits::query::Fallible;\n-use traits::{ObligationCause, TraitEngine};\n+use traits::ObligationCause;\n use ty::fold::TypeFoldable;\n use ty::{Lift, ParamEnv, TyCtxt};\n \n@@ -31,89 +29,25 @@ pub mod subtype;\n pub trait TypeOp<'gcx, 'tcx>: Sized + fmt::Debug {\n     type Output;\n \n-    /// Micro-optimization: returns `Ok(x)` if we can trivially\n-    /// produce the output, else returns `Err(self)` back.\n-    fn trivial_noop(self, tcx: TyCtxt<'_, 'gcx, 'tcx>) -> Result<Self::Output, Self>;\n-\n-    /// Given an infcx, performs **the kernel** of the operation: this does the\n-    /// key action and then, optionally, returns a set of obligations which must be proven.\n-    ///\n-    /// This method is not meant to be invoked directly: instead, one\n-    /// should use `fully_perform`, which will take those resulting\n-    /// obligations and prove them, and then process the combined\n-    /// results into region obligations which are returned.\n-    fn perform(\n-        self,\n-        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n-    ) -> Fallible<InferOk<'tcx, Self::Output>>;\n-\n     /// Processes the operation and all resulting obligations,\n     /// returning the final result along with any region constraints\n     /// (they will be given over to the NLL region solver).\n     fn fully_perform(\n         self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n-    ) -> Fallible<(Self::Output, Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>)> {\n-        match self.trivial_noop(infcx.tcx) {\n-            Ok(r) => Ok((r, None)),\n-            Err(op) => op.fully_perform_nontrivial(infcx),\n-        }\n-    }\n-\n-    /// Helper for `fully_perform` that handles the nontrivial cases.\n-    #[inline(never)] // just to help with profiling\n-    fn fully_perform_nontrivial(\n-        self,\n-        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n-    ) -> Fallible<(Self::Output, Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>)> {\n-        if cfg!(debug_assertions) {\n-            info!(\n-                \"fully_perform_op_and_get_region_constraint_data({:?})\",\n-                self\n-            );\n-        }\n-\n-        let mut fulfill_cx = TraitEngine::new(infcx.tcx);\n-        let dummy_body_id = ObligationCause::dummy().body_id;\n-        let InferOk { value, obligations } = infcx.commit_if_ok(|_| self.perform(infcx))?;\n-        debug_assert!(obligations.iter().all(|o| o.cause.body_id == dummy_body_id));\n-        fulfill_cx.register_predicate_obligations(infcx, obligations);\n-        if let Err(e) = fulfill_cx.select_all_or_error(infcx) {\n-            infcx.tcx.sess.diagnostic().delay_span_bug(\n-                DUMMY_SP,\n-                &format!(\"errors selecting obligation during MIR typeck: {:?}\", e),\n-            );\n-        }\n-\n-        let region_obligations = infcx.take_registered_region_obligations();\n-\n-        let region_constraint_data = infcx.take_and_reset_region_constraints();\n-\n-        let outlives = query_result::make_query_outlives(\n-            infcx.tcx,\n-            region_obligations,\n-            &region_constraint_data,\n-        );\n-\n-        if outlives.is_empty() {\n-            Ok((value, None))\n-        } else {\n-            Ok((value, Some(Rc::new(outlives))))\n-        }\n-    }\n+    ) -> Fallible<(Self::Output, Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>)>;\n }\n \n pub trait QueryTypeOp<'gcx: 'tcx, 'tcx>: fmt::Debug + Sized {\n     type QueryKey: TypeFoldable<'tcx> + Lift<'gcx>;\n     type QueryResult: TypeFoldable<'tcx> + Lift<'gcx>;\n \n-    /// Micro-optimization: returns `Ok(x)` if we can trivially\n-    /// produce the output, else returns `Err(self)` back.\n-    fn trivial_noop(self, tcx: TyCtxt<'_, 'gcx, 'tcx>) -> Result<Self::QueryResult, Self>;\n-\n-    fn into_query_key(self) -> Self::QueryKey;\n+    /// Either converts `self` directly into a `QueryResult` (for\n+    /// simple cases) or into a `QueryKey` (for more complex cases\n+    /// where we actually have work to do).\n+    fn prequery(self, tcx: TyCtxt<'_, 'gcx, 'tcx>) -> Result<Self::QueryResult, Self::QueryKey>;\n \n-    fn param_env(&self) -> ParamEnv<'tcx>;\n+    fn param_env(key: &Self::QueryKey) -> ParamEnv<'tcx>;\n \n     fn perform_query(\n         tcx: TyCtxt<'_, 'gcx, 'tcx>,\n@@ -130,6 +64,51 @@ pub trait QueryTypeOp<'gcx: 'tcx, 'tcx>: fmt::Debug + Sized {\n     fn upcast_result(\n         lifted_query_result: &'a CanonicalizedQueryResult<'gcx, Self::QueryResult>,\n     ) -> &'a Canonical<'tcx, QueryResult<'tcx, Self::QueryResult>>;\n+\n+    fn fully_perform_into(\n+        self,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        output_query_region_constraints: &mut Vec<QueryRegionConstraint<'tcx>>,\n+    ) -> Fallible<Self::QueryResult> {\n+        match QueryTypeOp::prequery(self, infcx.tcx) {\n+            Ok(result) => Ok(result),\n+            Err(query_key) => {\n+                // FIXME(#33684) -- We need to use\n+                // `canonicalize_hr_query_hack` here because of things\n+                // like the subtype query, which go awry around\n+                // `'static` otherwise.\n+                let (canonical_self, canonical_var_values) =\n+                    infcx.canonicalize_hr_query_hack(&query_key);\n+                let canonical_result = Self::perform_query(infcx.tcx, canonical_self)?;\n+                let canonical_result = Self::upcast_result(&canonical_result);\n+\n+                let param_env = Self::param_env(&query_key);\n+\n+                let InferOk { value, obligations } = infcx\n+                    .instantiate_nll_query_result_and_region_obligations(\n+                        &ObligationCause::dummy(),\n+                        param_env,\n+                        &canonical_var_values,\n+                        canonical_result,\n+                        output_query_region_constraints,\n+                    )?;\n+\n+                // Typically, instantiating NLL query results does not\n+                // create obligations. However, in some cases there\n+                // are unresolved type variables, and unify them *can*\n+                // create obligations. In that case, we have to go\n+                // fulfill them. We do this via a (recursive) query.\n+                for obligation in obligations {\n+                    let () = prove_predicate::ProvePredicate::new(\n+                        obligation.param_env,\n+                        obligation.predicate,\n+                    ).fully_perform_into(infcx, output_query_region_constraints)?;\n+                }\n+\n+                Ok(value)\n+            }\n+        }\n+    }\n }\n \n impl<'gcx: 'tcx, 'tcx, Q> TypeOp<'gcx, 'tcx> for Q\n@@ -138,38 +117,21 @@ where\n {\n     type Output = Q::QueryResult;\n \n-    fn trivial_noop(self, tcx: TyCtxt<'_, 'gcx, 'tcx>) -> Result<Self::Output, Self> {\n-        QueryTypeOp::trivial_noop(self, tcx)\n-    }\n-\n-    fn perform(\n+    fn fully_perform(\n         self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n-    ) -> Fallible<InferOk<'tcx, Self::Output>> {\n-        let param_env = self.param_env();\n-\n-        // FIXME(#33684) -- We need to use\n-        // `canonicalize_hr_query_hack` here because of things like\n-        // the subtype query, which go awry around `'static`\n-        // otherwise.\n-        let query_key = self.into_query_key();\n-        let (canonical_self, canonical_var_values) = infcx.canonicalize_hr_query_hack(&query_key);\n-        let canonical_result = Q::perform_query(infcx.tcx, canonical_self)?;\n-\n-        // FIXME: This is not the most efficient setup. The\n-        // `instantiate_query_result_and_region_obligations` basically\n-        // takes the `QueryRegionConstraint` values that we ultimately\n-        // want to use and converts them into obligations. We return\n-        // those to our caller, which will convert them into AST\n-        // region constraints; we then convert *those* back into\n-        // `QueryRegionConstraint` and ultimately into NLL\n-        // constraints. We should cut out the middleman but that will\n-        // take a bit of refactoring.\n-        Ok(infcx.instantiate_query_result_and_region_obligations(\n-            &ObligationCause::dummy(),\n-            param_env,\n-            &canonical_var_values,\n-            Q::upcast_result(&canonical_result),\n-        )?)\n+    ) -> Fallible<(Self::Output, Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>)> {\n+        let mut qrc = vec![];\n+        let r = Q::fully_perform_into(self, infcx, &mut qrc)?;\n+\n+        // Promote the final query-region-constraints into a\n+        // (optional) ref-counted vector:\n+        let opt_qrc = if qrc.is_empty() {\n+            None\n+        } else {\n+            Some(Rc::new(qrc))\n+        };\n+\n+        Ok((r, opt_qrc))\n     }\n }"}, {"sha": "b72c887ba50c19b8bbad518c7b69175001539907", "filename": "src/librustc/traits/query/type_op/normalize.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/82169b6134b34f17b0e7c247dbd92bb6949951c0/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82169b6134b34f17b0e7c247dbd92bb6949951c0/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs?ref=82169b6134b34f17b0e7c247dbd92bb6949951c0", "patch": "@@ -36,20 +36,16 @@ where\n     type QueryKey = Self;\n     type QueryResult = T;\n \n-    fn trivial_noop(self, _tcx: TyCtxt<'_, 'gcx, 'tcx>) -> Result<T, Self> {\n+    fn prequery(self, _tcx: TyCtxt<'_, 'gcx, 'tcx>) -> Result<T, Self> {\n         if !self.value.has_projections() {\n             Ok(self.value)\n         } else {\n             Err(self)\n         }\n     }\n \n-    fn into_query_key(self) -> Self {\n-        self\n-    }\n-\n-    fn param_env(&self) -> ParamEnv<'tcx> {\n-        self.param_env\n+    fn param_env(key: &Self::QueryKey) -> ParamEnv<'tcx> {\n+        key.param_env\n     }\n \n     fn perform_query("}, {"sha": "0254b901a8c58bc2d8462feee979d4d07140754b", "filename": "src/librustc/traits/query/type_op/outlives.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/82169b6134b34f17b0e7c247dbd92bb6949951c0/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82169b6134b34f17b0e7c247dbd92bb6949951c0/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs?ref=82169b6134b34f17b0e7c247dbd92bb6949951c0", "patch": "@@ -36,20 +36,16 @@ where\n     type QueryKey = ParamEnvAnd<'tcx, Ty<'tcx>>;\n     type QueryResult = DropckOutlivesResult<'tcx>;\n \n-    fn trivial_noop(self, tcx: TyCtxt<'_, 'gcx, 'tcx>) -> Result<Self::QueryResult, Self> {\n+    fn prequery(self, tcx: TyCtxt<'_, 'gcx, 'tcx>) -> Result<Self::QueryResult, Self::QueryKey> {\n         if trivial_dropck_outlives(tcx, self.dropped_ty) {\n             Ok(DropckOutlivesResult::default())\n         } else {\n-            Err(self)\n+            Err(self.param_env.and(self.dropped_ty))\n         }\n     }\n \n-    fn param_env(&self) -> ParamEnv<'tcx> {\n-        self.param_env\n-    }\n-\n-    fn into_query_key(self) -> Self::QueryKey {\n-        self.param_env.and(self.dropped_ty)\n+    fn param_env(key: &Self::QueryKey) -> ParamEnv<'tcx> {\n+        key.param_env\n     }\n \n     fn perform_query("}, {"sha": "b06ad32ff2232dc883f14697c7d717df9b2ff132", "filename": "src/librustc/traits/query/type_op/prove_predicate.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/82169b6134b34f17b0e7c247dbd92bb6949951c0/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82169b6134b34f17b0e7c247dbd92bb6949951c0/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs?ref=82169b6134b34f17b0e7c247dbd92bb6949951c0", "patch": "@@ -31,16 +31,12 @@ impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for ProvePredicate<'tcx> {\n     type QueryKey = Self;\n     type QueryResult = ();\n \n-    fn trivial_noop(self, _tcx: TyCtxt<'_, 'gcx, 'tcx>) -> Result<Self::QueryResult, Self> {\n+    fn prequery(self, _tcx: TyCtxt<'_, 'gcx, 'tcx>) -> Result<Self::QueryResult, Self::QueryKey> {\n         Err(self)\n     }\n \n-    fn into_query_key(self) -> Self {\n-        self\n-    }\n-\n-    fn param_env(&self) -> ParamEnv<'tcx> {\n-        self.param_env\n+    fn param_env(key: &Self::QueryKey) -> ParamEnv<'tcx> {\n+        key.param_env\n     }\n \n     fn perform_query("}, {"sha": "bdc7dd9589b670eaa970033b0ad18058a4ea09c9", "filename": "src/librustc/traits/query/type_op/subtype.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/82169b6134b34f17b0e7c247dbd92bb6949951c0/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82169b6134b34f17b0e7c247dbd92bb6949951c0/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs?ref=82169b6134b34f17b0e7c247dbd92bb6949951c0", "patch": "@@ -33,20 +33,16 @@ impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for Subtype<'tcx> {\n     type QueryKey = Self;\n     type QueryResult = ();\n \n-    fn trivial_noop(self, _tcx: TyCtxt<'_, 'gcx, 'tcx>) -> Result<(), Self> {\n+    fn prequery(self, _tcx: TyCtxt<'_, 'gcx, 'tcx>) -> Result<(), Self::QueryKey> {\n         if self.sub == self.sup {\n             Ok(())\n         } else {\n             Err(self)\n         }\n     }\n \n-    fn into_query_key(self) -> Self {\n-        self\n-    }\n-\n-    fn param_env(&self) -> ParamEnv<'tcx> {\n-        self.param_env\n+    fn param_env(key: &Self::QueryKey) -> ParamEnv<'tcx> {\n+        key.param_env\n     }\n \n     fn perform_query("}]}