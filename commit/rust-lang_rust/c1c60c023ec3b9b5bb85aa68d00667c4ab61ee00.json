{"sha": "c1c60c023ec3b9b5bb85aa68d00667c4ab61ee00", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxYzYwYzAyM2VjM2I5YjViYjg1YWE2OGQwMDY2N2M0YWI2MWVlMDA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-11T00:16:48Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-12T00:21:53Z"}, "message": "first attempt at an assignability check", "tree": {"sha": "199e1451073265545e71b930aabb28a8a1d7d8b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/199e1451073265545e71b930aabb28a8a1d7d8b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1c60c023ec3b9b5bb85aa68d00667c4ab61ee00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1c60c023ec3b9b5bb85aa68d00667c4ab61ee00", "html_url": "https://github.com/rust-lang/rust/commit/c1c60c023ec3b9b5bb85aa68d00667c4ab61ee00", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1c60c023ec3b9b5bb85aa68d00667c4ab61ee00/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8967c4b409396edf610967b329f0bf6cbcee4a2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8967c4b409396edf610967b329f0bf6cbcee4a2f", "html_url": "https://github.com/rust-lang/rust/commit/8967c4b409396edf610967b329f0bf6cbcee4a2f"}], "stats": {"total": 192, "additions": 127, "deletions": 65}, "files": [{"sha": "95f5ae19f1c6c697b23d9aed969d976a8d342f88", "filename": "src/rustc/middle/infer.rs", "status": "modified", "additions": 117, "deletions": 61, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/c1c60c023ec3b9b5bb85aa68d00667c4ab61ee00/src%2Frustc%2Fmiddle%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1c60c023ec3b9b5bb85aa68d00667c4ab61ee00/src%2Frustc%2Fmiddle%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Finfer.rs?ref=c1c60c023ec3b9b5bb85aa68d00667c4ab61ee00", "patch": "@@ -201,41 +201,11 @@ impl of st for ty::region {\n     }\n }\n \n-// Most of these methods, like tys() and so forth, take two parameters\n-// a and b and they are tasked with \"ensuring that a is a subtype of\n-// b\".  They return success or failure.  They make changes in-place to\n-// the variable bindings: these changes are recorded in the `bindings`\n-// array, which then allows the changes to be rolled back if needed.\n-//\n-// The merge() and merge_bnds() methods are somewhat different in that\n-// they compute a new type range for a variable (generally a subset of\n-// the old range).  They therefore return a result.\n-impl unify_methods for infer_ctxt {\n-    fn uok() -> ures {\n-        ok(())\n-    }\n-\n-    fn uerr(e: ty::type_err) -> ures {\n-        #debug[\"Unification error: %?\", e];\n-        err(e)\n-    }\n-\n-    fn set<V:copy vid, T:copy to_str>(\n-        vb: vals_and_bindings<V, T>, vid: V,\n-        +new_v: var_value<V, T>) {\n-\n-        let old_v = vb.vals.get(vid.to_uint());\n-        vec::push(vb.bindings, (vid, old_v));\n-        vb.vals.insert(vid.to_uint(), new_v);\n-\n-        #debug[\"Updating variable %s from %s to %s\",\n-               vid.to_str(), old_v.to_str(self), new_v.to_str(self)];\n-    }\n-\n-    fn set_ty(vid: ty_vid, +new_v: var_value<ty_vid, ty::t>) {\n-        self.set(self.vb, vid, new_v);\n-    }\n+fn uok() -> ures {\n+    ok(())\n+}\n \n+impl methods for infer_ctxt {\n     fn commit<T,E>(f: fn() -> result<T,E>) -> result<T,E> {\n \n         assert self.vb.bindings.len() == 0u;\n@@ -276,6 +246,21 @@ impl unify_methods for infer_ctxt {\n         }\n         ret r;\n     }\n+}\n+\n+impl unify_methods for infer_ctxt {\n+\n+    fn set<V:copy vid, T:copy to_str>(\n+        vb: vals_and_bindings<V, T>, vid: V,\n+        +new_v: var_value<V, T>) {\n+\n+        let old_v = vb.vals.get(vid.to_uint());\n+        vec::push(vb.bindings, (vid, old_v));\n+        vb.vals.insert(vid.to_uint(), new_v);\n+\n+        #debug[\"Updating variable %s from %s to %s\",\n+               vid.to_str(), old_v.to_str(self), new_v.to_str(self)];\n+    }\n \n     fn get<V:copy vid, T:copy>(\n         vb: vals_and_bindings<V, T>, vid: V)\n@@ -397,7 +382,7 @@ impl unify_methods for infer_ctxt {\n             // be relatable:\n             self.bnds(bnds.lb, bnds.ub).then {||\n                 self.set(vb, v_id, bounded(bnds));\n-                self.uok()\n+                uok()\n             }\n         }}}}}\n     }\n@@ -414,7 +399,7 @@ impl unify_methods for infer_ctxt {\n                a_id.to_str(), a_bounds.to_str(self),\n                b_id.to_str(), b_bounds.to_str(self)];\n \n-        if a_id == b_id { ret self.uok(); }\n+        if a_id == b_id { ret uok(); }\n \n         // If both A's UB and B's LB have already been bound to types,\n         // see if we can make those types subtypes.\n@@ -437,7 +422,7 @@ impl unify_methods for infer_ctxt {\n         // A remains a subtype of B.  Actually, there are other options,\n         // but that's the route we choose to take.\n         self.set_var_to_merged_bounds(vb, a_id, a_bounds, b_bounds).then {||\n-            self.uok()\n+            uok()\n         }\n     }\n \n@@ -470,7 +455,7 @@ impl unify_methods for infer_ctxt {\n         actual_constr: @ty::type_constr) -> ures {\n \n         let err_res =\n-            self.uerr(ty::terr_constr_mismatch(expected, actual_constr));\n+            err(ty::terr_constr_mismatch(expected, actual_constr));\n \n         if expected.node.id != actual_constr.node.id { ret err_res; }\n         let expected_arg_len = vec::len(expected.node.args);\n@@ -505,7 +490,7 @@ impl unify_methods for infer_ctxt {\n             }\n             i += 1u;\n         }\n-        ret self.uok();\n+        ret uok();\n     }\n \n     fn bnds<T:copy to_str st>(\n@@ -517,7 +502,7 @@ impl unify_methods for infer_ctxt {\n               (none, none) |\n               (some(_), none) |\n               (none, some(_)) {\n-                self.uok()\n+                uok()\n               }\n               (some(t_a), some(t_b)) {\n                 t_a.sub(self, t_b)\n@@ -534,7 +519,7 @@ impl unify_methods for infer_ctxt {\n                 self.constrs(a, b)\n             }\n         } else {\n-            self.uerr(ty::terr_constr_len(bs.len(), as.len()))\n+            err(ty::terr_constr_len(bs.len(), as.len()))\n         }\n     }\n \n@@ -688,33 +673,103 @@ impl resolve_methods for infer_ctxt {\n     }\n }\n \n+// ______________________________________________________________________\n+// Type assignment\n+//\n+// True if rvalues of type `a` can be assigned to lvalues of type `b`.\n+\n+impl assignment for infer_ctxt {\n+    fn assign_tys(a: ty::t, b: ty::t,\n+                  encl_blk_id: ast::node_id) -> ures {\n+\n+        #debug[\"assign_tys(%s, %s)\", a.to_str(self), b.to_str(self)];\n+        let _r = indenter();\n+\n+        alt (ty::get(a).struct, ty::get(b).struct) {\n+          (ty::ty_bot, _) {\n+            uok()\n+          }\n+\n+          (ty::ty_var(a_id), ty::ty_var(b_id)) {\n+            let {root:_, bounds:a_bounds} = self.get(self.vb, a_id);\n+            let {root:_, bounds:b_bounds} = self.get(self.vb, b_id);\n+            self.assign_vars_or_sub(a, b, a_bounds, b_bounds, encl_blk_id)\n+          }\n+\n+          (ty::ty_var(a_id), _) {\n+            let {root:_, bounds:a_bounds} = self.get(self.vb, a_id);\n+            let b_bounds = {lb: some(b), ub: none};\n+            self.assign_vars_or_sub(a, b, a_bounds, b_bounds, encl_blk_id)\n+          }\n+\n+          (_, ty::ty_var(b_id)) {\n+            let a_bounds = {lb: none, ub: some(a)};\n+            let {root:_, bounds: b_bounds} = self.get(self.vb, b_id);\n+            self.assign_vars_or_sub(a, b, a_bounds, b_bounds, encl_blk_id)\n+          }\n+\n+          (ty::ty_box(a_mt), ty::ty_rptr(_, _)) |\n+          (ty::ty_uniq(a_mt), ty::ty_rptr(_, _)) {\n+            let a_r = ty::re_scope(encl_blk_id);\n+            let a_ty = ty::mk_rptr(self.tcx, a_r, a_mt);\n+            self.sub_tys(a_ty, b).to_ures()\n+          }\n+\n+          _ {\n+            self.sub_tys(a, b).to_ures()\n+          }\n+        }\n+    }\n+\n+    fn assign_tys_or_sub(a: ty::t, b: ty::t,\n+                         a_b: ty::t, b_b: ty::t,\n+                         encl_blk_id: ast::node_id) -> ures {\n+        self.try {||\n+            self.assign_tys(a_b, b_b, encl_blk_id)\n+        }.chain_err {|_e|\n+            self.sub_tys(a, b)\n+        }\n+    }\n+\n+    fn assign_vars_or_sub(a: ty::t, b: ty::t,\n+                          a_bounds: bounds<ty::t>, b_bounds: bounds<ty::t>,\n+                          encl_blk_id: ast::node_id) -> ures {\n+\n+        alt (a_bounds.ub, b_bounds.lb) {\n+          (some(a_ub), some(b_lb)) {\n+            self.assign_tys_or_sub(a, b, a_ub, b_lb, encl_blk_id)\n+          }\n+          _ {\n+            self.sub_tys(a, b).to_ures()\n+          }\n+        }\n+    }\n+}\n+\n // ______________________________________________________________________\n // Type combining\n //\n-// There are two type combiners, lub and gub.  The first computes the\n-// Least Upper Bound of two types `a` and `b`---that is, a mutual\n+// There are three type combiners, sub, lub, and gub.  `sub` is a bit\n+// different from the other two: it takes two types and makes the first\n+// a subtype of the other, or fails if this cannot be done.  It does\n+// return a new type but its return value is meaningless---it is only\n+// there to allow for greater code reuse.\n+//\n+// `lub` and `glb` compute the Least Upper Bound and Greatest Lower\n+// Bound respectively of two types `a` and `b`.  The LUB is a mutual\n // supertype type `c` where `a <: c` and `b <: c`.  As the name\n-// implies, it tries to pick the most precise `c` possible.  `glb`\n-// computes the greatest lower bound---that is, it computes a mutual\n-// subtype, aiming for the most general such type possible.  Both\n-// computations may fail.\n+// implies, it tries to pick the most precise `c` possible.  The GLB\n+// is a mutual subtype, aiming for the most general such type\n+// possible.  Both computations may fail.\n //\n // There is a lot of common code for these operations, which is\n-// abstracted out into functions named `c_X()` which take a combiner\n+// abstracted out into functions named `super_X()` which take a combiner\n // instance as the first parameter.  This would be better implemented\n // using traits.\n //\n-// The `c_X()` top-level items work for *both LUB and GLB*: any\n-// operation which varies between LUB and GLB will be dynamically\n-// dispatched using a `self.Y()` operation.\n-//\n-// In principle, the subtyping relation computed above could be built\n-// on the combine framework---this would result in less code but would\n-// be less efficient.  There is a significant performance gain from\n-// not recreating types unless we need to.  Even so, we could write\n-// the routines with a few more generics in there to mask type\n-// construction (which is, after all, the significant expense) but I\n-// haven't gotten around to it.\n+// The `super_X()` top-level items work for *sub, lub, and glb*: any\n+// operation which varies will be dynamically dispatched using a\n+// `self.Y()` operation.\n \n type cres<T> = result<T,ty::type_err>;\n \n@@ -736,7 +791,7 @@ iface combine {\n     fn regions(a: ty::region, b: ty::region) -> cres<ty::region>;\n }\n \n-enum sub = infer_ctxt;  // \"less than\" == \"subtype\" or \"subregion\"\n+enum sub = infer_ctxt;  // \"subtype\", \"subregion\" etc\n enum lub = infer_ctxt;  // \"least upper bound\" (common supertype)\n enum glb = infer_ctxt;  // \"greatest lower bound\" (common subtype)\n \n@@ -1445,7 +1500,8 @@ impl of combine for glb {\n // ______________________________________________________________________\n // Lattice operations on variables\n //\n-// this is common code used by both LUB and GLB\n+// This is common code used by both LUB and GLB to compute the LUB/GLB\n+// for pairs of variables or for variables and values.\n \n iface lattice_ops {\n     fn bnd<T:copy>(b: bounds<T>) -> option<T>;"}, {"sha": "b75623d6233a72d2f842be3a5ea1559c04988de9", "filename": "src/test/compile-fail/vec-concat-bug.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c1c60c023ec3b9b5bb85aa68d00667c4ab61ee00/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1c60c023ec3b9b5bb85aa68d00667c4ab61ee00/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs?ref=c1c60c023ec3b9b5bb85aa68d00667c4ab61ee00", "patch": "@@ -1,11 +1,10 @@\n-// xfail-test\n-\n fn concat<T: copy>(v: [const [const T]]) -> [T] {\n     let mut r = [];\n \n     // Earlier versions of our type checker accepted this:\n-    for v.each {|inner|\n-        //!^ ERROR found `[const 'a]` (values differ in mutability)\n+    vec::iter(v) {|&&inner: [T]|\n+        //!^ ERROR values differ in mutability\n+        //!^^ ERROR values differ in mutability\n         r += inner;\n     }\n "}, {"sha": "1e9d3954097415d14d66343b6bfb563278555e80", "filename": "src/test/run-pass/regions-borrow.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c1c60c023ec3b9b5bb85aa68d00667c4ab61ee00/src%2Ftest%2Frun-pass%2Fregions-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1c60c023ec3b9b5bb85aa68d00667c4ab61ee00/src%2Ftest%2Frun-pass%2Fregions-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-borrow.rs?ref=c1c60c023ec3b9b5bb85aa68d00667c4ab61ee00", "patch": "@@ -0,0 +1,7 @@\n+fn foo(x: &uint) -> &uint { x }\n+\n+fn main() {\n+    let p = @3u;\n+    let r = foo(p);\n+    assert *p == *r;\n+}\n\\ No newline at end of file"}]}