{"sha": "cdc8f0606d0f3c4f3866643382c8a5776d1bdaed", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkYzhmMDYwNmQwZjNjNGYzODY2NjQzMzgyYzhhNTc3NmQxYmRhZWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-05T21:02:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-05T21:02:18Z"}, "message": "Auto merge of #76217 - RalfJung:maybe-uninit-slice, r=KodrAus\n\nrename MaybeUninit slice methods\n\nThe `first` methods conceptually point to the whole slice, not just its first element, so rename them to be consistent with the raw ptr methods on ref-slices.\n\nAlso, do the equivalent of https://github.com/rust-lang/rust/pull/76047 for the slice reference getters, and make them part of https://github.com/rust-lang/rust/issues/63569 (so far they somehow had no tracking issue).\n\n* first_ptr -> slice_as_ptr\n* first_ptr_mut -> slice_as_mut_ptr\n* slice_get_ref -> slice_assume_init_ref\n* slice_get_mut -> slice_assume_init_mut", "tree": {"sha": "68ebd8e07e6b89ec944ab5d1163eaccee08880f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68ebd8e07e6b89ec944ab5d1163eaccee08880f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cdc8f0606d0f3c4f3866643382c8a5776d1bdaed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cdc8f0606d0f3c4f3866643382c8a5776d1bdaed", "html_url": "https://github.com/rust-lang/rust/commit/cdc8f0606d0f3c4f3866643382c8a5776d1bdaed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cdc8f0606d0f3c4f3866643382c8a5776d1bdaed/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de921ab3c3aa25d65b1476d77285da1ca99af397", "url": "https://api.github.com/repos/rust-lang/rust/commits/de921ab3c3aa25d65b1476d77285da1ca99af397", "html_url": "https://github.com/rust-lang/rust/commit/de921ab3c3aa25d65b1476d77285da1ca99af397"}, {"sha": "35068326b5966530225c8fc01bcdaa0fb4041138", "url": "https://api.github.com/repos/rust-lang/rust/commits/35068326b5966530225c8fc01bcdaa0fb4041138", "html_url": "https://github.com/rust-lang/rust/commit/35068326b5966530225c8fc01bcdaa0fb4041138"}], "stats": {"total": 198, "additions": 119, "deletions": 79}, "files": [{"sha": "1346ad19fe20ab1cbb75a577621a11bf14a08c40", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cdc8f0606d0f3c4f3866643382c8a5776d1bdaed/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdc8f0606d0f3c4f3866643382c8a5776d1bdaed/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=cdc8f0606d0f3c4f3866643382c8a5776d1bdaed", "patch": "@@ -474,11 +474,15 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n     fn into_key_slice(self) -> &'a [K] {\n-        unsafe { slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().keys), self.len()) }\n+        unsafe {\n+            slice::from_raw_parts(MaybeUninit::slice_as_ptr(&self.as_leaf().keys), self.len())\n+        }\n     }\n \n     fn into_val_slice(self) -> &'a [V] {\n-        unsafe { slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().vals), self.len()) }\n+        unsafe {\n+            slice::from_raw_parts(MaybeUninit::slice_as_ptr(&self.as_leaf().vals), self.len())\n+        }\n     }\n }\n \n@@ -493,7 +497,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         // SAFETY: The keys of a node must always be initialized up to length.\n         unsafe {\n             slice::from_raw_parts_mut(\n-                MaybeUninit::first_ptr_mut(&mut (*self.as_leaf_mut()).keys),\n+                MaybeUninit::slice_as_mut_ptr(&mut (*self.as_leaf_mut()).keys),\n                 self.len(),\n             )\n         }\n@@ -503,7 +507,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         // SAFETY: The values of a node must always be initialized up to length.\n         unsafe {\n             slice::from_raw_parts_mut(\n-                MaybeUninit::first_ptr_mut(&mut (*self.as_leaf_mut()).vals),\n+                MaybeUninit::slice_as_mut_ptr(&mut (*self.as_leaf_mut()).vals),\n                 self.len(),\n             )\n         }\n@@ -519,10 +523,10 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         let leaf = self.as_leaf_mut();\n         // SAFETY: The keys and values of a node must always be initialized up to length.\n         let keys = unsafe {\n-            slice::from_raw_parts_mut(MaybeUninit::first_ptr_mut(&mut (*leaf).keys), len)\n+            slice::from_raw_parts_mut(MaybeUninit::slice_as_mut_ptr(&mut (*leaf).keys), len)\n         };\n         let vals = unsafe {\n-            slice::from_raw_parts_mut(MaybeUninit::first_ptr_mut(&mut (*leaf).vals), len)\n+            slice::from_raw_parts_mut(MaybeUninit::slice_as_mut_ptr(&mut (*leaf).vals), len)\n         };\n         (keys, vals)\n     }\n@@ -536,9 +540,9 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::ValMut<'a>, K, V, Type> {\n         let len = self.len();\n         let leaf = self.node.as_ptr();\n         // SAFETY: The keys and values of a node must always be initialized up to length.\n-        let keys = unsafe { slice::from_raw_parts(MaybeUninit::first_ptr(&(*leaf).keys), len) };\n+        let keys = unsafe { slice::from_raw_parts(MaybeUninit::slice_as_ptr(&(*leaf).keys), len) };\n         let vals = unsafe {\n-            slice::from_raw_parts_mut(MaybeUninit::first_ptr_mut(&mut (*leaf).vals), len)\n+            slice::from_raw_parts_mut(MaybeUninit::slice_as_mut_ptr(&mut (*leaf).vals), len)\n         };\n         (keys, vals)\n     }\n@@ -617,7 +621,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n             slice_insert(self.vals_mut(), 0, val);\n             slice_insert(\n                 slice::from_raw_parts_mut(\n-                    MaybeUninit::first_ptr_mut(&mut self.as_internal_mut().edges),\n+                    MaybeUninit::slice_as_mut_ptr(&mut self.as_internal_mut().edges),\n                     self.len() + 1,\n                 ),\n                 0,\n@@ -675,7 +679,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n                 ForceResult::Internal(mut internal) => {\n                     let edge = slice_remove(\n                         slice::from_raw_parts_mut(\n-                            MaybeUninit::first_ptr_mut(&mut internal.as_internal_mut().edges),\n+                            MaybeUninit::slice_as_mut_ptr(&mut internal.as_internal_mut().edges),\n                             old_len + 1,\n                         ),\n                         0,\n@@ -962,7 +966,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n \n             slice_insert(\n                 slice::from_raw_parts_mut(\n-                    MaybeUninit::first_ptr_mut(&mut self.node.as_internal_mut().edges),\n+                    MaybeUninit::slice_as_mut_ptr(&mut self.node.as_internal_mut().edges),\n                     self.node.len(),\n                 ),\n                 self.idx + 1,"}, {"sha": "2e8b6419eea1ef91652cfb3d79a55801b21344ee", "filename": "library/core/src/array/iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cdc8f0606d0f3c4f3866643382c8a5776d1bdaed/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdc8f0606d0f3c4f3866643382c8a5776d1bdaed/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fiter.rs?ref=cdc8f0606d0f3c4f3866643382c8a5776d1bdaed", "patch": "@@ -73,7 +73,7 @@ impl<T, const N: usize> IntoIter<T, N> {\n         // SAFETY: We know that all elements within `alive` are properly initialized.\n         unsafe {\n             let slice = self.data.get_unchecked(self.alive.clone());\n-            MaybeUninit::slice_get_ref(slice)\n+            MaybeUninit::slice_assume_init_ref(slice)\n         }\n     }\n \n@@ -82,7 +82,7 @@ impl<T, const N: usize> IntoIter<T, N> {\n         // SAFETY: We know that all elements within `alive` are properly initialized.\n         unsafe {\n             let slice = self.data.get_unchecked_mut(self.alive.clone());\n-            MaybeUninit::slice_get_mut(slice)\n+            MaybeUninit::slice_assume_init_mut(slice)\n         }\n     }\n }"}, {"sha": "c1d3aca6fdd4fb417d0fde5e9223dbb61db6c908", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cdc8f0606d0f3c4f3866643382c8a5776d1bdaed/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdc8f0606d0f3c4f3866643382c8a5776d1bdaed/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=cdc8f0606d0f3c4f3866643382c8a5776d1bdaed", "patch": "@@ -410,7 +410,7 @@ impl<T, const N: usize> [T; N] {\n         }\n         let mut dst = MaybeUninit::uninit_array::<N>();\n         let mut guard: Guard<U, N> =\n-            Guard { dst: MaybeUninit::first_ptr_mut(&mut dst), initialized: 0 };\n+            Guard { dst: MaybeUninit::slice_as_mut_ptr(&mut dst), initialized: 0 };\n         for (src, dst) in IntoIter::new(self).zip(&mut dst) {\n             dst.write(f(src));\n             guard.initialized += 1;"}, {"sha": "ae3d0ddd46beb8cdc0873bf534dec80effe93641", "filename": "library/core/src/fmt/num.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cdc8f0606d0f3c4f3866643382c8a5776d1bdaed/library%2Fcore%2Fsrc%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdc8f0606d0f3c4f3866643382c8a5776d1bdaed/library%2Fcore%2Fsrc%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fnum.rs?ref=cdc8f0606d0f3c4f3866643382c8a5776d1bdaed", "patch": "@@ -85,7 +85,10 @@ trait GenericRadix {\n         // SAFETY: The only chars in `buf` are created by `Self::digit` which are assumed to be\n         // valid UTF-8\n         let buf = unsafe {\n-            str::from_utf8_unchecked(slice::from_raw_parts(MaybeUninit::first_ptr(buf), buf.len()))\n+            str::from_utf8_unchecked(slice::from_raw_parts(\n+                MaybeUninit::slice_as_ptr(buf),\n+                buf.len(),\n+            ))\n         };\n         f.pad_integral(is_nonnegative, Self::PREFIX, buf)\n     }\n@@ -192,7 +195,7 @@ macro_rules! impl_Display {\n             // 2^128 is about 3*10^38, so 39 gives an extra byte of space\n             let mut buf = [MaybeUninit::<u8>::uninit(); 39];\n             let mut curr = buf.len() as isize;\n-            let buf_ptr = MaybeUninit::first_ptr_mut(&mut buf);\n+            let buf_ptr = MaybeUninit::slice_as_mut_ptr(&mut buf);\n             let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n \n             // SAFETY: Since `d1` and `d2` are always less than or equal to `198`, we\n@@ -322,7 +325,7 @@ macro_rules! impl_Exp {\n             // that `curr >= 0`.\n             let mut buf = [MaybeUninit::<u8>::uninit(); 40];\n             let mut curr = buf.len() as isize; //index for buf\n-            let buf_ptr = MaybeUninit::first_ptr_mut(&mut buf);\n+            let buf_ptr = MaybeUninit::slice_as_mut_ptr(&mut buf);\n             let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n \n             // decode 2 chars at a time\n@@ -370,7 +373,7 @@ macro_rules! impl_Exp {\n \n             // stores 'e' (or 'E') and the up to 2-digit exponent\n             let mut exp_buf = [MaybeUninit::<u8>::uninit(); 3];\n-            let exp_ptr = MaybeUninit::first_ptr_mut(&mut exp_buf);\n+            let exp_ptr = MaybeUninit::slice_as_mut_ptr(&mut exp_buf);\n             // SAFETY: In either case, `exp_buf` is written within bounds and `exp_ptr[..len]`\n             // is contained within `exp_buf` since `len <= 3`.\n             let exp_slice = unsafe {"}, {"sha": "b64abf68c5e4a6184d0af45d889e7f1cba0891f2", "filename": "library/core/src/mem/maybe_uninit.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cdc8f0606d0f3c4f3866643382c8a5776d1bdaed/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdc8f0606d0f3c4f3866643382c8a5776d1bdaed/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs?ref=cdc8f0606d0f3c4f3866643382c8a5776d1bdaed", "patch": "@@ -3,8 +3,6 @@ use crate::fmt;\n use crate::intrinsics;\n use crate::mem::ManuallyDrop;\n \n-// ignore-tidy-undocumented-unsafe\n-\n /// A wrapper type to construct uninitialized instances of `T`.\n ///\n /// # Initialization invariant\n@@ -281,7 +279,7 @@ impl<T> MaybeUninit<T> {\n     /// # Examples\n     ///\n     /// ```no_run\n-    /// #![feature(maybe_uninit_uninit_array, maybe_uninit_extra, maybe_uninit_slice_assume_init)]\n+    /// #![feature(maybe_uninit_uninit_array, maybe_uninit_extra, maybe_uninit_slice)]\n     ///\n     /// use std::mem::MaybeUninit;\n     ///\n@@ -293,7 +291,7 @@ impl<T> MaybeUninit<T> {\n     /// fn read(buf: &mut [MaybeUninit<u8>]) -> &[u8] {\n     ///     unsafe {\n     ///         let len = read_into_buffer(buf.as_mut_ptr() as *mut u8, buf.len());\n-    ///         MaybeUninit::slice_get_ref(&buf[..len])\n+    ///         MaybeUninit::slice_assume_init_ref(&buf[..len])\n     ///     }\n     /// }\n     ///\n@@ -303,6 +301,7 @@ impl<T> MaybeUninit<T> {\n     #[unstable(feature = \"maybe_uninit_uninit_array\", issue = \"none\")]\n     #[inline(always)]\n     pub fn uninit_array<const LEN: usize>() -> [Self; LEN] {\n+        // SAFETY: An uninitialized `[MaybeUninit<_>; LEN]` is valid.\n         unsafe { MaybeUninit::<[MaybeUninit<T>; LEN]>::uninit().assume_init() }\n     }\n \n@@ -354,6 +353,7 @@ impl<T> MaybeUninit<T> {\n     #[rustc_diagnostic_item = \"maybe_uninit_zeroed\"]\n     pub fn zeroed() -> MaybeUninit<T> {\n         let mut u = MaybeUninit::<T>::uninit();\n+        // SAFETY: `u.as_mut_ptr()` points to allocated memory.\n         unsafe {\n             u.as_mut_ptr().write_bytes(0u8, 1);\n         }\n@@ -367,10 +367,9 @@ impl<T> MaybeUninit<T> {\n     #[unstable(feature = \"maybe_uninit_extra\", issue = \"63567\")]\n     #[inline(always)]\n     pub fn write(&mut self, val: T) -> &mut T {\n-        unsafe {\n-            self.value = ManuallyDrop::new(val);\n-            self.assume_init_mut()\n-        }\n+        *self = MaybeUninit::new(val);\n+        // SAFETY: We just initialized this value.\n+        unsafe { self.assume_init_mut() }\n     }\n \n     /// Gets a pointer to the contained value. Reading from this pointer or turning it\n@@ -769,9 +768,13 @@ impl<T> MaybeUninit<T> {\n     /// It is up to the caller to guarantee that the `MaybeUninit<T>` elements\n     /// really are in an initialized state.\n     /// Calling this when the content is not yet fully initialized causes undefined behavior.\n-    #[unstable(feature = \"maybe_uninit_slice_assume_init\", issue = \"none\")]\n+    ///\n+    /// See [`assume_init_ref`] for more details and examples.\n+    ///\n+    /// [`assume_init_ref`]: MaybeUninit::assume_init_ref\n+    #[unstable(feature = \"maybe_uninit_slice\", issue = \"63569\")]\n     #[inline(always)]\n-    pub unsafe fn slice_get_ref(slice: &[Self]) -> &[T] {\n+    pub unsafe fn slice_assume_init_ref(slice: &[Self]) -> &[T] {\n         // SAFETY: casting slice to a `*const [T]` is safe since the caller guarantees that\n         // `slice` is initialized, and`MaybeUninit` is guaranteed to have the same layout as `T`.\n         // The pointer obtained is valid since it refers to memory owned by `slice` which is a\n@@ -786,9 +789,13 @@ impl<T> MaybeUninit<T> {\n     /// It is up to the caller to guarantee that the `MaybeUninit<T>` elements\n     /// really are in an initialized state.\n     /// Calling this when the content is not yet fully initialized causes undefined behavior.\n-    #[unstable(feature = \"maybe_uninit_slice_assume_init\", issue = \"none\")]\n+    ///\n+    /// See [`assume_init_mut`] for more details and examples.\n+    ///\n+    /// [`assume_init_mut`]: MaybeUninit::assume_init_mut\n+    #[unstable(feature = \"maybe_uninit_slice\", issue = \"63569\")]\n     #[inline(always)]\n-    pub unsafe fn slice_get_mut(slice: &mut [Self]) -> &mut [T] {\n+    pub unsafe fn slice_assume_init_mut(slice: &mut [Self]) -> &mut [T] {\n         // SAFETY: similar to safety notes for `slice_get_ref`, but we have a\n         // mutable reference which is also guaranteed to be valid for writes.\n         unsafe { &mut *(slice as *mut [Self] as *mut [T]) }\n@@ -797,14 +804,14 @@ impl<T> MaybeUninit<T> {\n     /// Gets a pointer to the first element of the array.\n     #[unstable(feature = \"maybe_uninit_slice\", issue = \"63569\")]\n     #[inline(always)]\n-    pub fn first_ptr(this: &[MaybeUninit<T>]) -> *const T {\n+    pub fn slice_as_ptr(this: &[MaybeUninit<T>]) -> *const T {\n         this as *const [MaybeUninit<T>] as *const T\n     }\n \n     /// Gets a mutable pointer to the first element of the array.\n     #[unstable(feature = \"maybe_uninit_slice\", issue = \"63569\")]\n     #[inline(always)]\n-    pub fn first_ptr_mut(this: &mut [MaybeUninit<T>]) -> *mut T {\n+    pub fn slice_as_mut_ptr(this: &mut [MaybeUninit<T>]) -> *mut T {\n         this as *mut [MaybeUninit<T>] as *mut T\n     }\n }"}, {"sha": "e8f9d6574e2d011e0bde19ed715ade208b28f360", "filename": "library/core/src/num/flt2dec/mod.rs", "status": "modified", "additions": 56, "deletions": 32, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/cdc8f0606d0f3c4f3866643382c8a5776d1bdaed/library%2Fcore%2Fsrc%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdc8f0606d0f3c4f3866643382c8a5776d1bdaed/library%2Fcore%2Fsrc%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fflt2dec%2Fmod.rs?ref=cdc8f0606d0f3c4f3866643382c8a5776d1bdaed", "patch": "@@ -311,10 +311,10 @@ fn digits_to_dec_str<'a>(\n         if frac_digits > buf.len() && frac_digits - buf.len() > minus_exp {\n             parts[3] = MaybeUninit::new(Part::Zero((frac_digits - buf.len()) - minus_exp));\n             // SAFETY: we just initialized the elements `..4`.\n-            unsafe { MaybeUninit::slice_get_ref(&parts[..4]) }\n+            unsafe { MaybeUninit::slice_assume_init_ref(&parts[..4]) }\n         } else {\n             // SAFETY: we just initialized the elements `..3`.\n-            unsafe { MaybeUninit::slice_get_ref(&parts[..3]) }\n+            unsafe { MaybeUninit::slice_assume_init_ref(&parts[..3]) }\n         }\n     } else {\n         let exp = exp as usize;\n@@ -326,10 +326,10 @@ fn digits_to_dec_str<'a>(\n             if frac_digits > buf.len() - exp {\n                 parts[3] = MaybeUninit::new(Part::Zero(frac_digits - (buf.len() - exp)));\n                 // SAFETY: we just initialized the elements `..4`.\n-                unsafe { MaybeUninit::slice_get_ref(&parts[..4]) }\n+                unsafe { MaybeUninit::slice_assume_init_ref(&parts[..4]) }\n             } else {\n                 // SAFETY: we just initialized the elements `..3`.\n-                unsafe { MaybeUninit::slice_get_ref(&parts[..3]) }\n+                unsafe { MaybeUninit::slice_assume_init_ref(&parts[..3]) }\n             }\n         } else {\n             // the decimal point is after rendered digits: [1234][____0000] or [1234][__][.][__].\n@@ -339,10 +339,10 @@ fn digits_to_dec_str<'a>(\n                 parts[2] = MaybeUninit::new(Part::Copy(b\".\"));\n                 parts[3] = MaybeUninit::new(Part::Zero(frac_digits));\n                 // SAFETY: we just initialized the elements `..4`.\n-                unsafe { MaybeUninit::slice_get_ref(&parts[..4]) }\n+                unsafe { MaybeUninit::slice_assume_init_ref(&parts[..4]) }\n             } else {\n                 // SAFETY: we just initialized the elements `..2`.\n-                unsafe { MaybeUninit::slice_get_ref(&parts[..2]) }\n+                unsafe { MaybeUninit::slice_assume_init_ref(&parts[..2]) }\n             }\n         }\n     }\n@@ -393,7 +393,7 @@ fn digits_to_exp_str<'a>(\n         parts[n + 1] = MaybeUninit::new(Part::Num(exp as u16));\n     }\n     // SAFETY: we just initialized the elements `..n + 2`.\n-    unsafe { MaybeUninit::slice_get_ref(&parts[..n + 2]) }\n+    unsafe { MaybeUninit::slice_assume_init_ref(&parts[..n + 2]) }\n }\n \n /// Sign formatting options.\n@@ -487,24 +487,30 @@ where\n         FullDecoded::Nan => {\n             parts[0] = MaybeUninit::new(Part::Copy(b\"NaN\"));\n             // SAFETY: we just initialized the elements `..1`.\n-            Formatted { sign, parts: unsafe { MaybeUninit::slice_get_ref(&parts[..1]) } }\n+            Formatted { sign, parts: unsafe { MaybeUninit::slice_assume_init_ref(&parts[..1]) } }\n         }\n         FullDecoded::Infinite => {\n             parts[0] = MaybeUninit::new(Part::Copy(b\"inf\"));\n             // SAFETY: we just initialized the elements `..1`.\n-            Formatted { sign, parts: unsafe { MaybeUninit::slice_get_ref(&parts[..1]) } }\n+            Formatted { sign, parts: unsafe { MaybeUninit::slice_assume_init_ref(&parts[..1]) } }\n         }\n         FullDecoded::Zero => {\n             if frac_digits > 0 {\n                 // [0.][0000]\n                 parts[0] = MaybeUninit::new(Part::Copy(b\"0.\"));\n                 parts[1] = MaybeUninit::new(Part::Zero(frac_digits));\n-                // SAFETY: we just initialized the elements `..2`.\n-                Formatted { sign, parts: unsafe { MaybeUninit::slice_get_ref(&parts[..2]) } }\n+                Formatted {\n+                    sign,\n+                    // SAFETY: we just initialized the elements `..2`.\n+                    parts: unsafe { MaybeUninit::slice_assume_init_ref(&parts[..2]) },\n+                }\n             } else {\n                 parts[0] = MaybeUninit::new(Part::Copy(b\"0\"));\n-                // SAFETY: we just initialized the elements `..1`.\n-                Formatted { sign, parts: unsafe { MaybeUninit::slice_get_ref(&parts[..1]) } }\n+                Formatted {\n+                    sign,\n+                    // SAFETY: we just initialized the elements `..1`.\n+                    parts: unsafe { MaybeUninit::slice_assume_init_ref(&parts[..1]) },\n+                }\n             }\n         }\n         FullDecoded::Finite(ref decoded) => {\n@@ -557,12 +563,12 @@ where\n         FullDecoded::Nan => {\n             parts[0] = MaybeUninit::new(Part::Copy(b\"NaN\"));\n             // SAFETY: we just initialized the elements `..1`.\n-            Formatted { sign, parts: unsafe { MaybeUninit::slice_get_ref(&parts[..1]) } }\n+            Formatted { sign, parts: unsafe { MaybeUninit::slice_assume_init_ref(&parts[..1]) } }\n         }\n         FullDecoded::Infinite => {\n             parts[0] = MaybeUninit::new(Part::Copy(b\"inf\"));\n             // SAFETY: we just initialized the elements `..1`.\n-            Formatted { sign, parts: unsafe { MaybeUninit::slice_get_ref(&parts[..1]) } }\n+            Formatted { sign, parts: unsafe { MaybeUninit::slice_assume_init_ref(&parts[..1]) } }\n         }\n         FullDecoded::Zero => {\n             parts[0] = if dec_bounds.0 <= 0 && 0 < dec_bounds.1 {\n@@ -571,7 +577,7 @@ where\n                 MaybeUninit::new(Part::Copy(if upper { b\"0E0\" } else { b\"0e0\" }))\n             };\n             // SAFETY: we just initialized the elements `..1`.\n-            Formatted { sign, parts: unsafe { MaybeUninit::slice_get_ref(&parts[..1]) } }\n+            Formatted { sign, parts: unsafe { MaybeUninit::slice_assume_init_ref(&parts[..1]) } }\n         }\n         FullDecoded::Finite(ref decoded) => {\n             let (buf, exp) = format_shortest(decoded, buf);\n@@ -648,25 +654,31 @@ where\n         FullDecoded::Nan => {\n             parts[0] = MaybeUninit::new(Part::Copy(b\"NaN\"));\n             // SAFETY: we just initialized the elements `..1`.\n-            Formatted { sign, parts: unsafe { MaybeUninit::slice_get_ref(&parts[..1]) } }\n+            Formatted { sign, parts: unsafe { MaybeUninit::slice_assume_init_ref(&parts[..1]) } }\n         }\n         FullDecoded::Infinite => {\n             parts[0] = MaybeUninit::new(Part::Copy(b\"inf\"));\n             // SAFETY: we just initialized the elements `..1`.\n-            Formatted { sign, parts: unsafe { MaybeUninit::slice_get_ref(&parts[..1]) } }\n+            Formatted { sign, parts: unsafe { MaybeUninit::slice_assume_init_ref(&parts[..1]) } }\n         }\n         FullDecoded::Zero => {\n             if ndigits > 1 {\n                 // [0.][0000][e0]\n                 parts[0] = MaybeUninit::new(Part::Copy(b\"0.\"));\n                 parts[1] = MaybeUninit::new(Part::Zero(ndigits - 1));\n                 parts[2] = MaybeUninit::new(Part::Copy(if upper { b\"E0\" } else { b\"e0\" }));\n-                // SAFETY: we just initialized the elements `..3`.\n-                Formatted { sign, parts: unsafe { MaybeUninit::slice_get_ref(&parts[..3]) } }\n+                Formatted {\n+                    sign,\n+                    // SAFETY: we just initialized the elements `..3`.\n+                    parts: unsafe { MaybeUninit::slice_assume_init_ref(&parts[..3]) },\n+                }\n             } else {\n                 parts[0] = MaybeUninit::new(Part::Copy(if upper { b\"0E0\" } else { b\"0e0\" }));\n-                // SAFETY: we just initialized the elements `..1`.\n-                Formatted { sign, parts: unsafe { MaybeUninit::slice_get_ref(&parts[..1]) } }\n+                Formatted {\n+                    sign,\n+                    // SAFETY: we just initialized the elements `..1`.\n+                    parts: unsafe { MaybeUninit::slice_assume_init_ref(&parts[..1]) },\n+                }\n             }\n         }\n         FullDecoded::Finite(ref decoded) => {\n@@ -716,24 +728,30 @@ where\n         FullDecoded::Nan => {\n             parts[0] = MaybeUninit::new(Part::Copy(b\"NaN\"));\n             // SAFETY: we just initialized the elements `..1`.\n-            Formatted { sign, parts: unsafe { MaybeUninit::slice_get_ref(&parts[..1]) } }\n+            Formatted { sign, parts: unsafe { MaybeUninit::slice_assume_init_ref(&parts[..1]) } }\n         }\n         FullDecoded::Infinite => {\n             parts[0] = MaybeUninit::new(Part::Copy(b\"inf\"));\n             // SAFETY: we just initialized the elements `..1`.\n-            Formatted { sign, parts: unsafe { MaybeUninit::slice_get_ref(&parts[..1]) } }\n+            Formatted { sign, parts: unsafe { MaybeUninit::slice_assume_init_ref(&parts[..1]) } }\n         }\n         FullDecoded::Zero => {\n             if frac_digits > 0 {\n                 // [0.][0000]\n                 parts[0] = MaybeUninit::new(Part::Copy(b\"0.\"));\n                 parts[1] = MaybeUninit::new(Part::Zero(frac_digits));\n-                // SAFETY: we just initialized the elements `..2`.\n-                Formatted { sign, parts: unsafe { MaybeUninit::slice_get_ref(&parts[..2]) } }\n+                Formatted {\n+                    sign,\n+                    // SAFETY: we just initialized the elements `..2`.\n+                    parts: unsafe { MaybeUninit::slice_assume_init_ref(&parts[..2]) },\n+                }\n             } else {\n                 parts[0] = MaybeUninit::new(Part::Copy(b\"0\"));\n-                // SAFETY: we just initialized the elements `..1`.\n-                Formatted { sign, parts: unsafe { MaybeUninit::slice_get_ref(&parts[..1]) } }\n+                Formatted {\n+                    sign,\n+                    // SAFETY: we just initialized the elements `..1`.\n+                    parts: unsafe { MaybeUninit::slice_assume_init_ref(&parts[..1]) },\n+                }\n             }\n         }\n         FullDecoded::Finite(ref decoded) => {\n@@ -754,12 +772,18 @@ where\n                     // [0.][0000]\n                     parts[0] = MaybeUninit::new(Part::Copy(b\"0.\"));\n                     parts[1] = MaybeUninit::new(Part::Zero(frac_digits));\n-                    // SAFETY: we just initialized the elements `..2`.\n-                    Formatted { sign, parts: unsafe { MaybeUninit::slice_get_ref(&parts[..2]) } }\n+                    Formatted {\n+                        sign,\n+                        // SAFETY: we just initialized the elements `..2`.\n+                        parts: unsafe { MaybeUninit::slice_assume_init_ref(&parts[..2]) },\n+                    }\n                 } else {\n                     parts[0] = MaybeUninit::new(Part::Copy(b\"0\"));\n-                    // SAFETY: we just initialized the elements `..1`.\n-                    Formatted { sign, parts: unsafe { MaybeUninit::slice_get_ref(&parts[..1]) } }\n+                    Formatted {\n+                        sign,\n+                        // SAFETY: we just initialized the elements `..1`.\n+                        parts: unsafe { MaybeUninit::slice_assume_init_ref(&parts[..1]) },\n+                    }\n                 }\n             } else {\n                 Formatted { sign, parts: digits_to_dec_str(buf, exp, frac_digits, parts) }"}, {"sha": "8ced5971ec2f95f85eeea84c9e1b9023b201c78c", "filename": "library/core/src/num/flt2dec/strategy/dragon.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cdc8f0606d0f3c4f3866643382c8a5776d1bdaed/library%2Fcore%2Fsrc%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdc8f0606d0f3c4f3866643382c8a5776d1bdaed/library%2Fcore%2Fsrc%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs?ref=cdc8f0606d0f3c4f3866643382c8a5776d1bdaed", "patch": "@@ -246,15 +246,15 @@ pub fn format_shortest<'a>(\n         // it seems that this condition is very hard to satisfy (possibly impossible),\n         // but we are just being safe and consistent here.\n         // SAFETY: we initialized that memory above.\n-        if let Some(c) = round_up(unsafe { MaybeUninit::slice_get_mut(&mut buf[..i]) }) {\n+        if let Some(c) = round_up(unsafe { MaybeUninit::slice_assume_init_mut(&mut buf[..i]) }) {\n             buf[i] = MaybeUninit::new(c);\n             i += 1;\n             k += 1;\n         }\n     }\n \n     // SAFETY: we initialized that memory above.\n-    (unsafe { MaybeUninit::slice_get_ref(&buf[..i]) }, k)\n+    (unsafe { MaybeUninit::slice_assume_init_ref(&buf[..i]) }, k)\n }\n \n /// The exact and fixed mode implementation for Dragon.\n@@ -332,7 +332,7 @@ pub fn format_exact<'a>(\n                     *c = MaybeUninit::new(b'0');\n                 }\n                 // SAFETY: we initialized that memory above.\n-                return (unsafe { MaybeUninit::slice_get_ref(&buf[..len]) }, k);\n+                return (unsafe { MaybeUninit::slice_assume_init_ref(&buf[..len]) }, k);\n             }\n \n             let mut d = 0;\n@@ -371,7 +371,7 @@ pub fn format_exact<'a>(\n         // if rounding up changes the length, the exponent should also change.\n         // but we've been requested a fixed number of digits, so do not alter the buffer...\n         // SAFETY: we initialized that memory above.\n-        if let Some(c) = round_up(unsafe { MaybeUninit::slice_get_mut(&mut buf[..len]) }) {\n+        if let Some(c) = round_up(unsafe { MaybeUninit::slice_assume_init_mut(&mut buf[..len]) }) {\n             // ...unless we've been requested the fixed precision instead.\n             // we also need to check that, if the original buffer was empty,\n             // the additional digit can only be added when `k == limit` (edge case).\n@@ -384,5 +384,5 @@ pub fn format_exact<'a>(\n     }\n \n     // SAFETY: we initialized that memory above.\n-    (unsafe { MaybeUninit::slice_get_ref(&buf[..len]) }, k)\n+    (unsafe { MaybeUninit::slice_assume_init_ref(&buf[..len]) }, k)\n }"}, {"sha": "a4cb51c6297af0a2cc7be8a87d2c35851ce5b289", "filename": "library/core/src/num/flt2dec/strategy/grisu.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cdc8f0606d0f3c4f3866643382c8a5776d1bdaed/library%2Fcore%2Fsrc%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdc8f0606d0f3c4f3866643382c8a5776d1bdaed/library%2Fcore%2Fsrc%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs?ref=cdc8f0606d0f3c4f3866643382c8a5776d1bdaed", "patch": "@@ -276,7 +276,7 @@ pub fn format_shortest_opt<'a>(\n             let ten_kappa = (ten_kappa as u64) << e; // scale 10^kappa back to the shared exponent\n             return round_and_weed(\n                 // SAFETY: we initialized that memory above.\n-                unsafe { MaybeUninit::slice_get_mut(&mut buf[..i]) },\n+                unsafe { MaybeUninit::slice_assume_init_mut(&mut buf[..i]) },\n                 exp,\n                 plus1rem,\n                 delta1,\n@@ -327,7 +327,7 @@ pub fn format_shortest_opt<'a>(\n             let ten_kappa = 1 << e; // implicit divisor\n             return round_and_weed(\n                 // SAFETY: we initialized that memory above.\n-                unsafe { MaybeUninit::slice_get_mut(&mut buf[..i]) },\n+                unsafe { MaybeUninit::slice_assume_init_mut(&mut buf[..i]) },\n                 exp,\n                 r,\n                 threshold,\n@@ -701,7 +701,7 @@ pub fn format_exact_opt<'a>(\n         // `10^kappa` did not overflow after all, the second check is fine.\n         if ten_kappa - remainder > remainder && ten_kappa - 2 * remainder >= 2 * ulp {\n             // SAFETY: our caller initialized that memory.\n-            return Some((unsafe { MaybeUninit::slice_get_ref(&buf[..len]) }, exp));\n+            return Some((unsafe { MaybeUninit::slice_assume_init_ref(&buf[..len]) }, exp));\n         }\n \n         //   :<------- remainder ------>|   :\n@@ -722,8 +722,10 @@ pub fn format_exact_opt<'a>(\n         // as `10^kappa` is never zero). also note that `remainder - ulp <= 10^kappa`,\n         // so the second check does not overflow.\n         if remainder > ulp && ten_kappa - (remainder - ulp) <= remainder - ulp {\n-            // SAFETY: our caller must have initialized that memory.\n-            if let Some(c) = round_up(unsafe { MaybeUninit::slice_get_mut(&mut buf[..len]) }) {\n+            if let Some(c) =\n+                // SAFETY: our caller must have initialized that memory.\n+                round_up(unsafe { MaybeUninit::slice_assume_init_mut(&mut buf[..len]) })\n+            {\n                 // only add an additional digit when we've been requested the fixed precision.\n                 // we also need to check that, if the original buffer was empty,\n                 // the additional digit can only be added when `exp == limit` (edge case).\n@@ -734,7 +736,7 @@ pub fn format_exact_opt<'a>(\n                 }\n             }\n             // SAFETY: we and our caller initialized that memory.\n-            return Some((unsafe { MaybeUninit::slice_get_ref(&buf[..len]) }, exp));\n+            return Some((unsafe { MaybeUninit::slice_assume_init_ref(&buf[..len]) }, exp));\n         }\n \n         // otherwise we are doomed (i.e., some values between `v - 1 ulp` and `v + 1 ulp` are"}, {"sha": "4a00124fcff3e764455d26116c251d3cee59b917", "filename": "library/core/src/slice/sort.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cdc8f0606d0f3c4f3866643382c8a5776d1bdaed/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdc8f0606d0f3c4f3866643382c8a5776d1bdaed/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs?ref=cdc8f0606d0f3c4f3866643382c8a5776d1bdaed", "patch": "@@ -299,8 +299,8 @@ where\n \n         if start_l == end_l {\n             // Trace `block_l` elements from the left side.\n-            start_l = MaybeUninit::first_ptr_mut(&mut offsets_l);\n-            end_l = MaybeUninit::first_ptr_mut(&mut offsets_l);\n+            start_l = MaybeUninit::slice_as_mut_ptr(&mut offsets_l);\n+            end_l = MaybeUninit::slice_as_mut_ptr(&mut offsets_l);\n             let mut elem = l;\n \n             for i in 0..block_l {\n@@ -325,8 +325,8 @@ where\n \n         if start_r == end_r {\n             // Trace `block_r` elements from the right side.\n-            start_r = MaybeUninit::first_ptr_mut(&mut offsets_r);\n-            end_r = MaybeUninit::first_ptr_mut(&mut offsets_r);\n+            start_r = MaybeUninit::slice_as_mut_ptr(&mut offsets_r);\n+            end_r = MaybeUninit::slice_as_mut_ptr(&mut offsets_r);\n             let mut elem = r;\n \n             for i in 0..block_r {"}]}