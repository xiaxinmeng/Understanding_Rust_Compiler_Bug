{"sha": "c4155f5ea37b9921eff310d9ca06402d0bb9b0f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0MTU1ZjVlYTM3Yjk5MjFlZmYzMTBkOWNhMDY0MDJkMGJiOWIwZjY=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-09-19T05:54:08Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-13T03:43:38Z"}, "message": "Change the kind checker to ignore results of last-use\n\nand require explicit moves.\n\nAlso provide more info in some error messages.\n\nAlso: check that non-copyable struct fields don't get copied.\nCloses #3481", "tree": {"sha": "4275cc023f5324091cca8e5135724a00ff20b469", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4275cc023f5324091cca8e5135724a00ff20b469"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4155f5ea37b9921eff310d9ca06402d0bb9b0f6", "comment_count": 2, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4155f5ea37b9921eff310d9ca06402d0bb9b0f6", "html_url": "https://github.com/rust-lang/rust/commit/c4155f5ea37b9921eff310d9ca06402d0bb9b0f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4155f5ea37b9921eff310d9ca06402d0bb9b0f6/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9abc7f0a1cb5086fa6d9a38841258859a16cbdfe", "url": "https://api.github.com/repos/rust-lang/rust/commits/9abc7f0a1cb5086fa6d9a38841258859a16cbdfe", "html_url": "https://github.com/rust-lang/rust/commit/9abc7f0a1cb5086fa6d9a38841258859a16cbdfe"}], "stats": {"total": 86, "additions": 49, "deletions": 37}, "files": [{"sha": "edd3c6453586826fae7433cbb2ab152a8408b88c", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 49, "deletions": 37, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/c4155f5ea37b9921eff310d9ca06402d0bb9b0f6/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4155f5ea37b9921eff310d9ca06402d0bb9b0f6/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=c4155f5ea37b9921eff310d9ca06402d0bb9b0f6", "patch": "@@ -89,8 +89,11 @@ fn check_crate(tcx: ty::ctxt,\n     tcx.sess.abort_if_errors();\n }\n \n+// bool flag is only used for checking closures,\n+// where it refers to whether a var is 'move' in the\n+// capture clause\n type check_fn = fn@(ctx, node_id, Option<@freevar_entry>,\n-                    bool, ty::t, sp: span);\n+                   bool, ty::t, sp: span);\n \n // Yields the appropriate function to check the kind of closed over\n // variables. `id` is the node_id for some expression that creates the\n@@ -111,7 +114,6 @@ fn with_appropriate_checker(cx: ctx, id: node_id, b: fn(check_fn)) {\n                              \"to copy values into a ~fn closure, use a \\\n                               capture clause: `fn~(copy x)` or `|copy x|`\")));\n         }\n-\n         // check that only immutable variables are implicitly copied in\n         for fv.each |fv| {\n             check_imm_free_var(cx, fv.def, fv.span);\n@@ -132,7 +134,6 @@ fn with_appropriate_checker(cx: ctx, id: node_id, b: fn(check_fn)) {\n                              \"to copy values into a @fn closure, use a \\\n                               capture clause: `fn~(copy x)` or `|copy x|`\")));\n         }\n-\n         // check that only immutable variables are implicitly copied in\n         for fv.each |fv| {\n             check_imm_free_var(cx, fv.def, fv.span);\n@@ -151,7 +152,7 @@ fn with_appropriate_checker(cx: ctx, id: node_id, b: fn(check_fn)) {\n     }\n \n     fn check_for_bare(cx: ctx, _id: node_id, _fv: Option<@freevar_entry>,\n-                      _is_move: bool,_var_t: ty::t, sp: span) {\n+                      _is_move: bool, _var_t: ty::t, sp: span) {\n         cx.tcx.sess.span_err(sp, ~\"attempted dynamic environment capture\");\n     }\n \n@@ -189,6 +190,7 @@ fn check_fn(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n             let cap_def = cx.tcx.def_map.get(cap_item.id);\n             let cap_def_id = ast_util::def_id_of_def(cap_def).node;\n             let ty = ty::node_id_to_type(cx.tcx, cap_def_id);\n+            // Here's where is_move isn't always false...\n             chk(cx, fn_id, None, cap_item.is_move, ty, cap_item.span);\n             cap_def_id\n         };\n@@ -201,17 +203,10 @@ fn check_fn(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n             // skip over free variables that appear in the cap clause\n             if captured_vars.contains(&id) { loop; }\n \n-            // if this is the last use of the variable, then it will be\n-            // a move and not a copy\n-            let is_move = {\n-                match cx.last_use_map.find(fn_id) {\n-                  Some(vars) => (*vars).contains(&id),\n-                  None => false\n-                }\n-            };\n-\n             let ty = ty::node_id_to_type(cx.tcx, id);\n-            chk(cx, fn_id, Some(*fv), is_move, ty, fv.span);\n+            // is_move is always false here. See the let captured_vars...\n+            // code above for where it's not always false.\n+            chk(cx, fn_id, Some(*fv), false, ty, fv.span);\n         }\n     }\n \n@@ -220,7 +215,9 @@ fn check_fn(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n \n fn check_block(b: blk, cx: ctx, v: visit::vt<ctx>) {\n     match b.node.expr {\n-      Some(ex) => maybe_copy(cx, ex, None),\n+      Some(ex) => maybe_copy(cx, ex,\n+         Some((\"Tail expressions in blocks must be copyable\",\n+                                   \"(Try adding a move)\"))),\n       _ => ()\n     }\n     visit::visit_block(b, cx, v);\n@@ -281,33 +278,45 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n       expr_assign(_, ex) |\n       expr_unary(box(_), ex) | expr_unary(uniq(_), ex) |\n       expr_ret(Some(ex)) => {\n-        maybe_copy(cx, ex, None);\n+        maybe_copy(cx, ex, Some((\"Returned values must be copyable\",\n+                                 \"Try adding a move\")));\n       }\n       expr_cast(source, _) => {\n-        maybe_copy(cx, source, None);\n+        maybe_copy(cx, source, Some((\"Casted values must be copyable\",\n+                                     \"Try adding a move\")));\n         check_cast_for_escaping_regions(cx, source, e);\n       }\n-      expr_copy(expr) => check_copy_ex(cx, expr, false, None),\n+      expr_copy(expr) => check_copy_ex(cx, expr, false,\n+          Some((\"Explicit copy requires a copyable argument\", \"\"))),\n       // Vector add copies, but not \"implicitly\"\n-      expr_assign_op(_, _, ex) => check_copy_ex(cx, ex, false, None),\n+      expr_assign_op(_, _, ex) => check_copy_ex(cx, ex, false,\n+                                   Some((\"Assignment with operation requires \\\n+                                          a copyable argument\", \"\"))),\n       expr_binary(add, ls, rs) => {\n-        check_copy_ex(cx, ls, false, None);\n-        check_copy_ex(cx, rs, false, None);\n+        let reason = Some((\"Binary operators require copyable arguments\",\n+                           \"\"));\n+        check_copy_ex(cx, ls, false, reason);\n+        check_copy_ex(cx, rs, false, reason);\n       }\n-      expr_rec(fields, def) => {\n-        for fields.each |field| { maybe_copy(cx, field.node.expr, None); }\n+      expr_rec(fields, def) | expr_struct(_, fields, def) => {\n+        for fields.each |field| { maybe_copy(cx, field.node.expr,\n+                                   Some((\"Record or struct fields require \\\n+                                          copyable arguments\", \"\"))); }\n         match def {\n           Some(ex) => {\n             // All noncopyable fields must be overridden\n             let t = ty::expr_ty(cx.tcx, ex);\n             let ty_fields = match ty::get(t).sty {\n               ty::ty_rec(f) => f,\n-              _ => cx.tcx.sess.span_bug(ex.span, ~\"bad expr type in record\")\n+              ty::ty_class(did, substs) =>\n+                  ty::class_items_as_fields(cx.tcx, did, &substs),\n+              _ => cx.tcx.sess.span_bug(ex.span,\n+                                        ~\"bad base expr type in record\")\n             };\n             for ty_fields.each |tf| {\n                 if !vec::any(fields, |f| f.node.ident == tf.ident ) &&\n                     !ty::kind_can_be_copied(ty::type_kind(cx.tcx, tf.mt.ty)) {\n-                    cx.tcx.sess.span_err(ex.span,\n+                    cx.tcx.sess.span_err(e.span,\n                                          ~\"copying a noncopyable value\");\n                 }\n             }\n@@ -316,16 +325,16 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n         }\n       }\n       expr_tup(exprs) | expr_vec(exprs, _) => {\n-        for exprs.each |expr| { maybe_copy(cx, *expr, None); }\n+        for exprs.each |expr| { maybe_copy(cx, *expr,\n+                    Some((\"Tuple or vec elements must be copyable\", \"\"))); }\n       }\n       expr_call(f, args, _) => {\n-        let mut i = 0u;\n-        for ty::ty_fn_args(ty::expr_ty(cx.tcx, f)).each |arg_t| {\n+        for ty::ty_fn_args(ty::expr_ty(cx.tcx, f)).eachi |i, arg_t| {\n             match ty::arg_mode(cx.tcx, *arg_t) {\n-              by_copy => maybe_copy(cx, args[i], None),\n+              by_copy => maybe_copy(cx, args[i],\n+                     Some((\"Callee takes its argument by copy\", \"\"))),\n               by_ref | by_val | by_move => ()\n             }\n-            i += 1u;\n         }\n       }\n       expr_field(lhs, _, _) => {\n@@ -334,7 +343,9 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n         match cx.method_map.find(e.id) {\n             Some(ref mme) => {\n                 match ty::arg_mode(cx.tcx, mme.self_arg) {\n-                    by_copy => maybe_copy(cx, lhs, None),\n+                    by_copy => maybe_copy(cx, lhs,\n+                      Some((\"Method call takes its self argument by copy\",\n+                            \"\"))),\n                     by_ref | by_val | by_move => ()\n                 }\n             }\n@@ -344,10 +355,12 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n       expr_repeat(element, count_expr, _) => {\n         let count = ty::eval_repeat_count(cx.tcx, count_expr, e.span);\n         if count == 1 {\n-            maybe_copy(cx, element, None);\n+            maybe_copy(cx, element, Some((\"Trivial repeat takes its element \\\n+                                           by copy\", \"\")));\n         } else {\n             let element_ty = ty::expr_ty(cx.tcx, element);\n-            check_copy(cx, element.id, element_ty, element.span, true, None);\n+            check_copy(cx, element.id, element_ty, element.span, true,\n+                       Some((\"Repeat takes its elements by copy\", \"\")));\n         }\n       }\n       _ => { }\n@@ -360,7 +373,9 @@ fn check_stmt(stmt: @stmt, cx: ctx, v: visit::vt<ctx>) {\n       stmt_decl(@{node: decl_local(locals), _}, _) => {\n         for locals.each |local| {\n             match local.node.init {\n-              Some({op: init_assign, expr}) => maybe_copy(cx, expr, None),\n+              Some({op: init_assign, expr}) =>\n+                  maybe_copy(cx, expr, Some((\"Initializer statement \\\n+                              takes its right-hand side by copy\", \"\"))),\n               _ => {}\n             }\n         }\n@@ -434,9 +449,6 @@ fn check_copy_ex(cx: ctx, ex: @expr, implicit_copy: bool,\n                  why: Option<(&str,&str)>) {\n     if ty::expr_is_lval(cx.tcx, cx.method_map, ex) &&\n \n-        // this is a move\n-        !cx.last_use_map.contains_key(ex.id) &&\n-\n         // a reference to a constant like `none`... no need to warn\n         // about *this* even if the type is Option<~int>\n         !is_nullary_variant(cx, ex) &&"}]}