{"sha": "8e8aa7bb26c831e6e81a67e2e0f873de0a4f9de5", "node_id": "C_kwDOAAsO6NoAKDhlOGFhN2JiMjZjODMxZTZlODFhNjdlMmUwZjg3M2RlMGE0ZjlkZTU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-23T15:04:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-23T15:04:12Z"}, "message": "Auto merge of #12358 - Veykril:hl-mac, r=Veykril\n\nminor: Simplify syntax-highlighting macro checks", "tree": {"sha": "1b1c16d49bf4db2930f5ff0131dbddbad34479b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b1c16d49bf4db2930f5ff0131dbddbad34479b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e8aa7bb26c831e6e81a67e2e0f873de0a4f9de5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e8aa7bb26c831e6e81a67e2e0f873de0a4f9de5", "html_url": "https://github.com/rust-lang/rust/commit/8e8aa7bb26c831e6e81a67e2e0f873de0a4f9de5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e8aa7bb26c831e6e81a67e2e0f873de0a4f9de5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db9930b986fd41c5103343223dd60de1f515b7e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/db9930b986fd41c5103343223dd60de1f515b7e1", "html_url": "https://github.com/rust-lang/rust/commit/db9930b986fd41c5103343223dd60de1f515b7e1"}, {"sha": "9f6d99c6bd5e99d5bab744bd444059f5bc4e7265", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f6d99c6bd5e99d5bab744bd444059f5bc4e7265", "html_url": "https://github.com/rust-lang/rust/commit/9f6d99c6bd5e99d5bab744bd444059f5bc4e7265"}], "stats": {"total": 180, "additions": 87, "deletions": 93}, "files": [{"sha": "1d22c43317141975ea39e210b6ff2e7dbbbf4508", "filename": "crates/ide/src/syntax_highlighting.rs", "status": "modified", "additions": 87, "deletions": 93, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/8e8aa7bb26c831e6e81a67e2e0f873de0a4f9de5/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e8aa7bb26c831e6e81a67e2e0f873de0a4f9de5/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs?ref=8e8aa7bb26c831e6e81a67e2e0f873de0a4f9de5", "patch": "@@ -206,18 +206,19 @@ fn traverse(\n     let is_unlinked = sema.to_module_def(file_id).is_none();\n     let mut bindings_shadow_count: FxHashMap<Name, u32> = FxHashMap::default();\n \n-    let mut current_macro_call: Option<ast::MacroCall> = None;\n-    let mut current_attr_call = None;\n-    let mut current_derive_call = None;\n+    let mut tt_level = 0;\n+    let mut attr_or_derive_item = None;\n     let mut current_macro: Option<ast::Macro> = None;\n     let mut macro_highlighter = MacroHighlighter::default();\n     let mut inside_attribute = false;\n \n     // Walk all nodes, keeping track of whether we are inside a macro or not.\n     // If in macro, expand it first and highlight the expanded code.\n     for event in root.preorder_with_tokens() {\n+        use WalkEvent::{Enter, Leave};\n+\n         let range = match &event {\n-            WalkEvent::Enter(it) | WalkEvent::Leave(it) => it.text_range(),\n+            Enter(it) | Leave(it) => it.text_range(),\n         };\n \n         // Element outside of the viewport, no need to highlight\n@@ -227,78 +228,84 @@ fn traverse(\n \n         // set macro and attribute highlighting states\n         match event.clone() {\n-            WalkEvent::Enter(NodeOrToken::Node(node)) => match ast::Item::cast(node.clone()) {\n-                Some(ast::Item::MacroCall(mcall)) => {\n-                    current_macro_call = Some(mcall);\n-                    continue;\n-                }\n-                Some(ast::Item::MacroRules(mac)) => {\n-                    macro_highlighter.init();\n-                    current_macro = Some(mac.into());\n-                    continue;\n-                }\n-                Some(ast::Item::MacroDef(mac)) => {\n-                    macro_highlighter.init();\n-                    current_macro = Some(mac.into());\n-                    continue;\n-                }\n-                Some(item) => {\n-                    if matches!(node.kind(), FN | CONST | STATIC) {\n-                        bindings_shadow_count.clear();\n+            Enter(NodeOrToken::Node(node)) if ast::TokenTree::can_cast(node.kind()) => {\n+                tt_level += 1;\n+            }\n+            Leave(NodeOrToken::Node(node)) if ast::TokenTree::can_cast(node.kind()) => {\n+                tt_level -= 1;\n+            }\n+            Enter(NodeOrToken::Node(node)) if ast::Attr::can_cast(node.kind()) => {\n+                inside_attribute = true\n+            }\n+            Leave(NodeOrToken::Node(node)) if ast::Attr::can_cast(node.kind()) => {\n+                inside_attribute = false\n+            }\n+\n+            Enter(NodeOrToken::Node(node)) if ast::Item::can_cast(node.kind()) => {\n+                match ast::Item::cast(node.clone()) {\n+                    Some(ast::Item::MacroRules(mac)) => {\n+                        macro_highlighter.init();\n+                        current_macro = Some(mac.into());\n+                        continue;\n                     }\n+                    Some(ast::Item::MacroDef(mac)) => {\n+                        macro_highlighter.init();\n+                        current_macro = Some(mac.into());\n+                        continue;\n+                    }\n+                    Some(item) => {\n+                        if matches!(node.kind(), FN | CONST | STATIC) {\n+                            bindings_shadow_count.clear();\n+                        }\n \n-                    if sema.is_attr_macro_call(&item) {\n-                        current_attr_call = Some(item);\n-                    } else if current_attr_call.is_none() {\n-                        let adt = match item {\n-                            ast::Item::Enum(it) => Some(ast::Adt::Enum(it)),\n-                            ast::Item::Struct(it) => Some(ast::Adt::Struct(it)),\n-                            ast::Item::Union(it) => Some(ast::Adt::Union(it)),\n-                            _ => None,\n-                        };\n-                        match adt {\n-                            Some(adt) if sema.is_derive_annotated(&adt) => {\n-                                current_derive_call = Some(ast::Item::from(adt));\n+                        if attr_or_derive_item.is_none() {\n+                            if sema.is_attr_macro_call(&item) {\n+                                attr_or_derive_item = Some(item);\n+                            } else {\n+                                let adt = match item {\n+                                    ast::Item::Enum(it) => Some(ast::Adt::Enum(it)),\n+                                    ast::Item::Struct(it) => Some(ast::Adt::Struct(it)),\n+                                    ast::Item::Union(it) => Some(ast::Adt::Union(it)),\n+                                    _ => None,\n+                                };\n+                                match adt {\n+                                    Some(adt) if sema.is_derive_annotated(&adt) => {\n+                                        attr_or_derive_item = Some(ast::Item::from(adt));\n+                                    }\n+                                    _ => (),\n+                                }\n                             }\n-                            _ => (),\n                         }\n                     }\n+                    _ => (),\n                 }\n-                None if ast::Attr::can_cast(node.kind()) => inside_attribute = true,\n-                _ => (),\n-            },\n-            WalkEvent::Leave(NodeOrToken::Node(node)) => match ast::Item::cast(node.clone()) {\n-                Some(ast::Item::MacroCall(mcall)) => {\n-                    assert_eq!(current_macro_call, Some(mcall));\n-                    current_macro_call = None;\n-                }\n-                Some(ast::Item::MacroRules(mac)) => {\n-                    assert_eq!(current_macro, Some(mac.into()));\n-                    current_macro = None;\n-                    macro_highlighter = MacroHighlighter::default();\n-                }\n-                Some(ast::Item::MacroDef(mac)) => {\n-                    assert_eq!(current_macro, Some(mac.into()));\n-                    current_macro = None;\n-                    macro_highlighter = MacroHighlighter::default();\n-                }\n-                Some(item) if current_attr_call.as_ref().map_or(false, |it| *it == item) => {\n-                    current_attr_call = None;\n-                }\n-                Some(item) if current_derive_call.as_ref().map_or(false, |it| *it == item) => {\n-                    current_derive_call = None;\n+            }\n+            Leave(NodeOrToken::Node(node)) if ast::Item::can_cast(node.kind()) => {\n+                match ast::Item::cast(node.clone()) {\n+                    Some(ast::Item::MacroRules(mac)) => {\n+                        assert_eq!(current_macro, Some(mac.into()));\n+                        current_macro = None;\n+                        macro_highlighter = MacroHighlighter::default();\n+                    }\n+                    Some(ast::Item::MacroDef(mac)) => {\n+                        assert_eq!(current_macro, Some(mac.into()));\n+                        current_macro = None;\n+                        macro_highlighter = MacroHighlighter::default();\n+                    }\n+                    Some(item) if attr_or_derive_item.as_ref().map_or(false, |it| *it == item) => {\n+                        attr_or_derive_item = None;\n+                    }\n+                    _ => (),\n                 }\n-                None if ast::Attr::can_cast(node.kind()) => inside_attribute = false,\n-                _ => (),\n-            },\n+            }\n             _ => (),\n         }\n \n         let element = match event {\n-            WalkEvent::Enter(NodeOrToken::Token(tok)) if tok.kind() == WHITESPACE => continue,\n-            WalkEvent::Enter(it) => it,\n-            WalkEvent::Leave(NodeOrToken::Token(_)) => continue,\n-            WalkEvent::Leave(NodeOrToken::Node(node)) => {\n+            Enter(NodeOrToken::Token(tok)) if tok.kind() == WHITESPACE => continue,\n+            Enter(it) => it,\n+            Leave(NodeOrToken::Token(_)) => continue,\n+            Leave(NodeOrToken::Node(node)) => {\n                 // Doc comment highlighting injection, we do this when leaving the node\n                 // so that we overwrite the highlighting of the doc comment itself.\n                 inject::doc_comment(hl, sema, InFile::new(file_id.into(), &node));\n@@ -323,38 +330,25 @@ fn traverse(\n \n         // Descending tokens into macros is expensive even if no descending occurs, so make sure\n         // that we actually are in a position where descending is possible.\n-        let in_macro = current_macro_call.is_some()\n-            || current_derive_call.is_some()\n-            || current_attr_call.is_some();\n+        let in_macro = tt_level > 0 || attr_or_derive_item.is_some();\n         let descended_element = if in_macro {\n             // Attempt to descend tokens into macro-calls.\n             match element {\n                 NodeOrToken::Token(token) if token.kind() != COMMENT => {\n-                    // For function-like macro calls and derive attributes, only attempt to descend if\n-                    // we are inside their token-trees.\n-                    let in_tt = current_attr_call.is_some()\n-                        || token.parent().as_ref().map(SyntaxNode::kind) == Some(TOKEN_TREE);\n-\n-                    if in_tt {\n-                        let token = sema.descend_into_macros_single(token);\n-                        match token.parent().and_then(ast::NameLike::cast) {\n-                            // Remap the token into the wrapping single token nodes\n-                            // FIXME: if the node doesn't resolve, we also won't do token based highlighting!\n-                            Some(parent) => match (token.kind(), parent.syntax().kind()) {\n-                                (T![self] | T![ident], NAME | NAME_REF) => {\n-                                    NodeOrToken::Node(parent)\n-                                }\n-                                (T![self] | T![super] | T![crate] | T![Self], NAME_REF) => {\n-                                    NodeOrToken::Node(parent)\n-                                }\n-                                (INT_NUMBER, NAME_REF) => NodeOrToken::Node(parent),\n-                                (LIFETIME_IDENT, LIFETIME) => NodeOrToken::Node(parent),\n-                                _ => NodeOrToken::Token(token),\n-                            },\n-                            None => NodeOrToken::Token(token),\n-                        }\n-                    } else {\n-                        NodeOrToken::Token(token)\n+                    let token = sema.descend_into_macros_single(token);\n+                    match token.parent().and_then(ast::NameLike::cast) {\n+                        // Remap the token into the wrapping single token nodes\n+                        // FIXME: if the node doesn't resolve, we also won't do token based highlighting!\n+                        Some(parent) => match (token.kind(), parent.syntax().kind()) {\n+                            (T![self] | T![ident], NAME | NAME_REF) => NodeOrToken::Node(parent),\n+                            (T![self] | T![super] | T![crate] | T![Self], NAME_REF) => {\n+                                NodeOrToken::Node(parent)\n+                            }\n+                            (INT_NUMBER, NAME_REF) => NodeOrToken::Node(parent),\n+                            (LIFETIME_IDENT, LIFETIME) => NodeOrToken::Node(parent),\n+                            _ => NodeOrToken::Token(token),\n+                        },\n+                        None => NodeOrToken::Token(token),\n                     }\n                 }\n                 e => e,"}]}