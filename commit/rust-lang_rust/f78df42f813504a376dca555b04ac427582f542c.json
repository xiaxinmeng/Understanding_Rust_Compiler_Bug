{"sha": "f78df42f813504a376dca555b04ac427582f542c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3OGRmNDJmODEzNTA0YTM3NmRjYTU1NWIwNGFjNDI3NTgyZjU0MmM=", "commit": {"author": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2020-06-02T22:04:23Z"}, "committer": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2020-06-27T14:13:14Z"}, "message": "Fix issues caused during rebase", "tree": {"sha": "6fcf36c429b6e286cda892f0df16812633af70a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6fcf36c429b6e286cda892f0df16812633af70a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f78df42f813504a376dca555b04ac427582f542c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f78df42f813504a376dca555b04ac427582f542c", "html_url": "https://github.com/rust-lang/rust/commit/f78df42f813504a376dca555b04ac427582f542c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f78df42f813504a376dca555b04ac427582f542c/comments", "author": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2608a6fd3a024206d4776cc391e46ef28c018434", "url": "https://api.github.com/repos/rust-lang/rust/commits/2608a6fd3a024206d4776cc391e46ef28c018434", "html_url": "https://github.com/rust-lang/rust/commit/2608a6fd3a024206d4776cc391e46ef28c018434"}], "stats": {"total": 108, "additions": 63, "deletions": 45}, "files": [{"sha": "4240c6ad87a7b714fb05d7aeaa15f7b936a122ef", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 63, "deletions": 45, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/f78df42f813504a376dca555b04ac427582f542c/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f78df42f813504a376dca555b04ac427582f542c/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=f78df42f813504a376dca555b04ac427582f542c", "patch": "@@ -318,16 +318,20 @@ impl ExprCollector<'_> {\n             ast::Expr::BlockExpr(e) => self.collect_block(e),\n             ast::Expr::LoopExpr(e) => {\n                 let body = self.collect_block_opt(e.loop_body());\n-                track_parent!(self, self.alloc_expr(Expr::Loop { body }, syntax_ptr), vec![body])\n-                    Expr::Loop {\n-                        body,\n-                        label: e\n-                            .label()\n-                            .and_then(|l| l.lifetime_token())\n-                            .map(|l| Name::new_lifetime(&l)),\n-                    },\n-                    syntax_ptr,\n-                ), body)\n+                track_parent!(\n+                    self,\n+                    self.alloc_expr(\n+                        Expr::Loop {\n+                            body,\n+                            label: e\n+                                .label()\n+                                .and_then(|l| l.lifetime_token())\n+                                .map(|l| Name::new_lifetime(&l)),\n+                        },\n+                        syntax_ptr,\n+                    ),\n+                    body\n+                )\n             }\n             ast::Expr::WhileExpr(e) => {\n                 let body = self.collect_block_opt(e.loop_body());\n@@ -350,48 +354,62 @@ impl ExprCollector<'_> {\n                             ];\n                             let match_expr =\n                                 self.alloc_expr_desugared(Expr::Match { expr: match_expr, arms });\n-                            return track_parent!(self, self.alloc_expr(\n-                                Expr::Loop {\n-                                    body: match_expr,\n-                                    label: e\n-                                        .label()\n-                                        .and_then(|l| l.lifetime_token())\n-                                        .map(|l| Name::new_lifetime(&l)),\n-                                },\n-                                syntax_ptr,\n-                            ), match_expr);\n+                            return track_parent!(\n+                                self,\n+                                self.alloc_expr(\n+                                    Expr::Loop {\n+                                        body: match_expr,\n+                                        label: e\n+                                            .label()\n+                                            .and_then(|l| l.lifetime_token())\n+                                            .map(|l| Name::new_lifetime(&l)),\n+                                    },\n+                                    syntax_ptr,\n+                                ),\n+                                match_expr\n+                            );\n                         }\n                     },\n                 };\n \n-                track_parent!(self, self.alloc_expr(\n-                    Expr::While {\n-                        condition,\n-                        body,\n-                        label: e\n-                            .label()\n-                            .and_then(|l| l.lifetime_token())\n-                            .map(|l| Name::new_lifetime(&l)),\n-                    },\n-                    syntax_ptr,\n-                ), body, condition)\n+                track_parent!(\n+                    self,\n+                    self.alloc_expr(\n+                        Expr::While {\n+                            condition,\n+                            body,\n+                            label: e\n+                                .label()\n+                                .and_then(|l| l.lifetime_token())\n+                                .map(|l| Name::new_lifetime(&l)),\n+                        },\n+                        syntax_ptr,\n+                    ),\n+                    body,\n+                    condition\n+                )\n             }\n             ast::Expr::ForExpr(e) => {\n                 let iterable = self.collect_expr_opt(e.iterable());\n                 let pat = self.collect_pat_opt(e.pat());\n                 let body = self.collect_block_opt(e.loop_body());\n-                track_parent!(self, self.alloc_expr(\n-                    Expr::For {\n-                        iterable,\n-                        pat,\n-                        body,\n-                        label: e\n-                            .label()\n-                            .and_then(|l| l.lifetime_token())\n-                            .map(|l| Name::new_lifetime(&l)),\n-                    },\n-                    syntax_ptr,\n-                ), iterable, body)\n+                track_parent!(\n+                    self,\n+                    self.alloc_expr(\n+                        Expr::For {\n+                            iterable,\n+                            pat,\n+                            body,\n+                            label: e\n+                                .label()\n+                                .and_then(|l| l.lifetime_token())\n+                                .map(|l| Name::new_lifetime(&l)),\n+                        },\n+                        syntax_ptr,\n+                    ),\n+                    iterable,\n+                    body\n+                )\n             }\n             ast::Expr::CallExpr(e) => {\n                 let callee = self.collect_expr_opt(e.expr());\n@@ -461,10 +479,10 @@ impl ExprCollector<'_> {\n                     .unwrap_or(Expr::Missing);\n                 self.alloc_expr(path, syntax_ptr)\n             }\n-            ast::Expr::ContinueExpr(e) => (self.alloc_expr(\n+            ast::Expr::ContinueExpr(e) => self.alloc_expr(\n                 Expr::Continue { label: e.lifetime_token().map(|l| Name::new_lifetime(&l)) },\n                 syntax_ptr,\n-            ), vec![]),\n+            ),\n             ast::Expr::BreakExpr(e) => {\n                 let expr = e.expr().map(|e| self.collect_expr(e));\n                 track_parent!(self, self.alloc_expr("}]}