{"sha": "acac58502b3d86c5808d8d152d7870f8c6423074", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjYWM1ODUwMmIzZDg2YzU4MDhkOGQxNTJkNzg3MGY4YzY0MjMwNzQ=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-12-12T16:14:49Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-12-12T16:27:07Z"}, "message": "Move large chunks of miri from rustc::mir::interpret to rustc_mir::interpret", "tree": {"sha": "1d5ea5624b30b163f4afa489b0343bcb7360a581", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d5ea5624b30b163f4afa489b0343bcb7360a581"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/acac58502b3d86c5808d8d152d7870f8c6423074", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlowA18ACgkQpp+NIls6\n19mwbg//VJZt0QQmebVDBT9KwH7VqiVMhSFlhjqOKTdMXOVAE3PuZkPi0w/qbNJg\nTueYQtE+8mW2eknj3a5ZFTsi181raF9u4jYSG2F8A1AnHqSZWybhOgZ1p16iC3du\n4T+SQyoNVwxrWGmQXtBD96Vuu0+rheqH55mOi3POIMlOcdre+3WFIWLEgaJZJ798\n3Vg+s9CmcfZpouSzXY5LuMUFxkSgUh6nydh1kr174wcEAYqm+bYE7nKA7fBqkfNW\nd2MXCvWfmPavpVRiOwVkNRdgC8VPZqNoRDNC435Ze/UhOpUrthJskToHp8Bx1Job\n9vURgpo8x+kDHukBlawRX6m2r0ze6+aeA1XthVgSzJ64/iPAbsLFkDFxRr+mhZrY\nvB26nwHOAfNqYl2g620lWL/QeyI8RAP9s5hR4yU5aqE8rH4tlY89YLEcrz9dinH8\nXPA+O9hLTCgG1nJCjBddtFNg+ZTbBN+jEqq0pGqHJpCuo+fyLmZTkUh9voNRrOYP\n8kMIu2skQbSGxrRABmrnpmE2J1eb/H03j7CQq2hp5FE8UQv/MmoO6mEp2wRN2TtR\n9i3U1dsRNko59YeZBW3lAuN4DGZkWgJ5nbay6fZ/Lx5rSTjVexp/ZxRZjCDu9dVJ\nXRJpc3KWzX2pDIpMhPGJDQ5OUTh5yk3tx4lKtW3rIq5L3NoJSI0=\n=zjJE\n-----END PGP SIGNATURE-----", "payload": "tree 1d5ea5624b30b163f4afa489b0343bcb7360a581\nparent 8c2ec689c159e7f021d5913efb991aff875be967\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1513095289 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1513096027 +0100\n\nMove large chunks of miri from rustc::mir::interpret to rustc_mir::interpret\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/acac58502b3d86c5808d8d152d7870f8c6423074", "html_url": "https://github.com/rust-lang/rust/commit/acac58502b3d86c5808d8d152d7870f8c6423074", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/acac58502b3d86c5808d8d152d7870f8c6423074/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c2ec689c159e7f021d5913efb991aff875be967", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c2ec689c159e7f021d5913efb991aff875be967", "html_url": "https://github.com/rust-lang/rust/commit/8c2ec689c159e7f021d5913efb991aff875be967"}], "stats": {"total": 2156, "additions": 1103, "deletions": 1053}, "files": [{"sha": "93c2834b7d8730116bc1b2e78f6eb023f673052e", "filename": ".travis.yml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/acac58502b3d86c5808d8d152d7870f8c6423074/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/acac58502b3d86c5808d8d152d7870f8c6423074/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=acac58502b3d86c5808d8d152d7870f8c6423074", "patch": "@@ -293,6 +293,7 @@ before_deploy:\n           cp -r obj/build/dist/* deploy/$TRAVIS_COMMIT;\n       fi\n   - travis_retry gem update --system\n+  - ls -la deploy/$TRAVIS_COMMIT\n \n deploy:\n   - provider: s3"}, {"sha": "37b5e57ebf44464093f1feb29f58980ccaebbeb0", "filename": "src/Cargo.lock", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/acac58502b3d86c5808d8d152d7870f8c6423074/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/acac58502b3d86c5808d8d152d7870f8c6423074/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=acac58502b3d86c5808d8d152d7870f8c6423074", "patch": "@@ -961,6 +961,11 @@ name = \"lazy_static\"\n version = \"0.2.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"lazy_static\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"lazycell\"\n version = \"0.5.1\"\n@@ -1618,9 +1623,7 @@ dependencies = [\n  \"fmt_macros 0.0.0\",\n  \"graphviz 0.0.0\",\n  \"jobserver 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lazy_static 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log_settings 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_apfloat 0.0.0\",\n@@ -1863,9 +1866,14 @@ name = \"rustc_mir\"\n version = \"0.0.0\"\n dependencies = [\n  \"bitflags 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"byteorder 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"graphviz 0.0.0\",\n+ \"lazy_static 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log_settings 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n+ \"rustc_apfloat 0.0.0\",\n  \"rustc_const_eval 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n@@ -2763,6 +2771,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum kuchiki 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e03098e8e719c92b7794515dfd5c1724e2b12f5ce1788e61cfa4663f82eba8d8\"\n \"checksum languageserver-types 0.16.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"773e175c945800aeea4c21c04090bcb9db987b1a566ad9c6f569972299950e3e\"\n \"checksum lazy_static 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"76f033c7ad61445c5b347c7382dd1237847eb1bce590fe50365dcb33d546be73\"\n+\"checksum lazy_static 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c8f31047daa365f19be14b47c29df4f7c3b581832407daabe6ae77397619237d\"\n \"checksum lazycell 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3b585b7a6811fb03aa10e74b278a0f00f8dd9b45dc681f148bb29fa5cb61859b\"\n \"checksum libc 0.2.34 (registry+https://github.com/rust-lang/crates.io-index)\" = \"36fbc8a8929c632868295d0178dd8f63fc423fd7537ad0738372bd010b3ac9b0\"\n \"checksum libgit2-sys 0.6.16 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6f74b4959cef96898f5123148724fc7dee043b9a6b99f219d948851bfbe53cb2\""}, {"sha": "29eedc49be04bf577e7c44fcfca6f71b50b9a679", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=acac58502b3d86c5808d8d152d7870f8c6423074", "patch": "@@ -24,8 +24,6 @@ rustc_errors = { path = \"../librustc_errors\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n-log_settings = \"0.1.1\"\n-lazy_static = \"0.2.8\"\n regex = \"0.2.2\"\n backtrace = \"0.3.3\"\n byteorder = { version = \"1.1\", features = [\"i128\"]}"}, {"sha": "c7d2d136af1b35c808a1d0e8e7189ce8cfbd3dd6", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=acac58502b3d86c5808d8d152d7870f8c6423074", "patch": "@@ -91,10 +91,7 @@ extern crate jobserver;\n extern crate serialize as rustc_serialize; // used by deriving\n \n extern crate rustc_apfloat;\n-extern crate log_settings;\n extern crate byteorder;\n-#[macro_use]\n-extern crate lazy_static;\n extern crate regex;\n extern crate backtrace;\n "}, {"sha": "dd8bf09586acce0f71f682de31ef492262a2fd1d", "filename": "src/librustc/mir/interpret/const_eval.rs", "status": "removed", "additions": 0, "deletions": 288, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/8c2ec689c159e7f021d5913efb991aff875be967/src%2Flibrustc%2Fmir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2ec689c159e7f021d5913efb991aff875be967/src%2Flibrustc%2Fmir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fconst_eval.rs?ref=8c2ec689c159e7f021d5913efb991aff875be967", "patch": "@@ -1,288 +0,0 @@\n-use ty::{self, TyCtxt, Ty, Instance};\n-use ty::layout::{self, LayoutOf};\n-use mir;\n-\n-use syntax::ast::Mutability;\n-use syntax::codemap::Span;\n-\n-use super::{EvalResult, EvalError, EvalErrorKind, GlobalId, Place, Value, PrimVal, EvalContext,\n-            StackPopCleanup, PtrAndAlign, ValTy, HasMemory};\n-\n-use rustc_const_math::ConstInt;\n-\n-use std::fmt;\n-use std::error::Error;\n-\n-pub fn eval_body<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    instance: Instance<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-) -> (EvalResult<'tcx, (PtrAndAlign, Ty<'tcx>)>, EvalContext<'a, 'tcx, CompileTimeEvaluator>) {\n-    debug!(\"eval_body: {:?}, {:?}\", instance, param_env);\n-    let limits = super::ResourceLimits::default();\n-    let mut ecx = EvalContext::new(tcx, param_env, limits, CompileTimeEvaluator, ());\n-    let cid = GlobalId {\n-        instance,\n-        promoted: None,\n-    };\n-\n-    let try = (|| {\n-        if ecx.tcx.has_attr(instance.def_id(), \"linkage\") {\n-            return Err(ConstEvalError::NotConst(\"extern global\".to_string()).into());\n-        }\n-        // FIXME(eddyb) use `Instance::ty` when it becomes available.\n-        let instance_ty =\n-            ecx.monomorphize(instance.def.def_ty(tcx), instance.substs);\n-        if tcx.interpret_interner.borrow().get_cached(cid).is_none() {\n-            let mir = ecx.load_mir(instance.def)?;\n-            let layout = ecx.layout_of(instance_ty)?;\n-            assert!(!layout.is_unsized());\n-            let ptr = ecx.memory.allocate(\n-                layout.size.bytes(),\n-                layout.align.abi(),\n-                None,\n-            )?;\n-            tcx.interpret_interner.borrow_mut().cache(\n-                cid,\n-                PtrAndAlign {\n-                    ptr: ptr.into(),\n-                    aligned: !layout.is_packed(),\n-                },\n-            );\n-            let cleanup = StackPopCleanup::MarkStatic(Mutability::Immutable);\n-            let name = ty::tls::with(|tcx| tcx.item_path_str(instance.def_id()));\n-            trace!(\"const_eval: pushing stack frame for global: {}\", name);\n-            ecx.push_stack_frame(\n-                instance,\n-                mir.span,\n-                mir,\n-                Place::from_ptr(ptr),\n-                cleanup.clone(),\n-            )?;\n-\n-            while ecx.step()? {}\n-\n-            // reinsert the stack frame so any future queries have the correct substs\n-            ecx.push_stack_frame(\n-                instance,\n-                mir.span,\n-                mir,\n-                Place::from_ptr(ptr),\n-                cleanup,\n-            )?;\n-        }\n-        let value = tcx.interpret_interner.borrow().get_cached(cid).expect(\"global not cached\");\n-        Ok((value, instance_ty))\n-    })();\n-    (try, ecx)\n-}\n-\n-pub fn eval_body_as_integer<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    instance: Instance<'tcx>,\n-) -> EvalResult<'tcx, ConstInt> {\n-    let (ptr_ty, ecx) = eval_body(tcx, instance, param_env);\n-    let (ptr, ty) = ptr_ty?;\n-    let prim = match ecx.read_maybe_aligned(ptr.aligned, |ectx| ectx.try_read_value(ptr.ptr, ty))? {\n-        Some(Value::ByVal(prim)) => prim.to_bytes()?,\n-        _ => return err!(TypeNotPrimitive(ty)),\n-    };\n-    use syntax::ast::{IntTy, UintTy};\n-    use ty::TypeVariants::*;\n-    use rustc_const_math::{ConstIsize, ConstUsize};\n-    Ok(match ty.sty {\n-        TyInt(IntTy::I8) => ConstInt::I8(prim as i128 as i8),\n-        TyInt(IntTy::I16) => ConstInt::I16(prim as i128 as i16),\n-        TyInt(IntTy::I32) => ConstInt::I32(prim as i128 as i32),\n-        TyInt(IntTy::I64) => ConstInt::I64(prim as i128 as i64),\n-        TyInt(IntTy::I128) => ConstInt::I128(prim as i128),\n-        TyInt(IntTy::Is) => ConstInt::Isize(\n-            ConstIsize::new(prim as i128 as i64, tcx.sess.target.isize_ty)\n-                .expect(\"miri should already have errored\"),\n-        ),\n-        TyUint(UintTy::U8) => ConstInt::U8(prim as u8),\n-        TyUint(UintTy::U16) => ConstInt::U16(prim as u16),\n-        TyUint(UintTy::U32) => ConstInt::U32(prim as u32),\n-        TyUint(UintTy::U64) => ConstInt::U64(prim as u64),\n-        TyUint(UintTy::U128) => ConstInt::U128(prim),\n-        TyUint(UintTy::Us) => ConstInt::Usize(\n-            ConstUsize::new(prim as u64, tcx.sess.target.usize_ty)\n-                .expect(\"miri should already have errored\"),\n-        ),\n-        _ => {\n-            return Err(\n-                ConstEvalError::NeedsRfc(\n-                    \"evaluating anything other than isize/usize during typeck\".to_string(),\n-                ).into(),\n-            )\n-        }\n-    })\n-}\n-\n-pub struct CompileTimeEvaluator;\n-\n-impl<'tcx> Into<EvalError<'tcx>> for ConstEvalError {\n-    fn into(self) -> EvalError<'tcx> {\n-        EvalErrorKind::MachineError(Box::new(self)).into()\n-    }\n-}\n-\n-#[derive(Clone, Debug)]\n-enum ConstEvalError {\n-    NeedsRfc(String),\n-    NotConst(String),\n-}\n-\n-impl fmt::Display for ConstEvalError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        use self::ConstEvalError::*;\n-        match *self {\n-            NeedsRfc(ref msg) => {\n-                write!(\n-                    f,\n-                    \"\\\"{}\\\" needs an rfc before being allowed inside constants\",\n-                    msg\n-                )\n-            }\n-            NotConst(ref msg) => write!(f, \"Cannot evaluate within constants: \\\"{}\\\"\", msg),\n-        }\n-    }\n-}\n-\n-impl Error for ConstEvalError {\n-    fn description(&self) -> &str {\n-        use self::ConstEvalError::*;\n-        match *self {\n-            NeedsRfc(_) => \"this feature needs an rfc before being allowed inside constants\",\n-            NotConst(_) => \"this feature is not compatible with constant evaluation\",\n-        }\n-    }\n-\n-    fn cause(&self) -> Option<&Error> {\n-        None\n-    }\n-}\n-\n-impl<'tcx> super::Machine<'tcx> for CompileTimeEvaluator {\n-    type MemoryData = ();\n-    type MemoryKinds = !;\n-    fn eval_fn_call<'a>(\n-        ecx: &mut EvalContext<'a, 'tcx, Self>,\n-        instance: ty::Instance<'tcx>,\n-        destination: Option<(Place, mir::BasicBlock)>,\n-        _args: &[ValTy<'tcx>],\n-        span: Span,\n-        _sig: ty::FnSig<'tcx>,\n-    ) -> EvalResult<'tcx, bool> {\n-        debug!(\"eval_fn_call: {:?}\", instance);\n-        if !ecx.tcx.is_const_fn(instance.def_id()) {\n-            return Err(\n-                ConstEvalError::NotConst(format!(\"calling non-const fn `{}`\", instance)).into(),\n-            );\n-        }\n-        let mir = match ecx.load_mir(instance.def) {\n-            Ok(mir) => mir,\n-            Err(EvalError { kind: EvalErrorKind::NoMirFor(path), .. }) => {\n-                // some simple things like `malloc` might get accepted in the future\n-                return Err(\n-                    ConstEvalError::NeedsRfc(format!(\"calling extern function `{}`\", path))\n-                        .into(),\n-                );\n-            }\n-            Err(other) => return Err(other),\n-        };\n-        let (return_place, return_to_block) = match destination {\n-            Some((place, block)) => (place, StackPopCleanup::Goto(block)),\n-            None => (Place::undef(), StackPopCleanup::None),\n-        };\n-\n-        ecx.push_stack_frame(\n-            instance,\n-            span,\n-            mir,\n-            return_place,\n-            return_to_block,\n-        )?;\n-\n-        Ok(false)\n-    }\n-\n-\n-    fn call_intrinsic<'a>(\n-        ecx: &mut EvalContext<'a, 'tcx, Self>,\n-        instance: ty::Instance<'tcx>,\n-        _args: &[ValTy<'tcx>],\n-        dest: Place,\n-        dest_layout: layout::TyLayout<'tcx>,\n-        target: mir::BasicBlock,\n-    ) -> EvalResult<'tcx> {\n-        let substs = instance.substs;\n-\n-        let intrinsic_name = &ecx.tcx.item_name(instance.def_id())[..];\n-        match intrinsic_name {\n-            \"min_align_of\" => {\n-                let elem_ty = substs.type_at(0);\n-                let elem_align = ecx.layout_of(elem_ty)?.align.abi();\n-                let align_val = PrimVal::from_u128(elem_align as u128);\n-                ecx.write_primval(dest, align_val, dest_layout.ty)?;\n-            }\n-\n-            \"size_of\" => {\n-                let ty = substs.type_at(0);\n-                let size = ecx.layout_of(ty)?.size.bytes() as u128;\n-                ecx.write_primval(dest, PrimVal::from_u128(size), dest_layout.ty)?;\n-            }\n-\n-            name => return Err(ConstEvalError::NeedsRfc(format!(\"calling intrinsic `{}`\", name)).into()),\n-        }\n-\n-        ecx.goto_block(target);\n-\n-        // Since we pushed no stack frame, the main loop will act\n-        // as if the call just completed and it's returning to the\n-        // current frame.\n-        Ok(())\n-    }\n-\n-    fn try_ptr_op<'a>(\n-        _ecx: &EvalContext<'a, 'tcx, Self>,\n-        _bin_op: mir::BinOp,\n-        left: PrimVal,\n-        _left_ty: Ty<'tcx>,\n-        right: PrimVal,\n-        _right_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx, Option<(PrimVal, bool)>> {\n-        if left.is_bytes() && right.is_bytes() {\n-            Ok(None)\n-        } else {\n-            Err(\n-                ConstEvalError::NeedsRfc(\"Pointer arithmetic or comparison\".to_string()).into(),\n-            )\n-        }\n-    }\n-\n-    fn mark_static_initialized(m: !) -> EvalResult<'tcx> {\n-        m\n-    }\n-\n-    fn box_alloc<'a>(\n-        _ecx: &mut EvalContext<'a, 'tcx, Self>,\n-        _ty: Ty<'tcx>,\n-        _dest: Place,\n-    ) -> EvalResult<'tcx> {\n-        Err(\n-            ConstEvalError::NeedsRfc(\"Heap allocations via `box` keyword\".to_string()).into(),\n-        )\n-    }\n-\n-    fn global_item_with_linkage<'a>(\n-        _ecx: &mut EvalContext<'a, 'tcx, Self>,\n-        _instance: ty::Instance<'tcx>,\n-        _mutability: Mutability,\n-    ) -> EvalResult<'tcx> {\n-        Err(\n-            ConstEvalError::NotConst(\"statics with `linkage` attribute\".to_string()).into(),\n-        )\n-    }\n-}"}, {"sha": "c5d2ec1668c8238774dc0046098f7e2e978a4958", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 250, "deletions": 22, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=acac58502b3d86c5808d8d152d7870f8c6423074", "patch": "@@ -5,38 +5,266 @@ macro_rules! err {\n     ($($tt:tt)*) => { Err($crate::mir::interpret::EvalErrorKind::$($tt)*.into()) };\n }\n \n-mod cast;\n-mod const_eval;\n mod error;\n-mod eval_context;\n-mod place;\n-mod validation;\n-mod machine;\n-mod memory;\n-mod operator;\n-mod range_map;\n-mod step;\n-mod terminator;\n-mod traits;\n mod value;\n \n pub use self::error::{EvalError, EvalResult, EvalErrorKind};\n \n-pub use self::eval_context::{EvalContext, Frame, ResourceLimits, StackPopCleanup, DynamicLifetime,\n-                             TyAndPacked, PtrAndAlign, ValTy};\n+pub use self::value::{PrimVal, PrimValKind, Value, Pointer, PtrAndAlign, bytes_to_f32, bytes_to_f64};\n \n-pub use self::place::{Place, PlaceExtra, GlobalId};\n+use std::collections::BTreeMap;\n+use ty::layout::HasDataLayout;\n+use std::fmt;\n+use ty::layout;\n+use mir;\n+use ty;\n+use middle::region;\n+use std::iter;\n \n-pub use self::memory::{AllocId, Memory, MemoryPointer, MemoryKind, HasMemory, AccessKind, Allocation};\n+#[derive(Clone, Debug, PartialEq)]\n+pub enum Lock {\n+    NoLock,\n+    WriteLock(DynamicLifetime),\n+    /// This should never be empty -- that would be a read lock held and nobody there to release it...\n+    ReadLock(Vec<DynamicLifetime>),\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct DynamicLifetime {\n+    pub frame: usize,\n+    pub region: Option<region::Scope>, // \"None\" indicates \"until the function ends\"\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum AccessKind {\n+    Read,\n+    Write,\n+}\n+\n+/// Uniquely identifies a specific constant or static.\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]\n+pub struct GlobalId<'tcx> {\n+    /// For a constant or static, the `Instance` of the item itself.\n+    /// For a promoted global, the `Instance` of the function they belong to.\n+    pub instance: ty::Instance<'tcx>,\n+\n+    /// The index for promoted globals within their function's `Mir`.\n+    pub promoted: Option<mir::Promoted>,\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Pointer arithmetic\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub trait PointerArithmetic: layout::HasDataLayout {\n+    // These are not supposed to be overriden.\n+\n+    //// Trunace the given value to the pointer size; also return whether there was an overflow\n+    fn truncate_to_ptr(self, val: u128) -> (u64, bool) {\n+        let max_ptr_plus_1 = 1u128 << self.data_layout().pointer_size.bits();\n+        ((val % max_ptr_plus_1) as u64, val >= max_ptr_plus_1)\n+    }\n+\n+    // Overflow checking only works properly on the range from -u64 to +u64.\n+    fn overflowing_signed_offset(self, val: u64, i: i128) -> (u64, bool) {\n+        // FIXME: is it possible to over/underflow here?\n+        if i < 0 {\n+            // trickery to ensure that i64::min_value() works fine\n+            // this formula only works for true negative values, it panics for zero!\n+            let n = u64::max_value() - (i as u64) + 1;\n+            val.overflowing_sub(n)\n+        } else {\n+            self.overflowing_offset(val, i as u64)\n+        }\n+    }\n+\n+    fn overflowing_offset(self, val: u64, i: u64) -> (u64, bool) {\n+        let (res, over1) = val.overflowing_add(i);\n+        let (res, over2) = self.truncate_to_ptr(res as u128);\n+        (res, over1 || over2)\n+    }\n+\n+    fn signed_offset<'tcx>(self, val: u64, i: i64) -> EvalResult<'tcx, u64> {\n+        let (res, over) = self.overflowing_signed_offset(val, i as i128);\n+        if over { err!(OverflowingMath) } else { Ok(res) }\n+    }\n+\n+    fn offset<'tcx>(self, val: u64, i: u64) -> EvalResult<'tcx, u64> {\n+        let (res, over) = self.overflowing_offset(val, i);\n+        if over { err!(OverflowingMath) } else { Ok(res) }\n+    }\n+\n+    fn wrapping_signed_offset(self, val: u64, i: i64) -> u64 {\n+        self.overflowing_signed_offset(val, i as i128).0\n+    }\n+}\n+\n+impl<T: layout::HasDataLayout> PointerArithmetic for T {}\n+\n+\n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+pub struct MemoryPointer {\n+    pub alloc_id: AllocId,\n+    pub offset: u64,\n+}\n+\n+impl<'tcx> MemoryPointer {\n+    pub fn new(alloc_id: AllocId, offset: u64) -> Self {\n+        MemoryPointer { alloc_id, offset }\n+    }\n \n-use self::memory::{PointerArithmetic, Lock};\n+    pub(crate) fn wrapping_signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> Self {\n+        MemoryPointer::new(\n+            self.alloc_id,\n+            cx.data_layout().wrapping_signed_offset(self.offset, i),\n+        )\n+    }\n \n-use self::range_map::RangeMap;\n+    pub fn overflowing_signed_offset<C: HasDataLayout>(self, i: i128, cx: C) -> (Self, bool) {\n+        let (res, over) = cx.data_layout().overflowing_signed_offset(self.offset, i);\n+        (MemoryPointer::new(self.alloc_id, res), over)\n+    }\n \n-pub use self::value::{PrimVal, PrimValKind, Value, Pointer};\n+    pub(crate) fn signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n+        Ok(MemoryPointer::new(\n+            self.alloc_id,\n+            cx.data_layout().signed_offset(self.offset, i)?,\n+        ))\n+    }\n \n-pub use self::const_eval::{eval_body_as_integer, eval_body, CompileTimeEvaluator};\n+    pub fn overflowing_offset<C: HasDataLayout>(self, i: u64, cx: C) -> (Self, bool) {\n+        let (res, over) = cx.data_layout().overflowing_offset(self.offset, i);\n+        (MemoryPointer::new(self.alloc_id, res), over)\n+    }\n \n-pub use self::machine::Machine;\n+    pub fn offset<C: HasDataLayout>(self, i: u64, cx: C) -> EvalResult<'tcx, Self> {\n+        Ok(MemoryPointer::new(\n+            self.alloc_id,\n+            cx.data_layout().offset(self.offset, i)?,\n+        ))\n+    }\n+}\n+\n+\n+#[derive(Copy, Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug)]\n+pub struct AllocId(pub u64);\n+\n+impl fmt::Display for AllocId {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", self.0)\n+    }\n+}\n+\n+#[derive(Debug, Eq, PartialEq, Hash)]\n+pub struct Allocation {\n+    /// The actual bytes of the allocation.\n+    /// Note that the bytes of a pointer represent the offset of the pointer\n+    pub bytes: Vec<u8>,\n+    /// Maps from byte addresses to allocations.\n+    /// Only the first byte of a pointer is inserted into the map.\n+    pub relocations: BTreeMap<u64, AllocId>,\n+    /// Denotes undefined memory. Reading from undefined memory is forbidden in miri\n+    pub undef_mask: UndefMask,\n+    /// The alignment of the allocation to detect unaligned reads.\n+    pub align: u64,\n+}\n+\n+impl Allocation {\n+    pub fn from_bytes(slice: &[u8]) -> Self {\n+        let mut undef_mask = UndefMask::new(0);\n+        undef_mask.grow(slice.len() as u64, true);\n+        Self {\n+            bytes: slice.to_owned(),\n+            relocations: BTreeMap::new(),\n+            undef_mask,\n+            align: 1,\n+        }\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Undefined byte tracking\n+////////////////////////////////////////////////////////////////////////////////\n+\n+type Block = u64;\n+const BLOCK_SIZE: u64 = 64;\n \n-pub use self::validation::{ValidationQuery, AbsPlace};\n+#[derive(Clone, Debug, Eq, PartialEq, Hash)]\n+pub struct UndefMask {\n+    blocks: Vec<Block>,\n+    len: u64,\n+}\n+\n+impl UndefMask {\n+    pub fn new(size: u64) -> Self {\n+        let mut m = UndefMask {\n+            blocks: vec![],\n+            len: 0,\n+        };\n+        m.grow(size, false);\n+        m\n+    }\n+\n+    /// Check whether the range `start..end` (end-exclusive) is entirely defined.\n+    pub fn is_range_defined(&self, start: u64, end: u64) -> bool {\n+        if end > self.len {\n+            return false;\n+        }\n+        for i in start..end {\n+            if !self.get(i) {\n+                return false;\n+            }\n+        }\n+        true\n+    }\n+\n+    pub fn set_range(&mut self, start: u64, end: u64, new_state: bool) {\n+        let len = self.len;\n+        if end > len {\n+            self.grow(end - len, new_state);\n+        }\n+        self.set_range_inbounds(start, end, new_state);\n+    }\n+\n+    pub fn set_range_inbounds(&mut self, start: u64, end: u64, new_state: bool) {\n+        for i in start..end {\n+            self.set(i, new_state);\n+        }\n+    }\n+\n+    pub fn get(&self, i: u64) -> bool {\n+        let (block, bit) = bit_index(i);\n+        (self.blocks[block] & 1 << bit) != 0\n+    }\n+\n+    pub fn set(&mut self, i: u64, new_state: bool) {\n+        let (block, bit) = bit_index(i);\n+        if new_state {\n+            self.blocks[block] |= 1 << bit;\n+        } else {\n+            self.blocks[block] &= !(1 << bit);\n+        }\n+    }\n+\n+    pub fn grow(&mut self, amount: u64, new_state: bool) {\n+        let unused_trailing_bits = self.blocks.len() as u64 * BLOCK_SIZE - self.len;\n+        if amount > unused_trailing_bits {\n+            let additional_blocks = amount / BLOCK_SIZE + 1;\n+            assert_eq!(additional_blocks as usize as u64, additional_blocks);\n+            self.blocks.extend(\n+                iter::repeat(0).take(additional_blocks as usize),\n+            );\n+        }\n+        let start = self.len;\n+        self.len += amount;\n+        self.set_range_inbounds(start, start + amount, new_state);\n+    }\n+}\n+\n+fn bit_index(bits: u64) -> (usize, usize) {\n+    let a = bits / BLOCK_SIZE;\n+    let b = bits % BLOCK_SIZE;\n+    assert_eq!(a as usize as u64, a);\n+    assert_eq!(b as usize as u64, b);\n+    (a as usize, b as usize)\n+}"}, {"sha": "33b177b60a81b03550c1985e6c33a9664378bb69", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 22, "deletions": 73, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=acac58502b3d86c5808d8d152d7870f8c6423074", "patch": "@@ -2,18 +2,37 @@\n \n use ty::layout::HasDataLayout;\n \n-use super::{EvalResult, Memory, MemoryPointer, HasMemory, PointerArithmetic, Machine, PtrAndAlign};\n+use super::{EvalResult, MemoryPointer, PointerArithmetic};\n use syntax::ast::FloatTy;\n use rustc_const_math::ConstFloat;\n \n-pub(super) fn bytes_to_f32(bits: u128) -> ConstFloat {\n+#[derive(Copy, Clone, Debug)]\n+pub struct PtrAndAlign {\n+    pub ptr: Pointer,\n+    /// Remember whether this place is *supposed* to be aligned.\n+    pub aligned: bool,\n+}\n+\n+impl PtrAndAlign {\n+    pub fn to_ptr<'tcx>(self) -> EvalResult<'tcx, MemoryPointer> {\n+        self.ptr.to_ptr()\n+    }\n+    pub fn offset<'tcx, C: HasDataLayout>(self, i: u64, cx: C) -> EvalResult<'tcx, Self> {\n+        Ok(PtrAndAlign {\n+            ptr: self.ptr.offset(i, cx)?,\n+            aligned: self.aligned,\n+        })\n+    }\n+}\n+\n+pub fn bytes_to_f32(bits: u128) -> ConstFloat {\n     ConstFloat {\n         bits,\n         ty: FloatTy::F32,\n     }\n }\n \n-pub(super) fn bytes_to_f64(bits: u128) -> ConstFloat {\n+pub fn bytes_to_f64(bits: u128) -> ConstFloat {\n     ConstFloat {\n         bits,\n         ty: FloatTy::F64,\n@@ -168,76 +187,6 @@ impl<'a, 'tcx: 'a> Value {\n     pub fn by_ref(ptr: Pointer) -> Self {\n         Value::ByRef(PtrAndAlign { ptr, aligned: true })\n     }\n-\n-    /// Convert the value into a pointer (or a pointer-sized integer).  If the value is a ByRef,\n-    /// this may have to perform a load.\n-    pub fn into_ptr<M: Machine<'tcx>>(\n-        &self,\n-        mem: &Memory<'a, 'tcx, M>,\n-    ) -> EvalResult<'tcx, Pointer> {\n-        use self::Value::*;\n-        Ok(match *self {\n-            ByRef(PtrAndAlign { ptr, aligned }) => {\n-                mem.read_maybe_aligned(aligned, |mem| mem.read_ptr_sized_unsigned(ptr.to_ptr()?))?\n-            }\n-            ByVal(ptr) |\n-            ByValPair(ptr, _) => ptr,\n-        }.into())\n-    }\n-\n-    pub(super) fn into_ptr_vtable_pair<M: Machine<'tcx>>(\n-        &self,\n-        mem: &Memory<'a, 'tcx, M>,\n-    ) -> EvalResult<'tcx, (Pointer, MemoryPointer)> {\n-        use self::Value::*;\n-        match *self {\n-            ByRef(PtrAndAlign {\n-                      ptr: ref_ptr,\n-                      aligned,\n-                  }) => {\n-                mem.read_maybe_aligned(aligned, |mem| {\n-                    let ptr = mem.read_ptr_sized_unsigned(ref_ptr.to_ptr()?)?.into();\n-                    let vtable = mem.read_ptr_sized_unsigned(\n-                        ref_ptr.offset(mem.pointer_size(), &mem.tcx.data_layout)?.to_ptr()?,\n-                    )?.to_ptr()?;\n-                    Ok((ptr, vtable))\n-                })\n-            }\n-\n-            ByValPair(ptr, vtable) => Ok((ptr.into(), vtable.to_ptr()?)),\n-\n-            ByVal(PrimVal::Undef) => err!(ReadUndefBytes),\n-            _ => bug!(\"expected ptr and vtable, got {:?}\", self),\n-        }\n-    }\n-\n-    pub(super) fn into_slice<M: Machine<'tcx>>(\n-        &self,\n-        mem: &Memory<'a, 'tcx, M>,\n-    ) -> EvalResult<'tcx, (Pointer, u64)> {\n-        use self::Value::*;\n-        match *self {\n-            ByRef(PtrAndAlign {\n-                      ptr: ref_ptr,\n-                      aligned,\n-                  }) => {\n-                mem.read_maybe_aligned(aligned, |mem| {\n-                    let ptr = mem.read_ptr_sized_unsigned(ref_ptr.to_ptr()?)?.into();\n-                    let len = mem.read_ptr_sized_unsigned(\n-                        ref_ptr.offset(mem.pointer_size(), &mem.tcx.data_layout)?.to_ptr()?,\n-                    )?.to_bytes()? as u64;\n-                    Ok((ptr, len))\n-                })\n-            }\n-            ByValPair(ptr, val) => {\n-                let len = val.to_u128()?;\n-                assert_eq!(len as u64 as u128, len);\n-                Ok((ptr.into(), len as u64))\n-            }\n-            ByVal(PrimVal::Undef) => err!(ReadUndefBytes),\n-            ByVal(_) => bug!(\"expected ptr and length, got {:?}\", self),\n-        }\n-    }\n }\n \n impl<'tcx> PrimVal {"}, {"sha": "81cd63b5407c3b67de09c43e47442e4d21ae53d1", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 0, "deletions": 295, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=acac58502b3d86c5808d8d152d7870f8c6423074", "patch": "@@ -23,12 +23,6 @@ use rustc::ty::subst::{Substs, Subst};\n use rustc::util::common::ErrorReported;\n use rustc::util::nodemap::NodeMap;\n \n-use rustc::mir::interpret::{PrimVal, Value, PtrAndAlign, HasMemory, EvalError};\n-use rustc::mir::interpret::{CompileTimeEvaluator, EvalContext};\n-use rustc::mir::Field;\n-use rustc::mir::interpret::{Place, PlaceExtra};\n-use rustc_data_structures::indexed_vec::Idx;\n-\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax::attr;\n@@ -688,292 +682,3 @@ impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n         compare_const_vals(tcx, span, &a.val, &b.val)\n     }\n }\n-\n-pub(crate) fn const_eval<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                        key: ty::ParamEnvAnd<'tcx, (DefId, &'tcx Substs<'tcx>)>)\n-                        -> EvalResult<'tcx> {\n-    trace!(\"const eval: {:?}\", key);\n-    let (def_id, substs) = if let Some(resolved) = lookup_const_by_id(tcx, key) {\n-        resolved\n-    } else {\n-        return Err(ConstEvalErr {\n-            span: tcx.def_span(key.value.0),\n-            kind: TypeckError\n-        });\n-    };\n-\n-    let tables = tcx.typeck_tables_of(def_id);\n-    let body = if let Some(id) = tcx.hir.as_local_node_id(def_id) {\n-        let body_id = tcx.hir.body_owned_by(id);\n-\n-        // Do match-check before building MIR\n-        if tcx.check_match(def_id).is_err() {\n-            return Err(ConstEvalErr {\n-                span: tcx.def_span(key.value.0),\n-                kind: CheckMatchError,\n-            });\n-        }\n-\n-        tcx.mir_const_qualif(def_id);\n-        tcx.hir.body(body_id)\n-    } else {\n-        tcx.extern_const_body(def_id).body\n-    };\n-\n-    // do not continue into miri if typeck errors occurred\n-    // it will fail horribly\n-    if tables.tainted_by_errors {\n-        signal!(&body.value, TypeckError);\n-    }\n-\n-    trace!(\"running old const eval\");\n-    let old_result = ConstContext::new(tcx, key.param_env.and(substs), tables).eval(&body.value);\n-    trace!(\"old const eval produced {:?}\", old_result);\n-    if tcx.sess.opts.debugging_opts.miri {\n-        let instance = ty::Instance::new(def_id, substs);\n-        trace!(\"const eval instance: {:?}, {:?}\", instance, key.param_env);\n-        let miri_result = ::rustc::mir::interpret::eval_body(tcx, instance, key.param_env);\n-        match (miri_result, old_result) {\n-            ((Err(err), ecx), Ok(ok)) => {\n-                trace!(\"miri failed, ctfe returned {:?}\", ok);\n-                tcx.sess.span_warn(\n-                    tcx.def_span(key.value.0),\n-                    \"miri failed to eval, while ctfe succeeded\",\n-                );\n-                let () = unwrap_miri(&ecx, Err(err));\n-                Ok(ok)\n-            },\n-            ((Ok(_), _), Err(err)) => {\n-                Err(err)\n-            },\n-            ((Err(_), _), Err(err)) => Err(err),\n-            ((Ok((miri_val, miri_ty)), mut ecx), Ok(ctfe)) => {\n-                check_ctfe_against_miri(&mut ecx, miri_val, miri_ty, ctfe.val);\n-                Ok(ctfe)\n-            }\n-        }\n-    } else {\n-        old_result\n-    }\n-}\n-\n-fn check_ctfe_against_miri<'a, 'tcx>(\n-    ecx: &mut EvalContext<'a, 'tcx, CompileTimeEvaluator>,\n-    miri_val: PtrAndAlign,\n-    miri_ty: Ty<'tcx>,\n-    ctfe: ConstVal<'tcx>,\n-) {\n-    use rustc::ty::TypeVariants::*;\n-    match miri_ty.sty {\n-        TyInt(int_ty) => {\n-            let value = ecx.read_maybe_aligned(miri_val.aligned, |ectx| {\n-                ectx.try_read_value(miri_val.ptr, miri_ty)\n-            });\n-            let prim = get_prim(ecx, value);\n-            let c = ConstInt::new_signed_truncating(prim as i128,\n-                                                    int_ty,\n-                                                    ecx.tcx.sess.target.isize_ty);\n-            let c = ConstVal::Integral(c);\n-            assert_eq!(c, ctfe, \"miri evaluated to {:?}, but ctfe yielded {:?}\", c, ctfe);\n-        },\n-        TyUint(uint_ty) => {\n-            let value = ecx.read_maybe_aligned(miri_val.aligned, |ectx| {\n-                ectx.try_read_value(miri_val.ptr, miri_ty)\n-            });\n-            let prim = get_prim(ecx, value);\n-            let c = ConstInt::new_unsigned_truncating(prim,\n-                                                     uint_ty,\n-                                                     ecx.tcx.sess.target.usize_ty);\n-            let c = ConstVal::Integral(c);\n-            assert_eq!(c, ctfe, \"miri evaluated to {:?}, but ctfe yielded {:?}\", c, ctfe);\n-        },\n-        TyFloat(ty) => {\n-            let value = ecx.read_maybe_aligned(miri_val.aligned, |ectx| {\n-                ectx.try_read_value(miri_val.ptr, miri_ty)\n-            });\n-            let prim = get_prim(ecx, value);\n-            let f = ConstVal::Float(ConstFloat { bits: prim, ty });\n-            assert_eq!(f, ctfe, \"miri evaluated to {:?}, but ctfe yielded {:?}\", f, ctfe);\n-        },\n-        TyBool => {\n-            let value = ecx.read_maybe_aligned(miri_val.aligned, |ectx| {\n-                ectx.try_read_value(miri_val.ptr, miri_ty)\n-            });\n-            let bits = get_prim(ecx, value);\n-            if bits > 1 {\n-                bug!(\"miri evaluated to {}, but expected a bool {:?}\", bits, ctfe);\n-            }\n-            let b = ConstVal::Bool(bits == 1);\n-            assert_eq!(b, ctfe, \"miri evaluated to {:?}, but ctfe yielded {:?}\", b, ctfe);\n-        },\n-        TyChar => {\n-            let value = ecx.read_maybe_aligned(miri_val.aligned, |ectx| {\n-                ectx.try_read_value(miri_val.ptr, miri_ty)\n-            });\n-            let bits = get_prim(ecx, value);\n-            if let Some(cm) = ::std::char::from_u32(bits as u32) {\n-                assert_eq!(\n-                    ConstVal::Char(cm), ctfe,\n-                    \"miri evaluated to {:?}, but expected {:?}\", cm, ctfe,\n-                );\n-            } else {\n-                bug!(\"miri evaluated to {}, but expected a char {:?}\", bits, ctfe);\n-            }\n-        },\n-        TyStr => {\n-            let value = ecx.read_maybe_aligned(miri_val.aligned, |ectx| {\n-                ectx.try_read_value(miri_val.ptr, miri_ty)\n-            });\n-            if let Ok(Some(Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::Bytes(len)))) = value {\n-                let bytes = ecx\n-                    .memory\n-                    .read_bytes(ptr.into(), len as u64)\n-                    .expect(\"bad miri memory for str\");\n-                if let Ok(s) = ::std::str::from_utf8(bytes) {\n-                    if let ConstVal::Str(s2) = ctfe {\n-                        assert_eq!(s, s2, \"miri produced {:?}, but expected {:?}\", s, s2);\n-                    } else {\n-                        bug!(\"miri produced {:?}, but expected {:?}\", s, ctfe);\n-                    }\n-                } else {\n-                    bug!(\n-                        \"miri failed to produce valid utf8 {:?}, while ctfe produced {:?}\",\n-                        bytes,\n-                        ctfe,\n-                    );\n-                }\n-            } else {\n-                bug!(\"miri evaluated to {:?}, but expected a str {:?}\", value, ctfe);\n-            }\n-        },\n-        TyArray(elem_ty, n) => {\n-            let n = n.val.to_const_int().unwrap().to_u64().unwrap();\n-            let size = ecx.layout_of(elem_ty).unwrap().size.bytes();\n-            let vec: Vec<(ConstVal, Ty<'tcx>)> = match ctfe {\n-                ConstVal::ByteStr(arr) => arr.data.iter().map(|&b| {\n-                    (ConstVal::Integral(ConstInt::U8(b)), ecx.tcx.types.u8)\n-                }).collect(),\n-                ConstVal::Aggregate(Array(v)) => {\n-                    v.iter().map(|c| (c.val, c.ty)).collect()\n-                },\n-                ConstVal::Aggregate(Repeat(v, n)) => {\n-                    vec![(v.val, v.ty); n as usize]\n-                },\n-                _ => bug!(\"miri produced {:?}, but ctfe yielded {:?}\", miri_ty, ctfe),\n-            };\n-            for (i, elem) in vec.into_iter().enumerate() {\n-                assert!((i as u64) < n);\n-                let ptr = miri_val.offset(size * i as u64, &ecx).unwrap();\n-                check_ctfe_against_miri(ecx, ptr, elem_ty, elem.0);\n-            }\n-        },\n-        TyTuple(..) => {\n-            let vec = match ctfe {\n-                ConstVal::Aggregate(Tuple(v)) => v,\n-                _ => bug!(\"miri produced {:?}, but ctfe yielded {:?}\", miri_ty, ctfe),\n-            };\n-            let layout = ecx.layout_of(miri_ty).unwrap();\n-            for (i, elem) in vec.into_iter().enumerate() {\n-                let offset = layout.fields.offset(i);\n-                let ptr = miri_val.offset(offset.bytes(), &ecx).unwrap();\n-                check_ctfe_against_miri(ecx, ptr, elem.ty, elem.val);\n-            }\n-        },\n-        TyAdt(def, _) => {\n-            let (struct_variant, extra) = if def.is_enum() {\n-                let discr = ecx.read_discriminant_value(\n-                    Place::Ptr { ptr: miri_val, extra: PlaceExtra::None },\n-                    miri_ty).unwrap();\n-                let variant = def.discriminants(ecx.tcx).position(|variant_discr| {\n-                    variant_discr.to_u128_unchecked() == discr\n-                }).expect(\"miri produced invalid enum discriminant\");\n-                (&def.variants[variant], PlaceExtra::DowncastVariant(variant))\n-            } else {\n-                (def.struct_variant(), PlaceExtra::None)\n-            };\n-            let vec = match ctfe {\n-                ConstVal::Aggregate(Struct(v)) => v,\n-                ConstVal::Variant(did) => {\n-                    assert_eq!(struct_variant.fields.len(), 0);\n-                    assert_eq!(did, struct_variant.did);\n-                    return;\n-                },\n-                ctfe => bug!(\"miri produced {:?}, but ctfe yielded {:?}\", miri_ty, ctfe),\n-            };\n-            let layout = ecx.layout_of(miri_ty).unwrap();\n-            for &(name, elem) in vec.into_iter() {\n-                let field = struct_variant.fields.iter().position(|f| f.name == name).unwrap();\n-                let (place, _) = ecx.place_field(\n-                    Place::Ptr { ptr: miri_val, extra },\n-                    Field::new(field),\n-                    layout,\n-                ).unwrap();\n-                let ptr = place.to_ptr_extra_aligned().0;\n-                check_ctfe_against_miri(ecx, ptr, elem.ty, elem.val);\n-            }\n-        },\n-        TySlice(_) => bug!(\"miri produced a slice?\"),\n-        // not supported by ctfe\n-        TyRawPtr(_) |\n-        TyRef(..) => {}\n-        TyDynamic(..) => bug!(\"miri produced a trait object\"),\n-        TyClosure(..) => bug!(\"miri produced a closure\"),\n-        TyGenerator(..) => bug!(\"miri produced a generator\"),\n-        TyNever => bug!(\"miri produced a value of the never type\"),\n-        TyProjection(_) => bug!(\"miri produced a projection\"),\n-        TyAnon(..) => bug!(\"miri produced an impl Trait type\"),\n-        TyParam(_) => bug!(\"miri produced an unmonomorphized type\"),\n-        TyInfer(_) => bug!(\"miri produced an uninferred type\"),\n-        TyError => bug!(\"miri produced a type error\"),\n-        TyForeign(_) => bug!(\"miri produced an extern type\"),\n-        // should be fine\n-        TyFnDef(..) => {}\n-        TyFnPtr(_) => {\n-            let value = ecx.read_maybe_aligned(miri_val.aligned, |ectx| {\n-                ectx.try_read_value(miri_val.ptr, miri_ty)\n-            });\n-            let ptr = match value {\n-                Ok(Some(Value::ByVal(PrimVal::Ptr(ptr)))) => ptr,\n-                value => bug!(\"expected fn ptr, got {:?}\", value),\n-            };\n-            let inst = ecx.memory.get_fn(ptr).unwrap();\n-            match ctfe {\n-                ConstVal::Function(did, substs) => {\n-                    let ctfe = ty::Instance::resolve(\n-                        ecx.tcx,\n-                        ecx.param_env,\n-                        did,\n-                        substs,\n-                    ).unwrap();\n-                    assert_eq!(inst, ctfe, \"expected fn ptr {:?}, but got {:?}\", ctfe, inst);\n-                },\n-                _ => bug!(\"ctfe produced {:?}, but miri produced function {:?}\", ctfe, inst),\n-            }\n-        },\n-    }\n-}\n-\n-fn get_prim<'a, 'tcx>(\n-    ecx: &mut EvalContext<'a, 'tcx, CompileTimeEvaluator>,\n-    res: Result<Option<Value>, EvalError<'tcx>>,\n-) -> u128 {\n-    match res {\n-        Ok(Some(Value::ByVal(prim))) => unwrap_miri(ecx, prim.to_bytes()),\n-        Err(err) => unwrap_miri(ecx, Err(err)),\n-        val => bug!(\"got {:?}\", val),\n-    }\n-}\n-\n-fn unwrap_miri<'a, 'tcx, T>(\n-    ecx: &EvalContext<'a, 'tcx, CompileTimeEvaluator>,\n-    res: Result<T, EvalError<'tcx>>,\n-) -> T {\n-    match res {\n-        Ok(val) => val,\n-        Err(mut err) => {\n-            ecx.report(&mut err);\n-            ecx.tcx.sess.abort_if_errors();\n-            bug!(\"{:#?}\", err);\n-        }\n-    }\n-}"}, {"sha": "9d636b48bd0c5d4ae6d524cf0289e0114c5e470d", "filename": "src/librustc_const_eval/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_const_eval%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_const_eval%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Flib.rs?ref=acac58502b3d86c5808d8d152d7870f8c6423074", "patch": "@@ -50,7 +50,6 @@ use rustc::ty::maps::Providers;\n \n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n-        const_eval: eval::const_eval,\n         check_match: check_match::check_match,\n         ..*providers\n     };"}, {"sha": "1846b753ffd5bde51db9decbd38f05f1839e9078", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=acac58502b3d86c5808d8d152d7870f8c6423074", "patch": "@@ -12,6 +12,8 @@ crate-type = [\"dylib\"]\n bitflags = \"1.0\"\n graphviz = { path = \"../libgraphviz\" }\n log = \"0.3\"\n+log_settings = \"0.1.1\"\n+lazy_static = \"1.0\"\n rustc = { path = \"../librustc\" }\n rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n@@ -20,3 +22,6 @@ rustc_errors = { path = \"../librustc_errors\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n+byteorder = { version = \"1.1\", features = [\"i128\"] }\n+regex = \"0.2\"\n+rustc_apfloat = { path = \"../librustc_apfloat\" }"}, {"sha": "6f4a28fb28f013534f7bcf9ba739b707645b2071", "filename": "src/librustc_mir/interpret/cast.rs", "status": "renamed", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=acac58502b3d86c5808d8d152d7870f8c6423074", "patch": "@@ -1,8 +1,9 @@\n-use ty::Ty;\n+use rustc::ty::Ty;\n use syntax::ast::{FloatTy, IntTy, UintTy};\n \n use rustc_const_math::ConstFloat;\n-use super::{PrimVal, EvalContext, EvalResult, MemoryPointer, PointerArithmetic, Machine};\n+use super::{EvalContext, Machine};\n+use rustc::mir::interpret::{PrimVal, EvalResult, MemoryPointer, PointerArithmetic};\n use rustc_apfloat::ieee::{Single, Double};\n use rustc_apfloat::Float;\n \n@@ -20,7 +21,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             PrimVal::Undef => Ok(PrimVal::Undef),\n             PrimVal::Ptr(ptr) => self.cast_from_ptr(ptr, dest_ty),\n             val @ PrimVal::Bytes(_) => {\n-                use super::PrimValKind::*;\n+                use rustc::mir::interpret::PrimValKind::*;\n                 match src_kind {\n                     F32 => self.cast_from_float(val.to_f32()?, dest_ty),\n                     F64 => self.cast_from_float(val.to_f64()?, dest_ty),\n@@ -75,7 +76,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         negative: bool,\n     ) -> EvalResult<'tcx, PrimVal> {\n         trace!(\"cast_from_int: {}, {}, {}\", v, ty, negative);\n-        use ty::TypeVariants::*;\n+        use rustc::ty::TypeVariants::*;\n         match ty.sty {\n             // Casts to bool are not permitted by rustc, no need to handle them here.\n             TyInt(ty) => Ok(PrimVal::Bytes(self.int_to_int(v as i128, ty))),\n@@ -95,7 +96,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     }\n \n     fn cast_from_float(&self, val: ConstFloat, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n-        use ty::TypeVariants::*;\n+        use rustc::ty::TypeVariants::*;\n         match ty.sty {\n             TyUint(t) => {\n                 let width = t.bit_width().unwrap_or(self.memory.pointer_size() as usize * 8);\n@@ -119,7 +120,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     }\n \n     fn cast_from_ptr(&self, ptr: MemoryPointer, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n-        use ty::TypeVariants::*;\n+        use rustc::ty::TypeVariants::*;\n         match ty.sty {\n             // Casting to a reference or fn pointer is not permitted by rustc, no need to support it here.\n             TyRawPtr(_) |", "previous_filename": "src/librustc/mir/interpret/cast.rs"}, {"sha": "a78cd8477617f4fd57d14ebd696acd488d7c11df", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "added", "additions": 587, "deletions": 0, "changes": 587, "blob_url": "https://github.com/rust-lang/rust/blob/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=acac58502b3d86c5808d8d152d7870f8c6423074", "patch": "@@ -0,0 +1,587 @@\n+use rustc::ty::{self, TyCtxt, Ty, Instance};\n+use rustc::ty::layout::{self, LayoutOf};\n+use rustc::ty::subst::Substs;\n+use rustc::hir::def_id::DefId;\n+use rustc::mir;\n+use rustc::middle::const_val::ErrKind::{CheckMatchError, TypeckError};\n+use rustc::middle::const_val::{ConstEvalErr, ConstVal};\n+use rustc_const_eval::{lookup_const_by_id, ConstContext};\n+use rustc::mir::Field;\n+use rustc_data_structures::indexed_vec::Idx;\n+\n+use syntax::ast::Mutability;\n+use syntax::codemap::Span;\n+\n+use rustc::mir::interpret::{EvalResult, EvalError, EvalErrorKind, GlobalId, Value, PrimVal, PtrAndAlign};\n+use super::{Place, PlaceExtra, EvalContext, StackPopCleanup, ValTy, HasMemory};\n+\n+use rustc_const_math::ConstInt;\n+\n+use std::fmt;\n+use std::error::Error;\n+\n+pub fn eval_body<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    instance: Instance<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+) -> (EvalResult<'tcx, (PtrAndAlign, Ty<'tcx>)>, EvalContext<'a, 'tcx, CompileTimeEvaluator>) {\n+    debug!(\"eval_body: {:?}, {:?}\", instance, param_env);\n+    let limits = super::ResourceLimits::default();\n+    let mut ecx = EvalContext::new(tcx, param_env, limits, CompileTimeEvaluator, ());\n+    let cid = GlobalId {\n+        instance,\n+        promoted: None,\n+    };\n+\n+    let try = (|| {\n+        if ecx.tcx.has_attr(instance.def_id(), \"linkage\") {\n+            return Err(ConstEvalError::NotConst(\"extern global\".to_string()).into());\n+        }\n+        // FIXME(eddyb) use `Instance::ty` when it becomes available.\n+        let instance_ty =\n+            ecx.monomorphize(instance.def.def_ty(tcx), instance.substs);\n+        if tcx.interpret_interner.borrow().get_cached(cid).is_none() {\n+            let mir = ecx.load_mir(instance.def)?;\n+            let layout = ecx.layout_of(instance_ty)?;\n+            assert!(!layout.is_unsized());\n+            let ptr = ecx.memory.allocate(\n+                layout.size.bytes(),\n+                layout.align.abi(),\n+                None,\n+            )?;\n+            tcx.interpret_interner.borrow_mut().cache(\n+                cid,\n+                PtrAndAlign {\n+                    ptr: ptr.into(),\n+                    aligned: !layout.is_packed(),\n+                },\n+            );\n+            let cleanup = StackPopCleanup::MarkStatic(Mutability::Immutable);\n+            let name = ty::tls::with(|tcx| tcx.item_path_str(instance.def_id()));\n+            trace!(\"const_eval: pushing stack frame for global: {}\", name);\n+            ecx.push_stack_frame(\n+                instance,\n+                mir.span,\n+                mir,\n+                Place::from_ptr(ptr),\n+                cleanup.clone(),\n+            )?;\n+\n+            while ecx.step()? {}\n+\n+            // reinsert the stack frame so any future queries have the correct substs\n+            ecx.push_stack_frame(\n+                instance,\n+                mir.span,\n+                mir,\n+                Place::from_ptr(ptr),\n+                cleanup,\n+            )?;\n+        }\n+        let value = tcx.interpret_interner.borrow().get_cached(cid).expect(\"global not cached\");\n+        Ok((value, instance_ty))\n+    })();\n+    (try, ecx)\n+}\n+\n+pub fn eval_body_as_integer<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    instance: Instance<'tcx>,\n+) -> EvalResult<'tcx, ConstInt> {\n+    let (ptr_ty, ecx) = eval_body(tcx, instance, param_env);\n+    let (ptr, ty) = ptr_ty?;\n+    let prim = match ecx.read_maybe_aligned(ptr.aligned, |ectx| ectx.try_read_value(ptr.ptr, ty))? {\n+        Some(Value::ByVal(prim)) => prim.to_bytes()?,\n+        _ => return err!(TypeNotPrimitive(ty)),\n+    };\n+    use syntax::ast::{IntTy, UintTy};\n+    use rustc::ty::TypeVariants::*;\n+    use rustc_const_math::{ConstIsize, ConstUsize};\n+    Ok(match ty.sty {\n+        TyInt(IntTy::I8) => ConstInt::I8(prim as i128 as i8),\n+        TyInt(IntTy::I16) => ConstInt::I16(prim as i128 as i16),\n+        TyInt(IntTy::I32) => ConstInt::I32(prim as i128 as i32),\n+        TyInt(IntTy::I64) => ConstInt::I64(prim as i128 as i64),\n+        TyInt(IntTy::I128) => ConstInt::I128(prim as i128),\n+        TyInt(IntTy::Is) => ConstInt::Isize(\n+            ConstIsize::new(prim as i128 as i64, tcx.sess.target.isize_ty)\n+                .expect(\"miri should already have errored\"),\n+        ),\n+        TyUint(UintTy::U8) => ConstInt::U8(prim as u8),\n+        TyUint(UintTy::U16) => ConstInt::U16(prim as u16),\n+        TyUint(UintTy::U32) => ConstInt::U32(prim as u32),\n+        TyUint(UintTy::U64) => ConstInt::U64(prim as u64),\n+        TyUint(UintTy::U128) => ConstInt::U128(prim),\n+        TyUint(UintTy::Us) => ConstInt::Usize(\n+            ConstUsize::new(prim as u64, tcx.sess.target.usize_ty)\n+                .expect(\"miri should already have errored\"),\n+        ),\n+        _ => {\n+            return Err(\n+                ConstEvalError::NeedsRfc(\n+                    \"evaluating anything other than isize/usize during typeck\".to_string(),\n+                ).into(),\n+            )\n+        }\n+    })\n+}\n+\n+pub struct CompileTimeEvaluator;\n+\n+impl<'tcx> Into<EvalError<'tcx>> for ConstEvalError {\n+    fn into(self) -> EvalError<'tcx> {\n+        EvalErrorKind::MachineError(Box::new(self)).into()\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+enum ConstEvalError {\n+    NeedsRfc(String),\n+    NotConst(String),\n+}\n+\n+impl fmt::Display for ConstEvalError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        use self::ConstEvalError::*;\n+        match *self {\n+            NeedsRfc(ref msg) => {\n+                write!(\n+                    f,\n+                    \"\\\"{}\\\" needs an rfc before being allowed inside constants\",\n+                    msg\n+                )\n+            }\n+            NotConst(ref msg) => write!(f, \"Cannot evaluate within constants: \\\"{}\\\"\", msg),\n+        }\n+    }\n+}\n+\n+impl Error for ConstEvalError {\n+    fn description(&self) -> &str {\n+        use self::ConstEvalError::*;\n+        match *self {\n+            NeedsRfc(_) => \"this feature needs an rfc before being allowed inside constants\",\n+            NotConst(_) => \"this feature is not compatible with constant evaluation\",\n+        }\n+    }\n+\n+    fn cause(&self) -> Option<&Error> {\n+        None\n+    }\n+}\n+\n+impl<'tcx> super::Machine<'tcx> for CompileTimeEvaluator {\n+    type MemoryData = ();\n+    type MemoryKinds = !;\n+    fn eval_fn_call<'a>(\n+        ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        instance: ty::Instance<'tcx>,\n+        destination: Option<(Place, mir::BasicBlock)>,\n+        _args: &[ValTy<'tcx>],\n+        span: Span,\n+        _sig: ty::FnSig<'tcx>,\n+    ) -> EvalResult<'tcx, bool> {\n+        debug!(\"eval_fn_call: {:?}\", instance);\n+        if !ecx.tcx.is_const_fn(instance.def_id()) {\n+            return Err(\n+                ConstEvalError::NotConst(format!(\"calling non-const fn `{}`\", instance)).into(),\n+            );\n+        }\n+        let mir = match ecx.load_mir(instance.def) {\n+            Ok(mir) => mir,\n+            Err(EvalError { kind: EvalErrorKind::NoMirFor(path), .. }) => {\n+                // some simple things like `malloc` might get accepted in the future\n+                return Err(\n+                    ConstEvalError::NeedsRfc(format!(\"calling extern function `{}`\", path))\n+                        .into(),\n+                );\n+            }\n+            Err(other) => return Err(other),\n+        };\n+        let (return_place, return_to_block) = match destination {\n+            Some((place, block)) => (place, StackPopCleanup::Goto(block)),\n+            None => (Place::undef(), StackPopCleanup::None),\n+        };\n+\n+        ecx.push_stack_frame(\n+            instance,\n+            span,\n+            mir,\n+            return_place,\n+            return_to_block,\n+        )?;\n+\n+        Ok(false)\n+    }\n+\n+\n+    fn call_intrinsic<'a>(\n+        ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        instance: ty::Instance<'tcx>,\n+        _args: &[ValTy<'tcx>],\n+        dest: Place,\n+        dest_layout: layout::TyLayout<'tcx>,\n+        target: mir::BasicBlock,\n+    ) -> EvalResult<'tcx> {\n+        let substs = instance.substs;\n+\n+        let intrinsic_name = &ecx.tcx.item_name(instance.def_id())[..];\n+        match intrinsic_name {\n+            \"min_align_of\" => {\n+                let elem_ty = substs.type_at(0);\n+                let elem_align = ecx.layout_of(elem_ty)?.align.abi();\n+                let align_val = PrimVal::from_u128(elem_align as u128);\n+                ecx.write_primval(dest, align_val, dest_layout.ty)?;\n+            }\n+\n+            \"size_of\" => {\n+                let ty = substs.type_at(0);\n+                let size = ecx.layout_of(ty)?.size.bytes() as u128;\n+                ecx.write_primval(dest, PrimVal::from_u128(size), dest_layout.ty)?;\n+            }\n+\n+            name => return Err(ConstEvalError::NeedsRfc(format!(\"calling intrinsic `{}`\", name)).into()),\n+        }\n+\n+        ecx.goto_block(target);\n+\n+        // Since we pushed no stack frame, the main loop will act\n+        // as if the call just completed and it's returning to the\n+        // current frame.\n+        Ok(())\n+    }\n+\n+    fn try_ptr_op<'a>(\n+        _ecx: &EvalContext<'a, 'tcx, Self>,\n+        _bin_op: mir::BinOp,\n+        left: PrimVal,\n+        _left_ty: Ty<'tcx>,\n+        right: PrimVal,\n+        _right_ty: Ty<'tcx>,\n+    ) -> EvalResult<'tcx, Option<(PrimVal, bool)>> {\n+        if left.is_bytes() && right.is_bytes() {\n+            Ok(None)\n+        } else {\n+            Err(\n+                ConstEvalError::NeedsRfc(\"Pointer arithmetic or comparison\".to_string()).into(),\n+            )\n+        }\n+    }\n+\n+    fn mark_static_initialized(m: !) -> EvalResult<'tcx> {\n+        m\n+    }\n+\n+    fn box_alloc<'a>(\n+        _ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        _ty: Ty<'tcx>,\n+        _dest: Place,\n+    ) -> EvalResult<'tcx> {\n+        Err(\n+            ConstEvalError::NeedsRfc(\"Heap allocations via `box` keyword\".to_string()).into(),\n+        )\n+    }\n+\n+    fn global_item_with_linkage<'a>(\n+        _ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        _instance: ty::Instance<'tcx>,\n+        _mutability: Mutability,\n+    ) -> EvalResult<'tcx> {\n+        Err(\n+            ConstEvalError::NotConst(\"statics with `linkage` attribute\".to_string()).into(),\n+        )\n+    }\n+}\n+\n+pub fn const_eval_provider<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    key: ty::ParamEnvAnd<'tcx, (DefId, &'tcx Substs<'tcx>)>,\n+) -> ::rustc::middle::const_val::EvalResult<'tcx> {\n+    trace!(\"const eval: {:?}\", key);\n+    let (def_id, substs) = if let Some(resolved) = lookup_const_by_id(tcx, key) {\n+        resolved\n+    } else {\n+        return Err(ConstEvalErr {\n+            span: tcx.def_span(key.value.0),\n+            kind: TypeckError\n+        });\n+    };\n+\n+    let tables = tcx.typeck_tables_of(def_id);\n+    let body = if let Some(id) = tcx.hir.as_local_node_id(def_id) {\n+        let body_id = tcx.hir.body_owned_by(id);\n+\n+        // Do match-check before building MIR\n+        if tcx.check_match(def_id).is_err() {\n+            return Err(ConstEvalErr {\n+                span: tcx.def_span(key.value.0),\n+                kind: CheckMatchError,\n+            });\n+        }\n+\n+        tcx.mir_const_qualif(def_id);\n+        tcx.hir.body(body_id)\n+    } else {\n+        tcx.extern_const_body(def_id).body\n+    };\n+\n+    // do not continue into miri if typeck errors occurred\n+    // it will fail horribly\n+    if tables.tainted_by_errors {\n+        return Err(ConstEvalErr { span: body.value.span, kind: TypeckError })\n+    }\n+\n+    trace!(\"running old const eval\");\n+    let old_result = ConstContext::new(tcx, key.param_env.and(substs), tables).eval(&body.value);\n+    trace!(\"old const eval produced {:?}\", old_result);\n+    if tcx.sess.opts.debugging_opts.miri {\n+        let instance = ty::Instance::new(def_id, substs);\n+        trace!(\"const eval instance: {:?}, {:?}\", instance, key.param_env);\n+        let miri_result = ::interpret::eval_body(tcx, instance, key.param_env);\n+        match (miri_result, old_result) {\n+            ((Err(err), ecx), Ok(ok)) => {\n+                trace!(\"miri failed, ctfe returned {:?}\", ok);\n+                tcx.sess.span_warn(\n+                    tcx.def_span(key.value.0),\n+                    \"miri failed to eval, while ctfe succeeded\",\n+                );\n+                let () = unwrap_miri(&ecx, Err(err));\n+                Ok(ok)\n+            },\n+            ((Ok(_), _), Err(err)) => {\n+                Err(err)\n+            },\n+            ((Err(_), _), Err(err)) => Err(err),\n+            ((Ok((miri_val, miri_ty)), mut ecx), Ok(ctfe)) => {\n+                check_ctfe_against_miri(&mut ecx, miri_val, miri_ty, ctfe.val);\n+                Ok(ctfe)\n+            }\n+        }\n+    } else {\n+        old_result\n+    }\n+}\n+\n+fn check_ctfe_against_miri<'a, 'tcx>(\n+    ecx: &mut EvalContext<'a, 'tcx, CompileTimeEvaluator>,\n+    miri_val: PtrAndAlign,\n+    miri_ty: Ty<'tcx>,\n+    ctfe: ConstVal<'tcx>,\n+) {\n+    use rustc::middle::const_val::ConstAggregate::*;\n+    use rustc_const_math::ConstFloat;\n+    use rustc::ty::TypeVariants::*;\n+    match miri_ty.sty {\n+        TyInt(int_ty) => {\n+            let value = ecx.read_maybe_aligned(miri_val.aligned, |ectx| {\n+                ectx.try_read_value(miri_val.ptr, miri_ty)\n+            });\n+            let prim = get_prim(ecx, value);\n+            let c = ConstInt::new_signed_truncating(prim as i128,\n+                                                    int_ty,\n+                                                    ecx.tcx.sess.target.isize_ty);\n+            let c = ConstVal::Integral(c);\n+            assert_eq!(c, ctfe, \"miri evaluated to {:?}, but ctfe yielded {:?}\", c, ctfe);\n+        },\n+        TyUint(uint_ty) => {\n+            let value = ecx.read_maybe_aligned(miri_val.aligned, |ectx| {\n+                ectx.try_read_value(miri_val.ptr, miri_ty)\n+            });\n+            let prim = get_prim(ecx, value);\n+            let c = ConstInt::new_unsigned_truncating(prim,\n+                                                     uint_ty,\n+                                                     ecx.tcx.sess.target.usize_ty);\n+            let c = ConstVal::Integral(c);\n+            assert_eq!(c, ctfe, \"miri evaluated to {:?}, but ctfe yielded {:?}\", c, ctfe);\n+        },\n+        TyFloat(ty) => {\n+            let value = ecx.read_maybe_aligned(miri_val.aligned, |ectx| {\n+                ectx.try_read_value(miri_val.ptr, miri_ty)\n+            });\n+            let prim = get_prim(ecx, value);\n+            let f = ConstVal::Float(ConstFloat { bits: prim, ty });\n+            assert_eq!(f, ctfe, \"miri evaluated to {:?}, but ctfe yielded {:?}\", f, ctfe);\n+        },\n+        TyBool => {\n+            let value = ecx.read_maybe_aligned(miri_val.aligned, |ectx| {\n+                ectx.try_read_value(miri_val.ptr, miri_ty)\n+            });\n+            let bits = get_prim(ecx, value);\n+            if bits > 1 {\n+                bug!(\"miri evaluated to {}, but expected a bool {:?}\", bits, ctfe);\n+            }\n+            let b = ConstVal::Bool(bits == 1);\n+            assert_eq!(b, ctfe, \"miri evaluated to {:?}, but ctfe yielded {:?}\", b, ctfe);\n+        },\n+        TyChar => {\n+            let value = ecx.read_maybe_aligned(miri_val.aligned, |ectx| {\n+                ectx.try_read_value(miri_val.ptr, miri_ty)\n+            });\n+            let bits = get_prim(ecx, value);\n+            if let Some(cm) = ::std::char::from_u32(bits as u32) {\n+                assert_eq!(\n+                    ConstVal::Char(cm), ctfe,\n+                    \"miri evaluated to {:?}, but expected {:?}\", cm, ctfe,\n+                );\n+            } else {\n+                bug!(\"miri evaluated to {}, but expected a char {:?}\", bits, ctfe);\n+            }\n+        },\n+        TyStr => {\n+            let value = ecx.read_maybe_aligned(miri_val.aligned, |ectx| {\n+                ectx.try_read_value(miri_val.ptr, miri_ty)\n+            });\n+            if let Ok(Some(Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::Bytes(len)))) = value {\n+                let bytes = ecx\n+                    .memory\n+                    .read_bytes(ptr.into(), len as u64)\n+                    .expect(\"bad miri memory for str\");\n+                if let Ok(s) = ::std::str::from_utf8(bytes) {\n+                    if let ConstVal::Str(s2) = ctfe {\n+                        assert_eq!(s, s2, \"miri produced {:?}, but expected {:?}\", s, s2);\n+                    } else {\n+                        bug!(\"miri produced {:?}, but expected {:?}\", s, ctfe);\n+                    }\n+                } else {\n+                    bug!(\n+                        \"miri failed to produce valid utf8 {:?}, while ctfe produced {:?}\",\n+                        bytes,\n+                        ctfe,\n+                    );\n+                }\n+            } else {\n+                bug!(\"miri evaluated to {:?}, but expected a str {:?}\", value, ctfe);\n+            }\n+        },\n+        TyArray(elem_ty, n) => {\n+            let n = n.val.to_const_int().unwrap().to_u64().unwrap();\n+            let size = ecx.layout_of(elem_ty).unwrap().size.bytes();\n+            let vec: Vec<(ConstVal, Ty<'tcx>)> = match ctfe {\n+                ConstVal::ByteStr(arr) => arr.data.iter().map(|&b| {\n+                    (ConstVal::Integral(ConstInt::U8(b)), ecx.tcx.types.u8)\n+                }).collect(),\n+                ConstVal::Aggregate(Array(v)) => {\n+                    v.iter().map(|c| (c.val, c.ty)).collect()\n+                },\n+                ConstVal::Aggregate(Repeat(v, n)) => {\n+                    vec![(v.val, v.ty); n as usize]\n+                },\n+                _ => bug!(\"miri produced {:?}, but ctfe yielded {:?}\", miri_ty, ctfe),\n+            };\n+            for (i, elem) in vec.into_iter().enumerate() {\n+                assert!((i as u64) < n);\n+                let ptr = miri_val.offset(size * i as u64, &ecx).unwrap();\n+                check_ctfe_against_miri(ecx, ptr, elem_ty, elem.0);\n+            }\n+        },\n+        TyTuple(..) => {\n+            let vec = match ctfe {\n+                ConstVal::Aggregate(Tuple(v)) => v,\n+                _ => bug!(\"miri produced {:?}, but ctfe yielded {:?}\", miri_ty, ctfe),\n+            };\n+            let layout = ecx.layout_of(miri_ty).unwrap();\n+            for (i, elem) in vec.into_iter().enumerate() {\n+                let offset = layout.fields.offset(i);\n+                let ptr = miri_val.offset(offset.bytes(), &ecx).unwrap();\n+                check_ctfe_against_miri(ecx, ptr, elem.ty, elem.val);\n+            }\n+        },\n+        TyAdt(def, _) => {\n+            let (struct_variant, extra) = if def.is_enum() {\n+                let discr = ecx.read_discriminant_value(\n+                    Place::Ptr { ptr: miri_val, extra: PlaceExtra::None },\n+                    miri_ty).unwrap();\n+                let variant = def.discriminants(ecx.tcx).position(|variant_discr| {\n+                    variant_discr.to_u128_unchecked() == discr\n+                }).expect(\"miri produced invalid enum discriminant\");\n+                (&def.variants[variant], PlaceExtra::DowncastVariant(variant))\n+            } else {\n+                (def.struct_variant(), PlaceExtra::None)\n+            };\n+            let vec = match ctfe {\n+                ConstVal::Aggregate(Struct(v)) => v,\n+                ConstVal::Variant(did) => {\n+                    assert_eq!(struct_variant.fields.len(), 0);\n+                    assert_eq!(did, struct_variant.did);\n+                    return;\n+                },\n+                ctfe => bug!(\"miri produced {:?}, but ctfe yielded {:?}\", miri_ty, ctfe),\n+            };\n+            let layout = ecx.layout_of(miri_ty).unwrap();\n+            for &(name, elem) in vec.into_iter() {\n+                let field = struct_variant.fields.iter().position(|f| f.name == name).unwrap();\n+                let (place, _) = ecx.place_field(\n+                    Place::Ptr { ptr: miri_val, extra },\n+                    Field::new(field),\n+                    layout,\n+                ).unwrap();\n+                let ptr = place.to_ptr_extra_aligned().0;\n+                check_ctfe_against_miri(ecx, ptr, elem.ty, elem.val);\n+            }\n+        },\n+        TySlice(_) => bug!(\"miri produced a slice?\"),\n+        // not supported by ctfe\n+        TyRawPtr(_) |\n+        TyRef(..) => {}\n+        TyDynamic(..) => bug!(\"miri produced a trait object\"),\n+        TyClosure(..) => bug!(\"miri produced a closure\"),\n+        TyGenerator(..) => bug!(\"miri produced a generator\"),\n+        TyNever => bug!(\"miri produced a value of the never type\"),\n+        TyProjection(_) => bug!(\"miri produced a projection\"),\n+        TyAnon(..) => bug!(\"miri produced an impl Trait type\"),\n+        TyParam(_) => bug!(\"miri produced an unmonomorphized type\"),\n+        TyInfer(_) => bug!(\"miri produced an uninferred type\"),\n+        TyError => bug!(\"miri produced a type error\"),\n+        TyForeign(_) => bug!(\"miri produced an extern type\"),\n+        // should be fine\n+        TyFnDef(..) => {}\n+        TyFnPtr(_) => {\n+            let value = ecx.read_maybe_aligned(miri_val.aligned, |ectx| {\n+                ectx.try_read_value(miri_val.ptr, miri_ty)\n+            });\n+            let ptr = match value {\n+                Ok(Some(Value::ByVal(PrimVal::Ptr(ptr)))) => ptr,\n+                value => bug!(\"expected fn ptr, got {:?}\", value),\n+            };\n+            let inst = ecx.memory.get_fn(ptr).unwrap();\n+            match ctfe {\n+                ConstVal::Function(did, substs) => {\n+                    let ctfe = ty::Instance::resolve(\n+                        ecx.tcx,\n+                        ecx.param_env,\n+                        did,\n+                        substs,\n+                    ).unwrap();\n+                    assert_eq!(inst, ctfe, \"expected fn ptr {:?}, but got {:?}\", ctfe, inst);\n+                },\n+                _ => bug!(\"ctfe produced {:?}, but miri produced function {:?}\", ctfe, inst),\n+            }\n+        },\n+    }\n+}\n+\n+fn get_prim<'a, 'tcx>(\n+    ecx: &mut EvalContext<'a, 'tcx, CompileTimeEvaluator>,\n+    res: Result<Option<Value>, EvalError<'tcx>>,\n+) -> u128 {\n+    match res {\n+        Ok(Some(Value::ByVal(prim))) => unwrap_miri(ecx, prim.to_bytes()),\n+        Err(err) => unwrap_miri(ecx, Err(err)),\n+        val => bug!(\"got {:?}\", val),\n+    }\n+}\n+\n+fn unwrap_miri<'a, 'tcx, T>(\n+    ecx: &EvalContext<'a, 'tcx, CompileTimeEvaluator>,\n+    res: Result<T, EvalError<'tcx>>,\n+) -> T {\n+    match res {\n+        Ok(val) => val,\n+        Err(mut err) => {\n+            ecx.report(&mut err);\n+            ecx.tcx.sess.abort_if_errors();\n+            bug!(\"{:#?}\", err);\n+        }\n+    }\n+}"}, {"sha": "fd83213a26eec52d70a57bc4d22cdd2933598543", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "renamed", "additions": 26, "deletions": 48, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=acac58502b3d86c5808d8d152d7870f8c6423074", "patch": "@@ -1,21 +1,24 @@\n use std::collections::{HashMap, HashSet};\n use std::fmt::Write;\n \n-use hir::def_id::DefId;\n-use hir::map::definitions::DefPathData;\n-use middle::const_val::ConstVal;\n-use middle::region;\n-use mir;\n-use traits::Reveal;\n-use ty::layout::{self, Size, Align, HasDataLayout, LayoutOf, TyLayout};\n-use ty::subst::{Subst, Substs, Kind};\n-use ty::{self, Ty, TyCtxt};\n+use rustc::hir::def_id::DefId;\n+use rustc::hir::map::definitions::DefPathData;\n+use rustc::middle::const_val::ConstVal;\n+use rustc::mir;\n+use rustc::traits::Reveal;\n+use rustc::ty::layout::{self, Size, Align, HasDataLayout, LayoutOf, TyLayout};\n+use rustc::ty::subst::{Subst, Substs, Kind};\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc_data_structures::indexed_vec::Idx;\n use syntax::codemap::{self, DUMMY_SP};\n use syntax::ast::Mutability;\n+use rustc::mir::interpret::{\n+    PtrAndAlign, DynamicLifetime, GlobalId, Value, Pointer, PrimVal, PrimValKind,\n+    EvalError, EvalResult, EvalErrorKind, MemoryPointer,\n+};\n \n-use super::{EvalError, EvalResult, EvalErrorKind, GlobalId, Place, PlaceExtra, Memory,\n-            MemoryPointer, HasMemory, MemoryKind, operator, PrimVal, PrimValKind, Value, Pointer,\n+use super::{Place, PlaceExtra, Memory,\n+            HasMemory, MemoryKind, operator,\n             ValidationQuery, Machine};\n \n pub struct EvalContext<'a, 'tcx: 'a, M: Machine<'tcx>> {\n@@ -102,12 +105,6 @@ pub enum StackPopCleanup {\n     None,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct DynamicLifetime {\n-    pub frame: usize,\n-    pub region: Option<region::Scope>, // \"None\" indicates \"until the function ends\"\n-}\n-\n #[derive(Copy, Clone, Debug)]\n pub struct ResourceLimits {\n     pub memory_size: u64,\n@@ -144,25 +141,6 @@ impl<'tcx> ::std::ops::Deref for ValTy<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug)]\n-pub struct PtrAndAlign {\n-    pub ptr: Pointer,\n-    /// Remember whether this place is *supposed* to be aligned.\n-    pub aligned: bool,\n-}\n-\n-impl PtrAndAlign {\n-    pub fn to_ptr<'tcx>(self) -> EvalResult<'tcx, MemoryPointer> {\n-        self.ptr.to_ptr()\n-    }\n-    pub fn offset<'tcx, C: HasDataLayout>(self, i: u64, cx: C) -> EvalResult<'tcx, Self> {\n-        Ok(PtrAndAlign {\n-            ptr: self.ptr.offset(i, cx)?,\n-            aligned: self.aligned,\n-        })\n-    }\n-}\n-\n impl<'a, 'tcx, M: Machine<'tcx>> HasDataLayout for &'a EvalContext<'a, 'tcx, M> {\n     #[inline]\n     fn data_layout(&self) -> &layout::TargetDataLayout {\n@@ -268,7 +246,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     }\n \n     pub(super) fn const_to_value(&mut self, const_val: &ConstVal<'tcx>) -> EvalResult<'tcx, Value> {\n-        use middle::const_val::ConstVal::*;\n+        use rustc::middle::const_val::ConstVal::*;\n \n         let primval = match *const_val {\n             Integral(const_int) => PrimVal::Bytes(const_int.to_u128_unchecked()),\n@@ -410,14 +388,14 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     Ok((size.abi_align(align), align))\n                 }\n                 ty::TyDynamic(..) => {\n-                    let (_, vtable) = value.into_ptr_vtable_pair(&mut self.memory)?;\n+                    let (_, vtable) = self.into_ptr_vtable_pair(value)?;\n                     // the second entry in the vtable is the dynamic size of the object.\n                     self.read_size_and_align_from_vtable(vtable)\n                 }\n \n                 ty::TySlice(_) | ty::TyStr => {\n                     let (elem_size, align) = layout.field(&self, 0)?.size_and_align();\n-                    let (_, len) = value.into_slice(&mut self.memory)?;\n+                    let (_, len) = self.into_slice(value)?;\n                     Ok((elem_size * len, align))\n                 }\n \n@@ -438,7 +416,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n         /// Return the set of locals that have a storage annotation anywhere\n         fn collect_storage_annotations<'tcx>(mir: &'tcx mir::Mir<'tcx>) -> HashSet<mir::Local> {\n-            use mir::StatementKind::*;\n+            use rustc::mir::StatementKind::*;\n \n             let mut set = HashSet::new();\n             for block in mir.basic_blocks() {\n@@ -546,7 +524,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         let dest = self.eval_place(place)?;\n         let dest_ty = self.place_ty(place);\n \n-        use mir::Rvalue::*;\n+        use rustc::mir::Rvalue::*;\n         match *rvalue {\n             Use(ref operand) => {\n                 let value = self.eval_operand(operand)?.value;\n@@ -700,7 +678,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n             Cast(kind, ref operand, cast_ty) => {\n                 debug_assert_eq!(self.monomorphize(cast_ty, self.substs()), dest_ty);\n-                use mir::CastKind::*;\n+                use rustc::mir::CastKind::*;\n                 match kind {\n                     Unsize => {\n                         let src = self.eval_operand(operand)?;\n@@ -841,7 +819,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     }\n \n     pub fn eval_operand(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, ValTy<'tcx>> {\n-        use mir::Operand::*;\n+        use rustc::mir::Operand::*;\n         let ty = self.monomorphize(op.ty(self.mir(), self.tcx), self.substs());\n         match *op {\n             // FIXME: do some more logic on `move` to invalidate the old location\n@@ -854,7 +832,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             },\n \n             Constant(ref constant) => {\n-                use mir::Literal;\n+                use rustc::mir::Literal;\n                 let mir::Constant { ref literal, .. } = **constant;\n                 let value = match *literal {\n                     Literal::Value { ref value } => self.const_to_value(&value.val)?,\n@@ -1271,7 +1249,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             ty::TyAdt(..) => {\n                 match self.layout_of(ty)?.abi {\n                     layout::Abi::Scalar(ref scalar) => {\n-                        use ty::layout::Primitive::*;\n+                        use rustc::ty::layout::Primitive::*;\n                         match scalar.value {\n                             Int(i, false) => PrimValKind::from_uint_size(i.size().bytes()),\n                             Int(i, true) => PrimValKind::from_int_size(i.size().bytes()),\n@@ -1448,7 +1426,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n         match (&src_pointee_ty.sty, &dest_pointee_ty.sty) {\n             (&ty::TyArray(_, length), &ty::TySlice(_)) => {\n-                let ptr = src.into_ptr(&self.memory)?;\n+                let ptr = self.into_ptr(src)?;\n                 // u64 cast is from usize to u64, which is always good\n                 let valty = ValTy {\n                     value: ptr.to_value_with_len(length.val.to_const_int().unwrap().to_u64().unwrap() ),\n@@ -1473,7 +1451,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 );\n                 let trait_ref = self.tcx.erase_regions(&trait_ref);\n                 let vtable = self.get_vtable(src_pointee_ty, trait_ref)?;\n-                let ptr = src.into_ptr(&self.memory)?;\n+                let ptr = self.into_ptr(src)?;\n                 let valty = ValTy {\n                     value: ptr.to_value_with_vtable(vtable),\n                     ty: dest_ty,\n@@ -1759,7 +1737,7 @@ pub fn resolve_drop_in_place<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ty: Ty<'tcx>,\n ) -> ty::Instance<'tcx> {\n-    let def_id = tcx.require_lang_item(::middle::lang_items::DropInPlaceFnLangItem);\n+    let def_id = tcx.require_lang_item(::rustc::middle::lang_items::DropInPlaceFnLangItem);\n     let substs = tcx.intern_substs(&[Kind::from(ty)]);\n     ty::Instance::resolve(tcx, ty::ParamEnv::empty(Reveal::All), def_id, substs).unwrap()\n }", "previous_filename": "src/librustc/mir/interpret/eval_context.rs"}, {"sha": "c08deb636bb2f0806cc25021fc6ef6cb84686a57", "filename": "src/librustc_mir/interpret/machine.rs", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=acac58502b3d86c5808d8d152d7870f8c6423074", "patch": "@@ -2,10 +2,11 @@\n //! This separation exists to ensure that no fancy miri features like\n //! interpreting common C functions leak into CTFE.\n \n-use super::{EvalResult, EvalContext, Place, PrimVal, ValTy};\n+use rustc::mir::interpret::{EvalResult, PrimVal};\n+use super::{EvalContext, Place, ValTy};\n \n-use mir;\n-use ty::{self, Ty};\n+use rustc::mir;\n+use rustc::ty::{self, Ty};\n use syntax::codemap::Span;\n use syntax::ast::Mutability;\n ", "previous_filename": "src/librustc/mir/interpret/machine.rs"}, {"sha": "974979eda7fdf099130e880e099aaff13f4afac8", "filename": "src/librustc_mir/interpret/memory.rs", "status": "renamed", "additions": 78, "deletions": 235, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=acac58502b3d86c5808d8d152d7870f8c6423074", "patch": "@@ -1,26 +1,22 @@\n use byteorder::{ReadBytesExt, WriteBytesExt, LittleEndian, BigEndian};\n use std::collections::{btree_map, BTreeMap, HashMap, HashSet, VecDeque};\n-use std::{fmt, iter, ptr, mem, io};\n+use std::{ptr, mem, io};\n use std::cell::Cell;\n \n-use ty::{Instance, TyCtxt};\n-use ty::layout::{self, TargetDataLayout, HasDataLayout};\n+use rustc::ty::{Instance, TyCtxt};\n+use rustc::ty::layout::{self, TargetDataLayout};\n use syntax::ast::Mutability;\n-use middle::region;\n+use rustc::middle::region;\n \n-use super::{EvalResult, EvalErrorKind, PrimVal, Pointer, EvalContext, DynamicLifetime, Machine,\n-            RangeMap, AbsPlace};\n+use rustc::mir::interpret::{MemoryPointer, AllocId, Allocation, AccessKind, UndefMask, PtrAndAlign, Value, DynamicLifetime, Pointer,\n+                            EvalResult, PrimVal, EvalErrorKind};\n+\n+use super::{EvalContext, Machine, RangeMap, AbsPlace};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Locks\n ////////////////////////////////////////////////////////////////////////////////\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum AccessKind {\n-    Read,\n-    Write,\n-}\n-\n /// Information about a lock that is currently held.\n #[derive(Clone, Debug)]\n struct LockInfo<'tcx> {\n@@ -46,14 +42,9 @@ struct WriteLockId<'tcx> {\n     path: AbsPlace<'tcx>,\n }\n \n-#[derive(Clone, Debug, PartialEq)]\n-pub enum Lock {\n-    NoLock,\n-    WriteLock(DynamicLifetime),\n-    /// This should never be empty -- that would be a read lock held and nobody there to release it...\n-    ReadLock(Vec<DynamicLifetime>),\n-}\n-use self::Lock::*;\n+\n+use rustc::mir::interpret::Lock::*;\n+use rustc::mir::interpret::Lock;\n \n impl<'tcx> Default for LockInfo<'tcx> {\n     fn default() -> Self {\n@@ -91,42 +82,6 @@ impl<'tcx> LockInfo<'tcx> {\n // Allocations and pointers\n ////////////////////////////////////////////////////////////////////////////////\n \n-#[derive(Copy, Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug)]\n-pub struct AllocId(u64);\n-\n-impl fmt::Display for AllocId {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.0)\n-    }\n-}\n-\n-#[derive(Debug, Eq, PartialEq, Hash)]\n-pub struct Allocation {\n-    /// The actual bytes of the allocation.\n-    /// Note that the bytes of a pointer represent the offset of the pointer\n-    pub bytes: Vec<u8>,\n-    /// Maps from byte addresses to allocations.\n-    /// Only the first byte of a pointer is inserted into the map.\n-    pub relocations: BTreeMap<u64, AllocId>,\n-    /// Denotes undefined memory. Reading from undefined memory is forbidden in miri\n-    pub undef_mask: UndefMask,\n-    /// The alignment of the allocation to detect unaligned reads.\n-    pub align: u64,\n-}\n-\n-impl Allocation {\n-    pub fn from_bytes(slice: &[u8]) -> Self {\n-        let mut undef_mask = UndefMask::new(0);\n-        undef_mask.grow(slice.len() as u64, true);\n-        Self {\n-            bytes: slice.to_owned(),\n-            relocations: BTreeMap::new(),\n-            undef_mask,\n-            align: 1,\n-        }\n-    }\n-}\n-\n #[derive(Debug, PartialEq, Copy, Clone)]\n pub enum MemoryKind<T> {\n     /// Error if deallocated except during a stack pop\n@@ -137,49 +92,6 @@ pub enum MemoryKind<T> {\n     Machine(T),\n }\n \n-#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-pub struct MemoryPointer {\n-    pub alloc_id: AllocId,\n-    pub offset: u64,\n-}\n-\n-impl<'tcx> MemoryPointer {\n-    pub fn new(alloc_id: AllocId, offset: u64) -> Self {\n-        MemoryPointer { alloc_id, offset }\n-    }\n-\n-    pub(crate) fn wrapping_signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> Self {\n-        MemoryPointer::new(\n-            self.alloc_id,\n-            cx.data_layout().wrapping_signed_offset(self.offset, i),\n-        )\n-    }\n-\n-    pub fn overflowing_signed_offset<C: HasDataLayout>(self, i: i128, cx: C) -> (Self, bool) {\n-        let (res, over) = cx.data_layout().overflowing_signed_offset(self.offset, i);\n-        (MemoryPointer::new(self.alloc_id, res), over)\n-    }\n-\n-    pub(crate) fn signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n-        Ok(MemoryPointer::new(\n-            self.alloc_id,\n-            cx.data_layout().signed_offset(self.offset, i)?,\n-        ))\n-    }\n-\n-    pub fn overflowing_offset<C: HasDataLayout>(self, i: u64, cx: C) -> (Self, bool) {\n-        let (res, over) = cx.data_layout().overflowing_offset(self.offset, i);\n-        (MemoryPointer::new(self.alloc_id, res), over)\n-    }\n-\n-    pub fn offset<C: HasDataLayout>(self, i: u64, cx: C) -> EvalResult<'tcx, Self> {\n-        Ok(MemoryPointer::new(\n-            self.alloc_id,\n-            cx.data_layout().offset(self.offset, i)?,\n-        ))\n-    }\n-}\n-\n ////////////////////////////////////////////////////////////////////////////////\n // Top-level interpreter memory\n ////////////////////////////////////////////////////////////////////////////////\n@@ -1477,93 +1389,6 @@ fn read_target_int(endianess: layout::Endian, mut source: &[u8]) -> Result<i128,\n     }\n }\n \n-////////////////////////////////////////////////////////////////////////////////\n-// Undefined byte tracking\n-////////////////////////////////////////////////////////////////////////////////\n-\n-type Block = u64;\n-const BLOCK_SIZE: u64 = 64;\n-\n-#[derive(Clone, Debug, Eq, PartialEq, Hash)]\n-pub struct UndefMask {\n-    blocks: Vec<Block>,\n-    len: u64,\n-}\n-\n-impl UndefMask {\n-    fn new(size: u64) -> Self {\n-        let mut m = UndefMask {\n-            blocks: vec![],\n-            len: 0,\n-        };\n-        m.grow(size, false);\n-        m\n-    }\n-\n-    /// Check whether the range `start..end` (end-exclusive) is entirely defined.\n-    pub fn is_range_defined(&self, start: u64, end: u64) -> bool {\n-        if end > self.len {\n-            return false;\n-        }\n-        for i in start..end {\n-            if !self.get(i) {\n-                return false;\n-            }\n-        }\n-        true\n-    }\n-\n-    fn set_range(&mut self, start: u64, end: u64, new_state: bool) {\n-        let len = self.len;\n-        if end > len {\n-            self.grow(end - len, new_state);\n-        }\n-        self.set_range_inbounds(start, end, new_state);\n-    }\n-\n-    fn set_range_inbounds(&mut self, start: u64, end: u64, new_state: bool) {\n-        for i in start..end {\n-            self.set(i, new_state);\n-        }\n-    }\n-\n-    fn get(&self, i: u64) -> bool {\n-        let (block, bit) = bit_index(i);\n-        (self.blocks[block] & 1 << bit) != 0\n-    }\n-\n-    fn set(&mut self, i: u64, new_state: bool) {\n-        let (block, bit) = bit_index(i);\n-        if new_state {\n-            self.blocks[block] |= 1 << bit;\n-        } else {\n-            self.blocks[block] &= !(1 << bit);\n-        }\n-    }\n-\n-    fn grow(&mut self, amount: u64, new_state: bool) {\n-        let unused_trailing_bits = self.blocks.len() as u64 * BLOCK_SIZE - self.len;\n-        if amount > unused_trailing_bits {\n-            let additional_blocks = amount / BLOCK_SIZE + 1;\n-            assert_eq!(additional_blocks as usize as u64, additional_blocks);\n-            self.blocks.extend(\n-                iter::repeat(0).take(additional_blocks as usize),\n-            );\n-        }\n-        let start = self.len;\n-        self.len += amount;\n-        self.set_range_inbounds(start, start + amount, new_state);\n-    }\n-}\n-\n-fn bit_index(bits: u64) -> (usize, usize) {\n-    let a = bits / BLOCK_SIZE;\n-    let b = bits % BLOCK_SIZE;\n-    assert_eq!(a as usize as u64, a);\n-    assert_eq!(b as usize as u64, b);\n-    (a as usize, b as usize)\n-}\n-\n ////////////////////////////////////////////////////////////////////////////////\n // Unaligned accesses\n ////////////////////////////////////////////////////////////////////////////////\n@@ -1608,6 +1433,73 @@ pub trait HasMemory<'a, 'tcx: 'a, M: Machine<'tcx>> {\n         self.memory().writes_are_aligned.set(old);\n         t\n     }\n+\n+    /// Convert the value into a pointer (or a pointer-sized integer).  If the value is a ByRef,\n+    /// this may have to perform a load.\n+    fn into_ptr(\n+        &self,\n+        value: Value,\n+    ) -> EvalResult<'tcx, Pointer> {\n+        Ok(match value {\n+            Value::ByRef(PtrAndAlign { ptr, aligned }) => {\n+                self.memory().read_maybe_aligned(aligned, |mem| mem.read_ptr_sized_unsigned(ptr.to_ptr()?))?\n+            }\n+            Value::ByVal(ptr) |\n+            Value::ByValPair(ptr, _) => ptr,\n+        }.into())\n+    }\n+\n+    fn into_ptr_vtable_pair(\n+        &self,\n+        value: Value,\n+    ) -> EvalResult<'tcx, (Pointer, MemoryPointer)> {\n+        match value {\n+            Value::ByRef(PtrAndAlign {\n+                      ptr: ref_ptr,\n+                      aligned,\n+                  }) => {\n+                self.memory().read_maybe_aligned(aligned, |mem| {\n+                    let ptr = mem.read_ptr_sized_unsigned(ref_ptr.to_ptr()?)?.into();\n+                    let vtable = mem.read_ptr_sized_unsigned(\n+                        ref_ptr.offset(mem.pointer_size(), &mem.tcx.data_layout)?.to_ptr()?,\n+                    )?.to_ptr()?;\n+                    Ok((ptr, vtable))\n+                })\n+            }\n+\n+            Value::ByValPair(ptr, vtable) => Ok((ptr.into(), vtable.to_ptr()?)),\n+\n+            Value::ByVal(PrimVal::Undef) => err!(ReadUndefBytes),\n+            _ => bug!(\"expected ptr and vtable, got {:?}\", value),\n+        }\n+    }\n+\n+    fn into_slice(\n+        &self,\n+        value: Value,\n+    ) -> EvalResult<'tcx, (Pointer, u64)> {\n+        match value {\n+            Value::ByRef(PtrAndAlign {\n+                      ptr: ref_ptr,\n+                      aligned,\n+                  }) => {\n+                self.memory().read_maybe_aligned(aligned, |mem| {\n+                    let ptr = mem.read_ptr_sized_unsigned(ref_ptr.to_ptr()?)?.into();\n+                    let len = mem.read_ptr_sized_unsigned(\n+                        ref_ptr.offset(mem.pointer_size(), &mem.tcx.data_layout)?.to_ptr()?,\n+                    )?.to_bytes()? as u64;\n+                    Ok((ptr, len))\n+                })\n+            }\n+            Value::ByValPair(ptr, val) => {\n+                let len = val.to_u128()?;\n+                assert_eq!(len as u64 as u128, len);\n+                Ok((ptr.into(), len as u64))\n+            }\n+            Value::ByVal(PrimVal::Undef) => err!(ReadUndefBytes),\n+            Value::ByVal(_) => bug!(\"expected ptr and length, got {:?}\", value),\n+        }\n+    }\n }\n \n impl<'a, 'tcx, M: Machine<'tcx>> HasMemory<'a, 'tcx, M> for Memory<'a, 'tcx, M> {\n@@ -1634,55 +1526,6 @@ impl<'a, 'tcx, M: Machine<'tcx>> HasMemory<'a, 'tcx, M> for EvalContext<'a, 'tcx\n     }\n }\n \n-////////////////////////////////////////////////////////////////////////////////\n-// Pointer arithmetic\n-////////////////////////////////////////////////////////////////////////////////\n-\n-pub trait PointerArithmetic: layout::HasDataLayout {\n-    // These are not supposed to be overriden.\n-\n-    //// Trunace the given value to the pointer size; also return whether there was an overflow\n-    fn truncate_to_ptr(self, val: u128) -> (u64, bool) {\n-        let max_ptr_plus_1 = 1u128 << self.data_layout().pointer_size.bits();\n-        ((val % max_ptr_plus_1) as u64, val >= max_ptr_plus_1)\n-    }\n-\n-    // Overflow checking only works properly on the range from -u64 to +u64.\n-    fn overflowing_signed_offset(self, val: u64, i: i128) -> (u64, bool) {\n-        // FIXME: is it possible to over/underflow here?\n-        if i < 0 {\n-            // trickery to ensure that i64::min_value() works fine\n-            // this formula only works for true negative values, it panics for zero!\n-            let n = u64::max_value() - (i as u64) + 1;\n-            val.overflowing_sub(n)\n-        } else {\n-            self.overflowing_offset(val, i as u64)\n-        }\n-    }\n-\n-    fn overflowing_offset(self, val: u64, i: u64) -> (u64, bool) {\n-        let (res, over1) = val.overflowing_add(i);\n-        let (res, over2) = self.truncate_to_ptr(res as u128);\n-        (res, over1 || over2)\n-    }\n-\n-    fn signed_offset<'tcx>(self, val: u64, i: i64) -> EvalResult<'tcx, u64> {\n-        let (res, over) = self.overflowing_signed_offset(val, i as i128);\n-        if over { err!(OverflowingMath) } else { Ok(res) }\n-    }\n-\n-    fn offset<'tcx>(self, val: u64, i: u64) -> EvalResult<'tcx, u64> {\n-        let (res, over) = self.overflowing_offset(val, i);\n-        if over { err!(OverflowingMath) } else { Ok(res) }\n-    }\n-\n-    fn wrapping_signed_offset(self, val: u64, i: i64) -> u64 {\n-        self.overflowing_signed_offset(val, i as i128).0\n-    }\n-}\n-\n-impl<T: layout::HasDataLayout> PointerArithmetic for T {}\n-\n impl<'a, 'tcx, M: Machine<'tcx>> layout::HasDataLayout for &'a Memory<'a, 'tcx, M> {\n     #[inline]\n     fn data_layout(&self) -> &TargetDataLayout {", "previous_filename": "src/librustc/mir/interpret/memory.rs"}, {"sha": "c6c8ad8b7c945d99830f6a6546c262eb9da402ca", "filename": "src/librustc_mir/interpret/mod.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=acac58502b3d86c5808d8d152d7870f8c6423074", "patch": "@@ -0,0 +1,29 @@\n+//! An interpreter for MIR used in CTFE and by miri\n+\n+mod cast;\n+mod const_eval;\n+mod eval_context;\n+mod place;\n+mod validation;\n+mod machine;\n+mod memory;\n+mod operator;\n+mod range_map;\n+mod step;\n+mod terminator;\n+mod traits;\n+\n+pub use self::eval_context::{EvalContext, Frame, ResourceLimits, StackPopCleanup,\n+                             TyAndPacked, ValTy};\n+\n+pub use self::place::{Place, PlaceExtra};\n+\n+pub use self::memory::{Memory, MemoryKind, HasMemory};\n+\n+use self::range_map::RangeMap;\n+\n+pub use self::const_eval::{eval_body_as_integer, eval_body, CompileTimeEvaluator, const_eval_provider};\n+\n+pub use self::machine::Machine;\n+\n+pub use self::validation::{ValidationQuery, AbsPlace};"}, {"sha": "6ab1aec38b863cade1c7195ab072ee3771f1fcb8", "filename": "src/librustc_mir/interpret/operator.rs", "status": "renamed", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=acac58502b3d86c5808d8d152d7870f8c6423074", "patch": "@@ -1,12 +1,12 @@\n-use mir;\n-use ty::Ty;\n+use rustc::mir;\n+use rustc::ty::Ty;\n use rustc_const_math::ConstFloat;\n use syntax::ast::FloatTy;\n use std::cmp::Ordering;\n \n-use super::{EvalResult, EvalContext, Place, Machine, ValTy};\n+use super::{EvalContext, Place, Machine, ValTy};\n \n-use super::value::{PrimVal, PrimValKind, Value, bytes_to_f32, bytes_to_f64};\n+use rustc::mir::interpret::{EvalResult, PrimVal, PrimValKind, Value, bytes_to_f32, bytes_to_f64};\n \n impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     fn binop_with_overflow(\n@@ -67,7 +67,7 @@ macro_rules! int_arithmetic {\n     ($kind:expr, $int_op:ident, $l:expr, $r:expr) => ({\n         let l = $l;\n         let r = $r;\n-        use super::PrimValKind::*;\n+        use rustc::mir::interpret::PrimValKind::*;\n         match $kind {\n             I8  => overflow!($int_op, l as i8,  r as i8),\n             I16 => overflow!($int_op, l as i16, r as i16),\n@@ -115,8 +115,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         right: PrimVal,\n         right_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, (PrimVal, bool)> {\n-        use mir::BinOp::*;\n-        use super::PrimValKind::*;\n+        use rustc::mir::BinOp::*;\n+        use rustc::mir::interpret::PrimValKind::*;\n \n         let left_kind = self.ty_to_primval_kind(left_ty)?;\n         let right_kind = self.ty_to_primval_kind(right_ty)?;\n@@ -228,8 +228,8 @@ pub fn unary_op<'tcx>(\n     val: PrimVal,\n     val_kind: PrimValKind,\n ) -> EvalResult<'tcx, PrimVal> {\n-    use mir::UnOp::*;\n-    use super::PrimValKind::*;\n+    use rustc::mir::UnOp::*;\n+    use rustc::mir::interpret::PrimValKind::*;\n \n     let bytes = val.to_bytes()?;\n ", "previous_filename": "src/librustc/mir/interpret/operator.rs"}, {"sha": "538d768d3b0e409f8991e26c4b532f772534009c", "filename": "src/librustc_mir/interpret/place.rs", "status": "renamed", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=acac58502b3d86c5808d8d152d7870f8c6423074", "patch": "@@ -1,9 +1,12 @@\n-use mir;\n-use ty::{self, Ty};\n-use ty::layout::{LayoutOf, TyLayout};\n+use rustc::mir;\n+use rustc::ty::{self, Ty};\n+use rustc::ty::layout::{LayoutOf, TyLayout};\n use rustc_data_structures::indexed_vec::Idx;\n+use rustc::mir::interpret::{GlobalId, PtrAndAlign};\n \n-use super::{EvalResult, EvalContext, MemoryPointer, PrimVal, Value, Pointer, Machine, PtrAndAlign, ValTy};\n+use rustc::mir::interpret::{Value, PrimVal, EvalResult, Pointer, MemoryPointer};\n+use super::{EvalContext, Machine, ValTy};\n+use interpret::memory::HasMemory;\n \n #[derive(Copy, Clone, Debug)]\n pub enum Place {\n@@ -29,17 +32,6 @@ pub enum PlaceExtra {\n     DowncastVariant(usize),\n }\n \n-/// Uniquely identifies a specific constant or static.\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]\n-pub struct GlobalId<'tcx> {\n-    /// For a constant or static, the `Instance` of the item itself.\n-    /// For a promoted global, the `Instance` of the function they belong to.\n-    pub instance: ty::Instance<'tcx>,\n-\n-    /// The index for promoted globals within their function's `Mir`.\n-    pub promoted: Option<mir::Promoted>,\n-}\n-\n impl<'tcx> Place {\n     /// Produces an Place that will error if attempted to be read from\n     pub fn undef() -> Self {\n@@ -101,7 +93,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         &mut self,\n         place: &mir::Place<'tcx>,\n     ) -> EvalResult<'tcx, Option<Value>> {\n-        use mir::Place::*;\n+        use rustc::mir::Place::*;\n         match *place {\n             // Might allow this in the future, right now there's no way to do this from Rust code anyway\n             Local(mir::RETURN_PLACE) => err!(ReadFromReturnPointer),\n@@ -126,7 +118,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         &mut self,\n         proj: &mir::PlaceProjection<'tcx>,\n     ) -> EvalResult<'tcx, Option<Value>> {\n-        use mir::ProjectionElem::*;\n+        use rustc::mir::ProjectionElem::*;\n         let base = match self.try_read_place(&proj.base)? {\n             Some(base) => base,\n             None => return Ok(None),\n@@ -186,7 +178,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     }\n \n     pub fn eval_place(&mut self, mir_place: &mir::Place<'tcx>) -> EvalResult<'tcx, Place> {\n-        use mir::Place::*;\n+        use rustc::mir::Place::*;\n         let place = match *mir_place {\n             Local(mir::RETURN_PLACE) => self.frame().return_place,\n             Local(local) => Place::Local {\n@@ -289,20 +281,20 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     pub(super) fn val_to_place(&self, val: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Place> {\n         Ok(match self.tcx.struct_tail(ty).sty {\n             ty::TyDynamic(..) => {\n-                let (ptr, vtable) = val.into_ptr_vtable_pair(&self.memory)?;\n+                let (ptr, vtable) = self.into_ptr_vtable_pair(val)?;\n                 Place::Ptr {\n                     ptr: PtrAndAlign { ptr, aligned: true },\n                     extra: PlaceExtra::Vtable(vtable),\n                 }\n             }\n             ty::TyStr | ty::TySlice(_) => {\n-                let (ptr, len) = val.into_slice(&self.memory)?;\n+                let (ptr, len) = self.into_slice(val)?;\n                 Place::Ptr {\n                     ptr: PtrAndAlign { ptr, aligned: true },\n                     extra: PlaceExtra::Length(len),\n                 }\n             }\n-            _ => Place::from_primval_ptr(val.into_ptr(&self.memory)?),\n+            _ => Place::from_primval_ptr(self.into_ptr(val)?),\n         })\n     }\n \n@@ -349,7 +341,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         base_ty: Ty<'tcx>,\n         proj_elem: &mir::ProjectionElem<'tcx, mir::Local, Ty<'tcx>>,\n     ) -> EvalResult<'tcx, Place> {\n-        use mir::ProjectionElem::*;\n+        use rustc::mir::ProjectionElem::*;\n         let (ptr, extra) = match *proj_elem {\n             Field(field, _) => {\n                 let layout = self.layout_of(base_ty)?;", "previous_filename": "src/librustc/mir/interpret/place.rs"}, {"sha": "5cdcbe35121a579e26b6d74c461b5cb64ece2676", "filename": "src/librustc_mir/interpret/range_map.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_mir%2Finterpret%2Frange_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_mir%2Finterpret%2Frange_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Frange_map.rs?ref=acac58502b3d86c5808d8d152d7870f8c6423074", "previous_filename": "src/librustc/mir/interpret/range_map.rs"}, {"sha": "0e137f5cb5a6a2253ff014440b097c9818cc33a2", "filename": "src/librustc_mir/interpret/step.rs", "status": "renamed", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=acac58502b3d86c5808d8d152d7870f8c6423074", "patch": "@@ -2,15 +2,16 @@\n //!\n //! The main entry point is the `step` method.\n \n-use hir;\n-use mir::visit::{Visitor, PlaceContext};\n-use mir;\n-use ty::{self, Instance};\n-use ty::layout::LayoutOf;\n-use middle::const_val::ConstVal;\n+use rustc::hir;\n+use rustc::mir::visit::{Visitor, PlaceContext};\n+use rustc::mir;\n+use rustc::ty::{self, Instance};\n+use rustc::ty::layout::LayoutOf;\n+use rustc::middle::const_val::ConstVal;\n+use rustc::mir::interpret::{PtrAndAlign, GlobalId};\n \n-use super::{EvalResult, EvalContext, StackPopCleanup, PtrAndAlign, GlobalId, Place,\n-            Machine, EvalErrorKind};\n+use rustc::mir::interpret::{EvalResult, EvalErrorKind};\n+use super::{EvalContext, StackPopCleanup, Place, Machine};\n \n use syntax::codemap::Span;\n use syntax::ast::Mutability;\n@@ -92,7 +93,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     fn statement(&mut self, stmt: &mir::Statement<'tcx>) -> EvalResult<'tcx> {\n         trace!(\"{:?}\", stmt);\n \n-        use mir::StatementKind::*;\n+        use rustc::mir::StatementKind::*;\n \n         // Some statements (e.g. box) push new stack frames.  We have to record the stack frame number\n         // *before* executing the statement.", "previous_filename": "src/librustc/mir/interpret/step.rs"}, {"sha": "5db46149834d24b82ef353f6bb20aab962c6241c", "filename": "src/librustc_mir/interpret/terminator/drop.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs?ref=acac58502b3d86c5808d8d152d7870f8c6423074", "patch": "@@ -1,9 +1,9 @@\n-use mir::BasicBlock;\n-use ty::{self, Ty};\n+use rustc::mir::BasicBlock;\n+use rustc::ty::{self, Ty};\n use syntax::codemap::Span;\n \n-use mir::interpret::{EvalResult, EvalContext, Place, PlaceExtra, PrimVal, Value,\n-                Machine, ValTy};\n+use rustc::mir::interpret::{EvalResult, PrimVal, Value};\n+use interpret::{Machine, ValTy, EvalContext, Place, PlaceExtra};\n \n impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     pub(crate) fn drop_place(", "previous_filename": "src/librustc/mir/interpret/terminator/drop.rs"}, {"sha": "1cdfe1ff9ceacce0a81268c9c074698acbdabd10", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "renamed", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=acac58502b3d86c5808d8d152d7870f8c6423074", "patch": "@@ -1,13 +1,15 @@\n-use mir;\n-use ty::{self, Ty};\n-use ty::layout::LayoutOf;\n+use rustc::mir;\n+use rustc::ty::{self, Ty};\n+use rustc::ty::layout::LayoutOf;\n use syntax::codemap::Span;\n use syntax::abi::Abi;\n \n-use super::{EvalResult, EvalContext, eval_context,\n-            PtrAndAlign, Place, PrimVal, Value, Machine, ValTy};\n+use rustc::mir::interpret::{PtrAndAlign, EvalResult, PrimVal, Value};\n+use super::{EvalContext, eval_context,\n+            Place, Machine, ValTy};\n \n use rustc_data_structures::indexed_vec::Idx;\n+use interpret::memory::HasMemory;\n \n mod drop;\n \n@@ -21,7 +23,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         &mut self,\n         terminator: &mir::Terminator<'tcx>,\n     ) -> EvalResult<'tcx> {\n-        use mir::TerminatorKind::*;\n+        use rustc::mir::TerminatorKind::*;\n         match terminator.kind {\n             Return => {\n                 self.dump_local(self.frame().return_place);\n@@ -138,7 +140,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 if expected == cond_val {\n                     self.goto_block(target);\n                 } else {\n-                    use mir::AssertMessage::*;\n+                    use rustc::mir::AssertMessage::*;\n                     return match *msg {\n                         BoundsCheck { ref len, ref index } => {\n                             let span = terminator.source_info.span;\n@@ -401,7 +403,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             // cannot use the shim here, because that will only result in infinite recursion\n             ty::InstanceDef::Virtual(_, idx) => {\n                 let ptr_size = self.memory.pointer_size();\n-                let (ptr, vtable) = args[0].into_ptr_vtable_pair(&self.memory)?;\n+                let (ptr, vtable) = self.into_ptr_vtable_pair(args[0].value)?;\n                 let fn_ptr = self.memory.read_ptr_sized_unsigned(\n                     vtable.offset(ptr_size * (idx as u64 + 3), &self)?\n                 )?.to_ptr()?;", "previous_filename": "src/librustc/mir/interpret/terminator/mod.rs"}, {"sha": "c73b95c717c3de1e89e016222cc03f04a2a0921e", "filename": "src/librustc_mir/interpret/traits.rs", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=acac58502b3d86c5808d8d152d7870f8c6423074", "patch": "@@ -1,8 +1,9 @@\n-use ty::{self, Ty};\n-use ty::layout::{Size, Align, LayoutOf};\n+use rustc::ty::{self, Ty};\n+use rustc::ty::layout::{Size, Align, LayoutOf};\n use syntax::ast::Mutability;\n \n-use super::{EvalResult, EvalContext, eval_context, MemoryPointer, Value, PrimVal,\n+use rustc::mir::interpret::{PrimVal, Value, MemoryPointer, EvalResult};\n+use super::{EvalContext, eval_context,\n             Machine};\n \n impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {", "previous_filename": "src/librustc/mir/interpret/traits.rs"}, {"sha": "740a2c53e2f73858d0ffe3094cb8ff776a3e349a", "filename": "src/librustc_mir/interpret/validation.rs", "status": "renamed", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs?ref=acac58502b3d86c5808d8d152d7870f8c6423074", "patch": "@@ -1,17 +1,18 @@\n-use hir::{self, Mutability};\n-use hir::Mutability::*;\n-use mir::{self, ValidationOp, ValidationOperand};\n-use ty::{self, Ty, TypeFoldable, TyCtxt};\n-use ty::layout::LayoutOf;\n-use ty::subst::{Substs, Subst};\n-use traits;\n-use infer::InferCtxt;\n-use traits::Reveal;\n-use middle::region;\n+use rustc::hir::{self, Mutability};\n+use rustc::hir::Mutability::*;\n+use rustc::mir::{self, ValidationOp, ValidationOperand};\n+use rustc::ty::{self, Ty, TypeFoldable, TyCtxt};\n+use rustc::ty::layout::LayoutOf;\n+use rustc::ty::subst::{Substs, Subst};\n+use rustc::traits;\n+use rustc::infer::InferCtxt;\n+use rustc::traits::Reveal;\n+use rustc::middle::region;\n use rustc_data_structures::indexed_vec::Idx;\n+use interpret::memory::HasMemory;\n \n-use super::{EvalError, EvalResult, EvalErrorKind, EvalContext, DynamicLifetime, AccessKind, Value,\n-            Place, PlaceExtra, Machine, ValTy};\n+use super::{EvalContext, Place, PlaceExtra, Machine, ValTy};\n+use rustc::mir::interpret::{DynamicLifetime, AccessKind, EvalErrorKind, Value, EvalError, EvalResult};\n \n pub type ValidationQuery<'tcx> = ValidationOperand<'tcx, (AbsPlace<'tcx>, Place)>;\n \n@@ -407,7 +408,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n             // ADTs.\n             ty::TyAdt(def, substs) => {\n-                use ty::layout::Variants;\n+                use rustc::ty::layout::Variants;\n                 match layout.variants {\n                     Variants::Single { index } => {\n                         def.variants[index].fields[i].ty(tcx, substs)\n@@ -469,7 +470,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     ) -> EvalResult<'tcx> {\n         // Check alignment and non-NULLness\n         let (_, align) = self.size_and_align_of_dst(pointee_ty, val)?;\n-        let ptr = val.into_ptr(&self.memory)?;\n+        let ptr = self.into_ptr(val)?;\n         self.memory.check_align(ptr, align.abi(), None)?;\n \n         // Recurse\n@@ -491,9 +492,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         mut query: ValidationQuery<'tcx>,\n         mode: ValidationMode,\n     ) -> EvalResult<'tcx> {\n-        use ty::TypeVariants::*;\n-        use ty::RegionKind::*;\n-        use ty::AdtKind;\n+        use rustc::ty::TypeVariants::*;\n+        use rustc::ty::RegionKind::*;\n+        use rustc::ty::AdtKind;\n \n         // No point releasing shared stuff.\n         if !mode.acquiring() && query.mutbl == MutImmutable {\n@@ -645,9 +646,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     self.validate_ptr(val, query.place.0, query.ty.boxed_ty(), query.re, query.mutbl, mode)\n                 }\n                 TyFnPtr(_sig) => {\n-                    let ptr = self.read_place(query.place.1)?\n-                        .into_ptr(&self.memory)?\n-                        .to_ptr()?;\n+                    let ptr = self.read_place(query.place.1)?;\n+                    let ptr = self.into_ptr(ptr)?.to_ptr()?;\n                     self.memory.get_fn(ptr)?;\n                     // TODO: Check if the signature matches (should be the same check as what terminator/mod.rs already does on call?).\n                     Ok(())", "previous_filename": "src/librustc/mir/interpret/validation.rs"}, {"sha": "1f90de087b0d78504104a76c33aea0318e0fd251", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=acac58502b3d86c5808d8d152d7870f8c6423074", "patch": "@@ -25,7 +25,10 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(decl_macro)]\n #![feature(i128_type)]\n #![feature(inclusive_range_syntax)]\n+#![feature(inclusive_range)]\n+#![feature(macro_vis_matcher)]\n #![feature(match_default_bindings)]\n+#![feature(never_type)]\n #![feature(range_contains)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(placement_in_syntax)]\n@@ -48,6 +51,12 @@ extern crate syntax_pos;\n extern crate rustc_const_math;\n extern crate rustc_const_eval;\n extern crate core; // for NonZero\n+extern crate log_settings;\n+#[macro_use]\n+extern crate lazy_static;\n+extern crate rustc_apfloat;\n+extern crate regex;\n+extern crate byteorder;\n \n mod diagnostics;\n \n@@ -58,13 +67,15 @@ mod hair;\n mod shim;\n pub mod transform;\n pub mod util;\n+mod interpret;\n \n use rustc::ty::maps::Providers;\n \n pub fn provide(providers: &mut Providers) {\n     borrow_check::provide(providers);\n     shim::provide(providers);\n     transform::provide(providers);\n+    providers.const_eval = interpret::const_eval_provider;\n }\n \n __build_diagnostic_array! { librustc_mir, DIAGNOSTICS }"}, {"sha": "3fd844f326184a76d87602e19559bd31cad836c2", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acac58502b3d86c5808d8d152d7870f8c6423074/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=acac58502b3d86c5808d8d152d7870f8c6423074", "patch": "@@ -67,6 +67,7 @@ fn filter_dirs(path: &Path) -> bool {\n         \"src/tools/rustfmt\",\n         \"src/tools/miri\",\n         \"src/librustc/mir/interpret\",\n+        \"src/librustc_mir/interpret\",\n     ];\n     skip.iter().any(|p| path.ends_with(p))\n }"}]}