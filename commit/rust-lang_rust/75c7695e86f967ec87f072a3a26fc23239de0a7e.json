{"sha": "75c7695e86f967ec87f072a3a26fc23239de0a7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1Yzc2OTVlODZmOTY3ZWM4N2YwNzJhM2EyNmZjMjMyMzlkZTBhN2U=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-05-20T11:33:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-20T11:33:48Z"}, "message": "Merge #4532\n\n4532: Split change_ and fix_ visibility assists r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "4bc15c3e4bab37a2eb8b261aaab107ea60e6a1b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4bc15c3e4bab37a2eb8b261aaab107ea60e6a1b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75c7695e86f967ec87f072a3a26fc23239de0a7e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJexRWcCRBK7hj4Ov3rIwAAdHIIAKaHhVftw67sOZE77OLqv/GK\nocNr7E76D+Y0JrnjoGk1SX7pNLfcy76nEkZfcEywHmFLa6qbIbs4IVHu+LmzP3Lb\na5KHnTi+5NVBjHqoFHO0B/crbqZYyb32BxGq2DIvqXBSip5ylqzpu2pZOsc8vGcI\nd1D+6g7niNMAx4hXIEjZf7E+elU6mmJ87mikZ575LuZQXh24xeJ9A4HXwIYm5N2X\nVDkPbJkJB36xSyVNvt2AS8vdj1koLskvGjfiHus+ojkpyvM80Snvz/hGXVy4XC8/\niKFxMCeyVzZoztUD+8gCdJYWqG4ggUT/MWrr9YKYafh5oF3//Dj+UWl7lV8RiMk=\n=36xR\n-----END PGP SIGNATURE-----\n", "payload": "tree 4bc15c3e4bab37a2eb8b261aaab107ea60e6a1b9\nparent e3373629cd80404388c5da52f991e18f2d715d8d\nparent cec773926f08e2d46b05d923165f8e73c420aa8c\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1589974428 +0000\ncommitter GitHub <noreply@github.com> 1589974428 +0000\n\nMerge #4532\n\n4532: Split change_ and fix_ visibility assists r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75c7695e86f967ec87f072a3a26fc23239de0a7e", "html_url": "https://github.com/rust-lang/rust/commit/75c7695e86f967ec87f072a3a26fc23239de0a7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75c7695e86f967ec87f072a3a26fc23239de0a7e/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3373629cd80404388c5da52f991e18f2d715d8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3373629cd80404388c5da52f991e18f2d715d8d", "html_url": "https://github.com/rust-lang/rust/commit/e3373629cd80404388c5da52f991e18f2d715d8d"}, {"sha": "cec773926f08e2d46b05d923165f8e73c420aa8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/cec773926f08e2d46b05d923165f8e73c420aa8c", "html_url": "https://github.com/rust-lang/rust/commit/cec773926f08e2d46b05d923165f8e73c420aa8c"}], "stats": {"total": 1109, "additions": 603, "deletions": 506}, "files": [{"sha": "1d9b8e645e4395093a0b9d2c20cb8be4a597347b", "filename": "crates/ra_assists/src/handlers/change_visibility.rs", "status": "modified", "additions": 1, "deletions": 506, "changes": 507, "blob_url": "https://github.com/rust-lang/rust/blob/75c7695e86f967ec87f072a3a26fc23239de0a7e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75c7695e86f967ec87f072a3a26fc23239de0a7e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs?ref=75c7695e86f967ec87f072a3a26fc23239de0a7e", "patch": "@@ -5,14 +5,11 @@ use ra_syntax::{\n         ATTR, COMMENT, CONST_DEF, ENUM_DEF, FN_DEF, MODULE, STRUCT_DEF, TRAIT_DEF, VISIBILITY,\n         WHITESPACE,\n     },\n-    SyntaxNode, TextRange, TextSize, T,\n+    SyntaxNode, TextSize, T,\n };\n-\n-use hir::{db::HirDatabase, HasSource, HasVisibility, PathResolution};\n use test_utils::mark;\n \n use crate::{AssistContext, AssistId, Assists};\n-use ra_db::FileId;\n \n // Assist: change_visibility\n //\n@@ -30,8 +27,6 @@ pub(crate) fn change_visibility(acc: &mut Assists, ctx: &AssistContext) -> Optio\n         return change_vis(acc, vis);\n     }\n     add_vis(acc, ctx)\n-        .or_else(|| add_vis_to_referenced_module_def(acc, ctx))\n-        .or_else(|| add_vis_to_referenced_record_field(acc, ctx))\n }\n \n fn add_vis(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n@@ -77,143 +72,6 @@ fn add_vis(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     })\n }\n \n-fn add_vis_to_referenced_module_def(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let path: ast::Path = ctx.find_node_at_offset()?;\n-    let path_res = ctx.sema.resolve_path(&path)?;\n-    let def = match path_res {\n-        PathResolution::Def(def) => def,\n-        _ => return None,\n-    };\n-\n-    let current_module = ctx.sema.scope(&path.syntax()).module()?;\n-    let target_module = def.module(ctx.db)?;\n-\n-    let vis = target_module.visibility_of(ctx.db, &def)?;\n-    if vis.is_visible_from(ctx.db, current_module.into()) {\n-        return None;\n-    };\n-\n-    let (offset, target, target_file, target_name) = target_data_for_def(ctx.db, def)?;\n-\n-    let missing_visibility =\n-        if current_module.krate() == target_module.krate() { \"pub(crate)\" } else { \"pub\" };\n-\n-    let assist_label = match target_name {\n-        None => format!(\"Change visibility to {}\", missing_visibility),\n-        Some(name) => format!(\"Change visibility of {} to {}\", name, missing_visibility),\n-    };\n-\n-    acc.add(AssistId(\"change_visibility\"), assist_label, target, |edit| {\n-        edit.set_file(target_file);\n-        edit.insert(offset, format!(\"{} \", missing_visibility));\n-        edit.set_cursor(offset);\n-    })\n-}\n-\n-fn add_vis_to_referenced_record_field(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let record_field: ast::RecordField = ctx.find_node_at_offset()?;\n-    let (record_field_def, _) = ctx.sema.resolve_record_field(&record_field)?;\n-\n-    let current_module = ctx.sema.scope(record_field.syntax()).module()?;\n-    let visibility = record_field_def.visibility(ctx.db);\n-    if visibility.is_visible_from(ctx.db, current_module.into()) {\n-        return None;\n-    }\n-\n-    let parent = record_field_def.parent_def(ctx.db);\n-    let parent_name = parent.name(ctx.db);\n-    let target_module = parent.module(ctx.db);\n-\n-    let in_file_source = record_field_def.source(ctx.db);\n-    let (offset, target) = match in_file_source.value {\n-        hir::FieldSource::Named(it) => {\n-            let s = it.syntax();\n-            (vis_offset(s), s.text_range())\n-        }\n-        hir::FieldSource::Pos(it) => {\n-            let s = it.syntax();\n-            (vis_offset(s), s.text_range())\n-        }\n-    };\n-\n-    let missing_visibility =\n-        if current_module.krate() == target_module.krate() { \"pub(crate)\" } else { \"pub\" };\n-    let target_file = in_file_source.file_id.original_file(ctx.db);\n-\n-    let target_name = record_field_def.name(ctx.db);\n-    let assist_label =\n-        format!(\"Change visibility of {}.{} to {}\", parent_name, target_name, missing_visibility);\n-\n-    acc.add(AssistId(\"change_visibility\"), assist_label, target, |edit| {\n-        edit.set_file(target_file);\n-        edit.insert(offset, format!(\"{} \", missing_visibility));\n-        edit.set_cursor(offset)\n-    })\n-}\n-\n-fn target_data_for_def(\n-    db: &dyn HirDatabase,\n-    def: hir::ModuleDef,\n-) -> Option<(TextSize, TextRange, FileId, Option<hir::Name>)> {\n-    fn offset_target_and_file_id<S, Ast>(\n-        db: &dyn HirDatabase,\n-        x: S,\n-    ) -> (TextSize, TextRange, FileId)\n-    where\n-        S: HasSource<Ast = Ast>,\n-        Ast: AstNode,\n-    {\n-        let source = x.source(db);\n-        let in_file_syntax = source.syntax();\n-        let file_id = in_file_syntax.file_id;\n-        let syntax = in_file_syntax.value;\n-        (vis_offset(syntax), syntax.text_range(), file_id.original_file(db.upcast()))\n-    }\n-\n-    let target_name;\n-    let (offset, target, target_file) = match def {\n-        hir::ModuleDef::Function(f) => {\n-            target_name = Some(f.name(db));\n-            offset_target_and_file_id(db, f)\n-        }\n-        hir::ModuleDef::Adt(adt) => {\n-            target_name = Some(adt.name(db));\n-            match adt {\n-                hir::Adt::Struct(s) => offset_target_and_file_id(db, s),\n-                hir::Adt::Union(u) => offset_target_and_file_id(db, u),\n-                hir::Adt::Enum(e) => offset_target_and_file_id(db, e),\n-            }\n-        }\n-        hir::ModuleDef::Const(c) => {\n-            target_name = c.name(db);\n-            offset_target_and_file_id(db, c)\n-        }\n-        hir::ModuleDef::Static(s) => {\n-            target_name = s.name(db);\n-            offset_target_and_file_id(db, s)\n-        }\n-        hir::ModuleDef::Trait(t) => {\n-            target_name = Some(t.name(db));\n-            offset_target_and_file_id(db, t)\n-        }\n-        hir::ModuleDef::TypeAlias(t) => {\n-            target_name = Some(t.name(db));\n-            offset_target_and_file_id(db, t)\n-        }\n-        hir::ModuleDef::Module(m) => {\n-            target_name = m.name(db);\n-            let in_file_source = m.declaration_source(db)?;\n-            let file_id = in_file_source.file_id.original_file(db.upcast());\n-            let syntax = in_file_source.value.syntax();\n-            (vis_offset(syntax), syntax.text_range(), file_id)\n-        }\n-        // Enum variants can't be private, we can't modify builtin types\n-        hir::ModuleDef::EnumVariant(_) | hir::ModuleDef::BuiltinType(_) => return None,\n-    };\n-\n-    Some((offset, target, target_file, target_name))\n-}\n-\n fn vis_offset(node: &SyntaxNode) -> TextSize {\n     node.children_with_tokens()\n         .skip_while(|it| match it.kind() {\n@@ -333,193 +191,6 @@ mod tests {\n         )\n     }\n \n-    #[test]\n-    fn change_visibility_of_fn_via_path() {\n-        check_assist(\n-            change_visibility,\n-            r\"mod foo { fn foo() {} }\n-              fn main() { foo::foo<|>() } \",\n-            r\"mod foo { <|>pub(crate) fn foo() {} }\n-              fn main() { foo::foo() } \",\n-        );\n-        check_assist_not_applicable(\n-            change_visibility,\n-            r\"mod foo { pub fn foo() {} }\n-              fn main() { foo::foo<|>() } \",\n-        )\n-    }\n-\n-    #[test]\n-    fn change_visibility_of_adt_in_submodule_via_path() {\n-        check_assist(\n-            change_visibility,\n-            r\"mod foo { struct Foo; }\n-              fn main() { foo::Foo<|> } \",\n-            r\"mod foo { <|>pub(crate) struct Foo; }\n-              fn main() { foo::Foo } \",\n-        );\n-        check_assist_not_applicable(\n-            change_visibility,\n-            r\"mod foo { pub struct Foo; }\n-              fn main() { foo::Foo<|> } \",\n-        );\n-        check_assist(\n-            change_visibility,\n-            r\"mod foo { enum Foo; }\n-              fn main() { foo::Foo<|> } \",\n-            r\"mod foo { <|>pub(crate) enum Foo; }\n-              fn main() { foo::Foo } \",\n-        );\n-        check_assist_not_applicable(\n-            change_visibility,\n-            r\"mod foo { pub enum Foo; }\n-              fn main() { foo::Foo<|> } \",\n-        );\n-        check_assist(\n-            change_visibility,\n-            r\"mod foo { union Foo; }\n-              fn main() { foo::Foo<|> } \",\n-            r\"mod foo { <|>pub(crate) union Foo; }\n-              fn main() { foo::Foo } \",\n-        );\n-        check_assist_not_applicable(\n-            change_visibility,\n-            r\"mod foo { pub union Foo; }\n-              fn main() { foo::Foo<|> } \",\n-        );\n-    }\n-\n-    #[test]\n-    fn change_visibility_of_adt_in_other_file_via_path() {\n-        check_assist(\n-            change_visibility,\n-            r\"\n-              //- /main.rs\n-              mod foo;\n-              fn main() { foo::Foo<|> }\n-\n-              //- /foo.rs\n-              struct Foo;\n-              \",\n-            r\"<|>pub(crate) struct Foo;\n-\n-\",\n-        );\n-    }\n-\n-    #[test]\n-    fn change_visibility_of_struct_field_via_path() {\n-        check_assist(\n-            change_visibility,\n-            r\"mod foo { pub struct Foo { bar: (), } }\n-              fn main() { foo::Foo { <|>bar: () }; } \",\n-            r\"mod foo { pub struct Foo { <|>pub(crate) bar: (), } }\n-              fn main() { foo::Foo { bar: () }; } \",\n-        );\n-        check_assist(\n-            change_visibility,\n-            r\"//- /lib.rs\n-              mod foo;\n-              fn main() { foo::Foo { <|>bar: () }; }\n-              //- /foo.rs\n-              pub struct Foo { bar: () }\n-              \",\n-            r\"pub struct Foo { <|>pub(crate) bar: () }\n-\n-\",\n-        );\n-        check_assist_not_applicable(\n-            change_visibility,\n-            r\"mod foo { pub struct Foo { pub bar: (), } }\n-              fn main() { foo::Foo { <|>bar: () }; } \",\n-        );\n-        check_assist_not_applicable(\n-            change_visibility,\n-            r\"//- /lib.rs\n-              mod foo;\n-              fn main() { foo::Foo { <|>bar: () }; }\n-              //- /foo.rs\n-              pub struct Foo { pub bar: () }\n-              \",\n-        );\n-    }\n-\n-    #[test]\n-    fn change_visibility_of_enum_variant_field_via_path() {\n-        check_assist(\n-            change_visibility,\n-            r\"mod foo { pub enum Foo { Bar { bar: () } } }\n-              fn main() { foo::Foo::Bar { <|>bar: () }; } \",\n-            r\"mod foo { pub enum Foo { Bar { <|>pub(crate) bar: () } } }\n-              fn main() { foo::Foo::Bar { bar: () }; } \",\n-        );\n-        check_assist(\n-            change_visibility,\n-            r\"//- /lib.rs\n-              mod foo;\n-              fn main() { foo::Foo::Bar { <|>bar: () }; }\n-              //- /foo.rs\n-              pub enum Foo { Bar { bar: () } }\n-              \",\n-            r\"pub enum Foo { Bar { <|>pub(crate) bar: () } }\n-\n-\",\n-        );\n-        check_assist_not_applicable(\n-            change_visibility,\n-            r\"mod foo { pub struct Foo { pub bar: (), } }\n-              fn main() { foo::Foo { <|>bar: () }; } \",\n-        );\n-        check_assist_not_applicable(\n-            change_visibility,\n-            r\"//- /lib.rs\n-              mod foo;\n-              fn main() { foo::Foo { <|>bar: () }; }\n-              //- /foo.rs\n-              pub struct Foo { pub bar: () }\n-              \",\n-        );\n-    }\n-\n-    #[test]\n-    #[ignore]\n-    // FIXME reenable this test when `Semantics::resolve_record_field` works with union fields\n-    fn change_visibility_of_union_field_via_path() {\n-        check_assist(\n-            change_visibility,\n-            r\"mod foo { pub union Foo { bar: (), } }\n-              fn main() { foo::Foo { <|>bar: () }; } \",\n-            r\"mod foo { pub union Foo { <|>pub(crate) bar: (), } }\n-              fn main() { foo::Foo { bar: () }; } \",\n-        );\n-        check_assist(\n-            change_visibility,\n-            r\"//- /lib.rs\n-              mod foo;\n-              fn main() { foo::Foo { <|>bar: () }; }\n-              //- /foo.rs\n-              pub union Foo { bar: () }\n-              \",\n-            r\"pub union Foo { <|>pub(crate) bar: () }\n-\n-\",\n-        );\n-        check_assist_not_applicable(\n-            change_visibility,\n-            r\"mod foo { pub union Foo { pub bar: (), } }\n-              fn main() { foo::Foo { <|>bar: () }; } \",\n-        );\n-        check_assist_not_applicable(\n-            change_visibility,\n-            r\"//- /lib.rs\n-              mod foo;\n-              fn main() { foo::Foo { <|>bar: () }; }\n-              //- /foo.rs\n-              pub union Foo { pub bar: () }\n-              \",\n-        );\n-    }\n-\n     #[test]\n     fn not_applicable_for_enum_variants() {\n         check_assist_not_applicable(\n@@ -529,182 +200,6 @@ mod tests {\n         );\n     }\n \n-    #[test]\n-    fn change_visibility_of_const_via_path() {\n-        check_assist(\n-            change_visibility,\n-            r\"mod foo { const FOO: () = (); }\n-              fn main() { foo::FOO<|> } \",\n-            r\"mod foo { <|>pub(crate) const FOO: () = (); }\n-              fn main() { foo::FOO } \",\n-        );\n-        check_assist_not_applicable(\n-            change_visibility,\n-            r\"mod foo { pub const FOO: () = (); }\n-              fn main() { foo::FOO<|> } \",\n-        );\n-    }\n-\n-    #[test]\n-    fn change_visibility_of_static_via_path() {\n-        check_assist(\n-            change_visibility,\n-            r\"mod foo { static FOO: () = (); }\n-              fn main() { foo::FOO<|> } \",\n-            r\"mod foo { <|>pub(crate) static FOO: () = (); }\n-              fn main() { foo::FOO } \",\n-        );\n-        check_assist_not_applicable(\n-            change_visibility,\n-            r\"mod foo { pub static FOO: () = (); }\n-              fn main() { foo::FOO<|> } \",\n-        );\n-    }\n-\n-    #[test]\n-    fn change_visibility_of_trait_via_path() {\n-        check_assist(\n-            change_visibility,\n-            r\"mod foo { trait Foo { fn foo(&self) {} } }\n-              fn main() { let x: &dyn foo::<|>Foo; } \",\n-            r\"mod foo { <|>pub(crate) trait Foo { fn foo(&self) {} } }\n-              fn main() { let x: &dyn foo::Foo; } \",\n-        );\n-        check_assist_not_applicable(\n-            change_visibility,\n-            r\"mod foo { pub trait Foo { fn foo(&self) {} } }\n-              fn main() { let x: &dyn foo::Foo<|>; } \",\n-        );\n-    }\n-\n-    #[test]\n-    fn change_visibility_of_type_alias_via_path() {\n-        check_assist(\n-            change_visibility,\n-            r\"mod foo { type Foo = (); }\n-              fn main() { let x: foo::Foo<|>; } \",\n-            r\"mod foo { <|>pub(crate) type Foo = (); }\n-              fn main() { let x: foo::Foo; } \",\n-        );\n-        check_assist_not_applicable(\n-            change_visibility,\n-            r\"mod foo { pub type Foo = (); }\n-              fn main() { let x: foo::Foo<|>; } \",\n-        );\n-    }\n-\n-    #[test]\n-    fn change_visibility_of_module_via_path() {\n-        check_assist(\n-            change_visibility,\n-            r\"mod foo { mod bar { fn bar() {} } }\n-              fn main() { foo::bar<|>::bar(); } \",\n-            r\"mod foo { <|>pub(crate) mod bar { fn bar() {} } }\n-              fn main() { foo::bar::bar(); } \",\n-        );\n-\n-        check_assist(\n-            change_visibility,\n-            r\"\n-            //- /main.rs\n-            mod foo;\n-            fn main() { foo::bar<|>::baz(); }\n-\n-            //- /foo.rs\n-            mod bar {\n-                pub fn baz() {}\n-            }\n-            \",\n-            r\"<|>pub(crate) mod bar {\n-    pub fn baz() {}\n-}\n-\n-\",\n-        );\n-\n-        check_assist_not_applicable(\n-            change_visibility,\n-            r\"mod foo { pub mod bar { pub fn bar() {} } }\n-              fn main() { foo::bar<|>::bar(); } \",\n-        );\n-    }\n-\n-    #[test]\n-    fn change_visibility_of_inline_module_in_other_file_via_path() {\n-        check_assist(\n-            change_visibility,\n-            r\"\n-            //- /main.rs\n-            mod foo;\n-            fn main() { foo::bar<|>::baz(); }\n-\n-            //- /foo.rs\n-            mod bar;\n-\n-            //- /foo/bar.rs\n-            pub fn baz() {}\n-            }\n-            \",\n-            r\"<|>pub(crate) mod bar;\n-\",\n-        );\n-    }\n-\n-    #[test]\n-    fn change_visibility_of_module_declaration_in_other_file_via_path() {\n-        check_assist(\n-            change_visibility,\n-            r\"//- /main.rs\n-              mod foo;\n-              fn main() { foo::bar<|>>::baz(); }\n-\n-              //- /foo.rs\n-              mod bar {\n-                  pub fn baz() {}\n-              }\",\n-            r\"<|>pub(crate) mod bar {\n-    pub fn baz() {}\n-}\n-\",\n-        );\n-    }\n-\n-    #[test]\n-    #[ignore]\n-    // FIXME handle reexports properly\n-    fn change_visibility_of_reexport() {\n-        check_assist(\n-            change_visibility,\n-            r\"\n-            mod foo {\n-                use bar::Baz;\n-                mod bar { pub(super) struct Baz; }\n-            }\n-            foo::Baz<|>\n-            \",\n-            r\"\n-            mod foo {\n-                <|>pub(crate) use bar::Baz;\n-                mod bar { pub(super) struct Baz; }\n-            }\n-            foo::Baz\n-            \",\n-        )\n-    }\n-\n-    #[test]\n-    fn adds_pub_when_target_is_in_another_crate() {\n-        check_assist(\n-            change_visibility,\n-            r\"//- /main.rs crate:a deps:foo\n-              foo::Bar<|>\n-              //- /lib.rs crate:foo\n-              struct Bar;\",\n-            r\"<|>pub struct Bar;\n-\",\n-        )\n-    }\n-\n     #[test]\n     fn change_visibility_target() {\n         check_assist_target(change_visibility, \"<|>fn foo() {}\", \"fn\");"}, {"sha": "48ce07ca5a3a5a7f6587132f735dfe0f5c79643c", "filename": "crates/ra_assists/src/handlers/fix_visibility.rs", "status": "added", "additions": 555, "deletions": 0, "changes": 555, "blob_url": "https://github.com/rust-lang/rust/blob/75c7695e86f967ec87f072a3a26fc23239de0a7e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75c7695e86f967ec87f072a3a26fc23239de0a7e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs?ref=75c7695e86f967ec87f072a3a26fc23239de0a7e", "patch": "@@ -0,0 +1,555 @@\n+use hir::{db::HirDatabase, HasSource, HasVisibility, PathResolution};\n+use ra_db::FileId;\n+use ra_syntax::{\n+    ast, AstNode,\n+    SyntaxKind::{ATTR, COMMENT, WHITESPACE},\n+    SyntaxNode, TextRange, TextSize,\n+};\n+\n+use crate::{AssistContext, AssistId, Assists};\n+\n+// FIXME: this really should be a fix for diagnostic, rather than an assist.\n+\n+// Assist: fix_visibility\n+//\n+// Makes inaccessible item public.\n+//\n+// ```\n+// mod m {\n+//     fn frobnicate() {}\n+// }\n+// fn main() {\n+//     m::frobnicate<|>() {}\n+// }\n+// ```\n+// ->\n+// ```\n+// mod m {\n+//     pub(crate) fn frobnicate() {}\n+// }\n+// fn main() {\n+//     m::frobnicate() {}\n+// }\n+// ```\n+pub(crate) fn fix_visibility(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    add_vis_to_referenced_module_def(acc, ctx)\n+        .or_else(|| add_vis_to_referenced_record_field(acc, ctx))\n+}\n+\n+fn add_vis_to_referenced_module_def(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let path: ast::Path = ctx.find_node_at_offset()?;\n+    let path_res = ctx.sema.resolve_path(&path)?;\n+    let def = match path_res {\n+        PathResolution::Def(def) => def,\n+        _ => return None,\n+    };\n+\n+    let current_module = ctx.sema.scope(&path.syntax()).module()?;\n+    let target_module = def.module(ctx.db)?;\n+\n+    let vis = target_module.visibility_of(ctx.db, &def)?;\n+    if vis.is_visible_from(ctx.db, current_module.into()) {\n+        return None;\n+    };\n+\n+    let (offset, target, target_file, target_name) = target_data_for_def(ctx.db, def)?;\n+\n+    let missing_visibility =\n+        if current_module.krate() == target_module.krate() { \"pub(crate)\" } else { \"pub\" };\n+\n+    let assist_label = match target_name {\n+        None => format!(\"Change visibility to {}\", missing_visibility),\n+        Some(name) => format!(\"Change visibility of {} to {}\", name, missing_visibility),\n+    };\n+\n+    acc.add(AssistId(\"fix_visibility\"), assist_label, target, |edit| {\n+        edit.set_file(target_file);\n+        edit.insert(offset, format!(\"{} \", missing_visibility));\n+        edit.set_cursor(offset);\n+    })\n+}\n+\n+fn add_vis_to_referenced_record_field(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let record_field: ast::RecordField = ctx.find_node_at_offset()?;\n+    let (record_field_def, _) = ctx.sema.resolve_record_field(&record_field)?;\n+\n+    let current_module = ctx.sema.scope(record_field.syntax()).module()?;\n+    let visibility = record_field_def.visibility(ctx.db);\n+    if visibility.is_visible_from(ctx.db, current_module.into()) {\n+        return None;\n+    }\n+\n+    let parent = record_field_def.parent_def(ctx.db);\n+    let parent_name = parent.name(ctx.db);\n+    let target_module = parent.module(ctx.db);\n+\n+    let in_file_source = record_field_def.source(ctx.db);\n+    let (offset, target) = match in_file_source.value {\n+        hir::FieldSource::Named(it) => {\n+            let s = it.syntax();\n+            (vis_offset(s), s.text_range())\n+        }\n+        hir::FieldSource::Pos(it) => {\n+            let s = it.syntax();\n+            (vis_offset(s), s.text_range())\n+        }\n+    };\n+\n+    let missing_visibility =\n+        if current_module.krate() == target_module.krate() { \"pub(crate)\" } else { \"pub\" };\n+    let target_file = in_file_source.file_id.original_file(ctx.db);\n+\n+    let target_name = record_field_def.name(ctx.db);\n+    let assist_label =\n+        format!(\"Change visibility of {}.{} to {}\", parent_name, target_name, missing_visibility);\n+\n+    acc.add(AssistId(\"fix_visibility\"), assist_label, target, |edit| {\n+        edit.set_file(target_file);\n+        edit.insert(offset, format!(\"{} \", missing_visibility));\n+        edit.set_cursor(offset)\n+    })\n+}\n+\n+fn target_data_for_def(\n+    db: &dyn HirDatabase,\n+    def: hir::ModuleDef,\n+) -> Option<(TextSize, TextRange, FileId, Option<hir::Name>)> {\n+    fn offset_target_and_file_id<S, Ast>(\n+        db: &dyn HirDatabase,\n+        x: S,\n+    ) -> (TextSize, TextRange, FileId)\n+    where\n+        S: HasSource<Ast = Ast>,\n+        Ast: AstNode,\n+    {\n+        let source = x.source(db);\n+        let in_file_syntax = source.syntax();\n+        let file_id = in_file_syntax.file_id;\n+        let syntax = in_file_syntax.value;\n+        (vis_offset(syntax), syntax.text_range(), file_id.original_file(db.upcast()))\n+    }\n+\n+    let target_name;\n+    let (offset, target, target_file) = match def {\n+        hir::ModuleDef::Function(f) => {\n+            target_name = Some(f.name(db));\n+            offset_target_and_file_id(db, f)\n+        }\n+        hir::ModuleDef::Adt(adt) => {\n+            target_name = Some(adt.name(db));\n+            match adt {\n+                hir::Adt::Struct(s) => offset_target_and_file_id(db, s),\n+                hir::Adt::Union(u) => offset_target_and_file_id(db, u),\n+                hir::Adt::Enum(e) => offset_target_and_file_id(db, e),\n+            }\n+        }\n+        hir::ModuleDef::Const(c) => {\n+            target_name = c.name(db);\n+            offset_target_and_file_id(db, c)\n+        }\n+        hir::ModuleDef::Static(s) => {\n+            target_name = s.name(db);\n+            offset_target_and_file_id(db, s)\n+        }\n+        hir::ModuleDef::Trait(t) => {\n+            target_name = Some(t.name(db));\n+            offset_target_and_file_id(db, t)\n+        }\n+        hir::ModuleDef::TypeAlias(t) => {\n+            target_name = Some(t.name(db));\n+            offset_target_and_file_id(db, t)\n+        }\n+        hir::ModuleDef::Module(m) => {\n+            target_name = m.name(db);\n+            let in_file_source = m.declaration_source(db)?;\n+            let file_id = in_file_source.file_id.original_file(db.upcast());\n+            let syntax = in_file_source.value.syntax();\n+            (vis_offset(syntax), syntax.text_range(), file_id)\n+        }\n+        // Enum variants can't be private, we can't modify builtin types\n+        hir::ModuleDef::EnumVariant(_) | hir::ModuleDef::BuiltinType(_) => return None,\n+    };\n+\n+    Some((offset, target, target_file, target_name))\n+}\n+\n+fn vis_offset(node: &SyntaxNode) -> TextSize {\n+    node.children_with_tokens()\n+        .skip_while(|it| match it.kind() {\n+            WHITESPACE | COMMENT | ATTR => true,\n+            _ => false,\n+        })\n+        .next()\n+        .map(|it| it.text_range().start())\n+        .unwrap_or_else(|| node.text_range().start())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn fix_visibility_of_fn() {\n+        check_assist(\n+            fix_visibility,\n+            r\"mod foo { fn foo() {} }\n+              fn main() { foo::foo<|>() } \",\n+            r\"mod foo { <|>pub(crate) fn foo() {} }\n+              fn main() { foo::foo() } \",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"mod foo { pub fn foo() {} }\n+              fn main() { foo::foo<|>() } \",\n+        )\n+    }\n+\n+    #[test]\n+    fn fix_visibility_of_adt_in_submodule() {\n+        check_assist(\n+            fix_visibility,\n+            r\"mod foo { struct Foo; }\n+              fn main() { foo::Foo<|> } \",\n+            r\"mod foo { <|>pub(crate) struct Foo; }\n+              fn main() { foo::Foo } \",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"mod foo { pub struct Foo; }\n+              fn main() { foo::Foo<|> } \",\n+        );\n+        check_assist(\n+            fix_visibility,\n+            r\"mod foo { enum Foo; }\n+              fn main() { foo::Foo<|> } \",\n+            r\"mod foo { <|>pub(crate) enum Foo; }\n+              fn main() { foo::Foo } \",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"mod foo { pub enum Foo; }\n+              fn main() { foo::Foo<|> } \",\n+        );\n+        check_assist(\n+            fix_visibility,\n+            r\"mod foo { union Foo; }\n+              fn main() { foo::Foo<|> } \",\n+            r\"mod foo { <|>pub(crate) union Foo; }\n+              fn main() { foo::Foo } \",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"mod foo { pub union Foo; }\n+              fn main() { foo::Foo<|> } \",\n+        );\n+    }\n+\n+    #[test]\n+    fn fix_visibility_of_adt_in_other_file() {\n+        check_assist(\n+            fix_visibility,\n+            r\"\n+              //- /main.rs\n+              mod foo;\n+              fn main() { foo::Foo<|> }\n+\n+              //- /foo.rs\n+              struct Foo;\n+              \",\n+            r\"<|>pub(crate) struct Foo;\n+\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn fix_visibility_of_struct_field() {\n+        check_assist(\n+            fix_visibility,\n+            r\"mod foo { pub struct Foo { bar: (), } }\n+              fn main() { foo::Foo { <|>bar: () }; } \",\n+            r\"mod foo { pub struct Foo { <|>pub(crate) bar: (), } }\n+              fn main() { foo::Foo { bar: () }; } \",\n+        );\n+        check_assist(\n+            fix_visibility,\n+            r\"//- /lib.rs\n+              mod foo;\n+              fn main() { foo::Foo { <|>bar: () }; }\n+              //- /foo.rs\n+              pub struct Foo { bar: () }\n+              \",\n+            r\"pub struct Foo { <|>pub(crate) bar: () }\n+\n+\",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"mod foo { pub struct Foo { pub bar: (), } }\n+              fn main() { foo::Foo { <|>bar: () }; } \",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"//- /lib.rs\n+              mod foo;\n+              fn main() { foo::Foo { <|>bar: () }; }\n+              //- /foo.rs\n+              pub struct Foo { pub bar: () }\n+              \",\n+        );\n+    }\n+\n+    #[test]\n+    fn fix_visibility_of_enum_variant_field() {\n+        check_assist(\n+            fix_visibility,\n+            r\"mod foo { pub enum Foo { Bar { bar: () } } }\n+              fn main() { foo::Foo::Bar { <|>bar: () }; } \",\n+            r\"mod foo { pub enum Foo { Bar { <|>pub(crate) bar: () } } }\n+              fn main() { foo::Foo::Bar { bar: () }; } \",\n+        );\n+        check_assist(\n+            fix_visibility,\n+            r\"//- /lib.rs\n+              mod foo;\n+              fn main() { foo::Foo::Bar { <|>bar: () }; }\n+              //- /foo.rs\n+              pub enum Foo { Bar { bar: () } }\n+              \",\n+            r\"pub enum Foo { Bar { <|>pub(crate) bar: () } }\n+\n+\",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"mod foo { pub struct Foo { pub bar: (), } }\n+              fn main() { foo::Foo { <|>bar: () }; } \",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"//- /lib.rs\n+              mod foo;\n+              fn main() { foo::Foo { <|>bar: () }; }\n+              //- /foo.rs\n+              pub struct Foo { pub bar: () }\n+              \",\n+        );\n+    }\n+\n+    #[test]\n+    #[ignore]\n+    // FIXME reenable this test when `Semantics::resolve_record_field` works with union fields\n+    fn fix_visibility_of_union_field() {\n+        check_assist(\n+            fix_visibility,\n+            r\"mod foo { pub union Foo { bar: (), } }\n+              fn main() { foo::Foo { <|>bar: () }; } \",\n+            r\"mod foo { pub union Foo { <|>pub(crate) bar: (), } }\n+              fn main() { foo::Foo { bar: () }; } \",\n+        );\n+        check_assist(\n+            fix_visibility,\n+            r\"//- /lib.rs\n+              mod foo;\n+              fn main() { foo::Foo { <|>bar: () }; }\n+              //- /foo.rs\n+              pub union Foo { bar: () }\n+              \",\n+            r\"pub union Foo { <|>pub(crate) bar: () }\n+\n+\",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"mod foo { pub union Foo { pub bar: (), } }\n+              fn main() { foo::Foo { <|>bar: () }; } \",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"//- /lib.rs\n+              mod foo;\n+              fn main() { foo::Foo { <|>bar: () }; }\n+              //- /foo.rs\n+              pub union Foo { pub bar: () }\n+              \",\n+        );\n+    }\n+\n+    #[test]\n+    fn fix_visibility_of_const() {\n+        check_assist(\n+            fix_visibility,\n+            r\"mod foo { const FOO: () = (); }\n+              fn main() { foo::FOO<|> } \",\n+            r\"mod foo { <|>pub(crate) const FOO: () = (); }\n+              fn main() { foo::FOO } \",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"mod foo { pub const FOO: () = (); }\n+              fn main() { foo::FOO<|> } \",\n+        );\n+    }\n+\n+    #[test]\n+    fn fix_visibility_of_static() {\n+        check_assist(\n+            fix_visibility,\n+            r\"mod foo { static FOO: () = (); }\n+              fn main() { foo::FOO<|> } \",\n+            r\"mod foo { <|>pub(crate) static FOO: () = (); }\n+              fn main() { foo::FOO } \",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"mod foo { pub static FOO: () = (); }\n+              fn main() { foo::FOO<|> } \",\n+        );\n+    }\n+\n+    #[test]\n+    fn fix_visibility_of_trait() {\n+        check_assist(\n+            fix_visibility,\n+            r\"mod foo { trait Foo { fn foo(&self) {} } }\n+              fn main() { let x: &dyn foo::<|>Foo; } \",\n+            r\"mod foo { <|>pub(crate) trait Foo { fn foo(&self) {} } }\n+              fn main() { let x: &dyn foo::Foo; } \",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"mod foo { pub trait Foo { fn foo(&self) {} } }\n+              fn main() { let x: &dyn foo::Foo<|>; } \",\n+        );\n+    }\n+\n+    #[test]\n+    fn fix_visibility_of_type_alias() {\n+        check_assist(\n+            fix_visibility,\n+            r\"mod foo { type Foo = (); }\n+              fn main() { let x: foo::Foo<|>; } \",\n+            r\"mod foo { <|>pub(crate) type Foo = (); }\n+              fn main() { let x: foo::Foo; } \",\n+        );\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"mod foo { pub type Foo = (); }\n+              fn main() { let x: foo::Foo<|>; } \",\n+        );\n+    }\n+\n+    #[test]\n+    fn fix_visibility_of_module() {\n+        check_assist(\n+            fix_visibility,\n+            r\"mod foo { mod bar { fn bar() {} } }\n+              fn main() { foo::bar<|>::bar(); } \",\n+            r\"mod foo { <|>pub(crate) mod bar { fn bar() {} } }\n+              fn main() { foo::bar::bar(); } \",\n+        );\n+\n+        check_assist(\n+            fix_visibility,\n+            r\"\n+            //- /main.rs\n+            mod foo;\n+            fn main() { foo::bar<|>::baz(); }\n+\n+            //- /foo.rs\n+            mod bar {\n+                pub fn baz() {}\n+            }\n+            \",\n+            r\"<|>pub(crate) mod bar {\n+    pub fn baz() {}\n+}\n+\n+\",\n+        );\n+\n+        check_assist_not_applicable(\n+            fix_visibility,\n+            r\"mod foo { pub mod bar { pub fn bar() {} } }\n+              fn main() { foo::bar<|>::bar(); } \",\n+        );\n+    }\n+\n+    #[test]\n+    fn fix_visibility_of_inline_module_in_other_file() {\n+        check_assist(\n+            fix_visibility,\n+            r\"\n+            //- /main.rs\n+            mod foo;\n+            fn main() { foo::bar<|>::baz(); }\n+\n+            //- /foo.rs\n+            mod bar;\n+\n+            //- /foo/bar.rs\n+            pub fn baz() {}\n+            }\n+            \",\n+            r\"<|>pub(crate) mod bar;\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn fix_visibility_of_module_declaration_in_other_file() {\n+        check_assist(\n+            fix_visibility,\n+            r\"//- /main.rs\n+              mod foo;\n+              fn main() { foo::bar<|>>::baz(); }\n+\n+              //- /foo.rs\n+              mod bar {\n+                  pub fn baz() {}\n+              }\",\n+            r\"<|>pub(crate) mod bar {\n+    pub fn baz() {}\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn adds_pub_when_target_is_in_another_crate() {\n+        check_assist(\n+            fix_visibility,\n+            r\"//- /main.rs crate:a deps:foo\n+              foo::Bar<|>\n+              //- /lib.rs crate:foo\n+              struct Bar;\",\n+            r\"<|>pub struct Bar;\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    #[ignore]\n+    // FIXME handle reexports properly\n+    fn fix_visibility_of_reexport() {\n+        check_assist(\n+            fix_visibility,\n+            r\"\n+            mod foo {\n+                use bar::Baz;\n+                mod bar { pub(super) struct Baz; }\n+            }\n+            foo::Baz<|>\n+            \",\n+            r\"\n+            mod foo {\n+                <|>pub(crate) use bar::Baz;\n+                mod bar { pub(super) struct Baz; }\n+            }\n+            foo::Baz\n+            \",\n+        )\n+    }\n+}"}, {"sha": "464bc03dde9e77e0ca2359786424da8014f39675", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75c7695e86f967ec87f072a3a26fc23239de0a7e/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75c7695e86f967ec87f072a3a26fc23239de0a7e/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=75c7695e86f967ec87f072a3a26fc23239de0a7e", "patch": "@@ -116,6 +116,7 @@ mod handlers {\n     mod change_visibility;\n     mod early_return;\n     mod fill_match_arms;\n+    mod fix_visibility;\n     mod flip_binexpr;\n     mod flip_comma;\n     mod flip_trait_bound;\n@@ -154,6 +155,7 @@ mod handlers {\n             change_visibility::change_visibility,\n             early_return::convert_to_guarded_return,\n             fill_match_arms::fill_match_arms,\n+            fix_visibility::fix_visibility,\n             flip_binexpr::flip_binexpr,\n             flip_comma::flip_comma,\n             flip_trait_bound::flip_trait_bound,"}, {"sha": "417ee89a888bf77239886e3c5883c84067e673ef", "filename": "crates/ra_assists/src/tests/generated.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/75c7695e86f967ec87f072a3a26fc23239de0a7e/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75c7695e86f967ec87f072a3a26fc23239de0a7e/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=75c7695e86f967ec87f072a3a26fc23239de0a7e", "patch": "@@ -344,6 +344,29 @@ fn handle(action: Action) {\n     )\n }\n \n+#[test]\n+fn doctest_fix_visibility() {\n+    check_doc_test(\n+        \"fix_visibility\",\n+        r#####\"\n+mod m {\n+    fn frobnicate() {}\n+}\n+fn main() {\n+    m::frobnicate<|>() {}\n+}\n+\"#####,\n+        r#####\"\n+mod m {\n+    pub(crate) fn frobnicate() {}\n+}\n+fn main() {\n+    m::frobnicate() {}\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_flip_binexpr() {\n     check_doc_test("}, {"sha": "0ae242389e8e4ec440edc23527ee039e3f499cb7", "filename": "docs/user/assists.md", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/75c7695e86f967ec87f072a3a26fc23239de0a7e/docs%2Fuser%2Fassists.md", "raw_url": "https://github.com/rust-lang/rust/raw/75c7695e86f967ec87f072a3a26fc23239de0a7e/docs%2Fuser%2Fassists.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fassists.md?ref=75c7695e86f967ec87f072a3a26fc23239de0a7e", "patch": "@@ -331,6 +331,28 @@ fn handle(action: Action) {\n }\n ```\n \n+## `fix_visibility`\n+\n+Makes inaccessible item public.\n+\n+```rust\n+// BEFORE\n+mod m {\n+    fn frobnicate() {}\n+}\n+fn main() {\n+    m::frobnicate\u2503() {}\n+}\n+\n+// AFTER\n+mod m {\n+    pub(crate) fn frobnicate() {}\n+}\n+fn main() {\n+    m::frobnicate() {}\n+}\n+```\n+\n ## `flip_binexpr`\n \n Flips operands of a binary expression."}]}