{"sha": "f690cc2c63d436434412cef56154627d94b6284e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2OTBjYzJjNjNkNDM2NDM0NDEyY2VmNTYxNTQ2MjdkOTRiNjI4NGU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-03-04T18:39:49Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-03-08T20:08:59Z"}, "message": "libstd: Add some more functionality to Vec<T>", "tree": {"sha": "2960e435394c41d0ecaa04603bfc6429ad14aed6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2960e435394c41d0ecaa04603bfc6429ad14aed6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f690cc2c63d436434412cef56154627d94b6284e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f690cc2c63d436434412cef56154627d94b6284e", "html_url": "https://github.com/rust-lang/rust/commit/f690cc2c63d436434412cef56154627d94b6284e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f690cc2c63d436434412cef56154627d94b6284e/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96e8c00e95b1980c429c5cfa4aae33e3cc60f3c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/96e8c00e95b1980c429c5cfa4aae33e3cc60f3c5", "html_url": "https://github.com/rust-lang/rust/commit/96e8c00e95b1980c429c5cfa4aae33e3cc60f3c5"}], "stats": {"total": 131, "additions": 131, "deletions": 0}, "files": [{"sha": "f625e638ae881feec244a6ca70e6436d0b227fd4", "filename": "src/libstd/vec_ng.rs", "status": "modified", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/f690cc2c63d436434412cef56154627d94b6284e/src%2Flibstd%2Fvec_ng.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f690cc2c63d436434412cef56154627d94b6284e/src%2Flibstd%2Fvec_ng.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec_ng.rs?ref=f690cc2c63d436434412cef56154627d94b6284e", "patch": "@@ -20,6 +20,7 @@ use fmt;\n use iter::{DoubleEndedIterator, FromIterator, Extendable, Iterator};\n use libc::{free, c_void};\n use mem::{size_of, move_val_init};\n+use mem;\n use num;\n use num::{CheckedMul, CheckedAdd};\n use ops::Drop;\n@@ -66,6 +67,14 @@ impl<T> Vec<T> {\n }\n \n impl<T: Clone> Vec<T> {\n+    pub fn from_slice(values: &[T]) -> Vec<T> {\n+        let mut vector = Vec::new();\n+        for value in values.iter() {\n+            vector.push((*value).clone())\n+        }\n+        vector\n+    }\n+\n     pub fn from_elem(length: uint, value: T) -> Vec<T> {\n         unsafe {\n             let mut xs = Vec::with_capacity(length);\n@@ -282,6 +291,12 @@ impl<T> Vec<T> {\n         }\n     }\n \n+    #[inline]\n+    pub fn move_rev_iter(mut self) -> MoveItems<T> {\n+        self.reverse();\n+        self.move_iter()\n+    }\n+\n     #[inline]\n     pub unsafe fn set_len(&mut self, len: uint) {\n         self.len = len;\n@@ -322,6 +337,11 @@ impl<T> Vec<T> {\n         self.as_slice().tail()\n     }\n \n+    #[inline]\n+    pub fn tailn<'a>(&'a self, n: uint) -> &'a [T] {\n+        self.as_slice().tailn(n)\n+    }\n+\n     #[inline]\n     pub fn last<'a>(&'a self) -> Option<&'a T> {\n         self.as_slice().last()\n@@ -387,21 +407,132 @@ impl<T> Vec<T> {\n         }\n     }\n \n+    #[inline]\n+    pub fn mut_slice<'a>(&'a mut self, start: uint, end: uint)\n+                     -> &'a mut [T] {\n+        self.as_mut_slice().mut_slice(start, end)\n+    }\n+\n+    #[inline]\n+    pub fn reverse(&mut self) {\n+        self.as_mut_slice().reverse()\n+    }\n+\n+    #[inline]\n     pub fn slice_from<'a>(&'a self, start: uint) -> &'a [T] {\n         self.as_slice().slice_from(start)\n     }\n \n+    #[inline]\n+    pub fn slice_to<'a>(&'a self, end: uint) -> &'a [T] {\n+        self.as_slice().slice_to(end)\n+    }\n+\n     #[inline]\n     pub fn init<'a>(&'a self) -> &'a [T] {\n         self.slice(0, self.len() - 1)\n     }\n+\n+    #[inline]\n+    pub fn as_ptr(&self) -> *T {\n+        self.as_slice().as_ptr()\n+    }\n+\n+    #[inline]\n+    pub fn clear(&mut self) {\n+        self.truncate(0)\n+    }\n }\n \n impl<T:Eq> Vec<T> {\n     /// Return true if a vector contains an element with the given value\n     pub fn contains(&self, x: &T) -> bool {\n         self.as_slice().contains(x)\n     }\n+\n+    pub fn dedup(&mut self) {\n+        unsafe {\n+            // Although we have a mutable reference to `self`, we cannot make\n+            // *arbitrary* changes. The `Eq` comparisons could fail, so we\n+            // must ensure that the vector is in a valid state at all time.\n+            //\n+            // The way that we handle this is by using swaps; we iterate\n+            // over all the elements, swapping as we go so that at the end\n+            // the elements we wish to keep are in the front, and those we\n+            // wish to reject are at the back. We can then truncate the\n+            // vector. This operation is still O(n).\n+            //\n+            // Example: We start in this state, where `r` represents \"next\n+            // read\" and `w` represents \"next_write`.\n+            //\n+            //           r\n+            //     +---+---+---+---+---+---+\n+            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n+            //     +---+---+---+---+---+---+\n+            //           w\n+            //\n+            // Comparing self[r] against self[w-1], tis is not a duplicate, so\n+            // we swap self[r] and self[w] (no effect as r==w) and then increment both\n+            // r and w, leaving us with:\n+            //\n+            //               r\n+            //     +---+---+---+---+---+---+\n+            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n+            //     +---+---+---+---+---+---+\n+            //               w\n+            //\n+            // Comparing self[r] against self[w-1], this value is a duplicate,\n+            // so we increment `r` but leave everything else unchanged:\n+            //\n+            //                   r\n+            //     +---+---+---+---+---+---+\n+            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n+            //     +---+---+---+---+---+---+\n+            //               w\n+            //\n+            // Comparing self[r] against self[w-1], this is not a duplicate,\n+            // so swap self[r] and self[w] and advance r and w:\n+            //\n+            //                       r\n+            //     +---+---+---+---+---+---+\n+            //     | 0 | 1 | 2 | 1 | 3 | 3 |\n+            //     +---+---+---+---+---+---+\n+            //                   w\n+            //\n+            // Not a duplicate, repeat:\n+            //\n+            //                           r\n+            //     +---+---+---+---+---+---+\n+            //     | 0 | 1 | 2 | 3 | 1 | 3 |\n+            //     +---+---+---+---+---+---+\n+            //                       w\n+            //\n+            // Duplicate, advance r. End of vec. Truncate to w.\n+\n+            let ln = self.len();\n+            if ln < 1 { return; }\n+\n+            // Avoid bounds checks by using unsafe pointers.\n+            let p = self.as_mut_slice().as_mut_ptr();\n+            let mut r = 1;\n+            let mut w = 1;\n+\n+            while r < ln {\n+                let p_r = p.offset(r as int);\n+                let p_wm1 = p.offset((w - 1) as int);\n+                if *p_r != *p_wm1 {\n+                    if r != w {\n+                        let p_w = p_wm1.offset(1);\n+                        mem::swap(&mut *p_r, &mut *p_w);\n+                    }\n+                    w += 1;\n+                }\n+                r += 1;\n+            }\n+\n+            self.truncate(w);\n+        }\n+    }\n }\n \n #[inline]"}]}