{"sha": "6eeedbcd70855b45cf41ef14bc91a15f0ee67c7c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlZWVkYmNkNzA4NTViNDVjZjQxZWYxNGJjOTFhMTVmMGVlNjdjN2M=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-20T14:08:26Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-20T14:22:43Z"}, "message": "generator fields are not necessarily initialized", "tree": {"sha": "1657a3c71167b17a6c2649354dfe625312ef85b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1657a3c71167b17a6c2649354dfe625312ef85b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6eeedbcd70855b45cf41ef14bc91a15f0ee67c7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6eeedbcd70855b45cf41ef14bc91a15f0ee67c7c", "html_url": "https://github.com/rust-lang/rust/commit/6eeedbcd70855b45cf41ef14bc91a15f0ee67c7c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6eeedbcd70855b45cf41ef14bc91a15f0ee67c7c/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "046e054a995c7b293e26968774ff88b38661cd3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/046e054a995c7b293e26968774ff88b38661cd3c", "html_url": "https://github.com/rust-lang/rust/commit/046e054a995c7b293e26968774ff88b38661cd3c"}], "stats": {"total": 33, "additions": 22, "deletions": 11}, "files": [{"sha": "505195763d062fa2736e1027293de0bbf001222f", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6eeedbcd70855b45cf41ef14bc91a15f0ee67c7c/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eeedbcd70855b45cf41ef14bc91a15f0ee67c7c/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=6eeedbcd70855b45cf41ef14bc91a15f0ee67c7c", "patch": "@@ -142,6 +142,7 @@ macro_rules! make_value_visitor {\n                 self.walk_value(v)\n             }\n             /// Visit the given value as a union.  No automatic recursion can happen here.\n+            /// Also called for the fields of a generator, which may or may not be initialized.\n             #[inline(always)]\n             fn visit_union(&mut self, _v: Self::V) -> EvalResult<'tcx>\n             {\n@@ -291,17 +292,28 @@ macro_rules! make_value_visitor {\n                         // use that as an unambiguous signal for detecting primitives.  Make sure\n                         // we did not miss any primitive.\n                         debug_assert!(fields > 0);\n-                        self.visit_union(v)?;\n+                        self.visit_union(v)\n                     },\n                     layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n-                        // FIXME: We collect in a vec because otherwise there are lifetime errors:\n-                        // Projecting to a field needs (mutable!) access to `ecx`.\n-                        let fields: Vec<EvalResult<'tcx, Self::V>> =\n-                            (0..offsets.len()).map(|i| {\n-                                v.project_field(self.ecx(), i as u64)\n-                            })\n-                            .collect();\n-                        self.visit_aggregate(v, fields.into_iter())?;\n+                        // Special handling needed for generators: All but the first field\n+                        // (which is the state) are actually implicitly `MaybeUninit`, i.e.,\n+                        // they may or may not be initialized, so we cannot visit them.\n+                        match v.layout().ty.sty {\n+                            ty::Generator(..) => {\n+                                let field = v.project_field(self.ecx(), 0)?;\n+                                self.visit_aggregate(v, std::iter::once(Ok(field)))\n+                            }\n+                            _ => {\n+                                // FIXME: We collect in a vec because otherwise there are lifetime\n+                                // errors: Projecting to a field needs access to `ecx`.\n+                                let fields: Vec<EvalResult<'tcx, Self::V>> =\n+                                    (0..offsets.len()).map(|i| {\n+                                        v.project_field(self.ecx(), i as u64)\n+                                    })\n+                                    .collect();\n+                                self.visit_aggregate(v, fields.into_iter())\n+                            }\n+                        }\n                     },\n                     layout::FieldPlacement::Array { .. } => {\n                         // Let's get an mplace first.\n@@ -317,10 +329,9 @@ macro_rules! make_value_visitor {\n                             .map(|f| f.and_then(|f| {\n                                 Ok(Value::from_mem_place(f))\n                             }));\n-                        self.visit_aggregate(v, iter)?;\n+                        self.visit_aggregate(v, iter)\n                     }\n                 }\n-                Ok(())\n             }\n         }\n     }"}]}