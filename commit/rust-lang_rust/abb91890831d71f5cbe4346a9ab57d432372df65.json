{"sha": "abb91890831d71f5cbe4346a9ab57d432372df65", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiYjkxODkwODMxZDcxZjVjYmU0MzQ2YTlhYjU3ZDQzMjM3MmRmNjU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-01-06T06:47:09Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-01-07T05:20:39Z"}, "message": "std: Add a nonblocking `Child::try_wait` method\n\nThis commit adds a new method to the `Child` type in the `std::process` module\ncalled `try_wait`. This method is the same as `wait` except that it will not\nblock the calling thread and instead only attempt to collect the exit status. On\nUnix this means that we call `waitpid` with the `WNOHANG` flag and on Windows it\njust means that we pass a 0 timeout to `WaitForSingleObject`.\n\nCurrently it's possible to build this method out of tree, but it's unfortunately\ntricky to do so. Specifically on Unix you essentially lose ownership of the pid\nfor the process once a call to `waitpid` has succeeded. Although `Child` tracks\nthis state internally to be resilient to multiple calls to `wait` or a `kill`\nafter a successful wait, if the child is waited on externally then the state\ninside of `Child` is not updated. This means that external implementations of\nthis method must be extra careful to essentially not use a `Child`'s methods\nafter a call to `waitpid` has succeeded (even in a nonblocking fashion).\n\nBy adding this functionality to the standard library it should help canonicalize\nthese external implementations and ensure they can continue to robustly reuse\nthe `Child` type from the standard library without worrying about pid ownership.", "tree": {"sha": "d7886306e0b9d5f174a0b12fde2d595e15863b2c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7886306e0b9d5f174a0b12fde2d595e15863b2c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/abb91890831d71f5cbe4346a9ab57d432372df65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/abb91890831d71f5cbe4346a9ab57d432372df65", "html_url": "https://github.com/rust-lang/rust/commit/abb91890831d71f5cbe4346a9ab57d432372df65", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/abb91890831d71f5cbe4346a9ab57d432372df65/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42bed7238534b50178cb2bd275f1153d67cc3ece", "url": "https://api.github.com/repos/rust-lang/rust/commits/42bed7238534b50178cb2bd275f1153d67cc3ece", "html_url": "https://github.com/rust-lang/rust/commit/42bed7238534b50178cb2bd275f1153d67cc3ece"}], "stats": {"total": 140, "additions": 140, "deletions": 0}, "files": [{"sha": "ac77a9123a9e5253f6578601fe666fc776bf2fa4", "filename": "src/libstd/process.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/abb91890831d71f5cbe4346a9ab57d432372df65/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abb91890831d71f5cbe4346a9ab57d432372df65/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=abb91890831d71f5cbe4346a9ab57d432372df65", "patch": "@@ -793,6 +793,48 @@ impl Child {\n         self.handle.wait().map(ExitStatus)\n     }\n \n+    /// Attempts to collect the exit status of the child if it has already\n+    /// exited.\n+    ///\n+    /// This function will not block the calling thread and will only advisorily\n+    /// check to see if the child process has exited or not. If the child has\n+    /// exited then on Unix the process id is reaped. This function is\n+    /// guaranteed to repeatedly return a successful exit status so long as the\n+    /// child has already exited.\n+    ///\n+    /// If the child has exited, then `Ok(status)` is returned. If the exit\n+    /// status is not available at this time then an error is returned with the\n+    /// error kind `WouldBlock`. If an error occurs, then that error is returned.\n+    ///\n+    /// Note that unlike `wait`, this function will not attempt to drop stdin.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```no_run\n+    /// #![feature(process_try_wait)]\n+    ///\n+    /// use std::io;\n+    /// use std::process::Command;\n+    ///\n+    /// let mut child = Command::new(\"ls\").spawn().unwrap();\n+    ///\n+    /// match child.try_wait() {\n+    ///     Ok(status) => println!(\"exited with: {}\", status),\n+    ///     Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {\n+    ///         println!(\"status not ready yet, let's really wait\");\n+    ///         let res = child.wait();\n+    ///         println!(\"result: {:?}\", res);\n+    ///     }\n+    ///     Err(e) => println!(\"error attempting to wait: {}\", e),\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"process_try_wait\", issue = \"38903\")]\n+    pub fn try_wait(&mut self) -> io::Result<ExitStatus> {\n+        self.handle.try_wait().map(ExitStatus)\n+    }\n+\n     /// Simultaneously waits for the child to exit and collect all remaining\n     /// output on the stdout/stderr handles, returning an `Output`\n     /// instance."}, {"sha": "0dc1739c1a15aef50a5e7d956ddff298a7c56b85", "filename": "src/libstd/sys/unix/process/process_unix.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/abb91890831d71f5cbe4346a9ab57d432372df65/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abb91890831d71f5cbe4346a9ab57d432372df65/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=abb91890831d71f5cbe4346a9ab57d432372df65", "patch": "@@ -237,6 +237,7 @@ impl Process {\n             cvt(unsafe { libc::kill(self.pid, libc::SIGKILL) }).map(|_| ())\n         }\n     }\n+\n     pub fn wait(&mut self) -> io::Result<ExitStatus> {\n         use sys::cvt_r;\n         if let Some(status) = self.status {\n@@ -247,4 +248,20 @@ impl Process {\n         self.status = Some(ExitStatus::new(status));\n         Ok(ExitStatus::new(status))\n     }\n+\n+    pub fn try_wait(&mut self) -> io::Result<ExitStatus> {\n+        if let Some(status) = self.status {\n+            return Ok(status)\n+        }\n+        let mut status = 0 as c_int;\n+        let pid = cvt(unsafe {\n+            libc::waitpid(self.pid, &mut status, libc::WNOHANG)\n+        })?;\n+        if pid == 0 {\n+            Err(io::Error::from_raw_os_error(libc::EWOULDBLOCK))\n+        } else {\n+            self.status = Some(ExitStatus::new(status));\n+            Ok(ExitStatus::new(status))\n+        }\n+    }\n }"}, {"sha": "4d05904933e322d86e99076deb38f4266c3741df", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/abb91890831d71f5cbe4346a9ab57d432372df65/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abb91890831d71f5cbe4346a9ab57d432372df65/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=abb91890831d71f5cbe4346a9ab57d432372df65", "patch": "@@ -265,6 +265,7 @@ pub const FILE_CURRENT: DWORD = 1;\n pub const FILE_END: DWORD = 2;\n \n pub const WAIT_OBJECT_0: DWORD = 0x00000000;\n+pub const WAIT_TIMEOUT: DWORD = 258;\n \n #[cfg(target_env = \"msvc\")]\n pub const MAX_SYM_NAME: usize = 2000;"}, {"sha": "6b70a2f4d8b2ec7addffbd659fa325efe01da853", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/abb91890831d71f5cbe4346a9ab57d432372df65/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abb91890831d71f5cbe4346a9ab57d432372df65/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=abb91890831d71f5cbe4346a9ab57d432372df65", "patch": "@@ -344,6 +344,21 @@ impl Process {\n         }\n     }\n \n+    pub fn try_wait(&mut self) -> io::Result<ExitStatus> {\n+        unsafe {\n+            match c::WaitForSingleObject(self.handle.raw(), 0) {\n+                c::WAIT_OBJECT_0 => {}\n+                c::WAIT_TIMEOUT => {\n+                    return Err(io::Error::from_raw_os_error(c::WSAEWOULDBLOCK))\n+                }\n+                _ => return Err(io::Error::last_os_error()),\n+            }\n+            let mut status = 0;\n+            cvt(c::GetExitCodeProcess(self.handle.raw(), &mut status))?;\n+            Ok(ExitStatus(status))\n+        }\n+    }\n+\n     pub fn handle(&self) -> &Handle { &self.handle }\n \n     pub fn into_handle(self) -> Handle { self.handle }"}, {"sha": "fdaf0cfd5b0c812a5835da4f803c3caef13b6428", "filename": "src/test/run-pass/try-wait.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/abb91890831d71f5cbe4346a9ab57d432372df65/src%2Ftest%2Frun-pass%2Ftry-wait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abb91890831d71f5cbe4346a9ab57d432372df65/src%2Ftest%2Frun-pass%2Ftry-wait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftry-wait.rs?ref=abb91890831d71f5cbe4346a9ab57d432372df65", "patch": "@@ -0,0 +1,65 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(process_try_wait)]\n+\n+use std::env;\n+use std::io;\n+use std::process::Command;\n+use std::thread;\n+use std::time::Duration;\n+\n+fn main() {\n+    let args = env::args().collect::<Vec<_>>();\n+    if args.len() != 1 {\n+        match &args[1][..] {\n+            \"sleep\" => thread::sleep(Duration::new(1_000, 0)),\n+            _ => {}\n+        }\n+        return\n+    }\n+\n+    let mut me = Command::new(env::current_exe().unwrap())\n+                         .arg(\"sleep\")\n+                         .spawn()\n+                         .unwrap();\n+    let err = me.try_wait().unwrap_err();\n+    assert_eq!(err.kind(), io::ErrorKind::WouldBlock);\n+    let err = me.try_wait().unwrap_err();\n+    assert_eq!(err.kind(), io::ErrorKind::WouldBlock);\n+\n+    me.kill().unwrap();\n+    me.wait().unwrap();\n+\n+    let status = me.try_wait().unwrap();\n+    assert!(!status.success());\n+    let status = me.try_wait().unwrap();\n+    assert!(!status.success());\n+\n+    let mut me = Command::new(env::current_exe().unwrap())\n+                         .arg(\"return-quickly\")\n+                         .spawn()\n+                         .unwrap();\n+    loop {\n+        match me.try_wait() {\n+            Ok(res) => {\n+                assert!(res.success());\n+                break\n+            }\n+            Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {\n+                thread::sleep(Duration::from_millis(1));\n+            }\n+            Err(e) => panic!(\"error in try_wait: {}\", e),\n+        }\n+    }\n+\n+    let status = me.try_wait().unwrap();\n+    assert!(status.success());\n+}"}]}