{"sha": "52e084b92afd95630900f2067cca679e75aab36a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyZTA4NGI5MmFmZDk1NjMwOTAwZjIwNjdjY2E2NzllNzVhYWIzNmE=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-04-05T14:38:25Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-06T22:35:50Z"}, "message": "ignore tcp server/client test on linux 32bit, pending #2064\n\nalso println->log(debug,) and assorted cleanup ahead of merge to master", "tree": {"sha": "5345993f3f670abc473d48926135a61cd33cea66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5345993f3f670abc473d48926135a61cd33cea66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52e084b92afd95630900f2067cca679e75aab36a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52e084b92afd95630900f2067cca679e75aab36a", "html_url": "https://github.com/rust-lang/rust/commit/52e084b92afd95630900f2067cca679e75aab36a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52e084b92afd95630900f2067cca679e75aab36a/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82f8d8cb2a139a303354358ea272948fd177dab3", "url": "https://api.github.com/repos/rust-lang/rust/commits/82f8d8cb2a139a303354358ea272948fd177dab3", "html_url": "https://github.com/rust-lang/rust/commit/82f8d8cb2a139a303354358ea272948fd177dab3"}], "stats": {"total": 182, "additions": 107, "deletions": 75}, "files": [{"sha": "d0e8c66d4b08e040d745672bc39460effa66abe0", "filename": "src/libstd/uv.rs", "status": "modified", "additions": 100, "deletions": 70, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/52e084b92afd95630900f2067cca679e75aab36a/src%2Flibstd%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52e084b92afd95630900f2067cca679e75aab36a/src%2Flibstd%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv.rs?ref=52e084b92afd95630900f2067cca679e75aab36a", "patch": "@@ -681,15 +681,17 @@ type request_wrapper = {\n };\n \n crust fn after_close_cb(handle: *libc::c_void) {\n-    io::println(\"after uv_close!\");\n+    log(debug, #fmt(\"after uv_close! handle ptr: %?\",\n+                    handle));\n }\n \n crust fn on_alloc_cb(handle: *libc::c_void,\n                      ++suggested_size: libc::size_t)\n     -> ll::uv_buf_t unsafe {\n-    io::println(\"on_alloc_cb!\");\n+    log(debug, \"on_alloc_cb!\");\n     let char_ptr = ll::malloc_buf_base_of(suggested_size);\n-    io::println(#fmt(\"on_alloc_cb char_ptr: %u sug. size: %u\",\n+    log(debug, #fmt(\"on_alloc_cb h: %? char_ptr: %u sugsize: %u\",\n+                     handle,\n                      char_ptr as uint,\n                      suggested_size as uint));\n     ret ll::buf_init(char_ptr, suggested_size);\n@@ -698,10 +700,10 @@ crust fn on_alloc_cb(handle: *libc::c_void,\n crust fn on_read_cb(stream: *ll::uv_stream_t,\n                     nread: libc::ssize_t,\n                     ++buf: ll::uv_buf_t) unsafe {\n-    io::println(#fmt(\"CLIENT entering on_read_cb nred: %d\", nread));\n+    log(debug, #fmt(\"CLIENT entering on_read_cb nred: %d\", nread));\n     if (nread > 0) {\n         // we have data\n-        io::println(#fmt(\"CLIENT read: data! nread: %d\", nread));\n+        log(debug, #fmt(\"CLIENT read: data! nread: %d\", nread));\n         ll::read_stop(stream);\n         let client_data = ll::\n             get_data_for_uv_handle(stream as *libc::c_void)\n@@ -716,58 +718,58 @@ crust fn on_read_cb(stream: *ll::uv_stream_t,\n     }\n     else if (nread == -1) {\n         // err .. possibly EOF\n-        io::println(\"read: eof!\");\n+        log(debug, \"read: eof!\");\n     }\n     else {\n         // nread == 0 .. do nothing, just free buf as below\n-        io::println(\"read: do nothing!\");\n+        log(debug, \"read: do nothing!\");\n     }\n     // when we're done\n     ll::free_base_of_buf(buf);\n-    io::println(\"CLIENT exiting on_read_cb\");\n+    log(debug, \"CLIENT exiting on_read_cb\");\n }\n \n crust fn on_write_complete_cb(write_req: *ll::uv_write_t,\n                               status: libc::c_int) unsafe {\n-    io::println(#fmt(\"CLIENT beginning on_write_complete_cb status: %d\",\n+    log(debug, #fmt(\"CLIENT beginning on_write_complete_cb status: %d\",\n                      status as int));\n     let stream = ll::get_stream_handle_from_write_req(write_req);\n-    io::println(#fmt(\"CLIENT on_write_complete_cb: tcp:%d write_handle:%d\",\n+    log(debug, #fmt(\"CLIENT on_write_complete_cb: tcp:%d write_handle:%d\",\n         stream as int, write_req as int));\n     let result = ll::read_start(stream, on_alloc_cb, on_read_cb);\n-    io::println(#fmt(\"CLIENT ending on_write_complete_cb .. status: %d\",\n+    log(debug, #fmt(\"CLIENT ending on_write_complete_cb .. status: %d\",\n                      result as int));\n }\n \n crust fn on_connect_cb(connect_req_ptr: *ll::uv_connect_t,\n                              status: libc::c_int) unsafe {\n-    io::println(#fmt(\"beginning on_connect_cb .. status: %d\",\n+    log(debug, #fmt(\"beginning on_connect_cb .. status: %d\",\n                      status as int));\n     let stream =\n         ll::get_stream_handle_from_connect_req(connect_req_ptr);\n     if (status == 0i32) {\n-        io::println(\"on_connect_cb: in status=0 if..\");\n+        log(debug, \"on_connect_cb: in status=0 if..\");\n         let client_data = ll::get_data_for_req(\n             connect_req_ptr as *libc::c_void)\n             as *request_wrapper;\n         let write_handle = (*client_data).write_req as *libc::c_void;\n-        io::println(#fmt(\"on_connect_cb: tcp stream: %d write_handle addr %d\",\n+        log(debug, #fmt(\"on_connect_cb: tcp stream: %d write_handle addr %d\",\n                         stream as int, write_handle as int));\n         let write_result = ll::write(write_handle,\n                           stream as *libc::c_void,\n                           (*client_data).req_buf,\n                           on_write_complete_cb);\n-        io::println(#fmt(\"on_connect_cb: ll::write() status: %d\",\n+        log(debug, #fmt(\"on_connect_cb: ll::write() status: %d\",\n                          write_result as int));\n     }\n     else {\n         let test_loop = ll::get_loop_for_uv_handle(\n             stream as *libc::c_void);\n         let err_msg = ll::get_last_err_info(test_loop);\n-        io::println(err_msg);\n+        log(debug, err_msg);\n         assert false;\n     }\n-    io::println(\"finishing on_connect_cb\");\n+    log(debug, \"finishing on_connect_cb\");\n }\n \n fn impl_uv_tcp_request(ip: str, port: int, req_str: str,\n@@ -785,15 +787,15 @@ fn impl_uv_tcp_request(ip: str, port: int, req_str: str,\n     // data field in our uv_connect_t struct\n     let req_str_bytes = str::bytes(req_str);\n     let req_msg_ptr: *u8 = vec::unsafe::to_ptr(req_str_bytes);\n-    io::println(#fmt(\"req_msg ptr: %u\", req_msg_ptr as uint));\n+    log(debug, #fmt(\"req_msg ptr: %u\", req_msg_ptr as uint));\n     let req_msg = [\n         ll::buf_init(req_msg_ptr, vec::len(req_str_bytes))\n     ];\n     // this is the enclosing record, we'll pass a ptr to\n     // this to C..\n     let write_handle = ll::write_t();\n     let write_handle_ptr = ptr::addr_of(write_handle);\n-    io::println(#fmt(\"tcp req: tcp stream: %d write_handle: %d\",\n+    log(debug, #fmt(\"tcp req: tcp stream: %d write_handle: %d\",\n                      tcp_handle_ptr as int,\n                      write_handle_ptr as int));\n     let client_data = { writer_handle: write_handle_ptr,\n@@ -803,17 +805,17 @@ fn impl_uv_tcp_request(ip: str, port: int, req_str: str,\n     let tcp_init_result = ll::tcp_init(\n         test_loop as *libc::c_void, tcp_handle_ptr);\n     if (tcp_init_result == 0i32) {\n-        io::println(\"sucessful tcp_init_result\");\n+        log(debug, \"sucessful tcp_init_result\");\n \n-        io::println(\"building addr...\");\n+        log(debug, \"building addr...\");\n         let addr = ll::ip4_addr(ip, port);\n         // FIXME ref #2064\n         let addr_ptr = ptr::addr_of(addr);\n-        io::println(#fmt(\"after build addr in rust. port: %u\",\n+        log(debug, #fmt(\"after build addr in rust. port: %u\",\n                          addr.sin_port as uint));\n \n         // this should set up the connection request..\n-        io::println(#fmt(\"before calling tcp_connect .. connect cb ptr: %u \",\n+        log(debug, #fmt(\"before calling tcp_connect .. connect cb ptr: %u \",\n                         on_connect_cb as uint));\n         let tcp_connect_result = ll::tcp_connect(\n             connect_req_ptr, tcp_handle_ptr,\n@@ -827,30 +829,31 @@ fn impl_uv_tcp_request(ip: str, port: int, req_str: str,\n             ll::set_data_for_uv_handle(\n                 tcp_handle_ptr as *libc::c_void,\n                 ptr::addr_of(client_data) as *libc::c_void);\n-            io::println(\"before run tcp req loop\");\n+            log(debug, \"before run tcp req loop\");\n             ll::run(test_loop);\n-            io::println(\"after run tcp req loop\");\n+            log(debug, \"after run tcp req loop\");\n         }\n         else {\n-           io::println(\"ll::tcp_connect() failure\");\n+           log(debug, \"ll::tcp_connect() failure\");\n            assert false;\n         }\n     }\n     else {\n-        io::println(\"ll::tcp_init() failure\");\n+        log(debug, \"ll::tcp_init() failure\");\n         assert false;\n     }\n     ll::loop_delete(test_loop);\n \n }\n \n crust fn server_after_close_cb(handle: *libc::c_void) unsafe {\n-    io::println(\"SERVER server stream closed, should exit loop...\");\n+    log(debug, #fmt(\"SERVER server stream closed, should exit.. h: %?\",\n+               handle));\n }\n \n crust fn client_stream_after_close_cb(handle: *libc::c_void)\n     unsafe {\n-    io::println(\"SERVER: closed client stream, now closing server stream\");\n+    log(debug, \"SERVER: closed client stream, now closing server stream\");\n     let client_data = ll::get_data_for_uv_handle(\n         handle) as\n         *tcp_server_data;\n@@ -861,10 +864,7 @@ crust fn client_stream_after_close_cb(handle: *libc::c_void)\n crust fn after_server_resp_write(req: *ll::uv_write_t) unsafe {\n     let client_stream_ptr =\n         ll::get_stream_handle_from_write_req(req);\n-    let client_data = ll::get_data_for_uv_handle(\n-        client_stream_ptr as *libc::c_void) as\n-        *tcp_server_data;\n-    io::println(\"SERVER: resp sent... closing client stream\");\n+    log(debug, \"SERVER: resp sent... closing client stream\");\n     ll::close(client_stream_ptr as *libc::c_void,\n                   client_stream_after_close_cb)\n }\n@@ -874,12 +874,12 @@ crust fn on_server_read_cb(client_stream_ptr: *ll::uv_stream_t,\n                            ++buf: ll::uv_buf_t) unsafe {\n     if (nread > 0) {\n         // we have data\n-        io::println(#fmt(\"SERVER read: data! nread: %d\", nread));\n+        log(debug, #fmt(\"SERVER read: data! nread: %d\", nread));\n \n         // pull out the contents of the write from the client\n         let buf_base = ll::get_base_from_buf(buf);\n         let buf_len = ll::get_len_from_buf(buf);\n-        io::println(#fmt(\"SERVER buf base: %u, len: %u, nread: %d\",\n+        log(debug, #fmt(\"SERVER buf base: %u, len: %u, nread: %d\",\n                          buf_base as uint,\n                          buf_len as uint,\n                          nread));\n@@ -892,8 +892,8 @@ crust fn on_server_read_cb(client_stream_ptr: *ll::uv_stream_t,\n         let server_kill_msg = (*client_data).server_kill_msg;\n         let write_req = (*client_data).server_write_req;\n         if (str::contains(request_str, server_kill_msg)) {\n-            io::println(\"SERVER: client request contains server_kill_msg!\");\n-            io::println(\"SERVER: sending response to client\");\n+            log(debug, \"SERVER: client request contains server_kill_msg!\");\n+            log(debug, \"SERVER: sending response to client\");\n             ll::read_stop(client_stream_ptr);\n             let server_chan = *((*client_data).server_chan);\n             comm::send(server_chan, request_str);\n@@ -902,39 +902,45 @@ crust fn on_server_read_cb(client_stream_ptr: *ll::uv_stream_t,\n                 client_stream_ptr as *libc::c_void,\n                 (*client_data).server_resp_buf,\n                 after_server_resp_write);\n-            io::println(#fmt(\"SERVER: resp write result: %d\",\n+            log(debug, #fmt(\"SERVER: resp write result: %d\",\n                         write_result as int));\n             if (write_result != 0i32) {\n-                io::println(\"bad result for server resp ll::write()\");\n-                io::println(ll::get_last_err_info(\n+                log(debug, \"bad result for server resp ll::write()\");\n+                log(debug, ll::get_last_err_info(\n                     ll::get_loop_for_uv_handle(client_stream_ptr\n                         as *libc::c_void)));\n                 assert false;\n             }\n         }\n         else {\n-            io::println(\"SERVER: client req DOESNT contain server_kill_msg!\");\n+            log(debug, \"SERVER: client req DOESNT contain server_kill_msg!\");\n         }\n     }\n     else if (nread == -1) {\n         // err .. possibly EOF\n-        io::println(\"read: eof!\");\n+        log(debug, \"read: eof!\");\n     }\n     else {\n         // nread == 0 .. do nothing, just free buf as below\n-        io::println(\"read: do nothing!\");\n+        log(debug, \"read: do nothing!\");\n     }\n     // when we're done\n     ll::free_base_of_buf(buf);\n-    io::println(\"SERVER exiting on_read_cb\");\n+    log(debug, \"SERVER exiting on_read_cb\");\n }\n \n crust fn server_connection_cb(server_stream_ptr:\n                                 *ll::uv_stream_t,\n                               status: libc::c_int) unsafe {\n-    io::println(\"client connecting!\");\n+    log(debug, \"client connecting!\");\n     let test_loop = ll::get_loop_for_uv_handle(\n                            server_stream_ptr as *libc::c_void);\n+    if status != 0i32 {\n+        let err_msg = ll::get_last_err_info(test_loop);\n+        log(debug, #fmt(\"server_connect_cb: non-zero status: %?\",\n+                     err_msg));\n+        ret;\n+    }\n     let server_data = ll::get_data_for_uv_handle(\n         server_stream_ptr as *libc::c_void) as *tcp_server_data;\n     let client_stream_ptr = (*server_data).client;\n@@ -944,7 +950,7 @@ crust fn server_connection_cb(server_stream_ptr:\n         client_stream_ptr as *libc::c_void,\n         server_data as *libc::c_void);\n     if (client_init_result == 0i32) {\n-        io::println(\"successfully initialized client stream\");\n+        log(debug, \"successfully initialized client stream\");\n         let accept_result = ll::accept(server_stream_ptr as\n                                              *libc::c_void,\n                                            client_stream_ptr as\n@@ -956,22 +962,22 @@ crust fn server_connection_cb(server_stream_ptr:\n                                                  on_alloc_cb,\n                                                  on_server_read_cb);\n             if (read_result == 0i32) {\n-                io::println(\"successful server read start\");\n+                log(debug, \"successful server read start\");\n             }\n             else {\n-                io::println(#fmt(\"server_connection_cb: bad read:%d\",\n+                log(debug, #fmt(\"server_connection_cb: bad read:%d\",\n                                 read_result as int));\n                 assert false;\n             }\n         }\n         else {\n-            io::println(#fmt(\"server_connection_cb: bad accept: %d\",\n+            log(debug, #fmt(\"server_connection_cb: bad accept: %d\",\n                         accept_result as int));\n             assert false;\n         }\n     }\n     else {\n-        io::println(#fmt(\"server_connection_cb: bad client init: %d\",\n+        log(debug, #fmt(\"server_connection_cb: bad client init: %d\",\n                     client_init_result as int));\n         assert false;\n     }\n@@ -991,7 +997,8 @@ type async_handle_data = {\n };\n \n crust fn async_close_cb(handle: *libc::c_void) {\n-    io::println(\"SERVER: closing async cb...\");\n+    log(debug, #fmt(\"SERVER: closing async cb... h: %?\",\n+               handle));\n }\n \n crust fn continue_async_cb(async_handle: *ll::uv_async_t,\n@@ -1003,7 +1010,8 @@ crust fn continue_async_cb(async_handle: *ll::uv_async_t,\n     let data = ll::get_data_for_uv_handle(\n         async_handle as *libc::c_void) as *async_handle_data;\n     let continue_chan = *((*data).continue_chan);\n-    comm::send(continue_chan, true);\n+    let should_continue = status == 0i32;\n+    comm::send(continue_chan, should_continue);\n     ll::close(async_handle as *libc::c_void, async_close_cb);\n }\n \n@@ -1025,7 +1033,7 @@ fn impl_uv_tcp_server(server_ip: str,\n \n     let resp_str_bytes = str::bytes(server_resp_msg);\n     let resp_msg_ptr: *u8 = vec::unsafe::to_ptr(resp_str_bytes);\n-    io::println(#fmt(\"resp_msg ptr: %u\", resp_msg_ptr as uint));\n+    log(debug, #fmt(\"resp_msg ptr: %u\", resp_msg_ptr as uint));\n     let resp_msg = [\n         ll::buf_init(resp_msg_ptr, vec::len(resp_str_bytes))\n     ];\n@@ -1061,7 +1069,7 @@ fn impl_uv_tcp_server(server_ip: str,\n         let bind_result = ll::tcp_bind(tcp_server_ptr,\n                                            server_addr_ptr);\n         if (bind_result == 0i32) {\n-            io::println(\"successful uv_tcp_bind, listening\");\n+            log(debug, \"successful uv_tcp_bind, listening\");\n \n             // uv_listen()\n             let listen_result = ll::listen(tcp_server_ptr as\n@@ -1081,37 +1089,37 @@ fn impl_uv_tcp_server(server_ip: str,\n                     ll::async_send(continue_async_handle_ptr);\n                     // uv_run()\n                     ll::run(test_loop);\n-                    io::println(\"server uv::run() has returned\");\n+                    log(debug, \"server uv::run() has returned\");\n                 }\n                 else {\n-                    io::println(#fmt(\"uv_async_init failure: %d\",\n+                    log(debug, #fmt(\"uv_async_init failure: %d\",\n                             async_result as int));\n                     assert false;\n                 }\n             }\n             else {\n-                io::println(#fmt(\"non-zero result on uv_listen: %d\",\n+                log(debug, #fmt(\"non-zero result on uv_listen: %d\",\n                             listen_result as int));\n                 assert false;\n             }\n         }\n         else {\n-            io::println(#fmt(\"non-zero result on uv_tcp_bind: %d\",\n+            log(debug, #fmt(\"non-zero result on uv_tcp_bind: %d\",\n                         bind_result as int));\n             assert false;\n         }\n     }\n     else {\n-        io::println(#fmt(\"non-zero result on uv_tcp_init: %d\",\n+        log(debug, #fmt(\"non-zero result on uv_tcp_init: %d\",\n                     tcp_init_result as int));\n         assert false;\n     }\n     ll::loop_delete(test_loop);\n }\n \n-#[test]\n-#[ignore(cfg(target_os = \"freebsd\"))]\n-fn test_uv_tcp_server_and_request() unsafe {\n+// this is the impl for a test that is (maybe) ran on a\n+// per-platform/arch basis below\n+fn impl_uv_tcp_server_and_request() unsafe {\n     let bind_ip = \"0.0.0.0\";\n     let request_ip = \"127.0.0.1\";\n     let port = 8888;\n@@ -1135,9 +1143,9 @@ fn test_uv_tcp_server_and_request() unsafe {\n     };\n \n     // block until the server up is.. possibly a race?\n-    io::println(\"before receiving on server continue_port\");\n+    log(debug, \"before receiving on server continue_port\");\n     comm::recv(continue_port);\n-    io::println(\"received on continue port, set up tcp client\");\n+    log(debug, \"received on continue port, set up tcp client\");\n \n     task::spawn_sched(task::manual_threads(1u)) {||\n         impl_uv_tcp_request(request_ip, port,\n@@ -1152,6 +1160,28 @@ fn test_uv_tcp_server_and_request() unsafe {\n     assert str::contains(msg_from_server, server_resp_msg);\n }\n \n+// don't run this test on fbsd or 32bit linux\n+#[cfg(target_os=\"win32\")]\n+#[cfg(target_os=\"darwin\")]\n+#[cfg(target_os=\"linux\")]\n+mod tcp_and_server_client_test {\n+    #[cfg(target_arch=\"x86_64\")]\n+    mod impl64 {\n+        #[test]\n+        fn test_uv_tcp_server_and_request() unsafe {\n+            impl_uv_tcp_server_and_request();\n+        }\n+    }\n+    #[cfg(target_arch=\"x86\")]\n+    mod impl32 {\n+        #[test]\n+        #[ignore(cfg(target_os = \"linux\"))]\n+        fn test_uv_tcp_server_and_request() unsafe {\n+            impl_uv_tcp_server_and_request();\n+        }\n+    }\n+}\n+\n // struct size tests\n #[test]\n #[ignore(cfg(target_os = \"freebsd\"))]\n@@ -1160,7 +1190,7 @@ fn test_uv_struct_size_uv_tcp_t() {\n     let rust_handle_size = sys::size_of::<ll::uv_tcp_t>();\n     let output = #fmt(\"uv_tcp_t -- native: %u rust: %u\",\n                       native_handle_size as uint, rust_handle_size);\n-    io::println(output);\n+    log(debug, output);\n     assert native_handle_size as uint == rust_handle_size;\n }\n #[test]\n@@ -1171,7 +1201,7 @@ fn test_uv_struct_size_uv_connect_t() {\n     let rust_handle_size = sys::size_of::<ll::uv_connect_t>();\n     let output = #fmt(\"uv_connect_t -- native: %u rust: %u\",\n                       native_handle_size as uint, rust_handle_size);\n-    io::println(output);\n+    log(debug, output);\n     assert native_handle_size as uint == rust_handle_size;\n }\n #[test]\n@@ -1182,7 +1212,7 @@ fn test_uv_struct_size_uv_buf_t() {\n     let rust_handle_size = sys::size_of::<ll::uv_buf_t>();\n     let output = #fmt(\"uv_buf_t -- native: %u rust: %u\",\n                       native_handle_size as uint, rust_handle_size);\n-    io::println(output);\n+    log(debug, output);\n     assert native_handle_size as uint == rust_handle_size;\n }\n #[test]\n@@ -1193,7 +1223,7 @@ fn test_uv_struct_size_uv_write_t() {\n     let rust_handle_size = sys::size_of::<ll::uv_write_t>();\n     let output = #fmt(\"uv_write_t -- native: %u rust: %u\",\n                       native_handle_size as uint, rust_handle_size);\n-    io::println(output);\n+    log(debug, output);\n     assert native_handle_size as uint == rust_handle_size;\n }\n \n@@ -1205,7 +1235,7 @@ fn test_uv_struct_size_sockaddr_in() {\n     let rust_handle_size = sys::size_of::<ll::sockaddr_in>();\n     let output = #fmt(\"sockaddr_in -- native: %u rust: %u\",\n                       native_handle_size as uint, rust_handle_size);\n-    io::println(output);\n+    log(debug, output);\n     assert native_handle_size as uint == rust_handle_size;\n }\n \n@@ -1217,7 +1247,7 @@ fn test_uv_struct_size_uv_async_t() {\n     let rust_handle_size = sys::size_of::<ll::uv_async_t>();\n     let output = #fmt(\"uv_async_t -- native: %u rust: %u\",\n                       native_handle_size as uint, rust_handle_size);\n-    io::println(output);\n+    log(debug, output);\n     assert native_handle_size as uint == rust_handle_size;\n }\n "}, {"sha": "c716f7a306af47bd683bc206320fe0cdb82ea370", "filename": "src/libstd/uv_hl.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52e084b92afd95630900f2067cca679e75aab36a/src%2Flibstd%2Fuv_hl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52e084b92afd95630900f2067cca679e75aab36a/src%2Flibstd%2Fuv_hl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_hl.rs?ref=52e084b92afd95630900f2067cca679e75aab36a", "patch": "@@ -98,4 +98,6 @@ unsafe fn prepare_loop(loop_ptr: *libc::c_void)\n // we'll drain the port of pending callbacks, processing each\n crust fn interact_poke(async_handle: *libc::c_void) {\n     // nothing here, yet.\n+    log(debug, #fmt(\"interact_poke crust.. handle: %?\",\n+                     async_handle));\n }\n\\ No newline at end of file"}, {"sha": "85da16823c0eff40810d4b25917d3619da76a794", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/52e084b92afd95630900f2067cca679e75aab36a/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52e084b92afd95630900f2067cca679e75aab36a/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=52e084b92afd95630900f2067cca679e75aab36a", "patch": "@@ -517,7 +517,7 @@ unsafe fn tcp_connect(connect_ptr: *uv_connect_t,\n                       ++after_connect_cb: *u8)\n -> libc::c_int {\n     let address = *addr_ptr;\n-    io::println(#fmt(\"b4 native tcp_connect--addr port: %u cb: %u\",\n+    log(debug, #fmt(\"b4 native tcp_connect--addr port: %u cb: %u\",\n                      address.sin_port as uint, after_connect_cb as uint));\n     ret rustrt::rust_uv_tcp_connect(connect_ptr, tcp_handle_ptr,\n                                 after_connect_cb, addr_ptr);\n@@ -630,18 +630,18 @@ unsafe fn get_len_from_buf(buf: uv_buf_t) -> libc::size_t {\n unsafe fn buf_init(++input: *u8, len: uint) -> uv_buf_t {\n     let out_buf = { base: ptr::null(), len: 0 as libc::size_t };\n     let out_buf_ptr = ptr::addr_of(out_buf);\n-    io::println(#fmt(\"ll::buf_init - input %u len %u out_buf: %u\",\n+    log(debug, #fmt(\"ll::buf_init - input %u len %u out_buf: %u\",\n                      input as uint,\n                      len as uint,\n                      out_buf_ptr as uint));\n     // yuck :/\n     rustrt::rust_uv_buf_init(out_buf_ptr, input, len);\n     //let result = rustrt::rust_uv_buf_init_2(input, len);\n-    io::println(\"after rust_uv_buf_init\");\n+    log(debug, \"after rust_uv_buf_init\");\n     let res_base = get_base_from_buf(out_buf);\n     let res_len = get_len_from_buf(out_buf);\n     //let res_base = get_base_from_buf(result);\n-    io::println(#fmt(\"ll::buf_init - result %u len %u\",\n+    log(debug, #fmt(\"ll::buf_init - result %u len %u\",\n                      res_base as uint,\n                      res_len as uint));\n     ret out_buf;\n@@ -653,7 +653,7 @@ unsafe fn ip4_addr(ip: str, port: int)\n     addr_vec += [0u8]; // add null terminator\n     let addr_vec_ptr = vec::unsafe::to_ptr(addr_vec);\n     let ip_back = str::from_bytes(addr_vec);\n-    io::println(#fmt(\"vec val: '%s' length: %u\",\n+    log(debug, #fmt(\"vec val: '%s' length: %u\",\n                      ip_back, vec::len(addr_vec)));\n     ret rustrt::rust_uv_ip4_addr(addr_vec_ptr,\n                                  port as libc::c_int);"}]}