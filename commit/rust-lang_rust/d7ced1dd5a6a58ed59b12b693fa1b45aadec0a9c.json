{"sha": "d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3Y2VkMWRkNWE2YTU4ZWQ1OWIxMmI2OTNmYTFiNDVhYWRlYzBhOWM=", "commit": {"author": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2019-02-24T08:33:17Z"}, "committer": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2019-02-24T16:09:37Z"}, "message": "hir: remove NodeId from Expr", "tree": {"sha": "013131c53da5d21330c8ca86bbd99df288855a01", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/013131c53da5d21330c8ca86bbd99df288855a01"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "html_url": "https://github.com/rust-lang/rust/commit/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/comments", "author": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "021a140dcdbbae9050818b3f28402385efab3adc", "url": "https://api.github.com/repos/rust-lang/rust/commits/021a140dcdbbae9050818b3f28402385efab3adc", "html_url": "https://github.com/rust-lang/rust/commit/021a140dcdbbae9050818b3f28402385efab3adc"}], "stats": {"total": 612, "additions": 307, "deletions": 305}, "files": [{"sha": "30a0477467d8016ff94d58cebc0a5174a2175239", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -398,7 +398,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             args: I) -> CFGIndex {\n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);\n         let ret = self.straightline(call_expr, func_or_rcvr_exit, args);\n-        let m = self.tcx.hir().get_module_parent(call_expr.id);\n+        let m = self.tcx.hir().get_module_parent_by_hir_id(call_expr.hir_id);\n         if self.tcx.is_ty_uninhabited_from(m, self.tables.expr_ty(call_expr)) {\n             self.add_unreachable_node()\n         } else {"}, {"sha": "0211dd7287563d911148e0b2283f788d1fd53d11", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -963,7 +963,6 @@ impl<'a> LoweringContext<'a> {\n         let closure_hir_id = self.lower_node_id(closure_node_id).hir_id;\n         let decl = self.lower_fn_decl(&decl, None, /* impl trait allowed */ false, None);\n         let generator = hir::Expr {\n-            id: closure_node_id,\n             hir_id: closure_hir_id,\n             node: hir::ExprKind::Closure(capture_clause, decl, body_id, span,\n                 Some(hir::GeneratorMovability::Static)),\n@@ -3932,10 +3931,9 @@ impl<'a> LoweringContext<'a> {\n                     let mut block = this.lower_block(body, true).into_inner();\n                     let tail = block.expr.take().map_or_else(\n                         || {\n-                            let LoweredNodeId { node_id, hir_id } = this.next_id();\n+                            let LoweredNodeId { node_id: _, hir_id } = this.next_id();\n                             let span = this.sess.source_map().end_point(unstable_span);\n                             hir::Expr {\n-                                id: node_id,\n                                 span,\n                                 node: hir::ExprKind::Tup(hir_vec![]),\n                                 attrs: ThinVec::new(),\n@@ -4120,10 +4118,9 @@ impl<'a> LoweringContext<'a> {\n                 let struct_path = self.std_path(e.span, &struct_path, None, is_unit);\n                 let struct_path = hir::QPath::Resolved(None, P(struct_path));\n \n-                let LoweredNodeId { node_id, hir_id } = self.lower_node_id(e.id);\n+                let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(e.id);\n \n                 return hir::Expr {\n-                    id: node_id,\n                     hir_id,\n                     node: if is_unit {\n                         hir::ExprKind::Path(struct_path)\n@@ -4473,9 +4470,8 @@ impl<'a> LoweringContext<'a> {\n                     self.lower_label(opt_label),\n                     hir::LoopSource::ForLoop,\n                 );\n-                let LoweredNodeId { node_id, hir_id } = self.lower_node_id(e.id);\n+                let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(e.id);\n                 let loop_expr = P(hir::Expr {\n-                    id: node_id,\n                     hir_id,\n                     node: loop_expr,\n                     span: e.span,\n@@ -4620,10 +4616,9 @@ impl<'a> LoweringContext<'a> {\n             ExprKind::Mac(_) => panic!(\"Shouldn't exist here\"),\n         };\n \n-        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(e.id);\n+        let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(e.id);\n \n         hir::Expr {\n-            id: node_id,\n             hir_id,\n             node: kind,\n             span: e.span,\n@@ -4895,9 +4890,8 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn expr(&mut self, span: Span, node: hir::ExprKind, attrs: ThinVec<Attribute>) -> hir::Expr {\n-        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+        let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n         hir::Expr {\n-            id: node_id,\n             hir_id,\n             node,\n             span,"}, {"sha": "1114ef52bbc0c8aba1e10c5a599809fde89ed8d9", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -75,10 +75,10 @@ pub enum Code<'a> {\n }\n \n impl<'a> Code<'a> {\n-    pub fn id(&self) -> NodeId {\n+    pub fn id(&self) -> ast::HirId {\n         match *self {\n             Code::FnLike(node) => node.id(),\n-            Code::Expr(block) => block.id,\n+            Code::Expr(block) => block.hir_id,\n         }\n     }\n \n@@ -104,7 +104,7 @@ struct ItemFnParts<'a> {\n     vis:      &'a ast::Visibility,\n     generics: &'a ast::Generics,\n     body:     ast::BodyId,\n-    id:       NodeId,\n+    id:       ast::HirId,\n     span:     Span,\n     attrs:    &'a [Attribute],\n }\n@@ -114,13 +114,13 @@ struct ItemFnParts<'a> {\n struct ClosureParts<'a> {\n     decl: &'a FnDecl,\n     body: ast::BodyId,\n-    id: NodeId,\n+    id: ast::HirId,\n     span: Span,\n     attrs: &'a [Attribute],\n }\n \n impl<'a> ClosureParts<'a> {\n-    fn new(d: &'a FnDecl, b: ast::BodyId, id: NodeId, s: Span, attrs: &'a [Attribute]) -> Self {\n+    fn new(d: &'a FnDecl, b: ast::BodyId, id: ast::HirId, s: Span, attrs: &'a [Attribute]) -> Self {\n         ClosureParts {\n             decl: d,\n             body: b,\n@@ -168,7 +168,7 @@ impl<'a> FnLikeNode<'a> {\n                     |c: ClosureParts<'_>| c.span)\n     }\n \n-    pub fn id(self) -> NodeId {\n+    pub fn id(self) -> ast::HirId {\n         self.handle(|i: ItemFnParts<'_>| i.id,\n                     |id, _, _: &'a ast::MethodSig, _, _, _, _| id,\n                     |c: ClosureParts<'_>| c.id)\n@@ -213,7 +213,7 @@ impl<'a> FnLikeNode<'a> {\n \n     fn handle<A, I, M, C>(self, item_fn: I, method: M, closure: C) -> A where\n         I: FnOnce(ItemFnParts<'a>) -> A,\n-        M: FnOnce(NodeId,\n+        M: FnOnce(ast::HirId,\n                   Ident,\n                   &'a ast::MethodSig,\n                   Option<&'a ast::Visibility>,\n@@ -227,7 +227,7 @@ impl<'a> FnLikeNode<'a> {\n             map::Node::Item(i) => match i.node {\n                 ast::ItemKind::Fn(ref decl, header, ref generics, block) =>\n                     item_fn(ItemFnParts {\n-                        id: i.id,\n+                        id: i.hir_id,\n                         ident: i.ident,\n                         decl: &decl,\n                         body: block,\n@@ -241,21 +241,21 @@ impl<'a> FnLikeNode<'a> {\n             },\n             map::Node::TraitItem(ti) => match ti.node {\n                 ast::TraitItemKind::Method(ref sig, ast::TraitMethod::Provided(body)) => {\n-                    method(ti.id, ti.ident, sig, None, body, ti.span, &ti.attrs)\n+                    method(ti.hir_id, ti.ident, sig, None, body, ti.span, &ti.attrs)\n                 }\n                 _ => bug!(\"trait method FnLikeNode that is not fn-like\"),\n             },\n             map::Node::ImplItem(ii) => {\n                 match ii.node {\n                     ast::ImplItemKind::Method(ref sig, body) => {\n-                        method(ii.id, ii.ident, sig, Some(&ii.vis), body, ii.span, &ii.attrs)\n+                        method(ii.hir_id, ii.ident, sig, Some(&ii.vis), body, ii.span, &ii.attrs)\n                     }\n                     _ => bug!(\"impl method FnLikeNode that is not fn-like\")\n                 }\n             },\n             map::Node::Expr(e) => match e.node {\n                 ast::ExprKind::Closure(_, ref decl, block, _fn_decl_span, _gen) =>\n-                    closure(ClosureParts::new(&decl, block, e.id, e.span, &e.attrs)),\n+                    closure(ClosureParts::new(&decl, block, e.hir_id, e.span, &e.attrs)),\n                 _ => bug!(\"expr FnLikeNode that is not fn-like\"),\n             },\n             _ => bug!(\"other FnLikeNode that is not fn-like\"),"}, {"sha": "41e48e46ea5b6116d76cc4f62d397099e6cb6663", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -799,7 +799,7 @@ impl<'hir> Map<'hir> {\n     ///     false\n     /// }\n     /// ```\n-    pub fn get_return_block(&self, id: NodeId) -> Option<NodeId> {\n+    pub fn get_return_block(&self, id: HirId) -> Option<HirId> {\n         let match_fn = |node: &Node<'_>| {\n             match *node {\n                 Node::Item(_) |\n@@ -822,7 +822,10 @@ impl<'hir> Map<'hir> {\n             }\n         };\n \n-        self.walk_parent_nodes(id, match_fn, match_non_returning_block).ok()\n+        let node_id = self.hir_to_node_id(id);\n+        self.walk_parent_nodes(node_id, match_fn, match_non_returning_block)\n+            .ok()\n+            .map(|return_node_id| self.node_to_hir_id(return_node_id))\n     }\n \n     /// Retrieves the `NodeId` for `id`'s parent item, or `id` itself if no"}, {"sha": "497825e203e231e8633f44b9d04e2ed922d4ca6d", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -1333,7 +1333,6 @@ pub struct AnonConst {\n /// An expression\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Expr {\n-    pub id: NodeId,\n     pub span: Span,\n     pub node: ExprKind,\n     pub attrs: ThinVec<Attribute>,\n@@ -1436,7 +1435,7 @@ impl Expr {\n \n impl fmt::Debug for Expr {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"expr({}: {})\", self.id,\n+        write!(f, \"expr({}: {})\", self.hir_id,\n                print::to_string(print::NO_ANN, |s| s.print_expr(self)))\n     }\n }"}, {"sha": "d1161dda1e2ff592c04f5a7469634e0cc38620a0", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -559,7 +559,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Expr {\n                                           hasher: &mut StableHasher<W>) {\n         hcx.while_hashing_hir_bodies(true, |hcx| {\n             let hir::Expr {\n-                id: _,\n                 hir_id: _,\n                 ref span,\n                 ref node,"}, {"sha": "dd003e44bea09d8bba7acb41ca40af89e46ac595", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -723,7 +723,7 @@ fn lint_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, cnum: CrateNum)\n     };\n     let krate = tcx.hir().krate();\n \n-    builder.with_lint_attrs(ast::CRATE_NODE_ID, &krate.attrs, |builder| {\n+    builder.with_lint_attrs(hir::CRATE_HIR_ID, &krate.attrs, |builder| {\n         intravisit::walk_crate(builder, krate);\n     });\n \n@@ -737,13 +737,13 @@ struct LintLevelMapBuilder<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> LintLevelMapBuilder<'a, 'tcx> {\n     fn with_lint_attrs<F>(&mut self,\n-                          id: ast::NodeId,\n+                          id: hir::HirId,\n                           attrs: &[ast::Attribute],\n                           f: F)\n         where F: FnOnce(&mut Self)\n     {\n         let push = self.levels.push(attrs);\n-        self.levels.register_id(self.tcx.hir().definitions().node_to_hir_id(id));\n+        self.levels.register_id(id);\n         f(self);\n         self.levels.pop(push);\n     }\n@@ -755,25 +755,25 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for LintLevelMapBuilder<'a, 'tcx> {\n     }\n \n     fn visit_item(&mut self, it: &'tcx hir::Item) {\n-        self.with_lint_attrs(it.id, &it.attrs, |builder| {\n+        self.with_lint_attrs(it.hir_id, &it.attrs, |builder| {\n             intravisit::walk_item(builder, it);\n         });\n     }\n \n     fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem) {\n-        self.with_lint_attrs(it.id, &it.attrs, |builder| {\n+        self.with_lint_attrs(it.hir_id, &it.attrs, |builder| {\n             intravisit::walk_foreign_item(builder, it);\n         })\n     }\n \n     fn visit_expr(&mut self, e: &'tcx hir::Expr) {\n-        self.with_lint_attrs(e.id, &e.attrs, |builder| {\n+        self.with_lint_attrs(e.hir_id, &e.attrs, |builder| {\n             intravisit::walk_expr(builder, e);\n         })\n     }\n \n     fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n-        self.with_lint_attrs(s.id, &s.attrs, |builder| {\n+        self.with_lint_attrs(s.hir_id, &s.attrs, |builder| {\n             intravisit::walk_struct_field(builder, s);\n         })\n     }\n@@ -782,25 +782,25 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for LintLevelMapBuilder<'a, 'tcx> {\n                      v: &'tcx hir::Variant,\n                      g: &'tcx hir::Generics,\n                      item_id: hir::HirId) {\n-        self.with_lint_attrs(v.node.data.id(), &v.node.attrs, |builder| {\n+        self.with_lint_attrs(v.node.data.hir_id(), &v.node.attrs, |builder| {\n             intravisit::walk_variant(builder, v, g, item_id);\n         })\n     }\n \n     fn visit_local(&mut self, l: &'tcx hir::Local) {\n-        self.with_lint_attrs(l.id, &l.attrs, |builder| {\n+        self.with_lint_attrs(l.hir_id, &l.attrs, |builder| {\n             intravisit::walk_local(builder, l);\n         })\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n-        self.with_lint_attrs(trait_item.id, &trait_item.attrs, |builder| {\n+        self.with_lint_attrs(trait_item.hir_id, &trait_item.attrs, |builder| {\n             intravisit::walk_trait_item(builder, trait_item);\n         });\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n-        self.with_lint_attrs(impl_item.id, &impl_item.attrs, |builder| {\n+        self.with_lint_attrs(impl_item.hir_id, &impl_item.attrs, |builder| {\n             intravisit::walk_impl_item(builder, impl_item);\n         });\n     }"}, {"sha": "201a779ee1827adef9f99b6939f81db110bc0d6d", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -99,10 +99,10 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn handle_field_access(&mut self, lhs: &hir::Expr, node_id: ast::NodeId) {\n+    fn handle_field_access(&mut self, lhs: &hir::Expr, hir_id: hir::HirId) {\n         match self.tables.expr_ty_adjusted(lhs).sty {\n             ty::Adt(def, _) => {\n-                let index = self.tcx.field_index(node_id, self.tables);\n+                let index = self.tcx.field_index(hir_id, self.tables);\n                 self.insert_def_id(def.non_enum_variant().fields[index].did);\n             }\n             ty::Tuple(..) => {}\n@@ -120,7 +120,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             if let PatKind::Wild = pat.node.pat.node {\n                 continue;\n             }\n-            let index = self.tcx.field_index(pat.node.id, self.tables);\n+            let index = self.tcx.field_index(pat.node.hir_id, self.tables);\n             self.insert_def_id(variant.fields[index].did);\n         }\n     }\n@@ -190,7 +190,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     fn mark_as_used_if_union(&mut self, adt: &ty::AdtDef, fields: &hir::HirVec<hir::Field>) {\n         if adt.is_union() && adt.non_enum_variant().fields.len() > 1 && adt.did.is_local() {\n             for field in fields {\n-                let index = self.tcx.field_index(field.id, self.tables);\n+                let index = self.tcx.field_index(field.hir_id, self.tables);\n                 self.insert_def_id(adt.non_enum_variant().fields[index].did);\n             }\n         }\n@@ -232,7 +232,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n                 self.lookup_and_handle_method(expr.hir_id);\n             }\n             hir::ExprKind::Field(ref lhs, ..) => {\n-                self.handle_field_access(&lhs, expr.id);\n+                self.handle_field_access(&lhs, expr.hir_id);\n             }\n             hir::ExprKind::Struct(_, ref fields, _) => {\n                 if let ty::Adt(ref adt, _) = self.tables.expr_ty(expr).sty {"}, {"sha": "7fc01e302a7d2c22e131117fed35a817fa166994", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -33,7 +33,7 @@ pub trait Delegate<'tcx> {\n     // The value found at `cmt` is either copied or moved, depending\n     // on mode.\n     fn consume(&mut self,\n-               consume_id: ast::NodeId,\n+               consume_id: hir::HirId,\n                consume_span: Span,\n                cmt: &mc::cmt_<'tcx>,\n                mode: ConsumeMode);\n@@ -65,7 +65,7 @@ pub trait Delegate<'tcx> {\n     // The value found at `borrow` is being borrowed at the point\n     // `borrow_id` for the region `loan_region` with kind `bk`.\n     fn borrow(&mut self,\n-              borrow_id: ast::NodeId,\n+              borrow_id: hir::HirId,\n               borrow_span: Span,\n               cmt: &mc::cmt_<'tcx>,\n               loan_region: ty::Region<'tcx>,\n@@ -79,7 +79,7 @@ pub trait Delegate<'tcx> {\n \n     // The path at `cmt` is being assigned to.\n     fn mutate(&mut self,\n-              assignment_id: ast::NodeId,\n+              assignment_id: hir::HirId,\n               assignment_span: Span,\n               assignee_cmt: &mc::cmt_<'tcx>,\n               mode: MutateMode);\n@@ -329,7 +329,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     }\n \n     fn delegate_consume(&mut self,\n-                        consume_id: ast::NodeId,\n+                        consume_id: hir::HirId,\n                         consume_span: Span,\n                         cmt: &mc::cmt_<'tcx>) {\n         debug!(\"delegate_consume(consume_id={}, cmt={:?})\",\n@@ -349,7 +349,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         debug!(\"consume_expr(expr={:?})\", expr);\n \n         let cmt = return_if_err!(self.mc.cat_expr(expr));\n-        self.delegate_consume(expr.id, expr.span, &cmt);\n+        self.delegate_consume(expr.hir_id, expr.span, &cmt);\n         self.walk_expr(expr);\n     }\n \n@@ -359,7 +359,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                    expr: &hir::Expr,\n                    mode: MutateMode) {\n         let cmt = return_if_err!(self.mc.cat_expr(expr));\n-        self.delegate.mutate(assignment_expr.id, span, &cmt, mode);\n+        self.delegate.mutate(assignment_expr.hir_id, span, &cmt, mode);\n         self.walk_expr(expr);\n     }\n \n@@ -372,7 +372,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                expr, r, bk);\n \n         let cmt = return_if_err!(self.mc.cat_expr(expr));\n-        self.delegate.borrow(expr.id, expr.span, &cmt, r, bk, cause);\n+        self.delegate.borrow(expr.hir_id, expr.span, &cmt, r, bk, cause);\n \n         self.walk_expr(expr)\n     }\n@@ -662,7 +662,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 // Consume those fields of the with expression that are needed.\n                 for (f_index, with_field) in adt.non_enum_variant().fields.iter().enumerate() {\n                     let is_mentioned = fields.iter().any(|f| {\n-                        self.tcx().field_index(f.id, self.mc.tables) == f_index\n+                        self.tcx().field_index(f.hir_id, self.mc.tables) == f_index\n                     });\n                     if !is_mentioned {\n                         let cmt_field = self.mc.cat_field(\n@@ -672,7 +672,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                             with_field.ident,\n                             with_field.ty(self.tcx(), substs)\n                         );\n-                        self.delegate_consume(with_expr.id, with_expr.span, &cmt_field);\n+                        self.delegate_consume(with_expr.hir_id, with_expr.span, &cmt_field);\n                     }\n                 }\n             }\n@@ -711,7 +711,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 adjustment::Adjust::Unsize => {\n                     // Creating a closure/fn-pointer or unsizing consumes\n                     // the input and stores it into the resulting rvalue.\n-                    self.delegate_consume(expr.id, expr.span, &cmt);\n+                    self.delegate_consume(expr.hir_id, expr.span, &cmt);\n                 }\n \n                 adjustment::Adjust::Deref(None) => {}\n@@ -723,7 +723,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 // this is an autoref of `x`.\n                 adjustment::Adjust::Deref(Some(ref deref)) => {\n                     let bk = ty::BorrowKind::from_mutbl(deref.mutbl);\n-                    self.delegate.borrow(expr.id, expr.span, &cmt, deref.region, bk, AutoRef);\n+                    self.delegate.borrow(expr.hir_id, expr.span, &cmt, deref.region, bk, AutoRef);\n                 }\n \n                 adjustment::Adjust::Borrow(ref autoref) => {\n@@ -741,14 +741,14 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                     expr: &hir::Expr,\n                     cmt_base: &mc::cmt_<'tcx>,\n                     autoref: &adjustment::AutoBorrow<'tcx>) {\n-        debug!(\"walk_autoref(expr.id={} cmt_base={:?} autoref={:?})\",\n-               expr.id,\n+        debug!(\"walk_autoref(expr.hir_id={} cmt_base={:?} autoref={:?})\",\n+               expr.hir_id,\n                cmt_base,\n                autoref);\n \n         match *autoref {\n             adjustment::AutoBorrow::Ref(r, m) => {\n-                self.delegate.borrow(expr.id,\n+                self.delegate.borrow(expr.hir_id,\n                                      expr.span,\n                                      cmt_base,\n                                      r,\n@@ -757,8 +757,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             }\n \n             adjustment::AutoBorrow::RawPtr(m) => {\n-                debug!(\"walk_autoref: expr.id={} cmt_base={:?}\",\n-                       expr.id,\n+                debug!(\"walk_autoref: expr.hir_id={} cmt_base={:?}\",\n+                       expr.hir_id,\n                        cmt_base);\n \n                 // Converting from a &T to *T (or &mut T to *mut T) is\n@@ -770,7 +770,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                         data: region::ScopeData::Node\n                     }));\n \n-                self.delegate.borrow(expr.id,\n+                self.delegate.borrow(expr.hir_id,\n                                      expr.span,\n                                      cmt_base,\n                                      r,\n@@ -864,15 +864,15 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                     // binding being produced.\n                     let def = Def::Local(canonical_id);\n                     if let Ok(ref binding_cmt) = mc.cat_def(pat.hir_id, pat.span, pat_ty, def) {\n-                        delegate.mutate(pat.id, pat.span, binding_cmt, MutateMode::Init);\n+                        delegate.mutate(pat.hir_id, pat.span, binding_cmt, MutateMode::Init);\n                     }\n \n                     // It is also a borrow or copy/move of the value being matched.\n                     match bm {\n                         ty::BindByReference(m) => {\n                             if let ty::Ref(r, _, _) = pat_ty.sty {\n                                 let bk = ty::BorrowKind::from_mutbl(m);\n-                                delegate.borrow(pat.id, pat.span, &cmt_pat, r, bk, RefBinding);\n+                                delegate.borrow(pat.hir_id, pat.span, &cmt_pat, r, bk, RefBinding);\n                             }\n                         }\n                         ty::BindByValue(..) => {\n@@ -920,10 +920,11 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     fn walk_captures(&mut self, closure_expr: &hir::Expr, fn_decl_span: Span) {\n         debug!(\"walk_captures({:?})\", closure_expr);\n \n-        self.tcx().with_freevars(closure_expr.id, |freevars| {\n+        let closure_node_id = self.tcx().hir().hir_to_node_id(closure_expr.hir_id);\n+        let closure_def_id = self.tcx().hir().local_def_id(closure_node_id);\n+        self.tcx().with_freevars(closure_node_id, |freevars| {\n             for freevar in freevars {\n                 let var_hir_id = self.tcx().hir().node_to_hir_id(freevar.var_id());\n-                let closure_def_id = self.tcx().hir().local_def_id(closure_expr.id);\n                 let upvar_id = ty::UpvarId {\n                     var_path: ty::UpvarPath { hir_id: var_hir_id },\n                     closure_expr_id: closure_def_id.to_local(),\n@@ -938,10 +939,10 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                                                 self.param_env,\n                                                 &cmt_var,\n                                                 CaptureMove);\n-                        self.delegate.consume(closure_expr.id, freevar.span, &cmt_var, mode);\n+                        self.delegate.consume(closure_expr.hir_id, freevar.span, &cmt_var, mode);\n                     }\n                     ty::UpvarCapture::ByRef(upvar_borrow) => {\n-                        self.delegate.borrow(closure_expr.id,\n+                        self.delegate.borrow(closure_expr.hir_id,\n                                              fn_decl_span,\n                                              &cmt_var,\n                                              upvar_borrow.region,"}, {"sha": "76933a6e3484b02194d3341ba3b2bd0b6748c696", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -265,7 +265,7 @@ struct IrMaps<'a, 'tcx: 'a> {\n     num_vars: usize,\n     live_node_map: HirIdMap<LiveNode>,\n     variable_map: HirIdMap<Variable>,\n-    capture_info_map: NodeMap<Rc<Vec<CaptureInfo>>>,\n+    capture_info_map: HirIdMap<Rc<Vec<CaptureInfo>>>,\n     var_kinds: Vec<VarKind>,\n     lnks: Vec<LiveNodeKind>,\n }\n@@ -344,8 +344,8 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n         }\n     }\n \n-    fn set_captures(&mut self, node_id: NodeId, cs: Vec<CaptureInfo>) {\n-        self.capture_info_map.insert(node_id, Rc::new(cs));\n+    fn set_captures(&mut self, hir_id: HirId, cs: Vec<CaptureInfo>) {\n+        self.capture_info_map.insert(hir_id, Rc::new(cs));\n     }\n \n     fn lnk(&self, ln: LiveNode) -> LiveNodeKind {\n@@ -460,7 +460,7 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n       hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n-        debug!(\"expr {}: path that leads to {:?}\", expr.id, path.def);\n+        debug!(\"expr {}: path that leads to {:?}\", expr.hir_id, path.def);\n         if let Def::Local(..) = path.def {\n             ir.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n         }\n@@ -476,7 +476,8 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n         // in better error messages than just pointing at the closure\n         // construction site.\n         let mut call_caps = Vec::new();\n-        ir.tcx.with_freevars(expr.id, |freevars| {\n+        let node_id = ir.tcx.hir().hir_to_node_id(expr.hir_id);\n+        ir.tcx.with_freevars(node_id, |freevars| {\n             call_caps.extend(freevars.iter().filter_map(|fv| {\n                 if let Def::Local(rv) = fv.def {\n                     let fv_ln = ir.add_live_node(FreeVarNode(fv.span));\n@@ -487,7 +488,7 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n                 }\n             }));\n         });\n-        ir.set_captures(expr.id, call_caps);\n+        ir.set_captures(expr.hir_id, call_caps);\n \n         intravisit::walk_expr(ir, expr);\n       }\n@@ -925,7 +926,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn compute(&mut self, body: &hir::Expr) -> LiveNode {\n-        debug!(\"compute: using id for body, {}\", self.ir.tcx.hir().node_to_pretty_string(body.id));\n+        debug!(\"compute: using id for body, {}\",\n+               self.ir.tcx.hir().hir_to_pretty_string(body.hir_id));\n \n         // the fallthrough exit is only for those cases where we do not\n         // explicitly return:\n@@ -940,7 +942,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                    for ln_idx in 0..self.ir.num_live_nodes {\n                         debug!(\"{:?}\", self.ln_str(LiveNode(ln_idx as u32)));\n                    }\n-                   body.id\n+                   body.hir_id\n                },\n                entry_ln);\n \n@@ -1003,7 +1005,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn propagate_through_expr(&mut self, expr: &Expr, succ: LiveNode)\n                               -> LiveNode {\n-        debug!(\"propagate_through_expr: {}\", self.ir.tcx.hir().node_to_pretty_string(expr.id));\n+        debug!(\"propagate_through_expr: {}\", self.ir.tcx.hir().hir_to_pretty_string(expr.hir_id));\n \n         match expr.node {\n             // Interesting cases with control flow or which gen/kill\n@@ -1017,11 +1019,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n             hir::ExprKind::Closure(..) => {\n                 debug!(\"{} is an ExprKind::Closure\",\n-                       self.ir.tcx.hir().node_to_pretty_string(expr.id));\n+                       self.ir.tcx.hir().hir_to_pretty_string(expr.hir_id));\n \n                 // the construction of a closure itself is not important,\n                 // but we have to consider the closed over variables.\n-                let caps = self.ir.capture_info_map.get(&expr.id).cloned().unwrap_or_else(||\n+                let caps = self.ir.capture_info_map.get(&expr.hir_id).cloned().unwrap_or_else(||\n                     span_bug!(expr.span, \"no registered caps\"));\n \n                 caps.iter().rev().fold(succ, |succ, cap| {\n@@ -1170,7 +1172,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n \n             hir::ExprKind::Call(ref f, ref args) => {\n-                let m = self.ir.tcx.hir().get_module_parent(expr.id);\n+                let m = self.ir.tcx.hir().get_module_parent_by_hir_id(expr.hir_id);\n                 let succ = if self.ir.tcx.is_ty_uninhabited_from(m, self.tables.expr_ty(expr)) {\n                     self.s.exit_ln\n                 } else {\n@@ -1181,7 +1183,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n \n             hir::ExprKind::MethodCall(.., ref args) => {\n-                let m = self.ir.tcx.hir().get_module_parent(expr.id);\n+                let m = self.ir.tcx.hir().get_module_parent_by_hir_id(expr.hir_id);\n                 let succ = if self.ir.tcx.is_ty_uninhabited_from(m, self.tables.expr_ty(expr)) {\n                     self.s.exit_ln\n                 } else {\n@@ -1387,17 +1389,17 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n         }\n         debug!(\"propagate_through_loop: using id for loop body {} {}\",\n-               expr.id, self.ir.tcx.hir().hir_to_pretty_string(body.hir_id));\n+               expr.hir_id, self.ir.tcx.hir().hir_to_pretty_string(body.hir_id));\n \n-\n-        self.break_ln.insert(expr.id, succ);\n+        let node_id = self.ir.tcx.hir().hir_to_node_id(expr.hir_id);\n+        self.break_ln.insert(node_id, succ);\n \n         let cond_ln = match kind {\n             LoopLoop => ln,\n             WhileLoop(ref cond) => self.propagate_through_expr(&cond, ln),\n         };\n \n-        self.cont_ln.insert(expr.id, cond_ln);\n+        self.cont_ln.insert(node_id, cond_ln);\n \n         let body_ln = self.propagate_through_block(body, cond_ln);\n "}, {"sha": "822a42b374f38fc5a13e9b7d65e34776eff2be3d", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -632,7 +632,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn cat_expr_unadjusted(&self, expr: &hir::Expr) -> McResult<cmt_<'tcx>> {\n-        debug!(\"cat_expr: id={} expr={:?}\", expr.id, expr);\n+        debug!(\"cat_expr: id={} expr={:?}\", expr.hir_id, expr);\n \n         let expr_ty = self.expr_ty(expr)?;\n         match expr.node {\n@@ -648,10 +648,10 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             hir::ExprKind::Field(ref base, f_ident) => {\n                 let base_cmt = Rc::new(self.cat_expr(&base)?);\n                 debug!(\"cat_expr(cat_field): id={} expr={:?} base={:?}\",\n-                       expr.id,\n+                       expr.hir_id,\n                        expr,\n                        base_cmt);\n-                let f_index = self.tcx.field_index(expr.id, self.tables);\n+                let f_index = self.tcx.field_index(expr.hir_id, self.tables);\n                 Ok(self.cat_field(expr, base_cmt, f_index, f_ident, expr_ty))\n             }\n \n@@ -1321,7 +1321,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n                 for fp in field_pats {\n                     let field_ty = self.pat_ty_adjusted(&fp.node.pat)?; // see (*2)\n-                    let f_index = self.tcx.field_index(fp.node.id, self.tables);\n+                    let f_index = self.tcx.field_index(fp.node.hir_id, self.tables);\n                     let cmt_field = Rc::new(self.cat_field(pat, cmt.clone(), f_index,\n                                                            fp.node.ident, field_ty));\n                     self.cat_pattern_(cmt_field, &fp.node.pat, op)?;"}, {"sha": "55572c637f80ad729d6b243314415c57e12745b9", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -14,7 +14,7 @@ use crate::session::{DiagnosticMessageId, Session};\n use syntax::symbol::Symbol;\n use syntax_pos::{Span, MultiSpan};\n use syntax::ast;\n-use syntax::ast::{NodeId, Attribute};\n+use syntax::ast::Attribute;\n use syntax::errors::Applicability;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::attr::{self, Stability, Deprecation};\n@@ -557,9 +557,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// If `id` is `Some(_)`, this function will also check if the item at `def_id` has been\n     /// deprecated. If the item is indeed deprecated, we will emit a deprecation lint attached to\n     /// `id`.\n-    pub fn eval_stability(self, def_id: DefId, id: Option<NodeId>, span: Span) -> EvalResult {\n+    pub fn eval_stability(self, def_id: DefId, id: Option<HirId>, span: Span) -> EvalResult {\n         let lint_deprecated = |def_id: DefId,\n-                               id: NodeId,\n+                               id: HirId,\n                                note: Option<Symbol>,\n                                suggestion: Option<Symbol>,\n                                message: &str,\n@@ -570,9 +570,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 format!(\"{}\", message)\n             };\n \n-            let mut diag = self.struct_span_lint_node(lint, id, span, &msg);\n+            let mut diag = self.struct_span_lint_hir(lint, id, span, &msg);\n             if let Some(suggestion) = suggestion {\n-                if let hir::Node::Expr(_) = self.hir().get(id) {\n+                if let hir::Node::Expr(_) = self.hir().get_by_hir_id(id) {\n                     diag.span_suggestion(\n                         span,\n                         &msg,\n@@ -582,15 +582,16 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n             diag.emit();\n-            if id == ast::DUMMY_NODE_ID {\n-                span_bug!(span, \"emitted a {} lint with dummy node id: {:?}\", lint.name, def_id);\n+            if id == hir::DUMMY_HIR_ID {\n+                span_bug!(span, \"emitted a {} lint with dummy HIR id: {:?}\", lint.name, def_id);\n             }\n         };\n \n         // Deprecated attributes apply in-crate and cross-crate.\n         if let Some(id) = id {\n             if let Some(depr_entry) = self.lookup_deprecation_entry(def_id) {\n-                let parent_def_id = self.hir().local_def_id(self.hir().get_parent(id));\n+                let parent_def_id = self.hir().local_def_id_from_hir_id(\n+                    self.hir().get_parent_item(id));\n                 let skip = self.lookup_deprecation_entry(parent_def_id)\n                                .map_or(false, |parent_depr| parent_depr.same_origin(&depr_entry));\n \n@@ -703,7 +704,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     ///\n     /// Additionally, this function will also check if the item is deprecated. If so, and `id` is\n     /// not `None`, a deprecated lint attached to `id` will be emitted.\n-    pub fn check_stability(self, def_id: DefId, id: Option<NodeId>, span: Span) {\n+    pub fn check_stability(self, def_id: DefId, id: Option<HirId>, span: Span) {\n         match self.eval_stability(def_id, id, span) {\n             EvalResult::Allow => {}\n             EvalResult::Deny { feature, reason, issue } => {\n@@ -763,7 +764,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                     None => return,\n                 };\n                 let def_id = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n-                self.tcx.check_stability(def_id, Some(item.id), item.span);\n+                self.tcx.check_stability(def_id, Some(item.hir_id), item.span);\n             }\n \n             // For implementations of traits, check the stability of each item\n@@ -811,7 +812,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n     }\n \n     fn visit_path(&mut self, path: &'tcx hir::Path, id: hir::HirId) {\n-        let id = self.tcx.hir().hir_to_node_id(id);\n         if let Some(def_id) = path.def.opt_def_id() {\n             self.tcx.check_stability(def_id, Some(id), path.span)\n         }"}, {"sha": "be6a95948edb9d5201e8cfac86225b0f3c947f01", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -257,10 +257,10 @@ pub enum ObligationCauseCode<'tcx> {\n     ReturnNoExpression,\n \n     /// `return` with an expression\n-    ReturnType(ast::NodeId),\n+    ReturnType(hir::HirId),\n \n     /// Block implicit return\n-    BlockTailExpression(ast::NodeId),\n+    BlockTailExpression(hir::HirId),\n \n     /// #[feature(trivial_bounds)] is not enabled\n     TrivialBound,"}, {"sha": "a3cf7bf488ee71ad0398cc66095f8b5f7428179e", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -2775,8 +2775,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn field_index(self, node_id: NodeId, tables: &TypeckTables<'_>) -> usize {\n-        let hir_id = self.hir().node_to_hir_id(node_id);\n+    pub fn field_index(self, hir_id: hir::HirId, tables: &TypeckTables<'_>) -> usize {\n         tables.field_indices().get(hir_id).cloned().expect(\"no index for a field\")\n     }\n "}, {"sha": "c74d7f00cf5169626e5f634b1ed84878aa97988b", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -89,15 +89,14 @@ struct CheckLoanCtxt<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n     fn consume(&mut self,\n-               consume_id: ast::NodeId,\n+               consume_id: hir::HirId,\n                consume_span: Span,\n                cmt: &mc::cmt_<'tcx>,\n                mode: euv::ConsumeMode) {\n         debug!(\"consume(consume_id={}, cmt={:?}, mode={:?})\",\n                consume_id, cmt, mode);\n \n-        let hir_id = self.tcx().hir().node_to_hir_id(consume_id);\n-        self.consume_common(hir_id.local_id, consume_span, cmt, mode);\n+        self.consume_common(consume_id.local_id, consume_span, cmt, mode);\n     }\n \n     fn matched_pat(&mut self,\n@@ -118,7 +117,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n     }\n \n     fn borrow(&mut self,\n-              borrow_id: ast::NodeId,\n+              borrow_id: hir::HirId,\n               borrow_span: Span,\n               cmt: &mc::cmt_<'tcx>,\n               loan_region: ty::Region<'tcx>,\n@@ -130,22 +129,21 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                borrow_id, cmt, loan_region,\n                bk, loan_cause);\n \n-        let hir_id = self.tcx().hir().node_to_hir_id(borrow_id);\n         if let Some(lp) = opt_loan_path(cmt) {\n             let moved_value_use_kind = match loan_cause {\n                 euv::ClosureCapture(_) => MovedInCapture,\n                 _ => MovedInUse,\n             };\n-            self.check_if_path_is_moved(hir_id.local_id, borrow_span, moved_value_use_kind, &lp);\n+            self.check_if_path_is_moved(borrow_id.local_id, borrow_span, moved_value_use_kind, &lp);\n         }\n \n-        self.check_for_conflicting_loans(hir_id.local_id);\n+        self.check_for_conflicting_loans(borrow_id.local_id);\n \n         self.check_for_loans_across_yields(cmt, loan_region, borrow_span);\n     }\n \n     fn mutate(&mut self,\n-              assignment_id: ast::NodeId,\n+              assignment_id: hir::HirId,\n               assignment_span: Span,\n               assignee_cmt: &mc::cmt_<'tcx>,\n               mode: euv::MutateMode)\n@@ -176,8 +174,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                 }\n             }\n         }\n-        self.check_assignment(self.tcx().hir().node_to_hir_id(assignment_id).local_id,\n-                              assignment_span, assignee_cmt);\n+        self.check_assignment(assignment_id.local_id, assignment_span, assignee_cmt);\n     }\n \n     fn decl_without_init(&mut self, _id: ast::NodeId, _span: Span) { }\n@@ -188,7 +185,7 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                      move_data: &move_data::FlowedMoveData<'c, 'tcx>,\n                                      all_loans: &[Loan<'tcx>],\n                                      body: &hir::Body) {\n-    debug!(\"check_loans(body id={})\", body.value.id);\n+    debug!(\"check_loans(body id={})\", body.value.hir_id);\n \n     let def_id = bccx.tcx.hir().body_owner_def_id(body.id());\n "}, {"sha": "03af27997d3cbee7bdf7b4accd3f561ee603d89f", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -68,7 +68,7 @@ struct GatherLoanCtxt<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n     fn consume(&mut self,\n-               consume_id: ast::NodeId,\n+               consume_id: hir::HirId,\n                _consume_span: Span,\n                cmt: &mc::cmt_<'tcx>,\n                mode: euv::ConsumeMode) {\n@@ -79,7 +79,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n             euv::Move(move_reason) => {\n                 gather_moves::gather_move_from_expr(\n                     self.bccx, &self.move_data, &mut self.move_error_collector,\n-                    self.bccx.tcx.hir().node_to_hir_id(consume_id).local_id, cmt, move_reason);\n+                    consume_id.local_id, cmt, move_reason);\n             }\n             euv::Copy => { }\n         }\n@@ -115,7 +115,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n     }\n \n     fn borrow(&mut self,\n-              borrow_id: ast::NodeId,\n+              borrow_id: hir::HirId,\n               borrow_span: Span,\n               cmt: &mc::cmt_<'tcx>,\n               loan_region: ty::Region<'tcx>,\n@@ -126,8 +126,8 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n                bk={:?}, loan_cause={:?})\",\n                borrow_id, cmt, loan_region,\n                bk, loan_cause);\n-        let hir_id = self.bccx.tcx.hir().node_to_hir_id(borrow_id);\n-        self.guarantee_valid(hir_id.local_id,\n+\n+        self.guarantee_valid(borrow_id.local_id,\n                              borrow_span,\n                              cmt,\n                              bk,\n@@ -136,12 +136,13 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n     }\n \n     fn mutate(&mut self,\n-              assignment_id: ast::NodeId,\n+              assignment_id: hir::HirId,\n               assignment_span: Span,\n               assignee_cmt: &mc::cmt_<'tcx>,\n               _: euv::MutateMode)\n     {\n-        self.guarantee_assignment_valid(assignment_id,\n+        let node_id = self.bccx.tcx.hir().hir_to_node_id(assignment_id);\n+        self.guarantee_assignment_valid(node_id,\n                                         assignment_span,\n                                         assignee_cmt);\n     }"}, {"sha": "0698c15346ebc4e9792cacf3270a3e048c9e3c19", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -425,8 +425,8 @@ impl<'hir> pprust_hir::PpAnn for IdentifiedAnnotation<'hir> {\n             }\n             pprust_hir::AnnNode::Expr(expr) => {\n                 s.s.space()?;\n-                s.synth_comment(format!(\"node_id: {} hir local_id: {}\",\n-                                        expr.id, expr.hir_id.local_id.as_u32()))?;\n+                s.synth_comment(format!(\"expr hir_id: {} hir local_id: {}\",\n+                                        expr.hir_id, expr.hir_id.local_id.as_u32()))?;\n                 s.pclose()\n             }\n             pprust_hir::AnnNode::Pat(pat) => {\n@@ -834,15 +834,15 @@ fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n     let body_id = match code {\n         blocks::Code::Expr(expr) => {\n             // Find the function this expression is from.\n-            let mut node_id = expr.id;\n+            let mut hir_id = expr.hir_id;\n             loop {\n-                let node = tcx.hir().get(node_id);\n+                let node = tcx.hir().get_by_hir_id(hir_id);\n                 if let Some(n) = hir::map::blocks::FnLikeNode::from_node(node) {\n                     break n.body();\n                 }\n-                let parent = tcx.hir().get_parent_node(node_id);\n-                assert_ne!(node_id, parent);\n-                node_id = parent;\n+                let parent = tcx.hir().get_parent_node_by_hir_id(hir_id);\n+                assert_ne!(hir_id, parent);\n+                hir_id = parent;\n             }\n         }\n         blocks::Code::FnLike(fn_like) => fn_like.body(),"}, {"sha": "ac10b6403bd132e6a7d30c08350cb3b2fc8cb454", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -200,7 +200,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonShorthandFieldPatterns {\n                 }\n                 if let PatKind::Binding(_, _, _, ident, None) = fieldpat.node.pat.node {\n                     if cx.tcx.find_field_index(ident, &variant) ==\n-                       Some(cx.tcx.field_index(fieldpat.node.id, cx.tables)) {\n+                       Some(cx.tcx.field_index(fieldpat.node.hir_id, cx.tables)) {\n                         let mut err = cx.struct_span_lint(NON_SHORTHAND_FIELD_PATTERNS,\n                                      fieldpat.span,\n                                      &format!(\"the `{}:` in this pattern is redundant\", ident));"}, {"sha": "ba598ccf7ab5d35c81f7e7cd6a578160ee917bfd", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -48,12 +48,12 @@ declare_lint! {\n #[derive(Copy, Clone)]\n pub struct TypeLimits {\n     /// Id of the last visited negated expression\n-    negated_expr_id: ast::NodeId,\n+    negated_expr_id: hir::HirId,\n }\n \n impl TypeLimits {\n     pub fn new() -> TypeLimits {\n-        TypeLimits { negated_expr_id: ast::DUMMY_NODE_ID }\n+        TypeLimits { negated_expr_id: hir::DUMMY_HIR_ID }\n     }\n }\n \n@@ -73,8 +73,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n         match e.node {\n             hir::ExprKind::Unary(hir::UnNeg, ref expr) => {\n                 // propagate negation, if the negation itself isn't negated\n-                if self.negated_expr_id != e.id {\n-                    self.negated_expr_id = expr.id;\n+                if self.negated_expr_id != e.hir_id {\n+                    self.negated_expr_id = expr.hir_id;\n                 }\n             }\n             hir::ExprKind::Binary(binop, ref l, ref r) => {\n@@ -97,7 +97,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                                 };\n                                 let (_, max) = int_ty_range(int_type);\n                                 let max = max as u128;\n-                                let negative = self.negated_expr_id == e.id;\n+                                let negative = self.negated_expr_id == e.hir_id;\n \n                                 // Detect literal value out of range [min, max] inclusive\n                                 // avoiding use of -min to prevent overflow/panic\n@@ -138,8 +138,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                             _ => bug!(),\n                         };\n                         if lit_val < min || lit_val > max {\n-                            let parent_id = cx.tcx.hir().get_parent_node(e.id);\n-                            if let Node::Expr(parent_expr) = cx.tcx.hir().get(parent_id) {\n+                            let parent_id = cx.tcx.hir().get_parent_node_by_hir_id(e.hir_id);\n+                            if let Node::Expr(parent_expr) = cx.tcx.hir().get_by_hir_id(parent_id) {\n                                 if let hir::ExprKind::Cast(..) = parent_expr.node {\n                                     if let ty::Char = cx.tables.expr_ty(parent_expr).sty {\n                                         let mut err = cx.struct_span_lint("}, {"sha": "86b8b276eafe5930d35cb7c427705892690c0c6d", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -58,7 +58,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n \n         let t = cx.tables.expr_ty(&expr);\n         let type_permits_lack_of_use = if t.is_unit()\n-            || cx.tcx.is_ty_uninhabited_from(cx.tcx.hir().get_module_parent(expr.id), t) {\n+            || cx.tcx.is_ty_uninhabited_from(\n+                cx.tcx.hir().get_module_parent_by_hir_id(expr.hir_id), t)\n+        {\n             true\n         } else {\n             match t.sty {"}, {"sha": "5fdc5899a721ec3862365706ee6639c5fb3d7119", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -1729,7 +1729,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     fn encode_info_for_expr(&mut self, expr: &hir::Expr) {\n         match expr.node {\n             hir::ExprKind::Closure(..) => {\n-                let def_id = self.tcx.hir().local_def_id(expr.id);\n+                let def_id = self.tcx.hir().local_def_id_from_hir_id(expr.hir_id);\n                 self.record(def_id, IsolatedEncoder::encode_info_for_closure, def_id);\n             }\n             _ => {}"}, {"sha": "f58e61915e8c99d120db8bc72a714f97e62da050", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -103,7 +103,7 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         },\n                         pattern,\n                         initializer: local.init.to_ref(),\n-                        lint_level: cx.lint_level_of(local.id),\n+                        lint_level: cx.lint_level_of(local.hir_id),\n                     },\n                     opt_destruction_scope: opt_dxn_ext,\n                     span: stmt_span,"}, {"sha": "a11afc3a27f213c4ee4bf23295b0b443172fb41c", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -24,7 +24,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n             data: region::ScopeData::Node\n         };\n \n-        debug!(\"Expr::make_mirror(): id={}, span={:?}\", self.id, self.span);\n+        debug!(\"Expr::make_mirror(): id={}, span={:?}\", self.hir_id, self.span);\n \n         let mut expr = make_mirror_unadjusted(cx, self);\n \n@@ -44,7 +44,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n             kind: ExprKind::Scope {\n                 region_scope: expr_scope,\n                 value: expr.to_ref(),\n-                lint_level: cx.lint_level_of(self.id),\n+                lint_level: cx.lint_level_of(self.hir_id),\n             },\n         };\n \n@@ -529,7 +529,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     span_bug!(expr.span, \"closure expr w/o closure type: {:?}\", closure_ty);\n                 }\n             };\n-            let upvars = cx.tcx.with_freevars(expr.id, |freevars| {\n+            let expr_node_id = cx.tcx.hir().hir_to_node_id(expr.hir_id);\n+            let upvars = cx.tcx.with_freevars(expr_node_id, |freevars| {\n                 freevars.iter()\n                     .zip(substs.upvar_tys(def_id, cx.tcx))\n                     .map(|(fv, ty)| capture_freevar(cx, expr, fv, ty))\n@@ -637,7 +638,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         hir::ExprKind::Field(ref source, ..) => {\n             ExprKind::Field {\n                 lhs: source.to_ref(),\n-                name: Field::new(cx.tcx.field_index(expr.id, cx.tables)),\n+                name: Field::new(cx.tcx.field_index(expr.hir_id, cx.tables)),\n             }\n         }\n         hir::ExprKind::Cast(ref source, ref cast_ty) => {\n@@ -1184,7 +1185,7 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     let var_hir_id = cx.tcx.hir().node_to_hir_id(freevar.var_id());\n     let upvar_id = ty::UpvarId {\n         var_path: ty::UpvarPath { hir_id: var_hir_id },\n-        closure_expr_id: cx.tcx.hir().local_def_id(closure_expr.id).to_local(),\n+        closure_expr_id: cx.tcx.hir().local_def_id_from_hir_id(closure_expr.hir_id).to_local(),\n     };\n     let upvar_capture = cx.tables().upvar_capture(upvar_id);\n     let temp_lifetime = cx.region_scope_tree.temporary_scope(closure_expr.hir_id.local_id);\n@@ -1223,7 +1224,7 @@ fn field_refs<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     fields.iter()\n         .map(|field| {\n             FieldExprRef {\n-                name: Field::new(cx.tcx.field_index(field.id, cx.tables)),\n+                name: Field::new(cx.tcx.field_index(field.hir_id, cx.tables)),\n                 expr: field.expr.to_ref(),\n             }\n         })"}, {"sha": "9e19badf49db0591040ae5732149c3fb576525dc", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -197,8 +197,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         ty.needs_drop(self.tcx.global_tcx(), param_env)\n     }\n \n-    fn lint_level_of(&self, node_id: ast::NodeId) -> LintLevel {\n-        let hir_id = self.tcx.hir().definitions().node_to_hir_id(node_id);\n+    fn lint_level_of(&self, hir_id: hir::HirId) -> LintLevel {\n         let has_lint_level = self.tcx.dep_graph.with_ignore(|| {\n             self.tcx.lint_levels(LOCAL_CRATE).lint_level_set(hir_id).is_some()\n         });"}, {"sha": "fff810b0e6f2cce312a087baafb2dfd1f5ba5c3a", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -171,7 +171,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             }\n         }\n \n-        let module = self.tcx.hir().get_module_parent(scrut.id);\n+        let module = self.tcx.hir().get_module_parent_by_hir_id(scrut.hir_id);\n         MatchCheckCtxt::create_and_enter(self.tcx, self.param_env, module, |ref mut cx| {\n             let mut have_errors = false;\n \n@@ -203,7 +203,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             // Then, if the match has no arms, check whether the scrutinee\n             // is uninhabited.\n             let pat_ty = self.tables.node_type(scrut.hir_id);\n-            let module = self.tcx.hir().get_module_parent(scrut.id);\n+            let module = self.tcx.hir().get_module_parent_by_hir_id(scrut.hir_id);\n             if inlined_arms.is_empty() {\n                 let scrutinee_is_uninhabited = if self.tcx.features().exhaustive_patterns {\n                     self.tcx.is_ty_uninhabited_from(module, pat_ty)\n@@ -561,10 +561,10 @@ struct MutationChecker<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'tcx> {\n     fn matched_pat(&mut self, _: &Pat, _: &cmt_<'_>, _: euv::MatchMode) {}\n-    fn consume(&mut self, _: ast::NodeId, _: Span, _: &cmt_<'_>, _: ConsumeMode) {}\n+    fn consume(&mut self, _: hir::HirId, _: Span, _: &cmt_<'_>, _: ConsumeMode) {}\n     fn consume_pat(&mut self, _: &Pat, _: &cmt_<'_>, _: ConsumeMode) {}\n     fn borrow(&mut self,\n-              _: ast::NodeId,\n+              _: hir::HirId,\n               span: Span,\n               _: &cmt_<'_>,\n               _: ty::Region<'tcx>,\n@@ -587,7 +587,7 @@ impl<'a, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'tcx> {\n         }\n     }\n     fn decl_without_init(&mut self, _: ast::NodeId, _: Span) {}\n-    fn mutate(&mut self, _: ast::NodeId, span: Span, _: &cmt_<'_>, mode: MutateMode) {\n+    fn mutate(&mut self, _: hir::HirId, span: Span, _: &cmt_<'_>, mode: MutateMode) {\n         match mode {\n             MutateMode::JustWrite | MutateMode::WriteAndRead => {\n                 struct_span_err!(self.cx.tcx.sess, span, E0302, \"cannot assign in a pattern guard\")"}, {"sha": "9e5fdaa8afdf75b87d1359c1a500709b70254f62", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -631,7 +631,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     fields.iter()\n                           .map(|field| {\n                               FieldPattern {\n-                                  field: Field::new(self.tcx.field_index(field.node.id,\n+                                  field: Field::new(self.tcx.field_index(field.node.hir_id,\n                                                                          self.tables)),\n                                   pattern: self.lower_pattern(&field.node.pat),\n                               }"}, {"sha": "c25884df87ba13e49f8e4d8d13fbe34753bf1e87", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -23,7 +23,7 @@ use rustc::middle::mem_categorization::Categorization;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::query::Providers;\n use rustc::ty::subst::Substs;\n-use rustc::util::nodemap::{ItemLocalSet, NodeSet};\n+use rustc::util::nodemap::{ItemLocalSet, HirIdSet};\n use rustc::hir;\n use rustc_data_structures::sync::Lrc;\n use syntax::ast;\n@@ -92,7 +92,7 @@ struct CheckCrateVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     in_fn: bool,\n     in_static: bool,\n-    mut_rvalue_borrows: NodeSet,\n+    mut_rvalue_borrows: HirIdSet,\n     param_env: ty::ParamEnv<'tcx>,\n     identity_substs: &'tcx Substs<'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n@@ -169,7 +169,7 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n     fn remove_mut_rvalue_borrow(&mut self, pat: &hir::Pat) -> bool {\n         let mut any_removed = false;\n         pat.walk(|p| {\n-            any_removed |= self.mut_rvalue_borrows.remove(&p.id);\n+            any_removed |= self.mut_rvalue_borrows.remove(&p.hir_id);\n             true\n         });\n         any_removed\n@@ -223,7 +223,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n             hir::StmtKind::Local(ref local) => {\n                 if self.remove_mut_rvalue_borrow(&local.pat) {\n                     if let Some(init) = &local.init {\n-                        self.mut_rvalue_borrows.insert(init.id);\n+                        self.mut_rvalue_borrows.insert(init.hir_id);\n                     }\n                 }\n \n@@ -248,7 +248,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n         outer &= check_adjustments(self, ex);\n \n         // Handle borrows on (or inside the autorefs of) this expression.\n-        if self.mut_rvalue_borrows.remove(&ex.id) {\n+        if self.mut_rvalue_borrows.remove(&ex.hir_id) {\n             outer = NotPromotable\n         }\n \n@@ -318,7 +318,7 @@ fn check_expr_kind<'a, 'tcx>(\n         }\n         hir::ExprKind::Cast(ref from, _) => {\n             let expr_promotability = v.check_expr(from);\n-            debug!(\"Checking const cast(id={})\", from.id);\n+            debug!(\"Checking const cast(id={})\", from.hir_id);\n             match v.tables.cast_kinds().get(from.hir_id) {\n                 None => {\n                     v.tcx.sess.delay_span_bug(e.span, \"no kind for cast\");\n@@ -456,9 +456,10 @@ fn check_expr_kind<'a, 'tcx>(\n         hir::ExprKind::Closure(_capture_clause, ref _box_fn_decl,\n                                body_id, _span, _option_generator_movability) => {\n             let nested_body_promotable = v.check_nested_body(body_id);\n+            let node_id = v.tcx.hir().hir_to_node_id(e.hir_id);\n             // Paths in constant contexts cannot refer to local variables,\n             // as there are none, and thus closures can't have upvars there.\n-            if v.tcx.with_freevars(e.id, |fv| !fv.is_empty()) {\n+            if v.tcx.with_freevars(node_id, |fv| !fv.is_empty()) {\n                 NotPromotable\n             } else {\n                 nested_body_promotable\n@@ -518,7 +519,7 @@ fn check_expr_kind<'a, 'tcx>(\n                 mut_borrow = v.remove_mut_rvalue_borrow(pat);\n             }\n             if mut_borrow {\n-                v.mut_rvalue_borrows.insert(expr.id);\n+                v.mut_rvalue_borrows.insert(expr.hir_id);\n             }\n \n             let _ = v.check_expr(expr);\n@@ -619,13 +620,13 @@ fn check_adjustments<'a, 'tcx>(\n \n impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {\n     fn consume(&mut self,\n-               _consume_id: ast::NodeId,\n+               _consume_id: hir::HirId,\n                _consume_span: Span,\n                _cmt: &mc::cmt_<'_>,\n                _mode: euv::ConsumeMode) {}\n \n     fn borrow(&mut self,\n-              borrow_id: ast::NodeId,\n+              borrow_id: hir::HirId,\n               _borrow_span: Span,\n               cmt: &mc::cmt_<'tcx>,\n               _loan_region: ty::Region<'tcx>,\n@@ -678,7 +679,7 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {\n \n     fn decl_without_init(&mut self, _id: ast::NodeId, _span: Span) {}\n     fn mutate(&mut self,\n-              _assignment_id: ast::NodeId,\n+              _assignment_id: hir::HirId,\n               _assignment_span: Span,\n               _assignee_cmt: &mc::cmt_<'_>,\n               _mode: euv::MutateMode) {"}, {"sha": "568e622bd34c2e70f494729bc4fccd094ee1e9b0", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -271,7 +271,8 @@ fn def_id_visibility<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n                     return (ctor_vis, span, descr);\n                 }\n                 Node::Expr(expr) => {\n-                    return (ty::Visibility::Restricted(tcx.hir().get_module_parent(expr.id)),\n+                    return (ty::Visibility::Restricted(\n+                        tcx.hir().get_module_parent_by_hir_id(expr.hir_id)),\n                             expr.span, \"private\")\n                 }\n                 node => bug!(\"unexpected node kind: {:?}\", node)\n@@ -872,7 +873,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n                     // unmentioned fields, just check them all.\n                     for (vf_index, variant_field) in variant.fields.iter().enumerate() {\n                         let field = fields.iter().find(|f| {\n-                            self.tcx.field_index(f.id, self.tables) == vf_index\n+                            self.tcx.field_index(f.hir_id, self.tables) == vf_index\n                         });\n                         let (use_ctxt, span) = match field {\n                             Some(field) => (field.ident.span, field.span),\n@@ -883,7 +884,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n                 } else {\n                     for field in fields {\n                         let use_ctxt = field.ident.span;\n-                        let index = self.tcx.field_index(field.id, self.tables);\n+                        let index = self.tcx.field_index(field.hir_id, self.tables);\n                         self.check_field(use_ctxt, field.span, adt, &variant.fields[index]);\n                     }\n                 }\n@@ -902,7 +903,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n                 let variant = adt.variant_of_def(def);\n                 for field in fields {\n                     let use_ctxt = field.node.ident.span;\n-                    let index = self.tcx.field_index(field.node.id, self.tables);\n+                    let index = self.tcx.field_index(field.node.hir_id, self.tables);\n                     self.check_field(use_ctxt, field.span, adt, &variant.fields[index]);\n                 }\n             }"}, {"sha": "b82aee7c96ad296caa5b8ec2df951ac9405939f1", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -1517,7 +1517,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                         return;\n                     }\n                 };\n-                let def = self.save_ctxt.get_path_def(hir_expr.id);\n+                let node_id = self.save_ctxt.tcx.hir().hir_to_node_id(hir_expr.hir_id);\n+                let def = self.save_ctxt.get_path_def(node_id);\n                 self.process_struct_lit(ex, path, fields, adt.variant_of_def(def), base)\n             }\n             ast::ExprKind::MethodCall(ref seg, ref args) => self.process_method_call(ex, seg, args),"}, {"sha": "e5ab7ba1de946b07f1d365e9a1a5ec83d28e8cac", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -885,7 +885,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             let msg = format!(\"associated type `{}` is private\", binding.item_name);\n             tcx.sess.span_err(binding.span, &msg);\n         }\n-        tcx.check_stability(assoc_ty.def_id, Some(ref_id), binding.span);\n+        tcx.check_stability(assoc_ty.def_id, Some(hir_ref_id), binding.span);\n \n         if !speculative {\n             dup_bindings.entry(assoc_ty.def_id)\n@@ -1276,7 +1276,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n     ) -> (Ty<'tcx>, Def) {\n         let tcx = self.tcx();\n         let assoc_ident = assoc_segment.ident;\n-        let ref_id = tcx.hir().hir_to_node_id(hir_ref_id);\n \n         debug!(\"associated_path_to_ty: {:?}::{}\", qself_ty, assoc_ident);\n \n@@ -1293,7 +1292,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                     let def = Def::Variant(variant_def.did);\n                     if permit_variants {\n                         check_type_alias_enum_variants_enabled(tcx, span);\n-                        tcx.check_stability(variant_def.did, Some(ref_id), span);\n+                        tcx.check_stability(variant_def.did, Some(hir_ref_id), span);\n                         return (qself_ty, def);\n                     } else {\n                         variant_resolution = Some(def);\n@@ -1385,7 +1384,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             let msg = format!(\"{} `{}` is private\", def.kind_name(), assoc_ident);\n             tcx.sess.span_err(span, &msg);\n         }\n-        tcx.check_stability(item.def_id, Some(ref_id), span);\n+        tcx.check_stability(item.def_id, Some(hir_ref_id), span);\n \n         if let Some(variant_def) = variant_resolution {\n             let mut err = tcx.struct_span_lint_hir("}, {"sha": "7c53cb05391cce3ce099b4ce6e070c5304695fb3", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -64,7 +64,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n             PatKind::Path(ref qpath) => {\n-                let (def, _, _) = self.resolve_ty_and_def_ufcs(qpath, pat.id, pat.span);\n+                let (def, _, _) = self.resolve_ty_and_def_ufcs(qpath, pat.hir_id, pat.span);\n                 match def {\n                     Def::Const(..) | Def::AssociatedConst(..) => false,\n                     _ => true,\n@@ -630,7 +630,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n \n         if self.diverges.get().always() {\n             for arm in arms {\n-                self.warn_if_unreachable(arm.body.id, arm.body.span, \"arm\");\n+                self.warn_if_unreachable(arm.body.hir_id, arm.body.span, \"arm\");\n             }\n         }\n \n@@ -725,7 +725,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                 let cause = if i == 0 {\n                     // The reason for the first arm to fail is not that the match arms diverge,\n                     // but rather that there's a prior obligation that doesn't hold.\n-                    self.cause(arm_span, ObligationCauseCode::BlockTailExpression(arm.body.id))\n+                    self.cause(arm_span, ObligationCauseCode::BlockTailExpression(arm.body.hir_id))\n                 } else {\n                     self.cause(expr.span, ObligationCauseCode::MatchExpressionArm {\n                         arm_span,\n@@ -761,7 +761,8 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n     ) -> Ty<'tcx>\n     {\n         // Resolve the path and check the definition for errors.\n-        let (variant, pat_ty) = if let Some(variant_ty) = self.check_struct_path(qpath, pat.id) {\n+        let (variant, pat_ty) = if let Some(variant_ty) = self.check_struct_path(qpath, pat.hir_id)\n+        {\n             variant_ty\n         } else {\n             for field in fields {\n@@ -779,7 +780,8 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         self.demand_eqtype_pat(pat.span, expected, pat_ty, match_discrim_span);\n \n         // Type-check subpatterns.\n-        if self.check_struct_pat_fields(pat_ty, pat.id, pat.span, variant, fields, etc, def_bm) {\n+        if self.check_struct_pat_fields(pat_ty, pat.hir_id, pat.span, variant, fields, etc, def_bm)\n+        {\n             pat_ty\n         } else {\n             self.tcx.types.err\n@@ -795,7 +797,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         let tcx = self.tcx;\n \n         // Resolve the path and check the definition for errors.\n-        let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(qpath, pat.id, pat.span);\n+        let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(qpath, pat.hir_id, pat.span);\n         match def {\n             Def::Err => {\n                 self.set_tainted_by_errors();\n@@ -818,7 +820,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         }\n \n         // Type-check the path.\n-        let pat_ty = self.instantiate_value_path(segments, opt_ty, def, pat.span, pat.id).0;\n+        let pat_ty = self.instantiate_value_path(segments, opt_ty, def, pat.span, pat.hir_id).0;\n         self.demand_suptype(pat.span, expected, pat_ty);\n         pat_ty\n     }\n@@ -849,15 +851,16 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         };\n \n         // Resolve the path and check the definition for errors.\n-        let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(qpath, pat.id, pat.span);\n+        let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(qpath, pat.hir_id, pat.span);\n         if def == Def::Err {\n             self.set_tainted_by_errors();\n             on_error();\n             return self.tcx.types.err;\n         }\n \n         // Type-check the path.\n-        let (pat_ty, def) = self.instantiate_value_path(segments, opt_ty, def, pat.span, pat.id);\n+        let (pat_ty, def) = self.instantiate_value_path(segments, opt_ty, def, pat.span,\n+            pat.hir_id);\n         if !pat_ty.is_fn() {\n             report_unexpected_def(def);\n             return self.tcx.types.err;\n@@ -897,7 +900,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                 let field_ty = self.field_ty(subpat.span, &variant.fields[i], substs);\n                 self.check_pat_walk(&subpat, field_ty, def_bm, match_arm_pat_span);\n \n-                self.tcx.check_stability(variant.fields[i].did, Some(pat.id), subpat.span);\n+                self.tcx.check_stability(variant.fields[i].did, Some(pat.hir_id), subpat.span);\n             }\n         } else {\n             let subpats_ending = if subpats.len() == 1 { \"\" } else { \"s\" };\n@@ -917,7 +920,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n \n     fn check_struct_pat_fields(&self,\n                                adt_ty: Ty<'tcx>,\n-                               pat_id: ast::NodeId,\n+                               pat_id: hir::HirId,\n                                span: Span,\n                                variant: &'tcx ty::VariantDef,\n                                fields: &'gcx [Spanned<hir::FieldPat>],\n@@ -963,7 +966,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                     vacant.insert(span);\n                     field_map.get(&ident)\n                         .map(|(i, f)| {\n-                            self.write_field_index(field.id, *i);\n+                            self.write_field_index(field.hir_id, *i);\n                             self.tcx.check_stability(f.did, Some(pat_id), span);\n                             self.field_ty(span, f, substs)\n                         })"}, {"sha": "79dcb9a9305cd8374c1928a8acb62e6a41924753", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -250,7 +250,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 if let &ty::Adt(adt_def, ..) = t {\n                     if adt_def.is_enum() {\n                         if let hir::ExprKind::Call(ref expr, _) = call_expr.node {\n-                            unit_variant = Some(self.tcx.hir().node_to_pretty_string(expr.id))\n+                            unit_variant = Some(self.tcx.hir().hir_to_pretty_string(expr.hir_id))\n                         }\n                     }\n                 }"}, {"sha": "97ee973938ccbbe1e1d4b2d664ea069bbf55f600", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -399,9 +399,9 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         } else {\n             (\"\", lint::builtin::TRIVIAL_CASTS)\n         };\n-        let mut err = fcx.tcx.struct_span_lint_node(\n+        let mut err = fcx.tcx.struct_span_lint_hir(\n             lint,\n-            self.expr.id,\n+            self.expr.hir_id,\n             self.span,\n             &format!(\"trivial {}cast: `{}` as `{}`\",\n                      adjective,\n@@ -417,7 +417,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         self.cast_ty = fcx.structurally_resolved_type(self.span, self.cast_ty);\n \n         debug!(\"check_cast({}, {:?} as {:?})\",\n-               self.expr.id,\n+               self.expr.hir_id,\n                self.expr_ty,\n                self.cast_ty);\n "}, {"sha": "5cf767abfc512a71d6ecc89b25dadd347decc625", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -72,7 +72,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             opt_kind, expected_sig\n         );\n \n-        let expr_def_id = self.tcx.hir().local_def_id(expr.id);\n+        let expr_def_id = self.tcx.hir().local_def_id_from_hir_id(expr.hir_id);\n \n         let ClosureSignatures {\n             bound_sig,\n@@ -131,8 +131,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let closure_type = self.tcx.mk_closure(expr_def_id, substs);\n \n         debug!(\n-            \"check_closure: expr.id={:?} closure_type={:?}\",\n-            expr.id, closure_type\n+            \"check_closure: expr.hir_id={:?} closure_type={:?}\",\n+            expr.hir_id, closure_type\n         );\n \n         // Tuple up the arguments and insert the resulting function type into"}, {"sha": "62c6ab8da24a053e13a8f7d68da9ab8b7fbe1531", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -1177,7 +1177,8 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                         Expressions::UpFront(coercion_sites) => {\n                             // if the user gave us an array to validate, check that we got\n                             // the next expression in the list, as expected\n-                            assert_eq!(coercion_sites[self.pushed].as_coercion_site().id, e.id);\n+                            assert_eq!(coercion_sites[self.pushed].as_coercion_site().hir_id,\n+                                       e.hir_id);\n                         }\n                     }\n                     self.pushed += 1;\n@@ -1208,7 +1209,7 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                         db.span_label(cause.span, \"return type is not `()`\");\n                     }\n                     ObligationCauseCode::BlockTailExpression(blk_id) => {\n-                        let parent_id = fcx.tcx.hir().get_parent_node(blk_id);\n+                        let parent_id = fcx.tcx.hir().get_parent_node_by_hir_id(blk_id);\n                         db = self.report_return_mismatched_types(\n                             cause,\n                             expected,\n@@ -1246,8 +1247,8 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n         found: Ty<'tcx>,\n         err: TypeError<'tcx>,\n         fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n-        id: syntax::ast::NodeId,\n-        expression: Option<(&'gcx hir::Expr, syntax::ast::NodeId)>,\n+        id: hir::HirId,\n+        expression: Option<(&'gcx hir::Expr, hir::HirId)>,\n     ) -> DiagnosticBuilder<'a> {\n         let mut db = fcx.report_mismatched_types(cause, expected, found, err);\n \n@@ -1257,7 +1258,7 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n         // Verify that this is a tail expression of a function, otherwise the\n         // label pointing out the cause for the type coercion will be wrong\n         // as prior return coercions would not be relevant (#57664).\n-        let parent_id = fcx.tcx.hir().get_parent_node(id);\n+        let parent_id = fcx.tcx.hir().get_parent_node_by_hir_id(id);\n         let fn_decl = if let Some((expr, blk_id)) = expression {\n             pointing_at_return_type = fcx.suggest_mismatched_types_on_tail(\n                 &mut db,\n@@ -1267,7 +1268,7 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                 cause.span,\n                 blk_id,\n             );\n-            let parent = fcx.tcx.hir().get(parent_id);\n+            let parent = fcx.tcx.hir().get_by_hir_id(parent_id);\n             fcx.get_node_fn_decl(parent).map(|(fn_decl, _, is_main)| (fn_decl, is_main))\n         } else {\n             fcx.get_fn_decl(parent_id)"}, {"sha": "ac794c3d6f34deeea9f3cf83632861c51667573e", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -2,7 +2,6 @@ use crate::check::FnCtxt;\n use rustc::infer::InferOk;\n use rustc::traits::{ObligationCause, ObligationCauseCode};\n \n-use syntax::ast;\n use syntax::util::parser::PREC_POSTFIX;\n use syntax_pos::Span;\n use rustc::hir;\n@@ -164,7 +163,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                      probe::Mode::MethodCall,\n                                                      expected,\n                                                      checked_ty,\n-                                                     ast::DUMMY_NODE_ID);\n+                                                     hir::DUMMY_HIR_ID);\n         methods.retain(|m| {\n             self.has_no_input_arg(m) &&\n                 self.tcx.get_attrs(m.def_id).iter()\n@@ -218,15 +217,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             if let hir::def::Def::Local(id) = path.def {\n                 let parent = self.tcx.hir().get_parent_node(id);\n                 if let Some(Node::Expr(hir::Expr {\n-                    id,\n+                    hir_id,\n                     node: hir::ExprKind::Closure(_, decl, ..),\n                     ..\n                 })) = self.tcx.hir().find(parent) {\n-                    let parent = self.tcx.hir().get_parent_node(*id);\n+                    let parent = self.tcx.hir().get_parent_node_by_hir_id(*hir_id);\n                     if let (Some(Node::Expr(hir::Expr {\n                         node: hir::ExprKind::MethodCall(path, span, expr),\n                         ..\n-                    })), 1) = (self.tcx.hir().find(parent), decl.inputs.len()) {\n+                    })), 1) = (self.tcx.hir().find_by_hir_id(parent), decl.inputs.len()) {\n                         let self_ty = self.tables.borrow().node_type(expr[0].hir_id);\n                         let self_ty = format!(\"{:?}\", self_ty);\n                         let name = path.ident.as_str();\n@@ -470,8 +469,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         checked_ty: Ty<'tcx>,\n         expected_ty: Ty<'tcx>,\n     ) -> bool {\n-        let parent_id = self.tcx.hir().get_parent_node(expr.id);\n-        if let Some(parent) = self.tcx.hir().find(parent_id) {\n+        let parent_id = self.tcx.hir().get_parent_node_by_hir_id(expr.hir_id);\n+        if let Some(parent) = self.tcx.hir().find_by_hir_id(parent_id) {\n             // Shouldn't suggest `.into()` on `const`s.\n             if let Node::Item(Item { node: ItemKind::Const(_, _), .. }) = parent {\n                 // FIXME(estebank): modify once we decide to suggest `as` casts\n@@ -501,10 +500,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if let Some(hir::Node::Expr(hir::Expr {\n             node: hir::ExprKind::Struct(_, fields, _),\n             ..\n-        })) = self.tcx.hir().find(self.tcx.hir().get_parent_node(expr.id)) {\n+        })) = self.tcx.hir().find_by_hir_id(self.tcx.hir().get_parent_node_by_hir_id(expr.hir_id)) {\n             // `expr` is a literal field for a struct, only suggest if appropriate\n             for field in fields {\n-                if field.expr.id == expr.id && field.is_shorthand {\n+                if field.expr.hir_id == expr.hir_id && field.is_shorthand {\n                     // This is a field literal\n                     prefix = format!(\"{}: \", field.ident);\n                     break;"}, {"sha": "b14c56ddad008fa03c9ed1c0bb347f1490b918f3", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -105,7 +105,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn method_exists(&self,\n                          method_name: ast::Ident,\n                          self_ty: Ty<'tcx>,\n-                         call_expr_id: ast::NodeId,\n+                         call_expr_id: hir::HirId,\n                          allow_private: bool)\n                          -> bool {\n         let mode = probe::Mode::MethodCall;\n@@ -131,7 +131,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         msg: &str,\n         method_name: ast::Ident,\n         self_ty: Ty<'tcx>,\n-        call_expr_id: ast::NodeId,\n+        call_expr_id: hir::HirId,\n     ) {\n         let has_params = self\n             .probe_for_name(\n@@ -202,7 +202,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 .unwrap().insert(import_def_id);\n         }\n \n-        self.tcx.check_stability(pick.item.def_id, Some(call_expr.id), span);\n+        self.tcx.check_stability(pick.item.def_id, Some(call_expr.hir_id), span);\n \n         let result = self.confirm_method(\n             span,\n@@ -255,7 +255,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let mode = probe::Mode::MethodCall;\n         let self_ty = self.resolve_type_vars_if_possible(&self_ty);\n         self.probe_for_name(span, mode, method_name, IsSuggestion(false),\n-                            self_ty, call_expr.id, scope)\n+                            self_ty, call_expr.hir_id, scope)\n     }\n \n     /// `lookup_method_in_trait` is used for overloaded operators.\n@@ -399,7 +399,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         span: Span,\n         method_name: ast::Ident,\n         self_ty: Ty<'tcx>,\n-        expr_id: ast::NodeId\n+        expr_id: hir::HirId\n     ) -> Result<Def, MethodError<'tcx>> {\n         debug!(\n             \"resolve_ufcs: method_name={:?} self_ty={:?} expr_id={:?}\","}, {"sha": "c6116d58c1e7f00ec9ff2358966853699c67d00b", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -209,7 +209,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                  mode: Mode,\n                                  return_type: Ty<'tcx>,\n                                  self_ty: Ty<'tcx>,\n-                                 scope_expr_id: ast::NodeId)\n+                                 scope_expr_id: hir::HirId)\n                                  -> Vec<ty::AssociatedItem> {\n         debug!(\"probe(self_ty={:?}, return_type={}, scope_expr_id={})\",\n                self_ty,\n@@ -238,7 +238,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                           item_name: ast::Ident,\n                           is_suggestion: IsSuggestion,\n                           self_ty: Ty<'tcx>,\n-                          scope_expr_id: ast::NodeId,\n+                          scope_expr_id: hir::HirId,\n                           scope: ProbeScope)\n                           -> PickResult<'tcx> {\n         debug!(\"probe(self_ty={:?}, item_name={}, scope_expr_id={})\",\n@@ -263,7 +263,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                       return_type: Option<Ty<'tcx>>,\n                       is_suggestion: IsSuggestion,\n                       self_ty: Ty<'tcx>,\n-                      scope_expr_id: ast::NodeId,\n+                      scope_expr_id: hir::HirId,\n                       scope: ProbeScope,\n                       op: OP)\n                       -> Result<R, MethodError<'tcx>>\n@@ -340,7 +340,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                               \"the type of this value must be known \\\n                                to call a method on a raw pointer on it\");\n                 } else {\n-                   self.tcx.lint_node(\n+                   self.tcx.lint_hir(\n                         lint::builtin::TYVAR_BEHIND_RAW_POINTER,\n                         scope_expr_id,\n                         span,\n@@ -825,13 +825,12 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     }\n \n     fn assemble_extension_candidates_for_traits_in_scope(&mut self,\n-                                                         expr_id: ast::NodeId)\n+                                                         expr_hir_id: hir::HirId)\n                                                          -> Result<(), MethodError<'tcx>> {\n-        if expr_id == ast::DUMMY_NODE_ID {\n+        if expr_hir_id == hir::DUMMY_HIR_ID {\n             return Ok(())\n         }\n         let mut duplicates = FxHashSet::default();\n-        let expr_hir_id = self.tcx.hir().node_to_hir_id(expr_id);\n         let opt_applicable_traits = self.tcx.in_scope_traits(expr_hir_id);\n         if let Some(applicable_traits) = opt_applicable_traits {\n             for trait_candidate in applicable_traits.iter() {\n@@ -1415,7 +1414,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                                             steps, IsSuggestion(true));\n             pcx.allow_similar_names = true;\n             pcx.assemble_inherent_candidates();\n-            pcx.assemble_extension_candidates_for_traits_in_scope(ast::DUMMY_NODE_ID)?;\n+            pcx.assemble_extension_candidates_for_traits_in_scope(hir::DUMMY_HIR_ID)?;\n \n             let method_names = pcx.candidate_method_names();\n             pcx.allow_similar_names = false;\n@@ -1425,7 +1424,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                     pcx.reset();\n                     pcx.method_name = Some(method_name);\n                     pcx.assemble_inherent_candidates();\n-                    pcx.assemble_extension_candidates_for_traits_in_scope(ast::DUMMY_NODE_ID)\n+                    pcx.assemble_extension_candidates_for_traits_in_scope(hir::DUMMY_HIR_ID)\n                         .ok().map_or(None, |_| {\n                             pcx.pick_core()\n                                 .and_then(|pick| pick.ok())"}, {"sha": "0ff3b613fe7a99403e70800e7f7da10c342ddb72", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 66, "deletions": 65, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -137,7 +137,7 @@ use crate::TypeAndSubsts;\n use crate::lint;\n use crate::util::captures::Captures;\n use crate::util::common::{ErrorReported, indenter};\n-use crate::util::nodemap::{DefIdMap, DefIdSet, FxHashMap, FxHashSet, NodeMap};\n+use crate::util::nodemap::{DefIdMap, DefIdSet, FxHashMap, FxHashSet, HirIdMap, NodeMap};\n \n pub use self::Expectation::*;\n use self::autoderef::Autoderef;\n@@ -497,11 +497,11 @@ pub struct BreakableCtxt<'gcx: 'tcx, 'tcx> {\n \n pub struct EnclosingBreakables<'gcx: 'tcx, 'tcx> {\n     stack: Vec<BreakableCtxt<'gcx, 'tcx>>,\n-    by_id: NodeMap<usize>,\n+    by_id: HirIdMap<usize>,\n }\n \n impl<'gcx, 'tcx> EnclosingBreakables<'gcx, 'tcx> {\n-    fn find_breakable(&mut self, target_id: ast::NodeId) -> &mut BreakableCtxt<'gcx, 'tcx> {\n+    fn find_breakable(&mut self, target_id: hir::HirId) -> &mut BreakableCtxt<'gcx, 'tcx> {\n         let ix = *self.by_id.get(&target_id).unwrap_or_else(|| {\n             bug!(\"could not find enclosing breakable with id {}\", target_id);\n         });\n@@ -2049,13 +2049,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     /// Produces warning on the given node, if the current point in the\n     /// function is unreachable, and there hasn't been another warning.\n-    fn warn_if_unreachable(&self, id: ast::NodeId, span: Span, kind: &str) {\n+    fn warn_if_unreachable(&self, id: hir::HirId, span: Span, kind: &str) {\n         if self.diverges.get() == Diverges::Always {\n             self.diverges.set(Diverges::WarnedAlways);\n \n             debug!(\"warn_if_unreachable: id={:?} span={:?} kind={}\", id, span, kind);\n \n-            self.tcx().lint_node(\n+            self.tcx().lint_hir(\n                 lint::builtin::UNREACHABLE_CODE,\n                 id, span,\n                 &format!(\"unreachable {}\", kind));\n@@ -2143,8 +2143,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn write_field_index(&self, node_id: ast::NodeId, index: usize) {\n-        let hir_id = self.tcx.hir().node_to_hir_id(node_id);\n+    pub fn write_field_index(&self, hir_id: hir::HirId, index: usize) {\n         self.tables.borrow_mut().field_indices_mut().insert(hir_id, index);\n     }\n \n@@ -3007,7 +3006,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // Closure arguments themselves can't be diverging, but\n                 // a previous argument can, e.g., `foo(panic!(), || {})`.\n                 if !check_closures {\n-                    self.warn_if_unreachable(arg.id, arg.span, \"expression\");\n+                    self.warn_if_unreachable(arg.hir_id, arg.span, \"expression\");\n                 }\n \n                 let is_closure = match arg.node {\n@@ -3338,7 +3337,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         ret_coercion.borrow_mut()\n                     .coerce(self,\n                             &self.cause(return_expr.span,\n-                                        ObligationCauseCode::ReturnType(return_expr.id)),\n+                                        ObligationCauseCode::ReturnType(return_expr.hir_id)),\n                             return_expr,\n                             return_expr_ty);\n     }\n@@ -3509,13 +3508,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         let field_ty = self.field_ty(expr.span, field, substs);\n                         // Save the index of all fields regardless of their visibility in case\n                         // of error recovery.\n-                        self.write_field_index(expr.id, index);\n+                        self.write_field_index(expr.hir_id, index);\n                         if field.vis.is_accessible_from(def_scope, self.tcx) {\n                             let adjustments = autoderef.adjust_steps(self, needs);\n                             self.apply_adjustments(base, adjustments);\n                             autoderef.finalize(self);\n \n-                            self.tcx.check_stability(field.did, Some(expr.id), expr.span);\n+                            self.tcx.check_stability(field.did, Some(expr.hir_id), expr.span);\n                             return field_ty;\n                         }\n                         private_candidate = Some((base_def.did, field_ty));\n@@ -3530,7 +3529,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 self.apply_adjustments(base, adjustments);\n                                 autoderef.finalize(self);\n \n-                                self.write_field_index(expr.id, index);\n+                                self.write_field_index(expr.hir_id, index);\n                                 return field_ty;\n                             }\n                         }\n@@ -3547,31 +3546,33 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                            \"field `{}` of struct `{}` is private\",\n                                            field, struct_path);\n             // Also check if an accessible method exists, which is often what is meant.\n-            if self.method_exists(field, expr_t, expr.id, false) && !self.expr_in_place(expr.id) {\n+            if self.method_exists(field, expr_t, expr.hir_id, false)\n+                && !self.expr_in_place(expr.hir_id)\n+            {\n                 self.suggest_method_call(\n                     &mut err,\n                     &format!(\"a method `{}` also exists, call it with parentheses\", field),\n                     field,\n                     expr_t,\n-                    expr.id,\n+                    expr.hir_id,\n                 );\n             }\n             err.emit();\n             field_ty\n         } else if field.name == keywords::Invalid.name() {\n             self.tcx().types.err\n-        } else if self.method_exists(field, expr_t, expr.id, true) {\n+        } else if self.method_exists(field, expr_t, expr.hir_id, true) {\n             let mut err = type_error_struct!(self.tcx().sess, field.span, expr_t, E0615,\n                                \"attempted to take value of method `{}` on type `{}`\",\n                                field, expr_t);\n \n-            if !self.expr_in_place(expr.id) {\n+            if !self.expr_in_place(expr.hir_id) {\n                 self.suggest_method_call(\n                     &mut err,\n                     \"use parentheses to call the method\",\n                     field,\n                     expr_t,\n-                    expr.id\n+                    expr.hir_id\n                 );\n             } else {\n                 err.help(\"methods are immutable and cannot be assigned to\");\n@@ -3611,7 +3612,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         ) {\n                             let base = self.tcx.sess.source_map()\n                                 .span_to_snippet(base.span)\n-                                .unwrap_or_else(|_| self.tcx.hir().node_to_pretty_string(base.id));\n+                                .unwrap_or_else(|_|\n+                                    self.tcx.hir().hir_to_pretty_string(base.hir_id));\n                             let help = \"instead of using tuple indexing, use array indexing\";\n                             let suggestion = format!(\"{}[{}]\", base, field);\n                             let applicability = if len < user_index {\n@@ -3627,7 +3629,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     ty::RawPtr(..) => {\n                         let base = self.tcx.sess.source_map()\n                             .span_to_snippet(base.span)\n-                            .unwrap_or_else(|_| self.tcx.hir().node_to_pretty_string(base.id));\n+                            .unwrap_or_else(|_| self.tcx.hir().hir_to_pretty_string(base.hir_id));\n                         let msg = format!(\"`{}` is a raw pointer; try dereferencing it\", base);\n                         let suggestion = format!(\"(*{}).{}\", base, field);\n                         err.span_suggestion(\n@@ -3752,7 +3754,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn check_expr_struct_fields(&self,\n                                 adt_ty: Ty<'tcx>,\n                                 expected: Expectation<'tcx>,\n-                                expr_id: ast::NodeId,\n+                                expr_id: hir::HirId,\n                                 span: Span,\n                                 variant: &'tcx ty::VariantDef,\n                                 ast_fields: &'gcx [hir::Field],\n@@ -3785,7 +3787,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let ident = tcx.adjust_ident(field.ident, variant.did, self.body_id).0;\n             let field_type = if let Some((i, v_field)) = remaining_fields.remove(&ident) {\n                 seen_fields.insert(ident, field.span);\n-                self.write_field_index(field.id, i);\n+                self.write_field_index(field.hir_id, i);\n \n                 // We don't look at stability attributes on\n                 // struct-like enums (yet...), but it's definitely not\n@@ -3873,13 +3875,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn check_struct_path(&self,\n                              qpath: &QPath,\n-                             node_id: ast::NodeId)\n+                             hir_id: hir::HirId)\n                              -> Option<(&'tcx ty::VariantDef,  Ty<'tcx>)> {\n         let path_span = match *qpath {\n             QPath::Resolved(_, ref path) => path.span,\n             QPath::TypeRelative(ref qself, _) => qself.span\n         };\n-        let (def, ty) = self.finish_resolving_struct_path(qpath, path_span, node_id);\n+        let (def, ty) = self.finish_resolving_struct_path(qpath, path_span, hir_id);\n         let variant = match def {\n             Def::Err => {\n                 self.set_tainted_by_errors();\n@@ -3907,7 +3909,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         if let Some((variant, did, substs)) = variant {\n             debug!(\"check_struct_path: did={:?} substs={:?}\", did, substs);\n-            let hir_id = self.tcx.hir().node_to_hir_id(node_id);\n             self.write_user_type_annotation_from_substs(hir_id, did, substs, None);\n \n             // Check bounds on type arguments used in the path.\n@@ -3936,7 +3937,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     {\n         // Find the relevant variant\n         let (variant, adt_ty) =\n-            if let Some(variant_ty) = self.check_struct_path(qpath, expr.id) {\n+            if let Some(variant_ty) = self.check_struct_path(qpath, expr.hir_id) {\n                 variant_ty\n             } else {\n                 self.check_struct_fields_on_error(fields, base_expr);\n@@ -3956,7 +3957,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                       adt.variant_descr());\n         }\n \n-        let error_happened = self.check_expr_struct_fields(adt_ty, expected, expr.id, path_span,\n+        let error_happened = self.check_expr_struct_fields(adt_ty, expected, expr.hir_id, path_span,\n                                                            variant, fields, base_expr.is_none());\n         if let &Some(ref base_expr) = base_expr {\n             // If check_expr_struct_fields hit an error, do not attempt to populate\n@@ -4005,7 +4006,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                expr, expected);\n \n         // Warn for expressions after diverging siblings.\n-        self.warn_if_unreachable(expr.id, expr.span, \"expression\");\n+        self.warn_if_unreachable(expr.hir_id, expr.span, \"expression\");\n \n         // Hide the outer diverging and has_errors flags.\n         let old_diverges = self.diverges.get();\n@@ -4021,7 +4022,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             ExprKind::Loop(..) | ExprKind::While(..) |\n             ExprKind::If(..) | ExprKind::Match(..) => {}\n \n-            _ => self.warn_if_unreachable(expr.id, expr.span, \"expression\")\n+            _ => self.warn_if_unreachable(expr.hir_id, expr.span, \"expression\")\n         }\n \n         // Any expression that produces a value of type `!` must have diverged\n@@ -4038,7 +4039,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.diverges.set(self.diverges.get() | old_diverges);\n         self.has_errors.set(self.has_errors.get() | old_has_errors);\n \n-        debug!(\"type of {} is...\", self.tcx.hir().node_to_string(expr.id));\n+        debug!(\"type of {} is...\", self.tcx.hir().hir_to_string(expr.hir_id));\n         debug!(\"... {:?}, expected is {:?}\", ty, expected);\n \n         ty\n@@ -4058,7 +4059,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         );\n \n         let tcx = self.tcx;\n-        let id = expr.id;\n+        let id = expr.hir_id;\n         match expr.node {\n             ExprKind::Box(ref subexpr) => {\n                 let expected_inner = expected.to_option(self).map_or(NoExpectation, |ty| {\n@@ -4190,7 +4191,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n             ExprKind::Path(ref qpath) => {\n-                let (def, opt_ty, segs) = self.resolve_ty_and_def_ufcs(qpath, expr.id, expr.span);\n+                let (def, opt_ty, segs) = self.resolve_ty_and_def_ufcs(qpath, expr.hir_id,\n+                    expr.span);\n                 let ty = match def {\n                     Def::Err => {\n                         self.set_tainted_by_errors();\n@@ -4255,6 +4257,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n             ExprKind::Break(destination, ref expr_opt) => {\n                 if let Ok(target_id) = destination.target_id {\n+                    let target_id = tcx.hir().node_to_hir_id(target_id);\n                     let (e_ty, cause);\n                     if let Some(ref e) = *expr_opt {\n                         // If this is a break with a value, we need to type-check\n@@ -4360,7 +4363,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         *self.ret_coercion_span.borrow_mut() = Some(expr.span);\n                     }\n                     let cause = self.cause(expr.span, ObligationCauseCode::ReturnNoExpression);\n-                    if let Some((fn_decl, _)) = self.get_fn_decl(expr.id) {\n+                    if let Some((fn_decl, _)) = self.get_fn_decl(expr.hir_id) {\n                         coercion.coerce_forced_unit(\n                             self,\n                             &cause,\n@@ -4422,7 +4425,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     may_break: false,  // Will get updated if/when we find a `break`.\n                 };\n \n-                let (ctxt, ()) = self.with_breakable_ctxt(expr.id, ctxt, || {\n+                let (ctxt, ()) = self.with_breakable_ctxt(expr.hir_id, ctxt, || {\n                     self.check_expr_has_type_or_error(&cond, tcx.types.bool);\n                     let cond_diverging = self.diverges.get();\n                     self.check_block_no_value(&body);\n@@ -4458,7 +4461,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     may_break: false, // Will get updated if/when we find a `break`.\n                 };\n \n-                let (ctxt, ()) = self.with_breakable_ctxt(expr.id, ctxt, || {\n+                let (ctxt, ()) = self.with_breakable_ctxt(expr.hir_id, ctxt, || {\n                     self.check_block_no_value(&body);\n                 });\n \n@@ -4715,7 +4718,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn finish_resolving_struct_path(&self,\n                                     qpath: &QPath,\n                                     path_span: Span,\n-                                    node_id: ast::NodeId)\n+                                    hir_id: hir::HirId)\n                                     -> (Def, Ty<'tcx>)\n     {\n         match *qpath {\n@@ -4732,12 +4735,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 } else {\n                     Def::Err\n                 };\n-                let hir_id = self.tcx.hir().node_to_hir_id(node_id);\n                 let (ty, def) = AstConv::associated_path_to_ty(self, hir_id, path_span,\n                                                                ty, def, segment, true);\n \n                 // Write back the new resolution.\n-                let hir_id = self.tcx.hir().node_to_hir_id(node_id);\n                 self.tables.borrow_mut().type_dependent_defs_mut().insert(hir_id, def);\n \n                 (def, ty)\n@@ -4749,11 +4750,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// definition. The newly resolved definition is written into `type_dependent_defs`.\n     pub fn resolve_ty_and_def_ufcs<'b>(&self,\n                                        qpath: &'b QPath,\n-                                       node_id: ast::NodeId,\n+                                       hir_id: hir::HirId,\n                                        span: Span)\n                                        -> (Def, Option<Ty<'tcx>>, &'b [hir::PathSegment])\n     {\n-        debug!(\"resolve_ty_and_def_ufcs: qpath={:?} node_id={:?} span={:?}\", qpath, node_id, span);\n+        debug!(\"resolve_ty_and_def_ufcs: qpath={:?} hir_id={:?} span={:?}\", qpath, hir_id, span);\n         let (ty, qself, item_segment) = match *qpath {\n             QPath::Resolved(ref opt_qself, ref path) => {\n                 return (path.def,\n@@ -4764,14 +4765,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 (self.to_ty(qself), qself, segment)\n             }\n         };\n-        let hir_id = self.tcx.hir().node_to_hir_id(node_id);\n         if let Some(cached_def) = self.tables.borrow().type_dependent_defs().get(hir_id) {\n             // Return directly on cache hit. This is useful to avoid doubly reporting\n             // errors with default match binding modes. See #44614.\n             return (*cached_def, Some(ty), slice::from_ref(&**item_segment))\n         }\n         let item_name = item_segment.ident;\n-        let def = match self.resolve_ufcs(span, item_name, ty, node_id) {\n+        let def = match self.resolve_ufcs(span, item_name, ty, hir_id) {\n             Ok(def) => def,\n             Err(error) => {\n                 let def = match error {\n@@ -4853,7 +4853,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             hir::StmtKind::Local(..) | hir::StmtKind::Expr(..) | hir::StmtKind::Semi(..) => {}\n         }\n \n-        self.warn_if_unreachable(stmt.id, stmt.span, \"statement\");\n+        self.warn_if_unreachable(stmt.hir_id, stmt.span, \"statement\");\n \n         // Hide the outer diverging and `has_errors` flags.\n         let old_diverges = self.diverges.get();\n@@ -4935,8 +4935,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             may_break: false,\n         };\n \n-        let blk_node_id = self.tcx.hir().hir_to_node_id(blk.hir_id);\n-        let (ctxt, ()) = self.with_breakable_ctxt(blk_node_id, ctxt, || {\n+        let (ctxt, ()) = self.with_breakable_ctxt(blk.hir_id, ctxt, || {\n             for s in &blk.stmts {\n                 self.check_stmt(s);\n             }\n@@ -4946,12 +4945,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let tail_expr_ty = tail_expr.map(|t| self.check_expr_with_expectation(t, expected));\n \n             let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n-            let ctxt = enclosing_breakables.find_breakable(blk_node_id);\n+            let ctxt = enclosing_breakables.find_breakable(blk.hir_id);\n             let coerce = ctxt.coerce.as_mut().unwrap();\n             if let Some(tail_expr_ty) = tail_expr_ty {\n                 let tail_expr = tail_expr.unwrap();\n                 let cause = self.cause(tail_expr.span,\n-                                       ObligationCauseCode::BlockTailExpression(blk_node_id));\n+                                       ObligationCauseCode::BlockTailExpression(blk.hir_id));\n                 coerce.coerce(self,\n                               &cause,\n                               tail_expr,\n@@ -4975,6 +4974,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // that highlight errors inline.\n                     let mut sp = blk.span;\n                     let mut fn_span = None;\n+                    let blk_node_id = self.tcx.hir().hir_to_node_id(blk.hir_id);\n                     if let Some((decl, ident)) = self.get_parent_fn_decl(blk_node_id) {\n                         let ret_sp = decl.output.span();\n                         if let Some(block_sp) = self.parent_item_span(blk_node_id) {\n@@ -5067,13 +5067,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Given a `NodeId`, return the `FnDecl` of the method it is enclosed by and whether a\n+    /// Given a `HirId`, return the `FnDecl` of the method it is enclosed by and whether a\n     /// suggestion can be made, `None` otherwise.\n-    pub fn get_fn_decl(&self, blk_id: ast::NodeId) -> Option<(hir::FnDecl, bool)> {\n+    pub fn get_fn_decl(&self, blk_id: hir::HirId) -> Option<(hir::FnDecl, bool)> {\n         // Get enclosing Fn, if it is a function or a trait method, unless there's a `loop` or\n         // `while` before reaching it, as block tail returns are not available in them.\n         self.tcx.hir().get_return_block(blk_id).and_then(|blk_id| {\n-            let parent = self.tcx.hir().get(blk_id);\n+            let parent = self.tcx.hir().get_by_hir_id(blk_id);\n             self.get_node_fn_decl(parent).map(|(fn_decl, _, is_main)| (fn_decl, is_main))\n         })\n     }\n@@ -5090,7 +5090,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n         cause_span: Span,\n-        blk_id: ast::NodeId,\n+        blk_id: hir::HirId,\n     ) -> bool {\n         self.suggest_missing_semicolon(err, expression, expected, cause_span);\n         let mut pointing_at_return_type = false;\n@@ -5303,14 +5303,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                   self_ty: Option<Ty<'tcx>>,\n                                   def: Def,\n                                   span: Span,\n-                                  node_id: ast::NodeId)\n+                                  hir_id: hir::HirId)\n                                   -> (Ty<'tcx>, Def) {\n         debug!(\n-            \"instantiate_value_path(segments={:?}, self_ty={:?}, def={:?}, node_id={})\",\n+            \"instantiate_value_path(segments={:?}, self_ty={:?}, def={:?}, hir_id={})\",\n             segments,\n             self_ty,\n             def,\n-            node_id,\n+            hir_id,\n         );\n \n         let tcx = self.tcx;\n@@ -5380,7 +5380,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Def::Local(nid) | Def::Upvar(nid, ..) => {\n                 let ty = self.local_ty(span, nid).decl_ty;\n                 let ty = self.normalize_associated_types_in(span, &ty);\n-                self.write_ty(tcx.hir().node_to_hir_id(node_id), ty);\n+                self.write_ty(hir_id, ty);\n                 return (ty, def);\n             }\n             _ => {}\n@@ -5532,7 +5532,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         assert!(!ty.has_escaping_bound_vars());\n \n         // First, store the \"user substs\" for later.\n-        let hir_id = tcx.hir().node_to_hir_id(node_id);\n         self.write_user_type_annotation_from_substs(hir_id, def_id, substs, user_self_ty);\n \n         // Add all the obligations that are required, substituting and\n@@ -5566,10 +5565,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        self.check_rustc_args_require_const(def_id, node_id, span);\n+        self.check_rustc_args_require_const(def_id, hir_id, span);\n \n         debug!(\"instantiate_value_path: type of {:?} is {:?}\",\n-               node_id,\n+               hir_id,\n                ty_substituted);\n         self.write_substs(hir_id, substs);\n \n@@ -5578,7 +5577,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn check_rustc_args_require_const(&self,\n                                       def_id: DefId,\n-                                      node_id: ast::NodeId,\n+                                      hir_id: hir::HirId,\n                                       span: Span) {\n         // We're only interested in functions tagged with\n         // #[rustc_args_required_const], so ignore anything that's not.\n@@ -5588,9 +5587,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // If our calling expression is indeed the function itself, we're good!\n         // If not, generate an error that this can only be called directly.\n-        if let Node::Expr(expr) = self.tcx.hir().get(self.tcx.hir().get_parent_node(node_id)) {\n+        if let Node::Expr(expr) = self.tcx.hir().get_by_hir_id(\n+            self.tcx.hir().get_parent_node_by_hir_id(hir_id))\n+        {\n             if let ExprKind::Call(ref callee, ..) = expr.node {\n-                if callee.id == node_id {\n+                if callee.hir_id == hir_id {\n                     return\n                 }\n             }\n@@ -5618,7 +5619,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn with_breakable_ctxt<F: FnOnce() -> R, R>(&self, id: ast::NodeId,\n+    fn with_breakable_ctxt<F: FnOnce() -> R, R>(&self, id: hir::HirId,\n                                                 ctxt: BreakableCtxt<'gcx, 'tcx>, f: F)\n                                                 -> (BreakableCtxt<'gcx, 'tcx>, R) {\n         let index;\n@@ -5655,22 +5656,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Returns `true` if an expression is contained inside the LHS of an assignment expression.\n-    fn expr_in_place(&self, mut expr_id: ast::NodeId) -> bool {\n+    fn expr_in_place(&self, mut expr_id: hir::HirId) -> bool {\n         let mut contained_in_place = false;\n \n         while let hir::Node::Expr(parent_expr) =\n-            self.tcx.hir().get(self.tcx.hir().get_parent_node(expr_id))\n+            self.tcx.hir().get_by_hir_id(self.tcx.hir().get_parent_node_by_hir_id(expr_id))\n         {\n             match &parent_expr.node {\n                 hir::ExprKind::Assign(lhs, ..) | hir::ExprKind::AssignOp(_, lhs, ..) => {\n-                    if lhs.id == expr_id {\n+                    if lhs.hir_id == expr_id {\n                         contained_in_place = true;\n                         break;\n                     }\n                 }\n                 _ => (),\n             }\n-            expr_id = parent_expr.id;\n+            expr_id = parent_expr.hir_id;\n         }\n \n         contained_in_place"}, {"sha": "284c8d1b7c42756a4c0183293f29997ec59d3c7e", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -51,8 +51,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     {\n         let tcx = self.tcx;\n \n-        debug!(\"check_binop(expr.id={}, expr={:?}, op={:?}, lhs_expr={:?}, rhs_expr={:?})\",\n-               expr.id,\n+        debug!(\"check_binop(expr.hir_id={}, expr={:?}, op={:?}, lhs_expr={:?}, rhs_expr={:?})\",\n+               expr.hir_id,\n                expr,\n                op,\n                lhs_expr,\n@@ -150,8 +150,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                               is_assign: IsAssign)\n                               -> (Ty<'tcx>, Ty<'tcx>, Ty<'tcx>)\n     {\n-        debug!(\"check_overloaded_binop(expr.id={}, op={:?}, is_assign={:?})\",\n-               expr.id,\n+        debug!(\"check_overloaded_binop(expr.hir_id={}, op={:?}, is_assign={:?})\",\n+               expr.hir_id,\n                op,\n                is_assign);\n "}, {"sha": "bf4df19556d0277736601ee70b26bf739cb01db7", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -694,8 +694,8 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n             hir::ExprKind::Ret(Some(ref ret_expr)) => {\n                 let call_site_scope = self.call_site_scope;\n                 debug!(\n-                    \"visit_expr ExprKind::Ret ret_expr.id {} call_site_scope: {:?}\",\n-                    ret_expr.id, call_site_scope\n+                    \"visit_expr ExprKind::Ret ret_expr.hir_id {} call_site_scope: {:?}\",\n+                    ret_expr.hir_id, call_site_scope\n                 );\n                 let call_site_region = self.tcx.mk_region(ty::ReScope(call_site_scope.unwrap()));\n                 self.type_of_node_must_outlive("}, {"sha": "ffeef84c4176149c5569fa6b219c882a969ca9a0", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -67,7 +67,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for InferBorrowKindVisitor<'a, 'gcx, 'tcx> {\n             let body = self.fcx.tcx.hir().body(body_id);\n             self.visit_body(body);\n             self.fcx\n-                .analyze_closure(expr.id, expr.hir_id, expr.span, body, cc);\n+                .analyze_closure(expr.hir_id, expr.span, body, cc);\n         }\n \n         intravisit::walk_expr(self, expr);\n@@ -77,7 +77,6 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for InferBorrowKindVisitor<'a, 'gcx, 'tcx> {\n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn analyze_closure(\n         &self,\n-        closure_node_id: ast::NodeId,\n         closure_hir_id: hir::HirId,\n         span: Span,\n         body: &hir::Body,\n@@ -89,7 +88,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         debug!(\n             \"analyze_closure(id={:?}, body.id={:?})\",\n-            closure_node_id,\n+            closure_hir_id,\n             body.id()\n         );\n \n@@ -105,7 +104,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 span_bug!(\n                     span,\n                     \"type of closure expr {:?} is not a closure {:?}\",\n-                    closure_node_id,\n+                    closure_hir_id,\n                     t\n                 );\n             }\n@@ -121,6 +120,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             None\n         };\n \n+        let closure_node_id = self.tcx.hir().hir_to_node_id(closure_hir_id);\n+\n         self.tcx.with_freevars(closure_node_id, |freevars| {\n             let mut freevar_list: Vec<ty::UpvarId> = Vec::with_capacity(freevars.len());\n             for freevar in freevars {\n@@ -582,7 +583,7 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'gcx, 'tcx> {\n     fn consume(\n         &mut self,\n-        _consume_id: ast::NodeId,\n+        _consume_id: hir::HirId,\n         _consume_span: Span,\n         cmt: &mc::cmt_<'tcx>,\n         mode: euv::ConsumeMode,\n@@ -611,7 +612,7 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'gcx, 'tcx> {\n \n     fn borrow(\n         &mut self,\n-        borrow_id: ast::NodeId,\n+        borrow_id: hir::HirId,\n         _borrow_span: Span,\n         cmt: &mc::cmt_<'tcx>,\n         _loan_region: ty::Region<'tcx>,\n@@ -638,7 +639,7 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'gcx, 'tcx> {\n \n     fn mutate(\n         &mut self,\n-        _assignment_id: ast::NodeId,\n+        _assignment_id: hir::HirId,\n         _assignment_span: Span,\n         assignee_cmt: &mc::cmt_<'tcx>,\n         _mode: euv::MutateMode,"}, {"sha": "82a12b95d99172d6c6b553c0a1271020ea102570", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -243,11 +243,11 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n             }\n             hir::ExprKind::Struct(_, ref fields, _) => {\n                 for field in fields {\n-                    self.visit_field_id(field.id);\n+                    self.visit_field_id(field.hir_id);\n                 }\n             }\n             hir::ExprKind::Field(..) => {\n-                self.visit_field_id(e.id);\n+                self.visit_field_id(e.hir_id);\n             }\n             _ => {}\n         }\n@@ -273,7 +273,7 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n             }\n             hir::PatKind::Struct(_, ref fields, _) => {\n                 for field in fields {\n-                    self.visit_field_id(field.node.id);\n+                    self.visit_field_id(field.node.hir_id);\n                 }\n             }\n             _ => {}\n@@ -590,8 +590,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn visit_field_id(&mut self, node_id: ast::NodeId) {\n-        let hir_id = self.tcx().hir().node_to_hir_id(node_id);\n+    fn visit_field_id(&mut self, hir_id: hir::HirId) {\n         if let Some(index) = self.fcx\n             .tables\n             .borrow_mut()"}, {"sha": "7587380acf8cb3f4a89edb33496f879dc77b6992", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=d7ced1dd5a6a58ed59b12b693fa1b45aadec0a9c", "patch": "@@ -144,7 +144,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         if let hir::ExprKind::Closure(..) = expr.node {\n-            let def_id = self.tcx.hir().local_def_id(expr.id);\n+            let def_id = self.tcx.hir().local_def_id_from_hir_id(expr.hir_id);\n             self.tcx.generics_of(def_id);\n             self.tcx.type_of(def_id);\n         }"}]}