{"sha": "f86e433b67292150faa9fd978cad487934d90c76", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4NmU0MzNiNjcyOTIxNTBmYWE5ZmQ5NzhjYWQ0ODc5MzRkOTBjNzY=", "commit": {"author": {"name": "Adolfo Ochagav\u00eda", "email": "aochagavia92@gmail.com", "date": "2017-07-08T19:32:29Z"}, "committer": {"name": "Adolfo Ochagav\u00eda", "email": "aochagavia92@gmail.com", "date": "2017-07-12T14:14:47Z"}, "message": "Add regression tests to ensure stable drop order", "tree": {"sha": "7f5a4c0d809256d3ecf6ccdacc612b49b7b83dd2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f5a4c0d809256d3ecf6ccdacc612b49b7b83dd2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f86e433b67292150faa9fd978cad487934d90c76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f86e433b67292150faa9fd978cad487934d90c76", "html_url": "https://github.com/rust-lang/rust/commit/f86e433b67292150faa9fd978cad487934d90c76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f86e433b67292150faa9fd978cad487934d90c76/comments", "author": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e5162ce5b701dbcdb5b5f6cc98cd35feeb6b958", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e5162ce5b701dbcdb5b5f6cc98cd35feeb6b958", "html_url": "https://github.com/rust-lang/rust/commit/1e5162ce5b701dbcdb5b5f6cc98cd35feeb6b958"}], "stats": {"total": 231, "additions": 231, "deletions": 0}, "files": [{"sha": "42f989538c89066a2ee37d4feeb6197a8e93fb12", "filename": "src/test/run-pass/rfc1857-drop-order.rs", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/f86e433b67292150faa9fd978cad487934d90c76/src%2Ftest%2Frun-pass%2Frfc1857-drop-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f86e433b67292150faa9fd978cad487934d90c76/src%2Ftest%2Frun-pass%2Frfc1857-drop-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc1857-drop-order.rs?ref=f86e433b67292150faa9fd978cad487934d90c76", "patch": "@@ -0,0 +1,231 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code, unreachable_code)]\n+\n+use std::cell::RefCell;\n+use std::rc::Rc;\n+use std::panic::{self, AssertUnwindSafe, UnwindSafe};\n+\n+// This struct is used to record the order in which elements are dropped\n+struct PushOnDrop {\n+    vec: Rc<RefCell<Vec<u32>>>,\n+    val: u32\n+}\n+\n+impl PushOnDrop {\n+    fn new(val: u32, vec: Rc<RefCell<Vec<u32>>>) -> PushOnDrop {\n+        PushOnDrop { vec, val }\n+    }\n+}\n+\n+impl Drop for PushOnDrop {\n+    fn drop(&mut self) {\n+        self.vec.borrow_mut().push(self.val)\n+    }\n+}\n+\n+impl UnwindSafe for PushOnDrop { }\n+\n+// Structs\n+struct TestStruct {\n+    x: PushOnDrop,\n+    y: PushOnDrop,\n+    z: PushOnDrop\n+}\n+\n+// Tuple structs\n+struct TestTupleStruct(PushOnDrop, PushOnDrop, PushOnDrop);\n+\n+// Enum variants\n+enum TestEnum {\n+    Tuple(PushOnDrop, PushOnDrop, PushOnDrop),\n+    Struct { x: PushOnDrop, y: PushOnDrop, z: PushOnDrop }\n+}\n+\n+fn test_drop_tuple() {\n+    // Tuple fields are dropped in the same order they are declared\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let test_tuple = (PushOnDrop::new(1, dropped_fields.clone()),\n+                      PushOnDrop::new(2, dropped_fields.clone()));\n+    drop(test_tuple);\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2]);\n+\n+    // Panic during construction means that fields are treated as local variables\n+    // Therefore they are dropped in reverse order of initialization\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let cloned = AssertUnwindSafe(dropped_fields.clone());\n+    panic::catch_unwind(|| {\n+        (PushOnDrop::new(2, cloned.clone()),\n+         PushOnDrop::new(1, cloned.clone()),\n+         panic!(\"this panic is catched :D\"));\n+    }).err().unwrap();\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2]);\n+}\n+\n+fn test_drop_struct() {\n+    // Struct fields are dropped in the same order they are declared\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let test_struct = TestStruct {\n+        x: PushOnDrop::new(1, dropped_fields.clone()),\n+        y: PushOnDrop::new(2, dropped_fields.clone()),\n+        z: PushOnDrop::new(3, dropped_fields.clone()),\n+    };\n+    drop(test_struct);\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2, 3]);\n+\n+    // The same holds for tuple structs\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let test_tuple_struct = TestTupleStruct(PushOnDrop::new(1, dropped_fields.clone()),\n+                                            PushOnDrop::new(2, dropped_fields.clone()),\n+                                            PushOnDrop::new(3, dropped_fields.clone()));\n+    drop(test_tuple_struct);\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2, 3]);\n+\n+    // Panic during struct construction means that fields are treated as local variables\n+    // Therefore they are dropped in reverse order of initialization\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let cloned = AssertUnwindSafe(dropped_fields.clone());\n+    panic::catch_unwind(|| {\n+        TestStruct {\n+            x: PushOnDrop::new(2, cloned.clone()),\n+            y: PushOnDrop::new(1, cloned.clone()),\n+            z: panic!(\"this panic is catched :D\")\n+        };\n+    }).err().unwrap();\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2]);\n+\n+    // Test with different initialization order\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let cloned = AssertUnwindSafe(dropped_fields.clone());\n+    panic::catch_unwind(|| {\n+        TestStruct {\n+            y: PushOnDrop::new(2, cloned.clone()),\n+            x: PushOnDrop::new(1, cloned.clone()),\n+            z: panic!(\"this panic is catched :D\")\n+        };\n+    }).err().unwrap();\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2]);\n+\n+    // The same holds for tuple structs\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let cloned = AssertUnwindSafe(dropped_fields.clone());\n+    panic::catch_unwind(|| {\n+        TestTupleStruct(PushOnDrop::new(2, cloned.clone()),\n+                        PushOnDrop::new(1, cloned.clone()),\n+                        panic!(\"this panic is catched :D\"));\n+    }).err().unwrap();\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2]);\n+}\n+\n+fn test_drop_enum() {\n+    // Enum variants are dropped in the same order they are declared\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let test_struct_enum = TestEnum::Struct {\n+        x: PushOnDrop::new(1, dropped_fields.clone()),\n+        y: PushOnDrop::new(2, dropped_fields.clone()),\n+        z: PushOnDrop::new(3, dropped_fields.clone())\n+    };\n+    drop(test_struct_enum);\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2, 3]);\n+\n+    // The same holds for tuple enum variants\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let test_tuple_enum = TestEnum::Tuple(PushOnDrop::new(1, dropped_fields.clone()),\n+                                          PushOnDrop::new(2, dropped_fields.clone()),\n+                                          PushOnDrop::new(3, dropped_fields.clone()));\n+    drop(test_tuple_enum);\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2, 3]);\n+\n+    // Panic during enum construction means that fields are treated as local variables\n+    // Therefore they are dropped in reverse order of initialization\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let cloned = AssertUnwindSafe(dropped_fields.clone());\n+    panic::catch_unwind(|| {\n+        TestEnum::Struct {\n+            x: PushOnDrop::new(2, cloned.clone()),\n+            y: PushOnDrop::new(1, cloned.clone()),\n+            z: panic!(\"this panic is catched :D\")\n+        };\n+    }).err().unwrap();\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2]);\n+\n+    // Test with different initialization order\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let cloned = AssertUnwindSafe(dropped_fields.clone());\n+    panic::catch_unwind(|| {\n+        TestEnum::Struct {\n+            y: PushOnDrop::new(2, cloned.clone()),\n+            x: PushOnDrop::new(1, cloned.clone()),\n+            z: panic!(\"this panic is catched :D\")\n+        };\n+    }).err().unwrap();\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2]);\n+\n+    // The same holds for tuple enum variants\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let cloned = AssertUnwindSafe(dropped_fields.clone());\n+    panic::catch_unwind(|| {\n+        TestEnum::Tuple(PushOnDrop::new(2, cloned.clone()),\n+                        PushOnDrop::new(1, cloned.clone()),\n+                        panic!(\"this panic is catched :D\"));\n+    }).err().unwrap();\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2]);\n+}\n+\n+fn test_drop_list() {\n+    // Elements in a Vec are dropped in the same order they are pushed\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let xs = vec![PushOnDrop::new(1, dropped_fields.clone()),\n+                  PushOnDrop::new(2, dropped_fields.clone()),\n+                  PushOnDrop::new(3, dropped_fields.clone())];\n+    drop(xs);\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2, 3]);\n+\n+    // The same holds for arrays\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let xs = [PushOnDrop::new(1, dropped_fields.clone()),\n+              PushOnDrop::new(2, dropped_fields.clone()),\n+              PushOnDrop::new(3, dropped_fields.clone())];\n+    drop(xs);\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2, 3]);\n+\n+    // Panic during vec construction means that fields are treated as local variables\n+    // Therefore they are dropped in reverse order of initialization\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let cloned = AssertUnwindSafe(dropped_fields.clone());\n+    panic::catch_unwind(|| {\n+        vec![\n+            PushOnDrop::new(2, cloned.clone()),\n+            PushOnDrop::new(1, cloned.clone()),\n+            panic!(\"this panic is catched :D\")\n+        ];\n+    }).err().unwrap();\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2]);\n+\n+    // The same holds for arrays\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let cloned = AssertUnwindSafe(dropped_fields.clone());\n+    panic::catch_unwind(|| {\n+        [\n+            PushOnDrop::new(2, cloned.clone()),\n+            PushOnDrop::new(1, cloned.clone()),\n+            panic!(\"this panic is catched :D\")\n+        ];\n+    }).err().unwrap();\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2]);\n+}\n+\n+fn main() {\n+    test_drop_tuple();\n+    test_drop_struct();\n+    test_drop_enum();\n+    test_drop_list();\n+}"}]}