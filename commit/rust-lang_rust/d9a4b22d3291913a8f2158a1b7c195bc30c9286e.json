{"sha": "d9a4b22d3291913a8f2158a1b7c195bc30c9286e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5YTRiMjJkMzI5MTkxM2E4ZjIxNThhMWI3YzE5NWJjMzBjOTI4NmU=", "commit": {"author": {"name": "Matthias Einwag", "email": "matthias.einwag@live.com", "date": "2019-01-30T03:02:42Z"}, "committer": {"name": "Matthias Einwag", "email": "matthias.einwag@live.com", "date": "2019-02-03T21:46:53Z"}, "message": "Update the future/task API\n\nThis change updates the future and task API as discussed in the stabilization RFC at https://github.com/rust-lang/rfcs/pull/2592.\n\nChanges:\n- Replacing UnsafeWake with RawWaker and RawWakerVtable\n- Removal of LocalWaker\n- Removal of Arc-based Wake trait", "tree": {"sha": "cfa2cc014dc500634727555d9fc16b818e2c10f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cfa2cc014dc500634727555d9fc16b818e2c10f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9a4b22d3291913a8f2158a1b7c195bc30c9286e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9a4b22d3291913a8f2158a1b7c195bc30c9286e", "html_url": "https://github.com/rust-lang/rust/commit/d9a4b22d3291913a8f2158a1b7c195bc30c9286e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9a4b22d3291913a8f2158a1b7c195bc30c9286e/comments", "author": {"login": "Matthias247", "id": 6330334, "node_id": "MDQ6VXNlcjYzMzAzMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6330334?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Matthias247", "html_url": "https://github.com/Matthias247", "followers_url": "https://api.github.com/users/Matthias247/followers", "following_url": "https://api.github.com/users/Matthias247/following{/other_user}", "gists_url": "https://api.github.com/users/Matthias247/gists{/gist_id}", "starred_url": "https://api.github.com/users/Matthias247/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Matthias247/subscriptions", "organizations_url": "https://api.github.com/users/Matthias247/orgs", "repos_url": "https://api.github.com/users/Matthias247/repos", "events_url": "https://api.github.com/users/Matthias247/events{/privacy}", "received_events_url": "https://api.github.com/users/Matthias247/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Matthias247", "id": 6330334, "node_id": "MDQ6VXNlcjYzMzAzMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6330334?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Matthias247", "html_url": "https://github.com/Matthias247", "followers_url": "https://api.github.com/users/Matthias247/followers", "following_url": "https://api.github.com/users/Matthias247/following{/other_user}", "gists_url": "https://api.github.com/users/Matthias247/gists{/gist_id}", "starred_url": "https://api.github.com/users/Matthias247/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Matthias247/subscriptions", "organizations_url": "https://api.github.com/users/Matthias247/orgs", "repos_url": "https://api.github.com/users/Matthias247/repos", "events_url": "https://api.github.com/users/Matthias247/events{/privacy}", "received_events_url": "https://api.github.com/users/Matthias247/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "html_url": "https://github.com/rust-lang/rust/commit/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922"}], "stats": {"total": 522, "additions": 111, "deletions": 411}, "files": [{"sha": "51549f92d4dbf02e50a2a48c21ff8339988c2e3b", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d9a4b22d3291913a8f2158a1b7c195bc30c9286e/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9a4b22d3291913a8f2158a1b7c195bc30c9286e/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=d9a4b22d3291913a8f2158a1b7c195bc30c9286e", "patch": "@@ -71,7 +71,7 @@ use core::ops::{\n     CoerceUnsized, DispatchFromDyn, Deref, DerefMut, Receiver, Generator, GeneratorState\n };\n use core::ptr::{self, NonNull, Unique};\n-use core::task::{LocalWaker, Poll};\n+use core::task::{Waker, Poll};\n \n use crate::vec::Vec;\n use crate::raw_vec::RawVec;\n@@ -896,7 +896,7 @@ impl<G: ?Sized + Generator> Generator for Pin<Box<G>> {\n impl<F: ?Sized + Future + Unpin> Future for Box<F> {\n     type Output = F::Output;\n \n-    fn poll(mut self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<Self::Output> {\n-        F::poll(Pin::new(&mut *self), lw)\n+    fn poll(mut self: Pin<&mut Self>, waker: &Waker) -> Poll<Self::Output> {\n+        F::poll(Pin::new(&mut *self), waker)\n     }\n }"}, {"sha": "cc73e282b6f6fb49e548da538d665547f0467c94", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9a4b22d3291913a8f2158a1b7c195bc30c9286e/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9a4b22d3291913a8f2158a1b7c195bc30c9286e/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=d9a4b22d3291913a8f2158a1b7c195bc30c9286e", "patch": "@@ -133,10 +133,6 @@ mod macros;\n \n pub mod alloc;\n \n-#[unstable(feature = \"futures_api\",\n-           reason = \"futures in libcore are unstable\",\n-           issue = \"50547\")]\n-pub mod task;\n // Primitive types using the heaps above\n \n // Need to conditionally define the mod from `boxed.rs` to avoid"}, {"sha": "2261dabe2779af4b35d35107db0db391023b879d", "filename": "src/liballoc/task.rs", "status": "removed", "additions": 0, "deletions": 130, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftask.rs?ref=4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "patch": "@@ -1,130 +0,0 @@\n-//! Types and Traits for working with asynchronous tasks.\n-\n-pub use core::task::*;\n-\n-#[cfg(all(target_has_atomic = \"ptr\", target_has_atomic = \"cas\"))]\n-pub use if_arc::*;\n-\n-#[cfg(all(target_has_atomic = \"ptr\", target_has_atomic = \"cas\"))]\n-mod if_arc {\n-    use super::*;\n-    use core::marker::PhantomData;\n-    use core::mem;\n-    use core::ptr::{self, NonNull};\n-    use crate::sync::Arc;\n-\n-    /// A way of waking up a specific task.\n-    ///\n-    /// Any task executor must provide a way of signaling that a task it owns\n-    /// is ready to be `poll`ed again. Executors do so by implementing this trait.\n-    pub trait Wake: Send + Sync {\n-        /// Indicates that the associated task is ready to make progress and should\n-        /// be `poll`ed.\n-        ///\n-        /// Executors generally maintain a queue of \"ready\" tasks; `wake` should place\n-        /// the associated task onto this queue.\n-        fn wake(arc_self: &Arc<Self>);\n-\n-        /// Indicates that the associated task is ready to make progress and should\n-        /// be `poll`ed. This function is like `wake`, but can only be called from the\n-        /// thread on which this `Wake` was created.\n-        ///\n-        /// Executors generally maintain a queue of \"ready\" tasks; `wake_local` should place\n-        /// the associated task onto this queue.\n-        #[inline]\n-        unsafe fn wake_local(arc_self: &Arc<Self>) {\n-            Self::wake(arc_self);\n-        }\n-    }\n-\n-    #[cfg(all(target_has_atomic = \"ptr\", target_has_atomic = \"cas\"))]\n-    struct ArcWrapped<T>(PhantomData<T>);\n-\n-    unsafe impl<T: Wake + 'static> UnsafeWake for ArcWrapped<T> {\n-        #[inline]\n-        unsafe fn clone_raw(&self) -> Waker {\n-            let me: *const ArcWrapped<T> = self;\n-            let arc = (*(&me as *const *const ArcWrapped<T> as *const Arc<T>)).clone();\n-            Waker::from(arc)\n-        }\n-\n-        #[inline]\n-        unsafe fn drop_raw(&self) {\n-            let mut me: *const ArcWrapped<T> = self;\n-            let me = &mut me as *mut *const ArcWrapped<T> as *mut Arc<T>;\n-            ptr::drop_in_place(me);\n-        }\n-\n-        #[inline]\n-        unsafe fn wake(&self) {\n-            let me: *const ArcWrapped<T> = self;\n-            T::wake(&*(&me as *const *const ArcWrapped<T> as *const Arc<T>))\n-        }\n-\n-        #[inline]\n-        unsafe fn wake_local(&self) {\n-            let me: *const ArcWrapped<T> = self;\n-            T::wake_local(&*(&me as *const *const ArcWrapped<T> as *const Arc<T>))\n-        }\n-    }\n-\n-    impl<T> From<Arc<T>> for Waker\n-        where T: Wake + 'static,\n-    {\n-        fn from(rc: Arc<T>) -> Self {\n-            unsafe {\n-                let ptr = mem::transmute::<Arc<T>, NonNull<ArcWrapped<T>>>(rc);\n-                Waker::new(ptr)\n-            }\n-        }\n-    }\n-\n-    /// Creates a `LocalWaker` from a local `wake`.\n-    ///\n-    /// This function requires that `wake` is \"local\" (created on the current thread).\n-    /// The resulting `LocalWaker` will call `wake.wake_local()` when awoken, and\n-    /// will call `wake.wake()` if awoken after being converted to a `Waker`.\n-    #[inline]\n-    pub unsafe fn local_waker<W: Wake + 'static>(wake: Arc<W>) -> LocalWaker {\n-        let ptr = mem::transmute::<Arc<W>, NonNull<ArcWrapped<W>>>(wake);\n-        LocalWaker::new(ptr)\n-    }\n-\n-    struct NonLocalAsLocal<T>(ArcWrapped<T>);\n-\n-    unsafe impl<T: Wake + 'static> UnsafeWake for NonLocalAsLocal<T> {\n-        #[inline]\n-        unsafe fn clone_raw(&self) -> Waker {\n-            self.0.clone_raw()\n-        }\n-\n-        #[inline]\n-        unsafe fn drop_raw(&self) {\n-            self.0.drop_raw()\n-        }\n-\n-        #[inline]\n-        unsafe fn wake(&self) {\n-            self.0.wake()\n-        }\n-\n-        #[inline]\n-        unsafe fn wake_local(&self) {\n-            // Since we're nonlocal, we can't call wake_local\n-            self.0.wake()\n-        }\n-    }\n-\n-    /// Creates a `LocalWaker` from a non-local `wake`.\n-    ///\n-    /// This function is similar to `local_waker`, but does not require that `wake`\n-    /// is local to the current thread. The resulting `LocalWaker` will call\n-    /// `wake.wake()` when awoken.\n-    #[inline]\n-    pub fn local_waker_from_nonlocal<W: Wake + 'static>(wake: Arc<W>) -> LocalWaker {\n-        unsafe {\n-            let ptr = mem::transmute::<Arc<W>, NonNull<NonLocalAsLocal<W>>>(wake);\n-            LocalWaker::new(ptr)\n-        }\n-    }\n-}"}, {"sha": "c40045245425bae008b74b2a7e3505d3d162a756", "filename": "src/libcore/future/future.rs", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d9a4b22d3291913a8f2158a1b7c195bc30c9286e/src%2Flibcore%2Ffuture%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9a4b22d3291913a8f2158a1b7c195bc30c9286e/src%2Flibcore%2Ffuture%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture.rs?ref=d9a4b22d3291913a8f2158a1b7c195bc30c9286e", "patch": "@@ -5,7 +5,7 @@\n use marker::Unpin;\n use ops;\n use pin::Pin;\n-use task::{Poll, LocalWaker};\n+use task::{Poll, Waker};\n \n /// A future represents an asynchronous computation.\n ///\n@@ -25,7 +25,7 @@ use task::{Poll, LocalWaker};\n /// `await!` the value.\n #[must_use = \"futures do nothing unless polled\"]\n pub trait Future {\n-    /// The result of the `Future`.\n+    /// The type of value produced on completion.\n     type Output;\n \n     /// Attempt to resolve the future to a final value, registering\n@@ -42,16 +42,16 @@ pub trait Future {\n     /// Once a future has finished, clients should not `poll` it again.\n     ///\n     /// When a future is not ready yet, `poll` returns `Poll::Pending` and\n-    /// stores a clone of the [`LocalWaker`] to be woken once the future can\n+    /// stores a clone of the [`Waker`] to be woken once the future can\n     /// make progress. For example, a future waiting for a socket to become\n-    /// readable would call `.clone()` on the [`LocalWaker`] and store it.\n+    /// readable would call `.clone()` on the [`Waker`] and store it.\n     /// When a signal arrives elsewhere indicating that the socket is readable,\n-    /// `[LocalWaker::wake]` is called and the socket future's task is awoken.\n+    /// `[Waker::wake]` is called and the socket future's task is awoken.\n     /// Once a task has been woken up, it should attempt to `poll` the future\n     /// again, which may or may not produce a final value.\n     ///\n     /// Note that on multiple calls to `poll`, only the most recent\n-    /// [`LocalWaker`] passed to `poll` should be scheduled to receive a\n+    /// [`Waker`] passed to `poll` should be scheduled to receive a\n     /// wakeup.\n     ///\n     /// # Runtime characteristics\n@@ -74,16 +74,6 @@ pub trait Future {\n     /// thread pool (or something similar) to ensure that `poll` can return\n     /// quickly.\n     ///\n-    /// # [`LocalWaker`], [`Waker`] and thread-safety\n-    ///\n-    /// The `poll` function takes a [`LocalWaker`], an object which knows how to\n-    /// awaken the current task. [`LocalWaker`] is not `Send` nor `Sync`, so in\n-    /// order to make thread-safe futures the [`LocalWaker::into_waker`] method\n-    /// should be used to convert the [`LocalWaker`] into a thread-safe version.\n-    /// [`LocalWaker::wake`] implementations have the ability to be more\n-    /// efficient, however, so when thread safety is not necessary,\n-    /// [`LocalWaker`] should be preferred.\n-    ///\n     /// # Panics\n     ///\n     /// Once a future has completed (returned `Ready` from `poll`),\n@@ -93,18 +83,16 @@ pub trait Future {\n     ///\n     /// [`Poll::Pending`]: ../task/enum.Poll.html#variant.Pending\n     /// [`Poll::Ready(val)`]: ../task/enum.Poll.html#variant.Ready\n-    /// [`LocalWaker`]: ../task/struct.LocalWaker.html\n-    /// [`LocalWaker::into_waker`]: ../task/struct.LocalWaker.html#method.into_waker\n-    /// [`LocalWaker::wake`]: ../task/struct.LocalWaker.html#method.wake\n     /// [`Waker`]: ../task/struct.Waker.html\n-    fn poll(self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<Self::Output>;\n+    /// [`Waker::wake`]: ../task/struct.Waker.html#method.wake\n+    fn poll(self: Pin<&mut Self>, waker: &Waker) -> Poll<Self::Output>;\n }\n \n impl<'a, F: ?Sized + Future + Unpin> Future for &'a mut F {\n     type Output = F::Output;\n \n-    fn poll(mut self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<Self::Output> {\n-        F::poll(Pin::new(&mut **self), lw)\n+    fn poll(mut self: Pin<&mut Self>, waker: &Waker) -> Poll<Self::Output> {\n+        F::poll(Pin::new(&mut **self), waker)\n     }\n }\n \n@@ -115,7 +103,7 @@ where\n {\n     type Output = <<P as ops::Deref>::Target as Future>::Output;\n \n-    fn poll(self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<Self::Output> {\n-        Pin::get_mut(self).as_mut().poll(lw)\n+    fn poll(self: Pin<&mut Self>, waker: &Waker) -> Poll<Self::Output> {\n+        Pin::get_mut(self).as_mut().poll(waker)\n     }\n }"}, {"sha": "9b8f59811620083edf04be7e8cb1b8795d2d1253", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9a4b22d3291913a8f2158a1b7c195bc30c9286e/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9a4b22d3291913a8f2158a1b7c195bc30c9286e/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=d9a4b22d3291913a8f2158a1b7c195bc30c9286e", "patch": "@@ -8,4 +8,4 @@ mod poll;\n pub use self::poll::Poll;\n \n mod wake;\n-pub use self::wake::{Waker, LocalWaker, UnsafeWake};\n+pub use self::wake::{Waker, RawWaker, RawWakerVTable};"}, {"sha": "bb91bf2ecfb4424906f46e7f053b6f74f6e1a54f", "filename": "src/libcore/task/wake.rs", "status": "modified", "additions": 82, "deletions": 234, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/d9a4b22d3291913a8f2158a1b7c195bc30c9286e/src%2Flibcore%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9a4b22d3291913a8f2158a1b7c195bc30c9286e/src%2Flibcore%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fwake.rs?ref=d9a4b22d3291913a8f2158a1b7c195bc30c9286e", "patch": "@@ -4,281 +4,129 @@\n \n use fmt;\n use marker::Unpin;\n-use ptr::NonNull;\n+\n+/// A `RawWaker` allows the implementor of a task executor to create a `Waker`\n+/// which provides customized wakeup behavior.\n+///\n+/// It consists of a data pointer and a virtual function pointer table (vtable) that\n+/// customizes the behavior of the `RawWaker`.\n+#[derive(PartialEq)]\n+pub struct RawWaker {\n+    /// A data pointer, which can be used to store arbitrary data as required\n+    /// by the executor. This could be e.g. a type-erased pointer to an `Arc`\n+    /// that is associated with the task.\n+    /// The value of this field gets passed to all functions that are part of\n+    /// the vtable as first parameter.\n+    pub data: *const (),\n+    /// Virtual function pointer table that customizes the behavior of this waker.\n+    pub vtable: &'static RawWakerVTable,\n+}\n+\n+impl fmt::Debug for RawWaker {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"RawWaker\")\n+            .finish()\n+    }\n+}\n+\n+/// A virtual function pointer table (vtable) that specifies the behavior\n+/// of a `RawWaker`.\n+///\n+/// The pointer passed to all functions inside the vtable is the `data` pointer\n+/// from the enclosing `RawWaker` object.\n+#[derive(PartialEq, Copy, Clone)]\n+pub struct RawWakerVTable {\n+    /// This function will be called when the `RawWaker` gets cloned, e.g. when\n+    /// the `Waker` in which the `RawWaker` is stored gets cloned.\n+    ///\n+    /// The implementation of this function must retain all resources that are\n+    /// required for this additional instance of a `RawWaker` and associated\n+    /// task. Calling `wake` on the resulting `RawWaker` should result in a wakeup\n+    /// of the same task that would have been awoken by the original `RawWaker`.\n+    pub clone: unsafe fn(*const ()) -> RawWaker,\n+\n+    /// This function will be called when `wake` is called on the `Waker`.\n+    /// It must wake up the task associated with this `RawWaker`.\n+    pub wake: unsafe fn(*const ()),\n+\n+    /// This function gets called when a `RawWaker` gets dropped.\n+    ///\n+    /// The implementation of this function must make sure to release any\n+    /// resources that are associated with this instance of a `RawWaker` and\n+    /// associated task.\n+    pub drop_fn: unsafe fn(*const ()),\n+}\n+\n+impl fmt::Debug for RawWakerVTable {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"RawWakerVTable\")\n+            .finish()\n+    }\n+}\n \n /// A `Waker` is a handle for waking up a task by notifying its executor that it\n /// is ready to be run.\n ///\n-/// This handle contains a trait object pointing to an instance of the `UnsafeWake`\n-/// trait, allowing notifications to get routed through it.\n+/// This handle encapsulates a `RawWaker` instance, which defines the\n+/// executor-specific wakeup behavior.\n+///\n+/// Implements `Clone`, `Send`, and `Sync`.\n #[repr(transparent)]\n pub struct Waker {\n-    inner: NonNull<dyn UnsafeWake>,\n+    waker: RawWaker,\n }\n \n impl Unpin for Waker {}\n unsafe impl Send for Waker {}\n unsafe impl Sync for Waker {}\n \n impl Waker {\n-    /// Constructs a new `Waker` directly.\n-    ///\n-    /// Note that most code will not need to call this. Implementers of the\n-    /// `UnsafeWake` trait will typically provide a wrapper that calls this\n-    /// but you otherwise shouldn't call it directly.\n-    ///\n-    /// If you're working with the standard library then it's recommended to\n-    /// use the `Waker::from` function instead which works with the safe\n-    /// `Arc` type and the safe `Wake` trait.\n-    #[inline]\n-    pub unsafe fn new(inner: NonNull<dyn UnsafeWake>) -> Self {\n-        Waker { inner }\n-    }\n-\n     /// Wake up the task associated with this `Waker`.\n-    #[inline]\n     pub fn wake(&self) {\n-        unsafe { self.inner.as_ref().wake() }\n+        // The actual wakeup call is delegated through a virtual function call\n+        // to the implementation which is defined by the executor.\n+        unsafe { (self.waker.vtable.wake)(self.waker.data) }\n     }\n \n-    /// Returns whether or not this `Waker` and `other` awaken the same task.\n+    /// Returns whether or not this `Waker` and other `Waker` have awaken the same task.\n     ///\n     /// This function works on a best-effort basis, and may return false even\n     /// when the `Waker`s would awaken the same task. However, if this function\n-    /// returns true, it is guaranteed that the `Waker`s will awaken the same\n-    /// task.\n+    /// returns `true`, it is guaranteed that the `Waker`s will awaken the same task.\n     ///\n     /// This function is primarily used for optimization purposes.\n-    #[inline]\n     pub fn will_wake(&self, other: &Waker) -> bool {\n-        self.inner == other.inner\n+        self.waker == other.waker\n     }\n \n-    /// Returns whether or not this `Waker` and `other` `LocalWaker` awaken\n-    /// the same task.\n-    ///\n-    /// This function works on a best-effort basis, and may return false even\n-    /// when the `Waker`s would awaken the same task. However, if this function\n-    /// returns true, it is guaranteed that the `Waker`s will awaken the same\n-    /// task.\n+    /// Creates a new `Waker` from `RawWaker`.\n     ///\n-    /// This function is primarily used for optimization purposes.\n-    #[inline]\n-    pub fn will_wake_local(&self, other: &LocalWaker) -> bool {\n-        self.will_wake(&other.0)\n+    /// The method cannot check whether `RawWaker` fulfills the required API\n+    /// contract to make it usable for `Waker` and is therefore unsafe.\n+    pub unsafe fn new_unchecked(waker: RawWaker) -> Waker {\n+        Waker {\n+            waker: waker,\n+        }\n     }\n }\n \n impl Clone for Waker {\n-    #[inline]\n     fn clone(&self) -> Self {\n-        unsafe {\n-            self.inner.as_ref().clone_raw()\n+        Waker {\n+            waker: unsafe { (self.waker.vtable.clone)(self.waker.data) },\n         }\n     }\n }\n \n-impl fmt::Debug for Waker {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"Waker\")\n-            .finish()\n-    }\n-}\n-\n impl Drop for Waker {\n-    #[inline]\n     fn drop(&mut self) {\n-        unsafe {\n-            self.inner.as_ref().drop_raw()\n-        }\n+        unsafe { (self.waker.vtable.drop_fn)(self.waker.data) }\n     }\n }\n \n-/// A `LocalWaker` is a handle for waking up a task by notifying its executor that it\n-/// is ready to be run.\n-///\n-/// This is similar to the `Waker` type, but cannot be sent across threads.\n-/// Task executors can use this type to implement more optimized single-threaded wakeup\n-/// behavior.\n-#[repr(transparent)]\n-#[derive(Clone)]\n-pub struct LocalWaker(Waker);\n-\n-impl Unpin for LocalWaker {}\n-impl !Send for LocalWaker {}\n-impl !Sync for LocalWaker {}\n-\n-impl LocalWaker {\n-    /// Constructs a new `LocalWaker` directly.\n-    ///\n-    /// Note that most code will not need to call this. Implementers of the\n-    /// `UnsafeWake` trait will typically provide a wrapper that calls this\n-    /// but you otherwise shouldn't call it directly.\n-    ///\n-    /// If you're working with the standard library then it's recommended to\n-    /// use the `local_waker_from_nonlocal` or `local_waker` to convert a `Waker`\n-    /// into a `LocalWaker`.\n-    ///\n-    /// For this function to be used safely, it must be sound to call `inner.wake_local()`\n-    /// on the current thread.\n-    #[inline]\n-    pub unsafe fn new(inner: NonNull<dyn UnsafeWake>) -> Self {\n-        LocalWaker(Waker::new(inner))\n-    }\n-\n-    /// Borrows this `LocalWaker` as a `Waker`.\n-    ///\n-    /// `Waker` is nearly identical to `LocalWaker`, but is threadsafe\n-    /// (implements `Send` and `Sync`).\n-    #[inline]\n-    pub fn as_waker(&self) -> &Waker {\n-        &self.0\n-    }\n-\n-    /// Converts this `LocalWaker` into a `Waker`.\n-    ///\n-    /// `Waker` is nearly identical to `LocalWaker`, but is threadsafe\n-    /// (implements `Send` and `Sync`).\n-    #[inline]\n-    pub fn into_waker(self) -> Waker {\n-        self.0\n-    }\n-\n-    /// Wake up the task associated with this `LocalWaker`.\n-    #[inline]\n-    pub fn wake(&self) {\n-        unsafe { self.0.inner.as_ref().wake_local() }\n-    }\n-\n-    /// Returns whether or not this `LocalWaker` and `other` `LocalWaker` awaken the same task.\n-    ///\n-    /// This function works on a best-effort basis, and may return false even\n-    /// when the `LocalWaker`s would awaken the same task. However, if this function\n-    /// returns true, it is guaranteed that the `LocalWaker`s will awaken the same\n-    /// task.\n-    ///\n-    /// This function is primarily used for optimization purposes.\n-    #[inline]\n-    pub fn will_wake(&self, other: &LocalWaker) -> bool {\n-        self.0.will_wake(&other.0)\n-    }\n-\n-    /// Returns whether or not this `LocalWaker` and `other` `Waker` awaken the same task.\n-    ///\n-    /// This function works on a best-effort basis, and may return false even\n-    /// when the `Waker`s would awaken the same task. However, if this function\n-    /// returns true, it is guaranteed that the `LocalWaker`s will awaken the same\n-    /// task.\n-    ///\n-    /// This function is primarily used for optimization purposes.\n-    #[inline]\n-    pub fn will_wake_nonlocal(&self, other: &Waker) -> bool {\n-        self.0.will_wake(other)\n-    }\n-}\n-\n-impl From<LocalWaker> for Waker {\n-    /// Converts a `LocalWaker` into a `Waker`.\n-    ///\n-    /// This conversion turns a `!Sync` `LocalWaker` into a `Sync` `Waker`, allowing a wakeup\n-    /// object to be sent to another thread, but giving up its ability to do specialized\n-    /// thread-local wakeup behavior.\n-    #[inline]\n-    fn from(local_waker: LocalWaker) -> Self {\n-        local_waker.0\n-    }\n-}\n-\n-impl fmt::Debug for LocalWaker {\n+impl fmt::Debug for Waker {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"LocalWaker\")\n+        f.debug_struct(\"Waker\")\n             .finish()\n     }\n }\n-\n-/// An unsafe trait for implementing custom memory management for a `Waker` or `LocalWaker`.\n-///\n-/// A `Waker` conceptually is a cloneable trait object for `Wake`, and is\n-/// most often essentially just `Arc<dyn Wake>`. However, in some contexts\n-/// (particularly `no_std`), it's desirable to avoid `Arc` in favor of some\n-/// custom memory management strategy. This trait is designed to allow for such\n-/// customization.\n-///\n-/// When using `std`, a default implementation of the `UnsafeWake` trait is provided for\n-/// `Arc<T>` where `T: Wake`.\n-pub unsafe trait UnsafeWake: Send + Sync {\n-    /// Creates a clone of this `UnsafeWake` and stores it behind a `Waker`.\n-    ///\n-    /// This function will create a new uniquely owned handle that under the\n-    /// hood references the same notification instance. In other words calls\n-    /// to `wake` on the returned handle should be equivalent to calls to\n-    /// `wake` on this handle.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This function is unsafe to call because it's asserting the `UnsafeWake`\n-    /// value is in a consistent state, i.e., hasn't been dropped.\n-    unsafe fn clone_raw(&self) -> Waker;\n-\n-    /// Drops this instance of `UnsafeWake`, deallocating resources\n-    /// associated with it.\n-    ///\n-    /// FIXME(cramertj)\n-    /// This method is intended to have a signature such as:\n-    ///\n-    /// ```ignore (not-a-doctest)\n-    /// fn drop_raw(self: *mut Self);\n-    /// ```\n-    ///\n-    /// Unfortunately in Rust today that signature is not object safe.\n-    /// Nevertheless it's recommended to implement this function *as if* that\n-    /// were its signature. As such it is not safe to call on an invalid\n-    /// pointer, nor is the validity of the pointer guaranteed after this\n-    /// function returns.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This function is unsafe to call because it's asserting the `UnsafeWake`\n-    /// value is in a consistent state, i.e., hasn't been dropped.\n-    unsafe fn drop_raw(&self);\n-\n-    /// Indicates that the associated task is ready to make progress and should\n-    /// be `poll`ed.\n-    ///\n-    /// Executors generally maintain a queue of \"ready\" tasks; `wake` should place\n-    /// the associated task onto this queue.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Implementations should avoid panicking, but clients should also be prepared\n-    /// for panics.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This function is unsafe to call because it's asserting the `UnsafeWake`\n-    /// value is in a consistent state, i.e., hasn't been dropped.\n-    unsafe fn wake(&self);\n-\n-    /// Indicates that the associated task is ready to make progress and should\n-    /// be `poll`ed. This function is the same as `wake`, but can only be called\n-    /// from the thread that this `UnsafeWake` is \"local\" to. This allows for\n-    /// implementors to provide specialized wakeup behavior specific to the current\n-    /// thread. This function is called by `LocalWaker::wake`.\n-    ///\n-    /// Executors generally maintain a queue of \"ready\" tasks; `wake_local` should place\n-    /// the associated task onto this queue.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Implementations should avoid panicking, but clients should also be prepared\n-    /// for panics.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This function is unsafe to call because it's asserting the `UnsafeWake`\n-    /// value is in a consistent state, i.e., hasn't been dropped, and that the\n-    /// `UnsafeWake` hasn't moved from the thread on which it was created.\n-    unsafe fn wake_local(&self) {\n-        self.wake()\n-    }\n-}"}, {"sha": "aa784746122db71e82ccc8896d491d67a2587333", "filename": "src/libstd/future.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d9a4b22d3291913a8f2158a1b7c195bc30c9286e/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9a4b22d3291913a8f2158a1b7c195bc30c9286e/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=d9a4b22d3291913a8f2158a1b7c195bc30c9286e", "patch": "@@ -5,7 +5,7 @@ use core::marker::Unpin;\n use core::pin::Pin;\n use core::option::Option;\n use core::ptr::NonNull;\n-use core::task::{LocalWaker, Poll};\n+use core::task::{Waker, Poll};\n use core::ops::{Drop, Generator, GeneratorState};\n \n #[doc(inline)]\n@@ -32,21 +32,21 @@ impl<T: Generator<Yield = ()>> !Unpin for GenFuture<T> {}\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n impl<T: Generator<Yield = ()>> Future for GenFuture<T> {\n     type Output = T::Return;\n-    fn poll(self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<Self::Output> {\n+    fn poll(self: Pin<&mut Self>, waker: &Waker) -> Poll<Self::Output> {\n         // Safe because we're !Unpin + !Drop mapping to a ?Unpin value\n         let gen = unsafe { Pin::map_unchecked_mut(self, |s| &mut s.0) };\n-        set_task_waker(lw, || match gen.resume() {\n+        set_task_waker(waker, || match gen.resume() {\n             GeneratorState::Yielded(()) => Poll::Pending,\n             GeneratorState::Complete(x) => Poll::Ready(x),\n         })\n     }\n }\n \n thread_local! {\n-    static TLS_WAKER: Cell<Option<NonNull<LocalWaker>>> = Cell::new(None);\n+    static TLS_WAKER: Cell<Option<NonNull<Waker>>> = Cell::new(None);\n }\n \n-struct SetOnDrop(Option<NonNull<LocalWaker>>);\n+struct SetOnDrop(Option<NonNull<Waker>>);\n \n impl Drop for SetOnDrop {\n     fn drop(&mut self) {\n@@ -58,12 +58,12 @@ impl Drop for SetOnDrop {\n \n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n /// Sets the thread-local task context used by async/await futures.\n-pub fn set_task_waker<F, R>(lw: &LocalWaker, f: F) -> R\n+pub fn set_task_waker<F, R>(waker: &Waker, f: F) -> R\n where\n     F: FnOnce() -> R\n {\n     let old_waker = TLS_WAKER.with(|tls_waker| {\n-        tls_waker.replace(Some(NonNull::from(lw)))\n+        tls_waker.replace(Some(NonNull::from(waker)))\n     });\n     let _reset_waker = SetOnDrop(old_waker);\n     f()\n@@ -78,7 +78,7 @@ where\n /// retrieved by a surrounding call to get_task_waker.\n pub fn get_task_waker<F, R>(f: F) -> R\n where\n-    F: FnOnce(&LocalWaker) -> R\n+    F: FnOnce(&Waker) -> R\n {\n     let waker_ptr = TLS_WAKER.with(|tls_waker| {\n         // Clear the entry so that nested `get_task_waker` calls\n@@ -88,7 +88,7 @@ where\n     let _reset_waker = SetOnDrop(waker_ptr);\n \n     let waker_ptr = waker_ptr.expect(\n-        \"TLS LocalWaker not set. This is a rustc bug. \\\n+        \"TLS Waker not set. This is a rustc bug. \\\n         Please file an issue on https://github.com/rust-lang/rust.\");\n     unsafe { f(waker_ptr.as_ref()) }\n }\n@@ -99,5 +99,5 @@ pub fn poll_with_tls_waker<F>(f: Pin<&mut F>) -> Poll<F::Output>\n where\n     F: Future\n {\n-    get_task_waker(|lw| F::poll(f, lw))\n+    get_task_waker(|waker| F::poll(f, waker))\n }"}, {"sha": "207ba9ae02f0599284b5af365aa7ec6f6f2df234", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9a4b22d3291913a8f2158a1b7c195bc30c9286e/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9a4b22d3291913a8f2158a1b7c195bc30c9286e/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=d9a4b22d3291913a8f2158a1b7c195bc30c9286e", "patch": "@@ -468,8 +468,6 @@ pub mod task {\n     //! Types and Traits for working with asynchronous tasks.\n     #[doc(inline)]\n     pub use core::task::*;\n-    #[doc(inline)]\n-    pub use alloc_crate::task::*;\n }\n \n #[unstable(feature = \"futures_api\","}, {"sha": "862fdf051ccd10b1d6344c4802c18ed94246fba5", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d9a4b22d3291913a8f2158a1b7c195bc30c9286e/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9a4b22d3291913a8f2158a1b7c195bc30c9286e/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=d9a4b22d3291913a8f2158a1b7c195bc30c9286e", "patch": "@@ -12,7 +12,7 @@ use panicking;\n use ptr::{Unique, NonNull};\n use rc::Rc;\n use sync::{Arc, Mutex, RwLock, atomic};\n-use task::{LocalWaker, Poll};\n+use task::{Waker, Poll};\n use thread::Result;\n \n #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n@@ -323,9 +323,9 @@ impl<T: fmt::Debug> fmt::Debug for AssertUnwindSafe<T> {\n impl<'a, F: Future> Future for AssertUnwindSafe<F> {\n     type Output = F::Output;\n \n-    fn poll(self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<Self::Output> {\n+    fn poll(self: Pin<&mut Self>, waker: &Waker) -> Poll<Self::Output> {\n         let pinned_field = unsafe { Pin::map_unchecked_mut(self, |x| &mut x.0) };\n-        F::poll(pinned_field, lw)\n+        F::poll(pinned_field, waker)\n     }\n }\n "}]}