{"sha": "be1a74e4d3e629a350928e850514541782b46fdd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlMWE3NGU0ZDNlNjI5YTM1MDkyOGU4NTA1MTQ1NDE3ODJiNDZmZGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-15T02:06:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-15T02:06:20Z"}, "message": "Auto merge of #41312 - frewsxcv:rollup, r=frewsxcv\n\nRollup of 2 pull requests\n\n- Successful merges: #41125, #41309\n- Failed merges:", "tree": {"sha": "add43bd1e97808670711899ce2e6a222ccdd51ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/add43bd1e97808670711899ce2e6a222ccdd51ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be1a74e4d3e629a350928e850514541782b46fdd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be1a74e4d3e629a350928e850514541782b46fdd", "html_url": "https://github.com/rust-lang/rust/commit/be1a74e4d3e629a350928e850514541782b46fdd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be1a74e4d3e629a350928e850514541782b46fdd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0ca5d4bad07a4fc8497bd9766cdadaee1bd0ac6", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0ca5d4bad07a4fc8497bd9766cdadaee1bd0ac6", "html_url": "https://github.com/rust-lang/rust/commit/f0ca5d4bad07a4fc8497bd9766cdadaee1bd0ac6"}, {"sha": "3adcd1c37e38c57066837152dff02cf0c9ba6e23", "url": "https://api.github.com/repos/rust-lang/rust/commits/3adcd1c37e38c57066837152dff02cf0c9ba6e23", "html_url": "https://github.com/rust-lang/rust/commit/3adcd1c37e38c57066837152dff02cf0c9ba6e23"}], "stats": {"total": 422, "additions": 367, "deletions": 55}, "files": [{"sha": "a9796fdf01e0d38f9aa79528dedc9fffd731ade7", "filename": "src/doc/unstable-book/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/be1a74e4d3e629a350928e850514541782b46fdd/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/be1a74e4d3e629a350928e850514541782b46fdd/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md?ref=be1a74e4d3e629a350928e850514541782b46fdd", "patch": "@@ -136,6 +136,7 @@\n - [optin_builtin_traits](optin-builtin-traits.md)\n - [option_entry](option-entry.md)\n - [osstring_shrink_to_fit](osstring-shrink-to-fit.md)\n+- [overlapping_marker_traits](overlapping-marker-traits.md)\n - [panic_abort](panic-abort.md)\n - [panic_runtime](panic-runtime.md)\n - [panic_unwind](panic-unwind.md)"}, {"sha": "a4920839c6ca9d8199f3ef4cb3232ac94bd3b1c4", "filename": "src/doc/unstable-book/src/overlapping-marker-traits.md", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/be1a74e4d3e629a350928e850514541782b46fdd/src%2Fdoc%2Funstable-book%2Fsrc%2Foverlapping-marker-traits.md", "raw_url": "https://github.com/rust-lang/rust/raw/be1a74e4d3e629a350928e850514541782b46fdd/src%2Fdoc%2Funstable-book%2Fsrc%2Foverlapping-marker-traits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Foverlapping-marker-traits.md?ref=be1a74e4d3e629a350928e850514541782b46fdd", "patch": "@@ -0,0 +1,7 @@\n+# `overlapping_marker_traits`\n+\n+The tracking issue for this feature is: [#29864]\n+\n+[#29864]: https://github.com/rust-lang/rust/issues/29864\n+\n+------------------------"}, {"sha": "f68361e8522778b6d2e950278cd96217d0aedf6e", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 164, "deletions": 33, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/be1a74e4d3e629a350928e850514541782b46fdd/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be1a74e4d3e629a350928e850514541782b46fdd/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=be1a74e4d3e629a350928e850514541782b46fdd", "patch": "@@ -107,29 +107,25 @@ mod sip;\n \n /// A hashable type.\n ///\n-/// The `H` type parameter is an abstract hash state that is used by the `Hash`\n-/// to compute the hash.\n+/// Types implementing `Hash` are able to be [`hash`]ed with an instance of\n+/// [`Hasher`].\n ///\n-/// If you are also implementing [`Eq`], there is an additional property that\n-/// is important:\n+/// ## Implementing `Hash`\n ///\n-/// ```text\n-/// k1 == k2 -> hash(k1) == hash(k2)\n-/// ```\n-///\n-/// In other words, if two keys are equal, their hashes should also be equal.\n-/// [`HashMap`] and [`HashSet`] both rely on this behavior.\n+/// You can derive `Hash` with `#[derive(Hash)]` if all fields implement `Hash`.\n+/// The resulting hash will be the combination of the values from calling\n+/// [`hash`] on each field.\n ///\n-/// ## Derivable\n-///\n-/// This trait can be used with `#[derive]` if all fields implement `Hash`.\n-/// When `derive`d, the resulting hash will be the combination of the values\n-/// from calling [`.hash`] on each field.\n-///\n-/// ## How can I implement `Hash`?\n+/// ```\n+/// #[derive(Hash)]\n+/// struct Rustacean {\n+///     name: String,\n+///     country: String,\n+/// }\n+/// ```\n ///\n-/// If you need more control over how a value is hashed, you need to implement\n-/// the `Hash` trait:\n+/// If you need more control over how a value is hashed, you can of course\n+/// implement the `Hash` trait yourself:\n ///\n /// ```\n /// use std::hash::{Hash, Hasher};\n@@ -148,17 +144,60 @@ mod sip;\n /// }\n /// ```\n ///\n+/// ## `Hash` and `Eq`\n+///\n+/// When implementing both `Hash` and [`Eq`], it is important that the following\n+/// property holds:\n+///\n+/// ```text\n+/// k1 == k2 -> hash(k1) == hash(k2)\n+/// ```\n+///\n+/// In other words, if two keys are equal, their hashes must also be equal.\n+/// [`HashMap`] and [`HashSet`] both rely on this behavior.\n+///\n+/// Thankfully, you won't need to worry about upholding this property when\n+/// deriving both [`Eq`] and `Hash` with `#[derive(PartialEq, Eq, Hash)]`.\n+///\n /// [`Eq`]: ../../std/cmp/trait.Eq.html\n+/// [`Hasher`]: trait.Hasher.html\n /// [`HashMap`]: ../../std/collections/struct.HashMap.html\n /// [`HashSet`]: ../../std/collections/struct.HashSet.html\n-/// [`.hash`]: #tymethod.hash\n+/// [`hash`]: #tymethod.hash\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Hash {\n-    /// Feeds this value into the state given, updating the hasher as necessary.\n+    /// Feeds this value into the given [`Hasher`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::hash_map::DefaultHasher;\n+    /// use std::hash::{Hash, Hasher};\n+    ///\n+    /// let mut hasher = DefaultHasher::new();\n+    /// 7920.hash(&mut hasher);\n+    /// println!(\"Hash is {:x}!\", hasher.finish());\n+    /// ```\n+    ///\n+    /// [`Hasher`]: trait.Hasher.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn hash<H: Hasher>(&self, state: &mut H);\n \n-    /// Feeds a slice of this type into the state provided.\n+    /// Feeds a slice of this type into the given [`Hasher`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::hash_map::DefaultHasher;\n+    /// use std::hash::{Hash, Hasher};\n+    ///\n+    /// let mut hasher = DefaultHasher::new();\n+    /// let numbers = [6, 28, 496, 8128];\n+    /// Hash::hash_slice(&numbers, &mut hasher);\n+    /// println!(\"Hash is {:x}!\", hasher.finish());\n+    /// ```\n+    ///\n+    /// [`Hasher`]: trait.Hasher.html\n     #[stable(feature = \"hash_slice\", since = \"1.3.0\")]\n     fn hash_slice<H: Hasher>(data: &[Self], state: &mut H)\n         where Self: Sized\n@@ -169,18 +208,73 @@ pub trait Hash {\n     }\n }\n \n-/// A trait which represents the ability to hash an arbitrary stream of bytes.\n+/// A trait for hashing an arbitrary stream of bytes.\n+///\n+/// Instances of `Hasher` usually represent state that is changed while hashing\n+/// data.\n+///\n+/// `Hasher` provides a fairly basic interface for retrieving the generated hash\n+/// (with [`finish`]), and writing integers as well as slices of bytes into an\n+/// instance (with [`write`] and [`write_u8`] etc.). Most of the time, `Hasher`\n+/// instances are used in conjunction with the [`Hash`] trait.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::collections::hash_map::DefaultHasher;\n+/// use std::hash::Hasher;\n+///\n+/// let mut hasher = DefaultHasher::new();\n+///\n+/// hasher.write_u32(1989);\n+/// hasher.write_u8(11);\n+/// hasher.write_u8(9);\n+/// hasher.write(b\"Huh?\");\n+///\n+/// println!(\"Hash is {:x}!\", hasher.finish());\n+/// ```\n+///\n+/// [`Hash`]: trait.Hash.html\n+/// [`finish`]: #tymethod.finish\n+/// [`write`]: #tymethod.write\n+/// [`write_u8`]: #method.write_u8\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Hasher {\n     /// Completes a round of hashing, producing the output hash generated.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::hash_map::DefaultHasher;\n+    /// use std::hash::Hasher;\n+    ///\n+    /// let mut hasher = DefaultHasher::new();\n+    /// hasher.write(b\"Cool!\");\n+    ///\n+    /// println!(\"Hash is {:x}!\", hasher.finish());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn finish(&self) -> u64;\n \n     /// Writes some data into this `Hasher`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::hash_map::DefaultHasher;\n+    /// use std::hash::Hasher;\n+    ///\n+    /// let mut hasher = DefaultHasher::new();\n+    /// let data = [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef];\n+    ///\n+    /// hasher.write(&data);\n+    ///\n+    /// println!(\"Hash is {:x}!\", hasher.finish());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn write(&mut self, bytes: &[u8]);\n \n-    /// Write a single `u8` into this hasher.\n+    /// Writes a single `u8` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n     fn write_u8(&mut self, i: u8) {\n@@ -258,12 +352,35 @@ pub trait Hasher {\n     }\n }\n \n-/// A `BuildHasher` is typically used as a factory for instances of `Hasher`\n-/// which a `HashMap` can then use to hash keys independently.\n+/// A trait for creating instances of [`Hasher`].\n+///\n+/// A `BuildHasher` is typically used (e.g. by [`HashMap`]) to create\n+/// [`Hasher`]s for each key such that they are hashed independently of one\n+/// another, since [`Hasher`]s contain state.\n+///\n+/// For each instance of `BuildHasher`, the [`Hasher`]s created by\n+/// [`build_hasher`] should be identical. That is, if the same stream of bytes\n+/// is fed into each hasher, the same output will also be generated.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::collections::hash_map::RandomState;\n+/// use std::hash::{BuildHasher, Hasher};\n+///\n+/// let s = RandomState::new();\n+/// let mut hasher_1 = s.build_hasher();\n+/// let mut hasher_2 = s.build_hasher();\n ///\n-/// Note that for each instance of `BuildHasher`, the created hashers should be\n-/// identical. That is, if the same stream of bytes is fed into each hasher, the\n-/// same output will also be generated.\n+/// hasher_1.write_u32(8128);\n+/// hasher_2.write_u32(8128);\n+///\n+/// assert_eq!(hasher_1.finish(), hasher_2.finish());\n+/// ```\n+///\n+/// [`build_hasher`]: #tymethod.build_hasher\n+/// [`Hasher`]: trait.Hasher.html\n+/// [`HashMap`]: ../../std/collections/struct.HashMap.html\n #[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n pub trait BuildHasher {\n     /// Type of the hasher that will be created.\n@@ -272,6 +389,9 @@ pub trait BuildHasher {\n \n     /// Creates a new hasher.\n     ///\n+    /// Each call to `build_hasher` on the same instance should produce identical\n+    /// [`Hasher`]s.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -281,15 +401,23 @@ pub trait BuildHasher {\n     /// let s = RandomState::new();\n     /// let new_s = s.build_hasher();\n     /// ```\n+    ///\n+    /// [`Hasher`]: trait.Hasher.html\n     #[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n     fn build_hasher(&self) -> Self::Hasher;\n }\n \n-/// The `BuildHasherDefault` structure is used in scenarios where one has a\n-/// type that implements [`Hasher`] and [`Default`], but needs that type to\n-/// implement [`BuildHasher`].\n+/// Used to create a default [`BuildHasher`] instance for types that implement\n+/// [`Hasher`] and [`Default`].\n ///\n-/// This structure is zero-sized and does not need construction.\n+/// `BuildHasherDefault<H>` can be used when a type `H` implements [`Hasher`] and\n+/// [`Default`], and you need a corresponding [`BuildHasher`] instance, but none is\n+/// defined.\n+///\n+/// Any `BuildHasherDefault` is [zero-sized]. It can be created with\n+/// [`default`][method.Default]. When using `BuildHasherDefault` with [`HashMap`] or\n+/// [`HashSet`], this doesn't need to be done, since they implement appropriate\n+/// [`Default`] instances themselves.\n ///\n /// # Examples\n ///\n@@ -322,8 +450,11 @@ pub trait BuildHasher {\n ///\n /// [`BuildHasher`]: trait.BuildHasher.html\n /// [`Default`]: ../default/trait.Default.html\n+/// [method.default]: #method.default\n /// [`Hasher`]: trait.Hasher.html\n /// [`HashMap`]: ../../std/collections/struct.HashMap.html\n+/// [`HashSet`]: ../../std/collections/struct.HashSet.html\n+/// [zero-sized]: https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts\n #[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n pub struct BuildHasherDefault<H>(marker::PhantomData<H>);\n "}, {"sha": "410eb2b84849e0a830bb0dddf9b90cb7d386cc7d", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/be1a74e4d3e629a350928e850514541782b46fdd/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be1a74e4d3e629a350928e850514541782b46fdd/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=be1a74e4d3e629a350928e850514541782b46fdd", "patch": "@@ -1736,7 +1736,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 if other.evaluation == EvaluatedToOk {\n                     if let ImplCandidate(victim_def) = victim.candidate {\n                         let tcx = self.tcx().global_tcx();\n-                        return traits::specializes(tcx, other_def, victim_def);\n+                        return traits::specializes(tcx, other_def, victim_def) ||\n+                            tcx.impls_are_allowed_to_overlap(other_def, victim_def);\n                     }\n                 }\n "}, {"sha": "6e2c16c82aeb42274fd30c21a4a058a66d607e00", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be1a74e4d3e629a350928e850514541782b46fdd/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be1a74e4d3e629a350928e850514541782b46fdd/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=be1a74e4d3e629a350928e850514541782b46fdd", "patch": "@@ -113,6 +113,10 @@ impl<'a, 'gcx, 'tcx> Children {\n                                                         possible_sibling,\n                                                         impl_def_id);\n                 if let Some(impl_header) = overlap {\n+                    if tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling) {\n+                        return Ok((false, false));\n+                    }\n+\n                     let le = specializes(tcx, impl_def_id, possible_sibling);\n                     let ge = specializes(tcx, possible_sibling, impl_def_id);\n "}, {"sha": "3da9383762bc6c682889daef12a5be762b0215cc", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/be1a74e4d3e629a350928e850514541782b46fdd/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be1a74e4d3e629a350928e850514541782b46fdd/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=be1a74e4d3e629a350928e850514541782b46fdd", "patch": "@@ -2227,6 +2227,25 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         queries::impl_trait_ref::get(self, DUMMY_SP, id)\n     }\n \n+    /// Returns true if the impls are the same polarity and are implementing\n+    /// a trait which contains no items\n+    pub fn impls_are_allowed_to_overlap(self, def_id1: DefId, def_id2: DefId) -> bool {\n+        if !self.sess.features.borrow().overlapping_marker_traits {\n+            return false;\n+        }\n+        let trait1_is_empty = self.impl_trait_ref(def_id1)\n+            .map_or(false, |trait_ref| {\n+                self.associated_item_def_ids(trait_ref.def_id).is_empty()\n+            });\n+        let trait2_is_empty = self.impl_trait_ref(def_id2)\n+            .map_or(false, |trait_ref| {\n+                self.associated_item_def_ids(trait_ref.def_id).is_empty()\n+            });\n+        self.trait_impl_polarity(def_id1) == self.trait_impl_polarity(def_id2)\n+            && trait1_is_empty\n+            && trait2_is_empty\n+    }\n+\n     // Returns `ty::VariantDef` if `def` refers to a struct,\n     // or variant or their constructors, panics otherwise.\n     pub fn expect_variant_def(self, def: Def) -> &'tcx VariantDef {"}, {"sha": "6e455234196d461d6430838a1e6c6bd10be46927", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/be1a74e4d3e629a350928e850514541782b46fdd/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be1a74e4d3e629a350928e850514541782b46fdd/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=be1a74e4d3e629a350928e850514541782b46fdd", "patch": "@@ -349,6 +349,9 @@ declare_features! (\n \n     // Allows module-level inline assembly by way of global_asm!()\n     (active, global_asm, \"1.18.0\", Some(35119)),\n+\n+    // Allows overlapping impls of marker traits\n+    (active, overlapping_marker_traits, \"1.18.0\", Some(29864)),\n );\n \n declare_features! ("}, {"sha": "80cc0d2680f7c5a7456d22ade460122aaf963eeb", "filename": "src/test/compile-fail/E0120.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Fcompile-fail%2FE0120.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Fcompile-fail%2FE0120.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0120.rs?ref=be1a74e4d3e629a350928e850514541782b46fdd", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait MyTrait {}\n+trait MyTrait { fn foo() {} }\n \n impl Drop for MyTrait {\n               //~^ ERROR E0120"}, {"sha": "3190ce430ad67ca41fc32553745bc6b016e52678", "filename": "src/test/compile-fail/auxiliary/trait_impl_conflict.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Ftrait_impl_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Ftrait_impl_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Ftrait_impl_conflict.rs?ref=be1a74e4d3e629a350928e850514541782b46fdd", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n pub trait Foo {\n+    fn foo() {}\n }\n \n impl Foo for isize {"}, {"sha": "8e9d1eff34580575dc64b4ba6e43c77ae09c6f2c", "filename": "src/test/compile-fail/coherence-conflicting-negative-trait-impl.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Fcompile-fail%2Fcoherence-conflicting-negative-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Fcompile-fail%2Fcoherence-conflicting-negative-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-conflicting-negative-trait-impl.rs?ref=be1a74e4d3e629a350928e850514541782b46fdd", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![feature(optin_builtin_traits)]\n+#![feature(overlapping_marker_traits)]\n \n trait MyTrait {}\n \n@@ -20,8 +21,8 @@ impl<T: MyTrait> !Send for TestType<T> {}\n //~^ ERROR conflicting implementations of trait `std::marker::Send`\n \n unsafe impl<T:'static> Send for TestType<T> {}\n-//~^ ERROR conflicting implementations of trait `std::marker::Send`\n \n impl !Send for TestType<i32> {}\n+//~^ ERROR conflicting implementations of trait `std::marker::Send`\n \n fn main() {}"}, {"sha": "e6bf068156c2b037fcf4d99a987cfc8a2e6c9c74", "filename": "src/test/compile-fail/coherence-default-trait-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Fcompile-fail%2Fcoherence-default-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Fcompile-fail%2Fcoherence-default-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-default-trait-impl.rs?ref=be1a74e4d3e629a350928e850514541782b46fdd", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(optin_builtin_traits)]\n \n-trait MyTrait {}\n+trait MyTrait { fn foo() {} }\n \n impl MyTrait for .. {}\n //~^ ERROR redundant default implementations of trait `MyTrait`"}, {"sha": "9caaee41aeb1dba09b2ad576a83cba1a559d3143", "filename": "src/test/compile-fail/coherence-impls-send.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-send.rs?ref=be1a74e4d3e629a350928e850514541782b46fdd", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![feature(optin_builtin_traits)]\n+#![feature(overlapping_marker_traits)]\n \n use std::marker::Copy;\n \n@@ -34,7 +35,6 @@ unsafe impl Send for [MyType] {}\n \n unsafe impl Send for &'static [NotSync] {}\n //~^ ERROR E0117\n-//~| ERROR E0119\n \n fn main() {\n }"}, {"sha": "47026cd32d411a6f51033000677c775d1e657c7f", "filename": "src/test/compile-fail/coherence-no-direct-lifetime-dispatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Fcompile-fail%2Fcoherence-no-direct-lifetime-dispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Fcompile-fail%2Fcoherence-no-direct-lifetime-dispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-no-direct-lifetime-dispatch.rs?ref=be1a74e4d3e629a350928e850514541782b46fdd", "patch": "@@ -10,7 +10,7 @@\n \n // Test that you cannot *directly* dispatch on lifetime requirements\n \n-trait MyTrait {}\n+trait MyTrait { fn foo() {} }\n \n impl<T> MyTrait for T {}\n impl<T: 'static> MyTrait for T {} //~ ERROR E0119"}, {"sha": "1fad608db6c3b1a3e52c5c1e62d0f7746a22ad0d", "filename": "src/test/compile-fail/coherence-overlap-all-t-and-tuple.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-all-t-and-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-all-t-and-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-all-t-and-tuple.rs?ref=be1a74e4d3e629a350928e850514541782b46fdd", "patch": "@@ -17,6 +17,7 @@\n // Seems pretty basic, but then there was issue #24241. :)\n \n trait From<U> {\n+    fn foo() {}\n }\n \n impl <T> From<T> for T {"}, {"sha": "a10deeafbe67e267f3b7100f3584436696b61cb9", "filename": "src/test/compile-fail/coherence-overlap-messages.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-messages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-messages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-messages.rs?ref=be1a74e4d3e629a350928e850514541782b46fdd", "patch": "@@ -8,22 +8,22 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait Foo {}\n+trait Foo { fn foo() {} }\n \n impl<T> Foo for T {}\n impl<U> Foo for U {} //~ ERROR conflicting implementations of trait `Foo`:\n \n-trait Bar {}\n+trait Bar { fn bar() {} }\n \n impl<T> Bar for (T, u8) {}\n impl<T> Bar for (u8, T) {} //~ ERROR conflicting implementations of trait `Bar` for type `(u8, u8)`:\n \n-trait Baz<T> {}\n+trait Baz<T> { fn baz() {} }\n \n impl<T> Baz<u8> for T {}\n impl<T> Baz<T> for u8 {} //~ ERROR conflicting implementations of trait `Baz<u8>` for type `u8`:\n \n-trait Quux<U, V> {}\n+trait Quux<U, V> { fn quux() {} }\n \n impl<T, U, V> Quux<U, V> for T {}\n impl<T, U> Quux<U, U> for T {} //~ ERROR conflicting implementations of trait `Quux<_, _>`:"}, {"sha": "784ff0cd5e0aa72982f288efcfbaf92cd34d88bc", "filename": "src/test/compile-fail/coherence-projection-conflict-orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Fcompile-fail%2Fcoherence-projection-conflict-orphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Fcompile-fail%2Fcoherence-projection-conflict-orphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-projection-conflict-orphan.rs?ref=be1a74e4d3e629a350928e850514541782b46fdd", "patch": "@@ -15,7 +15,7 @@\n // due to the orphan rules. Therefore, `A::Item` may yet turn out to\n // be `i32`.\n \n-pub trait Foo<P> {}\n+pub trait Foo<P> { fn foo() {} }\n \n pub trait Bar {\n     type Output: 'static;"}, {"sha": "120d9046389a18fb3a5d834c39b132049b3cb401", "filename": "src/test/compile-fail/coherence-projection-conflict-ty-param.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Fcompile-fail%2Fcoherence-projection-conflict-ty-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Fcompile-fail%2Fcoherence-projection-conflict-ty-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-projection-conflict-ty-param.rs?ref=be1a74e4d3e629a350928e850514541782b46fdd", "patch": "@@ -13,7 +13,7 @@\n \n use std::marker::PhantomData;\n \n-pub trait Foo<P> {}\n+pub trait Foo<P> { fn foo() {} }\n \n impl <P, T: Foo<P>> Foo<P> for Option<T> {}\n "}, {"sha": "3c32ab38b93dc15da014d66ad612824a6a4c012f", "filename": "src/test/compile-fail/coherence-projection-conflict.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Fcompile-fail%2Fcoherence-projection-conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Fcompile-fail%2Fcoherence-projection-conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-projection-conflict.rs?ref=be1a74e4d3e629a350928e850514541782b46fdd", "patch": "@@ -10,7 +10,7 @@\n \n use std::marker::PhantomData;\n \n-pub trait Foo<P> {}\n+pub trait Foo<P> { fn foo() {} }\n \n pub trait Bar {\n     type Output: 'static;"}, {"sha": "9fbb7aa4cb1a7f70a180821a46bd137fdda6503a", "filename": "src/test/compile-fail/coherence_copy_like_err_fundamental_struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct.rs?ref=be1a74e4d3e629a350928e850514541782b46fdd", "patch": "@@ -20,7 +20,7 @@ extern crate coherence_copy_like_lib as lib;\n \n struct MyType { x: i32 }\n \n-trait MyTrait { }\n+trait MyTrait { fn foo() {} }\n impl<T: lib::MyCopy> MyTrait for T { }\n \n // `MyFundamentalStruct` is declared fundamental, so we can test that"}, {"sha": "2f6dca4f3c2715ae4915cab7ea847f7dc1f401a6", "filename": "src/test/compile-fail/coherence_copy_like_err_fundamental_struct_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct_ref.rs?ref=be1a74e4d3e629a350928e850514541782b46fdd", "patch": "@@ -20,7 +20,7 @@ extern crate coherence_copy_like_lib as lib;\n \n struct MyType { x: i32 }\n \n-trait MyTrait { }\n+trait MyTrait { fn foo() {} }\n impl<T: lib::MyCopy> MyTrait for T { }\n \n // `MyFundamentalStruct` is declared fundamental, so we can test that"}, {"sha": "f424e8872010f25d5d4414a5ff07d1e3d636f48f", "filename": "src/test/compile-fail/coherence_copy_like_err_fundamental_struct_tuple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct_tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct_tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct_tuple.rs?ref=be1a74e4d3e629a350928e850514541782b46fdd", "patch": "@@ -19,7 +19,7 @@ extern crate coherence_copy_like_lib as lib;\n \n struct MyType { x: i32 }\n \n-trait MyTrait { }\n+trait MyTrait { fn foo() {} }\n \n impl<T: lib::MyCopy> MyTrait for T { }\n "}, {"sha": "04262e65c5a2afe8d2ff72e4113ce08165ef35ae", "filename": "src/test/compile-fail/coherence_copy_like_err_struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_struct.rs?ref=be1a74e4d3e629a350928e850514541782b46fdd", "patch": "@@ -17,7 +17,7 @@ extern crate coherence_copy_like_lib as lib;\n \n struct MyType { x: i32 }\n \n-trait MyTrait { }\n+trait MyTrait { fn foo() {} }\n impl<T: lib::MyCopy> MyTrait for T { }\n \n // `MyStruct` is not declared fundamental, therefore this would"}, {"sha": "378a70864f0eedb93cf06ff9988b8ff55eabccc8", "filename": "src/test/compile-fail/coherence_copy_like_err_tuple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_tuple.rs?ref=be1a74e4d3e629a350928e850514541782b46fdd", "patch": "@@ -17,7 +17,7 @@ extern crate coherence_copy_like_lib as lib;\n \n struct MyType { x: i32 }\n \n-trait MyTrait { }\n+trait MyTrait { fn foo() {} }\n impl<T: lib::MyCopy> MyTrait for T { }\n \n // Tuples are not fundamental, therefore this would require that"}, {"sha": "d2aa4e59b5ba9615455f4feebf4ade3137fc9ada", "filename": "src/test/compile-fail/feature-gate-overlapping_marker_traits.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Fcompile-fail%2Ffeature-gate-overlapping_marker_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Fcompile-fail%2Ffeature-gate-overlapping_marker_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-overlapping_marker_traits.rs?ref=be1a74e4d3e629a350928e850514541782b46fdd", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt::{Debug, Display};\n+\n+trait MyMarker {}\n+\n+impl<T: Display> MyMarker for T {}\n+impl<T: Debug> MyMarker for T {}\n+//~^ ERROR E0119\n+\n+fn main() {}"}, {"sha": "a649ae25f34ead92744b02549bc24282171dde6a", "filename": "src/test/compile-fail/overlap-marker-trait.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Fcompile-fail%2Foverlap-marker-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Fcompile-fail%2Foverlap-marker-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foverlap-marker-trait.rs?ref=be1a74e4d3e629a350928e850514541782b46fdd", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test for RFC 1268: we allow overlapping impls of marker traits,\n+// that is, traits without items. In this case, a type `T` is\n+// `MyMarker` if it is either `Debug` or `Display`. This test just\n+// checks that we don't consider **all** types to be `MyMarker`.  See\n+// also the companion test in\n+// `run-pass/overlap-permitted-for-marker-traits.rs`.\n+\n+#![feature(overlapping_marker_traits)]\n+#![feature(optin_builtin_traits)]\n+\n+use std::fmt::{Debug, Display};\n+\n+trait Marker {}\n+\n+impl<T: Debug> Marker for T {}\n+impl<T: Display> Marker for T {}\n+\n+fn is_marker<T: Marker>() { }\n+\n+struct NotDebugOrDisplay;\n+\n+fn main() {\n+    // Debug && Display:\n+    is_marker::<i32>();\n+\n+    // Debug && !Display:\n+    is_marker::<Vec<i32>>();\n+\n+    // !Debug && !Display\n+    is_marker::<NotDebugOrDisplay>(); //~ ERROR\n+}"}, {"sha": "ff12a82db5b7dff2ded854e7a4de119bd7800cd4", "filename": "src/test/compile-fail/specialization/specialization-overlap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fspecialization-overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fspecialization-overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fspecialization-overlap.rs?ref=be1a74e4d3e629a350928e850514541782b46fdd", "patch": "@@ -10,19 +10,19 @@\n \n #![feature(specialization)]\n \n-trait Foo {}\n+trait Foo { fn foo() {} }\n impl<T: Clone> Foo for T {}\n impl<T> Foo for Vec<T> {} //~ ERROR E0119\n \n-trait Bar {}\n+trait Bar { fn bar() {} }\n impl<T> Bar for (T, u8) {}\n impl<T> Bar for (u8, T) {} //~ ERROR E0119\n \n-trait Baz<U> {}\n+trait Baz<U> { fn baz() {} }\n impl<T> Baz<T> for u8 {}\n impl<T> Baz<u8> for T {} //~ ERROR E0119\n \n-trait Qux {}\n+trait Qux { fn qux() {} }\n impl<T: Clone> Qux for T {}\n impl<T: Eq> Qux for T {} //~ ERROR E0119\n "}, {"sha": "ed45d81c0d6a155937f7514f4019d8d261f06e56", "filename": "src/test/run-pass/overlap-doesnt-conflict-with-specialization.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Frun-pass%2Foverlap-doesnt-conflict-with-specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Frun-pass%2Foverlap-doesnt-conflict-with-specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverlap-doesnt-conflict-with-specialization.rs?ref=be1a74e4d3e629a350928e850514541782b46fdd", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(overlapping_marker_traits)]\n+#![feature(specialization)]\n+\n+trait MyMarker {}\n+\n+impl<T> MyMarker for T {}\n+impl<T> MyMarker for Vec<T> {}\n+\n+fn foo<T: MyMarker>(t: T) -> T {\n+    t\n+}\n+\n+fn main() {\n+    assert_eq!(1, foo(1));\n+    assert_eq!(2.0, foo(2.0));\n+    assert_eq!(vec![1], foo(vec![1]));\n+}"}, {"sha": "740d5d22ab5078a5290923df174be6a6e2607d51", "filename": "src/test/run-pass/overlap-permitted-for-marker-traits-neg.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Frun-pass%2Foverlap-permitted-for-marker-traits-neg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Frun-pass%2Foverlap-permitted-for-marker-traits-neg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverlap-permitted-for-marker-traits-neg.rs?ref=be1a74e4d3e629a350928e850514541782b46fdd", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(overlapping_marker_traits)]\n+#![feature(optin_builtin_traits)]\n+\n+// Overlapping negative impls for `MyStruct` are permitted:\n+struct MyStruct;\n+impl !Send for MyStruct {}\n+impl !Send for MyStruct {}\n+\n+fn main() {\n+}"}, {"sha": "11a46299d8c83a2d68ff495a52d17714116cf783", "filename": "src/test/run-pass/overlap-permitted-for-marker-traits.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Frun-pass%2Foverlap-permitted-for-marker-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be1a74e4d3e629a350928e850514541782b46fdd/src%2Ftest%2Frun-pass%2Foverlap-permitted-for-marker-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverlap-permitted-for-marker-traits.rs?ref=be1a74e4d3e629a350928e850514541782b46fdd", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests for RFC 1268: we allow overlapping impls of marker traits,\n+// that is, traits without items. In this case, a type `T` is\n+// `MyMarker` if it is either `Debug` or `Display`.\n+\n+#![feature(overlapping_marker_traits)]\n+#![feature(optin_builtin_traits)]\n+\n+use std::fmt::{Debug, Display};\n+\n+trait MyMarker {}\n+\n+impl<T: Debug> MyMarker for T {}\n+impl<T: Display> MyMarker for T {}\n+\n+fn foo<T: MyMarker>(t: T) -> T {\n+    t\n+}\n+\n+fn main() {\n+    // Debug && Display:\n+    assert_eq!(1, foo(1));\n+    assert_eq!(2.0, foo(2.0));\n+\n+    // Debug && !Display:\n+    assert_eq!(vec![1], foo(vec![1]));\n+}"}]}