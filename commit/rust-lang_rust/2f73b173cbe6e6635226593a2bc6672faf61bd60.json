{"sha": "2f73b173cbe6e6635226593a2bc6672faf61bd60", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmNzNiMTczY2JlNmU2NjM1MjI2NTkzYTJiYzY2NzJmYWY2MWJkNjA=", "commit": {"author": {"name": "Artem Chernyak", "email": "artemchernyak@gmail.com", "date": "2017-04-29T03:44:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-04-29T03:44:34Z"}, "message": "Merge branch 'master' into def_span", "tree": {"sha": "fd55a6bed0b70db92af5a26ff1eae35458c8ef83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd55a6bed0b70db92af5a26ff1eae35458c8ef83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f73b173cbe6e6635226593a2bc6672faf61bd60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f73b173cbe6e6635226593a2bc6672faf61bd60", "html_url": "https://github.com/rust-lang/rust/commit/2f73b173cbe6e6635226593a2bc6672faf61bd60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f73b173cbe6e6635226593a2bc6672faf61bd60/comments", "author": {"login": "hackeryarn", "id": 827709, "node_id": "MDQ6VXNlcjgyNzcwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/827709?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hackeryarn", "html_url": "https://github.com/hackeryarn", "followers_url": "https://api.github.com/users/hackeryarn/followers", "following_url": "https://api.github.com/users/hackeryarn/following{/other_user}", "gists_url": "https://api.github.com/users/hackeryarn/gists{/gist_id}", "starred_url": "https://api.github.com/users/hackeryarn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hackeryarn/subscriptions", "organizations_url": "https://api.github.com/users/hackeryarn/orgs", "repos_url": "https://api.github.com/users/hackeryarn/repos", "events_url": "https://api.github.com/users/hackeryarn/events{/privacy}", "received_events_url": "https://api.github.com/users/hackeryarn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba90718bb44fe7e2a5edbcc3e5503ee1f7feebd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba90718bb44fe7e2a5edbcc3e5503ee1f7feebd5", "html_url": "https://github.com/rust-lang/rust/commit/ba90718bb44fe7e2a5edbcc3e5503ee1f7feebd5"}, {"sha": "810ed98d08158574e98b504c0955fce6c6a72ad9", "url": "https://api.github.com/repos/rust-lang/rust/commits/810ed98d08158574e98b504c0955fce6c6a72ad9", "html_url": "https://github.com/rust-lang/rust/commit/810ed98d08158574e98b504c0955fce6c6a72ad9"}], "stats": {"total": 2076, "additions": 1121, "deletions": 955}, "files": [{"sha": "5d97ccaabbf02ee57252f03363d2a8e844cb39b1", "filename": "src/Cargo.lock", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -366,14 +366,6 @@ dependencies = [\n  \"bitflags 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"qemu-test-client\"\n-version = \"0.1.0\"\n-\n-[[package]]\n-name = \"qemu-test-server\"\n-version = \"0.1.0\"\n-\n [[package]]\n name = \"quick-error\"\n version = \"1.1.0\"\n@@ -403,6 +395,14 @@ name = \"regex-syntax\"\n version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"remote-test-client\"\n+version = \"0.1.0\"\n+\n+[[package]]\n+name = \"remote-test-server\"\n+version = \"0.1.0\"\n+\n [[package]]\n name = \"rls-data\"\n version = \"0.1.0\""}, {"sha": "8f6150c6438fe058e74cbf5da565e904106e9d26", "filename": "src/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.toml?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -11,8 +11,8 @@ members = [\n   \"tools/rustbook\",\n   \"tools/tidy\",\n   \"tools/build-manifest\",\n-  \"tools/qemu-test-client\",\n-  \"tools/qemu-test-server\",\n+  \"tools/remote-test-client\",\n+  \"tools/remote-test-server\",\n ]\n \n # Curiously, compiletest will segfault if compiled with opt-level=3 on 64-bit"}, {"sha": "1bcec2cdedec45ce208dbb4bc01baf22f9005b47", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 27, "deletions": 113, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -28,7 +28,7 @@ use {Build, Compiler, Mode};\n use dist;\n use util::{self, dylib_path, dylib_path_var, exe};\n \n-const ADB_TEST_DIR: &'static str = \"/data/tmp\";\n+const ADB_TEST_DIR: &'static str = \"/data/tmp/work\";\n \n /// The two modes of the test runner; tests or benchmarks.\n #[derive(Copy, Clone)]\n@@ -243,10 +243,10 @@ pub fn compiletest(build: &Build,\n            .arg(\"--llvm-cxxflags\").arg(\"\");\n     }\n \n-    if build.qemu_rootfs(target).is_some() {\n-        cmd.arg(\"--qemu-test-client\")\n+    if build.remote_tested(target) {\n+        cmd.arg(\"--remote-test-client\")\n            .arg(build.tool(&Compiler::new(0, &build.config.build),\n-                           \"qemu-test-client\"));\n+                           \"remote-test-client\"));\n     }\n \n     // Running a C compiler on MSVC requires a few env vars to be set, to be\n@@ -445,9 +445,7 @@ pub fn krate(build: &Build,\n     dylib_path.insert(0, build.sysroot_libdir(&compiler, target));\n     cargo.env(dylib_path_var(), env::join_paths(&dylib_path).unwrap());\n \n-    if target.contains(\"android\") ||\n-       target.contains(\"emscripten\") ||\n-       build.qemu_rootfs(target).is_some() {\n+    if target.contains(\"emscripten\") || build.remote_tested(target) {\n         cargo.arg(\"--no-run\");\n     }\n \n@@ -459,75 +457,24 @@ pub fn krate(build: &Build,\n \n     let _time = util::timeit();\n \n-    if target.contains(\"android\") {\n-        build.run(&mut cargo);\n-        krate_android(build, &compiler, target, mode);\n-    } else if target.contains(\"emscripten\") {\n+    if target.contains(\"emscripten\") {\n         build.run(&mut cargo);\n         krate_emscripten(build, &compiler, target, mode);\n-    } else if build.qemu_rootfs(target).is_some() {\n+    } else if build.remote_tested(target) {\n         build.run(&mut cargo);\n-        krate_qemu(build, &compiler, target, mode);\n+        krate_remote(build, &compiler, target, mode);\n     } else {\n         cargo.args(&build.flags.cmd.test_args());\n         build.run(&mut cargo);\n     }\n }\n \n-fn krate_android(build: &Build,\n-                 compiler: &Compiler,\n-                 target: &str,\n-                 mode: Mode) {\n-    let mut tests = Vec::new();\n-    let out_dir = build.cargo_out(compiler, mode, target);\n-    find_tests(&out_dir, target, &mut tests);\n-    find_tests(&out_dir.join(\"deps\"), target, &mut tests);\n-\n-    for test in tests {\n-        build.run(Command::new(\"adb\").arg(\"push\").arg(&test).arg(ADB_TEST_DIR));\n-\n-        let test_file_name = test.file_name().unwrap().to_string_lossy();\n-        let log = format!(\"{}/check-stage{}-T-{}-H-{}-{}.log\",\n-                          ADB_TEST_DIR,\n-                          compiler.stage,\n-                          target,\n-                          compiler.host,\n-                          test_file_name);\n-        let quiet = if build.config.quiet_tests { \"--quiet\" } else { \"\" };\n-        let program = format!(\"(cd {dir}; \\\n-                                LD_LIBRARY_PATH=./{target} ./{test} \\\n-                                    --logfile {log} \\\n-                                    {quiet} \\\n-                                    {args})\",\n-                              dir = ADB_TEST_DIR,\n-                              target = target,\n-                              test = test_file_name,\n-                              log = log,\n-                              quiet = quiet,\n-                              args = build.flags.cmd.test_args().join(\" \"));\n-\n-        let output = output(Command::new(\"adb\").arg(\"shell\").arg(&program));\n-        println!(\"{}\", output);\n-\n-        t!(fs::create_dir_all(build.out.join(\"tmp\")));\n-        build.run(Command::new(\"adb\")\n-                          .arg(\"pull\")\n-                          .arg(&log)\n-                          .arg(build.out.join(\"tmp\")));\n-        build.run(Command::new(\"adb\").arg(\"shell\").arg(\"rm\").arg(&log));\n-        if !output.contains(\"result: ok\") {\n-            panic!(\"some tests failed\");\n-        }\n-    }\n-}\n-\n fn krate_emscripten(build: &Build,\n                     compiler: &Compiler,\n                     target: &str,\n                     mode: Mode) {\n     let mut tests = Vec::new();\n     let out_dir = build.cargo_out(compiler, mode, target);\n-    find_tests(&out_dir, target, &mut tests);\n     find_tests(&out_dir.join(\"deps\"), target, &mut tests);\n \n     for test in tests {\n@@ -543,17 +490,16 @@ fn krate_emscripten(build: &Build,\n     }\n }\n \n-fn krate_qemu(build: &Build,\n-              compiler: &Compiler,\n-              target: &str,\n-              mode: Mode) {\n+fn krate_remote(build: &Build,\n+                compiler: &Compiler,\n+                target: &str,\n+                mode: Mode) {\n     let mut tests = Vec::new();\n     let out_dir = build.cargo_out(compiler, mode, target);\n-    find_tests(&out_dir, target, &mut tests);\n     find_tests(&out_dir.join(\"deps\"), target, &mut tests);\n \n     let tool = build.tool(&Compiler::new(0, &build.config.build),\n-                          \"qemu-test-client\");\n+                          \"remote-test-client\");\n     for test in tests {\n         let mut cmd = Command::new(&tool);\n         cmd.arg(\"run\")\n@@ -566,7 +512,6 @@ fn krate_qemu(build: &Build,\n     }\n }\n \n-\n fn find_tests(dir: &Path,\n               target: &str,\n               dst: &mut Vec<PathBuf>) {\n@@ -585,59 +530,28 @@ fn find_tests(dir: &Path,\n }\n \n pub fn emulator_copy_libs(build: &Build, compiler: &Compiler, target: &str) {\n-    if target.contains(\"android\") {\n-        android_copy_libs(build, compiler, target)\n-    } else if let Some(s) = build.qemu_rootfs(target) {\n-        qemu_copy_libs(build, compiler, target, s)\n-    }\n-}\n-\n-fn android_copy_libs(build: &Build, compiler: &Compiler, target: &str) {\n-    println!(\"Android copy libs to emulator ({})\", target);\n-    build.run(Command::new(\"adb\").arg(\"wait-for-device\"));\n-    build.run(Command::new(\"adb\").arg(\"remount\"));\n-    build.run(Command::new(\"adb\").args(&[\"shell\", \"rm\", \"-r\", ADB_TEST_DIR]));\n-    build.run(Command::new(\"adb\").args(&[\"shell\", \"mkdir\", ADB_TEST_DIR]));\n-    build.run(Command::new(\"adb\")\n-                      .arg(\"push\")\n-                      .arg(build.src.join(\"src/etc/adb_run_wrapper.sh\"))\n-                      .arg(ADB_TEST_DIR));\n-\n-    let target_dir = format!(\"{}/{}\", ADB_TEST_DIR, target);\n-    build.run(Command::new(\"adb\").args(&[\"shell\", \"mkdir\", &target_dir]));\n-\n-    for f in t!(build.sysroot_libdir(compiler, target).read_dir()) {\n-        let f = t!(f);\n-        let name = f.file_name().into_string().unwrap();\n-        if util::is_dylib(&name) {\n-            build.run(Command::new(\"adb\")\n-                              .arg(\"push\")\n-                              .arg(f.path())\n-                              .arg(&target_dir));\n-        }\n+    if !build.remote_tested(target) {\n+        return\n     }\n-}\n \n-fn qemu_copy_libs(build: &Build,\n-                  compiler: &Compiler,\n-                  target: &str,\n-                  rootfs: &Path) {\n-    println!(\"QEMU copy libs to emulator ({})\", target);\n-    assert!(target.starts_with(\"arm\"), \"only works with arm for now\");\n+    println!(\"REMOTE copy libs to emulator ({})\", target);\n     t!(fs::create_dir_all(build.out.join(\"tmp\")));\n \n-    // Copy our freshly compiled test server over to the rootfs\n     let server = build.cargo_out(compiler, Mode::Tool, target)\n-                      .join(exe(\"qemu-test-server\", target));\n-    t!(fs::copy(&server, rootfs.join(\"testd\")));\n+                      .join(exe(\"remote-test-server\", target));\n \n     // Spawn the emulator and wait for it to come online\n     let tool = build.tool(&Compiler::new(0, &build.config.build),\n-                          \"qemu-test-client\");\n-    build.run(Command::new(&tool)\n-                      .arg(\"spawn-emulator\")\n-                      .arg(rootfs)\n-                      .arg(build.out.join(\"tmp\")));\n+                          \"remote-test-client\");\n+    let mut cmd = Command::new(&tool);\n+    cmd.arg(\"spawn-emulator\")\n+       .arg(target)\n+       .arg(&server)\n+       .arg(build.out.join(\"tmp\"));\n+    if let Some(rootfs) = build.qemu_rootfs(target) {\n+        cmd.arg(rootfs);\n+    }\n+    build.run(&mut cmd);\n \n     // Push all our dylibs to the emulator\n     for f in t!(build.sysroot_libdir(compiler, target).read_dir()) {"}, {"sha": "74c58844741c7dcd89d4ad60f297f70cda9f258d", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -945,6 +945,12 @@ impl Build {\n             .map(|p| &**p)\n     }\n \n+    /// Returns whether the target will be tested using the `remote-test-client`\n+    /// and `remote-test-server` binaries.\n+    fn remote_tested(&self, target: &str) -> bool {\n+        self.qemu_rootfs(target).is_some() || target.contains(\"android\")\n+    }\n+\n     /// Returns the root of the \"rootfs\" image that this target will be using,\n     /// if one was configured.\n     ///"}, {"sha": "a4d6f91fbef7577c389124ab0759ba64432fb392", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -513,15 +513,15 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n     rules.test(\"emulator-copy-libs\", \"path/to/nowhere\")\n          .dep(|s| s.name(\"libtest\"))\n          .dep(move |s| {\n-             if build.qemu_rootfs(s.target).is_some() {\n-                s.name(\"tool-qemu-test-client\").target(s.host).stage(0)\n+             if build.remote_tested(s.target) {\n+                s.name(\"tool-remote-test-client\").target(s.host).stage(0)\n              } else {\n                  Step::noop()\n              }\n          })\n          .dep(move |s| {\n-             if build.qemu_rootfs(s.target).is_some() {\n-                s.name(\"tool-qemu-test-server\")\n+             if build.remote_tested(s.target) {\n+                s.name(\"tool-remote-test-server\")\n              } else {\n                  Step::noop()\n              }\n@@ -566,14 +566,14 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n          .dep(|s| s.name(\"maybe-clean-tools\"))\n          .dep(|s| s.name(\"libstd-tool\"))\n          .run(move |s| compile::tool(build, s.stage, s.target, \"build-manifest\"));\n-    rules.build(\"tool-qemu-test-server\", \"src/tools/qemu-test-server\")\n+    rules.build(\"tool-remote-test-server\", \"src/tools/remote-test-server\")\n          .dep(|s| s.name(\"maybe-clean-tools\"))\n          .dep(|s| s.name(\"libstd-tool\"))\n-         .run(move |s| compile::tool(build, s.stage, s.target, \"qemu-test-server\"));\n-    rules.build(\"tool-qemu-test-client\", \"src/tools/qemu-test-client\")\n+         .run(move |s| compile::tool(build, s.stage, s.target, \"remote-test-server\"));\n+    rules.build(\"tool-remote-test-client\", \"src/tools/remote-test-client\")\n          .dep(|s| s.name(\"maybe-clean-tools\"))\n          .dep(|s| s.name(\"libstd-tool\"))\n-         .run(move |s| compile::tool(build, s.stage, s.target, \"qemu-test-client\"));\n+         .run(move |s| compile::tool(build, s.stage, s.target, \"remote-test-client\"));\n     rules.build(\"tool-cargo\", \"cargo\")\n          .dep(|s| s.name(\"maybe-clean-tools\"))\n          .dep(|s| s.name(\"libstd-tool\"))"}, {"sha": "0d0485dc872d7bd379744132b380a175b7d6bac1", "filename": "src/doc/unstable-book/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -2,6 +2,7 @@\n \n - [Compiler flags](compiler-flags.md)\n     - [linker_flavor](compiler-flags/linker-flavor.md)\n+    - [remap_path_prefix](compiler-flags/remap-path-prefix.md)\n - [Language features](language-features.md)\n     - [abi_msp430_interrupt](language-features/abi-msp430-interrupt.md)\n     - [abi_ptx](language-features/abi-ptx.md)"}, {"sha": "8ca04d253259258af86b8e2546cc28f943d8734d", "filename": "src/doc/unstable-book/src/compiler-flags/remap-path-prefix.md", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fremap-path-prefix.md", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fremap-path-prefix.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fremap-path-prefix.md?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -0,0 +1,37 @@\n+# `remap-path-prefix`\n+\n+The tracking issue for this feature is: [#41555](https://github.com/rust-lang/rust/issues/41555)\n+\n+------------------------\n+\n+The `-Z remap-path-prefix-from`, `-Z remap-path-prefix-to` commandline option\n+pair allows to replace prefixes of any file paths the compiler emits in various\n+places. This is useful for bringing debuginfo paths into a well-known form and\n+for achieving reproducible builds independent of the directory the compiler was\n+executed in. All paths emitted by the compiler are affected, including those in\n+error messages.\n+\n+In order to map all paths starting with `/home/foo/my-project/src` to\n+`/sources/my-project`, one would invoke the compiler as follows:\n+\n+```text\n+rustc -Zremap-path-prefix-from=\"/home/foo/my-project/src\" -Zremap-path-prefix-to=\"/sources/my-project\"\n+```\n+\n+Debuginfo for code from the file `/home/foo/my-project/src/foo/mod.rs`,\n+for example, would then point debuggers to `/sources/my-project/foo/mod.rs`\n+instead of the original file.\n+\n+The options can be specified multiple times when multiple prefixes should be\n+mapped:\n+\n+```text\n+rustc -Zremap-path-prefix-from=\"/home/foo/my-project/src\" \\\n+      -Zremap-path-prefix-to=\"/sources/my-project\" \\\n+      -Zremap-path-prefix-from=\"/home/foo/my-project/build-dir\" \\\n+      -Zremap-path-prefix-to=\"/stable-build-dir\"\n+```\n+\n+When the options are given multiple times, the nth `-from` will be matched up\n+with the nth `-to` and they can appear anywhere on the commandline. Mappings\n+specified later on the line will take precedence over earlier ones."}, {"sha": "bd6c483156f8125df69f0f2753b0dbf5eed15487", "filename": "src/etc/adb_run_wrapper.sh", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ba90718bb44fe7e2a5edbcc3e5503ee1f7feebd5/src%2Fetc%2Fadb_run_wrapper.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ba90718bb44fe7e2a5edbcc3e5503ee1f7feebd5/src%2Fetc%2Fadb_run_wrapper.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fadb_run_wrapper.sh?ref=ba90718bb44fe7e2a5edbcc3e5503ee1f7feebd5", "patch": "@@ -1,35 +0,0 @@\n-# Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-#\n-# ignore-tidy-linelength\n-#\n-# usage : adb_run_wrapper [test dir - where test executables exist] [test executable]\n-#\n-\n-TEST_PATH=$1\n-BIN_PATH=/system/bin\n-if [ -d \"$TEST_PATH\" ]\n-then\n-    shift\n-    RUN=$1\n-\n-    if [ ! -z \"$RUN\" ]\n-    then\n-        shift\n-\n-        # The length of binary path (i.e. ./$RUN) should be shorter than 128 characters.\n-        cd $TEST_PATH\n-        TEST_EXEC_ENV=22 LD_LIBRARY_PATH=$TEST_PATH PATH=$BIN_PATH:$TEST_PATH ./$RUN $@ 1>$TEST_PATH/$RUN.stdout 2>$TEST_PATH/$RUN.stderr\n-        L_RET=$?\n-\n-        echo $L_RET > $TEST_PATH/$RUN.exitcode\n-\n-    fi\n-fi"}, {"sha": "3ac043f7aa9bc13568c73c482ce5484a3a09f745", "filename": "src/grammar/verify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Fgrammar%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Fgrammar%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fverify.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -296,7 +296,7 @@ fn main() {\n                                          syntax::errors::registry::Registry::new(&[]),\n                                          Rc::new(DummyCrateStore));\n     let filemap = session.parse_sess.codemap()\n-                         .new_filemap(\"<n/a>\".to_string(), None, code);\n+                         .new_filemap(\"<n/a>\".to_string(), code);\n     let mut lexer = lexer::StringReader::new(session.diagnostic(), filemap);\n     let cm = session.codemap();\n "}, {"sha": "622bf4dd0bd0835f4c126a26f9ed85f7bd8b86ee", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -475,14 +475,13 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n         // This is done to handle the case where, for example, the static\n         // method of a private type is used, but the type itself is never\n         // called directly.\n-        if let Some(impl_list) =\n-                self.tcx.maps.inherent_impls.borrow().get(&self.tcx.hir.local_def_id(id)) {\n-            for &impl_did in impl_list.iter() {\n-                for &item_did in &self.tcx.associated_item_def_ids(impl_did)[..] {\n-                    if let Some(item_node_id) = self.tcx.hir.as_local_node_id(item_did) {\n-                        if self.live_symbols.contains(&item_node_id) {\n-                            return true;\n-                        }\n+        let def_id = self.tcx.hir.local_def_id(id);\n+        let inherent_impls = self.tcx.inherent_impls(def_id);\n+        for &impl_did in inherent_impls.iter() {\n+            for &item_did in &self.tcx.associated_item_def_ids(impl_did)[..] {\n+                if let Some(item_node_id) = self.tcx.hir.as_local_node_id(item_did) {\n+                    if self.live_symbols.contains(&item_node_id) {\n+                        return true;\n                     }\n                 }\n             }"}, {"sha": "0bb4cd69e0cd18e5cd1e8a50fb0f22534fe69b0c", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -25,6 +25,7 @@ use lint;\n use middle::cstore;\n \n use syntax::ast::{self, IntTy, UintTy};\n+use syntax::codemap::FilePathMapping;\n use syntax::parse::token;\n use syntax::parse;\n use syntax::symbol::Symbol;\n@@ -492,6 +493,14 @@ impl Options {\n         self.incremental.is_none() ||\n         self.cg.codegen_units == 1\n     }\n+\n+    pub fn file_path_mapping(&self) -> FilePathMapping {\n+        FilePathMapping::new(\n+            self.debugging_opts.remap_path_prefix_from.iter().zip(\n+                self.debugging_opts.remap_path_prefix_to.iter()\n+            ).map(|(src, dst)| (src.clone(), dst.clone())).collect()\n+        )\n+    }\n }\n \n // The type of entry function, so\n@@ -1012,6 +1021,10 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"Set the optimization fuel quota for a crate.\"),\n     print_fuel: Option<String> = (None, parse_opt_string, [TRACKED],\n         \"Make Rustc print the total optimization fuel used by a crate.\"),\n+    remap_path_prefix_from: Vec<String> = (vec![], parse_string_push, [TRACKED],\n+        \"add a source pattern to the file path remapping config\"),\n+    remap_path_prefix_to: Vec<String> = (vec![], parse_string_push, [TRACKED],\n+        \"add a mapping target to the file path remapping config\"),\n }\n \n pub fn default_lib_output() -> CrateType {\n@@ -1319,7 +1332,7 @@ pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n // Convert strings provided as --cfg [cfgspec] into a crate_cfg\n pub fn parse_cfgspecs(cfgspecs: Vec<String> ) -> ast::CrateConfig {\n     cfgspecs.into_iter().map(|s| {\n-        let sess = parse::ParseSess::new();\n+        let sess = parse::ParseSess::new(FilePathMapping::empty());\n         let mut parser =\n             parse::new_parser_from_source_str(&sess, \"cfgspec\".to_string(), s.to_string());\n \n@@ -1430,6 +1443,23 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n         output_types.insert(OutputType::Exe, None);\n     }\n \n+    let remap_path_prefix_sources = debugging_opts.remap_path_prefix_from.len();\n+    let remap_path_prefix_targets = debugging_opts.remap_path_prefix_from.len();\n+\n+    if remap_path_prefix_targets < remap_path_prefix_sources {\n+        for source in &debugging_opts.remap_path_prefix_from[remap_path_prefix_targets..] {\n+            early_error(error_format,\n+                &format!(\"option `-Zremap-path-prefix-from='{}'` does not have \\\n+                         a corresponding `-Zremap-path-prefix-to`\", source))\n+        }\n+    } else if remap_path_prefix_targets > remap_path_prefix_sources {\n+        for target in &debugging_opts.remap_path_prefix_to[remap_path_prefix_sources..] {\n+            early_error(error_format,\n+                &format!(\"option `-Zremap-path-prefix-to='{}'` does not have \\\n+                          a corresponding `-Zremap-path-prefix-from`\", target))\n+        }\n+    }\n+\n     let mut cg = build_codegen_options(matches, error_format);\n \n     // Issue #30063: if user requests llvm-related output to one"}, {"sha": "c8732c31663ebc54f33f5e0b5fde892666e73350", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -74,8 +74,10 @@ pub struct Session {\n     // The name of the root source file of the crate, in the local file system.\n     // The path is always expected to be absolute. `None` means that there is no\n     // source file.\n-    pub local_crate_source_file: Option<PathBuf>,\n-    pub working_dir: PathBuf,\n+    pub local_crate_source_file: Option<String>,\n+    // The directory the compiler has been executed in plus a flag indicating\n+    // if the value stored here has been affected by path remapping.\n+    pub working_dir: (String, bool),\n     pub lint_store: RefCell<lint::LintStore>,\n     pub lints: RefCell<lint::LintTable>,\n     /// Set of (LintId, span, message) tuples tracking lint (sub)diagnostics\n@@ -553,12 +555,14 @@ pub fn build_session(sopts: config::Options,\n                      registry: errors::registry::Registry,\n                      cstore: Rc<CrateStore>)\n                      -> Session {\n+    let file_path_mapping = sopts.file_path_mapping();\n+\n     build_session_with_codemap(sopts,\n                                dep_graph,\n                                local_crate_source_file,\n                                registry,\n                                cstore,\n-                               Rc::new(codemap::CodeMap::new()),\n+                               Rc::new(codemap::CodeMap::new(file_path_mapping)),\n                                None)\n }\n \n@@ -622,7 +626,7 @@ pub fn build_session_(sopts: config::Options,\n         Ok(t) => t,\n         Err(e) => {\n             panic!(span_diagnostic.fatal(&format!(\"Error loading host specification: {}\", e)));\n-    }\n+        }\n     };\n     let target_cfg = config::build_target_config(&sopts, &span_diagnostic);\n     let p_s = parse::ParseSess::with_span_handler(span_diagnostic, codemap);\n@@ -631,21 +635,22 @@ pub fn build_session_(sopts: config::Options,\n         None => Some(filesearch::get_or_default_sysroot())\n     };\n \n+    let file_path_mapping = sopts.file_path_mapping();\n+\n     // Make the path absolute, if necessary\n-    let local_crate_source_file = local_crate_source_file.map(|path|\n-        if path.is_absolute() {\n-            path.clone()\n-        } else {\n-            env::current_dir().unwrap().join(&path)\n-        }\n-    );\n+    let local_crate_source_file = local_crate_source_file.map(|path| {\n+        file_path_mapping.map_prefix(path.to_string_lossy().into_owned()).0\n+    });\n \n     let optimization_fuel_crate = sopts.debugging_opts.fuel.as_ref().map(|i| i.0.clone());\n     let optimization_fuel_limit = Cell::new(sopts.debugging_opts.fuel.as_ref()\n         .map(|i| i.1).unwrap_or(0));\n     let print_fuel_crate = sopts.debugging_opts.print_fuel.clone();\n     let print_fuel = Cell::new(0);\n \n+    let working_dir = env::current_dir().unwrap().to_string_lossy().into_owned();\n+    let working_dir = file_path_mapping.map_prefix(working_dir);\n+\n     let sess = Session {\n         dep_graph: dep_graph.clone(),\n         target: target_cfg,\n@@ -660,7 +665,7 @@ pub fn build_session_(sopts: config::Options,\n         derive_registrar_fn: Cell::new(None),\n         default_sysroot: default_sysroot,\n         local_crate_source_file: local_crate_source_file,\n-        working_dir: env::current_dir().unwrap(),\n+        working_dir: working_dir,\n         lint_store: RefCell::new(lint::LintStore::new()),\n         lints: RefCell::new(lint::LintTable::new()),\n         one_time_diagnostics: RefCell::new(FxHashSet()),"}, {"sha": "16d5d1187fc8bf5de52ee2b6cd934f5e709f8896", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -13,16 +13,19 @@ use hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use ty::{self, Ty, TyCtxt};\n use syntax::ast;\n use syntax::symbol::Symbol;\n+use syntax_pos::DUMMY_SP;\n \n use std::cell::Cell;\n \n thread_local! {\n-    static FORCE_ABSOLUTE: Cell<bool> = Cell::new(false)\n+    static FORCE_ABSOLUTE: Cell<bool> = Cell::new(false);\n+    static FORCE_IMPL_FILENAME_LINE: Cell<bool> = Cell::new(false);\n }\n \n-/// Enforces that item_path_str always returns an absolute path.\n-/// This is useful when building symbols that contain types,\n-/// where we want the crate name to be part of the symbol.\n+/// Enforces that item_path_str always returns an absolute path and\n+/// also enables \"type-based\" impl paths. This is used when building\n+/// symbols that contain types, where we want the crate name to be\n+/// part of the symbol.\n pub fn with_forced_absolute_paths<F: FnOnce() -> R, R>(f: F) -> R {\n     FORCE_ABSOLUTE.with(|force| {\n         let old = force.get();\n@@ -33,6 +36,20 @@ pub fn with_forced_absolute_paths<F: FnOnce() -> R, R>(f: F) -> R {\n     })\n }\n \n+/// Force us to name impls with just the filename/line number. We\n+/// normally try to use types. But at some points, notably while printing\n+/// cycle errors, this can result in extra or suboptimal error output,\n+/// so this variable disables that check.\n+pub fn with_forced_impl_filename_line<F: FnOnce() -> R, R>(f: F) -> R {\n+    FORCE_IMPL_FILENAME_LINE.with(|force| {\n+        let old = force.get();\n+        force.set(true);\n+        let result = f();\n+        force.set(old);\n+        result\n+    })\n+}\n+\n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Returns a string identifying this def-id. This string is\n     /// suitable for user output. It is relative to the current crate\n@@ -199,14 +216,16 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     {\n         let parent_def_id = self.parent_def_id(impl_def_id).unwrap();\n \n-        let use_types = if !impl_def_id.is_local() {\n-            // always have full types available for extern crates\n-            true\n-        } else {\n-            // for local crates, check whether type info is\n-            // available; typeck might not have completed yet\n-            self.maps.impl_trait_ref.borrow().contains_key(&impl_def_id) &&\n-                self.maps.type_of.borrow().contains_key(&impl_def_id)\n+        // Always use types for non-local impls, where types are always\n+        // available, and filename/line-number is mostly uninteresting.\n+        let use_types = !impl_def_id.is_local() || {\n+            // Otherwise, use filename/line-number if forced.\n+            let force_no_types = FORCE_IMPL_FILENAME_LINE.with(|f| f.get());\n+            !force_no_types && {\n+                // Otherwise, use types if we can query them without inducing a cycle.\n+                ty::queries::impl_trait_ref::try_get(self, DUMMY_SP, impl_def_id).is_ok() &&\n+                    ty::queries::type_of::try_get(self, DUMMY_SP, impl_def_id).is_ok()\n+            }\n         };\n \n         if !use_types {"}, {"sha": "13c167de0fd5b21b23b5da383ae57d14c3a0c18d", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 77, "deletions": 55, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -17,11 +17,13 @@ use middle::privacy::AccessLevels;\n use mir;\n use session::CompileResult;\n use ty::{self, CrateInherentImpls, Ty, TyCtxt};\n+use ty::item_path;\n use ty::subst::Substs;\n use util::nodemap::NodeSet;\n \n use rustc_data_structures::indexed_vec::IndexVec;\n use std::cell::{RefCell, RefMut};\n+use std::mem;\n use std::ops::Deref;\n use std::rc::Rc;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -139,24 +141,36 @@ pub struct CycleError<'a, 'tcx: 'a> {\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn report_cycle(self, CycleError { span, cycle }: CycleError) {\n-        assert!(!cycle.is_empty());\n-\n-        let mut err = struct_span_err!(self.sess, span, E0391,\n-            \"unsupported cyclic reference between types/traits detected\");\n-        err.span_label(span, &format!(\"cyclic reference\"));\n-\n-        err.span_note(cycle[0].0, &format!(\"the cycle begins when {}...\",\n-                                           cycle[0].1.describe(self)));\n-\n-        for &(span, ref query) in &cycle[1..] {\n-            err.span_note(span, &format!(\"...which then requires {}...\",\n-                                         query.describe(self)));\n-        }\n+        // Subtle: release the refcell lock before invoking `describe()`\n+        // below by dropping `cycle`.\n+        let stack = cycle.to_vec();\n+        mem::drop(cycle);\n+\n+        assert!(!stack.is_empty());\n+\n+        // Disable naming impls with types in this path, since that\n+        // sometimes cycles itself, leading to extra cycle errors.\n+        // (And cycle errors around impls tend to occur during the\n+        // collect/coherence phases anyhow.)\n+        item_path::with_forced_impl_filename_line(|| {\n+            let mut err =\n+                struct_span_err!(self.sess, span, E0391,\n+                                 \"unsupported cyclic reference between types/traits detected\");\n+            err.span_label(span, &format!(\"cyclic reference\"));\n+\n+            err.span_note(stack[0].0, &format!(\"the cycle begins when {}...\",\n+                                               stack[0].1.describe(self)));\n+\n+            for &(span, ref query) in &stack[1..] {\n+                err.span_note(span, &format!(\"...which then requires {}...\",\n+                                             query.describe(self)));\n+            }\n \n-        err.note(&format!(\"...which then again requires {}, completing the cycle.\",\n-                          cycle[0].1.describe(self)));\n+            err.note(&format!(\"...which then again requires {}, completing the cycle.\",\n+                              stack[0].1.describe(self)));\n \n-        err.emit();\n+            err.emit();\n+        });\n     }\n \n     fn cycle_check<F, R>(self, span: Span, query: Query<'gcx>, compute: F)\n@@ -280,11 +294,11 @@ impl<'tcx> QueryDescription for queries::def_span<'tcx> {\n macro_rules! define_maps {\n     (<$tcx:tt>\n      $($(#[$attr:meta])*\n-       pub $name:ident: $node:ident($K:ty) -> $V:ty),*) => {\n+       [$($pub:tt)*] $name:ident: $node:ident($K:ty) -> $V:ty),*) => {\n         pub struct Maps<$tcx> {\n             providers: IndexVec<CrateNum, Providers<$tcx>>,\n             query_stack: RefCell<Vec<(Span, Query<$tcx>)>>,\n-            $($(#[$attr])* pub $name: RefCell<DepTrackingMap<queries::$name<$tcx>>>),*\n+            $($(#[$attr])* $($pub)* $name: RefCell<DepTrackingMap<queries::$name<$tcx>>>),*\n         }\n \n         impl<$tcx> Maps<$tcx> {\n@@ -341,6 +355,11 @@ macro_rules! define_maps {\n                                   -> Result<R, CycleError<'a, $tcx>>\n                 where F: FnOnce(&$V) -> R\n             {\n+                debug!(\"ty::queries::{}::try_get_with(key={:?}, span={:?})\",\n+                       stringify!($name),\n+                       key,\n+                       span);\n+\n                 if let Some(result) = tcx.maps.$name.borrow().get(&key) {\n                     return Ok(f(result));\n                 }\n@@ -447,52 +466,52 @@ macro_rules! define_maps {\n // the driver creates (using several `rustc_*` crates).\n define_maps! { <'tcx>\n     /// Records the type of every item.\n-    pub type_of: ItemSignature(DefId) -> Ty<'tcx>,\n+    [] type_of: ItemSignature(DefId) -> Ty<'tcx>,\n \n     /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n     /// associated generics and predicates.\n-    pub generics_of: ItemSignature(DefId) -> &'tcx ty::Generics,\n-    pub predicates_of: ItemSignature(DefId) -> ty::GenericPredicates<'tcx>,\n+    [] generics_of: ItemSignature(DefId) -> &'tcx ty::Generics,\n+    [] predicates_of: ItemSignature(DefId) -> ty::GenericPredicates<'tcx>,\n \n     /// Maps from the def-id of a trait to the list of\n     /// super-predicates. This is a subset of the full list of\n     /// predicates. We store these in a separate map because we must\n     /// evaluate them even during type conversion, often before the\n     /// full predicates are available (note that supertraits have\n     /// additional acyclicity requirements).\n-    pub super_predicates_of: ItemSignature(DefId) -> ty::GenericPredicates<'tcx>,\n+    [] super_predicates_of: ItemSignature(DefId) -> ty::GenericPredicates<'tcx>,\n \n     /// To avoid cycles within the predicates of a single item we compute\n     /// per-type-parameter predicates for resolving `T::AssocTy`.\n-    pub type_param_predicates: TypeParamPredicates((DefId, DefId))\n+    [] type_param_predicates: TypeParamPredicates((DefId, DefId))\n         -> ty::GenericPredicates<'tcx>,\n \n-    pub trait_def: ItemSignature(DefId) -> &'tcx ty::TraitDef,\n-    pub adt_def: ItemSignature(DefId) -> &'tcx ty::AdtDef,\n-    pub adt_destructor: AdtDestructor(DefId) -> Option<ty::Destructor>,\n-    pub adt_sized_constraint: SizedConstraint(DefId) -> &'tcx [Ty<'tcx>],\n-    pub adt_dtorck_constraint: DtorckConstraint(DefId) -> ty::DtorckConstraint<'tcx>,\n+    [] trait_def: ItemSignature(DefId) -> &'tcx ty::TraitDef,\n+    [] adt_def: ItemSignature(DefId) -> &'tcx ty::AdtDef,\n+    [] adt_destructor: AdtDestructor(DefId) -> Option<ty::Destructor>,\n+    [] adt_sized_constraint: SizedConstraint(DefId) -> &'tcx [Ty<'tcx>],\n+    [] adt_dtorck_constraint: DtorckConstraint(DefId) -> ty::DtorckConstraint<'tcx>,\n \n     /// True if this is a foreign item (i.e., linked via `extern { ... }`).\n-    pub is_foreign_item: IsForeignItem(DefId) -> bool,\n+    [] is_foreign_item: IsForeignItem(DefId) -> bool,\n \n     /// Maps from def-id of a type or region parameter to its\n     /// (inferred) variance.\n-    pub variances_of: ItemSignature(DefId) -> Rc<Vec<ty::Variance>>,\n+    [pub] variances_of: ItemSignature(DefId) -> Rc<Vec<ty::Variance>>,\n \n     /// Maps from an impl/trait def-id to a list of the def-ids of its items\n-    pub associated_item_def_ids: AssociatedItemDefIds(DefId) -> Rc<Vec<DefId>>,\n+    [] associated_item_def_ids: AssociatedItemDefIds(DefId) -> Rc<Vec<DefId>>,\n \n     /// Maps from a trait item to the trait item \"descriptor\"\n-    pub associated_item: AssociatedItems(DefId) -> ty::AssociatedItem,\n+    [] associated_item: AssociatedItems(DefId) -> ty::AssociatedItem,\n \n-    pub impl_trait_ref: ItemSignature(DefId) -> Option<ty::TraitRef<'tcx>>,\n-    pub impl_polarity: ItemSignature(DefId) -> hir::ImplPolarity,\n+    [] impl_trait_ref: ItemSignature(DefId) -> Option<ty::TraitRef<'tcx>>,\n+    [] impl_polarity: ItemSignature(DefId) -> hir::ImplPolarity,\n \n     /// Maps a DefId of a type to a list of its inherent impls.\n     /// Contains implementations of methods that are inherent to a type.\n     /// Methods in these implementations don't need to be exported.\n-    pub inherent_impls: InherentImpls(DefId) -> Rc<Vec<DefId>>,\n+    [] inherent_impls: InherentImpls(DefId) -> Rc<Vec<DefId>>,\n \n     /// Maps from the def-id of a function/method or const/static\n     /// to its MIR. Mutation is done at an item granularity to\n@@ -501,60 +520,63 @@ define_maps! { <'tcx>\n     ///\n     /// Note that cross-crate MIR appears to be always borrowed\n     /// (in the `RefCell` sense) to prevent accidental mutation.\n-    pub mir: Mir(DefId) -> &'tcx RefCell<mir::Mir<'tcx>>,\n+    [pub] mir: Mir(DefId) -> &'tcx RefCell<mir::Mir<'tcx>>,\n \n     /// Maps DefId's that have an associated Mir to the result\n     /// of the MIR qualify_consts pass. The actual meaning of\n     /// the value isn't known except to the pass itself.\n-    pub mir_const_qualif: Mir(DefId) -> u8,\n+    [] mir_const_qualif: Mir(DefId) -> u8,\n \n     /// Records the type of each closure. The def ID is the ID of the\n     /// expression defining the closure.\n-    pub closure_kind: ItemSignature(DefId) -> ty::ClosureKind,\n+    [] closure_kind: ItemSignature(DefId) -> ty::ClosureKind,\n \n     /// Records the type of each closure. The def ID is the ID of the\n     /// expression defining the closure.\n-    pub closure_type: ItemSignature(DefId) -> ty::PolyFnSig<'tcx>,\n+    [] closure_type: ItemSignature(DefId) -> ty::PolyFnSig<'tcx>,\n \n     /// Caches CoerceUnsized kinds for impls on custom types.\n-    pub coerce_unsized_info: ItemSignature(DefId)\n+    [] coerce_unsized_info: ItemSignature(DefId)\n         -> ty::adjustment::CoerceUnsizedInfo,\n \n-    pub typeck_item_bodies: typeck_item_bodies_dep_node(CrateNum) -> CompileResult,\n+    [] typeck_item_bodies: typeck_item_bodies_dep_node(CrateNum) -> CompileResult,\n+\n+    [] typeck_tables_of: TypeckTables(DefId) -> &'tcx ty::TypeckTables<'tcx>,\n \n-    pub typeck_tables_of: TypeckTables(DefId) -> &'tcx ty::TypeckTables<'tcx>,\n+    [] has_typeck_tables: TypeckTables(DefId) -> bool,\n \n-    pub coherent_trait: coherent_trait_dep_node((CrateNum, DefId)) -> (),\n+    [] coherent_trait: coherent_trait_dep_node((CrateNum, DefId)) -> (),\n \n-    pub borrowck: BorrowCheck(DefId) -> (),\n+    [] borrowck: BorrowCheck(DefId) -> (),\n \n     /// Gets a complete map from all types to their inherent impls.\n     /// Not meant to be used directly outside of coherence.\n     /// (Defined only for LOCAL_CRATE)\n-    pub crate_inherent_impls: crate_inherent_impls_dep_node(CrateNum) -> CrateInherentImpls,\n+    [] crate_inherent_impls: crate_inherent_impls_dep_node(CrateNum) -> CrateInherentImpls,\n \n     /// Checks all types in the krate for overlap in their inherent impls. Reports errors.\n     /// Not meant to be used directly outside of coherence.\n     /// (Defined only for LOCAL_CRATE)\n-    pub crate_inherent_impls_overlap_check: crate_inherent_impls_dep_node(CrateNum) -> (),\n+    [] crate_inherent_impls_overlap_check: crate_inherent_impls_dep_node(CrateNum) -> (),\n \n     /// Results of evaluating const items or constants embedded in\n     /// other items (such as enum variant explicit discriminants).\n-    pub const_eval: const_eval_dep_node((DefId, &'tcx Substs<'tcx>))\n+    [] const_eval: const_eval_dep_node((DefId, &'tcx Substs<'tcx>))\n         -> const_val::EvalResult<'tcx>,\n \n     /// Performs the privacy check and computes \"access levels\".\n-    pub privacy_access_levels: PrivacyAccessLevels(CrateNum) -> Rc<AccessLevels>,\n+    [] privacy_access_levels: PrivacyAccessLevels(CrateNum) -> Rc<AccessLevels>,\n \n-    pub reachable_set: reachability_dep_node(CrateNum) -> Rc<NodeSet>,\n+    [] reachable_set: reachability_dep_node(CrateNum) -> Rc<NodeSet>,\n \n-    pub mir_shims: mir_shim_dep_node(ty::InstanceDef<'tcx>) -> &'tcx RefCell<mir::Mir<'tcx>>,\n+    [] mir_shims: mir_shim_dep_node(ty::InstanceDef<'tcx>) -> &'tcx RefCell<mir::Mir<'tcx>>,\n \n-    pub def_symbol_name: SymbolName(DefId) -> ty::SymbolName,\n-    pub symbol_name: symbol_name_dep_node(ty::Instance<'tcx>) -> ty::SymbolName,\n+    [] def_symbol_name: SymbolName(DefId) -> ty::SymbolName,\n+    [] symbol_name: symbol_name_dep_node(ty::Instance<'tcx>) -> ty::SymbolName,\n \n-    pub describe_def: MetaData(DefId) -> Option<Def>,\n-    pub def_span: MetaData(DefId) -> Span\n+\n+    [] describe_def: MetaData(DefId) -> Option<Def>,\n+    [] def_span: MetaData(DefId) -> Span\n }\n \n fn coherent_trait_dep_node((_, def_id): (CrateNum, DefId)) -> DepNode<DefId> {\n@@ -585,4 +607,4 @@ fn typeck_item_bodies_dep_node(_: CrateNum) -> DepNode<DefId> {\n \n fn const_eval_dep_node((def_id, _): (DefId, &Substs)) -> DepNode<DefId> {\n     DepNode::ConstEval(def_id)\n-}\n\\ No newline at end of file\n+}"}, {"sha": "8be3e4be7c8b7d83d3253d45213dd33fddf032d5", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -2139,6 +2139,26 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n+    pub fn opt_associated_item(self, def_id: DefId) -> Option<AssociatedItem> {\n+        let is_associated_item = if let Some(node_id) = self.hir.as_local_node_id(def_id) {\n+            match self.hir.get(node_id) {\n+                hir_map::NodeTraitItem(_) | hir_map::NodeImplItem(_) => true,\n+                _ => false,\n+            }\n+        } else {\n+            match self.describe_def(def_id).expect(\"no def for def-id\") {\n+                Def::AssociatedConst(_) | Def::Method(_) | Def::AssociatedTy(_) => true,\n+                _ => false,\n+            }\n+        };\n+\n+        if is_associated_item {\n+            Some(self.associated_item(def_id))\n+        } else {\n+            None\n+        }\n+    }\n+\n     fn associated_item_from_trait_item_ref(self,\n                                            parent_def_id: DefId,\n                                            parent_vis: &hir::Visibility,\n@@ -2383,7 +2403,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 None\n             }\n         } else {\n-            self.maps.associated_item.borrow().get(&def_id).cloned()\n+            self.opt_associated_item(def_id)\n         };\n \n         match item {\n@@ -2404,15 +2424,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         if def_id.krate != LOCAL_CRATE {\n             return self.sess.cstore.trait_of_item(def_id);\n         }\n-        match self.maps.associated_item.borrow().get(&def_id) {\n-            Some(associated_item) => {\n+        self.opt_associated_item(def_id)\n+            .and_then(|associated_item| {\n                 match associated_item.container {\n                     TraitContainer(def_id) => Some(def_id),\n                     ImplContainer(_) => None\n                 }\n-            }\n-            None => None\n-        }\n+            })\n     }\n \n     /// Construct a parameter environment suitable for static contexts or other contexts where there\n@@ -2580,11 +2598,12 @@ fn associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n             }\n         }\n \n-        ref r => {\n-            panic!(\"unexpected container of associated items: {:?}\", r)\n-        }\n+        _ => { }\n     }\n-    panic!(\"associated item not found for def_id: {:?}\", def_id);\n+\n+    span_bug!(parent_item.span,\n+              \"unexpected parent of trait or impl item or item not found: {:?}\",\n+              parent_item.node)\n }\n \n /// Calculates the Sized-constraint."}, {"sha": "e4ed2b8eb8fabda1fad638c30772383eb05721db", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -206,7 +206,7 @@ pub fn run_compiler<'a>(args: &[String],\n     let cstore = Rc::new(CStore::new(&dep_graph));\n \n     let loader = file_loader.unwrap_or(box RealFileLoader);\n-    let codemap = Rc::new(CodeMap::with_file_loader(loader));\n+    let codemap = Rc::new(CodeMap::with_file_loader(loader, sopts.file_path_mapping()));\n     let mut sess = session::build_session_with_codemap(\n         sopts, &dep_graph, input_file_path, descriptions, cstore.clone(), codemap, emitter_dest,\n     );"}, {"sha": "a19bc4aea2c9dba97aeac93ea82bf4b7cb0452b4", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -31,7 +31,7 @@ use rustc::session::{self, config};\n use std::rc::Rc;\n use syntax::ast;\n use syntax::abi::Abi;\n-use syntax::codemap::CodeMap;\n+use syntax::codemap::{CodeMap, FilePathMapping};\n use errors;\n use errors::emitter::Emitter;\n use errors::{Level, DiagnosticBuilder};\n@@ -108,7 +108,7 @@ fn test_env<F>(source_string: &str,\n                                        &dep_graph,\n                                        None,\n                                        diagnostic_handler,\n-                                       Rc::new(CodeMap::new()),\n+                                       Rc::new(CodeMap::new(FilePathMapping::empty())),\n                                        cstore.clone());\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     let input = config::Input::Str {"}, {"sha": "d4b8f0a4924619ebcdb3ce53cf3992f56768f59e", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -27,19 +27,15 @@ pub enum MethodLateContext {\n     PlainImpl,\n }\n \n-pub fn method_context(cx: &LateContext, id: ast::NodeId, span: Span) -> MethodLateContext {\n+pub fn method_context(cx: &LateContext, id: ast::NodeId) -> MethodLateContext {\n     let def_id = cx.tcx.hir.local_def_id(id);\n-    match cx.tcx.maps.associated_item.borrow().get(&def_id) {\n-        None => span_bug!(span, \"missing method descriptor?!\"),\n-        Some(item) => {\n-            match item.container {\n-                ty::TraitContainer(..) => MethodLateContext::TraitDefaultImpl,\n-                ty::ImplContainer(cid) => {\n-                    match cx.tcx.impl_trait_ref(cid) {\n-                        Some(_) => MethodLateContext::TraitImpl,\n-                        None => MethodLateContext::PlainImpl,\n-                    }\n-                }\n+    let item = cx.tcx.associated_item(def_id);\n+    match item.container {\n+        ty::TraitContainer(..) => MethodLateContext::TraitDefaultImpl,\n+        ty::ImplContainer(cid) => {\n+            match cx.tcx.impl_trait_ref(cid) {\n+                Some(_) => MethodLateContext::TraitImpl,\n+                None => MethodLateContext::PlainImpl,\n             }\n         }\n     }\n@@ -244,7 +240,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n                 id: ast::NodeId) {\n         match fk {\n             FnKind::Method(name, ..) => {\n-                match method_context(cx, id, span) {\n+                match method_context(cx, id) {\n                     MethodLateContext::PlainImpl => {\n                         self.check_snake_case(cx, \"method\", &name.as_str(), Some(span))\n                     }"}, {"sha": "57ed298809635d5093324e94f95c9431a9247900", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -432,7 +432,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n \n     fn check_impl_item(&mut self, cx: &LateContext, impl_item: &hir::ImplItem) {\n         // If the method is an impl for a trait, don't doc.\n-        if method_context(cx, impl_item.id, impl_item.span) == MethodLateContext::TraitImpl {\n+        if method_context(cx, impl_item.id) == MethodLateContext::TraitImpl {\n             return;\n         }\n "}, {"sha": "36b993aad69bb9374aea810185153d0cf825cce3", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -393,7 +393,7 @@ impl CrateStore for cstore::CStore {\n         let (name, def) = data.get_macro(id.index);\n         let source_name = format!(\"<{} macros>\", name);\n \n-        let filemap = sess.parse_sess.codemap().new_filemap(source_name, None, def.body);\n+        let filemap = sess.parse_sess.codemap().new_filemap(source_name, def.body);\n         let local_span = Span { lo: filemap.start_pos, hi: filemap.end_pos, ctxt: NO_EXPANSION };\n         let body = filemap_to_stream(&sess.parse_sess, filemap);\n "}, {"sha": "28fea2eec60f08c36f5359182f76429777e868f6", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -827,7 +827,7 @@ impl<'a, 'tcx> CrateMetadata {\n             EntryKind::AssociatedType(container) => {\n                 (ty::AssociatedKind::Type, container, false)\n             }\n-            _ => bug!()\n+            _ => bug!(\"cannot get associated-item of `{:?}`\", def_key)\n         };\n \n         ty::AssociatedItem {\n@@ -1138,7 +1138,7 @@ impl<'a, 'tcx> CrateMetadata {\n                         // We can't reuse an existing FileMap, so allocate a new one\n                         // containing the information we need.\n                         let syntax_pos::FileMap { name,\n-                                                  abs_path,\n+                                                  name_was_remapped,\n                                                   start_pos,\n                                                   end_pos,\n                                                   lines,\n@@ -1162,7 +1162,7 @@ impl<'a, 'tcx> CrateMetadata {\n                         }\n \n                         let local_version = local_codemap.new_imported_filemap(name,\n-                                                                               abs_path,\n+                                                                               name_was_remapped,\n                                                                                source_length,\n                                                                                lines,\n                                                                                multibyte_chars);"}, {"sha": "189b94a1b6285e43bd8f3335ff7c8819c5e53a61", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 38, "deletions": 10, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -30,6 +30,7 @@ use std::hash::Hash;\n use std::intrinsics;\n use std::io::prelude::*;\n use std::io::Cursor;\n+use std::path::Path;\n use std::rc::Rc;\n use std::u32;\n use syntax::ast::{self, CRATE_NODE_ID};\n@@ -626,14 +627,14 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n     // Encodes the inherent implementations of a structure, enumeration, or trait.\n     fn encode_inherent_implementations(&mut self, def_id: DefId) -> LazySeq<DefIndex> {\n         debug!(\"EntryBuilder::encode_inherent_implementations({:?})\", def_id);\n-        match self.tcx.maps.inherent_impls.borrow().get(&def_id) {\n-            None => LazySeq::empty(),\n-            Some(implementations) => {\n-                self.lazy_seq(implementations.iter().map(|&def_id| {\n-                    assert!(def_id.is_local());\n-                    def_id.index\n-                }))\n-            }\n+        let implementations = self.tcx.inherent_impls(def_id);\n+        if implementations.is_empty() {\n+            LazySeq::empty()\n+        } else {\n+            self.lazy_seq(implementations.iter().map(|&def_id| {\n+                assert!(def_id.is_local());\n+                def_id.index\n+            }))\n         }\n     }\n \n@@ -1270,13 +1271,40 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_codemap(&mut self) -> LazySeq<syntax_pos::FileMap> {\n         let codemap = self.tcx.sess.codemap();\n         let all_filemaps = codemap.files.borrow();\n-        self.lazy_seq_ref(all_filemaps.iter()\n+        let adapted = all_filemaps.iter()\n             .filter(|filemap| {\n                 // No need to re-export imported filemaps, as any downstream\n                 // crate will import them from their original source.\n                 !filemap.is_imported()\n             })\n-            .map(|filemap| &**filemap))\n+            .map(|filemap| {\n+                // When exporting FileMaps, we expand all paths to absolute\n+                // paths because any relative paths are potentially relative to\n+                // a wrong directory.\n+                // However, if a path has been modified via\n+                // `-Zremap-path-prefix` we assume the user has already set\n+                // things up the way they want and don't touch the path values\n+                // anymore.\n+                let name = Path::new(&filemap.name);\n+                let (ref working_dir, working_dir_was_remapped) = self.tcx.sess.working_dir;\n+                if filemap.name_was_remapped ||\n+                   (name.is_relative() && working_dir_was_remapped) {\n+                    // This path of this FileMap has been modified by\n+                    // path-remapping, so we use it verbatim (and avoid cloning\n+                    // the whole map in the process).\n+                    filemap.clone()\n+                } else {\n+                    let mut adapted = (**filemap).clone();\n+                    let abs_path = Path::new(working_dir).join(name)\n+                                                         .to_string_lossy()\n+                                                         .into_owned();\n+                    adapted.name = abs_path;\n+                    Rc::new(adapted)\n+                }\n+            })\n+            .collect::<Vec<_>>();\n+\n+        self.lazy_seq_ref(adapted.iter().map(|fm| &**fm))\n     }\n \n     fn encode_def_path_table(&mut self) -> Lazy<DefPathTable> {"}, {"sha": "26780c48a1392e68a863ff67ec5ef99131fc05d9", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -37,6 +37,7 @@ use rustc::ty::{self, TyCtxt, AssociatedItemContainer};\n use std::collections::HashSet;\n use std::collections::hash_map::DefaultHasher;\n use std::hash::*;\n+use std::path::Path;\n \n use syntax::ast::{self, NodeId, PatKind, Attribute, CRATE_NODE_ID};\n use syntax::parse::token;\n@@ -114,20 +115,21 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         where F: FnOnce(&mut DumpVisitor<'l, 'tcx, 'll, D>)\n     {\n         let item_def_id = self.tcx.hir.local_def_id(item_id);\n-        match self.tcx.maps.typeck_tables_of.borrow().get(&item_def_id) {\n-            Some(tables) => {\n-                let old_tables = self.save_ctxt.tables;\n-                self.save_ctxt.tables = tables;\n-                f(self);\n-                self.save_ctxt.tables = old_tables;\n-            }\n-            None => f(self),\n+        if self.tcx.has_typeck_tables(item_def_id) {\n+            let tables = self.tcx.typeck_tables_of(item_def_id);\n+            let old_tables = self.save_ctxt.tables;\n+            self.save_ctxt.tables = tables;\n+            f(self);\n+            self.save_ctxt.tables = old_tables;\n+        } else {\n+            f(self)\n         }\n     }\n \n     pub fn dump_crate_info(&mut self, name: &str, krate: &ast::Crate) {\n         let source_file = self.tcx.sess.local_crate_source_file.as_ref();\n         let crate_root = source_file.map(|source_file| {\n+            let source_file = Path::new(source_file);\n             match source_file.file_name() {\n                 Some(_) => source_file.parent().unwrap().display().to_string(),\n                 None => source_file.display().to_string(),"}, {"sha": "ae618c7e170df4b4a07d4e93194070b12701023f", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::FunctionDebugContext;\n+use super::{FunctionDebugContext, FunctionDebugContextData};\n use super::metadata::file_metadata;\n use super::utils::{DIB, span_start};\n \n use llvm;\n-use llvm::debuginfo::{DIScope, DISubprogram};\n+use llvm::debuginfo::DIScope;\n use common::CrateContext;\n use rustc::mir::{Mir, VisibilityScope};\n \n@@ -53,8 +53,8 @@ pub fn create_mir_scopes(ccx: &CrateContext, mir: &Mir, debug_context: &Function\n     };\n     let mut scopes = IndexVec::from_elem(null_scope, &mir.visibility_scopes);\n \n-    let fn_metadata = match *debug_context {\n-        FunctionDebugContext::RegularContext(ref data) => data.fn_metadata,\n+    let debug_context = match *debug_context {\n+        FunctionDebugContext::RegularContext(ref data) => data,\n         FunctionDebugContext::DebugInfoDisabled |\n         FunctionDebugContext::FunctionWithoutDebugInfo => {\n             return scopes;\n@@ -71,7 +71,7 @@ pub fn create_mir_scopes(ccx: &CrateContext, mir: &Mir, debug_context: &Function\n     // Instantiate all scopes.\n     for idx in 0..mir.visibility_scopes.len() {\n         let scope = VisibilityScope::new(idx);\n-        make_mir_scope(ccx, &mir, &has_variables, fn_metadata, scope, &mut scopes);\n+        make_mir_scope(ccx, &mir, &has_variables, debug_context, scope, &mut scopes);\n     }\n \n     scopes\n@@ -80,7 +80,7 @@ pub fn create_mir_scopes(ccx: &CrateContext, mir: &Mir, debug_context: &Function\n fn make_mir_scope(ccx: &CrateContext,\n                   mir: &Mir,\n                   has_variables: &BitVector,\n-                  fn_metadata: DISubprogram,\n+                  debug_context: &FunctionDebugContextData,\n                   scope: VisibilityScope,\n                   scopes: &mut IndexVec<VisibilityScope, MirDebugScope>) {\n     if scopes[scope].is_valid() {\n@@ -89,13 +89,13 @@ fn make_mir_scope(ccx: &CrateContext,\n \n     let scope_data = &mir.visibility_scopes[scope];\n     let parent_scope = if let Some(parent) = scope_data.parent_scope {\n-        make_mir_scope(ccx, mir, has_variables, fn_metadata, parent, scopes);\n+        make_mir_scope(ccx, mir, has_variables, debug_context, parent, scopes);\n         scopes[parent]\n     } else {\n         // The root is the function itself.\n         let loc = span_start(ccx, mir.span);\n         scopes[scope] = MirDebugScope {\n-            scope_metadata: fn_metadata,\n+            scope_metadata: debug_context.fn_metadata,\n             file_start_pos: loc.file.start_pos,\n             file_end_pos: loc.file.end_pos,\n         };\n@@ -109,14 +109,17 @@ fn make_mir_scope(ccx: &CrateContext,\n         // However, we don't skip creating a nested scope if\n         // our parent is the root, because we might want to\n         // put arguments in the root and not have shadowing.\n-        if parent_scope.scope_metadata != fn_metadata {\n+        if parent_scope.scope_metadata != debug_context.fn_metadata {\n             scopes[scope] = parent_scope;\n             return;\n         }\n     }\n \n     let loc = span_start(ccx, scope_data.span);\n-    let file_metadata = file_metadata(ccx, &loc.file.name, &loc.file.abs_path);\n+    let file_metadata = file_metadata(ccx,\n+                                      &loc.file.name,\n+                                      debug_context.defining_crate);\n+\n     let scope_metadata = unsafe {\n         llvm::LLVMRustDIBuilderCreateLexicalBlock(\n             DIB(ccx),"}, {"sha": "188f8ee3366370ccb30fdb1309630a9f0056d627", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 41, "deletions": 50, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -26,7 +26,7 @@ use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor,\n                       DICompositeType, DILexicalBlock, DIFlags};\n \n use rustc::hir::def::CtorKind;\n-use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n use rustc::ty::fold::TypeVisitor;\n use rustc::ty::subst::Substs;\n use rustc::ty::util::TypeIdHasher;\n@@ -39,14 +39,12 @@ use rustc::ty::{self, AdtKind, Ty};\n use rustc::ty::layout::{self, LayoutTyper};\n use session::config;\n use util::nodemap::FxHashMap;\n-use util::common::path2cstr;\n \n use libc::{c_uint, c_longlong};\n use std::ffi::CString;\n-use std::path::Path;\n use std::ptr;\n use syntax::ast;\n-use syntax::symbol::{Interner, InternedString};\n+use syntax::symbol::{Interner, InternedString, Symbol};\n use syntax_pos::{self, Span};\n \n \n@@ -349,8 +347,7 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     assert!(member_descriptions.len() == member_llvm_types.len());\n \n-    let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, &loc.file.name, &loc.file.abs_path);\n+    let file_metadata = unknown_file_metadata(cx);\n \n     let metadata = composite_type_metadata(cx,\n                                            slice_llvm_type,\n@@ -659,44 +656,51 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     metadata\n }\n \n-pub fn file_metadata(cx: &CrateContext, path: &str, full_path: &Option<String>) -> DIFile {\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    let work_dir = cx.sess().working_dir.to_str().unwrap();\n-    let file_name =\n-        full_path.as_ref().map(|p| p.as_str()).unwrap_or_else(|| {\n-            if path.starts_with(work_dir) {\n-                &path[work_dir.len() + 1..path.len()]\n-            } else {\n-                path\n-            }\n-        });\n+pub fn file_metadata(cx: &CrateContext,\n+                     file_name: &str,\n+                     defining_crate: CrateNum) -> DIFile {\n+    debug!(\"file_metadata: file_name: {}, defining_crate: {}\",\n+           file_name,\n+           defining_crate);\n \n-    file_metadata_(cx, path, file_name, &work_dir)\n+    let directory = if defining_crate == LOCAL_CRATE {\n+        &cx.sess().working_dir.0[..]\n+    } else {\n+        // If the path comes from an upstream crate we assume it has been made\n+        // independent of the compiler's working directory one way or another.\n+        \"\"\n+    };\n+\n+    file_metadata_raw(cx, file_name, directory)\n }\n \n pub fn unknown_file_metadata(cx: &CrateContext) -> DIFile {\n-    // Regular filenames should not be empty, so we abuse an empty name as the\n-    // key for the special unknown file metadata\n-    file_metadata_(cx, \"\", \"<unknown>\", \"\")\n-\n+    file_metadata_raw(cx, \"<unknown>\", \"\")\n }\n \n-fn file_metadata_(cx: &CrateContext, key: &str, file_name: &str, work_dir: &str) -> DIFile {\n-    if let Some(file_metadata) = debug_context(cx).created_files.borrow().get(key) {\n+fn file_metadata_raw(cx: &CrateContext,\n+                     file_name: &str,\n+                     directory: &str)\n+                     -> DIFile {\n+    let key = (Symbol::intern(file_name), Symbol::intern(directory));\n+\n+    if let Some(file_metadata) = debug_context(cx).created_files.borrow().get(&key) {\n         return *file_metadata;\n     }\n \n-    debug!(\"file_metadata: file_name: {}, work_dir: {}\", file_name, work_dir);\n+    debug!(\"file_metadata: file_name: {}, directory: {}\", file_name, directory);\n \n     let file_name = CString::new(file_name).unwrap();\n-    let work_dir = CString::new(work_dir).unwrap();\n+    let directory = CString::new(directory).unwrap();\n+\n     let file_metadata = unsafe {\n-        llvm::LLVMRustDIBuilderCreateFile(DIB(cx), file_name.as_ptr(),\n-                                          work_dir.as_ptr())\n+        llvm::LLVMRustDIBuilderCreateFile(DIB(cx),\n+                                          file_name.as_ptr(),\n+                                          directory.as_ptr())\n     };\n \n     let mut created_files = debug_context(cx).created_files.borrow_mut();\n-    created_files.insert(key.to_string(), file_metadata);\n+    created_files.insert(key, file_metadata);\n     file_metadata\n }\n \n@@ -761,25 +765,10 @@ pub fn compile_unit_metadata(scc: &SharedCrateContext,\n                              debug_context: &CrateDebugContext,\n                              sess: &Session)\n                              -> DIDescriptor {\n-    let work_dir = &sess.working_dir;\n     let compile_unit_name = match sess.local_crate_source_file {\n         None => fallback_path(scc),\n-        Some(ref abs_path) => {\n-            if abs_path.is_relative() {\n-                sess.warn(\"debuginfo: Invalid path to crate's local root source file!\");\n-                fallback_path(scc)\n-            } else {\n-                match abs_path.strip_prefix(work_dir) {\n-                    Ok(ref p) if p.is_relative() => {\n-                        if p.starts_with(Path::new(\"./\")) {\n-                            path2cstr(p)\n-                        } else {\n-                            path2cstr(&Path::new(\".\").join(p))\n-                        }\n-                    }\n-                    _ => fallback_path(scc)\n-                }\n-            }\n+        Some(ref path) => {\n+            CString::new(&path[..]).unwrap()\n         }\n     };\n \n@@ -789,7 +778,8 @@ pub fn compile_unit_metadata(scc: &SharedCrateContext,\n                            (option_env!(\"CFG_VERSION\")).expect(\"CFG_VERSION\"));\n \n     let compile_unit_name = compile_unit_name.as_ptr();\n-    let work_dir = path2cstr(&work_dir);\n+\n+    let work_dir = CString::new(&sess.working_dir.0[..]).unwrap();\n     let producer = CString::new(producer).unwrap();\n     let flags = \"\\0\";\n     let split_name = \"\\0\";\n@@ -1760,7 +1750,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n \n     let (file_metadata, line_number) = if span != syntax_pos::DUMMY_SP {\n         let loc = span_start(cx, span);\n-        (file_metadata(cx, &loc.file.name, &loc.file.abs_path), loc.line as c_uint)\n+        (file_metadata(cx, &loc.file.name, LOCAL_CRATE), loc.line as c_uint)\n     } else {\n         (unknown_file_metadata(cx), UNKNOWN_LINE_NUMBER)\n     };\n@@ -1795,9 +1785,10 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n // Creates an \"extension\" of an existing DIScope into another file.\n pub fn extend_scope_to_file(ccx: &CrateContext,\n                             scope_metadata: DIScope,\n-                            file: &syntax_pos::FileMap)\n+                            file: &syntax_pos::FileMap,\n+                            defining_crate: CrateNum)\n                             -> DILexicalBlock {\n-    let file_metadata = file_metadata(ccx, &file.name, &file.abs_path);\n+    let file_metadata = file_metadata(ccx, &file.name, defining_crate);\n     unsafe {\n         llvm::LLVMRustDIBuilderCreateLexicalBlockFile(\n             DIB(ccx),"}, {"sha": "ebe42a2b9082d2214acbfdd89a7a817efebe992b", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -23,7 +23,7 @@ use self::source_loc::InternalDebugLocation::{self, UnknownLocation};\n use llvm;\n use llvm::{ModuleRef, ContextRef, ValueRef};\n use llvm::debuginfo::{DIFile, DIType, DIScope, DIBuilderRef, DISubprogram, DIArray, DIFlags};\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{DefId, CrateNum};\n use rustc::ty::subst::Substs;\n \n use abi::Abi;\n@@ -42,6 +42,7 @@ use std::ptr;\n \n use syntax_pos::{self, Span, Pos};\n use syntax::ast;\n+use syntax::symbol::Symbol;\n use rustc::ty::layout;\n \n pub mod gdb;\n@@ -67,7 +68,7 @@ const DW_TAG_arg_variable: c_uint = 0x101;\n pub struct CrateDebugContext<'tcx> {\n     llcontext: ContextRef,\n     builder: DIBuilderRef,\n-    created_files: RefCell<FxHashMap<String, DIFile>>,\n+    created_files: RefCell<FxHashMap<(Symbol, Symbol), DIFile>>,\n     created_enum_disr_types: RefCell<FxHashMap<(DefId, layout::Integer), DIType>>,\n \n     type_map: RefCell<TypeMap<'tcx>>,\n@@ -103,7 +104,7 @@ pub enum FunctionDebugContext {\n }\n \n impl FunctionDebugContext {\n-    fn get_ref<'a>(&'a self, span: Span) -> &'a FunctionDebugContextData {\n+    pub fn get_ref<'a>(&'a self, span: Span) -> &'a FunctionDebugContextData {\n         match *self {\n             FunctionDebugContext::RegularContext(ref data) => data,\n             FunctionDebugContext::DebugInfoDisabled => {\n@@ -128,6 +129,7 @@ impl FunctionDebugContext {\n pub struct FunctionDebugContextData {\n     fn_metadata: DISubprogram,\n     source_locations_enabled: Cell<bool>,\n+    pub defining_crate: CrateNum,\n }\n \n pub enum VariableAccess<'a> {\n@@ -220,24 +222,25 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         return FunctionDebugContext::FunctionWithoutDebugInfo;\n     }\n \n+    let def_id = instance.def_id();\n     let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, &loc.file.name, &loc.file.abs_path);\n+    let file_metadata = file_metadata(cx, &loc.file.name, def_id.krate);\n \n     let function_type_metadata = unsafe {\n         let fn_signature = get_function_signature(cx, sig);\n         llvm::LLVMRustDIBuilderCreateSubroutineType(DIB(cx), file_metadata, fn_signature)\n     };\n \n     // Find the enclosing function, in case this is a closure.\n-    let def_key = cx.tcx().def_key(instance.def_id());\n+    let def_key = cx.tcx().def_key(def_id);\n     let mut name = def_key.disambiguated_data.data.to_string();\n     let name_len = name.len();\n \n-    let fn_def_id = cx.tcx().closure_base_def_id(instance.def_id());\n+    let enclosing_fn_def_id = cx.tcx().closure_base_def_id(def_id);\n \n     // Get_template_parameters() will append a `<...>` clause to the function\n     // name if necessary.\n-    let generics = cx.tcx().generics_of(fn_def_id);\n+    let generics = cx.tcx().generics_of(enclosing_fn_def_id);\n     let substs = instance.substs.truncate_to(cx.tcx(), generics);\n     let template_parameters = get_template_parameters(cx,\n                                                       &generics,\n@@ -289,6 +292,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let fn_debug_context = FunctionDebugContextData {\n         fn_metadata: fn_metadata,\n         source_locations_enabled: Cell::new(false),\n+        defining_crate: def_id.krate,\n     };\n \n     return FunctionDebugContext::RegularContext(fn_debug_context);\n@@ -438,8 +442,9 @@ pub fn declare_local<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n     let cx = bcx.ccx;\n \n     let file = span_start(cx, span).file;\n-    let filename = file.name.clone();\n-    let file_metadata = file_metadata(cx, &filename[..], &file.abs_path);\n+    let file_metadata = file_metadata(cx,\n+                                      &file.name[..],\n+                                      dbg_context.get_ref(span).defining_crate);\n \n     let loc = span_start(cx, span);\n     let type_metadata = type_metadata(cx, variable_type, span);"}, {"sha": "54a129536d03dfad5f33bfb3b00477d2cf60e799", "filename": "src/librustc_trans/debuginfo/namespace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -72,7 +72,7 @@ pub fn item_namespace(ccx: &CrateContext, def_id: DefId) -> DIScope {\n     let span = ccx.tcx().def_span(def_id);\n     let (file, line) = if span != DUMMY_SP {\n         let loc = span_start(ccx, span);\n-        (file_metadata(ccx, &loc.file.name, &loc.file.abs_path), loc.line as c_uint)\n+        (file_metadata(ccx, &loc.file.name, def_id.krate), loc.line as c_uint)\n     } else {\n         (unknown_file_metadata(ccx), UNKNOWN_LINE_NUMBER)\n     };"}, {"sha": "19a556bf3f0f9b27af268a234b5a73a1ee343bcd", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -157,7 +157,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         if pos < self.scopes[scope_id].file_start_pos ||\n            pos >= self.scopes[scope_id].file_end_pos {\n             let cm = self.ccx.sess().codemap();\n-            debuginfo::extend_scope_to_file(self.ccx, scope_metadata, &cm.lookup_char_pos(pos).file)\n+            let defining_crate = self.debug_context.get_ref(DUMMY_SP).defining_crate;\n+            debuginfo::extend_scope_to_file(self.ccx,\n+                                            scope_metadata,\n+                                            &cm.lookup_char_pos(pos).file,\n+                                            defining_crate)\n         } else {\n             scope_metadata\n         }"}, {"sha": "0186755e30a624ba889201f27a61964760e843b5", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 72, "deletions": 45, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -637,6 +637,7 @@ pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n         typeck_item_bodies,\n         typeck_tables_of,\n+        has_typeck_tables,\n         closure_type,\n         closure_kind,\n         adt_destructor,\n@@ -664,55 +665,49 @@ fn adt_destructor<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tcx.calculate_dtor(def_id, &mut dropck::check_drop_impl)\n }\n \n-fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           def_id: DefId)\n-                           -> &'tcx ty::TypeckTables<'tcx> {\n-    // Closures' tables come from their outermost function,\n-    // as they are part of the same \"inference environment\".\n-    let outer_def_id = tcx.closure_base_def_id(def_id);\n-    if outer_def_id != def_id {\n-        return tcx.typeck_tables_of(outer_def_id);\n-    }\n-\n-    let id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    let span = tcx.hir.span(id);\n-    let unsupported = || {\n-        span_bug!(span, \"can't type-check body of {:?}\", def_id);\n-    };\n-\n-    // Figure out what primary body this item has.\n-    let mut fn_decl = None;\n-    let body_id = match tcx.hir.get(id) {\n+/// If this def-id is a \"primary tables entry\", returns `Some((body_id, decl))`\n+/// with information about it's body-id and fn-decl (if any). Otherwise,\n+/// returns `None`.\n+///\n+/// If this function returns \"some\", then `typeck_tables(def_id)` will\n+/// succeed; if it returns `None`, then `typeck_tables(def_id)` may or\n+/// may not succeed.  In some cases where this function returns `None`\n+/// (notably closures), `typeck_tables(def_id)` would wind up\n+/// redirecting to the owning function.\n+fn primary_body_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             id: ast::NodeId)\n+                             -> Option<(hir::BodyId, Option<&'tcx hir::FnDecl>)>\n+{\n+    match tcx.hir.get(id) {\n         hir::map::NodeItem(item) => {\n             match item.node {\n                 hir::ItemConst(_, body) |\n-                hir::ItemStatic(_, _, body) => body,\n-                hir::ItemFn(ref decl, .., body) => {\n-                    fn_decl = Some(decl);\n-                    body\n-                }\n-                _ => unsupported()\n+                hir::ItemStatic(_, _, body) =>\n+                    Some((body, None)),\n+                hir::ItemFn(ref decl, .., body) =>\n+                    Some((body, Some(decl))),\n+                _ =>\n+                    None,\n             }\n         }\n         hir::map::NodeTraitItem(item) => {\n             match item.node {\n-                hir::TraitItemKind::Const(_, Some(body)) => body,\n-                hir::TraitItemKind::Method(ref sig,\n-                    hir::TraitMethod::Provided(body)) => {\n-                        fn_decl = Some(&sig.decl);\n-                        body\n-                    }\n-                _ => unsupported()\n+                hir::TraitItemKind::Const(_, Some(body)) =>\n+                    Some((body, None)),\n+                hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Provided(body)) =>\n+                    Some((body, Some(&sig.decl))),\n+                _ =>\n+                    None,\n             }\n         }\n         hir::map::NodeImplItem(item) => {\n             match item.node {\n-                hir::ImplItemKind::Const(_, body) => body,\n-                hir::ImplItemKind::Method(ref sig, body) => {\n-                    fn_decl = Some(&sig.decl);\n-                    body\n-                }\n-                _ => unsupported()\n+                hir::ImplItemKind::Const(_, body) =>\n+                    Some((body, None)),\n+                hir::ImplItemKind::Method(ref sig, body) =>\n+                    Some((body, Some(&sig.decl))),\n+                _ =>\n+                    None,\n             }\n         }\n         hir::map::NodeExpr(expr) => {\n@@ -723,15 +718,47 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // Assume that everything other than closures\n             // is a constant \"initializer\" expression.\n             match expr.node {\n-                hir::ExprClosure(..) => {\n-                    // We should've bailed out above for closures.\n-                    span_bug!(expr.span, \"unexpected closure\")\n-                }\n-                _ => hir::BodyId { node_id: expr.id }\n+                hir::ExprClosure(..) =>\n+                    None,\n+                _ =>\n+                    Some((hir::BodyId { node_id: expr.id }, None)),\n             }\n         }\n-        _ => unsupported()\n-    };\n+        _ => None,\n+    }\n+}\n+\n+fn has_typeck_tables<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                               def_id: DefId)\n+                               -> bool {\n+    // Closures' tables come from their outermost function,\n+    // as they are part of the same \"inference environment\".\n+    let outer_def_id = tcx.closure_base_def_id(def_id);\n+    if outer_def_id != def_id {\n+        return tcx.has_typeck_tables(outer_def_id);\n+    }\n+\n+    let id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    primary_body_of(tcx, id).is_some()\n+}\n+\n+fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                              def_id: DefId)\n+                              -> &'tcx ty::TypeckTables<'tcx> {\n+    // Closures' tables come from their outermost function,\n+    // as they are part of the same \"inference environment\".\n+    let outer_def_id = tcx.closure_base_def_id(def_id);\n+    if outer_def_id != def_id {\n+        return tcx.typeck_tables_of(outer_def_id);\n+    }\n+\n+    let id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    let span = tcx.hir.span(id);\n+\n+    // Figure out what primary body this item has.\n+    let (body_id, fn_decl) = primary_body_of(tcx, id).unwrap_or_else(|| {\n+        span_bug!(span, \"can't type-check body of {:?}\", def_id);\n+    });\n     let body = tcx.hir.body(body_id);\n \n     Inherited::build(tcx, id).enter(|inh| {"}, {"sha": "1af55d4d840d9b0fa852923539632a75a896c1b6", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -63,17 +63,11 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CheckVisitor<'a, 'tcx> {\n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut used_trait_imports = DefIdSet();\n     for &body_id in tcx.hir.krate().bodies.keys() {\n-        let item_id = tcx.hir.body_owner(body_id);\n-        let item_def_id = tcx.hir.local_def_id(item_id);\n-\n-        // this will have been written by the main typeck pass\n-        if let Some(tables) = tcx.maps.typeck_tables_of.borrow().get(&item_def_id) {\n-            let imports = &tables.used_trait_imports;\n-            debug!(\"GatherVisitor: item_def_id={:?} with imports {:#?}\", item_def_id, imports);\n-            used_trait_imports.extend(imports);\n-        } else {\n-            debug!(\"GatherVisitor: item_def_id={:?} with no imports\", item_def_id);\n-        }\n+        let item_def_id = tcx.hir.body_owner_def_id(body_id);\n+        let tables = tcx.typeck_tables_of(item_def_id);\n+        let imports = &tables.used_trait_imports;\n+        debug!(\"GatherVisitor: item_def_id={:?} with imports {:#?}\", item_def_id, imports);\n+        used_trait_imports.extend(imports);\n     }\n \n     let mut visitor = CheckVisitor { tcx, used_trait_imports };"}, {"sha": "238952865c7bd91e3525e19fc3e6b5e8e8471c37", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -66,11 +66,15 @@ pub fn inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     //\n     // [the plan]: https://github.com/rust-lang/rust-roadmap/issues/4\n \n+    thread_local! {\n+        static EMPTY_DEF_ID_VEC: Rc<Vec<DefId>> = Rc::new(vec![])\n+    }\n+\n     let result = tcx.dep_graph.with_ignore(|| {\n         let crate_map = tcx.crate_inherent_impls(ty_def_id.krate);\n         match crate_map.inherent_impls.get(&ty_def_id) {\n             Some(v) => v.clone(),\n-            None => Rc::new(vec![]),\n+            None => EMPTY_DEF_ID_VEC.with(|v| v.clone())\n         }\n     });\n "}, {"sha": "6417270b9c73bc8a1ce8c0a137a8f950ff4bfaba", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -129,7 +129,7 @@ pub fn run_core(search_paths: SearchPaths,\n         ..config::basic_options().clone()\n     };\n \n-    let codemap = Rc::new(codemap::CodeMap::new());\n+    let codemap = Rc::new(codemap::CodeMap::new(sessopts.file_path_mapping()));\n     let diagnostic_handler = errors::Handler::with_tty_emitter(ColorConfig::Auto,\n                                                                true,\n                                                                false,"}, {"sha": "15dada10c0dc11d7758761762c7ad1924cbeb924", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -26,7 +26,7 @@ use std::fmt::Display;\n use std::io;\n use std::io::prelude::*;\n \n-use syntax::codemap::CodeMap;\n+use syntax::codemap::{CodeMap, FilePathMapping};\n use syntax::parse::lexer::{self, TokenAndSpan};\n use syntax::parse::token;\n use syntax::parse;\n@@ -36,8 +36,8 @@ use syntax_pos::Span;\n pub fn render_with_highlighting(src: &str, class: Option<&str>, id: Option<&str>,\n                                 extension: Option<&str>) -> String {\n     debug!(\"highlighting: ================\\n{}\\n==============\", src);\n-    let sess = parse::ParseSess::new();\n-    let fm = sess.codemap().new_filemap(\"<stdin>\".to_string(), None, src.to_string());\n+    let sess = parse::ParseSess::new(FilePathMapping::empty());\n+    let fm = sess.codemap().new_filemap(\"<stdin>\".to_string(), src.to_string());\n \n     let mut out = Vec::new();\n     write_header(class, id, &mut out).unwrap();\n@@ -58,8 +58,8 @@ pub fn render_with_highlighting(src: &str, class: Option<&str>, id: Option<&str>\n /// be inserted into an element. C.f., `render_with_highlighting` which includes\n /// an enclosing `<pre>` block.\n pub fn render_inner_with_highlighting(src: &str) -> io::Result<String> {\n-    let sess = parse::ParseSess::new();\n-    let fm = sess.codemap().new_filemap(\"<stdin>\".to_string(), None, src.to_string());\n+    let sess = parse::ParseSess::new(FilePathMapping::empty());\n+    let fm = sess.codemap().new_filemap(\"<stdin>\".to_string(), src.to_string());\n \n     let mut out = Vec::new();\n     let mut classifier = Classifier::new(lexer::StringReader::new(&sess, fm), sess.codemap());"}, {"sha": "5428b0663f36808f6f87a66bcff5c6e8d8c151b4", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -74,7 +74,7 @@ pub fn run(input: &str,\n         ..config::basic_options().clone()\n     };\n \n-    let codemap = Rc::new(CodeMap::new());\n+    let codemap = Rc::new(CodeMap::new(sessopts.file_path_mapping()));\n     let handler =\n         errors::Handler::with_tty_emitter(ColorConfig::Auto, true, false, Some(codemap.clone()));\n \n@@ -217,7 +217,7 @@ fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n         }\n     }\n     let data = Arc::new(Mutex::new(Vec::new()));\n-    let codemap = Rc::new(CodeMap::new());\n+    let codemap = Rc::new(CodeMap::new(sessopts.file_path_mapping()));\n     let emitter = errors::emitter::EmitterWriter::new(box Sink(data.clone()),\n                                                       Some(codemap.clone()));\n     let old = io::set_panic(Some(box Sink(data.clone())));"}, {"sha": "8a88ec3a6724fc0df57382592d07b0c5f1c17553", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 69, "deletions": 32, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -104,32 +104,42 @@ impl FileLoader for RealFileLoader {\n \n pub struct CodeMap {\n     pub files: RefCell<Vec<Rc<FileMap>>>,\n-    file_loader: Box<FileLoader>\n+    file_loader: Box<FileLoader>,\n+    // This is used to apply the file path remapping as specified via\n+    // -Zremap-path-prefix to all FileMaps allocated within this CodeMap.\n+    path_mapping: FilePathMapping,\n }\n \n impl CodeMap {\n-    pub fn new() -> CodeMap {\n+    pub fn new(path_mapping: FilePathMapping) -> CodeMap {\n         CodeMap {\n             files: RefCell::new(Vec::new()),\n-            file_loader: Box::new(RealFileLoader)\n+            file_loader: Box::new(RealFileLoader),\n+            path_mapping: path_mapping,\n         }\n     }\n \n-    pub fn with_file_loader(file_loader: Box<FileLoader>) -> CodeMap {\n+    pub fn with_file_loader(file_loader: Box<FileLoader>,\n+                            path_mapping: FilePathMapping)\n+                            -> CodeMap {\n         CodeMap {\n             files: RefCell::new(Vec::new()),\n-            file_loader: file_loader\n+            file_loader: file_loader,\n+            path_mapping: path_mapping,\n         }\n     }\n \n+    pub fn path_mapping(&self) -> &FilePathMapping {\n+        &self.path_mapping\n+    }\n+\n     pub fn file_exists(&self, path: &Path) -> bool {\n         self.file_loader.file_exists(path)\n     }\n \n     pub fn load_file(&self, path: &Path) -> io::Result<Rc<FileMap>> {\n         let src = self.file_loader.read_file(path)?;\n-        let abs_path = self.file_loader.abs_path(path).map(|p| p.to_str().unwrap().to_string());\n-        Ok(self.new_filemap(path.to_str().unwrap().to_string(), abs_path, src))\n+        Ok(self.new_filemap(path.to_str().unwrap().to_string(), src))\n     }\n \n     fn next_start_pos(&self) -> usize {\n@@ -144,8 +154,7 @@ impl CodeMap {\n \n     /// Creates a new filemap without setting its line information. If you don't\n     /// intend to set the line information yourself, you should use new_filemap_and_lines.\n-    pub fn new_filemap(&self, filename: FileName, abs_path: Option<FileName>,\n-                       mut src: String) -> Rc<FileMap> {\n+    pub fn new_filemap(&self, filename: FileName, mut src: String) -> Rc<FileMap> {\n         let start_pos = self.next_start_pos();\n         let mut files = self.files.borrow_mut();\n \n@@ -156,9 +165,11 @@ impl CodeMap {\n \n         let end_pos = start_pos + src.len();\n \n+        let (filename, was_remapped) = self.path_mapping.map_prefix(filename);\n+\n         let filemap = Rc::new(FileMap {\n             name: filename,\n-            abs_path: abs_path,\n+            name_was_remapped: was_remapped,\n             src: Some(Rc::new(src)),\n             start_pos: Pos::from_usize(start_pos),\n             end_pos: Pos::from_usize(end_pos),\n@@ -172,11 +183,8 @@ impl CodeMap {\n     }\n \n     /// Creates a new filemap and sets its line information.\n-    pub fn new_filemap_and_lines(&self, filename: &str, abs_path: Option<&str>,\n-                                 src: &str) -> Rc<FileMap> {\n-        let fm = self.new_filemap(filename.to_string(),\n-                                  abs_path.map(|s| s.to_owned()),\n-                                  src.to_owned());\n+    pub fn new_filemap_and_lines(&self, filename: &str, src: &str) -> Rc<FileMap> {\n+        let fm = self.new_filemap(filename.to_string(), src.to_owned());\n         let mut byte_pos: u32 = fm.start_pos.0;\n         for line in src.lines() {\n             // register the start of this line\n@@ -195,7 +203,7 @@ impl CodeMap {\n     /// information for things inlined from other crates.\n     pub fn new_imported_filemap(&self,\n                                 filename: FileName,\n-                                abs_path: Option<FileName>,\n+                                name_was_remapped: bool,\n                                 source_len: usize,\n                                 mut file_local_lines: Vec<BytePos>,\n                                 mut file_local_multibyte_chars: Vec<MultiByteChar>)\n@@ -216,7 +224,7 @@ impl CodeMap {\n \n         let filemap = Rc::new(FileMap {\n             name: filename,\n-            abs_path: abs_path,\n+            name_was_remapped: name_was_remapped,\n             src: None,\n             start_pos: start_pos,\n             end_pos: end_pos,\n@@ -550,6 +558,42 @@ impl CodeMapper for CodeMap {\n     }\n }\n \n+#[derive(Clone)]\n+pub struct FilePathMapping {\n+    mapping: Vec<(String, String)>,\n+}\n+\n+impl FilePathMapping {\n+    pub fn empty() -> FilePathMapping {\n+        FilePathMapping {\n+            mapping: vec![]\n+        }\n+    }\n+\n+    pub fn new(mapping: Vec<(String, String)>) -> FilePathMapping {\n+        FilePathMapping {\n+            mapping: mapping\n+        }\n+    }\n+\n+    /// Applies any path prefix substitution as defined by the mapping.\n+    /// The return value is the remapped path and a boolean indicating whether\n+    /// the path was affected by the mapping.\n+    pub fn map_prefix(&self, path: String) -> (String, bool) {\n+        // NOTE: We are iterating over the mapping entries from last to first\n+        //       because entries specified later on the command line should\n+        //       take precedence.\n+        for &(ref from, ref to) in self.mapping.iter().rev() {\n+            if path.starts_with(from) {\n+                let mapped = path.replacen(from, to, 1);\n+                return (mapped, true);\n+            }\n+        }\n+\n+        (path, false)\n+    }\n+}\n+\n // _____________________________________________________________________________\n // Tests\n //\n@@ -561,9 +605,8 @@ mod tests {\n \n     #[test]\n     fn t1 () {\n-        let cm = CodeMap::new();\n+        let cm = CodeMap::new(FilePathMapping::empty());\n         let fm = cm.new_filemap(\"blork.rs\".to_string(),\n-                                None,\n                                 \"first line.\\nsecond line\".to_string());\n         fm.next_line(BytePos(0));\n         // Test we can get lines with partial line info.\n@@ -578,9 +621,8 @@ mod tests {\n     #[test]\n     #[should_panic]\n     fn t2 () {\n-        let cm = CodeMap::new();\n+        let cm = CodeMap::new(FilePathMapping::empty());\n         let fm = cm.new_filemap(\"blork.rs\".to_string(),\n-                                None,\n                                 \"first line.\\nsecond line\".to_string());\n         // TESTING *REALLY* BROKEN BEHAVIOR:\n         fm.next_line(BytePos(0));\n@@ -589,15 +631,12 @@ mod tests {\n     }\n \n     fn init_code_map() -> CodeMap {\n-        let cm = CodeMap::new();\n+        let cm = CodeMap::new(FilePathMapping::empty());\n         let fm1 = cm.new_filemap(\"blork.rs\".to_string(),\n-                                 None,\n                                  \"first line.\\nsecond line\".to_string());\n         let fm2 = cm.new_filemap(\"empty.rs\".to_string(),\n-                                 None,\n                                  \"\".to_string());\n         let fm3 = cm.new_filemap(\"blork2.rs\".to_string(),\n-                                 None,\n                                  \"first line.\\nsecond line\".to_string());\n \n         fm1.next_line(BytePos(0));\n@@ -656,14 +695,12 @@ mod tests {\n     }\n \n     fn init_code_map_mbc() -> CodeMap {\n-        let cm = CodeMap::new();\n+        let cm = CodeMap::new(FilePathMapping::empty());\n         // \u20ac is a three byte utf8 char.\n         let fm1 =\n             cm.new_filemap(\"blork.rs\".to_string(),\n-                           None,\n                            \"fir\u20acst \u20ac\u20ac\u20ac\u20ac line.\\nsecond line\".to_string());\n         let fm2 = cm.new_filemap(\"blork2.rs\".to_string(),\n-                                 None,\n                                  \"first line\u20ac\u20ac.\\n\u20ac second line\".to_string());\n \n         fm1.next_line(BytePos(0));\n@@ -728,10 +765,10 @@ mod tests {\n     /// lines in the middle of a file.\n     #[test]\n     fn span_to_snippet_and_lines_spanning_multiple_lines() {\n-        let cm = CodeMap::new();\n+        let cm = CodeMap::new(FilePathMapping::empty());\n         let inputtext = \"aaaaa\\nbbbbBB\\nCCC\\nDDDDDddddd\\neee\\n\";\n         let selection = \"     \\n    ~~\\n~~~\\n~~~~~     \\n   \\n\";\n-        cm.new_filemap_and_lines(\"blork.rs\", None, inputtext);\n+        cm.new_filemap_and_lines(\"blork.rs\", inputtext);\n         let span = span_from_selection(inputtext, selection);\n \n         // check that we are extracting the text we thought we were extracting\n@@ -770,11 +807,11 @@ mod tests {\n     /// Test failing to merge two spans on different lines\n     #[test]\n     fn span_merging_fail() {\n-        let cm = CodeMap::new();\n+        let cm = CodeMap::new(FilePathMapping::empty());\n         let inputtext  = \"bbbb BB\\ncc CCC\\n\";\n         let selection1 = \"     ~~\\n      \\n\";\n         let selection2 = \"       \\n   ~~~\\n\";\n-        cm.new_filemap_and_lines(\"blork.rs\", None, inputtext);\n+        cm.new_filemap_and_lines(\"blork.rs\", inputtext);\n         let span1 = span_from_selection(inputtext, selection1);\n         let span2 = span_from_selection(inputtext, selection2);\n "}, {"sha": "2db295d013639e8bcd36463381b5a01328b8eb1a", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -783,7 +783,7 @@ fn stream_for_item(item: &Annotatable, parse_sess: &ParseSess) -> TokenStream {\n \n fn string_to_stream(text: String, parse_sess: &ParseSess) -> TokenStream {\n     let filename = String::from(\"<macro expansion>\");\n-    filemap_to_stream(parse_sess, parse_sess.codemap().new_filemap(filename, None, text))\n+    filemap_to_stream(parse_sess, parse_sess.codemap().new_filemap(filename, text))\n }\n \n impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {"}, {"sha": "22a5776315a0cfe6cdf3c1e72e7de81ab0ef4b92", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -142,7 +142,7 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenT\n             // Add this input file to the code map to make it available as\n             // dependency information\n             let filename = format!(\"{}\", file.display());\n-            cx.codemap().new_filemap_and_lines(&filename, None, &src);\n+            cx.codemap().new_filemap_and_lines(&filename, &src);\n \n             base::MacEager::expr(cx.expr_str(sp, Symbol::intern(&src)))\n         }\n@@ -173,7 +173,7 @@ pub fn expand_include_bytes(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::Toke\n             // Add this input file to the code map to make it available as\n             // dependency information, but don't enter it's contents\n             let filename = format!(\"{}\", file.display());\n-            cx.codemap().new_filemap_and_lines(&filename, None, \"\");\n+            cx.codemap().new_filemap_and_lines(&filename, \"\");\n \n             base::MacEager::expr(cx.expr_lit(sp, ast::LitKind::ByteStr(Rc::new(bytes))))\n         }"}, {"sha": "47b60f0e080d0760518ead367eab8efe8c385dad", "filename": "src/libsyntax/json.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibsyntax%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibsyntax%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -19,7 +19,7 @@\n \n // FIXME spec the JSON output properly.\n \n-use codemap::CodeMap;\n+use codemap::{CodeMap, FilePathMapping};\n use syntax_pos::{self, MacroBacktrace, Span, SpanLabel, MultiSpan};\n use errors::registry::Registry;\n use errors::{DiagnosticBuilder, SubDiagnostic, RenderSpan, CodeSuggestion, CodeMapper};\n@@ -48,7 +48,8 @@ impl JsonEmitter {\n     }\n \n     pub fn basic() -> JsonEmitter {\n-        JsonEmitter::stderr(None, Rc::new(CodeMap::new()))\n+        let file_path_mapping = FilePathMapping::empty();\n+        JsonEmitter::stderr(None, Rc::new(CodeMap::new(file_path_mapping)))\n     }\n \n     pub fn new(dst: Box<Write + Send>,"}, {"sha": "7ac322b144c7ea46c9641fbb719f87909e0f6998", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -348,8 +348,8 @@ pub fn gather_comments_and_literals(sess: &ParseSess, path: String, srdr: &mut R\n     let mut src = Vec::new();\n     srdr.read_to_end(&mut src).unwrap();\n     let src = String::from_utf8(src).unwrap();\n-    let cm = CodeMap::new();\n-    let filemap = cm.new_filemap(path, None, src);\n+    let cm = CodeMap::new(sess.codemap().path_mapping().clone());\n+    let filemap = cm.new_filemap(path, src);\n     let mut rdr = lexer::StringReader::new_raw(sess, filemap);\n \n     let mut comments: Vec<Comment> = Vec::new();"}, {"sha": "c2e5763237d3c89e0b4f36876365ee073cc40ad4", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -10,7 +10,7 @@\n \n use ast::{self, Ident};\n use syntax_pos::{self, BytePos, CharPos, Pos, Span, NO_EXPANSION};\n-use codemap::CodeMap;\n+use codemap::{CodeMap, FilePathMapping};\n use errors::{FatalError, DiagnosticBuilder};\n use parse::{token, ParseSess};\n use str::char_at;\n@@ -563,7 +563,7 @@ impl<'a> StringReader<'a> {\n \n                 // I guess this is the only way to figure out if\n                 // we're at the beginning of the file...\n-                let cmap = CodeMap::new();\n+                let cmap = CodeMap::new(FilePathMapping::empty());\n                 cmap.files.borrow_mut().push(self.filemap.clone());\n                 let loc = cmap.lookup_char_pos_adj(self.pos);\n                 debug!(\"Skipping a shebang\");\n@@ -1718,13 +1718,13 @@ mod tests {\n                  sess: &'a ParseSess,\n                  teststr: String)\n                  -> StringReader<'a> {\n-        let fm = cm.new_filemap(\"zebra.rs\".to_string(), None, teststr);\n+        let fm = cm.new_filemap(\"zebra.rs\".to_string(), teststr);\n         StringReader::new(sess, fm)\n     }\n \n     #[test]\n     fn t1() {\n-        let cm = Rc::new(CodeMap::new());\n+        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         let mut string_reader = setup(&cm,\n                                       &sh,\n@@ -1776,71 +1776,71 @@ mod tests {\n \n     #[test]\n     fn doublecolonparsing() {\n-        let cm = Rc::new(CodeMap::new());\n+        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         check_tokenization(setup(&cm, &sh, \"a b\".to_string()),\n                            vec![mk_ident(\"a\"), token::Whitespace, mk_ident(\"b\")]);\n     }\n \n     #[test]\n     fn dcparsing_2() {\n-        let cm = Rc::new(CodeMap::new());\n+        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         check_tokenization(setup(&cm, &sh, \"a::b\".to_string()),\n                            vec![mk_ident(\"a\"), token::ModSep, mk_ident(\"b\")]);\n     }\n \n     #[test]\n     fn dcparsing_3() {\n-        let cm = Rc::new(CodeMap::new());\n+        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         check_tokenization(setup(&cm, &sh, \"a ::b\".to_string()),\n                            vec![mk_ident(\"a\"), token::Whitespace, token::ModSep, mk_ident(\"b\")]);\n     }\n \n     #[test]\n     fn dcparsing_4() {\n-        let cm = Rc::new(CodeMap::new());\n+        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         check_tokenization(setup(&cm, &sh, \"a:: b\".to_string()),\n                            vec![mk_ident(\"a\"), token::ModSep, token::Whitespace, mk_ident(\"b\")]);\n     }\n \n     #[test]\n     fn character_a() {\n-        let cm = Rc::new(CodeMap::new());\n+        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         assert_eq!(setup(&cm, &sh, \"'a'\".to_string()).next_token().tok,\n                    token::Literal(token::Char(Symbol::intern(\"a\")), None));\n     }\n \n     #[test]\n     fn character_space() {\n-        let cm = Rc::new(CodeMap::new());\n+        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         assert_eq!(setup(&cm, &sh, \"' '\".to_string()).next_token().tok,\n                    token::Literal(token::Char(Symbol::intern(\" \")), None));\n     }\n \n     #[test]\n     fn character_escaped() {\n-        let cm = Rc::new(CodeMap::new());\n+        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         assert_eq!(setup(&cm, &sh, \"'\\\\n'\".to_string()).next_token().tok,\n                    token::Literal(token::Char(Symbol::intern(\"\\\\n\")), None));\n     }\n \n     #[test]\n     fn lifetime_name() {\n-        let cm = Rc::new(CodeMap::new());\n+        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         assert_eq!(setup(&cm, &sh, \"'abc\".to_string()).next_token().tok,\n                    token::Lifetime(Ident::from_str(\"'abc\")));\n     }\n \n     #[test]\n     fn raw_string() {\n-        let cm = Rc::new(CodeMap::new());\n+        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         assert_eq!(setup(&cm, &sh, \"r###\\\"\\\"#a\\\\b\\x00c\\\"\\\"###\".to_string())\n                        .next_token()\n@@ -1850,7 +1850,7 @@ mod tests {\n \n     #[test]\n     fn literal_suffixes() {\n-        let cm = Rc::new(CodeMap::new());\n+        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         macro_rules! test {\n             ($input: expr, $tok_type: ident, $tok_contents: expr) => {{\n@@ -1894,7 +1894,7 @@ mod tests {\n \n     #[test]\n     fn nested_block_comments() {\n-        let cm = Rc::new(CodeMap::new());\n+        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         let mut lexer = setup(&cm, &sh, \"/* /* */ */'a'\".to_string());\n         match lexer.next_token().tok {\n@@ -1907,7 +1907,7 @@ mod tests {\n \n     #[test]\n     fn crlf_comments() {\n-        let cm = Rc::new(CodeMap::new());\n+        let cm = Rc::new(CodeMap::new(FilePathMapping::empty()));\n         let sh = mk_sess(cm.clone());\n         let mut lexer = setup(&cm, &sh, \"// test\\r\\n/// test\\r\\n\".to_string());\n         let comment = lexer.next_token();"}, {"sha": "9d8f3b3d039d2ef60768d0a46f00116f40a07878", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -11,7 +11,7 @@\n //! The main parser interface\n \n use ast::{self, CrateConfig};\n-use codemap::CodeMap;\n+use codemap::{CodeMap, FilePathMapping};\n use syntax_pos::{self, Span, FileMap, NO_EXPANSION};\n use errors::{Handler, ColorConfig, DiagnosticBuilder};\n use feature_gate::UnstableFeatures;\n@@ -53,8 +53,8 @@ pub struct ParseSess {\n }\n \n impl ParseSess {\n-    pub fn new() -> Self {\n-        let cm = Rc::new(CodeMap::new());\n+    pub fn new(file_path_mapping: FilePathMapping) -> Self {\n+        let cm = Rc::new(CodeMap::new(file_path_mapping));\n         let handler = Handler::with_tty_emitter(ColorConfig::Auto,\n                                                 true,\n                                                 false,\n@@ -143,13 +143,13 @@ pub fn parse_stmt_from_source_str<'a>(name: String, source: String, sess: &'a Pa\n \n pub fn parse_stream_from_source_str<'a>(name: String, source: String, sess: &'a ParseSess)\n                                         -> TokenStream {\n-    filemap_to_stream(sess, sess.codemap().new_filemap(name, None, source))\n+    filemap_to_stream(sess, sess.codemap().new_filemap(name, source))\n }\n \n // Create a new parser from a source string\n pub fn new_parser_from_source_str<'a>(sess: &'a ParseSess, name: String, source: String)\n                                       -> Parser<'a> {\n-    filemap_to_parser(sess, sess.codemap().new_filemap(name, None, source))\n+    filemap_to_parser(sess, sess.codemap().new_filemap(name, source))\n }\n \n /// Create a new parser, handling errors as appropriate\n@@ -828,7 +828,7 @@ mod tests {\n     }\n \n     #[test] fn parse_ident_pat () {\n-        let sess = ParseSess::new();\n+        let sess = ParseSess::new(FilePathMapping::empty());\n         let mut parser = string_to_parser(&sess, \"b\".to_string());\n         assert!(panictry!(parser.parse_pat())\n                 == P(ast::Pat{\n@@ -998,7 +998,7 @@ mod tests {\n     }\n \n     #[test] fn crlf_doc_comments() {\n-        let sess = ParseSess::new();\n+        let sess = ParseSess::new(FilePathMapping::empty());\n \n         let name = \"<source>\".to_string();\n         let source = \"/// doc comment\\r\\nfn foo() {}\".to_string();\n@@ -1023,7 +1023,7 @@ mod tests {\n \n     #[test]\n     fn ttdelim_span() {\n-        let sess = ParseSess::new();\n+        let sess = ParseSess::new(FilePathMapping::empty());\n         let expr = parse::parse_expr_from_source_str(\"foo\".to_string(),\n             \"foo!( fn main() { body } )\".to_string(), &sess).unwrap();\n "}, {"sha": "84d53dbef7c884ae6f2b95205f646f7db8b9e4f9", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -1453,9 +1453,9 @@ impl<'a> Parser<'a> {\n         } else if self.eat_keyword(keywords::Impl) {\n             // FIXME: figure out priority of `+` in `impl Trait1 + Trait2` (#34511).\n             TyKind::ImplTrait(self.parse_ty_param_bounds()?)\n-        } else if self.check(&token::Question) {\n+        } else if self.check(&token::Question) ||\n+                  self.check_lifetime() && self.look_ahead(1, |t| t == &token::BinOp(token::Plus)){\n             // Bound list (trait object type)\n-            // Bound lists starting with `'lt` are not currently supported (#40043)\n             TyKind::TraitObject(self.parse_ty_param_bounds_common(allow_plus)?)\n         } else {\n             let msg = format!(\"expected type, found {}\", self.this_token_descr());"}, {"sha": "b3fa1e97376d016faaed2d4d09a31df547be9bf1", "filename": "src/libsyntax/test_snippet.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibsyntax%2Ftest_snippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibsyntax%2Ftest_snippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest_snippet.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use codemap::CodeMap;\n+use codemap::{CodeMap, FilePathMapping};\n use errors::Handler;\n use errors::emitter::EmitterWriter;\n use std::io;\n@@ -47,8 +47,8 @@ impl<T: Write> Write for Shared<T> {\n fn test_harness(file_text: &str, span_labels: Vec<SpanLabel>, expected_output: &str) {\n     let output = Arc::new(Mutex::new(Vec::new()));\n \n-    let code_map = Rc::new(CodeMap::new());\n-    code_map.new_filemap_and_lines(\"test.rs\", None, &file_text);\n+    let code_map = Rc::new(CodeMap::new(FilePathMapping::empty()));\n+    code_map.new_filemap_and_lines(\"test.rs\", &file_text);\n \n     let primary_span = make_span(&file_text, &span_labels[0].start, &span_labels[0].end);\n     let mut msp = MultiSpan::from_span(primary_span);"}, {"sha": "2727ab79ebf76b80763a9420132598355b6aba6e", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use ast::{self, Ident};\n+use codemap::FilePathMapping;\n use parse::{ParseSess, PResult, filemap_to_stream};\n use parse::{lexer, new_parser_from_source_str};\n use parse::parser::Parser;\n@@ -18,8 +19,8 @@ use std::iter::Peekable;\n \n /// Map a string to tts, using a made-up filename:\n pub fn string_to_stream(source_str: String) -> TokenStream {\n-    let ps = ParseSess::new();\n-    filemap_to_stream(&ps, ps.codemap().new_filemap(\"bogofile\".to_string(), None, source_str))\n+    let ps = ParseSess::new(FilePathMapping::empty());\n+    filemap_to_stream(&ps, ps.codemap().new_filemap(\"bogofile\".to_string(), source_str))\n }\n \n /// Map string to parser (via tts)\n@@ -38,31 +39,31 @@ fn with_error_checking_parse<'a, T, F>(s: String, ps: &'a ParseSess, f: F) -> T\n \n /// Parse a string, return a crate.\n pub fn string_to_crate (source_str : String) -> ast::Crate {\n-    let ps = ParseSess::new();\n+    let ps = ParseSess::new(FilePathMapping::empty());\n     with_error_checking_parse(source_str, &ps, |p| {\n         p.parse_crate_mod()\n     })\n }\n \n /// Parse a string, return an expr\n pub fn string_to_expr (source_str : String) -> P<ast::Expr> {\n-    let ps = ParseSess::new();\n+    let ps = ParseSess::new(FilePathMapping::empty());\n     with_error_checking_parse(source_str, &ps, |p| {\n         p.parse_expr()\n     })\n }\n \n /// Parse a string, return an item\n pub fn string_to_item (source_str : String) -> Option<P<ast::Item>> {\n-    let ps = ParseSess::new();\n+    let ps = ParseSess::new(FilePathMapping::empty());\n     with_error_checking_parse(source_str, &ps, |p| {\n         p.parse_item()\n     })\n }\n \n /// Parse a string, return a stmt\n pub fn string_to_stmt(source_str : String) -> Option<ast::Stmt> {\n-    let ps = ParseSess::new();\n+    let ps = ParseSess::new(FilePathMapping::empty());\n     with_error_checking_parse(source_str, &ps, |p| {\n         p.parse_stmt()\n     })\n@@ -71,7 +72,7 @@ pub fn string_to_stmt(source_str : String) -> Option<ast::Stmt> {\n /// Parse a string, return a pat. Uses \"irrefutable\"... which doesn't\n /// (currently) affect parsing.\n pub fn string_to_pat(source_str: String) -> P<ast::Pat> {\n-    let ps = ParseSess::new();\n+    let ps = ParseSess::new(FilePathMapping::empty());\n     with_error_checking_parse(source_str, &ps, |p| {\n         p.parse_pat()\n     })"}, {"sha": "f46b4fcb715b088da96a2c7bf2aa277deb9dc192", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -369,13 +369,14 @@ pub struct MultiByteChar {\n }\n \n /// A single source in the CodeMap.\n+#[derive(Clone)]\n pub struct FileMap {\n     /// The name of the file that the source came from, source that doesn't\n     /// originate from files has names between angle brackets by convention,\n     /// e.g. `<anon>`\n     pub name: FileName,\n-    /// The absolute path of the file that the source came from.\n-    pub abs_path: Option<FileName>,\n+    /// True if the `name` field above has been modified by -Zremap-path-prefix\n+    pub name_was_remapped: bool,\n     /// The complete source code\n     pub src: Option<Rc<String>>,\n     /// The start position of this source in the CodeMap\n@@ -392,7 +393,7 @@ impl Encodable for FileMap {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_struct(\"FileMap\", 6, |s| {\n             s.emit_struct_field(\"name\", 0, |s| self.name.encode(s))?;\n-            s.emit_struct_field(\"abs_path\", 1, |s| self.abs_path.encode(s))?;\n+            s.emit_struct_field(\"name_was_remapped\", 1, |s| self.name_was_remapped.encode(s))?;\n             s.emit_struct_field(\"start_pos\", 2, |s| self.start_pos.encode(s))?;\n             s.emit_struct_field(\"end_pos\", 3, |s| self.end_pos.encode(s))?;\n             s.emit_struct_field(\"lines\", 4, |s| {\n@@ -453,8 +454,8 @@ impl Decodable for FileMap {\n \n         d.read_struct(\"FileMap\", 6, |d| {\n             let name: String = d.read_struct_field(\"name\", 0, |d| Decodable::decode(d))?;\n-            let abs_path: Option<String> =\n-                d.read_struct_field(\"abs_path\", 1, |d| Decodable::decode(d))?;\n+            let name_was_remapped: bool =\n+                d.read_struct_field(\"name_was_remapped\", 1, |d| Decodable::decode(d))?;\n             let start_pos: BytePos = d.read_struct_field(\"start_pos\", 2, |d| Decodable::decode(d))?;\n             let end_pos: BytePos = d.read_struct_field(\"end_pos\", 3, |d| Decodable::decode(d))?;\n             let lines: Vec<BytePos> = d.read_struct_field(\"lines\", 4, |d| {\n@@ -489,7 +490,7 @@ impl Decodable for FileMap {\n                 d.read_struct_field(\"multibyte_chars\", 5, |d| Decodable::decode(d))?;\n             Ok(FileMap {\n                 name: name,\n-                abs_path: abs_path,\n+                name_was_remapped: name_was_remapped,\n                 start_pos: start_pos,\n                 end_pos: end_pos,\n                 src: None,"}, {"sha": "5543a091680f17fd52cf6396c2fd7937d7a13e5b", "filename": "src/test/codegen/remap_path_prefix/auxiliary/remap_path_prefix_aux.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fauxiliary%2Fremap_path_prefix_aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fauxiliary%2Fremap_path_prefix_aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fauxiliary%2Fremap_path_prefix_aux.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+\n+// compile-flags: -g  -Zremap-path-prefix-from={{cwd}} -Zremap-path-prefix-to=/the/aux-cwd -Zremap-path-prefix-from={{src-base}}/remap_path_prefix/auxiliary -Zremap-path-prefix-to=/the/aux-src\n+\n+#[inline]\n+pub fn some_aux_function() -> i32 {\n+    1234\n+}"}, {"sha": "eb00c91ba5f39f29feebb269845343725af119eb", "filename": "src/test/codegen/remap_path_prefix/main.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fmain.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-windows\n+// ignore-tidy-linelength\n+\n+// compile-flags: -g  -C no-prepopulate-passes -Zremap-path-prefix-from={{cwd}} -Zremap-path-prefix-to=/the/cwd -Zremap-path-prefix-from={{src-base}} -Zremap-path-prefix-to=/the/src\n+// aux-build:remap_path_prefix_aux.rs\n+\n+extern crate remap_path_prefix_aux;\n+\n+// Here we check that the expansion of the file!() macro is mapped.\n+// CHECK: internal constant [34 x i8] c\"/the/src/remap_path_prefix/main.rs\"\n+pub static FILE_PATH: &'static str = file!();\n+\n+fn main() {\n+    remap_path_prefix_aux::some_aux_function();\n+}\n+\n+// Here we check that local debuginfo is mapped correctly.\n+// CHECK: !DIFile(filename: \"/the/src/remap_path_prefix/main.rs\", directory: \"/the/cwd\")\n+\n+// And here that debuginfo from other crates are expanded to absolute paths.\n+// CHECK: !DIFile(filename: \"/the/aux-src/remap_path_prefix_aux.rs\", directory: \"\")"}, {"sha": "3e2829adeb52e6e9a874a0bc011dacf7a8a46de0", "filename": "src/test/compile-fail-fulldeps/qquote.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -16,12 +16,13 @@ extern crate syntax;\n extern crate syntax_pos;\n \n use syntax::ast;\n+use syntax::codemap::FilePathMapping;\n use syntax::print::pprust;\n use syntax::symbol::Symbol;\n use syntax_pos::DUMMY_SP;\n \n fn main() {\n-    let ps = syntax::parse::ParseSess::new();\n+    let ps = syntax::parse::ParseSess::new(FilePathMapping::empty());\n     let mut resolver = syntax::ext::base::DummyResolver;\n     let mut cx = syntax::ext::base::ExtCtxt::new(\n         &ps,"}, {"sha": "8497a699e974c3b130b12879b482ee9fdeb95dcd", "filename": "src/test/compile-fail/trait-object-macro-matcher.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Ftest%2Fcompile-fail%2Ftrait-object-macro-matcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Ftest%2Fcompile-fail%2Ftrait-object-macro-matcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-object-macro-matcher.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -16,4 +16,6 @@ macro_rules! m {\n \n fn main() {\n     m!(Copy + Send + 'static); //~ ERROR the trait `std::marker::Copy` cannot be made into an object\n+    m!('static + Send);\n+    m!('static +); //~ ERROR at least one non-builtin trait is required for an object type\n }"}, {"sha": "9801cac4714434a168b2614bfadd221fe730c27c", "filename": "src/test/compile-fail/trait-object-vs-lifetime-2.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Ftest%2Fcompile-fail%2Ftrait-object-vs-lifetime-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Ftest%2Fcompile-fail%2Ftrait-object-vs-lifetime-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-object-vs-lifetime-2.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// A few contrived examples where lifetime should (or should not) be parsed as an object type.\n+// Lifetimes parsed as types are still rejected later by semantic checks.\n+\n+// compile-flags: -Z continue-parse-after-error\n+\n+// `'static` is a lifetime, `'static +` is a type, `'a` is a type\n+fn g() where\n+    'static: 'static,\n+    'static +: 'static + Copy,\n+    //~^ ERROR at least one non-builtin trait is required for an object type\n+{}\n+\n+fn main() {}"}, {"sha": "a70141edc29f277922c4ada64c3306eea8f32a42", "filename": "src/test/compile-fail/trait-object-vs-lifetime.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Ftest%2Fcompile-fail%2Ftrait-object-vs-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Ftest%2Fcompile-fail%2Ftrait-object-vs-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-object-vs-lifetime.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// A few contrived examples where lifetime should (or should not) be parsed as an object type.\n+// Lifetimes parsed as types are still rejected later by semantic checks.\n+\n+// compile-flags: -Z continue-parse-after-error\n+\n+struct S<'a, T>(&'a u8, T);\n+\n+fn main() {\n+    // `'static` is a lifetime argument, `'static +` is a type argument\n+    let _: S<'static, u8>;\n+    let _: S<'static, 'static +>;\n+    //~^ at least one non-builtin trait is required for an object type\n+    let _: S<'static, 'static>;\n+    //~^ ERROR wrong number of lifetime parameters: expected 1, found 2\n+    //~| ERROR wrong number of type arguments: expected 1, found 0\n+    let _: S<'static +, 'static>;\n+    //~^ ERROR lifetime parameters must be declared prior to type parameters\n+    //~| ERROR at least one non-builtin trait is required for an object type\n+}"}, {"sha": "27b9e27be43853c01a339e6bc817732966df3627", "filename": "src/test/run-fail-fulldeps/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -24,7 +24,7 @@ use syntax::symbol::Symbol;\n use syntax_pos::DUMMY_SP;\n \n fn main() {\n-    let ps = syntax::parse::ParseSess::new();\n+    let ps = syntax::parse::ParseSess::new(codemap::FilePathMapping::empty());\n     let mut resolver = syntax::ext::base::DummyResolver;\n     let mut cx = syntax::ext::base::ExtCtxt::new(\n         &ps,"}, {"sha": "fc031f4a310c2585718a269caad5c17c9c1a6755", "filename": "src/test/run-pass-fulldeps/ast_stmt_expr_attr.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -17,6 +17,7 @@ extern crate syntax;\n use syntax::ast::*;\n use syntax::attr::*;\n use syntax::ast;\n+use syntax::codemap::FilePathMapping;\n use syntax::parse;\n use syntax::parse::{ParseSess, PResult};\n use syntax::parse::new_parser_from_source_str;\n@@ -78,7 +79,7 @@ fn str_compare<T, F: Fn(&T) -> String>(e: &str, expected: &[T], actual: &[T], f:\n }\n \n fn check_expr_attrs(es: &str, expected: &[&str]) {\n-    let ps = ParseSess::new();\n+    let ps = ParseSess::new(FilePathMapping::empty());\n     let e = expr(es, &ps).expect(\"parse error\");\n     let actual = &e.attrs;\n     str_compare(es,\n@@ -88,7 +89,7 @@ fn check_expr_attrs(es: &str, expected: &[&str]) {\n }\n \n fn check_stmt_attrs(es: &str, expected: &[&str]) {\n-    let ps = ParseSess::new();\n+    let ps = ParseSess::new(FilePathMapping::empty());\n     let e = stmt(es, &ps).expect(\"parse error\");\n     let actual = e.node.attrs();\n     str_compare(es,\n@@ -98,15 +99,15 @@ fn check_stmt_attrs(es: &str, expected: &[&str]) {\n }\n \n fn reject_expr_parse(es: &str) {\n-    let ps = ParseSess::new();\n+    let ps = ParseSess::new(FilePathMapping::empty());\n     match expr(es, &ps) {\n         Ok(_) => panic!(\"parser did not reject `{}`\", es),\n         Err(mut e) => e.cancel(),\n     };\n }\n \n fn reject_stmt_parse(es: &str) {\n-    let ps = ParseSess::new();\n+    let ps = ParseSess::new(FilePathMapping::empty());\n     match stmt(es, &ps) {\n         Ok(_) => panic!(\"parser did not reject `{}`\", es),\n         Err(mut e) => e.cancel(),"}, {"sha": "949aa8a9518c0f803fdba39bf70bffb7770d693c", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -15,12 +15,13 @@\n extern crate syntax;\n extern crate syntax_pos;\n \n+use syntax::codemap::FilePathMapping;\n use syntax::print::pprust::*;\n use syntax::symbol::Symbol;\n use syntax_pos::DUMMY_SP;\n \n fn main() {\n-    let ps = syntax::parse::ParseSess::new();\n+    let ps = syntax::parse::ParseSess::new(FilePathMapping::empty());\n     let mut resolver = syntax::ext::base::DummyResolver;\n     let mut cx = syntax::ext::base::ExtCtxt::new(\n         &ps,"}, {"sha": "f269fe90d4b4e0b98b5261ae286dfc69b77e2381", "filename": "src/test/run-pass/trait-object-lifetime-first.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Ftest%2Frun-pass%2Ftrait-object-lifetime-first.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Ftest%2Frun-pass%2Ftrait-object-lifetime-first.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-object-lifetime-first.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt::Display;\n+\n+static BYTE: u8 = 33;\n+\n+fn main() {\n+    let x: &('static + Display) = &BYTE;\n+    let y: Box<'static + Display> = Box::new(BYTE);\n+    let xstr = format!(\"{}\", x);\n+    let ystr = format!(\"{}\", y);\n+    assert_eq!(xstr, \"33\");\n+    assert_eq!(ystr, \"33\");\n+}"}, {"sha": "8ad6ca0abb027a6c00414a956b640c20d6513e3c", "filename": "src/test/run-pass/vector-sort-panic-safe.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -13,9 +13,11 @@\n #![feature(rand)]\n #![feature(const_fn)]\n \n-use std::sync::atomic::{AtomicUsize, Ordering};\n use std::__rand::{thread_rng, Rng};\n+use std::panic;\n+use std::sync::atomic::{AtomicUsize, Ordering};\n use std::thread;\n+use std::cell::Cell;\n \n const MAX_LEN: usize = 80;\n \n@@ -76,6 +78,7 @@ fn test(input: &[DropCounter]) {\n             let mut panic_countdown = panic_countdown;\n             v.sort_by(|a, b| {\n                 if panic_countdown == 0 {\n+                    SILENCE_PANIC.with(|s| s.set(true));\n                     panic!();\n                 }\n                 panic_countdown -= 1;\n@@ -94,7 +97,15 @@ fn test(input: &[DropCounter]) {\n     }\n }\n \n+thread_local!(static SILENCE_PANIC: Cell<bool> = Cell::new(false));\n+\n fn main() {\n+    let prev = panic::take_hook();\n+    panic::set_hook(Box::new(move |info| {\n+        if !SILENCE_PANIC.with(|s| s.get()) {\n+            prev(info);\n+        }\n+    }));\n     for len in (1..20).chain(70..MAX_LEN) {\n         // Test on a random array.\n         let mut rng = thread_rng();"}, {"sha": "df41e786be58fc120b37709717e79e2eedc543df", "filename": "src/tools/compiletest/src/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -185,8 +185,8 @@ pub struct Config {\n     // Print one character per test instead of one line\n     pub quiet: bool,\n \n-    // where to find the qemu test client process, if we're using it\n-    pub qemu_test_client: Option<PathBuf>,\n+    // where to find the remote test client process, if we're using it\n+    pub remote_test_client: Option<PathBuf>,\n \n     // Configuration for various run-make tests frobbing things like C compilers\n     // or querying about various LLVM component information."}, {"sha": "0f653dfbcf07c9293b1302b44ecbc5433d5e5743", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 152, "deletions": 119, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -40,23 +40,24 @@ impl EarlyProps {\n                     None,\n                     &mut |ln| {\n             props.ignore =\n-                props.ignore || parse_name_directive(ln, \"ignore-test\") ||\n-                parse_name_directive(ln, &ignore_target(config)) ||\n-                parse_name_directive(ln, &ignore_architecture(config)) ||\n-                parse_name_directive(ln, &ignore_stage(config)) ||\n-                parse_name_directive(ln, &ignore_env(config)) ||\n-                (config.mode == common::Pretty && parse_name_directive(ln, \"ignore-pretty\")) ||\n+                props.ignore || config.parse_name_directive(ln, \"ignore-test\") ||\n+                config.parse_name_directive(ln, &ignore_target(config)) ||\n+                config.parse_name_directive(ln, &ignore_architecture(config)) ||\n+                config.parse_name_directive(ln, &ignore_stage(config)) ||\n+                config.parse_name_directive(ln, &ignore_env(config)) ||\n+                (config.mode == common::Pretty &&\n+                 config.parse_name_directive(ln, \"ignore-pretty\")) ||\n                 (config.target != config.host &&\n-                 parse_name_directive(ln, \"ignore-cross-compile\")) ||\n+                 config.parse_name_directive(ln, \"ignore-cross-compile\")) ||\n                 ignore_gdb(config, ln) ||\n                 ignore_lldb(config, ln) ||\n                 ignore_llvm(config, ln);\n \n-            if let Some(s) = parse_aux_build(ln) {\n+            if let Some(s) = config.parse_aux_build(ln) {\n                 props.aux.push(s);\n             }\n \n-            props.should_fail = props.should_fail || parse_name_directive(ln, \"should-fail\");\n+            props.should_fail = props.should_fail || config.parse_name_directive(ln, \"should-fail\");\n         });\n \n         return props;\n@@ -80,7 +81,7 @@ impl EarlyProps {\n             }\n \n             if !line.contains(\"ignore-gdb-version\") &&\n-               parse_name_directive(line, \"ignore-gdb\") {\n+               config.parse_name_directive(line, \"ignore-gdb\") {\n                 return true;\n             }\n \n@@ -143,7 +144,7 @@ impl EarlyProps {\n                 return false;\n             }\n \n-            if parse_name_directive(line, \"ignore-lldb\") {\n+            if config.parse_name_directive(line, \"ignore-lldb\") {\n                 return true;\n             }\n \n@@ -260,105 +261,112 @@ impl TestProps {\n         }\n     }\n \n-    pub fn from_aux_file(&self, testfile: &Path, cfg: Option<&str>) -> Self {\n+    pub fn from_aux_file(&self,\n+                         testfile: &Path,\n+                         cfg: Option<&str>,\n+                         config: &Config)\n+                         -> Self {\n         let mut props = TestProps::new();\n \n         // copy over select properties to the aux build:\n         props.incremental_dir = self.incremental_dir.clone();\n-        props.load_from(testfile, cfg);\n+        props.load_from(testfile, cfg, config);\n \n         props\n     }\n \n-    pub fn from_file(testfile: &Path) -> Self {\n+    pub fn from_file(testfile: &Path, config: &Config) -> Self {\n         let mut props = TestProps::new();\n-        props.load_from(testfile, None);\n+        props.load_from(testfile, None, config);\n         props\n     }\n \n     /// Load properties from `testfile` into `props`. If a property is\n     /// tied to a particular revision `foo` (indicated by writing\n     /// `//[foo]`), then the property is ignored unless `cfg` is\n     /// `Some(\"foo\")`.\n-    pub fn load_from(&mut self, testfile: &Path, cfg: Option<&str>) {\n+    pub fn load_from(&mut self,\n+                     testfile: &Path,\n+                     cfg: Option<&str>,\n+                     config: &Config) {\n         iter_header(testfile,\n                     cfg,\n                     &mut |ln| {\n-            if let Some(ep) = parse_error_pattern(ln) {\n+            if let Some(ep) = config.parse_error_pattern(ln) {\n                 self.error_patterns.push(ep);\n             }\n \n-            if let Some(flags) = parse_compile_flags(ln) {\n+            if let Some(flags) = config.parse_compile_flags(ln) {\n                 self.compile_flags.extend(flags.split_whitespace()\n                     .map(|s| s.to_owned()));\n             }\n \n-            if let Some(r) = parse_revisions(ln) {\n+            if let Some(r) = config.parse_revisions(ln) {\n                 self.revisions.extend(r);\n             }\n \n             if self.run_flags.is_none() {\n-                self.run_flags = parse_run_flags(ln);\n+                self.run_flags = config.parse_run_flags(ln);\n             }\n \n             if self.pp_exact.is_none() {\n-                self.pp_exact = parse_pp_exact(ln, testfile);\n+                self.pp_exact = config.parse_pp_exact(ln, testfile);\n             }\n \n             if !self.build_aux_docs {\n-                self.build_aux_docs = parse_build_aux_docs(ln);\n+                self.build_aux_docs = config.parse_build_aux_docs(ln);\n             }\n \n             if !self.force_host {\n-                self.force_host = parse_force_host(ln);\n+                self.force_host = config.parse_force_host(ln);\n             }\n \n             if !self.check_stdout {\n-                self.check_stdout = parse_check_stdout(ln);\n+                self.check_stdout = config.parse_check_stdout(ln);\n             }\n \n             if !self.no_prefer_dynamic {\n-                self.no_prefer_dynamic = parse_no_prefer_dynamic(ln);\n+                self.no_prefer_dynamic = config.parse_no_prefer_dynamic(ln);\n             }\n \n             if !self.pretty_expanded {\n-                self.pretty_expanded = parse_pretty_expanded(ln);\n+                self.pretty_expanded = config.parse_pretty_expanded(ln);\n             }\n \n-            if let Some(m) = parse_pretty_mode(ln) {\n+            if let Some(m) = config.parse_pretty_mode(ln) {\n                 self.pretty_mode = m;\n             }\n \n             if !self.pretty_compare_only {\n-                self.pretty_compare_only = parse_pretty_compare_only(ln);\n+                self.pretty_compare_only = config.parse_pretty_compare_only(ln);\n             }\n \n-            if let Some(ab) = parse_aux_build(ln) {\n+            if let Some(ab) = config.parse_aux_build(ln) {\n                 self.aux_builds.push(ab);\n             }\n \n-            if let Some(ee) = parse_env(ln, \"exec-env\") {\n+            if let Some(ee) = config.parse_env(ln, \"exec-env\") {\n                 self.exec_env.push(ee);\n             }\n \n-            if let Some(ee) = parse_env(ln, \"rustc-env\") {\n+            if let Some(ee) = config.parse_env(ln, \"rustc-env\") {\n                 self.rustc_env.push(ee);\n             }\n \n-            if let Some(cl) = parse_check_line(ln) {\n+            if let Some(cl) = config.parse_check_line(ln) {\n                 self.check_lines.push(cl);\n             }\n \n-            if let Some(of) = parse_forbid_output(ln) {\n+            if let Some(of) = config.parse_forbid_output(ln) {\n                 self.forbid_output.push(of);\n             }\n \n             if !self.must_compile_successfully {\n-                self.must_compile_successfully = parse_must_compile_successfully(ln);\n+                self.must_compile_successfully = config.parse_must_compile_successfully(ln);\n             }\n \n             if !self.check_test_line_numbers_match {\n-                self.check_test_line_numbers_match = parse_check_test_line_numbers_match(ln);\n+                self.check_test_line_numbers_match = config.parse_check_test_line_numbers_match(ln);\n             }\n         });\n \n@@ -410,114 +418,118 @@ fn iter_header(testfile: &Path, cfg: Option<&str>, it: &mut FnMut(&str)) {\n     return;\n }\n \n-fn parse_error_pattern(line: &str) -> Option<String> {\n-    parse_name_value_directive(line, \"error-pattern\")\n-}\n+impl Config {\n \n-fn parse_forbid_output(line: &str) -> Option<String> {\n-    parse_name_value_directive(line, \"forbid-output\")\n-}\n+    fn parse_error_pattern(&self, line: &str) -> Option<String> {\n+        self.parse_name_value_directive(line, \"error-pattern\")\n+    }\n \n-fn parse_aux_build(line: &str) -> Option<String> {\n-    parse_name_value_directive(line, \"aux-build\")\n-}\n+    fn parse_forbid_output(&self, line: &str) -> Option<String> {\n+        self.parse_name_value_directive(line, \"forbid-output\")\n+    }\n \n-fn parse_compile_flags(line: &str) -> Option<String> {\n-    parse_name_value_directive(line, \"compile-flags\")\n-}\n+    fn parse_aux_build(&self, line: &str) -> Option<String> {\n+        self.parse_name_value_directive(line, \"aux-build\")\n+    }\n \n-fn parse_revisions(line: &str) -> Option<Vec<String>> {\n-    parse_name_value_directive(line, \"revisions\")\n-        .map(|r| r.split_whitespace().map(|t| t.to_string()).collect())\n-}\n+    fn parse_compile_flags(&self, line: &str) -> Option<String> {\n+        self.parse_name_value_directive(line, \"compile-flags\")\n+    }\n \n-fn parse_run_flags(line: &str) -> Option<String> {\n-    parse_name_value_directive(line, \"run-flags\")\n-}\n+    fn parse_revisions(&self, line: &str) -> Option<Vec<String>> {\n+        self.parse_name_value_directive(line, \"revisions\")\n+            .map(|r| r.split_whitespace().map(|t| t.to_string()).collect())\n+    }\n \n-fn parse_check_line(line: &str) -> Option<String> {\n-    parse_name_value_directive(line, \"check\")\n-}\n+    fn parse_run_flags(&self, line: &str) -> Option<String> {\n+        self.parse_name_value_directive(line, \"run-flags\")\n+    }\n \n-fn parse_force_host(line: &str) -> bool {\n-    parse_name_directive(line, \"force-host\")\n-}\n+    fn parse_check_line(&self, line: &str) -> Option<String> {\n+        self.parse_name_value_directive(line, \"check\")\n+    }\n \n-fn parse_build_aux_docs(line: &str) -> bool {\n-    parse_name_directive(line, \"build-aux-docs\")\n-}\n+    fn parse_force_host(&self, line: &str) -> bool {\n+        self.parse_name_directive(line, \"force-host\")\n+    }\n \n-fn parse_check_stdout(line: &str) -> bool {\n-    parse_name_directive(line, \"check-stdout\")\n-}\n+    fn parse_build_aux_docs(&self, line: &str) -> bool {\n+        self.parse_name_directive(line, \"build-aux-docs\")\n+    }\n \n-fn parse_no_prefer_dynamic(line: &str) -> bool {\n-    parse_name_directive(line, \"no-prefer-dynamic\")\n-}\n+    fn parse_check_stdout(&self, line: &str) -> bool {\n+        self.parse_name_directive(line, \"check-stdout\")\n+    }\n \n-fn parse_pretty_expanded(line: &str) -> bool {\n-    parse_name_directive(line, \"pretty-expanded\")\n-}\n+    fn parse_no_prefer_dynamic(&self, line: &str) -> bool {\n+        self.parse_name_directive(line, \"no-prefer-dynamic\")\n+    }\n \n-fn parse_pretty_mode(line: &str) -> Option<String> {\n-    parse_name_value_directive(line, \"pretty-mode\")\n-}\n+    fn parse_pretty_expanded(&self, line: &str) -> bool {\n+        self.parse_name_directive(line, \"pretty-expanded\")\n+    }\n \n-fn parse_pretty_compare_only(line: &str) -> bool {\n-    parse_name_directive(line, \"pretty-compare-only\")\n-}\n+    fn parse_pretty_mode(&self, line: &str) -> Option<String> {\n+        self.parse_name_value_directive(line, \"pretty-mode\")\n+    }\n \n-fn parse_must_compile_successfully(line: &str) -> bool {\n-    parse_name_directive(line, \"must-compile-successfully\")\n-}\n+    fn parse_pretty_compare_only(&self, line: &str) -> bool {\n+        self.parse_name_directive(line, \"pretty-compare-only\")\n+    }\n \n-fn parse_check_test_line_numbers_match(line: &str) -> bool {\n-    parse_name_directive(line, \"check-test-line-numbers-match\")\n-}\n+    fn parse_must_compile_successfully(&self, line: &str) -> bool {\n+        self.parse_name_directive(line, \"must-compile-successfully\")\n+    }\n \n-fn parse_env(line: &str, name: &str) -> Option<(String, String)> {\n-    parse_name_value_directive(line, name).map(|nv| {\n-        // nv is either FOO or FOO=BAR\n-        let mut strs: Vec<String> = nv.splitn(2, '=')\n-            .map(str::to_owned)\n-            .collect();\n+    fn parse_check_test_line_numbers_match(&self, line: &str) -> bool {\n+        self.parse_name_directive(line, \"check-test-line-numbers-match\")\n+    }\n \n-        match strs.len() {\n-            1 => (strs.pop().unwrap(), \"\".to_owned()),\n-            2 => {\n-                let end = strs.pop().unwrap();\n-                (strs.pop().unwrap(), end)\n+    fn parse_env(&self, line: &str, name: &str) -> Option<(String, String)> {\n+        self.parse_name_value_directive(line, name).map(|nv| {\n+            // nv is either FOO or FOO=BAR\n+            let mut strs: Vec<String> = nv.splitn(2, '=')\n+                .map(str::to_owned)\n+                .collect();\n+\n+            match strs.len() {\n+                1 => (strs.pop().unwrap(), \"\".to_owned()),\n+                2 => {\n+                    let end = strs.pop().unwrap();\n+                    (strs.pop().unwrap(), end)\n+                }\n+                n => panic!(\"Expected 1 or 2 strings, not {}\", n),\n             }\n-            n => panic!(\"Expected 1 or 2 strings, not {}\", n),\n-        }\n-    })\n-}\n+        })\n+    }\n \n-fn parse_pp_exact(line: &str, testfile: &Path) -> Option<PathBuf> {\n-    if let Some(s) = parse_name_value_directive(line, \"pp-exact\") {\n-        Some(PathBuf::from(&s))\n-    } else {\n-        if parse_name_directive(line, \"pp-exact\") {\n-            testfile.file_name().map(PathBuf::from)\n+    fn parse_pp_exact(&self, line: &str, testfile: &Path) -> Option<PathBuf> {\n+        if let Some(s) = self.parse_name_value_directive(line, \"pp-exact\") {\n+            Some(PathBuf::from(&s))\n         } else {\n-            None\n+            if self.parse_name_directive(line, \"pp-exact\") {\n+                testfile.file_name().map(PathBuf::from)\n+            } else {\n+                None\n+            }\n         }\n     }\n-}\n \n-fn parse_name_directive(line: &str, directive: &str) -> bool {\n-    // This 'no-' rule is a quick hack to allow pretty-expanded and no-pretty-expanded to coexist\n-    line.contains(directive) && !line.contains(&(\"no-\".to_owned() + directive))\n-}\n+    fn parse_name_directive(&self, line: &str, directive: &str) -> bool {\n+        // This 'no-' rule is a quick hack to allow pretty-expanded and\n+        // no-pretty-expanded to coexist\n+        line.contains(directive) && !line.contains(&(\"no-\".to_owned() + directive))\n+    }\n \n-pub fn parse_name_value_directive(line: &str, directive: &str) -> Option<String> {\n-    let keycolon = format!(\"{}:\", directive);\n-    if let Some(colon) = line.find(&keycolon) {\n-        let value = line[(colon + keycolon.len())..line.len()].to_owned();\n-        debug!(\"{}: {}\", directive, value);\n-        Some(value)\n-    } else {\n-        None\n+    pub fn parse_name_value_directive(&self, line: &str, directive: &str) -> Option<String> {\n+        let keycolon = format!(\"{}:\", directive);\n+        if let Some(colon) = line.find(&keycolon) {\n+            let value = line[(colon + keycolon.len())..line.len()].to_owned();\n+            debug!(\"{}: {}\", directive, value);\n+            Some(expand_variables(value, self))\n+        } else {\n+            None\n+        }\n     }\n }\n \n@@ -528,3 +540,24 @@ pub fn lldb_version_to_int(version_string: &str) -> isize {\n     let major: isize = version_string.parse().ok().expect(&error_string);\n     return major;\n }\n+\n+fn expand_variables(mut value: String, config: &Config) -> String {\n+    const CWD: &'static str = \"{{cwd}}\";\n+    const SRC_BASE: &'static str = \"{{src-base}}\";\n+    const BUILD_BASE: &'static str = \"{{build-base}}\";\n+\n+    if value.contains(CWD) {\n+        let cwd = env::current_dir().unwrap();\n+        value = value.replace(CWD, &cwd.to_string_lossy());\n+    }\n+\n+    if value.contains(SRC_BASE) {\n+        value = value.replace(SRC_BASE, &config.src_base.to_string_lossy());\n+    }\n+\n+    if value.contains(BUILD_BASE) {\n+        value = value.replace(BUILD_BASE, &config.build_base.to_string_lossy());\n+    }\n+\n+    value\n+}"}, {"sha": "0e4901ef1aba661b74a5971774f9218b9951a640", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 13, "deletions": 27, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -106,7 +106,7 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n           reqopt(\"\", \"llvm-components\", \"list of LLVM components built in\", \"LIST\"),\n           reqopt(\"\", \"llvm-cxxflags\", \"C++ flags for LLVM\", \"FLAGS\"),\n           optopt(\"\", \"nodejs\", \"the name of nodejs\", \"PATH\"),\n-          optopt(\"\", \"qemu-test-client\", \"path to the qemu test client\", \"PATH\"),\n+          optopt(\"\", \"remote-test-client\", \"path to the remote test client\", \"PATH\"),\n           optflag(\"h\", \"help\", \"show this message\")];\n \n     let (argv0, args_) = args.split_first().unwrap();\n@@ -177,17 +177,15 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n         llvm_version: matches.opt_str(\"llvm-version\"),\n         android_cross_path: opt_path(matches, \"android-cross-path\"),\n         adb_path: opt_str2(matches.opt_str(\"adb-path\")),\n-        adb_test_dir: format!(\"{}/{}\",\n-            opt_str2(matches.opt_str(\"adb-test-dir\")),\n-            opt_str2(matches.opt_str(\"target\"))),\n+        adb_test_dir: opt_str2(matches.opt_str(\"adb-test-dir\")),\n         adb_device_status:\n             opt_str2(matches.opt_str(\"target\")).contains(\"android\") &&\n             \"(none)\" != opt_str2(matches.opt_str(\"adb-test-dir\")) &&\n             !opt_str2(matches.opt_str(\"adb-test-dir\")).is_empty(),\n         lldb_python_dir: matches.opt_str(\"lldb-python-dir\"),\n         verbose: matches.opt_present(\"verbose\"),\n         quiet: matches.opt_present(\"quiet\"),\n-        qemu_test_client: matches.opt_str(\"qemu-test-client\").map(PathBuf::from),\n+        remote_test_client: matches.opt_str(\"remote-test-client\").map(PathBuf::from),\n \n         cc: matches.opt_str(\"cc\").unwrap(),\n         cxx: matches.opt_str(\"cxx\").unwrap(),\n@@ -252,27 +250,14 @@ pub fn run_tests(config: &Config) {\n         if let DebugInfoGdb = config.mode {\n             println!(\"{} debug-info test uses tcp 5039 port.\\\n                      please reserve it\", config.target);\n-        }\n-\n-        // android debug-info test uses remote debugger\n-        // so, we test 1 thread at once.\n-        // also trying to isolate problems with adb_run_wrapper.sh ilooping\n-        match config.mode {\n-            // These tests don't actually run code or don't run for android, so\n-            // we don't need to limit ourselves there\n-            Mode::Ui |\n-            Mode::CompileFail |\n-            Mode::ParseFail |\n-            Mode::RunMake |\n-            Mode::Codegen |\n-            Mode::CodegenUnits |\n-            Mode::Pretty |\n-            Mode::Rustdoc => {}\n-\n-            _ => {\n-                env::set_var(\"RUST_TEST_THREADS\", \"1\");\n-            }\n \n+            // android debug-info test uses remote debugger so, we test 1 thread\n+            // at once as they're all sharing the same TCP port to communicate\n+            // over.\n+            //\n+            // we should figure out how to lift this restriction! (run them all\n+            // on different ports allocated dynamically).\n+            env::set_var(\"RUST_TEST_THREADS\", \"1\");\n         }\n     }\n \n@@ -296,9 +281,10 @@ pub fn run_tests(config: &Config) {\n         }\n \n         DebugInfoGdb => {\n-            if config.qemu_test_client.is_some() {\n+            if config.remote_test_client.is_some() &&\n+               !config.target.contains(\"android\"){\n                 println!(\"WARNING: debuginfo tests are not available when \\\n-                          testing with QEMU\");\n+                          testing with remote\");\n                 return\n             }\n         }"}, {"sha": "d38b1d61ddd94d6126c698e3b3e235d7d3c78a87", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 22, "deletions": 210, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -16,15 +16,13 @@ use errors::{self, ErrorKind, Error};\n use filetime::FileTime;\n use json;\n use header::TestProps;\n-use header;\n use procsrv;\n use test::TestPaths;\n use uidiff;\n use util::logv;\n \n use std::collections::HashSet;\n use std::env;\n-use std::fmt;\n use std::fs::{self, File, create_dir_all};\n use std::io::prelude::*;\n use std::io::{self, BufReader};\n@@ -57,7 +55,7 @@ pub fn run(config: Config, testpaths: &TestPaths) {\n         print!(\"\\n\\n\");\n     }\n     debug!(\"running {:?}\", testpaths.file.display());\n-    let base_props = TestProps::from_file(&testpaths.file);\n+    let base_props = TestProps::from_file(&testpaths.file, &config);\n \n     let base_cx = TestCx { config: &config,\n                            props: &base_props,\n@@ -70,7 +68,7 @@ pub fn run(config: Config, testpaths: &TestPaths) {\n     } else {\n         for revision in &base_props.revisions {\n             let mut revision_props = base_props.clone();\n-            revision_props.load_from(&testpaths.file, Some(&revision));\n+            revision_props.load_from(&testpaths.file, Some(&revision), &config);\n             let rev_cx = TestCx {\n                 config: &config,\n                 props: &revision_props,\n@@ -469,7 +467,9 @@ actual:\\n\\\n \n         let debugger_run_result;\n         match &*self.config.target {\n-            \"arm-linux-androideabi\" | \"armv7-linux-androideabi\" | \"aarch64-linux-android\" => {\n+            \"arm-linux-androideabi\" |\n+            \"armv7-linux-androideabi\" |\n+            \"aarch64-linux-android\" => {\n \n                 cmds = cmds.replace(\"run\", \"continue\");\n \n@@ -534,6 +534,7 @@ actual:\\n\\\n                                       exe_file.file_name().unwrap().to_str()\n                                       .unwrap());\n \n+                debug!(\"adb arg: {}\", adb_arg);\n                 let mut process = procsrv::run_background(\"\",\n                                                           &self.config.adb_path\n                                                           ,\n@@ -590,7 +591,7 @@ actual:\\n\\\n                 };\n \n                 debugger_run_result = ProcRes {\n-                    status: Status::Normal(status),\n+                    status: status,\n                     stdout: out,\n                     stderr: err,\n                     cmdline: cmdline\n@@ -841,7 +842,7 @@ actual:\\n\\\n \n         self.dump_output(&out, &err);\n         ProcRes {\n-            status: Status::Normal(status),\n+            status: status,\n             stdout: out,\n             stderr: err,\n             cmdline: format!(\"{:?}\", cmd)\n@@ -867,13 +868,13 @@ actual:\\n\\\n                     }\n \n                     for &(ref command_directive, ref check_directive) in &directives {\n-                        header::parse_name_value_directive(\n+                        self.config.parse_name_value_directive(\n                             &line,\n                             &command_directive).map(|cmd| {\n                                 commands.push(cmd)\n                             });\n \n-                        header::parse_name_value_directive(\n+                        self.config.parse_name_value_directive(\n                             &line,\n                             &check_directive).map(|cmd| {\n                                 check_lines.push(cmd)\n@@ -1158,7 +1159,9 @@ actual:\\n\\\n         if self.props.build_aux_docs {\n             for rel_ab in &self.props.aux_builds {\n                 let aux_testpaths = self.compute_aux_test_paths(rel_ab);\n-                let aux_props = self.props.from_aux_file(&aux_testpaths.file, self.revision);\n+                let aux_props = self.props.from_aux_file(&aux_testpaths.file,\n+                                                         self.revision,\n+                                                         self.config);\n                 let aux_cx = TestCx {\n                     config: self.config,\n                     props: &aux_props,\n@@ -1190,25 +1193,20 @@ actual:\\n\\\n         let env = self.props.exec_env.clone();\n \n         match &*self.config.target {\n-\n-            \"arm-linux-androideabi\" | \"armv7-linux-androideabi\" | \"aarch64-linux-android\" => {\n-                self._arm_exec_compiled_test(env)\n-            }\n-\n             // This is pretty similar to below, we're transforming:\n             //\n             //      program arg1 arg2\n             //\n             // into\n             //\n-            //      qemu-test-client run program:support-lib.so arg1 arg2\n+            //      remote-test-client run program:support-lib.so arg1 arg2\n             //\n             // The test-client program will upload `program` to the emulator\n             // along with all other support libraries listed (in this case\n             // `support-lib.so`. It will then execute the program on the\n             // emulator with the arguments specified (in the environment we give\n             // the process) and then report back the same result.\n-            _ if self.config.qemu_test_client.is_some() => {\n+            _ if self.config.remote_test_client.is_some() => {\n                 let aux_dir = self.aux_output_dir_name();\n                 let mut args = self.make_run_args();\n                 let mut program = args.prog.clone();\n@@ -1224,7 +1222,7 @@ actual:\\n\\\n                 }\n                 args.args.insert(0, program);\n                 args.args.insert(0, \"run\".to_string());\n-                args.prog = self.config.qemu_test_client.clone().unwrap()\n+                args.prog = self.config.remote_test_client.clone().unwrap()\n                                 .into_os_string().into_string().unwrap();\n                 self.compose_and_run(args,\n                                      env,\n@@ -1279,7 +1277,9 @@ actual:\\n\\\n \n         for rel_ab in &self.props.aux_builds {\n             let aux_testpaths = self.compute_aux_test_paths(rel_ab);\n-            let aux_props = self.props.from_aux_file(&aux_testpaths.file, self.revision);\n+            let aux_props = self.props.from_aux_file(&aux_testpaths.file,\n+                                                     self.revision,\n+                                                     self.config);\n             let mut crate_type = if aux_props.no_prefer_dynamic {\n                 Vec::new()\n             } else {\n@@ -1324,13 +1324,6 @@ actual:\\n\\\n                              aux_testpaths.file.display()),\n                     &auxres);\n             }\n-\n-            match &*self.config.target {\n-                \"arm-linux-androideabi\" | \"armv7-linux-androideabi\" | \"aarch64-linux-android\" => {\n-                    self._arm_push_aux_shared_library();\n-                }\n-                _ => {}\n-            }\n         }\n \n         self.compose_and_run(args,\n@@ -1564,7 +1557,7 @@ actual:\\n\\\n                          input).expect(&format!(\"failed to exec `{}`\", prog));\n         self.dump_output(&out, &err);\n         return ProcRes {\n-            status: Status::Normal(status),\n+            status: status,\n             stdout: out,\n             stderr: err,\n             cmdline: cmdline,\n@@ -1698,157 +1691,6 @@ actual:\\n\\\n         println!(\"---------------------------------------------------\");\n     }\n \n-    fn _arm_exec_compiled_test(&self, env: Vec<(String, String)>) -> ProcRes {\n-        let args = self.make_run_args();\n-        let cmdline = self.make_cmdline(\"\", &args.prog, &args.args);\n-\n-        // get bare program string\n-        let mut tvec: Vec<String> = args.prog\n-                                        .split('/')\n-                                        .map(str::to_owned)\n-                                        .collect();\n-        let prog_short = tvec.pop().unwrap();\n-\n-        // copy to target\n-        let copy_result = procsrv::run(\"\",\n-                                       &self.config.adb_path,\n-                                       None,\n-                                       &[\n-                                           \"push\".to_owned(),\n-                                           args.prog.clone(),\n-                                           self.config.adb_test_dir.clone()\n-                                       ],\n-                                       vec![(\"\".to_owned(), \"\".to_owned())],\n-                                       Some(\"\".to_owned()))\n-            .expect(&format!(\"failed to exec `{}`\", self.config.adb_path));\n-\n-        if self.config.verbose {\n-            println!(\"push ({}) {} {} {}\",\n-                     self.config.target,\n-                     args.prog,\n-                     copy_result.out,\n-                     copy_result.err);\n-        }\n-\n-        logv(self.config, format!(\"executing ({}) {}\", self.config.target, cmdline));\n-\n-        let mut runargs = Vec::new();\n-\n-        // run test via adb_run_wrapper\n-        runargs.push(\"shell\".to_owned());\n-        for (key, val) in env {\n-            runargs.push(format!(\"{}={}\", key, val));\n-        }\n-        runargs.push(format!(\"{}/../adb_run_wrapper.sh\", self.config.adb_test_dir));\n-        runargs.push(format!(\"{}\", self.config.adb_test_dir));\n-        runargs.push(format!(\"{}\", prog_short));\n-\n-        for tv in &args.args {\n-            runargs.push(tv.to_owned());\n-        }\n-        procsrv::run(\"\",\n-                     &self.config.adb_path,\n-                     None,\n-                     &runargs,\n-                     vec![(\"\".to_owned(), \"\".to_owned())], Some(\"\".to_owned()))\n-            .expect(&format!(\"failed to exec `{}`\", self.config.adb_path));\n-\n-        // get exitcode of result\n-        runargs = Vec::new();\n-        runargs.push(\"shell\".to_owned());\n-        runargs.push(\"cat\".to_owned());\n-        runargs.push(format!(\"{}/{}.exitcode\", self.config.adb_test_dir, prog_short));\n-\n-        let procsrv::Result{ out: exitcode_out, err: _, status: _ } =\n-            procsrv::run(\"\",\n-                         &self.config.adb_path,\n-                         None,\n-                         &runargs,\n-                         vec![(\"\".to_owned(), \"\".to_owned())],\n-                         Some(\"\".to_owned()))\n-            .expect(&format!(\"failed to exec `{}`\", self.config.adb_path));\n-\n-        let mut exitcode: i32 = 0;\n-        for c in exitcode_out.chars() {\n-            if !c.is_numeric() { break; }\n-            exitcode = exitcode * 10 + match c {\n-                '0' ... '9' => c as i32 - ('0' as i32),\n-                _ => 101,\n-            }\n-        }\n-\n-        // get stdout of result\n-        runargs = Vec::new();\n-        runargs.push(\"shell\".to_owned());\n-        runargs.push(\"cat\".to_owned());\n-        runargs.push(format!(\"{}/{}.stdout\", self.config.adb_test_dir, prog_short));\n-\n-        let procsrv::Result{ out: stdout_out, err: _, status: _ } =\n-            procsrv::run(\"\",\n-                         &self.config.adb_path,\n-                         None,\n-                         &runargs,\n-                         vec![(\"\".to_owned(), \"\".to_owned())],\n-                         Some(\"\".to_owned()))\n-            .expect(&format!(\"failed to exec `{}`\", self.config.adb_path));\n-\n-        // get stderr of result\n-        runargs = Vec::new();\n-        runargs.push(\"shell\".to_owned());\n-        runargs.push(\"cat\".to_owned());\n-        runargs.push(format!(\"{}/{}.stderr\", self.config.adb_test_dir, prog_short));\n-\n-        let procsrv::Result{ out: stderr_out, err: _, status: _ } =\n-            procsrv::run(\"\",\n-                         &self.config.adb_path,\n-                         None,\n-                         &runargs,\n-                         vec![(\"\".to_owned(), \"\".to_owned())],\n-                         Some(\"\".to_owned()))\n-            .expect(&format!(\"failed to exec `{}`\", self.config.adb_path));\n-\n-        self.dump_output(&stdout_out, &stderr_out);\n-\n-        ProcRes {\n-            status: Status::Parsed(exitcode),\n-            stdout: stdout_out,\n-            stderr: stderr_out,\n-            cmdline: cmdline\n-        }\n-    }\n-\n-    fn _arm_push_aux_shared_library(&self) {\n-        let tdir = self.aux_output_dir_name();\n-\n-        let dirs = fs::read_dir(&tdir).unwrap();\n-        for file in dirs {\n-            let file = file.unwrap().path();\n-            if file.extension().and_then(|s| s.to_str()) == Some(\"so\") {\n-                // FIXME (#9639): This needs to handle non-utf8 paths\n-                let copy_result = procsrv::run(\"\",\n-                                               &self.config.adb_path,\n-                                               None,\n-                                               &[\n-                                                   \"push\".to_owned(),\n-                                                   file.to_str()\n-                                                       .unwrap()\n-                                                       .to_owned(),\n-                                                   self.config.adb_test_dir.to_owned(),\n-                                               ],\n-                                               vec![(\"\".to_owned(),\n-                                                     \"\".to_owned())],\n-                                               Some(\"\".to_owned()))\n-                    .expect(&format!(\"failed to exec `{}`\", self.config.adb_path));\n-\n-                if self.config.verbose {\n-                    println!(\"push ({}) {:?} {} {}\",\n-                             self.config.target, file.display(),\n-                             copy_result.out, copy_result.err);\n-                }\n-            }\n-        }\n-    }\n-\n     // codegen tests (using FileCheck)\n \n     fn compile_test_and_save_ir(&self) -> ProcRes {\n@@ -2347,7 +2189,7 @@ actual:\\n\\\n         let output = cmd.output().expect(\"failed to spawn `make`\");\n         if !output.status.success() {\n             let res = ProcRes {\n-                status: Status::Normal(output.status),\n+                status: output.status,\n                 stdout: String::from_utf8_lossy(&output.stdout).into_owned(),\n                 stderr: String::from_utf8_lossy(&output.stderr).into_owned(),\n                 cmdline: format!(\"{:?}\", cmd),\n@@ -2594,17 +2436,12 @@ struct ProcArgs {\n }\n \n pub struct ProcRes {\n-    status: Status,\n+    status: ExitStatus,\n     stdout: String,\n     stderr: String,\n     cmdline: String,\n }\n \n-enum Status {\n-    Parsed(i32),\n-    Normal(ExitStatus),\n-}\n-\n impl ProcRes {\n     pub fn fatal(&self, err: Option<&str>) -> ! {\n         if let Some(e) = err {\n@@ -2628,31 +2465,6 @@ impl ProcRes {\n     }\n }\n \n-impl Status {\n-    fn code(&self) -> Option<i32> {\n-        match *self {\n-            Status::Parsed(i) => Some(i),\n-            Status::Normal(ref e) => e.code(),\n-        }\n-    }\n-\n-    fn success(&self) -> bool {\n-        match *self {\n-            Status::Parsed(i) => i == 0,\n-            Status::Normal(ref e) => e.success(),\n-        }\n-    }\n-}\n-\n-impl fmt::Display for Status {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            Status::Parsed(i) => write!(f, \"exit code: {}\", i),\n-            Status::Normal(ref e) => e.fmt(f),\n-        }\n-    }\n-}\n-\n enum TargetLocation {\n     ThisFile(PathBuf),\n     ThisDirectory(PathBuf),"}, {"sha": "54739101f1eff6bced78a9096e4b5b32a72358d0", "filename": "src/tools/remote-test-client/Cargo.toml", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Ftools%2Fremote-test-client%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Ftools%2Fremote-test-client%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fremote-test-client%2FCargo.toml?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -1,5 +1,5 @@\n [package]\n-name = \"qemu-test-client\"\n+name = \"remote-test-client\"\n version = \"0.1.0\"\n authors = [\"The Rust Project Developers\"]\n ", "previous_filename": "src/tools/qemu-test-client/Cargo.toml"}, {"sha": "265354ff800543440fea28419ba58b77eb986887", "filename": "src/tools/remote-test-client/src/main.rs", "status": "renamed", "additions": 93, "deletions": 33, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Ftools%2Fremote-test-client%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Ftools%2Fremote-test-client%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fremote-test-client%2Fsrc%2Fmain.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -8,19 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/// This is a small client program intended to pair with `qemu-test-server` in\n+/// This is a small client program intended to pair with `remote-test-server` in\n /// this repository. This client connects to the server over TCP and is used to\n /// push artifacts and run tests on the server instead of locally.\n ///\n /// Here is also where we bake in the support to spawn the QEMU emulator as\n /// well.\n \n use std::env;\n-use std::fs::File;\n+use std::fs::{self, File};\n use std::io::prelude::*;\n use std::io::{self, BufWriter};\n use std::net::TcpStream;\n-use std::path::Path;\n+use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio};\n use std::thread;\n use std::time::Duration;\n@@ -37,8 +37,10 @@ fn main() {\n \n     match &args.next().unwrap()[..] {\n         \"spawn-emulator\" => {\n-            spawn_emulator(Path::new(&args.next().unwrap()),\n-                           Path::new(&args.next().unwrap()))\n+            spawn_emulator(&args.next().unwrap(),\n+                           Path::new(&args.next().unwrap()),\n+                           Path::new(&args.next().unwrap()),\n+                           args.next().map(|s| s.into()))\n         }\n         \"push\" => {\n             push(Path::new(&args.next().unwrap()))\n@@ -50,11 +52,74 @@ fn main() {\n     }\n }\n \n-fn spawn_emulator(rootfs: &Path, tmpdir: &Path) {\n+fn spawn_emulator(target: &str,\n+                  server: &Path,\n+                  tmpdir: &Path,\n+                  rootfs: Option<PathBuf>) {\n+    if target.contains(\"android\") {\n+        start_android_emulator(server);\n+    } else {\n+        let rootfs = rootfs.as_ref().expect(\"need rootfs on non-android\");\n+        start_qemu_emulator(rootfs, server, tmpdir);\n+    }\n+\n+    // Wait for the emulator to come online\n+    loop {\n+        let dur = Duration::from_millis(100);\n+        if let Ok(mut client) = TcpStream::connect(\"127.0.0.1:12345\") {\n+            t!(client.set_read_timeout(Some(dur)));\n+            t!(client.set_write_timeout(Some(dur)));\n+            if client.write_all(b\"ping\").is_ok() {\n+                let mut b = [0; 4];\n+                if client.read_exact(&mut b).is_ok() {\n+                    break\n+                }\n+            }\n+        }\n+        thread::sleep(dur);\n+    }\n+}\n+\n+fn start_android_emulator(server: &Path) {\n+    println!(\"waiting for device to come online\");\n+    let status = Command::new(\"adb\")\n+                    .arg(\"wait-for-device\")\n+                    .status()\n+                    .unwrap();\n+    assert!(status.success());\n+\n+    println!(\"pushing server\");\n+    let status = Command::new(\"adb\")\n+                    .arg(\"push\")\n+                    .arg(server)\n+                    .arg(\"/data/tmp/testd\")\n+                    .status()\n+                    .unwrap();\n+    assert!(status.success());\n+\n+    println!(\"forwarding tcp\");\n+    let status = Command::new(\"adb\")\n+                    .arg(\"forward\")\n+                    .arg(\"tcp:12345\")\n+                    .arg(\"tcp:12345\")\n+                    .status()\n+                    .unwrap();\n+    assert!(status.success());\n+\n+    println!(\"executing server\");\n+    Command::new(\"adb\")\n+                    .arg(\"shell\")\n+                    .arg(\"/data/tmp/testd\")\n+                    .spawn()\n+                    .unwrap();\n+}\n+\n+fn start_qemu_emulator(rootfs: &Path, server: &Path, tmpdir: &Path) {\n     // Generate a new rootfs image now that we've updated the test server\n     // executable. This is the equivalent of:\n     //\n     //      find $rootfs -print 0 | cpio --null -o --format=newc > rootfs.img\n+    t!(fs::copy(server, rootfs.join(\"testd\")));\n     let rootfs_img = tmpdir.join(\"rootfs.img\");\n     let mut cmd = Command::new(\"cpio\");\n     cmd.arg(\"--null\")\n@@ -83,22 +148,6 @@ fn spawn_emulator(rootfs: &Path, tmpdir: &Path) {\n        .arg(\"-redir\").arg(\"tcp:12345::12345\");\n     t!(cmd.spawn());\n \n-    // Wait for the emulator to come online\n-    loop {\n-        let dur = Duration::from_millis(100);\n-        if let Ok(mut client) = TcpStream::connect(\"127.0.0.1:12345\") {\n-            t!(client.set_read_timeout(Some(dur)));\n-            t!(client.set_write_timeout(Some(dur)));\n-            if client.write_all(b\"ping\").is_ok() {\n-                let mut b = [0; 4];\n-                if client.read_exact(&mut b).is_ok() {\n-                    break\n-                }\n-            }\n-        }\n-        thread::sleep(dur);\n-    }\n-\n     fn add_files(w: &mut Write, root: &Path, cur: &Path) {\n         for entry in t!(cur.read_dir()) {\n             let entry = t!(entry);\n@@ -116,11 +165,15 @@ fn push(path: &Path) {\n     let client = t!(TcpStream::connect(\"127.0.0.1:12345\"));\n     let mut client = BufWriter::new(client);\n     t!(client.write_all(b\"push\"));\n-    t!(client.write_all(path.file_name().unwrap().to_str().unwrap().as_bytes()));\n-    t!(client.write_all(&[0]));\n-    let mut file = t!(File::open(path));\n-    t!(io::copy(&mut file, &mut client));\n+    send(path, &mut client);\n     t!(client.flush());\n+\n+    // Wait for an acknowledgement that all the data was received. No idea\n+    // why this is necessary, seems like it shouldn't be!\n+    let mut client = client.into_inner().unwrap();\n+    let mut buf = [0; 4];\n+    t!(client.read_exact(&mut buf));\n+    assert_eq!(&buf, b\"ack \");\n     println!(\"done pushing {:?}\", path);\n }\n \n@@ -137,22 +190,27 @@ fn run(files: String, args: Vec<String>) {\n     t!(client.write_all(&[0]));\n \n     // Send over env vars\n+    //\n+    // Don't send over *everything* though as some env vars are set by and used\n+    // by the client.\n     for (k, v) in env::vars() {\n-        if k != \"PATH\" && k != \"LD_LIBRARY_PATH\" {\n-            t!(client.write_all(k.as_bytes()));\n-            t!(client.write_all(&[0]));\n-            t!(client.write_all(v.as_bytes()));\n-            t!(client.write_all(&[0]));\n+        match &k[..] {\n+            \"PATH\" |\n+            \"LD_LIBRARY_PATH\" |\n+            \"PWD\" => continue,\n+            _ => {}\n         }\n+        t!(client.write_all(k.as_bytes()));\n+        t!(client.write_all(&[0]));\n+        t!(client.write_all(v.as_bytes()));\n+        t!(client.write_all(&[0]));\n     }\n     t!(client.write_all(&[0]));\n \n     // Send over support libraries\n     let mut files = files.split(':');\n     let exe = files.next().unwrap();\n     for file in files.map(Path::new) {\n-        t!(client.write_all(file.file_name().unwrap().to_str().unwrap().as_bytes()));\n-        t!(client.write_all(&[0]));\n         send(&file, &mut client);\n     }\n     t!(client.write_all(&[0]));\n@@ -209,6 +267,8 @@ fn run(files: String, args: Vec<String>) {\n }\n \n fn send(path: &Path, dst: &mut Write) {\n+    t!(dst.write_all(path.file_name().unwrap().to_str().unwrap().as_bytes()));\n+    t!(dst.write_all(&[0]));\n     let mut file = t!(File::open(&path));\n     let amt = t!(file.metadata()).len();\n     t!(dst.write_all(&[", "previous_filename": "src/tools/qemu-test-client/src/main.rs"}, {"sha": "8704296289e83648ab4d694d6693102b868d7489", "filename": "src/tools/remote-test-server/Cargo.toml", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Ftools%2Fremote-test-server%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Ftools%2Fremote-test-server%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fremote-test-server%2FCargo.toml?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -1,5 +1,5 @@\n [package]\n-name = \"qemu-test-server\"\n+name = \"remote-test-server\"\n version = \"0.1.0\"\n authors = [\"The Rust Project Developers\"]\n ", "previous_filename": "src/tools/qemu-test-server/Cargo.toml"}, {"sha": "308ccdbef77baeb7e72c47253c8f5c28d9a5481a", "filename": "src/tools/remote-test-server/src/main.rs", "status": "renamed", "additions": 58, "deletions": 33, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Ftools%2Fremote-test-server%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f73b173cbe6e6635226593a2bc6672faf61bd60/src%2Ftools%2Fremote-test-server%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fremote-test-server%2Fsrc%2Fmain.rs?ref=2f73b173cbe6e6635226593a2bc6672faf61bd60", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n /// This is a small server which is intended to run inside of an emulator. This\n-/// server pairs with the `qemu-test-client` program in this repository. The\n-/// `qemu-test-client` connects to this server over a TCP socket and performs\n+/// server pairs with the `remote-test-client` program in this repository. The\n+/// `remote-test-client` connects to this server over a TCP socket and performs\n /// work such as:\n ///\n /// 1. Pushing shared libraries to the server\n@@ -20,17 +20,18 @@\n /// themselves having support libraries. All data over the TCP sockets is in a\n /// basically custom format suiting our needs.\n \n+use std::cmp;\n use std::fs::{self, File, Permissions};\n use std::io::prelude::*;\n use std::io::{self, BufReader};\n use std::net::{TcpListener, TcpStream};\n use std::os::unix::prelude::*;\n-use std::sync::{Arc, Mutex};\n-use std::path::Path;\n+use std::path::{Path, PathBuf};\n+use std::process::{Command, Stdio};\n use std::str;\n use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+use std::sync::{Arc, Mutex};\n use std::thread;\n-use std::process::{Command, Stdio};\n \n macro_rules! t {\n     ($e:expr) => (match $e {\n@@ -43,18 +44,24 @@ static TEST: AtomicUsize = ATOMIC_USIZE_INIT;\n \n fn main() {\n     println!(\"starting test server\");\n-    let listener = t!(TcpListener::bind(\"10.0.2.15:12345\"));\n+    let (listener, work) = if cfg!(target_os = \"android\") {\n+        (t!(TcpListener::bind(\"0.0.0.0:12345\")), \"/data/tmp/work\")\n+    } else {\n+        (t!(TcpListener::bind(\"10.0.2.15:12345\")), \"/tmp/work\")\n+    };\n     println!(\"listening!\");\n \n-    let work = Path::new(\"/tmp/work\");\n+    let work = Path::new(work);\n     t!(fs::create_dir_all(work));\n \n     let lock = Arc::new(Mutex::new(()));\n \n     for socket in listener.incoming() {\n         let mut socket = t!(socket);\n         let mut buf = [0; 4];\n-        t!(socket.read_exact(&mut buf));\n+        if socket.read_exact(&mut buf).is_err() {\n+            continue\n+        }\n         if &buf[..] == b\"ping\" {\n             t!(socket.write_all(b\"pong\"));\n         } else if &buf[..] == b\"push\" {\n@@ -70,14 +77,10 @@ fn main() {\n \n fn handle_push(socket: TcpStream, work: &Path) {\n     let mut reader = BufReader::new(socket);\n-    let mut filename = Vec::new();\n-    t!(reader.read_until(0, &mut filename));\n-    filename.pop(); // chop off the 0\n-    let filename = t!(str::from_utf8(&filename));\n+    recv(&work, &mut reader);\n \n-    let path = work.join(filename);\n-    t!(io::copy(&mut reader, &mut t!(File::create(&path))));\n-    t!(fs::set_permissions(&path, Permissions::from_mode(0o755)));\n+    let mut socket = reader.into_inner();\n+    t!(socket.write_all(b\"ack \"));\n }\n \n struct RemoveOnDrop<'a> {\n@@ -98,29 +101,29 @@ fn handle_run(socket: TcpStream, work: &Path, lock: &Mutex<()>) {\n     // space.\n     let n = TEST.fetch_add(1, Ordering::SeqCst);\n     let path = work.join(format!(\"test{}\", n));\n-    let exe = path.join(\"exe\");\n     t!(fs::create_dir(&path));\n     let _a = RemoveOnDrop { inner: &path };\n \n     // First up we'll get a list of arguments delimited with 0 bytes. An empty\n     // argument means that we're done.\n-    let mut cmd = Command::new(&exe);\n+    let mut args = Vec::new();\n     while t!(reader.read_until(0, &mut arg)) > 1 {\n-        cmd.arg(t!(str::from_utf8(&arg[..arg.len() - 1])));\n+        args.push(t!(str::from_utf8(&arg[..arg.len() - 1])).to_string());\n         arg.truncate(0);\n     }\n \n     // Next we'll get a bunch of env vars in pairs delimited by 0s as well\n+    let mut env = Vec::new();\n     arg.truncate(0);\n     while t!(reader.read_until(0, &mut arg)) > 1 {\n         let key_len = arg.len() - 1;\n         let val_len = t!(reader.read_until(0, &mut arg)) - 1;\n         {\n             let key = &arg[..key_len];\n             let val = &arg[key_len + 1..][..val_len];\n-            let key = t!(str::from_utf8(key));\n-            let val = t!(str::from_utf8(val));\n-            cmd.env(key, val);\n+            let key = t!(str::from_utf8(key)).to_string();\n+            let val = t!(str::from_utf8(val)).to_string();\n+            env.push((key, val));\n         }\n         arg.truncate(0);\n     }\n@@ -148,23 +151,23 @@ fn handle_run(socket: TcpStream, work: &Path, lock: &Mutex<()>) {\n     let lock = lock.lock();\n \n     // Next there's a list of dynamic libraries preceded by their filenames.\n-    arg.truncate(0);\n-    while t!(reader.read_until(0, &mut arg)) > 1 {\n-        let dst = path.join(t!(str::from_utf8(&arg[..arg.len() - 1])));\n-        let amt = read_u32(&mut reader) as u64;\n-        t!(io::copy(&mut reader.by_ref().take(amt),\n-                    &mut t!(File::create(&dst))));\n-        t!(fs::set_permissions(&dst, Permissions::from_mode(0o755)));\n-        arg.truncate(0);\n+    while t!(reader.fill_buf())[0] != 0 {\n+        recv(&path, &mut reader);\n     }\n+    assert_eq!(t!(reader.read(&mut [0])), 1);\n \n     // Finally we'll get the binary. The other end will tell us how big the\n     // binary is and then we'll download it all to the exe path we calculated\n     // earlier.\n-    let amt = read_u32(&mut reader) as u64;\n-    t!(io::copy(&mut reader.by_ref().take(amt),\n-                &mut t!(File::create(&exe))));\n-    t!(fs::set_permissions(&exe, Permissions::from_mode(0o755)));\n+    let exe = recv(&path, &mut reader);\n+\n+    let mut cmd = Command::new(&exe);\n+    for arg in args {\n+        cmd.arg(arg);\n+    }\n+    for (k, v) in env {\n+        cmd.env(k, v);\n+    }\n \n     // Support libraries were uploaded to `work` earlier, so make sure that's\n     // in `LD_LIBRARY_PATH`. Also include our own current dir which may have\n@@ -202,6 +205,28 @@ fn handle_run(socket: TcpStream, work: &Path, lock: &Mutex<()>) {\n     ]));\n }\n \n+fn recv<B: BufRead>(dir: &Path, io: &mut B) -> PathBuf {\n+    let mut filename = Vec::new();\n+    t!(io.read_until(0, &mut filename));\n+\n+    // We've got some tests with *really* long names. We try to name the test\n+    // executable the same on the target as it is on the host to aid with\n+    // debugging, but the targets we're emulating are often more restrictive\n+    // than the hosts as well.\n+    //\n+    // To ensure we can run a maximum number of tests without modifications we\n+    // just arbitrarily truncate the filename to 50 bytes. That should\n+    // hopefully allow us to still identify what's running while staying under\n+    // the filesystem limits.\n+    let len = cmp::min(filename.len() - 1, 50);\n+    let dst = dir.join(t!(str::from_utf8(&filename[..len])));\n+    let amt = read_u32(io) as u64;\n+    t!(io::copy(&mut io.take(amt),\n+                &mut t!(File::create(&dst))));\n+    t!(fs::set_permissions(&dst, Permissions::from_mode(0o755)));\n+    return dst\n+}\n+\n fn my_copy(src: &mut Read, which: u8, dst: &Mutex<Write>) {\n     let mut b = [0; 1024];\n     loop {", "previous_filename": "src/tools/qemu-test-server/src/main.rs"}]}