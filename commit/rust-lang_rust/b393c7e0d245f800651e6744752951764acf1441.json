{"sha": "b393c7e0d245f800651e6744752951764acf1441", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzOTNjN2UwZDI0NWY4MDA2NTFlNjc0NDc1Mjk1MTc2NGFjZjE0NDE=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-06-29T15:51:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-06-29T15:51:23Z"}, "message": "Rollup merge of #34513 - ollie27:rustdoc_stripped, r=alexcrichton\n\nrustdoc: Fix a few stripping issues\n\nWe need to recurse into stripped modules to strip things like impl methods\nbut when doing so we must not add any items to the `retained` set.\n\nFor example this removes [`core::num::ParseFloatError::__description`](https://doc.rust-lang.org/nightly/core/num/struct.ParseFloatError.html#method.__description) and [`impl Clone for ThreadRng`](https://doc.rust-lang.org/nightly/std/clone/trait.Clone.html).", "tree": {"sha": "f663c2c9e74ff64f01c5477161cc889be0a691ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f663c2c9e74ff64f01c5477161cc889be0a691ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b393c7e0d245f800651e6744752951764acf1441", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b393c7e0d245f800651e6744752951764acf1441", "html_url": "https://github.com/rust-lang/rust/commit/b393c7e0d245f800651e6744752951764acf1441", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b393c7e0d245f800651e6744752951764acf1441/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5bd3ef81c67673bde99e1b85ecc37fd551493070", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bd3ef81c67673bde99e1b85ecc37fd551493070", "html_url": "https://github.com/rust-lang/rust/commit/5bd3ef81c67673bde99e1b85ecc37fd551493070"}, {"sha": "beebaf1366d84425cb52074a710d4bc560f3d2c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/beebaf1366d84425cb52074a710d4bc560f3d2c3", "html_url": "https://github.com/rust-lang/rust/commit/beebaf1366d84425cb52074a710d4bc560f3d2c3"}], "stats": {"total": 124, "additions": 106, "deletions": 18}, "files": [{"sha": "b8e40790646a7eab87cdf78d558404baf8628823", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 40, "deletions": 18, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b393c7e0d245f800651e6744752951764acf1441/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b393c7e0d245f800651e6744752951764acf1441/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=b393c7e0d245f800651e6744752951764acf1441", "patch": "@@ -12,6 +12,7 @@ use rustc::hir::def_id::DefId;\n use rustc::middle::privacy::AccessLevels;\n use rustc::util::nodemap::DefIdSet;\n use std::cmp;\n+use std::mem;\n use std::string::String;\n use std::usize;\n \n@@ -29,7 +30,8 @@ pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n     // strip all #[doc(hidden)] items\n     let krate = {\n         struct Stripper<'a> {\n-            retained: &'a mut DefIdSet\n+            retained: &'a mut DefIdSet,\n+            update_retained: bool,\n         }\n         impl<'a> fold::DocFolder for Stripper<'a> {\n             fn fold_item(&mut self, i: Item) -> Option<Item> {\n@@ -38,17 +40,25 @@ pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n                     // use a dedicated hidden item for given item type if any\n                     match i.inner {\n                         clean::StructFieldItem(..) | clean::ModuleItem(..) => {\n-                            return Strip(i).fold()\n+                            // We need to recurse into stripped modules to\n+                            // strip things like impl methods but when doing so\n+                            // we must not add any items to the `retained` set.\n+                            let old = mem::replace(&mut self.update_retained, false);\n+                            let ret = Strip(self.fold_item_recur(i).unwrap()).fold();\n+                            self.update_retained = old;\n+                            return ret;\n                         }\n                         _ => return None,\n                     }\n                 } else {\n-                    self.retained.insert(i.def_id);\n+                    if self.update_retained {\n+                        self.retained.insert(i.def_id);\n+                    }\n                 }\n                 self.fold_item_recur(i)\n             }\n         }\n-        let mut stripper = Stripper{ retained: &mut retained };\n+        let mut stripper = Stripper{ retained: &mut retained, update_retained: true };\n         stripper.fold_crate(krate)\n     };\n \n@@ -69,6 +79,7 @@ pub fn strip_private(mut krate: clean::Crate) -> plugins::PluginResult {\n         let mut stripper = Stripper {\n             retained: &mut retained,\n             access_levels: &access_levels,\n+            update_retained: true,\n         };\n         krate = ImportStripper.fold_crate(stripper.fold_crate(krate));\n     }\n@@ -81,12 +92,21 @@ pub fn strip_private(mut krate: clean::Crate) -> plugins::PluginResult {\n struct Stripper<'a> {\n     retained: &'a mut DefIdSet,\n     access_levels: &'a AccessLevels<DefId>,\n+    update_retained: bool,\n }\n \n impl<'a> fold::DocFolder for Stripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         match i.inner {\n-            clean::StrippedItem(..) => return Some(i),\n+            clean::StrippedItem(..) => {\n+                // We need to recurse into stripped modules to strip things\n+                // like impl methods but when doing so we must not add any\n+                // items to the `retained` set.\n+                let old = mem::replace(&mut self.update_retained, false);\n+                let ret = self.fold_item_recur(i);\n+                self.update_retained = old;\n+                return ret;\n+            }\n             // These items can all get re-exported\n             clean::TypedefItem(..) | clean::StaticItem(..) |\n             clean::StructItem(..) | clean::EnumItem(..) |\n@@ -109,18 +129,13 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n \n             clean::ModuleItem(..) => {\n                 if i.def_id.is_local() && i.visibility != Some(clean::Public) {\n-                    return Strip(self.fold_item_recur(i).unwrap()).fold()\n+                    let old = mem::replace(&mut self.update_retained, false);\n+                    let ret = Strip(self.fold_item_recur(i).unwrap()).fold();\n+                    self.update_retained = old;\n+                    return ret;\n                 }\n             }\n \n-            // trait impls for private items should be stripped\n-            clean::ImplItem(clean::Impl{\n-                for_: clean::ResolvedPath{ did, is_generic, .. }, ..\n-            }) => {\n-                if did.is_local() && !is_generic && !self.access_levels.is_exported(did) {\n-                    return None;\n-                }\n-            }\n             // handled in the `strip-priv-imports` pass\n             clean::ExternCrateItem(..) | clean::ImportItem(..) => {}\n \n@@ -152,21 +167,24 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n         };\n \n         let i = if fastreturn {\n-            self.retained.insert(i.def_id);\n+            if self.update_retained {\n+                self.retained.insert(i.def_id);\n+            }\n             return Some(i);\n         } else {\n             self.fold_item_recur(i)\n         };\n \n         i.and_then(|i| {\n             match i.inner {\n-                // emptied modules/impls have no need to exist\n+                // emptied modules have no need to exist\n                 clean::ModuleItem(ref m)\n                     if m.items.is_empty() &&\n                        i.doc_value().is_none() => None,\n-                clean::ImplItem(ref i) if i.items.is_empty() => None,\n                 _ => {\n-                    self.retained.insert(i.def_id);\n+                    if self.update_retained {\n+                        self.retained.insert(i.def_id);\n+                    }\n                     Some(i)\n                 }\n             }\n@@ -182,6 +200,10 @@ struct ImplStripper<'a> {\n impl<'a> fold::DocFolder for ImplStripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         if let clean::ImplItem(ref imp) = i.inner {\n+            // emptied none trait impls can be stripped\n+            if imp.trait_.is_none() && imp.items.is_empty() {\n+                return None;\n+            }\n             if let Some(did) = imp.for_.def_id() {\n                 if did.is_local() && !imp.for_.is_generic() &&\n                     !self.retained.contains(&did)"}, {"sha": "203c56e9e2e00173282b287bfca3144521d23172", "filename": "src/test/rustdoc/hidden-impls.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b393c7e0d245f800651e6744752951764acf1441/src%2Ftest%2Frustdoc%2Fhidden-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b393c7e0d245f800651e6744752951764acf1441/src%2Ftest%2Frustdoc%2Fhidden-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fhidden-impls.rs?ref=b393c7e0d245f800651e6744752951764acf1441", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_name = \"foo\"]\n+\n+mod hidden {\n+    #[derive(Clone)]\n+    pub struct Foo;\n+}\n+\n+#[doc(hidden)]\n+pub mod __hidden {\n+    pub use hidden::Foo;\n+}\n+\n+// @has foo/trait.Clone.html\n+// @!has - 'Foo'\n+// @has implementors/foo/trait.Clone.js\n+// @!has - 'Foo'\n+pub use std::clone::Clone;"}, {"sha": "18f5f086cd1a4ea85ad386c2c6831daf26bfa25e", "filename": "src/test/rustdoc/hidden-methods.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b393c7e0d245f800651e6744752951764acf1441/src%2Ftest%2Frustdoc%2Fhidden-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b393c7e0d245f800651e6744752951764acf1441/src%2Ftest%2Frustdoc%2Fhidden-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fhidden-methods.rs?ref=b393c7e0d245f800651e6744752951764acf1441", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_name = \"foo\"]\n+\n+#[doc(hidden)]\n+pub mod hidden {\n+    pub struct Foo;\n+\n+    impl Foo {\n+        #[doc(hidden)]\n+        pub fn this_should_be_hidden() {}\n+    }\n+\n+    pub struct Bar;\n+\n+    impl Bar {\n+        fn this_should_be_hidden() {}\n+    }\n+}\n+\n+// @has foo/struct.Foo.html\n+// @!has - 'Methods'\n+// @!has - 'impl Foo'\n+// @!has - 'this_should_be_hidden'\n+pub use hidden::Foo;\n+\n+// @has foo/struct.Bar.html\n+// @!has - 'Methods'\n+// @!has - 'impl Bar'\n+// @!has - 'this_should_be_hidden'\n+pub use hidden::Bar;"}]}