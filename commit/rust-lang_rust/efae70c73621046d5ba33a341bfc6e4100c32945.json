{"sha": "efae70c73621046d5ba33a341bfc6e4100c32945", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmYWU3MGM3MzYyMTA0NmQ1YmEzM2EzNDFiZmM2ZTQxMDBjMzI5NDU=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-09-14T02:55:57Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-09-14T02:55:57Z"}, "message": "Split `Liveness::users` into three.\n\nThis reduces memory usage on some benchmarks because no space is wasted\nfor padding. For a `check-clean` build of `keccak` it reduces `max-rss`\nby 20%.", "tree": {"sha": "16806b8812b8c3810d9e5d3526b53b99648f0eaa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16806b8812b8c3810d9e5d3526b53b99648f0eaa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/efae70c73621046d5ba33a341bfc6e4100c32945", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/efae70c73621046d5ba33a341bfc6e4100c32945", "html_url": "https://github.com/rust-lang/rust/commit/efae70c73621046d5ba33a341bfc6e4100c32945", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/efae70c73621046d5ba33a341bfc6e4100c32945/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6720cc810ea3dc9e051a95ff1a8dc9755c3bdb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6720cc810ea3dc9e051a95ff1a8dc9755c3bdb5", "html_url": "https://github.com/rust-lang/rust/commit/d6720cc810ea3dc9e051a95ff1a8dc9755c3bdb5"}], "stats": {"total": 74, "additions": 35, "deletions": 39}, "files": [{"sha": "13847fb48cee961e0d96e58006fee93c582dfc8d", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 35, "deletions": 39, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/efae70c73621046d5ba33a341bfc6e4100c32945/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efae70c73621046d5ba33a341bfc6e4100c32945/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=efae70c73621046d5ba33a341bfc6e4100c32945", "patch": "@@ -64,10 +64,10 @@\n //! methods.  It effectively does a reverse walk of the AST; whenever we\n //! reach a loop node, we iterate until a fixed point is reached.\n //!\n-//! ## The `Users` struct\n+//! ## The `users_*` fields\n //!\n //! At each live node `N`, we track three pieces of information for each\n-//! variable `V` (these are encapsulated in the `Users` struct):\n+//! variable `V` (these are in the `users_*` fields):\n //!\n //! - `reader`: the `LiveNode` ID of some node which will read the value\n //!    that `V` holds on entry to `N`.  Formally: a node `M` such\n@@ -536,21 +536,6 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n // Actually we compute just a bit more than just liveness, but we use\n // the same basic propagation framework in all cases.\n \n-#[derive(Clone, Copy)]\n-struct Users {\n-    reader: LiveNode,\n-    writer: LiveNode,\n-    used: bool\n-}\n-\n-fn invalid_users() -> Users {\n-    Users {\n-        reader: invalid_node(),\n-        writer: invalid_node(),\n-        used: false\n-    }\n-}\n-\n #[derive(Copy, Clone)]\n struct Specials {\n     exit_ln: LiveNode,\n@@ -567,7 +552,14 @@ struct Liveness<'a, 'tcx: 'a> {\n     tables: &'a ty::TypeckTables<'tcx>,\n     s: Specials,\n     successors: Vec<LiveNode>,\n-    users: Vec<Users>,\n+\n+    // We used to have a single `users: Vec<Users>` field here, where `Users`\n+    // had `reader`, `writer` and `used` fields. But the number of users can\n+    // get very large, and it's more compact to store the data in three\n+    // separate `Vec`s so that no space is wasted for padding.\n+    users_reader: Vec<LiveNode>,\n+    users_writer: Vec<LiveNode>,\n+    users_used: Vec<bool>,\n \n     // mappings from loop node ID to LiveNode\n     // (\"break\" label should map to loop node ID,\n@@ -592,13 +584,16 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n         let num_live_nodes = ir.num_live_nodes;\n         let num_vars = ir.num_vars;\n+        let num_users = num_live_nodes * num_vars;\n \n         Liveness {\n             ir,\n             tables,\n             s: specials,\n             successors: vec![invalid_node(); num_live_nodes],\n-            users: vec![invalid_users(); num_live_nodes * num_vars],\n+            users_reader: vec![invalid_node(); num_users],\n+            users_writer: vec![invalid_node(); num_users],\n+            users_used: vec![false; num_users],\n             break_ln: NodeMap(),\n             cont_ln: NodeMap(),\n         }\n@@ -665,7 +660,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn live_on_entry(&self, ln: LiveNode, var: Variable)\n                       -> Option<LiveNodeKind> {\n         assert!(ln.is_valid());\n-        let reader = self.users[self.idx(ln, var)].reader;\n+        let reader = self.users_reader[self.idx(ln, var)];\n         if reader.is_valid() {Some(self.ir.lnk(reader))} else {None}\n     }\n \n@@ -680,13 +675,13 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn used_on_entry(&self, ln: LiveNode, var: Variable) -> bool {\n         assert!(ln.is_valid());\n-        self.users[self.idx(ln, var)].used\n+        self.users_used[self.idx(ln, var)]\n     }\n \n     fn assigned_on_entry(&self, ln: LiveNode, var: Variable)\n                          -> Option<LiveNodeKind> {\n         assert!(ln.is_valid());\n-        let writer = self.users[self.idx(ln, var)].writer;\n+        let writer = self.users_writer[self.idx(ln, var)];\n         if writer.is_valid() {Some(self.ir.lnk(writer))} else {None}\n     }\n \n@@ -730,9 +725,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         {\n             let wr = &mut wr as &mut dyn Write;\n             write!(wr, \"[ln({:?}) of kind {:?} reads\", ln.get(), self.ir.lnk(ln));\n-            self.write_vars(wr, ln, |idx| self.users[idx].reader);\n+            self.write_vars(wr, ln, |idx| self.users_reader[idx]);\n             write!(wr, \"  writes\");\n-            self.write_vars(wr, ln, |idx| self.users[idx].writer);\n+            self.write_vars(wr, ln, |idx| self.users_writer[idx]);\n             write!(wr, \"  precedes {:?}]\", self.successors[ln.get()]);\n         }\n         String::from_utf8(wr).unwrap()\n@@ -747,7 +742,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         // only grow during iterations.\n         //\n         // self.indices(ln) { |idx|\n-        //     self.users[idx] = invalid_users();\n+        //     self.users_reader[idx] = invalid_node();\n+        //     self.users_writer[idx] = invalid_node();\n+        //     self.users_used[idx] = false;\n         // }\n     }\n \n@@ -756,7 +753,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         self.successors[ln.get()] = succ_ln;\n \n         self.indices2(ln, succ_ln, |this, idx, succ_idx| {\n-            this.users[idx] = this.users[succ_idx]\n+            this.users_reader[idx] = this.users_reader[succ_idx];\n+            this.users_writer[idx] = this.users_writer[succ_idx];\n+            this.users_used[idx] = this.users_used[succ_idx];\n         });\n         debug!(\"init_from_succ(ln={}, succ={})\",\n                self.ln_str(ln), self.ln_str(succ_ln));\n@@ -771,12 +770,10 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n         let mut changed = false;\n         self.indices2(ln, succ_ln, |this, idx, succ_idx| {\n-            changed |= copy_if_invalid(this.users[succ_idx].reader,\n-                                       &mut this.users[idx].reader);\n-            changed |= copy_if_invalid(this.users[succ_idx].writer,\n-                                       &mut this.users[idx].writer);\n-            if this.users[succ_idx].used && !this.users[idx].used {\n-                this.users[idx].used = true;\n+            changed |= copy_if_invalid(this.users_reader[succ_idx], &mut this.users_reader[idx]);\n+            changed |= copy_if_invalid(this.users_writer[succ_idx], &mut this.users_writer[idx]);\n+            if this.users_used[succ_idx] && !this.users_used[idx] {\n+                this.users_used[idx] = true;\n                 changed = true;\n             }\n         });\n@@ -800,8 +797,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     // this) so we just clear out all the data.\n     fn define(&mut self, writer: LiveNode, var: Variable) {\n         let idx = self.idx(writer, var);\n-        self.users[idx].reader = invalid_node();\n-        self.users[idx].writer = invalid_node();\n+        self.users_reader[idx] = invalid_node();\n+        self.users_writer[idx] = invalid_node();\n \n         debug!(\"{:?} defines {:?} (idx={}): {}\", writer, var,\n                idx, self.ln_str(writer));\n@@ -813,21 +810,20 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                ln, acc, var, self.ln_str(ln));\n \n         let idx = self.idx(ln, var);\n-        let user = &mut self.users[idx];\n \n         if (acc & ACC_WRITE) != 0 {\n-            user.reader = invalid_node();\n-            user.writer = ln;\n+            self.users_reader[idx] = invalid_node();\n+            self.users_writer[idx] = ln;\n         }\n \n         // Important: if we both read/write, must do read second\n         // or else the write will override.\n         if (acc & ACC_READ) != 0 {\n-            user.reader = ln;\n+            self.users_reader[idx] = ln;\n         }\n \n         if (acc & ACC_USE) != 0 {\n-            user.used = true;\n+            self.users_used[idx] = true;\n         }\n     }\n "}]}