{"sha": "8e9e858b786c262185b279be2d78e9eea0a81ed8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlOWU4NThiNzg2YzI2MjE4NWIyNzliZTJkNzhlOWVlYTBhODFlZDg=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-03-01T19:38:21Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-03-08T16:00:44Z"}, "message": "Remove uses of `ast_ty_to_ty_cache`", "tree": {"sha": "22653048d9f8689942060485a02024aef243d61b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22653048d9f8689942060485a02024aef243d61b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e9e858b786c262185b279be2d78e9eea0a81ed8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e9e858b786c262185b279be2d78e9eea0a81ed8", "html_url": "https://github.com/rust-lang/rust/commit/8e9e858b786c262185b279be2d78e9eea0a81ed8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e9e858b786c262185b279be2d78e9eea0a81ed8/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7129f560d4a47d95a0b2f84ebf3b15a9b9f79c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7129f560d4a47d95a0b2f84ebf3b15a9b9f79c6", "html_url": "https://github.com/rust-lang/rust/commit/d7129f560d4a47d95a0b2f84ebf3b15a9b9f79c6"}], "stats": {"total": 75, "additions": 36, "deletions": 39}, "files": [{"sha": "3ed75fdffeb7ba14159de83963b5f0b0392ccb14", "filename": "src/methods.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8e9e858b786c262185b279be2d78e9eea0a81ed8/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9e858b786c262185b279be2d78e9eea0a81ed8/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=8e9e858b786c262185b279be2d78e9eea0a81ed8", "patch": "@@ -10,7 +10,7 @@ use std::{fmt, iter};\n use syntax::codemap::Span;\n use syntax::ptr::P;\n use utils::{get_trait_def_id, implements_trait, in_external_macro, in_macro, match_path, match_trait_method,\n-            match_type, method_chain_args, returns_self, snippet, snippet_opt, span_lint,\n+            match_type, method_chain_args, return_ty, snippet, snippet_opt, span_lint,\n             span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth};\n use utils::{BTREEMAP_ENTRY_PATH, DEFAULT_TRAIT_PATH, HASHMAP_ENTRY_PATH, OPTION_PATH, RESULT_PATH, STRING_PATH,\n             VEC_PATH};\n@@ -431,7 +431,8 @@ impl LateLintPass for MethodsPass {\n                         }\n                     }\n \n-                    if &name.as_str() == &\"new\" && !returns_self(cx, &sig.decl.output, ty)  {\n+                    let ret_ty = return_ty(cx.tcx.node_id_to_type(implitem.id));\n+                    if &name.as_str() == &\"new\" && !ret_ty.map_or(false, |ret_ty| ret_ty.walk().any(|t| t == ty)) {\n                         span_lint(cx,\n                                   NEW_RET_NO_SELF,\n                                   sig.explicit_self.span,"}, {"sha": "89467f1dc556e8d8f87fdeb7417a84498aa8ae95", "filename": "src/new_without_default.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8e9e858b786c262185b279be2d78e9eea0a81ed8/src%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9e858b786c262185b279be2d78e9eea0a81ed8/src%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnew_without_default.rs?ref=8e9e858b786c262185b279be2d78e9eea0a81ed8", "patch": "@@ -3,7 +3,7 @@ use rustc_front::hir;\n use rustc_front::intravisit::FnKind;\n use syntax::ast;\n use syntax::codemap::Span;\n-use utils::{get_trait_def_id, implements_trait, in_external_macro, returns_self, span_lint, DEFAULT_TRAIT_PATH};\n+use utils::{get_trait_def_id, implements_trait, in_external_macro, return_ty, span_lint, DEFAULT_TRAIT_PATH};\n \n /// **What it does:** This lints about type with a `fn new() -> Self` method and no `Default`\n /// implementation.\n@@ -47,13 +47,15 @@ impl LateLintPass for NewWithoutDefault {\n \n         if let FnKind::Method(name, _, _) = kind {\n             if decl.inputs.is_empty() && name.as_str() == \"new\" {\n-                let ty = cx.tcx.lookup_item_type(cx.tcx.map.local_def_id(cx.tcx.map.get_parent(id))).ty;\n+                let self_ty = cx.tcx.lookup_item_type(cx.tcx.map.local_def_id(cx.tcx.map.get_parent(id))).ty;\n \n-                if  returns_self(cx, &decl.output, ty) {\n+                let ret_ty = return_ty(cx.tcx.node_id_to_type(id));\n+\n+                if Some(self_ty) == ret_ty {\n                     if let Some(default_trait_id) = get_trait_def_id(cx, &DEFAULT_TRAIT_PATH) {\n-                        if !implements_trait(cx, ty, default_trait_id, Vec::new()) {\n+                        if !implements_trait(cx, self_ty, default_trait_id, Vec::new()) {\n                             span_lint(cx, NEW_WITHOUT_DEFAULT, span,\n-                                      &format!(\"you should consider adding a `Default` implementation for `{}`\", ty));\n+                                      &format!(\"you should consider adding a `Default` implementation for `{}`\", self_ty));\n                         }\n                     }\n                 }"}, {"sha": "85baf3310c3d40f8c2afa7f5fbee0c88bf3b37de", "filename": "src/ptr_arg.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8e9e858b786c262185b279be2d78e9eea0a81ed8/src%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9e858b786c262185b279be2d78e9eea0a81ed8/src%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fptr_arg.rs?ref=8e9e858b786c262185b279be2d78e9eea0a81ed8", "patch": "@@ -6,6 +6,7 @@ use rustc::front::map::NodeItem;\n use rustc::lint::*;\n use rustc::middle::ty;\n use rustc_front::hir::*;\n+use syntax::ast::NodeId;\n use utils::{STRING_PATH, VEC_PATH};\n use utils::{span_lint, match_type};\n \n@@ -35,7 +36,7 @@ impl LintPass for PtrArg {\n impl LateLintPass for PtrArg {\n     fn check_item(&mut self, cx: &LateContext, item: &Item) {\n         if let ItemFn(ref decl, _, _, _, _, _) = item.node {\n-            check_fn(cx, decl);\n+            check_fn(cx, decl, item.id);\n         }\n     }\n \n@@ -46,34 +47,34 @@ impl LateLintPass for PtrArg {\n                     return; // ignore trait impls\n                 }\n             }\n-            check_fn(cx, &sig.decl);\n+            check_fn(cx, &sig.decl, item.id);\n         }\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext, item: &TraitItem) {\n         if let MethodTraitItem(ref sig, _) = item.node {\n-            check_fn(cx, &sig.decl);\n+            check_fn(cx, &sig.decl, item.id);\n         }\n     }\n }\n \n-fn check_fn(cx: &LateContext, decl: &FnDecl) {\n-    for arg in &decl.inputs {\n-        if let Some(ty) = cx.tcx.ast_ty_to_ty_cache.borrow().get(&arg.ty.id) {\n-            if let ty::TyRef(_, ty::TypeAndMut { ty, mutbl: MutImmutable }) = ty.sty {\n-                if match_type(cx, ty, &VEC_PATH) {\n-                    span_lint(cx,\n-                              PTR_ARG,\n-                              arg.ty.span,\n-                              \"writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used \\\n-                               with non-Vec-based slices. Consider changing the type to `&[...]`\");\n-                } else if match_type(cx, ty, &STRING_PATH) {\n-                    span_lint(cx,\n-                              PTR_ARG,\n-                              arg.ty.span,\n-                              \"writing `&String` instead of `&str` involves a new object where a slice will do. \\\n-                               Consider changing the type to `&str`\");\n-                }\n+fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId) {\n+    let fn_ty = cx.tcx.node_id_to_type(fn_id).fn_sig().skip_binder();\n+\n+    for (arg, ty) in decl.inputs.iter().zip(&fn_ty.inputs) {\n+        if let ty::TyRef(_, ty::TypeAndMut { ty, mutbl: MutImmutable }) = ty.sty {\n+            if match_type(cx, ty, &VEC_PATH) {\n+                span_lint(cx,\n+                          PTR_ARG,\n+                          arg.ty.span,\n+                          \"writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used \\\n+                           with non-Vec-based slices. Consider changing the type to `&[...]`\");\n+            } else if match_type(cx, ty, &STRING_PATH) {\n+                span_lint(cx,\n+                          PTR_ARG,\n+                          arg.ty.span,\n+                          \"writing `&String` instead of `&str` involves a new object where a slice will do. \\\n+                           Consider changing the type to `&str`\");\n             }\n         }\n     }"}, {"sha": "bef4baea67e18b59055228da5e678824ed3560ec", "filename": "src/utils/mod.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8e9e858b786c262185b279be2d78e9eea0a81ed8/src%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9e858b786c262185b279be2d78e9eea0a81ed8/src%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fmod.rs?ref=8e9e858b786c262185b279be2d78e9eea0a81ed8", "patch": "@@ -732,18 +732,11 @@ pub fn unsugar_range(expr: &Expr) -> Option<UnsugaredRange> {\n     }\n }\n \n-/// Return whether a method returns `Self`.\n-pub fn returns_self(cx: &LateContext, ret: &FunctionRetTy, ty: ty::Ty) -> bool {\n-    if let FunctionRetTy::Return(ref ret_ty) = *ret {\n-        let ast_ty_to_ty_cache = cx.tcx.ast_ty_to_ty_cache.borrow();\n-        let ret_ty = ast_ty_to_ty_cache.get(&ret_ty.id);\n-\n-        if let Some(&ret_ty) = ret_ty {\n-            ret_ty.walk().any(|t| t == ty)\n-        } else {\n-            false\n-        }\n+/// Convenience function to get the return type of a function or `None` if the function diverges.\n+pub fn return_ty(fun: ty::Ty) -> Option<ty::Ty> {\n+    if let ty::FnConverging(ret_ty) = fun.fn_sig().skip_binder().output {\n+        Some(ret_ty)\n     } else {\n-        false\n+        None\n     }\n }"}]}