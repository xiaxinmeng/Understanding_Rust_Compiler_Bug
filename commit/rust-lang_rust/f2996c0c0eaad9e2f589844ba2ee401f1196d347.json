{"sha": "f2996c0c0eaad9e2f589844ba2ee401f1196d347", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyOTk2YzBjMGVhYWQ5ZTJmNTg5ODQ0YmEyZWU0MDFmMTE5NmQzNDc=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-03-21T02:09:57Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-03-24T16:10:01Z"}, "message": "Add basic information about associated types", "tree": {"sha": "73df7b38d3756259aef74b6a27428b25e40ec5ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73df7b38d3756259aef74b6a27428b25e40ec5ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2996c0c0eaad9e2f589844ba2ee401f1196d347", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2996c0c0eaad9e2f589844ba2ee401f1196d347", "html_url": "https://github.com/rust-lang/rust/commit/f2996c0c0eaad9e2f589844ba2ee401f1196d347", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2996c0c0eaad9e2f589844ba2ee401f1196d347/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ecdf792d1dda479d04781e5750737aa6cc574119", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecdf792d1dda479d04781e5750737aa6cc574119", "html_url": "https://github.com/rust-lang/rust/commit/ecdf792d1dda479d04781e5750737aa6cc574119"}], "stats": {"total": 203, "additions": 203, "deletions": 0}, "files": [{"sha": "69d49f67941d43a02b78ed4b167d3dce9363f190", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f2996c0c0eaad9e2f589844ba2ee401f1196d347/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/f2996c0c0eaad9e2f589844ba2ee401f1196d347/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=f2996c0c0eaad9e2f589844ba2ee401f1196d347", "patch": "@@ -22,6 +22,7 @@\n     * [More Strings](more-strings.md)\n     * [Patterns](patterns.md)\n     * [Method Syntax](method-syntax.md)\n+    * [Associated Types](associated-types.md)\n     * [Closures](closures.md)\n     * [Iterators](iterators.md)\n     * [Generics](generics.md)"}, {"sha": "f36c2c56b6a76d06ff21500a4495fb01c059e102", "filename": "src/doc/trpl/associated-types.md", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/f2996c0c0eaad9e2f589844ba2ee401f1196d347/src%2Fdoc%2Ftrpl%2Fassociated-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/f2996c0c0eaad9e2f589844ba2ee401f1196d347/src%2Fdoc%2Ftrpl%2Fassociated-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fassociated-types.md?ref=f2996c0c0eaad9e2f589844ba2ee401f1196d347", "patch": "@@ -0,0 +1,202 @@\n+% Associated Types\n+\n+Associated types are a powerful part of Rust's type system. They're related to\n+the idea of a 'type family', in other words, grouping multiple types together. That\n+description is a bit abstract, so let's dive right into an example. If you want\n+to write a `Graph` trait, you have two types to be generic over: the node type\n+and the edge type. So you might write a trait, `Graph<N, E>`, that looks like\n+this:\n+\n+```rust\n+trait Graph<N, E> {\n+    fn has_edge(&self, &N, &N) -> bool;\n+    fn edges(&self, &N) -> Vec<E>;\n+    // etc\n+}\n+```\n+\n+While this sort of works, it ends up being awkward. For example, any function\n+that wants to take a `Graph` as a parameter now _also_ needs to be generic over\n+the `N`ode and `E`dge types too:\n+\n+```rust,ignore\n+fn distance<N, E, G: Graph<N, E>>(graph: &G, start: &N, end: &N) -> u32 { ... }\n+```\n+\n+Our distance calculation works regardless of our `Edge` type, so the `E` stuff in\n+this signature is just a distraction.\n+\n+What we really want to say is that a certain `E`dge and `N`ode type come together\n+to form each kind of `Graph`. We can do that with associated types:\n+\n+```rust\n+trait Graph {\n+    type N;\n+    type E;\n+\n+    fn has_edge(&self, &Self::N, &Self::N) -> bool;\n+    fn edges(&self, &Self::N) -> Vec<Self::E>;\n+    // etc\n+}\n+```\n+\n+Now, our clients can be abstract over a given `Graph`:\n+\n+```rust,ignore\n+fn distance<G: Graph>(graph: &G, start: &G::N, end: &G::N) -> uint { ... }\n+```\n+\n+No need to deal with the `E`dge type here!\n+\n+Let's go over all this in more detail.\n+\n+## Defining associated types\n+\n+Let's build that `Graph` trait. Here's the definition:\n+\n+```rust\n+trait Graph {\n+    type N;\n+    type E;\n+\n+    fn has_edge(&self, &Self::N, &Self::N) -> bool;\n+    fn edges(&self, &Self::N) -> Vec<Self::E>;\n+}\n+```\n+\n+Simple enough. Associated types use the `type` keyword, and go inside the body\n+of the trait, with the functions.\n+\n+These `type` declarations can have all the same thing as functions do. For example,\n+if we wanted our `N` type to implement `Display`, so we can print the nodes out,\n+we could do this:\n+\n+```rust\n+use std::fmt;\n+\n+trait Graph {\n+    type N: fmt::Display;\n+    type E;\n+\n+    fn has_edge(&self, &Self::N, &Self::N) -> bool;\n+    fn edges(&self, &Self::N) -> Vec<Self::E>;\n+}\n+```\n+\n+## Implementing associated types\n+\n+Just like any trait, traits that use associated types use the `impl` keyword to\n+provide implementations. Here's a simple implementation of Graph:\n+\n+```rust\n+# trait Graph {\n+#     type N;\n+#     type E;\n+#     fn has_edge(&self, &Self::N, &Self::N) -> bool;\n+#     fn edges(&self, &Self::N) -> Vec<Self::E>;\n+# }\n+struct Node;\n+\n+struct Edge;\n+\n+struct MyGraph;\n+\n+impl Graph for MyGraph {\n+    type N = Node;\n+    type E = Edge;\n+\n+    fn has_edge(&self, n1: &Node, n2: &Node) -> bool {\n+        true\n+    }\n+\n+    fn edges(&self, n: &Node) -> Vec<Edge> {\n+        Vec::new()\n+    }\n+}\n+```\n+\n+This silly implementation always returns `true` and an empty `Vec<Edge>`, but it\n+gives you an idea of how to implement this kind of thing. We first need three\n+`struct`s, one for the graph, one for the node, and one for the edge. If it made\n+more sense to use a different type, that would work as well, we're just going to\n+use `struct`s for all three here.\n+\n+Next is the `impl` line, which is just like implementing any other trait.\n+\n+From here, we use `=` to define our associated types. The name the trait uses\n+goes on the left of the `=`, and the concrete type we're `impl`ementing this\n+for goes on the right. Finally, we use the concrete types in our function\n+declarations.\n+\n+## Trait objects with associated types\n+\n+There\u2019s one more bit of syntax we should talk about: trait objects. If you\n+try to create a trait object from an associated type, like this:\n+\n+```rust,ignore\n+# trait Graph {\n+#     type N;\n+#     type E;\n+#     fn has_edge(&self, &Self::N, &Self::N) -> bool;\n+#     fn edges(&self, &Self::N) -> Vec<Self::E>;\n+# }\n+# struct Node;\n+# struct Edge;\n+# struct MyGraph;\n+# impl Graph for MyGraph {\n+#     type N = Node;\n+#     type E = Edge;\n+#     fn has_edge(&self, n1: &Node, n2: &Node) -> bool {\n+#         true\n+#     }\n+#     fn edges(&self, n: &Node) -> Vec<Edge> {\n+#         Vec::new()\n+#     }\n+# }\n+let graph = MyGraph;\n+let obj = Box::new(graph) as Box<Graph>;\n+```\n+\n+You\u2019ll get two errors:\n+\n+```text\n+error: the value of the associated type `E` (from the trait `main::Graph`) must\n+be specified [E0191]\n+let obj = Box::new(graph) as Box<Graph>;\n+          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+24:44 error: the value of the associated type `N` (from the trait\n+`main::Graph`) must be specified [E0191]\n+let obj = Box::new(graph) as Box<Graph>;\n+          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+```\n+\n+We can\u2019t create a trait object like this, becuase we don\u2019t know the associated\n+types. Instead, we can write this:\n+\n+```rust\n+# trait Graph {\n+#     type N;\n+#     type E;\n+#     fn has_edge(&self, &Self::N, &Self::N) -> bool;\n+#     fn edges(&self, &Self::N) -> Vec<Self::E>;\n+# }\n+# struct Node;\n+# struct Edge;\n+# struct MyGraph;\n+# impl Graph for MyGraph {\n+#     type N = Node;\n+#     type E = Edge;\n+#     fn has_edge(&self, n1: &Node, n2: &Node) -> bool {\n+#         true\n+#     }\n+#     fn edges(&self, n: &Node) -> Vec<Edge> {\n+#         Vec::new()\n+#     }\n+# }\n+let graph = MyGraph;\n+let obj = Box::new(graph) as Box<Graph<N=Node, E=Edge>>;\n+```\n+\n+The `N=Node` syntax allows us to provide a concrete type, `Node`, for the `N`\n+type parameter. Same with `E=Edge`. If we didn\u2019t proide this constraint, we\n+couldn\u2019t be sure which `impl` to match this trait object to."}]}