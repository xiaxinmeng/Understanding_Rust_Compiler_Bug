{"sha": "3a20dda7eacf84faa64be0031c67e2169928962f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhMjBkZGE3ZWFjZjg0ZmFhNjRiZTAwMzFjNjdlMjE2OTkyODk2MmY=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-05T12:57:27Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-05T13:17:31Z"}, "message": "Get external interfaces / impls working\n\nIssue #1227", "tree": {"sha": "60d68fa16d378d7c7122a943f63964a835b49187", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60d68fa16d378d7c7122a943f63964a835b49187"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a20dda7eacf84faa64be0031c67e2169928962f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a20dda7eacf84faa64be0031c67e2169928962f", "html_url": "https://github.com/rust-lang/rust/commit/3a20dda7eacf84faa64be0031c67e2169928962f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a20dda7eacf84faa64be0031c67e2169928962f/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38c3bd9057b4fe0dace2da9d8925038fc1aaf5b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/38c3bd9057b4fe0dace2da9d8925038fc1aaf5b4", "html_url": "https://github.com/rust-lang/rust/commit/38c3bd9057b4fe0dace2da9d8925038fc1aaf5b4"}], "stats": {"total": 261, "additions": 152, "deletions": 109}, "files": [{"sha": "db415d5d31a4239b93580b76ef9f4e21700ad6cb", "filename": "src/comp/metadata/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a20dda7eacf84faa64be0031c67e2169928962f/src%2Fcomp%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a20dda7eacf84faa64be0031c67e2169928962f/src%2Fcomp%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcommon.rs?ref=3a20dda7eacf84faa64be0031c67e2169928962f", "patch": "@@ -66,8 +66,9 @@ const tag_crate_hash: uint = 0x28u;\n \n const tag_mod_impl: uint = 0x30u;\n \n-const tag_impl_method: uint = 0x31u;\n+const tag_item_method: uint = 0x31u;\n const tag_impl_iface: uint = 0x32u;\n+const tag_impl_iface_did: uint = 0x33u;\n \n // djb's cdb hashes.\n fn hash_node_id(&&node_id: int) -> uint { ret 177573u ^ (node_id as uint); }"}, {"sha": "364dd7aef21f2a411968fb439c7e01461fc5e161", "filename": "src/comp/metadata/csearch.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3a20dda7eacf84faa64be0031c67e2169928962f/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a20dda7eacf84faa64be0031c67e2169928962f/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcsearch.rs?ref=3a20dda7eacf84faa64be0031c67e2169928962f", "patch": "@@ -10,7 +10,7 @@ export get_type_param_count;\n export lookup_defs;\n export get_tag_variants;\n export get_impls_for_mod;\n-export get_impl_methods;\n+export get_iface_methods;\n export get_type;\n export get_item_name;\n export get_impl_iface;\n@@ -66,33 +66,23 @@ fn get_tag_variants(tcx: ty::ctxt, def: ast::def_id) -> [ty::variant_info] {\n \n fn get_impls_for_mod(cstore: cstore::cstore, def: ast::def_id,\n                      name: option::t<ast::ident>)\n-    -> [@middle::resolve::_impl] {\n+    -> @[@middle::resolve::_impl] {\n     let cdata = cstore::get_crate_data(cstore, def.crate).data;\n-    let result = [];\n-    for did in decoder::get_impls_for_mod(cdata, def.node, def.crate) {\n-        let nm = decoder::lookup_item_name(cdata, did.node);\n-        if alt name { some(n) { n == nm } none. { true } } {\n-            result += [@{did: did,\n-                         iface_did: none::<ast::def_id>, // FIXME[impl]\n-                         ident: nm,\n-                         methods: decoder::lookup_impl_methods(\n-                             cdata, did.node, did.crate)}];\n-        }\n-    }\n-    result\n+    let resolver = bind translate_def_id(cstore, def.crate, _);\n+    decoder::get_impls_for_mod(cdata, def, name, resolver)\n }\n \n-fn get_impl_methods(cstore: cstore::cstore, def: ast::def_id)\n-    -> [@middle::resolve::method_info] {\n+fn get_iface_methods(tcx: ty::ctxt, def: ast::def_id) -> @[ty::method] {\n+    let cstore = tcx.sess.get_cstore();\n     let cdata = cstore::get_crate_data(cstore, def.crate).data;\n-    decoder::lookup_impl_methods(cdata, def.node, def.crate)\n+    let resolver = bind translate_def_id(cstore, def.crate, _);\n+    decoder::get_iface_methods(cdata, def, tcx, resolver)\n }\n \n fn get_type(tcx: ty::ctxt, def: ast::def_id) -> ty::ty_param_bounds_and_ty {\n     let cstore = tcx.sess.get_cstore();\n-    let cnum = def.crate;\n-    let cdata = cstore::get_crate_data(cstore, cnum).data;\n-    let resolver = bind translate_def_id(cstore, cnum, _);\n+    let cdata = cstore::get_crate_data(cstore, def.crate).data;\n+    let resolver = bind translate_def_id(cstore, def.crate, _);\n     decoder::get_type(cdata, def, tcx, resolver)\n }\n "}, {"sha": "95bd8e5811df739470171a9484381a703a5bab70", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 72, "deletions": 49, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/3a20dda7eacf84faa64be0031c67e2169928962f/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a20dda7eacf84faa64be0031c67e2169928962f/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=3a20dda7eacf84faa64be0031c67e2169928962f", "patch": "@@ -26,7 +26,7 @@ export get_crate_deps;\n export get_crate_hash;\n export external_resolver;\n export get_impls_for_mod;\n-export lookup_impl_methods;\n+export get_iface_methods;\n // A function that takes a def_id relative to the crate being searched and\n // returns a def_id relative to the compilation environment, i.e. if we hit a\n // def_id for an item defined in another crate, somebody needs to figure out\n@@ -105,38 +105,52 @@ fn parse_external_def_id(this_cnum: ast::crate_num,\n     } else { ret extres(external_def_id); }\n }\n \n+fn doc_type(doc: ebml::doc, this_cnum: ast::crate_num, tcx: ty::ctxt,\n+            extres: external_resolver) -> ty::t {\n+    let tp = ebml::get_doc(doc, tag_items_data_item_type);\n+    let def_parser = bind parse_external_def_id(this_cnum, extres, _);\n+    parse_ty_data(tp.data, this_cnum, tp.start, def_parser, tcx)\n+}\n+\n fn item_type(item: ebml::doc, this_cnum: ast::crate_num, tcx: ty::ctxt,\n              extres: external_resolver) -> ty::t {\n-    let tp = ebml::get_doc(item, tag_items_data_item_type);\n-    let def_parser = bind parse_external_def_id(this_cnum, extres, _);\n-    let t = parse_ty_data(item.data, this_cnum, tp.start, tp.end - tp.start,\n-                          def_parser, tcx);\n+    let t = doc_type(item, this_cnum, tcx, extres);\n     if family_names_type(item_family(item)) {\n-        t = ty::mk_named(tcx, t, @item_name(item));\n-    }\n-    t\n+        ty::mk_named(tcx, t, @item_name(item))\n+    } else { t }\n }\n \n fn item_impl_iface(item: ebml::doc, this_cnum: ast::crate_num, tcx: ty::ctxt,\n                    extres: external_resolver) -> option::t<ty::t> {\n     let result = none;\n     ebml::tagged_docs(item, tag_impl_iface) {|ity|\n         let def_parser = bind parse_external_def_id(this_cnum, extres, _);\n-        let t = parse_ty_data(ity.data, this_cnum, ity.start,\n-                              ity.end - ity.start, def_parser, tcx);\n+        let t = parse_ty_data(ity.data, this_cnum, ity.start, def_parser,\n+                              tcx);\n         result = some(t);\n     }\n     result\n }\n \n+fn item_impl_iface_did(item: ebml::doc, this_cnum: ast::crate_num,\n+                       extres: external_resolver)\n+    -> option::t<ast::def_id> {\n+    let result = none;\n+    ebml::tagged_docs(item, tag_impl_iface_did) {|doc|\n+        let s = str::unsafe_from_bytes(ebml::doc_data(doc));\n+        result = some(parse_external_def_id(this_cnum, extres, s));\n+    }\n+    result\n+}\n+\n fn item_ty_param_bounds(item: ebml::doc, this_cnum: ast::crate_num,\n                         tcx: ty::ctxt, extres: external_resolver)\n     -> @[ty::param_bounds] {\n     let bounds = [];\n     let def_parser = bind parse_external_def_id(this_cnum, extres, _);\n     ebml::tagged_docs(item, tag_items_data_item_ty_param_bounds) {|p|\n-        bounds += [tydecode::parse_bounds_data(@ebml::doc_data(p), this_cnum,\n-                                               def_parser, tcx)];\n+        bounds += [tydecode::parse_bounds_data(p.data, p.start,\n+                                               this_cnum, def_parser, tcx)];\n     }\n     @bounds\n }\n@@ -211,18 +225,17 @@ fn lookup_def(cnum: ast::crate_num, data: @[u8], did_: ast::def_id) ->\n             tid = {crate: cnum, node: tid.node};\n             ast::def_variant(tid, did)\n           }\n+          'I' { ast::def_ty(did) }\n         };\n     ret def;\n }\n \n fn get_type(data: @[u8], def: ast::def_id, tcx: ty::ctxt,\n             extres: external_resolver) -> ty::ty_param_bounds_and_ty {\n-    let this_cnum = def.crate;\n-    let node_id = def.node;\n-    let item = lookup_item(node_id, data);\n-    let t = item_type(item, this_cnum, tcx, extres);\n+    let item = lookup_item(def.node, data);\n+    let t = item_type(item, def.crate, tcx, extres);\n     let tp_bounds = if family_has_type_params(item_family(item)) {\n-        item_ty_param_bounds(item, this_cnum, tcx, extres)\n+        item_ty_param_bounds(item, def.crate, tcx, extres)\n     } else { @[] };\n     ret {bounds: tp_bounds, ty: t};\n }\n@@ -264,51 +277,59 @@ fn get_tag_variants(_data: @[u8], def: ast::def_id, tcx: ty::ctxt,\n     ret infos;\n }\n \n-fn get_impls_for_mod(data: @[u8], node: ast::node_id, cnum: ast::crate_num)\n-    -> [ast::def_id] {\n-    let mod_item = lookup_item(node, data), result = [];\n-    ebml::tagged_docs(mod_item, tag_mod_impl) {|doc|\n-        let did = parse_def_id(ebml::doc_data(doc));\n-        result += [{crate: cnum with did}];\n-    }\n-    result\n-}\n-\n-fn lookup_impl_methods(data: @[u8], node: ast::node_id, cnum: ast::crate_num)\n+fn item_impl_methods(data: @[u8], item: ebml::doc, base_tps: uint)\n     -> [@middle::resolve::method_info] {\n-    let impl_item = lookup_item(node, data), rslt = [];\n-    let base_tps = item_ty_param_count(impl_item);\n-    ebml::tagged_docs(impl_item, tag_impl_method) {|doc|\n+    let rslt = [];\n+    ebml::tagged_docs(item, tag_item_method) {|doc|\n         let m_did = parse_def_id(ebml::doc_data(doc));\n         let mth_item = lookup_item(m_did.node, data);\n-        rslt += [@{did: {crate: cnum, node: m_did.node},\n+        rslt += [@{did: m_did,\n                    n_tps: item_ty_param_count(mth_item) - base_tps,\n                    ident: item_name(mth_item)}];\n     }\n     rslt\n }\n \n+fn get_impls_for_mod(data: @[u8], m_def: ast::def_id,\n+                     name: option::t<ast::ident>, extres: external_resolver)\n+    -> @[@middle::resolve::_impl] {\n+    let mod_item = lookup_item(m_def.node, data), result = [];\n+    ebml::tagged_docs(mod_item, tag_mod_impl) {|doc|\n+        let did = parse_external_def_id(\n+            m_def.crate, extres, str::unsafe_from_bytes(ebml::doc_data(doc)));\n+        let item = lookup_item(did.node, data), nm = item_name(item);\n+        if alt name { some(n) { n == nm } none. { true } } {\n+            let base_tps = item_ty_param_count(doc);\n+            let i_did = item_impl_iface_did(item, m_def.crate, extres);\n+            result += [@{did: did, iface_did: i_did, ident: nm,\n+                         methods: item_impl_methods(data, doc, base_tps)}];\n+        }\n+    }\n+    @result\n+}\n+\n+fn get_iface_methods(data: @[u8], def: ast::def_id, tcx: ty::ctxt,\n+                     extres: external_resolver) -> @[ty::method] {\n+    let item = lookup_item(def.node, data), result = [];\n+    ebml::tagged_docs(item, tag_item_method) {|mth|\n+        let bounds = item_ty_param_bounds(mth, def.crate, tcx, extres);\n+        let name = item_name(mth);\n+        let ty = doc_type(mth, def.crate, tcx, extres);\n+        let fty = alt ty::struct(tcx, ty) { ty::ty_fn(f) { f } };\n+        result += [{ident: name, tps: bounds, fty: fty}];\n+    }\n+    @result\n+}\n+\n fn family_has_type_params(fam_ch: u8) -> bool {\n-    ret alt fam_ch as char {\n-          'c' { false }\n-          'f' { true }\n-          'u' { true }\n-          'p' { true }\n-          'F' { true }\n-          'U' { true }\n-          'P' { true }\n-          'y' { true }\n-          't' { true }\n-          'T' { false }\n-          'm' { false }\n-          'n' { false }\n-          'v' { true }\n-          'i' { true }\n-        };\n+    alt fam_ch as char {\n+      'c' | 'T' | 'm' | 'n' { false }\n+      'f' | 'u' | 'p' | 'F' | 'U' | 'P' | 'y' | 't' | 'v' | 'i' | 'I' { true }\n+    }\n }\n \n fn family_names_type(fam_ch: u8) -> bool {\n-    alt fam_ch as char { 'y' | 't' { true } _ { false } }\n+    alt fam_ch as char { 'y' | 't' | 'I' { true } _ { false } }\n }\n \n fn read_path(d: ebml::doc) -> {path: str, pos: uint} {\n@@ -339,6 +360,8 @@ fn item_family_to_str(fam: u8) -> str {\n       'm' { ret \"mod\"; }\n       'n' { ret \"native mod\"; }\n       'v' { ret \"tag\"; }\n+      'i' { ret \"impl\"; }\n+      'I' { ret \"iface\"; }\n     }\n }\n "}, {"sha": "8c564ec627aeb60d29151f6a45b240a65e810d37", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 40, "deletions": 14, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/3a20dda7eacf84faa64be0031c67e2169928962f/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a20dda7eacf84faa64be0031c67e2169928962f/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=3a20dda7eacf84faa64be0031c67e2169928962f", "patch": "@@ -277,12 +277,13 @@ fn encode_info_for_mod(ebml_w: ebml::writer, md: _mod,\n \n fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n                         &index: [entry<int>]) {\n+    let tcx = ecx.ccx.tcx;\n     alt item.node {\n       item_const(_, _) {\n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'c' as u8);\n-        encode_type(ecx, ebml_w, node_id_to_monotype(ecx.ccx.tcx, item.id));\n+        encode_type(ecx, ebml_w, node_id_to_monotype(tcx, item.id));\n         encode_symbol(ecx, ebml_w, item.id);\n         ebml::end_tag(ebml_w);\n       }\n@@ -296,7 +297,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n                         impure_fn. { 'f' }\n                       } as u8);\n         encode_type_param_bounds(ebml_w, ecx, tps);\n-        encode_type(ecx, ebml_w, node_id_to_monotype(ecx.ccx.tcx, item.id));\n+        encode_type(ecx, ebml_w, node_id_to_monotype(tcx, item.id));\n         encode_symbol(ecx, ebml_w, item.id);\n         ebml::end_tag(ebml_w);\n       }\n@@ -315,7 +316,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'y' as u8);\n         encode_type_param_bounds(ebml_w, ecx, tps);\n-        encode_type(ecx, ebml_w, node_id_to_monotype(ecx.ccx.tcx, item.id));\n+        encode_type(ecx, ebml_w, node_id_to_monotype(tcx, item.id));\n         encode_name(ebml_w, item.ident);\n         ebml::end_tag(ebml_w);\n       }\n@@ -324,7 +325,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 't' as u8);\n         encode_type_param_bounds(ebml_w, ecx, tps);\n-        encode_type(ecx, ebml_w, node_id_to_monotype(ecx.ccx.tcx, item.id));\n+        encode_type(ecx, ebml_w, node_id_to_monotype(tcx, item.id));\n         encode_name(ebml_w, item.ident);\n         for v: variant in variants {\n             encode_variant_id(ebml_w, local_def(v.node.id));\n@@ -333,13 +334,13 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_tag_variant_info(ecx, ebml_w, item.id, variants, index, tps);\n       }\n       item_res(_, tps, _, _, ctor_id) {\n-        let fn_ty = node_id_to_monotype(ecx.ccx.tcx, ctor_id);\n+        let fn_ty = node_id_to_monotype(tcx, ctor_id);\n \n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(ctor_id));\n         encode_family(ebml_w, 'y' as u8);\n         encode_type_param_bounds(ebml_w, ecx, tps);\n-        encode_type(ecx, ebml_w, ty::ty_fn_ret(ecx.ccx.tcx, fn_ty));\n+        encode_type(ecx, ebml_w, ty::ty_fn_ret(tcx, fn_ty));\n         encode_name(ebml_w, item.ident);\n         encode_symbol(ecx, ebml_w, item.id);\n         ebml::end_tag(ebml_w);\n@@ -354,13 +355,13 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         ebml::end_tag(ebml_w);\n       }\n       item_obj(_, tps, ctor_id) {\n-        let fn_ty = node_id_to_monotype(ecx.ccx.tcx, ctor_id);\n+        let fn_ty = node_id_to_monotype(tcx, ctor_id);\n \n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'y' as u8);\n         encode_type_param_bounds(ebml_w, ecx, tps);\n-        encode_type(ecx, ebml_w, ty::ty_fn_ret(ecx.ccx.tcx, fn_ty));\n+        encode_type(ecx, ebml_w, ty::ty_fn_ret(tcx, fn_ty));\n         encode_name(ebml_w, item.ident);\n         ebml::end_tag(ebml_w);\n \n@@ -378,18 +379,26 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'i' as u8);\n         encode_type_param_bounds(ebml_w, ecx, tps);\n-        encode_type(ecx, ebml_w, node_id_to_monotype(ecx.ccx.tcx, item.id));\n+        encode_type(ecx, ebml_w, node_id_to_monotype(tcx, item.id));\n         encode_name(ebml_w, item.ident);\n         for m in methods {\n-            ebml::start_tag(ebml_w, tag_impl_method);\n+            ebml::start_tag(ebml_w, tag_item_method);\n             ebml_w.writer.write(str::bytes(def_to_str(local_def(m.id))));\n             ebml::end_tag(ebml_w);\n         }\n         alt ifce {\n           some(_) {\n+            encode_symbol(ecx, ebml_w, item.id);\n+            let i_ty = ty::lookup_item_type(tcx, local_def(item.id)).ty;\n             ebml::start_tag(ebml_w, tag_impl_iface);\n-            write_type(ecx, ebml_w, ty::lookup_item_type(\n-                ecx.ccx.tcx, local_def(item.id)).ty);\n+            write_type(ecx, ebml_w, i_ty);\n+            ebml::end_tag(ebml_w);\n+            ebml::start_tag(ebml_w, tag_impl_iface_did);\n+            alt ty::struct(tcx, i_ty) {\n+              ty::ty_iface(did, _) {\n+                ebml_w.writer.write(str::bytes(def_to_str(did)));\n+              }\n+            }\n             ebml::end_tag(ebml_w);\n           }\n           _ {}\n@@ -403,13 +412,30 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n             encode_family(ebml_w, 'f' as u8);\n             encode_type_param_bounds(ebml_w, ecx, tps + m.tps);\n             encode_type(ecx, ebml_w,\n-                        node_id_to_monotype(ecx.ccx.tcx, m.id));\n+                        node_id_to_monotype(tcx, m.id));\n             encode_name(ebml_w, m.ident);\n             encode_symbol(ecx, ebml_w, m.id);\n             ebml::end_tag(ebml_w);\n         }\n       }\n-      item_iface(_, _) { /* FIXME[impl] */ }\n+      item_iface(tps, ms) {\n+        ebml::start_tag(ebml_w, tag_items_data_item);\n+        encode_def_id(ebml_w, local_def(item.id));\n+        encode_family(ebml_w, 'I' as u8);\n+        encode_type_param_bounds(ebml_w, ecx, tps);\n+        encode_type(ecx, ebml_w, node_id_to_monotype(tcx, item.id));\n+        encode_name(ebml_w, item.ident);\n+        let i = 0u;\n+        for mty in *ty::iface_methods(tcx, local_def(item.id)) {\n+            ebml::start_tag(ebml_w, tag_item_method);\n+            encode_name(ebml_w, mty.ident);\n+            encode_type_param_bounds(ebml_w, ecx, ms[i].tps);\n+            encode_type(ecx, ebml_w, ty::mk_fn(tcx, mty.fty));\n+            ebml::end_tag(ebml_w);\n+            i += 1u;\n+        }\n+        ebml::end_tag(ebml_w);\n+      }\n     }\n }\n "}, {"sha": "9e87a17537b1b69e8ca9049867d62a46e3970ec6", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3a20dda7eacf84faa64be0031c67e2169928962f/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a20dda7eacf84faa64be0031c67e2169928962f/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=3a20dda7eacf84faa64be0031c67e2169928962f", "patch": "@@ -19,11 +19,10 @@ export parse_bounds_data;\n // Callback to translate defs to strs or back:\n type str_def = fn@(str) -> ast::def_id;\n \n-type pstate =\n-    {data: @[u8], crate: int, mutable pos: uint, len: uint, tcx: ty::ctxt};\n+type pstate = {data: @[u8], crate: int, mutable pos: uint, tcx: ty::ctxt};\n \n fn peek(st: @pstate) -> u8 {\n-    if st.pos < vec::len(*st.data) { st.data[st.pos] } else { 0u8 }\n+    st.data[st.pos]\n }\n \n fn next(st: @pstate) -> u8 {\n@@ -47,10 +46,9 @@ fn parse_ident_(st: @pstate, _sd: str_def, is_last: fn@(char) -> bool) ->\n }\n \n \n-fn parse_ty_data(data: @[u8], crate_num: int, pos: uint, len: uint,\n-                 sd: str_def, tcx: ty::ctxt) -> ty::t {\n-    let st =\n-        @{data: data, crate: crate_num, mutable pos: pos, len: len, tcx: tcx};\n+fn parse_ty_data(data: @[u8], crate_num: int, pos: uint, sd: str_def,\n+                 tcx: ty::ctxt) -> ty::t {\n+    let st = @{data: data, crate: crate_num, mutable pos: pos, tcx: tcx};\n     parse_ty(st, sd)\n }\n \n@@ -295,7 +293,7 @@ fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n         alt st.tcx.rcache.find({cnum: st.crate, pos: pos, len: len}) {\n           some(tt) { ret tt; }\n           none. {\n-            let ps = @{pos: pos, len: len with *st};\n+            let ps = @{pos: pos with *st};\n             let tt = parse_ty(ps, sd);\n             st.tcx.rcache.insert({cnum: st.crate, pos: pos, len: len}, tt);\n             ret tt;\n@@ -381,7 +379,7 @@ fn parse_ty_fn(st: @pstate, sd: str_def) -> ty::fn_ty {\n // Rust metadata parsing\n fn parse_def_id(buf: [u8]) -> ast::def_id {\n     let colon_idx = 0u;\n-    let len = vec::len::<u8>(buf);\n+    let len = vec::len(buf);\n     while colon_idx < len && buf[colon_idx] != ':' as u8 { colon_idx += 1u; }\n     if colon_idx == len {\n         #error(\"didn't find ':' when parsing def id\");\n@@ -400,20 +398,21 @@ fn parse_def_id(buf: [u8]) -> ast::def_id {\n     ret {crate: crate_num, node: def_num};\n }\n \n-fn parse_bounds_data(data: @[u8], crate_num: int, sd: str_def, tcx: ty::ctxt)\n+fn parse_bounds_data(data: @[u8], start: uint,\n+                     crate_num: int, sd: str_def, tcx: ty::ctxt)\n     -> @[ty::param_bound] {\n-    let st = @{data: data, crate: crate_num, mutable pos: 0u,\n-               len: vec::len(*data), tcx: tcx};\n+    let st = @{data: data, crate: crate_num, mutable pos: start, tcx: tcx};\n     parse_bounds(st, sd)\n }\n \n fn parse_bounds(st: @pstate, sd: str_def) -> @[ty::param_bound] {\n     let bounds = [];\n-    while peek(st) != 0u8 {\n+    while true {\n         bounds += [alt next(st) as char {\n           'S' { ty::bound_send }\n           'C' { ty::bound_copy }\n           'I' { ty::bound_iface(parse_ty(st, sd)) }\n+          '.' { break; }\n         }];\n     }\n     @bounds"}, {"sha": "2ba572154c55807c51f085bd13412047552e3fb3", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3a20dda7eacf84faa64be0031c67e2169928962f/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a20dda7eacf84faa64be0031c67e2169928962f/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=3a20dda7eacf84faa64be0031c67e2169928962f", "patch": "@@ -66,10 +66,8 @@ fn enc_ty(w: io::writer, cx: @ctxt, t: ty::t) {\n             let abbrev_len = 3u + estimate_sz(pos) + estimate_sz(len);\n             if abbrev_len < len {\n                 // I.e. it's actually an abbreviation.\n-\n-                let s =\n-                    \"#\" + uint::to_str(pos, 16u) + \":\" +\n-                        uint::to_str(len, 16u) + \"#\";\n+                let s = \"#\" + uint::to_str(pos, 16u) + \":\" +\n+                    uint::to_str(len, 16u) + \"#\";\n                 let a = {pos: pos, len: len, s: @s};\n                 abbrevs.insert(t, a);\n             }\n@@ -282,6 +280,7 @@ fn enc_bounds(w: io::writer, cx: @ctxt, bs: @[ty::param_bound]) {\n           }\n         }\n     }\n+    w.write_char('.');\n }\n \n //"}, {"sha": "01be1c4409f50223e0302a523c55a2987a6a30d9", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a20dda7eacf84faa64be0031c67e2169928962f/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a20dda7eacf84faa64be0031c67e2169928962f/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=3a20dda7eacf84faa64be0031c67e2169928962f", "patch": "@@ -1827,7 +1827,7 @@ fn find_impls_in_mod(e: env, m: def, &impls: [@_impl],\n                 }\n                 @tmp\n             } else {\n-                @csearch::get_impls_for_mod(e.cstore, defid, name)\n+                csearch::get_impls_for_mod(e.sess.get_cstore(), defid, name)\n             };\n             e.impl_cache.insert(defid, cached);\n           }"}, {"sha": "4325f0af52b66dec851972269e9d4220dc24fb01", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3a20dda7eacf84faa64be0031c67e2169928962f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a20dda7eacf84faa64be0031c67e2169928962f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=3a20dda7eacf84faa64be0031c67e2169928962f", "patch": "@@ -5039,8 +5039,8 @@ fn trans_item(cx: @local_ctxt, item: ast::item) {\n                  with *extend_path(cx, item.ident)};\n         trans_obj(sub_cx, item.span, ob, ctor_id, tps);\n       }\n-      ast::item_impl(tps, ifce, _, ms) {\n-        trans_impl::trans_impl(cx, item.ident, ms, item.id, tps, ifce);\n+      ast::item_impl(tps, _, _, ms) {\n+        trans_impl::trans_impl(cx, item.ident, ms, item.id, tps);\n       }\n       ast::item_res(decl, tps, body, dtor_id, ctor_id) {\n         trans_res_ctor(cx, item.span, decl, ctor_id, tps);\n@@ -5436,6 +5436,7 @@ fn trans_constant(ccx: @crate_ctxt, it: @ast::item, &&pt: [str],\n         llvm::LLVMSetInitializer(vt_gvar, tbl);\n         llvm::LLVMSetGlobalConstant(vt_gvar, True);\n         ccx.item_ids.insert(it.id, vt_gvar);\n+        ccx.item_symbols.insert(it.id, s);\n       }\n       _ { }\n     }"}, {"sha": "bddfbb03e6e417a8210c2a8973fe168e22e9e3f3", "filename": "src/comp/middle/trans_impl.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3a20dda7eacf84faa64be0031c67e2169928962f/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a20dda7eacf84faa64be0031c67e2169928962f/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs?ref=3a20dda7eacf84faa64be0031c67e2169928962f", "patch": "@@ -3,13 +3,13 @@ import trans_common::*;\n import trans_build::*;\n import option::{some, none};\n import syntax::{ast, ast_util};\n+import metadata::csearch;\n import back::link;\n import lib::llvm;\n import llvm::llvm::{ValueRef, TypeRef, LLVMGetParam};\n \n fn trans_impl(cx: @local_ctxt, name: ast::ident, methods: [@ast::method],\n-              id: ast::node_id, tps: [ast::ty_param],\n-              _ifce: option::t<@ast::ty>) {\n+              id: ast::node_id, tps: [ast::ty_param]) {\n     let sub_cx = extend_path(cx, name);\n     for m in methods {\n         alt cx.ccx.item_ids.find(m.id) {\n@@ -136,8 +136,12 @@ fn get_dict(bcx: @block_ctxt, origin: typeck::dict_origin) -> result {\n     let bcx = bcx, ccx = bcx_ccx(bcx);\n     alt origin {\n       typeck::dict_static(impl_did, tys, sub_origins) {\n-        assert impl_did.crate == ast::local_crate; // FIXME[impl]\n-        let vtable = ccx.item_ids.get(impl_did.node);\n+        let vtable = if impl_did.crate == ast::local_crate {\n+            ccx.item_ids.get(impl_did.node)\n+        } else {\n+            let name = csearch::get_symbol(ccx.sess.get_cstore(), impl_did);\n+            get_extern_const(ccx.externs, ccx.llmod, name, T_ptr(T_i8()))\n+        };\n         let impl_params = ty::lookup_item_type(ccx.tcx, impl_did).bounds;\n         let ptrs = [vtable], i = 0u, origin = 0u, ti = none;\n         for param in *impl_params {"}, {"sha": "76a3591cd183816d61b21f2eba03dd0879274f92", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a20dda7eacf84faa64be0031c67e2169928962f/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a20dda7eacf84faa64be0031c67e2169928962f/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=3a20dda7eacf84faa64be0031c67e2169928962f", "patch": "@@ -2665,7 +2665,7 @@ fn iface_methods(cx: ctxt, id: ast::def_id) -> @[method] {\n     }\n     // Local interfaces are supposed to have been added explicitly.\n     assert id.crate != ast::local_crate;\n-    let result = @[]; // FIXME[impl]\n+    let result = csearch::get_iface_methods(cx, id);\n     cx.iface_method_cache.insert(id, result);\n     result\n }"}]}