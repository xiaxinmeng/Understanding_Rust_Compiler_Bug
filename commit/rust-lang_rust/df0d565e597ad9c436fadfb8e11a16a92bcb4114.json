{"sha": "df0d565e597ad9c436fadfb8e11a16a92bcb4114", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmMGQ1NjVlNTk3YWQ5YzQzNmZhZGZiOGUxMWExNmE5MmJjYjQxMTQ=", "commit": {"author": {"name": "Hirochika Matsumoto", "email": "matsujika@gmail.com", "date": "2020-10-02T09:21:17Z"}, "committer": {"name": "Hirochika Matsumoto", "email": "matsujika@gmail.com", "date": "2020-11-17T16:28:37Z"}, "message": "Move `find_all_ret_expressions` into `utils`", "tree": {"sha": "ae11222486ca61cc559b97ec21c6135b2a72eb57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae11222486ca61cc559b97ec21c6135b2a72eb57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df0d565e597ad9c436fadfb8e11a16a92bcb4114", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df0d565e597ad9c436fadfb8e11a16a92bcb4114", "html_url": "https://github.com/rust-lang/rust/commit/df0d565e597ad9c436fadfb8e11a16a92bcb4114", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df0d565e597ad9c436fadfb8e11a16a92bcb4114/comments", "author": {"login": "hkmatsumoto", "id": 57856193, "node_id": "MDQ6VXNlcjU3ODU2MTkz", "avatar_url": "https://avatars.githubusercontent.com/u/57856193?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hkmatsumoto", "html_url": "https://github.com/hkmatsumoto", "followers_url": "https://api.github.com/users/hkmatsumoto/followers", "following_url": "https://api.github.com/users/hkmatsumoto/following{/other_user}", "gists_url": "https://api.github.com/users/hkmatsumoto/gists{/gist_id}", "starred_url": "https://api.github.com/users/hkmatsumoto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hkmatsumoto/subscriptions", "organizations_url": "https://api.github.com/users/hkmatsumoto/orgs", "repos_url": "https://api.github.com/users/hkmatsumoto/repos", "events_url": "https://api.github.com/users/hkmatsumoto/events{/privacy}", "received_events_url": "https://api.github.com/users/hkmatsumoto/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hkmatsumoto", "id": 57856193, "node_id": "MDQ6VXNlcjU3ODU2MTkz", "avatar_url": "https://avatars.githubusercontent.com/u/57856193?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hkmatsumoto", "html_url": "https://github.com/hkmatsumoto", "followers_url": "https://api.github.com/users/hkmatsumoto/followers", "following_url": "https://api.github.com/users/hkmatsumoto/following{/other_user}", "gists_url": "https://api.github.com/users/hkmatsumoto/gists{/gist_id}", "starred_url": "https://api.github.com/users/hkmatsumoto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hkmatsumoto/subscriptions", "organizations_url": "https://api.github.com/users/hkmatsumoto/orgs", "repos_url": "https://api.github.com/users/hkmatsumoto/repos", "events_url": "https://api.github.com/users/hkmatsumoto/events{/privacy}", "received_events_url": "https://api.github.com/users/hkmatsumoto/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b55f3fec98fa8fd4ca15edbf1cc1ab86d22f08f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b55f3fec98fa8fd4ca15edbf1cc1ab86d22f08f", "html_url": "https://github.com/rust-lang/rust/commit/6b55f3fec98fa8fd4ca15edbf1cc1ab86d22f08f"}], "stats": {"total": 383, "additions": 133, "deletions": 250}, "files": [{"sha": "540a1484a8558292a92ad7ea0222eabce8892d26", "filename": "clippy_lints/src/methods/bind_instead_of_map.rs", "status": "modified", "additions": 1, "deletions": 124, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/df0d565e597ad9c436fadfb8e11a16a92bcb4114/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df0d565e597ad9c436fadfb8e11a16a92bcb4114/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs?ref=df0d565e597ad9c436fadfb8e11a16a92bcb4114", "patch": "@@ -1,14 +1,12 @@\n use super::{contains_return, BIND_INSTEAD_OF_MAP};\n use crate::utils::{\n     in_macro, match_qpath, match_type, method_calls, multispan_sugg_with_applicability, paths, remove_blocks, snippet,\n-    snippet_with_macro_callsite, span_lint_and_sugg, span_lint_and_then,\n+    snippet_with_macro_callsite, span_lint_and_sugg, span_lint_and_then, visitors::find_all_ret_expressions,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::intravisit::{self, Visitor};\n use rustc_lint::LateContext;\n-use rustc_middle::hir::map::Map;\n use rustc_span::Span;\n \n pub(crate) struct OptionAndThenSome;\n@@ -193,124 +191,3 @@ pub(crate) trait BindInsteadOfMap {\n         }\n     }\n }\n-\n-/// returns `true` if expr contains match expr desugared from try\n-fn contains_try(expr: &hir::Expr<'_>) -> bool {\n-    struct TryFinder {\n-        found: bool,\n-    }\n-\n-    impl<'hir> intravisit::Visitor<'hir> for TryFinder {\n-        type Map = Map<'hir>;\n-\n-        fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n-            intravisit::NestedVisitorMap::None\n-        }\n-\n-        fn visit_expr(&mut self, expr: &'hir hir::Expr<'hir>) {\n-            if self.found {\n-                return;\n-            }\n-            match expr.kind {\n-                hir::ExprKind::Match(_, _, hir::MatchSource::TryDesugar) => self.found = true,\n-                _ => intravisit::walk_expr(self, expr),\n-            }\n-        }\n-    }\n-\n-    let mut visitor = TryFinder { found: false };\n-    visitor.visit_expr(expr);\n-    visitor.found\n-}\n-\n-fn find_all_ret_expressions<'hir, F>(_cx: &LateContext<'_>, expr: &'hir hir::Expr<'hir>, callback: F) -> bool\n-where\n-    F: FnMut(&'hir hir::Expr<'hir>) -> bool,\n-{\n-    struct RetFinder<F> {\n-        in_stmt: bool,\n-        failed: bool,\n-        cb: F,\n-    }\n-\n-    struct WithStmtGuarg<'a, F> {\n-        val: &'a mut RetFinder<F>,\n-        prev_in_stmt: bool,\n-    }\n-\n-    impl<F> RetFinder<F> {\n-        fn inside_stmt(&mut self, in_stmt: bool) -> WithStmtGuarg<'_, F> {\n-            let prev_in_stmt = std::mem::replace(&mut self.in_stmt, in_stmt);\n-            WithStmtGuarg {\n-                val: self,\n-                prev_in_stmt,\n-            }\n-        }\n-    }\n-\n-    impl<F> std::ops::Deref for WithStmtGuarg<'_, F> {\n-        type Target = RetFinder<F>;\n-\n-        fn deref(&self) -> &Self::Target {\n-            self.val\n-        }\n-    }\n-\n-    impl<F> std::ops::DerefMut for WithStmtGuarg<'_, F> {\n-        fn deref_mut(&mut self) -> &mut Self::Target {\n-            self.val\n-        }\n-    }\n-\n-    impl<F> Drop for WithStmtGuarg<'_, F> {\n-        fn drop(&mut self) {\n-            self.val.in_stmt = self.prev_in_stmt;\n-        }\n-    }\n-\n-    impl<'hir, F: FnMut(&'hir hir::Expr<'hir>) -> bool> intravisit::Visitor<'hir> for RetFinder<F> {\n-        type Map = Map<'hir>;\n-\n-        fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n-            intravisit::NestedVisitorMap::None\n-        }\n-\n-        fn visit_stmt(&mut self, stmt: &'hir hir::Stmt<'_>) {\n-            intravisit::walk_stmt(&mut *self.inside_stmt(true), stmt)\n-        }\n-\n-        fn visit_expr(&mut self, expr: &'hir hir::Expr<'_>) {\n-            if self.failed {\n-                return;\n-            }\n-            if self.in_stmt {\n-                match expr.kind {\n-                    hir::ExprKind::Ret(Some(expr)) => self.inside_stmt(false).visit_expr(expr),\n-                    _ => intravisit::walk_expr(self, expr),\n-                }\n-            } else {\n-                match expr.kind {\n-                    hir::ExprKind::Match(cond, arms, _) => {\n-                        self.inside_stmt(true).visit_expr(cond);\n-                        for arm in arms {\n-                            self.visit_expr(arm.body);\n-                        }\n-                    },\n-                    hir::ExprKind::Block(..) => intravisit::walk_expr(self, expr),\n-                    hir::ExprKind::Ret(Some(expr)) => self.visit_expr(expr),\n-                    _ => self.failed |= !(self.cb)(expr),\n-                }\n-            }\n-        }\n-    }\n-\n-    !contains_try(expr) && {\n-        let mut ret_finder = RetFinder {\n-            in_stmt: false,\n-            failed: false,\n-            cb: callback,\n-        };\n-        ret_finder.visit_expr(expr);\n-        !ret_finder.failed\n-    }\n-}"}, {"sha": "de13301381e2bfd91871f9b4d213c7de8ce6c28a", "filename": "clippy_lints/src/unnecessary_wrap.rs", "status": "modified", "additions": 6, "deletions": 126, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/df0d565e597ad9c436fadfb8e11a16a92bcb4114/clippy_lints%2Fsrc%2Funnecessary_wrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df0d565e597ad9c436fadfb8e11a16a92bcb4114/clippy_lints%2Fsrc%2Funnecessary_wrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_wrap.rs?ref=df0d565e597ad9c436fadfb8e11a16a92bcb4114", "patch": "@@ -1,10 +1,13 @@\n-use crate::utils::{is_type_diagnostic_item, match_qpath, paths, return_ty, snippet, span_lint_and_then};\n+use crate::utils::{\n+    is_type_diagnostic_item, match_qpath, paths, return_ty, snippet, span_lint_and_then,\n+    visitors::find_all_ret_expressions,\n+};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::intravisit::{FnKind, Visitor};\n+use rustc_hir::intravisit::FnKind;\n use rustc_hir::*;\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::{hir::map::Map, ty::subst::GenericArgKind};\n+use rustc_middle::ty::subst::GenericArgKind;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::Span;\n \n@@ -125,126 +128,3 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryWrap {\n         }\n     }\n }\n-\n-// code below is copied from `bind_instead_of_map`\n-\n-fn find_all_ret_expressions<'hir, F>(_cx: &LateContext<'_>, expr: &'hir Expr<'hir>, callback: F) -> bool\n-where\n-    F: FnMut(&'hir Expr<'hir>) -> bool,\n-{\n-    struct RetFinder<F> {\n-        in_stmt: bool,\n-        failed: bool,\n-        cb: F,\n-    }\n-\n-    struct WithStmtGuarg<'a, F> {\n-        val: &'a mut RetFinder<F>,\n-        prev_in_stmt: bool,\n-    }\n-\n-    impl<F> RetFinder<F> {\n-        fn inside_stmt(&mut self, in_stmt: bool) -> WithStmtGuarg<'_, F> {\n-            let prev_in_stmt = std::mem::replace(&mut self.in_stmt, in_stmt);\n-            WithStmtGuarg {\n-                val: self,\n-                prev_in_stmt,\n-            }\n-        }\n-    }\n-\n-    impl<F> std::ops::Deref for WithStmtGuarg<'_, F> {\n-        type Target = RetFinder<F>;\n-\n-        fn deref(&self) -> &Self::Target {\n-            self.val\n-        }\n-    }\n-\n-    impl<F> std::ops::DerefMut for WithStmtGuarg<'_, F> {\n-        fn deref_mut(&mut self) -> &mut Self::Target {\n-            self.val\n-        }\n-    }\n-\n-    impl<F> Drop for WithStmtGuarg<'_, F> {\n-        fn drop(&mut self) {\n-            self.val.in_stmt = self.prev_in_stmt;\n-        }\n-    }\n-\n-    impl<'hir, F: FnMut(&'hir Expr<'hir>) -> bool> intravisit::Visitor<'hir> for RetFinder<F> {\n-        type Map = Map<'hir>;\n-\n-        fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n-            intravisit::NestedVisitorMap::None\n-        }\n-\n-        fn visit_stmt(&mut self, stmt: &'hir Stmt<'_>) {\n-            intravisit::walk_stmt(&mut *self.inside_stmt(true), stmt)\n-        }\n-\n-        fn visit_expr(&mut self, expr: &'hir Expr<'_>) {\n-            if self.failed {\n-                return;\n-            }\n-            if self.in_stmt {\n-                match expr.kind {\n-                    ExprKind::Ret(Some(expr)) => self.inside_stmt(false).visit_expr(expr),\n-                    _ => intravisit::walk_expr(self, expr),\n-                }\n-            } else {\n-                match expr.kind {\n-                    ExprKind::Match(cond, arms, _) => {\n-                        self.inside_stmt(true).visit_expr(cond);\n-                        for arm in arms {\n-                            self.visit_expr(arm.body);\n-                        }\n-                    },\n-                    ExprKind::Block(..) => intravisit::walk_expr(self, expr),\n-                    ExprKind::Ret(Some(expr)) => self.visit_expr(expr),\n-                    _ => self.failed |= !(self.cb)(expr),\n-                }\n-            }\n-        }\n-    }\n-\n-    !contains_try(expr) && {\n-        let mut ret_finder = RetFinder {\n-            in_stmt: false,\n-            failed: false,\n-            cb: callback,\n-        };\n-        ret_finder.visit_expr(expr);\n-        !ret_finder.failed\n-    }\n-}\n-\n-/// returns `true` if expr contains match expr desugared from try\n-fn contains_try(expr: &Expr<'_>) -> bool {\n-    struct TryFinder {\n-        found: bool,\n-    }\n-\n-    impl<'hir> intravisit::Visitor<'hir> for TryFinder {\n-        type Map = Map<'hir>;\n-\n-        fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n-            intravisit::NestedVisitorMap::None\n-        }\n-\n-        fn visit_expr(&mut self, expr: &'hir Expr<'hir>) {\n-            if self.found {\n-                return;\n-            }\n-            match expr.kind {\n-                ExprKind::Match(_, _, MatchSource::TryDesugar) => self.found = true,\n-                _ => intravisit::walk_expr(self, expr),\n-            }\n-        }\n-    }\n-\n-    let mut visitor = TryFinder { found: false };\n-    visitor.visit_expr(expr);\n-    visitor.found\n-}"}, {"sha": "bd62e67f80e380b151970bc9f6a73a71993535f4", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/df0d565e597ad9c436fadfb8e11a16a92bcb4114/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df0d565e597ad9c436fadfb8e11a16a92bcb4114/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=df0d565e597ad9c436fadfb8e11a16a92bcb4114", "patch": "@@ -21,6 +21,7 @@ pub mod ptr;\n pub mod qualify_min_const_fn;\n pub mod sugg;\n pub mod usage;\n+pub mod visitors;\n \n pub use self::attrs::*;\n pub use self::diagnostics::*;"}, {"sha": "b0837b6c43e76dc3f9bbdaf80ad15bc7bf0039c6", "filename": "clippy_lints/src/utils/visitors.rs", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/df0d565e597ad9c436fadfb8e11a16a92bcb4114/clippy_lints%2Fsrc%2Futils%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df0d565e597ad9c436fadfb8e11a16a92bcb4114/clippy_lints%2Fsrc%2Futils%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fvisitors.rs?ref=df0d565e597ad9c436fadfb8e11a16a92bcb4114", "patch": "@@ -0,0 +1,125 @@\n+use rustc_hir as hir;\n+use rustc_hir::intravisit::{self, Visitor};\n+use rustc_lint::LateContext;\n+use rustc_middle::hir::map::Map;\n+\n+/// returns `true` if expr contains match expr desugared from try\n+fn contains_try(expr: &hir::Expr<'_>) -> bool {\n+    struct TryFinder {\n+        found: bool,\n+    }\n+\n+    impl<'hir> intravisit::Visitor<'hir> for TryFinder {\n+        type Map = Map<'hir>;\n+\n+        fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n+            intravisit::NestedVisitorMap::None\n+        }\n+\n+        fn visit_expr(&mut self, expr: &'hir hir::Expr<'hir>) {\n+            if self.found {\n+                return;\n+            }\n+            match expr.kind {\n+                hir::ExprKind::Match(_, _, hir::MatchSource::TryDesugar) => self.found = true,\n+                _ => intravisit::walk_expr(self, expr),\n+            }\n+        }\n+    }\n+\n+    let mut visitor = TryFinder { found: false };\n+    visitor.visit_expr(expr);\n+    visitor.found\n+}\n+\n+pub fn find_all_ret_expressions<'hir, F>(_cx: &LateContext<'_>, expr: &'hir hir::Expr<'hir>, callback: F) -> bool\n+where\n+    F: FnMut(&'hir hir::Expr<'hir>) -> bool,\n+{\n+    struct RetFinder<F> {\n+        in_stmt: bool,\n+        failed: bool,\n+        cb: F,\n+    }\n+\n+    struct WithStmtGuarg<'a, F> {\n+        val: &'a mut RetFinder<F>,\n+        prev_in_stmt: bool,\n+    }\n+\n+    impl<F> RetFinder<F> {\n+        fn inside_stmt(&mut self, in_stmt: bool) -> WithStmtGuarg<'_, F> {\n+            let prev_in_stmt = std::mem::replace(&mut self.in_stmt, in_stmt);\n+            WithStmtGuarg {\n+                val: self,\n+                prev_in_stmt,\n+            }\n+        }\n+    }\n+\n+    impl<F> std::ops::Deref for WithStmtGuarg<'_, F> {\n+        type Target = RetFinder<F>;\n+\n+        fn deref(&self) -> &Self::Target {\n+            self.val\n+        }\n+    }\n+\n+    impl<F> std::ops::DerefMut for WithStmtGuarg<'_, F> {\n+        fn deref_mut(&mut self) -> &mut Self::Target {\n+            self.val\n+        }\n+    }\n+\n+    impl<F> Drop for WithStmtGuarg<'_, F> {\n+        fn drop(&mut self) {\n+            self.val.in_stmt = self.prev_in_stmt;\n+        }\n+    }\n+\n+    impl<'hir, F: FnMut(&'hir hir::Expr<'hir>) -> bool> intravisit::Visitor<'hir> for RetFinder<F> {\n+        type Map = Map<'hir>;\n+\n+        fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n+            intravisit::NestedVisitorMap::None\n+        }\n+\n+        fn visit_stmt(&mut self, stmt: &'hir hir::Stmt<'_>) {\n+            intravisit::walk_stmt(&mut *self.inside_stmt(true), stmt)\n+        }\n+\n+        fn visit_expr(&mut self, expr: &'hir hir::Expr<'_>) {\n+            if self.failed {\n+                return;\n+            }\n+            if self.in_stmt {\n+                match expr.kind {\n+                    hir::ExprKind::Ret(Some(expr)) => self.inside_stmt(false).visit_expr(expr),\n+                    _ => intravisit::walk_expr(self, expr),\n+                }\n+            } else {\n+                match expr.kind {\n+                    hir::ExprKind::Match(cond, arms, _) => {\n+                        self.inside_stmt(true).visit_expr(cond);\n+                        for arm in arms {\n+                            self.visit_expr(arm.body);\n+                        }\n+                    },\n+                    hir::ExprKind::Block(..) => intravisit::walk_expr(self, expr),\n+                    hir::ExprKind::Ret(Some(expr)) => self.visit_expr(expr),\n+                    _ => self.failed |= !(self.cb)(expr),\n+                }\n+            }\n+        }\n+    }\n+\n+    !contains_try(expr) && {\n+        let mut ret_finder = RetFinder {\n+            in_stmt: false,\n+            failed: false,\n+            cb: callback,\n+        };\n+        ret_finder.visit_expr(expr);\n+        !ret_finder.failed\n+    }\n+}"}]}