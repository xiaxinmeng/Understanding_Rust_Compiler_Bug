{"sha": "012ea3fac62df26abefa6d64b81570ed58118dea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxMmVhM2ZhYzYyZGYyNmFiZWZhNmQ2NGI4MTU3MGVkNTgxMThkZWE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-26T14:01:58Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-26T14:01:58Z"}, "message": "handle all the reads on the \"main\" watcher thread", "tree": {"sha": "11052942db7df5d596ba290a546add213de2ac83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11052942db7df5d596ba290a546add213de2ac83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/012ea3fac62df26abefa6d64b81570ed58118dea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/012ea3fac62df26abefa6d64b81570ed58118dea", "html_url": "https://github.com/rust-lang/rust/commit/012ea3fac62df26abefa6d64b81570ed58118dea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/012ea3fac62df26abefa6d64b81570ed58118dea/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ce531f95dec87a1f59e9347fdd6c250e36b489d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ce531f95dec87a1f59e9347fdd6c250e36b489d", "html_url": "https://github.com/rust-lang/rust/commit/3ce531f95dec87a1f59e9347fdd6c250e36b489d"}], "stats": {"total": 123, "additions": 75, "deletions": 48}, "files": [{"sha": "98b107b3591f754c9cc6bbc20b2d784f593a75f9", "filename": "crates/ra_vfs/src/io.rs", "status": "modified", "additions": 75, "deletions": 48, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/012ea3fac62df26abefa6d64b81570ed58118dea/crates%2Fra_vfs%2Fsrc%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012ea3fac62df26abefa6d64b81570ed58118dea/crates%2Fra_vfs%2Fsrc%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Fio.rs?ref=012ea3fac62df26abefa6d64b81570ed58118dea", "patch": "@@ -5,7 +5,7 @@ use std::{\n     sync::{mpsc, Arc},\n     time::Duration,\n };\n-use crossbeam_channel::{Receiver, Sender};\n+use crossbeam_channel::{Receiver, Sender, unbounded, RecvError, select};\n use relative_path::RelativePathBuf;\n use thread_worker::WorkerHandle;\n use walkdir::WalkDir;\n@@ -61,9 +61,25 @@ pub(crate) struct Worker {\n \n impl Worker {\n     pub(crate) fn start(roots: Arc<Roots>) -> Worker {\n-        let (worker, worker_handle) =\n-            thread_worker::spawn(\"vfs\", 128, move |input_receiver, output_sender| {\n+        // This is a pretty elaborate setup of threads & channels! It is\n+        // explained by the following concerns:\n+\n+        //    * we need to burn a thread translating from notify's mpsc to\n+        //      crossbeam_channel.\n+        //    * we want to read all files from a single thread, to gurantee that\n+        //      we always get fresher versions and never go back in time.\n+        //    * we want to tear down everything neatly during shutdown.\n+        let (worker, worker_handle) = thread_worker::spawn(\n+            \"vfs\",\n+            128,\n+            // This are the channels we use to communicate with outside world.\n+            // If `input_receiver` is closed we need to tear ourselves down.\n+            // `output_sender` should not be closed unless the parent died.\n+            move |input_receiver, output_sender| {\n+                // These are `std` channels notify will send events to\n                 let (notify_sender, notify_receiver) = mpsc::channel();\n+                // These are the corresponding crossbeam channels\n+                let (watcher_sender, watcher_receiver) = unbounded();\n                 let watcher = notify::watcher(notify_sender, WATCHER_DELAY)\n                     .map_err(|e| log::error!(\"failed to spawn notify {}\", e))\n                     .ok();\n@@ -72,28 +88,40 @@ impl Worker {\n                     watcher: Arc::new(Mutex::new(watcher)),\n                     sender: output_sender,\n                 };\n-                let thread = thread::spawn({\n-                    let ctx = ctx.clone();\n-                    move || {\n-                        let _ = notify_receiver\n-                            .into_iter()\n-                            // forward relevant events only\n-                            .try_for_each(|change| ctx.handle_debounced_event(change));\n-                    }\n-                });\n-                let res1 = input_receiver.into_iter().try_for_each(|t| match t {\n-                    Task::AddRoot { root, config } => watch_root(&ctx, root, Arc::clone(&config)),\n+                let thread = thread::spawn(move || {\n+                    let _ = notify_receiver\n+                        .into_iter()\n+                        // forward relevant events only\n+                        .for_each(|event| convert_notify_event(event, &watcher_sender));\n                 });\n+\n+                loop {\n+                    select! {\n+                        // Received request from the caller. If this channel is\n+                        // closed, we should shutdown everything.\n+                        recv(input_receiver) -> t => match t {\n+                            Err(RecvError) => break,\n+                            Ok(Task::AddRoot { root, config }) => watch_root(&ctx, root, Arc::clone(&config)),\n+                        },\n+                        // Watcher send us changes. If **this** channel is\n+                        // closed, the watcher has died, which indicates a bug\n+                        // -- escalate!\n+                        recv(watcher_receiver) -> event => match event {\n+                            Err(RecvError) => panic!(\"watcher is dead\"),\n+                            Ok((path, change)) => WatcherCtx::handle_change(&ctx, path, change).unwrap(),\n+                        },\n+                    }\n+                }\n                 drop(ctx.watcher.lock().take());\n                 drop(ctx);\n                 let res2 = thread.join();\n                 match &res2 {\n                     Ok(()) => log::info!(\"... Watcher terminated with ok\"),\n                     Err(_) => log::error!(\"... Watcher terminated with err\"),\n                 }\n-                res1.unwrap();\n                 res2.unwrap();\n-            });\n+            },\n+        );\n         Worker {\n             worker,\n             worker_handle,\n@@ -114,7 +142,7 @@ impl Worker {\n     }\n }\n \n-fn watch_root(woker: &WatcherCtx, root: VfsRoot, config: Arc<RootConfig>) -> Result<()> {\n+fn watch_root(woker: &WatcherCtx, root: VfsRoot, config: Arc<RootConfig>) {\n     let mut guard = woker.watcher.lock();\n     log::debug!(\"loading {} ...\", config.root.as_path().display());\n     let files = watch_recursive(guard.as_mut(), config.root.as_path(), &*config)\n@@ -127,9 +155,9 @@ fn watch_root(woker: &WatcherCtx, root: VfsRoot, config: Arc<RootConfig>) -> Res\n         .collect();\n     woker\n         .sender\n-        .send(TaskResult::BulkLoadRoot { root, files })?;\n+        .send(TaskResult::BulkLoadRoot { root, files })\n+        .unwrap();\n     log::debug!(\"... loaded {}\", config.root.as_path().display());\n-    Ok(())\n }\n \n #[derive(Clone)]\n@@ -139,38 +167,37 @@ struct WatcherCtx {\n     sender: Sender<TaskResult>,\n }\n \n-impl WatcherCtx {\n-    fn handle_debounced_event(&self, ev: DebouncedEvent) -> Result<()> {\n-        match ev {\n-            DebouncedEvent::NoticeWrite(_)\n-            | DebouncedEvent::NoticeRemove(_)\n-            | DebouncedEvent::Chmod(_) => {\n-                // ignore\n-            }\n-            DebouncedEvent::Rescan => {\n-                // TODO rescan all roots\n-            }\n-            DebouncedEvent::Create(path) => {\n-                self.handle_change(path, ChangeKind::Create)?;\n-            }\n-            DebouncedEvent::Write(path) => {\n-                self.handle_change(path, ChangeKind::Write)?;\n-            }\n-            DebouncedEvent::Remove(path) => {\n-                self.handle_change(path, ChangeKind::Remove)?;\n-            }\n-            DebouncedEvent::Rename(src, dst) => {\n-                self.handle_change(src, ChangeKind::Remove)?;\n-                self.handle_change(dst, ChangeKind::Create)?;\n-            }\n-            DebouncedEvent::Error(err, path) => {\n-                // TODO should we reload the file contents?\n-                log::warn!(\"watcher error \\\"{}\\\", {:?}\", err, path);\n-            }\n+fn convert_notify_event(event: DebouncedEvent, sender: &Sender<(PathBuf, ChangeKind)>) {\n+    match event {\n+        DebouncedEvent::NoticeWrite(_)\n+        | DebouncedEvent::NoticeRemove(_)\n+        | DebouncedEvent::Chmod(_) => {\n+            // ignore\n+        }\n+        DebouncedEvent::Rescan => {\n+            // TODO rescan all roots\n+        }\n+        DebouncedEvent::Create(path) => {\n+            sender.send((path, ChangeKind::Create)).unwrap();\n+        }\n+        DebouncedEvent::Write(path) => {\n+            sender.send((path, ChangeKind::Write)).unwrap();\n+        }\n+        DebouncedEvent::Remove(path) => {\n+            sender.send((path, ChangeKind::Remove)).unwrap();\n+        }\n+        DebouncedEvent::Rename(src, dst) => {\n+            sender.send((src, ChangeKind::Remove)).unwrap();\n+            sender.send((dst, ChangeKind::Create)).unwrap();\n+        }\n+        DebouncedEvent::Error(err, path) => {\n+            // TODO should we reload the file contents?\n+            log::warn!(\"watcher error \\\"{}\\\", {:?}\", err, path);\n         }\n-        Ok(())\n     }\n+}\n \n+impl WatcherCtx {\n     fn handle_change(&self, path: PathBuf, kind: ChangeKind) -> Result<()> {\n         let (root, rel_path) = match self.roots.find(&path) {\n             None => return Ok(()),"}]}