{"sha": "e12e97223f9f0bb0f2806334029aec1d9790f074", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxMmU5NzIyM2Y5ZjBiYjBmMjgwNjMzNDAyOWFlYzFkOTc5MGYwNzQ=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-10-24T20:39:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-24T20:39:51Z"}, "message": "Rollup merge of #78072 - Nadrieril:cleanup-constant-matching, r=varkor\n\nCleanup constant matching in exhaustiveness checking\n\nThis supercedes https://github.com/rust-lang/rust/pull/77390. I made the `Opaque` constructor work.\nI have opened two issues https://github.com/rust-lang/rust/issues/78071 and https://github.com/rust-lang/rust/issues/78057 from the discussion we had on the previous PR. They are not regressions nor directly related to the current PR so I thought we'd deal with them separately.\n\nI left a FIXME somewhere because I didn't know how to compare string constants for equality. There might even be some unicode things that need to happen there. In the meantime I preserved previous behavior.\n\nEDIT: I accidentally fixed #78071", "tree": {"sha": "ea9262ad3bbd29d43864cfdb08bdbb2658d19b88", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea9262ad3bbd29d43864cfdb08bdbb2658d19b88"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e12e97223f9f0bb0f2806334029aec1d9790f074", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJflJEYCRBK7hj4Ov3rIwAAdHIIAKEYOFcTIvEtGaiomScXrlUx\n50oraN3PoGm7PoUWPh3CeV/OtNz2XXAEYPUBwR4+SeutVbcZUsSU1mV0LFJejfyT\nXVK23Uw72NZcC1Kcp0Z4f3WAKnxVULnS+7eSG5UDrjyafj2dCCR9rqLg+LW3kIaU\nbZH5U/H/v64Fq9sd2Ov0kVl4Oq0K1iKjZqo1ORTO5vfTcsWaqFWTeo40pxJ/Ovse\nN/BHHxXSqdurVEmbrLMaT8WK83e8NDWdC/oZPpICbKkgFof+UJYqZOc9RoIzMK1m\n+DK08v4QN/9wbH6WfqQMra70Iabkzc5fVjIqlLRtPcsDHVH0ntbKORQz/aMq/6c=\n=9CLL\n-----END PGP SIGNATURE-----\n", "payload": "tree ea9262ad3bbd29d43864cfdb08bdbb2658d19b88\nparent 0a06d7344b5e83c304b926d03452f4c95d2c89dc\nparent faf87105db54a399bc598765528dec818b63a54a\nauthor Jonas Schievink <jonasschievink@gmail.com> 1603571991 +0200\ncommitter GitHub <noreply@github.com> 1603571991 +0200\n\nRollup merge of #78072 - Nadrieril:cleanup-constant-matching, r=varkor\n\nCleanup constant matching in exhaustiveness checking\n\nThis supercedes https://github.com/rust-lang/rust/pull/77390. I made the `Opaque` constructor work.\nI have opened two issues https://github.com/rust-lang/rust/issues/78071 and https://github.com/rust-lang/rust/issues/78057 from the discussion we had on the previous PR. They are not regressions nor directly related to the current PR so I thought we'd deal with them separately.\n\nI left a FIXME somewhere because I didn't know how to compare string constants for equality. There might even be some unicode things that need to happen there. In the meantime I preserved previous behavior.\n\nEDIT: I accidentally fixed #78071\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e12e97223f9f0bb0f2806334029aec1d9790f074", "html_url": "https://github.com/rust-lang/rust/commit/e12e97223f9f0bb0f2806334029aec1d9790f074", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e12e97223f9f0bb0f2806334029aec1d9790f074/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a06d7344b5e83c304b926d03452f4c95d2c89dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a06d7344b5e83c304b926d03452f4c95d2c89dc", "html_url": "https://github.com/rust-lang/rust/commit/0a06d7344b5e83c304b926d03452f4c95d2c89dc"}, {"sha": "faf87105db54a399bc598765528dec818b63a54a", "url": "https://api.github.com/repos/rust-lang/rust/commits/faf87105db54a399bc598765528dec818b63a54a", "html_url": "https://github.com/rust-lang/rust/commit/faf87105db54a399bc598765528dec818b63a54a"}], "stats": {"total": 795, "additions": 448, "deletions": 347}, "files": [{"sha": "0449e14983150da08372f98a4c916d97e7777d44", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 111, "deletions": 339, "changes": 450, "blob_url": "https://github.com/rust-lang/rust/blob/e12e97223f9f0bb0f2806334029aec1d9790f074/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e12e97223f9f0bb0f2806334029aec1d9790f074/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=e12e97223f9f0bb0f2806334029aec1d9790f074", "patch": "@@ -302,10 +302,9 @@ use super::{FieldPat, Pat, PatKind, PatRange};\n \n use rustc_arena::TypedArena;\n use rustc_attr::{SignedInt, UnsignedInt};\n-use rustc_errors::ErrorReported;\n use rustc_hir::def_id::DefId;\n use rustc_hir::{HirId, RangeEnd};\n-use rustc_middle::mir::interpret::{truncate, AllocId, ConstValue, Pointer, Scalar};\n+use rustc_middle::mir::interpret::{truncate, ConstValue};\n use rustc_middle::mir::Field;\n use rustc_middle::ty::layout::IntegerExt;\n use rustc_middle::ty::{self, Const, Ty, TyCtxt};\n@@ -314,108 +313,21 @@ use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::{Integer, Size, VariantIdx};\n \n use smallvec::{smallvec, SmallVec};\n-use std::borrow::Cow;\n use std::cmp::{self, max, min, Ordering};\n-use std::convert::TryInto;\n use std::fmt;\n use std::iter::{FromIterator, IntoIterator};\n use std::ops::RangeInclusive;\n \n-crate fn expand_pattern<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>, pat: Pat<'tcx>) -> Pat<'tcx> {\n-    LiteralExpander { tcx: cx.tcx, param_env: cx.param_env }.fold_pattern(&pat)\n+crate fn expand_pattern<'tcx>(pat: Pat<'tcx>) -> Pat<'tcx> {\n+    LiteralExpander.fold_pattern(&pat)\n }\n \n-struct LiteralExpander<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-}\n+struct LiteralExpander;\n \n-impl<'tcx> LiteralExpander<'tcx> {\n-    /// Derefs `val` and potentially unsizes the value if `crty` is an array and `rty` a slice.\n-    ///\n-    /// `crty` and `rty` can differ because you can use array constants in the presence of slice\n-    /// patterns. So the pattern may end up being a slice, but the constant is an array. We convert\n-    /// the array to a slice in that case.\n-    fn fold_const_value_deref(\n-        &mut self,\n-        val: ConstValue<'tcx>,\n-        // the pattern's pointee type\n-        rty: Ty<'tcx>,\n-        // the constant's pointee type\n-        crty: Ty<'tcx>,\n-    ) -> ConstValue<'tcx> {\n-        debug!(\"fold_const_value_deref {:?} {:?} {:?}\", val, rty, crty);\n-        match (val, &crty.kind(), &rty.kind()) {\n-            // the easy case, deref a reference\n-            (ConstValue::Scalar(p), x, y) if x == y => {\n-                match p {\n-                    Scalar::Ptr(p) => {\n-                        let alloc = self.tcx.global_alloc(p.alloc_id).unwrap_memory();\n-                        ConstValue::ByRef { alloc, offset: p.offset }\n-                    }\n-                    Scalar::Raw { .. } => {\n-                        let layout = self.tcx.layout_of(self.param_env.and(rty)).unwrap();\n-                        if layout.is_zst() {\n-                            // Deref of a reference to a ZST is a nop.\n-                            ConstValue::Scalar(Scalar::zst())\n-                        } else {\n-                            // FIXME(oli-obk): this is reachable for `const FOO: &&&u32 = &&&42;`\n-                            bug!(\"cannot deref {:#?}, {} -> {}\", val, crty, rty);\n-                        }\n-                    }\n-                }\n-            }\n-            // unsize array to slice if pattern is array but match value or other patterns are slice\n-            (ConstValue::Scalar(Scalar::Ptr(p)), ty::Array(t, n), ty::Slice(u)) => {\n-                assert_eq!(t, u);\n-                ConstValue::Slice {\n-                    data: self.tcx.global_alloc(p.alloc_id).unwrap_memory(),\n-                    start: p.offset.bytes().try_into().unwrap(),\n-                    end: n.eval_usize(self.tcx, ty::ParamEnv::empty()).try_into().unwrap(),\n-                }\n-            }\n-            // fat pointers stay the same\n-            (ConstValue::Slice { .. }, _, _)\n-            | (_, ty::Slice(_), ty::Slice(_))\n-            | (_, ty::Str, ty::Str) => val,\n-            // FIXME(oli-obk): this is reachable for `const FOO: &&&u32 = &&&42;` being used\n-            _ => bug!(\"cannot deref {:#?}, {} -> {}\", val, crty, rty),\n-        }\n-    }\n-}\n-\n-impl<'tcx> PatternFolder<'tcx> for LiteralExpander<'tcx> {\n+impl<'tcx> PatternFolder<'tcx> for LiteralExpander {\n     fn fold_pattern(&mut self, pat: &Pat<'tcx>) -> Pat<'tcx> {\n         debug!(\"fold_pattern {:?} {:?} {:?}\", pat, pat.ty.kind(), pat.kind);\n         match (pat.ty.kind(), &*pat.kind) {\n-            (&ty::Ref(_, rty, _), &PatKind::Constant { value: Const { val, ty: const_ty } })\n-                if const_ty.is_ref() =>\n-            {\n-                let crty =\n-                    if let ty::Ref(_, crty, _) = const_ty.kind() { crty } else { unreachable!() };\n-                if let ty::ConstKind::Value(val) = val {\n-                    Pat {\n-                        ty: pat.ty,\n-                        span: pat.span,\n-                        kind: box PatKind::Deref {\n-                            subpattern: Pat {\n-                                ty: rty,\n-                                span: pat.span,\n-                                kind: box PatKind::Constant {\n-                                    value: Const::from_value(\n-                                        self.tcx,\n-                                        self.fold_const_value_deref(*val, rty, crty),\n-                                        rty,\n-                                    ),\n-                                },\n-                            },\n-                        },\n-                    }\n-                } else {\n-                    bug!(\"cannot deref {:#?}, {} -> {}\", val, crty, rty)\n-                }\n-            }\n-\n             (_, &PatKind::Binding { subpattern: Some(ref s), .. }) => s.fold_with(self),\n             (_, &PatKind::AscribeUserType { subpattern: ref s, .. }) => s.fold_with(self),\n             _ => pat.super_fold_with(self),\n@@ -500,9 +412,15 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n         cx: &mut MatchCheckCtxt<'p, 'tcx>,\n         constructor: &Constructor<'tcx>,\n         ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n+        is_my_head_ctor: bool,\n     ) -> Option<PatStack<'p, 'tcx>> {\n-        let new_fields =\n-            specialize_one_pattern(cx, self.head(), constructor, ctor_wild_subpatterns)?;\n+        let new_fields = specialize_one_pattern(\n+            cx,\n+            self.head(),\n+            constructor,\n+            ctor_wild_subpatterns,\n+            is_my_head_ctor,\n+        )?;\n         Some(new_fields.push_on_patstack(&self.0[1..]))\n     }\n }\n@@ -680,6 +598,7 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n                                 cx,\n                                 constructor,\n                                 ctor_wild_subpatterns,\n+                                false,\n                             )\n                         })\n                         .collect()\n@@ -705,7 +624,9 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n             SpecializationCache::Incompatible => self\n                 .patterns\n                 .iter()\n-                .filter_map(|r| r.specialize_constructor(cx, constructor, ctor_wild_subpatterns))\n+                .filter_map(|r| {\n+                    r.specialize_constructor(cx, constructor, ctor_wild_subpatterns, false)\n+                })\n                 .collect(),\n         }\n     }\n@@ -725,6 +646,7 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n /// +++++++++++++++++++++++++++++\n /// + _     + [_, _, tail @ ..] +\n /// +++++++++++++++++++++++++++++\n+/// ```\n impl<'p, 'tcx> fmt::Debug for Matrix<'p, 'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"\\n\")?;\n@@ -926,42 +848,30 @@ enum Constructor<'tcx> {\n     Single,\n     /// Enum variants.\n     Variant(DefId),\n-    /// Literal values.\n-    ConstantValue(&'tcx ty::Const<'tcx>),\n     /// Ranges of integer literal values (`2`, `2..=5` or `2..5`).\n     IntRange(IntRange<'tcx>),\n     /// Ranges of floating-point literal values (`2.0..=5.2`).\n     FloatRange(&'tcx ty::Const<'tcx>, &'tcx ty::Const<'tcx>, RangeEnd),\n+    /// String literals. Strings are not quite the same as `&[u8]` so we treat them separately.\n+    Str(&'tcx ty::Const<'tcx>),\n     /// Array and slice patterns.\n     Slice(Slice),\n+    /// Constants that must not be matched structurally. They are treated as black\n+    /// boxes for the purposes of exhaustiveness: we must not inspect them, and they\n+    /// don't count towards making a match exhaustive.\n+    Opaque,\n     /// Fake extra constructor for enums that aren't allowed to be matched exhaustively.\n     NonExhaustive,\n }\n \n impl<'tcx> Constructor<'tcx> {\n-    fn is_slice(&self) -> bool {\n-        match self {\n-            Slice(_) => true,\n-            _ => false,\n-        }\n-    }\n-\n-    fn variant_index_for_adt<'a>(\n-        &self,\n-        cx: &MatchCheckCtxt<'a, 'tcx>,\n-        adt: &'tcx ty::AdtDef,\n-    ) -> VariantIdx {\n+    fn variant_index_for_adt(&self, adt: &'tcx ty::AdtDef) -> VariantIdx {\n         match *self {\n             Variant(id) => adt.variant_index_with_id(id),\n             Single => {\n                 assert!(!adt.is_enum());\n                 VariantIdx::new(0)\n             }\n-            ConstantValue(c) => cx\n-                .tcx\n-                .destructure_const(cx.param_env.and(c))\n-                .variant\n-                .expect(\"destructed const of adt without variant id\"),\n             _ => bug!(\"bad constructor {:?} for adt {:?}\", self, adt),\n         }\n     }\n@@ -975,16 +885,14 @@ impl<'tcx> Constructor<'tcx> {\n \n         match self {\n             // Those constructors can only match themselves.\n-            Single | Variant(_) | ConstantValue(..) | FloatRange(..) => {\n+            Single | Variant(_) | Str(..) | FloatRange(..) => {\n                 if other_ctors.iter().any(|c| c == self) { vec![] } else { vec![self.clone()] }\n             }\n             &Slice(slice) => {\n                 let mut other_slices = other_ctors\n                     .iter()\n                     .filter_map(|c: &Constructor<'_>| match c {\n                         Slice(slice) => Some(*slice),\n-                        // FIXME(oli-obk): implement `deref` for `ConstValue`\n-                        ConstantValue(..) => None,\n                         _ => bug!(\"bad slice pattern constructor {:?}\", c),\n                     })\n                     .map(Slice::value_kind);\n@@ -1048,6 +956,7 @@ impl<'tcx> Constructor<'tcx> {\n             }\n             // This constructor is never covered by anything else\n             NonExhaustive => vec![NonExhaustive],\n+            Opaque => bug!(\"unexpected opaque ctor {:?} found in all_ctors\", self),\n         }\n     }\n \n@@ -1087,7 +996,7 @@ impl<'tcx> Constructor<'tcx> {\n                             PatKind::Variant {\n                                 adt_def: adt,\n                                 substs,\n-                                variant_index: self.variant_index_for_adt(cx, adt),\n+                                variant_index: self.variant_index_for_adt(adt),\n                                 subpatterns,\n                             }\n                         } else {\n@@ -1126,10 +1035,11 @@ impl<'tcx> Constructor<'tcx> {\n                     PatKind::Slice { prefix, slice: Some(wild), suffix }\n                 }\n             },\n-            &ConstantValue(value) => PatKind::Constant { value },\n+            &Str(value) => PatKind::Constant { value },\n             &FloatRange(lo, hi, end) => PatKind::Range(PatRange { lo, hi, end }),\n             IntRange(range) => return range.to_pat(cx.tcx),\n             NonExhaustive => PatKind::Wild,\n+            Opaque => bug!(\"we should not try to apply an opaque constructor {:?}\", self),\n         };\n \n         Pat { ty, span: DUMMY_SP, kind: Box::new(pat) }\n@@ -1204,12 +1114,6 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n         Fields::Slice(std::slice::from_ref(pat))\n     }\n \n-    /// Construct a new `Fields` from the given patterns. You must be sure those patterns can't\n-    /// contain fields that need to be filtered out. When in doubt, prefer `replace_fields`.\n-    fn from_slice_unfiltered(pats: &'p [Pat<'tcx>]) -> Self {\n-        Fields::Slice(pats)\n-    }\n-\n     /// Convenience; internal use.\n     fn wildcards_from_tys(\n         cx: &MatchCheckCtxt<'p, 'tcx>,\n@@ -1239,7 +1143,7 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                         // Use T as the sub pattern type of Box<T>.\n                         Fields::from_single_pattern(wildcard_from_ty(substs.type_at(0)))\n                     } else {\n-                        let variant = &adt.variants[constructor.variant_index_for_adt(cx, adt)];\n+                        let variant = &adt.variants[constructor.variant_index_for_adt(adt)];\n                         // Whether we must not match the fields of this variant exhaustively.\n                         let is_non_exhaustive =\n                             variant.is_field_list_non_exhaustive() && !adt.did.is_local();\n@@ -1287,7 +1191,7 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                 }\n                 _ => bug!(\"bad slice pattern {:?} {:?}\", constructor, ty),\n             },\n-            ConstantValue(..) | FloatRange(..) | IntRange(..) | NonExhaustive => Fields::empty(),\n+            Str(..) | FloatRange(..) | IntRange(..) | NonExhaustive | Opaque => Fields::empty(),\n         };\n         debug!(\"Fields::wildcards({:?}, {:?}) = {:#?}\", constructor, ty, ret);\n         ret\n@@ -1600,9 +1504,7 @@ fn all_constructors<'a, 'tcx>(\n         )\n     };\n     match *pcx.ty.kind() {\n-        ty::Bool => {\n-            [true, false].iter().map(|&b| ConstantValue(ty::Const::from_bool(cx.tcx, b))).collect()\n-        }\n+        ty::Bool => vec![make_range(0, 1)],\n         ty::Array(ref sub_ty, len) if len.try_eval_usize(cx.tcx, cx.param_env).is_some() => {\n             let len = len.eval_usize(cx.tcx, cx.param_env);\n             if len != 0 && cx.is_uninhabited(sub_ty) {\n@@ -1717,7 +1619,7 @@ impl<'tcx> IntRange<'tcx> {\n     #[inline]\n     fn is_integral(ty: Ty<'_>) -> bool {\n         match ty.kind() {\n-            ty::Char | ty::Int(_) | ty::Uint(_) => true,\n+            ty::Char | ty::Int(_) | ty::Uint(_) | ty::Bool => true,\n             _ => false,\n         }\n     }\n@@ -1739,6 +1641,7 @@ impl<'tcx> IntRange<'tcx> {\n     #[inline]\n     fn integral_size_and_signed_bias(tcx: TyCtxt<'tcx>, ty: Ty<'_>) -> Option<(Size, u128)> {\n         match *ty.kind() {\n+            ty::Bool => Some((Size::from_bytes(1), 0)),\n             ty::Char => Some((Size::from_bytes(4), 0)),\n             ty::Int(ity) => {\n                 let size = Integer::from_attr(&tcx, SignedInt(ity)).size();\n@@ -2230,7 +2133,7 @@ fn is_useful_specialized<'p, 'tcx>(\n     // We cache the result of `Fields::wildcards` because it is used a lot.\n     let ctor_wild_subpatterns = Fields::wildcards(cx, &ctor, ty);\n     let matrix = matrix.specialize_constructor(cx, &ctor, &ctor_wild_subpatterns);\n-    v.specialize_constructor(cx, &ctor, &ctor_wild_subpatterns)\n+    v.specialize_constructor(cx, &ctor, &ctor_wild_subpatterns, true)\n         .map(|v| is_useful(cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false))\n         .map(|u| u.apply_constructor(cx, &ctor, ty, &ctor_wild_subpatterns))\n         .unwrap_or(NotUseful)\n@@ -2255,18 +2158,13 @@ fn pat_constructor<'tcx>(\n             if let Some(int_range) = IntRange::from_const(tcx, param_env, value, pat.span) {\n                 Some(IntRange(int_range))\n             } else {\n-                match (value.val, &value.ty.kind()) {\n-                    (_, ty::Array(_, n)) => {\n-                        let len = n.eval_usize(tcx, param_env);\n-                        Some(Slice(Slice { array_len: Some(len), kind: FixedLen(len) }))\n-                    }\n-                    (ty::ConstKind::Value(ConstValue::Slice { start, end, .. }), ty::Slice(_)) => {\n-                        let len = (end - start) as u64;\n-                        Some(Slice(Slice { array_len: None, kind: FixedLen(len) }))\n-                    }\n-                    // FIXME(oli-obk): implement `deref` for `ConstValue`\n-                    // (ty::ConstKind::Value(ConstValue::ByRef { .. }), ty::Slice(_)) => { ... }\n-                    _ => Some(ConstantValue(value)),\n+                match value.ty.kind() {\n+                    ty::Float(_) => Some(FloatRange(value, value, RangeEnd::Included)),\n+                    ty::Ref(_, t, _) if t.is_str() => Some(Str(value)),\n+                    // All constants that can be structurally matched have already been expanded\n+                    // into the corresponding `Pat`s by `const_to_pat`. Constants that remain are\n+                    // opaque.\n+                    _ => Some(Opaque),\n                 }\n             }\n         }\n@@ -2302,75 +2200,6 @@ fn pat_constructor<'tcx>(\n     }\n }\n \n-// checks whether a constant is equal to a user-written slice pattern. Only supports byte slices,\n-// meaning all other types will compare unequal and thus equal patterns often do not cause the\n-// second pattern to lint about unreachable match arms.\n-fn slice_pat_covered_by_const<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    _span: Span,\n-    const_val: &'tcx ty::Const<'tcx>,\n-    prefix: &[Pat<'tcx>],\n-    slice: &Option<Pat<'tcx>>,\n-    suffix: &[Pat<'tcx>],\n-    param_env: ty::ParamEnv<'tcx>,\n-) -> Result<bool, ErrorReported> {\n-    let const_val_val = if let ty::ConstKind::Value(val) = const_val.val {\n-        val\n-    } else {\n-        bug!(\n-            \"slice_pat_covered_by_const: {:#?}, {:#?}, {:#?}, {:#?}\",\n-            const_val,\n-            prefix,\n-            slice,\n-            suffix,\n-        )\n-    };\n-\n-    let data: &[u8] = match (const_val_val, &const_val.ty.kind()) {\n-        (ConstValue::ByRef { offset, alloc, .. }, ty::Array(t, n)) => {\n-            assert_eq!(*t, tcx.types.u8);\n-            let n = n.eval_usize(tcx, param_env);\n-            let ptr = Pointer::new(AllocId(0), offset);\n-            alloc.get_bytes(&tcx, ptr, Size::from_bytes(n)).unwrap()\n-        }\n-        (ConstValue::Slice { data, start, end }, ty::Slice(t)) => {\n-            assert_eq!(*t, tcx.types.u8);\n-            let ptr = Pointer::new(AllocId(0), Size::from_bytes(start));\n-            data.get_bytes(&tcx, ptr, Size::from_bytes(end - start)).unwrap()\n-        }\n-        // FIXME(oli-obk): create a way to extract fat pointers from ByRef\n-        (_, ty::Slice(_)) => return Ok(false),\n-        _ => bug!(\n-            \"slice_pat_covered_by_const: {:#?}, {:#?}, {:#?}, {:#?}\",\n-            const_val,\n-            prefix,\n-            slice,\n-            suffix,\n-        ),\n-    };\n-\n-    let pat_len = prefix.len() + suffix.len();\n-    if data.len() < pat_len || (slice.is_none() && data.len() > pat_len) {\n-        return Ok(false);\n-    }\n-\n-    for (ch, pat) in data[..prefix.len()]\n-        .iter()\n-        .zip(prefix)\n-        .chain(data[data.len() - suffix.len()..].iter().zip(suffix))\n-    {\n-        if let box PatKind::Constant { value } = pat.kind {\n-            let b = value.eval_bits(tcx, param_env, pat.ty);\n-            assert_eq!(b as u8 as u128, b);\n-            if b as u8 != *ch {\n-                return Ok(false);\n-            }\n-        }\n-    }\n-\n-    Ok(true)\n-}\n-\n /// For exhaustive integer matching, some constructors are grouped within other constructors\n /// (namely integer typed values are grouped within ranges). However, when specialising these\n /// constructors, we want to be specialising for the underlying constructors (the integers), not\n@@ -2668,35 +2497,6 @@ fn lint_overlapping_patterns<'tcx>(\n     }\n }\n \n-fn constructor_covered_by_range<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    ctor: &Constructor<'tcx>,\n-    pat: &Pat<'tcx>,\n-) -> Option<()> {\n-    if let Single = ctor {\n-        return Some(());\n-    }\n-\n-    let (pat_from, pat_to, pat_end, ty) = match *pat.kind {\n-        PatKind::Constant { value } => (value, value, RangeEnd::Included, value.ty),\n-        PatKind::Range(PatRange { lo, hi, end }) => (lo, hi, end, lo.ty),\n-        _ => bug!(\"`constructor_covered_by_range` called with {:?}\", pat),\n-    };\n-    let (ctor_from, ctor_to, ctor_end) = match *ctor {\n-        ConstantValue(value) => (value, value, RangeEnd::Included),\n-        FloatRange(from, to, ctor_end) => (from, to, ctor_end),\n-        _ => bug!(\"`constructor_covered_by_range` called with {:?}\", ctor),\n-    };\n-    trace!(\"constructor_covered_by_range {:#?}, {:#?}, {:#?}, {}\", ctor, pat_from, pat_to, ty);\n-\n-    let to = compare_const_vals(tcx, ctor_to, pat_to, param_env, ty)?;\n-    let from = compare_const_vals(tcx, ctor_from, pat_from, param_env, ty)?;\n-    let intersects = (from == Ordering::Greater || from == Ordering::Equal)\n-        && (to == Ordering::Less || (pat_end == ctor_end && to == Ordering::Equal));\n-    if intersects { Some(()) } else { None }\n-}\n-\n /// This is the main specialization step. It expands the pattern\n /// into `arity` patterns based on the constructor. For most patterns, the step is trivial,\n /// for instance tuple patterns are flattened and box patterns expand into their inner pattern.\n@@ -2713,15 +2513,43 @@ fn specialize_one_pattern<'p, 'tcx>(\n     pat: &'p Pat<'tcx>,\n     constructor: &Constructor<'tcx>,\n     ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n+    is_its_own_ctor: bool, // Whether `ctor` is known to be derived from `pat`\n ) -> Option<Fields<'p, 'tcx>> {\n     if let NonExhaustive = constructor {\n-        // Only a wildcard pattern can match the special extra constructor\n+        // Only a wildcard pattern can match the special extra constructor.\n         if !pat.is_wildcard() {\n             return None;\n         }\n         return Some(Fields::empty());\n     }\n \n+    if let Opaque = constructor {\n+        // Only a wildcard pattern can match an opaque constant, unless we're specializing the\n+        // value against its own constructor. That happens when we call\n+        // `v.specialize_constructor(ctor)` with `ctor` obtained from `pat_constructor(v.head())`.\n+        // For example, in the following match, when we are dealing with the third branch, we will\n+        // specialize with an `Opaque` ctor. We want to ignore the second branch because opaque\n+        // constants should not be inspected, but we don't want to ignore the current (third)\n+        // branch, as that would cause us to always conclude that such a branch is unreachable.\n+        // ```rust\n+        // #[derive(PartialEq)]\n+        // struct Foo(i32);\n+        // impl Eq for Foo {}\n+        // const FOO: Foo = Foo(42);\n+        //\n+        // match (Foo(0), true) {\n+        //     (_, true) => {}\n+        //     (FOO, true) => {}\n+        //     (FOO, false) => {}\n+        // }\n+        // ```\n+        if is_its_own_ctor || pat.is_wildcard() {\n+            return Some(Fields::empty());\n+        } else {\n+            return None;\n+        }\n+    }\n+\n     let result = match *pat.kind {\n         PatKind::AscribeUserType { .. } => bug!(), // Handled by `expand_pattern`\n \n@@ -2741,93 +2569,52 @@ fn specialize_one_pattern<'p, 'tcx>(\n \n         PatKind::Deref { ref subpattern } => Some(Fields::from_single_pattern(subpattern)),\n \n-        PatKind::Constant { value } if constructor.is_slice() => {\n-            // We extract an `Option` for the pointer because slices of zero\n-            // elements don't necessarily point to memory, they are usually\n-            // just integers. The only time they should be pointing to memory\n-            // is when they are subslices of nonzero slices.\n-            let (alloc, offset, n, ty) = match value.ty.kind() {\n-                ty::Array(t, n) => {\n-                    let n = n.eval_usize(cx.tcx, cx.param_env);\n-                    // Shortcut for `n == 0` where no matter what `alloc` and `offset` we produce,\n-                    // the result would be exactly what we early return here.\n-                    if n == 0 {\n-                        if ctor_wild_subpatterns.len() as u64 != n {\n-                            return None;\n-                        }\n-                        return Some(Fields::empty());\n-                    }\n-                    match value.val {\n-                        ty::ConstKind::Value(ConstValue::ByRef { offset, alloc, .. }) => {\n-                            (Cow::Borrowed(alloc), offset, n, t)\n-                        }\n-                        _ => span_bug!(pat.span, \"array pattern is {:?}\", value,),\n+        PatKind::Constant { .. } | PatKind::Range { .. } => {\n+            match constructor {\n+                IntRange(ctor) => {\n+                    let pat = IntRange::from_pat(cx.tcx, cx.param_env, pat)?;\n+                    ctor.intersection(cx.tcx, &pat)?;\n+                    // Constructor splitting should ensure that all intersections we encounter\n+                    // are actually inclusions.\n+                    assert!(ctor.is_subrange(&pat));\n+                }\n+                FloatRange(ctor_from, ctor_to, ctor_end) => {\n+                    let (pat_from, pat_to, pat_end, ty) = match *pat.kind {\n+                        PatKind::Constant { value } => (value, value, RangeEnd::Included, value.ty),\n+                        PatKind::Range(PatRange { lo, hi, end }) => (lo, hi, end, lo.ty),\n+                        _ => unreachable!(), // This is ensured by the branch we're in\n+                    };\n+                    let to = compare_const_vals(cx.tcx, ctor_to, pat_to, cx.param_env, ty)?;\n+                    let from = compare_const_vals(cx.tcx, ctor_from, pat_from, cx.param_env, ty)?;\n+                    let intersects = (from == Ordering::Greater || from == Ordering::Equal)\n+                        && (to == Ordering::Less\n+                            || (pat_end == *ctor_end && to == Ordering::Equal));\n+                    if !intersects {\n+                        return None;\n                     }\n                 }\n-                ty::Slice(t) => {\n-                    match value.val {\n-                        ty::ConstKind::Value(ConstValue::Slice { data, start, end }) => {\n-                            let offset = Size::from_bytes(start);\n-                            let n = (end - start) as u64;\n-                            (Cow::Borrowed(data), offset, n, t)\n-                        }\n-                        ty::ConstKind::Value(ConstValue::ByRef { .. }) => {\n-                            // FIXME(oli-obk): implement `deref` for `ConstValue`\n-                            return None;\n-                        }\n+                Str(ctor_value) => {\n+                    let pat_value = match *pat.kind {\n+                        PatKind::Constant { value } => value,\n                         _ => span_bug!(\n                             pat.span,\n-                            \"slice pattern constant must be scalar pair but is {:?}\",\n-                            value,\n+                            \"unexpected range pattern {:?} for constant value ctor\",\n+                            pat\n                         ),\n+                    };\n+\n+                    // FIXME: there's probably a more direct way of comparing for equality\n+                    if compare_const_vals(cx.tcx, ctor_value, pat_value, cx.param_env, pat.ty)?\n+                        != Ordering::Equal\n+                    {\n+                        return None;\n                     }\n                 }\n-                _ => span_bug!(\n-                    pat.span,\n-                    \"unexpected const-val {:?} with ctor {:?}\",\n-                    value,\n-                    constructor,\n-                ),\n-            };\n-            if ctor_wild_subpatterns.len() as u64 != n {\n-                return None;\n-            }\n-\n-            // Convert a constant slice/array pattern to a list of patterns.\n-            let layout = cx.tcx.layout_of(cx.param_env.and(ty)).ok()?;\n-            let ptr = Pointer::new(AllocId(0), offset);\n-            let pats = cx.pattern_arena.alloc_from_iter((0..n).filter_map(|i| {\n-                let ptr = ptr.offset(layout.size * i, &cx.tcx).ok()?;\n-                let scalar = alloc.read_scalar(&cx.tcx, ptr, layout.size).ok()?;\n-                let scalar = scalar.check_init().ok()?;\n-                let value = ty::Const::from_scalar(cx.tcx, scalar, ty);\n-                let pattern = Pat { ty, span: pat.span, kind: box PatKind::Constant { value } };\n-                Some(pattern)\n-            }));\n-            // Ensure none of the dereferences failed.\n-            if pats.len() as u64 != n {\n-                return None;\n-            }\n-            Some(Fields::from_slice_unfiltered(pats))\n-        }\n-\n-        PatKind::Constant { .. } | PatKind::Range { .. } => {\n-            // If the constructor is a:\n-            // - Single value: add a row if the pattern contains the constructor.\n-            // - Range: add a row if the constructor intersects the pattern.\n-            if let IntRange(ctor) = constructor {\n-                let pat = IntRange::from_pat(cx.tcx, cx.param_env, pat)?;\n-                ctor.intersection(cx.tcx, &pat)?;\n-                // Constructor splitting should ensure that all intersections we encounter\n-                // are actually inclusions.\n-                assert!(ctor.is_subrange(&pat));\n-            } else {\n-                // Fallback for non-ranges and ranges that involve\n-                // floating-point numbers, which are not conveniently handled\n-                // by `IntRange`. For these cases, the constructor may not be a\n-                // range so intersection actually devolves into being covered\n-                // by the pattern.\n-                constructor_covered_by_range(cx.tcx, cx.param_env, constructor, pat)?;\n+                _ => {\n+                    // If we reach here, we must be trying to inspect an opaque constant. Thus we skip\n+                    // the row.\n+                    return None;\n+                }\n             }\n             Some(Fields::empty())\n         }\n@@ -2850,21 +2637,6 @@ fn specialize_one_pattern<'p, 'tcx>(\n                 let suffix = suffix.iter().enumerate().map(|(i, p)| (arity - suffix.len() + i, p));\n                 Some(ctor_wild_subpatterns.replace_fields_indexed(prefix.chain(suffix)))\n             }\n-            ConstantValue(cv) => {\n-                match slice_pat_covered_by_const(\n-                    cx.tcx,\n-                    pat.span,\n-                    cv,\n-                    prefix,\n-                    slice,\n-                    suffix,\n-                    cx.param_env,\n-                ) {\n-                    Ok(true) => Some(Fields::empty()),\n-                    Ok(false) => None,\n-                    Err(ErrorReported) => None,\n-                }\n-            }\n             _ => span_bug!(pat.span, \"unexpected ctor {:?} for slice pat\", constructor),\n         },\n "}, {"sha": "30b700a1d4f63e6c0fb6e9dda087d4002b8597c9", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e12e97223f9f0bb0f2806334029aec1d9790f074/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e12e97223f9f0bb0f2806334029aec1d9790f074/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=e12e97223f9f0bb0f2806334029aec1d9790f074", "patch": "@@ -137,7 +137,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n         patcx.include_lint_checks();\n         let pattern = patcx.lower_pattern(pat);\n         let pattern_ty = pattern.ty;\n-        let pattern: &_ = cx.pattern_arena.alloc(expand_pattern(cx, pattern));\n+        let pattern: &_ = cx.pattern_arena.alloc(expand_pattern(pattern));\n         if !patcx.errors.is_empty() {\n             *have_errors = true;\n             patcx.report_inlining_errors(pat.span);"}, {"sha": "6370f8c375b2a91cf5d4cef7018d52f96b6e6aec", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e12e97223f9f0bb0f2806334029aec1d9790f074/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e12e97223f9f0bb0f2806334029aec1d9790f074/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=e12e97223f9f0bb0f2806334029aec1d9790f074", "patch": "@@ -387,14 +387,16 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 // `&str` and `&[u8]` are represented as `ConstValue::Slice`, let's keep using this\n                 // optimization for now.\n                 ty::Str => PatKind::Constant { value: cv },\n-                ty::Slice(elem_ty) if elem_ty == tcx.types.u8 => PatKind::Constant { value: cv },\n                 // `b\"foo\"` produces a `&[u8; 3]`, but you can't use constants of array type when\n                 // matching against references, you can only use byte string literals.\n-                // FIXME: clean this up, likely by permitting array patterns when matching on slices\n-                ty::Array(elem_ty, _) if elem_ty == tcx.types.u8 => PatKind::Constant { value: cv },\n+                // The typechecker has a special case for byte string literals, by treating them\n+                // as slices. This means we turn `&[T; N]` constants into slice patterns, which\n+                // has no negative effects on pattern matching, even if we're actually matching on\n+                // arrays.\n+                ty::Array(..) |\n                 // Cannot merge this with the catch all branch below, because the `const_deref`\n-                // changes the type from slice to array, and slice patterns behave differently from\n-                // array patterns.\n+                // changes the type from slice to array, we need to keep the original type in the\n+                // pattern.\n                 ty::Slice(..) => {\n                     let old = self.behind_reference.replace(true);\n                     let array = tcx.deref_const(self.param_env.and(cv));"}, {"sha": "25e187243416d5e412c9b552f3fbc54873739816", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e12e97223f9f0bb0f2806334029aec1d9790f074/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e12e97223f9f0bb0f2806334029aec1d9790f074/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=e12e97223f9f0bb0f2806334029aec1d9790f074", "patch": "@@ -158,6 +158,13 @@ crate enum PatKind<'tcx> {\n         subpattern: Pat<'tcx>,\n     },\n \n+    /// One of the following:\n+    /// * `&str`, which will be handled as a string pattern and thus exhaustiveness\n+    ///   checking will detect if you use the same string twice in different patterns.\n+    /// * integer, bool, char or float, which will be handled by exhaustivenes to cover exactly\n+    ///   its own value, similar to `&str`, but these values are much simpler.\n+    /// * Opaque constants, that must not be matched structurally. So anything that does not derive\n+    ///   `PartialEq` and `Eq`.\n     Constant {\n         value: &'tcx ty::Const<'tcx>,\n     },"}, {"sha": "96e8795e52d56687ceb660c8d9a5bd1833f1e8e4", "filename": "src/test/ui/consts/const_in_pattern/issue-44333.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e12e97223f9f0bb0f2806334029aec1d9790f074/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-44333.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e12e97223f9f0bb0f2806334029aec1d9790f074/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-44333.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-44333.rs?ref=e12e97223f9f0bb0f2806334029aec1d9790f074", "previous_filename": "src/test/ui/issues/issue-44333.rs"}, {"sha": "8302b09e5334d0b62919327b4258d3bbc85b69a5", "filename": "src/test/ui/consts/const_in_pattern/issue-44333.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e12e97223f9f0bb0f2806334029aec1d9790f074/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-44333.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e12e97223f9f0bb0f2806334029aec1d9790f074/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-44333.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-44333.stderr?ref=e12e97223f9f0bb0f2806334029aec1d9790f074", "previous_filename": "src/test/ui/issues/issue-44333.stderr"}, {"sha": "355ba63790f3bd2f283362803ec916ca2aa1c8b4", "filename": "src/test/ui/consts/const_in_pattern/issue-53708.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e12e97223f9f0bb0f2806334029aec1d9790f074/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-53708.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e12e97223f9f0bb0f2806334029aec1d9790f074/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-53708.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-53708.rs?ref=e12e97223f9f0bb0f2806334029aec1d9790f074", "patch": "@@ -0,0 +1,11 @@\n+// check-pass\n+// https://github.com/rust-lang/rust/issues/53708\n+#[derive(PartialEq, Eq)]\n+struct S;\n+\n+fn main() {\n+    const C: &S = &S;\n+    match C {\n+        C => {}\n+    }\n+}"}, {"sha": "69cf8404da18e34506019ef421193e7134bfbbf2", "filename": "src/test/ui/consts/const_in_pattern/issue-78057.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e12e97223f9f0bb0f2806334029aec1d9790f074/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-78057.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e12e97223f9f0bb0f2806334029aec1d9790f074/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-78057.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-78057.rs?ref=e12e97223f9f0bb0f2806334029aec1d9790f074", "patch": "@@ -0,0 +1,17 @@\n+#![deny(unreachable_patterns)]\n+\n+#[derive(PartialEq)]\n+struct Opaque(i32);\n+\n+impl Eq for Opaque {}\n+\n+const FOO: Opaque = Opaque(42);\n+\n+fn main() {\n+    match FOO {\n+        FOO => {},\n+        //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+        _ => {}\n+        //~^ ERROR unreachable pattern\n+    }\n+}"}, {"sha": "0d49d0e96c8540908508e46b7e3a651fc782ea28", "filename": "src/test/ui/consts/const_in_pattern/issue-78057.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e12e97223f9f0bb0f2806334029aec1d9790f074/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-78057.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e12e97223f9f0bb0f2806334029aec1d9790f074/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-78057.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-78057.stderr?ref=e12e97223f9f0bb0f2806334029aec1d9790f074", "patch": "@@ -0,0 +1,20 @@\n+error: to use a constant of type `Opaque` in a pattern, `Opaque` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/issue-78057.rs:12:9\n+   |\n+LL |         FOO => {},\n+   |         ^^^\n+\n+error: unreachable pattern\n+  --> $DIR/issue-78057.rs:14:9\n+   |\n+LL |         _ => {}\n+   |         ^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-78057.rs:1:9\n+   |\n+LL | #![deny(unreachable_patterns)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "f87f96e34fccdc373f5ca237d60b2596caa5bf5f", "filename": "src/test/ui/pattern/usefulness/consts-opaque.rs", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/e12e97223f9f0bb0f2806334029aec1d9790f074/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fconsts-opaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e12e97223f9f0bb0f2806334029aec1d9790f074/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fconsts-opaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fconsts-opaque.rs?ref=e12e97223f9f0bb0f2806334029aec1d9790f074", "patch": "@@ -0,0 +1,114 @@\n+// This file tests the exhaustiveness algorithm on opaque constants. Most of the examples give\n+// unnecessary warnings because const_to_pat.rs converts a constant pattern to a wildcard when the\n+// constant is not allowed as a pattern. This is an edge case so we may not care to fix it.\n+// See also https://github.com/rust-lang/rust/issues/78057\n+\n+#![deny(unreachable_patterns)]\n+\n+#[derive(PartialEq)]\n+struct Foo(i32);\n+impl Eq for Foo {}\n+const FOO: Foo = Foo(42);\n+const FOO_REF: &Foo = &Foo(42);\n+const FOO_REF_REF: &&Foo = &&Foo(42);\n+\n+#[derive(PartialEq)]\n+struct Bar;\n+impl Eq for Bar {}\n+const BAR: Bar = Bar;\n+\n+#[derive(PartialEq)]\n+enum Baz {\n+    Baz1,\n+    Baz2\n+}\n+impl Eq for Baz {}\n+const BAZ: Baz = Baz::Baz1;\n+\n+type Quux = fn(usize, usize) -> usize;\n+fn quux(a: usize, b: usize) -> usize { a + b }\n+const QUUX: Quux = quux;\n+\n+fn main() {\n+    match FOO {\n+        FOO => {}\n+        //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+        _ => {} // should not be emitting unreachable warning\n+        //~^ ERROR unreachable pattern\n+    }\n+\n+    match FOO_REF {\n+        FOO_REF => {}\n+        //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+        Foo(_) => {} // should not be emitting unreachable warning\n+        //~^ ERROR unreachable pattern\n+    }\n+\n+    // This used to cause an ICE (https://github.com/rust-lang/rust/issues/78071)\n+    match FOO_REF_REF {\n+        FOO_REF_REF => {}\n+        //~^ WARNING must be annotated with `#[derive(PartialEq, Eq)]`\n+        //~| WARNING this was previously accepted by the compiler but is being phased out\n+        Foo(_) => {}\n+    }\n+\n+    match BAR {\n+        Bar => {}\n+        BAR => {} // should not be emitting unreachable warning\n+        //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+        //~| ERROR unreachable pattern\n+        _ => {}\n+        //~^ ERROR unreachable pattern\n+    }\n+\n+    match BAR {\n+        BAR => {}\n+        //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+        Bar => {} // should not be emitting unreachable warning\n+        //~^ ERROR unreachable pattern\n+        _ => {}\n+        //~^ ERROR unreachable pattern\n+    }\n+\n+    match BAR {\n+        BAR => {}\n+        //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+        BAR => {} // should not be emitting unreachable warning\n+        //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+        //~| ERROR unreachable pattern\n+        _ => {} // should not be emitting unreachable warning\n+        //~^ ERROR unreachable pattern\n+    }\n+\n+    match BAZ {\n+        BAZ => {}\n+        //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+        Baz::Baz1 => {} // should not be emitting unreachable warning\n+        //~^ ERROR unreachable pattern\n+        _ => {}\n+        //~^ ERROR unreachable pattern\n+    }\n+\n+    match BAZ {\n+        Baz::Baz1 => {}\n+        BAZ => {}\n+        //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+        _ => {}\n+        //~^ ERROR unreachable pattern\n+    }\n+\n+    match BAZ {\n+        BAZ => {}\n+        //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+        Baz::Baz2 => {} // should not be emitting unreachable warning\n+        //~^ ERROR unreachable pattern\n+        _ => {} // should not be emitting unreachable warning\n+        //~^ ERROR unreachable pattern\n+    }\n+\n+    match QUUX {\n+        QUUX => {}\n+        QUUX => {}\n+        _ => {}\n+    }\n+}"}, {"sha": "f10166d5a35801cae7b9a33a5e32d672ad706d0e", "filename": "src/test/ui/pattern/usefulness/consts-opaque.stderr", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/e12e97223f9f0bb0f2806334029aec1d9790f074/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fconsts-opaque.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e12e97223f9f0bb0f2806334029aec1d9790f074/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fconsts-opaque.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fconsts-opaque.stderr?ref=e12e97223f9f0bb0f2806334029aec1d9790f074", "patch": "@@ -0,0 +1,158 @@\n+error: to use a constant of type `Foo` in a pattern, `Foo` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/consts-opaque.rs:34:9\n+   |\n+LL |         FOO => {}\n+   |         ^^^\n+\n+error: unreachable pattern\n+  --> $DIR/consts-opaque.rs:36:9\n+   |\n+LL |         _ => {} // should not be emitting unreachable warning\n+   |         ^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/consts-opaque.rs:6:9\n+   |\n+LL | #![deny(unreachable_patterns)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: to use a constant of type `Foo` in a pattern, `Foo` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/consts-opaque.rs:41:9\n+   |\n+LL |         FOO_REF => {}\n+   |         ^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/consts-opaque.rs:43:9\n+   |\n+LL |         Foo(_) => {} // should not be emitting unreachable warning\n+   |         ^^^^^^\n+\n+warning: to use a constant of type `Foo` in a pattern, `Foo` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/consts-opaque.rs:49:9\n+   |\n+LL |         FOO_REF_REF => {}\n+   |         ^^^^^^^^^^^\n+   |\n+   = note: `#[warn(indirect_structural_match)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #62411 <https://github.com/rust-lang/rust/issues/62411>\n+\n+error: to use a constant of type `Bar` in a pattern, `Bar` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/consts-opaque.rs:57:9\n+   |\n+LL |         BAR => {} // should not be emitting unreachable warning\n+   |         ^^^\n+\n+error: unreachable pattern\n+  --> $DIR/consts-opaque.rs:57:9\n+   |\n+LL |         Bar => {}\n+   |         --- matches any value\n+LL |         BAR => {} // should not be emitting unreachable warning\n+   |         ^^^ unreachable pattern\n+\n+error: unreachable pattern\n+  --> $DIR/consts-opaque.rs:60:9\n+   |\n+LL |         Bar => {}\n+   |         --- matches any value\n+...\n+LL |         _ => {}\n+   |         ^ unreachable pattern\n+\n+error: to use a constant of type `Bar` in a pattern, `Bar` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/consts-opaque.rs:65:9\n+   |\n+LL |         BAR => {}\n+   |         ^^^\n+\n+error: unreachable pattern\n+  --> $DIR/consts-opaque.rs:67:9\n+   |\n+LL |         Bar => {} // should not be emitting unreachable warning\n+   |         ^^^\n+\n+error: unreachable pattern\n+  --> $DIR/consts-opaque.rs:69:9\n+   |\n+LL |         Bar => {} // should not be emitting unreachable warning\n+   |         --- matches any value\n+LL |\n+LL |         _ => {}\n+   |         ^ unreachable pattern\n+\n+error: to use a constant of type `Bar` in a pattern, `Bar` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/consts-opaque.rs:74:9\n+   |\n+LL |         BAR => {}\n+   |         ^^^\n+\n+error: to use a constant of type `Bar` in a pattern, `Bar` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/consts-opaque.rs:76:9\n+   |\n+LL |         BAR => {} // should not be emitting unreachable warning\n+   |         ^^^\n+\n+error: unreachable pattern\n+  --> $DIR/consts-opaque.rs:76:9\n+   |\n+LL |         BAR => {} // should not be emitting unreachable warning\n+   |         ^^^\n+\n+error: unreachable pattern\n+  --> $DIR/consts-opaque.rs:79:9\n+   |\n+LL |         _ => {} // should not be emitting unreachable warning\n+   |         ^\n+\n+error: to use a constant of type `Baz` in a pattern, `Baz` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/consts-opaque.rs:84:9\n+   |\n+LL |         BAZ => {}\n+   |         ^^^\n+\n+error: unreachable pattern\n+  --> $DIR/consts-opaque.rs:86:9\n+   |\n+LL |         Baz::Baz1 => {} // should not be emitting unreachable warning\n+   |         ^^^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/consts-opaque.rs:88:9\n+   |\n+LL |         _ => {}\n+   |         ^\n+\n+error: to use a constant of type `Baz` in a pattern, `Baz` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/consts-opaque.rs:94:9\n+   |\n+LL |         BAZ => {}\n+   |         ^^^\n+\n+error: unreachable pattern\n+  --> $DIR/consts-opaque.rs:96:9\n+   |\n+LL |         _ => {}\n+   |         ^\n+\n+error: to use a constant of type `Baz` in a pattern, `Baz` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/consts-opaque.rs:101:9\n+   |\n+LL |         BAZ => {}\n+   |         ^^^\n+\n+error: unreachable pattern\n+  --> $DIR/consts-opaque.rs:103:9\n+   |\n+LL |         Baz::Baz2 => {} // should not be emitting unreachable warning\n+   |         ^^^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/consts-opaque.rs:105:9\n+   |\n+LL |         _ => {} // should not be emitting unreachable warning\n+   |         ^\n+\n+error: aborting due to 22 previous errors; 1 warning emitted\n+"}, {"sha": "7968f9713ff2272552e57f07f83501e0b7739953", "filename": "src/test/ui/pattern/usefulness/match-byte-array-patterns-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e12e97223f9f0bb0f2806334029aec1d9790f074/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e12e97223f9f0bb0f2806334029aec1d9790f074/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr?ref=e12e97223f9f0bb0f2806334029aec1d9790f074", "patch": "@@ -7,11 +7,11 @@ LL |     match buf {\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[u8; 4]`\n \n-error[E0004]: non-exhaustive patterns: `&[]`, `&[_]`, `&[_, _]` and 2 more not covered\n+error[E0004]: non-exhaustive patterns: `&[0_u8..=64_u8, _, _, _]` and `&[66_u8..=u8::MAX, _, _, _]` not covered\n   --> $DIR/match-byte-array-patterns-2.rs:10:11\n    |\n LL |     match buf {\n-   |           ^^^ patterns `&[]`, `&[_]`, `&[_, _]` and 2 more not covered\n+   |           ^^^ patterns `&[0_u8..=64_u8, _, _, _]` and `&[66_u8..=u8::MAX, _, _, _]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[u8]`"}]}