{"sha": "cdea73cf5b94784fdc910ab23d5d3455c868d247", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkZWE3M2NmNWI5NDc4NGZkYzkxMGFiMjNkNWQzNDU1Yzg2OGQyNDc=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-07-03T06:34:17Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-07-03T14:46:50Z"}, "message": "Convert vec::{as_imm_buf, as_mut_buf} to methods.", "tree": {"sha": "2dd80963877ed91797384bf52752e1d87a095a9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2dd80963877ed91797384bf52752e1d87a095a9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cdea73cf5b94784fdc910ab23d5d3455c868d247", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cdea73cf5b94784fdc910ab23d5d3455c868d247", "html_url": "https://github.com/rust-lang/rust/commit/cdea73cf5b94784fdc910ab23d5d3455c868d247", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cdea73cf5b94784fdc910ab23d5d3455c868d247/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a732a2daffefffb1b292c26810bec3fbb4a0b9f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/a732a2daffefffb1b292c26810bec3fbb4a0b9f9", "html_url": "https://github.com/rust-lang/rust/commit/a732a2daffefffb1b292c26810bec3fbb4a0b9f9"}], "stats": {"total": 176, "additions": 90, "deletions": 86}, "files": [{"sha": "88c61e60d86b4186cf8127ef3ae1494062640f56", "filename": "src/libextra/flate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cdea73cf5b94784fdc910ab23d5d3455c868d247/src%2Flibextra%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdea73cf5b94784fdc910ab23d5d3455c868d247/src%2Flibextra%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflate.rs?ref=cdea73cf5b94784fdc910ab23d5d3455c868d247", "patch": "@@ -45,7 +45,7 @@ static LZ_NORM : c_int = 0x80;  // LZ with 128 probes, \"normal\"\n static LZ_BEST : c_int = 0xfff; // LZ with 4095 probes, \"best\"\n \n pub fn deflate_bytes(bytes: &[u8]) -> ~[u8] {\n-    do vec::as_imm_buf(bytes) |b, len| {\n+    do bytes.as_imm_buf |b, len| {\n         unsafe {\n             let mut outsz : size_t = 0;\n             let res =\n@@ -63,7 +63,7 @@ pub fn deflate_bytes(bytes: &[u8]) -> ~[u8] {\n }\n \n pub fn inflate_bytes(bytes: &[u8]) -> ~[u8] {\n-    do vec::as_imm_buf(bytes) |b, len| {\n+    do bytes.as_imm_buf |b, len| {\n         unsafe {\n             let mut outsz : size_t = 0;\n             let res ="}, {"sha": "d56f7b32ae7d86ab96e08c9d9ea8e2e67c346517", "filename": "src/libextra/par.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cdea73cf5b94784fdc910ab23d5d3455c868d247/src%2Flibextra%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdea73cf5b94784fdc910ab23d5d3455c868d247/src%2Flibextra%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpar.rs?ref=cdea73cf5b94784fdc910ab23d5d3455c868d247", "patch": "@@ -53,7 +53,7 @@ fn map_slices<A:Copy + Send,B:Copy + Send>(\n         info!(\"spawning tasks\");\n         while base < len {\n             let end = uint::min(len, base + items_per_task);\n-            do vec::as_imm_buf(xs) |p, _len| {\n+            do xs.as_imm_buf |p, _len| {\n                 let f = f();\n                 let base = base;\n                 let f = do future_spawn() || {"}, {"sha": "69ff100784077f93c323b9fb1ec16d3cd7659473", "filename": "src/libextra/uv_ll.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cdea73cf5b94784fdc910ab23d5d3455c868d247/src%2Flibextra%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdea73cf5b94784fdc910ab23d5d3455c868d247/src%2Flibextra%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuv_ll.rs?ref=cdea73cf5b94784fdc910ab23d5d3455c868d247", "patch": "@@ -1046,7 +1046,7 @@ pub unsafe fn ip4_name(src: &sockaddr_in) -> ~str {\n     // ipv4 addr max size: 15 + 1 trailing null byte\n     let dst: ~[u8] = ~[0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n                      0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8];\n-    do vec::as_imm_buf(dst) |dst_buf, size| {\n+    do dst.as_imm_buf |dst_buf, size| {\n         rust_uv_ip4_name(to_unsafe_ptr(src),\n                                  dst_buf, size as libc::size_t);\n         // seems that checking the result of uv_ip4_name\n@@ -1066,7 +1066,7 @@ pub unsafe fn ip6_name(src: &sockaddr_in6) -> ~str {\n                        0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n                        0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n                        0u8,0u8,0u8,0u8,0u8,0u8];\n-    do vec::as_imm_buf(dst) |dst_buf, size| {\n+    do dst.as_imm_buf |dst_buf, size| {\n         let src_unsafe_ptr = to_unsafe_ptr(src);\n         let result = rust_uv_ip6_name(src_unsafe_ptr,\n                                               dst_buf, size as libc::size_t);"}, {"sha": "811138c6dbddfb0110213e4f3cc01d2cb2eac6fc", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cdea73cf5b94784fdc910ab23d5d3455c868d247/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdea73cf5b94784fdc910ab23d5d3455c868d247/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=cdea73cf5b94784fdc910ab23d5d3455c868d247", "patch": "@@ -565,7 +565,7 @@ pub fn LoadRangeAssert(cx: block, PointerVal: ValueRef, lo: c_ulonglong,\n         let min = llvm::LLVMConstInt(t, lo, signed);\n         let max = llvm::LLVMConstInt(t, hi, signed);\n \n-        do vec::as_imm_buf([min, max]) |ptr, len| {\n+        do [min, max].as_imm_buf |ptr, len| {\n             llvm::LLVMSetMetadata(value, lib::llvm::MD_range as c_uint,\n                                   llvm::LLVMMDNodeInContext(cx.fcx.ccx.llcx,\n                                                             ptr, len as c_uint));\n@@ -942,7 +942,7 @@ pub fn Call(cx: block, Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n                cx.val_to_str(Fn),\n                Args.map(|arg| cx.val_to_str(*arg)));\n \n-        do vec::as_imm_buf(Args) |ptr, len| {\n+        do Args.as_imm_buf |ptr, len| {\n             llvm::LLVMBuildCall(B(cx), Fn, ptr, len as c_uint, noname())\n         }\n     }"}, {"sha": "865fb26b94558da93879e0e8596268170fc7dbfb", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cdea73cf5b94784fdc910ab23d5d3455c868d247/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdea73cf5b94784fdc910ab23d5d3455c868d247/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=cdea73cf5b94784fdc910ab23d5d3455c868d247", "patch": "@@ -774,23 +774,23 @@ pub fn C_zero_byte_arr(size: uint) -> ValueRef {\n \n pub fn C_struct(elts: &[ValueRef]) -> ValueRef {\n     unsafe {\n-        do vec::as_imm_buf(elts) |ptr, len| {\n+        do elts.as_imm_buf |ptr, len| {\n             llvm::LLVMConstStructInContext(base::task_llcx(), ptr, len as c_uint, False)\n         }\n     }\n }\n \n pub fn C_packed_struct(elts: &[ValueRef]) -> ValueRef {\n     unsafe {\n-        do vec::as_imm_buf(elts) |ptr, len| {\n+        do elts.as_imm_buf |ptr, len| {\n             llvm::LLVMConstStructInContext(base::task_llcx(), ptr, len as c_uint, True)\n         }\n     }\n }\n \n pub fn C_named_struct(T: Type, elts: &[ValueRef]) -> ValueRef {\n     unsafe {\n-        do vec::as_imm_buf(elts) |ptr, len| {\n+        do elts.as_imm_buf |ptr, len| {\n             llvm::LLVMConstNamedStruct(T.to_ref(), ptr, len as c_uint)\n         }\n     }\n@@ -826,7 +826,7 @@ pub fn get_param(fndecl: ValueRef, param: uint) -> ValueRef {\n pub fn const_get_elt(cx: &CrateContext, v: ValueRef, us: &[c_uint])\n                   -> ValueRef {\n     unsafe {\n-        let r = do vec::as_imm_buf(us) |p, len| {\n+        let r = do us.as_imm_buf |p, len| {\n             llvm::LLVMConstExtractValue(v, p, len as c_uint)\n         };\n "}, {"sha": "38826dd411b681f7653c08321123051abd501297", "filename": "src/libstd/io.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cdea73cf5b94784fdc910ab23d5d3455c868d247/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdea73cf5b94784fdc910ab23d5d3455c868d247/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=cdea73cf5b94784fdc910ab23d5d3455c868d247", "patch": "@@ -917,7 +917,7 @@ fn convert_whence(whence: SeekStyle) -> i32 {\n impl Reader for *libc::FILE {\n     fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n         unsafe {\n-            do vec::as_mut_buf(bytes) |buf_p, buf_len| {\n+            do bytes.as_mut_buf |buf_p, buf_len| {\n                 assert!(buf_len >= len);\n \n                 let count = libc::fread(buf_p as *mut c_void, 1u as size_t,\n@@ -1152,7 +1152,7 @@ impl<W:Writer,C> Writer for Wrapper<W, C> {\n impl Writer for *libc::FILE {\n     fn write(&self, v: &[u8]) {\n         unsafe {\n-            do vec::as_imm_buf(v) |vbuf, len| {\n+            do v.as_imm_buf |vbuf, len| {\n                 let nout = libc::fwrite(vbuf as *c_void,\n                                         1,\n                                         len as size_t,\n@@ -1203,7 +1203,7 @@ impl Writer for fd_t {\n     fn write(&self, v: &[u8]) {\n         unsafe {\n             let mut count = 0u;\n-            do vec::as_imm_buf(v) |vbuf, len| {\n+            do v.as_imm_buf |vbuf, len| {\n                 while count < len {\n                     let vb = ptr::offset(vbuf, count) as *c_void;\n                     let nout = libc::write(*self, vb, len as size_t);"}, {"sha": "be0c504885b312906d377a5bc0ed7144abdfee40", "filename": "src/libstd/os.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cdea73cf5b94784fdc910ab23d5d3455c868d247/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdea73cf5b94784fdc910ab23d5d3455c868d247/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=cdea73cf5b94784fdc910ab23d5d3455c868d247", "patch": "@@ -92,7 +92,7 @@ pub fn as_c_charp<T>(s: &str, f: &fn(*c_char) -> T) -> T {\n pub fn fill_charp_buf(f: &fn(*mut c_char, size_t) -> bool)\n     -> Option<~str> {\n     let mut buf = vec::from_elem(TMPBUF_SZ, 0u8 as c_char);\n-    do vec::as_mut_buf(buf) |b, sz| {\n+    do buf.as_mut_buf |b, sz| {\n         if f(b, sz as size_t) {\n             unsafe {\n                 Some(str::raw::from_buf(b as *u8))\n@@ -122,7 +122,7 @@ pub mod win32 {\n             while !done {\n                 let mut k: DWORD = 0;\n                 let mut buf = vec::from_elem(n as uint, 0u16);\n-                do vec::as_mut_buf(buf) |b, _sz| {\n+                do buf.as_mut_buf |b, _sz| {\n                     k = f(b, TMPBUF_SZ as DWORD);\n                     if k == (0 as DWORD) {\n                         done = true;\n@@ -147,7 +147,7 @@ pub mod win32 {\n         let mut t = s.to_utf16();\n         // Null terminate before passing on.\n         t.push(0u16);\n-        vec::as_imm_buf(t, |buf, _len| f(buf))\n+        t.as_imm_buf(|buf, _len| f(buf))\n     }\n }\n \n@@ -937,7 +937,7 @@ pub fn copy_file(from: &Path, to: &Path) -> bool {\n             let mut done = false;\n             let mut ok = true;\n             while !done {\n-                do vec::as_mut_buf(buf) |b, _sz| {\n+                do buf.as_mut_buf |b, _sz| {\n                   let nread = libc::fread(b as *mut c_void, 1u as size_t,\n                                           bufsize as size_t,\n                                           istream);\n@@ -1683,7 +1683,7 @@ mod tests {\n           let s = ~\"hello\";\n           let mut buf = s.as_bytes_with_null().to_owned();\n           let len = buf.len();\n-          do vec::as_mut_buf(buf) |b, _len| {\n+          do buf.as_mut_buf |b, _len| {\n               assert_eq!(libc::fwrite(b as *c_void, 1u as size_t,\n                                       (s.len() + 1u) as size_t, ostream),\n                          len as size_t)"}, {"sha": "aee6f1bd204e3a6070d06d5013ffac9b74943f21", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cdea73cf5b94784fdc910ab23d5d3455c868d247/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdea73cf5b94784fdc910ab23d5d3455c868d247/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=cdea73cf5b94784fdc910ab23d5d3455c868d247", "patch": "@@ -406,7 +406,7 @@ pub mod ptr_tests {\n             do str::as_c_str(s1) |p1| {\n                 do str::as_c_str(s2) |p2| {\n                     let v = ~[p0, p1, p2, null()];\n-                    do vec::as_imm_buf(v) |vp, len| {\n+                    do v.as_imm_buf |vp, len| {\n                         assert_eq!(unsafe { buf_len(vp) }, 3u);\n                         assert_eq!(len, 4u);\n                     }"}, {"sha": "5054763d742b05cf3e1f7a66bc005ebd0660d336", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cdea73cf5b94784fdc910ab23d5d3455c868d247/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdea73cf5b94784fdc910ab23d5d3455c868d247/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=cdea73cf5b94784fdc910ab23d5d3455c868d247", "patch": "@@ -830,7 +830,7 @@ pub fn seed() -> ~[u8] {\n     unsafe {\n         let n = rustrt::rand_seed_size() as uint;\n         let mut s = vec::from_elem(n, 0_u8);\n-        do vec::as_mut_buf(s) |p, sz| {\n+        do s.as_mut_buf |p, sz| {\n             rustrt::rand_gen_seed(p, sz as size_t)\n         }\n         s\n@@ -1087,7 +1087,7 @@ mod tests {\n         for 10.times {\n             unsafe {\n                 let seed = super::seed();\n-                let rt_rng = do vec::as_imm_buf(seed) |p, sz| {\n+                let rt_rng = do seed.as_imm_buf |p, sz| {\n                     rustrt::rand_new_seeded(p, sz as size_t)\n                 };\n                 let mut rng = IsaacRng::new_seeded(seed);"}, {"sha": "092d736620268db78c049814d6a297fc4d30a103", "filename": "src/libstd/rt/uv/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cdea73cf5b94784fdc910ab23d5d3455c868d247/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdea73cf5b94784fdc910ab23d5d3455c868d247/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fmod.rs?ref=cdea73cf5b94784fdc910ab23d5d3455c868d247", "patch": "@@ -40,6 +40,7 @@ use str::raw::from_c_str;\n use to_str::ToStr;\n use ptr::RawPtr;\n use vec;\n+use vec::ImmutableVector;\n use ptr;\n use str;\n use libc::{c_void, c_int, size_t, malloc, free};\n@@ -300,7 +301,7 @@ pub fn vec_to_uv_buf(v: ~[u8]) -> Buf {\n     unsafe {\n         let data = malloc(v.len() as size_t) as *u8;\n         assert!(data.is_not_null());\n-        do vec::as_imm_buf(v) |b, l| {\n+        do v.as_imm_buf |b, l| {\n             let data = data as *mut u8;\n             ptr::copy_memory(data, b, l)\n         }"}, {"sha": "df15111a91f4287940f2824dff39fcdf33ed9f4e", "filename": "src/libstd/run.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cdea73cf5b94784fdc910ab23d5d3455c868d247/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdea73cf5b94784fdc910ab23d5d3455c868d247/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=cdea73cf5b94784fdc910ab23d5d3455c868d247", "patch": "@@ -24,7 +24,7 @@ use prelude::*;\n use ptr;\n use str;\n use task;\n-use vec;\n+use vec::ImmutableVector;\n \n /**\n  * A value representing a child process.\n@@ -703,7 +703,7 @@ fn with_argv<T>(prog: &str, args: &[~str],\n         argptrs.push(str::as_c_str(*t, |b| b));\n     }\n     argptrs.push(ptr::null());\n-    vec::as_imm_buf(argptrs, |buf, _len| cb(buf))\n+    argptrs.as_imm_buf(|buf, _len| cb(buf))\n }\n \n #[cfg(unix)]\n@@ -722,7 +722,7 @@ fn with_envp<T>(env: Option<&[(~str, ~str)]>, cb: &fn(*c_void) -> T) -> T {\n         }\n \n         ptrs.push(ptr::null());\n-        vec::as_imm_buf(ptrs, |p, _len|\n+        ptrs.as_imm_buf(|p, _len|\n             unsafe { cb(::cast::transmute(p)) }\n         )\n       }\n@@ -743,7 +743,7 @@ fn with_envp<T>(env: Option<&[(~str, ~str)]>, cb: &fn(*mut c_void) -> T) -> T {\n             blk.push_all(kv.as_bytes_with_null_consume());\n         }\n         blk.push(0);\n-        vec::as_imm_buf(blk, |p, _len|\n+        blk.as_imm_buf(|p, _len|\n             unsafe { cb(::cast::transmute(p)) }\n         )\n       }"}, {"sha": "564c58f7097ee90080eaa8e7d605709c02591f76", "filename": "src/libstd/str.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cdea73cf5b94784fdc910ab23d5d3455c868d247/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdea73cf5b94784fdc910ab23d5d3455c868d247/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=cdea73cf5b94784fdc910ab23d5d3455c868d247", "patch": "@@ -826,6 +826,7 @@ pub mod raw {\n     use str::raw;\n     use str::{as_buf, is_utf8};\n     use vec;\n+    use vec::MutableVector;\n \n     /// Create a Rust string from a null-terminated *u8 buffer\n     pub unsafe fn from_buf(buf: *u8) -> ~str {\n@@ -841,7 +842,7 @@ pub mod raw {\n     /// Create a Rust string from a *u8 buffer of the given length\n     pub unsafe fn from_buf_len(buf: *u8, len: uint) -> ~str {\n         let mut v: ~[u8] = vec::with_capacity(len + 1);\n-        vec::as_mut_buf(v, |vbuf, _len| {\n+        v.as_mut_buf(|vbuf, _len| {\n             ptr::copy_memory(vbuf, buf as *u8, len)\n         });\n         vec::raw::set_len(&mut v, len);\n@@ -863,7 +864,7 @@ pub mod raw {\n \n     /// Converts a vector of bytes to a new owned string.\n     pub unsafe fn from_bytes(v: &[u8]) -> ~str {\n-        do vec::as_imm_buf(v) |buf, len| {\n+        do v.as_imm_buf |buf, len| {\n             from_buf_len(buf, len)\n         }\n     }\n@@ -917,7 +918,7 @@ pub mod raw {\n             assert!((end <= n));\n \n             let mut v = vec::with_capacity(end - begin + 1u);\n-            do vec::as_imm_buf(v) |vbuf, _vlen| {\n+            do v.as_imm_buf |vbuf, _vlen| {\n                 let vbuf = ::cast::transmute_mut_unsafe(vbuf);\n                 let src = ptr::offset(sbuf, begin);\n                 ptr::copy_memory(vbuf, src, end - begin);"}, {"sha": "fb9c47b43733b1db42bc766d7e87122638ae1853", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 57, "deletions": 54, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/cdea73cf5b94784fdc910ab23d5d3455c868d247/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdea73cf5b94784fdc910ab23d5d3455c868d247/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=cdea73cf5b94784fdc910ab23d5d3455c868d247", "patch": "@@ -71,7 +71,7 @@ pub fn same_length<T, U>(xs: &[T], ys: &[U]) -> bool {\n pub fn from_fn<T>(n_elts: uint, op: &fn(uint) -> T) -> ~[T] {\n     unsafe {\n         let mut v = with_capacity(n_elts);\n-        do as_mut_buf(v) |p, _len| {\n+        do v.as_mut_buf |p, _len| {\n             let mut i: uint = 0u;\n             while i < n_elts {\n                 intrinsics::move_val_init(&mut(*ptr::mut_offset(p, i)), op(i));\n@@ -96,7 +96,7 @@ pub fn from_elem<T:Copy>(n_elts: uint, t: T) -> ~[T] {\n     // vec::with_capacity/ptr::set_memory for primitive types.\n     unsafe {\n         let mut v = with_capacity(n_elts);\n-        do as_mut_buf(v) |p, _len| {\n+        do v.as_mut_buf |p, _len| {\n             let mut i = 0u;\n             while i < n_elts {\n                 intrinsics::move_val_init(&mut(*ptr::mut_offset(p, i)), copy t);\n@@ -494,40 +494,6 @@ impl<'self, T> Iterator<&'self [T]> for VecChunkIter<'self, T> {\n     }\n }\n \n-/**\n- * Work with the buffer of a vector.\n- *\n- * Allows for unsafe manipulation of vector contents, which is useful for\n- * foreign interop.\n- */\n-#[inline]\n-pub fn as_imm_buf<T,U>(s: &[T],\n-                       /* NB---this CANNOT be const, see below */\n-                       f: &fn(*T, uint) -> U) -> U {\n-\n-    // NB---Do not change the type of s to `&const [T]`.  This is\n-    // unsound.  The reason is that we are going to create immutable pointers\n-    // into `s` and pass them to `f()`, but in fact they are potentially\n-    // pointing at *mutable memory*.  Use `as_const_buf` or `as_mut_buf`\n-    // instead!\n-\n-    unsafe {\n-        let v : *(*T,uint) = transmute(&s);\n-        let (buf,len) = *v;\n-        f(buf, len / sys::nonzero_size_of::<T>())\n-    }\n-}\n-\n-/// Similar to `as_imm_buf` but passing a `*mut T`\n-#[inline]\n-pub fn as_mut_buf<T,U>(s: &mut [T], f: &fn(*mut T, uint) -> U) -> U {\n-    unsafe {\n-        let v : *(*mut T,uint) = transmute(&s);\n-        let (buf,len) = *v;\n-        f(buf, len / sys::nonzero_size_of::<T>())\n-    }\n-}\n-\n // Equality\n \n #[cfg(not(test))]\n@@ -695,27 +661,27 @@ impl<'self, T> Container for &'self [T] {\n     /// Returns true if a vector contains no elements\n     #[inline]\n     fn is_empty(&self) -> bool {\n-        as_imm_buf(*self, |_p, len| len == 0u)\n+        self.as_imm_buf(|_p, len| len == 0u)\n     }\n \n     /// Returns the length of a vector\n     #[inline]\n     fn len(&self) -> uint {\n-        as_imm_buf(*self, |_p, len| len)\n+        self.as_imm_buf(|_p, len| len)\n     }\n }\n \n impl<T> Container for ~[T] {\n     /// Returns true if a vector contains no elements\n     #[inline]\n     fn is_empty(&self) -> bool {\n-        as_imm_buf(*self, |_p, len| len == 0u)\n+        self.as_imm_buf(|_p, len| len == 0u)\n     }\n \n     /// Returns the length of a vector\n     #[inline]\n     fn len(&self) -> uint {\n-        as_imm_buf(*self, |_p, len| len)\n+        self.as_imm_buf(|_p, len| len)\n     }\n }\n \n@@ -765,6 +731,8 @@ pub trait ImmutableVector<'self, T> {\n     fn bsearch(&self, f: &fn(&T) -> Ordering) -> Option<uint>;\n \n     fn map<U>(&self, &fn(t: &T) -> U) -> ~[U];\n+\n+    fn as_imm_buf<U>(&self, f: &fn(*T, uint) -> U) -> U;\n }\n \n /// Extension methods for vectors\n@@ -774,7 +742,7 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     fn slice(&self, start: uint, end: uint) -> &'self [T] {\n     assert!(start <= end);\n     assert!(end <= self.len());\n-        do as_imm_buf(*self) |p, _len| {\n+        do self.as_imm_buf |p, _len| {\n             unsafe {\n                 transmute((ptr::offset(p, start),\n                            (end - start) * sys::nonzero_size_of::<T>()))\n@@ -1007,6 +975,28 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U] {\n         self.iter().transform(f).collect()\n     }\n+\n+    /**\n+     * Work with the buffer of a vector.\n+     *\n+     * Allows for unsafe manipulation of vector contents, which is useful for\n+     * foreign interop.\n+     */\n+    #[inline]\n+    fn as_imm_buf<U>(&self,\n+                     /* NB---this CANNOT be const, see below */\n+                     f: &fn(*T, uint) -> U) -> U {\n+        // NB---Do not change the type of s to `&const [T]`.  This is\n+        // unsound.  The reason is that we are going to create immutable pointers\n+        // into `s` and pass them to `f()`, but in fact they are potentially\n+        // pointing at *mutable memory*.  Use `as_mut_buf` instead!\n+\n+        unsafe {\n+            let v : *(*T,uint) = transmute(self);\n+            let (buf,len) = *v;\n+            f(buf, len / sys::nonzero_size_of::<T>())\n+        }\n+    }\n }\n \n #[allow(missing_doc)]\n@@ -1280,7 +1270,7 @@ impl<T> OwnedVector<T> for ~[T] {\n         let new_len = self.len() + rhs.len();\n         self.reserve(new_len);\n         unsafe {\n-            do as_mut_buf(rhs) |p, len| {\n+            do rhs.as_mut_buf |p, len| {\n                 for uint::range(0, len) |i| {\n                     let x = ptr::replace_ptr(ptr::mut_offset(p, i),\n                                              intrinsics::uninit());\n@@ -1412,7 +1402,7 @@ impl<T> OwnedVector<T> for ~[T] {\n \n     /// Shorten a vector, dropping excess elements.\n     fn truncate(&mut self, newlen: uint) {\n-        do as_mut_buf(*self) |p, oldlen| {\n+        do self.as_mut_buf |p, oldlen| {\n             assert!(newlen <= oldlen);\n             unsafe {\n                 // This loop is optimized out for non-drop types.\n@@ -1570,7 +1560,7 @@ impl<T:Eq> OwnedEqVector<T> for ~[T] {\n             if self.len() == 0 { return; }\n             let mut last_written = 0;\n             let mut next_to_read = 1;\n-            do as_mut_buf(*self) |p, ln| {\n+            do self.as_mut_buf |p, ln| {\n                 // last_written < next_to_read <= ln\n                 while next_to_read < ln {\n                     // last_written < next_to_read < ln\n@@ -1624,6 +1614,8 @@ pub trait MutableVector<'self, T> {\n \n     unsafe fn unsafe_mut_ref(&self, index: uint) -> *mut T;\n     unsafe fn unsafe_set(&self, index: uint, val: T);\n+\n+    fn as_mut_buf<U>(&self, f: &fn(*mut T, uint) -> U) -> U;\n }\n \n impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n@@ -1632,7 +1624,7 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n     fn mut_slice(self, start: uint, end: uint) -> &'self mut [T] {\n         assert!(start <= end);\n         assert!(end <= self.len());\n-        do as_mut_buf(self) |p, _len| {\n+        do self.as_mut_buf |p, _len| {\n             unsafe {\n                 transmute((ptr::mut_offset(p, start),\n                            (end - start) * sys::nonzero_size_of::<T>()))\n@@ -1705,6 +1697,17 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n     unsafe fn unsafe_set(&self, index: uint, val: T) {\n         *self.unsafe_mut_ref(index) = val;\n     }\n+\n+    /// Similar to `as_imm_buf` but passing a `*mut T`\n+    #[inline]\n+    fn as_mut_buf<U>(&self, f: &fn(*mut T, uint) -> U) -> U {\n+        unsafe {\n+            let v : *(*mut T,uint) = transmute(self);\n+            let (buf,len) = *v;\n+            f(buf, len / sys::nonzero_size_of::<T>())\n+        }\n+    }\n+\n }\n \n /// Trait for ~[T] where T is Cloneable\n@@ -1754,7 +1757,7 @@ pub mod raw {\n     use ptr;\n     use sys;\n     use unstable::intrinsics;\n-    use vec::{UnboxedVecRepr, as_imm_buf, as_mut_buf, with_capacity};\n+    use vec::{UnboxedVecRepr, with_capacity, ImmutableVector, MutableVector};\n     use util;\n \n     /// The internal representation of a (boxed) vector\n@@ -1842,7 +1845,7 @@ pub mod raw {\n      */\n     #[inline]\n     pub unsafe fn get<T:Copy>(v: &[T], i: uint) -> T {\n-        as_imm_buf(v, |p, _len| copy *ptr::offset(p, i))\n+        v.as_imm_buf(|p, _len| copy *ptr::offset(p, i))\n     }\n \n     /**\n@@ -1853,7 +1856,7 @@ pub mod raw {\n     #[inline]\n     pub unsafe fn init_elem<T>(v: &mut [T], i: uint, val: T) {\n         let mut box = Some(val);\n-        do as_mut_buf(v) |p, _len| {\n+        do v.as_mut_buf |p, _len| {\n             let box2 = util::replace(&mut box, None);\n             intrinsics::move_val_init(&mut(*ptr::mut_offset(p, i)),\n                                       box2.unwrap());\n@@ -1873,7 +1876,7 @@ pub mod raw {\n     pub unsafe fn from_buf_raw<T>(ptr: *T, elts: uint) -> ~[T] {\n         let mut dst = with_capacity(elts);\n         set_len(&mut dst, elts);\n-        as_mut_buf(dst, |p_dst, _len_dst| ptr::copy_memory(p_dst, ptr, elts));\n+        dst.as_mut_buf(|p_dst, _len_dst| ptr::copy_memory(p_dst, ptr, elts));\n         dst\n     }\n \n@@ -1889,8 +1892,8 @@ pub mod raw {\n         assert!(dst.len() >= count);\n         assert!(src.len() >= count);\n \n-        do as_mut_buf(dst) |p_dst, _len_dst| {\n-            do as_imm_buf(src) |p_src, _len_src| {\n+        do dst.as_mut_buf |p_dst, _len_dst| {\n+            do src.as_imm_buf |p_src, _len_src| {\n                 ptr::copy_memory(p_dst, p_src, count)\n             }\n         }\n@@ -1914,7 +1917,7 @@ pub mod bytes {\n     impl<'self> MutableByteVector for &'self mut [u8] {\n         #[inline]\n         fn set_memory(self, value: u8) {\n-            do vec::as_mut_buf(self) |p, len| {\n+            do self.as_mut_buf |p, len| {\n                 unsafe { ptr::set_memory(p, value, len) };\n             }\n         }\n@@ -2920,7 +2923,7 @@ mod tests {\n     #[should_fail]\n     fn test_as_imm_buf_fail() {\n         let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        do as_imm_buf(v) |_buf, _i| {\n+        do v.as_imm_buf |_buf, _i| {\n             fail!()\n         }\n     }\n@@ -2930,7 +2933,7 @@ mod tests {\n     #[should_fail]\n     fn test_as_mut_buf_fail() {\n         let mut v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        do as_mut_buf(v) |_buf, _i| {\n+        do v.as_mut_buf |_buf, _i| {\n             fail!()\n         }\n     }"}, {"sha": "0fdaf31c59361a13adb460e4a98878331cca8d0c", "filename": "src/test/run-fail/bug-2470-bounds-check-overflow.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cdea73cf5b94784fdc910ab23d5d3455c868d247/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdea73cf5b94784fdc910ab23d5d3455c868d247/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs?ref=cdea73cf5b94784fdc910ab23d5d3455c868d247", "patch": "@@ -11,7 +11,6 @@\n // error-pattern:index out of bounds\n \n use std::sys;\n-use std::vec;\n \n fn main() {\n \n@@ -22,7 +21,7 @@ fn main() {\n     // huge).\n \n     let x = ~[1u,2u,3u];\n-    do vec::as_imm_buf(x) |p, _len| {\n+    do x.as_imm_buf |p, _len| {\n         let base = p as uint;\n         let idx = base / sys::size_of::<uint>();\n         error!(\"ov1 base = 0x%x\", base);"}]}