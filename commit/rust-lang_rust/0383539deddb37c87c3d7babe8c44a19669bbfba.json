{"sha": "0383539deddb37c87c3d7babe8c44a19669bbfba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzODM1MzlkZWRkYjM3Yzg3YzNkN2JhYmU4YzQ0YTE5NjY5YmJmYmE=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-14T18:25:26Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-16T19:10:01Z"}, "message": "Fix handling of floating-point ranges", "tree": {"sha": "d374fc6d4cb2cd7f157ea34580531350071b685c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d374fc6d4cb2cd7f157ea34580531350071b685c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0383539deddb37c87c3d7babe8c44a19669bbfba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0383539deddb37c87c3d7babe8c44a19669bbfba", "html_url": "https://github.com/rust-lang/rust/commit/0383539deddb37c87c3d7babe8c44a19669bbfba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0383539deddb37c87c3d7babe8c44a19669bbfba/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1dbc78112f29d12175ff56c9271ac47c042a718a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1dbc78112f29d12175ff56c9271ac47c042a718a", "html_url": "https://github.com/rust-lang/rust/commit/1dbc78112f29d12175ff56c9271ac47c042a718a"}], "stats": {"total": 23, "additions": 15, "deletions": 8}, "files": [{"sha": "22345f4322c13c66adb0dcf56878e76a3f9c549c", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0383539deddb37c87c3d7babe8c44a19669bbfba/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0383539deddb37c87c3d7babe8c44a19669bbfba/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=0383539deddb37c87c3d7babe8c44a19669bbfba", "patch": "@@ -1360,6 +1360,19 @@ fn slice_pat_covered_by_constructor<'tcx>(\n     Ok(true)\n }\n \n+// Whether to evaluate a constructor using exhaustive integer matching. This is true if the\n+// constructor is a range or constant with an integer type.\n+fn should_treat_range_exhaustively(tcx: TyCtxt<'_, 'tcx, 'tcx>, ctor: &Constructor<'tcx>) -> bool {\n+    if tcx.features().exhaustive_integer_patterns {\n+        if let ConstantValue(value) | ConstantRange(value, _, _) = ctor {\n+            if let ty::TyChar | ty::TyInt(_) | ty::TyUint(_) = value.ty.sty {\n+                return true;\n+            }\n+        }\n+    }\n+    false\n+}\n+\n /// For exhaustive integer matching, some constructors are grouped within other constructors\n /// (namely integer typed values are grouped within ranges). However, when specialising these\n /// constructors, we want to be specialising for the underlying constructors (the integers), not\n@@ -1394,7 +1407,7 @@ fn split_grouped_constructors<'p, 'a: 'p, 'tcx: 'a>(\n         match ctor {\n             // For now, only ranges may denote groups of \"subconstructors\", so we only need to\n             // special-case constant ranges.\n-            ConstantRange(..) => {\n+            ConstantRange(..) if should_treat_range_exhaustively(tcx, &ctor) => {\n                 // We only care about finding all the subranges within the range of the intersection\n                 // of the new pattern `p_({m + 1},1)` (here `pat`) and the constructor range.\n                 // Anything else is irrelevant, because it is guaranteed to result in `NotUseful`,\n@@ -1509,13 +1522,7 @@ fn constructor_intersects_pattern<'p, 'a: 'p, 'tcx: 'a>(\n     ctor: &Constructor<'tcx>,\n     pat: &'p Pattern<'tcx>,\n ) -> Option<Vec<&'p Pattern<'tcx>>> {\n-    let mut integer_matching = false;\n-    if let ConstantValue(value) | ConstantRange(value, _, _) = ctor {\n-        if let ty::TyChar | ty::TyInt(_) | ty::TyUint(_) = value.ty.sty {\n-            integer_matching = true;\n-        }\n-    }\n-    if integer_matching {\n+    if should_treat_range_exhaustively(tcx, ctor) {\n         match (IntRange::from_ctor(tcx, ctor), IntRange::from_pat(tcx, pat)) {\n             (Some(ctor), Some(pat)) => ctor.intersection(&pat).map(|_| vec![]),\n             _ => None,"}]}