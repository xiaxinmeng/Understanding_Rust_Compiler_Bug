{"sha": "efc512362b0f2ae200ef079e3566c6b158a857cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmYzUxMjM2MmIwZjJhZTIwMGVmMDc5ZTM1NjZjNmIxNThhODU3Y2M=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-11-21T00:23:04Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-11-26T16:24:18Z"}, "message": "libsyntax: Remove all non-`proc` `do` syntax.", "tree": {"sha": "f13bd8c52a12ebff5bc304312aa9708bf34780dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f13bd8c52a12ebff5bc304312aa9708bf34780dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/efc512362b0f2ae200ef079e3566c6b158a857cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/efc512362b0f2ae200ef079e3566c6b158a857cc", "html_url": "https://github.com/rust-lang/rust/commit/efc512362b0f2ae200ef079e3566c6b158a857cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/efc512362b0f2ae200ef079e3566c6b158a857cc/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a61a3678ebe5571842d4223e2a0313714893bbf7", "url": "https://api.github.com/repos/rust-lang/rust/commits/a61a3678ebe5571842d4223e2a0313714893bbf7", "html_url": "https://github.com/rust-lang/rust/commit/a61a3678ebe5571842d4223e2a0313714893bbf7"}], "stats": {"total": 370, "additions": 178, "deletions": 192}, "files": [{"sha": "9f69379f3c58cbd42169b918959d2d9ff4803086", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=efc512362b0f2ae200ef079e3566c6b158a857cc", "patch": "@@ -104,14 +104,14 @@ pub fn lookup(name: &str) -> Option<Abi> {\n \n     let mut res = None;\n \n-    do each_abi |abi| {\n+    each_abi(|abi| {\n         if name == abi.data().name {\n             res = Some(abi);\n             false\n         } else {\n             true\n         }\n-    };\n+    });\n     res\n }\n \n@@ -217,21 +217,21 @@ impl AbiSet {\n \n         let mut res = None;\n \n-        do self.each |abi| {\n+        self.each(|abi| {\n             let data = abi.data();\n             match data.abi_arch {\n                 Archs(a) if (a & arch.bit()) != 0 => { res = Some(abi); false }\n                 Archs(_) => { true }\n                 RustArch | AllArch => { res = Some(abi); false }\n             }\n-        };\n+        });\n \n         res.map(|r| r.for_target(os, arch))\n     }\n \n     pub fn check_valid(&self) -> Option<(Abi, Abi)> {\n         let mut abis = ~[];\n-        do self.each |abi| { abis.push(abi); true };\n+        self.each(|abi| { abis.push(abi); true });\n \n         for (i, abi) in abis.iter().enumerate() {\n             let data = abi.data();\n@@ -285,10 +285,10 @@ impl ToStr for Abi {\n impl ToStr for AbiSet {\n     fn to_str(&self) -> ~str {\n         let mut strs = ~[];\n-        do self.each |abi| {\n+        self.each(|abi| {\n             strs.push(abi.data().name);\n             true\n-        };\n+        });\n         format!(\"\\\"{}\\\"\", strs.connect(\" \"))\n     }\n }"}, {"sha": "32b270643afd23069ee273db7730dd1cf4c90369", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=efc512362b0f2ae200ef079e3566c6b158a857cc", "patch": "@@ -52,13 +52,13 @@ pub type path = ~[path_elt];\n \n pub fn path_to_str_with_sep(p: &[path_elt], sep: &str, itr: @ident_interner)\n                          -> ~str {\n-    let strs = do p.map |e| {\n+    let strs = p.map(|e| {\n         match *e {\n             path_mod(s) | path_name(s) | path_pretty_name(s, _) => {\n                 itr.get(s.name)\n             }\n         }\n-    };\n+    });\n     strs.connect(sep)\n }\n "}, {"sha": "ef3c23f515380c1f3b2b230cd49e37b8ae8ebefc", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=efc512362b0f2ae200ef079e3566c6b158a857cc", "patch": "@@ -254,12 +254,12 @@ pub fn unguarded_pat(a: &Arm) -> Option<~[@Pat]> {\n }\n \n pub fn public_methods(ms: ~[@method]) -> ~[@method] {\n-    do ms.move_iter().filter |m| {\n+    ms.move_iter().filter(|m| {\n         match m.vis {\n             public => true,\n             _   => false\n         }\n-    }.collect()\n+    }).collect()\n }\n \n // extract a TypeMethod from a trait_method. if the trait_method is"}, {"sha": "ecde00aa3021141a9c973978146d284e76ab0133", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=efc512362b0f2ae200ef079e3566c6b158a857cc", "patch": "@@ -169,18 +169,18 @@ pub fn mk_sugared_doc_attr(text: @str, lo: BytePos, hi: BytePos) -> Attribute {\n pub fn contains(haystack: &[@ast::MetaItem],\n                 needle: @ast::MetaItem) -> bool {\n     debug!(\"attr::contains (name={})\", needle.name());\n-    do haystack.iter().any |item| {\n+    haystack.iter().any(|item| {\n         debug!(\"  testing: {}\", item.name());\n         item.node == needle.node\n-    }\n+    })\n }\n \n pub fn contains_name<AM: AttrMetaMethods>(metas: &[AM], name: &str) -> bool {\n     debug!(\"attr::contains_name (name={})\", name);\n-    do metas.iter().any |item| {\n+    metas.iter().any(|item| {\n         debug!(\"  testing: {}\", item.name());\n         name == item.name()\n-    }\n+    })\n }\n \n pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: &str)\n@@ -204,12 +204,10 @@ pub fn sort_meta_items(items: &[@MetaItem]) -> ~[@MetaItem] {\n         .map(|&mi| (mi.name(), mi))\n         .collect::<~[(@str, @MetaItem)]>();\n \n-    do extra::sort::quick_sort(v) |&(a, _), &(b, _)| {\n-        a <= b\n-    }\n+    extra::sort::quick_sort(v, |&(a, _), &(b, _)| a <= b);\n \n     // There doesn't seem to be a more optimal way to do this\n-    do v.move_iter().map |(_, m)| {\n+    v.move_iter().map(|(_, m)| {\n         match m.node {\n             MetaList(n, ref mis) => {\n                 @Spanned {\n@@ -219,7 +217,7 @@ pub fn sort_meta_items(items: &[@MetaItem]) -> ~[@MetaItem] {\n             }\n             _ => m\n         }\n-    }.collect()\n+    }).collect()\n }\n \n /**\n@@ -248,7 +246,7 @@ pub enum InlineAttr {\n /// True if something like #[inline] is found in the list of attrs.\n pub fn find_inline_attr(attrs: &[Attribute]) -> InlineAttr {\n     // FIXME (#2809)---validate the usage of #[inline] and #[inline]\n-    do attrs.iter().fold(InlineNone) |ia,attr| {\n+    attrs.iter().fold(InlineNone, |ia,attr| {\n         match attr.node.value.node {\n           MetaWord(n) if \"inline\" == n => InlineHint,\n           MetaList(n, ref items) if \"inline\" == n => {\n@@ -262,7 +260,7 @@ pub fn find_inline_attr(attrs: &[Attribute]) -> InlineAttr {\n           }\n           _ => ia\n         }\n-    }\n+    })\n }\n \n /// Tests if any `cfg(...)` meta items in `metas` match `cfg`. e.g.\n@@ -278,7 +276,7 @@ pub fn test_cfg<AM: AttrMetaMethods, It: Iterator<AM>>\n \n     // this would be much nicer as a chain of iterator adaptors, but\n     // this doesn't work.\n-    let some_cfg_matches = do metas.any |mi| {\n+    let some_cfg_matches = metas.any(|mi| {\n         debug!(\"testing name: {}\", mi.name());\n         if \"cfg\" == mi.name() { // it is a #[cfg()] attribute\n             debug!(\"is cfg\");\n@@ -287,7 +285,7 @@ pub fn test_cfg<AM: AttrMetaMethods, It: Iterator<AM>>\n             match mi.meta_item_list() {\n                 Some(cfg_meta) => {\n                     debug!(\"is cfg(...)\");\n-                    do cfg_meta.iter().all |cfg_mi| {\n+                    cfg_meta.iter().all(|cfg_mi| {\n                         debug!(\"cfg({}[...])\", cfg_mi.name());\n                         match cfg_mi.node {\n                             ast::MetaList(s, ref not_cfgs) if \"not\" == s => {\n@@ -301,14 +299,14 @@ pub fn test_cfg<AM: AttrMetaMethods, It: Iterator<AM>>\n                             }\n                             _ => contains(cfg, *cfg_mi)\n                         }\n-                    }\n+                    })\n                 }\n                 None => false\n             }\n         } else {\n             false\n         }\n-    };\n+    });\n     debug!(\"test_cfg (no_cfgs={}, some_cfg_matches={})\", no_cfgs, some_cfg_matches);\n     no_cfgs || some_cfg_matches\n }"}, {"sha": "36e6bf32451f9199b92c9fbbc952d46be2452646", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=efc512362b0f2ae200ef079e3566c6b158a857cc", "patch": "@@ -314,9 +314,7 @@ fn highlight_lines(cm: @codemap::CodeMap,\n         // Skip is the number of characters we need to skip because they are\n         // part of the 'filename:line ' part of the previous line.\n         let skip = fm.name.len() + digits + 3u;\n-        do skip.times() {\n-            s.push_char(' ');\n-        }\n+        skip.times(|| s.push_char(' '));\n         let orig = fm.get_line(lines.lines[0] as int);\n         for pos in range(0u, left-skip) {\n             let curChar = (orig[pos] as char);\n@@ -335,9 +333,7 @@ fn highlight_lines(cm: @codemap::CodeMap,\n         if hi.col != lo.col {\n             // the ^ already takes up one space\n             let num_squigglies = hi.col.to_uint()-lo.col.to_uint()-1u;\n-            do num_squigglies.times() {\n-                s.push_char('~')\n-            }\n+            num_squigglies.times(|| s.push_char('~'));\n         }\n         print_maybe_styled(s + \"\\n\", term::attr::ForegroundColor(diagnosticcolor(lvl)));\n     }"}, {"sha": "2a7f6dfe2d20a112b23cd7ae2e542bf8b94ec397", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=efc512362b0f2ae200ef079e3566c6b158a857cc", "patch": "@@ -370,9 +370,9 @@ impl AstBuilder for @ExtCtxt {\n     }\n \n     fn strip_bounds(&self, generics: &Generics) -> Generics {\n-        let new_params = do generics.ty_params.map |ty_param| {\n+        let new_params = generics.ty_params.map(|ty_param| {\n             ast::TyParam { bounds: opt_vec::Empty, ..*ty_param }\n-        };\n+        });\n         Generics {\n             ty_params: new_params,\n             .. (*generics).clone()\n@@ -883,9 +883,9 @@ impl AstBuilder for @ExtCtxt {\n \n     fn view_use_list(&self, sp: Span, vis: ast::visibility,\n                      path: ~[ast::Ident], imports: &[ast::Ident]) -> ast::view_item {\n-        let imports = do imports.map |id| {\n+        let imports = imports.map(|id| {\n             respan(sp, ast::path_list_ident_ { name: *id, id: ast::DUMMY_NODE_ID })\n-        };\n+        });\n \n         self.view_use(sp, vis,\n                       ~[@respan(sp,"}, {"sha": "6dd358144a474e37a0b5a935f65febc3e9cfeda9", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=efc512362b0f2ae200ef079e3566c6b158a857cc", "patch": "@@ -103,15 +103,15 @@ fn cs_clone(\n         },\n         _ => {\n             // struct-like\n-            let fields = do all_fields.map |field| {\n+            let fields = all_fields.map(|field| {\n                 let ident = match field.name {\n                     Some(i) => i,\n                     None => cx.span_bug(span,\n                                         format!(\"unnamed field in normal struct in `deriving({})`\",\n                                              name))\n                 };\n                 cx.field_imm(span, ident, subcall(field.self_))\n-            };\n+            });\n \n             if fields.is_empty() {\n                 // no fields, so construct like `None`"}, {"sha": "4ab0cc3bc67f59e6dd977bd95e310ac5f0e83309", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=efc512362b0f2ae200ef079e3566c6b158a857cc", "patch": "@@ -70,13 +70,16 @@ fn decodable_substructure(cx: @ExtCtxt, span: Span,\n             };\n             let read_struct_field = cx.ident_of(\"read_struct_field\");\n \n-            let result = do decode_static_fields(cx, span, substr.type_ident,\n-                                                 summary) |span, name, field| {\n+            let result = decode_static_fields(cx,\n+                                              span,\n+                                              substr.type_ident,\n+                                              summary,\n+                                              |span, name, field| {\n                 cx.expr_method_call(span, blkdecoder, read_struct_field,\n                                     ~[cx.expr_str(span, name),\n                                       cx.expr_uint(span, field),\n                                       lambdadecode])\n-            };\n+            });\n             cx.expr_method_call(span, decoder, cx.ident_of(\"read_struct\"),\n                                 ~[cx.expr_str(span, cx.str_of(substr.type_ident)),\n                                   cx.expr_uint(span, nfields),\n@@ -93,12 +96,15 @@ fn decodable_substructure(cx: @ExtCtxt, span: Span,\n                 let (name, parts) = match *f { (i, ref p) => (i, p) };\n                 variants.push(cx.expr_str(span, cx.str_of(name)));\n \n-                let decoded = do decode_static_fields(cx, span, name,\n-                                                      parts) |span, _, field| {\n+                let decoded = decode_static_fields(cx,\n+                                                   span,\n+                                                   name,\n+                                                   parts,\n+                                                   |span, _, field| {\n                     cx.expr_method_call(span, blkdecoder, rvariant_arg,\n                                         ~[cx.expr_uint(span, field),\n                                           lambdadecode])\n-                };\n+                });\n \n                 arms.push(cx.arm(span,\n                                  ~[cx.pat_lit(span, cx.expr_uint(span, i))],\n@@ -135,18 +141,18 @@ fn decode_static_fields(cx: @ExtCtxt,\n             if fields.is_empty() {\n                 cx.expr_ident(outer_span, outer_pat_ident)\n             } else {\n-                let fields = do fields.iter().enumerate().map |(i, &span)| {\n+                let fields = fields.iter().enumerate().map(|(i, &span)| {\n                     getarg(span, format!(\"_field{}\", i).to_managed(), i)\n-                }.collect();\n+                }).collect();\n \n                 cx.expr_call_ident(outer_span, outer_pat_ident, fields)\n             }\n         }\n         Named(ref fields) => {\n             // use the field's span to get nicer error messages.\n-            let fields = do fields.iter().enumerate().map |(i, &(name, span))| {\n+            let fields = fields.iter().enumerate().map(|(i, &(name, span))| {\n                 cx.field_imm(span, name, getarg(span, cx.str_of(name), i))\n-            }.collect();\n+            }).collect();\n             cx.expr_struct_ident(outer_span, outer_pat_ident, fields)\n         }\n     }"}, {"sha": "015083f11d35ba4128746547854390fe0b91a68c", "filename": "src/libsyntax/ext/deriving/default.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs?ref=efc512362b0f2ae200ef079e3566c6b158a857cc", "patch": "@@ -60,9 +60,9 @@ fn default_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Exp\n                     }\n                 }\n                 Named(ref fields) => {\n-                    let default_fields = do fields.map |&(ident, span)| {\n+                    let default_fields = fields.map(|&(ident, span)| {\n                         cx.field_imm(span, ident, default_call(span))\n-                    };\n+                    });\n                     cx.expr_struct_ident(span, substr.type_ident, default_fields)\n                 }\n             }"}, {"sha": "96b77c4c16246f32a6d14ecdaac1be5242982275", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=efc512362b0f2ae200ef079e3566c6b158a857cc", "patch": "@@ -24,19 +24,19 @@ would generate two implementations like:\n \n impl<S:extra::serialize::Encoder> Encodable<S> for Node {\n     fn encode(&self, s: &S) {\n-        do s.emit_struct(\"Node\", 1) {\n+        s.emit_struct(\"Node\", 1, || {\n             s.emit_field(\"id\", 0, || s.emit_uint(self.id))\n-        }\n+        })\n     }\n }\n \n impl<D:Decoder> Decodable for node_id {\n     fn decode(d: &D) -> Node {\n-        do d.read_struct(\"Node\", 1) {\n+        d.read_struct(\"Node\", 1, || {\n             Node {\n                 id: d.read_field(~\"x\", 0, || decode(d))\n             }\n-        }\n+        })\n     }\n }\n \n@@ -53,10 +53,10 @@ would yield functions like:\n         T: Encodable<S>\n     > spanned<T>: Encodable<S> {\n         fn encode<S:Encoder>(s: &S) {\n-            do s.emit_rec {\n+            s.emit_rec(|| {\n                 s.emit_field(\"node\", 0, || self.node.encode(s));\n                 s.emit_field(\"span\", 1, || self.span.encode(s));\n-            }\n+            })\n         }\n     }\n \n@@ -65,12 +65,12 @@ would yield functions like:\n         T: Decodable<D>\n     > spanned<T>: Decodable<D> {\n         fn decode(d: &D) -> spanned<T> {\n-            do d.read_rec {\n+            d.read_rec(|| {\n                 {\n                     node: d.read_field(~\"node\", 0, || decode(d)),\n                     span: d.read_field(~\"span\", 1, || decode(d)),\n                 }\n-            }\n+            })\n         }\n     }\n */"}, {"sha": "614c719e0a2be2a33020c790b7b9c923f7d8bda9", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=efc512362b0f2ae200ef079e3566c6b158a857cc", "patch": "@@ -362,9 +362,9 @@ impl<'self> TraitDef<'self> {\n             // a TyParamBound requires an ast id\n             let mut bounds = opt_vec::from(\n                 // extra restrictions on the generics parameters to the type being derived upon\n-                do self.additional_bounds.map |p| {\n+                self.additional_bounds.map(|p| {\n                     cx.typarambound(p.to_path(cx, trait_span, type_ident, generics))\n-                });\n+                }));\n             // require the current trait\n             bounds.push(cx.typarambound(trait_path.clone()));\n \n@@ -375,9 +375,9 @@ impl<'self> TraitDef<'self> {\n         let trait_ref = cx.trait_ref(trait_path);\n \n         // Create the type parameters on the `self` path.\n-        let self_ty_params = do generics.ty_params.map |ty_param| {\n+        let self_ty_params = generics.ty_params.map(|ty_param| {\n             cx.ty_ident(trait_span, ty_param.ident)\n-        };\n+        });\n \n         let self_lifetimes = generics.lifetimes.clone();\n \n@@ -405,7 +405,7 @@ impl<'self> TraitDef<'self> {\n                          struct_def: &struct_def,\n                          type_ident: Ident,\n                          generics: &Generics) -> @ast::item {\n-        let methods = do self.methods.map |method_def| {\n+        let methods = self.methods.map(|method_def| {\n             let (explicit_self, self_args, nonself_args, tys) =\n                 method_def.split_self_nonself_args(cx, trait_span, type_ident, generics);\n \n@@ -426,7 +426,7 @@ impl<'self> TraitDef<'self> {\n                                      type_ident, generics,\n                                      explicit_self, tys,\n                                      body)\n-        };\n+        });\n \n         self.create_derived_impl(cx, trait_span, type_ident, generics, methods)\n     }\n@@ -436,7 +436,7 @@ impl<'self> TraitDef<'self> {\n                        enum_def: &enum_def,\n                        type_ident: Ident,\n                        generics: &Generics) -> @ast::item {\n-        let methods = do self.methods.map |method_def| {\n+        let methods = self.methods.map(|method_def| {\n             let (explicit_self, self_args, nonself_args, tys) =\n                 method_def.split_self_nonself_args(cx, trait_span, type_ident, generics);\n \n@@ -457,7 +457,7 @@ impl<'self> TraitDef<'self> {\n                                      type_ident, generics,\n                                      explicit_self, tys,\n                                      body)\n-        };\n+        });\n \n         self.create_derived_impl(cx, trait_span, type_ident, generics, methods)\n     }\n@@ -547,9 +547,9 @@ impl<'self> MethodDef<'self> {\n         // create the generics that aren't for Self\n         let fn_generics = self.generics.to_generics(cx, trait_span, type_ident, generics);\n \n-        let args = do arg_types.move_iter().map |(name, ty)| {\n+        let args = arg_types.move_iter().map(|(name, ty)| {\n             cx.arg(trait_span, name, ty)\n-        }.collect();\n+        }).collect();\n \n         let ret_type = self.get_ret_ty(cx, trait_span, generics, type_ident);\n \n@@ -624,19 +624,19 @@ impl<'self> MethodDef<'self> {\n         // transpose raw_fields\n         let fields = match raw_fields {\n             [ref self_arg, .. rest] => {\n-                do self_arg.iter().enumerate().map |(i, &(span, opt_id, field))| {\n-                    let other_fields = do rest.map |l| {\n+                self_arg.iter().enumerate().map(|(i, &(span, opt_id, field))| {\n+                    let other_fields = rest.map(|l| {\n                         match &l[i] {\n                             &(_, _, ex) => ex\n                         }\n-                    };\n+                    });\n                     FieldInfo {\n                         span: span,\n                         name: opt_id,\n                         self_: field,\n                         other: other_fields\n                     }\n-                }.collect()\n+                }).collect()\n             }\n             [] => { cx.span_bug(trait_span, \"No self arguments to non-static \\\n                                        method in generic `deriving`\") }\n@@ -787,16 +787,16 @@ impl<'self> MethodDef<'self> {\n                         }\n                     }\n                     let field_tuples =\n-                        do self_vec.iter()\n-                           .zip(enum_matching_fields.iter())\n-                           .map |(&(span, id, self_f), other)| {\n+                        self_vec.iter()\n+                                .zip(enum_matching_fields.iter())\n+                                .map(|(&(span, id, self_f), other)| {\n                         FieldInfo {\n                             span: span,\n                             name: id,\n                             self_: self_f,\n                             other: (*other).clone()\n                         }\n-                    }.collect();\n+                    }).collect();\n                     substructure = EnumMatching(variant_index, variant, field_tuples);\n                 }\n                 None => {\n@@ -901,7 +901,7 @@ impl<'self> MethodDef<'self> {\n                                       self_args: &[@Expr],\n                                       nonself_args: &[@Expr])\n         -> @Expr {\n-        let summary = do enum_def.variants.map |v| {\n+        let summary = enum_def.variants.map(|v| {\n             let ident = v.node.name;\n             let summary = match v.node.kind {\n                 ast::tuple_variant_kind(ref args) => Unnamed(args.map(|va| va.ty.span)),\n@@ -910,7 +910,7 @@ impl<'self> MethodDef<'self> {\n                 }\n             };\n             (ident, summary)\n-        };\n+        });\n         self.call_substructure_method(cx,\n                                       trait_span, type_ident,\n                                       self_args, nonself_args,\n@@ -944,10 +944,10 @@ pub fn create_subpatterns(cx: @ExtCtxt,\n                           field_paths: ~[ast::Path],\n                           mutbl: ast::Mutability)\n                    -> ~[@ast::Pat] {\n-    do field_paths.map |path| {\n+    field_paths.map(|path| {\n         cx.pat(path.span,\n                ast::PatIdent(ast::BindByRef(mutbl), (*path).clone(), None))\n-    }\n+    })\n }\n \n #[deriving(Eq)] // dogfooding!\n@@ -1003,10 +1003,10 @@ fn create_struct_pattern(cx: @ExtCtxt,\n     // struct_type is definitely not Unknown, since struct_def.fields\n     // must be nonempty to reach here\n     let pattern = if struct_type == Record {\n-        let field_pats = do subpats.iter().zip(ident_expr.iter()).map |(&pat, &(_, id, _))| {\n+        let field_pats = subpats.iter().zip(ident_expr.iter()).map(|(&pat, &(_, id, _))| {\n             // id is guaranteed to be Some\n             ast::FieldPat { ident: id.unwrap(), pat: pat }\n-        }.collect();\n+        }).collect();\n         cx.pat_struct(trait_span, matching_path, field_pats)\n     } else {\n         cx.pat_enum(trait_span, matching_path, subpats)\n@@ -1075,13 +1075,13 @@ pub fn cs_fold(use_foldl: bool,\n     match *substructure.fields {\n         EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n             if use_foldl {\n-                do all_fields.iter().fold(base) |old, field| {\n+                all_fields.iter().fold(base, |old, field| {\n                     f(cx, field.span, old, field.self_, field.other)\n-                }\n+                })\n             } else {\n-                do all_fields.rev_iter().fold(base) |old, field| {\n+                all_fields.rev_iter().fold(base, |old, field| {\n                     f(cx, field.span, old, field.self_, field.other)\n-                }\n+                })\n             }\n         },\n         EnumNonMatching(ref all_enums) => enum_nonmatch_f(cx, trait_span,\n@@ -1113,12 +1113,12 @@ pub fn cs_same_method(f: |@ExtCtxt, Span, ~[@Expr]| -> @Expr,\n     match *substructure.fields {\n         EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n             // call self_n.method(other_1_n, other_2_n, ...)\n-            let called = do all_fields.map |field| {\n+            let called = all_fields.map(|field| {\n                 cx.expr_method_call(field.span,\n                                     field.self_,\n                                     substructure.method_ident,\n                                     field.other.clone())\n-            };\n+            });\n \n             f(cx, trait_span, called)\n         },\n@@ -1148,13 +1148,13 @@ pub fn cs_same_method_fold(use_foldl: bool,\n     cs_same_method(\n         |cx, span, vals| {\n             if use_foldl {\n-                do vals.iter().fold(base) |old, &new| {\n+                vals.iter().fold(base, |old, &new| {\n                     f(cx, span, old, new)\n-                }\n+                })\n             } else {\n-                do vals.rev_iter().fold(base) |old, &new| {\n+                vals.rev_iter().fold(base, |old, &new| {\n                     f(cx, span, old, new)\n-                }\n+                })\n             }\n         },\n         enum_nonmatch_f,"}, {"sha": "7e3debd7967f60f48ce977ab25aa8dc23f67bdf4", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=efc512362b0f2ae200ef079e3566c6b158a857cc", "patch": "@@ -90,7 +90,7 @@ fn iter_bytes_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @\n         cx.span_bug(span, \"#[deriving(IterBytes)] needs at least one field\");\n     }\n \n-    do exprs.slice(1, exprs.len()).iter().fold(exprs[0]) |prev, me| {\n+    exprs.slice(1, exprs.len()).iter().fold(exprs[0], |prev, me| {\n         cx.expr_binary(span, BiAnd, prev, *me)\n-    }\n+    })\n }"}, {"sha": "9c611d7e7b2844fffd08b09ce289edc6434514d0", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=efc512362b0f2ae200ef079e3566c6b158a857cc", "patch": "@@ -74,7 +74,7 @@ pub fn expand_meta_deriving(cx: @ExtCtxt,\n             in_items\n         }\n         MetaList(_, ref titems) => {\n-            do titems.rev_iter().fold(in_items) |in_items, &titem| {\n+            titems.rev_iter().fold(in_items, |in_items, &titem| {\n                 match titem.node {\n                     MetaNameValue(tname, _) |\n                     MetaList(tname, _) |\n@@ -112,7 +112,7 @@ pub fn expand_meta_deriving(cx: @ExtCtxt,\n                         }\n                     }\n                 }\n-            }\n+            })\n         }\n     }\n }"}, {"sha": "40fdee481edd98d90e942bc04c88a7e93308299a", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=efc512362b0f2ae200ef079e3566c6b158a857cc", "patch": "@@ -104,7 +104,7 @@ fn rand_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n                                               value_ref,\n                                               variant_count);\n \n-            let mut arms = do variants.iter().enumerate().map |(i, id_sum)| {\n+            let mut arms = variants.iter().enumerate().map(|(i, id_sum)| {\n                 let i_expr = cx.expr_uint(span, i);\n                 let pat = cx.pat_lit(span, i_expr);\n \n@@ -115,7 +115,7 @@ fn rand_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n                                rand_thing(cx, span, ident, summary, |sp| rand_call(sp)))\n                     }\n                 }\n-            }.collect::<~[ast::Arm]>();\n+            }).collect::<~[ast::Arm]>();\n \n             // _ => {} at the end. Should never occur\n             arms.push(cx.arm_unreachable(span));\n@@ -144,9 +144,9 @@ fn rand_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n                 }\n             }\n             Named(ref fields) => {\n-                let rand_fields = do fields.map |&(ident, span)| {\n+                let rand_fields = fields.map(|&(ident, span)| {\n                     cx.field_imm(span, ident, rand_call(span))\n-                };\n+                });\n                 cx.expr_struct_ident(span, ctor_ident, rand_fields)\n             }\n         }"}, {"sha": "eb957e80835ffedc96b34d18d876a2b9bbe95e84", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=efc512362b0f2ae200ef079e3566c6b158a857cc", "patch": "@@ -171,9 +171,9 @@ impl<'self> Ty<'self> {\n                    -> ast::Path {\n         match *self {\n             Self => {\n-                let self_params = do self_generics.ty_params.map |ty_param| {\n+                let self_params = self_generics.ty_params.map(|ty_param| {\n                     cx.ty_ident(span, ty_param.ident)\n-                };\n+                });\n                 let lifetimes = self_generics.lifetimes.clone();\n \n                 cx.path_all(span, false, ~[self_ty], lifetimes,\n@@ -192,10 +192,10 @@ impl<'self> Ty<'self> {\n fn mk_ty_param(cx: @ExtCtxt, span: Span, name: &str, bounds: &[Path],\n                self_ident: Ident, self_generics: &Generics) -> ast::TyParam {\n     let bounds = opt_vec::from(\n-        do bounds.map |b| {\n+        bounds.map(|b| {\n             let path = b.to_path(cx, span, self_ident, self_generics);\n             cx.typarambound(path)\n-        });\n+        }));\n     cx.typaram(cx.ident_of(name), bounds)\n }\n \n@@ -224,16 +224,16 @@ impl<'self> LifetimeBounds<'self> {\n                        self_ty: Ident,\n                        self_generics: &Generics)\n                        -> Generics {\n-        let lifetimes = do self.lifetimes.map |lt| {\n+        let lifetimes = self.lifetimes.map(|lt| {\n             cx.lifetime(span, cx.ident_of(*lt))\n-        };\n-        let ty_params = do self.bounds.map |t| {\n+        });\n+        let ty_params = self.bounds.map(|t| {\n             match t {\n                 &(ref name, ref bounds) => {\n                     mk_ty_param(cx, span, *name, *bounds, self_ty, self_generics)\n                 }\n             }\n-        };\n+        });\n         mk_generics(lifetimes, ty_params)\n     }\n }"}, {"sha": "a37cb586f59d457308283d69ae308a5e98949eab", "filename": "src/libsyntax/ext/deriving/zero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs?ref=efc512362b0f2ae200ef079e3566c6b158a857cc", "patch": "@@ -76,9 +76,9 @@ fn zero_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n                     }\n                 }\n                 Named(ref fields) => {\n-                    let zero_fields = do fields.map |&(ident, span)| {\n+                    let zero_fields = fields.map(|&(ident, span)| {\n                         cx.field_imm(span, ident, zero_call(span))\n-                    };\n+                    });\n                     cx.expr_struct_ident(span, substr.type_ident, zero_fields)\n                 }\n             }"}, {"sha": "f23e13b89311c25f644321f16dd5f25b2dc0ca3f", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=efc512362b0f2ae200ef079e3566c6b158a857cc", "patch": "@@ -261,8 +261,8 @@ pub fn expand_mod_items(extsbox: @mut SyntaxEnv,\n     // For each item, look through the attributes.  If any of them are\n     // decorated with \"item decorators\", then use that function to transform\n     // the item into a new set of items.\n-    let new_items = do vec::flat_map(module_.items) |item| {\n-        do item.attrs.rev_iter().fold(~[*item]) |items, attr| {\n+    let new_items = vec::flat_map(module_.items, |item| {\n+        item.attrs.rev_iter().fold(~[*item], |items, attr| {\n             let mname = attr.name();\n \n             match (*extsbox).find(&intern(mname)) {\n@@ -280,8 +280,8 @@ pub fn expand_mod_items(extsbox: @mut SyntaxEnv,\n               },\n               _ => items,\n             }\n-        }\n-    };\n+        })\n+    });\n \n     ast::_mod {\n         items: new_items,"}, {"sha": "1c0930f984a71343ce80282d98c19accd04eeb9a", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=efc512362b0f2ae200ef079e3566c6b158a857cc", "patch": "@@ -742,20 +742,20 @@ pub fn expand_args(ecx: @ExtCtxt, sp: Span,\n                                \"format argument must be a string literal.\");\n \n     let mut err = false;\n-    do parse::parse_error::cond.trap(|m| {\n+    parse::parse_error::cond.trap(|m| {\n         if !err {\n             err = true;\n             ecx.span_err(efmt.span, m);\n         }\n-    }).inside {\n+    }).inside(|| {\n         for piece in parse::Parser::new(fmt) {\n             if !err {\n                 cx.verify_piece(&piece);\n                 let piece = cx.trans_piece(&piece);\n                 cx.pieces.push(piece);\n             }\n         }\n-    }\n+    });\n     if err { return MRExpr(efmt) }\n \n     // Make sure that all arguments were used and all arguments have types."}, {"sha": "3e877d29300dab03766b903d6325e287d97cc6dd", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=efc512362b0f2ae200ef079e3566c6b158a857cc", "patch": "@@ -127,12 +127,12 @@ pub fn copy_up(mpu: &matcher_pos_up) -> ~MatcherPos {\n }\n \n pub fn count_names(ms: &[matcher]) -> uint {\n-    do ms.iter().fold(0) |ct, m| {\n+    ms.iter().fold(0, |ct, m| {\n         ct + match m.node {\n           match_tok(_) => 0u,\n           match_seq(ref more_ms, _, _, _, _) => count_names((*more_ms)),\n           match_nonterminal(_,_,_) => 1u\n-        }}\n+        }})\n }\n \n pub fn initial_matcher_pos(ms: ~[matcher], sep: Option<Token>, lo: BytePos)\n@@ -416,9 +416,9 @@ pub fn parse(\n                 }\n                 cur_eis.push(ei);\n \n-                do rust_parser.tokens_consumed.times() || {\n-                    rdr.next_token();\n-                }\n+                rust_parser.tokens_consumed.times(|| {\n+                    let _ = rdr.next_token();\n+                });\n             }\n         }\n "}, {"sha": "0f7b92b5b064050a962692380c0895941040d892", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=efc512362b0f2ae200ef079e3566c6b158a857cc", "patch": "@@ -151,10 +151,10 @@ fn lockstep_iter_size(t: &token_tree, r: &mut TtReader) -> lis {\n     }\n     match *t {\n       tt_delim(ref tts) | tt_seq(_, ref tts, _, _) => {\n-        do tts.iter().fold(lis_unconstrained) |lis, tt| {\n+        tts.iter().fold(lis_unconstrained, |lis, tt| {\n             let lis2 = lockstep_iter_size(tt, r);\n             lis_merge(lis, lis2)\n-        }\n+        })\n       }\n       tt_tok(*) => lis_unconstrained,\n       tt_nonterminal(_, name) => match *lookup_cur_matched(r, name) {"}, {"sha": "b268988c3c567ec407dfea4d929f0fccbac6bece", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=efc512362b0f2ae200ef079e3566c6b158a857cc", "patch": "@@ -187,12 +187,12 @@ pub trait ast_fold {\n             }\n             PatStruct(ref pth, ref fields, etc) => {\n                 let pth_ = self.fold_path(pth);\n-                let fs = do fields.map |f| {\n+                let fs = fields.map(|f| {\n                     ast::FieldPat {\n                         ident: f.ident,\n                         pat: self.fold_pat(f.pat)\n                     }\n-                };\n+                });\n                 PatStruct(pth_, fs, etc)\n             }\n             PatTup(ref elts) => PatTup(elts.map(|x| self.fold_pat(*x))),\n@@ -455,7 +455,7 @@ fn fold_arg_<T:ast_fold>(a: &arg, fld: &T) -> arg {\n // build a new vector of tts by appling the ast_fold's fold_ident to\n // all of the identifiers in the token trees.\n pub fn fold_tts<T:ast_fold>(tts: &[token_tree], fld: &T) -> ~[token_tree] {\n-    do tts.map |tt| {\n+    tts.map(|tt| {\n         match *tt {\n             tt_tok(span, ref tok) =>\n             tt_tok(span,maybe_fold_ident(tok,fld)),\n@@ -468,7 +468,7 @@ pub fn fold_tts<T:ast_fold>(tts: &[token_tree], fld: &T) -> ~[token_tree] {\n             tt_nonterminal(sp,ref ident) =>\n             tt_nonterminal(sp,fld.fold_ident(*ident))\n         }\n-    }\n+    })\n }\n \n // apply ident folder if it's an ident, otherwise leave it alone\n@@ -601,11 +601,11 @@ fn fold_field<T:ast_fold>(f: TypeField, folder: &T) -> TypeField {\n \n fn fold_opt_bounds<T:ast_fold>(b: &Option<OptVec<TyParamBound>>, folder: &T)\n                                -> Option<OptVec<TyParamBound>> {\n-    do b.as_ref().map |bounds| {\n-        do bounds.map |bound| {\n+    b.as_ref().map(|bounds| {\n+        bounds.map(|bound| {\n             fold_ty_param_bound(bound, folder)\n-        }\n-    }\n+        })\n+    })\n }\n \n fn fold_variant_arg_<T:ast_fold>(va: &variant_arg, folder: &T)\n@@ -660,9 +660,9 @@ pub fn noop_fold_item_underscore<T:ast_fold>(i: &item_, folder: &T) -> item_ {\n         item_enum(ref enum_definition, ref generics) => {\n             item_enum(\n                 ast::enum_def {\n-                    variants: do enum_definition.variants.map |x| {\n+                    variants: enum_definition.variants.map(|x| {\n                         folder.fold_variant(x)\n-                    },\n+                    }),\n                 },\n                 fold_generics(generics, folder))\n         }\n@@ -678,12 +678,12 @@ pub fn noop_fold_item_underscore<T:ast_fold>(i: &item_, folder: &T) -> item_ {\n             )\n         }\n         item_trait(ref generics, ref traits, ref methods) => {\n-            let methods = do methods.map |method| {\n+            let methods = methods.map(|method| {\n                 match *method {\n                     required(ref m) => required(folder.fold_type_method(m)),\n                     provided(method) => provided(folder.fold_method(method))\n                 }\n-            };\n+            });\n             item_trait(fold_generics(generics, folder),\n                        traits.map(|p| fold_trait_ref(p, folder)),\n                        methods)"}, {"sha": "d8f2d8a53807a6050900cb8c822249b65b5f70bd", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=efc512362b0f2ae200ef079e3566c6b158a857cc", "patch": "@@ -106,9 +106,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n         }\n \n         if can_trim {\n-            do lines.map |line| {\n-                line.slice(i + 1, line.len()).to_owned()\n-            }\n+            lines.map(|line| line.slice(i + 1, line.len()).to_owned())\n         } else {\n             lines\n         }\n@@ -377,10 +375,10 @@ pub fn gather_comments_and_literals(span_diagnostic:\n         //discard, and look ahead; we're working with internal state\n         let TokenAndSpan {tok: tok, sp: sp} = rdr.peek();\n         if token::is_lit(&tok) {\n-            do with_str_from(rdr, bstart) |s| {\n+            with_str_from(rdr, bstart, |s| {\n                 debug!(\"tok lit: {}\", s);\n                 literals.push(lit {lit: s.to_owned(), pos: sp.lo});\n-            }\n+            })\n         } else {\n             debug!(\"tok: {}\", token::to_str(get_ident_interner(), &tok));\n         }"}, {"sha": "e4b93c3b4d5b567035234955d8e3a5c7f96cdddd", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=efc512362b0f2ae200ef079e3566c6b158a857cc", "patch": "@@ -337,7 +337,7 @@ fn consume_any_line_comment(rdr: @mut StringReader)\n                 while rdr.curr != '\\n' && !is_eof(rdr) {\n                     bump(rdr);\n                 }\n-                let ret = do with_str_from(rdr, start_bpos) |string| {\n+                let ret = with_str_from(rdr, start_bpos, |string| {\n                     // but comments with only more \"/\"s are not\n                     if !is_line_non_doc_comment(string) {\n                         Some(TokenAndSpan{\n@@ -347,7 +347,7 @@ fn consume_any_line_comment(rdr: @mut StringReader)\n                     } else {\n                         None\n                     }\n-                };\n+                });\n \n                 if ret.is_some() {\n                     return ret;\n@@ -412,7 +412,7 @@ fn consume_block_comment(rdr: @mut StringReader)\n     }\n \n     let res = if is_doc_comment {\n-        do with_str_from(rdr, start_bpos) |string| {\n+        with_str_from(rdr, start_bpos, |string| {\n             // but comments with only \"*\"s between two \"/\"s are not\n             if !is_block_non_doc_comment(string) {\n                 Some(TokenAndSpan{\n@@ -422,7 +422,7 @@ fn consume_block_comment(rdr: @mut StringReader)\n             } else {\n                 None\n             }\n-        }\n+        })\n     } else {\n         None\n     };\n@@ -652,7 +652,7 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n             bump(rdr);\n         }\n \n-        return do with_str_from(rdr, start) |string| {\n+        return with_str_from(rdr, start, |string| {\n             if string == \"_\" {\n                 token::UNDERSCORE\n             } else {\n@@ -661,7 +661,7 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n                 // FIXME: perform NFKC normalization here. (Issue #2253)\n                 token::IDENT(str_to_ident(string), is_mod_name)\n             }\n-        }\n+        })\n     }\n     if is_dec_digit(c) {\n         return scan_number(c, rdr);\n@@ -775,9 +775,9 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n             while ident_continue(rdr.curr) {\n                 bump(rdr);\n             }\n-            return do with_str_from(rdr, start) |lifetime_name| {\n+            return with_str_from(rdr, start, |lifetime_name| {\n                 token::LIFETIME(str_to_ident(lifetime_name))\n-            }\n+            })\n         }\n \n         // Otherwise it is a character constant:"}, {"sha": "b9a7ec33ee4ffcd8af5358196c8a820b7a45d289", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 21, "deletions": 25, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=efc512362b0f2ae200ef079e3566c6b158a857cc", "patch": "@@ -1031,11 +1031,11 @@ impl Parser {\n \n     // parse the methods in a trait declaration\n     pub fn parse_trait_methods(&self) -> ~[trait_method] {\n-        do self.parse_unspanned_seq(\n+        self.parse_unspanned_seq(\n             &token::LBRACE,\n             &token::RBRACE,\n-            seq_sep_none()\n-        ) |p| {\n+            seq_sep_none(),\n+            |p| {\n             let attrs = p.parse_outer_attributes();\n             let lo = p.span.lo;\n \n@@ -1048,11 +1048,11 @@ impl Parser {\n \n             let generics = p.parse_generics();\n \n-            let (explicit_self, d) = do self.parse_fn_decl_with_self() |p| {\n+            let (explicit_self, d) = self.parse_fn_decl_with_self(|p| {\n                 // This is somewhat dubious; We don't want to allow argument\n                 // names to be left off if there is a definition...\n                 p.parse_arg_general(false)\n-            };\n+            });\n \n             let hi = p.last_span.hi;\n             debug!(\"parse_trait_methods(): trait method signature ends in \\\n@@ -1108,7 +1108,7 @@ impl Parser {\n                     );\n                 }\n             }\n-        }\n+        })\n     }\n \n     // parse a possibly mutable type\n@@ -3000,13 +3000,13 @@ impl Parser {\n             let mutbl = self.parse_mutability();\n             pat = self.parse_pat_ident(BindByRef(mutbl));\n         } else {\n-            let can_be_enum_or_struct = do self.look_ahead(1) |t| {\n+            let can_be_enum_or_struct = self.look_ahead(1, |t| {\n                 match *t {\n                     token::LPAREN | token::LBRACKET | token::LT |\n                     token::LBRACE | token::MOD_SEP => true,\n                     _ => false,\n                 }\n-            };\n+            });\n \n             if self.look_ahead(1, |t| *t == token::DOTDOT) {\n                 let start = self.parse_expr_res(RESTRICT_NO_BAR_OP);\n@@ -3040,18 +3040,18 @@ impl Parser {\n                         let mut args: ~[@Pat] = ~[];\n                         match *self.token {\n                           token::LPAREN => {\n-                            let is_star = do self.look_ahead(1) |t| {\n+                            let is_star = self.look_ahead(1, |t| {\n                                 match *t {\n                                     token::BINOP(token::STAR) => true,\n                                     _ => false,\n                                 }\n-                            };\n-                            let is_dotdot = do self.look_ahead(1) |t| {\n+                            });\n+                            let is_dotdot = self.look_ahead(1, |t| {\n                                 match *t {\n                                     token::DOTDOT => true,\n                                     _ => false,\n                                 }\n-                            };\n+                            });\n                             if is_star | is_dotdot {\n                                 // This is a \"top constructor only\" pat\n                                 self.bump();\n@@ -3884,9 +3884,9 @@ impl Parser {\n         let pur = self.parse_fn_purity();\n         let ident = self.parse_ident();\n         let generics = self.parse_generics();\n-        let (explicit_self, decl) = do self.parse_fn_decl_with_self() |p| {\n+        let (explicit_self, decl) = self.parse_fn_decl_with_self(|p| {\n             p.parse_arg()\n-        };\n+        });\n \n         let (inner_attrs, body) = self.parse_inner_attrs_and_block();\n         let hi = body.span.hi;\n@@ -4027,11 +4027,11 @@ impl Parser {\n         } else if *self.token == token::LPAREN {\n             // It's a tuple-like struct.\n             is_tuple_like = true;\n-            fields = do self.parse_unspanned_seq(\n+            fields = self.parse_unspanned_seq(\n                 &token::LPAREN,\n                 &token::RPAREN,\n-                seq_sep_trailing_allowed(token::COMMA)\n-            ) |p| {\n+                seq_sep_trailing_allowed(token::COMMA),\n+                |p| {\n                 let attrs = self.parse_outer_attributes();\n                 let lo = p.span.lo;\n                 let struct_field_ = ast::struct_field_ {\n@@ -4041,7 +4041,7 @@ impl Parser {\n                     attrs: attrs,\n                 };\n                 @spanned(lo, p.span.hi, struct_field_)\n-            };\n+            });\n             self.expect(&token::SEMI);\n         } else if self.eat(&token::SEMI) {\n             // It's a unit-like struct.\n@@ -4259,20 +4259,16 @@ impl Parser {\n                               path: Path,\n                               outer_attrs: ~[ast::Attribute],\n                               id_sp: Span) -> (ast::item_, ~[ast::Attribute]) {\n-        let maybe_i = do self.sess.included_mod_stack.iter().position |p| { *p == path };\n+        let maybe_i = self.sess.included_mod_stack.iter().position(|p| *p == path);\n         match maybe_i {\n             Some(i) => {\n                 let stack = &self.sess.included_mod_stack;\n                 let mut err = ~\"circular modules: \";\n                 for p in stack.slice(i, stack.len()).iter() {\n-                    do p.display().with_str |s| {\n-                        err.push_str(s);\n-                    }\n+                    p.display().with_str(|s| err.push_str(s));\n                     err.push_str(\" -> \");\n                 }\n-                do path.display().with_str |s| {\n-                    err.push_str(s);\n-                }\n+                path.display().with_str(|s| err.push_str(s));\n                 self.span_fatal(id_sp, err);\n             }\n             None => ()"}, {"sha": "870c1bd74b1b0b13ea5ba4802479a9a7511803a4", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=efc512362b0f2ae200ef079e3566c6b158a857cc", "patch": "@@ -169,9 +169,9 @@ pub fn to_str(input: @ident_interner, t: &Token) -> ~str {\n       /* Literals */\n       LIT_CHAR(c) => {\n           let mut res = ~\"'\";\n-          do char::from_u32(c).unwrap().escape_default |c| {\n+          char::from_u32(c).unwrap().escape_default(|c| {\n               res.push_char(c);\n-          }\n+          });\n           res.push_char('\\'');\n           res\n       }"}, {"sha": "a8f82221fa199abf30ff7cb245d9e63516db2dfe", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc512362b0f2ae200ef079e3566c6b158a857cc/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=efc512362b0f2ae200ef079e3566c6b158a857cc", "patch": "@@ -704,15 +704,15 @@ pub fn print_struct(s: @ps,\n     if ast_util::struct_def_is_tuple_like(struct_def) {\n         if !struct_def.fields.is_empty() {\n             popen(s);\n-            do commasep(s, inconsistent, struct_def.fields) |s, field| {\n+            commasep(s, inconsistent, struct_def.fields, |s, field| {\n                 match field.node.kind {\n                     ast::named_field(*) => fail!(\"unexpected named field\"),\n                     ast::unnamed_field => {\n                         maybe_print_comment(s, field.span.lo);\n                         print_type(s, &field.node.ty);\n                     }\n                 }\n-            }\n+            });\n             pclose(s);\n         }\n         word(s.s, \";\");\n@@ -1699,9 +1699,7 @@ pub fn print_pat(s: @ps, pat: &ast::Pat) {\n       }\n       ast::PatVec(ref before, slice, ref after) => {\n         word(s.s, \"[\");\n-        do commasep(s, inconsistent, *before) |s, &p| {\n-            print_pat(s, p);\n-        }\n+        commasep(s, inconsistent, *before, |s, &p| print_pat(s, p));\n         for &p in slice.iter() {\n             if !before.is_empty() { word_space(s, \",\"); }\n             match p {\n@@ -1713,9 +1711,7 @@ pub fn print_pat(s: @ps, pat: &ast::Pat) {\n             print_pat(s, p);\n             if !after.is_empty() { word_space(s, \",\"); }\n         }\n-        do commasep(s, inconsistent, *after) |s, &p| {\n-            print_pat(s, p);\n-        }\n+        commasep(s, inconsistent, *after, |s, &p| print_pat(s, p));\n         word(s.s, \"]\");\n       }\n     }\n@@ -1937,9 +1933,9 @@ pub fn print_view_path(s: @ps, vp: &ast::view_path) {\n       ast::view_path_list(ref path, ref idents, _) => {\n         print_path(s, path, false);\n         word(s.s, \"::{\");\n-        do commasep(s, inconsistent, (*idents)) |s, w| {\n+        commasep(s, inconsistent, (*idents), |s, w| {\n             print_ident(s, w.node.name);\n-        }\n+        });\n         word(s.s, \"}\");\n       }\n     }\n@@ -2053,9 +2049,7 @@ pub fn print_ty_fn(s: @ps,\n     match id { Some(id) => { word(s.s, \" \"); print_ident(s, id); } _ => () }\n \n     if opt_sigil != Some(ast::BorrowedSigil) {\n-        do opt_bounds.as_ref().map |bounds| {\n-            print_bounds(s, bounds, true);\n-        };\n+        opt_bounds.as_ref().map(|bounds| print_bounds(s, bounds, true));\n     }\n \n     match generics { Some(g) => print_generics(s, g), _ => () }\n@@ -2157,9 +2151,7 @@ pub fn print_literal(s: @ps, lit: &ast::lit) {\n       ast::lit_str(st, style) => print_string(s, st, style),\n       ast::lit_char(ch) => {\n           let mut res = ~\"'\";\n-          do char::from_u32(ch).unwrap().escape_default |c| {\n-              res.push_char(c);\n-          }\n+          char::from_u32(ch).unwrap().escape_default(|c| res.push_char(c));\n           res.push_char('\\'');\n           word(s.s, res);\n       }"}]}