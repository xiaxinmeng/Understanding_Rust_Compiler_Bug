{"sha": "90ccefd16e1eeec1a616aa3ba9aa710d954231ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwY2NlZmQxNmUxZWVlYzFhNjE2YWEzYmE5YWE3MTBkOTU0MjMxZWY=", "commit": {"author": {"name": "Cristi Cobzarenco", "email": "cristi.cobzarenco@gmail.com", "date": "2015-10-15T16:14:06Z"}, "committer": {"name": "Cristi Cobzarenco", "email": "cristi.cobzarenco@gmail.com", "date": "2015-10-15T17:05:54Z"}, "message": "std: add into_inner and get_mut to RwLock", "tree": {"sha": "655d7ee984afcef3e3f7e196493f7e17beb7bbd8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/655d7ee984afcef3e3f7e196493f7e17beb7bbd8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90ccefd16e1eeec1a616aa3ba9aa710d954231ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90ccefd16e1eeec1a616aa3ba9aa710d954231ef", "html_url": "https://github.com/rust-lang/rust/commit/90ccefd16e1eeec1a616aa3ba9aa710d954231ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90ccefd16e1eeec1a616aa3ba9aa710d954231ef/comments", "author": {"login": "cristicbz", "id": 801328, "node_id": "MDQ6VXNlcjgwMTMyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/801328?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cristicbz", "html_url": "https://github.com/cristicbz", "followers_url": "https://api.github.com/users/cristicbz/followers", "following_url": "https://api.github.com/users/cristicbz/following{/other_user}", "gists_url": "https://api.github.com/users/cristicbz/gists{/gist_id}", "starred_url": "https://api.github.com/users/cristicbz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cristicbz/subscriptions", "organizations_url": "https://api.github.com/users/cristicbz/orgs", "repos_url": "https://api.github.com/users/cristicbz/repos", "events_url": "https://api.github.com/users/cristicbz/events{/privacy}", "received_events_url": "https://api.github.com/users/cristicbz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cristicbz", "id": 801328, "node_id": "MDQ6VXNlcjgwMTMyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/801328?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cristicbz", "html_url": "https://github.com/cristicbz", "followers_url": "https://api.github.com/users/cristicbz/followers", "following_url": "https://api.github.com/users/cristicbz/following{/other_user}", "gists_url": "https://api.github.com/users/cristicbz/gists{/gist_id}", "starred_url": "https://api.github.com/users/cristicbz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cristicbz/subscriptions", "organizations_url": "https://api.github.com/users/cristicbz/orgs", "repos_url": "https://api.github.com/users/cristicbz/repos", "events_url": "https://api.github.com/users/cristicbz/events{/privacy}", "received_events_url": "https://api.github.com/users/cristicbz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8e8561e1a67e8d3d82a2450f288438004aba1c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8e8561e1a67e8d3d82a2450f288438004aba1c5", "html_url": "https://github.com/rust-lang/rust/commit/b8e8561e1a67e8d3d82a2450f288438004aba1c5"}], "stats": {"total": 118, "additions": 118, "deletions": 0}, "files": [{"sha": "9278481f2d62b194f715329b0b7164810a98e4f5", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/90ccefd16e1eeec1a616aa3ba9aa710d954231ef/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90ccefd16e1eeec1a616aa3ba9aa710d954231ef/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=90ccefd16e1eeec1a616aa3ba9aa710d954231ef", "patch": "@@ -13,7 +13,9 @@ use prelude::v1::*;\n use cell::UnsafeCell;\n use fmt;\n use marker;\n+use mem;\n use ops::{Deref, DerefMut};\n+use ptr;\n use sys_common::poison::{self, LockResult, TryLockError, TryLockResult};\n use sys_common::rwlock as sys;\n \n@@ -260,11 +262,60 @@ impl<T: ?Sized> RwLock<T> {\n     pub fn is_poisoned(&self) -> bool {\n         self.inner.poison.get()\n     }\n+\n+    /// Consumes this `RwLock`, returning the underlying data.\n+    ///\n+    /// # Failure\n+    ///\n+    /// This function will return an error if the RwLock is poisoned. An RwLock\n+    /// is poisoned whenever a writer panics while holding an exclusive lock. An\n+    /// error will only be returned if the lock would have otherwise been\n+    /// acquired.\n+    #[unstable(feature = \"rwlock_into_inner\", reason = \"recently added\", issue = \"28968\")]\n+    pub fn into_inner(self) -> LockResult<T> where T: Sized {\n+        // We know statically that there are no outstanding references to\n+        // `self` so there's no need to lock the inner StaticRwLock.\n+        //\n+        // To get the inner value, we'd like to call `data.into_inner()`,\n+        // but because `RwLock` impl-s `Drop`, we can't move out of it, so\n+        // we'll have to destructure it manually instead.\n+        unsafe {\n+            // Like `let RwLock { inner, data } = self`.\n+            let (inner, data) = {\n+                let RwLock { ref inner, ref data } = self;\n+                (ptr::read(inner), ptr::read(data))\n+            };\n+            mem::forget(self);\n+            inner.lock.destroy();  // Keep in sync with the `Drop` impl.\n+\n+            poison::map_result(inner.poison.borrow(), |_| data.into_inner())\n+        }\n+    }\n+\n+    /// Returns a mutable reference to the underlying data.\n+    ///\n+    /// Since this call borrows the `RwLock` mutably, no actual locking needs to\n+    /// take place---the mutable borrow statically guarantees no locks exist.\n+    ///\n+    /// # Failure\n+    ///\n+    /// This function will return an error if the RwLock is poisoned. An RwLock\n+    /// is poisoned whenever a writer panics while holding an exclusive lock. An\n+    /// error will only be returned if the lock would have otherwise been\n+    /// acquired.\n+    #[unstable(feature = \"rwlock_get_mut\", reason = \"recently added\", issue = \"28968\")]\n+    pub fn get_mut(&mut self) -> LockResult<&mut T> {\n+        // We know statically that there are no other references to `self`, so\n+        // there's no need to lock the inner StaticRwLock.\n+        let data = unsafe { &mut *self.data.get() };\n+        poison::map_result(self.inner.poison.borrow(), |_| data )\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Drop for RwLock<T> {\n     fn drop(&mut self) {\n+        // IMPORTANT: This code needs to be kept in sync with `RwLock::into_inner`.\n         unsafe { self.inner.lock.destroy() }\n     }\n }\n@@ -426,6 +477,10 @@ mod tests {\n     use sync::mpsc::channel;\n     use thread;\n     use sync::{Arc, RwLock, StaticRwLock, TryLockError};\n+    use sync::atomic::{AtomicUsize, Ordering};\n+\n+    #[derive(Eq, PartialEq, Debug)]\n+    struct NonCopy(i32);\n \n     #[test]\n     fn smoke() {\n@@ -606,4 +661,67 @@ mod tests {\n \n         drop(read_guard);\n     }\n+\n+    #[test]\n+    fn test_into_inner() {\n+        let m = RwLock::new(NonCopy(10));\n+        assert_eq!(m.into_inner().unwrap(), NonCopy(10));\n+    }\n+\n+    #[test]\n+    fn test_into_inner_drop() {\n+        struct Foo(Arc<AtomicUsize>);\n+        impl Drop for Foo {\n+            fn drop(&mut self) {\n+                self.0.fetch_add(1, Ordering::SeqCst);\n+            }\n+        }\n+        let num_drops = Arc::new(AtomicUsize::new(0));\n+        let m = RwLock::new(Foo(num_drops.clone()));\n+        assert_eq!(num_drops.load(Ordering::SeqCst), 0);\n+        {\n+            let _inner = m.into_inner().unwrap();\n+            assert_eq!(num_drops.load(Ordering::SeqCst), 0);\n+        }\n+        assert_eq!(num_drops.load(Ordering::SeqCst), 1);\n+    }\n+\n+    #[test]\n+    fn test_into_inner_poison() {\n+        let m = Arc::new(RwLock::new(NonCopy(10)));\n+        let m2 = m.clone();\n+        let _ = thread::spawn(move || {\n+            let _lock = m2.write().unwrap();\n+            panic!(\"test panic in inner thread to poison RwLock\");\n+        }).join();\n+\n+        assert!(m.is_poisoned());\n+        match Arc::try_unwrap(m).unwrap().into_inner() {\n+            Err(e) => assert_eq!(e.into_inner(), NonCopy(10)),\n+            Ok(x) => panic!(\"into_inner of poisoned RwLock is Ok: {:?}\", x),\n+        }\n+    }\n+\n+    #[test]\n+    fn test_get_mut() {\n+        let mut m = RwLock::new(NonCopy(10));\n+        *m.get_mut().unwrap() = NonCopy(20);\n+        assert_eq!(m.into_inner().unwrap(), NonCopy(20));\n+    }\n+\n+    #[test]\n+    fn test_get_mut_poison() {\n+        let m = Arc::new(RwLock::new(NonCopy(10)));\n+        let m2 = m.clone();\n+        let _ = thread::spawn(move || {\n+            let _lock = m2.write().unwrap();\n+            panic!(\"test panic in inner thread to poison RwLock\");\n+        }).join();\n+\n+        assert!(m.is_poisoned());\n+        match Arc::try_unwrap(m).unwrap().get_mut() {\n+            Err(e) => assert_eq!(*e.into_inner(), NonCopy(10)),\n+            Ok(x) => panic!(\"get_mut of poisoned RwLock is Ok: {:?}\", x),\n+        }\n+    }\n }"}]}