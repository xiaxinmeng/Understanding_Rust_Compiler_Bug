{"sha": "f4f70c0e0da9783eb0b935e0c8698a9505c7b45e", "node_id": "C_kwDOAAsO6NoAKGY0ZjcwYzBlMGRhOTc4M2ViMGI5MzVlMGM4Njk4YTk1MDVjN2I0NWU", "commit": {"author": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2022-08-10T07:49:49Z"}, "committer": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2022-08-10T07:49:49Z"}, "message": "Remove incomplete 1.64 ABI", "tree": {"sha": "3d32a1421d76351c0a34e7b7d04b6cc3ce90c327", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d32a1421d76351c0a34e7b7d04b6cc3ce90c327"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4f70c0e0da9783eb0b935e0c8698a9505c7b45e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4f70c0e0da9783eb0b935e0c8698a9505c7b45e", "html_url": "https://github.com/rust-lang/rust/commit/f4f70c0e0da9783eb0b935e0c8698a9505c7b45e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4f70c0e0da9783eb0b935e0c8698a9505c7b45e/comments", "author": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5366009fe47ab06e53b68811873448de52c5cd8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5366009fe47ab06e53b68811873448de52c5cd8f", "html_url": "https://github.com/rust-lang/rust/commit/5366009fe47ab06e53b68811873448de52c5cd8f"}], "stats": {"total": 4444, "additions": 1, "deletions": 4443}, "files": [{"sha": "9d56f0eaf888f74403e1051c3c026ab357bbff2d", "filename": "crates/proc-macro-srv/src/abis/abi_1_64/mod.rs", "status": "removed", "additions": 0, "deletions": 105, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/5366009fe47ab06e53b68811873448de52c5cd8f/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5366009fe47ab06e53b68811873448de52c5cd8f/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fmod.rs?ref=5366009fe47ab06e53b68811873448de52c5cd8f", "patch": "@@ -1,105 +0,0 @@\n-//! Proc macro ABI.\n-\n-#[allow(dead_code)]\n-#[doc(hidden)]\n-mod proc_macro;\n-\n-#[allow(dead_code)]\n-#[doc(hidden)]\n-mod ra_server;\n-\n-use libloading::Library;\n-use proc_macro_api::ProcMacroKind;\n-\n-use super::PanicMessage;\n-\n-pub use ra_server::TokenStream;\n-\n-pub(crate) struct Abi {\n-    exported_macros: Vec<proc_macro::bridge::client::ProcMacro>,\n-}\n-\n-impl From<proc_macro::bridge::PanicMessage> for PanicMessage {\n-    fn from(p: proc_macro::bridge::PanicMessage) -> Self {\n-        Self { message: p.as_str().map(|s| s.to_string()) }\n-    }\n-}\n-\n-impl Abi {\n-    pub unsafe fn from_lib(lib: &Library, symbol_name: String) -> Result<Abi, libloading::Error> {\n-        let macros: libloading::Symbol<'_, &&[proc_macro::bridge::client::ProcMacro]> =\n-            lib.get(symbol_name.as_bytes())?;\n-        Ok(Self { exported_macros: macros.to_vec() })\n-    }\n-\n-    pub fn expand(\n-        &self,\n-        macro_name: &str,\n-        macro_body: &tt::Subtree,\n-        attributes: Option<&tt::Subtree>,\n-    ) -> Result<tt::Subtree, PanicMessage> {\n-        let parsed_body = TokenStream::with_subtree(macro_body.clone());\n-\n-        let parsed_attributes =\n-            attributes.map_or(TokenStream::new(), |attr| TokenStream::with_subtree(attr.clone()));\n-\n-        for proc_macro in &self.exported_macros {\n-            match proc_macro {\n-                proc_macro::bridge::client::ProcMacro::CustomDerive {\n-                    trait_name, client, ..\n-                } if *trait_name == macro_name => {\n-                    let res = client.run(\n-                        &proc_macro::bridge::server::SameThread,\n-                        ra_server::RustAnalyzer::default(),\n-                        parsed_body,\n-                        true,\n-                    );\n-                    return res.map(|it| it.into_subtree()).map_err(PanicMessage::from);\n-                }\n-                proc_macro::bridge::client::ProcMacro::Bang { name, client }\n-                    if *name == macro_name =>\n-                {\n-                    let res = client.run(\n-                        &proc_macro::bridge::server::SameThread,\n-                        ra_server::RustAnalyzer::default(),\n-                        parsed_body,\n-                        true,\n-                    );\n-                    return res.map(|it| it.into_subtree()).map_err(PanicMessage::from);\n-                }\n-                proc_macro::bridge::client::ProcMacro::Attr { name, client }\n-                    if *name == macro_name =>\n-                {\n-                    let res = client.run(\n-                        &proc_macro::bridge::server::SameThread,\n-                        ra_server::RustAnalyzer::default(),\n-                        parsed_attributes,\n-                        parsed_body,\n-                        true,\n-                    );\n-                    return res.map(|it| it.into_subtree()).map_err(PanicMessage::from);\n-                }\n-                _ => continue,\n-            }\n-        }\n-\n-        Err(proc_macro::bridge::PanicMessage::String(\"Nothing to expand\".to_string()).into())\n-    }\n-\n-    pub fn list_macros(&self) -> Vec<(String, ProcMacroKind)> {\n-        self.exported_macros\n-            .iter()\n-            .map(|proc_macro| match proc_macro {\n-                proc_macro::bridge::client::ProcMacro::CustomDerive { trait_name, .. } => {\n-                    (trait_name.to_string(), ProcMacroKind::CustomDerive)\n-                }\n-                proc_macro::bridge::client::ProcMacro::Bang { name, .. } => {\n-                    (name.to_string(), ProcMacroKind::FuncLike)\n-                }\n-                proc_macro::bridge::client::ProcMacro::Attr { name, .. } => {\n-                    (name.to_string(), ProcMacroKind::Attr)\n-                }\n-            })\n-            .collect()\n-    }\n-}"}, {"sha": "48030f8d82dcaa3671ec67631991774c36ed5098", "filename": "crates/proc-macro-srv/src/abis/abi_1_64/proc_macro/bridge/buffer.rs", "status": "removed", "additions": 0, "deletions": 156, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/5366009fe47ab06e53b68811873448de52c5cd8f/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fbuffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5366009fe47ab06e53b68811873448de52c5cd8f/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fbuffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fbuffer.rs?ref=5366009fe47ab06e53b68811873448de52c5cd8f", "patch": "@@ -1,156 +0,0 @@\n-//! Buffer management for same-process client<->server communication.\n-\n-use std::io::{self, Write};\n-use std::mem;\n-use std::ops::{Deref, DerefMut};\n-use std::slice;\n-\n-#[repr(C)]\n-pub struct Buffer {\n-    data: *mut u8,\n-    len: usize,\n-    capacity: usize,\n-    reserve: extern \"C\" fn(Buffer, usize) -> Buffer,\n-    drop: extern \"C\" fn(Buffer),\n-}\n-\n-unsafe impl Sync for Buffer {}\n-unsafe impl Send for Buffer {}\n-\n-impl Default for Buffer {\n-    #[inline]\n-    fn default() -> Self {\n-        Self::from(vec![])\n-    }\n-}\n-\n-impl Deref for Buffer {\n-    type Target = [u8];\n-    #[inline]\n-    fn deref(&self) -> &[u8] {\n-        unsafe { slice::from_raw_parts(self.data as *const u8, self.len) }\n-    }\n-}\n-\n-impl DerefMut for Buffer {\n-    #[inline]\n-    fn deref_mut(&mut self) -> &mut [u8] {\n-        unsafe { slice::from_raw_parts_mut(self.data, self.len) }\n-    }\n-}\n-\n-impl Buffer {\n-    #[inline]\n-    pub(super) fn new() -> Self {\n-        Self::default()\n-    }\n-\n-    #[inline]\n-    pub(super) fn clear(&mut self) {\n-        self.len = 0;\n-    }\n-\n-    #[inline]\n-    pub(super) fn take(&mut self) -> Self {\n-        mem::take(self)\n-    }\n-\n-    // We have the array method separate from extending from a slice. This is\n-    // because in the case of small arrays, codegen can be more efficient\n-    // (avoiding a memmove call). With extend_from_slice, LLVM at least\n-    // currently is not able to make that optimization.\n-    #[inline]\n-    pub(super) fn extend_from_array<const N: usize>(&mut self, xs: &[u8; N]) {\n-        if xs.len() > (self.capacity - self.len) {\n-            let b = self.take();\n-            *self = (b.reserve)(b, xs.len());\n-        }\n-        unsafe {\n-            xs.as_ptr().copy_to_nonoverlapping(self.data.add(self.len), xs.len());\n-            self.len += xs.len();\n-        }\n-    }\n-\n-    #[inline]\n-    pub(super) fn extend_from_slice(&mut self, xs: &[u8]) {\n-        if xs.len() > (self.capacity - self.len) {\n-            let b = self.take();\n-            *self = (b.reserve)(b, xs.len());\n-        }\n-        unsafe {\n-            xs.as_ptr().copy_to_nonoverlapping(self.data.add(self.len), xs.len());\n-            self.len += xs.len();\n-        }\n-    }\n-\n-    #[inline]\n-    pub(super) fn push(&mut self, v: u8) {\n-        // The code here is taken from Vec::push, and we know that reserve()\n-        // will panic if we're exceeding isize::MAX bytes and so there's no need\n-        // to check for overflow.\n-        if self.len == self.capacity {\n-            let b = self.take();\n-            *self = (b.reserve)(b, 1);\n-        }\n-        unsafe {\n-            *self.data.add(self.len) = v;\n-            self.len += 1;\n-        }\n-    }\n-}\n-\n-impl Write for Buffer {\n-    #[inline]\n-    fn write(&mut self, xs: &[u8]) -> io::Result<usize> {\n-        self.extend_from_slice(xs);\n-        Ok(xs.len())\n-    }\n-\n-    #[inline]\n-    fn write_all(&mut self, xs: &[u8]) -> io::Result<()> {\n-        self.extend_from_slice(xs);\n-        Ok(())\n-    }\n-\n-    #[inline]\n-    fn flush(&mut self) -> io::Result<()> {\n-        Ok(())\n-    }\n-}\n-\n-impl Drop for Buffer {\n-    #[inline]\n-    fn drop(&mut self) {\n-        let b = self.take();\n-        (b.drop)(b);\n-    }\n-}\n-\n-impl From<Vec<u8>> for Buffer {\n-    fn from(mut v: Vec<u8>) -> Self {\n-        let (data, len, capacity) = (v.as_mut_ptr(), v.len(), v.capacity());\n-        mem::forget(v);\n-\n-        // This utility function is nested in here because it can *only*\n-        // be safely called on `Buffer`s created by *this* `proc_macro`.\n-        fn to_vec(b: Buffer) -> Vec<u8> {\n-            unsafe {\n-                let Buffer { data, len, capacity, .. } = b;\n-                mem::forget(b);\n-                Vec::from_raw_parts(data, len, capacity)\n-            }\n-        }\n-\n-        extern \"C\" fn reserve(b: Buffer, additional: usize) -> Buffer {\n-            let mut v = to_vec(b);\n-            v.reserve(additional);\n-            Buffer::from(v)\n-        }\n-\n-        extern \"C\" fn drop(b: Buffer) {\n-            mem::drop(to_vec(b));\n-        }\n-\n-        Buffer { data, len, capacity, reserve, drop }\n-    }\n-}"}, {"sha": "22bda8ba5a7cf026346de6feab2469d3d6525e17", "filename": "crates/proc-macro-srv/src/abis/abi_1_64/proc_macro/bridge/client.rs", "status": "removed", "additions": 0, "deletions": 529, "changes": 529, "blob_url": "https://github.com/rust-lang/rust/blob/5366009fe47ab06e53b68811873448de52c5cd8f/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5366009fe47ab06e53b68811873448de52c5cd8f/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fclient.rs?ref=5366009fe47ab06e53b68811873448de52c5cd8f", "patch": "@@ -1,529 +0,0 @@\n-//! Client-side types.\n-\n-use super::*;\n-\n-use std::marker::PhantomData;\n-\n-macro_rules! define_handles {\n-    (\n-        'owned: $($oty:ident,)*\n-        'interned: $($ity:ident,)*\n-    ) => {\n-        #[repr(C)]\n-        #[allow(non_snake_case)]\n-        pub struct HandleCounters {\n-            $($oty: AtomicUsize,)*\n-            $($ity: AtomicUsize,)*\n-        }\n-\n-        impl HandleCounters {\n-            // FIXME(eddyb) use a reference to the `static COUNTERS`, instead of\n-            // a wrapper `fn` pointer, once `const fn` can reference `static`s.\n-            extern \"C\" fn get() -> &'static Self {\n-                static COUNTERS: HandleCounters = HandleCounters {\n-                    $($oty: AtomicUsize::new(1),)*\n-                    $($ity: AtomicUsize::new(1),)*\n-                };\n-                &COUNTERS\n-            }\n-        }\n-\n-        // FIXME(eddyb) generate the definition of `HandleStore` in `server.rs`.\n-        #[repr(C)]\n-        #[allow(non_snake_case)]\n-        pub(super) struct HandleStore<S: server::Types> {\n-            $($oty: handle::OwnedStore<S::$oty>,)*\n-            $($ity: handle::InternedStore<S::$ity>,)*\n-        }\n-\n-        impl<S: server::Types> HandleStore<S> {\n-            pub(super) fn new(handle_counters: &'static HandleCounters) -> Self {\n-                HandleStore {\n-                    $($oty: handle::OwnedStore::new(&handle_counters.$oty),)*\n-                    $($ity: handle::InternedStore::new(&handle_counters.$ity),)*\n-                }\n-            }\n-        }\n-\n-        $(\n-            #[repr(C)]\n-            pub(crate) struct $oty {\n-                handle: handle::Handle,\n-                // Prevent Send and Sync impls. `!Send`/`!Sync` is the usual\n-                // way of doing this, but that requires unstable features.\n-                // rust-analyzer uses this code and avoids unstable features.\n-                _marker: PhantomData<*mut ()>,\n-            }\n-\n-            // Forward `Drop::drop` to the inherent `drop` method.\n-            impl Drop for $oty {\n-                fn drop(&mut self) {\n-                    $oty {\n-                        handle: self.handle,\n-                        _marker: PhantomData,\n-                    }.drop();\n-                }\n-            }\n-\n-            impl<S> Encode<S> for $oty {\n-                fn encode(self, w: &mut Writer, s: &mut S) {\n-                    let handle = self.handle;\n-                    mem::forget(self);\n-                    handle.encode(w, s);\n-                }\n-            }\n-\n-            impl<S: server::Types> DecodeMut<'_, '_, HandleStore<server::MarkedTypes<S>>>\n-                for Marked<S::$oty, $oty>\n-            {\n-                fn decode(r: &mut Reader<'_>, s: &mut HandleStore<server::MarkedTypes<S>>) -> Self {\n-                    s.$oty.take(handle::Handle::decode(r, &mut ()))\n-                }\n-            }\n-\n-            impl<S> Encode<S> for &$oty {\n-                fn encode(self, w: &mut Writer, s: &mut S) {\n-                    self.handle.encode(w, s);\n-                }\n-            }\n-\n-            impl<'s, S: server::Types> Decode<'_, 's, HandleStore<server::MarkedTypes<S>>>\n-                for &'s Marked<S::$oty, $oty>\n-            {\n-                fn decode(r: &mut Reader<'_>, s: &'s HandleStore<server::MarkedTypes<S>>) -> Self {\n-                    &s.$oty[handle::Handle::decode(r, &mut ())]\n-                }\n-            }\n-\n-            impl<S> Encode<S> for &mut $oty {\n-                fn encode(self, w: &mut Writer, s: &mut S) {\n-                    self.handle.encode(w, s);\n-                }\n-            }\n-\n-            impl<'s, S: server::Types> DecodeMut<'_, 's, HandleStore<server::MarkedTypes<S>>>\n-                for &'s mut Marked<S::$oty, $oty>\n-            {\n-                fn decode(\n-                    r: &mut Reader<'_>,\n-                    s: &'s mut HandleStore<server::MarkedTypes<S>>\n-                ) -> Self {\n-                    &mut s.$oty[handle::Handle::decode(r, &mut ())]\n-                }\n-            }\n-\n-            impl<S: server::Types> Encode<HandleStore<server::MarkedTypes<S>>>\n-                for Marked<S::$oty, $oty>\n-            {\n-                fn encode(self, w: &mut Writer, s: &mut HandleStore<server::MarkedTypes<S>>) {\n-                    s.$oty.alloc(self).encode(w, s);\n-                }\n-            }\n-\n-            impl<S> DecodeMut<'_, '_, S> for $oty {\n-                fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n-                    $oty {\n-                        handle: handle::Handle::decode(r, s),\n-                        _marker: PhantomData,\n-                    }\n-                }\n-            }\n-        )*\n-\n-        $(\n-            #[repr(C)]\n-            #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-            pub(crate) struct $ity {\n-                handle: handle::Handle,\n-                // Prevent Send and Sync impls. `!Send`/`!Sync` is the usual\n-                // way of doing this, but that requires unstable features.\n-                // rust-analyzer uses this code and avoids unstable features.\n-                _marker: PhantomData<*mut ()>,\n-            }\n-\n-            impl<S> Encode<S> for $ity {\n-                fn encode(self, w: &mut Writer, s: &mut S) {\n-                    self.handle.encode(w, s);\n-                }\n-            }\n-\n-            impl<S: server::Types> DecodeMut<'_, '_, HandleStore<server::MarkedTypes<S>>>\n-                for Marked<S::$ity, $ity>\n-            {\n-                fn decode(r: &mut Reader<'_>, s: &mut HandleStore<server::MarkedTypes<S>>) -> Self {\n-                    s.$ity.copy(handle::Handle::decode(r, &mut ()))\n-                }\n-            }\n-\n-            impl<S: server::Types> Encode<HandleStore<server::MarkedTypes<S>>>\n-                for Marked<S::$ity, $ity>\n-            {\n-                fn encode(self, w: &mut Writer, s: &mut HandleStore<server::MarkedTypes<S>>) {\n-                    s.$ity.alloc(self).encode(w, s);\n-                }\n-            }\n-\n-            impl<S> DecodeMut<'_, '_, S> for $ity {\n-                fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n-                    $ity {\n-                        handle: handle::Handle::decode(r, s),\n-                        _marker: PhantomData,\n-                    }\n-                }\n-            }\n-        )*\n-    }\n-}\n-define_handles! {\n-    'owned:\n-    FreeFunctions,\n-    TokenStream,\n-    Literal,\n-    SourceFile,\n-    MultiSpan,\n-    Diagnostic,\n-\n-    'interned:\n-    Ident,\n-    Span,\n-}\n-\n-// FIXME(eddyb) generate these impls by pattern-matching on the\n-// names of methods - also could use the presence of `fn drop`\n-// to distinguish between 'owned and 'interned, above.\n-// Alternatively, special \"modes\" could be listed of types in with_api\n-// instead of pattern matching on methods, here and in server decl.\n-\n-impl Clone for TokenStream {\n-    fn clone(&self) -> Self {\n-        self.clone()\n-    }\n-}\n-\n-impl Clone for Literal {\n-    fn clone(&self) -> Self {\n-        self.clone()\n-    }\n-}\n-\n-impl fmt::Debug for Literal {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Literal\")\n-            // format the kind without quotes, as in `kind: Float`\n-            .field(\"kind\", &format_args!(\"{}\", &self.debug_kind()))\n-            .field(\"symbol\", &self.symbol())\n-            // format `Some(\"...\")` on one line even in {:#?} mode\n-            .field(\"suffix\", &format_args!(\"{:?}\", &self.suffix()))\n-            .field(\"span\", &self.span())\n-            .finish()\n-    }\n-}\n-\n-impl Clone for SourceFile {\n-    fn clone(&self) -> Self {\n-        self.clone()\n-    }\n-}\n-\n-impl Span {\n-    pub(crate) fn def_site() -> Span {\n-        Bridge::with(|bridge| bridge.globals.def_site)\n-    }\n-\n-    pub(crate) fn call_site() -> Span {\n-        Bridge::with(|bridge| bridge.globals.call_site)\n-    }\n-\n-    pub(crate) fn mixed_site() -> Span {\n-        Bridge::with(|bridge| bridge.globals.mixed_site)\n-    }\n-}\n-\n-impl fmt::Debug for Span {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(&self.debug())\n-    }\n-}\n-\n-macro_rules! define_client_side {\n-    ($($name:ident {\n-        $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)*;)*\n-    }),* $(,)?) => {\n-        $(impl $name {\n-            $(pub(crate) fn $method($($arg: $arg_ty),*) $(-> $ret_ty)* {\n-                Bridge::with(|bridge| {\n-                    let mut buf = bridge.cached_buffer.take();\n-\n-                    buf.clear();\n-                    api_tags::Method::$name(api_tags::$name::$method).encode(&mut buf, &mut ());\n-                    reverse_encode!(buf; $($arg),*);\n-\n-                    buf = bridge.dispatch.call(buf);\n-\n-                    let r = Result::<_, PanicMessage>::decode(&mut &buf[..], &mut ());\n-\n-                    bridge.cached_buffer = buf;\n-\n-                    r.unwrap_or_else(|e| panic::resume_unwind(e.into()))\n-                })\n-            })*\n-        })*\n-    }\n-}\n-with_api!(self, self, define_client_side);\n-\n-struct Bridge<'a> {\n-    /// Reusable buffer (only `clear`-ed, never shrunk), primarily\n-    /// used for making requests.\n-    cached_buffer: Buffer,\n-\n-    /// Server-side function that the client uses to make requests.\n-    dispatch: closure::Closure<'a, Buffer, Buffer>,\n-\n-    /// Provided globals for this macro expansion.\n-    globals: ExpnGlobals<Span>,\n-}\n-\n-enum BridgeState<'a> {\n-    /// No server is currently connected to this client.\n-    NotConnected,\n-\n-    /// A server is connected and available for requests.\n-    Connected(Bridge<'a>),\n-\n-    /// Access to the bridge is being exclusively acquired\n-    /// (e.g., during `BridgeState::with`).\n-    InUse,\n-}\n-\n-enum BridgeStateL {}\n-\n-impl<'a> scoped_cell::ApplyL<'a> for BridgeStateL {\n-    type Out = BridgeState<'a>;\n-}\n-\n-thread_local! {\n-    static BRIDGE_STATE: scoped_cell::ScopedCell<BridgeStateL> =\n-        scoped_cell::ScopedCell::new(BridgeState::NotConnected);\n-}\n-\n-impl BridgeState<'_> {\n-    /// Take exclusive control of the thread-local\n-    /// `BridgeState`, and pass it to `f`, mutably.\n-    /// The state will be restored after `f` exits, even\n-    /// by panic, including modifications made to it by `f`.\n-    ///\n-    /// N.B., while `f` is running, the thread-local state\n-    /// is `BridgeState::InUse`.\n-    fn with<R>(f: impl FnOnce(&mut BridgeState<'_>) -> R) -> R {\n-        BRIDGE_STATE.with(|state| {\n-            state.replace(BridgeState::InUse, |mut state| {\n-                // FIXME(#52812) pass `f` directly to `replace` when `RefMutL` is gone\n-                f(&mut *state)\n-            })\n-        })\n-    }\n-}\n-\n-impl Bridge<'_> {\n-    fn with<R>(f: impl FnOnce(&mut Bridge<'_>) -> R) -> R {\n-        BridgeState::with(|state| match state {\n-            BridgeState::NotConnected => {\n-                panic!(\"procedural macro API is used outside of a procedural macro\");\n-            }\n-            BridgeState::InUse => {\n-                panic!(\"procedural macro API is used while it's already in use\");\n-            }\n-            BridgeState::Connected(bridge) => f(bridge),\n-        })\n-    }\n-}\n-\n-pub(crate) fn is_available() -> bool {\n-    BridgeState::with(|state| match state {\n-        BridgeState::Connected(_) | BridgeState::InUse => true,\n-        BridgeState::NotConnected => false,\n-    })\n-}\n-\n-/// A client-side RPC entry-point, which may be using a different `proc_macro`\n-/// from the one used by the server, but can be invoked compatibly.\n-///\n-/// Note that the (phantom) `I` (\"input\") and `O` (\"output\") type parameters\n-/// decorate the `Client<I, O>` with the RPC \"interface\" of the entry-point, but\n-/// do not themselves participate in ABI, at all, only facilitate type-checking.\n-///\n-/// E.g. `Client<TokenStream, TokenStream>` is the common proc macro interface,\n-/// used for `#[proc_macro] fn foo(input: TokenStream) -> TokenStream`,\n-/// indicating that the RPC input and output will be serialized token streams,\n-/// and forcing the use of APIs that take/return `S::TokenStream`, server-side.\n-#[repr(C)]\n-pub struct Client<I, O> {\n-    // FIXME(eddyb) use a reference to the `static COUNTERS`, instead of\n-    // a wrapper `fn` pointer, once `const fn` can reference `static`s.\n-    pub(super) get_handle_counters: extern \"C\" fn() -> &'static HandleCounters,\n-\n-    pub(super) run: extern \"C\" fn(BridgeConfig<'_>) -> Buffer,\n-\n-    pub(super) _marker: PhantomData<fn(I) -> O>,\n-}\n-\n-impl<I, O> Copy for Client<I, O> {}\n-impl<I, O> Clone for Client<I, O> {\n-    fn clone(&self) -> Self {\n-        *self\n-    }\n-}\n-\n-fn maybe_install_panic_hook(force_show_panics: bool) {\n-    // Hide the default panic output within `proc_macro` expansions.\n-    // NB. the server can't do this because it may use a different libstd.\n-    static HIDE_PANICS_DURING_EXPANSION: Once = Once::new();\n-    HIDE_PANICS_DURING_EXPANSION.call_once(|| {\n-        let prev = panic::take_hook();\n-        panic::set_hook(Box::new(move |info| {\n-            let show = BridgeState::with(|state| match state {\n-                BridgeState::NotConnected => true,\n-                BridgeState::Connected(_) | BridgeState::InUse => force_show_panics,\n-            });\n-            if show {\n-                prev(info)\n-            }\n-        }));\n-    });\n-}\n-\n-/// Client-side helper for handling client panics, entering the bridge,\n-/// deserializing input and serializing output.\n-// FIXME(eddyb) maybe replace `Bridge::enter` with this?\n-fn run_client<A: for<'a, 's> DecodeMut<'a, 's, ()>, R: Encode<()>>(\n-    config: BridgeConfig<'_>,\n-    f: impl FnOnce(A) -> R,\n-) -> Buffer {\n-    let BridgeConfig { input: mut buf, dispatch, force_show_panics, .. } = config;\n-\n-    panic::catch_unwind(panic::AssertUnwindSafe(|| {\n-        maybe_install_panic_hook(force_show_panics);\n-\n-        let reader = &mut &buf[..];\n-        let (globals, input) = <(ExpnGlobals<Span>, A)>::decode(reader, &mut ());\n-\n-        // Put the buffer we used for input back in the `Bridge` for requests.\n-        let new_state =\n-            BridgeState::Connected(Bridge { cached_buffer: buf.take(), dispatch, globals });\n-\n-        BRIDGE_STATE.with(|state| {\n-            state.set(new_state, || {\n-                let output = f(input);\n-\n-                // Take the `cached_buffer` back out, for the output value.\n-                buf = Bridge::with(|bridge| bridge.cached_buffer.take());\n-\n-                // HACK(eddyb) Separate encoding a success value (`Ok(output)`)\n-                // from encoding a panic (`Err(e: PanicMessage)`) to avoid\n-                // having handles outside the `bridge.enter(|| ...)` scope, and\n-                // to catch panics that could happen while encoding the success.\n-                //\n-                // Note that panics should be impossible beyond this point, but\n-                // this is defensively trying to avoid any accidental panicking\n-                // reaching the `extern \"C\"` (which should `abort` but might not\n-                // at the moment, so this is also potentially preventing UB).\n-                buf.clear();\n-                Ok::<_, ()>(output).encode(&mut buf, &mut ());\n-            })\n-        })\n-    }))\n-    .map_err(PanicMessage::from)\n-    .unwrap_or_else(|e| {\n-        buf.clear();\n-        Err::<(), _>(e).encode(&mut buf, &mut ());\n-    });\n-    buf\n-}\n-\n-impl Client<super::super::TokenStream, super::super::TokenStream> {\n-    pub const fn expand1(\n-        f: impl Fn(super::super::TokenStream) -> super::super::TokenStream + Copy,\n-    ) -> Self {\n-        Client {\n-            get_handle_counters: HandleCounters::get,\n-            run: super::selfless_reify::reify_to_extern_c_fn_hrt_bridge(move |bridge| {\n-                run_client(bridge, |input| f(super::super::TokenStream(input)).0)\n-            }),\n-            _marker: PhantomData,\n-        }\n-    }\n-}\n-\n-impl Client<(super::super::TokenStream, super::super::TokenStream), super::super::TokenStream> {\n-    pub const fn expand2(\n-        f: impl Fn(super::super::TokenStream, super::super::TokenStream) -> super::super::TokenStream\n-            + Copy,\n-    ) -> Self {\n-        Client {\n-            get_handle_counters: HandleCounters::get,\n-            run: super::selfless_reify::reify_to_extern_c_fn_hrt_bridge(move |bridge| {\n-                run_client(bridge, |(input, input2)| {\n-                    f(super::super::TokenStream(input), super::super::TokenStream(input2)).0\n-                })\n-            }),\n-            _marker: PhantomData,\n-        }\n-    }\n-}\n-\n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-pub enum ProcMacro {\n-    CustomDerive {\n-        trait_name: &'static str,\n-        attributes: &'static [&'static str],\n-        client: Client<super::super::TokenStream, super::super::TokenStream>,\n-    },\n-\n-    Attr {\n-        name: &'static str,\n-        client: Client<\n-            (super::super::TokenStream, super::super::TokenStream),\n-            super::super::TokenStream,\n-        >,\n-    },\n-\n-    Bang {\n-        name: &'static str,\n-        client: Client<super::super::TokenStream, super::super::TokenStream>,\n-    },\n-}\n-\n-impl ProcMacro {\n-    pub fn name(&self) -> &'static str {\n-        match self {\n-            ProcMacro::CustomDerive { trait_name, .. } => trait_name,\n-            ProcMacro::Attr { name, .. } => name,\n-            ProcMacro::Bang { name, .. } => name,\n-        }\n-    }\n-\n-    pub const fn custom_derive(\n-        trait_name: &'static str,\n-        attributes: &'static [&'static str],\n-        expand: impl Fn(super::super::TokenStream) -> super::super::TokenStream + Copy,\n-    ) -> Self {\n-        ProcMacro::CustomDerive { trait_name, attributes, client: Client::expand1(expand) }\n-    }\n-\n-    pub const fn attr(\n-        name: &'static str,\n-        expand: impl Fn(super::super::TokenStream, super::super::TokenStream) -> super::super::TokenStream\n-            + Copy,\n-    ) -> Self {\n-        ProcMacro::Attr { name, client: Client::expand2(expand) }\n-    }\n-\n-    pub const fn bang(\n-        name: &'static str,\n-        expand: impl Fn(super::super::TokenStream) -> super::super::TokenStream + Copy,\n-    ) -> Self {\n-        ProcMacro::Bang { name, client: Client::expand1(expand) }\n-    }\n-}"}, {"sha": "d371ae3cea0981a01f38cb261fc39e203b495130", "filename": "crates/proc-macro-srv/src/abis/abi_1_64/proc_macro/bridge/closure.rs", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5366009fe47ab06e53b68811873448de52c5cd8f/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5366009fe47ab06e53b68811873448de52c5cd8f/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fclosure.rs?ref=5366009fe47ab06e53b68811873448de52c5cd8f", "patch": "@@ -1,32 +0,0 @@\n-//! Closure type (equivalent to `&mut dyn FnMut(A) -> R`) that's `repr(C)`.\n-\n-use std::marker::PhantomData;\n-\n-#[repr(C)]\n-pub struct Closure<'a, A, R> {\n-    call: unsafe extern \"C\" fn(*mut Env, A) -> R,\n-    env: *mut Env,\n-    // Prevent Send and Sync impls. `!Send`/`!Sync` is the usual way of doing\n-    // this, but that requires unstable features. rust-analyzer uses this code\n-    // and avoids unstable features.\n-    //\n-    // The `'a` lifetime parameter represents the lifetime of `Env`.\n-    _marker: PhantomData<*mut &'a mut ()>,\n-}\n-\n-struct Env;\n-\n-impl<'a, A, R, F: FnMut(A) -> R> From<&'a mut F> for Closure<'a, A, R> {\n-    fn from(f: &'a mut F) -> Self {\n-        unsafe extern \"C\" fn call<A, R, F: FnMut(A) -> R>(env: *mut Env, arg: A) -> R {\n-            (*(env as *mut _ as *mut F))(arg)\n-        }\n-        Closure { call: call::<A, R, F>, env: f as *mut _ as *mut Env, _marker: PhantomData }\n-    }\n-}\n-\n-impl<'a, A, R> Closure<'a, A, R> {\n-    pub fn call(&mut self, arg: A) -> R {\n-        unsafe { (self.call)(self.env, arg) }\n-    }\n-}"}, {"sha": "c219a9465d39f2d091133298a697049cd0712c67", "filename": "crates/proc-macro-srv/src/abis/abi_1_64/proc_macro/bridge/handle.rs", "status": "removed", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/5366009fe47ab06e53b68811873448de52c5cd8f/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5366009fe47ab06e53b68811873448de52c5cd8f/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fhandle.rs?ref=5366009fe47ab06e53b68811873448de52c5cd8f", "patch": "@@ -1,89 +0,0 @@\n-//! Server-side handles and storage for per-handle data.\n-\n-use std::collections::{BTreeMap, HashMap};\n-use std::hash::{BuildHasher, Hash};\n-use std::num::NonZeroU32;\n-use std::ops::{Index, IndexMut};\n-use std::sync::atomic::{AtomicUsize, Ordering};\n-\n-pub(super) type Handle = NonZeroU32;\n-\n-/// A store that associates values of type `T` with numeric handles. A value can\n-/// be looked up using its handle.\n-pub(super) struct OwnedStore<T: 'static> {\n-    counter: &'static AtomicUsize,\n-    data: BTreeMap<Handle, T>,\n-}\n-\n-impl<T> OwnedStore<T> {\n-    pub(super) fn new(counter: &'static AtomicUsize) -> Self {\n-        // Ensure the handle counter isn't 0, which would panic later,\n-        // when `NonZeroU32::new` (aka `Handle::new`) is called in `alloc`.\n-        assert_ne!(counter.load(Ordering::SeqCst), 0);\n-\n-        OwnedStore { counter, data: BTreeMap::new() }\n-    }\n-}\n-\n-impl<T> OwnedStore<T> {\n-    pub(super) fn alloc(&mut self, x: T) -> Handle {\n-        let counter = self.counter.fetch_add(1, Ordering::SeqCst);\n-        let handle = Handle::new(counter as u32).expect(\"`proc_macro` handle counter overflowed\");\n-        assert!(self.data.insert(handle, x).is_none());\n-        handle\n-    }\n-\n-    pub(super) fn take(&mut self, h: Handle) -> T {\n-        self.data.remove(&h).expect(\"use-after-free in `proc_macro` handle\")\n-    }\n-}\n-\n-impl<T> Index<Handle> for OwnedStore<T> {\n-    type Output = T;\n-    fn index(&self, h: Handle) -> &T {\n-        self.data.get(&h).expect(\"use-after-free in `proc_macro` handle\")\n-    }\n-}\n-\n-impl<T> IndexMut<Handle> for OwnedStore<T> {\n-    fn index_mut(&mut self, h: Handle) -> &mut T {\n-        self.data.get_mut(&h).expect(\"use-after-free in `proc_macro` handle\")\n-    }\n-}\n-\n-// HACK(eddyb) deterministic `std::collections::hash_map::RandomState` replacement\n-// that doesn't require adding any dependencies to `proc_macro` (like `rustc-hash`).\n-#[derive(Clone)]\n-struct NonRandomState;\n-\n-impl BuildHasher for NonRandomState {\n-    type Hasher = std::collections::hash_map::DefaultHasher;\n-    #[inline]\n-    fn build_hasher(&self) -> Self::Hasher {\n-        Self::Hasher::new()\n-    }\n-}\n-\n-/// Like `OwnedStore`, but avoids storing any value more than once.\n-pub(super) struct InternedStore<T: 'static> {\n-    owned: OwnedStore<T>,\n-    interner: HashMap<T, Handle, NonRandomState>,\n-}\n-\n-impl<T: Copy + Eq + Hash> InternedStore<T> {\n-    pub(super) fn new(counter: &'static AtomicUsize) -> Self {\n-        InternedStore {\n-            owned: OwnedStore::new(counter),\n-            interner: HashMap::with_hasher(NonRandomState),\n-        }\n-    }\n-\n-    pub(super) fn alloc(&mut self, x: T) -> Handle {\n-        let owned = &mut self.owned;\n-        *self.interner.entry(x).or_insert_with(|| owned.alloc(x))\n-    }\n-\n-    pub(super) fn copy(&mut self, h: Handle) -> T {\n-        self.owned[h]\n-    }\n-}"}, {"sha": "ffd440793231c21cdb1968a0860c5fe5c3da2ff9", "filename": "crates/proc-macro-srv/src/abis/abi_1_64/proc_macro/bridge/mod.rs", "status": "removed", "additions": 0, "deletions": 493, "changes": 493, "blob_url": "https://github.com/rust-lang/rust/blob/5366009fe47ab06e53b68811873448de52c5cd8f/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5366009fe47ab06e53b68811873448de52c5cd8f/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fmod.rs?ref=5366009fe47ab06e53b68811873448de52c5cd8f", "patch": "@@ -1,493 +0,0 @@\n-//! Internal interface for communicating between a `proc_macro` client\n-//! (a proc macro crate) and a `proc_macro` server (a compiler front-end).\n-//!\n-//! Serialization (with C ABI buffers) and unique integer handles are employed\n-//! to allow safely interfacing between two copies of `proc_macro` built\n-//! (from the same source) by different compilers with potentially mismatching\n-//! Rust ABIs (e.g., stage0/bin/rustc vs stage1/bin/rustc during bootstrap).\n-\n-#![deny(unsafe_code)]\n-\n-pub use super::{Delimiter, Level, LineColumn, Spacing};\n-use std::fmt;\n-use std::hash::Hash;\n-use std::marker;\n-use std::mem;\n-use std::ops::Bound;\n-use std::panic;\n-use std::sync::atomic::AtomicUsize;\n-use std::sync::Once;\n-use std::thread;\n-\n-/// Higher-order macro describing the server RPC API, allowing automatic\n-/// generation of type-safe Rust APIs, both client-side and server-side.\n-///\n-/// `with_api!(MySelf, my_self, my_macro)` expands to:\n-/// ```rust,ignore (pseudo-code)\n-/// my_macro! {\n-///     // ...\n-///     Literal {\n-///         // ...\n-///         fn character(ch: char) -> MySelf::Literal;\n-///         // ...\n-///         fn span(my_self: &MySelf::Literal) -> MySelf::Span;\n-///         fn set_span(my_self: &mut MySelf::Literal, span: MySelf::Span);\n-///     },\n-///     // ...\n-/// }\n-/// ```\n-///\n-/// The first two arguments serve to customize the arguments names\n-/// and argument/return types, to enable several different usecases:\n-///\n-/// If `my_self` is just `self`, then each `fn` signature can be used\n-/// as-is for a method. If it's anything else (`self_` in practice),\n-/// then the signatures don't have a special `self` argument, and\n-/// can, therefore, have a different one introduced.\n-///\n-/// If `MySelf` is just `Self`, then the types are only valid inside\n-/// a trait or a trait impl, where the trait has associated types\n-/// for each of the API types. If non-associated types are desired,\n-/// a module name (`self` in practice) can be used instead of `Self`.\n-macro_rules! with_api {\n-    ($S:ident, $self:ident, $m:ident) => {\n-        $m! {\n-            FreeFunctions {\n-                fn drop($self: $S::FreeFunctions);\n-                fn track_env_var(var: &str, value: Option<&str>);\n-                fn track_path(path: &str);\n-            },\n-            TokenStream {\n-                fn drop($self: $S::TokenStream);\n-                fn clone($self: &$S::TokenStream) -> $S::TokenStream;\n-                fn is_empty($self: &$S::TokenStream) -> bool;\n-                fn expand_expr($self: &$S::TokenStream) -> Result<$S::TokenStream, ()>;\n-                fn from_str(src: &str) -> $S::TokenStream;\n-                fn to_string($self: &$S::TokenStream) -> String;\n-                fn from_token_tree(\n-                    tree: TokenTree<$S::TokenStream, $S::Span, $S::Ident, $S::Literal>,\n-                ) -> $S::TokenStream;\n-                fn concat_trees(\n-                    base: Option<$S::TokenStream>,\n-                    trees: Vec<TokenTree<$S::TokenStream, $S::Span, $S::Ident, $S::Literal>>,\n-                ) -> $S::TokenStream;\n-                fn concat_streams(\n-                    base: Option<$S::TokenStream>,\n-                    streams: Vec<$S::TokenStream>,\n-                ) -> $S::TokenStream;\n-                fn into_trees(\n-                    $self: $S::TokenStream\n-                ) -> Vec<TokenTree<$S::TokenStream, $S::Span, $S::Ident, $S::Literal>>;\n-            },\n-            Ident {\n-                fn new(string: &str, span: $S::Span, is_raw: bool) -> $S::Ident;\n-                fn span($self: $S::Ident) -> $S::Span;\n-                fn with_span($self: $S::Ident, span: $S::Span) -> $S::Ident;\n-            },\n-            Literal {\n-                fn drop($self: $S::Literal);\n-                fn clone($self: &$S::Literal) -> $S::Literal;\n-                fn from_str(s: &str) -> Result<$S::Literal, ()>;\n-                fn to_string($self: &$S::Literal) -> String;\n-                fn debug_kind($self: &$S::Literal) -> String;\n-                fn symbol($self: &$S::Literal) -> String;\n-                fn suffix($self: &$S::Literal) -> Option<String>;\n-                fn integer(n: &str) -> $S::Literal;\n-                fn typed_integer(n: &str, kind: &str) -> $S::Literal;\n-                fn float(n: &str) -> $S::Literal;\n-                fn f32(n: &str) -> $S::Literal;\n-                fn f64(n: &str) -> $S::Literal;\n-                fn string(string: &str) -> $S::Literal;\n-                fn character(ch: char) -> $S::Literal;\n-                fn byte_string(bytes: &[u8]) -> $S::Literal;\n-                fn span($self: &$S::Literal) -> $S::Span;\n-                fn set_span($self: &mut $S::Literal, span: $S::Span);\n-                fn subspan(\n-                    $self: &$S::Literal,\n-                    start: Bound<usize>,\n-                    end: Bound<usize>,\n-                ) -> Option<$S::Span>;\n-            },\n-            SourceFile {\n-                fn drop($self: $S::SourceFile);\n-                fn clone($self: &$S::SourceFile) -> $S::SourceFile;\n-                fn eq($self: &$S::SourceFile, other: &$S::SourceFile) -> bool;\n-                fn path($self: &$S::SourceFile) -> String;\n-                fn is_real($self: &$S::SourceFile) -> bool;\n-            },\n-            MultiSpan {\n-                fn drop($self: $S::MultiSpan);\n-                fn new() -> $S::MultiSpan;\n-                fn push($self: &mut $S::MultiSpan, span: $S::Span);\n-            },\n-            Diagnostic {\n-                fn drop($self: $S::Diagnostic);\n-                fn new(level: Level, msg: &str, span: $S::MultiSpan) -> $S::Diagnostic;\n-                fn sub(\n-                    $self: &mut $S::Diagnostic,\n-                    level: Level,\n-                    msg: &str,\n-                    span: $S::MultiSpan,\n-                );\n-                fn emit($self: $S::Diagnostic);\n-            },\n-            Span {\n-                fn debug($self: $S::Span) -> String;\n-                fn source_file($self: $S::Span) -> $S::SourceFile;\n-                fn parent($self: $S::Span) -> Option<$S::Span>;\n-                fn source($self: $S::Span) -> $S::Span;\n-                fn start($self: $S::Span) -> LineColumn;\n-                fn end($self: $S::Span) -> LineColumn;\n-                fn before($self: $S::Span) -> $S::Span;\n-                fn after($self: $S::Span) -> $S::Span;\n-                fn join($self: $S::Span, other: $S::Span) -> Option<$S::Span>;\n-                fn resolved_at($self: $S::Span, at: $S::Span) -> $S::Span;\n-                fn source_text($self: $S::Span) -> Option<String>;\n-                fn save_span($self: $S::Span) -> usize;\n-                fn recover_proc_macro_span(id: usize) -> $S::Span;\n-            },\n-        }\n-    };\n-}\n-\n-// FIXME(eddyb) this calls `encode` for each argument, but in reverse,\n-// to match the ordering in `reverse_decode`.\n-macro_rules! reverse_encode {\n-    ($writer:ident;) => {};\n-    ($writer:ident; $first:ident $(, $rest:ident)*) => {\n-        reverse_encode!($writer; $($rest),*);\n-        $first.encode(&mut $writer, &mut ());\n-    }\n-}\n-\n-// FIXME(eddyb) this calls `decode` for each argument, but in reverse,\n-// to avoid borrow conflicts from borrows started by `&mut` arguments.\n-macro_rules! reverse_decode {\n-    ($reader:ident, $s:ident;) => {};\n-    ($reader:ident, $s:ident; $first:ident: $first_ty:ty $(, $rest:ident: $rest_ty:ty)*) => {\n-        reverse_decode!($reader, $s; $($rest: $rest_ty),*);\n-        let $first = <$first_ty>::decode(&mut $reader, $s);\n-    }\n-}\n-\n-#[allow(unsafe_code)]\n-mod buffer;\n-#[forbid(unsafe_code)]\n-pub mod client;\n-#[allow(unsafe_code)]\n-mod closure;\n-#[forbid(unsafe_code)]\n-mod handle;\n-#[macro_use]\n-#[forbid(unsafe_code)]\n-mod rpc;\n-#[allow(unsafe_code)]\n-mod scoped_cell;\n-#[allow(unsafe_code)]\n-mod selfless_reify;\n-#[forbid(unsafe_code)]\n-pub mod server;\n-\n-use buffer::Buffer;\n-pub use rpc::PanicMessage;\n-use rpc::{Decode, DecodeMut, Encode, Reader, Writer};\n-\n-/// Configuration for establishing an active connection between a server and a\n-/// client.  The server creates the bridge config (`run_server` in `server.rs`),\n-/// then passes it to the client through the function pointer in the `run` field\n-/// of `client::Client`. The client constructs a local `Bridge` from the config\n-/// in TLS during its execution (`Bridge::{enter, with}` in `client.rs`).\n-#[repr(C)]\n-pub struct BridgeConfig<'a> {\n-    /// Buffer used to pass initial input to the client.\n-    input: Buffer,\n-\n-    /// Server-side function that the client uses to make requests.\n-    dispatch: closure::Closure<'a, Buffer, Buffer>,\n-\n-    /// If 'true', always invoke the default panic hook\n-    force_show_panics: bool,\n-\n-    // Prevent Send and Sync impls. `!Send`/`!Sync` is the usual way of doing\n-    // this, but that requires unstable features. rust-analyzer uses this code\n-    // and avoids unstable features.\n-    _marker: marker::PhantomData<*mut ()>,\n-}\n-\n-#[forbid(unsafe_code)]\n-#[allow(non_camel_case_types)]\n-mod api_tags {\n-    use super::rpc::{DecodeMut, Encode, Reader, Writer};\n-\n-    macro_rules! declare_tags {\n-        ($($name:ident {\n-            $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)*;)*\n-        }),* $(,)?) => {\n-            $(\n-                pub(super) enum $name {\n-                    $($method),*\n-                }\n-                rpc_encode_decode!(enum $name { $($method),* });\n-            )*\n-\n-            pub(super) enum Method {\n-                $($name($name)),*\n-            }\n-            rpc_encode_decode!(enum Method { $($name(m)),* });\n-        }\n-    }\n-    with_api!(self, self, declare_tags);\n-}\n-\n-/// Helper to wrap associated types to allow trait impl dispatch.\n-/// That is, normally a pair of impls for `T::Foo` and `T::Bar`\n-/// can overlap, but if the impls are, instead, on types like\n-/// `Marked<T::Foo, Foo>` and `Marked<T::Bar, Bar>`, they can't.\n-trait Mark {\n-    type Unmarked;\n-    fn mark(unmarked: Self::Unmarked) -> Self;\n-}\n-\n-/// Unwrap types wrapped by `Mark::mark` (see `Mark` for details).\n-trait Unmark {\n-    type Unmarked;\n-    fn unmark(self) -> Self::Unmarked;\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-struct Marked<T, M> {\n-    value: T,\n-    _marker: marker::PhantomData<M>,\n-}\n-\n-impl<T, M> Mark for Marked<T, M> {\n-    type Unmarked = T;\n-    fn mark(unmarked: Self::Unmarked) -> Self {\n-        Marked { value: unmarked, _marker: marker::PhantomData }\n-    }\n-}\n-impl<T, M> Unmark for Marked<T, M> {\n-    type Unmarked = T;\n-    fn unmark(self) -> Self::Unmarked {\n-        self.value\n-    }\n-}\n-impl<'a, T, M> Unmark for &'a Marked<T, M> {\n-    type Unmarked = &'a T;\n-    fn unmark(self) -> Self::Unmarked {\n-        &self.value\n-    }\n-}\n-impl<'a, T, M> Unmark for &'a mut Marked<T, M> {\n-    type Unmarked = &'a mut T;\n-    fn unmark(self) -> Self::Unmarked {\n-        &mut self.value\n-    }\n-}\n-\n-impl<T: Mark> Mark for Vec<T> {\n-    type Unmarked = Vec<T::Unmarked>;\n-    fn mark(unmarked: Self::Unmarked) -> Self {\n-        // Should be a no-op due to std's in-place collect optimizations.\n-        unmarked.into_iter().map(T::mark).collect()\n-    }\n-}\n-impl<T: Unmark> Unmark for Vec<T> {\n-    type Unmarked = Vec<T::Unmarked>;\n-    fn unmark(self) -> Self::Unmarked {\n-        // Should be a no-op due to std's in-place collect optimizations.\n-        self.into_iter().map(T::unmark).collect()\n-    }\n-}\n-\n-macro_rules! mark_noop {\n-    ($($ty:ty),* $(,)?) => {\n-        $(\n-            impl Mark for $ty {\n-                type Unmarked = Self;\n-                fn mark(unmarked: Self::Unmarked) -> Self {\n-                    unmarked\n-                }\n-            }\n-            impl Unmark for $ty {\n-                type Unmarked = Self;\n-                fn unmark(self) -> Self::Unmarked {\n-                    self\n-                }\n-            }\n-        )*\n-    }\n-}\n-mark_noop! {\n-    (),\n-    bool,\n-    char,\n-    &'_ [u8],\n-    &'_ str,\n-    String,\n-    u8,\n-    usize,\n-    Delimiter,\n-    Level,\n-    LineColumn,\n-    Spacing,\n-}\n-\n-rpc_encode_decode!(\n-    enum Delimiter {\n-        Parenthesis,\n-        Brace,\n-        Bracket,\n-        None,\n-    }\n-);\n-rpc_encode_decode!(\n-    enum Level {\n-        Error,\n-        Warning,\n-        Note,\n-        Help,\n-    }\n-);\n-rpc_encode_decode!(struct LineColumn { line, column });\n-rpc_encode_decode!(\n-    enum Spacing {\n-        Alone,\n-        Joint,\n-    }\n-);\n-\n-macro_rules! mark_compound {\n-    (struct $name:ident <$($T:ident),+> { $($field:ident),* $(,)? }) => {\n-        impl<$($T: Mark),+> Mark for $name <$($T),+> {\n-            type Unmarked = $name <$($T::Unmarked),+>;\n-            fn mark(unmarked: Self::Unmarked) -> Self {\n-                $name {\n-                    $($field: Mark::mark(unmarked.$field)),*\n-                }\n-            }\n-        }\n-        impl<$($T: Unmark),+> Unmark for $name <$($T),+> {\n-            type Unmarked = $name <$($T::Unmarked),+>;\n-            fn unmark(self) -> Self::Unmarked {\n-                $name {\n-                    $($field: Unmark::unmark(self.$field)),*\n-                }\n-            }\n-        }\n-    };\n-    (enum $name:ident <$($T:ident),+> { $($variant:ident $(($field:ident))?),* $(,)? }) => {\n-        impl<$($T: Mark),+> Mark for $name <$($T),+> {\n-            type Unmarked = $name <$($T::Unmarked),+>;\n-            fn mark(unmarked: Self::Unmarked) -> Self {\n-                match unmarked {\n-                    $($name::$variant $(($field))? => {\n-                        $name::$variant $((Mark::mark($field)))?\n-                    })*\n-                }\n-            }\n-        }\n-        impl<$($T: Unmark),+> Unmark for $name <$($T),+> {\n-            type Unmarked = $name <$($T::Unmarked),+>;\n-            fn unmark(self) -> Self::Unmarked {\n-                match self {\n-                    $($name::$variant $(($field))? => {\n-                        $name::$variant $((Unmark::unmark($field)))?\n-                    })*\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-macro_rules! compound_traits {\n-    ($($t:tt)*) => {\n-        rpc_encode_decode!($($t)*);\n-        mark_compound!($($t)*);\n-    };\n-}\n-\n-compound_traits!(\n-    enum Bound<T> {\n-        Included(x),\n-        Excluded(x),\n-        Unbounded,\n-    }\n-);\n-\n-compound_traits!(\n-    enum Option<T> {\n-        Some(t),\n-        None,\n-    }\n-);\n-\n-compound_traits!(\n-    enum Result<T, E> {\n-        Ok(t),\n-        Err(e),\n-    }\n-);\n-\n-#[derive(Copy, Clone)]\n-pub struct DelimSpan<Span> {\n-    pub open: Span,\n-    pub close: Span,\n-    pub entire: Span,\n-}\n-\n-impl<Span: Copy> DelimSpan<Span> {\n-    pub fn from_single(span: Span) -> Self {\n-        DelimSpan { open: span, close: span, entire: span }\n-    }\n-}\n-\n-compound_traits!(struct DelimSpan<Span> { open, close, entire });\n-\n-#[derive(Clone)]\n-pub struct Group<TokenStream, Span> {\n-    pub delimiter: Delimiter,\n-    pub stream: Option<TokenStream>,\n-    pub span: DelimSpan<Span>,\n-}\n-\n-compound_traits!(struct Group<TokenStream, Span> { delimiter, stream, span });\n-\n-#[derive(Clone)]\n-pub struct Punct<Span> {\n-    pub ch: u8,\n-    pub joint: bool,\n-    pub span: Span,\n-}\n-\n-compound_traits!(struct Punct<Span> { ch, joint, span });\n-\n-#[derive(Clone)]\n-pub enum TokenTree<TokenStream, Span, Ident, Literal> {\n-    Group(Group<TokenStream, Span>),\n-    Punct(Punct<Span>),\n-    Ident(Ident),\n-    Literal(Literal),\n-}\n-\n-compound_traits!(\n-    enum TokenTree<TokenStream, Span, Ident, Literal> {\n-        Group(tt),\n-        Punct(tt),\n-        Ident(tt),\n-        Literal(tt),\n-    }\n-);\n-\n-/// Globals provided alongside the initial inputs for a macro expansion.\n-/// Provides values such as spans which are used frequently to avoid RPC.\n-#[derive(Clone)]\n-pub struct ExpnGlobals<Span> {\n-    pub def_site: Span,\n-    pub call_site: Span,\n-    pub mixed_site: Span,\n-}\n-\n-compound_traits!(\n-    struct ExpnGlobals<Span> { def_site, call_site, mixed_site }\n-);"}, {"sha": "e9d7a46c06f6d270d66e848788e9f01fbd776e54", "filename": "crates/proc-macro-srv/src/abis/abi_1_64/proc_macro/bridge/rpc.rs", "status": "removed", "additions": 0, "deletions": 304, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/5366009fe47ab06e53b68811873448de52c5cd8f/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Frpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5366009fe47ab06e53b68811873448de52c5cd8f/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Frpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Frpc.rs?ref=5366009fe47ab06e53b68811873448de52c5cd8f", "patch": "@@ -1,304 +0,0 @@\n-//! Serialization for client-server communication.\n-\n-use std::any::Any;\n-use std::char;\n-use std::io::Write;\n-use std::num::NonZeroU32;\n-use std::str;\n-\n-pub(super) type Writer = super::buffer::Buffer;\n-\n-pub(super) trait Encode<S>: Sized {\n-    fn encode(self, w: &mut Writer, s: &mut S);\n-}\n-\n-pub(super) type Reader<'a> = &'a [u8];\n-\n-pub(super) trait Decode<'a, 's, S>: Sized {\n-    fn decode(r: &mut Reader<'a>, s: &'s S) -> Self;\n-}\n-\n-pub(super) trait DecodeMut<'a, 's, S>: Sized {\n-    fn decode(r: &mut Reader<'a>, s: &'s mut S) -> Self;\n-}\n-\n-macro_rules! rpc_encode_decode {\n-    (le $ty:ty) => {\n-        impl<S> Encode<S> for $ty {\n-            fn encode(self, w: &mut Writer, _: &mut S) {\n-                w.extend_from_array(&self.to_le_bytes());\n-            }\n-        }\n-\n-        impl<S> DecodeMut<'_, '_, S> for $ty {\n-            fn decode(r: &mut Reader<'_>, _: &mut S) -> Self {\n-                const N: usize = ::std::mem::size_of::<$ty>();\n-\n-                let mut bytes = [0; N];\n-                bytes.copy_from_slice(&r[..N]);\n-                *r = &r[N..];\n-\n-                Self::from_le_bytes(bytes)\n-            }\n-        }\n-    };\n-    (struct $name:ident $(<$($T:ident),+>)? { $($field:ident),* $(,)? }) => {\n-        impl<S, $($($T: Encode<S>),+)?> Encode<S> for $name $(<$($T),+>)? {\n-            fn encode(self, w: &mut Writer, s: &mut S) {\n-                $(self.$field.encode(w, s);)*\n-            }\n-        }\n-\n-        impl<'a, S, $($($T: for<'s> DecodeMut<'a, 's, S>),+)?> DecodeMut<'a, '_, S>\n-            for $name $(<$($T),+>)?\n-        {\n-            fn decode(r: &mut Reader<'a>, s: &mut S) -> Self {\n-                $name {\n-                    $($field: DecodeMut::decode(r, s)),*\n-                }\n-            }\n-        }\n-    };\n-    (enum $name:ident $(<$($T:ident),+>)? { $($variant:ident $(($field:ident))*),* $(,)? }) => {\n-        impl<S, $($($T: Encode<S>),+)?> Encode<S> for $name $(<$($T),+>)? {\n-            fn encode(self, w: &mut Writer, s: &mut S) {\n-                // HACK(eddyb): `Tag` enum duplicated between the\n-                // two impls as there's no other place to stash it.\n-                #[allow(non_upper_case_globals)]\n-                mod tag {\n-                    #[repr(u8)] enum Tag { $($variant),* }\n-\n-                    $(pub const $variant: u8 = Tag::$variant as u8;)*\n-                }\n-\n-                match self {\n-                    $($name::$variant $(($field))* => {\n-                        tag::$variant.encode(w, s);\n-                        $($field.encode(w, s);)*\n-                    })*\n-                }\n-            }\n-        }\n-\n-        impl<'a, S, $($($T: for<'s> DecodeMut<'a, 's, S>),+)?> DecodeMut<'a, '_, S>\n-            for $name $(<$($T),+>)?\n-        {\n-            fn decode(r: &mut Reader<'a>, s: &mut S) -> Self {\n-                // HACK(eddyb): `Tag` enum duplicated between the\n-                // two impls as there's no other place to stash it.\n-                #[allow(non_upper_case_globals)]\n-                mod tag {\n-                    #[repr(u8)] enum Tag { $($variant),* }\n-\n-                    $(pub const $variant: u8 = Tag::$variant as u8;)*\n-                }\n-\n-                match u8::decode(r, s) {\n-                    $(tag::$variant => {\n-                        $(let $field = DecodeMut::decode(r, s);)*\n-                        $name::$variant $(($field))*\n-                    })*\n-                    _ => unreachable!(),\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl<S> Encode<S> for () {\n-    fn encode(self, _: &mut Writer, _: &mut S) {}\n-}\n-\n-impl<S> DecodeMut<'_, '_, S> for () {\n-    fn decode(_: &mut Reader<'_>, _: &mut S) -> Self {}\n-}\n-\n-impl<S> Encode<S> for u8 {\n-    fn encode(self, w: &mut Writer, _: &mut S) {\n-        w.push(self);\n-    }\n-}\n-\n-impl<S> DecodeMut<'_, '_, S> for u8 {\n-    fn decode(r: &mut Reader<'_>, _: &mut S) -> Self {\n-        let x = r[0];\n-        *r = &r[1..];\n-        x\n-    }\n-}\n-\n-rpc_encode_decode!(le u32);\n-rpc_encode_decode!(le usize);\n-\n-impl<S> Encode<S> for bool {\n-    fn encode(self, w: &mut Writer, s: &mut S) {\n-        (self as u8).encode(w, s);\n-    }\n-}\n-\n-impl<S> DecodeMut<'_, '_, S> for bool {\n-    fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n-        match u8::decode(r, s) {\n-            0 => false,\n-            1 => true,\n-            _ => unreachable!(),\n-        }\n-    }\n-}\n-\n-impl<S> Encode<S> for char {\n-    fn encode(self, w: &mut Writer, s: &mut S) {\n-        (self as u32).encode(w, s);\n-    }\n-}\n-\n-impl<S> DecodeMut<'_, '_, S> for char {\n-    fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n-        char::from_u32(u32::decode(r, s)).unwrap()\n-    }\n-}\n-\n-impl<S> Encode<S> for NonZeroU32 {\n-    fn encode(self, w: &mut Writer, s: &mut S) {\n-        self.get().encode(w, s);\n-    }\n-}\n-\n-impl<S> DecodeMut<'_, '_, S> for NonZeroU32 {\n-    fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n-        Self::new(u32::decode(r, s)).unwrap()\n-    }\n-}\n-\n-impl<S, A: Encode<S>, B: Encode<S>> Encode<S> for (A, B) {\n-    fn encode(self, w: &mut Writer, s: &mut S) {\n-        self.0.encode(w, s);\n-        self.1.encode(w, s);\n-    }\n-}\n-\n-impl<'a, S, A: for<'s> DecodeMut<'a, 's, S>, B: for<'s> DecodeMut<'a, 's, S>> DecodeMut<'a, '_, S>\n-    for (A, B)\n-{\n-    fn decode(r: &mut Reader<'a>, s: &mut S) -> Self {\n-        (DecodeMut::decode(r, s), DecodeMut::decode(r, s))\n-    }\n-}\n-\n-impl<S> Encode<S> for &[u8] {\n-    fn encode(self, w: &mut Writer, s: &mut S) {\n-        self.len().encode(w, s);\n-        w.write_all(self).unwrap();\n-    }\n-}\n-\n-impl<'a, S> DecodeMut<'a, '_, S> for &'a [u8] {\n-    fn decode(r: &mut Reader<'a>, s: &mut S) -> Self {\n-        let len = usize::decode(r, s);\n-        let xs = &r[..len];\n-        *r = &r[len..];\n-        xs\n-    }\n-}\n-\n-impl<S> Encode<S> for &str {\n-    fn encode(self, w: &mut Writer, s: &mut S) {\n-        self.as_bytes().encode(w, s);\n-    }\n-}\n-\n-impl<'a, S> DecodeMut<'a, '_, S> for &'a str {\n-    fn decode(r: &mut Reader<'a>, s: &mut S) -> Self {\n-        str::from_utf8(<&[u8]>::decode(r, s)).unwrap()\n-    }\n-}\n-\n-impl<S> Encode<S> for String {\n-    fn encode(self, w: &mut Writer, s: &mut S) {\n-        self[..].encode(w, s);\n-    }\n-}\n-\n-impl<S> DecodeMut<'_, '_, S> for String {\n-    fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n-        <&str>::decode(r, s).to_string()\n-    }\n-}\n-\n-impl<S, T: Encode<S>> Encode<S> for Vec<T> {\n-    fn encode(self, w: &mut Writer, s: &mut S) {\n-        self.len().encode(w, s);\n-        for x in self {\n-            x.encode(w, s);\n-        }\n-    }\n-}\n-\n-impl<'a, S, T: for<'s> DecodeMut<'a, 's, S>> DecodeMut<'a, '_, S> for Vec<T> {\n-    fn decode(r: &mut Reader<'a>, s: &mut S) -> Self {\n-        let len = usize::decode(r, s);\n-        let mut vec = Vec::with_capacity(len);\n-        for _ in 0..len {\n-            vec.push(T::decode(r, s));\n-        }\n-        vec\n-    }\n-}\n-\n-/// Simplified version of panic payloads, ignoring\n-/// types other than `&'static str` and `String`.\n-pub enum PanicMessage {\n-    StaticStr(&'static str),\n-    String(String),\n-    Unknown,\n-}\n-\n-impl From<Box<dyn Any + Send>> for PanicMessage {\n-    fn from(payload: Box<dyn Any + Send + 'static>) -> Self {\n-        if let Some(s) = payload.downcast_ref::<&'static str>() {\n-            return PanicMessage::StaticStr(s);\n-        }\n-        if let Ok(s) = payload.downcast::<String>() {\n-            return PanicMessage::String(*s);\n-        }\n-        PanicMessage::Unknown\n-    }\n-}\n-\n-impl Into<Box<dyn Any + Send>> for PanicMessage {\n-    fn into(self) -> Box<dyn Any + Send> {\n-        match self {\n-            PanicMessage::StaticStr(s) => Box::new(s),\n-            PanicMessage::String(s) => Box::new(s),\n-            PanicMessage::Unknown => {\n-                struct UnknownPanicMessage;\n-                Box::new(UnknownPanicMessage)\n-            }\n-        }\n-    }\n-}\n-\n-impl PanicMessage {\n-    pub fn as_str(&self) -> Option<&str> {\n-        match self {\n-            PanicMessage::StaticStr(s) => Some(s),\n-            PanicMessage::String(s) => Some(s),\n-            PanicMessage::Unknown => None,\n-        }\n-    }\n-}\n-\n-impl<S> Encode<S> for PanicMessage {\n-    fn encode(self, w: &mut Writer, s: &mut S) {\n-        self.as_str().encode(w, s);\n-    }\n-}\n-\n-impl<S> DecodeMut<'_, '_, S> for PanicMessage {\n-    fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n-        match Option::<String>::decode(r, s) {\n-            Some(s) => PanicMessage::String(s),\n-            None => PanicMessage::Unknown,\n-        }\n-    }\n-}"}, {"sha": "2cde1f65adf9c484ab0aee45fe6c978fda30cbb9", "filename": "crates/proc-macro-srv/src/abis/abi_1_64/proc_macro/bridge/scoped_cell.rs", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/5366009fe47ab06e53b68811873448de52c5cd8f/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fscoped_cell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5366009fe47ab06e53b68811873448de52c5cd8f/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fscoped_cell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fscoped_cell.rs?ref=5366009fe47ab06e53b68811873448de52c5cd8f", "patch": "@@ -1,81 +0,0 @@\n-//! `Cell` variant for (scoped) existential lifetimes.\n-\n-use std::cell::Cell;\n-use std::mem;\n-use std::ops::{Deref, DerefMut};\n-\n-/// Type lambda application, with a lifetime.\n-#[allow(unused_lifetimes)]\n-pub trait ApplyL<'a> {\n-    type Out;\n-}\n-\n-/// Type lambda taking a lifetime, i.e., `Lifetime -> Type`.\n-pub trait LambdaL: for<'a> ApplyL<'a> {}\n-\n-impl<T: for<'a> ApplyL<'a>> LambdaL for T {}\n-\n-// HACK(eddyb) work around projection limitations with a newtype\n-// FIXME(#52812) replace with `&'a mut <T as ApplyL<'b>>::Out`\n-pub struct RefMutL<'a, 'b, T: LambdaL>(&'a mut <T as ApplyL<'b>>::Out);\n-\n-impl<'a, 'b, T: LambdaL> Deref for RefMutL<'a, 'b, T> {\n-    type Target = <T as ApplyL<'b>>::Out;\n-    fn deref(&self) -> &Self::Target {\n-        self.0\n-    }\n-}\n-\n-impl<'a, 'b, T: LambdaL> DerefMut for RefMutL<'a, 'b, T> {\n-    fn deref_mut(&mut self) -> &mut Self::Target {\n-        self.0\n-    }\n-}\n-\n-pub struct ScopedCell<T: LambdaL>(Cell<<T as ApplyL<'static>>::Out>);\n-\n-impl<T: LambdaL> ScopedCell<T> {\n-    pub const fn new(value: <T as ApplyL<'static>>::Out) -> Self {\n-        ScopedCell(Cell::new(value))\n-    }\n-\n-    /// Sets the value in `self` to `replacement` while\n-    /// running `f`, which gets the old value, mutably.\n-    /// The old value will be restored after `f` exits, even\n-    /// by panic, including modifications made to it by `f`.\n-    pub fn replace<'a, R>(\n-        &self,\n-        replacement: <T as ApplyL<'a>>::Out,\n-        f: impl for<'b, 'c> FnOnce(RefMutL<'b, 'c, T>) -> R,\n-    ) -> R {\n-        /// Wrapper that ensures that the cell always gets filled\n-        /// (with the original state, optionally changed by `f`),\n-        /// even if `f` had panicked.\n-        struct PutBackOnDrop<'a, T: LambdaL> {\n-            cell: &'a ScopedCell<T>,\n-            value: Option<<T as ApplyL<'static>>::Out>,\n-        }\n-\n-        impl<'a, T: LambdaL> Drop for PutBackOnDrop<'a, T> {\n-            fn drop(&mut self) {\n-                self.cell.0.set(self.value.take().unwrap());\n-            }\n-        }\n-\n-        let mut put_back_on_drop = PutBackOnDrop {\n-            cell: self,\n-            value: Some(self.0.replace(unsafe {\n-                let erased = mem::transmute_copy(&replacement);\n-                mem::forget(replacement);\n-                erased\n-            })),\n-        };\n-\n-        f(RefMutL(put_back_on_drop.value.as_mut().unwrap()))\n-    }\n-\n-    /// Sets the value in `self` to `value` while running `f`.\n-    pub fn set<R>(&self, value: <T as ApplyL<'_>>::Out, f: impl FnOnce() -> R) -> R {\n-        self.replace(value, |_| f())\n-    }\n-}"}, {"sha": "907ad256e4b432683671ffdb7158b71e2f774b7b", "filename": "crates/proc-macro-srv/src/abis/abi_1_64/proc_macro/bridge/selfless_reify.rs", "status": "removed", "additions": 0, "deletions": 84, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/5366009fe47ab06e53b68811873448de52c5cd8f/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fselfless_reify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5366009fe47ab06e53b68811873448de52c5cd8f/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fselfless_reify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fselfless_reify.rs?ref=5366009fe47ab06e53b68811873448de52c5cd8f", "patch": "@@ -1,84 +0,0 @@\n-//! Abstraction for creating `fn` pointers from any callable that *effectively*\n-//! has the equivalent of implementing `Default`, even if the compiler neither\n-//! provides `Default` nor allows reifying closures (i.e. creating `fn` pointers)\n-//! other than those with absolutely no captures.\n-//!\n-//! More specifically, for a closure-like type to be \"effectively `Default`\":\n-//! * it must be a ZST (zero-sized type): no information contained within, so\n-//!   that `Default`'s return value (if it were implemented) is unambiguous\n-//! * it must be `Copy`: no captured \"unique ZST tokens\" or any other similar\n-//!   types that would make duplicating values at will unsound\n-//!   * combined with the ZST requirement, this confers a kind of \"telecopy\"\n-//!     ability: similar to `Copy`, but without keeping the value around, and\n-//!     instead \"reconstructing\" it (a noop given it's a ZST) when needed\n-//! * it must be *provably* inhabited: no captured uninhabited types or any\n-//!   other types that cannot be constructed by the user of this abstraction\n-//!   * the proof is a value of the closure-like type itself, in a sense the\n-//!     \"seed\" for the \"telecopy\" process made possible by ZST + `Copy`\n-//!   * this requirement is the only reason an abstraction limited to a specific\n-//!     usecase is required: ZST + `Copy` can be checked with *at worst* a panic\n-//!     at the \"attempted `::default()` call\" time, but that doesn't guarantee\n-//!     that the value can be soundly created, and attempting to use the typical\n-//!     \"proof ZST token\" approach leads yet again to having a ZST + `Copy` type\n-//!     that is not proof of anything without a value (i.e. isomorphic to a\n-//!     newtype of the type it's trying to prove the inhabitation of)\n-//!\n-//! A more flexible (and safer) solution to the general problem could exist once\n-//! `const`-generic parameters can have type parameters in their types:\n-//!\n-//! ```rust,ignore (needs future const-generics)\n-//! extern \"C\" fn ffi_wrapper<\n-//!     A, R,\n-//!     F: Fn(A) -> R,\n-//!     const f: F, // <-- this `const`-generic is not yet allowed\n-//! >(arg: A) -> R {\n-//!     f(arg)\n-//! }\n-//! ```\n-\n-use std::mem;\n-\n-// FIXME(eddyb) this could be `trait` impls except for the `const fn` requirement.\n-macro_rules! define_reify_functions {\n-    ($(\n-        fn $name:ident $(<$($param:ident),*>)?\n-            for $(extern $abi:tt)? fn($($arg:ident: $arg_ty:ty),*) -> $ret_ty:ty;\n-    )+) => {\n-        $(pub const fn $name<\n-            $($($param,)*)?\n-            F: Fn($($arg_ty),*) -> $ret_ty + Copy\n-        >(f: F) -> $(extern $abi)? fn($($arg_ty),*) -> $ret_ty {\n-            // FIXME(eddyb) describe the `F` type (e.g. via `type_name::<F>`) once panic\n-            // formatting becomes possible in `const fn`.\n-            assert!(mem::size_of::<F>() == 0, \"selfless_reify: closure must be zero-sized\");\n-\n-            $(extern $abi)? fn wrapper<\n-                $($($param,)*)?\n-                F: Fn($($arg_ty),*) -> $ret_ty + Copy\n-            >($($arg: $arg_ty),*) -> $ret_ty {\n-                let f = unsafe {\n-                    // SAFETY: `F` satisfies all criteria for \"out of thin air\"\n-                    // reconstructability (see module-level doc comment).\n-                    mem::MaybeUninit::<F>::uninit().assume_init()\n-                };\n-                f($($arg),*)\n-            }\n-            let _f_proof = f;\n-            wrapper::<\n-                $($($param,)*)?\n-                F\n-            >\n-        })+\n-    }\n-}\n-\n-define_reify_functions! {\n-    fn _reify_to_extern_c_fn_unary<A, R> for extern \"C\" fn(arg: A) -> R;\n-\n-    // HACK(eddyb) this abstraction is used with `for<'a> fn(BridgeConfig<'a>)\n-    // -> T` but that doesn't work with just `reify_to_extern_c_fn_unary`\n-    // because of the `fn` pointer type being \"higher-ranked\" (i.e. the\n-    // `for<'a>` binder).\n-    // FIXME(eddyb) try to remove the lifetime from `BridgeConfig`, that'd help.\n-    fn reify_to_extern_c_fn_hrt_bridge<R> for extern \"C\" fn(bridge: super::BridgeConfig<'_>) -> R;\n-}"}, {"sha": "6e7a8d8c10df1a7d0111db0be50fb500b741df2d", "filename": "crates/proc-macro-srv/src/abis/abi_1_64/proc_macro/bridge/server.rs", "status": "removed", "additions": 0, "deletions": 339, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/5366009fe47ab06e53b68811873448de52c5cd8f/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fserver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5366009fe47ab06e53b68811873448de52c5cd8f/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fserver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fserver.rs?ref=5366009fe47ab06e53b68811873448de52c5cd8f", "patch": "@@ -1,339 +0,0 @@\n-//! Server-side traits.\n-\n-use super::*;\n-\n-// FIXME(eddyb) generate the definition of `HandleStore` in `server.rs`.\n-use super::client::HandleStore;\n-\n-pub trait Types {\n-    type FreeFunctions: 'static;\n-    type TokenStream: 'static + Clone;\n-    type Ident: 'static + Copy + Eq + Hash;\n-    type Literal: 'static + Clone;\n-    type SourceFile: 'static + Clone;\n-    type MultiSpan: 'static;\n-    type Diagnostic: 'static;\n-    type Span: 'static + Copy + Eq + Hash;\n-}\n-\n-/// Declare an associated fn of one of the traits below, adding necessary\n-/// default bodies.\n-macro_rules! associated_fn {\n-    (fn drop(&mut self, $arg:ident: $arg_ty:ty)) =>\n-        (fn drop(&mut self, $arg: $arg_ty) { mem::drop($arg) });\n-\n-    (fn clone(&mut self, $arg:ident: $arg_ty:ty) -> $ret_ty:ty) =>\n-        (fn clone(&mut self, $arg: $arg_ty) -> $ret_ty { $arg.clone() });\n-\n-    ($($item:tt)*) => ($($item)*;)\n-}\n-\n-macro_rules! declare_server_traits {\n-    ($($name:ident {\n-        $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)?;)*\n-    }),* $(,)?) => {\n-        $(pub trait $name: Types {\n-            $(associated_fn!(fn $method(&mut self, $($arg: $arg_ty),*) $(-> $ret_ty)?);)*\n-        })*\n-\n-        pub trait Server: Types $(+ $name)* {\n-            fn globals(&mut self) -> ExpnGlobals<Self::Span>;\n-        }\n-    }\n-}\n-with_api!(Self, self_, declare_server_traits);\n-\n-pub(super) struct MarkedTypes<S: Types>(S);\n-\n-impl<S: Server> Server for MarkedTypes<S> {\n-    fn globals(&mut self) -> ExpnGlobals<Self::Span> {\n-        <_>::mark(Server::globals(&mut self.0))\n-    }\n-}\n-\n-macro_rules! define_mark_types_impls {\n-    ($($name:ident {\n-        $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)?;)*\n-    }),* $(,)?) => {\n-        impl<S: Types> Types for MarkedTypes<S> {\n-            $(type $name = Marked<S::$name, client::$name>;)*\n-        }\n-\n-        $(impl<S: $name> $name for MarkedTypes<S> {\n-            $(fn $method(&mut self, $($arg: $arg_ty),*) $(-> $ret_ty)? {\n-                <_>::mark($name::$method(&mut self.0, $($arg.unmark()),*))\n-            })*\n-        })*\n-    }\n-}\n-with_api!(Self, self_, define_mark_types_impls);\n-\n-struct Dispatcher<S: Types> {\n-    handle_store: HandleStore<S>,\n-    server: S,\n-}\n-\n-macro_rules! define_dispatcher_impl {\n-    ($($name:ident {\n-        $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)?;)*\n-    }),* $(,)?) => {\n-        // FIXME(eddyb) `pub` only for `ExecutionStrategy` below.\n-        pub trait DispatcherTrait {\n-            // HACK(eddyb) these are here to allow `Self::$name` to work below.\n-            $(type $name;)*\n-            fn dispatch(&mut self, buf: Buffer) -> Buffer;\n-        }\n-\n-        impl<S: Server> DispatcherTrait for Dispatcher<MarkedTypes<S>> {\n-            $(type $name = <MarkedTypes<S> as Types>::$name;)*\n-            fn dispatch(&mut self, mut buf: Buffer) -> Buffer {\n-                let Dispatcher { handle_store, server } = self;\n-\n-                let mut reader = &buf[..];\n-                match api_tags::Method::decode(&mut reader, &mut ()) {\n-                    $(api_tags::Method::$name(m) => match m {\n-                        $(api_tags::$name::$method => {\n-                            let mut call_method = || {\n-                                reverse_decode!(reader, handle_store; $($arg: $arg_ty),*);\n-                                $name::$method(server, $($arg),*)\n-                            };\n-                            // HACK(eddyb) don't use `panic::catch_unwind` in a panic.\n-                            // If client and server happen to use the same `libstd`,\n-                            // `catch_unwind` asserts that the panic counter was 0,\n-                            // even when the closure passed to it didn't panic.\n-                            let r = if thread::panicking() {\n-                                Ok(call_method())\n-                            } else {\n-                                panic::catch_unwind(panic::AssertUnwindSafe(call_method))\n-                                    .map_err(PanicMessage::from)\n-                            };\n-\n-                            buf.clear();\n-                            r.encode(&mut buf, handle_store);\n-                        })*\n-                    }),*\n-                }\n-                buf\n-            }\n-        }\n-    }\n-}\n-with_api!(Self, self_, define_dispatcher_impl);\n-\n-pub trait ExecutionStrategy {\n-    fn run_bridge_and_client(\n-        &self,\n-        dispatcher: &mut impl DispatcherTrait,\n-        input: Buffer,\n-        run_client: extern \"C\" fn(BridgeConfig<'_>) -> Buffer,\n-        force_show_panics: bool,\n-    ) -> Buffer;\n-}\n-\n-pub struct SameThread;\n-\n-impl ExecutionStrategy for SameThread {\n-    fn run_bridge_and_client(\n-        &self,\n-        dispatcher: &mut impl DispatcherTrait,\n-        input: Buffer,\n-        run_client: extern \"C\" fn(BridgeConfig<'_>) -> Buffer,\n-        force_show_panics: bool,\n-    ) -> Buffer {\n-        let mut dispatch = |buf| dispatcher.dispatch(buf);\n-\n-        run_client(BridgeConfig {\n-            input,\n-            dispatch: (&mut dispatch).into(),\n-            force_show_panics,\n-            _marker: marker::PhantomData,\n-        })\n-    }\n-}\n-\n-// NOTE(eddyb) Two implementations are provided, the second one is a bit\n-// faster but neither is anywhere near as fast as same-thread execution.\n-\n-pub struct CrossThread1;\n-\n-impl ExecutionStrategy for CrossThread1 {\n-    fn run_bridge_and_client(\n-        &self,\n-        dispatcher: &mut impl DispatcherTrait,\n-        input: Buffer,\n-        run_client: extern \"C\" fn(BridgeConfig<'_>) -> Buffer,\n-        force_show_panics: bool,\n-    ) -> Buffer {\n-        use std::sync::mpsc::channel;\n-\n-        let (req_tx, req_rx) = channel();\n-        let (res_tx, res_rx) = channel();\n-\n-        let join_handle = thread::spawn(move || {\n-            let mut dispatch = |buf| {\n-                req_tx.send(buf).unwrap();\n-                res_rx.recv().unwrap()\n-            };\n-\n-            run_client(BridgeConfig {\n-                input,\n-                dispatch: (&mut dispatch).into(),\n-                force_show_panics,\n-                _marker: marker::PhantomData,\n-            })\n-        });\n-\n-        for b in req_rx {\n-            res_tx.send(dispatcher.dispatch(b)).unwrap();\n-        }\n-\n-        join_handle.join().unwrap()\n-    }\n-}\n-\n-pub struct CrossThread2;\n-\n-impl ExecutionStrategy for CrossThread2 {\n-    fn run_bridge_and_client(\n-        &self,\n-        dispatcher: &mut impl DispatcherTrait,\n-        input: Buffer,\n-        run_client: extern \"C\" fn(BridgeConfig<'_>) -> Buffer,\n-        force_show_panics: bool,\n-    ) -> Buffer {\n-        use std::sync::{Arc, Mutex};\n-\n-        enum State<T> {\n-            Req(T),\n-            Res(T),\n-        }\n-\n-        let mut state = Arc::new(Mutex::new(State::Res(Buffer::new())));\n-\n-        let server_thread = thread::current();\n-        let state2 = state.clone();\n-        let join_handle = thread::spawn(move || {\n-            let mut dispatch = |b| {\n-                *state2.lock().unwrap() = State::Req(b);\n-                server_thread.unpark();\n-                loop {\n-                    thread::park();\n-                    if let State::Res(b) = &mut *state2.lock().unwrap() {\n-                        break b.take();\n-                    }\n-                }\n-            };\n-\n-            let r = run_client(BridgeConfig {\n-                input,\n-                dispatch: (&mut dispatch).into(),\n-                force_show_panics,\n-                _marker: marker::PhantomData,\n-            });\n-\n-            // Wake up the server so it can exit the dispatch loop.\n-            drop(state2);\n-            server_thread.unpark();\n-\n-            r\n-        });\n-\n-        // Check whether `state2` was dropped, to know when to stop.\n-        while Arc::get_mut(&mut state).is_none() {\n-            thread::park();\n-            let mut b = match &mut *state.lock().unwrap() {\n-                State::Req(b) => b.take(),\n-                _ => continue,\n-            };\n-            b = dispatcher.dispatch(b.take());\n-            *state.lock().unwrap() = State::Res(b);\n-            join_handle.thread().unpark();\n-        }\n-\n-        join_handle.join().unwrap()\n-    }\n-}\n-\n-fn run_server<\n-    S: Server,\n-    I: Encode<HandleStore<MarkedTypes<S>>>,\n-    O: for<'a, 's> DecodeMut<'a, 's, HandleStore<MarkedTypes<S>>>,\n->(\n-    strategy: &impl ExecutionStrategy,\n-    handle_counters: &'static client::HandleCounters,\n-    server: S,\n-    input: I,\n-    run_client: extern \"C\" fn(BridgeConfig<'_>) -> Buffer,\n-    force_show_panics: bool,\n-) -> Result<O, PanicMessage> {\n-    let mut dispatcher =\n-        Dispatcher { handle_store: HandleStore::new(handle_counters), server: MarkedTypes(server) };\n-\n-    let globals = dispatcher.server.globals();\n-\n-    let mut buf = Buffer::new();\n-    (globals, input).encode(&mut buf, &mut dispatcher.handle_store);\n-\n-    buf = strategy.run_bridge_and_client(&mut dispatcher, buf, run_client, force_show_panics);\n-\n-    Result::decode(&mut &buf[..], &mut dispatcher.handle_store)\n-}\n-\n-impl client::Client<super::super::TokenStream, super::super::TokenStream> {\n-    pub fn run<S>(\n-        &self,\n-        strategy: &impl ExecutionStrategy,\n-        server: S,\n-        input: S::TokenStream,\n-        force_show_panics: bool,\n-    ) -> Result<S::TokenStream, PanicMessage>\n-    where\n-        S: Server,\n-        S::TokenStream: Default,\n-    {\n-        let client::Client { get_handle_counters, run, _marker } = *self;\n-        run_server(\n-            strategy,\n-            get_handle_counters(),\n-            server,\n-            <MarkedTypes<S> as Types>::TokenStream::mark(input),\n-            run,\n-            force_show_panics,\n-        )\n-        .map(|s| <Option<<MarkedTypes<S> as Types>::TokenStream>>::unmark(s).unwrap_or_default())\n-    }\n-}\n-\n-impl\n-    client::Client<\n-        (super::super::TokenStream, super::super::TokenStream),\n-        super::super::TokenStream,\n-    >\n-{\n-    pub fn run<S>(\n-        &self,\n-        strategy: &impl ExecutionStrategy,\n-        server: S,\n-        input: S::TokenStream,\n-        input2: S::TokenStream,\n-        force_show_panics: bool,\n-    ) -> Result<S::TokenStream, PanicMessage>\n-    where\n-        S: Server,\n-        S::TokenStream: Default,\n-    {\n-        let client::Client { get_handle_counters, run, _marker } = *self;\n-        run_server(\n-            strategy,\n-            get_handle_counters(),\n-            server,\n-            (\n-                <MarkedTypes<S> as Types>::TokenStream::mark(input),\n-                <MarkedTypes<S> as Types>::TokenStream::mark(input2),\n-            ),\n-            run,\n-            force_show_panics,\n-        )\n-        .map(|s| <Option<<MarkedTypes<S> as Types>::TokenStream>>::unmark(s).unwrap_or_default())\n-    }\n-}"}, {"sha": "3fade2dc4f9ccdd4dbac7ef201b49ba8992d09a8", "filename": "crates/proc-macro-srv/src/abis/abi_1_64/proc_macro/diagnostic.rs", "status": "removed", "additions": 0, "deletions": 166, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/5366009fe47ab06e53b68811873448de52c5cd8f/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5366009fe47ab06e53b68811873448de52c5cd8f/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fdiagnostic.rs?ref=5366009fe47ab06e53b68811873448de52c5cd8f", "patch": "@@ -1,166 +0,0 @@\n-//! lib-proc-macro diagnostic\n-//!\n-//! Copy from <https://github.com/rust-lang/rust/blob/e45d9973b2665897a768312e971b82cc62633103/src/libproc_macro/diagnostic.rs>\n-//! augmented with removing unstable features\n-\n-use super::Span;\n-\n-/// An enum representing a diagnostic level.\n-#[derive(Copy, Clone, Debug)]\n-#[non_exhaustive]\n-pub enum Level {\n-    /// An error.\n-    Error,\n-    /// A warning.\n-    Warning,\n-    /// A note.\n-    Note,\n-    /// A help message.\n-    Help,\n-}\n-\n-/// Trait implemented by types that can be converted into a set of `Span`s.\n-pub trait MultiSpan {\n-    /// Converts `self` into a `Vec<Span>`.\n-    fn into_spans(self) -> Vec<Span>;\n-}\n-\n-impl MultiSpan for Span {\n-    fn into_spans(self) -> Vec<Span> {\n-        vec![self]\n-    }\n-}\n-\n-impl MultiSpan for Vec<Span> {\n-    fn into_spans(self) -> Vec<Span> {\n-        self\n-    }\n-}\n-\n-impl<'a> MultiSpan for &'a [Span] {\n-    fn into_spans(self) -> Vec<Span> {\n-        self.to_vec()\n-    }\n-}\n-\n-/// A structure representing a diagnostic message and associated children\n-/// messages.\n-#[derive(Clone, Debug)]\n-pub struct Diagnostic {\n-    level: Level,\n-    message: String,\n-    spans: Vec<Span>,\n-    children: Vec<Diagnostic>,\n-}\n-\n-macro_rules! diagnostic_child_methods {\n-    ($spanned:ident, $regular:ident, $level:expr) => {\n-        #[doc = concat!(\"Adds a new child diagnostics message to `self` with the [`\",\n-                        stringify!($level), \"`] level, and the given `spans` and `message`.\")]\n-        pub fn $spanned<S, T>(mut self, spans: S, message: T) -> Diagnostic\n-        where\n-            S: MultiSpan,\n-            T: Into<String>,\n-        {\n-            self.children.push(Diagnostic::spanned(spans, $level, message));\n-            self\n-        }\n-\n-        #[doc = concat!(\"Adds a new child diagnostic message to `self` with the [`\",\n-                        stringify!($level), \"`] level, and the given `message`.\")]\n-        pub fn $regular<T: Into<String>>(mut self, message: T) -> Diagnostic {\n-            self.children.push(Diagnostic::new($level, message));\n-            self\n-        }\n-    };\n-}\n-\n-/// Iterator over the children diagnostics of a `Diagnostic`.\n-#[derive(Debug, Clone)]\n-pub struct Children<'a>(std::slice::Iter<'a, Diagnostic>);\n-\n-impl<'a> Iterator for Children<'a> {\n-    type Item = &'a Diagnostic;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        self.0.next()\n-    }\n-}\n-\n-impl Diagnostic {\n-    /// Creates a new diagnostic with the given `level` and `message`.\n-    pub fn new<T: Into<String>>(level: Level, message: T) -> Diagnostic {\n-        Diagnostic { level, message: message.into(), spans: vec![], children: vec![] }\n-    }\n-\n-    /// Creates a new diagnostic with the given `level` and `message` pointing to\n-    /// the given set of `spans`.\n-    pub fn spanned<S, T>(spans: S, level: Level, message: T) -> Diagnostic\n-    where\n-        S: MultiSpan,\n-        T: Into<String>,\n-    {\n-        Diagnostic { level, message: message.into(), spans: spans.into_spans(), children: vec![] }\n-    }\n-\n-    diagnostic_child_methods!(span_error, error, Level::Error);\n-    diagnostic_child_methods!(span_warning, warning, Level::Warning);\n-    diagnostic_child_methods!(span_note, note, Level::Note);\n-    diagnostic_child_methods!(span_help, help, Level::Help);\n-\n-    /// Returns the diagnostic `level` for `self`.\n-    pub fn level(&self) -> Level {\n-        self.level\n-    }\n-\n-    /// Sets the level in `self` to `level`.\n-    pub fn set_level(&mut self, level: Level) {\n-        self.level = level;\n-    }\n-\n-    /// Returns the message in `self`.\n-    pub fn message(&self) -> &str {\n-        &self.message\n-    }\n-\n-    /// Sets the message in `self` to `message`.\n-    pub fn set_message<T: Into<String>>(&mut self, message: T) {\n-        self.message = message.into();\n-    }\n-\n-    /// Returns the `Span`s in `self`.\n-    pub fn spans(&self) -> &[Span] {\n-        &self.spans\n-    }\n-\n-    /// Sets the `Span`s in `self` to `spans`.\n-    pub fn set_spans<S: MultiSpan>(&mut self, spans: S) {\n-        self.spans = spans.into_spans();\n-    }\n-\n-    /// Returns an iterator over the children diagnostics of `self`.\n-    pub fn children(&self) -> Children<'_> {\n-        Children(self.children.iter())\n-    }\n-\n-    /// Emit the diagnostic.\n-    pub fn emit(self) {\n-        fn to_internal(spans: Vec<Span>) -> super::bridge::client::MultiSpan {\n-            let mut multi_span = super::bridge::client::MultiSpan::new();\n-            for span in spans {\n-                multi_span.push(span.0);\n-            }\n-            multi_span\n-        }\n-\n-        let mut diag = super::bridge::client::Diagnostic::new(\n-            self.level,\n-            &self.message[..],\n-            to_internal(self.spans),\n-        );\n-        for c in self.children {\n-            diag.sub(c.level, &c.message[..], to_internal(c.spans));\n-        }\n-        diag.emit();\n-    }\n-}"}, {"sha": "86a59b64559037119c2f853ec53531afa7efa5eb", "filename": "crates/proc-macro-srv/src/abis/abi_1_64/proc_macro/mod.rs", "status": "removed", "additions": 0, "deletions": 1125, "changes": 1125, "blob_url": "https://github.com/rust-lang/rust/blob/5366009fe47ab06e53b68811873448de52c5cd8f/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5366009fe47ab06e53b68811873448de52c5cd8f/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fmod.rs?ref=5366009fe47ab06e53b68811873448de52c5cd8f", "patch": "@@ -1,1125 +0,0 @@\n-//! A support library for macro authors when defining new macros.\n-//!\n-//! This library, provided by the standard distribution, provides the types\n-//! consumed in the interfaces of procedurally defined macro definitions such as\n-//! function-like macros `#[proc_macro]`, macro attributes `#[proc_macro_attribute]` and\n-//! custom derive attributes`#[proc_macro_derive]`.\n-//!\n-//! See [the book] for more.\n-//!\n-//! [the book]: ../book/ch19-06-macros.html#procedural-macros-for-generating-code-from-attributes\n-\n-#[doc(hidden)]\n-pub mod bridge;\n-\n-mod diagnostic;\n-\n-pub use diagnostic::{Diagnostic, Level, MultiSpan};\n-\n-use std::cmp::Ordering;\n-use std::ops::RangeBounds;\n-use std::path::PathBuf;\n-use std::str::FromStr;\n-use std::{error, fmt, iter, mem};\n-\n-/// Determines whether proc_macro has been made accessible to the currently\n-/// running program.\n-///\n-/// The proc_macro crate is only intended for use inside the implementation of\n-/// procedural macros. All the functions in this crate panic if invoked from\n-/// outside of a procedural macro, such as from a build script or unit test or\n-/// ordinary Rust binary.\n-///\n-/// With consideration for Rust libraries that are designed to support both\n-/// macro and non-macro use cases, `proc_macro::is_available()` provides a\n-/// non-panicking way to detect whether the infrastructure required to use the\n-/// API of proc_macro is presently available. Returns true if invoked from\n-/// inside of a procedural macro, false if invoked from any other binary.\n-pub fn is_available() -> bool {\n-    bridge::client::is_available()\n-}\n-\n-/// The main type provided by this crate, representing an abstract stream of\n-/// tokens, or, more specifically, a sequence of token trees.\n-/// The type provide interfaces for iterating over those token trees and, conversely,\n-/// collecting a number of token trees into one stream.\n-///\n-/// This is both the input and output of `#[proc_macro]`, `#[proc_macro_attribute]`\n-/// and `#[proc_macro_derive]` definitions.\n-#[derive(Clone)]\n-pub struct TokenStream(Option<bridge::client::TokenStream>);\n-\n-/// Error returned from `TokenStream::from_str`.\n-#[non_exhaustive]\n-#[derive(Debug)]\n-pub struct LexError;\n-\n-impl fmt::Display for LexError {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(\"cannot parse string into token stream\")\n-    }\n-}\n-\n-impl error::Error for LexError {}\n-\n-/// Error returned from `TokenStream::expand_expr`.\n-#[non_exhaustive]\n-#[derive(Debug)]\n-pub struct ExpandError;\n-\n-impl fmt::Display for ExpandError {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(\"macro expansion failed\")\n-    }\n-}\n-\n-impl error::Error for ExpandError {}\n-\n-impl TokenStream {\n-    /// Returns an empty `TokenStream` containing no token trees.\n-    pub fn new() -> TokenStream {\n-        TokenStream(None)\n-    }\n-\n-    /// Checks if this `TokenStream` is empty.\n-    pub fn is_empty(&self) -> bool {\n-        self.0.as_ref().map(|h| h.is_empty()).unwrap_or(true)\n-    }\n-\n-    /// Parses this `TokenStream` as an expression and attempts to expand any\n-    /// macros within it. Returns the expanded `TokenStream`.\n-    ///\n-    /// Currently only expressions expanding to literals will succeed, although\n-    /// this may be relaxed in the future.\n-    ///\n-    /// NOTE: In error conditions, `expand_expr` may leave macros unexpanded,\n-    /// report an error, failing compilation, and/or return an `Err(..)`. The\n-    /// specific behavior for any error condition, and what conditions are\n-    /// considered errors, is unspecified and may change in the future.\n-    pub fn expand_expr(&self) -> Result<TokenStream, ExpandError> {\n-        let stream = self.0.as_ref().ok_or(ExpandError)?;\n-        match bridge::client::TokenStream::expand_expr(stream) {\n-            Ok(stream) => Ok(TokenStream(Some(stream))),\n-            Err(_) => Err(ExpandError),\n-        }\n-    }\n-}\n-\n-/// Attempts to break the string into tokens and parse those tokens into a token stream.\n-/// May fail for a number of reasons, for example, if the string contains unbalanced delimiters\n-/// or characters not existing in the language.\n-/// All tokens in the parsed stream get `Span::call_site()` spans.\n-///\n-/// NOTE: some errors may cause panics instead of returning `LexError`. We reserve the right to\n-/// change these errors into `LexError`s later.\n-impl FromStr for TokenStream {\n-    type Err = LexError;\n-\n-    fn from_str(src: &str) -> Result<TokenStream, LexError> {\n-        Ok(TokenStream(Some(bridge::client::TokenStream::from_str(src))))\n-    }\n-}\n-\n-/// Prints the token stream as a string that is supposed to be losslessly convertible back\n-/// into the same token stream (modulo spans), except for possibly `TokenTree::Group`s\n-/// with `Delimiter::None` delimiters and negative numeric literals.\n-impl fmt::Display for TokenStream {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(&self.to_string())\n-    }\n-}\n-\n-/// Prints token in a form convenient for debugging.\n-impl fmt::Debug for TokenStream {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(\"TokenStream \")?;\n-        f.debug_list().entries(self.clone()).finish()\n-    }\n-}\n-\n-impl Default for TokenStream {\n-    fn default() -> Self {\n-        TokenStream::new()\n-    }\n-}\n-\n-pub use quote::{quote, quote_span};\n-\n-fn tree_to_bridge_tree(\n-    tree: TokenTree,\n-) -> bridge::TokenTree<\n-    bridge::client::TokenStream,\n-    bridge::client::Span,\n-    bridge::client::Ident,\n-    bridge::client::Literal,\n-> {\n-    match tree {\n-        TokenTree::Group(tt) => bridge::TokenTree::Group(tt.0),\n-        TokenTree::Punct(tt) => bridge::TokenTree::Punct(tt.0),\n-        TokenTree::Ident(tt) => bridge::TokenTree::Ident(tt.0),\n-        TokenTree::Literal(tt) => bridge::TokenTree::Literal(tt.0),\n-    }\n-}\n-\n-/// Creates a token stream containing a single token tree.\n-impl From<TokenTree> for TokenStream {\n-    fn from(tree: TokenTree) -> TokenStream {\n-        TokenStream(Some(bridge::client::TokenStream::from_token_tree(tree_to_bridge_tree(tree))))\n-    }\n-}\n-\n-/// Non-generic helper for implementing `FromIterator<TokenStream>` and\n-/// `Extend<TokenStream>` with less monomorphization in calling crates.\n-struct ConcatStreamsHelper {\n-    streams: Vec<bridge::client::TokenStream>,\n-}\n-\n-impl ConcatStreamsHelper {\n-    fn new(capacity: usize) -> Self {\n-        ConcatStreamsHelper { streams: Vec::with_capacity(capacity) }\n-    }\n-\n-    fn push(&mut self, stream: TokenStream) {\n-        if let Some(stream) = stream.0 {\n-            self.streams.push(stream);\n-        }\n-    }\n-\n-    fn build(mut self) -> TokenStream {\n-        if self.streams.len() <= 1 {\n-            TokenStream(self.streams.pop())\n-        } else {\n-            TokenStream(Some(bridge::client::TokenStream::concat_streams(None, self.streams)))\n-        }\n-    }\n-\n-    fn append_to(mut self, stream: &mut TokenStream) {\n-        if self.streams.is_empty() {\n-            return;\n-        }\n-        let base = stream.0.take();\n-        if base.is_none() && self.streams.len() == 1 {\n-            stream.0 = self.streams.pop();\n-        } else {\n-            stream.0 = Some(bridge::client::TokenStream::concat_streams(base, self.streams));\n-        }\n-    }\n-}\n-\n-/// Collects a number of token trees into a single stream.\n-impl FromIterator<TokenTree> for TokenStream {\n-    fn from_iter<I: IntoIterator<Item = TokenTree>>(trees: I) -> Self {\n-        trees.into_iter().map(TokenStream::from).collect()\n-    }\n-}\n-\n-/// A \"flattening\" operation on token streams, collects token trees\n-/// from multiple token streams into a single stream.\n-impl FromIterator<TokenStream> for TokenStream {\n-    fn from_iter<I: IntoIterator<Item = TokenStream>>(streams: I) -> Self {\n-        let iter = streams.into_iter();\n-        let mut builder = ConcatStreamsHelper::new(iter.size_hint().0);\n-        iter.for_each(|stream| builder.push(stream));\n-        builder.build()\n-    }\n-}\n-\n-impl Extend<TokenTree> for TokenStream {\n-    fn extend<I: IntoIterator<Item = TokenTree>>(&mut self, trees: I) {\n-        self.extend(trees.into_iter().map(TokenStream::from));\n-    }\n-}\n-\n-impl Extend<TokenStream> for TokenStream {\n-    fn extend<I: IntoIterator<Item = TokenStream>>(&mut self, streams: I) {\n-        // FIXME(eddyb) Use an optimized implementation if/when possible.\n-        *self = iter::once(mem::replace(self, Self::new())).chain(streams).collect();\n-    }\n-}\n-\n-/// Public implementation details for the `TokenStream` type, such as iterators.\n-pub mod token_stream {\n-    use super::{bridge, Group, Ident, Literal, Punct, TokenStream, TokenTree};\n-\n-    /// An iterator over `TokenStream`'s `TokenTree`s.\n-    /// The iteration is \"shallow\", e.g., the iterator doesn't recurse into delimited groups,\n-    /// and returns whole groups as token trees.\n-    #[derive(Clone)]\n-    pub struct IntoIter(\n-        std::vec::IntoIter<\n-            bridge::TokenTree<\n-                bridge::client::TokenStream,\n-                bridge::client::Span,\n-                bridge::client::Ident,\n-                bridge::client::Literal,\n-            >,\n-        >,\n-    );\n-\n-    impl Iterator for IntoIter {\n-        type Item = TokenTree;\n-\n-        fn next(&mut self) -> Option<TokenTree> {\n-            self.0.next().map(|tree| match tree {\n-                bridge::TokenTree::Group(tt) => TokenTree::Group(Group(tt)),\n-                bridge::TokenTree::Punct(tt) => TokenTree::Punct(Punct(tt)),\n-                bridge::TokenTree::Ident(tt) => TokenTree::Ident(Ident(tt)),\n-                bridge::TokenTree::Literal(tt) => TokenTree::Literal(Literal(tt)),\n-            })\n-        }\n-    }\n-\n-    impl IntoIterator for TokenStream {\n-        type Item = TokenTree;\n-        type IntoIter = IntoIter;\n-\n-        fn into_iter(self) -> IntoIter {\n-            IntoIter(self.0.map(|v| v.into_trees()).unwrap_or_default().into_iter())\n-        }\n-    }\n-}\n-\n-#[doc(hidden)]\n-mod quote;\n-\n-/// A region of source code, along with macro expansion information.\n-#[derive(Copy, Clone)]\n-pub struct Span(bridge::client::Span);\n-\n-macro_rules! diagnostic_method {\n-    ($name:ident, $level:expr) => {\n-        /// Creates a new `Diagnostic` with the given `message` at the span\n-        /// `self`.\n-        pub fn $name<T: Into<String>>(self, message: T) -> Diagnostic {\n-            Diagnostic::spanned(self, $level, message)\n-        }\n-    };\n-}\n-\n-impl Span {\n-    /// A span that resolves at the macro definition site.\n-    pub fn def_site() -> Span {\n-        Span(bridge::client::Span::def_site())\n-    }\n-\n-    /// The span of the invocation of the current procedural macro.\n-    /// Identifiers created with this span will be resolved as if they were written\n-    /// directly at the macro call location (call-site hygiene) and other code\n-    /// at the macro call site will be able to refer to them as well.\n-    pub fn call_site() -> Span {\n-        Span(bridge::client::Span::call_site())\n-    }\n-\n-    /// A span that represents `macro_rules` hygiene, and sometimes resolves at the macro\n-    /// definition site (local variables, labels, `$crate`) and sometimes at the macro\n-    /// call site (everything else).\n-    /// The span location is taken from the call-site.\n-    pub fn mixed_site() -> Span {\n-        Span(bridge::client::Span::mixed_site())\n-    }\n-\n-    /// The original source file into which this span points.\n-    pub fn source_file(&self) -> SourceFile {\n-        SourceFile(self.0.source_file())\n-    }\n-\n-    /// The `Span` for the tokens in the previous macro expansion from which\n-    /// `self` was generated from, if any.\n-    pub fn parent(&self) -> Option<Span> {\n-        self.0.parent().map(Span)\n-    }\n-\n-    /// The span for the origin source code that `self` was generated from. If\n-    /// this `Span` wasn't generated from other macro expansions then the return\n-    /// value is the same as `*self`.\n-    pub fn source(&self) -> Span {\n-        Span(self.0.source())\n-    }\n-\n-    /// Gets the starting line/column in the source file for this span.\n-    pub fn start(&self) -> LineColumn {\n-        self.0.start().add_1_to_column()\n-    }\n-\n-    /// Gets the ending line/column in the source file for this span.\n-    pub fn end(&self) -> LineColumn {\n-        self.0.end().add_1_to_column()\n-    }\n-\n-    /// Creates an empty span pointing to directly before this span.\n-    pub fn before(&self) -> Span {\n-        Span(self.0.before())\n-    }\n-\n-    /// Creates an empty span pointing to directly after this span.\n-    pub fn after(&self) -> Span {\n-        Span(self.0.after())\n-    }\n-\n-    /// Creates a new span encompassing `self` and `other`.\n-    ///\n-    /// Returns `None` if `self` and `other` are from different files.\n-    pub fn join(&self, other: Span) -> Option<Span> {\n-        self.0.join(other.0).map(Span)\n-    }\n-\n-    /// Creates a new span with the same line/column information as `self` but\n-    /// that resolves symbols as though it were at `other`.\n-    pub fn resolved_at(&self, other: Span) -> Span {\n-        Span(self.0.resolved_at(other.0))\n-    }\n-\n-    /// Creates a new span with the same name resolution behavior as `self` but\n-    /// with the line/column information of `other`.\n-    pub fn located_at(&self, other: Span) -> Span {\n-        other.resolved_at(*self)\n-    }\n-\n-    /// Compares to spans to see if they're equal.\n-    pub fn eq(&self, other: &Span) -> bool {\n-        self.0 == other.0\n-    }\n-\n-    /// Returns the source text behind a span. This preserves the original source\n-    /// code, including spaces and comments. It only returns a result if the span\n-    /// corresponds to real source code.\n-    ///\n-    /// Note: The observable result of a macro should only rely on the tokens and\n-    /// not on this source text. The result of this function is a best effort to\n-    /// be used for diagnostics only.\n-    pub fn source_text(&self) -> Option<String> {\n-        self.0.source_text()\n-    }\n-\n-    // Used by the implementation of `Span::quote`\n-    #[doc(hidden)]\n-    pub fn save_span(&self) -> usize {\n-        self.0.save_span()\n-    }\n-\n-    // Used by the implementation of `Span::quote`\n-    #[doc(hidden)]\n-    pub fn recover_proc_macro_span(id: usize) -> Span {\n-        Span(bridge::client::Span::recover_proc_macro_span(id))\n-    }\n-\n-    diagnostic_method!(error, Level::Error);\n-    diagnostic_method!(warning, Level::Warning);\n-    diagnostic_method!(note, Level::Note);\n-    diagnostic_method!(help, Level::Help);\n-}\n-\n-/// Prints a span in a form convenient for debugging.\n-impl fmt::Debug for Span {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.0.fmt(f)\n-    }\n-}\n-\n-/// A line-column pair representing the start or end of a `Span`.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub struct LineColumn {\n-    /// The 1-indexed line in the source file on which the span starts or ends (inclusive).\n-    pub line: usize,\n-    /// The 1-indexed column (number of bytes in UTF-8 encoding) in the source\n-    /// file on which the span starts or ends (inclusive).\n-    pub column: usize,\n-}\n-\n-impl LineColumn {\n-    fn add_1_to_column(self) -> Self {\n-        LineColumn { line: self.line, column: self.column + 1 }\n-    }\n-}\n-\n-impl Ord for LineColumn {\n-    fn cmp(&self, other: &Self) -> Ordering {\n-        self.line.cmp(&other.line).then(self.column.cmp(&other.column))\n-    }\n-}\n-\n-impl PartialOrd for LineColumn {\n-    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n-/// The source file of a given `Span`.\n-#[derive(Clone)]\n-pub struct SourceFile(bridge::client::SourceFile);\n-\n-impl SourceFile {\n-    /// Gets the path to this source file.\n-    ///\n-    /// ### Note\n-    /// If the code span associated with this `SourceFile` was generated by an external macro, this\n-    /// macro, this might not be an actual path on the filesystem. Use [`is_real`] to check.\n-    ///\n-    /// Also note that even if `is_real` returns `true`, if `--remap-path-prefix` was passed on\n-    /// the command line, the path as given might not actually be valid.\n-    ///\n-    /// [`is_real`]: Self::is_real\n-    pub fn path(&self) -> PathBuf {\n-        PathBuf::from(self.0.path())\n-    }\n-\n-    /// Returns `true` if this source file is a real source file, and not generated by an external\n-    /// macro's expansion.\n-    pub fn is_real(&self) -> bool {\n-        // This is a hack until intercrate spans are implemented and we can have real source files\n-        // for spans generated in external macros.\n-        // https://github.com/rust-lang/rust/pull/43604#issuecomment-333334368\n-        self.0.is_real()\n-    }\n-}\n-\n-impl fmt::Debug for SourceFile {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"SourceFile\")\n-            .field(\"path\", &self.path())\n-            .field(\"is_real\", &self.is_real())\n-            .finish()\n-    }\n-}\n-\n-impl PartialEq for SourceFile {\n-    fn eq(&self, other: &Self) -> bool {\n-        self.0.eq(&other.0)\n-    }\n-}\n-\n-impl Eq for SourceFile {}\n-\n-/// A single token or a delimited sequence of token trees (e.g., `[1, (), ..]`).\n-#[derive(Clone)]\n-pub enum TokenTree {\n-    /// A token stream surrounded by bracket delimiters.\n-    Group(Group),\n-    /// An identifier.\n-    Ident(Ident),\n-    /// A single punctuation character (`+`, `,`, `$`, etc.).\n-    Punct(Punct),\n-    /// A literal character (`'a'`), string (`\"hello\"`), number (`2.3`), etc.\n-    Literal(Literal),\n-}\n-\n-impl TokenTree {\n-    /// Returns the span of this tree, delegating to the `span` method of\n-    /// the contained token or a delimited stream.\n-    pub fn span(&self) -> Span {\n-        match *self {\n-            TokenTree::Group(ref t) => t.span(),\n-            TokenTree::Ident(ref t) => t.span(),\n-            TokenTree::Punct(ref t) => t.span(),\n-            TokenTree::Literal(ref t) => t.span(),\n-        }\n-    }\n-\n-    /// Configures the span for *only this token*.\n-    ///\n-    /// Note that if this token is a `Group` then this method will not configure\n-    /// the span of each of the internal tokens, this will simply delegate to\n-    /// the `set_span` method of each variant.\n-    pub fn set_span(&mut self, span: Span) {\n-        match *self {\n-            TokenTree::Group(ref mut t) => t.set_span(span),\n-            TokenTree::Ident(ref mut t) => t.set_span(span),\n-            TokenTree::Punct(ref mut t) => t.set_span(span),\n-            TokenTree::Literal(ref mut t) => t.set_span(span),\n-        }\n-    }\n-}\n-\n-/// Prints token tree in a form convenient for debugging.\n-impl fmt::Debug for TokenTree {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // Each of these has the name in the struct type in the derived debug,\n-        // so don't bother with an extra layer of indirection\n-        match *self {\n-            TokenTree::Group(ref tt) => tt.fmt(f),\n-            TokenTree::Ident(ref tt) => tt.fmt(f),\n-            TokenTree::Punct(ref tt) => tt.fmt(f),\n-            TokenTree::Literal(ref tt) => tt.fmt(f),\n-        }\n-    }\n-}\n-\n-impl From<Group> for TokenTree {\n-    fn from(g: Group) -> TokenTree {\n-        TokenTree::Group(g)\n-    }\n-}\n-\n-impl From<Ident> for TokenTree {\n-    fn from(g: Ident) -> TokenTree {\n-        TokenTree::Ident(g)\n-    }\n-}\n-\n-impl From<Punct> for TokenTree {\n-    fn from(g: Punct) -> TokenTree {\n-        TokenTree::Punct(g)\n-    }\n-}\n-\n-impl From<Literal> for TokenTree {\n-    fn from(g: Literal) -> TokenTree {\n-        TokenTree::Literal(g)\n-    }\n-}\n-\n-/// Prints the token tree as a string that is supposed to be losslessly convertible back\n-/// into the same token tree (modulo spans), except for possibly `TokenTree::Group`s\n-/// with `Delimiter::None` delimiters and negative numeric literals.\n-impl fmt::Display for TokenTree {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(&self.to_string())\n-    }\n-}\n-\n-/// A delimited token stream.\n-///\n-/// A `Group` internally contains a `TokenStream` which is surrounded by `Delimiter`s.\n-#[derive(Clone)]\n-pub struct Group(bridge::Group<bridge::client::TokenStream, bridge::client::Span>);\n-\n-/// Describes how a sequence of token trees is delimited.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum Delimiter {\n-    /// `( ... )`\n-    Parenthesis,\n-    /// `{ ... }`\n-    Brace,\n-    /// `[ ... ]`\n-    Bracket,\n-    /// `\u00d8 ... \u00d8`\n-    /// An invisible delimiter, that may, for example, appear around tokens coming from a\n-    /// \"macro variable\" `$var`. It is important to preserve operator priorities in cases like\n-    /// `$var * 3` where `$var` is `1 + 2`.\n-    /// Invisible delimiters might not survive roundtrip of a token stream through a string.\n-    None,\n-}\n-\n-impl Group {\n-    /// Creates a new `Group` with the given delimiter and token stream.\n-    ///\n-    /// This constructor will set the span for this group to\n-    /// `Span::call_site()`. To change the span you can use the `set_span`\n-    /// method below.\n-    pub fn new(delimiter: Delimiter, stream: TokenStream) -> Group {\n-        Group(bridge::Group {\n-            delimiter,\n-            stream: stream.0,\n-            span: bridge::DelimSpan::from_single(Span::call_site().0),\n-        })\n-    }\n-\n-    /// Returns the delimiter of this `Group`\n-    pub fn delimiter(&self) -> Delimiter {\n-        self.0.delimiter\n-    }\n-\n-    /// Returns the `TokenStream` of tokens that are delimited in this `Group`.\n-    ///\n-    /// Note that the returned token stream does not include the delimiter\n-    /// returned above.\n-    pub fn stream(&self) -> TokenStream {\n-        TokenStream(self.0.stream.clone())\n-    }\n-\n-    /// Returns the span for the delimiters of this token stream, spanning the\n-    /// entire `Group`.\n-    ///\n-    /// ```text\n-    /// pub fn span(&self) -> Span {\n-    ///            ^^^^^^^\n-    /// ```\n-    pub fn span(&self) -> Span {\n-        Span(self.0.span.entire)\n-    }\n-\n-    /// Returns the span pointing to the opening delimiter of this group.\n-    ///\n-    /// ```text\n-    /// pub fn span_open(&self) -> Span {\n-    ///                 ^\n-    /// ```\n-    pub fn span_open(&self) -> Span {\n-        Span(self.0.span.open)\n-    }\n-\n-    /// Returns the span pointing to the closing delimiter of this group.\n-    ///\n-    /// ```text\n-    /// pub fn span_close(&self) -> Span {\n-    ///                        ^\n-    /// ```\n-    pub fn span_close(&self) -> Span {\n-        Span(self.0.span.close)\n-    }\n-\n-    /// Configures the span for this `Group`'s delimiters, but not its internal\n-    /// tokens.\n-    ///\n-    /// This method will **not** set the span of all the internal tokens spanned\n-    /// by this group, but rather it will only set the span of the delimiter\n-    /// tokens at the level of the `Group`.\n-    pub fn set_span(&mut self, span: Span) {\n-        self.0.span = bridge::DelimSpan::from_single(span.0);\n-    }\n-}\n-\n-/// Prints the group as a string that should be losslessly convertible back\n-/// into the same group (modulo spans), except for possibly `TokenTree::Group`s\n-/// with `Delimiter::None` delimiters.\n-impl fmt::Display for Group {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(&self.to_string())\n-    }\n-}\n-\n-impl fmt::Debug for Group {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Group\")\n-            .field(\"delimiter\", &self.delimiter())\n-            .field(\"stream\", &self.stream())\n-            .field(\"span\", &self.span())\n-            .finish()\n-    }\n-}\n-\n-/// A `Punct` is a single punctuation character such as `+`, `-` or `#`.\n-///\n-/// Multi-character operators like `+=` are represented as two instances of `Punct` with different\n-/// forms of `Spacing` returned.\n-#[derive(Clone)]\n-pub struct Punct(bridge::Punct<bridge::client::Span>);\n-\n-/// Describes whether a `Punct` is followed immediately by another `Punct` ([`Spacing::Joint`]) or\n-/// by a different token or whitespace ([`Spacing::Alone`]).\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum Spacing {\n-    /// A `Punct` is not immediately followed by another `Punct`.\n-    /// E.g. `+` is `Alone` in `+ =`, `+ident` and `+()`.\n-    Alone,\n-    /// A `Punct` is immediately followed by another `Punct`.\n-    /// E.g. `+` is `Joint` in `+=` and `++`.\n-    ///\n-    /// Additionally, single quote `'` can join with identifiers to form lifetimes: `'ident`.\n-    Joint,\n-}\n-\n-impl Punct {\n-    /// Creates a new `Punct` from the given character and spacing.\n-    /// The `ch` argument must be a valid punctuation character permitted by the language,\n-    /// otherwise the function will panic.\n-    ///\n-    /// The returned `Punct` will have the default span of `Span::call_site()`\n-    /// which can be further configured with the `set_span` method below.\n-    pub fn new(ch: char, spacing: Spacing) -> Punct {\n-        const LEGAL_CHARS: &[char] = &[\n-            '=', '<', '>', '!', '~', '+', '-', '*', '/', '%', '^', '&', '|', '@', '.', ',', ';',\n-            ':', '#', '$', '?', '\\'',\n-        ];\n-        if !LEGAL_CHARS.contains(&ch) {\n-            panic!(\"unsupported character `{:?}`\", ch);\n-        }\n-        Punct(bridge::Punct {\n-            ch: ch as u8,\n-            joint: spacing == Spacing::Joint,\n-            span: Span::call_site().0,\n-        })\n-    }\n-\n-    /// Returns the value of this punctuation character as `char`.\n-    pub fn as_char(&self) -> char {\n-        self.0.ch as char\n-    }\n-\n-    /// Returns the spacing of this punctuation character, indicating whether it's immediately\n-    /// followed by another `Punct` in the token stream, so they can potentially be combined into\n-    /// a multi-character operator (`Joint`), or it's followed by some other token or whitespace\n-    /// (`Alone`) so the operator has certainly ended.\n-    pub fn spacing(&self) -> Spacing {\n-        if self.0.joint {\n-            Spacing::Joint\n-        } else {\n-            Spacing::Alone\n-        }\n-    }\n-\n-    /// Returns the span for this punctuation character.\n-    pub fn span(&self) -> Span {\n-        Span(self.0.span)\n-    }\n-\n-    /// Configure the span for this punctuation character.\n-    pub fn set_span(&mut self, span: Span) {\n-        self.0.span = span.0;\n-    }\n-}\n-\n-/// Prints the punctuation character as a string that should be losslessly convertible\n-/// back into the same character.\n-impl fmt::Display for Punct {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(&self.to_string())\n-    }\n-}\n-\n-impl fmt::Debug for Punct {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Punct\")\n-            .field(\"ch\", &self.as_char())\n-            .field(\"spacing\", &self.spacing())\n-            .field(\"span\", &self.span())\n-            .finish()\n-    }\n-}\n-\n-impl PartialEq<char> for Punct {\n-    fn eq(&self, rhs: &char) -> bool {\n-        self.as_char() == *rhs\n-    }\n-}\n-\n-impl PartialEq<Punct> for char {\n-    fn eq(&self, rhs: &Punct) -> bool {\n-        *self == rhs.as_char()\n-    }\n-}\n-\n-/// An identifier (`ident`).\n-#[derive(Clone)]\n-pub struct Ident(bridge::client::Ident);\n-\n-impl Ident {\n-    /// Creates a new `Ident` with the given `string` as well as the specified\n-    /// `span`.\n-    /// The `string` argument must be a valid identifier permitted by the\n-    /// language (including keywords, e.g. `self` or `fn`). Otherwise, the function will panic.\n-    ///\n-    /// Note that `span`, currently in rustc, configures the hygiene information\n-    /// for this identifier.\n-    ///\n-    /// As of this time `Span::call_site()` explicitly opts-in to \"call-site\" hygiene\n-    /// meaning that identifiers created with this span will be resolved as if they were written\n-    /// directly at the location of the macro call, and other code at the macro call site will be\n-    /// able to refer to them as well.\n-    ///\n-    /// Later spans like `Span::def_site()` will allow to opt-in to \"definition-site\" hygiene\n-    /// meaning that identifiers created with this span will be resolved at the location of the\n-    /// macro definition and other code at the macro call site will not be able to refer to them.\n-    ///\n-    /// Due to the current importance of hygiene this constructor, unlike other\n-    /// tokens, requires a `Span` to be specified at construction.\n-    pub fn new(string: &str, span: Span) -> Ident {\n-        Ident(bridge::client::Ident::new(string, span.0, false))\n-    }\n-\n-    /// Same as `Ident::new`, but creates a raw identifier (`r#ident`).\n-    /// The `string` argument be a valid identifier permitted by the language\n-    /// (including keywords, e.g. `fn`). Keywords which are usable in path segments\n-    /// (e.g. `self`, `super`) are not supported, and will cause a panic.\n-    pub fn new_raw(string: &str, span: Span) -> Ident {\n-        Ident(bridge::client::Ident::new(string, span.0, true))\n-    }\n-\n-    /// Returns the span of this `Ident`, encompassing the entire string returned\n-    /// by [`to_string`](Self::to_string).\n-    pub fn span(&self) -> Span {\n-        Span(self.0.span())\n-    }\n-\n-    /// Configures the span of this `Ident`, possibly changing its hygiene context.\n-    pub fn set_span(&mut self, span: Span) {\n-        self.0 = self.0.with_span(span.0);\n-    }\n-}\n-\n-/// Prints the identifier as a string that should be losslessly convertible\n-/// back into the same identifier.\n-impl fmt::Display for Ident {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(&self.to_string())\n-    }\n-}\n-\n-impl fmt::Debug for Ident {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Ident\")\n-            .field(\"ident\", &self.to_string())\n-            .field(\"span\", &self.span())\n-            .finish()\n-    }\n-}\n-\n-/// A literal string (`\"hello\"`), byte string (`b\"hello\"`),\n-/// character (`'a'`), byte character (`b'a'`), an integer or floating point number\n-/// with or without a suffix (`1`, `1u8`, `2.3`, `2.3f32`).\n-/// Boolean literals like `true` and `false` do not belong here, they are `Ident`s.\n-#[derive(Clone)]\n-pub struct Literal(bridge::client::Literal);\n-\n-macro_rules! suffixed_int_literals {\n-    ($($name:ident => $kind:ident,)*) => ($(\n-        /// Creates a new suffixed integer literal with the specified value.\n-        ///\n-        /// This function will create an integer like `1u32` where the integer\n-        /// value specified is the first part of the token and the integral is\n-        /// also suffixed at the end.\n-        /// Literals created from negative numbers might not survive round-trips through\n-        /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n-        ///\n-        /// Literals created through this method have the `Span::call_site()`\n-        /// span by default, which can be configured with the `set_span` method\n-        /// below.\n-        pub fn $name(n: $kind) -> Literal {\n-            Literal(bridge::client::Literal::typed_integer(&n.to_string(), stringify!($kind)))\n-        }\n-    )*)\n-}\n-\n-macro_rules! unsuffixed_int_literals {\n-    ($($name:ident => $kind:ident,)*) => ($(\n-        /// Creates a new unsuffixed integer literal with the specified value.\n-        ///\n-        /// This function will create an integer like `1` where the integer\n-        /// value specified is the first part of the token. No suffix is\n-        /// specified on this token, meaning that invocations like\n-        /// `Literal::i8_unsuffixed(1)` are equivalent to\n-        /// `Literal::u32_unsuffixed(1)`.\n-        /// Literals created from negative numbers might not survive rountrips through\n-        /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n-        ///\n-        /// Literals created through this method have the `Span::call_site()`\n-        /// span by default, which can be configured with the `set_span` method\n-        /// below.\n-        pub fn $name(n: $kind) -> Literal {\n-            Literal(bridge::client::Literal::integer(&n.to_string()))\n-        }\n-    )*)\n-}\n-\n-impl Literal {\n-    suffixed_int_literals! {\n-        u8_suffixed => u8,\n-        u16_suffixed => u16,\n-        u32_suffixed => u32,\n-        u64_suffixed => u64,\n-        u128_suffixed => u128,\n-        usize_suffixed => usize,\n-        i8_suffixed => i8,\n-        i16_suffixed => i16,\n-        i32_suffixed => i32,\n-        i64_suffixed => i64,\n-        i128_suffixed => i128,\n-        isize_suffixed => isize,\n-    }\n-\n-    unsuffixed_int_literals! {\n-        u8_unsuffixed => u8,\n-        u16_unsuffixed => u16,\n-        u32_unsuffixed => u32,\n-        u64_unsuffixed => u64,\n-        u128_unsuffixed => u128,\n-        usize_unsuffixed => usize,\n-        i8_unsuffixed => i8,\n-        i16_unsuffixed => i16,\n-        i32_unsuffixed => i32,\n-        i64_unsuffixed => i64,\n-        i128_unsuffixed => i128,\n-        isize_unsuffixed => isize,\n-    }\n-\n-    /// Creates a new unsuffixed floating-point literal.\n-    ///\n-    /// This constructor is similar to those like `Literal::i8_unsuffixed` where\n-    /// the float's value is emitted directly into the token but no suffix is\n-    /// used, so it may be inferred to be a `f64` later in the compiler.\n-    /// Literals created from negative numbers might not survive rountrips through\n-    /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function requires that the specified float is finite, for\n-    /// example if it is infinity or NaN this function will panic.\n-    pub fn f32_unsuffixed(n: f32) -> Literal {\n-        if !n.is_finite() {\n-            panic!(\"Invalid float literal {n}\");\n-        }\n-        let mut repr = n.to_string();\n-        if !repr.contains('.') {\n-            repr.push_str(\".0\");\n-        }\n-        Literal(bridge::client::Literal::float(&repr))\n-    }\n-\n-    /// Creates a new suffixed floating-point literal.\n-    ///\n-    /// This constructor will create a literal like `1.0f32` where the value\n-    /// specified is the preceding part of the token and `f32` is the suffix of\n-    /// the token. This token will always be inferred to be an `f32` in the\n-    /// compiler.\n-    /// Literals created from negative numbers might not survive rountrips through\n-    /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function requires that the specified float is finite, for\n-    /// example if it is infinity or NaN this function will panic.\n-    pub fn f32_suffixed(n: f32) -> Literal {\n-        if !n.is_finite() {\n-            panic!(\"Invalid float literal {n}\");\n-        }\n-        Literal(bridge::client::Literal::f32(&n.to_string()))\n-    }\n-\n-    /// Creates a new unsuffixed floating-point literal.\n-    ///\n-    /// This constructor is similar to those like `Literal::i8_unsuffixed` where\n-    /// the float's value is emitted directly into the token but no suffix is\n-    /// used, so it may be inferred to be a `f64` later in the compiler.\n-    /// Literals created from negative numbers might not survive rountrips through\n-    /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function requires that the specified float is finite, for\n-    /// example if it is infinity or NaN this function will panic.\n-    pub fn f64_unsuffixed(n: f64) -> Literal {\n-        if !n.is_finite() {\n-            panic!(\"Invalid float literal {n}\");\n-        }\n-        let mut repr = n.to_string();\n-        if !repr.contains('.') {\n-            repr.push_str(\".0\");\n-        }\n-        Literal(bridge::client::Literal::float(&repr))\n-    }\n-\n-    /// Creates a new suffixed floating-point literal.\n-    ///\n-    /// This constructor will create a literal like `1.0f64` where the value\n-    /// specified is the preceding part of the token and `f64` is the suffix of\n-    /// the token. This token will always be inferred to be an `f64` in the\n-    /// compiler.\n-    /// Literals created from negative numbers might not survive rountrips through\n-    /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function requires that the specified float is finite, for\n-    /// example if it is infinity or NaN this function will panic.\n-    pub fn f64_suffixed(n: f64) -> Literal {\n-        if !n.is_finite() {\n-            panic!(\"Invalid float literal {n}\");\n-        }\n-        Literal(bridge::client::Literal::f64(&n.to_string()))\n-    }\n-\n-    /// String literal.\n-    pub fn string(string: &str) -> Literal {\n-        Literal(bridge::client::Literal::string(string))\n-    }\n-\n-    /// Character literal.\n-    pub fn character(ch: char) -> Literal {\n-        Literal(bridge::client::Literal::character(ch))\n-    }\n-\n-    /// Byte string literal.\n-    pub fn byte_string(bytes: &[u8]) -> Literal {\n-        Literal(bridge::client::Literal::byte_string(bytes))\n-    }\n-\n-    /// Returns the span encompassing this literal.\n-    pub fn span(&self) -> Span {\n-        Span(self.0.span())\n-    }\n-\n-    /// Configures the span associated for this literal.\n-    pub fn set_span(&mut self, span: Span) {\n-        self.0.set_span(span.0);\n-    }\n-\n-    /// Returns a `Span` that is a subset of `self.span()` containing only the\n-    /// source bytes in range `range`. Returns `None` if the would-be trimmed\n-    /// span is outside the bounds of `self`.\n-    // FIXME(SergioBenitez): check that the byte range starts and ends at a\n-    // UTF-8 boundary of the source. otherwise, it's likely that a panic will\n-    // occur elsewhere when the source text is printed.\n-    // FIXME(SergioBenitez): there is no way for the user to know what\n-    // `self.span()` actually maps to, so this method can currently only be\n-    // called blindly. For example, `to_string()` for the character 'c' returns\n-    // \"'\\u{63}'\"; there is no way for the user to know whether the source text\n-    // was 'c' or whether it was '\\u{63}'.\n-    pub fn subspan<R: RangeBounds<usize>>(&self, range: R) -> Option<Span> {\n-        self.0.subspan(range.start_bound().cloned(), range.end_bound().cloned()).map(Span)\n-    }\n-}\n-\n-/// Parse a single literal from its stringified representation.\n-///\n-/// In order to parse successfully, the input string must not contain anything\n-/// but the literal token. Specifically, it must not contain whitespace or\n-/// comments in addition to the literal.\n-///\n-/// The resulting literal token will have a `Span::call_site()` span.\n-///\n-/// NOTE: some errors may cause panics instead of returning `LexError`. We\n-/// reserve the right to change these errors into `LexError`s later.\n-impl FromStr for Literal {\n-    type Err = LexError;\n-\n-    fn from_str(src: &str) -> Result<Self, LexError> {\n-        match bridge::client::Literal::from_str(src) {\n-            Ok(literal) => Ok(Literal(literal)),\n-            Err(()) => Err(LexError),\n-        }\n-    }\n-}\n-\n-/// Prints the literal as a string that should be losslessly convertible\n-/// back into the same literal (except for possible rounding for floating point literals).\n-impl fmt::Display for Literal {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(&self.to_string())\n-    }\n-}\n-\n-impl fmt::Debug for Literal {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.0.fmt(f)\n-    }\n-}\n-\n-/// Tracked access to environment variables.\n-pub mod tracked_env {\n-    use std::env::{self, VarError};\n-    use std::ffi::OsStr;\n-\n-    /// Retrieve an environment variable and add it to build dependency info.\n-    /// Build system executing the compiler will know that the variable was accessed during\n-    /// compilation, and will be able to rerun the build when the value of that variable changes.\n-    /// Besides the dependency tracking this function should be equivalent to `env::var` from the\n-    /// standard library, except that the argument must be UTF-8.\n-    pub fn var<K: AsRef<OsStr> + AsRef<str>>(key: K) -> Result<String, VarError> {\n-        let key: &str = key.as_ref();\n-        let value = env::var(key);\n-        super::bridge::client::FreeFunctions::track_env_var(key, value.as_deref().ok());\n-        value\n-    }\n-}\n-\n-/// Tracked access to additional files.\n-pub mod tracked_path {\n-\n-    /// Track a file explicitly.\n-    ///\n-    /// Commonly used for tracking asset preprocessing.\n-    pub fn path<P: AsRef<str>>(path: P) {\n-        let path: &str = path.as_ref();\n-        super::bridge::client::FreeFunctions::track_path(path);\n-    }\n-}"}, {"sha": "39309faa412133f1c3638332f1a0502cdc9f6248", "filename": "crates/proc-macro-srv/src/abis/abi_1_64/proc_macro/quote.rs", "status": "removed", "additions": 0, "deletions": 139, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/5366009fe47ab06e53b68811873448de52c5cd8f/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5366009fe47ab06e53b68811873448de52c5cd8f/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fquote.rs?ref=5366009fe47ab06e53b68811873448de52c5cd8f", "patch": "@@ -1,139 +0,0 @@\n-//! # Quasiquoter\n-//! This file contains the implementation internals of the quasiquoter provided by `quote!`.\n-\n-//! This quasiquoter uses macros 2.0 hygiene to reliably access\n-//! items from `proc_macro`, to build a `proc_macro::TokenStream`.\n-\n-use super::{Delimiter, Group, Ident, Literal, Punct, Spacing, Span, TokenStream, TokenTree};\n-\n-macro_rules! quote_tt {\n-    (($($t:tt)*)) => { Group::new(Delimiter::Parenthesis, quote!($($t)*)) };\n-    ([$($t:tt)*]) => { Group::new(Delimiter::Bracket, quote!($($t)*)) };\n-    ({$($t:tt)*}) => { Group::new(Delimiter::Brace, quote!($($t)*)) };\n-    (,) => { Punct::new(',', Spacing::Alone) };\n-    (.) => { Punct::new('.', Spacing::Alone) };\n-    (;) => { Punct::new(';', Spacing::Alone) };\n-    (!) => { Punct::new('!', Spacing::Alone) };\n-    (<) => { Punct::new('<', Spacing::Alone) };\n-    (>) => { Punct::new('>', Spacing::Alone) };\n-    (&) => { Punct::new('&', Spacing::Alone) };\n-    (=) => { Punct::new('=', Spacing::Alone) };\n-    ($i:ident) => { Ident::new(stringify!($i), Span::def_site()) };\n-}\n-\n-macro_rules! quote_ts {\n-    ((@ $($t:tt)*)) => { $($t)* };\n-    (::) => {\n-        [\n-            TokenTree::from(Punct::new(':', Spacing::Joint)),\n-            TokenTree::from(Punct::new(':', Spacing::Alone)),\n-        ].iter()\n-            .cloned()\n-            .map(|mut x| {\n-                x.set_span(Span::def_site());\n-                x\n-            })\n-            .collect::<TokenStream>()\n-    };\n-    ($t:tt) => { TokenTree::from(quote_tt!($t)) };\n-}\n-\n-/// Simpler version of the real `quote!` macro, implemented solely\n-/// through `macro_rules`, for bootstrapping the real implementation\n-/// (see the `quote` function), which does not have access to the\n-/// real `quote!` macro due to the `proc_macro` crate not being\n-/// able to depend on itself.\n-///\n-/// Note: supported tokens are a subset of the real `quote!`, but\n-/// unquoting is different: instead of `$x`, this uses `(@ expr)`.\n-macro_rules! quote {\n-    () => { TokenStream::new() };\n-    ($($t:tt)*) => {\n-        [\n-            $(TokenStream::from(quote_ts!($t)),)*\n-        ].iter().cloned().collect::<TokenStream>()\n-    };\n-}\n-\n-/// Quote a `TokenStream` into a `TokenStream`.\n-/// This is the actual implementation of the `quote!()` proc macro.\n-///\n-/// It is loaded by the compiler in `register_builtin_macros`.\n-pub fn quote(stream: TokenStream) -> TokenStream {\n-    if stream.is_empty() {\n-        return quote!(super::TokenStream::new());\n-    }\n-    let proc_macro_crate = quote!(crate);\n-    let mut after_dollar = false;\n-    let tokens = stream\n-        .into_iter()\n-        .filter_map(|tree| {\n-            if after_dollar {\n-                after_dollar = false;\n-                match tree {\n-                    TokenTree::Ident(_) => {\n-                        return Some(quote!(Into::<super::TokenStream>::into(\n-                        Clone::clone(&(@ tree))),));\n-                    }\n-                    TokenTree::Punct(ref tt) if tt.as_char() == '$' => {}\n-                    _ => panic!(\"`$` must be followed by an ident or `$` in `quote!`\"),\n-                }\n-            } else if let TokenTree::Punct(ref tt) = tree {\n-                if tt.as_char() == '$' {\n-                    after_dollar = true;\n-                    return None;\n-                }\n-            }\n-\n-            Some(quote!(super::TokenStream::from((@ match tree {\n-                TokenTree::Punct(tt) => quote!(super::TokenTree::Punct(super::Punct::new(\n-                    (@ TokenTree::from(Literal::character(tt.as_char()))),\n-                    (@ match tt.spacing() {\n-                        Spacing::Alone => quote!(super::Spacing::Alone),\n-                        Spacing::Joint => quote!(super::Spacing::Joint),\n-                    }),\n-                ))),\n-                TokenTree::Group(tt) => quote!(super::TokenTree::Group(super::Group::new(\n-                    (@ match tt.delimiter() {\n-                        Delimiter::Parenthesis => quote!(super::Delimiter::Parenthesis),\n-                        Delimiter::Brace => quote!(super::Delimiter::Brace),\n-                        Delimiter::Bracket => quote!(super::Delimiter::Bracket),\n-                        Delimiter::None => quote!(super::Delimiter::None),\n-                    }),\n-                    (@ quote(tt.stream())),\n-                ))),\n-                TokenTree::Ident(tt) => quote!(super::TokenTree::Ident(super::Ident::new(\n-                    (@ TokenTree::from(Literal::string(&tt.to_string()))),\n-                    (@ quote_span(proc_macro_crate.clone(), tt.span())),\n-                ))),\n-                TokenTree::Literal(tt) => quote!(super::TokenTree::Literal({\n-                    let mut iter = (@ TokenTree::from(Literal::string(&tt.to_string())))\n-                        .parse::<super::TokenStream>()\n-                        .unwrap()\n-                        .into_iter();\n-                    if let (Some(super::TokenTree::Literal(mut lit)), None) =\n-                        (iter.next(), iter.next())\n-                    {\n-                        lit.set_span((@ quote_span(proc_macro_crate.clone(), tt.span())));\n-                        lit\n-                    } else {\n-                        unreachable!()\n-                    }\n-                }))\n-            })),))\n-        })\n-        .collect::<TokenStream>();\n-\n-    if after_dollar {\n-        panic!(\"unexpected trailing `$` in `quote!`\");\n-    }\n-\n-    quote!([(@ tokens)].iter().cloned().collect::<super::TokenStream>())\n-}\n-\n-/// Quote a `Span` into a `TokenStream`.\n-/// This is needed to implement a custom quoter.\n-pub fn quote_span(proc_macro_crate: TokenStream, span: Span) -> TokenStream {\n-    let id = span.save_span();\n-    quote!((@ proc_macro_crate ) ::Span::recover_proc_macro_span((@ TokenTree::from(Literal::usize_unsuffixed(id)))))\n-}"}, {"sha": "d8aa1ec429a7dc7ae37f3ae30431f5b1b2534407", "filename": "crates/proc-macro-srv/src/abis/abi_1_64/ra_server.rs", "status": "removed", "additions": 0, "deletions": 791, "changes": 791, "blob_url": "https://github.com/rust-lang/rust/blob/5366009fe47ab06e53b68811873448de52c5cd8f/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fra_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5366009fe47ab06e53b68811873448de52c5cd8f/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fra_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fra_server.rs?ref=5366009fe47ab06e53b68811873448de52c5cd8f", "patch": "@@ -1,791 +0,0 @@\n-//! Rustc proc-macro server implementation with tt\n-//!\n-//! Based on idea from <https://github.com/fedochet/rust-proc-macro-expander>\n-//! The lib-proc-macro server backend is `TokenStream`-agnostic, such that\n-//! we could provide any TokenStream implementation.\n-//! The original idea from fedochet is using proc-macro2 as backend,\n-//! we use tt instead for better integration with RA.\n-//!\n-//! FIXME: No span and source file information is implemented yet\n-\n-use super::proc_macro::bridge::{self, server};\n-\n-use std::collections::HashMap;\n-use std::hash::Hash;\n-use std::ops::Bound;\n-use std::{ascii, vec::IntoIter};\n-\n-type Group = tt::Subtree;\n-type TokenTree = tt::TokenTree;\n-type Punct = tt::Punct;\n-type Spacing = tt::Spacing;\n-type Literal = tt::Literal;\n-type Span = tt::TokenId;\n-\n-#[derive(Debug, Default, Clone)]\n-pub struct TokenStream {\n-    pub token_trees: Vec<TokenTree>,\n-}\n-\n-impl TokenStream {\n-    pub fn new() -> Self {\n-        TokenStream::default()\n-    }\n-\n-    pub fn with_subtree(subtree: tt::Subtree) -> Self {\n-        if subtree.delimiter.is_some() {\n-            TokenStream { token_trees: vec![TokenTree::Subtree(subtree)] }\n-        } else {\n-            TokenStream { token_trees: subtree.token_trees }\n-        }\n-    }\n-\n-    pub fn into_subtree(self) -> tt::Subtree {\n-        tt::Subtree { delimiter: None, token_trees: self.token_trees }\n-    }\n-\n-    pub fn is_empty(&self) -> bool {\n-        self.token_trees.is_empty()\n-    }\n-}\n-\n-/// Creates a token stream containing a single token tree.\n-impl From<TokenTree> for TokenStream {\n-    fn from(tree: TokenTree) -> TokenStream {\n-        TokenStream { token_trees: vec![tree] }\n-    }\n-}\n-\n-/// Collects a number of token trees into a single stream.\n-impl FromIterator<TokenTree> for TokenStream {\n-    fn from_iter<I: IntoIterator<Item = TokenTree>>(trees: I) -> Self {\n-        trees.into_iter().map(TokenStream::from).collect()\n-    }\n-}\n-\n-/// A \"flattening\" operation on token streams, collects token trees\n-/// from multiple token streams into a single stream.\n-impl FromIterator<TokenStream> for TokenStream {\n-    fn from_iter<I: IntoIterator<Item = TokenStream>>(streams: I) -> Self {\n-        let mut builder = TokenStreamBuilder::new();\n-        streams.into_iter().for_each(|stream| builder.push(stream));\n-        builder.build()\n-    }\n-}\n-\n-impl Extend<TokenTree> for TokenStream {\n-    fn extend<I: IntoIterator<Item = TokenTree>>(&mut self, trees: I) {\n-        self.extend(trees.into_iter().map(TokenStream::from));\n-    }\n-}\n-\n-impl Extend<TokenStream> for TokenStream {\n-    fn extend<I: IntoIterator<Item = TokenStream>>(&mut self, streams: I) {\n-        for item in streams {\n-            for tkn in item {\n-                match tkn {\n-                    tt::TokenTree::Subtree(subtree) if subtree.delimiter.is_none() => {\n-                        self.token_trees.extend(subtree.token_trees);\n-                    }\n-                    _ => {\n-                        self.token_trees.push(tkn);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Clone)]\n-pub struct SourceFile {\n-    // FIXME stub\n-}\n-\n-type Level = super::proc_macro::Level;\n-type LineColumn = super::proc_macro::LineColumn;\n-\n-/// A structure representing a diagnostic message and associated children\n-/// messages.\n-#[derive(Clone, Debug)]\n-pub struct Diagnostic {\n-    level: Level,\n-    message: String,\n-    spans: Vec<Span>,\n-    children: Vec<Diagnostic>,\n-}\n-\n-impl Diagnostic {\n-    /// Creates a new diagnostic with the given `level` and `message`.\n-    pub fn new<T: Into<String>>(level: Level, message: T) -> Diagnostic {\n-        Diagnostic { level, message: message.into(), spans: vec![], children: vec![] }\n-    }\n-}\n-\n-// Rustc Server Ident has to be `Copyable`\n-// We use a stub here for bypassing\n-#[derive(Hash, Eq, PartialEq, Copy, Clone)]\n-pub struct IdentId(u32);\n-\n-#[derive(Clone, Hash, Eq, PartialEq)]\n-struct IdentData(tt::Ident);\n-\n-#[derive(Default)]\n-struct IdentInterner {\n-    idents: HashMap<IdentData, u32>,\n-    ident_data: Vec<IdentData>,\n-}\n-\n-impl IdentInterner {\n-    fn intern(&mut self, data: &IdentData) -> u32 {\n-        if let Some(index) = self.idents.get(data) {\n-            return *index;\n-        }\n-\n-        let index = self.idents.len() as u32;\n-        self.ident_data.push(data.clone());\n-        self.idents.insert(data.clone(), index);\n-        index\n-    }\n-\n-    fn get(&self, index: u32) -> &IdentData {\n-        &self.ident_data[index as usize]\n-    }\n-\n-    #[allow(unused)]\n-    fn get_mut(&mut self, index: u32) -> &mut IdentData {\n-        self.ident_data.get_mut(index as usize).expect(\"Should be consistent\")\n-    }\n-}\n-\n-pub struct TokenStreamBuilder {\n-    acc: TokenStream,\n-}\n-\n-/// Public implementation details for the `TokenStream` type, such as iterators.\n-pub mod token_stream {\n-    use std::str::FromStr;\n-\n-    use super::{TokenStream, TokenTree};\n-\n-    /// An iterator over `TokenStream`'s `TokenTree`s.\n-    /// The iteration is \"shallow\", e.g., the iterator doesn't recurse into delimited groups,\n-    /// and returns whole groups as token trees.\n-    impl IntoIterator for TokenStream {\n-        type Item = TokenTree;\n-        type IntoIter = super::IntoIter<TokenTree>;\n-\n-        fn into_iter(self) -> Self::IntoIter {\n-            self.token_trees.into_iter()\n-        }\n-    }\n-\n-    type LexError = String;\n-\n-    /// Attempts to break the string into tokens and parse those tokens into a token stream.\n-    /// May fail for a number of reasons, for example, if the string contains unbalanced delimiters\n-    /// or characters not existing in the language.\n-    /// All tokens in the parsed stream get `Span::call_site()` spans.\n-    ///\n-    /// NOTE: some errors may cause panics instead of returning `LexError`. We reserve the right to\n-    /// change these errors into `LexError`s later.\n-    impl FromStr for TokenStream {\n-        type Err = LexError;\n-\n-        fn from_str(src: &str) -> Result<TokenStream, LexError> {\n-            let (subtree, _token_map) =\n-                mbe::parse_to_token_tree(src).ok_or(\"Failed to parse from mbe\")?;\n-\n-            let subtree = subtree_replace_token_ids_with_unspecified(subtree);\n-            Ok(TokenStream::with_subtree(subtree))\n-        }\n-    }\n-\n-    impl ToString for TokenStream {\n-        fn to_string(&self) -> String {\n-            tt::pretty(&self.token_trees)\n-        }\n-    }\n-\n-    fn subtree_replace_token_ids_with_unspecified(subtree: tt::Subtree) -> tt::Subtree {\n-        tt::Subtree {\n-            delimiter: subtree\n-                .delimiter\n-                .map(|d| tt::Delimiter { id: tt::TokenId::unspecified(), ..d }),\n-            token_trees: subtree\n-                .token_trees\n-                .into_iter()\n-                .map(token_tree_replace_token_ids_with_unspecified)\n-                .collect(),\n-        }\n-    }\n-\n-    fn token_tree_replace_token_ids_with_unspecified(tt: tt::TokenTree) -> tt::TokenTree {\n-        match tt {\n-            tt::TokenTree::Leaf(leaf) => {\n-                tt::TokenTree::Leaf(leaf_replace_token_ids_with_unspecified(leaf))\n-            }\n-            tt::TokenTree::Subtree(subtree) => {\n-                tt::TokenTree::Subtree(subtree_replace_token_ids_with_unspecified(subtree))\n-            }\n-        }\n-    }\n-\n-    fn leaf_replace_token_ids_with_unspecified(leaf: tt::Leaf) -> tt::Leaf {\n-        match leaf {\n-            tt::Leaf::Literal(lit) => {\n-                tt::Leaf::Literal(tt::Literal { id: tt::TokenId::unspecified(), ..lit })\n-            }\n-            tt::Leaf::Punct(punct) => {\n-                tt::Leaf::Punct(tt::Punct { id: tt::TokenId::unspecified(), ..punct })\n-            }\n-            tt::Leaf::Ident(ident) => {\n-                tt::Leaf::Ident(tt::Ident { id: tt::TokenId::unspecified(), ..ident })\n-            }\n-        }\n-    }\n-}\n-\n-impl TokenStreamBuilder {\n-    fn new() -> TokenStreamBuilder {\n-        TokenStreamBuilder { acc: TokenStream::new() }\n-    }\n-\n-    fn push(&mut self, stream: TokenStream) {\n-        self.acc.extend(stream.into_iter())\n-    }\n-\n-    fn build(self) -> TokenStream {\n-        self.acc\n-    }\n-}\n-\n-pub struct FreeFunctions;\n-\n-#[derive(Clone)]\n-pub struct TokenStreamIter {\n-    trees: IntoIter<TokenTree>,\n-}\n-\n-#[derive(Default)]\n-pub struct RustAnalyzer {\n-    ident_interner: IdentInterner,\n-    // FIXME: store span information here.\n-}\n-\n-impl server::Types for RustAnalyzer {\n-    type FreeFunctions = FreeFunctions;\n-    type TokenStream = TokenStream;\n-    type Ident = IdentId;\n-    type Literal = Literal;\n-    type SourceFile = SourceFile;\n-    type Diagnostic = Diagnostic;\n-    type Span = Span;\n-    type MultiSpan = Vec<Span>;\n-}\n-\n-impl server::FreeFunctions for RustAnalyzer {\n-    fn track_env_var(&mut self, _var: &str, _value: Option<&str>) {\n-        // FIXME: track env var accesses\n-        // https://github.com/rust-lang/rust/pull/71858\n-    }\n-    fn track_path(&mut self, _path: &str) {}\n-}\n-\n-impl server::TokenStream for RustAnalyzer {\n-    fn is_empty(&mut self, stream: &Self::TokenStream) -> bool {\n-        stream.is_empty()\n-    }\n-    fn from_str(&mut self, src: &str) -> Self::TokenStream {\n-        use std::str::FromStr;\n-\n-        Self::TokenStream::from_str(src).expect(\"cannot parse string\")\n-    }\n-    fn to_string(&mut self, stream: &Self::TokenStream) -> String {\n-        stream.to_string()\n-    }\n-    fn from_token_tree(\n-        &mut self,\n-        tree: bridge::TokenTree<Self::TokenStream, Self::Span, Self::Ident, Self::Literal>,\n-    ) -> Self::TokenStream {\n-        match tree {\n-            bridge::TokenTree::Group(group) => {\n-                let group = Group {\n-                    delimiter: delim_to_internal(group.delimiter),\n-                    token_trees: match group.stream {\n-                        Some(stream) => stream.into_iter().collect(),\n-                        None => Vec::new(),\n-                    },\n-                };\n-                let tree = TokenTree::from(group);\n-                Self::TokenStream::from_iter(vec![tree])\n-            }\n-\n-            bridge::TokenTree::Ident(IdentId(index)) => {\n-                let IdentData(ident) = self.ident_interner.get(index).clone();\n-                let ident: tt::Ident = ident;\n-                let leaf = tt::Leaf::from(ident);\n-                let tree = TokenTree::from(leaf);\n-                Self::TokenStream::from_iter(vec![tree])\n-            }\n-\n-            bridge::TokenTree::Literal(literal) => {\n-                let leaf = tt::Leaf::from(literal);\n-                let tree = TokenTree::from(leaf);\n-                Self::TokenStream::from_iter(vec![tree])\n-            }\n-\n-            bridge::TokenTree::Punct(p) => {\n-                let punct = tt::Punct {\n-                    char: p.ch as char,\n-                    spacing: if p.joint { Spacing::Joint } else { Spacing::Alone },\n-                    id: p.span,\n-                };\n-                let leaf = tt::Leaf::from(punct);\n-                let tree = TokenTree::from(leaf);\n-                Self::TokenStream::from_iter(vec![tree])\n-            }\n-        }\n-    }\n-\n-    fn expand_expr(&mut self, self_: &Self::TokenStream) -> Result<Self::TokenStream, ()> {\n-        Ok(self_.clone())\n-    }\n-\n-    fn concat_trees(\n-        &mut self,\n-        base: Option<Self::TokenStream>,\n-        trees: Vec<bridge::TokenTree<Self::TokenStream, Self::Span, Self::Ident, Self::Literal>>,\n-    ) -> Self::TokenStream {\n-        let mut builder = TokenStreamBuilder::new();\n-        if let Some(base) = base {\n-            builder.push(base);\n-        }\n-        for tree in trees {\n-            builder.push(self.from_token_tree(tree));\n-        }\n-        builder.build()\n-    }\n-\n-    fn concat_streams(\n-        &mut self,\n-        base: Option<Self::TokenStream>,\n-        streams: Vec<Self::TokenStream>,\n-    ) -> Self::TokenStream {\n-        let mut builder = TokenStreamBuilder::new();\n-        if let Some(base) = base {\n-            builder.push(base);\n-        }\n-        for stream in streams {\n-            builder.push(stream);\n-        }\n-        builder.build()\n-    }\n-\n-    fn into_trees(\n-        &mut self,\n-        stream: Self::TokenStream,\n-    ) -> Vec<bridge::TokenTree<Self::TokenStream, Self::Span, Self::Ident, Self::Literal>> {\n-        stream\n-            .into_iter()\n-            .map(|tree| match tree {\n-                tt::TokenTree::Leaf(tt::Leaf::Ident(ident)) => {\n-                    bridge::TokenTree::Ident(IdentId(self.ident_interner.intern(&IdentData(ident))))\n-                }\n-                tt::TokenTree::Leaf(tt::Leaf::Literal(lit)) => bridge::TokenTree::Literal(lit),\n-                tt::TokenTree::Leaf(tt::Leaf::Punct(punct)) => {\n-                    bridge::TokenTree::Punct(bridge::Punct {\n-                        ch: punct.char as u8,\n-                        joint: punct.spacing == Spacing::Joint,\n-                        span: punct.id,\n-                    })\n-                }\n-                tt::TokenTree::Subtree(subtree) => bridge::TokenTree::Group(bridge::Group {\n-                    delimiter: delim_to_external(subtree.delimiter),\n-                    stream: if subtree.token_trees.is_empty() {\n-                        None\n-                    } else {\n-                        Some(subtree.token_trees.into_iter().collect())\n-                    },\n-                    span: bridge::DelimSpan::from_single(\n-                        subtree.delimiter.map_or(Span::unspecified(), |del| del.id),\n-                    ),\n-                }),\n-            })\n-            .collect()\n-    }\n-}\n-\n-fn delim_to_internal(d: bridge::Delimiter) -> Option<tt::Delimiter> {\n-    let kind = match d {\n-        bridge::Delimiter::Parenthesis => tt::DelimiterKind::Parenthesis,\n-        bridge::Delimiter::Brace => tt::DelimiterKind::Brace,\n-        bridge::Delimiter::Bracket => tt::DelimiterKind::Bracket,\n-        bridge::Delimiter::None => return None,\n-    };\n-    Some(tt::Delimiter { id: tt::TokenId::unspecified(), kind })\n-}\n-\n-fn delim_to_external(d: Option<tt::Delimiter>) -> bridge::Delimiter {\n-    match d.map(|it| it.kind) {\n-        Some(tt::DelimiterKind::Parenthesis) => bridge::Delimiter::Parenthesis,\n-        Some(tt::DelimiterKind::Brace) => bridge::Delimiter::Brace,\n-        Some(tt::DelimiterKind::Bracket) => bridge::Delimiter::Bracket,\n-        None => bridge::Delimiter::None,\n-    }\n-}\n-\n-fn spacing_to_internal(spacing: bridge::Spacing) -> Spacing {\n-    match spacing {\n-        bridge::Spacing::Alone => Spacing::Alone,\n-        bridge::Spacing::Joint => Spacing::Joint,\n-    }\n-}\n-\n-fn spacing_to_external(spacing: Spacing) -> bridge::Spacing {\n-    match spacing {\n-        Spacing::Alone => bridge::Spacing::Alone,\n-        Spacing::Joint => bridge::Spacing::Joint,\n-    }\n-}\n-\n-impl server::Ident for RustAnalyzer {\n-    fn new(&mut self, string: &str, span: Self::Span, _is_raw: bool) -> Self::Ident {\n-        IdentId(self.ident_interner.intern(&IdentData(tt::Ident { text: string.into(), id: span })))\n-    }\n-\n-    fn span(&mut self, ident: Self::Ident) -> Self::Span {\n-        self.ident_interner.get(ident.0).0.id\n-    }\n-    fn with_span(&mut self, ident: Self::Ident, span: Self::Span) -> Self::Ident {\n-        let data = self.ident_interner.get(ident.0);\n-        let new = IdentData(tt::Ident { id: span, ..data.0.clone() });\n-        IdentId(self.ident_interner.intern(&new))\n-    }\n-}\n-\n-impl server::Literal for RustAnalyzer {\n-    fn debug_kind(&mut self, _literal: &Self::Literal) -> String {\n-        // r-a: debug_kind and suffix are unsupported; corresponding client code has been changed to not call these.\n-        // They must still be present to be ABI-compatible and work with upstream proc_macro.\n-        \"\".to_owned()\n-    }\n-    fn from_str(&mut self, s: &str) -> Result<Self::Literal, ()> {\n-        Ok(Literal { text: s.into(), id: tt::TokenId::unspecified() })\n-    }\n-    fn symbol(&mut self, literal: &Self::Literal) -> String {\n-        literal.text.to_string()\n-    }\n-    fn suffix(&mut self, _literal: &Self::Literal) -> Option<String> {\n-        None\n-    }\n-\n-    fn to_string(&mut self, literal: &Self::Literal) -> String {\n-        literal.to_string()\n-    }\n-\n-    fn integer(&mut self, n: &str) -> Self::Literal {\n-        let n = match n.parse::<i128>() {\n-            Ok(n) => n.to_string(),\n-            Err(_) => n.parse::<u128>().unwrap().to_string(),\n-        };\n-        Literal { text: n.into(), id: tt::TokenId::unspecified() }\n-    }\n-\n-    fn typed_integer(&mut self, n: &str, kind: &str) -> Self::Literal {\n-        macro_rules! def_suffixed_integer {\n-            ($kind:ident, $($ty:ty),*) => {\n-                match $kind {\n-                    $(\n-                        stringify!($ty) => {\n-                            let n: $ty = n.parse().unwrap();\n-                            format!(concat!(\"{}\", stringify!($ty)), n)\n-                        }\n-                    )*\n-                    _ => unimplemented!(\"unknown args for typed_integer: n {}, kind {}\", n, $kind),\n-                }\n-            }\n-        }\n-\n-        let text = def_suffixed_integer! {kind, u8, u16, u32, u64, u128, usize, i8, i16, i32, i64, i128, isize};\n-\n-        Literal { text: text.into(), id: tt::TokenId::unspecified() }\n-    }\n-\n-    fn float(&mut self, n: &str) -> Self::Literal {\n-        let n: f64 = n.parse().unwrap();\n-        let mut text = f64::to_string(&n);\n-        if !text.contains('.') {\n-            text += \".0\"\n-        }\n-        Literal { text: text.into(), id: tt::TokenId::unspecified() }\n-    }\n-\n-    fn f32(&mut self, n: &str) -> Self::Literal {\n-        let n: f32 = n.parse().unwrap();\n-        let text = format!(\"{}f32\", n);\n-        Literal { text: text.into(), id: tt::TokenId::unspecified() }\n-    }\n-\n-    fn f64(&mut self, n: &str) -> Self::Literal {\n-        let n: f64 = n.parse().unwrap();\n-        let text = format!(\"{}f64\", n);\n-        Literal { text: text.into(), id: tt::TokenId::unspecified() }\n-    }\n-\n-    fn string(&mut self, string: &str) -> Self::Literal {\n-        let mut escaped = String::new();\n-        for ch in string.chars() {\n-            escaped.extend(ch.escape_debug());\n-        }\n-        Literal { text: format!(\"\\\"{}\\\"\", escaped).into(), id: tt::TokenId::unspecified() }\n-    }\n-\n-    fn character(&mut self, ch: char) -> Self::Literal {\n-        Literal { text: format!(\"'{}'\", ch).into(), id: tt::TokenId::unspecified() }\n-    }\n-\n-    fn byte_string(&mut self, bytes: &[u8]) -> Self::Literal {\n-        let string = bytes\n-            .iter()\n-            .cloned()\n-            .flat_map(ascii::escape_default)\n-            .map(Into::<char>::into)\n-            .collect::<String>();\n-\n-        Literal { text: format!(\"b\\\"{}\\\"\", string).into(), id: tt::TokenId::unspecified() }\n-    }\n-\n-    fn span(&mut self, literal: &Self::Literal) -> Self::Span {\n-        literal.id\n-    }\n-\n-    fn set_span(&mut self, literal: &mut Self::Literal, span: Self::Span) {\n-        literal.id = span;\n-    }\n-\n-    fn subspan(\n-        &mut self,\n-        _literal: &Self::Literal,\n-        _start: Bound<usize>,\n-        _end: Bound<usize>,\n-    ) -> Option<Self::Span> {\n-        // FIXME handle span\n-        None\n-    }\n-}\n-\n-impl server::SourceFile for RustAnalyzer {\n-    // FIXME these are all stubs\n-    fn eq(&mut self, _file1: &Self::SourceFile, _file2: &Self::SourceFile) -> bool {\n-        true\n-    }\n-    fn path(&mut self, _file: &Self::SourceFile) -> String {\n-        String::new()\n-    }\n-    fn is_real(&mut self, _file: &Self::SourceFile) -> bool {\n-        true\n-    }\n-}\n-\n-impl server::Diagnostic for RustAnalyzer {\n-    fn new(&mut self, level: Level, msg: &str, spans: Self::MultiSpan) -> Self::Diagnostic {\n-        let mut diag = Diagnostic::new(level, msg);\n-        diag.spans = spans;\n-        diag\n-    }\n-\n-    fn sub(\n-        &mut self,\n-        _diag: &mut Self::Diagnostic,\n-        _level: Level,\n-        _msg: &str,\n-        _spans: Self::MultiSpan,\n-    ) {\n-        // FIXME handle diagnostic\n-        //\n-    }\n-\n-    fn emit(&mut self, _diag: Self::Diagnostic) {\n-        // FIXME handle diagnostic\n-        // diag.emit()\n-    }\n-}\n-\n-impl server::Span for RustAnalyzer {\n-    fn debug(&mut self, span: Self::Span) -> String {\n-        format!(\"{:?}\", span.0)\n-    }\n-    fn source_file(&mut self, _span: Self::Span) -> Self::SourceFile {\n-        SourceFile {}\n-    }\n-    fn save_span(&mut self, _span: Self::Span) -> usize {\n-        // FIXME stub\n-        0\n-    }\n-    fn recover_proc_macro_span(&mut self, _id: usize) -> Self::Span {\n-        // FIXME stub\n-        tt::TokenId::unspecified()\n-    }\n-    /// Recent feature, not yet in the proc_macro\n-    ///\n-    /// See PR:\n-    /// https://github.com/rust-lang/rust/pull/55780\n-    fn source_text(&mut self, _span: Self::Span) -> Option<String> {\n-        None\n-    }\n-\n-    fn parent(&mut self, _span: Self::Span) -> Option<Self::Span> {\n-        // FIXME handle span\n-        None\n-    }\n-    fn source(&mut self, span: Self::Span) -> Self::Span {\n-        // FIXME handle span\n-        span\n-    }\n-    fn start(&mut self, _span: Self::Span) -> LineColumn {\n-        // FIXME handle span\n-        LineColumn { line: 0, column: 0 }\n-    }\n-    fn end(&mut self, _span: Self::Span) -> LineColumn {\n-        // FIXME handle span\n-        LineColumn { line: 0, column: 0 }\n-    }\n-    fn join(&mut self, first: Self::Span, _second: Self::Span) -> Option<Self::Span> {\n-        // Just return the first span again, because some macros will unwrap the result.\n-        Some(first)\n-    }\n-    fn resolved_at(&mut self, _span: Self::Span, _at: Self::Span) -> Self::Span {\n-        // FIXME handle span\n-        tt::TokenId::unspecified()\n-    }\n-\n-    fn after(&mut self, _self_: Self::Span) -> Self::Span {\n-        tt::TokenId::unspecified()\n-    }\n-\n-    fn before(&mut self, _self_: Self::Span) -> Self::Span {\n-        tt::TokenId::unspecified()\n-    }\n-}\n-\n-impl server::MultiSpan for RustAnalyzer {\n-    fn new(&mut self) -> Self::MultiSpan {\n-        // FIXME handle span\n-        vec![]\n-    }\n-\n-    fn push(&mut self, other: &mut Self::MultiSpan, span: Self::Span) {\n-        //TODP\n-        other.push(span)\n-    }\n-}\n-\n-impl server::Server for RustAnalyzer {\n-    fn globals(&mut self) -> bridge::ExpnGlobals<Self::Span> {\n-        bridge::ExpnGlobals {\n-            def_site: Span::unspecified(),\n-            call_site: Span::unspecified(),\n-            mixed_site: Span::unspecified(),\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::super::proc_macro::bridge::server::Literal;\n-    use super::*;\n-\n-    #[test]\n-    fn test_ra_server_literals() {\n-        let mut srv = RustAnalyzer { ident_interner: IdentInterner::default() };\n-        assert_eq!(srv.integer(\"1234\").text, \"1234\");\n-\n-        assert_eq!(srv.typed_integer(\"12\", \"u8\").text, \"12u8\");\n-        assert_eq!(srv.typed_integer(\"255\", \"u16\").text, \"255u16\");\n-        assert_eq!(srv.typed_integer(\"1234\", \"u32\").text, \"1234u32\");\n-        assert_eq!(srv.typed_integer(\"15846685\", \"u64\").text, \"15846685u64\");\n-        assert_eq!(srv.typed_integer(\"15846685258\", \"u128\").text, \"15846685258u128\");\n-        assert_eq!(srv.typed_integer(\"156788984\", \"usize\").text, \"156788984usize\");\n-        assert_eq!(srv.typed_integer(\"127\", \"i8\").text, \"127i8\");\n-        assert_eq!(srv.typed_integer(\"255\", \"i16\").text, \"255i16\");\n-        assert_eq!(srv.typed_integer(\"1234\", \"i32\").text, \"1234i32\");\n-        assert_eq!(srv.typed_integer(\"15846685\", \"i64\").text, \"15846685i64\");\n-        assert_eq!(srv.typed_integer(\"15846685258\", \"i128\").text, \"15846685258i128\");\n-        assert_eq!(srv.float(\"0\").text, \"0.0\");\n-        assert_eq!(srv.float(\"15684.5867\").text, \"15684.5867\");\n-        assert_eq!(srv.f32(\"15684.58\").text, \"15684.58f32\");\n-        assert_eq!(srv.f64(\"15684.58\").text, \"15684.58f64\");\n-\n-        assert_eq!(srv.string(\"hello_world\").text, \"\\\"hello_world\\\"\");\n-        assert_eq!(srv.character('c').text, \"'c'\");\n-        assert_eq!(srv.byte_string(b\"1234586\\x88\").text, \"b\\\"1234586\\\\x88\\\"\");\n-\n-        // u128::max\n-        assert_eq!(\n-            srv.integer(\"340282366920938463463374607431768211455\").text,\n-            \"340282366920938463463374607431768211455\"\n-        );\n-        // i128::min\n-        assert_eq!(\n-            srv.integer(\"-170141183460469231731687303715884105728\").text,\n-            \"-170141183460469231731687303715884105728\"\n-        );\n-    }\n-\n-    #[test]\n-    fn test_ra_server_to_string() {\n-        let s = TokenStream {\n-            token_trees: vec![\n-                tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n-                    text: \"struct\".into(),\n-                    id: tt::TokenId::unspecified(),\n-                })),\n-                tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n-                    text: \"T\".into(),\n-                    id: tt::TokenId::unspecified(),\n-                })),\n-                tt::TokenTree::Subtree(tt::Subtree {\n-                    delimiter: Some(tt::Delimiter {\n-                        id: tt::TokenId::unspecified(),\n-                        kind: tt::DelimiterKind::Brace,\n-                    }),\n-                    token_trees: vec![],\n-                }),\n-            ],\n-        };\n-\n-        assert_eq!(s.to_string(), \"struct T {}\");\n-    }\n-\n-    #[test]\n-    fn test_ra_server_from_str() {\n-        use std::str::FromStr;\n-        let subtree_paren_a = tt::TokenTree::Subtree(tt::Subtree {\n-            delimiter: Some(tt::Delimiter {\n-                id: tt::TokenId::unspecified(),\n-                kind: tt::DelimiterKind::Parenthesis,\n-            }),\n-            token_trees: vec![tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n-                text: \"a\".into(),\n-                id: tt::TokenId::unspecified(),\n-            }))],\n-        });\n-\n-        let t1 = TokenStream::from_str(\"(a)\").unwrap();\n-        assert_eq!(t1.token_trees.len(), 1);\n-        assert_eq!(t1.token_trees[0], subtree_paren_a);\n-\n-        let t2 = TokenStream::from_str(\"(a);\").unwrap();\n-        assert_eq!(t2.token_trees.len(), 2);\n-        assert_eq!(t2.token_trees[0], subtree_paren_a);\n-\n-        let underscore = TokenStream::from_str(\"_\").unwrap();\n-        assert_eq!(\n-            underscore.token_trees[0],\n-            tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n-                text: \"_\".into(),\n-                id: tt::TokenId::unspecified(),\n-            }))\n-        );\n-    }\n-}"}, {"sha": "f7d3a30919e1c786c50c4ad0494f3f0c546af4aa", "filename": "crates/proc-macro-srv/src/abis/mod.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f4f70c0e0da9783eb0b935e0c8698a9505c7b45e/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4f70c0e0da9783eb0b935e0c8698a9505c7b45e/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs?ref=f4f70c0e0da9783eb0b935e0c8698a9505c7b45e", "patch": "@@ -25,7 +25,6 @@\n \n mod abi_1_58;\n mod abi_1_63;\n-mod abi_1_64;\n #[cfg(feature = \"sysroot-abi\")]\n mod abi_sysroot;\n \n@@ -34,12 +33,11 @@ include!(concat!(env!(\"OUT_DIR\"), \"/rustc_version.rs\"));\n \n // Used by `test/utils.rs`\n #[cfg(test)]\n-pub(crate) use abi_1_64::TokenStream as TestTokenStream;\n+pub(crate) use abi_1_63::TokenStream as TestTokenStream;\n \n use super::dylib::LoadProcMacroDylibError;\n pub(crate) use abi_1_58::Abi as Abi_1_58;\n pub(crate) use abi_1_63::Abi as Abi_1_63;\n-pub(crate) use abi_1_64::Abi as Abi_1_64;\n #[cfg(feature = \"sysroot-abi\")]\n pub(crate) use abi_sysroot::Abi as Abi_Sysroot;\n use libloading::Library;\n@@ -58,7 +56,6 @@ impl PanicMessage {\n pub(crate) enum Abi {\n     Abi1_58(Abi_1_58),\n     Abi1_63(Abi_1_63),\n-    Abi1_64(Abi_1_64),\n     #[cfg(feature = \"sysroot-abi\")]\n     AbiSysroot(Abi_Sysroot),\n }\n@@ -120,10 +117,6 @@ impl Abi {\n                 let inner = unsafe { Abi_1_63::from_lib(lib, symbol_name) }?;\n                 Ok(Abi::Abi1_63(inner))\n             }\n-            (1, 64..) => {\n-                let inner = unsafe { Abi_1_64::from_lib(lib, symbol_name) }?;\n-                Ok(Abi::Abi1_64(inner))\n-            }\n             _ => Err(LoadProcMacroDylibError::UnsupportedABI),\n         }\n     }\n@@ -137,7 +130,6 @@ impl Abi {\n         match self {\n             Self::Abi1_58(abi) => abi.expand(macro_name, macro_body, attributes),\n             Self::Abi1_63(abi) => abi.expand(macro_name, macro_body, attributes),\n-            Self::Abi1_64(abi) => abi.expand(macro_name, macro_body, attributes),\n             #[cfg(feature = \"sysroot-abi\")]\n             Self::AbiSysroot(abi) => abi.expand(macro_name, macro_body, attributes),\n         }\n@@ -147,7 +139,6 @@ impl Abi {\n         match self {\n             Self::Abi1_58(abi) => abi.list_macros(),\n             Self::Abi1_63(abi) => abi.list_macros(),\n-            Self::Abi1_64(abi) => abi.list_macros(),\n             #[cfg(feature = \"sysroot-abi\")]\n             Self::AbiSysroot(abi) => abi.list_macros(),\n         }"}]}