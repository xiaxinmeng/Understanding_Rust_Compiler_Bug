{"sha": "f7bc441fd342783ad42b8a9fbb2a1595e80044ad", "node_id": "C_kwDOAAsO6NoAKGY3YmM0NDFmZDM0Mjc4M2FkNDJiOGE5ZmJiMmExNTk1ZTgwMDQ0YWQ", "commit": {"author": {"name": "carbotaniuman", "email": "41451839+carbotaniuman@users.noreply.github.com", "date": "2022-05-22T20:22:05Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-05-23T07:07:31Z"}, "message": "Initial work on permissive provenance", "tree": {"sha": "3c04a4e18d703184b438193bc5323116c576c63f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c04a4e18d703184b438193bc5323116c576c63f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7bc441fd342783ad42b8a9fbb2a1595e80044ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7bc441fd342783ad42b8a9fbb2a1595e80044ad", "html_url": "https://github.com/rust-lang/rust/commit/f7bc441fd342783ad42b8a9fbb2a1595e80044ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7bc441fd342783ad42b8a9fbb2a1595e80044ad/comments", "author": {"login": "carbotaniuman", "id": 41451839, "node_id": "MDQ6VXNlcjQxNDUxODM5", "avatar_url": "https://avatars.githubusercontent.com/u/41451839?v=4", "gravatar_id": "", "url": "https://api.github.com/users/carbotaniuman", "html_url": "https://github.com/carbotaniuman", "followers_url": "https://api.github.com/users/carbotaniuman/followers", "following_url": "https://api.github.com/users/carbotaniuman/following{/other_user}", "gists_url": "https://api.github.com/users/carbotaniuman/gists{/gist_id}", "starred_url": "https://api.github.com/users/carbotaniuman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/carbotaniuman/subscriptions", "organizations_url": "https://api.github.com/users/carbotaniuman/orgs", "repos_url": "https://api.github.com/users/carbotaniuman/repos", "events_url": "https://api.github.com/users/carbotaniuman/events{/privacy}", "received_events_url": "https://api.github.com/users/carbotaniuman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d60aa4771b98a32b12ba5506dfaba6b368efe9e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/d60aa4771b98a32b12ba5506dfaba6b368efe9e8", "html_url": "https://github.com/rust-lang/rust/commit/d60aa4771b98a32b12ba5506dfaba6b368efe9e8"}], "stats": {"total": 323, "additions": 275, "deletions": 48}, "files": [{"sha": "784f0da8a30dd2bbf5aa4192a1b942e624df47f7", "filename": "src/bin/miri.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f7bc441fd342783ad42b8a9fbb2a1595e80044ad/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bc441fd342783ad42b8a9fbb2a1595e80044ad/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=f7bc441fd342783ad42b8a9fbb2a1595e80044ad", "patch": "@@ -30,7 +30,7 @@ use rustc_middle::{\n };\n use rustc_session::{config::ErrorOutputType, search_paths::PathKind, CtfeBacktrace};\n \n-use miri::BacktraceStyle;\n+use miri::{BacktraceStyle, ProvenanceMode};\n \n struct MiriCompilerCalls {\n     miri_config: miri::MiriConfig,\n@@ -384,10 +384,14 @@ fn main() {\n                     miri_config.tag_raw = true;\n                 }\n                 \"-Zmiri-strict-provenance\" => {\n-                    miri_config.strict_provenance = true;\n+                    miri_config.provenance_mode = ProvenanceMode::Strict;\n                     miri_config.tag_raw = true;\n                     miri_config.check_number_validity = true;\n                 }\n+                \"-Zmiri-permissive-provenance\" => {\n+                    miri_config.provenance_mode = ProvenanceMode::Permissive;\n+                    miri_config.tag_raw = true;\n+                }\n                 \"-Zmiri-mute-stdout-stderr\" => {\n                     miri_config.mute_stdout_stderr = true;\n                 }"}, {"sha": "430ff06cf15adb6d8b80da162db6b6fb21e6f57c", "filename": "src/eval.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f7bc441fd342783ad42b8a9fbb2a1595e80044ad/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bc441fd342783ad42b8a9fbb2a1595e80044ad/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=f7bc441fd342783ad42b8a9fbb2a1595e80044ad", "patch": "@@ -113,9 +113,8 @@ pub struct MiriConfig {\n     pub panic_on_unsupported: bool,\n     /// Which style to use for printing backtraces.\n     pub backtrace_style: BacktraceStyle,\n-    /// Whether to enforce \"strict provenance\" rules. Enabling this means int2ptr casts return\n-    /// pointers with an invalid provenance, i.e., not valid for any memory access.\n-    pub strict_provenance: bool,\n+    /// Which provenance to use for int2ptr casts\n+    pub provenance_mode: ProvenanceMode,\n     /// Whether to ignore any output by the program. This is helpful when debugging miri\n     /// as its messages don't get intermingled with the program messages.\n     pub mute_stdout_stderr: bool,\n@@ -144,7 +143,7 @@ impl Default for MiriConfig {\n             measureme_out: None,\n             panic_on_unsupported: false,\n             backtrace_style: BacktraceStyle::Short,\n-            strict_provenance: false,\n+            provenance_mode: ProvenanceMode::Legacy,\n             mute_stdout_stderr: false,\n         }\n     }"}, {"sha": "08b2fa98a2300eff37acc0fcacf73b61d688bd00", "filename": "src/helpers.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7bc441fd342783ad42b8a9fbb2a1595e80044ad/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bc441fd342783ad42b8a9fbb2a1595e80044ad/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=f7bc441fd342783ad42b8a9fbb2a1595e80044ad", "patch": "@@ -786,8 +786,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn mark_immutable(&mut self, mplace: &MemPlace<Tag>) {\n         let this = self.eval_context_mut();\n         // This got just allocated, so there definitely is a pointer here.\n-        this.alloc_mark_immutable(mplace.ptr.into_pointer_or_addr().unwrap().provenance.alloc_id)\n-            .unwrap();\n+        let provenance = mplace.ptr.into_pointer_or_addr().unwrap().provenance;\n+        this.alloc_mark_immutable(provenance.get_alloc_id().unwrap()).unwrap();\n     }\n \n     fn item_link_name(&self, def_id: DefId) -> Symbol {"}, {"sha": "8395cdc2733d2829c7ba554fa03c405b5058792f", "filename": "src/intptrcast.rs", "status": "modified", "additions": 103, "deletions": 20, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/f7bc441fd342783ad42b8a9fbb2a1595e80044ad/src%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bc441fd342783ad42b8a9fbb2a1595e80044ad/src%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintptrcast.rs?ref=f7bc441fd342783ad42b8a9fbb2a1595e80044ad", "patch": "@@ -4,11 +4,25 @@ use std::collections::hash_map::Entry;\n use log::trace;\n use rand::Rng;\n \n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_target::abi::{HasDataLayout, Size};\n \n use crate::*;\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum ProvenanceMode {\n+    /// Int2ptr casts return pointers with \"wildcard\" provenance\n+    /// that basically matches that of all exposed pointers\n+    /// (and SB tags, if enabled).\n+    Permissive,\n+    /// Int2ptr casts return pointers with an invalid provenance,\n+    /// i.e., not valid for any memory access.\n+    Strict,\n+    /// Int2ptr casts determine the allocation they point to at cast time.\n+    /// All allocations are considered exposed.\n+    Legacy,\n+}\n+\n pub type GlobalState = RefCell<GlobalStateInner>;\n \n #[derive(Clone, Debug)]\n@@ -21,35 +35,37 @@ pub struct GlobalStateInner {\n     /// they do not have an `AllocExtra`.\n     /// This is the inverse of `int_to_ptr_map`.\n     base_addr: FxHashMap<AllocId, u64>,\n+    /// Whether an allocation has been exposed or not. This cannot be put\n+    /// into `AllocExtra` for the same reason as `base_addr`.\n+    exposed: FxHashSet<AllocId>,\n     /// This is used as a memory address when a new pointer is casted to an integer. It\n     /// is always larger than any address that was previously made part of a block.\n     next_base_addr: u64,\n-    /// Whether to enforce \"strict provenance\" rules. Enabling this means int2ptr casts return\n-    /// pointers with an invalid provenance, i.e., not valid for any memory access.\n-    strict_provenance: bool,\n+    /// The provenance to use for int2ptr casts\n+    provenance_mode: ProvenanceMode,\n }\n \n impl GlobalStateInner {\n     pub fn new(config: &MiriConfig) -> Self {\n         GlobalStateInner {\n             int_to_ptr_map: Vec::default(),\n             base_addr: FxHashMap::default(),\n+            exposed: FxHashSet::default(),\n             next_base_addr: STACK_ADDR,\n-            strict_provenance: config.strict_provenance,\n+            provenance_mode: config.provenance_mode,\n         }\n     }\n }\n \n impl<'mir, 'tcx> GlobalStateInner {\n-    pub fn ptr_from_addr(addr: u64, ecx: &MiriEvalContext<'mir, 'tcx>) -> Pointer<Option<Tag>> {\n-        trace!(\"Casting 0x{:x} to a pointer\", addr);\n+    // Returns the exposed `AllocId` that corresponds to the specified addr,\n+    // or `None` if the addr is out of bounds\n+    fn alloc_id_from_addr(ecx: &MiriEvalContext<'mir, 'tcx>, addr: u64) -> Option<AllocId> {\n         let global_state = ecx.machine.intptrcast.borrow();\n-\n-        if global_state.strict_provenance {\n-            return Pointer::new(None, Size::from_bytes(addr));\n-        }\n+        assert!(global_state.provenance_mode != ProvenanceMode::Strict);\n \n         let pos = global_state.int_to_ptr_map.binary_search_by_key(&addr, |(addr, _)| *addr);\n+\n         let alloc_id = match pos {\n             Ok(pos) => Some(global_state.int_to_ptr_map[pos].1),\n             Err(0) => None,\n@@ -60,6 +76,7 @@ impl<'mir, 'tcx> GlobalStateInner {\n                 // This never overflows because `addr >= glb`\n                 let offset = addr - glb;\n                 // If the offset exceeds the size of the allocation, don't use this `alloc_id`.\n+\n                 if offset\n                     <= ecx\n                         .get_alloc_size_and_align(alloc_id, AllocCheck::MaybeDead)\n@@ -72,12 +89,65 @@ impl<'mir, 'tcx> GlobalStateInner {\n                     None\n                 }\n             }\n-        };\n-        // Pointers created from integers are untagged.\n-        Pointer::new(\n-            alloc_id.map(|alloc_id| Tag { alloc_id, sb: SbTag::Untagged }),\n-            Size::from_bytes(addr),\n-        )\n+        }?;\n+\n+        // In legacy mode, we consider all allocations exposed.\n+        if global_state.provenance_mode == ProvenanceMode::Legacy\n+            || global_state.exposed.contains(&alloc_id)\n+        {\n+            Some(alloc_id)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn expose_addr(ecx: &MiriEvalContext<'mir, 'tcx>, alloc_id: AllocId) {\n+        trace!(\"Exposing allocation id {:?}\", alloc_id);\n+\n+        let mut global_state = ecx.machine.intptrcast.borrow_mut();\n+        if global_state.provenance_mode == ProvenanceMode::Permissive {\n+            global_state.exposed.insert(alloc_id);\n+        }\n+    }\n+\n+    pub fn ptr_from_addr_transmute(\n+        ecx: &MiriEvalContext<'mir, 'tcx>,\n+        addr: u64,\n+    ) -> Pointer<Option<Tag>> {\n+        trace!(\"Transmuting 0x{:x} to a pointer\", addr);\n+\n+        let global_state = ecx.machine.intptrcast.borrow();\n+\n+        // In legacy mode, we have to support int2ptr transmutes,\n+        // so just pretend they do the same thing as a cast.\n+        if global_state.provenance_mode == ProvenanceMode::Legacy {\n+            Self::ptr_from_addr_cast(ecx, addr)\n+        } else {\n+            Pointer::new(None, Size::from_bytes(addr))\n+        }\n+    }\n+\n+    pub fn ptr_from_addr_cast(\n+        ecx: &MiriEvalContext<'mir, 'tcx>,\n+        addr: u64,\n+    ) -> Pointer<Option<Tag>> {\n+        trace!(\"Casting 0x{:x} to a pointer\", addr);\n+\n+        let global_state = ecx.machine.intptrcast.borrow();\n+\n+        if global_state.provenance_mode == ProvenanceMode::Strict {\n+            Pointer::new(None, Size::from_bytes(addr))\n+        } else if global_state.provenance_mode == ProvenanceMode::Legacy {\n+            let alloc_id = Self::alloc_id_from_addr(ecx, addr);\n+\n+            Pointer::new(\n+                alloc_id\n+                    .map(|alloc_id| Tag::Concrete(ConcreteTag { alloc_id, sb: SbTag::Untagged })),\n+                Size::from_bytes(addr),\n+            )\n+        } else {\n+            Pointer::new(Some(Tag::Wildcard), Size::from_bytes(addr))\n+        }\n     }\n \n     fn alloc_base_addr(ecx: &MiriEvalContext<'mir, 'tcx>, alloc_id: AllocId) -> u64 {\n@@ -136,14 +206,27 @@ impl<'mir, 'tcx> GlobalStateInner {\n         dl.overflowing_offset(base_addr, offset.bytes()).0\n     }\n \n-    pub fn abs_ptr_to_rel(ecx: &MiriEvalContext<'mir, 'tcx>, ptr: Pointer<Tag>) -> Size {\n+    pub fn abs_ptr_to_rel(\n+        ecx: &MiriEvalContext<'mir, 'tcx>,\n+        ptr: Pointer<Tag>,\n+    ) -> Option<(AllocId, Size)> {\n         let (tag, addr) = ptr.into_parts(); // addr is absolute (Tag provenance)\n-        let base_addr = GlobalStateInner::alloc_base_addr(ecx, tag.alloc_id);\n+\n+        let alloc_id = if let Tag::Concrete(concrete) = tag {\n+            concrete.alloc_id\n+        } else {\n+            GlobalStateInner::alloc_id_from_addr(ecx, addr.bytes())?\n+        };\n+\n+        let base_addr = GlobalStateInner::alloc_base_addr(ecx, alloc_id);\n \n         // Wrapping \"addr - base_addr\"\n         let dl = ecx.data_layout();\n         let neg_base_addr = (base_addr as i64).wrapping_neg();\n-        Size::from_bytes(dl.overflowing_signed_offset(addr.bytes(), neg_base_addr).0)\n+        Some((\n+            alloc_id,\n+            Size::from_bytes(dl.overflowing_signed_offset(addr.bytes(), neg_base_addr).0),\n+        ))\n     }\n \n     /// Shifts `addr` to make it aligned with `align` by rounding `addr` to the smallest multiple"}, {"sha": "e571c8a001029a68d280c261b2be2377bcef91a2", "filename": "src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f7bc441fd342783ad42b8a9fbb2a1595e80044ad/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bc441fd342783ad42b8a9fbb2a1595e80044ad/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=f7bc441fd342783ad42b8a9fbb2a1595e80044ad", "patch": "@@ -78,9 +78,10 @@ pub use crate::eval::{\n     create_ecx, eval_entry, AlignmentCheck, BacktraceStyle, IsolatedOp, MiriConfig, RejectOpWith,\n };\n pub use crate::helpers::{CurrentSpan, EvalContextExt as HelpersEvalContextExt};\n+pub use crate::intptrcast::ProvenanceMode;\n pub use crate::machine::{\n-    AllocExtra, Evaluator, FrameData, MiriEvalContext, MiriEvalContextExt, MiriMemoryKind, Tag,\n-    NUM_CPUS, PAGE_SIZE, STACK_ADDR, STACK_SIZE,\n+    AllocExtra, ConcreteTag, Evaluator, FrameData, MiriEvalContext, MiriEvalContextExt,\n+    MiriMemoryKind, Tag, NUM_CPUS, PAGE_SIZE, STACK_ADDR, STACK_SIZE,\n };\n pub use crate::mono_hash_map::MonoHashMap;\n pub use crate::operator::EvalContextExt as OperatorEvalContextExt;"}, {"sha": "12a32d81b5c93f5095dbbfef4a7ca6ae16ec35d9", "filename": "src/machine.rs", "status": "modified", "additions": 53, "deletions": 17, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f7bc441fd342783ad42b8a9fbb2a1595e80044ad/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bc441fd342783ad42b8a9fbb2a1595e80044ad/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=f7bc441fd342783ad42b8a9fbb2a1595e80044ad", "patch": "@@ -125,16 +125,22 @@ impl fmt::Display for MiriMemoryKind {\n \n /// Pointer provenance (tag).\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct Tag {\n+pub enum Tag {\n+    Concrete(ConcreteTag),\n+    Wildcard,\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct ConcreteTag {\n     pub alloc_id: AllocId,\n     /// Stacked Borrows tag.\n     pub sb: SbTag,\n }\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n static_assert_size!(Pointer<Tag>, 24);\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-static_assert_size!(Pointer<Option<Tag>>, 24);\n+// #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+// static_assert_size!(Pointer<Option<Tag>>, 24);\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n static_assert_size!(ScalarMaybeUninit<Tag>, 32);\n \n@@ -148,18 +154,31 @@ impl Provenance for Tag {\n     fn fmt(ptr: &Pointer<Self>, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let (tag, addr) = ptr.into_parts(); // address is absolute\n         write!(f, \"0x{:x}\", addr.bytes())?;\n-        // Forward `alternate` flag to `alloc_id` printing.\n-        if f.alternate() {\n-            write!(f, \"[{:#?}]\", tag.alloc_id)?;\n-        } else {\n-            write!(f, \"[{:?}]\", tag.alloc_id)?;\n+\n+        match tag {\n+            Tag::Concrete(tag) => {\n+                // Forward `alternate` flag to `alloc_id` printing.\n+                if f.alternate() {\n+                    write!(f, \"[{:#?}]\", tag.alloc_id)?;\n+                } else {\n+                    write!(f, \"[{:?}]\", tag.alloc_id)?;\n+                }\n+                // Print Stacked Borrows tag.\n+                write!(f, \"{:?}\", tag.sb)?;\n+            }\n+            Tag::Wildcard => {\n+                write!(f, \"[Wildcard]\")?;\n+            }\n         }\n-        // Print Stacked Borrows tag.\n-        write!(f, \"{:?}\", tag.sb)\n+\n+        Ok(())\n     }\n \n     fn get_alloc_id(self) -> Option<AllocId> {\n-        Some(self.alloc_id)\n+        match self {\n+            Tag::Concrete(concrete) => Some(concrete.alloc_id),\n+            Tag::Wildcard => None,\n+        }\n     }\n }\n \n@@ -611,30 +630,41 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         } else {\n             SbTag::Untagged\n         };\n-        Pointer::new(Tag { alloc_id: ptr.provenance, sb: sb_tag }, Size::from_bytes(absolute_addr))\n+        Pointer::new(\n+            Tag::Concrete(ConcreteTag { alloc_id: ptr.provenance, sb: sb_tag }),\n+            Size::from_bytes(absolute_addr),\n+        )\n     }\n \n     #[inline(always)]\n     fn ptr_from_addr_cast(\n         ecx: &MiriEvalContext<'mir, 'tcx>,\n         addr: u64,\n     ) -> Pointer<Option<Self::PointerTag>> {\n-        intptrcast::GlobalStateInner::ptr_from_addr(addr, ecx)\n+        intptrcast::GlobalStateInner::ptr_from_addr_cast(ecx, addr)\n     }\n \n     #[inline(always)]\n     fn ptr_from_addr_transmute(\n         ecx: &MiriEvalContext<'mir, 'tcx>,\n         addr: u64,\n     ) -> Pointer<Option<Self::PointerTag>> {\n-        Self::ptr_from_addr_cast(ecx, addr)\n+        intptrcast::GlobalStateInner::ptr_from_addr_transmute(ecx, addr)\n     }\n \n     #[inline(always)]\n     fn expose_ptr(\n-        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        _ptr: Pointer<Self::PointerTag>,\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        ptr: Pointer<Self::PointerTag>,\n     ) -> InterpResult<'tcx> {\n+        let tag = ptr.provenance;\n+\n+        if let Tag::Concrete(concrete) = tag {\n+            intptrcast::GlobalStateInner::expose_addr(ecx, concrete.alloc_id);\n+        }\n+\n+        // No need to do anything for wildcard pointers as\n+        // their provenances have already been previously exposed.\n         Ok(())\n     }\n \n@@ -645,7 +675,13 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         ptr: Pointer<Self::PointerTag>,\n     ) -> Option<(AllocId, Size, Self::TagExtra)> {\n         let rel = intptrcast::GlobalStateInner::abs_ptr_to_rel(ecx, ptr);\n-        Some((ptr.provenance.alloc_id, rel, ptr.provenance.sb))\n+\n+        let sb = match ptr.provenance {\n+            Tag::Concrete(ConcreteTag { sb, .. }) => sb,\n+            Tag::Wildcard => SbTag::Untagged,\n+        };\n+\n+        rel.map(|(alloc_id, size)| (alloc_id, size, sb))\n     }\n \n     #[inline(always)]"}, {"sha": "f137b861342a09748e14c9893629148da458a484", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f7bc441fd342783ad42b8a9fbb2a1595e80044ad/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bc441fd342783ad42b8a9fbb2a1595e80044ad/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=f7bc441fd342783ad42b8a9fbb2a1595e80044ad", "patch": "@@ -867,7 +867,16 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.reborrow(&place, size, kind, new_tag, protect)?;\n \n         // Adjust pointer.\n-        let new_place = place.map_provenance(|p| p.map(|t| Tag { sb: new_tag, ..t }));\n+        let new_place = place.map_provenance(|p| {\n+            p.map(|t| {\n+                // TODO: Fix this eventually\n+                if let Tag::Concrete(t) = t {\n+                    Tag::Concrete(ConcreteTag { sb: new_tag, ..t })\n+                } else {\n+                    t\n+                }\n+            })\n+        });\n \n         // Return new pointer.\n         Ok(ImmTy::from_immediate(new_place.to_ref(this), val.layout))"}, {"sha": "2aecb68b8b647d11373c5222bb13e7f4034d3b09", "filename": "tests/compile-fail/ptr_int_unexposed.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f7bc441fd342783ad42b8a9fbb2a1595e80044ad/tests%2Fcompile-fail%2Fptr_int_unexposed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bc441fd342783ad42b8a9fbb2a1595e80044ad/tests%2Fcompile-fail%2Fptr_int_unexposed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_int_unexposed.rs?ref=f7bc441fd342783ad42b8a9fbb2a1595e80044ad", "patch": "@@ -0,0 +1,12 @@\n+// compile-flags: -Zmiri-permissive-provenance -Zmiri-disable-stacked-borrows\n+\n+fn main() {\n+    let x: i32 = 3;\n+    let x_ptr = &x as *const i32;\n+\n+    // TODO: switch this to addr() once we intrinsify it\n+    let x_usize: usize = unsafe { std::mem::transmute(x_ptr) };\n+    // Cast back a pointer that did *not* get exposed.\n+    let ptr = x_usize as *const i32;\n+    assert_eq!(unsafe { *ptr }, 3); //~ ERROR Undefined Behavior: dereferencing pointer failed\n+}"}, {"sha": "aecc1460e085332502b21261f95f1c47875ce31d", "filename": "tests/compile-fail/ptr_legacy_provenance.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f7bc441fd342783ad42b8a9fbb2a1595e80044ad/tests%2Fcompile-fail%2Fptr_legacy_provenance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bc441fd342783ad42b8a9fbb2a1595e80044ad/tests%2Fcompile-fail%2Fptr_legacy_provenance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_legacy_provenance.rs?ref=f7bc441fd342783ad42b8a9fbb2a1595e80044ad", "patch": "@@ -0,0 +1,21 @@\n+// compile-flags: -Zmiri-disable-stacked-borrows\n+#![feature(strict_provenance)]\n+\n+use std::ptr;\n+\n+// Make sure that with legacy provenance, the allocation id of\n+// a casted pointer is determined at cast-time\n+fn main() {\n+    let x: i32 = 0;\n+    let y: i32 = 1;\n+\n+    let x_ptr = &x as *const i32;\n+    let y_ptr = &y as *const i32;\n+\n+    let x_usize = x_ptr.expose_addr();\n+    let y_usize = y_ptr.expose_addr();\n+\n+    let ptr = ptr::from_exposed_addr::<i32>(y_usize);\n+    let ptr = ptr.with_addr(x_usize);\n+    assert_eq!(unsafe { *ptr }, 0); //~ ERROR is out-of-bounds\n+}"}, {"sha": "e025cf921313adb9a7ad0440122b0a1aa9891687", "filename": "tests/run-pass/ptr_int_permissive_provenance.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/f7bc441fd342783ad42b8a9fbb2a1595e80044ad/tests%2Frun-pass%2Fptr_int_permissive_provenance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bc441fd342783ad42b8a9fbb2a1595e80044ad/tests%2Frun-pass%2Fptr_int_permissive_provenance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fptr_int_permissive_provenance.rs?ref=f7bc441fd342783ad42b8a9fbb2a1595e80044ad", "patch": "@@ -0,0 +1,62 @@\n+// compile-flags: -Zmiri-permissive-provenance -Zmiri-disable-stacked-borrows\n+#![feature(strict_provenance)]\n+\n+use std::ptr;\n+\n+/// Ensure we can expose the address of a pointer that is out-of-bounds\n+fn ptr_roundtrip_out_of_bounds() {\n+    let x: i32 = 3;\n+    let x_ptr = &x as *const i32;\n+\n+    let x_usize = x_ptr.wrapping_offset(128).expose_addr();\n+\n+    let ptr = ptr::from_exposed_addr::<i32>(x_usize).wrapping_offset(-128);\n+    assert_eq!(unsafe { *ptr }, 3);\n+}\n+\n+/// Ensure that we can move between allocations after casting back to a ptr\n+fn ptr_roundtrip_confusion() {\n+    let x: i32 = 0;\n+    let y: i32 = 1;\n+\n+    let x_ptr = &x as *const i32;\n+    let y_ptr = &y as *const i32;\n+\n+    let x_usize = x_ptr.expose_addr();\n+    let y_usize = y_ptr.expose_addr();\n+\n+    let ptr = ptr::from_exposed_addr::<i32>(y_usize);\n+    let ptr = ptr.with_addr(x_usize);\n+    assert_eq!(unsafe { *ptr }, 0);\n+}\n+\n+/// Ensure we can cast back a different integer than the one we got when exposing.\n+fn ptr_roundtrip_imperfect() {\n+    let x: u8 = 3;\n+    let x_ptr = &x as *const u8;\n+\n+    let x_usize = x_ptr.expose_addr() + 128;\n+\n+    let ptr = ptr::from_exposed_addr::<u8>(x_usize).wrapping_offset(-128);\n+    assert_eq!(unsafe { *ptr }, 3);\n+}\n+\n+/// Ensure that we can roundtrip through a pointer with an address of 0\n+fn ptr_roundtrip_null() {\n+    let x = &42;\n+    let x_ptr = x as *const i32;\n+    let x_null_ptr = x_ptr.with_addr(0); // addr 0, but still the provenance of x\n+    let null = x_null_ptr.expose_addr();\n+    assert_eq!(null, 0);\n+\n+    let x_null_ptr_copy = ptr::from_exposed_addr::<i32>(null); // just a roundtrip, so has provenance of x (angelically)\n+    let x_ptr_copy = x_null_ptr_copy.with_addr(x_ptr.addr()); // addr of x and provenance of x\n+    assert_eq!(unsafe { *x_ptr_copy }, 42);\n+}\n+\n+fn main() {\n+    ptr_roundtrip_out_of_bounds();\n+    ptr_roundtrip_confusion();\n+    ptr_roundtrip_imperfect();\n+    ptr_roundtrip_null();\n+}"}]}