{"sha": "9f2a43c1b518a674ef4bb368732ee8dac3c1f779", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmMmE0M2MxYjUxOGE2NzRlZjRiYjM2ODczMmVlOGRhYzNjMWY3Nzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-05T01:31:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-05T01:31:52Z"}, "message": "auto merge of #15419 : erickt/rust/json, r=pcwalton\n\nThis speeds up json serialization by removing most of the allocations.", "tree": {"sha": "8ce9973521da2ff17bf5bd269ed7f54c864f8643", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ce9973521da2ff17bf5bd269ed7f54c864f8643"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f2a43c1b518a674ef4bb368732ee8dac3c1f779", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f2a43c1b518a674ef4bb368732ee8dac3c1f779", "html_url": "https://github.com/rust-lang/rust/commit/9f2a43c1b518a674ef4bb368732ee8dac3c1f779", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f2a43c1b518a674ef4bb368732ee8dac3c1f779/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "459f155f81291c46633e86a480628b50304ffb1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/459f155f81291c46633e86a480628b50304ffb1c", "html_url": "https://github.com/rust-lang/rust/commit/459f155f81291c46633e86a480628b50304ffb1c"}, {"sha": "67c8a8d5dd90e476d0579df3738fe1e744ef68f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/67c8a8d5dd90e476d0579df3738fe1e744ef68f1", "html_url": "https://github.com/rust-lang/rust/commit/67c8a8d5dd90e476d0579df3738fe1e744ef68f1"}], "stats": {"total": 124, "additions": 87, "deletions": 37}, "files": [{"sha": "f4e5c27a14b33638bb7b2db1f03921841d3a944d", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 87, "deletions": 37, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/9f2a43c1b518a674ef4bb368732ee8dac3c1f779/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f2a43c1b518a674ef4bb368732ee8dac3c1f779/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=9f2a43c1b518a674ef4bb368732ee8dac3c1f779", "patch": "@@ -256,22 +256,63 @@ fn io_error_to_error(io: io::IoError) -> ParserError {\n pub type EncodeResult = io::IoResult<()>;\n pub type DecodeResult<T> = Result<T, DecoderError>;\n \n-fn escape_str(s: &str) -> String {\n-    let mut escaped = String::from_str(\"\\\"\");\n-    for c in s.chars() {\n-        match c {\n-            '\"' => escaped.push_str(\"\\\\\\\"\"),\n-            '\\\\' => escaped.push_str(\"\\\\\\\\\"),\n-            '\\x08' => escaped.push_str(\"\\\\b\"),\n-            '\\x0c' => escaped.push_str(\"\\\\f\"),\n-            '\\n' => escaped.push_str(\"\\\\n\"),\n-            '\\r' => escaped.push_str(\"\\\\r\"),\n-            '\\t' => escaped.push_str(\"\\\\t\"),\n-            _ => escaped.push_char(c),\n+pub fn escape_bytes(wr: &mut io::Writer, bytes: &[u8]) -> Result<(), io::IoError> {\n+    try!(wr.write_str(\"\\\"\"));\n+\n+    let mut start = 0;\n+\n+    for (i, byte) in bytes.iter().enumerate() {\n+        let escaped = match *byte {\n+            b'\"' => \"\\\\\\\"\",\n+            b'\\\\' => \"\\\\\\\\\",\n+            b'\\x08' => \"\\\\b\",\n+            b'\\x0c' => \"\\\\f\",\n+            b'\\n' => \"\\\\n\",\n+            b'\\r' => \"\\\\r\",\n+            b'\\t' => \"\\\\t\",\n+            _ => { continue; }\n+        };\n+\n+        if start < i {\n+            try!(wr.write(bytes.slice(start, i)));\n         }\n-    };\n-    escaped.push_char('\"');\n-    escaped\n+\n+        try!(wr.write_str(escaped));\n+\n+        start = i + 1;\n+    }\n+\n+    if start != bytes.len() {\n+        try!(wr.write(bytes.slice_from(start)));\n+    }\n+\n+    wr.write_str(\"\\\"\")\n+}\n+\n+fn escape_str(writer: &mut io::Writer, v: &str) -> Result<(), io::IoError> {\n+    escape_bytes(writer, v.as_bytes())\n+}\n+\n+fn escape_char(writer: &mut io::Writer, v: char) -> Result<(), io::IoError> {\n+    let mut buf = [0, .. 4];\n+    v.encode_utf8(buf);\n+    escape_bytes(writer, buf)\n+}\n+\n+fn spaces(wr: &mut io::Writer, mut n: uint) -> Result<(), io::IoError> {\n+    static len: uint = 16;\n+    static buf: [u8, ..len] = [b' ', ..len];\n+\n+    while n >= len {\n+        try!(wr.write(buf));\n+        n -= len;\n+    }\n+\n+    if n > 0 {\n+        wr.write(buf.slice_to(n))\n+    } else {\n+        Ok(())\n+    }\n }\n \n fn fmt_number_or_null(v: f64) -> String {\n@@ -281,10 +322,6 @@ fn fmt_number_or_null(v: f64) -> String {\n     }\n }\n \n-fn spaces(n: uint) -> String {\n-    String::from_char(n, ' ')\n-}\n-\n /// A structure for implementing serialization to JSON.\n pub struct Encoder<'a> {\n     writer: &'a mut io::Writer,\n@@ -348,10 +385,10 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n     fn emit_f32(&mut self, v: f32) -> EncodeResult { self.emit_f64(v as f64) }\n \n     fn emit_char(&mut self, v: char) -> EncodeResult {\n-        self.emit_str(str::from_char(v).as_slice())\n+        escape_char(self.writer, v)\n     }\n     fn emit_str(&mut self, v: &str) -> EncodeResult {\n-        write!(self.writer, \"{}\", escape_str(v))\n+        escape_str(self.writer, v)\n     }\n \n     fn emit_enum(&mut self, _name: &str, f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n@@ -367,10 +404,10 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n         // Bunny => \"Bunny\"\n         // Kangaroo(34,\"William\") => {\"variant\": \"Kangaroo\", \"fields\": [34,\"William\"]}\n         if cnt == 0 {\n-            write!(self.writer, \"{}\", escape_str(name))\n+            escape_str(self.writer, name)\n         } else {\n             try!(write!(self.writer, \"{{\\\"variant\\\":\"));\n-            try!(write!(self.writer, \"{}\", escape_str(name)));\n+            try!(escape_str(self.writer, name));\n             try!(write!(self.writer, \",\\\"fields\\\":[\"));\n             try!(f(self));\n             write!(self.writer, \"]}}\")\n@@ -415,7 +452,8 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n                          idx: uint,\n                          f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n         if idx != 0 { try!(write!(self.writer, \",\")); }\n-        try!(write!(self.writer, \"{}:\", escape_str(name)));\n+        try!(escape_str(self.writer, name));\n+        try!(write!(self.writer, \":\"));\n         f(self)\n     }\n \n@@ -541,10 +579,10 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n     }\n \n     fn emit_char(&mut self, v: char) -> EncodeResult {\n-        self.emit_str(str::from_char(v).as_slice())\n+        escape_char(self.writer, v)\n     }\n     fn emit_str(&mut self, v: &str) -> EncodeResult {\n-        write!(self.writer, \"{}\", escape_str(v))\n+        escape_str(self.writer, v)\n     }\n \n     fn emit_enum(&mut self,\n@@ -559,14 +597,18 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n                          cnt: uint,\n                          f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n         if cnt == 0 {\n-            write!(self.writer, \"{}\", escape_str(name))\n+            escape_str(self.writer, name)\n         } else {\n             self.indent += 2;\n-            try!(write!(self.writer, \"[\\n{}{},\\n\", spaces(self.indent),\n-                          escape_str(name)));\n+            try!(write!(self.writer, \"[\\n\"));\n+            try!(spaces(self.writer, self.indent));\n+            try!(escape_str(self.writer, name));\n+            try!(write!(self.writer, \",\\n\"));\n             try!(f(self));\n             self.indent -= 2;\n-            write!(self.writer, \"\\n{}]\", spaces(self.indent))\n+            try!(write!(self.writer, \"\\n\"));\n+            try!(spaces(self.writer, self.indent));\n+            write!(self.writer, \"]\")\n         }\n     }\n \n@@ -576,7 +618,7 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n         if idx != 0 {\n             try!(write!(self.writer, \",\\n\"));\n         }\n-        try!(write!(self.writer, \"{}\", spaces(self.indent)));\n+        try!(spaces(self.writer, self.indent));\n         f(self)\n     }\n \n@@ -607,7 +649,9 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n             self.indent += 2;\n             try!(f(self));\n             self.indent -= 2;\n-            write!(self.writer, \"\\n{}}}\", spaces(self.indent))\n+            try!(write!(self.writer, \"\\n\"));\n+            try!(spaces(self.writer, self.indent));\n+            write!(self.writer, \"}}\")\n         }\n     }\n \n@@ -620,7 +664,9 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n         } else {\n             try!(write!(self.writer, \",\\n\"));\n         }\n-        try!(write!(self.writer, \"{}{}: \", spaces(self.indent), escape_str(name)));\n+        try!(spaces(self.writer, self.indent));\n+        try!(escape_str(self.writer, name));\n+        try!(write!(self.writer, \": \"));\n         f(self)\n     }\n \n@@ -665,7 +711,9 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n             self.indent += 2;\n             try!(f(self));\n             self.indent -= 2;\n-            write!(self.writer, \"\\n{}]\", spaces(self.indent))\n+            try!(write!(self.writer, \"\\n\"));\n+            try!(spaces(self.writer, self.indent));\n+            write!(self.writer, \"]\")\n         }\n     }\n \n@@ -677,7 +725,7 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n         } else {\n             try!(write!(self.writer, \",\\n\"));\n         }\n-        try!(write!(self.writer, \"{}\", spaces(self.indent)));\n+        try!(spaces(self.writer, self.indent));\n         f(self)\n     }\n \n@@ -691,7 +739,9 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n             self.indent += 2;\n             try!(f(self));\n             self.indent -= 2;\n-            write!(self.writer, \"\\n{}}}\", spaces(self.indent))\n+            try!(write!(self.writer, \"\\n\"));\n+            try!(spaces(self.writer, self.indent));\n+            write!(self.writer, \"}}\")\n         }\n     }\n \n@@ -703,7 +753,7 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n         } else {\n             try!(write!(self.writer, \",\\n\"));\n         }\n-        try!(write!(self.writer, \"{}\", spaces(self.indent)));\n+        try!(spaces(self.writer, self.indent));\n         // ref #12967, make sure to wrap a key in double quotes,\n         // in the event that its of a type that omits them (eg numbers)\n         let mut buf = MemWriter::new();"}]}