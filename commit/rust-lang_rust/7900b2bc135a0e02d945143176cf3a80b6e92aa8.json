{"sha": "7900b2bc135a0e02d945143176cf3a80b6e92aa8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5MDBiMmJjMTM1YTBlMDJkOTQ1MTQzMTc2Y2YzYTgwYjZlOTJhYTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-21T13:26:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-21T13:26:44Z"}, "message": "Auto merge of #70222 - Dylan-DPC:rollup-cwkv5ez, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #69497 (Don't unwind when hitting the macro expansion recursion limit)\n - #69901 (add #[rustc_layout(debug)])\n - #69910 (Avoid query type in generics)\n - #69955 (Fix abort-on-eprintln during process shutdown)\n - #70032 (put type params in front of const params in generics_of)\n - #70119 (rustc: use LocalDefId instead of DefId in TypeckTables.)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "42bf64842fa16d1666f68b4743abb0a7c18b9049", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42bf64842fa16d1666f68b4743abb0a7c18b9049"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7900b2bc135a0e02d945143176cf3a80b6e92aa8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7900b2bc135a0e02d945143176cf3a80b6e92aa8", "html_url": "https://github.com/rust-lang/rust/commit/7900b2bc135a0e02d945143176cf3a80b6e92aa8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7900b2bc135a0e02d945143176cf3a80b6e92aa8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98803c182b2ba6ef5dccb6bf501958249295eac0", "url": "https://api.github.com/repos/rust-lang/rust/commits/98803c182b2ba6ef5dccb6bf501958249295eac0", "html_url": "https://github.com/rust-lang/rust/commit/98803c182b2ba6ef5dccb6bf501958249295eac0"}, {"sha": "f1ab7500838eee0736055eb2b65ff37fd05fcbd0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1ab7500838eee0736055eb2b65ff37fd05fcbd0", "html_url": "https://github.com/rust-lang/rust/commit/f1ab7500838eee0736055eb2b65ff37fd05fcbd0"}], "stats": {"total": 1426, "additions": 947, "deletions": 479}, "files": [{"sha": "75842fd554941fb8d4d5be581a75d6a1a7bd7f6b", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 50, "deletions": 77, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -188,37 +188,37 @@ pub struct CommonConsts<'tcx> {\n }\n \n pub struct LocalTableInContext<'a, V> {\n-    local_id_root: Option<DefId>,\n+    hir_owner: Option<LocalDefId>,\n     data: &'a ItemLocalMap<V>,\n }\n \n /// Validate that the given HirId (respectively its `local_id` part) can be\n /// safely used as a key in the tables of a TypeckTable. For that to be\n /// the case, the HirId must have the same `owner` as all the other IDs in\n-/// this table (signified by `local_id_root`). Otherwise the HirId\n+/// this table (signified by `hir_owner`). Otherwise the HirId\n /// would be in a different frame of reference and using its `local_id`\n /// would result in lookup errors, or worse, in silently wrong data being\n /// stored/returned.\n fn validate_hir_id_for_typeck_tables(\n-    local_id_root: Option<DefId>,\n+    hir_owner: Option<LocalDefId>,\n     hir_id: hir::HirId,\n     mut_access: bool,\n ) {\n-    if let Some(local_id_root) = local_id_root {\n-        if hir_id.owner.to_def_id() != local_id_root {\n+    if let Some(hir_owner) = hir_owner {\n+        if hir_id.owner != hir_owner {\n             ty::tls::with(|tcx| {\n                 bug!(\n                     \"node {} with HirId::owner {:?} cannot be placed in \\\n-                     TypeckTables with local_id_root {:?}\",\n+                     TypeckTables with hir_owner {:?}\",\n                     tcx.hir().node_to_string(hir_id),\n                     hir_id.owner,\n-                    local_id_root\n+                    hir_owner\n                 )\n             });\n         }\n     } else {\n         // We use \"Null Object\" TypeckTables in some of the analysis passes.\n-        // These are just expected to be empty and their `local_id_root` is\n+        // These are just expected to be empty and their `hir_owner` is\n         // `None`. Therefore we cannot verify whether a given `HirId` would\n         // be a valid key for the given table. Instead we make sure that\n         // nobody tries to write to such a Null Object table.\n@@ -230,12 +230,12 @@ fn validate_hir_id_for_typeck_tables(\n \n impl<'a, V> LocalTableInContext<'a, V> {\n     pub fn contains_key(&self, id: hir::HirId) -> bool {\n-        validate_hir_id_for_typeck_tables(self.local_id_root, id, false);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id, false);\n         self.data.contains_key(&id.local_id)\n     }\n \n     pub fn get(&self, id: hir::HirId) -> Option<&V> {\n-        validate_hir_id_for_typeck_tables(self.local_id_root, id, false);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id, false);\n         self.data.get(&id.local_id)\n     }\n \n@@ -253,28 +253,28 @@ impl<'a, V> ::std::ops::Index<hir::HirId> for LocalTableInContext<'a, V> {\n }\n \n pub struct LocalTableInContextMut<'a, V> {\n-    local_id_root: Option<DefId>,\n+    hir_owner: Option<LocalDefId>,\n     data: &'a mut ItemLocalMap<V>,\n }\n \n impl<'a, V> LocalTableInContextMut<'a, V> {\n     pub fn get_mut(&mut self, id: hir::HirId) -> Option<&mut V> {\n-        validate_hir_id_for_typeck_tables(self.local_id_root, id, true);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id, true);\n         self.data.get_mut(&id.local_id)\n     }\n \n     pub fn entry(&mut self, id: hir::HirId) -> Entry<'_, hir::ItemLocalId, V> {\n-        validate_hir_id_for_typeck_tables(self.local_id_root, id, true);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id, true);\n         self.data.entry(id.local_id)\n     }\n \n     pub fn insert(&mut self, id: hir::HirId, val: V) -> Option<V> {\n-        validate_hir_id_for_typeck_tables(self.local_id_root, id, true);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id, true);\n         self.data.insert(id.local_id, val)\n     }\n \n     pub fn remove(&mut self, id: hir::HirId) -> Option<V> {\n-        validate_hir_id_for_typeck_tables(self.local_id_root, id, true);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id, true);\n         self.data.remove(&id.local_id)\n     }\n }\n@@ -322,8 +322,8 @@ pub struct GeneratorInteriorTypeCause<'tcx> {\n \n #[derive(RustcEncodable, RustcDecodable, Debug)]\n pub struct TypeckTables<'tcx> {\n-    /// The HirId::owner all ItemLocalIds in this table are relative to.\n-    pub local_id_root: Option<DefId>,\n+    /// The `HirId::owner` all `ItemLocalId`s in this table are relative to.\n+    pub hir_owner: Option<LocalDefId>,\n \n     /// Resolved definitions for `<T>::X` associated paths and\n     /// method calls, including those of overloaded operators.\n@@ -431,9 +431,9 @@ pub struct TypeckTables<'tcx> {\n }\n \n impl<'tcx> TypeckTables<'tcx> {\n-    pub fn empty(local_id_root: Option<DefId>) -> TypeckTables<'tcx> {\n+    pub fn empty(hir_owner: Option<LocalDefId>) -> TypeckTables<'tcx> {\n         TypeckTables {\n-            local_id_root,\n+            hir_owner,\n             type_dependent_defs: Default::default(),\n             field_indices: Default::default(),\n             user_provided_types: Default::default(),\n@@ -469,11 +469,11 @@ impl<'tcx> TypeckTables<'tcx> {\n     pub fn type_dependent_defs(\n         &self,\n     ) -> LocalTableInContext<'_, Result<(DefKind, DefId), ErrorReported>> {\n-        LocalTableInContext { local_id_root: self.local_id_root, data: &self.type_dependent_defs }\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.type_dependent_defs }\n     }\n \n     pub fn type_dependent_def(&self, id: HirId) -> Option<(DefKind, DefId)> {\n-        validate_hir_id_for_typeck_tables(self.local_id_root, id, false);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id, false);\n         self.type_dependent_defs.get(&id.local_id).cloned().and_then(|r| r.ok())\n     }\n \n@@ -484,39 +484,33 @@ impl<'tcx> TypeckTables<'tcx> {\n     pub fn type_dependent_defs_mut(\n         &mut self,\n     ) -> LocalTableInContextMut<'_, Result<(DefKind, DefId), ErrorReported>> {\n-        LocalTableInContextMut {\n-            local_id_root: self.local_id_root,\n-            data: &mut self.type_dependent_defs,\n-        }\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.type_dependent_defs }\n     }\n \n     pub fn field_indices(&self) -> LocalTableInContext<'_, usize> {\n-        LocalTableInContext { local_id_root: self.local_id_root, data: &self.field_indices }\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.field_indices }\n     }\n \n     pub fn field_indices_mut(&mut self) -> LocalTableInContextMut<'_, usize> {\n-        LocalTableInContextMut { local_id_root: self.local_id_root, data: &mut self.field_indices }\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.field_indices }\n     }\n \n     pub fn user_provided_types(&self) -> LocalTableInContext<'_, CanonicalUserType<'tcx>> {\n-        LocalTableInContext { local_id_root: self.local_id_root, data: &self.user_provided_types }\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.user_provided_types }\n     }\n \n     pub fn user_provided_types_mut(\n         &mut self,\n     ) -> LocalTableInContextMut<'_, CanonicalUserType<'tcx>> {\n-        LocalTableInContextMut {\n-            local_id_root: self.local_id_root,\n-            data: &mut self.user_provided_types,\n-        }\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.user_provided_types }\n     }\n \n     pub fn node_types(&self) -> LocalTableInContext<'_, Ty<'tcx>> {\n-        LocalTableInContext { local_id_root: self.local_id_root, data: &self.node_types }\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.node_types }\n     }\n \n     pub fn node_types_mut(&mut self) -> LocalTableInContextMut<'_, Ty<'tcx>> {\n-        LocalTableInContextMut { local_id_root: self.local_id_root, data: &mut self.node_types }\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.node_types }\n     }\n \n     pub fn node_type(&self, id: hir::HirId) -> Ty<'tcx> {\n@@ -526,21 +520,21 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n \n     pub fn node_type_opt(&self, id: hir::HirId) -> Option<Ty<'tcx>> {\n-        validate_hir_id_for_typeck_tables(self.local_id_root, id, false);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id, false);\n         self.node_types.get(&id.local_id).cloned()\n     }\n \n     pub fn node_substs_mut(&mut self) -> LocalTableInContextMut<'_, SubstsRef<'tcx>> {\n-        LocalTableInContextMut { local_id_root: self.local_id_root, data: &mut self.node_substs }\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.node_substs }\n     }\n \n     pub fn node_substs(&self, id: hir::HirId) -> SubstsRef<'tcx> {\n-        validate_hir_id_for_typeck_tables(self.local_id_root, id, false);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id, false);\n         self.node_substs.get(&id.local_id).cloned().unwrap_or_else(|| InternalSubsts::empty())\n     }\n \n     pub fn node_substs_opt(&self, id: hir::HirId) -> Option<SubstsRef<'tcx>> {\n-        validate_hir_id_for_typeck_tables(self.local_id_root, id, false);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, id, false);\n         self.node_substs.get(&id.local_id).cloned()\n     }\n \n@@ -573,17 +567,17 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n \n     pub fn adjustments(&self) -> LocalTableInContext<'_, Vec<ty::adjustment::Adjustment<'tcx>>> {\n-        LocalTableInContext { local_id_root: self.local_id_root, data: &self.adjustments }\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.adjustments }\n     }\n \n     pub fn adjustments_mut(\n         &mut self,\n     ) -> LocalTableInContextMut<'_, Vec<ty::adjustment::Adjustment<'tcx>>> {\n-        LocalTableInContextMut { local_id_root: self.local_id_root, data: &mut self.adjustments }\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.adjustments }\n     }\n \n     pub fn expr_adjustments(&self, expr: &hir::Expr<'_>) -> &[ty::adjustment::Adjustment<'tcx>] {\n-        validate_hir_id_for_typeck_tables(self.local_id_root, expr.hir_id, false);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, expr.hir_id, false);\n         self.adjustments.get(&expr.hir_id.local_id).map_or(&[], |a| &a[..])\n     }\n \n@@ -618,66 +612,51 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n \n     pub fn pat_binding_modes(&self) -> LocalTableInContext<'_, BindingMode> {\n-        LocalTableInContext { local_id_root: self.local_id_root, data: &self.pat_binding_modes }\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.pat_binding_modes }\n     }\n \n     pub fn pat_binding_modes_mut(&mut self) -> LocalTableInContextMut<'_, BindingMode> {\n-        LocalTableInContextMut {\n-            local_id_root: self.local_id_root,\n-            data: &mut self.pat_binding_modes,\n-        }\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.pat_binding_modes }\n     }\n \n     pub fn pat_adjustments(&self) -> LocalTableInContext<'_, Vec<Ty<'tcx>>> {\n-        LocalTableInContext { local_id_root: self.local_id_root, data: &self.pat_adjustments }\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.pat_adjustments }\n     }\n \n     pub fn pat_adjustments_mut(&mut self) -> LocalTableInContextMut<'_, Vec<Ty<'tcx>>> {\n-        LocalTableInContextMut {\n-            local_id_root: self.local_id_root,\n-            data: &mut self.pat_adjustments,\n-        }\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.pat_adjustments }\n     }\n \n     pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> ty::UpvarCapture<'tcx> {\n         self.upvar_capture_map[&upvar_id]\n     }\n \n     pub fn closure_kind_origins(&self) -> LocalTableInContext<'_, (Span, ast::Name)> {\n-        LocalTableInContext { local_id_root: self.local_id_root, data: &self.closure_kind_origins }\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.closure_kind_origins }\n     }\n \n     pub fn closure_kind_origins_mut(&mut self) -> LocalTableInContextMut<'_, (Span, ast::Name)> {\n-        LocalTableInContextMut {\n-            local_id_root: self.local_id_root,\n-            data: &mut self.closure_kind_origins,\n-        }\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.closure_kind_origins }\n     }\n \n     pub fn liberated_fn_sigs(&self) -> LocalTableInContext<'_, ty::FnSig<'tcx>> {\n-        LocalTableInContext { local_id_root: self.local_id_root, data: &self.liberated_fn_sigs }\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.liberated_fn_sigs }\n     }\n \n     pub fn liberated_fn_sigs_mut(&mut self) -> LocalTableInContextMut<'_, ty::FnSig<'tcx>> {\n-        LocalTableInContextMut {\n-            local_id_root: self.local_id_root,\n-            data: &mut self.liberated_fn_sigs,\n-        }\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.liberated_fn_sigs }\n     }\n \n     pub fn fru_field_types(&self) -> LocalTableInContext<'_, Vec<Ty<'tcx>>> {\n-        LocalTableInContext { local_id_root: self.local_id_root, data: &self.fru_field_types }\n+        LocalTableInContext { hir_owner: self.hir_owner, data: &self.fru_field_types }\n     }\n \n     pub fn fru_field_types_mut(&mut self) -> LocalTableInContextMut<'_, Vec<Ty<'tcx>>> {\n-        LocalTableInContextMut {\n-            local_id_root: self.local_id_root,\n-            data: &mut self.fru_field_types,\n-        }\n+        LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.fru_field_types }\n     }\n \n     pub fn is_coercion_cast(&self, hir_id: hir::HirId) -> bool {\n-        validate_hir_id_for_typeck_tables(self.local_id_root, hir_id, true);\n+        validate_hir_id_for_typeck_tables(self.hir_owner, hir_id, true);\n         self.coercion_casts.contains(&hir_id.local_id)\n     }\n \n@@ -693,7 +672,7 @@ impl<'tcx> TypeckTables<'tcx> {\n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckTables<'tcx> {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let ty::TypeckTables {\n-            local_id_root,\n+            hir_owner,\n             ref type_dependent_defs,\n             ref field_indices,\n             ref user_provided_types,\n@@ -730,18 +709,12 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckTables<'tcx> {\n             hash_stable_hashmap(hcx, hasher, upvar_capture_map, |up_var_id, hcx| {\n                 let ty::UpvarId { var_path, closure_expr_id } = *up_var_id;\n \n-                let local_id_root = local_id_root.expect(\"trying to hash invalid TypeckTables\");\n+                assert_eq!(Some(var_path.hir_id.owner), hir_owner);\n \n-                let var_owner_def_id = DefId {\n-                    krate: local_id_root.krate,\n-                    index: var_path.hir_id.owner.local_def_index,\n-                };\n-                let closure_def_id =\n-                    DefId { krate: local_id_root.krate, index: closure_expr_id.local_def_index };\n                 (\n-                    hcx.def_path_hash(var_owner_def_id),\n+                    hcx.local_def_path_hash(var_path.hir_id.owner),\n                     var_path.hir_id.local_id,\n-                    hcx.def_path_hash(closure_def_id),\n+                    hcx.local_def_path_hash(closure_expr_id),\n                 )\n             });\n "}, {"sha": "a11b3bcba3ed30dc7e8774f8e200e3db01ca1e9c", "filename": "src/librustc/ty/query/caches.rs", "status": "modified", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc%2Fty%2Fquery%2Fcaches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc%2Fty%2Fquery%2Fcaches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fcaches.rs?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -1,82 +1,94 @@\n use crate::dep_graph::DepNodeIndex;\n-use crate::ty::query::config::QueryAccessors;\n use crate::ty::query::plumbing::{QueryLookup, QueryState, QueryStateShard};\n use crate::ty::TyCtxt;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sharded::Sharded;\n use std::default::Default;\n use std::hash::Hash;\n+use std::marker::PhantomData;\n \n pub(crate) trait CacheSelector<K, V> {\n-    type Cache: QueryCache<K, V>;\n+    type Cache: QueryCache<Key = K, Value = V>;\n }\n \n-pub(crate) trait QueryCache<K, V>: Default {\n+pub(crate) trait QueryCache: Default {\n+    type Key;\n+    type Value;\n     type Sharded: Default;\n \n     /// Checks if the query is already computed and in the cache.\n     /// It returns the shard index and a lock guard to the shard,\n     /// which will be used if the query is not in the cache and we need\n     /// to compute it.\n-    fn lookup<'tcx, R, GetCache, OnHit, OnMiss, Q>(\n+    fn lookup<'tcx, R, GetCache, OnHit, OnMiss>(\n         &self,\n-        state: &'tcx QueryState<'tcx, Q>,\n+        state: &'tcx QueryState<'tcx, Self>,\n         get_cache: GetCache,\n-        key: K,\n+        key: Self::Key,\n         // `on_hit` can be called while holding a lock to the query state shard.\n         on_hit: OnHit,\n         on_miss: OnMiss,\n     ) -> R\n     where\n-        Q: QueryAccessors<'tcx>,\n-        GetCache: for<'a> Fn(&'a mut QueryStateShard<'tcx, Q>) -> &'a mut Self::Sharded,\n-        OnHit: FnOnce(&V, DepNodeIndex) -> R,\n-        OnMiss: FnOnce(K, QueryLookup<'tcx, Q>) -> R;\n+        GetCache: for<'a> Fn(\n+            &'a mut QueryStateShard<'tcx, Self::Key, Self::Sharded>,\n+        ) -> &'a mut Self::Sharded,\n+        OnHit: FnOnce(&Self::Value, DepNodeIndex) -> R,\n+        OnMiss: FnOnce(Self::Key, QueryLookup<'tcx, Self::Key, Self::Sharded>) -> R;\n \n     fn complete(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         lock_sharded_storage: &mut Self::Sharded,\n-        key: K,\n-        value: V,\n+        key: Self::Key,\n+        value: Self::Value,\n         index: DepNodeIndex,\n     );\n \n     fn iter<R, L>(\n         &self,\n         shards: &Sharded<L>,\n         get_shard: impl Fn(&mut L) -> &mut Self::Sharded,\n-        f: impl for<'a> FnOnce(Box<dyn Iterator<Item = (&'a K, &'a V, DepNodeIndex)> + 'a>) -> R,\n+        f: impl for<'a> FnOnce(\n+            Box<dyn Iterator<Item = (&'a Self::Key, &'a Self::Value, DepNodeIndex)> + 'a>,\n+        ) -> R,\n     ) -> R;\n }\n \n pub struct DefaultCacheSelector;\n \n impl<K: Eq + Hash, V: Clone> CacheSelector<K, V> for DefaultCacheSelector {\n-    type Cache = DefaultCache;\n+    type Cache = DefaultCache<K, V>;\n }\n \n-#[derive(Default)]\n-pub struct DefaultCache;\n+pub struct DefaultCache<K, V>(PhantomData<(K, V)>);\n+\n+impl<K, V> Default for DefaultCache<K, V> {\n+    fn default() -> Self {\n+        DefaultCache(PhantomData)\n+    }\n+}\n \n-impl<K: Eq + Hash, V: Clone> QueryCache<K, V> for DefaultCache {\n+impl<K: Eq + Hash, V: Clone> QueryCache for DefaultCache<K, V> {\n+    type Key = K;\n+    type Value = V;\n     type Sharded = FxHashMap<K, (V, DepNodeIndex)>;\n \n     #[inline(always)]\n-    fn lookup<'tcx, R, GetCache, OnHit, OnMiss, Q>(\n+    fn lookup<'tcx, R, GetCache, OnHit, OnMiss>(\n         &self,\n-        state: &'tcx QueryState<'tcx, Q>,\n+        state: &'tcx QueryState<'tcx, Self>,\n         get_cache: GetCache,\n         key: K,\n         on_hit: OnHit,\n         on_miss: OnMiss,\n     ) -> R\n     where\n-        Q: QueryAccessors<'tcx>,\n-        GetCache: for<'a> Fn(&'a mut QueryStateShard<'tcx, Q>) -> &'a mut Self::Sharded,\n+        GetCache:\n+            for<'a> Fn(&'a mut QueryStateShard<'tcx, K, Self::Sharded>) -> &'a mut Self::Sharded,\n         OnHit: FnOnce(&V, DepNodeIndex) -> R,\n-        OnMiss: FnOnce(K, QueryLookup<'tcx, Q>) -> R,\n+        OnMiss: FnOnce(K, QueryLookup<'tcx, K, Self::Sharded>) -> R,\n     {\n         let mut lookup = state.get_lookup(&key);\n         let lock = &mut *lookup.lock;"}, {"sha": "72a0fdf1567268f03338dbd0db6afc97ad70fb85", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -2,7 +2,7 @@ use crate::dep_graph::SerializedDepNodeIndex;\n use crate::dep_graph::{DepKind, DepNode};\n use crate::ty::query::caches::QueryCache;\n use crate::ty::query::plumbing::CycleError;\n-use crate::ty::query::{Query, QueryState};\n+use crate::ty::query::QueryState;\n use crate::ty::TyCtxt;\n use rustc_data_structures::profiling::ProfileCategory;\n use rustc_hir::def_id::DefId;\n@@ -28,18 +28,15 @@ pub trait QueryConfig<'tcx> {\n pub(crate) trait QueryAccessors<'tcx>: QueryConfig<'tcx> {\n     const ANON: bool;\n     const EVAL_ALWAYS: bool;\n+    const DEP_KIND: DepKind;\n \n-    type Cache: QueryCache<Self::Key, Self::Value>;\n-\n-    fn query(key: Self::Key) -> Query<'tcx>;\n+    type Cache: QueryCache<Key = Self::Key, Value = Self::Value>;\n \n     // Don't use this method to access query results, instead use the methods on TyCtxt\n-    fn query_state<'a>(tcx: TyCtxt<'tcx>) -> &'a QueryState<'tcx, Self>;\n+    fn query_state<'a>(tcx: TyCtxt<'tcx>) -> &'a QueryState<'tcx, Self::Cache>;\n \n     fn to_dep_node(tcx: TyCtxt<'tcx>, key: &Self::Key) -> DepNode;\n \n-    fn dep_kind() -> DepKind;\n-\n     // Don't use this method to compute query results, instead use the methods on TyCtxt\n     fn compute(tcx: TyCtxt<'tcx>, key: Self::Key) -> Self::Value;\n \n@@ -62,10 +59,7 @@ pub(crate) trait QueryDescription<'tcx>: QueryAccessors<'tcx> {\n     }\n }\n \n-impl<'tcx, M: QueryAccessors<'tcx, Key = DefId>> QueryDescription<'tcx> for M\n-where\n-    <M as QueryAccessors<'tcx>>::Cache: QueryCache<DefId, <M as QueryConfig<'tcx>>::Value>,\n-{\n+impl<'tcx, M: QueryAccessors<'tcx, Key = DefId>> QueryDescription<'tcx> for M {\n     default fn describe(tcx: TyCtxt<'_>, def_id: DefId) -> Cow<'static, str> {\n         if !tcx.sess.verbose() {\n             format!(\"processing `{}`\", tcx.def_path_str(def_id)).into()"}, {"sha": "32ba13b1dbe9a5cfe2740383518400befde1ad28", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -56,13 +56,12 @@ use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n use std::borrow::Cow;\n use std::collections::BTreeMap;\n-use std::convert::TryFrom;\n use std::ops::Deref;\n use std::sync::Arc;\n \n #[macro_use]\n mod plumbing;\n-pub use self::plumbing::CycleError;\n+pub(crate) use self::plumbing::CycleError;\n use self::plumbing::*;\n \n mod stats;"}, {"sha": "0bfcae5fa2e6692a54857b30abf9d4f8eb5710ee", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 172, "deletions": 153, "changes": 325, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -2,10 +2,10 @@\n //! generate the actual methods on tcx which find and execute the provider,\n //! manage the caches, and so forth.\n \n-use crate::dep_graph::{DepNode, DepNodeIndex, SerializedDepNodeIndex};\n+use crate::dep_graph::{DepKind, DepNode, DepNodeIndex, SerializedDepNodeIndex};\n use crate::ty::query::caches::QueryCache;\n-use crate::ty::query::config::{QueryAccessors, QueryDescription};\n-use crate::ty::query::job::{QueryInfo, QueryJob, QueryJobId, QueryShardJobId};\n+use crate::ty::query::config::QueryDescription;\n+use crate::ty::query::job::{QueryInfo, QueryJob, QueryJobId, QueryJobInfo, QueryShardJobId};\n use crate::ty::query::Query;\n use crate::ty::tls;\n use crate::ty::{self, TyCtxt};\n@@ -20,44 +20,47 @@ use rustc_errors::{struct_span_err, Diagnostic, DiagnosticBuilder, FatalError, H\n use rustc_span::source_map::DUMMY_SP;\n use rustc_span::Span;\n use std::collections::hash_map::Entry;\n+use std::convert::TryFrom;\n+use std::fmt::Debug;\n use std::hash::{Hash, Hasher};\n use std::mem;\n use std::num::NonZeroU32;\n use std::ptr;\n #[cfg(debug_assertions)]\n use std::sync::atomic::{AtomicUsize, Ordering};\n \n-pub(crate) struct QueryStateShard<'tcx, D: QueryAccessors<'tcx> + ?Sized> {\n-    pub(super) cache: <<D as QueryAccessors<'tcx>>::Cache as QueryCache<D::Key, D::Value>>::Sharded,\n-    pub(super) active: FxHashMap<D::Key, QueryResult<'tcx>>,\n+pub(crate) struct QueryStateShard<'tcx, K, C> {\n+    cache: C,\n+    active: FxHashMap<K, QueryResult<'tcx>>,\n \n     /// Used to generate unique ids for active jobs.\n-    pub(super) jobs: u32,\n+    jobs: u32,\n }\n \n-impl<'tcx, Q: QueryAccessors<'tcx>> QueryStateShard<'tcx, Q> {\n-    fn get_cache(\n-        &mut self,\n-    ) -> &mut <<Q as QueryAccessors<'tcx>>::Cache as QueryCache<Q::Key, Q::Value>>::Sharded {\n+impl<'tcx, K, C> QueryStateShard<'tcx, K, C> {\n+    fn get_cache(&mut self) -> &mut C {\n         &mut self.cache\n     }\n }\n \n-impl<'tcx, Q: QueryAccessors<'tcx>> Default for QueryStateShard<'tcx, Q> {\n-    fn default() -> QueryStateShard<'tcx, Q> {\n+impl<'tcx, K, C: Default> Default for QueryStateShard<'tcx, K, C> {\n+    fn default() -> QueryStateShard<'tcx, K, C> {\n         QueryStateShard { cache: Default::default(), active: Default::default(), jobs: 0 }\n     }\n }\n \n-pub(crate) struct QueryState<'tcx, D: QueryAccessors<'tcx> + ?Sized> {\n-    pub(super) cache: D::Cache,\n-    pub(super) shards: Sharded<QueryStateShard<'tcx, D>>,\n+pub(crate) struct QueryState<'tcx, C: QueryCache> {\n+    cache: C,\n+    shards: Sharded<QueryStateShard<'tcx, C::Key, C::Sharded>>,\n     #[cfg(debug_assertions)]\n     pub(super) cache_hits: AtomicUsize,\n }\n \n-impl<'tcx, Q: QueryAccessors<'tcx>> QueryState<'tcx, Q> {\n-    pub(super) fn get_lookup<K: Hash>(&'tcx self, key: &K) -> QueryLookup<'tcx, Q> {\n+impl<'tcx, C: QueryCache> QueryState<'tcx, C> {\n+    pub(super) fn get_lookup<K2: Hash>(\n+        &'tcx self,\n+        key: &K2,\n+    ) -> QueryLookup<'tcx, C::Key, C::Sharded> {\n         // We compute the key's hash once and then use it for both the\n         // shard lookup and the hashmap lookup. This relies on the fact\n         // that both of them use `FxHasher`.\n@@ -72,7 +75,7 @@ impl<'tcx, Q: QueryAccessors<'tcx>> QueryState<'tcx, Q> {\n }\n \n /// Indicates the state of a query for a given key in a query map.\n-pub(super) enum QueryResult<'tcx> {\n+enum QueryResult<'tcx> {\n     /// An already executing query. The query job can be used to await for its completion.\n     Started(QueryJob<'tcx>),\n \n@@ -81,25 +84,54 @@ pub(super) enum QueryResult<'tcx> {\n     Poisoned,\n }\n \n-impl<'tcx, M: QueryAccessors<'tcx>> QueryState<'tcx, M> {\n-    pub fn iter_results<R>(\n+impl<'tcx, C: QueryCache> QueryState<'tcx, C> {\n+    pub(super) fn iter_results<R>(\n         &self,\n         f: impl for<'a> FnOnce(\n-            Box<dyn Iterator<Item = (&'a M::Key, &'a M::Value, DepNodeIndex)> + 'a>,\n+            Box<dyn Iterator<Item = (&'a C::Key, &'a C::Value, DepNodeIndex)> + 'a>,\n         ) -> R,\n     ) -> R {\n         self.cache.iter(&self.shards, |shard| &mut shard.cache, f)\n     }\n-    pub fn all_inactive(&self) -> bool {\n+    pub(super) fn all_inactive(&self) -> bool {\n         let shards = self.shards.lock_shards();\n         shards.iter().all(|shard| shard.active.is_empty())\n     }\n+\n+    pub(super) fn try_collect_active_jobs(\n+        &self,\n+        kind: DepKind,\n+        make_query: fn(C::Key) -> Query<'tcx>,\n+        jobs: &mut FxHashMap<QueryJobId, QueryJobInfo<'tcx>>,\n+    ) -> Option<()>\n+    where\n+        C::Key: Clone,\n+    {\n+        // We use try_lock_shards here since we are called from the\n+        // deadlock handler, and this shouldn't be locked.\n+        let shards = self.shards.try_lock_shards()?;\n+        let shards = shards.iter().enumerate();\n+        jobs.extend(shards.flat_map(|(shard_id, shard)| {\n+            shard.active.iter().filter_map(move |(k, v)| {\n+                if let QueryResult::Started(ref job) = *v {\n+                    let id =\n+                        QueryJobId { job: job.id, shard: u16::try_from(shard_id).unwrap(), kind };\n+                    let info = QueryInfo { span: job.span, query: make_query(k.clone()) };\n+                    Some((id, QueryJobInfo { info, job: job.clone() }))\n+                } else {\n+                    None\n+                }\n+            })\n+        }));\n+\n+        Some(())\n+    }\n }\n \n-impl<'tcx, M: QueryAccessors<'tcx>> Default for QueryState<'tcx, M> {\n-    fn default() -> QueryState<'tcx, M> {\n+impl<'tcx, C: QueryCache> Default for QueryState<'tcx, C> {\n+    fn default() -> QueryState<'tcx, C> {\n         QueryState {\n-            cache: M::Cache::default(),\n+            cache: C::default(),\n             shards: Default::default(),\n             #[cfg(debug_assertions)]\n             cache_hits: AtomicUsize::new(0),\n@@ -108,21 +140,31 @@ impl<'tcx, M: QueryAccessors<'tcx>> Default for QueryState<'tcx, M> {\n }\n \n /// Values used when checking a query cache which can be reused on a cache-miss to execute the query.\n-pub(crate) struct QueryLookup<'tcx, Q: QueryAccessors<'tcx>> {\n+pub(crate) struct QueryLookup<'tcx, K, C> {\n     pub(super) key_hash: u64,\n-    pub(super) shard: usize,\n-    pub(super) lock: LockGuard<'tcx, QueryStateShard<'tcx, Q>>,\n+    shard: usize,\n+    pub(super) lock: LockGuard<'tcx, QueryStateShard<'tcx, K, C>>,\n }\n \n /// A type representing the responsibility to execute the job in the `job` field.\n /// This will poison the relevant query if dropped.\n-pub(super) struct JobOwner<'tcx, Q: QueryDescription<'tcx>> {\n-    tcx: TyCtxt<'tcx>,\n-    key: Q::Key,\n+struct JobOwner<'tcx, C>\n+where\n+    C: QueryCache,\n+    C::Key: Eq + Hash + Clone + Debug,\n+    C::Value: Clone,\n+{\n+    state: &'tcx QueryState<'tcx, C>,\n+    key: C::Key,\n     id: QueryJobId,\n }\n \n-impl<'tcx, Q: QueryDescription<'tcx>> JobOwner<'tcx, Q> {\n+impl<'tcx, C: QueryCache> JobOwner<'tcx, C>\n+where\n+    C: QueryCache,\n+    C::Key: Eq + Hash + Clone + Debug,\n+    C::Value: Clone,\n+{\n     /// Either gets a `JobOwner` corresponding the query, allowing us to\n     /// start executing the query, or returns with the result of the query.\n     /// This function assumes that `try_get_cached` is already called and returned `lookup`.\n@@ -132,12 +174,15 @@ impl<'tcx, Q: QueryDescription<'tcx>> JobOwner<'tcx, Q> {\n     /// This function is inlined because that results in a noticeable speed-up\n     /// for some compile-time benchmarks.\n     #[inline(always)]\n-    pub(super) fn try_start(\n+    fn try_start<Q>(\n         tcx: TyCtxt<'tcx>,\n         span: Span,\n-        key: &Q::Key,\n-        mut lookup: QueryLookup<'tcx, Q>,\n-    ) -> TryGetJob<'tcx, Q> {\n+        key: &C::Key,\n+        mut lookup: QueryLookup<'tcx, C::Key, C::Sharded>,\n+    ) -> TryGetJob<'tcx, C>\n+    where\n+        Q: QueryDescription<'tcx, Key = C::Key, Value = C::Value, Cache = C>,\n+    {\n         let lock = &mut *lookup.lock;\n \n         let (latch, mut _query_blocked_prof_timer) = match lock.active.entry((*key).clone()) {\n@@ -154,7 +199,7 @@ impl<'tcx, Q: QueryDescription<'tcx>> JobOwner<'tcx, Q> {\n                         };\n \n                         // Create the id of the job we're waiting for\n-                        let id = QueryJobId::new(job.id, lookup.shard, Q::dep_kind());\n+                        let id = QueryJobId::new(job.id, lookup.shard, Q::DEP_KIND);\n \n                         (job.latch(id), _query_blocked_prof_timer)\n                     }\n@@ -169,13 +214,14 @@ impl<'tcx, Q: QueryDescription<'tcx>> JobOwner<'tcx, Q> {\n                 lock.jobs = id;\n                 let id = QueryShardJobId(NonZeroU32::new(id).unwrap());\n \n-                let global_id = QueryJobId::new(id, lookup.shard, Q::dep_kind());\n+                let global_id = QueryJobId::new(id, lookup.shard, Q::DEP_KIND);\n \n                 let job = tls::with_related_context(tcx, |icx| QueryJob::new(id, span, icx.query));\n \n                 entry.insert(QueryResult::Started(job));\n \n-                let owner = JobOwner { tcx, id: global_id, key: (*key).clone() };\n+                let owner =\n+                    JobOwner { state: Q::query_state(tcx), id: global_id, key: (*key).clone() };\n                 return TryGetJob::NotYetStarted(owner);\n             }\n         };\n@@ -198,7 +244,8 @@ impl<'tcx, Q: QueryDescription<'tcx>> JobOwner<'tcx, Q> {\n                 return TryGetJob::Cycle(Q::handle_cycle_error(tcx, cycle));\n             }\n \n-            let cached = tcx.try_get_cached::<Q, _, _, _>(\n+            let cached = tcx.try_get_cached(\n+                Q::query_state(tcx),\n                 (*key).clone(),\n                 |value, index| (value.clone(), index),\n                 |_, _| panic!(\"value must be in cache after waiting\"),\n@@ -215,16 +262,15 @@ impl<'tcx, Q: QueryDescription<'tcx>> JobOwner<'tcx, Q> {\n     /// Completes the query by updating the query cache with the `result`,\n     /// signals the waiter and forgets the JobOwner, so it won't poison the query\n     #[inline(always)]\n-    pub(super) fn complete(self, result: &Q::Value, dep_node_index: DepNodeIndex) {\n+    fn complete(self, tcx: TyCtxt<'tcx>, result: &C::Value, dep_node_index: DepNodeIndex) {\n         // We can move out of `self` here because we `mem::forget` it below\n         let key = unsafe { ptr::read(&self.key) };\n-        let tcx = self.tcx;\n+        let state = self.state;\n \n         // Forget ourself so our destructor won't poison the query\n         mem::forget(self);\n \n         let job = {\n-            let state = Q::query_state(tcx);\n             let result = result.clone();\n             let mut lock = state.shards.get_shard_by_value(&key).lock();\n             let job = match lock.active.remove(&key).unwrap() {\n@@ -249,12 +295,16 @@ where\n     (result, diagnostics.into_inner())\n }\n \n-impl<'tcx, Q: QueryDescription<'tcx>> Drop for JobOwner<'tcx, Q> {\n+impl<'tcx, C: QueryCache> Drop for JobOwner<'tcx, C>\n+where\n+    C::Key: Eq + Hash + Clone + Debug,\n+    C::Value: Clone,\n+{\n     #[inline(never)]\n     #[cold]\n     fn drop(&mut self) {\n         // Poison the query so jobs waiting on it panic.\n-        let state = Q::query_state(self.tcx);\n+        let state = self.state;\n         let shard = state.shards.get_shard_by_value(&self.key);\n         let job = {\n             let mut shard = shard.lock();\n@@ -272,33 +322,37 @@ impl<'tcx, Q: QueryDescription<'tcx>> Drop for JobOwner<'tcx, Q> {\n }\n \n #[derive(Clone)]\n-pub struct CycleError<'tcx> {\n+pub(crate) struct CycleError<'tcx> {\n     /// The query and related span that uses the cycle.\n     pub(super) usage: Option<(Span, Query<'tcx>)>,\n     pub(super) cycle: Vec<QueryInfo<'tcx>>,\n }\n \n /// The result of `try_start`.\n-pub(super) enum TryGetJob<'tcx, D: QueryDescription<'tcx>> {\n+enum TryGetJob<'tcx, C: QueryCache>\n+where\n+    C::Key: Eq + Hash + Clone + Debug,\n+    C::Value: Clone,\n+{\n     /// The query is not yet started. Contains a guard to the cache eventually used to start it.\n-    NotYetStarted(JobOwner<'tcx, D>),\n+    NotYetStarted(JobOwner<'tcx, C>),\n \n     /// The query was already completed.\n     /// Returns the result of the query and its dep-node index\n     /// if it succeeded or a cycle error if it failed.\n     #[cfg(parallel_compiler)]\n-    JobCompleted((D::Value, DepNodeIndex)),\n+    JobCompleted((C::Value, DepNodeIndex)),\n \n     /// Trying to execute the query resulted in a cycle.\n-    Cycle(D::Value),\n+    Cycle(C::Value),\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n     /// Executes a job by changing the `ImplicitCtxt` to point to the\n     /// new query job while it executes. It returns the diagnostics\n     /// captured during execution and the actual result.\n     #[inline(always)]\n-    pub(super) fn start_query<F, R>(\n+    fn start_query<F, R>(\n         self,\n         token: QueryJobId,\n         diagnostics: Option<&Lock<ThinVec<Diagnostic>>>,\n@@ -419,23 +473,22 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// which will be used if the query is not in the cache and we need\n     /// to compute it.\n     #[inline(always)]\n-    fn try_get_cached<Q, R, OnHit, OnMiss>(\n+    fn try_get_cached<C, R, OnHit, OnMiss>(\n         self,\n-        key: Q::Key,\n+        state: &'tcx QueryState<'tcx, C>,\n+        key: C::Key,\n         // `on_hit` can be called while holding a lock to the query cache\n         on_hit: OnHit,\n         on_miss: OnMiss,\n     ) -> R\n     where\n-        Q: QueryDescription<'tcx> + 'tcx,\n-        OnHit: FnOnce(&Q::Value, DepNodeIndex) -> R,\n-        OnMiss: FnOnce(Q::Key, QueryLookup<'tcx, Q>) -> R,\n+        C: QueryCache,\n+        OnHit: FnOnce(&C::Value, DepNodeIndex) -> R,\n+        OnMiss: FnOnce(C::Key, QueryLookup<'tcx, C::Key, C::Sharded>) -> R,\n     {\n-        let state = Q::query_state(self);\n-\n         state.cache.lookup(\n             state,\n-            QueryStateShard::<Q>::get_cache,\n+            QueryStateShard::<C::Key, C::Sharded>::get_cache,\n             key,\n             |value, index| {\n                 if unlikely!(self.prof.enabled()) {\n@@ -459,7 +512,8 @@ impl<'tcx> TyCtxt<'tcx> {\n     ) -> Q::Value {\n         debug!(\"ty::query::get_query<{}>(key={:?}, span={:?})\", Q::NAME, key, span);\n \n-        self.try_get_cached::<Q, _, _, _>(\n+        self.try_get_cached(\n+            Q::query_state(self),\n             key,\n             |value, index| {\n                 self.dep_graph.read_index(index);\n@@ -470,13 +524,13 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     #[inline(always)]\n-    pub(super) fn try_execute_query<Q: QueryDescription<'tcx>>(\n+    fn try_execute_query<Q: QueryDescription<'tcx> + 'tcx>(\n         self,\n         span: Span,\n         key: Q::Key,\n-        lookup: QueryLookup<'tcx, Q>,\n+        lookup: QueryLookup<'tcx, Q::Key, <Q::Cache as QueryCache>::Sharded>,\n     ) -> Q::Value {\n-        let job = match JobOwner::try_start(self, span, &key, lookup) {\n+        let job = match JobOwner::try_start::<Q>(self, span, &key, lookup) {\n             TryGetJob::NotYetStarted(job) => job,\n             TryGetJob::Cycle(result) => return result,\n             #[cfg(parallel_compiler)]\n@@ -498,7 +552,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n             let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n                 self.start_query(job.id, diagnostics, |tcx| {\n-                    tcx.dep_graph.with_anon_task(Q::dep_kind(), || Q::compute(tcx, key))\n+                    tcx.dep_graph.with_anon_task(Q::DEP_KIND, || Q::compute(tcx, key))\n                 })\n             });\n \n@@ -512,7 +566,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                     .store_diagnostics_for_anon_node(dep_node_index, diagnostics);\n             }\n \n-            job.complete(&result, dep_node_index);\n+            job.complete(self, &result, dep_node_index);\n \n             return result;\n         }\n@@ -538,7 +592,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 })\n             });\n             if let Some((result, dep_node_index)) = loaded {\n-                job.complete(&result, dep_node_index);\n+                job.complete(self, &result, dep_node_index);\n                 return result;\n             }\n         }\n@@ -634,10 +688,10 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     #[inline(always)]\n-    fn force_query_with_job<Q: QueryDescription<'tcx>>(\n+    fn force_query_with_job<Q: QueryDescription<'tcx> + 'tcx>(\n         self,\n         key: Q::Key,\n-        job: JobOwner<'tcx, Q>,\n+        job: JobOwner<'tcx, Q::Cache>,\n         dep_node: DepNode,\n     ) -> (Q::Value, DepNodeIndex) {\n         // If the following assertion triggers, it can have two reasons:\n@@ -680,7 +734,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             }\n         }\n \n-        job.complete(&result, dep_node_index);\n+        job.complete(self, &result, dep_node_index);\n \n         (result, dep_node_index)\n     }\n@@ -729,13 +783,14 @@ impl<'tcx> TyCtxt<'tcx> {\n         // We may be concurrently trying both execute and force a query.\n         // Ensure that only one of them runs the query.\n \n-        self.try_get_cached::<Q, _, _, _>(\n+        self.try_get_cached(\n+            Q::query_state(self),\n             key,\n             |_, _| {\n                 // Cache hit, do nothing\n             },\n             |key, lookup| {\n-                let job = match JobOwner::try_start(self, span, &key, lookup) {\n+                let job = match JobOwner::try_start::<Q>(self, span, &key, lookup) {\n                     TryGetJob::NotYetStarted(job) => job,\n                     TryGetJob::Cycle(_) => return,\n                     #[cfg(parallel_compiler)]\n@@ -842,55 +897,6 @@ macro_rules! define_queries_inner {\n             input: ($(([$($modifiers)*] [$($attr)*] [$name]))*)\n         }\n \n-        impl<$tcx> Queries<$tcx> {\n-            pub fn new(\n-                providers: IndexVec<CrateNum, Providers<$tcx>>,\n-                fallback_extern_providers: Providers<$tcx>,\n-                on_disk_cache: OnDiskCache<'tcx>,\n-            ) -> Self {\n-                Queries {\n-                    providers,\n-                    fallback_extern_providers: Box::new(fallback_extern_providers),\n-                    on_disk_cache,\n-                    $($name: Default::default()),*\n-                }\n-            }\n-\n-            pub fn try_collect_active_jobs(\n-                &self\n-            ) -> Option<FxHashMap<QueryJobId, QueryJobInfo<'tcx>>> {\n-                let mut jobs = FxHashMap::default();\n-\n-                $(\n-                    // We use try_lock_shards here since we are called from the\n-                    // deadlock handler, and this shouldn't be locked.\n-                    let shards = self.$name.shards.try_lock_shards()?;\n-                    let shards = shards.iter().enumerate();\n-                    jobs.extend(shards.flat_map(|(shard_id, shard)| {\n-                        shard.active.iter().filter_map(move |(k, v)| {\n-                        if let QueryResult::Started(ref job) = *v {\n-                                let id = QueryJobId {\n-                                    job: job.id,\n-                                    shard:  u16::try_from(shard_id).unwrap(),\n-                                    kind:\n-                                        <queries::$name<'tcx> as QueryAccessors<'tcx>>::dep_kind(),\n-                                };\n-                                let info = QueryInfo {\n-                                    span: job.span,\n-                                    query: queries::$name::query(k.clone())\n-                                };\n-                                Some((id, QueryJobInfo { info,  job: job.clone() }))\n-                        } else {\n-                            None\n-                        }\n-                        })\n-                    }));\n-                )*\n-\n-                Some(jobs)\n-            }\n-        }\n-\n         #[allow(nonstandard_style)]\n         #[derive(Clone, Debug)]\n         pub enum Query<$tcx> {\n@@ -951,16 +957,6 @@ macro_rules! define_queries_inner {\n             })*\n         }\n \n-        // This module and the functions in it exist only to provide a\n-        // predictable symbol name prefix for query providers. This is helpful\n-        // for analyzing queries in profilers.\n-        pub(super) mod __query_compute {\n-            $(#[inline(never)]\n-            pub fn $name<F: FnOnce() -> R, R>(f: F) -> R {\n-                f()\n-            })*\n-        }\n-\n         $(impl<$tcx> QueryConfig<$tcx> for queries::$name<$tcx> {\n             type Key = $K;\n             type Value = $V;\n@@ -971,16 +967,12 @@ macro_rules! define_queries_inner {\n         impl<$tcx> QueryAccessors<$tcx> for queries::$name<$tcx> {\n             const ANON: bool = is_anon!([$($modifiers)*]);\n             const EVAL_ALWAYS: bool = is_eval_always!([$($modifiers)*]);\n+            const DEP_KIND: dep_graph::DepKind = dep_graph::DepKind::$node;\n \n             type Cache = query_storage!([$($modifiers)*][$K, $V]);\n \n             #[inline(always)]\n-            fn query(key: Self::Key) -> Query<'tcx> {\n-                Query::$name(key)\n-            }\n-\n-            #[inline(always)]\n-            fn query_state<'a>(tcx: TyCtxt<$tcx>) -> &'a QueryState<$tcx, Self> {\n+            fn query_state<'a>(tcx: TyCtxt<$tcx>) -> &'a QueryState<$tcx, Self::Cache> {\n                 &tcx.queries.$name\n             }\n \n@@ -990,23 +982,16 @@ macro_rules! define_queries_inner {\n                 DepConstructor::$node(tcx, *key)\n             }\n \n-            #[inline(always)]\n-            fn dep_kind() -> dep_graph::DepKind {\n-                dep_graph::DepKind::$node\n-            }\n-\n             #[inline]\n             fn compute(tcx: TyCtxt<'tcx>, key: Self::Key) -> Self::Value {\n-                __query_compute::$name(move || {\n-                    let provider = tcx.queries.providers.get(key.query_crate())\n-                        // HACK(eddyb) it's possible crates may be loaded after\n-                        // the query engine is created, and because crate loading\n-                        // is not yet integrated with the query engine, such crates\n-                        // would be missing appropriate entries in `providers`.\n-                        .unwrap_or(&tcx.queries.fallback_extern_providers)\n-                        .$name;\n-                    provider(tcx, key)\n-                })\n+                let provider = tcx.queries.providers.get(key.query_crate())\n+                    // HACK(eddyb) it's possible crates may be loaded after\n+                    // the query engine is created, and because crate loading\n+                    // is not yet integrated with the query engine, such crates\n+                    // would be missing appropriate entries in `providers`.\n+                    .unwrap_or(&tcx.queries.fallback_extern_providers)\n+                    .$name;\n+                provider(tcx, key)\n             }\n \n             fn hash_result(\n@@ -1139,7 +1124,41 @@ macro_rules! define_queries_struct {\n             providers: IndexVec<CrateNum, Providers<$tcx>>,\n             fallback_extern_providers: Box<Providers<$tcx>>,\n \n-            $($(#[$attr])*  $name: QueryState<$tcx, queries::$name<$tcx>>,)*\n+            $($(#[$attr])*  $name: QueryState<\n+                $tcx,\n+                <queries::$name<$tcx> as QueryAccessors<'tcx>>::Cache,\n+            >,)*\n+        }\n+\n+        impl<$tcx> Queries<$tcx> {\n+            pub(crate) fn new(\n+                providers: IndexVec<CrateNum, Providers<$tcx>>,\n+                fallback_extern_providers: Providers<$tcx>,\n+                on_disk_cache: OnDiskCache<'tcx>,\n+            ) -> Self {\n+                Queries {\n+                    providers,\n+                    fallback_extern_providers: Box::new(fallback_extern_providers),\n+                    on_disk_cache,\n+                    $($name: Default::default()),*\n+                }\n+            }\n+\n+            pub(crate) fn try_collect_active_jobs(\n+                &self\n+            ) -> Option<FxHashMap<QueryJobId, QueryJobInfo<'tcx>>> {\n+                let mut jobs = FxHashMap::default();\n+\n+                $(\n+                    self.$name.try_collect_active_jobs(\n+                        <queries::$name<'tcx> as QueryAccessors<'tcx>>::DEP_KIND,\n+                        Query::$name,\n+                        &mut jobs,\n+                    )?;\n+                )*\n+\n+                Some(jobs)\n+            }\n         }\n     };\n }"}, {"sha": "58ace917786cf15d70342ddea66c30ee596c65dd", "filename": "src/librustc/ty/query/profiling_support.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc%2Fty%2Fquery%2Fprofiling_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc%2Fty%2Fquery%2Fprofiling_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fprofiling_support.rs?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -1,6 +1,6 @@\n use crate::hir::map::definitions::DefPathData;\n use crate::ty::context::TyCtxt;\n-use crate::ty::query::config::QueryAccessors;\n+use crate::ty::query::caches::QueryCache;\n use crate::ty::query::plumbing::QueryState;\n use measureme::{StringComponent, StringId};\n use rustc_data_structures::fx::FxHashMap;\n@@ -157,13 +157,14 @@ where\n /// Allocate the self-profiling query strings for a single query cache. This\n /// method is called from `alloc_self_profile_query_strings` which knows all\n /// the queries via macro magic.\n-pub(super) fn alloc_self_profile_query_strings_for_query_cache<'tcx, Q>(\n+pub(super) fn alloc_self_profile_query_strings_for_query_cache<'tcx, C>(\n     tcx: TyCtxt<'tcx>,\n     query_name: &'static str,\n-    query_state: &QueryState<'tcx, Q>,\n+    query_state: &QueryState<'tcx, C>,\n     string_cache: &mut QueryKeyStringCache,\n ) where\n-    Q: QueryAccessors<'tcx>,\n+    C: QueryCache,\n+    C::Key: Debug + Clone,\n {\n     tcx.prof.with_profiler(|profiler| {\n         let event_id_builder = profiler.event_id_builder();"}, {"sha": "527bb46c908882ff6d387558b083a267a353a533", "filename": "src/librustc/ty/query/stats.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc%2Fty%2Fquery%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc%2Fty%2Fquery%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fstats.rs?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -1,3 +1,4 @@\n+use crate::ty::query::caches::QueryCache;\n use crate::ty::query::config::QueryAccessors;\n use crate::ty::query::plumbing::QueryState;\n use crate::ty::query::queries;\n@@ -37,20 +38,17 @@ struct QueryStats {\n     local_def_id_keys: Option<usize>,\n }\n \n-fn stats<'tcx, Q: QueryAccessors<'tcx>>(\n-    name: &'static str,\n-    map: &QueryState<'tcx, Q>,\n-) -> QueryStats {\n+fn stats<'tcx, C: QueryCache>(name: &'static str, map: &QueryState<'tcx, C>) -> QueryStats {\n     let mut stats = QueryStats {\n         name,\n         #[cfg(debug_assertions)]\n         cache_hits: map.cache_hits.load(Ordering::Relaxed),\n         #[cfg(not(debug_assertions))]\n         cache_hits: 0,\n-        key_size: mem::size_of::<Q::Key>(),\n-        key_type: type_name::<Q::Key>(),\n-        value_size: mem::size_of::<Q::Value>(),\n-        value_type: type_name::<Q::Value>(),\n+        key_size: mem::size_of::<C::Key>(),\n+        key_type: type_name::<C::Key>(),\n+        value_size: mem::size_of::<C::Value>(),\n+        value_type: type_name::<C::Value>(),\n         entry_count: map.iter_results(|results| results.count()),\n         local_def_id_keys: None,\n     };\n@@ -125,7 +123,9 @@ macro_rules! print_stats {\n             let mut queries = Vec::new();\n \n             $($(\n-                queries.push(stats::<queries::$name<'_>>(\n+                queries.push(stats::<\n+                    <queries::$name<'_> as QueryAccessors<'_>>::Cache,\n+                >(\n                     stringify!($name),\n                     &tcx.queries.$name,\n                 ));"}, {"sha": "b4363778094b4ceedda02d39e2c7f1d77a444f97", "filename": "src/librustc_ast_passes/ast_validation.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc_ast_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc_ast_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Fast_validation.rs?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -645,6 +645,8 @@ impl<'a> AstValidator<'a> {\n     }\n }\n \n+/// Checks that generic parameters are in the correct order,\n+/// which is lifetimes, then types and then consts. (`<'a, T, const N: usize>`)\n fn validate_generic_param_order<'a>(\n     sess: &Session,\n     handler: &rustc_errors::Handler,"}, {"sha": "0fc477bbd0b4c95507287785357dc4b451584d71", "filename": "src/librustc_expand/base.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc_expand%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc_expand%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbase.rs?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -922,6 +922,7 @@ pub struct ExpansionData {\n pub struct ExtCtxt<'a> {\n     pub parse_sess: &'a ParseSess,\n     pub ecfg: expand::ExpansionConfig<'a>,\n+    pub reduced_recursion_limit: Option<usize>,\n     pub root_path: PathBuf,\n     pub resolver: &'a mut dyn Resolver,\n     pub current_expansion: ExpansionData,\n@@ -940,6 +941,7 @@ impl<'a> ExtCtxt<'a> {\n         ExtCtxt {\n             parse_sess,\n             ecfg,\n+            reduced_recursion_limit: None,\n             resolver,\n             extern_mod_loaded,\n             root_path: PathBuf::new(),"}, {"sha": "4f568e5456c725b3bed8d19ef0d1c3f469a71bdb", "filename": "src/librustc_expand/expand.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc_expand%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc_expand%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fexpand.rs?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -17,7 +17,7 @@ use rustc_ast::util::map_in_place::MapInPlace;\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n use rustc_ast_pretty::pprust;\n use rustc_attr::{self as attr, is_builtin_attr, HasAttrs};\n-use rustc_errors::{Applicability, FatalError, PResult};\n+use rustc_errors::{Applicability, PResult};\n use rustc_feature::Features;\n use rustc_parse::parser::Parser;\n use rustc_parse::validate_attr;\n@@ -645,7 +645,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             ))\n             .emit();\n         self.cx.trace_macros_diag();\n-        FatalError.raise();\n     }\n \n     /// A macro's expansion does not fit in this fragment kind.\n@@ -665,8 +664,17 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         invoc: Invocation,\n         ext: &SyntaxExtensionKind,\n     ) -> ExpandResult<AstFragment, Invocation> {\n-        if self.cx.current_expansion.depth > self.cx.ecfg.recursion_limit {\n-            self.error_recursion_limit_reached();\n+        let recursion_limit =\n+            self.cx.reduced_recursion_limit.unwrap_or(self.cx.ecfg.recursion_limit);\n+        if self.cx.current_expansion.depth > recursion_limit {\n+            if self.cx.reduced_recursion_limit.is_none() {\n+                self.error_recursion_limit_reached();\n+            }\n+\n+            // Reduce the recursion limit by half each time it triggers.\n+            self.cx.reduced_recursion_limit = Some(recursion_limit / 2);\n+\n+            return ExpandResult::Ready(invoc.fragment_kind.dummy(invoc.span()));\n         }\n \n         let (fragment_kind, span) = (invoc.fragment_kind, invoc.span());"}, {"sha": "78f97c40cbd1277f3c9a1af4466b63e3231e755a", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -1784,11 +1784,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         // suggest adding an explicit lifetime bound to it.\n         let type_param_span = match (self.in_progress_tables, bound_kind) {\n             (Some(ref table), GenericKind::Param(ref param)) => {\n-                let table = table.borrow();\n-                table.local_id_root.and_then(|did| {\n-                    let generics = self.tcx.generics_of(did);\n-                    // Account for the case where `did` corresponds to `Self`, which doesn't have\n-                    // the expected type argument.\n+                let table_owner = table.borrow().hir_owner;\n+                table_owner.and_then(|table_owner| {\n+                    let generics = self.tcx.generics_of(table_owner.to_def_id());\n+                    // Account for the case where `param` corresponds to `Self`,\n+                    // which doesn't have the expected type argument.\n                     if !(generics.has_self && param.index == 0) {\n                         let type_param = generics.type_param(param, self.tcx);\n                         let hir = &self.tcx.hir();"}, {"sha": "fbacc31b1178c2e1ecd27350b795a234848f73d1", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -29,7 +29,7 @@ use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::unify as ut;\n use rustc_errors::DiagnosticBuilder;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_session::config::BorrowckMode;\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n@@ -559,7 +559,7 @@ impl TyCtxtInferExt<'tcx> for TyCtxt<'tcx> {\n impl<'tcx> InferCtxtBuilder<'tcx> {\n     /// Used only by `rustc_typeck` during body type-checking/inference,\n     /// will initialize `in_progress_tables` with fresh `TypeckTables`.\n-    pub fn with_fresh_in_progress_tables(mut self, table_owner: DefId) -> Self {\n+    pub fn with_fresh_in_progress_tables(mut self, table_owner: LocalDefId) -> Self {\n         self.fresh_tables = Some(RefCell::new(ty::TypeckTables::empty(Some(table_owner))));\n         self\n     }"}, {"sha": "8d9e287cdc9d69329166e5a6865fb0e0b26d728b", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -312,6 +312,8 @@ fn configure_and_expand_inner<'a>(\n             ecx.parse_sess.missing_fragment_specifiers.borrow().iter().cloned().collect();\n         missing_fragment_specifiers.sort();\n \n+        let recursion_limit_hit = ecx.reduced_recursion_limit.is_some();\n+\n         for span in missing_fragment_specifiers {\n             let lint = lint::builtin::MISSING_FRAGMENT_SPECIFIER;\n             let msg = \"missing fragment specifier\";\n@@ -320,8 +322,15 @@ fn configure_and_expand_inner<'a>(\n         if cfg!(windows) {\n             env::set_var(\"PATH\", &old_path);\n         }\n-        krate\n-    });\n+\n+        if recursion_limit_hit {\n+            // If we hit a recursion limit, exit early to avoid later passes getting overwhelmed\n+            // with a large AST\n+            Err(ErrorReported)\n+        } else {\n+            Ok(krate)\n+        }\n+    })?;\n \n     sess.time(\"maybe_building_test_harness\", || {\n         rustc_builtin_macros::test_harness::inject("}, {"sha": "9d8b1422bdf2469bc0910ee7bf3ce9d395dd0b69", "filename": "src/librustc_passes/layout_test.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc_passes%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc_passes%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flayout_test.rs?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -17,32 +17,38 @@ use rustc_span::symbol::sym;\n pub fn test_layout(tcx: TyCtxt<'_>) {\n     if tcx.features().rustc_attrs {\n         // if the `rustc_attrs` feature is not enabled, don't bother testing layout\n-        tcx.hir().krate().visit_all_item_likes(&mut VarianceTest { tcx });\n+        tcx.hir().krate().visit_all_item_likes(&mut LayoutTest { tcx });\n     }\n }\n \n-struct VarianceTest<'tcx> {\n+struct LayoutTest<'tcx> {\n     tcx: TyCtxt<'tcx>,\n }\n \n-impl ItemLikeVisitor<'tcx> for VarianceTest<'tcx> {\n+impl ItemLikeVisitor<'tcx> for LayoutTest<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         let item_def_id = self.tcx.hir().local_def_id(item.hir_id);\n \n-        if let ItemKind::TyAlias(..) = item.kind {\n-            for attr in self.tcx.get_attrs(item_def_id).iter() {\n-                if attr.check_name(sym::rustc_layout) {\n-                    self.dump_layout_of(item_def_id, item, attr);\n+        match item.kind {\n+            ItemKind::TyAlias(..)\n+            | ItemKind::Enum(..)\n+            | ItemKind::Struct(..)\n+            | ItemKind::Union(..) => {\n+                for attr in self.tcx.get_attrs(item_def_id).iter() {\n+                    if attr.check_name(sym::rustc_layout) {\n+                        self.dump_layout_of(item_def_id, item, attr);\n+                    }\n                 }\n             }\n+            _ => {}\n         }\n     }\n \n     fn visit_trait_item(&mut self, _: &'tcx hir::TraitItem<'tcx>) {}\n     fn visit_impl_item(&mut self, _: &'tcx hir::ImplItem<'tcx>) {}\n }\n \n-impl VarianceTest<'tcx> {\n+impl LayoutTest<'tcx> {\n     fn dump_layout_of(&self, item_def_id: DefId, item: &hir::Item<'tcx>, attr: &Attribute) {\n         let tcx = self.tcx;\n         let param_env = self.tcx.param_env(item_def_id);\n@@ -81,6 +87,13 @@ impl VarianceTest<'tcx> {\n                             );\n                         }\n \n+                        sym::debug => {\n+                            self.tcx.sess.span_err(\n+                                item.span,\n+                                &format!(\"layout debugging: {:#?}\", *ty_layout),\n+                            );\n+                        }\n+\n                         name => {\n                             self.tcx.sess.span_err(\n                                 meta_item.span(),"}, {"sha": "dcb4e849a75e8f34be5a7d592347117391a76ddf", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -253,6 +253,7 @@ symbols! {\n         debug_trait,\n         declare_lint_pass,\n         decl_macro,\n+        debug,\n         Debug,\n         Decodable,\n         Default,"}, {"sha": "40eb893e6daa85e3d0ef353a27da5d333e1881d7", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -1105,15 +1105,15 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let generator_did_root = self.tcx.closure_base_def_id(generator_did);\n         debug!(\n             \"maybe_note_obligation_cause_for_async_await: generator_did={:?} \\\n-             generator_did_root={:?} in_progress_tables.local_id_root={:?} span={:?}\",\n+             generator_did_root={:?} in_progress_tables.hir_owner={:?} span={:?}\",\n             generator_did,\n             generator_did_root,\n-            in_progress_tables.as_ref().map(|t| t.local_id_root),\n+            in_progress_tables.as_ref().map(|t| t.hir_owner),\n             span\n         );\n         let query_tables;\n         let tables: &TypeckTables<'tcx> = match &in_progress_tables {\n-            Some(t) if t.local_id_root == Some(generator_did_root) => t,\n+            Some(t) if t.hir_owner.map(|owner| owner.to_def_id()) == Some(generator_did_root) => t,\n             _ => {\n                 query_tables = self.tcx.typeck_tables_of(generator_did);\n                 &query_tables"}, {"sha": "6178158e4e504c7555c256fdcf004a118fd916d0", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -213,7 +213,7 @@ fn compare_predicate_entailment<'tcx>(\n     );\n \n     tcx.infer_ctxt().enter(|infcx| {\n-        let inh = Inherited::new(infcx, impl_m.def_id);\n+        let inh = Inherited::new(infcx, impl_m.def_id.expect_local());\n         let infcx = &inh.infcx;\n \n         debug!(\"compare_impl_method: caller_bounds={:?}\", param_env.caller_bounds);\n@@ -950,7 +950,7 @@ crate fn compare_const_impl<'tcx>(\n \n     tcx.infer_ctxt().enter(|infcx| {\n         let param_env = tcx.param_env(impl_c.def_id);\n-        let inh = Inherited::new(infcx, impl_c.def_id);\n+        let inh = Inherited::new(infcx, impl_c.def_id.expect_local());\n         let infcx = &inh.infcx;\n \n         // The below is for the most part highly similar to the procedure\n@@ -1130,7 +1130,7 @@ fn compare_type_predicate_entailment(\n         normalize_cause.clone(),\n     );\n     tcx.infer_ctxt().enter(|infcx| {\n-        let inh = Inherited::new(infcx, impl_ty.def_id);\n+        let inh = Inherited::new(infcx, impl_ty.def_id.expect_local());\n         let infcx = &inh.infcx;\n \n         debug!(\"compare_type_predicate_entailment: caller_bounds={:?}\", param_env.caller_bounds);"}, {"sha": "061433bcf6515749cc7305a2e66dddc98de03012", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -1018,9 +1018,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Obtain the span for `param` and use it for a structured suggestion.\n             let mut suggested = false;\n             if let (Some(ref param), Some(ref table)) = (param_type, self.in_progress_tables) {\n-                let table = table.borrow();\n-                if let Some(did) = table.local_id_root {\n-                    let generics = self.tcx.generics_of(did);\n+                let table_owner = table.borrow().hir_owner;\n+                if let Some(table_owner) = table_owner {\n+                    let generics = self.tcx.generics_of(table_owner.to_def_id());\n                     let type_param = generics.type_param(param, self.tcx);\n                     let hir = &self.tcx.hir();\n                     if let Some(id) = hir.as_local_hir_id(type_param.def_id) {"}, {"sha": "e4bd42f61c32129bd5c385fe5676979f02afbe0f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -112,7 +112,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder, DiagnosticId};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n-use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, LocalDefId, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::{ExprKind, GenericArg, HirIdMap, Item, ItemKind, Node, PatKind, QPath};\n@@ -633,19 +633,15 @@ impl<'a, 'tcx> Deref for FnCtxt<'a, 'tcx> {\n /// `F: for<'b, 'tcx> where 'tcx FnOnce(Inherited<'b, 'tcx>)`.\n pub struct InheritedBuilder<'tcx> {\n     infcx: infer::InferCtxtBuilder<'tcx>,\n-    def_id: DefId,\n+    def_id: LocalDefId,\n }\n \n impl Inherited<'_, 'tcx> {\n-    pub fn build(tcx: TyCtxt<'tcx>, def_id: DefId) -> InheritedBuilder<'tcx> {\n-        let hir_id_root = if let Some(def_id) = def_id.as_local() {\n-            tcx.hir().local_def_id_to_hir_id(def_id).owner.to_def_id()\n-        } else {\n-            def_id\n-        };\n+    pub fn build(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> InheritedBuilder<'tcx> {\n+        let hir_owner = tcx.hir().local_def_id_to_hir_id(def_id).owner;\n \n         InheritedBuilder {\n-            infcx: tcx.infer_ctxt().with_fresh_in_progress_tables(hir_id_root),\n+            infcx: tcx.infer_ctxt().with_fresh_in_progress_tables(hir_owner),\n             def_id,\n         }\n     }\n@@ -662,10 +658,10 @@ impl<'tcx> InheritedBuilder<'tcx> {\n }\n \n impl Inherited<'a, 'tcx> {\n-    fn new(infcx: InferCtxt<'a, 'tcx>, def_id: DefId) -> Self {\n+    fn new(infcx: InferCtxt<'a, 'tcx>, def_id: LocalDefId) -> Self {\n         let tcx = infcx.tcx;\n-        let item_id = tcx.hir().as_local_hir_id(def_id);\n-        let body_id = item_id.and_then(|id| tcx.hir().maybe_body_owned_by(id));\n+        let item_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+        let body_id = tcx.hir().maybe_body_owned_by(item_id);\n         let implicit_region_bound = body_id.map(|body_id| {\n             let body = tcx.hir().body(body_id);\n             tcx.mk_region(ty::ReScope(region::Scope {\n@@ -1002,7 +998,7 @@ fn typeck_tables_of_with_fallback<'tcx>(\n     });\n     let body = tcx.hir().body(body_id);\n \n-    let tables = Inherited::build(tcx, def_id).enter(|inh| {\n+    let tables = Inherited::build(tcx, def_id.expect_local()).enter(|inh| {\n         let param_env = tcx.param_env(def_id);\n         let fcx = if let (Some(header), Some(decl)) = (fn_header, fn_decl) {\n             let fn_sig = if crate::collect::get_infer_ret_ty(&decl.output).is_some() {\n@@ -1127,7 +1123,7 @@ fn typeck_tables_of_with_fallback<'tcx>(\n \n     // Consistency check our TypeckTables instance can hold all ItemLocalIds\n     // it will need to hold.\n-    assert_eq!(tables.local_id_root, Some(id.owner.to_def_id()));\n+    assert_eq!(tables.hir_owner, Some(id.owner));\n \n     tables\n }"}, {"sha": "72c58af7912fba51ac76e0ecb849e6f45b9367c1", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -316,12 +316,12 @@ fn for_item<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'_>) -> CheckWfFcxBuilder<\n }\n \n fn for_id(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) -> CheckWfFcxBuilder<'_> {\n-    let def_id = tcx.hir().local_def_id(id);\n+    let def_id = tcx.hir().local_def_id(id).expect_local();\n     CheckWfFcxBuilder {\n         inherited: Inherited::build(tcx, def_id),\n         id,\n         span,\n-        param_env: tcx.param_env(def_id),\n+        param_env: tcx.param_env(def_id.to_def_id()),\n     }\n }\n "}, {"sha": "65f81ef033dd7288300b46928bb809c83d1569a8", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -111,7 +111,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n         WritebackCx {\n             fcx,\n-            tables: ty::TypeckTables::empty(Some(owner.to_def_id())),\n+            tables: ty::TypeckTables::empty(Some(owner)),\n             body,\n             rustc_dump_user_substs,\n         }\n@@ -338,19 +338,19 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n     fn visit_closures(&mut self) {\n         let fcx_tables = self.fcx.tables.borrow();\n-        debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);\n-        let common_local_id_root = fcx_tables.local_id_root.unwrap();\n+        assert_eq!(fcx_tables.hir_owner, self.tables.hir_owner);\n+        let common_hir_owner = fcx_tables.hir_owner.unwrap();\n \n         for (&id, &origin) in fcx_tables.closure_kind_origins().iter() {\n-            let hir_id = hir::HirId { owner: common_local_id_root.expect_local(), local_id: id };\n+            let hir_id = hir::HirId { owner: common_hir_owner, local_id: id };\n             self.tables.closure_kind_origins_mut().insert(hir_id, origin);\n         }\n     }\n \n     fn visit_coercion_casts(&mut self) {\n         let fcx_tables = self.fcx.tables.borrow();\n         let fcx_coercion_casts = fcx_tables.coercion_casts();\n-        debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);\n+        assert_eq!(fcx_tables.hir_owner, self.tables.hir_owner);\n \n         for local_id in fcx_coercion_casts {\n             self.tables.set_coercion_cast(*local_id);\n@@ -359,12 +359,12 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n     fn visit_user_provided_tys(&mut self) {\n         let fcx_tables = self.fcx.tables.borrow();\n-        debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);\n-        let common_local_id_root = fcx_tables.local_id_root.unwrap();\n+        assert_eq!(fcx_tables.hir_owner, self.tables.hir_owner);\n+        let common_hir_owner = fcx_tables.hir_owner.unwrap();\n \n         let mut errors_buffer = Vec::new();\n         for (&local_id, c_ty) in fcx_tables.user_provided_types().iter() {\n-            let hir_id = hir::HirId { owner: common_local_id_root.expect_local(), local_id };\n+            let hir_id = hir::HirId { owner: common_hir_owner, local_id };\n \n             if cfg!(debug_assertions) && c_ty.has_local_value() {\n                 span_bug!(hir_id.to_span(self.fcx.tcx), \"writeback: `{:?}` is a local value\", c_ty);\n@@ -397,7 +397,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n     fn visit_user_provided_sigs(&mut self) {\n         let fcx_tables = self.fcx.tables.borrow();\n-        debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);\n+        assert_eq!(fcx_tables.hir_owner, self.tables.hir_owner);\n \n         for (&def_id, c_sig) in fcx_tables.user_provided_sigs.iter() {\n             if cfg!(debug_assertions) && c_sig.has_local_value() {\n@@ -414,7 +414,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n     fn visit_generator_interior_types(&mut self) {\n         let fcx_tables = self.fcx.tables.borrow();\n-        debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);\n+        assert_eq!(fcx_tables.hir_owner, self.tables.hir_owner);\n         self.tables.generator_interior_types = fcx_tables.generator_interior_types.clone();\n     }\n \n@@ -553,23 +553,23 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n     fn visit_liberated_fn_sigs(&mut self) {\n         let fcx_tables = self.fcx.tables.borrow();\n-        debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);\n-        let common_local_id_root = fcx_tables.local_id_root.unwrap();\n+        assert_eq!(fcx_tables.hir_owner, self.tables.hir_owner);\n+        let common_hir_owner = fcx_tables.hir_owner.unwrap();\n \n         for (&local_id, fn_sig) in fcx_tables.liberated_fn_sigs().iter() {\n-            let hir_id = hir::HirId { owner: common_local_id_root.expect_local(), local_id };\n+            let hir_id = hir::HirId { owner: common_hir_owner, local_id };\n             let fn_sig = self.resolve(fn_sig, &hir_id);\n             self.tables.liberated_fn_sigs_mut().insert(hir_id, fn_sig.clone());\n         }\n     }\n \n     fn visit_fru_field_types(&mut self) {\n         let fcx_tables = self.fcx.tables.borrow();\n-        debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);\n-        let common_local_id_root = fcx_tables.local_id_root.unwrap();\n+        assert_eq!(fcx_tables.hir_owner, self.tables.hir_owner);\n+        let common_hir_owner = fcx_tables.hir_owner.unwrap();\n \n         for (&local_id, ftys) in fcx_tables.fru_field_types().iter() {\n-            let hir_id = hir::HirId { owner: common_local_id_root.expect_local(), local_id };\n+            let hir_id = hir::HirId { owner: common_hir_owner, local_id };\n             let ftys = self.resolve(ftys, &hir_id);\n             self.tables.fru_field_types_mut().insert(hir_id, ftys);\n         }"}, {"sha": "a79c065307796e9f719fd21a8129fa4917cded4b", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 57, "deletions": 37, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -1306,47 +1306,67 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n     // Now create the real type and const parameters.\n     let type_start = own_start - has_self as u32 + params.len() as u32;\n     let mut i = 0;\n-    params.extend(ast_generics.params.iter().filter_map(|param| {\n-        let kind = match param.kind {\n-            GenericParamKind::Type { ref default, synthetic, .. } => {\n-                if !allow_defaults && default.is_some() {\n-                    if !tcx.features().default_type_parameter_fallback {\n-                        tcx.struct_span_lint_hir(\n-                            lint::builtin::INVALID_TYPE_PARAM_DEFAULT,\n-                            param.hir_id,\n-                            param.span,\n-                            |lint| {\n-                                lint.build(\n-                                    \"defaults for type parameters are only allowed in \\\n-                                            `struct`, `enum`, `type`, or `trait` definitions.\",\n-                                )\n-                                .emit();\n-                            },\n-                        );\n-                    }\n-                }\n \n-                ty::GenericParamDefKind::Type {\n-                    has_default: default.is_some(),\n-                    object_lifetime_default: object_lifetime_defaults\n-                        .as_ref()\n-                        .map_or(rl::Set1::Empty, |o| o[i]),\n-                    synthetic,\n+    // FIXME(const_generics): a few places in the compiler expect generic params\n+    // to be in the order lifetimes, then type params, then const params.\n+    //\n+    // To prevent internal errors in case const parameters are supplied before\n+    // type parameters we first add all type params, then all const params.\n+    params.extend(ast_generics.params.iter().filter_map(|param| {\n+        if let GenericParamKind::Type { ref default, synthetic, .. } = param.kind {\n+            if !allow_defaults && default.is_some() {\n+                if !tcx.features().default_type_parameter_fallback {\n+                    tcx.struct_span_lint_hir(\n+                        lint::builtin::INVALID_TYPE_PARAM_DEFAULT,\n+                        param.hir_id,\n+                        param.span,\n+                        |lint| {\n+                            lint.build(\n+                                \"defaults for type parameters are only allowed in \\\n+                                        `struct`, `enum`, `type`, or `trait` definitions.\",\n+                            )\n+                            .emit();\n+                        },\n+                    );\n                 }\n             }\n-            GenericParamKind::Const { .. } => ty::GenericParamDefKind::Const,\n-            _ => return None,\n-        };\n \n-        let param_def = ty::GenericParamDef {\n-            index: type_start + i as u32,\n-            name: param.name.ident().name,\n-            def_id: tcx.hir().local_def_id(param.hir_id),\n-            pure_wrt_drop: param.pure_wrt_drop,\n-            kind,\n-        };\n-        i += 1;\n-        Some(param_def)\n+            let kind = ty::GenericParamDefKind::Type {\n+                has_default: default.is_some(),\n+                object_lifetime_default: object_lifetime_defaults\n+                    .as_ref()\n+                    .map_or(rl::Set1::Empty, |o| o[i]),\n+                synthetic,\n+            };\n+\n+            let param_def = ty::GenericParamDef {\n+                index: type_start + i as u32,\n+                name: param.name.ident().name,\n+                def_id: tcx.hir().local_def_id(param.hir_id),\n+                pure_wrt_drop: param.pure_wrt_drop,\n+                kind,\n+            };\n+            i += 1;\n+            Some(param_def)\n+        } else {\n+            None\n+        }\n+    }));\n+\n+    params.extend(ast_generics.params.iter().filter_map(|param| {\n+        if let GenericParamKind::Const { .. } = param.kind {\n+            let param_def = ty::GenericParamDef {\n+                index: type_start + i as u32,\n+                name: param.name.ident().name,\n+                def_id: tcx.hir().local_def_id(param.hir_id),\n+                pure_wrt_drop: param.pure_wrt_drop,\n+                kind: ty::GenericParamDefKind::Const,\n+            };\n+            i += 1;\n+            Some(param_def)\n+        } else {\n+            None\n+        }\n     }));\n \n     // provide junk type parameter defs - the only place that"}, {"sha": "9a82ae7626d9714094ac733402e8950284d5e983", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 31, "deletions": 18, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -6,7 +6,7 @@ use crate::cell::RefCell;\n use crate::fmt;\n use crate::io::lazy::Lazy;\n use crate::io::{self, BufReader, Initializer, IoSlice, IoSliceMut, LineWriter};\n-use crate::sync::{Arc, Mutex, MutexGuard};\n+use crate::sync::{Arc, Mutex, MutexGuard, Once};\n use crate::sys::stdio;\n use crate::sys_common::remutex::{ReentrantMutex, ReentrantMutexGuard};\n use crate::thread::LocalKey;\n@@ -493,7 +493,11 @@ pub fn stdout() -> Stdout {\n             Ok(stdout) => Maybe::Real(stdout),\n             _ => Maybe::Fake,\n         };\n-        Arc::new(ReentrantMutex::new(RefCell::new(LineWriter::new(stdout))))\n+        unsafe {\n+            let ret = Arc::new(ReentrantMutex::new(RefCell::new(LineWriter::new(stdout))));\n+            ret.init();\n+            return ret;\n+        }\n     }\n }\n \n@@ -520,7 +524,7 @@ impl Stdout {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn lock(&self) -> StdoutLock<'_> {\n-        StdoutLock { inner: self.inner.lock().unwrap_or_else(|e| e.into_inner()) }\n+        StdoutLock { inner: self.inner.lock() }\n     }\n }\n \n@@ -581,7 +585,7 @@ impl fmt::Debug for StdoutLock<'_> {\n /// an error.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Stderr {\n-    inner: Arc<ReentrantMutex<RefCell<Maybe<StderrRaw>>>>,\n+    inner: &'static ReentrantMutex<RefCell<Maybe<StderrRaw>>>,\n }\n \n /// A locked reference to the `Stderr` handle.\n@@ -639,19 +643,28 @@ pub struct StderrLock<'a> {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stderr() -> Stderr {\n-    static INSTANCE: Lazy<ReentrantMutex<RefCell<Maybe<StderrRaw>>>> = Lazy::new();\n-    return Stderr {\n-        inner: unsafe { INSTANCE.get(stderr_init).expect(\"cannot access stderr during shutdown\") },\n-    };\n-\n-    fn stderr_init() -> Arc<ReentrantMutex<RefCell<Maybe<StderrRaw>>>> {\n-        // This must not reentrantly access `INSTANCE`\n-        let stderr = match stderr_raw() {\n-            Ok(stderr) => Maybe::Real(stderr),\n-            _ => Maybe::Fake,\n-        };\n-        Arc::new(ReentrantMutex::new(RefCell::new(stderr)))\n-    }\n+    // Note that unlike `stdout()` we don't use `Lazy` here which registers a\n+    // destructor. Stderr is not buffered nor does the `stderr_raw` type consume\n+    // any owned resources, so there's no need to run any destructors at some\n+    // point in the future.\n+    //\n+    // This has the added benefit of allowing `stderr` to be usable during\n+    // process shutdown as well!\n+    static INSTANCE: ReentrantMutex<RefCell<Maybe<StderrRaw>>> =\n+        unsafe { ReentrantMutex::new(RefCell::new(Maybe::Fake)) };\n+\n+    // When accessing stderr we need one-time initialization of the reentrant\n+    // mutex, followed by one-time detection of whether we actually have a\n+    // stderr handle or not. Afterwards we can just always use the now-filled-in\n+    // `INSTANCE` value.\n+    static INIT: Once = Once::new();\n+    INIT.call_once(|| unsafe {\n+        INSTANCE.init();\n+        if let Ok(stderr) = stderr_raw() {\n+            *INSTANCE.lock().borrow_mut() = Maybe::Real(stderr);\n+        }\n+    });\n+    return Stderr { inner: &INSTANCE };\n }\n \n impl Stderr {\n@@ -677,7 +690,7 @@ impl Stderr {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn lock(&self) -> StderrLock<'_> {\n-        StderrLock { inner: self.inner.lock().unwrap_or_else(|e| e.into_inner()) }\n+        StderrLock { inner: self.inner.lock() }\n     }\n }\n "}, {"sha": "580ab0e8ad863face1a94e6243a19d72a21960fe", "filename": "src/libstd/sys/cloudabi/mutex.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibstd%2Fsys%2Fcloudabi%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibstd%2Fsys%2Fcloudabi%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fmutex.rs?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -53,16 +53,16 @@ pub struct ReentrantMutex {\n }\n \n impl ReentrantMutex {\n-    pub unsafe fn uninitialized() -> ReentrantMutex {\n+    pub const unsafe fn uninitialized() -> ReentrantMutex {\n         ReentrantMutex {\n             lock: UnsafeCell::new(MaybeUninit::uninit()),\n             recursion: UnsafeCell::new(MaybeUninit::uninit()),\n         }\n     }\n \n-    pub unsafe fn init(&mut self) {\n-        self.lock = UnsafeCell::new(MaybeUninit::new(AtomicU32::new(abi::LOCK_UNLOCKED.0)));\n-        self.recursion = UnsafeCell::new(MaybeUninit::new(0));\n+    pub unsafe fn init(&self) {\n+        *self.lock.get() = MaybeUninit::new(AtomicU32::new(abi::LOCK_UNLOCKED.0));\n+        *self.recursion.get() = MaybeUninit::new(0);\n     }\n \n     pub unsafe fn try_lock(&self) -> bool {"}, {"sha": "3d4813209cbc4d0030dca9030f28afe18e6a83e7", "filename": "src/libstd/sys/hermit/mutex.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibstd%2Fsys%2Fhermit%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibstd%2Fsys%2Fhermit%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fmutex.rs?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -46,13 +46,13 @@ pub struct ReentrantMutex {\n }\n \n impl ReentrantMutex {\n-    pub unsafe fn uninitialized() -> ReentrantMutex {\n+    pub const unsafe fn uninitialized() -> ReentrantMutex {\n         ReentrantMutex { inner: ptr::null() }\n     }\n \n     #[inline]\n-    pub unsafe fn init(&mut self) {\n-        let _ = abi::recmutex_init(&mut self.inner as *mut *const c_void);\n+    pub unsafe fn init(&self) {\n+        let _ = abi::recmutex_init(&self.inner as *const *const c_void as *mut _);\n     }\n \n     #[inline]"}, {"sha": "4911c2f5387690877a75b1e8b4d372d6cc51854f", "filename": "src/libstd/sys/sgx/mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibstd%2Fsys%2Fsgx%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibstd%2Fsys%2Fsgx%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fmutex.rs?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -75,7 +75,7 @@ impl ReentrantMutex {\n     }\n \n     #[inline]\n-    pub unsafe fn init(&mut self) {}\n+    pub unsafe fn init(&self) {}\n \n     #[inline]\n     pub unsafe fn lock(&self) {"}, {"sha": "103d87e3d2f91c075fbe8437d1496bc8620bd3db", "filename": "src/libstd/sys/unix/mutex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -92,11 +92,11 @@ unsafe impl Send for ReentrantMutex {}\n unsafe impl Sync for ReentrantMutex {}\n \n impl ReentrantMutex {\n-    pub unsafe fn uninitialized() -> ReentrantMutex {\n+    pub const unsafe fn uninitialized() -> ReentrantMutex {\n         ReentrantMutex { inner: UnsafeCell::new(libc::PTHREAD_MUTEX_INITIALIZER) }\n     }\n \n-    pub unsafe fn init(&mut self) {\n+    pub unsafe fn init(&self) {\n         let mut attr = MaybeUninit::<libc::pthread_mutexattr_t>::uninit();\n         let result = libc::pthread_mutexattr_init(attr.as_mut_ptr());\n         debug_assert_eq!(result, 0);"}, {"sha": "103d87e3d2f91c075fbe8437d1496bc8620bd3db", "filename": "src/libstd/sys/vxworks/mutex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibstd%2Fsys%2Fvxworks%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibstd%2Fsys%2Fvxworks%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fmutex.rs?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -92,11 +92,11 @@ unsafe impl Send for ReentrantMutex {}\n unsafe impl Sync for ReentrantMutex {}\n \n impl ReentrantMutex {\n-    pub unsafe fn uninitialized() -> ReentrantMutex {\n+    pub const unsafe fn uninitialized() -> ReentrantMutex {\n         ReentrantMutex { inner: UnsafeCell::new(libc::PTHREAD_MUTEX_INITIALIZER) }\n     }\n \n-    pub unsafe fn init(&mut self) {\n+    pub unsafe fn init(&self) {\n         let mut attr = MaybeUninit::<libc::pthread_mutexattr_t>::uninit();\n         let result = libc::pthread_mutexattr_init(attr.as_mut_ptr());\n         debug_assert_eq!(result, 0);"}, {"sha": "7aaf1b3a343b613637c3cb443087c8928356cc16", "filename": "src/libstd/sys/wasm/mutex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibstd%2Fsys%2Fwasm%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibstd%2Fsys%2Fwasm%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fmutex.rs?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -47,11 +47,11 @@ impl Mutex {\n pub struct ReentrantMutex {}\n \n impl ReentrantMutex {\n-    pub unsafe fn uninitialized() -> ReentrantMutex {\n+    pub const unsafe fn uninitialized() -> ReentrantMutex {\n         ReentrantMutex {}\n     }\n \n-    pub unsafe fn init(&mut self) {}\n+    pub unsafe fn init(&self) {}\n \n     pub unsafe fn lock(&self) {}\n "}, {"sha": "268a53bb5641ca58ca79b89b75310b6d3d5c91d8", "filename": "src/libstd/sys/wasm/mutex_atomics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibstd%2Fsys%2Fwasm%2Fmutex_atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibstd%2Fsys%2Fwasm%2Fmutex_atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fmutex_atomics.rs?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -80,11 +80,11 @@ unsafe impl Sync for ReentrantMutex {}\n // released when this recursion counter reaches 0.\n \n impl ReentrantMutex {\n-    pub unsafe fn uninitialized() -> ReentrantMutex {\n+    pub const unsafe fn uninitialized() -> ReentrantMutex {\n         ReentrantMutex { owner: AtomicU32::new(0), recursions: UnsafeCell::new(0) }\n     }\n \n-    pub unsafe fn init(&mut self) {\n+    pub unsafe fn init(&self) {\n         // nothing to do...\n     }\n "}, {"sha": "63dfc640908e94da6e82418dd0368fd0df43b9e7", "filename": "src/libstd/sys/windows/mutex.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -109,7 +109,7 @@ impl Mutex {\n             0 => {}\n             n => return n as *mut _,\n         }\n-        let mut re = box ReentrantMutex::uninitialized();\n+        let re = box ReentrantMutex::uninitialized();\n         re.init();\n         let re = Box::into_raw(re);\n         match self.lock.compare_and_swap(0, re as usize, Ordering::SeqCst) {\n@@ -157,11 +157,11 @@ unsafe impl Send for ReentrantMutex {}\n unsafe impl Sync for ReentrantMutex {}\n \n impl ReentrantMutex {\n-    pub fn uninitialized() -> ReentrantMutex {\n+    pub const fn uninitialized() -> ReentrantMutex {\n         ReentrantMutex { inner: UnsafeCell::new(MaybeUninit::uninit()) }\n     }\n \n-    pub unsafe fn init(&mut self) {\n+    pub unsafe fn init(&self) {\n         c::InitializeCriticalSection((&mut *self.inner.get()).as_mut_ptr());\n     }\n "}, {"sha": "4f19bbc467f33d19b47d70a7fc320562d58506f5", "filename": "src/libstd/sys_common/remutex.rs", "status": "modified", "additions": 51, "deletions": 63, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibstd%2Fsys_common%2Fremutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Flibstd%2Fsys_common%2Fremutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fremutex.rs?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -3,16 +3,14 @@ use crate::marker;\n use crate::ops::Deref;\n use crate::panic::{RefUnwindSafe, UnwindSafe};\n use crate::sys::mutex as sys;\n-use crate::sys_common::poison::{self, LockResult, TryLockError, TryLockResult};\n \n /// A re-entrant mutual exclusion\n ///\n /// This mutex will block *other* threads waiting for the lock to become\n /// available. The thread which has already locked the mutex can lock it\n /// multiple times without blocking, preventing a common source of deadlocks.\n pub struct ReentrantMutex<T> {\n-    inner: Box<sys::ReentrantMutex>,\n-    poison: poison::Flag,\n+    inner: sys::ReentrantMutex,\n     data: T,\n }\n \n@@ -39,23 +37,30 @@ pub struct ReentrantMutexGuard<'a, T: 'a> {\n     // funny underscores due to how Deref currently works (it disregards field\n     // privacy).\n     __lock: &'a ReentrantMutex<T>,\n-    __poison: poison::Guard,\n }\n \n impl<T> !marker::Send for ReentrantMutexGuard<'_, T> {}\n \n impl<T> ReentrantMutex<T> {\n     /// Creates a new reentrant mutex in an unlocked state.\n-    pub fn new(t: T) -> ReentrantMutex<T> {\n-        unsafe {\n-            let mut mutex = ReentrantMutex {\n-                inner: box sys::ReentrantMutex::uninitialized(),\n-                poison: poison::Flag::new(),\n-                data: t,\n-            };\n-            mutex.inner.init();\n-            mutex\n-        }\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This function is unsafe because it is required that `init` is called\n+    /// once this mutex is in its final resting place, and only then are the\n+    /// lock/unlock methods safe.\n+    pub const unsafe fn new(t: T) -> ReentrantMutex<T> {\n+        ReentrantMutex { inner: sys::ReentrantMutex::uninitialized(), data: t }\n+    }\n+\n+    /// Initializes this mutex so it's ready for use.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// Unsafe to call more than once, and must be called after this will no\n+    /// longer move in memory.\n+    pub unsafe fn init(&self) {\n+        self.inner.init();\n     }\n \n     /// Acquires a mutex, blocking the current thread until it is able to do so.\n@@ -70,7 +75,7 @@ impl<T> ReentrantMutex<T> {\n     /// If another user of this mutex panicked while holding the mutex, then\n     /// this call will return failure if the mutex would otherwise be\n     /// acquired.\n-    pub fn lock(&self) -> LockResult<ReentrantMutexGuard<'_, T>> {\n+    pub fn lock(&self) -> ReentrantMutexGuard<'_, T> {\n         unsafe { self.inner.lock() }\n         ReentrantMutexGuard::new(&self)\n     }\n@@ -87,12 +92,8 @@ impl<T> ReentrantMutex<T> {\n     /// If another user of this mutex panicked while holding the mutex, then\n     /// this call will return failure if the mutex would otherwise be\n     /// acquired.\n-    pub fn try_lock(&self) -> TryLockResult<ReentrantMutexGuard<'_, T>> {\n-        if unsafe { self.inner.try_lock() } {\n-            Ok(ReentrantMutexGuard::new(&self)?)\n-        } else {\n-            Err(TryLockError::WouldBlock)\n-        }\n+    pub fn try_lock(&self) -> Option<ReentrantMutexGuard<'_, T>> {\n+        if unsafe { self.inner.try_lock() } { Some(ReentrantMutexGuard::new(&self)) } else { None }\n     }\n }\n \n@@ -108,11 +109,8 @@ impl<T> Drop for ReentrantMutex<T> {\n impl<T: fmt::Debug + 'static> fmt::Debug for ReentrantMutex<T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.try_lock() {\n-            Ok(guard) => f.debug_struct(\"ReentrantMutex\").field(\"data\", &*guard).finish(),\n-            Err(TryLockError::Poisoned(err)) => {\n-                f.debug_struct(\"ReentrantMutex\").field(\"data\", &**err.get_ref()).finish()\n-            }\n-            Err(TryLockError::WouldBlock) => {\n+            Some(guard) => f.debug_struct(\"ReentrantMutex\").field(\"data\", &*guard).finish(),\n+            None => {\n                 struct LockedPlaceholder;\n                 impl fmt::Debug for LockedPlaceholder {\n                     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n@@ -127,11 +125,8 @@ impl<T: fmt::Debug + 'static> fmt::Debug for ReentrantMutex<T> {\n }\n \n impl<'mutex, T> ReentrantMutexGuard<'mutex, T> {\n-    fn new(lock: &'mutex ReentrantMutex<T>) -> LockResult<ReentrantMutexGuard<'mutex, T>> {\n-        poison::map_result(lock.poison.borrow(), |guard| ReentrantMutexGuard {\n-            __lock: lock,\n-            __poison: guard,\n-        })\n+    fn new(lock: &'mutex ReentrantMutex<T>) -> ReentrantMutexGuard<'mutex, T> {\n+        ReentrantMutexGuard { __lock: lock }\n     }\n }\n \n@@ -147,7 +142,6 @@ impl<T> Drop for ReentrantMutexGuard<'_, T> {\n     #[inline]\n     fn drop(&mut self) {\n         unsafe {\n-            self.__lock.poison.done(&self.__poison);\n             self.__lock.inner.unlock();\n         }\n     }\n@@ -162,13 +156,17 @@ mod tests {\n \n     #[test]\n     fn smoke() {\n-        let m = ReentrantMutex::new(());\n+        let m = unsafe {\n+            let m = ReentrantMutex::new(());\n+            m.init();\n+            m\n+        };\n         {\n-            let a = m.lock().unwrap();\n+            let a = m.lock();\n             {\n-                let b = m.lock().unwrap();\n+                let b = m.lock();\n                 {\n-                    let c = m.lock().unwrap();\n+                    let c = m.lock();\n                     assert_eq!(*c, ());\n                 }\n                 assert_eq!(*b, ());\n@@ -179,15 +177,19 @@ mod tests {\n \n     #[test]\n     fn is_mutex() {\n-        let m = Arc::new(ReentrantMutex::new(RefCell::new(0)));\n+        let m = unsafe {\n+            let m = Arc::new(ReentrantMutex::new(RefCell::new(0)));\n+            m.init();\n+            m\n+        };\n         let m2 = m.clone();\n-        let lock = m.lock().unwrap();\n+        let lock = m.lock();\n         let child = thread::spawn(move || {\n-            let lock = m2.lock().unwrap();\n+            let lock = m2.lock();\n             assert_eq!(*lock.borrow(), 4950);\n         });\n         for i in 0..100 {\n-            let lock = m.lock().unwrap();\n+            let lock = m.lock();\n             *lock.borrow_mut() += i;\n         }\n         drop(lock);\n@@ -196,17 +198,21 @@ mod tests {\n \n     #[test]\n     fn trylock_works() {\n-        let m = Arc::new(ReentrantMutex::new(()));\n+        let m = unsafe {\n+            let m = Arc::new(ReentrantMutex::new(()));\n+            m.init();\n+            m\n+        };\n         let m2 = m.clone();\n-        let _lock = m.try_lock().unwrap();\n-        let _lock2 = m.try_lock().unwrap();\n+        let _lock = m.try_lock();\n+        let _lock2 = m.try_lock();\n         thread::spawn(move || {\n             let lock = m2.try_lock();\n-            assert!(lock.is_err());\n+            assert!(lock.is_none());\n         })\n         .join()\n         .unwrap();\n-        let _lock3 = m.try_lock().unwrap();\n+        let _lock3 = m.try_lock();\n     }\n \n     pub struct Answer<'a>(pub ReentrantMutexGuard<'a, RefCell<u32>>);\n@@ -215,22 +221,4 @@ mod tests {\n             *self.0.borrow_mut() = 42;\n         }\n     }\n-\n-    #[test]\n-    fn poison_works() {\n-        let m = Arc::new(ReentrantMutex::new(RefCell::new(0)));\n-        let mc = m.clone();\n-        let result = thread::spawn(move || {\n-            let lock = mc.lock().unwrap();\n-            *lock.borrow_mut() = 1;\n-            let lock2 = mc.lock().unwrap();\n-            *lock.borrow_mut() = 2;\n-            let _answer = Answer(lock2);\n-            panic!(\"What the answer to my lifetimes dilemma is?\");\n-        })\n-        .join();\n-        assert!(result.is_err());\n-        let r = m.lock().err().unwrap().into_inner();\n-        assert_eq!(*r.borrow(), 42);\n-    }\n }"}, {"sha": "3446600d0495f647179637564c9847e958a776a0", "filename": "src/test/ui/const-generics/argument_order.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Ftest%2Fui%2Fconst-generics%2Fargument_order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Ftest%2Fui%2Fconst-generics%2Fargument_order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fargument_order.rs?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -0,0 +1,9 @@\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+struct Bad<const N: usize, T> { //~ ERROR type parameters must be declared prior\n+    arr: [u8; { N }],\n+    another: T,\n+}\n+\n+fn main() { }"}, {"sha": "1e3b364eb6089e7420f9ce618d9208d1ac5bb967", "filename": "src/test/ui/const-generics/argument_order.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Ftest%2Fui%2Fconst-generics%2Fargument_order.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Ftest%2Fui%2Fconst-generics%2Fargument_order.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fargument_order.stderr?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -0,0 +1,16 @@\n+error: type parameters must be declared prior to const parameters\n+  --> $DIR/argument_order.rs:4:28\n+   |\n+LL | struct Bad<const N: usize, T> {\n+   |           -----------------^- help: reorder the parameters: lifetimes, then types, then consts: `<T, const N: usize>`\n+\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/argument_order.rs:1:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error: aborting due to previous error\n+"}, {"sha": "9c4800c1a3fa1affff3dfca6e31ae1e51cb5192e", "filename": "src/test/ui/eprint-on-tls-drop.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Ftest%2Fui%2Feprint-on-tls-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Ftest%2Fui%2Feprint-on-tls-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feprint-on-tls-drop.rs?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -0,0 +1,48 @@\n+// run-pass\n+// ignore-emscripten no processes\n+\n+use std::cell::RefCell;\n+use std::env;\n+use std::process::Command;\n+\n+fn main() {\n+    let name = \"YOU_ARE_THE_TEST\";\n+    if env::var(name).is_ok() {\n+        std::thread::spawn(|| {\n+            TLS.with(|f| f.borrow().ensure());\n+        })\n+        .join()\n+        .unwrap();\n+    } else {\n+        let me = env::current_exe().unwrap();\n+        let output = Command::new(&me).env(name, \"1\").output().unwrap();\n+        println!(\"{:?}\", output);\n+        assert!(output.status.success());\n+        let stderr = String::from_utf8(output.stderr).unwrap();\n+        assert!(stderr.contains(\"hello new\\n\"));\n+        assert!(stderr.contains(\"hello drop\\n\"));\n+    }\n+}\n+\n+struct Stuff {\n+    _x: usize,\n+}\n+\n+impl Stuff {\n+    fn new() -> Self {\n+        eprintln!(\"hello new\");\n+        Self { _x: 0 }\n+    }\n+\n+    fn ensure(&self) {}\n+}\n+\n+impl Drop for Stuff {\n+    fn drop(&mut self) {\n+        eprintln!(\"hello drop\");\n+    }\n+}\n+\n+thread_local! {\n+    static TLS: RefCell<Stuff> = RefCell::new(Stuff::new());\n+}"}, {"sha": "70ae200e3e5aa936003e77e2b30a1352d898a198", "filename": "src/test/ui/layout/debug.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Ftest%2Fui%2Flayout%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Ftest%2Fui%2Flayout%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fdebug.rs?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -0,0 +1,15 @@\n+// normalize-stderr-test \"pref: Align \\{\\n *pow2: [1-3],\\n *\\}\" -> \"pref: $$PREF_ALIGN\"\n+#![feature(never_type, rustc_attrs)]\n+#![crate_type = \"lib\"]\n+\n+#[rustc_layout(debug)]\n+enum E { Foo, Bar(!, i32, i32) } //~ ERROR: layout debugging\n+\n+#[rustc_layout(debug)]\n+struct S { f1: i32, f2: (), f3: i32 } //~ ERROR: layout debugging\n+\n+#[rustc_layout(debug)]\n+union U { f1: (i32, i32), f3: i32 } //~ ERROR: layout debugging\n+\n+#[rustc_layout(debug)]\n+type Test = Result<i32, i32>; //~ ERROR: layout debugging"}, {"sha": "0ce538285f8c497989503587ea9222cc7f9cecd7", "filename": "src/test/ui/layout/debug.stderr", "status": "added", "additions": 319, "deletions": 0, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Ftest%2Fui%2Flayout%2Fdebug.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Ftest%2Fui%2Flayout%2Fdebug.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fdebug.stderr?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -0,0 +1,319 @@\n+error: layout debugging: LayoutDetails {\n+    fields: Arbitrary {\n+        offsets: [\n+            Size {\n+                raw: 0,\n+            },\n+        ],\n+        memory_index: [\n+            0,\n+        ],\n+    },\n+    variants: Multiple {\n+        discr: Scalar {\n+            value: Int(\n+                I32,\n+                false,\n+            ),\n+            valid_range: 0..=0,\n+        },\n+        discr_kind: Tag,\n+        discr_index: 0,\n+        variants: [\n+            LayoutDetails {\n+                fields: Arbitrary {\n+                    offsets: [],\n+                    memory_index: [],\n+                },\n+                variants: Single {\n+                    index: 0,\n+                },\n+                abi: Aggregate {\n+                    sized: true,\n+                },\n+                largest_niche: None,\n+                align: AbiAndPrefAlign {\n+                    abi: Align {\n+                        pow2: 0,\n+                    },\n+                    pref: $PREF_ALIGN,\n+                },\n+                size: Size {\n+                    raw: 4,\n+                },\n+            },\n+            LayoutDetails {\n+                fields: Arbitrary {\n+                    offsets: [\n+                        Size {\n+                            raw: 4,\n+                        },\n+                        Size {\n+                            raw: 4,\n+                        },\n+                        Size {\n+                            raw: 8,\n+                        },\n+                    ],\n+                    memory_index: [\n+                        0,\n+                        1,\n+                        2,\n+                    ],\n+                },\n+                variants: Single {\n+                    index: 1,\n+                },\n+                abi: Uninhabited,\n+                largest_niche: None,\n+                align: AbiAndPrefAlign {\n+                    abi: Align {\n+                        pow2: 2,\n+                    },\n+                    pref: $PREF_ALIGN,\n+                },\n+                size: Size {\n+                    raw: 12,\n+                },\n+            },\n+        ],\n+    },\n+    abi: Aggregate {\n+        sized: true,\n+    },\n+    largest_niche: Some(\n+        Niche {\n+            offset: Size {\n+                raw: 0,\n+            },\n+            scalar: Scalar {\n+                value: Int(\n+                    I32,\n+                    false,\n+                ),\n+                valid_range: 0..=0,\n+            },\n+        },\n+    ),\n+    align: AbiAndPrefAlign {\n+        abi: Align {\n+            pow2: 2,\n+        },\n+        pref: $PREF_ALIGN,\n+    },\n+    size: Size {\n+        raw: 12,\n+    },\n+}\n+  --> $DIR/debug.rs:6:1\n+   |\n+LL | enum E { Foo, Bar(!, i32, i32) }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: layout debugging: LayoutDetails {\n+    fields: Arbitrary {\n+        offsets: [\n+            Size {\n+                raw: 0,\n+            },\n+            Size {\n+                raw: 0,\n+            },\n+            Size {\n+                raw: 4,\n+            },\n+        ],\n+        memory_index: [\n+            1,\n+            0,\n+            2,\n+        ],\n+    },\n+    variants: Single {\n+        index: 0,\n+    },\n+    abi: ScalarPair(\n+        Scalar {\n+            value: Int(\n+                I32,\n+                true,\n+            ),\n+            valid_range: 0..=4294967295,\n+        },\n+        Scalar {\n+            value: Int(\n+                I32,\n+                true,\n+            ),\n+            valid_range: 0..=4294967295,\n+        },\n+    ),\n+    largest_niche: None,\n+    align: AbiAndPrefAlign {\n+        abi: Align {\n+            pow2: 2,\n+        },\n+        pref: $PREF_ALIGN,\n+    },\n+    size: Size {\n+        raw: 8,\n+    },\n+}\n+  --> $DIR/debug.rs:9:1\n+   |\n+LL | struct S { f1: i32, f2: (), f3: i32 }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: layout debugging: LayoutDetails {\n+    fields: Union(\n+        2,\n+    ),\n+    variants: Single {\n+        index: 0,\n+    },\n+    abi: Aggregate {\n+        sized: true,\n+    },\n+    largest_niche: None,\n+    align: AbiAndPrefAlign {\n+        abi: Align {\n+            pow2: 2,\n+        },\n+        pref: $PREF_ALIGN,\n+    },\n+    size: Size {\n+        raw: 8,\n+    },\n+}\n+  --> $DIR/debug.rs:12:1\n+   |\n+LL | union U { f1: (i32, i32), f3: i32 }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: layout debugging: LayoutDetails {\n+    fields: Arbitrary {\n+        offsets: [\n+            Size {\n+                raw: 0,\n+            },\n+        ],\n+        memory_index: [\n+            0,\n+        ],\n+    },\n+    variants: Multiple {\n+        discr: Scalar {\n+            value: Int(\n+                I32,\n+                false,\n+            ),\n+            valid_range: 0..=1,\n+        },\n+        discr_kind: Tag,\n+        discr_index: 0,\n+        variants: [\n+            LayoutDetails {\n+                fields: Arbitrary {\n+                    offsets: [\n+                        Size {\n+                            raw: 4,\n+                        },\n+                    ],\n+                    memory_index: [\n+                        0,\n+                    ],\n+                },\n+                variants: Single {\n+                    index: 0,\n+                },\n+                abi: Aggregate {\n+                    sized: true,\n+                },\n+                largest_niche: None,\n+                align: AbiAndPrefAlign {\n+                    abi: Align {\n+                        pow2: 2,\n+                    },\n+                    pref: $PREF_ALIGN,\n+                },\n+                size: Size {\n+                    raw: 8,\n+                },\n+            },\n+            LayoutDetails {\n+                fields: Arbitrary {\n+                    offsets: [\n+                        Size {\n+                            raw: 4,\n+                        },\n+                    ],\n+                    memory_index: [\n+                        0,\n+                    ],\n+                },\n+                variants: Single {\n+                    index: 1,\n+                },\n+                abi: Aggregate {\n+                    sized: true,\n+                },\n+                largest_niche: None,\n+                align: AbiAndPrefAlign {\n+                    abi: Align {\n+                        pow2: 2,\n+                    },\n+                    pref: $PREF_ALIGN,\n+                },\n+                size: Size {\n+                    raw: 8,\n+                },\n+            },\n+        ],\n+    },\n+    abi: ScalarPair(\n+        Scalar {\n+            value: Int(\n+                I32,\n+                false,\n+            ),\n+            valid_range: 0..=1,\n+        },\n+        Scalar {\n+            value: Int(\n+                I32,\n+                true,\n+            ),\n+            valid_range: 0..=4294967295,\n+        },\n+    ),\n+    largest_niche: Some(\n+        Niche {\n+            offset: Size {\n+                raw: 0,\n+            },\n+            scalar: Scalar {\n+                value: Int(\n+                    I32,\n+                    false,\n+                ),\n+                valid_range: 0..=1,\n+            },\n+        },\n+    ),\n+    align: AbiAndPrefAlign {\n+        abi: Align {\n+            pow2: 2,\n+        },\n+        pref: $PREF_ALIGN,\n+    },\n+    size: Size {\n+        raw: 8,\n+    },\n+}\n+  --> $DIR/debug.rs:15:1\n+   |\n+LL | type Test = Result<i32, i32>;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "a55f05414b206c98f1a002859bdb0e444b152e2f", "filename": "src/test/ui/macros/trace_faulty_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Ftest%2Fui%2Fmacros%2Ftrace_faulty_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Ftest%2Fui%2Fmacros%2Ftrace_faulty_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Ftrace_faulty_macros.rs?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -13,7 +13,7 @@ macro_rules! pat_macro {\n         pat_macro!(A{a:a, b:0, c:_, ..});\n     };\n     ($a:pat) => {\n-        $a\n+        $a //~ ERROR expected expression\n     };\n }\n "}, {"sha": "109b493b43717e970268c315bf4e1afc07da8535", "filename": "src/test/ui/macros/trace_faulty_macros.stderr", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Ftest%2Fui%2Fmacros%2Ftrace_faulty_macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7900b2bc135a0e02d945143176cf3a80b6e92aa8/src%2Ftest%2Fui%2Fmacros%2Ftrace_faulty_macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Ftrace_faulty_macros.stderr?ref=7900b2bc135a0e02d945143176cf3a80b6e92aa8", "patch": "@@ -49,5 +49,16 @@ LL |     my_recursive_macro!();\n    = note: expanding `my_recursive_macro! {  }`\n    = note: to `my_recursive_macro ! () ;`\n \n-error: aborting due to 2 previous errors\n+error: expected expression, found `A { a: a, b: 0, c: _, .. }`\n+  --> $DIR/trace_faulty_macros.rs:16:9\n+   |\n+LL |         $a\n+   |         ^^ expected expression\n+...\n+LL |     let a = pat_macro!();\n+   |             ------------ in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 3 previous errors\n "}]}