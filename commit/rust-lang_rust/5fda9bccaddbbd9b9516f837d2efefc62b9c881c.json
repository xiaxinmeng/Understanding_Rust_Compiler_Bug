{"sha": "5fda9bccaddbbd9b9516f837d2efefc62b9c881c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmZGE5YmNjYWRkYmJkOWI5NTE2ZjgzN2QyZWZlZmM2MmI5Yzg4MWM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-21T17:14:30Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-21T17:14:30Z"}, "message": "rollup merge of #21368: tomjakubowski/rustdoc-miscellany\n\nConflicts:\n\tsrc/librustdoc/clean/mod.rs", "tree": {"sha": "ef1e7e3c644bf3f03cdd264277de47c1f02b53da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef1e7e3c644bf3f03cdd264277de47c1f02b53da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5fda9bccaddbbd9b9516f837d2efefc62b9c881c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5fda9bccaddbbd9b9516f837d2efefc62b9c881c", "html_url": "https://github.com/rust-lang/rust/commit/5fda9bccaddbbd9b9516f837d2efefc62b9c881c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5fda9bccaddbbd9b9516f837d2efefc62b9c881c/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ecc9dccc15cf4bdab8f1af943ac83b28bd3894d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecc9dccc15cf4bdab8f1af943ac83b28bd3894d7", "html_url": "https://github.com/rust-lang/rust/commit/ecc9dccc15cf4bdab8f1af943ac83b28bd3894d7"}, {"sha": "159236a63b64fec9aec6e1d36ee4e1c811747240", "url": "https://api.github.com/repos/rust-lang/rust/commits/159236a63b64fec9aec6e1d36ee4e1c811747240", "html_url": "https://github.com/rust-lang/rust/commit/159236a63b64fec9aec6e1d36ee4e1c811747240"}], "stats": {"total": 167, "additions": 95, "deletions": 72}, "files": [{"sha": "06fb9106b195d66a7c769ea7380f6affc2afb445", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5fda9bccaddbbd9b9516f837d2efefc62b9c881c/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fda9bccaddbbd9b9516f837d2efefc62b9c881c/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=5fda9bccaddbbd9b9516f837d2efefc62b9c881c", "patch": "@@ -70,7 +70,7 @@ use util::nodemap::{FnvHashMap};\n use arena::TypedArena;\n use std::borrow::{BorrowFrom, Cow};\n use std::cell::{Cell, RefCell};\n-use std::cmp::{self, Ordering};\n+use std::cmp;\n use std::fmt::{self, Show};\n use std::hash::{Hash, Writer, SipHasher, Hasher};\n use std::mem;\n@@ -5089,25 +5089,6 @@ pub fn associated_type_parameter_index(cx: &ctxt,\n     cx.sess.bug(\"couldn't find associated type parameter index\")\n }\n \n-#[derive(Copy, PartialEq, Eq)]\n-pub struct AssociatedTypeInfo {\n-    pub def_id: ast::DefId,\n-    pub index: uint,\n-    pub name: ast::Name,\n-}\n-\n-impl PartialOrd for AssociatedTypeInfo {\n-    fn partial_cmp(&self, other: &AssociatedTypeInfo) -> Option<Ordering> {\n-        Some(self.index.cmp(&other.index))\n-    }\n-}\n-\n-impl Ord for AssociatedTypeInfo {\n-    fn cmp(&self, other: &AssociatedTypeInfo) -> Ordering {\n-        self.index.cmp(&other.index)\n-    }\n-}\n-\n pub fn trait_item_def_ids(cx: &ctxt, id: ast::DefId)\n                           -> Rc<Vec<ImplOrTraitItemId>> {\n     lookup_locally_or_in_crate_store(\"trait_item_def_ids\","}, {"sha": "6e79bd9bebda1003233dfa0a9b8ce95d06e125f7", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5fda9bccaddbbd9b9516f837d2efefc62b9c881c/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fda9bccaddbbd9b9516f837d2efefc62b9c881c/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=5fda9bccaddbbd9b9516f837d2efefc62b9c881c", "patch": "@@ -147,14 +147,22 @@ pub fn record_extern_fqn(cx: &DocContext, did: ast::DefId, kind: clean::TypeKind\n \n pub fn build_external_trait(cx: &DocContext, tcx: &ty::ctxt,\n                             did: ast::DefId) -> clean::Trait {\n+    use clean::TraitMethod;\n+\n     let def = ty::lookup_trait_def(tcx, did);\n     let trait_items = ty::trait_items(tcx, did).clean(cx);\n     let provided = ty::provided_trait_methods(tcx, did);\n     let items = trait_items.into_iter().map(|trait_item| {\n-        if provided.iter().any(|a| a.def_id == trait_item.def_id) {\n-            clean::ProvidedMethod(trait_item)\n-        } else {\n-            clean::RequiredMethod(trait_item)\n+        match trait_item.inner {\n+            clean::TyMethodItem(_) => {\n+                if provided.iter().any(|a| a.def_id == trait_item.def_id) {\n+                    TraitMethod::ProvidedMethod(trait_item)\n+                } else {\n+                    TraitMethod::RequiredMethod(trait_item)\n+                }\n+            },\n+            clean::AssociatedTypeItem(_) => TraitMethod::TypeTraitItem(trait_item),\n+            _ => unreachable!()\n         }\n     });\n     let trait_def = ty::lookup_trait_def(tcx, did);\n@@ -311,9 +319,21 @@ fn build_impl(cx: &DocContext, tcx: &ty::ctxt,\n                 };\n                 Some(item)\n             }\n-            ty::TypeTraitItem(_) => {\n-                // FIXME(pcwalton): Implement.\n-                None\n+            ty::TypeTraitItem(ref assoc_ty) => {\n+                let did = assoc_ty.def_id;\n+                let type_scheme = ty::lookup_item_type(tcx, did);\n+                // Not sure the choice of ParamSpace actually matters here, because an\n+                // associated type won't have generics on the LHS\n+                let typedef = (type_scheme, subst::ParamSpace::TypeSpace).clean(cx);\n+                Some(clean::Item {\n+                    name: Some(assoc_ty.name.clean(cx)),\n+                    inner: clean::TypedefItem(typedef),\n+                    source: clean::Span::empty(),\n+                    attrs: vec![],\n+                    visibility: None,\n+                    stability: stability::lookup(tcx, did).clean(cx),\n+                    def_id: did\n+                })\n             }\n         }\n     }).collect();"}, {"sha": "7c7db97951eff83bb1c3a9a71006de642bbf8f05", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 52, "deletions": 36, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/5fda9bccaddbbd9b9516f837d2efefc62b9c881c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fda9bccaddbbd9b9516f837d2efefc62b9c881c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=5fda9bccaddbbd9b9516f837d2efefc62b9c881c", "patch": "@@ -45,7 +45,6 @@ use rustc::middle::def;\n use rustc::middle::subst::{self, ParamSpace, VecPerParamSpace};\n use rustc::middle::ty;\n use rustc::middle::stability;\n-use rustc::session::config;\n \n use std::rc::Rc;\n use std::u32;\n@@ -116,7 +115,7 @@ impl<T: Clean<U>, U> Clean<Vec<U>> for syntax::owned_slice::OwnedSlice<T> {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct Crate {\n     pub name: String,\n     pub src: FsPath,\n@@ -127,15 +126,17 @@ pub struct Crate {\n \n impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n     fn clean(&self, cx: &DocContext) -> Crate {\n+        use rustc::session::config::Input;\n+\n         let mut externs = Vec::new();\n         cx.sess().cstore.iter_crate_data(|n, meta| {\n             externs.push((n, meta.clean(cx)));\n         });\n         externs.sort_by(|&(a, _), &(b, _)| a.cmp(&b));\n \n         // Figure out the name of this crate\n-        let input = config::Input::File(cx.src.clone());\n-        let name = link::find_crate_name(None, self.attrs.as_slice(), &input);\n+        let input = &cx.input;\n+        let name = link::find_crate_name(None, self.attrs.as_slice(), input);\n \n         // Clean the crate, translating the entire libsyntax AST to one that is\n         // understood by rustdoc.\n@@ -188,17 +189,22 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n             m.items.extend(tmp.into_iter());\n         }\n \n+        let src = match cx.input {\n+            Input::File(ref path) => path.clone(),\n+            Input::Str(_) => FsPath::new(\"\") // FIXME: this is wrong\n+        };\n+\n         Crate {\n             name: name.to_string(),\n-            src: cx.src.clone(),\n+            src: src,\n             module: Some(module),\n             externs: externs,\n             primitives: primitives,\n         }\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct ExternalCrate {\n     pub name: String,\n     pub attrs: Vec<Attribute>,\n@@ -231,7 +237,7 @@ impl Clean<ExternalCrate> for cstore::crate_metadata {\n /// Anything with a source location and set of attributes and, optionally, a\n /// name. That is, anything that can be documented. This doesn't correspond\n /// directly to the AST's concept of an item; it's a strict superset.\n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct Item {\n     /// Stringified span\n     pub source: Span,\n@@ -307,7 +313,7 @@ impl Item {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub enum ItemEnum {\n     StructItem(Struct),\n     EnumItem(Enum),\n@@ -336,7 +342,7 @@ pub enum ItemEnum {\n     AssociatedTypeItem(TyParam),\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct Module {\n     pub items: Vec<Item>,\n     pub is_crate: bool,\n@@ -938,7 +944,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>, subst::ParamSpace) {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct Method {\n     pub generics: Generics,\n     pub self_: SelfTy,\n@@ -977,7 +983,7 @@ impl Clean<Item> for ast::Method {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct TyMethod {\n     pub unsafety: ast::Unsafety,\n     pub decl: FnDecl,\n@@ -1015,7 +1021,7 @@ impl Clean<Item> for ast::TypeMethod {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n pub enum SelfTy {\n     SelfStatic,\n     SelfValue,\n@@ -1036,7 +1042,7 @@ impl Clean<SelfTy> for ast::ExplicitSelf_ {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct Function {\n     pub decl: FnDecl,\n     pub generics: Generics,\n@@ -1155,7 +1161,7 @@ impl Clean<FunctionRetTy> for ast::FunctionRetTy {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct Trait {\n     pub unsafety: ast::Unsafety,\n     pub items: Vec<TraitMethod>,\n@@ -1199,11 +1205,11 @@ impl Clean<PolyTrait> for ast::PolyTraitRef {\n \n /// An item belonging to a trait, whether a method or associated. Could be named\n /// TraitItem except that's already taken by an exported enum variant.\n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub enum TraitMethod {\n     RequiredMethod(Item),\n     ProvidedMethod(Item),\n-    TypeTraitItem(Item),\n+    TypeTraitItem(Item), // an associated type\n }\n \n impl TraitMethod {\n@@ -1244,7 +1250,7 @@ impl Clean<TraitMethod> for ast::TraitItem {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub enum ImplMethod {\n     MethodImplItem(Item),\n     TypeImplItem(Item),\n@@ -1380,7 +1386,7 @@ pub enum PrimitiveType {\n     PrimitiveTuple,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Copy)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Copy, Show)]\n pub enum TypeKind {\n     TypeEnum,\n     TypeFunction,\n@@ -1623,7 +1629,7 @@ impl Clean<Type> for ast::QPath {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub enum StructField {\n     HiddenStructField, // inserted later by strip passes\n     TypedStructField(Type),\n@@ -1682,7 +1688,7 @@ impl Clean<Option<Visibility>> for ast::Visibility {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct Struct {\n     pub struct_type: doctree::StructType,\n     pub generics: Generics,\n@@ -1712,7 +1718,7 @@ impl Clean<Item> for doctree::Struct {\n /// This is a more limited form of the standard Struct, different in that\n /// it lacks the things most items have (name, id, parameterization). Found\n /// only as a variant in an enum.\n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct VariantStruct {\n     pub struct_type: doctree::StructType,\n     pub fields: Vec<Item>,\n@@ -1729,7 +1735,7 @@ impl Clean<VariantStruct> for syntax::ast::StructDef {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct Enum {\n     pub variants: Vec<Item>,\n     pub generics: Generics,\n@@ -1754,7 +1760,7 @@ impl Clean<Item> for doctree::Enum {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct Variant {\n     pub kind: VariantKind,\n }\n@@ -1822,7 +1828,7 @@ impl<'tcx> Clean<Item> for ty::VariantInfo<'tcx> {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub enum VariantKind {\n     CLikeVariant,\n     TupleVariant(Vec<Type>),\n@@ -1969,7 +1975,7 @@ impl Clean<String> for ast::Name {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct Typedef {\n     pub type_: Type,\n     pub generics: Generics,\n@@ -2082,7 +2088,7 @@ impl Clean<Mutability> for ast::Mutability {\n     }\n }\n \n-#[derive(Show, Clone, RustcEncodable, RustcDecodable, PartialEq, Copy)]\n+#[derive(Show, Clone, RustcEncodable, RustcDecodable, PartialEq, Copy, Show)]\n pub enum ImplPolarity {\n     Positive,\n     Negative,\n@@ -2097,7 +2103,7 @@ impl Clean<ImplPolarity> for ast::ImplPolarity {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct Impl {\n     pub generics: Generics,\n     pub trait_: Option<Type>,\n@@ -2137,7 +2143,7 @@ impl Clean<Item> for doctree::Impl {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct ViewItem {\n     pub inner: ViewItemInner,\n }\n@@ -2203,7 +2209,7 @@ impl Clean<Vec<Item>> for ast::ViewItem {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub enum ViewItemInner {\n     ExternCrate(String, Option<String>, ast::NodeId),\n     Import(ViewPath)\n@@ -2226,7 +2232,7 @@ impl Clean<ViewItemInner> for ast::ViewItem_ {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub enum ViewPath {\n     // use source as str;\n     SimpleImport(String, ImportSource),\n@@ -2236,7 +2242,7 @@ pub enum ViewPath {\n     ImportList(ImportSource, Vec<ViewListIdent>),\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct ImportSource {\n     pub path: Path,\n     pub did: Option<ast::DefId>,\n@@ -2257,7 +2263,7 @@ impl Clean<ViewPath> for ast::ViewPath {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct ViewListIdent {\n     pub name: String,\n     pub source: Option<ast::DefId>,\n@@ -2476,7 +2482,7 @@ fn resolve_def(cx: &DocContext, id: ast::NodeId) -> Option<ast::DefId> {\n     })\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct Macro {\n     pub source: String,\n }\n@@ -2497,7 +2503,7 @@ impl Clean<Item> for doctree::Macro {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct Stability {\n     pub level: attr::StabilityLevel,\n     pub text: String\n@@ -2533,14 +2539,14 @@ impl Clean<Item> for ty::AssociatedType {\n             source: DUMMY_SP.clean(cx),\n             name: Some(self.name.clean(cx)),\n             attrs: Vec::new(),\n-            // FIXME(#18048): this is wrong, but cross-crate associated types are broken\n-            // anyway, for the time being.\n             inner: AssociatedTypeItem(TyParam {\n                 name: self.name.clean(cx),\n                 did: ast::DefId {\n                     krate: 0,\n                     node: ast::DUMMY_NODE_ID\n                 },\n+                // FIXME(#20727): bounds are missing and need to be filled in from the\n+                // predicates on the trait itself\n                 bounds: vec![],\n                 default: None,\n             }),\n@@ -2572,6 +2578,16 @@ impl Clean<Item> for ast::Typedef {\n     }\n }\n \n+impl<'a> Clean<Typedef> for (ty::TypeScheme<'a>, ParamSpace) {\n+    fn clean(&self, cx: &DocContext) -> Typedef {\n+        let (ref ty_scheme, ps) = *self;\n+        Typedef {\n+            type_: ty_scheme.ty.clean(cx),\n+            generics: (&ty_scheme.generics, ps).clean(cx)\n+        }\n+    }\n+}\n+\n fn lang_struct(cx: &DocContext, did: Option<ast::DefId>,\n                t: ty::Ty, name: &str,\n                fallback: fn(Box<Type>) -> Type) -> Type {"}, {"sha": "04947e41663ece794c6c2c52f3b29ef3950216da", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5fda9bccaddbbd9b9516f837d2efefc62b9c881c/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fda9bccaddbbd9b9516f837d2efefc62b9c881c/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=5fda9bccaddbbd9b9516f837d2efefc62b9c881c", "patch": "@@ -12,7 +12,6 @@ pub use self::MaybeTyped::*;\n use rustc_driver::driver;\n use rustc::session::{self, config};\n use rustc::session::config::UnstableFeatures;\n-use rustc::session::search_paths::SearchPaths;\n use rustc::middle::{privacy, ty};\n use rustc::lint;\n use rustc_trans::back::link;\n@@ -27,6 +26,9 @@ use visit_ast::RustdocVisitor;\n use clean;\n use clean::Clean;\n \n+pub use rustc::session::config::Input;\n+pub use rustc::session::search_paths::SearchPaths;\n+\n /// Are we generating documentation (`Typed`) or tests (`NotTyped`)?\n pub enum MaybeTyped<'tcx> {\n     Typed(ty::ctxt<'tcx>),\n@@ -39,7 +41,7 @@ pub type ExternalPaths = RefCell<Option<HashMap<ast::DefId,\n pub struct DocContext<'tcx> {\n     pub krate: &'tcx ast::Crate,\n     pub maybe_typed: MaybeTyped<'tcx>,\n-    pub src: Path,\n+    pub input: Input,\n     pub external_paths: ExternalPaths,\n     pub external_traits: RefCell<Option<HashMap<ast::DefId, clean::Trait>>>,\n     pub external_typarams: RefCell<Option<HashMap<ast::DefId, String>>>,\n@@ -80,12 +82,15 @@ pub struct CrateAnalysis {\n pub type Externs = HashMap<String, Vec<String>>;\n \n pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n-                cpath: &Path, triple: Option<String>)\n+                input: Input, triple: Option<String>)\n                 -> (clean::Crate, CrateAnalysis) {\n \n     // Parse, resolve, and typecheck the given crate.\n \n-    let input = config::Input::File(cpath.clone());\n+    let cpath = match input {\n+        Input::File(ref p) => Some(p.clone()),\n+        _ => None\n+    };\n \n     let warning_lint = lint::builtin::WARNINGS.name_lower();\n \n@@ -107,8 +112,7 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n     let span_diagnostic_handler =\n         diagnostic::mk_span_handler(diagnostic_handler, codemap);\n \n-    let sess = session::build_session_(sessopts,\n-                                       Some(cpath.clone()),\n+    let sess = session::build_session_(sessopts, cpath,\n                                        span_diagnostic_handler);\n \n     let cfg = config::build_configuration(&sess);\n@@ -136,7 +140,7 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n     let ctxt = DocContext {\n         krate: ty_cx.map.krate(),\n         maybe_typed: Typed(ty_cx),\n-        src: cpath.clone(),\n+        input: input,\n         external_traits: RefCell::new(Some(HashMap::new())),\n         external_typarams: RefCell::new(Some(HashMap::new())),\n         external_paths: RefCell::new(Some(HashMap::new())),"}, {"sha": "db17c7014c23758651d86ea1b2f3eed3220c763d", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5fda9bccaddbbd9b9516f837d2efefc62b9c881c/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fda9bccaddbbd9b9516f837d2efefc62b9c881c/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=5fda9bccaddbbd9b9516f837d2efefc62b9c881c", "patch": "@@ -351,8 +351,10 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n     info!(\"starting to run rustc\");\n \n     let (mut krate, analysis) = std::thread::Thread::scoped(move |:| {\n+        use rustc::session::config::Input;\n+\n         let cr = cr;\n-        core::run_core(paths, cfgs, externs, &cr, triple)\n+        core::run_core(paths, cfgs, externs, Input::File(cr), triple)\n     }).join().map_err(|_| \"rustc failed\").unwrap();\n     info!(\"finished with rustc\");\n     let mut analysis = Some(analysis);"}, {"sha": "7f1bd9e6d59657ed075659b79b1e868653e4db24", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fda9bccaddbbd9b9516f837d2efefc62b9c881c/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fda9bccaddbbd9b9516f837d2efefc62b9c881c/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=5fda9bccaddbbd9b9516f837d2efefc62b9c881c", "patch": "@@ -79,7 +79,7 @@ pub fn run(input: &str,\n     let ctx = core::DocContext {\n         krate: &krate,\n         maybe_typed: core::NotTyped(sess),\n-        src: input_path,\n+        input: input,\n         external_paths: RefCell::new(Some(HashMap::new())),\n         external_traits: RefCell::new(None),\n         external_typarams: RefCell::new(None),"}]}