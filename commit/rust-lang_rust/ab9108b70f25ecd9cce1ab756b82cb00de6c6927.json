{"sha": "ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiOTEwOGI3MGYyNWVjZDljY2UxYWI3NTZiODJjYjAwZGU2YzY5Mjc=", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2021-07-17T16:48:07Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2021-08-26T09:00:30Z"}, "message": "update `TypeFlags` to deal with missing ct substs", "tree": {"sha": "e170e754ffe5d4fdad51e85fdb043a9cc98e1dc8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e170e754ffe5d4fdad51e85fdb043a9cc98e1dc8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "html_url": "https://github.com/rust-lang/rust/commit/ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc47998e2877f13712a12b3814cc2bbf07fbae09", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc47998e2877f13712a12b3814cc2bbf07fbae09", "html_url": "https://github.com/rust-lang/rust/commit/cc47998e2877f13712a12b3814cc2bbf07fbae09"}], "stats": {"total": 471, "additions": 305, "deletions": 166}, "files": [{"sha": "2e8a960401724e1df62003a2abc242570ccd26b5", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -499,7 +499,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                         ty::Adt(def, ..) if !def.is_box() => {\n                             // Again, only create type information if full debuginfo is enabled\n                             if cx.sess().opts.debuginfo == DebugInfo::Full\n-                                && !impl_self_ty.needs_subst()\n+                                && !impl_self_ty.needs_subst(cx.tcx)\n                             {\n                                 Some(type_metadata(cx, impl_self_ty, rustc_span::DUMMY_SP))\n                             } else {"}, {"sha": "673d348a2a89c377b3af1602e44cc1156579f775", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -1398,7 +1398,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 LocalRef::UnsizedPlace(_) => bug!(\"transmute must not involve unsized locals\"),\n                 LocalRef::Operand(None) => {\n                     let dst_layout = bx.layout_of(self.monomorphized_place_ty(dst.as_ref()));\n-                    assert!(!dst_layout.ty.has_erasable_regions());\n+                    assert!(!dst_layout.ty.has_erasable_regions(self.cx.tcx()));\n                     let place = PlaceRef::alloca(bx, dst_layout);\n                     place.storage_live(bx);\n                     self.codegen_transmute_into(bx, src, place);"}, {"sha": "e2edd448267175974d734b913086e88f43ebac16", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -216,7 +216,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         let mut allocate_local = |local| {\n             let decl = &mir.local_decls[local];\n             let layout = bx.layout_of(fx.monomorphize(decl.ty));\n-            assert!(!layout.ty.has_erasable_regions());\n+            assert!(!layout.ty.has_erasable_regions(cx.tcx()));\n \n             if local == mir::RETURN_PLACE && fx.fn_abi.ret.is_indirect() {\n                 debug!(\"alloc: {:?} (return place) -> place\", local);"}, {"sha": "c6e150d114c55e18fe2a744f3ff4ed7a63ec132c", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -470,7 +470,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n     {\n         let needs_canonical_flags = if canonicalize_region_mode.any() {\n             TypeFlags::NEEDS_INFER |\n-            TypeFlags::HAS_FREE_REGIONS | // `HAS_RE_PLACEHOLDER` implies `HAS_FREE_REGIONS`\n+            TypeFlags::HAS_POTENTIAL_FREE_REGIONS | // `HAS_RE_PLACEHOLDER` implies `HAS_xxx_FREE_REGIONS`\n             TypeFlags::HAS_TY_PLACEHOLDER |\n             TypeFlags::HAS_CT_PLACEHOLDER\n         } else {"}, {"sha": "c40e409891bc25cb76a7612fbab231493c67de98", "filename": "compiler/rustc_infer/src/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -146,7 +146,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !t.needs_infer() && !t.has_erasable_regions() {\n+        if !t.needs_infer() && !t.has_erasable_regions(self.tcx()) {\n             return t;\n         }\n "}, {"sha": "8f848f54aad631a0beea2babf5537f27641319ab", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -1656,7 +1656,7 @@ impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n                     ConstEquate(..) |\n                     TypeWellFormedFromEnv(..) => continue,\n                 };\n-                if predicate.is_global() {\n+                if predicate.is_global(cx.tcx) {\n                     cx.struct_span_lint(TRIVIAL_BOUNDS, span, |lint| {\n                         lint.build(&format!(\n                             \"{} bound {} does not depend on any type \\"}, {"sha": "908d847915f88801fd21c9db1bd029044723d514", "filename": "compiler/rustc_lint/src/noop_method_call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -62,7 +62,7 @@ impl<'tcx> LateLintPass<'tcx> for NoopMethodCall {\n             _ => return,\n         };\n         let substs = cx.typeck_results().node_substs(expr.hir_id);\n-        if substs.needs_subst() {\n+        if substs.needs_subst(cx.tcx) {\n             // We can't resolve on types that require monomorphization, so we don't handle them if\n             // we need to perfom substitution.\n             return;"}, {"sha": "6a7758bedfb8009edcd731441f32a5dcc58f82ec", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -242,6 +242,7 @@ pub struct Body<'tcx> {\n \n impl<'tcx> Body<'tcx> {\n     pub fn new(\n+        tcx: TyCtxt<'tcx>,\n         source: MirSource<'tcx>,\n         basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n         source_scopes: IndexVec<SourceScope, SourceScopeData<'tcx>>,\n@@ -284,7 +285,7 @@ impl<'tcx> Body<'tcx> {\n             predecessor_cache: PredecessorCache::new(),\n             is_cyclic: GraphIsCyclicCache::new(),\n         };\n-        body.is_polymorphic = body.has_param_types_or_consts();\n+        body.is_polymorphic = body.has_param_types_or_consts(tcx);\n         body\n     }\n \n@@ -293,7 +294,10 @@ impl<'tcx> Body<'tcx> {\n     /// The returned MIR contains no `LocalDecl`s (even for the return place) or source scopes. It\n     /// is only useful for testing but cannot be `#[cfg(test)]` because it is used in a different\n     /// crate.\n-    pub fn new_cfg_only(basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>) -> Self {\n+    pub fn new_cfg_only(\n+        tcx: TyCtxt<'tcx>,\n+        basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n+    ) -> Self {\n         let mut body = Body {\n             phase: MirPhase::Build,\n             source: MirSource::item(DefId::local(CRATE_DEF_INDEX)),\n@@ -311,7 +315,7 @@ impl<'tcx> Body<'tcx> {\n             predecessor_cache: PredecessorCache::new(),\n             is_cyclic: GraphIsCyclicCache::new(),\n         };\n-        body.is_polymorphic = body.has_param_types_or_consts();\n+        body.is_polymorphic = body.has_param_types_or_consts(tcx);\n         body\n     }\n "}, {"sha": "174c35dbc7187309ddece035e973b5bddf85d9aa", "filename": "compiler/rustc_middle/src/ty/consts/kind.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -12,6 +12,12 @@ use rustc_target::abi::Size;\n \n use super::ScalarInt;\n /// An unevaluated, potentially generic, constant.\n+///\n+/// If `substs_` is `None` it means that this anon const\n+/// still has its default substs.\n+///\n+/// We check for all possible substs in `fn default_anon_const_substs`,\n+/// so refer to that check for more info.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, TyEncodable, TyDecodable)]\n #[derive(Hash, HashStable)]\n pub struct Unevaluated<'tcx> {"}, {"sha": "63eb55ed1a6208121d0e479810ae80209b0bce03", "filename": "compiler/rustc_middle/src/ty/erase_regions.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferase_regions.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -21,7 +21,9 @@ impl<'tcx> TyCtxt<'tcx> {\n         T: TypeFoldable<'tcx>,\n     {\n         // If there's nothing to erase avoid performing the query at all\n-        if !value.has_type_flags(TypeFlags::HAS_RE_LATE_BOUND | TypeFlags::HAS_FREE_REGIONS) {\n+        if !value\n+            .has_type_flags(TypeFlags::HAS_RE_LATE_BOUND | TypeFlags::HAS_POTENTIAL_FREE_REGIONS)\n+        {\n             return value;\n         }\n         debug!(\"erase_regions({:?})\", value);"}, {"sha": "41c2447cfc5159603be3aea5433032cf415ca7b9", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -34,6 +34,12 @@ impl FlagComputation {\n         result.flags\n     }\n \n+    pub fn for_unevaluated_const(uv: ty::Unevaluated<'_>) -> TypeFlags {\n+        let mut result = FlagComputation::new();\n+        result.add_unevaluated_const(uv);\n+        result.flags\n+    }\n+\n     fn add_flags(&mut self, flags: TypeFlags) {\n         self.flags = self.flags | flags;\n     }\n@@ -91,7 +97,7 @@ impl FlagComputation {\n             &ty::Error(_) => self.add_flags(TypeFlags::HAS_ERROR),\n \n             &ty::Param(_) => {\n-                self.add_flags(TypeFlags::HAS_TY_PARAM);\n+                self.add_flags(TypeFlags::HAS_KNOWN_TY_PARAM);\n                 self.add_flags(TypeFlags::STILL_FURTHER_SPECIALIZABLE);\n             }\n \n@@ -292,7 +298,7 @@ impl FlagComputation {\n                 self.add_bound_var(debruijn);\n             }\n             ty::ConstKind::Param(_) => {\n-                self.add_flags(TypeFlags::HAS_CT_PARAM);\n+                self.add_flags(TypeFlags::HAS_KNOWN_CT_PARAM);\n                 self.add_flags(TypeFlags::STILL_FURTHER_SPECIALIZABLE);\n             }\n             ty::ConstKind::Placeholder(_) => {\n@@ -305,8 +311,12 @@ impl FlagComputation {\n     }\n \n     fn add_unevaluated_const(&mut self, ct: ty::Unevaluated<'tcx>) {\n-        // TODO\n-        self.add_substs(ct.substs_.unwrap());\n+        if let Some(substs) = ct.substs_ {\n+            self.add_substs(substs);\n+        } else {\n+            self.add_flags(TypeFlags::STILL_FURTHER_SPECIALIZABLE);\n+            self.add_flags(TypeFlags::HAS_UNKNOWN_DEFAULT_CONST_SUBSTS);\n+        }\n         self.add_flags(TypeFlags::HAS_CT_PROJECTION);\n     }\n "}, {"sha": "0c5e292e6eb5b61e6454b5569a1d860ec595c215", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 82, "deletions": 21, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -74,8 +74,14 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n         self.has_vars_bound_at_or_above(ty::INNERMOST)\n     }\n \n+    fn definitely_has_type_flags(&self, tcx: TyCtxt<'tcx>, flags: TypeFlags) -> bool {\n+        self.visit_with(&mut HasTypeFlagsVisitor { tcx: Some(tcx), flags }).break_value()\n+            == Some(FoundFlags)\n+    }\n+\n     fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        self.visit_with(&mut HasTypeFlagsVisitor { flags }).break_value() == Some(FoundFlags)\n+        self.visit_with(&mut HasTypeFlagsVisitor { tcx: None, flags }).break_value()\n+            == Some(FoundFlags)\n     }\n     fn has_projections(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_PROJECTION)\n@@ -86,8 +92,18 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     fn references_error(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_ERROR)\n     }\n-    fn has_param_types_or_consts(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_TY_PARAM | TypeFlags::HAS_CT_PARAM)\n+    fn has_potential_param_types_or_consts(&self) -> bool {\n+        self.has_type_flags(\n+            TypeFlags::HAS_KNOWN_TY_PARAM\n+                | TypeFlags::HAS_KNOWN_CT_PARAM\n+                | TypeFlags::HAS_UNKNOWN_DEFAULT_CONST_SUBSTS,\n+        )\n+    }\n+    fn has_param_types_or_consts(&self, tcx: TyCtxt<'tcx>) -> bool {\n+        self.definitely_has_type_flags(\n+            tcx,\n+            TypeFlags::HAS_KNOWN_TY_PARAM | TypeFlags::HAS_KNOWN_CT_PARAM,\n+        )\n     }\n     fn has_infer_regions(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_RE_INFER)\n@@ -108,29 +124,44 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n                 | TypeFlags::HAS_CT_PLACEHOLDER,\n         )\n     }\n-    fn needs_subst(&self) -> bool {\n-        self.has_type_flags(TypeFlags::NEEDS_SUBST)\n+    fn potentially_needs_subst(&self) -> bool {\n+        self.has_type_flags(\n+            TypeFlags::KNOWN_NEEDS_SUBST | TypeFlags::HAS_UNKNOWN_DEFAULT_CONST_SUBSTS,\n+        )\n+    }\n+    fn needs_subst(&self, tcx: TyCtxt<'tcx>) -> bool {\n+        self.definitely_has_type_flags(tcx, TypeFlags::KNOWN_NEEDS_SUBST)\n     }\n     /// \"Free\" regions in this context means that it has any region\n     /// that is not (a) erased or (b) late-bound.\n-    fn has_free_regions(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_FREE_REGIONS)\n+    fn has_free_regions(&self, tcx: TyCtxt<'tcx>) -> bool {\n+        self.definitely_has_type_flags(tcx, TypeFlags::HAS_KNOWN_FREE_REGIONS)\n     }\n \n     fn has_erased_regions(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_RE_ERASED)\n     }\n \n     /// True if there are any un-erased free regions.\n-    fn has_erasable_regions(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_FREE_REGIONS)\n+    fn has_erasable_regions(&self, tcx: TyCtxt<'tcx>) -> bool {\n+        self.definitely_has_type_flags(tcx, TypeFlags::HAS_KNOWN_FREE_REGIONS)\n+    }\n+\n+    /// Indicates whether this value definitely references only 'global'\n+    /// generic parameters that are the same regardless of what fn we are\n+    /// in. This is used for caching.\n+    ///\n+    /// Note that this function is pessimistic and may incorrectly return\n+    /// `false`.\n+    fn is_known_global(&self) -> bool {\n+        !self.has_type_flags(TypeFlags::HAS_POTENTIAL_FREE_LOCAL_NAMES)\n     }\n \n     /// Indicates whether this value references only 'global'\n     /// generic parameters that are the same regardless of what fn we are\n     /// in. This is used for caching.\n-    fn is_global(&self) -> bool {\n-        !self.has_type_flags(TypeFlags::HAS_FREE_LOCAL_NAMES)\n+    fn is_global(&self, tcx: TyCtxt<'tcx>) -> bool {\n+        !self.definitely_has_type_flags(tcx, TypeFlags::HAS_KNOWN_FREE_LOCAL_NAMES)\n     }\n \n     /// True if there are any late-bound regions\n@@ -217,6 +248,10 @@ pub trait TypeVisitor<'tcx>: Sized {\n         c.super_visit_with(self)\n     }\n \n+    fn visit_unevaluated_const(&mut self, uv: ty::Unevaluated<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        uv.super_visit_with(self)\n+    }\n+\n     fn visit_predicate(&mut self, p: ty::Predicate<'tcx>) -> ControlFlow<Self::BreakTy> {\n         p.super_visit_with(self)\n     }\n@@ -369,7 +404,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n             fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n                 // We're only interested in types involving regions\n-                if ty.flags().intersects(TypeFlags::HAS_FREE_REGIONS) {\n+                if ty.flags().intersects(TypeFlags::HAS_POTENTIAL_FREE_REGIONS) {\n                     ty.super_visit_with(self)\n                 } else {\n                     ControlFlow::CONTINUE\n@@ -1078,23 +1113,19 @@ impl<'tcx> TypeVisitor<'tcx> for HasEscapingVarsVisitor {\n struct FoundFlags;\n \n // FIXME: Optimize for checking for infer flags\n-struct HasTypeFlagsVisitor {\n+struct HasTypeFlagsVisitor<'tcx> {\n+    tcx: Option<TyCtxt<'tcx>>,\n     flags: ty::TypeFlags,\n }\n \n-impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n+impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor<'tcx> {\n     type BreakTy = FoundFlags;\n     fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n-        // TypeFlagsVisitor must not look into the default anon const substs\n-        // as that would cause cycle errors, but we do care about them for\n-        // some flags.\n-        //\n-        // We therefore have to be very careful here.\n-        None\n+        self.tcx\n     }\n \n     #[inline]\n-    fn visit_ty(&mut self, t: Ty<'_>) -> ControlFlow<Self::BreakTy> {\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         debug!(\n             \"HasTypeFlagsVisitor: t={:?} t.flags={:?} self.flags={:?}\",\n             t,\n@@ -1103,6 +1134,11 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n         );\n         if t.flags().intersects(self.flags) {\n             ControlFlow::Break(FoundFlags)\n+        } else if self.tcx.is_some()\n+            && t.flags().intersects(TypeFlags::HAS_UNKNOWN_DEFAULT_CONST_SUBSTS)\n+            && self.flags.intersects(TypeFlags::MAY_NEED_DEFAULT_CONST_SUBSTS)\n+        {\n+            t.super_visit_with(self)\n         } else {\n             ControlFlow::CONTINUE\n         }\n@@ -1125,6 +1161,26 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n         debug!(\"HasTypeFlagsVisitor: c={:?} c.flags={:?} self.flags={:?}\", c, flags, self.flags);\n         if flags.intersects(self.flags) {\n             ControlFlow::Break(FoundFlags)\n+        } else if self.tcx.is_some()\n+            && flags.intersects(TypeFlags::HAS_UNKNOWN_DEFAULT_CONST_SUBSTS)\n+            && self.flags.intersects(TypeFlags::MAY_NEED_DEFAULT_CONST_SUBSTS)\n+        {\n+            c.super_visit_with(self)\n+        } else {\n+            ControlFlow::CONTINUE\n+        }\n+    }\n+\n+    fn visit_unevaluated_const(&mut self, uv: ty::Unevaluated<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        let flags = FlagComputation::for_unevaluated_const(uv);\n+        debug!(\"HasTypeFlagsVisitor: uv={:?} uv.flags={:?} self.flags={:?}\", uv, flags, self.flags);\n+        if flags.intersects(self.flags) {\n+            ControlFlow::Break(FoundFlags)\n+        } else if self.tcx.is_some()\n+            && flags.intersects(TypeFlags::HAS_UNKNOWN_DEFAULT_CONST_SUBSTS)\n+            && self.flags.intersects(TypeFlags::MAY_NEED_DEFAULT_CONST_SUBSTS)\n+        {\n+            uv.super_visit_with(self)\n         } else {\n             ControlFlow::CONTINUE\n         }\n@@ -1138,6 +1194,11 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n         );\n         if predicate.inner.flags.intersects(self.flags) {\n             ControlFlow::Break(FoundFlags)\n+        } else if self.tcx.is_some()\n+            && predicate.inner.flags.intersects(TypeFlags::HAS_UNKNOWN_DEFAULT_CONST_SUBSTS)\n+            && self.flags.intersects(TypeFlags::MAY_NEED_DEFAULT_CONST_SUBSTS)\n+        {\n+            predicate.super_visit_with(self)\n         } else {\n             ControlFlow::CONTINUE\n         }"}, {"sha": "6761fbaf53659e0ba6b1a21a7932e3fea2b23ccf", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -1727,7 +1727,9 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         // Ignore layouts that are done with non-empty environments or\n         // non-monomorphic layouts, as the user only wants to see the stuff\n         // resulting from the final codegen session.\n-        if layout.ty.has_param_types_or_consts() || !self.param_env.caller_bounds().is_empty() {\n+        if layout.ty.has_param_types_or_consts(self.tcx)\n+            || !self.param_env.caller_bounds().is_empty()\n+        {\n             return;\n         }\n \n@@ -1894,7 +1896,7 @@ impl<'tcx> SizeSkeleton<'tcx> {\n                 let tail = tcx.struct_tail_erasing_lifetimes(pointee, param_env);\n                 match tail.kind() {\n                     ty::Param(_) | ty::Projection(_) => {\n-                        debug_assert!(tail.has_param_types_or_consts());\n+                        debug_assert!(tail.has_param_types_or_consts(tcx));\n                         Ok(SizeSkeleton::Pointer { non_zero, tail: tcx.erase_regions(tail) })\n                     }\n                     _ => bug!("}, {"sha": "eccc1ebd80517cd02eb12d9267a4916a56070588", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -1292,7 +1292,7 @@ impl<'tcx> ParamEnv<'tcx> {\n             Reveal::UserFacing => ParamEnvAnd { param_env: self, value },\n \n             Reveal::All => {\n-                if value.is_global() {\n+                if value.is_known_global() {\n                     ParamEnvAnd { param_env: self.without_caller_bounds(), value }\n                 } else {\n                     ParamEnvAnd { param_env: self, value }"}, {"sha": "5c3da507e140612253293047064dd3725e58c52f", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -1201,7 +1201,9 @@ pub trait PrettyPrinter<'tcx>:\n             //\n             // FIXME(eddyb) for `--emit=mir`/`-Z dump-mir`, we should provide the\n             // correct `ty::ParamEnv` to allow printing *all* constant values.\n-            (_, ty::Array(..) | ty::Tuple(..) | ty::Adt(..)) if !ty.has_param_types_or_consts() => {\n+            (_, ty::Array(..) | ty::Tuple(..) | ty::Adt(..))\n+                if !ty.has_potential_param_types_or_consts() =>\n+            {\n                 let contents = self.tcx().destructure_const(\n                     ty::ParamEnv::reveal_all()\n                         .and(self.tcx().mk_const(ty::Const { val: ty::ConstKind::Value(ct), ty })),"}, {"sha": "369dfaf32a003d08ac83e1281fc76295850e827e", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -1086,6 +1086,10 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Unevaluated<'tcx> {\n         }\n     }\n \n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n+        visitor.visit_unevaluated_const(*self)\n+    }\n+\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n         if let Some(tcx) = visitor.tcx_for_anon_const_substs() {\n             self.substs(tcx).visit_with(visitor)"}, {"sha": "8b893b779c0a2d47a44974c399c1af59435c1734", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -1565,26 +1565,26 @@ impl RegionKind {\n \n         match *self {\n             ty::ReVar(..) => {\n-                flags = flags | TypeFlags::HAS_FREE_REGIONS;\n-                flags = flags | TypeFlags::HAS_FREE_LOCAL_REGIONS;\n+                flags = flags | TypeFlags::HAS_KNOWN_FREE_REGIONS;\n+                flags = flags | TypeFlags::HAS_KNOWN_FREE_LOCAL_REGIONS;\n                 flags = flags | TypeFlags::HAS_RE_INFER;\n             }\n             ty::RePlaceholder(..) => {\n-                flags = flags | TypeFlags::HAS_FREE_REGIONS;\n-                flags = flags | TypeFlags::HAS_FREE_LOCAL_REGIONS;\n+                flags = flags | TypeFlags::HAS_KNOWN_FREE_REGIONS;\n+                flags = flags | TypeFlags::HAS_KNOWN_FREE_LOCAL_REGIONS;\n                 flags = flags | TypeFlags::HAS_RE_PLACEHOLDER;\n             }\n             ty::ReEarlyBound(..) => {\n-                flags = flags | TypeFlags::HAS_FREE_REGIONS;\n-                flags = flags | TypeFlags::HAS_FREE_LOCAL_REGIONS;\n-                flags = flags | TypeFlags::HAS_RE_PARAM;\n+                flags = flags | TypeFlags::HAS_KNOWN_FREE_REGIONS;\n+                flags = flags | TypeFlags::HAS_KNOWN_FREE_LOCAL_REGIONS;\n+                flags = flags | TypeFlags::HAS_KNOWN_RE_PARAM;\n             }\n             ty::ReFree { .. } => {\n-                flags = flags | TypeFlags::HAS_FREE_REGIONS;\n-                flags = flags | TypeFlags::HAS_FREE_LOCAL_REGIONS;\n+                flags = flags | TypeFlags::HAS_KNOWN_FREE_REGIONS;\n+                flags = flags | TypeFlags::HAS_KNOWN_FREE_LOCAL_REGIONS;\n             }\n             ty::ReEmpty(_) | ty::ReStatic => {\n-                flags = flags | TypeFlags::HAS_FREE_REGIONS;\n+                flags = flags | TypeFlags::HAS_KNOWN_FREE_REGIONS;\n             }\n             ty::ReLateBound(..) => {\n                 flags = flags | TypeFlags::HAS_RE_LATE_BOUND;"}, {"sha": "2438d1a16021b50aa4f318d5946842e6bc6d4281", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -486,7 +486,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !t.needs_subst() {\n+        if !t.potentially_needs_subst() {\n             return t;\n         }\n \n@@ -497,10 +497,6 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n     }\n \n     fn fold_const(&mut self, c: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        if !c.needs_subst() {\n-            return c;\n-        }\n-\n         if let ty::ConstKind::Param(p) = c.val {\n             self.const_for_param(p, c)\n         } else {"}, {"sha": "566c11811e6e1108267411a5d79c688ed0809946", "filename": "compiler/rustc_mir/src/borrow_check/type_check/liveness/trace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -171,7 +171,7 @@ impl LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n         for (local, location) in drop_used {\n             if !live_locals.contains(&local) {\n                 let local_ty = self.cx.body.local_decls[local].ty;\n-                if local_ty.has_free_regions() {\n+                if local_ty.has_free_regions(self.cx.typeck.tcx()) {\n                     self.cx.add_drop_live_facts_for(local, local_ty, &[location], &locations);\n                 }\n             }"}, {"sha": "37c13c2d42aec6d19342b4d4e6ed69b3b75a5914", "filename": "compiler/rustc_mir/src/interpret/util.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Futil.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -9,7 +9,7 @@ where\n     T: TypeFoldable<'tcx>,\n {\n     debug!(\"ensure_monomorphic_enough: ty={:?}\", ty);\n-    if !ty.needs_subst() {\n+    if !ty.potentially_needs_subst() {\n         return Ok(());\n     }\n \n@@ -25,19 +25,8 @@ where\n             Some(self.tcx)\n         }\n \n-        fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-            if !c.needs_subst() {\n-                return ControlFlow::CONTINUE;\n-            }\n-\n-            match c.val {\n-                ty::ConstKind::Param(..) => ControlFlow::Break(FoundParam),\n-                _ => c.super_visit_with(self),\n-            }\n-        }\n-\n         fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-            if !ty.needs_subst() {\n+            if !ty.potentially_needs_subst() {\n                 return ControlFlow::CONTINUE;\n             }\n \n@@ -54,7 +43,7 @@ where\n                         let is_used = unused_params.contains(index).map_or(true, |unused| !unused);\n                         // Only recurse when generic parameters in fns, closures and generators\n                         // are used and require substitution.\n-                        match (is_used, subst.needs_subst()) {\n+                        match (is_used, subst.needs_subst(self.tcx)) {\n                             // Just in case there are closures or generators within this subst,\n                             // recurse.\n                             (true, true) => return subst.super_visit_with(self),\n@@ -77,6 +66,13 @@ where\n                 _ => ty.super_visit_with(self),\n             }\n         }\n+\n+        fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+            match c.val {\n+                ty::ConstKind::Param(..) => ControlFlow::Break(FoundParam),\n+                _ => c.super_visit_with(self),\n+            }\n+        }\n     }\n \n     let mut vis = UsedParamsNeedSubstVisitor { tcx };"}, {"sha": "368ac70b55203e61c29654317d212a565903ed5d", "filename": "compiler/rustc_mir/src/monomorphize/polymorphize.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpolymorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpolymorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpolymorphize.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -288,7 +288,7 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for MarkUsedGenericParams<'a, 'tcx> {\n     }\n     #[instrument(skip(self))]\n     fn visit_const(&mut self, c: &'tcx Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        if !c.has_param_types_or_consts() {\n+        if !c.has_potential_param_types_or_consts() {\n             return ControlFlow::CONTINUE;\n         }\n \n@@ -321,7 +321,7 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for MarkUsedGenericParams<'a, 'tcx> {\n \n     #[instrument(skip(self))]\n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        if !ty.has_param_types_or_consts() {\n+        if !ty.has_potential_param_types_or_consts() {\n             return ControlFlow::CONTINUE;\n         }\n \n@@ -363,7 +363,7 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for HasUsedGenericParams<'a, 'tcx> {\n \n     #[instrument(skip(self))]\n     fn visit_const(&mut self, c: &'tcx Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        if !c.has_param_types_or_consts() {\n+        if !c.has_potential_param_types_or_consts() {\n             return ControlFlow::CONTINUE;\n         }\n \n@@ -381,7 +381,7 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for HasUsedGenericParams<'a, 'tcx> {\n \n     #[instrument(skip(self))]\n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        if !ty.has_param_types_or_consts() {\n+        if !ty.has_potential_param_types_or_consts() {\n             return ControlFlow::CONTINUE;\n         }\n "}, {"sha": "8083ec954478a136cb6dd25599b6a4b208a21ebb", "filename": "compiler/rustc_mir/src/shim.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_mir%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_mir%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fshim.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -163,7 +163,7 @@ fn build_drop_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, ty: Option<Ty<'tcx>>)\n \n     let source = MirSource::from_instance(ty::InstanceDef::DropGlue(def_id, ty));\n     let mut body =\n-        new_body(source, blocks, local_decls_for_sig(&sig, span), sig.inputs().len(), span);\n+        new_body(tcx, source, blocks, local_decls_for_sig(&sig, span), sig.inputs().len(), span);\n \n     if ty.is_some() {\n         // The first argument (index 0), but add 1 for the return value.\n@@ -202,13 +202,15 @@ fn build_drop_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, ty: Option<Ty<'tcx>>)\n }\n \n fn new_body<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     source: MirSource<'tcx>,\n     basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n     local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n     arg_count: usize,\n     span: Span,\n ) -> Body<'tcx> {\n     Body::new(\n+        tcx,\n         source,\n         basic_blocks,\n         IndexVec::from_elem_n(\n@@ -353,7 +355,14 @@ impl CloneShimBuilder<'tcx> {\n             self.def_id,\n             self.sig.inputs_and_output[0],\n         ));\n-        new_body(source, self.blocks, self.local_decls, self.sig.inputs().len(), self.span)\n+        new_body(\n+            self.tcx,\n+            source,\n+            self.blocks,\n+            self.local_decls,\n+            self.sig.inputs().len(),\n+            self.span,\n+        )\n     }\n \n     fn source_info(&self) -> SourceInfo {\n@@ -851,8 +860,14 @@ fn build_call_shim<'tcx>(\n         block(&mut blocks, vec![], TerminatorKind::Resume, true);\n     }\n \n-    let mut body =\n-        new_body(MirSource::from_instance(instance), blocks, local_decls, sig.inputs().len(), span);\n+    let mut body = new_body(\n+        tcx,\n+        MirSource::from_instance(instance),\n+        blocks,\n+        local_decls,\n+        sig.inputs().len(),\n+        span,\n+    );\n \n     if let Abi::RustCall = sig.abi {\n         body.spread_arg = Some(Local::new(sig.inputs().len()));\n@@ -917,6 +932,7 @@ pub fn build_adt_ctor(tcx: TyCtxt<'_>, ctor_id: DefId) -> Body<'_> {\n \n     let source = MirSource::item(ctor_id);\n     let body = new_body(\n+        tcx,\n         source,\n         IndexVec::from_elem_n(start_block, 1),\n         local_decls,"}, {"sha": "0d58625633f083e1ecd4a53c1f97ce6f806959e4", "filename": "compiler/rustc_mir/src/transform/const_prop.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -120,7 +120,7 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n             .predicates_of(def_id.to_def_id())\n             .predicates\n             .iter()\n-            .filter_map(|(p, _)| if p.is_global() { Some(*p) } else { None });\n+            .filter_map(|(p, _)| if p.is_global(tcx) { Some(*p) } else { None });\n         if traits::impossible_predicates(\n             tcx,\n             traits::elaborate_predicates(tcx, predicates).map(|o| o.predicate).collect(),\n@@ -132,6 +132,7 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n         trace!(\"ConstProp starting for {:?}\", def_id);\n \n         let dummy_body = &Body::new(\n+            tcx,\n             body.source,\n             body.basic_blocks().clone(),\n             body.source_scopes.clone(),\n@@ -468,7 +469,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     /// Returns the value, if any, of evaluating `c`.\n     fn eval_constant(&mut self, c: &Constant<'tcx>, source_info: SourceInfo) -> Option<OpTy<'tcx>> {\n         // FIXME we need to revisit this for #67176\n-        if c.needs_subst() {\n+        if c.needs_subst(self.tcx) {\n             return None;\n         }\n \n@@ -488,9 +489,9 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                             }) => true,\n                             // Out of backwards compatibility we cannot report hard errors in unused\n                             // generic functions using associated constants of the generic parameters.\n-                            _ => c.literal.needs_subst(),\n+                            _ => c.literal.needs_subst(*tcx),\n                         },\n-                        ConstantKind::Val(_, ty) => ty.needs_subst(),\n+                        ConstantKind::Val(_, ty) => ty.needs_subst(*tcx),\n                     };\n                     if lint_only {\n                         // Out of backwards compatibility we cannot report hard errors in unused\n@@ -720,7 +721,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n \n         // FIXME we need to revisit this for #67176\n-        if rvalue.needs_subst() {\n+        if rvalue.needs_subst(self.tcx) {\n             return None;\n         }\n "}, {"sha": "46628b928de92c204238e3fe7610c56b0cc8c11e", "filename": "compiler/rustc_mir/src/transform/inline/cycle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline%2Fcycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline%2Fcycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline%2Fcycle.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -89,7 +89,7 @@ crate fn mir_callgraph_reachable(\n                     // FIXME: A not fully substituted drop shim can cause ICEs if one attempts to\n                     // have its MIR built. Likely oli-obk just screwed up the `ParamEnv`s, so this\n                     // needs some more analysis.\n-                    if callee.needs_subst() {\n+                    if callee.needs_subst(tcx) {\n                         continue;\n                     }\n                 }"}, {"sha": "d4c2456e9a4367f9591b7db075163c7f845da290", "filename": "compiler/rustc_mir/src/transform/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -400,7 +400,7 @@ fn inner_mir_for_ctfe(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -\n         }\n     }\n \n-    debug_assert!(!body.has_free_regions(), \"Free regions in MIR for CTFE\");\n+    debug_assert!(!body.has_free_regions(tcx), \"Free regions in MIR for CTFE\");\n \n     body\n }\n@@ -594,7 +594,7 @@ fn inner_optimized_mir(tcx: TyCtxt<'_>, did: LocalDefId) -> Body<'_> {\n         tcx.mir_drops_elaborated_and_const_checked(ty::WithOptConstParam::unknown(did)).steal();\n     run_optimization_passes(tcx, &mut body);\n \n-    debug_assert!(!body.has_free_regions(), \"Free regions in optimized MIR\");\n+    debug_assert!(!body.has_free_regions(tcx), \"Free regions in optimized MIR\");\n \n     body\n }\n@@ -621,7 +621,7 @@ fn promoted_mir<'tcx>(\n         run_post_borrowck_cleanup_passes(tcx, body);\n     }\n \n-    debug_assert!(!promoted.has_free_regions(), \"Free regions in promoted MIR\");\n+    debug_assert!(!promoted.has_free_regions(tcx), \"Free regions in promoted MIR\");\n \n     tcx.arena.alloc(promoted)\n }"}, {"sha": "1b43670ba3ac103eaa3021f0b2e2a0c7c69545c7", "filename": "compiler/rustc_mir/src/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -992,6 +992,7 @@ pub fn promote_candidates<'tcx>(\n         scope.parent_scope = None;\n \n         let promoted = Body::new(\n+            tcx,\n             body.source, // `promoted` gets filled in below\n             IndexVec::new(),\n             IndexVec::from_elem_n(scope, 1),"}, {"sha": "0a760a740dcaea5801a8b4bcb854d19ba6758d50", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -239,10 +239,10 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n         // The exception is `body.user_type_annotations`, which is used unmodified\n         // by borrow checking.\n         debug_assert!(\n-            !(body.local_decls.has_free_regions()\n-                || body.basic_blocks().has_free_regions()\n-                || body.var_debug_info.has_free_regions()\n-                || body.yield_ty().has_free_regions()),\n+            !(body.local_decls.has_free_regions(tcx)\n+                || body.basic_blocks().has_free_regions(tcx)\n+                || body.var_debug_info.has_free_regions(tcx)\n+                || body.yield_ty().has_free_regions(tcx)),\n             \"Unexpected free regions in MIR: {:?}\",\n             body,\n         );\n@@ -755,6 +755,7 @@ fn construct_error<'a, 'tcx>(\n     cfg.terminate(START_BLOCK, source_info, TerminatorKind::Unreachable);\n \n     let mut body = Body::new(\n+        tcx,\n         MirSource::item(def.did.to_def_id()),\n         cfg.basic_blocks,\n         source_scopes,\n@@ -843,6 +844,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n \n         Body::new(\n+            self.tcx,\n             MirSource::item(self.def_id),\n             self.cfg.basic_blocks,\n             self.source_scopes,"}, {"sha": "267e2d8808fb395f4da18c98ab911cabedbbb926", "filename": "compiler/rustc_symbol_mangling/src/legacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -109,7 +109,7 @@ fn get_symbol_hash<'tcx>(\n         // Include the main item-type. Note that, in this case, the\n         // assertions about `needs_subst` may not hold, but this item-type\n         // ought to be the same for every reference anyway.\n-        assert!(!item_type.has_erasable_regions());\n+        assert!(!item_type.has_erasable_regions(tcx));\n         hcx.while_hashing_spans(false, |hcx| {\n             hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n                 item_type.hash_stable(hcx, &mut hasher);"}, {"sha": "3ac9d1e5745f152651e80f819e082a8d1c71acd3", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -277,7 +277,8 @@ impl Printer<'tcx> for &mut SymbolMangler<'tcx> {\n \n         // Encode impl generic params if the substitutions contain parameters (implying\n         // polymorphization is enabled) and this isn't an inherent impl.\n-        if impl_trait_ref.is_some() && substs.iter().any(|a| a.has_param_types_or_consts()) {\n+        if impl_trait_ref.is_some() && substs.iter().any(|a| a.has_param_types_or_consts(self.tcx))\n+        {\n             self = self.path_generic_args(\n                 |this| {\n                     this.path_append_ns("}, {"sha": "b743c809ca2434926b49c0f80ee205744d366cd5", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -583,7 +583,7 @@ where\n \n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         // We're only interested in types involving regions\n-        if !ty.flags().intersects(ty::TypeFlags::HAS_FREE_REGIONS) {\n+        if !ty.flags().intersects(ty::TypeFlags::HAS_POTENTIAL_FREE_REGIONS) {\n             return ControlFlow::CONTINUE;\n         }\n "}, {"sha": "6ab079ad404d52543571863c0c01781bb4a51158", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -391,7 +391,7 @@ fn orphan_check_trait_ref<'tcx>(\n ) -> Result<(), OrphanCheckErr<'tcx>> {\n     debug!(\"orphan_check_trait_ref(trait_ref={:?}, in_crate={:?})\", trait_ref, in_crate);\n \n-    if trait_ref.needs_infer() && trait_ref.needs_subst() {\n+    if trait_ref.needs_infer() && trait_ref.needs_subst(tcx) {\n         bug!(\n             \"can't orphan check a trait ref with both params and inference variables {:?}\",\n             trait_ref"}, {"sha": "2cc74ca2abb4be05322b6687b72cfdec9f4a3221", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -91,7 +91,7 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n                         let leaf = leaf.subst(tcx, ct.substs);\n                         if leaf.has_infer_types_or_consts() {\n                             failure_kind = FailureKind::MentionsInfer;\n-                        } else if leaf.has_param_types_or_consts() {\n+                        } else if leaf.has_param_types_or_consts(tcx) {\n                             failure_kind = cmp::min(failure_kind, FailureKind::MentionsParam);\n                         }\n \n@@ -101,7 +101,7 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n                         let ty = ty.subst(tcx, ct.substs);\n                         if ty.has_infer_types_or_consts() {\n                             failure_kind = FailureKind::MentionsInfer;\n-                        } else if ty.has_param_types_or_consts() {\n+                        } else if ty.has_param_types_or_consts(tcx) {\n                             failure_kind = cmp::min(failure_kind, FailureKind::MentionsParam);\n                         }\n \n@@ -158,7 +158,7 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n     let concrete =\n         infcx.const_eval_resolve(param_env, ty::Unevaluated::new(def, substs), Some(span));\n \n-    if concrete.is_ok() && substs.has_param_types_or_consts() {\n+    if concrete.is_ok() && substs.has_param_types_or_consts(infcx.tcx) {\n         match infcx.tcx.def_kind(def.did) {\n             DefKind::AnonConst => {\n                 let mir_body = infcx.tcx.mir_for_ctfe_opt_const_arg(def);"}, {"sha": "edf2274ab54ff7a4030b8449516a2ddcf64b0f9e", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -669,7 +669,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n         stalled_on: &mut Vec<TyOrConstInferVar<'tcx>>,\n     ) -> ProcessResult<PendingPredicateObligation<'tcx>, FulfillmentErrorCode<'tcx>> {\n         let infcx = self.selcx.infcx();\n-        if obligation.predicate.is_global() {\n+        if obligation.predicate.is_known_global() {\n             // no type variables present, can use evaluation for better caching.\n             // FIXME: consider caching errors too.\n             //\n@@ -728,7 +728,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n     ) -> ProcessResult<PendingPredicateObligation<'tcx>, FulfillmentErrorCode<'tcx>> {\n         let tcx = self.selcx.tcx();\n \n-        if obligation.predicate.is_global() {\n+        if obligation.predicate.is_global(tcx) {\n             // no type variables present, can use evaluation for better caching.\n             // FIXME: consider caching errors too.\n             //"}, {"sha": "43ee1c3304ab7ca69f734e2e4a58c001b5d32376", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -450,7 +450,7 @@ fn subst_and_check_impossible_predicates<'tcx>(\n     debug!(\"subst_and_check_impossible_predicates(key={:?})\", key);\n \n     let mut predicates = tcx.predicates_of(key.0).instantiate(tcx, key.1).predicates;\n-    predicates.retain(|predicate| !predicate.needs_subst());\n+    predicates.retain(|predicate| !predicate.needs_subst(tcx));\n     let result = impossible_predicates(tcx, predicates);\n \n     debug!(\"subst_and_check_impossible_predicates(key={:?}) = {:?}\", key, result);"}, {"sha": "1c4e7e6c5898082be8eedb4bded6e6b276597dbb", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -544,7 +544,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 },\n \n                 ty::PredicateKind::TypeOutlives(pred) => {\n-                    if pred.0.is_global() {\n+                    if pred.0.is_known_global() {\n                         Ok(EvaluatedToOk)\n                     } else {\n                         Ok(EvaluatedToOkModuloRegions)\n@@ -692,8 +692,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(?obligation, \"evaluate_trait_predicate_recursively\");\n \n         if !self.intercrate\n-            && obligation.is_global()\n-            && obligation.param_env.caller_bounds().iter().all(|bound| bound.needs_subst())\n+            && obligation.is_global(self.tcx())\n+            && obligation\n+                .param_env\n+                .caller_bounds()\n+                .iter()\n+                .all(|bound| bound.needs_subst(self.tcx()))\n         {\n             // If a param env has no global bounds, global obligations do not\n             // depend on its particular value in order to work, so we can clear\n@@ -1452,7 +1456,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // the param_env so that it can be given the lowest priority. See\n         // #50825 for the motivation for this.\n         let is_global =\n-            |cand: &ty::PolyTraitRef<'_>| cand.is_global() && !cand.has_late_bound_regions();\n+            |cand: &ty::PolyTraitRef<'_>| cand.is_known_global() && !cand.has_late_bound_regions();\n \n         // (*) Prefer `BuiltinCandidate { has_nested: false }`, `PointeeCandidate`,\n         // and `DiscriminantKindCandidate` to anything else."}, {"sha": "c405bbe2d1f53abb2193df1b8a478db40843ced5", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 67, "deletions": 45, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -19,94 +19,116 @@ bitflags! {\n         // Does this have parameters? Used to determine whether substitution is\n         // required.\n         /// Does this have `Param`?\n-        const HAS_TY_PARAM                = 1 << 0;\n+        const HAS_KNOWN_TY_PARAM                = 1 << 0;\n         /// Does this have `ReEarlyBound`?\n-        const HAS_RE_PARAM                = 1 << 1;\n+        const HAS_KNOWN_RE_PARAM                = 1 << 1;\n         /// Does this have `ConstKind::Param`?\n-        const HAS_CT_PARAM                = 1 << 2;\n+        const HAS_KNOWN_CT_PARAM                = 1 << 2;\n \n-        const NEEDS_SUBST                 = TypeFlags::HAS_TY_PARAM.bits\n-                                          | TypeFlags::HAS_RE_PARAM.bits\n-                                          | TypeFlags::HAS_CT_PARAM.bits;\n+        const KNOWN_NEEDS_SUBST                 = TypeFlags::HAS_KNOWN_TY_PARAM.bits\n+                                                | TypeFlags::HAS_KNOWN_RE_PARAM.bits\n+                                                | TypeFlags::HAS_KNOWN_CT_PARAM.bits;\n \n         /// Does this have `Infer`?\n-        const HAS_TY_INFER                = 1 << 3;\n+        const HAS_TY_INFER                      = 1 << 3;\n         /// Does this have `ReVar`?\n-        const HAS_RE_INFER                = 1 << 4;\n+        const HAS_RE_INFER                      = 1 << 4;\n         /// Does this have `ConstKind::Infer`?\n-        const HAS_CT_INFER                = 1 << 5;\n+        const HAS_CT_INFER                      = 1 << 5;\n \n         /// Does this have inference variables? Used to determine whether\n         /// inference is required.\n-        const NEEDS_INFER                 = TypeFlags::HAS_TY_INFER.bits\n-                                          | TypeFlags::HAS_RE_INFER.bits\n-                                          | TypeFlags::HAS_CT_INFER.bits;\n+        const NEEDS_INFER                       = TypeFlags::HAS_TY_INFER.bits\n+                                                | TypeFlags::HAS_RE_INFER.bits\n+                                                | TypeFlags::HAS_CT_INFER.bits;\n \n         /// Does this have `Placeholder`?\n-        const HAS_TY_PLACEHOLDER          = 1 << 6;\n+        const HAS_TY_PLACEHOLDER                = 1 << 6;\n         /// Does this have `RePlaceholder`?\n-        const HAS_RE_PLACEHOLDER          = 1 << 7;\n+        const HAS_RE_PLACEHOLDER                = 1 << 7;\n         /// Does this have `ConstKind::Placeholder`?\n-        const HAS_CT_PLACEHOLDER          = 1 << 8;\n+        const HAS_CT_PLACEHOLDER                = 1 << 8;\n \n         /// `true` if there are \"names\" of regions and so forth\n         /// that are local to a particular fn/inferctxt\n-        const HAS_FREE_LOCAL_REGIONS      = 1 << 9;\n+        const HAS_KNOWN_FREE_LOCAL_REGIONS      = 1 << 9;\n \n         /// `true` if there are \"names\" of types and regions and so forth\n         /// that are local to a particular fn\n-        const HAS_FREE_LOCAL_NAMES        = TypeFlags::HAS_TY_PARAM.bits\n-                                          | TypeFlags::HAS_CT_PARAM.bits\n-                                          | TypeFlags::HAS_TY_INFER.bits\n-                                          | TypeFlags::HAS_CT_INFER.bits\n-                                          | TypeFlags::HAS_TY_PLACEHOLDER.bits\n-                                          | TypeFlags::HAS_CT_PLACEHOLDER.bits\n-                                          // We consider 'freshened' types and constants\n-                                          // to depend on a particular fn.\n-                                          // The freshening process throws away information,\n-                                          // which can make things unsuitable for use in a global\n-                                          // cache. Note that there is no 'fresh lifetime' flag -\n-                                          // freshening replaces all lifetimes with `ReErased`,\n-                                          // which is different from how types/const are freshened.\n-                                          | TypeFlags::HAS_TY_FRESH.bits\n-                                          | TypeFlags::HAS_CT_FRESH.bits\n-                                          | TypeFlags::HAS_FREE_LOCAL_REGIONS.bits;\n+        const HAS_KNOWN_FREE_LOCAL_NAMES        = TypeFlags::HAS_KNOWN_TY_PARAM.bits\n+                                                | TypeFlags::HAS_KNOWN_CT_PARAM.bits\n+                                                | TypeFlags::HAS_TY_INFER.bits\n+                                                | TypeFlags::HAS_CT_INFER.bits\n+                                                | TypeFlags::HAS_TY_PLACEHOLDER.bits\n+                                                | TypeFlags::HAS_CT_PLACEHOLDER.bits\n+                                                // We consider 'freshened' types and constants\n+                                                // to depend on a particular fn.\n+                                                // The freshening process throws away information,\n+                                                // which can make things unsuitable for use in a global\n+                                                // cache. Note that there is no 'fresh lifetime' flag -\n+                                                // freshening replaces all lifetimes with `ReErased`,\n+                                                // which is different from how types/const are freshened.\n+                                                | TypeFlags::HAS_TY_FRESH.bits\n+                                                | TypeFlags::HAS_CT_FRESH.bits\n+                                                | TypeFlags::HAS_KNOWN_FREE_LOCAL_REGIONS.bits;\n+\n+        const HAS_POTENTIAL_FREE_LOCAL_NAMES    = TypeFlags::HAS_KNOWN_FREE_LOCAL_NAMES.bits\n+                                                | TypeFlags::HAS_UNKNOWN_DEFAULT_CONST_SUBSTS.bits;\n \n         /// Does this have `Projection`?\n-        const HAS_TY_PROJECTION           = 1 << 10;\n+        const HAS_TY_PROJECTION                 = 1 << 10;\n         /// Does this have `Opaque`?\n-        const HAS_TY_OPAQUE               = 1 << 11;\n+        const HAS_TY_OPAQUE                     = 1 << 11;\n         /// Does this have `ConstKind::Unevaluated`?\n-        const HAS_CT_PROJECTION           = 1 << 12;\n+        const HAS_CT_PROJECTION                 = 1 << 12;\n \n         /// Could this type be normalized further?\n-        const HAS_PROJECTION              = TypeFlags::HAS_TY_PROJECTION.bits\n-                                          | TypeFlags::HAS_TY_OPAQUE.bits\n-                                          | TypeFlags::HAS_CT_PROJECTION.bits;\n+        const HAS_PROJECTION                    = TypeFlags::HAS_TY_PROJECTION.bits\n+                                                | TypeFlags::HAS_TY_OPAQUE.bits\n+                                                | TypeFlags::HAS_CT_PROJECTION.bits;\n \n         /// Is an error type/const reachable?\n-        const HAS_ERROR                   = 1 << 13;\n+        const HAS_ERROR                         = 1 << 13;\n \n         /// Does this have any region that \"appears free\" in the type?\n         /// Basically anything but `ReLateBound` and `ReErased`.\n-        const HAS_FREE_REGIONS            = 1 << 14;\n+        const HAS_KNOWN_FREE_REGIONS            = 1 << 14;\n+\n+        const HAS_POTENTIAL_FREE_REGIONS        = TypeFlags::HAS_KNOWN_FREE_REGIONS.bits\n+                                                | TypeFlags::HAS_UNKNOWN_DEFAULT_CONST_SUBSTS.bits;\n \n         /// Does this have any `ReLateBound` regions? Used to check\n         /// if a global bound is safe to evaluate.\n-        const HAS_RE_LATE_BOUND           = 1 << 15;\n+        const HAS_RE_LATE_BOUND                 = 1 << 15;\n \n         /// Does this have any `ReErased` regions?\n-        const HAS_RE_ERASED               = 1 << 16;\n+        const HAS_RE_ERASED                     = 1 << 16;\n \n         /// Does this value have parameters/placeholders/inference variables which could be\n         /// replaced later, in a way that would change the results of `impl` specialization?\n-        const STILL_FURTHER_SPECIALIZABLE = 1 << 17;\n+        ///\n+        /// Note that this flag being set is not a guarantee, as it is also\n+        /// set if there are any anon consts with unknown default substs.\n+        const STILL_FURTHER_SPECIALIZABLE       = 1 << 17;\n \n         /// Does this value have `InferTy::FreshTy/FreshIntTy/FreshFloatTy`?\n-        const HAS_TY_FRESH                = 1 << 18;\n+        const HAS_TY_FRESH                      = 1 << 18;\n \n         /// Does this value have `InferConst::Fresh`?\n-        const HAS_CT_FRESH                = 1 << 19;\n+        const HAS_CT_FRESH                      = 1 << 19;\n+\n+        /// Does this value have unknown default anon const substs.\n+        ///\n+        /// For more details refer to...\n+        /// FIXME(@lcnr): ask me for now, still have to write all of this.\n+        const HAS_UNKNOWN_DEFAULT_CONST_SUBSTS  = 1 << 20;\n+        /// Flags which can be influenced by default anon const substs.\n+        const MAY_NEED_DEFAULT_CONST_SUBSTS     = TypeFlags::HAS_KNOWN_RE_PARAM.bits\n+                                                | TypeFlags::HAS_KNOWN_TY_PARAM.bits\n+                                                | TypeFlags::HAS_KNOWN_CT_PARAM.bits\n+                                                | TypeFlags::HAS_KNOWN_FREE_LOCAL_REGIONS.bits\n+                                                | TypeFlags::HAS_KNOWN_FREE_REGIONS.bits;\n+\n     }\n }\n "}, {"sha": "bbfceeeff48360d4a60496182a9a672e49649fac", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -2204,7 +2204,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 self.prohibit_generics(path.segments);\n                 // Try to evaluate any array length constants.\n                 let normalized_ty = self.normalize_ty(span, tcx.at(span).type_of(def_id));\n-                if forbid_generic && normalized_ty.needs_subst() {\n+                if forbid_generic && normalized_ty.needs_subst(tcx) {\n                     let mut err = tcx.sess.struct_span_err(\n                         path.span,\n                         \"generic `Self` types are currently not permitted in anonymous constants\","}, {"sha": "25d1c8706e874db89651462d90596388b7049189", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -239,7 +239,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.tag(),\n         );\n \n-        if Self::can_contain_user_lifetime_bounds((substs, user_self_ty)) {\n+        if self.can_contain_user_lifetime_bounds((substs, user_self_ty)) {\n             let canonicalized = self.infcx.canonicalize_user_type_annotation(UserType::TypeOf(\n                 def_id,\n                 UserSubsts { substs, user_self_ty },\n@@ -481,7 +481,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let ty = self.to_ty(ast_ty);\n         debug!(\"to_ty_saving_user_provided_ty: ty={:?}\", ty);\n \n-        if Self::can_contain_user_lifetime_bounds(ty) {\n+        if self.can_contain_user_lifetime_bounds(ty) {\n             let c_ty = self.infcx.canonicalize_response(UserType::Ty(ty));\n             debug!(\"to_ty_saving_user_provided_ty: c_ty={:?}\", c_ty);\n             self.typeck_results.borrow_mut().user_provided_types_mut().insert(ast_ty.hir_id, c_ty);\n@@ -526,11 +526,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     // reader, although I have my doubts). Also pass in types with inference\n     // types, because they may be repeated. Other sorts of things are already\n     // sufficiently enforced with erased regions. =)\n-    fn can_contain_user_lifetime_bounds<T>(t: T) -> bool\n+    fn can_contain_user_lifetime_bounds<T>(&self, t: T) -> bool\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        t.has_free_regions() || t.has_projections() || t.has_infer_types()\n+        t.has_free_regions(self.tcx) || t.has_projections() || t.has_infer_types()\n     }\n \n     pub fn node_ty(&self, id: hir::HirId) -> Ty<'tcx> {"}, {"sha": "057a15a435866dcb0e9dc5088b656df3dae0b86c", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -746,7 +746,7 @@ fn check_where_clauses<'tcx, 'fcx>(\n                     // Ignore dependent defaults -- that is, where the default of one type\n                     // parameter includes another (e.g., `<T, U = T>`). In those cases, we can't\n                     // be sure if it will error or not as user might always specify the other.\n-                    if !ty.needs_subst() {\n+                    if !ty.needs_subst(tcx) {\n                         fcx.register_wf_obligation(\n                             ty.into(),\n                             tcx.def_span(param.def_id),\n@@ -762,7 +762,7 @@ fn check_where_clauses<'tcx, 'fcx>(\n                     // for `struct Foo<const N: usize, const M: usize = { 1 - 2 }>`\n                     // we should eagerly error.\n                     let default_ct = tcx.const_param_default(param.def_id);\n-                    if !default_ct.needs_subst() {\n+                    if !default_ct.needs_subst(tcx) {\n                         fcx.register_wf_obligation(\n                             default_ct.into(),\n                             tcx.def_span(param.def_id),\n@@ -796,7 +796,7 @@ fn check_where_clauses<'tcx, 'fcx>(\n                 if is_our_default(param) {\n                     let default_ty = tcx.type_of(param.def_id);\n                     // ... and it's not a dependent default, ...\n-                    if !default_ty.needs_subst() {\n+                    if !default_ty.needs_subst(tcx) {\n                         // ... then substitute it with the default.\n                         return default_ty.into();\n                     }\n@@ -809,7 +809,7 @@ fn check_where_clauses<'tcx, 'fcx>(\n                 if is_our_default(param) {\n                     let default_ct = tcx.const_param_default(param.def_id);\n                     // ... and it's not a dependent default, ...\n-                    if !default_ct.needs_subst() {\n+                    if !default_ct.needs_subst(tcx) {\n                         // ... then substitute it with the default.\n                         return default_ct.into();\n                     }\n@@ -858,7 +858,7 @@ fn check_where_clauses<'tcx, 'fcx>(\n             let substituted_pred = pred.subst(tcx, substs);\n             // Don't check non-defaulted params, dependent defaults (including lifetimes)\n             // or preds with multiple params.\n-            if substituted_pred.has_param_types_or_consts()\n+            if substituted_pred.has_param_types_or_consts(tcx)\n                 || param_count.params.len() > 1\n                 || has_region\n             {\n@@ -1380,7 +1380,7 @@ fn check_false_global_bounds(fcx: &FnCtxt<'_, '_>, span: Span, id: hir::HirId) {\n     for obligation in implied_obligations {\n         let pred = obligation.predicate;\n         // Match the existing behavior.\n-        if pred.is_global() && !pred.has_late_bound_regions() {\n+        if pred.is_global(fcx.tcx) && !pred.has_late_bound_regions() {\n             let pred = fcx.normalize_associated_types_in(span, pred);\n             let obligation = traits::Obligation::new(\n                 traits::ObligationCause::new(span, id, traits::TrivialBound),"}, {"sha": "c57ec9ef78f6856804cbe95c990e5b3b6a56241e", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -130,7 +130,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n     fn write_ty_to_typeck_results(&mut self, hir_id: hir::HirId, ty: Ty<'tcx>) {\n         debug!(\"write_ty_to_typeck_results({:?}, {:?})\", hir_id, ty);\n-        assert!(!ty.needs_infer() && !ty.has_placeholders() && !ty.has_free_regions());\n+        assert!(!ty.needs_infer() && !ty.has_placeholders() && !ty.has_free_regions(self.tcx()));\n         self.typeck_results.node_types_mut().insert(hir_id, ty);\n     }\n "}, {"sha": "9b10874b8bcf3fdec5b59dff40f9529ab883ed8f", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -275,7 +275,16 @@ fn get_path_containing_arg_in_pat<'hir>(\n }\n \n pub(super) fn default_anon_const_substs(tcx: TyCtxt<'_>, def_id: DefId) -> SubstsRef<'_> {\n-    InternalSubsts::identity_for_item(tcx, def_id)\n+    let substs = InternalSubsts::identity_for_item(tcx, def_id);\n+    // We only expect substs with the following type flags as default substs.\n+    //\n+    // Getting this wrong can lead to ICE and unsoundness, so we assert it here.\n+    for arg in substs.iter().flat_map(|s| s.walk(tcx)) {\n+        let allowed_flags = ty::TypeFlags::MAY_NEED_DEFAULT_CONST_SUBSTS\n+            | ty::TypeFlags::STILL_FURTHER_SPECIALIZABLE;\n+        assert!(!arg.has_type_flags(!allowed_flags));\n+    }\n+    substs\n }\n \n pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {"}, {"sha": "d3e4be128a8df54a7b1c93b20da1cb82530b833c", "filename": "compiler/rustc_typeck/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -363,7 +363,7 @@ fn check_specialization_on<'tcx>(tcx: TyCtxt<'tcx>, predicate: ty::Predicate<'tc\n     match predicate.kind().skip_binder() {\n         // Global predicates are either always true or always false, so we\n         // are fine to specialize on.\n-        _ if predicate.is_global() => (),\n+        _ if predicate.is_global(tcx) => (),\n         // We allow specializing on explicitly marked traits with no associated\n         // items.\n         ty::PredicateKind::Trait(ty::TraitPredicate {"}, {"sha": "90b2aa16896267b3fd66d06d739a34a202d88db4", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -117,7 +117,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n         let fn_def_id = cx.tcx.hir().local_def_id(hir_id);\n \n         let preds = traits::elaborate_predicates(cx.tcx, cx.param_env.caller_bounds().iter())\n-            .filter(|p| !p.is_global())\n+            .filter(|p| !p.is_global(cx.tcx))\n             .filter_map(|obligation| {\n                 // Note that we do not want to deal with qualified predicates here.\n                 match obligation.predicate.kind().no_bound_vars() {"}, {"sha": "ddff1686ba2ce99f9ac3f22de1abe04cd50997f8", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9108b70f25ecd9cce1ab756b82cb00de6c6927/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=ab9108b70f25ecd9cce1ab756b82cb00de6c6927", "patch": "@@ -1581,7 +1581,7 @@ pub fn fn_has_unsatisfiable_preds(cx: &LateContext<'_>, did: DefId) -> bool {\n         .predicates_of(did)\n         .predicates\n         .iter()\n-        .filter_map(|(p, _)| if p.is_global() { Some(*p) } else { None });\n+        .filter_map(|(p, _)| if p.is_global(cx.tcx) { Some(*p) } else { None });\n     traits::impossible_predicates(\n         cx.tcx,\n         traits::elaborate_predicates(cx.tcx, predicates)"}]}