{"sha": "ab34864a304fa364dc91bf16988e272e93de8d62", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiMzQ4NjRhMzA0ZmEzNjRkYzkxYmYxNjk4OGUyNzJlOTNkZThkNjI=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-07-02T21:32:21Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-07-02T21:32:21Z"}, "message": "Merge pull request #7187 from nikomatsakis/issue-3238-defer-reasoning-about-regions\n\nDefer reasoning about regions until after regionck", "tree": {"sha": "0fcd338308200b79a27bd99b0c3968e8b44f0b10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0fcd338308200b79a27bd99b0c3968e8b44f0b10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab34864a304fa364dc91bf16988e272e93de8d62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab34864a304fa364dc91bf16988e272e93de8d62", "html_url": "https://github.com/rust-lang/rust/commit/ab34864a304fa364dc91bf16988e272e93de8d62", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab34864a304fa364dc91bf16988e272e93de8d62/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2db7c15ce9f586164cabb15d83fb3f6bbeb3cf5", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2db7c15ce9f586164cabb15d83fb3f6bbeb3cf5", "html_url": "https://github.com/rust-lang/rust/commit/a2db7c15ce9f586164cabb15d83fb3f6bbeb3cf5"}, {"sha": "ef5c439fb006875d3d54b3b100f5411efc2c40f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef5c439fb006875d3d54b3b100f5411efc2c40f3", "html_url": "https://github.com/rust-lang/rust/commit/ef5c439fb006875d3d54b3b100f5411efc2c40f3"}], "stats": {"total": 3870, "additions": 2507, "deletions": 1363}, "files": [{"sha": "f65d3ad464c46ee040fd8bacd0b08242f0f4cb09", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -15,6 +15,9 @@ pass builds up the `scope_map`, which describes the parent links in\n the region hierarchy.  The second pass infers which types must be\n region parameterized.\n \n+Most of the documentation on regions can be found in\n+`middle/typeck/infer/region_inference.rs`\n+\n */\n \n "}, {"sha": "45867ae77e0807f61ad3fe4b786ef41ddca87844", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 30, "deletions": 22, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -15,6 +15,7 @@ use middle::typeck::check::demand;\n use middle::typeck::check::{check_block, check_expr_has_type, FnCtxt};\n use middle::typeck::check::{instantiate_path, lookup_def};\n use middle::typeck::check::{structure_of, valid_range_bounds};\n+use middle::typeck::infer;\n use middle::typeck::require_same_types;\n \n use std::hashmap::{HashMap, HashSet};\n@@ -29,26 +30,31 @@ pub fn check_match(fcx: @mut FnCtxt,\n                    arms: &[ast::arm]) {\n     let tcx = fcx.ccx.tcx;\n \n-    let pattern_ty = fcx.infcx().next_ty_var();\n-    check_expr_has_type(fcx, discrim, pattern_ty);\n+    let discrim_ty = fcx.infcx().next_ty_var();\n+    check_expr_has_type(fcx, discrim, discrim_ty);\n \n     // Typecheck the patterns first, so that we get types for all the\n     // bindings.\n     for arms.iter().advance |arm| {\n         let pcx = pat_ctxt {\n             fcx: fcx,\n             map: pat_id_map(tcx.def_map, arm.pats[0]),\n-            match_region: ty::re_scope(expr.id),\n-            block_region: ty::re_scope(arm.body.node.id)\n         };\n \n-        for arm.pats.iter().advance |p| { check_pat(&pcx, *p, pattern_ty);}\n+        for arm.pats.iter().advance |p| { check_pat(&pcx, *p, discrim_ty);}\n     }\n \n+    // The result of the match is the common supertype of all the\n+    // arms. Start out the value as bottom, since it's the, well,\n+    // bottom the type lattice, and we'll be moving up the lattice as\n+    // we process each arm. (Note that any match with 0 arms is matching\n+    // on any empty type and is therefore unreachable; should the flow\n+    // of execution reach it, we will fail, so bottom is an appropriate\n+    // type in that case)\n+    let mut result_ty = ty::mk_bot();\n+\n     // Now typecheck the blocks.\n-    let mut result_ty = fcx.infcx().next_ty_var();\n-    let mut arm_non_bot = false;\n-    let mut saw_err = false;\n+    let mut saw_err = ty::type_is_error(discrim_ty);\n     for arms.iter().advance |arm| {\n         let mut guard_err = false;\n         let mut guard_bot = false;\n@@ -75,26 +81,28 @@ pub fn check_match(fcx: @mut FnCtxt,\n         else if guard_bot {\n             fcx.write_bot(arm.body.node.id);\n         }\n-        else if !ty::type_is_bot(bty) {\n-            arm_non_bot = true; // If the match *may* evaluate to a non-_|_\n-                                // expr, the whole thing is non-_|_\n-        }\n-        demand::suptype(fcx, arm.body.span, result_ty, bty);\n+\n+        result_ty =\n+            infer::common_supertype(\n+                fcx.infcx(),\n+                infer::MatchExpression(expr.span),\n+                true, // result_ty is \"expected\" here\n+                result_ty,\n+                bty);\n     }\n+\n     if saw_err {\n         result_ty = ty::mk_err();\n-    }\n-    else if !arm_non_bot {\n+    } else if ty::type_is_bot(discrim_ty) {\n         result_ty = ty::mk_bot();\n     }\n+\n     fcx.write_ty(expr.id, result_ty);\n }\n \n pub struct pat_ctxt {\n     fcx: @mut FnCtxt,\n     map: PatIdMap,\n-    match_region: ty::Region, // Region for the match as a whole\n-    block_region: ty::Region, // Region for the block of the arm\n }\n \n pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: @ast::Path,\n@@ -442,8 +450,8 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             // then the type of x is &M T where M is the mutability\n             // and T is the expected type\n             let region_var =\n-                fcx.infcx().next_region_var_with_lb(\n-                    pat.span, pcx.block_region);\n+                fcx.infcx().next_region_var(\n+                    infer::PatternRegion(pat.span));\n             let mt = ty::mt {ty: expected, mutbl: mutbl};\n             let region_ty = ty::mk_rptr(tcx, region_var, mt);\n             demand::eqtype(fcx, pat.span, region_ty, typ);\n@@ -544,9 +552,8 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n       }\n       ast::pat_vec(ref before, slice, ref after) => {\n         let default_region_var =\n-            fcx.infcx().next_region_var_with_lb(\n-                pat.span, pcx.block_region\n-            );\n+            fcx.infcx().next_region_var(\n+                infer::PatternRegion(pat.span));\n \n         let (elt_type, region_var) = match structure_of(\n           fcx, pat.span, expected\n@@ -651,3 +658,4 @@ pub fn check_pointer_pat(pcx: &pat_ctxt,\n \n #[deriving(Eq)]\n enum PointerKind { Managed, Send, Borrowed }\n+"}, {"sha": "cf29d3f7f1f57ef7c2a00fd1be91edb949771b51", "filename": "src/librustc/middle/typeck/check/demand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -35,7 +35,7 @@ pub fn suptype_with_fn(fcx: @mut FnCtxt,\n                        ty_a: ty::t, ty_b: ty::t,\n                        handle_err: &fn(span, ty::t, ty::t, &ty::type_err)) {\n     // n.b.: order of actual, expected is reversed\n-    match infer::mk_subty(fcx.infcx(), b_is_expected, sp,\n+    match infer::mk_subty(fcx.infcx(), b_is_expected, infer::Misc(sp),\n                           ty_b, ty_a) {\n       result::Ok(()) => { /* ok */ }\n       result::Err(ref err) => {\n@@ -45,7 +45,7 @@ pub fn suptype_with_fn(fcx: @mut FnCtxt,\n }\n \n pub fn eqtype(fcx: @mut FnCtxt, sp: span, expected: ty::t, actual: ty::t) {\n-    match infer::mk_eqty(fcx.infcx(), false, sp, actual, expected) {\n+    match infer::mk_eqty(fcx.infcx(), false, infer::Misc(sp), actual, expected) {\n         Ok(()) => { /* ok */ }\n         Err(ref err) => {\n             fcx.report_mismatched_types(sp, expected, actual, err);"}, {"sha": "ee61399113a434fcd5dbb5cda873ce32315e52f2", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -619,14 +619,18 @@ impl<'self> LookupContext<'self> {\n                      autoref: None}))\n             }\n             ty::ty_rptr(_, self_mt) => {\n-                let region = self.infcx().next_region_var_nb(self.expr.span);\n+                let region =\n+                    self.infcx().next_region_var(\n+                        infer::Autoref(self.expr.span));\n                 (ty::mk_rptr(tcx, region, self_mt),\n                  ty::AutoDerefRef(ty::AutoDerefRef {\n                      autoderefs: autoderefs+1,\n                      autoref: Some(ty::AutoPtr(region, self_mt.mutbl))}))\n             }\n             ty::ty_evec(self_mt, vstore_slice(_)) => {\n-                let region = self.infcx().next_region_var_nb(self.expr.span);\n+                let region =\n+                    self.infcx().next_region_var(\n+                        infer::Autoref(self.expr.span));\n                 (ty::mk_evec(tcx, self_mt, vstore_slice(region)),\n                  ty::AutoDerefRef(ty::AutoDerefRef {\n                      autoderefs: autoderefs,\n@@ -758,7 +762,9 @@ impl<'self> LookupContext<'self> {\n         -> Option<method_map_entry> {\n         // This is hokey. We should have mutability inference as a\n         // variable.  But for now, try &const, then &, then &mut:\n-        let region = self.infcx().next_region_var_nb(self.expr.span);\n+        let region =\n+            self.infcx().next_region_var(\n+                infer::Autoref(self.expr.span));\n         for mutbls.iter().advance |mutbl| {\n             let autoref_ty = mk_autoref_ty(*mutbl, region);\n             match self.search_for_method(autoref_ty) {\n@@ -970,7 +976,8 @@ impl<'self> LookupContext<'self> {\n         let (_, opt_transformed_self_ty, fn_sig) =\n             replace_bound_regions_in_fn_sig(\n                 tcx, @Nil, Some(transformed_self_ty), &bare_fn_ty.sig,\n-                |_br| self.fcx.infcx().next_region_var_nb(self.expr.span));\n+                |br| self.fcx.infcx().next_region_var(\n+                    infer::BoundRegionInFnCall(self.expr.span, br)));\n         let transformed_self_ty = opt_transformed_self_ty.get();\n         let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {sig: fn_sig, ..bare_fn_ty});\n         debug!(\"after replacing bound regions, fty=%s\", self.ty_to_str(fty));\n@@ -982,7 +989,7 @@ impl<'self> LookupContext<'self> {\n         // variables to unify etc).  Since we checked beforehand, and\n         // nothing has changed in the meantime, this unification\n         // should never fail.\n-        match self.fcx.mk_subty(false, self.self_expr.span,\n+        match self.fcx.mk_subty(false, infer::Misc(self.self_expr.span),\n                                 rcvr_ty, transformed_self_ty) {\n             result::Ok(_) => (),\n             result::Err(_) => {"}, {"sha": "00ebca5abc1476b5777c4c9e6604bd790cd7d5fc", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 75, "deletions": 88, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -467,8 +467,6 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n             let pcx = pat_ctxt {\n                 fcx: fcx,\n                 map: pat_id_map(tcx.def_map, input.pat),\n-                match_region: region,\n-                block_region: region,\n             };\n             _match::check_pat(&pcx, input.pat, *arg_ty);\n         }\n@@ -686,9 +684,14 @@ impl FnCtxt {\n                     result::Ok(self.block_region())\n                 } else {\n                     result::Err(RegionError {\n-                        msg: fmt!(\"named region `%s` not in scope here\",\n-                                  bound_region_ptr_to_str(self.tcx(), br)),\n-                        replacement: self.infcx().next_region_var_nb(span)\n+                        msg: {\n+                            fmt!(\"named region `%s` not in scope here\",\n+                                 bound_region_ptr_to_str(self.tcx(), br))\n+                        },\n+                        replacement: {\n+                            self.infcx().next_region_var(\n+                                infer::BoundRegionError(span))\n+                        }\n                     })\n                 }\n             }\n@@ -698,7 +701,7 @@ impl FnCtxt {\n \n impl region_scope for FnCtxt {\n     fn anon_region(&self, span: span) -> Result<ty::Region, RegionError> {\n-        result::Ok(self.infcx().next_region_var_nb(span))\n+        result::Ok(self.infcx().next_region_var(infer::MiscVariable(span)))\n     }\n     fn self_region(&self, span: span) -> Result<ty::Region, RegionError> {\n         self.search_in_scope_regions(span, ty::br_self)\n@@ -845,21 +848,28 @@ impl FnCtxt {\n \n     pub fn mk_subty(&self,\n                     a_is_expected: bool,\n-                    span: span,\n+                    origin: infer::TypeOrigin,\n                     sub: ty::t,\n                     sup: ty::t)\n                     -> Result<(), ty::type_err> {\n-        infer::mk_subty(self.infcx(), a_is_expected, span, sub, sup)\n+        infer::mk_subty(self.infcx(), a_is_expected, origin, sub, sup)\n     }\n \n     pub fn can_mk_subty(&self, sub: ty::t, sup: ty::t)\n                         -> Result<(), ty::type_err> {\n         infer::can_mk_subty(self.infcx(), sub, sup)\n     }\n \n-    pub fn mk_assignty(&self, expr: @ast::expr, sub: ty::t, sup: ty::t)\n+    pub fn mk_assignty(&self,\n+                       expr: @ast::expr,\n+                       sub: ty::t,\n+                       sup: ty::t)\n                        -> Result<(), ty::type_err> {\n-        match infer::mk_coercety(self.infcx(), false, expr.span, sub, sup) {\n+        match infer::mk_coercety(self.infcx(),\n+                                 false,\n+                                 infer::ExprAssignable(expr),\n+                                 sub,\n+                                 sup) {\n             Ok(None) => result::Ok(()),\n             Err(ref e) => result::Err((*e)),\n             Ok(Some(adjustment)) => {\n@@ -876,20 +886,19 @@ impl FnCtxt {\n \n     pub fn mk_eqty(&self,\n                    a_is_expected: bool,\n-                   span: span,\n+                   origin: infer::TypeOrigin,\n                    sub: ty::t,\n                    sup: ty::t)\n                    -> Result<(), ty::type_err> {\n-        infer::mk_eqty(self.infcx(), a_is_expected, span, sub, sup)\n+        infer::mk_eqty(self.infcx(), a_is_expected, origin, sub, sup)\n     }\n \n     pub fn mk_subr(&self,\n                    a_is_expected: bool,\n-                   span: span,\n+                   origin: infer::SubregionOrigin,\n                    sub: ty::Region,\n-                   sup: ty::Region)\n-                   -> Result<(), ty::type_err> {\n-        infer::mk_subr(self.infcx(), a_is_expected, span, sub, sup)\n+                   sup: ty::Region) {\n+        infer::mk_subr(self.infcx(), a_is_expected, origin, sub, sup)\n     }\n \n     pub fn with_region_lb<R>(@mut self, lb: ast::node_id, f: &fn() -> R)\n@@ -905,7 +914,9 @@ impl FnCtxt {\n                                        rp: Option<ty::region_variance>,\n                                        span: span)\n                                        -> Option<ty::Region> {\n-        rp.map(|_rp| self.infcx().next_region_var_nb(span))\n+        rp.map(\n+            |_| self.infcx().next_region_var(\n+                infer::BoundRegionInTypeOrImpl(span)))\n     }\n \n     pub fn type_error_message(&self,\n@@ -1089,7 +1100,8 @@ pub fn impl_self_ty(vcx: &VtableContext,\n     };\n \n     let self_r = if region_param.is_some() {\n-        Some(vcx.infcx.next_region_var_nb(location_info.span))\n+        Some(vcx.infcx.next_region_var(\n+            infer::BoundRegionInTypeOrImpl(location_info.span)))\n     } else {\n         None\n     };\n@@ -1352,7 +1364,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let (_, _, fn_sig) =\n             replace_bound_regions_in_fn_sig(\n                 fcx.tcx(), @Nil, None, &fn_sig,\n-                |_br| fcx.infcx().next_region_var_nb(call_expr.span));\n+                |br| fcx.infcx().next_region_var(\n+                    infer::BoundRegionInFnCall(call_expr.span, br)));\n \n         // Call the generic checker.\n         check_argument_types(fcx, call_expr.span, fn_sig.inputs, f,\n@@ -1423,27 +1436,42 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     // A generic function for checking the then and else in an if\n     // or if-check\n     fn check_then_else(fcx: @mut FnCtxt,\n-                       thn: &ast::blk,\n-                       elsopt: Option<@ast::expr>,\n+                       cond_expr: @ast::expr,\n+                       then_blk: &ast::blk,\n+                       opt_else_expr: Option<@ast::expr>,\n                        id: ast::node_id,\n-                       _sp: span) {\n-        let if_t =\n-            match elsopt {\n-                Some(els) => {\n-                    let if_t = fcx.infcx().next_ty_var();\n-                    check_block(fcx, thn);\n-                    let thn_t = fcx.node_ty(thn.node.id);\n-                    demand::suptype(fcx, thn.span, if_t, thn_t);\n-                    check_expr_has_type(fcx, els, if_t);\n-                    if_t\n-                }\n-                None => {\n-                    check_block_no_value(fcx, thn);\n-                    ty::mk_nil()\n-                }\n-            };\n+                       sp: span,\n+                       expected: Option<ty::t>) {\n+        check_expr_has_type(fcx, cond_expr, ty::mk_bool());\n+\n+        let branches_ty = match opt_else_expr {\n+            Some(else_expr) => {\n+                check_block_with_expected(fcx, then_blk, expected);\n+                let then_ty = fcx.node_ty(then_blk.node.id);\n+                check_expr_with_opt_hint(fcx, else_expr, expected);\n+                let else_ty = fcx.expr_ty(else_expr);\n+                infer::common_supertype(fcx.infcx(),\n+                                        infer::IfExpression(sp),\n+                                        true,\n+                                        then_ty,\n+                                        else_ty)\n+            }\n+            None => {\n+                check_block_no_value(fcx, then_blk);\n+                ty::mk_nil()\n+            }\n+        };\n+\n+        let cond_ty = fcx.expr_ty(cond_expr);\n+        let if_ty = if ty::type_is_error(cond_ty) {\n+            ty::mk_err()\n+        } else if ty::type_is_bot(cond_ty) {\n+            ty::mk_bot()\n+        } else {\n+            branches_ty\n+        };\n \n-        fcx.write_ty(id, if_t);\n+        fcx.write_ty(id, if_ty);\n     }\n \n     fn lookup_op_method(fcx: @mut FnCtxt,\n@@ -2085,7 +2113,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let expected_sty = unpack_expected(fcx, expected, |x| Some(copy *x));\n         let inner_ty = match expected_sty {\n             Some(ty::ty_closure(ref fty)) => {\n-                match fcx.mk_subty(false, expr.span,\n+                match fcx.mk_subty(false, infer::Misc(expr.span),\n                                    fty.sig.output, ty::mk_bool()) {\n                     result::Ok(_) => {\n                         ty::mk_closure(tcx, ty::ClosureTy {\n@@ -2395,7 +2423,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         // Finally, borrowck is charged with guaranteeing that the\n         // value whose address was taken can actually be made to live\n         // as long as it needs to live.\n-        let region = fcx.infcx().next_region_var_nb(expr.span);\n+        let region = fcx.infcx().next_region_var(\n+            infer::AddrOfRegion(expr.span));\n \n         let tm = ty::mt { ty: fcx.expr_ty(oprnd), mutbl: mutbl };\n         let oprnd_t = if ty::type_is_error(tm.ty) {\n@@ -2437,7 +2466,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n           Some(t) =>  t, None => fcx.ret_ty\n         };\n         match expr_opt {\n-          None => match fcx.mk_eqty(false, expr.span,\n+          None => match fcx.mk_eqty(false, infer::Misc(expr.span),\n                                     ret_ty, ty::mk_nil()) {\n             result::Ok(_) => { /* fall through */ }\n             result::Err(_) => {\n@@ -2487,25 +2516,9 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             fcx.write_nil(id);\n         }\n       }\n-      ast::expr_if(cond, ref thn, elsopt) => {\n-        check_expr_has_type(fcx, cond, ty::mk_bool());\n-        check_then_else(fcx, thn, elsopt, id, expr.span);\n-        let cond_ty = fcx.expr_ty(cond);\n-        let then_ty = fcx.node_ty(thn.node.id);\n-        let else_is_bot = elsopt.map_default(false, |els| {\n-              ty::type_is_bot(fcx.expr_ty(*els))});\n-        if ty::type_is_error(cond_ty) || ty::type_is_error(then_ty) {\n-            fcx.write_error(id);\n-        }\n-        else if elsopt.map_default(false, |els| {\n-            ty::type_is_error(fcx.expr_ty(*els)) }) {\n-            fcx.write_error(id);\n-        }\n-        else if ty::type_is_bot(cond_ty) ||\n-            (ty::type_is_bot(then_ty) && else_is_bot) {\n-            fcx.write_bot(id);\n-        }\n-          // Other cases were handled by check_then_else\n+      ast::expr_if(cond, ref then_blk, opt_else_expr) => {\n+        check_then_else(fcx, cond, then_blk, opt_else_expr,\n+                        id, expr.span, expected);\n       }\n       ast::expr_while(cond, ref body) => {\n         check_expr_has_type(fcx, cond, ty::mk_bool());\n@@ -2533,30 +2546,6 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n       }\n       ast::expr_match(discrim, ref arms) => {\n         _match::check_match(fcx, expr, discrim, *arms);\n-        let discrim_ty = fcx.expr_ty(discrim);\n-        let arm_tys = arms.map(|a| fcx.node_ty(a.body.node.id));\n-        if ty::type_is_error(discrim_ty) ||\n-            arm_tys.iter().any_(|t| ty::type_is_error(*t)) {\n-            fcx.write_error(id);\n-        }\n-        // keep in mind that `all` returns true in the empty vec case,\n-        // which is what we want\n-        else if ty::type_is_bot(discrim_ty) ||\n-            arm_tys.iter().all(|t| ty::type_is_bot(*t)) {\n-            fcx.write_bot(id);\n-        }\n-        else {\n-            // Find the first non-_|_ arm.\n-            // We know there's at least one because we already checked\n-            // for n=0 as well as all arms being _|_ in the previous\n-            // `if`.\n-            for arm_tys.iter().advance |arm_ty| {\n-                if !ty::type_is_bot(*arm_ty) {\n-                    fcx.write_ty(id, *arm_ty);\n-                    break;\n-                }\n-            }\n-        }\n       }\n       ast::expr_fn_block(ref decl, ref body) => {\n         check_expr_fn(fcx, expr, None,\n@@ -2686,7 +2675,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                 let el = ty::sequence_element_type(fcx.tcx(),\n                                                                    t1);\n                                 infer::mk_eqty(fcx.infcx(), false,\n-                                               sp, el, t2).is_ok()\n+                                               infer::Misc(sp), el, t2).is_ok()\n                             }\n                         }\n \n@@ -2907,8 +2896,6 @@ pub fn check_decl_local(fcx: @mut FnCtxt, local: @ast::local)  {\n     let pcx = pat_ctxt {\n         fcx: fcx,\n         map: pat_id_map(tcx.def_map, local.node.pat),\n-        match_region: region,\n-        block_region: region,\n     };\n     _match::check_pat(&pcx, local.node.pat, t);\n     let pat_ty = fcx.node_ty(local.node.pat.id);\n@@ -3412,7 +3399,7 @@ pub fn ast_expr_vstore_to_vstore(fcx: @mut FnCtxt,\n         ast::expr_vstore_uniq => ty::vstore_uniq,\n         ast::expr_vstore_box | ast::expr_vstore_mut_box => ty::vstore_box,\n         ast::expr_vstore_slice | ast::expr_vstore_mut_slice => {\n-            let r = fcx.infcx().next_region_var_nb(e.span);\n+            let r = fcx.infcx().next_region_var(infer::AddrOfSlice(e.span));\n             ty::vstore_slice(r)\n         }\n     }"}, {"sha": "2e41649e4dbb2a0123d95b1b267bd50741669019", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 47, "deletions": 135, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*\n+/*!\n \n The region check is a final pass that runs over the AST after we have\n inferred the type constraints but before we have actually finalized\n@@ -35,7 +35,9 @@ use middle::typeck::check::FnCtxt;\n use middle::typeck::check::regionmanip::relate_nested_regions;\n use middle::typeck::infer::resolve_and_force_all_but_regions;\n use middle::typeck::infer::resolve_type;\n-use util::ppaux::{note_and_explain_region, ty_to_str, region_to_str};\n+use middle::typeck::infer;\n+use util::ppaux::{note_and_explain_region, ty_to_str,\n+                  region_to_str};\n use middle::pat_util;\n \n use std::result;\n@@ -224,7 +226,9 @@ fn constrain_bindings_in_pat(pat: @ast::pat, rcx: @mut Rcx) {\n         // variable's type enclose at least the variable's scope.\n \n         let encl_region = tcx.region_maps.encl_region(id);\n-        constrain_regions_in_type_of_node(rcx, id, encl_region, span);\n+        constrain_regions_in_type_of_node(\n+            rcx, id, encl_region,\n+            infer::BindingTypeIsNotValidAtDecl(span));\n     }\n }\n \n@@ -298,7 +302,8 @@ fn visit_expr(expr: @ast::expr, (rcx, v): (@mut Rcx, rvt)) {\n                         //\n                         // FIXME(#6268) remove to support nested method calls\n                         constrain_regions_in_type_of_node(\n-                            rcx, expr.id, ty::re_scope(expr.id), expr.span);\n+                            rcx, expr.id, ty::re_scope(expr.id),\n+                            infer::AutoBorrow(expr.span));\n                     }\n                 }\n                 _ => {}\n@@ -361,8 +366,11 @@ fn visit_expr(expr: @ast::expr, (rcx, v): (@mut Rcx, rvt)) {\n             match ty::get(target_ty).sty {\n                 ty::ty_trait(_, _, ty::RegionTraitStore(trait_region), _, _) => {\n                     let source_ty = rcx.fcx.expr_ty(source);\n-                    constrain_regions_in_type(rcx, trait_region,\n-                                              expr.span, source_ty);\n+                    constrain_regions_in_type(\n+                        rcx,\n+                        trait_region,\n+                        infer::RelateObjectBound(expr.span),\n+                        source_ty);\n                 }\n                 _ => ()\n             }\n@@ -379,7 +387,8 @@ fn visit_expr(expr: @ast::expr, (rcx, v): (@mut Rcx, rvt)) {\n             //\n             // FIXME(#6268) nested method calls requires that this rule change\n             let ty0 = rcx.resolve_node_type(expr.id);\n-            constrain_regions_in_type(rcx, ty::re_scope(expr.id), expr.span, ty0);\n+            constrain_regions_in_type(rcx, ty::re_scope(expr.id),\n+                                      infer::AddrOf(expr.span), ty0);\n         }\n \n         ast::expr_match(discr, ref arms) => {\n@@ -418,20 +427,8 @@ fn constrain_callee(rcx: @mut Rcx,\n     match ty::get(callee_ty).sty {\n         ty::ty_bare_fn(*) => { }\n         ty::ty_closure(ref closure_ty) => {\n-            match rcx.fcx.mk_subr(true, callee_expr.span,\n-                                  call_region, closure_ty.region) {\n-                result::Err(_) => {\n-                    tcx.sess.span_err(\n-                        callee_expr.span,\n-                        fmt!(\"cannot invoke closure outside of its lifetime\"));\n-                    note_and_explain_region(\n-                        tcx,\n-                        \"the closure is only valid for \",\n-                        closure_ty.region,\n-                        \"\");\n-                }\n-                result::Ok(_) => {}\n-            }\n+            rcx.fcx.mk_subr(true, infer::InvokeClosure(callee_expr.span),\n+                            call_region, closure_ty.region);\n         }\n         _ => {\n             // this should not happen, but it does if the program is\n@@ -479,7 +476,8 @@ fn constrain_call(rcx: @mut Rcx,\n         // ensure that any regions appearing in the argument type are\n         // valid for at least the lifetime of the function:\n         constrain_regions_in_type_of_node(\n-            rcx, arg_expr.id, callee_region, arg_expr.span);\n+            rcx, arg_expr.id, callee_region,\n+            infer::CallArg(arg_expr.span));\n \n         // unfortunately, there are two means of taking implicit\n         // references, and we need to propagate constraints as a\n@@ -493,7 +491,7 @@ fn constrain_call(rcx: @mut Rcx,\n     // as loop above, but for receiver\n     for receiver.iter().advance |&r| {\n         constrain_regions_in_type_of_node(\n-            rcx, r.id, callee_region, r.span);\n+            rcx, r.id, callee_region, infer::CallRcvr(r.span));\n         if implicitly_ref_args {\n             guarantor::for_by_ref(rcx, r, callee_scope);\n         }\n@@ -502,7 +500,8 @@ fn constrain_call(rcx: @mut Rcx,\n     // constrain regions that may appear in the return type to be\n     // valid for the function call:\n     constrain_regions_in_type(\n-        rcx, callee_region, call_expr.span, fn_sig.output);\n+        rcx, callee_region, infer::CallReturn(call_expr.span),\n+        fn_sig.output);\n }\n \n fn constrain_derefs(rcx: @mut Rcx,\n@@ -545,20 +544,8 @@ pub fn mk_subregion_due_to_derefence(rcx: @mut Rcx,\n                                      deref_span: span,\n                                      minimum_lifetime: ty::Region,\n                                      maximum_lifetime: ty::Region) {\n-    match rcx.fcx.mk_subr(true, deref_span,\n-                          minimum_lifetime, maximum_lifetime) {\n-        result::Ok(*) => {}\n-        result::Err(*) => {\n-            rcx.tcx().sess.span_err(\n-                deref_span,\n-                fmt!(\"dereference of reference outside its lifetime\"));\n-            note_and_explain_region(\n-                rcx.tcx(),\n-                \"the reference is only valid for \",\n-                maximum_lifetime,\n-                \"\");\n-        }\n-    }\n+    rcx.fcx.mk_subr(true, infer::DerefPointer(deref_span),\n+                    minimum_lifetime, maximum_lifetime)\n }\n \n \n@@ -581,19 +568,8 @@ fn constrain_index(rcx: @mut Rcx,\n     match ty::get(indexed_ty).sty {\n         ty::ty_estr(ty::vstore_slice(r_ptr)) |\n         ty::ty_evec(_, ty::vstore_slice(r_ptr)) => {\n-            match rcx.fcx.mk_subr(true, index_expr.span, r_index_expr, r_ptr) {\n-                result::Ok(*) => {}\n-                result::Err(*) => {\n-                    tcx.sess.span_err(\n-                        index_expr.span,\n-                        fmt!(\"index of slice outside its lifetime\"));\n-                    note_and_explain_region(\n-                        tcx,\n-                        \"the slice is only valid for \",\n-                        r_ptr,\n-                        \"\");\n-                }\n-            }\n+            rcx.fcx.mk_subr(true, infer::IndexSlice(index_expr.span),\n+                            r_index_expr, r_ptr);\n         }\n \n         _ => {}\n@@ -616,33 +592,16 @@ fn constrain_free_variables(rcx: @mut Rcx,\n         let def = freevar.def;\n         let en_region = encl_region_of_def(rcx.fcx, def);\n         debug!(\"en_region = %s\", en_region.repr(tcx));\n-        match rcx.fcx.mk_subr(true, freevar.span,\n-                              region, en_region) {\n-          result::Ok(()) => {}\n-          result::Err(_) => {\n-            tcx.sess.span_err(\n-                freevar.span,\n-                \"captured variable does not outlive the enclosing closure\");\n-            note_and_explain_region(\n-                tcx,\n-                \"captured variable is valid for \",\n-                en_region,\n-                \"\");\n-            note_and_explain_region(\n-                tcx,\n-                \"closure is valid for \",\n-                region,\n-                \"\");\n-          }\n-        }\n+        rcx.fcx.mk_subr(true, infer::FreeVariable(freevar.span),\n+                        region, en_region);\n     }\n }\n \n fn constrain_regions_in_type_of_node(\n     rcx: @mut Rcx,\n     id: ast::node_id,\n     minimum_lifetime: ty::Region,\n-    span: span) -> bool\n+    origin: infer::SubregionOrigin) -> bool\n {\n     //! Guarantees that any lifetimes which appear in the type of\n     //! the node `id` (after applying adjustments) are valid for at\n@@ -655,18 +614,18 @@ fn constrain_regions_in_type_of_node(\n     // report errors later on in the writeback phase.\n     let ty0 = rcx.resolve_node_type(id);\n     let adjustment = rcx.fcx.inh.adjustments.find_copy(&id);\n-    let ty = ty::adjust_ty(tcx, span, ty0, adjustment);\n+    let ty = ty::adjust_ty(tcx, origin.span(), ty0, adjustment);\n     debug!(\"constrain_regions_in_type_of_node(\\\n             ty=%s, ty0=%s, id=%d, minimum_lifetime=%?, adjustment=%?)\",\n            ty_to_str(tcx, ty), ty_to_str(tcx, ty0),\n            id, minimum_lifetime, adjustment);\n-    constrain_regions_in_type(rcx, minimum_lifetime, span, ty)\n+    constrain_regions_in_type(rcx, minimum_lifetime, origin, ty)\n }\n \n fn constrain_regions_in_type(\n     rcx: @mut Rcx,\n     minimum_lifetime: ty::Region,\n-    span: span,\n+    origin: infer::SubregionOrigin,\n     ty: ty::t) -> bool\n {\n     /*!\n@@ -700,40 +659,14 @@ fn constrain_regions_in_type(\n             // (e.g., the `&` in `fn(&T)`).  Such regions need not be\n             // constrained by `minimum_lifetime` as they are placeholders\n             // for regions that are as-yet-unknown.\n+        } else if r_sub == minimum_lifetime {\n+            rcx.fcx.mk_subr(\n+                true, origin,\n+                r_sub, r_sup);\n         } else {\n-            match rcx.fcx.mk_subr(true, span, r_sub, r_sup) {\n-                result::Err(_) => {\n-                    if r_sub == minimum_lifetime {\n-                        tcx.sess.span_err(\n-                            span,\n-                            fmt!(\"reference is not valid outside of its lifetime\"));\n-                        note_and_explain_region(\n-                            tcx,\n-                            \"the reference is only valid for \",\n-                            r_sup,\n-                            \"\");\n-                    } else {\n-                        tcx.sess.span_err(\n-                            span,\n-                            fmt!(\"in type `%s`, pointer has a longer lifetime than \\\n-                                  the data it references\",\n-                                 rcx.fcx.infcx().ty_to_str(ty)));\n-                        note_and_explain_region(\n-                            tcx,\n-                            \"the pointer is valid for \",\n-                            r_sub,\n-                            \"\");\n-                        note_and_explain_region(\n-                            tcx,\n-                            \"but the referenced data is only valid for \",\n-                            r_sup,\n-                            \"\");\n-                    }\n-                    rcx.errors_reported += 1u;\n-                }\n-                result::Ok(()) => {\n-                }\n-            }\n+            rcx.fcx.mk_subr(\n+                true, infer::ReferenceOutlivesReferent(ty, origin.span()),\n+                r_sub, r_sup);\n         }\n     }\n \n@@ -788,8 +721,9 @@ pub mod guarantor {\n      */\n \n \n-    use middle::typeck::check::regionck::{Rcx, infallibly_mk_subr};\n+    use middle::typeck::check::regionck::Rcx;\n     use middle::typeck::check::regionck::mk_subregion_due_to_derefence;\n+    use middle::typeck::infer;\n     use middle::ty;\n     use syntax::ast;\n     use syntax::codemap::span;\n@@ -869,9 +803,11 @@ pub mod guarantor {\n             rcx: @mut Rcx,\n             expr: @ast::expr,\n             sub_region: ty::Region,\n-            sup_region: Option<ty::Region>) {\n+            sup_region: Option<ty::Region>)\n+        {\n             for sup_region.iter().advance |r| {\n-                infallibly_mk_subr(rcx, true, expr.span, sub_region, *r);\n+                rcx.fcx.mk_subr(true, infer::Reborrow(expr.span),\n+                                sub_region, *r);\n             }\n         }\n     }\n@@ -929,7 +865,7 @@ pub mod guarantor {\n             let tcx = rcx.fcx.ccx.tcx;\n             debug!(\"rptr_ty=%s\", ty_to_str(tcx, rptr_ty));\n             let r = ty::ty_region(tcx, span, rptr_ty);\n-            infallibly_mk_subr(rcx, true, span, r, bound);\n+            rcx.fcx.mk_subr(true, infer::Reborrow(span), r, bound);\n         }\n     }\n \n@@ -1259,27 +1195,3 @@ pub mod guarantor {\n     }\n \n }\n-\n-pub fn infallibly_mk_subr(rcx: @mut Rcx,\n-                          a_is_expected: bool,\n-                          span: span,\n-                          a: ty::Region,\n-                          b: ty::Region) {\n-    /*!\n-     * Constrains `a` to be a subregion of `b`.  In many cases, we\n-     * know that this can never yield an error due to the way that\n-     * region inferencing works.  Therefore just report a bug if we\n-     * ever see `Err(_)`.\n-     */\n-\n-    match rcx.fcx.mk_subr(a_is_expected, span, a, b) {\n-        result::Ok(()) => {}\n-        result::Err(e) => {\n-            rcx.fcx.ccx.tcx.sess.span_bug(\n-                span,\n-                fmt!(\"Supposedly infallible attempt to \\\n-                      make %? < %? failed: %?\",\n-                     a, b, e));\n-        }\n-    }\n-}"}, {"sha": "d9086334439610d57025d4e19f26f2e8e173407f", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -101,18 +101,18 @@ fn lookup_vtables(vcx: &VtableContext,\n \n             // Substitute the values of the type parameters that may\n             // appear in the bound.\n-            let trait_ref = (*trait_ref).subst(tcx, substs);\n+            let trait_ref = trait_ref.subst(tcx, substs);\n \n             debug!(\"after subst: %s\", trait_ref.repr(tcx));\n \n-            match lookup_vtable(vcx, location_info, *ty, &trait_ref, is_early) {\n+            match lookup_vtable(vcx, location_info, *ty, trait_ref, is_early) {\n                 Some(vtable) => param_result.push(vtable),\n                 None => {\n                     vcx.tcx().sess.span_fatal(\n                         location_info.span,\n                         fmt!(\"failed to find an implementation of \\\n                               trait %s for %s\",\n-                             vcx.infcx.trait_ref_to_str(&trait_ref),\n+                             vcx.infcx.trait_ref_to_str(trait_ref),\n                              vcx.infcx.ty_to_str(*ty)));\n                 }\n             }\n@@ -152,8 +152,8 @@ fn fixup_substs(vcx: &VtableContext, location_info: &LocationInfo,\n \n fn relate_trait_refs(vcx: &VtableContext,\n                      location_info: &LocationInfo,\n-                     act_trait_ref: &ty::TraitRef,\n-                     exp_trait_ref: &ty::TraitRef)\n+                     act_trait_ref: @ty::TraitRef,\n+                     exp_trait_ref: @ty::TraitRef)\n {\n     /*!\n      *\n@@ -162,8 +162,11 @@ fn relate_trait_refs(vcx: &VtableContext,\n      * error otherwise.\n      */\n \n-    match infer::mk_sub_trait_refs(vcx.infcx, false, location_info.span,\n-                                   act_trait_ref, exp_trait_ref)\n+    match infer::mk_sub_trait_refs(vcx.infcx,\n+                                   false,\n+                                   infer::RelateTraitRefs(location_info.span),\n+                                   act_trait_ref,\n+                                   exp_trait_ref)\n     {\n         result::Ok(()) => {} // Ok.\n         result::Err(ref err) => {\n@@ -191,7 +194,7 @@ fn relate_trait_refs(vcx: &VtableContext,\n fn lookup_vtable(vcx: &VtableContext,\n                  location_info: &LocationInfo,\n                  ty: ty::t,\n-                 trait_ref: &ty::TraitRef,\n+                 trait_ref: @ty::TraitRef,\n                  is_early: bool)\n     -> Option<vtable_origin>\n {\n@@ -304,7 +307,8 @@ fn lookup_vtable(vcx: &VtableContext,\n                             } = impl_self_ty(vcx, location_info, im.did);\n                             match infer::mk_subty(vcx.infcx,\n                                                   false,\n-                                                  location_info.span,\n+                                                  infer::RelateSelfType(\n+                                                      location_info.span),\n                                                   ty,\n                                                   for_ty) {\n                                 result::Err(_) => loop,\n@@ -337,11 +341,10 @@ fn lookup_vtable(vcx: &VtableContext,\n                                    vcx.infcx.trait_ref_to_str(trait_ref),\n                                    vcx.infcx.trait_ref_to_str(of_trait_ref));\n \n-                            let of_trait_ref =\n-                                (*of_trait_ref).subst(tcx, &substs);\n+                            let of_trait_ref = of_trait_ref.subst(tcx, &substs);\n                             relate_trait_refs(\n                                 vcx, location_info,\n-                                &of_trait_ref, trait_ref);\n+                                of_trait_ref, trait_ref);\n \n                             // Recall that trait_ref -- the trait type\n                             // we're casting to -- is the trait with\n@@ -450,7 +453,7 @@ fn fixup_ty(vcx: &VtableContext,\n fn connect_trait_tps(vcx: &VtableContext,\n                      location_info: &LocationInfo,\n                      impl_substs: &ty::substs,\n-                     trait_ref: &ty::TraitRef,\n+                     trait_ref: @ty::TraitRef,\n                      impl_did: ast::def_id)\n {\n     let tcx = vcx.tcx();\n@@ -461,8 +464,8 @@ fn connect_trait_tps(vcx: &VtableContext,\n                                   \"connect_trait_tps invoked on a type impl\")\n     };\n \n-    let impl_trait_ref = (*impl_trait_ref).subst(tcx, impl_substs);\n-    relate_trait_refs(vcx, location_info, &impl_trait_ref, trait_ref);\n+    let impl_trait_ref = impl_trait_ref.subst(tcx, impl_substs);\n+    relate_trait_refs(vcx, location_info, impl_trait_ref, trait_ref);\n }\n \n fn insert_vtables(fcx: @mut FnCtxt,\n@@ -581,7 +584,7 @@ pub fn early_resolve_expr(ex: @ast::expr,\n                               ccx: fcx.ccx,\n                               infcx: fcx.infcx()\n                           };\n-                          let target_trait_ref = ty::TraitRef {\n+                          let target_trait_ref = @ty::TraitRef {\n                               def_id: target_def_id,\n                               substs: ty::substs {\n                                   tps: copy target_substs.tps,\n@@ -593,7 +596,7 @@ pub fn early_resolve_expr(ex: @ast::expr,\n                               lookup_vtable(&vcx,\n                                             location_info,\n                                             mt.ty,\n-                                            &target_trait_ref,\n+                                            target_trait_ref,\n                                             is_early);\n                           match vtable_opt {\n                               Some(vtable) => {\n@@ -622,7 +625,8 @@ pub fn early_resolve_expr(ex: @ast::expr,\n                                ty::RegionTraitStore(rb)) => {\n                                   infer::mk_subr(fcx.infcx(),\n                                                  false,\n-                                                 ex.span,\n+                                                 infer::RelateObjectBound(\n+                                                     ex.span),\n                                                  rb,\n                                                  ra);\n                               }"}, {"sha": "24ac63ac7b079d34423f5413b561952065eae4b8", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -36,6 +36,7 @@ use middle::typeck::infer::combine::Combine;\n use middle::typeck::infer::InferCtxt;\n use middle::typeck::infer::{new_infer_ctxt, resolve_ivar};\n use middle::typeck::infer::{resolve_nested_tvar, resolve_type};\n+use middle::typeck::infer;\n use syntax::ast::{crate, def_id, def_struct, def_ty};\n use syntax::ast::{item, item_enum, item_impl, item_mod, item_struct};\n use syntax::ast::{local_crate, method, trait_ref, ty_path};\n@@ -546,10 +547,10 @@ impl CoherenceChecker {\n     pub fn universally_quantify_polytype(&self,\n                                          polytype: ty_param_bounds_and_ty)\n                                          -> UniversalQuantificationResult {\n-        // NDM--this span is bogus.\n         let self_region =\n             polytype.generics.region_param.map(\n-                |_r| self.inference_context.next_region_var_nb(dummy_sp()));\n+                |_| self.inference_context.next_region_var(\n+                    infer::BoundRegionInCoherence));\n \n         let bounds_count = polytype.generics.type_param_defs.len();\n         let type_parameters = self.inference_context.next_ty_vars(bounds_count);\n@@ -580,11 +581,9 @@ impl CoherenceChecker {\n                                                 b: &'a\n                                                 UniversalQuantificationResult)\n                                                 -> bool {\n-        let mut might_unify = true;\n-        let _ = do self.inference_context.probe {\n-            let result = self.inference_context.sub(true, dummy_sp())\n-                                               .tys(a.monotype, b.monotype);\n-            if result.is_ok() {\n+        match infer::can_mk_subty(self.inference_context,\n+                                  a.monotype, b.monotype) {\n+            Ok(_) => {\n                 // Check to ensure that each parameter binding respected its\n                 // kind bounds.\n                 let xs = [a, b];\n@@ -604,8 +603,7 @@ impl CoherenceChecker {\n                                         self.inference_context.tcx,\n                                         resolved_ty)\n                                     {\n-                                        might_unify = false;\n-                                        break;\n+                                        return false;\n                                     }\n                                 }\n                                 Err(*) => {\n@@ -615,13 +613,13 @@ impl CoherenceChecker {\n                         }\n                     }\n                 }\n-            } else {\n-                might_unify = false;\n+                true\n             }\n \n-            result\n-        };\n-        might_unify\n+            Err(_) => {\n+                false\n+            }\n+        }\n     }\n \n     pub fn get_self_type_for_implementation(&self, implementation: @Impl)"}, {"sha": "de05aca61caf52bbcb9bd94c21c1e1b1d6b90d93", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -615,7 +615,8 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n     };\n     debug!(\"trait_fty (post-subst): %s\", trait_fty.repr(tcx));\n \n-    match infer::mk_subty(infcx, false, cm.span, impl_fty, trait_fty) {\n+    match infer::mk_subty(infcx, false, infer::MethodCompatCheck(cm.span),\n+                          impl_fty, trait_fty) {\n         result::Ok(()) => {}\n         result::Err(ref terr) => {\n             tcx.sess.span_err("}, {"sha": "03d243797b32d1818017fd2f2daca9fa913978b1", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -70,7 +70,7 @@ use middle::ty::{AutoDerefRef};\n use middle::ty::{vstore_slice, vstore_box, vstore_uniq};\n use middle::ty::{mt};\n use middle::ty;\n-use middle::typeck::infer::{CoerceResult, resolve_type};\n+use middle::typeck::infer::{CoerceResult, resolve_type, Coercion};\n use middle::typeck::infer::combine::CombineFields;\n use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::to_str::InferStr;\n@@ -165,7 +165,7 @@ impl Coerce {\n             }\n             Err(e) => {\n                 self.infcx.tcx.sess.span_bug(\n-                    self.span,\n+                    self.trace.origin.span(),\n                     fmt!(\"Failed to resolve even without \\\n                           any force options: %?\", e));\n             }\n@@ -189,7 +189,7 @@ impl Coerce {\n         // yield.\n \n         let sub = Sub(**self);\n-        let r_borrow = self.infcx.next_region_var_nb(self.span);\n+        let r_borrow = self.infcx.next_region_var(Coercion(self.trace));\n \n         let inner_ty = match *sty_a {\n             ty::ty_box(mt_a) => mt_a.ty,\n@@ -227,7 +227,7 @@ impl Coerce {\n             }\n         };\n \n-        let r_a = self.infcx.next_region_var_nb(self.span);\n+        let r_a = self.infcx.next_region_var(Coercion(self.trace));\n         let a_borrowed = ty::mk_estr(self.infcx.tcx, vstore_slice(r_a));\n         if_ok!(self.subtype(a_borrowed, b));\n         Ok(Some(@AutoDerefRef(AutoDerefRef {\n@@ -247,7 +247,7 @@ impl Coerce {\n                b.inf_str(self.infcx));\n \n         let sub = Sub(**self);\n-        let r_borrow = self.infcx.next_region_var_nb(self.span);\n+        let r_borrow = self.infcx.next_region_var(Coercion(self.trace));\n         let ty_inner = match *sty_a {\n             ty::ty_evec(mt, _) => mt.ty,\n             _ => {\n@@ -285,7 +285,7 @@ impl Coerce {\n             }\n         };\n \n-        let r_borrow = self.infcx.next_region_var_nb(self.span);\n+        let r_borrow = self.infcx.next_region_var(Coercion(self.trace));\n         let a_borrowed = ty::mk_closure(\n             self.infcx.tcx,\n             ty::ClosureTy {"}, {"sha": "f03f01732291ffc19b33c544f08783cfc28f957e", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -65,6 +65,7 @@ use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::unify::{InferCtxtMethods};\n use middle::typeck::infer::{InferCtxt, cres, ures};\n+use middle::typeck::infer::{TypeOrigin, TypeTrace};\n use util::common::indent;\n \n use std::result::{iter_vec2, map_vec2};\n@@ -79,7 +80,7 @@ pub trait Combine {\n     fn infcx(&self) -> @mut InferCtxt;\n     fn tag(&self) -> ~str;\n     fn a_is_expected(&self) -> bool;\n-    fn span(&self) -> span;\n+    fn trace(&self) -> TypeTrace;\n \n     fn sub(&self) -> Sub;\n     fn lub(&self) -> Lub;\n@@ -121,7 +122,7 @@ pub trait Combine {\n pub struct CombineFields {\n     infcx: @mut InferCtxt,\n     a_is_expected: bool,\n-    span: span,\n+    trace: TypeTrace,\n }\n \n pub fn expected_found<C:Combine,T>("}, {"sha": "11bfbc637169e20a81a36397d493acc2c88592b9", "filename": "src/librustc/middle/typeck/infer/doc.rs", "status": "added", "additions": 243, "deletions": 0, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fdoc.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -0,0 +1,243 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+# Type inference engine\n+\n+This is loosely based on standard HM-type inference, but with an\n+extension to try and accommodate subtyping.  There is nothing\n+principled about this extension; it's sound---I hope!---but it's a\n+heuristic, ultimately, and does not guarantee that it finds a valid\n+typing even if one exists (in fact, there are known scenarios where it\n+fails, some of which may eventually become problematic).\n+\n+## Key idea\n+\n+The main change is that each type variable T is associated with a\n+lower-bound L and an upper-bound U.  L and U begin as bottom and top,\n+respectively, but gradually narrow in response to new constraints\n+being introduced.  When a variable is finally resolved to a concrete\n+type, it can (theoretically) select any type that is a supertype of L\n+and a subtype of U.\n+\n+There are several critical invariants which we maintain:\n+\n+- the upper-bound of a variable only becomes lower and the lower-bound\n+  only becomes higher over time;\n+- the lower-bound L is always a subtype of the upper bound U;\n+- the lower-bound L and upper-bound U never refer to other type variables,\n+  but only to types (though those types may contain type variables).\n+\n+> An aside: if the terms upper- and lower-bound confuse you, think of\n+> \"supertype\" and \"subtype\".  The upper-bound is a \"supertype\"\n+> (super=upper in Latin, or something like that anyway) and the lower-bound\n+> is a \"subtype\" (sub=lower in Latin).  I find it helps to visualize\n+> a simple class hierarchy, like Java minus interfaces and\n+> primitive types.  The class Object is at the root (top) and other\n+> types lie in between.  The bottom type is then the Null type.\n+> So the tree looks like:\n+>\n+>             Object\n+>             /    \\\n+>         String   Other\n+>             \\    /\n+>             (null)\n+>\n+> So the upper bound type is the \"supertype\" and the lower bound is the\n+> \"subtype\" (also, super and sub mean upper and lower in Latin, or something\n+> like that anyway).\n+\n+## Satisfying constraints\n+\n+At a primitive level, there is only one form of constraint that the\n+inference understands: a subtype relation.  So the outside world can\n+say \"make type A a subtype of type B\".  If there are variables\n+involved, the inferencer will adjust their upper- and lower-bounds as\n+needed to ensure that this relation is satisfied. (We also allow \"make\n+type A equal to type B\", but this is translated into \"A <: B\" and \"B\n+<: A\")\n+\n+As stated above, we always maintain the invariant that type bounds\n+never refer to other variables.  This keeps the inference relatively\n+simple, avoiding the scenario of having a kind of graph where we have\n+to pump constraints along and reach a fixed point, but it does impose\n+some heuristics in the case where the user is relating two type\n+variables A <: B.\n+\n+Combining two variables such that variable A will forever be a subtype\n+of variable B is the trickiest part of the algorithm because there is\n+often no right choice---that is, the right choice will depend on\n+future constraints which we do not yet know. The problem comes about\n+because both A and B have bounds that can be adjusted in the future.\n+Let's look at some of the cases that can come up.\n+\n+Imagine, to start, the best case, where both A and B have an upper and\n+lower bound (that is, the bounds are not top nor bot respectively). In\n+that case, if we're lucky, A.ub <: B.lb, and so we know that whatever\n+A and B should become, they will forever have the desired subtyping\n+relation.  We can just leave things as they are.\n+\n+### Option 1: Unify\n+\n+However, suppose that A.ub is *not* a subtype of B.lb.  In\n+that case, we must make a decision.  One option is to unify A\n+and B so that they are one variable whose bounds are:\n+\n+    UB = GLB(A.ub, B.ub)\n+    LB = LUB(A.lb, B.lb)\n+\n+(Note that we will have to verify that LB <: UB; if it does not, the\n+types are not intersecting and there is an error) In that case, A <: B\n+holds trivially because A==B.  However, we have now lost some\n+flexibility, because perhaps the user intended for A and B to end up\n+as different types and not the same type.\n+\n+Pictorally, what this does is to take two distinct variables with\n+(hopefully not completely) distinct type ranges and produce one with\n+the intersection.\n+\n+                      B.ub                  B.ub\n+                       /\\                    /\n+               A.ub   /  \\           A.ub   /\n+               /   \\ /    \\              \\ /\n+              /     X      \\              UB\n+             /     / \\      \\            / \\\n+            /     /   /      \\          /   /\n+            \\     \\  /       /          \\  /\n+             \\      X       /             LB\n+              \\    / \\     /             / \\\n+               \\  /   \\   /             /   \\\n+               A.lb    B.lb          A.lb    B.lb\n+\n+\n+### Option 2: Relate UB/LB\n+\n+Another option is to keep A and B as distinct variables but set their\n+bounds in such a way that, whatever happens, we know that A <: B will hold.\n+This can be achieved by ensuring that A.ub <: B.lb.  In practice there\n+are two ways to do that, depicted pictorally here:\n+\n+        Before                Option #1            Option #2\n+\n+                 B.ub                B.ub                B.ub\n+                  /\\                 /  \\                /  \\\n+          A.ub   /  \\        A.ub   /(B')\\       A.ub   /(B')\\\n+          /   \\ /    \\           \\ /     /           \\ /     /\n+         /     X      \\         __UB____/             UB    /\n+        /     / \\      \\       /  |                   |    /\n+       /     /   /      \\     /   |                   |   /\n+       \\     \\  /       /    /(A')|                   |  /\n+        \\      X       /    /     LB            ______LB/\n+         \\    / \\     /    /     / \\           / (A')/ \\\n+          \\  /   \\   /     \\    /   \\          \\    /   \\\n+          A.lb    B.lb       A.lb    B.lb        A.lb    B.lb\n+\n+In these diagrams, UB and LB are defined as before.  As you can see,\n+the new ranges `A'` and `B'` are quite different from the range that\n+would be produced by unifying the variables.\n+\n+### What we do now\n+\n+Our current technique is to *try* (transactionally) to relate the\n+existing bounds of A and B, if there are any (i.e., if `UB(A) != top\n+&& LB(B) != bot`).  If that succeeds, we're done.  If it fails, then\n+we merge A and B into same variable.\n+\n+This is not clearly the correct course.  For example, if `UB(A) !=\n+top` but `LB(B) == bot`, we could conceivably set `LB(B)` to `UB(A)`\n+and leave the variables unmerged.  This is sometimes the better\n+course, it depends on the program.\n+\n+The main case which fails today that I would like to support is:\n+\n+    fn foo<T>(x: T, y: T) { ... }\n+\n+    fn bar() {\n+        let x: @mut int = @mut 3;\n+        let y: @int = @3;\n+        foo(x, y);\n+    }\n+\n+In principle, the inferencer ought to find that the parameter `T` to\n+`foo(x, y)` is `@const int`.  Today, however, it does not; this is\n+because the type variable `T` is merged with the type variable for\n+`X`, and thus inherits its UB/LB of `@mut int`.  This leaves no\n+flexibility for `T` to later adjust to accommodate `@int`.\n+\n+### What to do when not all bounds are present\n+\n+In the prior discussion we assumed that A.ub was not top and B.lb was\n+not bot.  Unfortunately this is rarely the case.  Often type variables\n+have \"lopsided\" bounds.  For example, if a variable in the program has\n+been initialized but has not been used, then its corresponding type\n+variable will have a lower bound but no upper bound.  When that\n+variable is then used, we would like to know its upper bound---but we\n+don't have one!  In this case we'll do different things depending on\n+how the variable is being used.\n+\n+## Transactional support\n+\n+Whenever we adjust merge variables or adjust their bounds, we always\n+keep a record of the old value.  This allows the changes to be undone.\n+\n+## Regions\n+\n+I've only talked about type variables here, but region variables\n+follow the same principle.  They have upper- and lower-bounds.  A\n+region A is a subregion of a region B if A being valid implies that B\n+is valid.  This basically corresponds to the block nesting structure:\n+the regions for outer block scopes are superregions of those for inner\n+block scopes.\n+\n+## Integral and floating-point type variables\n+\n+There is a third variety of type variable that we use only for\n+inferring the types of unsuffixed integer literals.  Integral type\n+variables differ from general-purpose type variables in that there's\n+no subtyping relationship among the various integral types, so instead\n+of associating each variable with an upper and lower bound, we just\n+use simple unification.  Each integer variable is associated with at\n+most one integer type.  Floating point types are handled similarly to\n+integral types.\n+\n+## GLB/LUB\n+\n+Computing the greatest-lower-bound and least-upper-bound of two\n+types/regions is generally straightforward except when type variables\n+are involved. In that case, we follow a similar \"try to use the bounds\n+when possible but otherwise merge the variables\" strategy.  In other\n+words, `GLB(A, B)` where `A` and `B` are variables will often result\n+in `A` and `B` being merged and the result being `A`.\n+\n+## Type coercion\n+\n+We have a notion of assignability which differs somewhat from\n+subtyping; in particular it may cause region borrowing to occur.  See\n+the big comment later in this file on Type Coercion for specifics.\n+\n+### In conclusion\n+\n+I showed you three ways to relate `A` and `B`.  There are also more,\n+of course, though I'm not sure if there are any more sensible options.\n+The main point is that there are various options, each of which\n+produce a distinct range of types for `A` and `B`.  Depending on what\n+the correct values for A and B are, one of these options will be the\n+right choice: but of course we don't know the right values for A and B\n+yet, that's what we're trying to find!  In our code, we opt to unify\n+(Option #1).\n+\n+# Implementation details\n+\n+We make use of a trait-like impementation strategy to consolidate\n+duplicated code between subtypes, GLB, and LUB computations.  See the\n+section on \"Type Combining\" below for details.\n+\n+*/\n\\ No newline at end of file"}, {"sha": "e533f019b4692724983b2eee1bbdf196a03c823d", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "added", "additions": 472, "deletions": 0, "changes": 472, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -0,0 +1,472 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+Error Reporting Code for the inference engine\n+\n+Because of the way inference, and in particular region inference,\n+works, it often happens that errors are not detected until far after\n+the relevant line of code has been type-checked. Therefore, there is\n+an elaborate system to track why a particular constraint in the\n+inference graph arose so that we can explain to the user what gave\n+rise to a patricular error.\n+\n+The basis of the system are the \"origin\" types. An \"origin\" is the\n+reason that a constraint or inference variable arose. There are\n+different \"origin\" enums for different kinds of constraints/variables\n+(e.g., `TypeOrigin`, `RegionVariableOrigin`). An origin always has\n+a span, but also more information so that we can generate a meaningful\n+error message.\n+\n+Having a catalogue of all the different reasons an error can arise is\n+also useful for other reasons, like cross-referencing FAQs etc, though\n+we are not really taking advantage of this yet.\n+\n+# Region Inference\n+\n+Region inference is particularly tricky because it always succeeds \"in\n+the moment\" and simply registers a constraint. Then, at the end, we\n+can compute the full graph and report errors, so we need to be able to\n+store and later report what gave rise to the conflicting constraints.\n+\n+# Subtype Trace\n+\n+Determing whether `T1 <: T2` often involves a number of subtypes and\n+subconstraints along the way. A \"TypeTrace\" is an extended version\n+of an origin that traces the types and other values that were being\n+compared. It is not necessarily comprehensive (in fact, at the time of\n+this writing it only tracks the root values being compared) but I'd\n+like to extend it to include significant \"waypoints\". For example, if\n+you are comparing `(T1, T2) <: (T3, T4)`, and the problem is that `T2\n+<: T4` fails, I'd like the trace to include enough information to say\n+\"in the 2nd element of the tuple\". Similarly, failures when comparing\n+arguments or return types in fn types should be able to cite the\n+specific position, etc.\n+\n+# Reality vs plan\n+\n+Of course, there is still a LOT of code in typeck that has yet to be\n+ported to this system, and which relies on string concatenation at the\n+time of error detection.\n+\n+*/\n+\n+use std::prelude::*;\n+use middle::ty;\n+use middle::ty::Region;\n+use middle::typeck::infer;\n+use middle::typeck::infer::InferCtxt;\n+use middle::typeck::infer::TypeTrace;\n+use middle::typeck::infer::TypeOrigin;\n+use middle::typeck::infer::SubregionOrigin;\n+use middle::typeck::infer::RegionVariableOrigin;\n+use middle::typeck::infer::Types;\n+use middle::typeck::infer::TraitRefs;\n+use middle::typeck::infer::ValuePairs;\n+use middle::typeck::infer::region_inference::RegionResolutionError;\n+use middle::typeck::infer::region_inference::ConcreteFailure;\n+use middle::typeck::infer::region_inference::SubSupConflict;\n+use middle::typeck::infer::region_inference::SupSupConflict;\n+use syntax::opt_vec;\n+use syntax::opt_vec::OptVec;\n+use util::ppaux::UserString;\n+use util::ppaux::note_and_explain_region;\n+\n+pub trait ErrorReporting {\n+    pub fn report_region_errors(@mut self,\n+                                errors: &OptVec<RegionResolutionError>);\n+\n+    pub fn report_and_explain_type_error(@mut self,\n+                                         trace: TypeTrace,\n+                                         terr: &ty::type_err);\n+\n+    fn values_str(@mut self, values: &ValuePairs) -> Option<~str>;\n+\n+    fn expected_found_str<T:UserString+Resolvable>(\n+        @mut self,\n+        exp_found: &ty::expected_found<T>)\n+        -> Option<~str>;\n+\n+    fn report_concrete_failure(@mut self,\n+                               origin: SubregionOrigin,\n+                               sub: Region,\n+                               sup: Region);\n+\n+    fn report_sub_sup_conflict(@mut self,\n+                               var_origin: RegionVariableOrigin,\n+                               sub_origin: SubregionOrigin,\n+                               sub_region: Region,\n+                               sup_origin: SubregionOrigin,\n+                               sup_region: Region);\n+\n+    fn report_sup_sup_conflict(@mut self,\n+                               var_origin: RegionVariableOrigin,\n+                               origin1: SubregionOrigin,\n+                               region1: Region,\n+                               origin2: SubregionOrigin,\n+                               region2: Region);\n+}\n+\n+\n+impl ErrorReporting for InferCtxt {\n+    pub fn report_region_errors(@mut self,\n+                                errors: &OptVec<RegionResolutionError>) {\n+        for errors.iter().advance |error| {\n+            match *error {\n+                ConcreteFailure(origin, sub, sup) => {\n+                    self.report_concrete_failure(origin, sub, sup);\n+                }\n+\n+                SubSupConflict(var_origin,\n+                               sub_origin, sub_r,\n+                               sup_origin, sup_r) => {\n+                    self.report_sub_sup_conflict(var_origin,\n+                                                 sub_origin, sub_r,\n+                                                 sup_origin, sup_r);\n+                }\n+\n+                SupSupConflict(var_origin,\n+                               origin1, r1,\n+                               origin2, r2) => {\n+                    self.report_sup_sup_conflict(var_origin,\n+                                                 origin1, r1,\n+                                                 origin2, r2);\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn report_and_explain_type_error(@mut self,\n+                                     trace: TypeTrace,\n+                                     terr: &ty::type_err) {\n+        let tcx = self.tcx;\n+\n+        let expected_found_str = match self.values_str(&trace.values) {\n+            Some(v) => v,\n+            None => {\n+                return; /* derived error */\n+            }\n+        };\n+\n+        let message_root_str = match trace.origin {\n+            infer::Misc(_) => \"mismatched types\",\n+            infer::MethodCompatCheck(_) => \"method not compatible with trait\",\n+            infer::ExprAssignable(_) => \"mismatched types\",\n+            infer::RelateTraitRefs(_) => \"mismatched traits\",\n+            infer::RelateSelfType(_) => \"mismatched types\",\n+            infer::MatchExpression(_) => \"match arms have incompatible types\",\n+            infer::IfExpression(_) => \"if and else have incompatible types\",\n+        };\n+\n+        self.tcx.sess.span_err(\n+            trace.origin.span(),\n+            fmt!(\"%s: %s (%s)\",\n+                 message_root_str,\n+                 expected_found_str,\n+                 ty::type_err_to_str(tcx, terr)));\n+\n+        ty::note_and_explain_type_err(self.tcx, terr);\n+    }\n+\n+    fn values_str(@mut self, values: &ValuePairs) -> Option<~str> {\n+        /*!\n+         * Returns a string of the form \"expected `%s` but found `%s`\",\n+         * or None if this is a derived error.\n+         */\n+        match *values {\n+            infer::Types(ref exp_found) => {\n+                self.expected_found_str(exp_found)\n+            }\n+            infer::TraitRefs(ref exp_found) => {\n+                self.expected_found_str(exp_found)\n+            }\n+        }\n+    }\n+\n+    fn expected_found_str<T:UserString+Resolvable>(\n+        @mut self,\n+        exp_found: &ty::expected_found<T>)\n+        -> Option<~str>\n+    {\n+        let expected = exp_found.expected.resolve(self);\n+        if expected.contains_error() {\n+            return None;\n+        }\n+\n+        let found = exp_found.found.resolve(self);\n+        if found.contains_error() {\n+            return None;\n+        }\n+\n+        Some(fmt!(\"expected `%s` but found `%s`\",\n+                  expected.user_string(self.tcx),\n+                  found.user_string(self.tcx)))\n+    }\n+\n+    fn report_concrete_failure(@mut self,\n+                               origin: SubregionOrigin,\n+                               sub: Region,\n+                               sup: Region) {\n+        match origin {\n+            infer::Subtype(trace) => {\n+                let terr = ty::terr_regions_does_not_outlive(sup, sub);\n+                self.report_and_explain_type_error(trace, &terr);\n+            }\n+            infer::Reborrow(span) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    \"lifetime of borrowed pointer outlines \\\n+                     lifetime of borrowed content...\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"...the borrowed pointer is valid for \",\n+                    sub,\n+                    \"...\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"...but the borrowed content is only valid for \",\n+                    sup,\n+                    \"\");\n+            }\n+            infer::InvokeClosure(span) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    \"cannot invoke closure outside of its lifetime\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"the closure is only valid for \",\n+                    sup,\n+                    \"\");\n+            }\n+            infer::DerefPointer(span) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    \"dereference of reference outside its lifetime\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"the reference is only valid for \",\n+                    sup,\n+                    \"\");\n+            }\n+            infer::FreeVariable(span) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    \"captured variable does not outlive the enclosing closure\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"captured variable is valid for \",\n+                    sup,\n+                    \"\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"closure is valid for \",\n+                    sub,\n+                    \"\");\n+            }\n+            infer::IndexSlice(span) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    fmt!(\"index of slice outside its lifetime\"));\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"the slice is only valid for \",\n+                    sup,\n+                    \"\");\n+            }\n+            infer::RelateObjectBound(span) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    \"lifetime of the source pointer does not outlive \\\n+                     lifetime bound of the object type\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"object type is valid for \",\n+                    sub,\n+                    \"\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"source pointer is only valid for \",\n+                    sup,\n+                    \"\");\n+            }\n+            infer::CallRcvr(span) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    \"lifetime of method receiver does not outlive \\\n+                     the method call\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"the receiver is only valid for \",\n+                    sup,\n+                    \"\");\n+            }\n+            infer::CallArg(span) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    \"lifetime of function argument does not outlive \\\n+                     the function call\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"the function argument is only valid for \",\n+                    sup,\n+                    \"\");\n+            }\n+            infer::CallReturn(span) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    \"lifetime of return value does not outlive \\\n+                     the function call\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"the return value is only valid for \",\n+                    sup,\n+                    \"\");\n+            }\n+            infer::AddrOf(span) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    \"borrowed pointer is not valid \\\n+                     at the time of borrow\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"the borrow is only valid for \",\n+                    sup,\n+                    \"\");\n+            }\n+            infer::AutoBorrow(span) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    \"automatically borrowed pointer is not valid \\\n+                     at the time of borrow\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"the automatic borrow is only valid for \",\n+                    sup,\n+                    \"\");\n+            }\n+            infer::BindingTypeIsNotValidAtDecl(span) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    \"lifetime of variable does not enclose its declaration\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"the variable is only valid for \",\n+                    sup,\n+                    \"\");\n+            }\n+            infer::ReferenceOutlivesReferent(ty, span) => {\n+                self.tcx.sess.span_err(\n+                    origin.span(),\n+                    fmt!(\"in type `%s`, pointer has a longer lifetime than \\\n+                          the data it references\",\n+                         ty.user_string(self.tcx)));\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"the pointer is valid for \",\n+                    sub,\n+                    \"\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"but the referenced data is only valid for \",\n+                    sup,\n+                    \"\");\n+            }\n+        }\n+    }\n+\n+    fn report_sub_sup_conflict(@mut self,\n+                               var_origin: RegionVariableOrigin,\n+                               sub_origin: SubregionOrigin,\n+                               sub_region: Region,\n+                               sup_origin: SubregionOrigin,\n+                               sup_region: Region) {\n+        self.tcx.sess.span_err(\n+            var_origin.span(),\n+            fmt!(\"cannot infer an appropriate lifetime \\\n+                  due to conflicting requirements\"));\n+\n+        note_and_explain_region(\n+            self.tcx,\n+            \"first, the lifetime cannot outlive \",\n+            sup_region,\n+            \"...\");\n+\n+        self.tcx.sess.span_note(\n+            sup_origin.span(),\n+            fmt!(\"...due to the following expression\"));\n+\n+        note_and_explain_region(\n+            self.tcx,\n+            \"but, the lifetime must be valid for \",\n+            sub_region,\n+            \"...\");\n+\n+        self.tcx.sess.span_note(\n+            sub_origin.span(),\n+            fmt!(\"...due to the following expression\"));\n+    }\n+\n+    fn report_sup_sup_conflict(@mut self,\n+                               var_origin: RegionVariableOrigin,\n+                               origin1: SubregionOrigin,\n+                               region1: Region,\n+                               origin2: SubregionOrigin,\n+                               region2: Region) {\n+        self.tcx.sess.span_err(\n+            var_origin.span(),\n+            fmt!(\"cannot infer an appropriate lifetime \\\n+                  due to conflicting requirements\"));\n+\n+        note_and_explain_region(\n+            self.tcx,\n+            \"first, the lifetime must be contained by \",\n+            region1,\n+            \"...\");\n+\n+        self.tcx.sess.span_note(\n+            origin1.span(),\n+            fmt!(\"...due to the following expression\"));\n+\n+        note_and_explain_region(\n+            self.tcx,\n+            \"but, the lifetime must also be contained by \",\n+            region2,\n+            \"...\");\n+\n+        self.tcx.sess.span_note(\n+            origin2.span(),\n+            fmt!(\"...due to the following expression\"));\n+    }\n+}\n+\n+trait Resolvable {\n+    fn resolve(&self, infcx: @mut InferCtxt) -> Self;\n+    fn contains_error(&self) -> bool;\n+}\n+\n+impl Resolvable for ty::t {\n+    fn resolve(&self, infcx: @mut InferCtxt) -> ty::t {\n+        infcx.resolve_type_vars_if_possible(*self)\n+    }\n+    fn contains_error(&self) -> bool {\n+        ty::type_is_error(*self)\n+    }\n+}\n+\n+impl Resolvable for @ty::TraitRef {\n+    fn resolve(&self, infcx: @mut InferCtxt) -> @ty::TraitRef {\n+        @infcx.resolve_type_vars_in_trait_ref_if_possible(*self)\n+    }\n+    fn contains_error(&self) -> bool {\n+        ty::trait_ref_contains_error(*self)\n+    }\n+}\n+"}, {"sha": "fefbf2336c29fe254cbd9b3401cccec1a071de00", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -18,6 +18,7 @@ use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::{cres, InferCtxt};\n+use middle::typeck::infer::{TypeTrace, Subtype};\n use middle::typeck::infer::fold_regions_in_sig;\n use middle::typeck::isr_alist;\n use syntax::ast;\n@@ -37,7 +38,7 @@ impl Combine for Glb {\n     fn infcx(&self) -> @mut InferCtxt { self.infcx }\n     fn tag(&self) -> ~str { ~\"glb\" }\n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n-    fn span(&self) -> span { self.span }\n+    fn trace(&self) -> TypeTrace { self.trace }\n \n     fn sub(&self) -> Sub { Sub(**self) }\n     fn lub(&self) -> Lub { Lub(**self) }\n@@ -127,9 +128,7 @@ impl Combine for Glb {\n                a.inf_str(self.infcx),\n                b.inf_str(self.infcx));\n \n-        do indent {\n-            self.infcx.region_vars.glb_regions(self.span, a, b)\n-        }\n+        Ok(self.infcx.region_vars.glb_regions(Subtype(self.trace), a, b))\n     }\n \n     fn contraregions(&self, a: ty::Region, b: ty::Region)\n@@ -181,11 +180,11 @@ impl Combine for Glb {\n         // Instantiate each bound region with a fresh region variable.\n         let (a_with_fresh, a_isr) =\n             self.infcx.replace_bound_regions_with_fresh_regions(\n-                self.span, a);\n+                self.trace, a);\n         let a_vars = var_ids(self, a_isr);\n         let (b_with_fresh, b_isr) =\n             self.infcx.replace_bound_regions_with_fresh_regions(\n-                self.span, b);\n+                self.trace, b);\n         let b_vars = var_ids(self, b_isr);\n \n         // Collect constraints.\n@@ -277,7 +276,7 @@ impl Combine for Glb {\n             }\n \n             this.infcx.tcx.sess.span_bug(\n-                this.span,\n+                this.trace.origin.span(),\n                 fmt!(\"could not find original bound region for %?\", r));\n         }\n "}, {"sha": "b1a6aefd17949830c481313d31fe47f95fbe0e06", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -530,7 +530,7 @@ pub fn var_ids<T:Combine>(this: &T, isr: isr_alist) -> ~[RegionVid] {\n             ty::re_infer(ty::ReVar(r)) => { result.push(r); }\n             r => {\n                 this.infcx().tcx.sess.span_bug(\n-                    this.span(),\n+                    this.trace().origin.span(),\n                     fmt!(\"Found non-region-vid: %?\", r));\n             }\n         }"}, {"sha": "efb1dc200b521a9045d1111c00abfd9b3e378aa4", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -19,6 +19,7 @@ use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::{cres, InferCtxt};\n use middle::typeck::infer::fold_regions_in_sig;\n+use middle::typeck::infer::{TypeTrace, Subtype};\n use middle::typeck::isr_alist;\n use util::common::indent;\n use util::ppaux::mt_to_str;\n@@ -44,7 +45,7 @@ impl Combine for Lub {\n     fn infcx(&self) -> @mut InferCtxt { self.infcx }\n     fn tag(&self) -> ~str { ~\"lub\" }\n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n-    fn span(&self) -> span { self.span }\n+    fn trace(&self) -> TypeTrace { self.trace }\n \n     fn sub(&self) -> Sub { Sub(**self) }\n     fn lub(&self) -> Lub { Lub(**self) }\n@@ -119,9 +120,7 @@ impl Combine for Lub {\n                a.inf_str(self.infcx),\n                b.inf_str(self.infcx));\n \n-        do indent {\n-            self.infcx.region_vars.lub_regions(self.span, a, b)\n-        }\n+        Ok(self.infcx.region_vars.lub_regions(Subtype(self.trace), a, b))\n     }\n \n     fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n@@ -137,10 +136,10 @@ impl Combine for Lub {\n         // Instantiate each bound region with a fresh region variable.\n         let (a_with_fresh, a_isr) =\n             self.infcx.replace_bound_regions_with_fresh_regions(\n-                self.span, a);\n+                self.trace, a);\n         let (b_with_fresh, _) =\n             self.infcx.replace_bound_regions_with_fresh_regions(\n-                self.span, b);\n+                self.trace, b);\n \n         // Collect constraints.\n         let sig0 = if_ok!(super_fn_sigs(self, &a_with_fresh, &b_with_fresh));\n@@ -196,7 +195,7 @@ impl Combine for Lub {\n             }\n \n             this.infcx.tcx.sess.span_bug(\n-                this.span,\n+                this.trace.origin.span(),\n                 fmt!(\"Region %? is not associated with \\\n                       any bound region from A!\", r0));\n         }"}, {"sha": "3360edc6a46787e6041892ca2c3ea82c814a53ad", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 358, "deletions": 290, "changes": 648, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -8,239 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n-\n-# Type inference engine\n-\n-This is loosely based on standard HM-type inference, but with an\n-extension to try and accommodate subtyping.  There is nothing\n-principled about this extension; it's sound---I hope!---but it's a\n-heuristic, ultimately, and does not guarantee that it finds a valid\n-typing even if one exists (in fact, there are known scenarios where it\n-fails, some of which may eventually become problematic).\n-\n-## Key idea\n-\n-The main change is that each type variable T is associated with a\n-lower-bound L and an upper-bound U.  L and U begin as bottom and top,\n-respectively, but gradually narrow in response to new constraints\n-being introduced.  When a variable is finally resolved to a concrete\n-type, it can (theoretically) select any type that is a supertype of L\n-and a subtype of U.\n-\n-There are several critical invariants which we maintain:\n-\n-- the upper-bound of a variable only becomes lower and the lower-bound\n-  only becomes higher over time;\n-- the lower-bound L is always a subtype of the upper bound U;\n-- the lower-bound L and upper-bound U never refer to other type variables,\n-  but only to types (though those types may contain type variables).\n-\n-> An aside: if the terms upper- and lower-bound confuse you, think of\n-> \"supertype\" and \"subtype\".  The upper-bound is a \"supertype\"\n-> (super=upper in Latin, or something like that anyway) and the lower-bound\n-> is a \"subtype\" (sub=lower in Latin).  I find it helps to visualize\n-> a simple class hierarchy, like Java minus interfaces and\n-> primitive types.  The class Object is at the root (top) and other\n-> types lie in between.  The bottom type is then the Null type.\n-> So the tree looks like:\n->\n->             Object\n->             /    \\\n->         String   Other\n->             \\    /\n->             (null)\n->\n-> So the upper bound type is the \"supertype\" and the lower bound is the\n-> \"subtype\" (also, super and sub mean upper and lower in Latin, or something\n-> like that anyway).\n-\n-## Satisfying constraints\n-\n-At a primitive level, there is only one form of constraint that the\n-inference understands: a subtype relation.  So the outside world can\n-say \"make type A a subtype of type B\".  If there are variables\n-involved, the inferencer will adjust their upper- and lower-bounds as\n-needed to ensure that this relation is satisfied. (We also allow \"make\n-type A equal to type B\", but this is translated into \"A <: B\" and \"B\n-<: A\")\n-\n-As stated above, we always maintain the invariant that type bounds\n-never refer to other variables.  This keeps the inference relatively\n-simple, avoiding the scenario of having a kind of graph where we have\n-to pump constraints along and reach a fixed point, but it does impose\n-some heuristics in the case where the user is relating two type\n-variables A <: B.\n-\n-Combining two variables such that variable A will forever be a subtype\n-of variable B is the trickiest part of the algorithm because there is\n-often no right choice---that is, the right choice will depend on\n-future constraints which we do not yet know. The problem comes about\n-because both A and B have bounds that can be adjusted in the future.\n-Let's look at some of the cases that can come up.\n-\n-Imagine, to start, the best case, where both A and B have an upper and\n-lower bound (that is, the bounds are not top nor bot respectively). In\n-that case, if we're lucky, A.ub <: B.lb, and so we know that whatever\n-A and B should become, they will forever have the desired subtyping\n-relation.  We can just leave things as they are.\n-\n-### Option 1: Unify\n-\n-However, suppose that A.ub is *not* a subtype of B.lb.  In\n-that case, we must make a decision.  One option is to unify A\n-and B so that they are one variable whose bounds are:\n-\n-    UB = GLB(A.ub, B.ub)\n-    LB = LUB(A.lb, B.lb)\n-\n-(Note that we will have to verify that LB <: UB; if it does not, the\n-types are not intersecting and there is an error) In that case, A <: B\n-holds trivially because A==B.  However, we have now lost some\n-flexibility, because perhaps the user intended for A and B to end up\n-as different types and not the same type.\n-\n-Pictorally, what this does is to take two distinct variables with\n-(hopefully not completely) distinct type ranges and produce one with\n-the intersection.\n-\n-                      B.ub                  B.ub\n-                       /\\                    /\n-               A.ub   /  \\           A.ub   /\n-               /   \\ /    \\              \\ /\n-              /     X      \\              UB\n-             /     / \\      \\            / \\\n-            /     /   /      \\          /   /\n-            \\     \\  /       /          \\  /\n-             \\      X       /             LB\n-              \\    / \\     /             / \\\n-               \\  /   \\   /             /   \\\n-               A.lb    B.lb          A.lb    B.lb\n-\n-\n-### Option 2: Relate UB/LB\n-\n-Another option is to keep A and B as distinct variables but set their\n-bounds in such a way that, whatever happens, we know that A <: B will hold.\n-This can be achieved by ensuring that A.ub <: B.lb.  In practice there\n-are two ways to do that, depicted pictorally here:\n-\n-        Before                Option #1            Option #2\n-\n-                 B.ub                B.ub                B.ub\n-                  /\\                 /  \\                /  \\\n-          A.ub   /  \\        A.ub   /(B')\\       A.ub   /(B')\\\n-          /   \\ /    \\           \\ /     /           \\ /     /\n-         /     X      \\         __UB____/             UB    /\n-        /     / \\      \\       /  |                   |    /\n-       /     /   /      \\     /   |                   |   /\n-       \\     \\  /       /    /(A')|                   |  /\n-        \\      X       /    /     LB            ______LB/\n-         \\    / \\     /    /     / \\           / (A')/ \\\n-          \\  /   \\   /     \\    /   \\          \\    /   \\\n-          A.lb    B.lb       A.lb    B.lb        A.lb    B.lb\n-\n-In these diagrams, UB and LB are defined as before.  As you can see,\n-the new ranges `A'` and `B'` are quite different from the range that\n-would be produced by unifying the variables.\n-\n-### What we do now\n-\n-Our current technique is to *try* (transactionally) to relate the\n-existing bounds of A and B, if there are any (i.e., if `UB(A) != top\n-&& LB(B) != bot`).  If that succeeds, we're done.  If it fails, then\n-we merge A and B into same variable.\n-\n-This is not clearly the correct course.  For example, if `UB(A) !=\n-top` but `LB(B) == bot`, we could conceivably set `LB(B)` to `UB(A)`\n-and leave the variables unmerged.  This is sometimes the better\n-course, it depends on the program.\n-\n-The main case which fails today that I would like to support is:\n-\n-    fn foo<T>(x: T, y: T) { ... }\n-\n-    fn bar() {\n-        let x: @mut int = @mut 3;\n-        let y: @int = @3;\n-        foo(x, y);\n-    }\n-\n-In principle, the inferencer ought to find that the parameter `T` to\n-`foo(x, y)` is `@const int`.  Today, however, it does not; this is\n-because the type variable `T` is merged with the type variable for\n-`X`, and thus inherits its UB/LB of `@mut int`.  This leaves no\n-flexibility for `T` to later adjust to accommodate `@int`.\n-\n-### What to do when not all bounds are present\n-\n-In the prior discussion we assumed that A.ub was not top and B.lb was\n-not bot.  Unfortunately this is rarely the case.  Often type variables\n-have \"lopsided\" bounds.  For example, if a variable in the program has\n-been initialized but has not been used, then its corresponding type\n-variable will have a lower bound but no upper bound.  When that\n-variable is then used, we would like to know its upper bound---but we\n-don't have one!  In this case we'll do different things depending on\n-how the variable is being used.\n-\n-## Transactional support\n-\n-Whenever we adjust merge variables or adjust their bounds, we always\n-keep a record of the old value.  This allows the changes to be undone.\n-\n-## Regions\n-\n-I've only talked about type variables here, but region variables\n-follow the same principle.  They have upper- and lower-bounds.  A\n-region A is a subregion of a region B if A being valid implies that B\n-is valid.  This basically corresponds to the block nesting structure:\n-the regions for outer block scopes are superregions of those for inner\n-block scopes.\n-\n-## Integral and floating-point type variables\n-\n-There is a third variety of type variable that we use only for\n-inferring the types of unsuffixed integer literals.  Integral type\n-variables differ from general-purpose type variables in that there's\n-no subtyping relationship among the various integral types, so instead\n-of associating each variable with an upper and lower bound, we just\n-use simple unification.  Each integer variable is associated with at\n-most one integer type.  Floating point types are handled similarly to\n-integral types.\n-\n-## GLB/LUB\n-\n-Computing the greatest-lower-bound and least-upper-bound of two\n-types/regions is generally straightforward except when type variables\n-are involved. In that case, we follow a similar \"try to use the bounds\n-when possible but otherwise merge the variables\" strategy.  In other\n-words, `GLB(A, B)` where `A` and `B` are variables will often result\n-in `A` and `B` being merged and the result being `A`.\n-\n-## Type coercion\n-\n-We have a notion of assignability which differs somewhat from\n-subtyping; in particular it may cause region borrowing to occur.  See\n-the big comment later in this file on Type Coercion for specifics.\n-\n-### In conclusion\n-\n-I showed you three ways to relate `A` and `B`.  There are also more,\n-of course, though I'm not sure if there are any more sensible options.\n-The main point is that there are various options, each of which\n-produce a distinct range of types for `A` and `B`.  Depending on what\n-the correct values for A and B are, one of these options will be the\n-right choice: but of course we don't know the right values for A and B\n-yet, that's what we're trying to find!  In our code, we opt to unify\n-(Option #1).\n-\n-# Implementation details\n-\n-We make use of a trait-like impementation strategy to consolidate\n-duplicated code between subtypes, GLB, and LUB computations.  See the\n-section on \"Type Combining\" below for details.\n-\n-*/\n+/*! See doc.rs for documentation */\n \n \n pub use middle::ty::IntVarValue;\n@@ -260,11 +28,14 @@ use middle::typeck::infer::combine::{Combine, CombineFields, eq_tys};\n use middle::typeck::infer::region_inference::{RegionVarBindings};\n use middle::typeck::infer::resolve::{resolver};\n use middle::typeck::infer::sub::Sub;\n+use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::unify::{ValsAndBindings, Root};\n+use middle::typeck::infer::error_reporting::ErrorReporting;\n use middle::typeck::isr_alist;\n use util::common::indent;\n-use util::ppaux::{bound_region_to_str, ty_to_str, trait_ref_to_str};\n+use util::ppaux::{bound_region_to_str, ty_to_str, trait_ref_to_str, Repr,\n+                  UserString};\n \n use std::result;\n use std::vec;\n@@ -275,17 +46,20 @@ use syntax::ast;\n use syntax::codemap;\n use syntax::codemap::span;\n \n+pub mod doc;\n pub mod macros;\n pub mod combine;\n pub mod glb;\n pub mod lattice;\n pub mod lub;\n+#[path = \"region_inference/mod.rs\"]\n pub mod region_inference;\n pub mod resolve;\n pub mod sub;\n pub mod to_str;\n pub mod unify;\n pub mod coercion;\n+pub mod error_reporting;\n \n pub type Bound<T> = Option<T>;\n pub struct Bounds<T> {\n@@ -319,6 +93,133 @@ pub struct InferCtxt {\n     region_vars: RegionVarBindings,\n }\n \n+/// Why did we require that the two types be related?\n+///\n+/// See `error_reporting.rs` for more details\n+pub enum TypeOrigin {\n+    // Not yet categorized in a better way\n+    Misc(span),\n+\n+    // Checking that method of impl is compatible with trait\n+    MethodCompatCheck(span),\n+\n+    // Checking that this expression can be assigned where it needs to be\n+    ExprAssignable(@ast::expr),\n+\n+    // Relating trait refs when resolving vtables\n+    RelateTraitRefs(span),\n+\n+    // Relating trait refs when resolving vtables\n+    RelateSelfType(span),\n+\n+    // Computing common supertype in a match expression\n+    MatchExpression(span),\n+\n+    // Computing common supertype in an if expression\n+    IfExpression(span),\n+}\n+\n+/// See `error_reporting.rs` for more details\n+pub enum ValuePairs {\n+    Types(ty::expected_found<ty::t>),\n+    TraitRefs(ty::expected_found<@ty::TraitRef>),\n+}\n+\n+/// The trace designates the path through inference that we took to\n+/// encounter an error or subtyping constraint.\n+///\n+/// See `error_reporting.rs` for more details.\n+pub struct TypeTrace {\n+    origin: TypeOrigin,\n+    values: ValuePairs,\n+}\n+\n+/// The origin of a `r1 <= r2` constraint.\n+///\n+/// See `error_reporting.rs` for more details\n+pub enum SubregionOrigin {\n+    // Arose from a subtyping relation\n+    Subtype(TypeTrace),\n+\n+    // Invocation of closure must be within its lifetime\n+    InvokeClosure(span),\n+\n+    // Dereference of borrowed pointer must be within its lifetime\n+    DerefPointer(span),\n+\n+    // Closure bound must not outlive captured free variables\n+    FreeVariable(span),\n+\n+    // Index into slice must be within its lifetime\n+    IndexSlice(span),\n+\n+    // When casting `&'a T` to an `&'b Trait` object,\n+    // relating `'a` to `'b`\n+    RelateObjectBound(span),\n+\n+    // Creating a pointer `b` to contents of another borrowed pointer\n+    Reborrow(span),\n+\n+    // (&'a &'b T) where a >= b\n+    ReferenceOutlivesReferent(ty::t, span),\n+\n+    // A `ref b` whose region does not enclose the decl site\n+    BindingTypeIsNotValidAtDecl(span),\n+\n+    // Regions appearing in a method receiver must outlive method call\n+    CallRcvr(span),\n+\n+    // Regions appearing in a function argument must outlive func call\n+    CallArg(span),\n+\n+    // Region in return type of invoked fn must enclose call\n+    CallReturn(span),\n+\n+    // Region resulting from a `&` expr must enclose the `&` expr\n+    AddrOf(span),\n+\n+    // An auto-borrow that does not enclose the expr where it occurs\n+    AutoBorrow(span),\n+}\n+\n+/// Reasons to create a region inference variable\n+///\n+/// See `error_reporting.rs` for more details\n+pub enum RegionVariableOrigin {\n+    // Region variables created for ill-categorized reasons,\n+    // mostly indicates places in need of refactoring\n+    MiscVariable(span),\n+\n+    // Regions created by a `&P` or `[...]` pattern\n+    PatternRegion(span),\n+\n+    // Regions created by `&` operator\n+    AddrOfRegion(span),\n+\n+    // Regions created by `&[...]` literal\n+    AddrOfSlice(span),\n+\n+    // Regions created as part of an autoref of a method receiver\n+    Autoref(span),\n+\n+    // Regions created as part of an automatic coercion\n+    Coercion(TypeTrace),\n+\n+    // Region variables created for bound regions\n+    // in a function or method that is called\n+    BoundRegionInFnCall(span, ty::bound_region),\n+\n+    // Region variables created for bound regions\n+    // when doing subtyping/lub/glb computations\n+    BoundRegionInFnType(span, ty::bound_region),\n+\n+    BoundRegionInTypeOrImpl(span),\n+\n+    BoundRegionInCoherence,\n+\n+    BoundRegionError(span),\n+}\n+\n pub enum fixup_err {\n     unresolved_int_ty(IntVid),\n     unresolved_ty(TyVid),\n@@ -364,16 +265,51 @@ pub fn new_infer_ctxt(tcx: ty::ctxt) -> @mut InferCtxt {\n     }\n }\n \n+pub fn common_supertype(cx: @mut InferCtxt,\n+                        origin: TypeOrigin,\n+                        a_is_expected: bool,\n+                        a: ty::t,\n+                        b: ty::t)\n+                        -> ty::t {\n+    /*!\n+     * Computes the least upper-bound of `a` and `b`. If this is\n+     * not possible, reports an error and returns ty::err.\n+     */\n+\n+    debug!(\"common_supertype(%s, %s)\", a.inf_str(cx), b.inf_str(cx));\n+\n+    let trace = TypeTrace {\n+        origin: origin,\n+        values: Types(expected_found(a_is_expected, a, b))\n+    };\n+\n+    let result = do cx.commit {\n+        cx.lub(a_is_expected, trace).tys(a, b)\n+    };\n+\n+    match result {\n+        Ok(t) => t,\n+        Err(ref err) => {\n+            cx.report_and_explain_type_error(trace, err);\n+            ty::mk_err()\n+        }\n+    }\n+}\n+\n pub fn mk_subty(cx: @mut InferCtxt,\n                 a_is_expected: bool,\n-                span: span,\n+                origin: TypeOrigin,\n                 a: ty::t,\n                 b: ty::t)\n              -> ures {\n     debug!(\"mk_subty(%s <: %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.commit {\n-            cx.sub(a_is_expected, span).tys(a, b)\n+            let trace = TypeTrace {\n+                origin: origin,\n+                values: Types(expected_found(a_is_expected, a, b))\n+            };\n+            cx.sub(a_is_expected, trace).tys(a, b)\n         }\n     }.to_ures()\n }\n@@ -382,67 +318,90 @@ pub fn can_mk_subty(cx: @mut InferCtxt, a: ty::t, b: ty::t) -> ures {\n     debug!(\"can_mk_subty(%s <: %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.probe {\n-            cx.sub(true, codemap::dummy_sp()).tys(a, b)\n+            let trace = TypeTrace {\n+                origin: Misc(codemap::dummy_sp()),\n+                values: Types(expected_found(true, a, b))\n+            };\n+            cx.sub(true, trace).tys(a, b)\n         }\n     }.to_ures()\n }\n \n pub fn mk_subr(cx: @mut InferCtxt,\n                a_is_expected: bool,\n-               span: span,\n+               origin: SubregionOrigin,\n                a: ty::Region,\n-               b: ty::Region)\n-            -> ures {\n+               b: ty::Region) {\n     debug!(\"mk_subr(%s <: %s)\", a.inf_str(cx), b.inf_str(cx));\n-    do indent {\n-        do cx.commit {\n-            cx.sub(a_is_expected, span).regions(a, b)\n-        }\n-    }.to_ures()\n+    cx.region_vars.start_snapshot();\n+    cx.region_vars.make_subregion(origin, a, b);\n+    cx.region_vars.commit();\n }\n \n pub fn mk_eqty(cx: @mut InferCtxt,\n                a_is_expected: bool,\n-               span: span,\n+               origin: TypeOrigin,\n                a: ty::t,\n                b: ty::t)\n             -> ures {\n     debug!(\"mk_eqty(%s <: %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.commit {\n-            let suber = cx.sub(a_is_expected, span);\n+            let trace = TypeTrace {\n+                origin: origin,\n+                values: Types(expected_found(a_is_expected, a, b))\n+            };\n+            let suber = cx.sub(a_is_expected, trace);\n             eq_tys(&suber, a, b)\n         }\n     }.to_ures()\n }\n \n pub fn mk_sub_trait_refs(cx: @mut InferCtxt,\n                          a_is_expected: bool,\n-                         span: span,\n-                         a: &ty::TraitRef,\n-                         b: &ty::TraitRef)\n+                         origin: TypeOrigin,\n+                         a: @ty::TraitRef,\n+                         b: @ty::TraitRef)\n     -> ures\n {\n     debug!(\"mk_sub_trait_refs(%s <: %s)\",\n            a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.commit {\n-            let suber = cx.sub(a_is_expected, span);\n+            let trace = TypeTrace {\n+                origin: origin,\n+                values: TraitRefs(expected_found(a_is_expected, a, b))\n+            };\n+            let suber = cx.sub(a_is_expected, trace);\n             suber.trait_refs(a, b)\n         }\n     }.to_ures()\n }\n \n+fn expected_found<T>(a_is_expected: bool,\n+                     a: T,\n+                     b: T) -> ty::expected_found<T> {\n+    if a_is_expected {\n+        ty::expected_found {expected: a, found: b}\n+    } else {\n+        ty::expected_found {expected: b, found: a}\n+    }\n+}\n+\n pub fn mk_coercety(cx: @mut InferCtxt,\n                    a_is_expected: bool,\n-                   span: span,\n+                   origin: TypeOrigin,\n                    a: ty::t,\n                    b: ty::t)\n                 -> CoerceResult {\n     debug!(\"mk_coercety(%s -> %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.commit {\n-            Coerce(cx.combine_fields(a_is_expected, span)).tys(a, b)\n+            let trace = TypeTrace {\n+                origin: origin,\n+                values: Types(expected_found(a_is_expected, a, b))\n+            };\n+            Coerce(cx.combine_fields(a_is_expected, trace)).tys(a, b)\n         }\n     }\n }\n@@ -451,8 +410,11 @@ pub fn can_mk_coercety(cx: @mut InferCtxt, a: ty::t, b: ty::t) -> ures {\n     debug!(\"can_mk_coercety(%s -> %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.probe {\n-            let span = codemap::dummy_sp();\n-            Coerce(cx.combine_fields(true, span)).tys(a, b)\n+            let trace = TypeTrace {\n+                origin: Misc(codemap::dummy_sp()),\n+                values: Types(expected_found(true, a, b))\n+            };\n+            Coerce(cx.combine_fields(true, trace)).tys(a, b)\n         }\n     }.to_ures()\n }\n@@ -535,15 +497,21 @@ struct Snapshot {\n }\n \n impl InferCtxt {\n-    pub fn combine_fields(@mut self, a_is_expected: bool, span: span)\n+    pub fn combine_fields(@mut self,\n+                          a_is_expected: bool,\n+                          trace: TypeTrace)\n                           -> CombineFields {\n         CombineFields {infcx: self,\n                        a_is_expected: a_is_expected,\n-                       span: span}\n+                       trace: trace}\n     }\n \n-    pub fn sub(@mut self, a_is_expected: bool, span: span) -> Sub {\n-        Sub(self.combine_fields(a_is_expected, span))\n+    pub fn sub(@mut self, a_is_expected: bool, trace: TypeTrace) -> Sub {\n+        Sub(self.combine_fields(a_is_expected, trace))\n+    }\n+\n+    pub fn lub(@mut self, a_is_expected: bool, trace: TypeTrace) -> Lub {\n+        Lub(self.combine_fields(a_is_expected, trace))\n     }\n \n     pub fn in_snapshot(&self) -> bool {\n@@ -663,31 +631,13 @@ impl InferCtxt {\n         ty::mk_float_var(self.tcx, self.next_float_var_id())\n     }\n \n-    pub fn next_region_var_nb(&mut self, span: span) -> ty::Region {\n-        ty::re_infer(ty::ReVar(self.region_vars.new_region_var(span)))\n-    }\n-\n-    pub fn next_region_var_with_lb(&mut self,\n-                                   span: span,\n-                                   lb_region: ty::Region)\n-                                   -> ty::Region {\n-        let region_var = self.next_region_var_nb(span);\n-\n-        // add lb_region as a lower bound on the newly built variable\n-        assert!(self.region_vars.make_subregion(span,\n-                                                     lb_region,\n-                                                     region_var).is_ok());\n-\n-        return region_var;\n-    }\n-\n-    pub fn next_region_var(&mut self, span: span, scope_id: ast::node_id)\n-                           -> ty::Region {\n-        self.next_region_var_with_lb(span, ty::re_scope(scope_id))\n+    pub fn next_region_var(&mut self, origin: RegionVariableOrigin) -> ty::Region {\n+        ty::re_infer(ty::ReVar(self.region_vars.new_region_var(origin)))\n     }\n \n-    pub fn resolve_regions(&mut self) {\n-        self.region_vars.resolve_regions();\n+    pub fn resolve_regions(@mut self) {\n+        let errors = self.region_vars.resolve_regions();\n+        self.report_region_errors(&errors); // see error_reporting.rs\n     }\n \n     pub fn ty_to_str(@mut self, t: ty::t) -> ~str {\n@@ -809,17 +759,13 @@ impl InferCtxt {\n     }\n \n     pub fn replace_bound_regions_with_fresh_regions(&mut self,\n-                                                    span: span,\n+                                                    trace: TypeTrace,\n                                                     fsig: &ty::FnSig)\n-                                                    -> (ty::FnSig,\n-                                                        isr_alist) {\n+                                                    -> (ty::FnSig, isr_alist) {\n         let(isr, _, fn_sig) =\n             replace_bound_regions_in_fn_sig(self.tcx, @Nil, None, fsig, |br| {\n-                // N.B.: The name of the bound region doesn't have anything to\n-                // do with the region variable that's created for it.  The\n-                // only thing we're doing with `br` here is using it in the\n-                // debug message.\n-                let rvar = self.next_region_var_nb(span);\n+                let rvar = self.next_region_var(\n+                    BoundRegionInFnType(trace.origin.span(), br));\n                 debug!(\"Bound region %s maps to %?\",\n                        bound_region_to_str(self.tcx, \"\", false, br),\n                        rvar);\n@@ -838,3 +784,125 @@ pub fn fold_regions_in_sig(\n         ty::fold_regions(tcx, t, |r, in_fn| fldr(r, in_fn))\n     }\n }\n+\n+impl TypeTrace {\n+    pub fn span(&self) -> span {\n+        self.origin.span()\n+    }\n+}\n+\n+impl Repr for TypeTrace {\n+    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+        fmt!(\"TypeTrace(%s)\", self.origin.repr(tcx))\n+    }\n+}\n+\n+impl TypeOrigin {\n+    pub fn span(&self) -> span {\n+        match *self {\n+            MethodCompatCheck(span) => span,\n+            ExprAssignable(expr) => expr.span,\n+            Misc(span) => span,\n+            RelateTraitRefs(span) => span,\n+            RelateSelfType(span) => span,\n+            MatchExpression(span) => span,\n+            IfExpression(span) => span,\n+        }\n+    }\n+}\n+\n+impl Repr for TypeOrigin {\n+    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+        match *self {\n+            MethodCompatCheck(a) => fmt!(\"MethodCompatCheck(%s)\", a.repr(tcx)),\n+            ExprAssignable(a) => fmt!(\"ExprAssignable(%s)\", a.repr(tcx)),\n+            Misc(a) => fmt!(\"Misc(%s)\", a.repr(tcx)),\n+            RelateTraitRefs(a) => fmt!(\"RelateTraitRefs(%s)\", a.repr(tcx)),\n+            RelateSelfType(a) => fmt!(\"RelateSelfType(%s)\", a.repr(tcx)),\n+            MatchExpression(a) => fmt!(\"MatchExpression(%s)\", a.repr(tcx)),\n+            IfExpression(a) => fmt!(\"IfExpression(%s)\", a.repr(tcx)),\n+        }\n+    }\n+}\n+\n+impl SubregionOrigin {\n+    pub fn span(&self) -> span {\n+        match *self {\n+            Subtype(a) => a.span(),\n+            InvokeClosure(a) => a,\n+            DerefPointer(a) => a,\n+            FreeVariable(a) => a,\n+            IndexSlice(a) => a,\n+            RelateObjectBound(a) => a,\n+            Reborrow(a) => a,\n+            ReferenceOutlivesReferent(_, a) => a,\n+            BindingTypeIsNotValidAtDecl(a) => a,\n+            CallRcvr(a) => a,\n+            CallArg(a) => a,\n+            CallReturn(a) => a,\n+            AddrOf(a) => a,\n+            AutoBorrow(a) => a,\n+        }\n+    }\n+}\n+\n+impl Repr for SubregionOrigin {\n+    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+        match *self {\n+            Subtype(a) => fmt!(\"Subtype(%s)\", a.repr(tcx)),\n+            InvokeClosure(a) => fmt!(\"InvokeClosure(%s)\", a.repr(tcx)),\n+            DerefPointer(a) => fmt!(\"DerefPointer(%s)\", a.repr(tcx)),\n+            FreeVariable(a) => fmt!(\"FreeVariable(%s)\", a.repr(tcx)),\n+            IndexSlice(a) => fmt!(\"IndexSlice(%s)\", a.repr(tcx)),\n+            RelateObjectBound(a) => fmt!(\"RelateObjectBound(%s)\", a.repr(tcx)),\n+            Reborrow(a) => fmt!(\"Reborrow(%s)\", a.repr(tcx)),\n+            ReferenceOutlivesReferent(_, a) => fmt!(\"ReferenceOutlivesReferent(%s)\", a.repr(tcx)),\n+            BindingTypeIsNotValidAtDecl(a) => fmt!(\"BindingTypeIsNotValidAtDecl(%s)\", a.repr(tcx)),\n+            CallRcvr(a) => fmt!(\"CallRcvr(%s)\", a.repr(tcx)),\n+            CallArg(a) => fmt!(\"CallArg(%s)\", a.repr(tcx)),\n+            CallReturn(a) => fmt!(\"CallReturn(%s)\", a.repr(tcx)),\n+            AddrOf(a) => fmt!(\"AddrOf(%s)\", a.repr(tcx)),\n+            AutoBorrow(a) => fmt!(\"AutoBorrow(%s)\", a.repr(tcx)),\n+        }\n+    }\n+}\n+\n+impl RegionVariableOrigin {\n+    pub fn span(&self) -> span {\n+        match *self {\n+            MiscVariable(a) => a,\n+            PatternRegion(a) => a,\n+            AddrOfRegion(a) => a,\n+            AddrOfSlice(a) => a,\n+            Autoref(a) => a,\n+            Coercion(a) => a.span(),\n+            BoundRegionInFnCall(a, _) => a,\n+            BoundRegionInFnType(a, _) => a,\n+            BoundRegionInTypeOrImpl(a) => a,\n+            BoundRegionInCoherence => codemap::dummy_sp(),\n+            BoundRegionError(a) => a,\n+        }\n+    }\n+}\n+\n+impl Repr for RegionVariableOrigin {\n+    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+        match *self {\n+            MiscVariable(a) => fmt!(\"MiscVariable(%s)\", a.repr(tcx)),\n+            PatternRegion(a) => fmt!(\"PatternRegion(%s)\", a.repr(tcx)),\n+            AddrOfRegion(a) => fmt!(\"AddrOfRegion(%s)\", a.repr(tcx)),\n+            AddrOfSlice(a) => fmt!(\"AddrOfSlice(%s)\", a.repr(tcx)),\n+            Autoref(a) => fmt!(\"Autoref(%s)\", a.repr(tcx)),\n+            Coercion(a) => fmt!(\"Coercion(%s)\", a.repr(tcx)),\n+            BoundRegionInFnCall(a, b) => fmt!(\"BoundRegionInFnCall(%s,%s)\",\n+                                              a.repr(tcx), b.repr(tcx)),\n+            BoundRegionInFnType(a, b) => fmt!(\"BoundRegionInFnType(%s,%s)\",\n+                                              a.repr(tcx), b.repr(tcx)),\n+            BoundRegionInTypeOrImpl(a) => fmt!(\"BoundRegionInTypeOrImpl(%s)\",\n+                                               a.repr(tcx)),\n+            BoundRegionInCoherence => fmt!(\"BoundRegionInCoherence\"),\n+            BoundRegionError(a) => fmt!(\"BoundRegionError(%s)\", a.repr(tcx)),\n+        }\n+    }\n+}\n+"}, {"sha": "df6d5dc1b2060060b684104203e9a8e7d1fa6041", "filename": "src/librustc/middle/typeck/infer/region_inference/doc.rs", "status": "added", "additions": 773, "deletions": 0, "changes": 773, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -0,0 +1,773 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+Region inference module.\n+\n+# Terminology\n+\n+Note that we use the terms region and lifetime interchangeably,\n+though the term `lifetime` is preferred.\n+\n+# Introduction\n+\n+Region inference uses a somewhat more involved algorithm than type\n+inference.  It is not the most efficient thing ever written though it\n+seems to work well enough in practice (famous last words).  The reason\n+that we use a different algorithm is because, unlike with types, it is\n+impractical to hand-annotate with regions (in some cases, there aren't\n+even the requisite syntactic forms).  So we have to get it right, and\n+it's worth spending more time on a more involved analysis.  Moreover,\n+regions are a simpler case than types: they don't have aggregate\n+structure, for example.\n+\n+Unlike normal type inference, which is similar in spirit to H-M and thus\n+works progressively, the region type inference works by accumulating\n+constraints over the course of a function.  Finally, at the end of\n+processing a function, we process and solve the constraints all at\n+once.\n+\n+The constraints are always of one of three possible forms:\n+\n+- ConstrainVarSubVar(R_i, R_j) states that region variable R_i\n+  must be a subregion of R_j\n+- ConstrainRegSubVar(R, R_i) states that the concrete region R\n+  (which must not be a variable) must be a subregion of the varibale R_i\n+- ConstrainVarSubReg(R_i, R) is the inverse\n+\n+# Building up the constraints\n+\n+Variables and constraints are created using the following methods:\n+\n+- `new_region_var()` creates a new, unconstrained region variable;\n+- `make_subregion(R_i, R_j)` states that R_i is a subregion of R_j\n+- `lub_regions(R_i, R_j) -> R_k` returns a region R_k which is\n+  the smallest region that is greater than both R_i and R_j\n+- `glb_regions(R_i, R_j) -> R_k` returns a region R_k which is\n+  the greatest region that is smaller than both R_i and R_j\n+\n+The actual region resolution algorithm is not entirely\n+obvious, though it is also not overly complex.\n+\n+## Snapshotting\n+\n+It is also permitted to try (and rollback) changes to the graph.  This\n+is done by invoking `start_snapshot()`, which returns a value.  Then\n+later you can call `rollback_to()` which undoes the work.\n+Alternatively, you can call `commit()` which ends all snapshots.\n+Snapshots can be recursive---so you can start a snapshot when another\n+is in progress, but only the root snapshot can \"commit\".\n+\n+# Resolving constraints\n+\n+The constraint resolution algorithm is not super complex but also not\n+entirely obvious.  Here I describe the problem somewhat abstractly,\n+then describe how the current code works.  There may be other, smarter\n+ways of doing this with which I am unfamiliar and can't be bothered to\n+research at the moment. - NDM\n+\n+## The problem\n+\n+Basically our input is a directed graph where nodes can be divided\n+into two categories: region variables and concrete regions.  Each edge\n+`R -> S` in the graph represents a constraint that the region `R` is a\n+subregion of the region `S`.\n+\n+Region variable nodes can have arbitrary degree.  There is one region\n+variable node per region variable.\n+\n+Each concrete region node is associated with some, well, concrete\n+region: e.g., a free lifetime, or the region for a particular scope.\n+Note that there may be more than one concrete region node for a\n+particular region value.  Moreover, because of how the graph is built,\n+we know that all concrete region nodes have either in-degree 1 or\n+out-degree 1.\n+\n+Before resolution begins, we build up the constraints in a hashmap\n+that maps `Constraint` keys to spans.  During resolution, we construct\n+the actual `Graph` structure that we describe here.\n+\n+## Our current algorithm\n+\n+We divide region variables into two groups: Expanding and Contracting.\n+Expanding region variables are those that have a concrete region\n+predecessor (direct or indirect).  Contracting region variables are\n+all others.\n+\n+We first resolve the values of Expanding region variables and then\n+process Contracting ones.  We currently use an iterative, fixed-point\n+procedure (but read on, I believe this could be replaced with a linear\n+walk).  Basically we iterate over the edges in the graph, ensuring\n+that, if the source of the edge has a value, then this value is a\n+subregion of the target value.  If the target does not yet have a\n+value, it takes the value from the source.  If the target already had\n+a value, then the resulting value is Least Upper Bound of the old and\n+new values. When we are done, each Expanding node will have the\n+smallest region that it could possibly have and still satisfy the\n+constraints.\n+\n+We next process the Contracting nodes.  Here we again iterate over the\n+edges, only this time we move values from target to source (if the\n+source is a Contracting node).  For each contracting node, we compute\n+its value as the GLB of all its successors.  Basically contracting\n+nodes ensure that there is overlap between their successors; we will\n+ultimately infer the largest overlap possible.\n+\n+# The Region Hierarchy\n+\n+## Without closures\n+\n+Let's first consider the region hierarchy without thinking about\n+closures, because they add a lot of complications. The region\n+hierarchy *basically* mirrors the lexical structure of the code.\n+There is a region for every piece of 'evaluation' that occurs, meaning\n+every expression, block, and pattern (patterns are considered to\n+\"execute\" by testing the value they are applied to and creating any\n+relevant bindings).  So, for example:\n+\n+    fn foo(x: int, y: int) { // -+\n+    //  +------------+       //  |\n+    //  |      +-----+       //  |\n+    //  |  +-+ +-+ +-+       //  |\n+    //  |  | | | | | |       //  |\n+    //  v  v v v v v v       //  |\n+        let z = x + y;       //  |\n+        ...                  //  |\n+    }                        // -+\n+\n+    fn bar() { ... }\n+\n+In this example, there is a region for the fn body block as a whole,\n+and then a subregion for the declaration of the local variable.\n+Within that, there are sublifetimes for the assignment pattern and\n+also the expression `x + y`. The expression itself has sublifetimes\n+for evaluating `x` and and `y`.\n+\n+## Function calls\n+\n+Function calls are a bit tricky. I will describe how we handle them\n+*now* and then a bit about how we can improve them (Issue #6268).\n+\n+Consider a function call like `func(expr1, expr2)`, where `func`,\n+`arg1`, and `arg2` are all arbitrary expressions. Currently,\n+we construct a region hierarchy like:\n+\n+    +----------------+\n+    |                |\n+    +--+ +---+  +---+|\n+    v  v v   v  v   vv\n+    func(expr1, expr2)\n+\n+Here you can see that the call as a whole has a region and the\n+function plus arguments are subregions of that. As a side-effect of\n+this, we get a lot of spurious errors around nested calls, in\n+particular when combined with `&mut` functions. For example, a call\n+like this one\n+\n+    self.foo(self.bar())\n+\n+where both `foo` and `bar` are `&mut self` functions will always yield\n+an error.\n+\n+Here is a more involved example (which is safe) so we can see what's\n+going on:\n+\n+    struct Foo { f: uint, g: uint }\n+    ...\n+    fn add(p: &mut uint, v: uint) {\n+        *p += v;\n+    }\n+    ...\n+    fn inc(p: &mut uint) -> uint {\n+        *p += 1; *p\n+    }\n+    fn weird() {\n+        let mut x: ~Foo = ~Foo { ... };\n+        'a: add(&mut (*x).f,\n+                'b: inc(&mut (*x).f)) // (*)\n+    }\n+\n+The important part is the line marked `(*)` which contains a call to\n+`add()`. The first argument is a mutable borrow of the field `f`.  The\n+second argument also borrows the field `f`. Now, in the current borrow\n+checker, the first borrow is given the lifetime of the call to\n+`add()`, `'a`.  The second borrow is given the lifetime of `'b` of the\n+call to `inc()`. Because `'b` is considered to be a sublifetime of\n+`'a`, an error is reported since there are two co-existing mutable\n+borrows of the same data.\n+\n+However, if we were to examine the lifetimes a bit more carefully, we\n+can see that this error is unnecessary. Let's examine the lifetimes\n+involved with `'a` in detail. We'll break apart all the steps involved\n+in a call expression:\n+\n+    'a: {\n+        'a_arg1: let a_temp1: ... = add;\n+        'a_arg2: let a_temp2: &'a mut uint = &'a mut (*x).f;\n+        'a_arg3: let a_temp3: uint = {\n+            let b_temp1: ... = inc;\n+            let b_temp2: &'b = &'b mut (*x).f;\n+            'b_call: b_temp1(b_temp2)\n+        };\n+        'a_call: a_temp1(a_temp2, a_temp3) // (**)\n+    }\n+\n+Here we see that the lifetime `'a` includes a number of substatements.\n+In particular, there is this lifetime I've called `'a_call` that\n+corresponds to the *actual execution of the function `add()`*, after\n+all arguments have been evaluated. There is a corresponding lifetime\n+`'b_call` for the execution of `inc()`. If we wanted to be precise\n+about it, the lifetime of the two borrows should be `'a_call` and\n+`'b_call` respectively, since the borrowed pointers that were created\n+will not be dereferenced except during the execution itself.\n+\n+However, this model by itself is not sound. The reason is that\n+while the two borrowed pointers that are created will never be used\n+simultaneously, it is still true that the first borrowed pointer is\n+*created* before the second argument is evaluated, and so even though\n+it will not be *dereferenced* during the evaluation of the second\n+argument, it can still be *invalidated* by that evaluation. Consider\n+this similar but unsound example:\n+\n+    struct Foo { f: uint, g: uint }\n+    ...\n+    fn add(p: &mut uint, v: uint) {\n+        *p += v;\n+    }\n+    ...\n+    fn consume(x: ~Foo) -> uint {\n+        x.f + x.g\n+    }\n+    fn weird() {\n+        let mut x: ~Foo = ~Foo { ... };\n+        'a: add(&mut (*x).f, consume(x)) // (*)\n+    }\n+\n+In this case, the second argument to `add` actually consumes `x`, thus\n+invalidating the first argument.\n+\n+So, for now, we exclude the `call` lifetimes from our model.\n+Eventually I would like to include them, but we will have to make the\n+borrow checker handle this situation correctly. In particular, if\n+there is a borrowed pointer created whose lifetime does not enclose\n+the borrow expression, we must issue sufficient restrictions to ensure\n+that the pointee remains valid.\n+\n+## Adding closures\n+\n+The other significant complication to the region hierarchy is\n+closures. I will describe here how closures should work, though some\n+of the work to implement this model is ongoing at the time of this\n+writing.\n+\n+The body of closures are type-checked along with the function that\n+creates them. However, unlike other expressions that appear within the\n+function body, it is not entirely obvious when a closure body executes\n+with respect to the other expressions. This is because the closure\n+body will execute whenever the closure is called; however, we can\n+never know precisely when the closure will be called, especially\n+without some sort of alias analysis.\n+\n+However, we can place some sort of limits on when the closure\n+executes.  In particular, the type of every closure `fn:'r K` includes\n+a region bound `'r`. This bound indicates the maximum lifetime of that\n+closure; once we exit that region, the closure cannot be called\n+anymore. Therefore, we say that the lifetime of the closure body is a\n+sublifetime of the closure bound, but the closure body itself is unordered\n+with respect to other parts of the code.\n+\n+For example, consider the following fragment of code:\n+\n+    'a: {\n+         let closure: fn:'a() = || 'b: {\n+             'c: ...\n+         };\n+         'd: ...\n+    }\n+\n+Here we have four lifetimes, `'a`, `'b`, `'c`, and `'d`. The closure\n+`closure` is bounded by the lifetime `'a`. The lifetime `'b` is the\n+lifetime of the closure body, and `'c` is some statement within the\n+closure body. Finally, `'d` is a statement within the outer block that\n+created the closure.\n+\n+We can say that the closure body `'b` is a sublifetime of `'a` due to\n+the closure bound. By the usual lexical scoping conventions, the\n+statement `'c` is clearly a sublifetime of `'b`, and `'d` is a\n+sublifetime of `'d`. However, there is no ordering between `'c` and\n+`'d` per se (this kind of ordering between statements is actually only\n+an issue for dataflow; passes like the borrow checker must assume that\n+closures could execute at any time from the moment they are created\n+until they go out of scope).\n+\n+### Complications due to closure bound inference\n+\n+There is only one problem with the above model: in general, we do not\n+actually *know* the closure bounds during region inference! In fact,\n+closure bounds are almost always region variables! This is very tricky\n+because the inference system implicitly assumes that we can do things\n+like compute the LUB of two scoped lifetimes without needing to know\n+the values of any variables.\n+\n+Here is an example to illustrate the problem:\n+\n+    fn identify<T>(x: T) -> T { x }\n+\n+    fn foo() { // 'foo is the function body\n+      'a: {\n+           let closure = identity(|| 'b: {\n+               'c: ...\n+           });\n+           'd: closure();\n+      }\n+      'e: ...;\n+    }\n+\n+In this example, the closure bound is not explicit. At compile time,\n+we will create a region variable (let's call it `V0`) to represent the\n+closure bound.\n+\n+The primary difficulty arises during the constraint propagation phase.\n+Imagine there is some variable with incoming edges from `'c` and `'d`.\n+This means that the value of the variable must be `LUB('c,\n+'d)`. However, without knowing what the closure bound `V0` is, we\n+can't compute the LUB of `'c` and `'d`! Any we don't know the closure\n+bound until inference is done.\n+\n+The solution is to rely on the fixed point nature of inference.\n+Basically, when we must compute `LUB('c, 'd)`, we just use the current\n+value for `V0` as the closure's bound. If `V0`'s binding should\n+change, then we will do another round of inference, and the result of\n+`LUB('c, 'd)` will change.\n+\n+One minor implication of this is that the graph does not in fact track\n+the full set of dependencies between edges. We cannot easily know\n+whether the result of a LUB computation will change, since there may\n+be indirect dependencies on other variables that are not reflected on\n+the graph. Therefore, we must *always* iterate over all edges when\n+doing the fixed point calculation, not just those adjacent to nodes\n+whose values have changed.\n+\n+Were it not for this requirement, we could in fact avoid fixed-point\n+iteration altogether. In that universe, we could instead first\n+identify and remove strongly connected components (SCC) in the graph.\n+Note that such components must consist solely of region variables; all\n+of these variables can effectively be unified into a single variable.\n+Once SCCs are removed, we are left with a DAG.  At this point, we\n+could walk the DAG in toplogical order once to compute the expanding\n+nodes, and again in reverse topological order to compute the\n+contracting nodes. However, as I said, this does not work given the\n+current treatment of closure bounds, but perhaps in the future we can\n+address this problem somehow and make region inference somewhat more\n+efficient. Note that this is solely a matter of performance, not\n+expressiveness.\n+\n+# Skolemization and functions\n+\n+One of the trickiest and most subtle aspects of regions is dealing\n+with the fact that region variables are bound in function types.  I\n+strongly suggest that if you want to understand the situation, you\n+read this paper (which is, admittedly, very long, but you don't have\n+to read the whole thing):\n+\n+http://research.microsoft.com/en-us/um/people/simonpj/papers/higher-rank/\n+\n+Although my explanation will never compete with SPJ's (for one thing,\n+his is approximately 100 pages), I will attempt to explain the basic\n+problem and also how we solve it.  Note that the paper only discusses\n+subtyping, not the computation of LUB/GLB.\n+\n+The problem we are addressing is that there is a kind of subtyping\n+between functions with bound region parameters.  Consider, for\n+example, whether the following relation holds:\n+\n+    fn(&'a int) <: &fn(&'b int)? (Yes, a => b)\n+\n+The answer is that of course it does.  These two types are basically\n+the same, except that in one we used the name `a` and one we used\n+the name `b`.\n+\n+In the examples that follow, it becomes very important to know whether\n+a lifetime is bound in a function type (that is, is a lifetime\n+parameter) or appears free (is defined in some outer scope).\n+Therefore, from now on I will write the bindings explicitly, using a\n+notation like `fn<a>(&'a int)` to indicate that `a` is a lifetime\n+parameter.\n+\n+Now let's consider two more function types.  Here, we assume that the\n+`self` lifetime is defined somewhere outside and hence is not a\n+lifetime parameter bound by the function type (it \"appears free\"):\n+\n+    fn<a>(&'a int) <: &fn(&'self int)? (Yes, a => self)\n+\n+This subtyping relation does in fact hold.  To see why, you have to\n+consider what subtyping means.  One way to look at `T1 <: T2` is to\n+say that it means that it is always ok to treat an instance of `T1` as\n+if it had the type `T2`.  So, with our functions, it is always ok to\n+treat a function that can take pointers with any lifetime as if it\n+were a function that can only take a pointer with the specific\n+lifetime `&self`.  After all, `&self` is a lifetime, after all, and\n+the function can take values of any lifetime.\n+\n+You can also look at subtyping as the *is a* relationship.  This amounts\n+to the same thing: a function that accepts pointers with any lifetime\n+*is a* function that accepts pointers with some specific lifetime.\n+\n+So, what if we reverse the order of the two function types, like this:\n+\n+    fn(&'self int) <: &fn<a>(&'a int)? (No)\n+\n+Does the subtyping relationship still hold?  The answer of course is\n+no.  In this case, the function accepts *only the lifetime `&self`*,\n+so it is not reasonable to treat it as if it were a function that\n+accepted any lifetime.\n+\n+What about these two examples:\n+\n+    fn<a,b>(&'a int, &'b int) <: &fn<a>(&'a int, &'a int)? (Yes)\n+    fn<a>(&'a int, &'a int) <: &fn<a,b>(&'a int, &'b int)? (No)\n+\n+Here, it is true that functions which take two pointers with any two\n+lifetimes can be treated as if they only accepted two pointers with\n+the same lifetime, but not the reverse.\n+\n+## The algorithm\n+\n+Here is the algorithm we use to perform the subtyping check:\n+\n+1. Replace all bound regions in the subtype with new variables\n+2. Replace all bound regions in the supertype with skolemized\n+   equivalents.  A \"skolemized\" region is just a new fresh region\n+   name.\n+3. Check that the parameter and return types match as normal\n+4. Ensure that no skolemized regions 'leak' into region variables\n+   visible from \"the outside\"\n+\n+Let's walk through some examples and see how this algorithm plays out.\n+\n+#### First example\n+\n+We'll start with the first example, which was:\n+\n+    1. fn<a>(&'a T) <: &fn<b>(&'b T)?        Yes: a -> b\n+\n+After steps 1 and 2 of the algorithm we will have replaced the types\n+like so:\n+\n+    1. fn(&'A T) <: &fn(&'x T)?\n+\n+Here the upper case `&A` indicates a *region variable*, that is, a\n+region whose value is being inferred by the system.  I also replaced\n+`&b` with `&x`---I'll use letters late in the alphabet (`x`, `y`, `z`)\n+to indicate skolemized region names.  We can assume they don't appear\n+elsewhere.  Note that neither the sub- nor the supertype bind any\n+region names anymore (as indicated by the absence of `<` and `>`).\n+\n+The next step is to check that the parameter types match.  Because\n+parameters are contravariant, this means that we check whether:\n+\n+    &'x T <: &'A T\n+\n+Region pointers are contravariant so this implies that\n+\n+    &A <= &x\n+\n+must hold, where `<=` is the subregion relationship.  Processing\n+*this* constrain simply adds a constraint into our graph that `&A <=\n+&x` and is considered successful (it can, for example, be satisfied by\n+choosing the value `&x` for `&A`).\n+\n+So far we have encountered no error, so the subtype check succeeds.\n+\n+#### The third example\n+\n+Now let's look first at the third example, which was:\n+\n+    3. fn(&'self T)    <: &fn<b>(&'b T)?        No!\n+\n+After steps 1 and 2 of the algorithm we will have replaced the types\n+like so:\n+\n+    3. fn(&'self T) <: &fn(&'x T)?\n+\n+This looks pretty much the same as before, except that on the LHS\n+`&self` was not bound, and hence was left as-is and not replaced with\n+a variable.  The next step is again to check that the parameter types\n+match.  This will ultimately require (as before) that `&self` <= `&x`\n+must hold: but this does not hold.  `self` and `x` are both distinct\n+free regions.  So the subtype check fails.\n+\n+#### Checking for skolemization leaks\n+\n+You may be wondering about that mysterious last step in the algorithm.\n+So far it has not been relevant.  The purpose of that last step is to\n+catch something like *this*:\n+\n+    fn<a>() -> fn(&'a T) <: &fn() -> fn<b>(&'b T)?   No.\n+\n+Here the function types are the same but for where the binding occurs.\n+The subtype returns a function that expects a value in precisely one\n+region.  The supertype returns a function that expects a value in any\n+region.  If we allow an instance of the subtype to be used where the\n+supertype is expected, then, someone could call the fn and think that\n+the return value has type `fn<b>(&'b T)` when it really has type\n+`fn(&'a T)` (this is case #3, above).  Bad.\n+\n+So let's step through what happens when we perform this subtype check.\n+We first replace the bound regions in the subtype (the supertype has\n+no bound regions).  This gives us:\n+\n+    fn() -> fn(&'A T) <: &fn() -> fn<b>(&'b T)?\n+\n+Now we compare the return types, which are covariant, and hence we have:\n+\n+    fn(&'A T) <: &fn<b>(&'b T)?\n+\n+Here we skolemize the bound region in the supertype to yield:\n+\n+    fn(&'A T) <: &fn(&'x T)?\n+\n+And then proceed to compare the argument types:\n+\n+    &'x T <: &'A T\n+    &A <= &x\n+\n+Finally, this is where it gets interesting!  This is where an error\n+*should* be reported.  But in fact this will not happen.  The reason why\n+is that `A` is a variable: we will infer that its value is the fresh\n+region `x` and think that everything is happy.  In fact, this behavior\n+is *necessary*, it was key to the first example we walked through.\n+\n+The difference between this example and the first one is that the variable\n+`A` already existed at the point where the skolemization occurred.  In\n+the first example, you had two functions:\n+\n+    fn<a>(&'a T) <: &fn<b>(&'b T)\n+\n+and hence `&A` and `&x` were created \"together\".  In general, the\n+intention of the skolemized names is that they are supposed to be\n+fresh names that could never be equal to anything from the outside.\n+But when inference comes into play, we might not be respecting this\n+rule.\n+\n+So the way we solve this is to add a fourth step that examines the\n+constraints that refer to skolemized names.  Basically, consider a\n+non-directed verison of the constraint graph.  Let `Tainted(x)` be the\n+set of all things reachable from a skolemized variable `x`.\n+`Tainted(x)` should not contain any regions that existed before the\n+step at which the skolemization was performed.  So this case here\n+would fail because `&x` was created alone, but is relatable to `&A`.\n+\n+## Computing the LUB and GLB\n+\n+The paper I pointed you at is written for Haskell.  It does not\n+therefore considering subtyping and in particular does not consider\n+LUB or GLB computation.  We have to consider this.  Here is the\n+algorithm I implemented.\n+\n+First though, let's discuss what we are trying to compute in more\n+detail.  The LUB is basically the \"common supertype\" and the GLB is\n+\"common subtype\"; one catch is that the LUB should be the\n+*most-specific* common supertype and the GLB should be *most general*\n+common subtype (as opposed to any common supertype or any common\n+subtype).\n+\n+Anyway, to help clarify, here is a table containing some\n+function pairs and their LUB/GLB:\n+\n+```\n+Type 1              Type 2              LUB               GLB\n+fn<a>(&a)           fn(&X)              fn(&X)            fn<a>(&a)\n+fn(&A)              fn(&X)              --                fn<a>(&a)\n+fn<a,b>(&a, &b)     fn<x>(&x, &x)       fn<a>(&a, &a)     fn<a,b>(&a, &b)\n+fn<a,b>(&a, &b, &a) fn<x,y>(&x, &y, &y) fn<a>(&a, &a, &a) fn<a,b,c>(&a,&b,&c)\n+```\n+\n+### Conventions\n+\n+I use lower-case letters (e.g., `&a`) for bound regions and upper-case\n+letters for free regions (`&A`).  Region variables written with a\n+dollar-sign (e.g., `$a`).  I will try to remember to enumerate the\n+bound-regions on the fn type as well (e.g., `fn<a>(&a)`).\n+\n+### High-level summary\n+\n+Both the LUB and the GLB algorithms work in a similar fashion.  They\n+begin by replacing all bound regions (on both sides) with fresh region\n+inference variables.  Therefore, both functions are converted to types\n+that contain only free regions.  We can then compute the LUB/GLB in a\n+straightforward way, as described in `combine.rs`.  This results in an\n+interim type T.  The algorithms then examine the regions that appear\n+in T and try to, in some cases, replace them with bound regions to\n+yield the final result.\n+\n+To decide whether to replace a region `R` that appears in `T` with a\n+bound region, the algorithms make use of two bits of information.\n+First is a set `V` that contains all region variables created as part\n+of the LUB/GLB computation. `V` will contain the region variables\n+created to replace the bound regions in the input types, but it also\n+contains 'intermediate' variables created to represent the LUB/GLB of\n+individual regions.  Basically, when asked to compute the LUB/GLB of a\n+region variable with another region, the inferencer cannot oblige\n+immediately since the valuese of that variables are not known.\n+Therefore, it creates a new variable that is related to the two\n+regions.  For example, the LUB of two variables `$x` and `$y` is a\n+fresh variable `$z` that is constrained such that `$x <= $z` and `$y\n+<= $z`.  So `V` will contain these intermediate variables as well.\n+\n+The other important factor in deciding how to replace a region in T is\n+the function `Tainted($r)` which, for a region variable, identifies\n+all regions that the region variable is related to in some way\n+(`Tainted()` made an appearance in the subtype computation as well).\n+\n+### LUB\n+\n+The LUB algorithm proceeds in three steps:\n+\n+1. Replace all bound regions (on both sides) with fresh region\n+   inference variables.\n+2. Compute the LUB \"as normal\", meaning compute the GLB of each\n+   pair of argument types and the LUB of the return types and\n+   so forth.  Combine those to a new function type `F`.\n+3. Replace each region `R` that appears in `F` as follows:\n+   - Let `V` be the set of variables created during the LUB\n+     computational steps 1 and 2, as described in the previous section.\n+   - If `R` is not in `V`, replace `R` with itself.\n+   - If `Tainted(R)` contains a region that is not in `V`,\n+     replace `R` with itself.\n+   - Otherwise, select the earliest variable in `Tainted(R)` that originates\n+     from the left-hand side and replace `R` with the bound region that\n+     this variable was a replacement for.\n+\n+So, let's work through the simplest example: `fn(&A)` and `fn<a>(&a)`.\n+In this case, `&a` will be replaced with `$a` and the interim LUB type\n+`fn($b)` will be computed, where `$b=GLB(&A,$a)`.  Therefore, `V =\n+{$a, $b}` and `Tainted($b) = { $b, $a, &A }`.  When we go to replace\n+`$b`, we find that since `&A \\in Tainted($b)` is not a member of `V`,\n+we leave `$b` as is.  When region inference happens, `$b` will be\n+resolved to `&A`, as we wanted.\n+\n+Let's look at a more complex one: `fn(&a, &b)` and `fn(&x, &x)`.  In\n+this case, we'll end up with a (pre-replacement) LUB type of `fn(&g,\n+&h)` and a graph that looks like:\n+\n+```\n+     $a        $b     *--$x\n+       \\        \\    /  /\n+        \\        $h-*  /\n+         $g-----------*\n+```\n+\n+Here `$g` and `$h` are fresh variables that are created to represent\n+the LUB/GLB of things requiring inference.  This means that `V` and\n+`Tainted` will look like:\n+\n+```\n+V = {$a, $b, $g, $h, $x}\n+Tainted($g) = Tainted($h) = { $a, $b, $h, $g, $x }\n+```\n+\n+Therefore we replace both `$g` and `$h` with `$a`, and end up\n+with the type `fn(&a, &a)`.\n+\n+### GLB\n+\n+The procedure for computing the GLB is similar.  The difference lies\n+in computing the replacements for the various variables. For each\n+region `R` that appears in the type `F`, we again compute `Tainted(R)`\n+and examine the results:\n+\n+1. If `R` is not in `V`, it is not replaced.\n+2. Else, if `Tainted(R)` contains only variables in `V`, and it\n+   contains exactly one variable from the LHS and one variable from\n+   the RHS, then `R` can be mapped to the bound version of the\n+   variable from the LHS.\n+3. Else, if `Tainted(R)` contains no variable from the LHS and no\n+   variable from the RHS, then `R` can be mapped to itself.\n+4. Else, `R` is mapped to a fresh bound variable.\n+\n+These rules are pretty complex.  Let's look at some examples to see\n+how they play out.\n+\n+Out first example was `fn(&a)` and `fn(&X)`.  In this case, `&a` will\n+be replaced with `$a` and we will ultimately compute a\n+(pre-replacement) GLB type of `fn($g)` where `$g=LUB($a,&X)`.\n+Therefore, `V={$a,$g}` and `Tainted($g)={$g,$a,&X}.  To find the\n+replacement for `$g` we consult the rules above:\n+- Rule (1) does not apply because `$g \\in V`\n+- Rule (2) does not apply because `&X \\in Tainted($g)`\n+- Rule (3) does not apply because `$a \\in Tainted($g)`\n+- Hence, by rule (4), we replace `$g` with a fresh bound variable `&z`.\n+So our final result is `fn(&z)`, which is correct.\n+\n+The next example is `fn(&A)` and `fn(&Z)`. In this case, we will again\n+have a (pre-replacement) GLB of `fn(&g)`, where `$g = LUB(&A,&Z)`.\n+Therefore, `V={$g}` and `Tainted($g) = {$g, &A, &Z}`.  In this case,\n+by rule (3), `$g` is mapped to itself, and hence the result is\n+`fn($g)`.  This result is correct (in this case, at least), but it is\n+indicative of a case that *can* lead us into concluding that there is\n+no GLB when in fact a GLB does exist.  See the section \"Questionable\n+Results\" below for more details.\n+\n+The next example is `fn(&a, &b)` and `fn(&c, &c)`. In this case, as\n+before, we'll end up with `F=fn($g, $h)` where `Tainted($g) =\n+Tainted($h) = {$g, $h, $a, $b, $c}`.  Only rule (4) applies and hence\n+we'll select fresh bound variables `y` and `z` and wind up with\n+`fn(&y, &z)`.\n+\n+For the last example, let's consider what may seem trivial, but is\n+not: `fn(&a, &a)` and `fn(&b, &b)`.  In this case, we'll get `F=fn($g,\n+$h)` where `Tainted($g) = {$g, $a, $x}` and `Tainted($h) = {$h, $a,\n+$x}`.  Both of these sets contain exactly one bound variable from each\n+side, so we'll map them both to `&a`, resulting in `fn(&a, &a)`, which\n+is the desired result.\n+\n+### Shortcomings and correctness\n+\n+You may be wondering whether this algorithm is correct.  The answer is\n+\"sort of\".  There are definitely cases where they fail to compute a\n+result even though a correct result exists.  I believe, though, that\n+if they succeed, then the result is valid, and I will attempt to\n+convince you.  The basic argument is that the \"pre-replacement\" step\n+computes a set of constraints.  The replacements, then, attempt to\n+satisfy those constraints, using bound identifiers where needed.\n+\n+For now I will briefly go over the cases for LUB/GLB and identify\n+their intent:\n+\n+- LUB:\n+  - The region variables that are substituted in place of bound regions\n+    are intended to collect constraints on those bound regions.\n+  - If Tainted(R) contains only values in V, then this region is unconstrained\n+    and can therefore be generalized, otherwise it cannot.\n+- GLB:\n+  - The region variables that are substituted in place of bound regions\n+    are intended to collect constraints on those bound regions.\n+  - If Tainted(R) contains exactly one variable from each side, and\n+    only variables in V, that indicates that those two bound regions\n+    must be equated.\n+  - Otherwise, if Tainted(R) references any variables from left or right\n+    side, then it is trying to combine a bound region with a free one or\n+    multiple bound regions, so we need to select fresh bound regions.\n+\n+Sorry this is more of a shorthand to myself.  I will try to write up something\n+more convincing in the future.\n+\n+#### Where are the algorithms wrong?\n+\n+- The pre-replacement computation can fail even though using a\n+  bound-region would have succeeded.\n+- We will compute GLB(fn(fn($a)), fn(fn($b))) as fn($c) where $c is the\n+  GLB of $a and $b.  But if inference finds that $a and $b must be mapped\n+  to regions without a GLB, then this is effectively a failure to compute\n+  the GLB.  However, the result `fn<$c>(fn($c))` is a valid GLB.\n+\n+*/"}, {"sha": "96cb5d3c747c36f54530e26b69a3ed5be5991329", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "renamed", "additions": 253, "deletions": 731, "changes": 984, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -8,555 +8,36 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n-\n-Region inference module.\n-\n-# Introduction\n-\n-Region inference uses a somewhat more involved algorithm than type\n-inference.  It is not the most efficient thing ever written though it\n-seems to work well enough in practice (famous last words).  The reason\n-that we use a different algorithm is because, unlike with types, it is\n-impractical to hand-annotate with regions (in some cases, there aren't\n-even the requisite syntactic forms).  So we have to get it right, and\n-it's worth spending more time on a more involved analysis.  Moreover,\n-regions are a simpler case than types: they don't have aggregate\n-structure, for example.\n-\n-Unlike normal type inference, which is similar in spirit to H-M and thus\n-works progressively, the region type inference works by accumulating\n-constraints over the course of a function.  Finally, at the end of\n-processing a function, we process and solve the constraints all at\n-once.\n-\n-The constraints are always of one of three possible forms:\n-\n-- ConstrainVarSubVar(R_i, R_j) states that region variable R_i\n-  must be a subregion of R_j\n-- ConstrainRegSubVar(R, R_i) states that the concrete region R\n-  (which must not be a variable) must be a subregion of the varibale R_i\n-- ConstrainVarSubReg(R_i, R) is the inverse\n-\n-# Building up the constraints\n-\n-Variables and constraints are created using the following methods:\n-\n-- `new_region_var()` creates a new, unconstrained region variable;\n-- `make_subregion(R_i, R_j)` states that R_i is a subregion of R_j\n-- `lub_regions(R_i, R_j) -> R_k` returns a region R_k which is\n-  the smallest region that is greater than both R_i and R_j\n-- `glb_regions(R_i, R_j) -> R_k` returns a region R_k which is\n-  the greatest region that is smaller than both R_i and R_j\n-\n-The actual region resolution algorithm is not entirely\n-obvious, though it is also not overly complex.  I'll explain\n-the algorithm as it currently works, then explain a somewhat\n-more complex variant that would probably scale better for\n-large graphs (and possibly all graphs).\n-\n-## Snapshotting\n-\n-It is also permitted to try (and rollback) changes to the graph.  This\n-is done by invoking `start_snapshot()`, which returns a value.  Then\n-later you can call `rollback_to()` which undoes the work.\n-Alternatively, you can call `commit()` which ends all snapshots.\n-Snapshots can be recursive---so you can start a snapshot when another\n-is in progress, but only the root snapshot can \"commit\".\n-\n-# Resolving constraints\n-\n-The constraint resolution algorithm is not super complex but also not\n-entirely obvious.  Here I describe the problem somewhat abstractly,\n-then describe how the current code works, and finally describe a\n-better solution that is as of yet unimplemented.  There may be other,\n-smarter ways of doing this with which I am unfamiliar and can't be\n-bothered to research at the moment. - NDM\n-\n-## The problem\n-\n-Basically our input is a directed graph where nodes can be divided\n-into two categories: region variables and concrete regions.  Each edge\n-`R -> S` in the graph represents a constraint that the region `R` is a\n-subregion of the region `S`.\n-\n-Region variable nodes can have arbitrary degree.  There is one region\n-variable node per region variable.\n-\n-Each concrete region node is associated with some, well, concrete\n-region: e.g., a free lifetime, or the region for a particular scope.\n-Note that there may be more than one concrete region node for a\n-particular region value.  Moreover, because of how the graph is built,\n-we know that all concrete region nodes have either in-degree 1 or\n-out-degree 1.\n-\n-Before resolution begins, we build up the constraints in a hashmap\n-that maps `Constraint` keys to spans.  During resolution, we construct\n-the actual `Graph` structure that we describe here.\n-\n-## Our current algorithm\n-\n-We divide region variables into two groups: Expanding and Contracting.\n-Expanding region variables are those that have a concrete region\n-predecessor (direct or indirect).  Contracting region variables are\n-all others.\n-\n-We first resolve the values of Expanding region variables and then\n-process Contracting ones.  We currently use an iterative, fixed-point\n-procedure (but read on, I believe this could be replaced with a linear\n-walk).  Basically we iterate over the edges in the graph, ensuring\n-that, if the source of the edge has a value, then this value is a\n-subregion of the target value.  If the target does not yet have a\n-value, it takes the value from the source.  If the target already had\n-a value, then the resulting value is Least Upper Bound of the old and\n-new values. When we are done, each Expanding node will have the\n-smallest region that it could possibly have and still satisfy the\n-constraints.\n-\n-We next process the Contracting nodes.  Here we again iterate over the\n-edges, only this time we move values from target to source (if the\n-source is a Contracting node).  For each contracting node, we compute\n-its value as the GLB of all its successors.  Basically contracting\n-nodes ensure that there is overlap between their successors; we will\n-ultimately infer the largest overlap possible.\n-\n-### A better algorithm\n-\n-Fixed-point iteration is not necessary.  What we ought to do is first\n-identify and remove strongly connected components (SCC) in the graph.\n-Note that such components must consist solely of region variables; all\n-of these variables can effectively be unified into a single variable.\n-\n-Once SCCs are removed, we are left with a DAG.  At this point, we can\n-walk the DAG in toplogical order once to compute the expanding nodes,\n-and again in reverse topological order to compute the contracting\n-nodes. The main reason I did not write it this way is that I did not\n-feel like implementing the SCC and toplogical sort algorithms at the\n-moment.\n-\n-# Skolemization and functions\n-\n-One of the trickiest and most subtle aspects of regions is dealing\n-with the fact that region variables are bound in function types.  I\n-strongly suggest that if you want to understand the situation, you\n-read this paper (which is, admittedly, very long, but you don't have\n-to read the whole thing):\n-\n-http://research.microsoft.com/en-us/um/people/simonpj/papers/higher-rank/\n-\n-Although my explanation will never compete with SPJ's (for one thing,\n-his is approximately 100 pages), I will attempt to explain the basic\n-problem and also how we solve it.  Note that the paper only discusses\n-subtyping, not the computation of LUB/GLB.\n-\n-The problem we are addressing is that there is a kind of subtyping\n-between functions with bound region parameters.  Consider, for\n-example, whether the following relation holds:\n-\n-    fn(&'a int) <: &fn(&'b int)? (Yes, a => b)\n-\n-The answer is that of course it does.  These two types are basically\n-the same, except that in one we used the name `a` and one we used\n-the name `b`.\n-\n-In the examples that follow, it becomes very important to know whether\n-a lifetime is bound in a function type (that is, is a lifetime\n-parameter) or appears free (is defined in some outer scope).\n-Therefore, from now on I will write the bindings explicitly, using a\n-notation like `fn<a>(&'a int)` to indicate that `a` is a lifetime\n-parameter.\n-\n-Now let's consider two more function types.  Here, we assume that the\n-`self` lifetime is defined somewhere outside and hence is not a\n-lifetime parameter bound by the function type (it \"appears free\"):\n-\n-    fn<a>(&'a int) <: &fn(&'self int)? (Yes, a => self)\n-\n-This subtyping relation does in fact hold.  To see why, you have to\n-consider what subtyping means.  One way to look at `T1 <: T2` is to\n-say that it means that it is always ok to treat an instance of `T1` as\n-if it had the type `T2`.  So, with our functions, it is always ok to\n-treat a function that can take pointers with any lifetime as if it\n-were a function that can only take a pointer with the specific\n-lifetime `&self`.  After all, `&self` is a lifetime, after all, and\n-the function can take values of any lifetime.\n-\n-You can also look at subtyping as the *is a* relationship.  This amounts\n-to the same thing: a function that accepts pointers with any lifetime\n-*is a* function that accepts pointers with some specific lifetime.\n-\n-So, what if we reverse the order of the two function types, like this:\n-\n-    fn(&'self int) <: &fn<a>(&'a int)? (No)\n-\n-Does the subtyping relationship still hold?  The answer of course is\n-no.  In this case, the function accepts *only the lifetime `&self`*,\n-so it is not reasonable to treat it as if it were a function that\n-accepted any lifetime.\n-\n-What about these two examples:\n-\n-    fn<a,b>(&'a int, &'b int) <: &fn<a>(&'a int, &'a int)? (Yes)\n-    fn<a>(&'a int, &'a int) <: &fn<a,b>(&'a int, &'b int)? (No)\n-\n-Here, it is true that functions which take two pointers with any two\n-lifetimes can be treated as if they only accepted two pointers with\n-the same lifetime, but not the reverse.\n-\n-## The algorithm\n-\n-Here is the algorithm we use to perform the subtyping check:\n-\n-1. Replace all bound regions in the subtype with new variables\n-2. Replace all bound regions in the supertype with skolemized\n-   equivalents.  A \"skolemized\" region is just a new fresh region\n-   name.\n-3. Check that the parameter and return types match as normal\n-4. Ensure that no skolemized regions 'leak' into region variables\n-   visible from \"the outside\"\n-\n-Let's walk through some examples and see how this algorithm plays out.\n-\n-#### First example\n-\n-We'll start with the first example, which was:\n-\n-    1. fn<a>(&'a T) <: &fn<b>(&'b T)?        Yes: a -> b\n-\n-After steps 1 and 2 of the algorithm we will have replaced the types\n-like so:\n-\n-    1. fn(&'A T) <: &fn(&'x T)?\n-\n-Here the upper case `&A` indicates a *region variable*, that is, a\n-region whose value is being inferred by the system.  I also replaced\n-`&b` with `&x`---I'll use letters late in the alphabet (`x`, `y`, `z`)\n-to indicate skolemized region names.  We can assume they don't appear\n-elsewhere.  Note that neither the sub- nor the supertype bind any\n-region names anymore (as indicated by the absence of `<` and `>`).\n-\n-The next step is to check that the parameter types match.  Because\n-parameters are contravariant, this means that we check whether:\n-\n-    &'x T <: &'A T\n-\n-Region pointers are contravariant so this implies that\n-\n-    &A <= &x\n-\n-must hold, where `<=` is the subregion relationship.  Processing\n-*this* constrain simply adds a constraint into our graph that `&A <=\n-&x` and is considered successful (it can, for example, be satisfied by\n-choosing the value `&x` for `&A`).\n-\n-So far we have encountered no error, so the subtype check succeeds.\n-\n-#### The third example\n-\n-Now let's look first at the third example, which was:\n-\n-    3. fn(&'self T)    <: &fn<b>(&'b T)?        No!\n-\n-After steps 1 and 2 of the algorithm we will have replaced the types\n-like so:\n-\n-    3. fn(&'self T) <: &fn(&'x T)?\n-\n-This looks pretty much the same as before, except that on the LHS\n-`&self` was not bound, and hence was left as-is and not replaced with\n-a variable.  The next step is again to check that the parameter types\n-match.  This will ultimately require (as before) that `&self` <= `&x`\n-must hold: but this does not hold.  `self` and `x` are both distinct\n-free regions.  So the subtype check fails.\n-\n-#### Checking for skolemization leaks\n-\n-You may be wondering about that mysterious last step in the algorithm.\n-So far it has not been relevant.  The purpose of that last step is to\n-catch something like *this*:\n-\n-    fn<a>() -> fn(&'a T) <: &fn() -> fn<b>(&'b T)?   No.\n-\n-Here the function types are the same but for where the binding occurs.\n-The subtype returns a function that expects a value in precisely one\n-region.  The supertype returns a function that expects a value in any\n-region.  If we allow an instance of the subtype to be used where the\n-supertype is expected, then, someone could call the fn and think that\n-the return value has type `fn<b>(&'b T)` when it really has type\n-`fn(&'a T)` (this is case #3, above).  Bad.\n-\n-So let's step through what happens when we perform this subtype check.\n-We first replace the bound regions in the subtype (the supertype has\n-no bound regions).  This gives us:\n-\n-    fn() -> fn(&'A T) <: &fn() -> fn<b>(&'b T)?\n-\n-Now we compare the return types, which are covariant, and hence we have:\n-\n-    fn(&'A T) <: &fn<b>(&'b T)?\n-\n-Here we skolemize the bound region in the supertype to yield:\n-\n-    fn(&'A T) <: &fn(&'x T)?\n-\n-And then proceed to compare the argument types:\n-\n-    &'x T <: &'A T\n-    &A <= &x\n-\n-Finally, this is where it gets interesting!  This is where an error\n-*should* be reported.  But in fact this will not happen.  The reason why\n-is that `A` is a variable: we will infer that its value is the fresh\n-region `x` and think that everything is happy.  In fact, this behavior\n-is *necessary*, it was key to the first example we walked through.\n-\n-The difference between this example and the first one is that the variable\n-`A` already existed at the point where the skolemization occurred.  In\n-the first example, you had two functions:\n-\n-    fn<a>(&'a T) <: &fn<b>(&'b T)\n-\n-and hence `&A` and `&x` were created \"together\".  In general, the\n-intention of the skolemized names is that they are supposed to be\n-fresh names that could never be equal to anything from the outside.\n-But when inference comes into play, we might not be respecting this\n-rule.\n-\n-So the way we solve this is to add a fourth step that examines the\n-constraints that refer to skolemized names.  Basically, consider a\n-non-directed verison of the constraint graph.  Let `Tainted(x)` be the\n-set of all things reachable from a skolemized variable `x`.\n-`Tainted(x)` should not contain any regions that existed before the\n-step at which the skolemization was performed.  So this case here\n-would fail because `&x` was created alone, but is relatable to `&A`.\n-\n-## Computing the LUB and GLB\n-\n-The paper I pointed you at is written for Haskell.  It does not\n-therefore considering subtyping and in particular does not consider\n-LUB or GLB computation.  We have to consider this.  Here is the\n-algorithm I implemented.\n-\n-First though, let's discuss what we are trying to compute in more\n-detail.  The LUB is basically the \"common supertype\" and the GLB is\n-\"common subtype\"; one catch is that the LUB should be the\n-*most-specific* common supertype and the GLB should be *most general*\n-common subtype (as opposed to any common supertype or any common\n-subtype).\n-\n-Anyway, to help clarify, here is a table containing some\n-function pairs and their LUB/GLB:\n-\n-```\n-Type 1              Type 2              LUB               GLB\n-fn<a>(&a)           fn(&X)              fn(&X)            fn<a>(&a)\n-fn(&A)              fn(&X)              --                fn<a>(&a)\n-fn<a,b>(&a, &b)     fn<x>(&x, &x)       fn<a>(&a, &a)     fn<a,b>(&a, &b)\n-fn<a,b>(&a, &b, &a) fn<x,y>(&x, &y, &y) fn<a>(&a, &a, &a) fn<a,b,c>(&a,&b,&c)\n-```\n-\n-### Conventions\n-\n-I use lower-case letters (e.g., `&a`) for bound regions and upper-case\n-letters for free regions (`&A`).  Region variables written with a\n-dollar-sign (e.g., `$a`).  I will try to remember to enumerate the\n-bound-regions on the fn type as well (e.g., `fn<a>(&a)`).\n-\n-### High-level summary\n-\n-Both the LUB and the GLB algorithms work in a similar fashion.  They\n-begin by replacing all bound regions (on both sides) with fresh region\n-inference variables.  Therefore, both functions are converted to types\n-that contain only free regions.  We can then compute the LUB/GLB in a\n-straightforward way, as described in `combine.rs`.  This results in an\n-interim type T.  The algorithms then examine the regions that appear\n-in T and try to, in some cases, replace them with bound regions to\n-yield the final result.\n-\n-To decide whether to replace a region `R` that appears in `T` with a\n-bound region, the algorithms make use of two bits of information.\n-First is a set `V` that contains all region variables created as part\n-of the LUB/GLB computation. `V` will contain the region variables\n-created to replace the bound regions in the input types, but it also\n-contains 'intermediate' variables created to represent the LUB/GLB of\n-individual regions.  Basically, when asked to compute the LUB/GLB of a\n-region variable with another region, the inferencer cannot oblige\n-immediately since the valuese of that variables are not known.\n-Therefore, it creates a new variable that is related to the two\n-regions.  For example, the LUB of two variables `$x` and `$y` is a\n-fresh variable `$z` that is constrained such that `$x <= $z` and `$y\n-<= $z`.  So `V` will contain these intermediate variables as well.\n-\n-The other important factor in deciding how to replace a region in T is\n-the function `Tainted($r)` which, for a region variable, identifies\n-all regions that the region variable is related to in some way\n-(`Tainted()` made an appearance in the subtype computation as well).\n-\n-### LUB\n-\n-The LUB algorithm proceeds in three steps:\n-\n-1. Replace all bound regions (on both sides) with fresh region\n-   inference variables.\n-2. Compute the LUB \"as normal\", meaning compute the GLB of each\n-   pair of argument types and the LUB of the return types and\n-   so forth.  Combine those to a new function type `F`.\n-3. Replace each region `R` that appears in `F` as follows:\n-   - Let `V` be the set of variables created during the LUB\n-     computational steps 1 and 2, as described in the previous section.\n-   - If `R` is not in `V`, replace `R` with itself.\n-   - If `Tainted(R)` contains a region that is not in `V`,\n-     replace `R` with itself.\n-   - Otherwise, select the earliest variable in `Tainted(R)` that originates\n-     from the left-hand side and replace `R` with the bound region that\n-     this variable was a replacement for.\n-\n-So, let's work through the simplest example: `fn(&A)` and `fn<a>(&a)`.\n-In this case, `&a` will be replaced with `$a` and the interim LUB type\n-`fn($b)` will be computed, where `$b=GLB(&A,$a)`.  Therefore, `V =\n-{$a, $b}` and `Tainted($b) = { $b, $a, &A }`.  When we go to replace\n-`$b`, we find that since `&A \\in Tainted($b)` is not a member of `V`,\n-we leave `$b` as is.  When region inference happens, `$b` will be\n-resolved to `&A`, as we wanted.\n-\n-Let's look at a more complex one: `fn(&a, &b)` and `fn(&x, &x)`.  In\n-this case, we'll end up with a (pre-replacement) LUB type of `fn(&g,\n-&h)` and a graph that looks like:\n-\n-```\n-     $a        $b     *--$x\n-       \\        \\    /  /\n-        \\        $h-*  /\n-         $g-----------*\n-```\n-\n-Here `$g` and `$h` are fresh variables that are created to represent\n-the LUB/GLB of things requiring inference.  This means that `V` and\n-`Tainted` will look like:\n-\n-```\n-V = {$a, $b, $g, $h, $x}\n-Tainted($g) = Tainted($h) = { $a, $b, $h, $g, $x }\n-```\n-\n-Therefore we replace both `$g` and `$h` with `$a`, and end up\n-with the type `fn(&a, &a)`.\n-\n-### GLB\n-\n-The procedure for computing the GLB is similar.  The difference lies\n-in computing the replacements for the various variables. For each\n-region `R` that appears in the type `F`, we again compute `Tainted(R)`\n-and examine the results:\n-\n-1. If `R` is not in `V`, it is not replaced.\n-2. Else, if `Tainted(R)` contains only variables in `V`, and it\n-   contains exactly one variable from the LHS and one variable from\n-   the RHS, then `R` can be mapped to the bound version of the\n-   variable from the LHS.\n-3. Else, if `Tainted(R)` contains no variable from the LHS and no\n-   variable from the RHS, then `R` can be mapped to itself.\n-4. Else, `R` is mapped to a fresh bound variable.\n-\n-These rules are pretty complex.  Let's look at some examples to see\n-how they play out.\n-\n-Out first example was `fn(&a)` and `fn(&X)`.  In this case, `&a` will\n-be replaced with `$a` and we will ultimately compute a\n-(pre-replacement) GLB type of `fn($g)` where `$g=LUB($a,&X)`.\n-Therefore, `V={$a,$g}` and `Tainted($g)={$g,$a,&X}.  To find the\n-replacement for `$g` we consult the rules above:\n-- Rule (1) does not apply because `$g \\in V`\n-- Rule (2) does not apply because `&X \\in Tainted($g)`\n-- Rule (3) does not apply because `$a \\in Tainted($g)`\n-- Hence, by rule (4), we replace `$g` with a fresh bound variable `&z`.\n-So our final result is `fn(&z)`, which is correct.\n-\n-The next example is `fn(&A)` and `fn(&Z)`. In this case, we will again\n-have a (pre-replacement) GLB of `fn(&g)`, where `$g = LUB(&A,&Z)`.\n-Therefore, `V={$g}` and `Tainted($g) = {$g, &A, &Z}`.  In this case,\n-by rule (3), `$g` is mapped to itself, and hence the result is\n-`fn($g)`.  This result is correct (in this case, at least), but it is\n-indicative of a case that *can* lead us into concluding that there is\n-no GLB when in fact a GLB does exist.  See the section \"Questionable\n-Results\" below for more details.\n-\n-The next example is `fn(&a, &b)` and `fn(&c, &c)`. In this case, as\n-before, we'll end up with `F=fn($g, $h)` where `Tainted($g) =\n-Tainted($h) = {$g, $h, $a, $b, $c}`.  Only rule (4) applies and hence\n-we'll select fresh bound variables `y` and `z` and wind up with\n-`fn(&y, &z)`.\n-\n-For the last example, let's consider what may seem trivial, but is\n-not: `fn(&a, &a)` and `fn(&b, &b)`.  In this case, we'll get `F=fn($g,\n-$h)` where `Tainted($g) = {$g, $a, $x}` and `Tainted($h) = {$h, $a,\n-$x}`.  Both of these sets contain exactly one bound variable from each\n-side, so we'll map them both to `&a`, resulting in `fn(&a, &a)`, which\n-is the desired result.\n-\n-### Shortcomings and correctness\n-\n-You may be wondering whether this algorithm is correct.  The answer is\n-\"sort of\".  There are definitely cases where they fail to compute a\n-result even though a correct result exists.  I believe, though, that\n-if they succeed, then the result is valid, and I will attempt to\n-convince you.  The basic argument is that the \"pre-replacement\" step\n-computes a set of constraints.  The replacements, then, attempt to\n-satisfy those constraints, using bound identifiers where needed.\n-\n-For now I will briefly go over the cases for LUB/GLB and identify\n-their intent:\n-\n-- LUB:\n-  - The region variables that are substituted in place of bound regions\n-    are intended to collect constraints on those bound regions.\n-  - If Tainted(R) contains only values in V, then this region is unconstrained\n-    and can therefore be generalized, otherwise it cannot.\n-- GLB:\n-  - The region variables that are substituted in place of bound regions\n-    are intended to collect constraints on those bound regions.\n-  - If Tainted(R) contains exactly one variable from each side, and\n-    only variables in V, that indicates that those two bound regions\n-    must be equated.\n-  - Otherwise, if Tainted(R) references any variables from left or right\n-    side, then it is trying to combine a bound region with a free one or\n-    multiple bound regions, so we need to select fresh bound regions.\n-\n-Sorry this is more of a shorthand to myself.  I will try to write up something\n-more convincing in the future.\n-\n-#### Where are the algorithms wrong?\n-\n-- The pre-replacement computation can fail even though using a\n-  bound-region would have succeeded.\n-- We will compute GLB(fn(fn($a)), fn(fn($b))) as fn($c) where $c is the\n-  GLB of $a and $b.  But if inference finds that $a and $b must be mapped\n-  to regions without a GLB, then this is effectively a failure to compute\n-  the GLB.  However, the result `fn<$c>(fn($c))` is a valid GLB.\n-\n-*/\n+/*! See doc.rs */\n \n \n use middle::ty;\n use middle::ty::{FreeRegion, Region, RegionVid};\n use middle::ty::{re_empty, re_static, re_infer, re_free, re_bound};\n use middle::ty::{re_scope, ReVar, ReSkolemized, br_fresh};\n use middle::typeck::infer::cres;\n+use middle::typeck::infer::{RegionVariableOrigin, SubregionOrigin};\n+use middle::typeck::infer;\n use util::common::indenter;\n-use util::ppaux::note_and_explain_region;\n+use util::ppaux::{note_and_explain_region, Repr, UserString};\n \n use std::cell::Cell;\n use std::hashmap::{HashMap, HashSet};\n use std::uint;\n use std::vec;\n use syntax::codemap::span;\n use syntax::ast;\n+use syntax::opt_vec;\n+use syntax::opt_vec::OptVec;\n \n-#[deriving(Eq,IterBytes)]\n+mod doc;\n+\n+#[deriving(Eq, IterBytes)]\n enum Constraint {\n     ConstrainVarSubVar(RegionVid, RegionVid),\n     ConstrainRegSubVar(Region, RegionVid),\n-    ConstrainVarSubReg(RegionVid, Region)\n+    ConstrainVarSubReg(RegionVid, Region),\n+    ConstrainRegSubReg(Region, Region),\n }\n \n #[deriving(Eq, IterBytes)]\n@@ -576,12 +57,37 @@ enum CombineMapType {\n     Lub, Glb\n }\n \n+pub enum RegionResolutionError {\n+    /// `ConcreteFailure(o, a, b)`:\n+    ///\n+    /// `o` requires that `a <= b`, but this does not hold\n+    ConcreteFailure(SubregionOrigin, Region, Region),\n+\n+    /// `SubSupConflict(v, sub_origin, sub_r, sup_origin, sup_r)`:\n+    ///\n+    /// Could not infer a value for `v` because `sub_r <= v` (due to\n+    /// `sub_origin`) but `v <= sup_r` (due to `sup_origin`) and\n+    /// `sub_r <= sup_r` does not hold.\n+    SubSupConflict(RegionVariableOrigin,\n+                   SubregionOrigin, Region,\n+                   SubregionOrigin, Region),\n+\n+    /// `SupSupConflict(v, origin1, r1, origin2, r2)`:\n+    ///\n+    /// Could not infer a value for `v` because `v <= r1` (due to\n+    /// `origin1`) and `v <= r2` (due to `origin2`) and\n+    /// `r1` and `r2` have no intersection.\n+    SupSupConflict(RegionVariableOrigin,\n+                   SubregionOrigin, Region,\n+                   SubregionOrigin, Region),\n+}\n+\n type CombineMap = HashMap<TwoRegions, RegionVid>;\n \n pub struct RegionVarBindings {\n     tcx: ty::ctxt,\n-    var_spans: ~[span],\n-    constraints: HashMap<Constraint, span>,\n+    var_origins: ~[RegionVariableOrigin],\n+    constraints: HashMap<Constraint, SubregionOrigin>,\n     lubs: CombineMap,\n     glbs: CombineMap,\n     skolemization_count: uint,\n@@ -606,7 +112,7 @@ pub struct RegionVarBindings {\n pub fn RegionVarBindings(tcx: ty::ctxt) -> RegionVarBindings {\n     RegionVarBindings {\n         tcx: tcx,\n-        var_spans: ~[],\n+        var_origins: ~[],\n         values: Cell::new_empty(),\n         constraints: HashMap::new(),\n         lubs: HashMap::new(),\n@@ -647,8 +153,8 @@ impl RegionVarBindings {\n             match undo_item {\n               Snapshot => {}\n               AddVar(vid) => {\n-                assert_eq!(self.var_spans.len(), vid.to_uint() + 1);\n-                self.var_spans.pop();\n+                assert_eq!(self.var_origins.len(), vid.to_uint() + 1);\n+                self.var_origins.pop();\n               }\n               AddConstraint(ref constraint) => {\n                 self.constraints.remove(constraint);\n@@ -664,18 +170,18 @@ impl RegionVarBindings {\n     }\n \n     pub fn num_vars(&mut self) -> uint {\n-        self.var_spans.len()\n+        self.var_origins.len()\n     }\n \n-    pub fn new_region_var(&mut self, span: span) -> RegionVid {\n+    pub fn new_region_var(&mut self, origin: RegionVariableOrigin) -> RegionVid {\n         let id = self.num_vars();\n-        self.var_spans.push(span);\n+        self.var_origins.push(origin);\n         let vid = RegionVid { id: id };\n         if self.in_snapshot() {\n             self.undo_log.push(AddVar(vid));\n         }\n-        debug!(\"created new region variable %? with span %?\",\n-               vid, self.tcx.sess.codemap.span_to_str(span));\n+        debug!(\"created new region variable %? with origin %?\",\n+               vid, origin.repr(self.tcx));\n         return vid;\n     }\n \n@@ -705,109 +211,106 @@ impl RegionVarBindings {\n         re_bound(br_fresh(sc))\n     }\n \n-    pub fn add_constraint(&mut self, constraint: Constraint, span: span) {\n+    pub fn add_constraint(&mut self,\n+                          constraint: Constraint,\n+                          origin: SubregionOrigin) {\n         // cannot add constraints once regions are resolved\n         assert!(self.values.is_empty());\n \n         debug!(\"RegionVarBindings: add_constraint(%?)\", constraint);\n \n-        if self.constraints.insert(constraint, span) {\n+        if self.constraints.insert(constraint, origin) {\n             if self.in_snapshot() {\n                 self.undo_log.push(AddConstraint(constraint));\n             }\n         }\n     }\n \n-    pub fn make_subregion(&mut self, span: span, sub: Region, sup: Region)\n-                          -> cres<()> {\n+    pub fn make_subregion(&mut self,\n+                          origin: SubregionOrigin,\n+                          sub: Region,\n+                          sup: Region) {\n         // cannot add constraints once regions are resolved\n         assert!(self.values.is_empty());\n \n         debug!(\"RegionVarBindings: make_subregion(%?, %?)\", sub, sup);\n         match (sub, sup) {\n           (re_infer(ReVar(sub_id)), re_infer(ReVar(sup_id))) => {\n-            self.add_constraint(ConstrainVarSubVar(sub_id, sup_id), span);\n-            Ok(())\n+            self.add_constraint(ConstrainVarSubVar(sub_id, sup_id), origin);\n           }\n           (r, re_infer(ReVar(sup_id))) => {\n-            self.add_constraint(ConstrainRegSubVar(r, sup_id), span);\n-            Ok(())\n+            self.add_constraint(ConstrainRegSubVar(r, sup_id), origin);\n           }\n           (re_infer(ReVar(sub_id)), r) => {\n-            self.add_constraint(ConstrainVarSubReg(sub_id, r), span);\n-            Ok(())\n+            self.add_constraint(ConstrainVarSubReg(sub_id, r), origin);\n           }\n           (re_bound(br), _) => {\n             self.tcx.sess.span_bug(\n-                span,\n+                origin.span(),\n                 fmt!(\"Cannot relate bound region as subregion: %?\", br));\n           }\n           (_, re_bound(br)) => {\n             self.tcx.sess.span_bug(\n-                span,\n+                origin.span(),\n                 fmt!(\"Cannot relate bound region as superregion: %?\", br));\n           }\n           _ => {\n-            if self.is_subregion_of(sub, sup) {\n-                Ok(())\n-            } else {\n-                Err(ty::terr_regions_does_not_outlive(sub, sup))\n-            }\n+            self.add_constraint(ConstrainRegSubReg(sub, sup), origin);\n           }\n         }\n     }\n \n-    pub fn lub_regions(&mut self, span: span, a: Region, b: Region)\n-                       -> cres<Region> {\n+    pub fn lub_regions(&mut self,\n+                       origin: SubregionOrigin,\n+                       a: Region,\n+                       b: Region)\n+                       -> Region {\n         // cannot add constraints once regions are resolved\n         assert!(self.values.is_empty());\n \n         debug!(\"RegionVarBindings: lub_regions(%?, %?)\", a, b);\n         match (a, b) {\n-          (re_static, _) | (_, re_static) => {\n-            Ok(re_static) // nothing lives longer than static\n-          }\n-\n-          (re_infer(ReVar(*)), _) | (_, re_infer(ReVar(*))) => {\n-            self.combine_vars(\n-                Lub, a, b, span,\n-                |this, old_r, new_r| this.make_subregion(span, old_r, new_r))\n-          }\n+            (re_static, _) | (_, re_static) => {\n+                re_static // nothing lives longer than static\n+            }\n \n-          _ => {\n-            Ok(self.lub_concrete_regions(a, b))\n-          }\n+            _ => {\n+                self.combine_vars(\n+                    Lub, a, b, origin,\n+                    |this, old_r, new_r|\n+                    this.make_subregion(origin, old_r, new_r))\n+            }\n         }\n     }\n \n-    pub fn glb_regions(&mut self, span: span, a: Region, b: Region)\n-                       -> cres<Region> {\n+    pub fn glb_regions(&mut self,\n+                       origin: SubregionOrigin,\n+                       a: Region,\n+                       b: Region)\n+                       -> Region {\n         // cannot add constraints once regions are resolved\n         assert!(self.values.is_empty());\n \n         debug!(\"RegionVarBindings: glb_regions(%?, %?)\", a, b);\n         match (a, b) {\n-          (re_static, r) | (r, re_static) => {\n-            // static lives longer than everything else\n-            Ok(r)\n-          }\n-\n-          (re_infer(ReVar(*)), _) | (_, re_infer(ReVar(*))) => {\n-            self.combine_vars(\n-                Glb, a, b, span,\n-                |this, old_r, new_r| this.make_subregion(span, new_r, old_r))\n-          }\n+            (re_static, r) | (r, re_static) => {\n+                // static lives longer than everything else\n+                r\n+            }\n \n-          _ => {\n-            self.glb_concrete_regions(a, b)\n-          }\n+            _ => {\n+                self.combine_vars(\n+                    Glb, a, b, origin,\n+                    |this, old_r, new_r|\n+                    this.make_subregion(origin, new_r, old_r))\n+            }\n         }\n     }\n \n     pub fn resolve_var(&mut self, rid: RegionVid) -> ty::Region {\n         if self.values.is_empty() {\n             self.tcx.sess.span_bug(\n-                self.var_spans[rid.to_uint()],\n+                self.var_origins[rid.to_uint()].span(),\n                 fmt!(\"Attempt to resolve region variable before values have \\\n                       been computed!\"));\n         }\n@@ -830,46 +333,41 @@ impl RegionVarBindings {\n         }\n     }\n \n+    fn combine_map<'a>(&'a mut self,\n+                       t: CombineMapType)\n+                       -> &'a mut CombineMap\n+    {\n+        match t {\n+            Glb => &mut self.glbs,\n+            Lub => &mut self.lubs,\n+        }\n+    }\n+\n     pub fn combine_vars(&mut self,\n                         t: CombineMapType,\n                         a: Region,\n                         b: Region,\n-                        span: span,\n+                        origin: SubregionOrigin,\n                         relate: &fn(this: &mut RegionVarBindings,\n                                     old_r: Region,\n-                                    new_r: Region) -> cres<()>)\n-                        -> cres<Region> {\n+                                    new_r: Region))\n+                        -> Region {\n         let vars = TwoRegions { a: a, b: b };\n-        let c;\n-        {\n-            // FIXME (#3850): shouldn't need a scope, nor should this need to be\n-            //                done twice to get the maps out\n-            {\n-                let combines = match t {\n-                    Glb => &self.glbs, Lub => &self.lubs\n-                };\n-                match combines.find(&vars) {\n-                  Some(&c) => return Ok(re_infer(ReVar(c))),\n-                  None => ()\n-                }\n-            }\n-            c = self.new_region_var(span);\n-            {\n-                let combines = match t {\n-                    Glb => &mut self.glbs, Lub => &mut self.lubs\n-                };\n-                combines.insert(vars, c);\n+        match self.combine_map(t).find(&vars) {\n+            Some(&c) => {\n+                return re_infer(ReVar(c));\n             }\n+            None => {}\n         }\n+        let c = self.new_region_var(infer::MiscVariable(origin.span()));\n+        self.combine_map(t).insert(vars, c);\n         if self.in_snapshot() {\n             self.undo_log.push(AddCombination(t, vars));\n         }\n-        do relate(self, a, re_infer(ReVar(c))).then {\n-            do relate(self, b, re_infer(ReVar(c))).then {\n-                debug!(\"combine_vars() c=%?\", c);\n-                Ok(re_infer(ReVar(c)))\n-            }\n-        }\n+        relate(self, a, re_infer(ReVar(c)));\n+        relate(self, b, re_infer(ReVar(c)));\n+        debug!(\"combine_vars() c=%?\", c);\n+        re_infer(ReVar(c))\n     }\n \n     pub fn vars_created_since_snapshot(&mut self, snapshot: uint)\n@@ -924,18 +422,21 @@ impl RegionVarBindings {\n                     AddConstraint(ConstrainVarSubReg(ref a, ref b)) => {\n                         Some((re_infer(ReVar(*a)), *b))\n                     }\n+                    AddConstraint(ConstrainRegSubReg(a, b)) => {\n+                        Some((a, b))\n+                    }\n                     _ => {\n                         None\n                     }\n                 };\n \n                 match regs {\n                     None => {}\n-                    Some((ref r1, ref r2)) => {\n+                    Some((r1, r2)) => {\n                         result_set =\n-                            consider_adding_edge(result_set, &r, r1, r2);\n+                            consider_adding_edge(result_set, r, r1, r2);\n                         result_set =\n-                            consider_adding_edge(result_set, &r, r2, r1);\n+                            consider_adding_edge(result_set, r, r2, r1);\n                     }\n                 }\n \n@@ -948,14 +449,14 @@ impl RegionVarBindings {\n         return result_set;\n \n         fn consider_adding_edge(result_set: ~[Region],\n-                                r: &Region,\n-                                r1: &Region,\n-                                r2: &Region) -> ~[Region]\n+                                r: Region,\n+                                r1: Region,\n+                                r2: Region) -> ~[Region]\n         {\n             let mut result_set = result_set;\n-            if *r == *r1 { // Clearly, this is potentially inefficient.\n-                if !result_set.iter().any_(|x| x == r2) {\n-                    result_set.push(*r2);\n+            if r == r1 { // Clearly, this is potentially inefficient.\n+                if !result_set.iter().any_(|x| *x == r2) {\n+                    result_set.push(r2);\n                 }\n             }\n             return result_set;\n@@ -969,10 +470,12 @@ impl RegionVarBindings {\n     constraints, assuming such values can be found; if they cannot,\n     errors are reported.\n     */\n-    pub fn resolve_regions(&mut self) {\n+    pub fn resolve_regions(&mut self) -> OptVec<RegionResolutionError> {\n         debug!(\"RegionVarBindings: resolve_regions()\");\n-        let v = self.infer_variable_values();\n+        let mut errors = opt_vec::Empty;\n+        let v = self.infer_variable_values(&mut errors);\n         self.values.put_back(v);\n+        errors\n     }\n }\n \n@@ -994,7 +497,7 @@ impl RegionVarBindings {\n \n           (re_infer(ReVar(v_id)), _) | (_, re_infer(ReVar(v_id))) => {\n             self.tcx.sess.span_bug(\n-                self.var_spans[v_id.to_uint()],\n+                self.var_origins[v_id.to_uint()].span(),\n                 fmt!(\"lub_concrete_regions invoked with \\\n                       non-concrete regions: %?, %?\", a, b));\n           }\n@@ -1096,7 +599,7 @@ impl RegionVarBindings {\n             (re_infer(ReVar(v_id)), _) |\n             (_, re_infer(ReVar(v_id))) => {\n                 self.tcx.sess.span_bug(\n-                    self.var_spans[v_id.to_uint()],\n+                    self.var_origins[v_id.to_uint()].span(),\n                     fmt!(\"glb_concrete_regions invoked with \\\n                           non-concrete regions: %?, %?\", a, b));\n             }\n@@ -1173,9 +676,11 @@ impl RegionVarBindings {\n         }\n     }\n \n-    fn report_type_error(&mut self, span: span, terr: &ty::type_err) {\n+    fn report_type_error(&mut self,\n+                         origin: SubregionOrigin,\n+                         terr: &ty::type_err) {\n         let terr_str = ty::type_err_to_str(self.tcx, terr);\n-        self.tcx.sess.span_err(span, terr_str);\n+        self.tcx.sess.span_err(origin.span(), terr_str);\n     }\n \n     fn intersect_scopes(&self,\n@@ -1210,7 +715,7 @@ enum Classification { Expanding, Contracting }\n enum GraphNodeValue { NoValue, Value(Region), ErrorValue }\n \n struct GraphNode {\n-    span: span,\n+    origin: RegionVariableOrigin,\n     classification: Classification,\n     value: GraphNodeValue,\n     head_edge: [uint, ..2],\n@@ -1219,28 +724,30 @@ struct GraphNode {\n struct GraphEdge {\n     next_edge: [uint, ..2],\n     constraint: Constraint,\n-    span: span,\n }\n \n struct Graph {\n     nodes: ~[GraphNode],\n     edges: ~[GraphEdge],\n }\n \n-struct SpannedRegion {\n+struct RegionAndOrigin {\n     region: Region,\n-    span: span,\n+    origin: SubregionOrigin,\n }\n \n impl RegionVarBindings {\n-    pub fn infer_variable_values(&mut self) -> ~[GraphNodeValue] {\n+    fn infer_variable_values(&mut self,\n+                             errors: &mut OptVec<RegionResolutionError>)\n+                             -> ~[GraphNodeValue] {\n         let mut graph = self.construct_graph();\n         self.expansion(&mut graph);\n         self.contraction(&mut graph);\n-        self.extract_values_and_report_conflicts(&graph)\n+        self.collect_concrete_region_errors(&graph, errors);\n+        self.extract_values_and_collect_conflicts(&graph, errors)\n     }\n \n-    pub fn construct_graph(&mut self) -> Graph {\n+    fn construct_graph(&mut self) -> Graph {\n         let num_vars = self.num_vars();\n         let num_edges = self.constraints.len();\n \n@@ -1251,19 +758,18 @@ impl RegionVarBindings {\n                 // those nodes that have a concrete region predecessor to\n                 // Expanding.\n                 classification: Contracting,\n-                span: self.var_spans[var_idx],\n+                origin: self.var_origins[var_idx],\n                 value: NoValue,\n                 head_edge: [uint::max_value, uint::max_value]\n             }\n         });\n \n         // It would be nice to write this using map():\n         let mut edges = vec::with_capacity(num_edges);\n-        for self.constraints.iter().advance |(constraint, span)| {\n+        for self.constraints.iter().advance |(constraint, _)| {\n             edges.push(GraphEdge {\n                 next_edge: [uint::max_value, uint::max_value],\n                 constraint: *constraint,\n-                span: *span\n             });\n         }\n \n@@ -1284,6 +790,10 @@ impl RegionVarBindings {\n               ConstrainVarSubReg(a_id, _) => {\n                 insert_edge(&mut graph, a_id, Outgoing, edge_idx);\n               }\n+              ConstrainRegSubReg(*) => {\n+                  // Relations between two concrete regions do not\n+                  // require an edge in the graph.\n+              }\n             }\n         }\n \n@@ -1305,7 +815,7 @@ impl RegionVarBindings {\n         }\n     }\n \n-    pub fn expansion(&mut self, graph: &mut Graph) {\n+    fn expansion(&mut self, graph: &mut Graph) {\n         do iterate_until_fixed_point(~\"Expansion\", graph) |nodes, edge| {\n             match edge.constraint {\n               ConstrainRegSubVar(a_region, b_vid) => {\n@@ -1325,15 +835,19 @@ impl RegionVarBindings {\n                 // This is a contraction constraint.  Ignore it.\n                 false\n               }\n+              ConstrainRegSubReg(*) => {\n+                // No region variables involved. Ignore.\n+                false\n+              }\n             }\n         }\n     }\n \n-    pub fn expand_node(&mut self,\n-                       a_region: Region,\n-                       b_vid: RegionVid,\n-                       b_node: &mut GraphNode)\n-                       -> bool {\n+    fn expand_node(&mut self,\n+                   a_region: Region,\n+                   b_vid: RegionVid,\n+                   b_node: &mut GraphNode)\n+                   -> bool {\n         debug!(\"expand_node(%?, %? == %?)\",\n                a_region, b_vid, b_node.value);\n \n@@ -1365,7 +879,8 @@ impl RegionVarBindings {\n         }\n     }\n \n-    pub fn contraction(&mut self, graph: &mut Graph) {\n+    fn contraction(&mut self,\n+                   graph: &mut Graph) {\n         do iterate_until_fixed_point(~\"Contraction\", graph) |nodes, edge| {\n             match edge.constraint {\n               ConstrainRegSubVar(*) => {\n@@ -1385,15 +900,19 @@ impl RegionVarBindings {\n                 let a_node = &mut nodes[a_vid.to_uint()];\n                 self.contract_node(a_vid, a_node, b_region)\n               }\n+              ConstrainRegSubReg(*) => {\n+                // No region variables involved. Ignore.\n+                false\n+              }\n             }\n         }\n     }\n \n-    pub fn contract_node(&mut self,\n-                         a_vid: RegionVid,\n-                         a_node: &mut GraphNode,\n-                         b_region: Region)\n-                         -> bool {\n+    fn contract_node(&mut self,\n+                     a_vid: RegionVid,\n+                     a_node: &mut GraphNode,\n+                     b_region: Region)\n+                     -> bool {\n         debug!(\"contract_node(%? == %?/%?, %?)\",\n                a_vid, a_node.value, a_node.classification, b_region);\n \n@@ -1461,9 +980,44 @@ impl RegionVarBindings {\n         }\n     }\n \n-    pub fn extract_values_and_report_conflicts(&mut self, graph: &Graph)\n-                                               -> ~[GraphNodeValue] {\n-        debug!(\"extract_values_and_report_conflicts()\");\n+    fn collect_concrete_region_errors(\n+        &mut self,\n+        graph: &Graph,\n+        errors: &mut OptVec<RegionResolutionError>)\n+    {\n+        let num_edges = graph.edges.len();\n+        for uint::range(0, num_edges) |edge_idx| {\n+            let edge = &graph.edges[edge_idx];\n+            let origin = self.constraints.get_copy(&edge.constraint);\n+\n+            let (sub, sup) = match edge.constraint {\n+                ConstrainVarSubVar(*) |\n+                ConstrainRegSubVar(*) |\n+                ConstrainVarSubReg(*) => {\n+                    loop;\n+                }\n+                ConstrainRegSubReg(sub, sup) => {\n+                    (sub, sup)\n+                }\n+            };\n+\n+            if self.is_subregion_of(sub, sup) {\n+                loop;\n+            }\n+\n+            debug!(\"ConcreteFailure: !(sub <= sup): sub=%?, sup=%?\",\n+                   sub, sup);\n+            errors.push(ConcreteFailure(origin, sub, sup));\n+        }\n+    }\n+\n+    fn extract_values_and_collect_conflicts(\n+        &mut self,\n+        graph: &Graph,\n+        errors: &mut OptVec<RegionResolutionError>)\n+        -> ~[GraphNodeValue]\n+    {\n+        debug!(\"extract_values_and_collect_conflicts()\");\n \n         // This is the best way that I have found to suppress\n         // duplicate and related errors. Basically we keep a set of\n@@ -1516,12 +1070,12 @@ impl RegionVarBindings {\n                     let node_vid = RegionVid { id: idx };\n                     match node.classification {\n                         Expanding => {\n-                            self.report_error_for_expanding_node(\n-                                graph, dup_vec, node_vid);\n+                            self.collect_error_for_expanding_node(\n+                                graph, dup_vec, node_vid, errors);\n                         }\n                         Contracting => {\n-                            self.report_error_for_contracting_node(\n-                                graph, dup_vec, node_vid);\n+                            self.collect_error_for_contracting_node(\n+                                graph, dup_vec, node_vid, errors);\n                         }\n                     }\n                 }\n@@ -1531,10 +1085,13 @@ impl RegionVarBindings {\n         }).collect()\n     }\n \n-    pub fn report_error_for_expanding_node(&mut self,\n-                                           graph: &Graph,\n-                                           dup_vec: &mut [uint],\n-                                           node_idx: RegionVid) {\n+    fn collect_error_for_expanding_node(\n+        &mut self,\n+        graph: &Graph,\n+        dup_vec: &mut [uint],\n+        node_idx: RegionVid,\n+        errors: &mut OptVec<RegionResolutionError>)\n+    {\n         // Errors in expanding nodes result from a lower-bound that is\n         // not contained by an upper-bound.\n         let (lower_bounds, lower_dup) =\n@@ -1550,50 +1107,33 @@ impl RegionVarBindings {\n             for upper_bounds.iter().advance |upper_bound| {\n                 if !self.is_subregion_of(lower_bound.region,\n                                          upper_bound.region) {\n-\n-                    self.tcx.sess.span_err(\n-                        self.var_spans[node_idx.to_uint()],\n-                        fmt!(\"cannot infer an appropriate lifetime \\\n-                              due to conflicting requirements\"));\n-\n-                    note_and_explain_region(\n-                        self.tcx,\n-                        \"first, the lifetime cannot outlive \",\n-                        upper_bound.region,\n-                        \"...\");\n-\n-                    self.tcx.sess.span_note(\n-                        upper_bound.span,\n-                        fmt!(\"...due to the following expression\"));\n-\n-                    note_and_explain_region(\n-                        self.tcx,\n-                        \"but, the lifetime must be valid for \",\n+                    errors.push(SubSupConflict(\n+                        self.var_origins[node_idx.to_uint()],\n+                        lower_bound.origin,\n                         lower_bound.region,\n-                        \"...\");\n-\n-                    self.tcx.sess.span_note(\n-                        lower_bound.span,\n-                        fmt!(\"...due to the following expression\"));\n-\n+                        upper_bound.origin,\n+                        upper_bound.region));\n                     return;\n                 }\n             }\n         }\n \n         self.tcx.sess.span_bug(\n-            self.var_spans[node_idx.to_uint()],\n-            fmt!(\"report_error_for_expanding_node() could not find error \\\n+            self.var_origins[node_idx.to_uint()].span(),\n+            fmt!(\"collect_error_for_expanding_node() could not find error \\\n                   for var %?, lower_bounds=%s, upper_bounds=%s\",\n                  node_idx,\n                  lower_bounds.map(|x| x.region).repr(self.tcx),\n                  upper_bounds.map(|x| x.region).repr(self.tcx)));\n     }\n \n-    pub fn report_error_for_contracting_node(&mut self,\n-                                             graph: &Graph,\n-                                             dup_vec: &mut [uint],\n-                                             node_idx: RegionVid) {\n+    fn collect_error_for_contracting_node(\n+        &mut self,\n+        graph: &Graph,\n+        dup_vec: &mut [uint],\n+        node_idx: RegionVid,\n+        errors: &mut OptVec<RegionResolutionError>)\n+    {\n         // Errors in contracting nodes result from two upper-bounds\n         // that have no intersection.\n         let (upper_bounds, dup_found) =\n@@ -1609,56 +1149,36 @@ impl RegionVarBindings {\n                                                 upper_bound_2.region) {\n                   Ok(_) => {}\n                   Err(_) => {\n-\n-                    self.tcx.sess.span_err(\n-                        self.var_spans[node_idx.to_uint()],\n-                        fmt!(\"cannot infer an appropriate lifetime \\\n-                              due to conflicting requirements\"));\n-\n-                    note_and_explain_region(\n-                        self.tcx,\n-                        \"first, the lifetime must be contained by \",\n+                    errors.push(SupSupConflict(\n+                        self.var_origins[node_idx.to_uint()],\n+                        upper_bound_1.origin,\n                         upper_bound_1.region,\n-                        \"...\");\n-\n-                    self.tcx.sess.span_note(\n-                        upper_bound_1.span,\n-                        fmt!(\"...due to the following expression\"));\n-\n-                    note_and_explain_region(\n-                        self.tcx,\n-                        \"but, the lifetime must also be contained by \",\n-                        upper_bound_2.region,\n-                        \"...\");\n-\n-                    self.tcx.sess.span_note(\n-                        upper_bound_2.span,\n-                        fmt!(\"...due to the following expression\"));\n-\n+                        upper_bound_2.origin,\n+                        upper_bound_2.region));\n                     return;\n                   }\n                 }\n             }\n         }\n \n         self.tcx.sess.span_bug(\n-            self.var_spans[node_idx.to_uint()],\n-            fmt!(\"report_error_for_contracting_node() could not find error \\\n+            self.var_origins[node_idx.to_uint()].span(),\n+            fmt!(\"collect_error_for_contracting_node() could not find error \\\n                   for var %?, upper_bounds=%s\",\n                  node_idx,\n                  upper_bounds.map(|x| x.region).repr(self.tcx)));\n     }\n \n-    pub fn collect_concrete_regions(&mut self,\n-                                    graph: &Graph,\n-                                    orig_node_idx: RegionVid,\n-                                    dir: Direction,\n-                                    dup_vec: &mut [uint])\n-                                    -> (~[SpannedRegion], bool) {\n+    fn collect_concrete_regions(&mut self,\n+                                graph: &Graph,\n+                                orig_node_idx: RegionVid,\n+                                dir: Direction,\n+                                dup_vec: &mut [uint])\n+                                -> (~[RegionAndOrigin], bool) {\n         struct WalkState {\n             set: HashSet<RegionVid>,\n             stack: ~[RegionVid],\n-            result: ~[SpannedRegion],\n+            result: ~[RegionAndOrigin],\n             dup_found: bool\n         }\n         let mut state = WalkState {\n@@ -1720,17 +1240,19 @@ impl RegionVarBindings {\n \n                     ConstrainRegSubVar(region, _) |\n                     ConstrainVarSubReg(_, region) => {\n-                        state.result.push(SpannedRegion {\n+                        state.result.push(RegionAndOrigin {\n                             region: region,\n-                            span: edge.span\n+                            origin: this.constraints.get_copy(&edge.constraint)\n                         });\n                     }\n+\n+                    ConstrainRegSubReg(*) => {}\n                 }\n             }\n         }\n     }\n \n-    pub fn each_edge(&mut self,\n+    pub fn each_edge(&self,\n                      graph: &Graph,\n                      node_idx: RegionVid,\n                      dir: Direction,", "previous_filename": "src/librustc/middle/typeck/infer/region_inference.rs"}, {"sha": "72178500b54ed2ac41ff76e43a16963fb7f7d302", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -20,6 +20,7 @@ use middle::typeck::infer::InferCtxt;\n use middle::typeck::infer::lattice::CombineFieldsLatticeMethods;\n use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::to_str::InferStr;\n+use middle::typeck::infer::{TypeTrace, Subtype};\n use util::common::{indent, indenter};\n use util::ppaux::bound_region_to_str;\n \n@@ -36,7 +37,7 @@ impl Combine for Sub {\n     fn infcx(&self) -> @mut InferCtxt { self.infcx }\n     fn tag(&self) -> ~str { ~\"sub\" }\n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n-    fn span(&self) -> span { self.span }\n+    fn trace(&self) -> TypeTrace { self.trace }\n \n     fn sub(&self) -> Sub { Sub(**self) }\n     fn lub(&self) -> Lub { Lub(**self) }\n@@ -62,12 +63,8 @@ impl Combine for Sub {\n                self.tag(),\n                a.inf_str(self.infcx),\n                b.inf_str(self.infcx));\n-        do indent {\n-            match self.infcx.region_vars.make_subregion(self.span, a, b) {\n-              Ok(()) => Ok(a),\n-              Err(ref e) => Err((*e))\n-            }\n-        }\n+        self.infcx.region_vars.make_subregion(Subtype(self.trace), a, b);\n+        Ok(a)\n     }\n \n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n@@ -170,7 +167,7 @@ impl Combine for Sub {\n         // region variable.\n         let (a_sig, _) =\n             self.infcx.replace_bound_regions_with_fresh_regions(\n-                self.span, a);\n+                self.trace, a);\n \n         // Second, we instantiate each bound region in the supertype with a\n         // fresh concrete region."}, {"sha": "bbcfc73853a1e00d292ae078b3ec18afb214c4ea", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -263,7 +263,7 @@ pub fn require_same_types(\n       }\n     }\n \n-    match infer::mk_eqty(l_infcx, t1_is_expected, span, t1, t2) {\n+    match infer::mk_eqty(l_infcx, t1_is_expected, infer::Misc(span), t1, t2) {\n         result::Ok(()) => true,\n         result::Err(ref terr) => {\n             l_tcx.sess.span_err(span, msg() + \": \" +"}, {"sha": "628940711453411da3b360e6dd510a1b2f12abaf", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -608,6 +608,12 @@ impl Repr for @ast::pat {\n     }\n }\n \n+impl Repr for ty::bound_region {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        bound_region_ptr_to_str(tcx, *self)\n+    }\n+}\n+\n impl Repr for ty::Region {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         region_to_str(tcx, \"\", false, *self)\n@@ -793,6 +799,19 @@ impl Repr for ty::BuiltinBounds {\n     }\n }\n \n+impl Repr for span {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        tcx.sess.codemap.span_to_str(*self)\n+    }\n+}\n+\n+impl<A:UserString> UserString for @A {\n+    fn user_string(&self, tcx: ctxt) -> ~str {\n+        let this: &A = &**self;\n+        this.user_string(tcx)\n+    }\n+}\n+\n impl UserString for ty::BuiltinBounds {\n     fn user_string(&self, tcx: ctxt) -> ~str {\n         if self.is_empty() { ~\"<no-bounds>\" } else {"}, {"sha": "b00b701191e2ec43eeb4b49a8942ac6ec9560a02", "filename": "src/test/compile-fail/arc-rw-cond-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Farc-rw-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Farc-rw-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-cond-shouldnt-escape.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: reference is not valid outside of its lifetime\n+// error-pattern: lifetime of return value does not outlive the function call\n extern mod extra;\n use extra::arc;\n fn main() {"}, {"sha": "001e6cf922f67e0977168b4e933c6fa50b0be030", "filename": "src/test/compile-fail/arc-rw-state-shouldnt-escape.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Farc-rw-state-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Farc-rw-state-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-state-shouldnt-escape.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -8,14 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: reference is not valid outside of its lifetime\n extern mod extra;\n use extra::arc;\n fn main() {\n     let x = ~arc::RWARC(1);\n-    let mut y = None;\n+    let mut y = None; //~ ERROR lifetime of variable does not enclose its declaration\n     do x.write |one| {\n         y = Some(one);\n     }\n     *y.unwrap() = 2;\n+    //~^ ERROR lifetime of return value does not outlive the function call\n+    //~^^ ERROR dereference of reference outside its lifetime\n }"}, {"sha": "59e899dbbf2ef23dc9b857af11fa84bde3b355d9", "filename": "src/test/compile-fail/arc-rw-write-mode-cond-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-cond-shouldnt-escape.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: reference is not valid outside of its lifetime\n+// error-pattern: lifetime of variable does not enclose its declaration\n extern mod extra;\n use extra::arc;\n fn main() {"}, {"sha": "2599fb4dfa0c7e7c4e66724c65e8aae55ef1618e", "filename": "src/test/compile-fail/arc-rw-write-mode-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: reference is not valid outside of its lifetime\n+// error-pattern: lifetime of variable does not enclose its declaration\n extern mod extra;\n use extra::arc;\n fn main() {"}, {"sha": "4ee824d1d49ad6cd6a6d999018e6603f4ac36305", "filename": "src/test/compile-fail/borrowck-move-by-capture.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -1,6 +1,4 @@\n-extern mod extra;\n-\n-fn main() {\n+pub fn main() {\n     let foo = ~3;\n     let _pfoo = &foo;\n     let _f: @fn() -> int = || *foo + 5;"}, {"sha": "1c6dd0ef9f65717d6c4b62891fa839c01eb89b0b", "filename": "src/test/compile-fail/if-branch-types.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Fif-branch-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Fif-branch-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fif-branch-types.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:mismatched types\n-\n-fn main() { let x = if true { 10i } else { 10u }; }\n+fn main() {\n+    let x = if true { 10i } else { 10u };\n+    //~^ ERROR if and else have incompatible types: expected `int` but found `uint`\n+}"}, {"sha": "33e122867bb3d0e0795748e515344e47b78e04d0", "filename": "src/test/compile-fail/kindck-owned-trait-contains.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -23,13 +23,13 @@ fn main() {\n     // Error results because the type of is inferred to be\n     // @repeat<&'blk int> where blk is the lifetime of the block below.\n \n-    let y = { //~ ERROR reference is not valid\n+    let y = { //~ ERROR lifetime of variable does not enclose its declaration\n         let x: &'blk int = &3;\n         repeater(@x)\n     };\n-    assert!(3 == *(y.get())); //~ ERROR dereference of reference outside its lifetime\n-    //~^ ERROR reference is not valid outside of its lifetime\n-    //~^^ ERROR reference is not valid outside of its lifetime\n-    //~^^^ ERROR reference is not valid outside of its lifetime\n+    assert!(3 == *(y.get()));\n+    //~^ ERROR dereference of reference outside its lifetime\n+    //~^^ ERROR automatically borrowed pointer is not valid at the time of borrow\n+    //~^^^ ERROR lifetime of return value does not outlive the function call\n     //~^^^^ ERROR cannot infer an appropriate lifetime\n }"}, {"sha": "358c61921470fcb917925ca81451a13b31d35073", "filename": "src/test/compile-fail/lub-if.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Flub-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Flub-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flub-if.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we correctly consider the type of `match` to be the LUB\n+// of the various arms, particularly in the case where regions are\n+// involved.\n+\n+pub fn opt_str0<'a>(maybestr: &'a Option<~str>) -> &'a str {\n+    if maybestr.is_none() {\n+        \"(none)\"\n+    } else {\n+        let s: &'a str = *maybestr.get_ref();\n+        s\n+    }\n+}\n+\n+pub fn opt_str1<'a>(maybestr: &'a Option<~str>) -> &'a str {\n+    if maybestr.is_some() {\n+        let s: &'a str = *maybestr.get_ref();\n+        s\n+    } else {\n+        \"(none)\"\n+    }\n+}\n+\n+pub fn opt_str2<'a>(maybestr: &'a Option<~str>) -> &'static str {\n+    if maybestr.is_none() { //~ ERROR mismatched types\n+        \"(none)\"\n+    } else {\n+        let s: &'a str = *maybestr.get_ref();\n+        s\n+    }\n+}\n+\n+pub fn opt_str3<'a>(maybestr: &'a Option<~str>) -> &'static str {\n+    if maybestr.is_some() {  //~ ERROR mismatched types\n+        let s: &'a str = *maybestr.get_ref();\n+        s\n+    } else {\n+        \"(none)\"\n+    }\n+}\n+\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "2a61b72997d1f9cc855faceb3f871e1fed152c3f", "filename": "src/test/compile-fail/lub-match.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Flub-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Flub-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flub-match.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we correctly consider the type of `match` to be the LUB\n+// of the various arms, particularly in the case where regions are\n+// involved.\n+\n+pub fn opt_str0<'a>(maybestr: &'a Option<~str>) -> &'a str {\n+    match *maybestr {\n+        Some(ref s) => {\n+            let s: &'a str = *s;\n+            s\n+        }\n+        None => \"(none)\",\n+    }\n+}\n+\n+pub fn opt_str1<'a>(maybestr: &'a Option<~str>) -> &'a str {\n+    match *maybestr {\n+        None => \"(none)\",\n+        Some(ref s) => {\n+            let s: &'a str = *s;\n+            s\n+        }\n+    }\n+}\n+\n+pub fn opt_str2<'a>(maybestr: &'a Option<~str>) -> &'static str {\n+    match *maybestr { //~ ERROR mismatched types\n+        None => \"(none)\",\n+        Some(ref s) => {\n+            let s: &'a str = *s;\n+            s\n+        }\n+    }\n+}\n+\n+pub fn opt_str3<'a>(maybestr: &'a Option<~str>) -> &'static str {\n+    match *maybestr { //~ ERROR mismatched types\n+        Some(ref s) => {\n+            let s: &'a str = *s;\n+            s\n+        }\n+        None => \"(none)\",\n+    }\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "ab2ac6cc0e5b9e4420042c933e578dd50b5c878a", "filename": "src/test/compile-fail/regions-bounds.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -17,10 +17,12 @@ struct a_class<'self> { x:&'self int }\n \n fn a_fn1<'a,'b>(e: an_enum<'a>) -> an_enum<'b> {\n     return e; //~ ERROR mismatched types: expected `an_enum<'b>` but found `an_enum<'a>`\n+    //~^ ERROR cannot infer an appropriate lifetime\n }\n \n fn a_fn3<'a,'b>(e: a_class<'a>) -> a_class<'b> {\n     return e; //~ ERROR mismatched types: expected `a_class<'b>` but found `a_class<'a>`\n+    //~^ ERROR cannot infer an appropriate lifetime\n }\n \n fn a_fn4<'a,'b>() {"}, {"sha": "305aa68528493f52cc7706ef6ce691e7762ad576", "filename": "src/test/compile-fail/regions-escape-bound-fn-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn-2.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -15,6 +15,6 @@ fn with_int(f: &fn(x: &int)) {\n \n fn main() {\n     let mut x = None;\n-         //~^ ERROR reference is not valid outside of its lifetime\n+         //~^ ERROR lifetime of variable does not enclose its declaration\n     with_int(|y| x = Some(y));\n }"}, {"sha": "5b6dc1b2f4fb48b11db5dba500fd12b01d12ae7d", "filename": "src/test/compile-fail/regions-escape-via-trait-or-not.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -23,7 +23,7 @@ fn with<R:deref>(f: &fn(x: &int) -> R) -> int {\n }\n \n fn return_it() -> int {\n-    with(|o| o) //~ ERROR reference is not valid outside of its lifetime\n+    with(|o| o) //~ ERROR lifetime of function argument does not outlive the function call\n }\n \n fn main() {"}, {"sha": "c2bd64fddafce6d6d2e2e45bb0c2310e264efd54", "filename": "src/test/compile-fail/regions-free-region-ordering-incorrect.rs", "status": "renamed", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-incorrect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-incorrect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-incorrect.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -8,16 +8,23 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Test that free regions ordering only goes one way. That is,\n+// we have `&'a Node<'self, T>`, which implies that `'a <= 'self`,\n+// but not `'self <= 'a`. Hence returning `&self.val` (which has lifetime\n+// `'a`) where `'self` is expected yields an error.\n+//\n+// This test began its life as a test for issue #4325.\n+\n struct Node<'self, T> {\n   val: T,\n   next: Option<&'self Node<'self, T>>\n }\n \n impl<'self, T> Node<'self, T> {\n-  fn get(&self) -> &'self T {\n+  fn get<'a>(&'a self) -> &'self T {\n     match self.next {\n       Some(ref next) => next.get(),\n-      None => &self.val\n+      None => &self.val //~ ERROR cannot infer an appropriate lifetime\n     }\n   }\n }", "previous_filename": "src/test/run-pass/issue-4325.rs"}, {"sha": "488d1f3940d6e6655a1a28348f4616dc5752ed5a", "filename": "src/test/compile-fail/regions-infer-at-fn-not-param.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Fregions-infer-at-fn-not-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Fregions-infer-at-fn-not-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-at-fn-not-param.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -20,7 +20,10 @@ struct not_parameterized2 {\n     g: @fn()\n }\n \n-fn take1(p: parameterized1) -> parameterized1 { p } //~ ERROR mismatched types\n+fn take1(p: parameterized1) -> parameterized1 { p }\n+//~^ ERROR mismatched types\n+//~^^ ERROR cannot infer an appropriate lifetime\n+\n fn take3(p: not_parameterized1) -> not_parameterized1 { p }\n fn take4(p: not_parameterized2) -> not_parameterized2 { p }\n "}, {"sha": "c33ca2dab2ee004ea5b6fa7fc66c4a7be5bb155a", "filename": "src/test/compile-fail/regions-infer-covariance-due-to-arg.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Fregions-infer-covariance-due-to-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Fregions-infer-covariance-due-to-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-covariance-due-to-arg.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -22,6 +22,7 @@ fn to_same_lifetime<'r>(bi: covariant<'r>) {\n \n fn to_shorter_lifetime<'r>(bi: covariant<'r>) {\n     let bj: covariant<'blk> = bi; //~ ERROR mismatched types\n+    //~^ ERROR cannot infer an appropriate lifetime\n }\n \n fn to_longer_lifetime<'r>(bi: covariant<'r>) -> covariant<'static> {"}, {"sha": "fa853b82d9ebd05badc774ea2ec771542ff4c419", "filename": "src/test/compile-fail/regions-infer-not-param.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Fregions-infer-not-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Fregions-infer-not-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-not-param.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -23,6 +23,11 @@ struct indirect2<'self> {\n }\n \n fn take_direct(p: direct) -> direct { p } //~ ERROR mismatched types\n+//~^ ERROR cannot infer an appropriate lifetime\n+\n fn take_indirect1(p: indirect1) -> indirect1 { p }\n+\n fn take_indirect2(p: indirect2) -> indirect2 { p } //~ ERROR mismatched types\n+//~^ ERROR cannot infer an appropriate lifetime\n+\n fn main() {}"}, {"sha": "0b4aa44010bdc35fa16666f1b017adc7408fdc5d", "filename": "src/test/compile-fail/regions-infer-paramd-indirect.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -30,6 +30,7 @@ impl<'self> set_f<'self> for c<'self> {\n \n     fn set_f_bad(&self, b: @b) {\n         self.f = b; //~ ERROR mismatched types: expected `@@&'self int` but found `@@&int`\n+        //~^ ERROR cannot infer an appropriate lifetime\n     }\n }\n "}, {"sha": "244e9cc06a1acd54f52a3fb7a68286087f809e90", "filename": "src/test/compile-fail/regions-nested-fns.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -22,6 +22,7 @@ fn nested<'x>(x: &'x int) {\n \n     ignore::<&fn<'z>(&'z int) -> &'z int>(|z| {\n         if false { return x; }  //~ ERROR mismatched types\n+        //~^ ERROR cannot infer an appropriate lifetime\n         if false { return ay; }\n         return z;\n     });"}, {"sha": "542711687190e23c8ad5292700cca0a5dd99d9d6", "filename": "src/test/compile-fail/regions-ret-borrowed-1.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -18,6 +18,8 @@ fn with<'a, R>(f: &fn(x: &'a int) -> R) -> R {\n \n fn return_it<'a>() -> &'a int {\n     with(|o| o) //~ ERROR mismatched types\n+        //~^ ERROR lifetime of return value does not outlive the function call\n+        //~^^ ERROR cannot infer an appropriate lifetime\n }\n \n fn main() {"}, {"sha": "4d646aa364a40c677a4e32d9b6eef8966a6ddd22", "filename": "src/test/compile-fail/regions-ret-borrowed.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -21,6 +21,8 @@ fn with<R>(f: &fn(x: &int) -> R) -> R {\n \n fn return_it() -> &int {\n     with(|o| o) //~ ERROR mismatched types\n+        //~^ ERROR lifetime of return value does not outlive the function call\n+        //~^^ ERROR cannot infer an appropriate lifetime\n }\n \n fn main() {"}, {"sha": "2006027e79707009756eb3180cb1f79834ebb273", "filename": "src/test/compile-fail/sync-cond-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Fsync-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Fsync-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-cond-shouldnt-escape.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: reference is not valid outside of its lifetime\n+// error-pattern: lifetime of variable does not enclose its declaration\n extern mod extra;\n use extra::sync;\n "}, {"sha": "4108201f911592a588550117bca436e3cfde88c1", "filename": "src/test/compile-fail/sync-rwlock-cond-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-cond-shouldnt-escape.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: reference is not valid outside of its lifetime\n+// error-pattern: lifetime of method receiver does not outlive the method call\n extern mod extra;\n use extra::sync;\n fn main() {"}, {"sha": "43b4d9aabb87678ad088b054dda0c85134947f3f", "filename": "src/test/compile-fail/sync-rwlock-write-mode-cond-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-cond-shouldnt-escape.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: reference is not valid outside of its lifetime\n+// error-pattern: lifetime of variable does not enclose its declaration\n extern mod extra;\n use extra::sync;\n fn main() {"}, {"sha": "15af7be5246872b72aec7d978b7dd60f156682af", "filename": "src/test/compile-fail/sync-rwlock-write-mode-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab34864a304fa364dc91bf16988e272e93de8d62/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-shouldnt-escape.rs?ref=ab34864a304fa364dc91bf16988e272e93de8d62", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: reference is not valid outside of its lifetime\n+// error-pattern: lifetime of variable does not enclose its declaration\n extern mod extra;\n use extra::sync;\n fn main() {"}]}