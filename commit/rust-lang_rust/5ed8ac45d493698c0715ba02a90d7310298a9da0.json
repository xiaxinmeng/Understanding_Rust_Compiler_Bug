{"sha": "5ed8ac45d493698c0715ba02a90d7310298a9da0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlZDhhYzQ1ZDQ5MzY5OGMwNzE1YmEwMmE5MGQ3MzEwMjk4YTlkYTA=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-10-24T20:39:57Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-24T20:39:57Z"}, "message": "Rollup merge of #78272 - lcnr:abstract-const-unused-node, r=oli-obk\n\nconst_evaluatable_checked: deal with unused nodes + div\n\nr? @oli-obk", "tree": {"sha": "440efb3b88d2e67bba6bd06cd8bf7ce7dcb730d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/440efb3b88d2e67bba6bd06cd8bf7ce7dcb730d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ed8ac45d493698c0715ba02a90d7310298a9da0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJflJEdCRBK7hj4Ov3rIwAAdHIIAHEgYy8UrGJ8g2eUQE04fA1Z\nL6Pp5R5AloRTmZOMMNQTB7h1D2yRZHf80wAMGwD8jyhHlQvchp5BX82flZDBz6ch\ndGX8jT7/AlOea6jKfl/4ampdjaxnB2C0sWyu7yWwqKn2HSow2skHpUkEbeDTN+LR\nZorNskR2D437smDBvsT06aWPsADojDxVjUphvojOctAzml5FJbiPPKPikL5r2aPt\nv6dy9vAw5jOxzi8Rv3wrIgGXoT+qFo14pQfYDTteUyZ74VHeZ2dAWSiPryRUsnsf\nvZ3xLhYoFH/pNREAYDwtRzZtvT+1BjuMMoIK0qUaKBfrOUKghg7NxaZ0qiGaVMY=\n=sVyl\n-----END PGP SIGNATURE-----\n", "payload": "tree 440efb3b88d2e67bba6bd06cd8bf7ce7dcb730d2\nparent 597b4c5bb40e2c1e55cbd0aec2cf258ec8de6b70\nparent 47cb871f14b48653df2f42082cf93b6c16e2b2f1\nauthor Jonas Schievink <jonasschievink@gmail.com> 1603571997 +0200\ncommitter GitHub <noreply@github.com> 1603571997 +0200\n\nRollup merge of #78272 - lcnr:abstract-const-unused-node, r=oli-obk\n\nconst_evaluatable_checked: deal with unused nodes + div\n\nr? @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ed8ac45d493698c0715ba02a90d7310298a9da0", "html_url": "https://github.com/rust-lang/rust/commit/5ed8ac45d493698c0715ba02a90d7310298a9da0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ed8ac45d493698c0715ba02a90d7310298a9da0/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "597b4c5bb40e2c1e55cbd0aec2cf258ec8de6b70", "url": "https://api.github.com/repos/rust-lang/rust/commits/597b4c5bb40e2c1e55cbd0aec2cf258ec8de6b70", "html_url": "https://github.com/rust-lang/rust/commit/597b4c5bb40e2c1e55cbd0aec2cf258ec8de6b70"}, {"sha": "47cb871f14b48653df2f42082cf93b6c16e2b2f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/47cb871f14b48653df2f42082cf93b6c16e2b2f1", "html_url": "https://github.com/rust-lang/rust/commit/47cb871f14b48653df2f42082cf93b6c16e2b2f1"}], "stats": {"total": 153, "additions": 132, "deletions": 21}, "files": [{"sha": "c79b2624f8cb0256d003fd53ae9e4ede270c1c34", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 64, "deletions": 21, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/5ed8ac45d493698c0715ba02a90d7310298a9da0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ed8ac45d493698c0715ba02a90d7310298a9da0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=5ed8ac45d493698c0715ba02a90d7310298a9da0", "patch": "@@ -223,11 +223,23 @@ impl AbstractConst<'tcx> {\n     }\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+struct WorkNode<'tcx> {\n+    node: Node<'tcx>,\n+    span: Span,\n+    used: bool,\n+}\n+\n struct AbstractConstBuilder<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     body: &'a mir::Body<'tcx>,\n     /// The current WIP node tree.\n-    nodes: IndexVec<NodeId, Node<'tcx>>,\n+    ///\n+    /// We require all nodes to be used in the final abstract const,\n+    /// so we store this here. Note that we also consider nodes as used\n+    /// if they are mentioned in an assert, so some used nodes are never\n+    /// actually reachable by walking the [`AbstractConst`].\n+    nodes: IndexVec<NodeId, WorkNode<'tcx>>,\n     locals: IndexVec<mir::Local, NodeId>,\n     /// We only allow field accesses if they access\n     /// the result of a checked operation.\n@@ -274,6 +286,27 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n         Ok(Some(builder))\n     }\n \n+    fn add_node(&mut self, node: Node<'tcx>, span: Span) -> NodeId {\n+        // Mark used nodes.\n+        match node {\n+            Node::Leaf(_) => (),\n+            Node::Binop(_, lhs, rhs) => {\n+                self.nodes[lhs].used = true;\n+                self.nodes[rhs].used = true;\n+            }\n+            Node::UnaryOp(_, input) => {\n+                self.nodes[input].used = true;\n+            }\n+            Node::FunctionCall(func, nodes) => {\n+                self.nodes[func].used = true;\n+                nodes.iter().for_each(|&n| self.nodes[n].used = true);\n+            }\n+        }\n+\n+        // Nodes start as unused.\n+        self.nodes.push(WorkNode { node, span, used: false })\n+    }\n+\n     fn place_to_local(\n         &mut self,\n         span: Span,\n@@ -311,7 +344,7 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                 let local = self.place_to_local(span, p)?;\n                 Ok(self.locals[local])\n             }\n-            mir::Operand::Constant(ct) => Ok(self.nodes.push(Node::Leaf(ct.literal))),\n+            mir::Operand::Constant(ct) => Ok(self.add_node(Node::Leaf(ct.literal), span)),\n         }\n     }\n \n@@ -336,38 +369,38 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n \n     fn build_statement(&mut self, stmt: &mir::Statement<'tcx>) -> Result<(), ErrorReported> {\n         debug!(\"AbstractConstBuilder: stmt={:?}\", stmt);\n+        let span = stmt.source_info.span;\n         match stmt.kind {\n             StatementKind::Assign(box (ref place, ref rvalue)) => {\n-                let local = self.place_to_local(stmt.source_info.span, place)?;\n+                let local = self.place_to_local(span, place)?;\n                 match *rvalue {\n                     Rvalue::Use(ref operand) => {\n-                        self.locals[local] =\n-                            self.operand_to_node(stmt.source_info.span, operand)?;\n+                        self.locals[local] = self.operand_to_node(span, operand)?;\n                         Ok(())\n                     }\n                     Rvalue::BinaryOp(op, ref lhs, ref rhs) if Self::check_binop(op) => {\n-                        let lhs = self.operand_to_node(stmt.source_info.span, lhs)?;\n-                        let rhs = self.operand_to_node(stmt.source_info.span, rhs)?;\n-                        self.locals[local] = self.nodes.push(Node::Binop(op, lhs, rhs));\n+                        let lhs = self.operand_to_node(span, lhs)?;\n+                        let rhs = self.operand_to_node(span, rhs)?;\n+                        self.locals[local] = self.add_node(Node::Binop(op, lhs, rhs), span);\n                         if op.is_checkable() {\n                             bug!(\"unexpected unchecked checkable binary operation\");\n                         } else {\n                             Ok(())\n                         }\n                     }\n                     Rvalue::CheckedBinaryOp(op, ref lhs, ref rhs) if Self::check_binop(op) => {\n-                        let lhs = self.operand_to_node(stmt.source_info.span, lhs)?;\n-                        let rhs = self.operand_to_node(stmt.source_info.span, rhs)?;\n-                        self.locals[local] = self.nodes.push(Node::Binop(op, lhs, rhs));\n+                        let lhs = self.operand_to_node(span, lhs)?;\n+                        let rhs = self.operand_to_node(span, rhs)?;\n+                        self.locals[local] = self.add_node(Node::Binop(op, lhs, rhs), span);\n                         self.checked_op_locals.insert(local);\n                         Ok(())\n                     }\n                     Rvalue::UnaryOp(op, ref operand) if Self::check_unop(op) => {\n-                        let operand = self.operand_to_node(stmt.source_info.span, operand)?;\n-                        self.locals[local] = self.nodes.push(Node::UnaryOp(op, operand));\n+                        let operand = self.operand_to_node(span, operand)?;\n+                        self.locals[local] = self.add_node(Node::UnaryOp(op, operand), span);\n                         Ok(())\n                     }\n-                    _ => self.error(Some(stmt.source_info.span), \"unsupported rvalue\")?,\n+                    _ => self.error(Some(span), \"unsupported rvalue\")?,\n                 }\n             }\n             // These are not actually relevant for us here, so we can ignore them.\n@@ -415,13 +448,9 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                         .map(|arg| self.operand_to_node(terminator.source_info.span, arg))\n                         .collect::<Result<Vec<NodeId>, _>>()?,\n                 );\n-                self.locals[local] = self.nodes.push(Node::FunctionCall(func, args));\n+                self.locals[local] = self.add_node(Node::FunctionCall(func, args), fn_span);\n                 Ok(Some(target))\n             }\n-            // We only allow asserts for checked operations.\n-            //\n-            // These asserts seem to all have the form `!_local.0` so\n-            // we only allow exactly that.\n             TerminatorKind::Assert { ref cond, expected: false, target, .. } => {\n                 let p = match cond {\n                     mir::Operand::Copy(p) | mir::Operand::Move(p) => p,\n@@ -430,7 +459,15 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n \n                 const ONE_FIELD: mir::Field = mir::Field::from_usize(1);\n                 debug!(\"proj: {:?}\", p.projection);\n-                if let &[mir::ProjectionElem::Field(ONE_FIELD, _)] = p.projection.as_ref() {\n+                if let Some(p) = p.as_local() {\n+                    debug_assert!(!self.checked_op_locals.contains(p));\n+                    // Mark locals directly used in asserts as used.\n+                    //\n+                    // This is needed because division does not use `CheckedBinop` but instead\n+                    // adds an explicit assert for `divisor != 0`.\n+                    self.nodes[self.locals[p]].used = true;\n+                    return Ok(Some(target));\n+                } else if let &[mir::ProjectionElem::Field(ONE_FIELD, _)] = p.projection.as_ref() {\n                     // Only allow asserts checking the result of a checked operation.\n                     if self.checked_op_locals.contains(p.local) {\n                         return Ok(Some(target));\n@@ -457,7 +494,13 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n             if let Some(next) = self.build_terminator(block.terminator())? {\n                 block = &self.body.basic_blocks()[next];\n             } else {\n-                return Ok(self.tcx.arena.alloc_from_iter(self.nodes));\n+                assert_eq!(self.locals[mir::RETURN_PLACE], self.nodes.last().unwrap());\n+                self.nodes[self.locals[mir::RETURN_PLACE]].used = true;\n+                if let Some(&unused) = self.nodes.iter().find(|n| !n.used) {\n+                    self.error(Some(unused.span), \"dead code\")?;\n+                }\n+\n+                return Ok(self.tcx.arena.alloc_from_iter(self.nodes.into_iter().map(|n| n.node)));\n             }\n         }\n     }"}, {"sha": "71a5f2d3472013d457b6b623159c1313c5266c49", "filename": "src/test/ui/const-generics/const_evaluatable_checked/division.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5ed8ac45d493698c0715ba02a90d7310298a9da0/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fdivision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ed8ac45d493698c0715ba02a90d7310298a9da0/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fdivision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fdivision.rs?ref=5ed8ac45d493698c0715ba02a90d7310298a9da0", "patch": "@@ -0,0 +1,11 @@\n+// run-pass\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+\n+fn with_bound<const N: usize>() where [u8; N / 2]: Sized {\n+    let _: [u8; N / 2] = [0; N / 2];\n+}\n+\n+fn main() {\n+    with_bound::<4>();\n+}"}, {"sha": "9c603c57a4818e16dc127e89c07702a29b60b625", "filename": "src/test/ui/const-generics/const_evaluatable_checked/unused_expr.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5ed8ac45d493698c0715ba02a90d7310298a9da0/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Funused_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ed8ac45d493698c0715ba02a90d7310298a9da0/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Funused_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Funused_expr.rs?ref=5ed8ac45d493698c0715ba02a90d7310298a9da0", "patch": "@@ -0,0 +1,25 @@\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+\n+fn add<const N: usize>() -> [u8; { N + 1; 5 }] {\n+    //~^ ERROR overly complex generic constant\n+    todo!()\n+}\n+\n+fn div<const N: usize>() -> [u8; { N / 1; 5 }] {\n+    //~^ ERROR overly complex generic constant\n+    todo!()\n+}\n+\n+const fn foo(n: usize) {}\n+\n+fn fn_call<const N: usize>() -> [u8; { foo(N); 5 }] {\n+    //~^ ERROR overly complex generic constant\n+    todo!()\n+}\n+\n+fn main() {\n+    add::<12>();\n+    div::<9>();\n+    fn_call::<14>();\n+}"}, {"sha": "1687dbbcbe3f8c3fedef497409a5aec01dfb0586", "filename": "src/test/ui/const-generics/const_evaluatable_checked/unused_expr.stderr", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5ed8ac45d493698c0715ba02a90d7310298a9da0/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Funused_expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ed8ac45d493698c0715ba02a90d7310298a9da0/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Funused_expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Funused_expr.stderr?ref=5ed8ac45d493698c0715ba02a90d7310298a9da0", "patch": "@@ -0,0 +1,32 @@\n+error: overly complex generic constant\n+  --> $DIR/unused_expr.rs:4:34\n+   |\n+LL | fn add<const N: usize>() -> [u8; { N + 1; 5 }] {\n+   |                                  ^^-----^^^^^\n+   |                                    |\n+   |                                    dead code\n+   |\n+   = help: consider moving this anonymous constant into a `const` function\n+\n+error: overly complex generic constant\n+  --> $DIR/unused_expr.rs:9:34\n+   |\n+LL | fn div<const N: usize>() -> [u8; { N / 1; 5 }] {\n+   |                                  ^^-----^^^^^\n+   |                                    |\n+   |                                    dead code\n+   |\n+   = help: consider moving this anonymous constant into a `const` function\n+\n+error: overly complex generic constant\n+  --> $DIR/unused_expr.rs:16:38\n+   |\n+LL | fn fn_call<const N: usize>() -> [u8; { foo(N); 5 }] {\n+   |                                      ^^------^^^^^\n+   |                                        |\n+   |                                        dead code\n+   |\n+   = help: consider moving this anonymous constant into a `const` function\n+\n+error: aborting due to 3 previous errors\n+"}]}