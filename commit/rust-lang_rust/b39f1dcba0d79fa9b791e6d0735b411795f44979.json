{"sha": "b39f1dcba0d79fa9b791e6d0735b411795f44979", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzOWYxZGNiYTBkNzlmYTliNzkxZTZkMDczNWI0MTE3OTVmNDQ5Nzk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-11-04T19:22:32Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-11-06T21:37:55Z"}, "message": "Remove rlibc from the distribution\n\nTo make progress on #18585 we're paring down the distribution to theoretically\n\"only libstd\", and this commit makes progress on this by removing the rlibc\ncrate from the distribution.\n\nThe crate has now been moved into an external cargo package located in the rust\nlang organization [1]. This is a breaking change due to this removal, and\nexisting crates depending on `rlibc` should use the Cargo crate instead.\n\n[1]: https://github.com/rust-lang/rlibc\n\n[breaking-change]\ncc #18585", "tree": {"sha": "b03d59f97db96e06e431a9aca101d153a6a4e9b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b03d59f97db96e06e431a9aca101d153a6a4e9b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b39f1dcba0d79fa9b791e6d0735b411795f44979", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b39f1dcba0d79fa9b791e6d0735b411795f44979", "html_url": "https://github.com/rust-lang/rust/commit/b39f1dcba0d79fa9b791e6d0735b411795f44979", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b39f1dcba0d79fa9b791e6d0735b411795f44979/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ed288edb27fc83b15a549af69c82b5bb4f8ac1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ed288edb27fc83b15a549af69c82b5bb4f8ac1e", "html_url": "https://github.com/rust-lang/rust/commit/8ed288edb27fc83b15a549af69c82b5bb4f8ac1e"}], "stats": {"total": 206, "additions": 1, "deletions": 205}, "files": [{"sha": "771c1821e3802b44d1ce1e332a0dc079a92f2dab", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b39f1dcba0d79fa9b791e6d0735b411795f44979/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b39f1dcba0d79fa9b791e6d0735b411795f44979/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=b39f1dcba0d79fa9b791e6d0735b411795f44979", "patch": "@@ -51,7 +51,7 @@\n \n TARGET_CRATES := libc std green native flate arena term \\\n                  serialize sync getopts collections test time rand \\\n-                 log regex graphviz core rbml rlibc alloc rustrt \\\n+                 log regex graphviz core rbml alloc rustrt \\\n                  unicode\n HOST_CRATES := syntax rustc rustdoc regex_macros fmt_macros \\\n \t       rustc_llvm rustc_back\n@@ -60,7 +60,6 @@ TOOLS := compiletest rustdoc rustc\n \n DEPS_core :=\n DEPS_libc := core\n-DEPS_rlibc := core\n DEPS_unicode := core\n DEPS_alloc := core libc native:jemalloc\n DEPS_rustrt := alloc core libc collections native:rustrt_native\n@@ -104,7 +103,6 @@ TOOL_SOURCE_rustc := $(S)src/driver/driver.rs\n \n ONLY_RLIB_core := 1\n ONLY_RLIB_libc := 1\n-ONLY_RLIB_rlibc := 1\n ONLY_RLIB_alloc := 1\n ONLY_RLIB_rand := 1\n ONLY_RLIB_collections := 1"}, {"sha": "128243187757aa9bd8443e93061d14712b94fd2c", "filename": "src/librlibc/lib.rs", "status": "removed", "additions": 0, "deletions": 202, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/8ed288edb27fc83b15a549af69c82b5bb4f8ac1e/src%2Flibrlibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed288edb27fc83b15a549af69c82b5bb4f8ac1e/src%2Flibrlibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrlibc%2Flib.rs?ref=8ed288edb27fc83b15a549af69c82b5bb4f8ac1e", "patch": "@@ -1,202 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A bare-metal library supplying functions rustc may lower code to\n-//!\n-//! This library is not intended for general use, and is superseded by a system\n-//! libc if one is available. In a freestanding context, however, common\n-//! functions such as memset, memcpy, etc are not implemented. This library\n-//! provides an implementation of these functions which are either required by\n-//! libcore or called by rustc implicitly.\n-//!\n-//! This library is never included by default, and must be manually included if\n-//! necessary. It is an error to include this library when also linking with\n-//! the system libc library.\n-\n-#![crate_name = \"rlibc\"]\n-#![experimental]\n-#![license = \"MIT/ASL2\"]\n-#![crate_type = \"rlib\"]\n-#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n-       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n-\n-#![feature(import_shadowing, intrinsics, phase)]\n-#![no_std]\n-\n-// This library defines the builtin functions, so it would be a shame for\n-// LLVM to optimize these function calls to themselves!\n-#![no_builtins]\n-\n-#[phase(plugin, link)] extern crate core;\n-\n-#[cfg(test)] extern crate native;\n-#[cfg(test)] extern crate test;\n-\n-#[cfg(test)] #[phase(plugin, link)] extern crate std;\n-\n-// Require the offset intrinsics for LLVM to properly optimize the\n-// implementations below. If pointer arithmetic is done through integers the\n-// optimizations start to break down.\n-extern \"rust-intrinsic\" {\n-    fn offset<T>(dst: *const T, offset: int) -> *const T;\n-}\n-\n-#[no_mangle]\n-pub unsafe extern \"C\" fn memcpy(dest: *mut u8, src: *const u8,\n-                                n: uint) -> *mut u8 {\n-    let mut i = 0;\n-    while i < n {\n-        *(offset(dest as *const u8, i as int) as *mut u8) =\n-            *offset(src, i as int);\n-        i += 1;\n-    }\n-    return dest;\n-}\n-\n-#[no_mangle]\n-pub unsafe extern \"C\" fn memmove(dest: *mut u8, src: *const u8,\n-                                 n: uint) -> *mut u8 {\n-    if src < dest as *const u8 { // copy from end\n-        let mut i = n;\n-        while i != 0 {\n-            i -= 1;\n-            *(offset(dest as *const u8, i as int) as *mut u8) =\n-                *offset(src, i as int);\n-        }\n-    } else { // copy from beginning\n-        let mut i = 0;\n-        while i < n {\n-            *(offset(dest as *const u8, i as int) as *mut u8) =\n-                *offset(src, i as int);\n-            i += 1;\n-        }\n-    }\n-    return dest;\n-}\n-\n-#[no_mangle]\n-pub unsafe extern \"C\" fn memset(s: *mut u8, c: i32, n: uint) -> *mut u8 {\n-    let mut i = 0;\n-    while i < n {\n-        *(offset(s as *const u8, i as int) as *mut u8) = c as u8;\n-        i += 1;\n-    }\n-    return s;\n-}\n-\n-#[no_mangle]\n-pub unsafe extern \"C\" fn memcmp(s1: *const u8, s2: *const u8, n: uint) -> i32 {\n-    let mut i = 0;\n-    while i < n {\n-        let a = *offset(s1, i as int);\n-        let b = *offset(s2, i as int);\n-        if a != b {\n-            return a as i32 - b as i32\n-        }\n-        i += 1;\n-    }\n-    return 0;\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use core::str::StrPrelude;\n-    use core::slice::{SlicePrelude};\n-\n-    use super::{memcmp, memset, memcpy, memmove};\n-\n-    #[test]\n-    fn memcmp_single_byte_pointers() {\n-        unsafe {\n-            assert_eq!(memcmp(&0xFAu8, &0xFAu8, 1), 0x00);\n-            assert!(memcmp(&0xEFu8, &0xFEu8, 1) < 0x00);\n-        }\n-    }\n-\n-    #[test]\n-    fn memcmp_strings() {\n-        {\n-            let (x, z) = (\"Hello!\", \"Good Bye.\");\n-            let l = x.len();\n-            unsafe {\n-                assert_eq!(memcmp(x.as_ptr(), x.as_ptr(), l), 0);\n-                assert!(memcmp(x.as_ptr(), z.as_ptr(), l) > 0);\n-                assert!(memcmp(z.as_ptr(), x.as_ptr(), l) < 0);\n-            }\n-        }\n-        {\n-            let (x, z) = (\"hey!\", \"hey.\");\n-            let l = x.len();\n-            unsafe {\n-                assert!(memcmp(x.as_ptr(), z.as_ptr(), l) < 0);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn memset_single_byte_pointers() {\n-        let mut x: u8 = 0xFF;\n-        unsafe {\n-            memset(&mut x, 0xAA, 1);\n-            assert_eq!(x, 0xAA);\n-            memset(&mut x, 0x00, 1);\n-            assert_eq!(x, 0x00);\n-            x = 0x01;\n-            memset(&mut x, 0x12, 0);\n-            assert_eq!(x, 0x01);\n-        }\n-    }\n-\n-    #[test]\n-    fn memset_array() {\n-        let mut buffer = [b'X', .. 100];\n-        unsafe {\n-            memset(buffer.as_mut_ptr(), b'#' as i32, buffer.len());\n-        }\n-        for byte in buffer.iter() { assert_eq!(*byte, b'#'); }\n-    }\n-\n-    #[test]\n-    fn memcpy_and_memcmp_arrays() {\n-        let (src, mut dst) = ([b'X', .. 100], [b'Y', .. 100]);\n-        unsafe {\n-            assert!(memcmp(src.as_ptr(), dst.as_ptr(), 100) != 0);\n-            let _ = memcpy(dst.as_mut_ptr(), src.as_ptr(), 100);\n-            assert_eq!(memcmp(src.as_ptr(), dst.as_ptr(), 100), 0);\n-        }\n-    }\n-\n-    #[test]\n-    fn memmove_overlapping() {\n-        {\n-            let mut buffer = [ b'0', b'1', b'2', b'3', b'4', b'5', b'6', b'7', b'8', b'9' ];\n-            unsafe {\n-                memmove(&mut buffer[4], &buffer[0], 6);\n-                let mut i = 0;\n-                for byte in b\"0123012345\".iter() {\n-                    assert_eq!(buffer[i], *byte);\n-                    i += 1;\n-                }\n-            }\n-        }\n-        {\n-            let mut buffer = [ b'0', b'1', b'2', b'3', b'4', b'5', b'6', b'7', b'8', b'9' ];\n-            unsafe {\n-                memmove(&mut buffer[0], &buffer[4], 6);\n-                let mut i = 0;\n-                for byte in b\"4567896789\".iter() {\n-                    assert_eq!(buffer[i], *byte);\n-                    i += 1;\n-                }\n-            }\n-        }\n-    }\n-}"}]}