{"sha": "9eb913a7e227e4c11ca0c2c7d8fd7ca22ed9c466", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllYjkxM2E3ZTIyN2U0YzExY2EwYzJjN2Q4ZmQ3Y2EyMmVkOWM0NjY=", "commit": {"author": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2020-02-09T05:00:49Z"}, "committer": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2020-02-09T12:02:27Z"}, "message": "Fix error E0460 when compiled on Rustc repo", "tree": {"sha": "9abdef00305487d9d95dbf215737fc0559aa5780", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9abdef00305487d9d95dbf215737fc0559aa5780"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9eb913a7e227e4c11ca0c2c7d8fd7ca22ed9c466", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9eb913a7e227e4c11ca0c2c7d8fd7ca22ed9c466", "html_url": "https://github.com/rust-lang/rust/commit/9eb913a7e227e4c11ca0c2c7d8fd7ca22ed9c466", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9eb913a7e227e4c11ca0c2c7d8fd7ca22ed9c466/comments", "author": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d9ef4e9f9363eb40064b8d2cc8f7743d8ecc873", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d9ef4e9f9363eb40064b8d2cc8f7743d8ecc873", "html_url": "https://github.com/rust-lang/rust/commit/2d9ef4e9f9363eb40064b8d2cc8f7743d8ecc873"}], "stats": {"total": 167, "additions": 78, "deletions": 89}, "files": [{"sha": "9973d5b844342b9c2ac810a75aa7838ab2a743fd", "filename": "tests/cargo/mod.rs", "status": "modified", "additions": 14, "deletions": 60, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/9eb913a7e227e4c11ca0c2c7d8fd7ca22ed9c466/tests%2Fcargo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb913a7e227e4c11ca0c2c7d8fd7ca22ed9c466/tests%2Fcargo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcargo%2Fmod.rs?ref=9eb913a7e227e4c11ca0c2c7d8fd7ca22ed9c466", "patch": "@@ -1,75 +1,29 @@\n-use cargo_metadata::{Message::CompilerArtifact, MetadataCommand};\n+use lazy_static::lazy_static;\n use std::env;\n-use std::ffi::OsStr;\n-use std::mem;\n use std::path::PathBuf;\n-use std::process::Command;\n \n-pub struct BuildInfo {\n-    cargo_target_dir: PathBuf,\n-}\n-\n-impl BuildInfo {\n-    pub fn new() -> Self {\n-        let data = MetadataCommand::new().exec().unwrap();\n-        Self {\n-            cargo_target_dir: data.target_directory,\n+lazy_static! {\n+    pub static ref CARGO_TARGET_DIR: PathBuf = {\n+        match env::var_os(\"CARGO_TARGET_DIR\") {\n+            Some(v) => v.into(),\n+            None => \"target\".into(),\n         }\n-    }\n-\n-    pub fn host_lib(&self) -> PathBuf {\n-        if let Some(path) = option_env!(\"HOST_LIBS\") {\n-            PathBuf::from(path)\n-        } else {\n-            self.cargo_target_dir.join(env!(\"PROFILE\"))\n-        }\n-    }\n-\n-    pub fn target_lib(&self) -> PathBuf {\n+    };\n+    pub static ref TARGET_LIB: PathBuf = {\n         if let Some(path) = option_env!(\"TARGET_LIBS\") {\n             path.into()\n         } else {\n-            let mut dir = self.cargo_target_dir.clone();\n+            let mut dir = CARGO_TARGET_DIR.clone();\n             if let Some(target) = env::var_os(\"CARGO_BUILD_TARGET\") {\n                 dir.push(target);\n             }\n             dir.push(env!(\"PROFILE\"));\n             dir\n         }\n-    }\n-\n-    pub fn clippy_driver_path(&self) -> PathBuf {\n-        if let Some(path) = option_env!(\"CLIPPY_DRIVER_PATH\") {\n-            PathBuf::from(path)\n-        } else {\n-            self.target_lib().join(\"clippy-driver\")\n-        }\n-    }\n-\n-    // When we'll want to use `extern crate ..` for a dependency that is used\n-    // both by the crate and the compiler itself, we can't simply pass -L flags\n-    // as we'll get a duplicate matching versions. Instead, disambiguate with\n-    // `--extern dep=path`.\n-    // See https://github.com/rust-lang/rust-clippy/issues/4015.\n-    pub fn third_party_crates() -> Vec<(&'static str, PathBuf)> {\n-        const THIRD_PARTY_CRATES: [&str; 4] = [\"serde\", \"serde_derive\", \"regex\", \"clippy_lints\"];\n-        let cargo = env::var_os(\"CARGO\");\n-        let cargo = cargo.as_deref().unwrap_or_else(|| OsStr::new(\"cargo\"));\n-        let output = Command::new(cargo)\n-            .arg(\"build\")\n-            .arg(\"--test=compile-test\")\n-            .arg(\"--message-format=json\")\n-            .output()\n-            .unwrap();\n+    };\n+}\n \n-        let mut crates = Vec::with_capacity(THIRD_PARTY_CRATES.len());\n-        for message in cargo_metadata::parse_messages(output.stdout.as_slice()) {\n-            if let CompilerArtifact(mut artifact) = message.unwrap() {\n-                if let Some(&krate) = THIRD_PARTY_CRATES.iter().find(|&&krate| krate == artifact.target.name) {\n-                    crates.push((krate, mem::take(&mut artifact.filenames[0])));\n-                }\n-            }\n-        }\n-        crates\n-    }\n+#[must_use]\n+pub fn is_rustc_test_suite() -> bool {\n+    option_env!(\"RUSTC_TEST_SUITE\").is_some()\n }"}, {"sha": "de2cf6d7873f8dac5276c3768531eaeb343a0661", "filename": "tests/compile-test.rs", "status": "modified", "additions": 58, "deletions": 22, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/9eb913a7e227e4c11ca0c2c7d8fd7ca22ed9c466/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb913a7e227e4c11ca0c2c7d8fd7ca22ed9c466/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=9eb913a7e227e4c11ca0c2c7d8fd7ca22ed9c466", "patch": "@@ -1,4 +1,4 @@\n-#![feature(test)]\n+#![feature(test)] // compiletest_rs requires this attribute\n \n use compiletest_rs as compiletest;\n use compiletest_rs::common::Mode as TestMode;\n@@ -11,51 +11,87 @@ use std::path::{Path, PathBuf};\n \n mod cargo;\n \n-#[must_use]\n-fn rustc_test_suite() -> Option<PathBuf> {\n-    option_env!(\"RUSTC_TEST_SUITE\").map(PathBuf::from)\n+fn host_lib() -> PathBuf {\n+    if let Some(path) = option_env!(\"HOST_LIBS\") {\n+        PathBuf::from(path)\n+    } else {\n+        cargo::CARGO_TARGET_DIR.join(env!(\"PROFILE\"))\n+    }\n }\n \n-#[must_use]\n-fn rustc_lib_path() -> PathBuf {\n-    option_env!(\"RUSTC_LIB_PATH\").unwrap().into()\n+fn clippy_driver_path() -> PathBuf {\n+    if let Some(path) = option_env!(\"CLIPPY_DRIVER_PATH\") {\n+        PathBuf::from(path)\n+    } else {\n+        cargo::TARGET_LIB.join(\"clippy-driver\")\n+    }\n+}\n+\n+// When we'll want to use `extern crate ..` for a dependency that is used\n+// both by the crate and the compiler itself, we can't simply pass -L flags\n+// as we'll get a duplicate matching versions. Instead, disambiguate with\n+// `--extern dep=path`.\n+// See https://github.com/rust-lang/rust-clippy/issues/4015.\n+//\n+// FIXME: We cannot use `cargo build --message-format=json` to resolve to dependency files.\n+//        Because it would force-rebuild if the options passed to `build` command is not the same\n+//        as what we manually pass to `cargo` invocation\n+fn third_party_crates() -> String {\n+    use std::collections::HashMap;\n+    static CRATES: &[&str] = &[\"serde\", \"serde_derive\", \"regex\", \"clippy_lints\"];\n+    let dep_dir = cargo::TARGET_LIB.join(\"deps\");\n+    let mut crates: HashMap<&str, PathBuf> = HashMap::with_capacity(CRATES.len());\n+    for entry in fs::read_dir(dep_dir).unwrap() {\n+        let path = match entry {\n+            Ok(entry) => entry.path(),\n+            _ => continue,\n+        };\n+        if let Some(name) = path.file_name().and_then(OsStr::to_str) {\n+            for dep in CRATES {\n+                if name.starts_with(&format!(\"lib{}-\", dep)) && name.ends_with(\".rlib\") {\n+                    crates.entry(dep).or_insert(path);\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    let v: Vec<_> = crates\n+        .into_iter()\n+        .map(|(dep, path)| format!(\"--extern {}={}\", dep, path.display()))\n+        .collect();\n+    v.join(\" \")\n }\n \n fn default_config() -> compiletest::Config {\n-    let build_info = cargo::BuildInfo::new();\n     let mut config = compiletest::Config::default();\n \n     if let Ok(name) = env::var(\"TESTNAME\") {\n         config.filter = Some(name);\n     }\n \n-    if rustc_test_suite().is_some() {\n-        let path = rustc_lib_path();\n+    if let Some(path) = option_env!(\"RUSTC_LIB_PATH\") {\n+        let path = PathBuf::from(path);\n         config.run_lib_path = path.clone();\n         config.compile_lib_path = path;\n     }\n \n-    let disambiguated: Vec<_> = cargo::BuildInfo::third_party_crates()\n-        .iter()\n-        .map(|(krate, path)| format!(\"--extern {}={}\", krate, path.display()))\n-        .collect();\n-\n     config.target_rustcflags = Some(format!(\n         \"-L {0} -L {1} -Dwarnings -Zui-testing {2}\",\n-        build_info.host_lib().join(\"deps\").display(),\n-        build_info.target_lib().join(\"deps\").display(),\n-        disambiguated.join(\" \")\n+        host_lib().join(\"deps\").display(),\n+        cargo::TARGET_LIB.join(\"deps\").display(),\n+        third_party_crates(),\n     ));\n \n-    config.build_base = if rustc_test_suite().is_some() {\n-        // we don't need access to the stderr files on travis\n+    config.build_base = if cargo::is_rustc_test_suite() {\n+        // This make the stderr files go to clippy OUT_DIR on rustc repo build dir\n         let mut path = PathBuf::from(env!(\"OUT_DIR\"));\n         path.push(\"test_build_base\");\n         path\n     } else {\n-        build_info.host_lib().join(\"test_build_base\")\n+        host_lib().join(\"test_build_base\")\n     };\n-    config.rustc_path = build_info.clippy_driver_path();\n+    config.rustc_path = clippy_driver_path();\n     config\n }\n "}, {"sha": "81af3d3033b23c268a152258d74a30a8cd0d4ecc", "filename": "tests/dogfood.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9eb913a7e227e4c11ca0c2c7d8fd7ca22ed9c466/tests%2Fdogfood.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eb913a7e227e4c11ca0c2c7d8fd7ca22ed9c466/tests%2Fdogfood.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fdogfood.rs?ref=9eb913a7e227e4c11ca0c2c7d8fd7ca22ed9c466", "patch": "@@ -1,21 +1,20 @@\n+// Dogfood cannot run on Windows\n+#![cfg(not(windows))]\n+\n use lazy_static::lazy_static;\n use std::path::PathBuf;\n use std::process::Command;\n \n-#[allow(dead_code)]\n mod cargo;\n \n lazy_static! {\n-    static ref CLIPPY_PATH: PathBuf = {\n-        let build_info = cargo::BuildInfo::new();\n-        build_info.target_lib().join(\"cargo-clippy\")\n-    };\n+    static ref CLIPPY_PATH: PathBuf = cargo::TARGET_LIB.join(\"cargo-clippy\");\n }\n \n #[test]\n fn dogfood_clippy() {\n     // run clippy on itself and fail the test if lint warnings are reported\n-    if option_env!(\"RUSTC_TEST_SUITE\").is_some() || cfg!(windows) {\n+    if cargo::is_rustc_test_suite() {\n         return;\n     }\n     let root_dir = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n@@ -44,7 +43,7 @@ fn dogfood_clippy() {\n #[test]\n fn dogfood_subprojects() {\n     // run clippy on remaining subprojects and fail the test if lint warnings are reported\n-    if option_env!(\"RUSTC_TEST_SUITE\").is_some() || cfg!(windows) {\n+    if cargo::is_rustc_test_suite() {\n         return;\n     }\n     let root_dir = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));"}]}