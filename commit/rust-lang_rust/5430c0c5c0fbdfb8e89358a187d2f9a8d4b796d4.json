{"sha": "5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0MzBjMGM1YzBmYmRmYjhlODkzNThhMTg3ZDJmOWE4ZDRiNzk2ZDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-07T21:59:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-07T21:59:15Z"}, "message": "Auto merge of #48806 - alexcrichton:rollup, r=alexcrichton\n\nRollup of 9 pull requests\n\n- Successful merges: #48511, #48549, #48618, #48624, #48651, #48698, #48778, #48787, #48802\n- Failed merges: #48669, #48710", "tree": {"sha": "99f6ed796a60eef5a806809bd02146d3463ddf0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99f6ed796a60eef5a806809bd02146d3463ddf0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "html_url": "https://github.com/rust-lang/rust/commit/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4cdbac639af2074b8a07b4391b4e3e28b4118487", "url": "https://api.github.com/repos/rust-lang/rust/commits/4cdbac639af2074b8a07b4391b4e3e28b4118487", "html_url": "https://github.com/rust-lang/rust/commit/4cdbac639af2074b8a07b4391b4e3e28b4118487"}, {"sha": "16cc9ce8a27eac42950d8413f46c648e35e10cb3", "url": "https://api.github.com/repos/rust-lang/rust/commits/16cc9ce8a27eac42950d8413f46c648e35e10cb3", "html_url": "https://github.com/rust-lang/rust/commit/16cc9ce8a27eac42950d8413f46c648e35e10cb3"}], "stats": {"total": 1755, "additions": 831, "deletions": 924}, "files": [{"sha": "45e1b4b90d6c75e91935bd726d4fda55986e3283", "filename": "appveyor.yml", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -19,12 +19,18 @@ environment:\n     RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-profiler\n     SCRIPT: python x.py test\n   - MSYS_BITS: 32\n-    RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc --target=i686-pc-windows-msvc\n-    SCRIPT: python x.py test --host i686-pc-windows-msvc --target i686-pc-windows-msvc\n+    RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc\n+    SCRIPT: python x.py test --exclude src/test/run-pass --exclude src/test/compile-fail\n+  - MSYS_BITS: 32\n+    RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc\n+    SCRIPT: python x.py test src/test/run-pass src/test/compile-fail\n \n   # MSVC aux tests\n   - MSYS_BITS: 64\n-    RUST_CHECK_TARGET: check-aux\n+    RUST_CHECK_TARGET: check-aux EXCLUDE_CARGO=1\n+    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n+  - MSYS_BITS: 64\n+    SCRIPT: python x.py test src/tools/cargotest src/tools/cargo\n     RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n \n   # MSVC tools tests"}, {"sha": "b70a01ebb3c18f64fe4a7476d07573a4611ebe51", "filename": "src/Cargo.lock", "status": "modified", "additions": 19, "deletions": 39, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -398,10 +398,12 @@ dependencies = [\n  \"getopts 0.2.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.36 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"miow 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"miow 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -926,12 +928,11 @@ dependencies = [\n  \"clap 2.29.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"error-chain 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"flate2 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lazy_static 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rayon 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rayon 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tar 0.4.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"walkdir 1.0.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"walkdir 2.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"xz2 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1185,6 +1186,15 @@ dependencies = [\n  \"ws2_32-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"miow\"\n+version = \"0.3.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"socket2 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"miri\"\n version = \"0.1.0\"\n@@ -1511,15 +1521,6 @@ dependencies = [\n  \"libc 0.2.36 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"rayon\"\n-version = \"0.9.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"either 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rayon-core 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"rayon\"\n version = \"1.0.0\"\n@@ -2225,15 +2226,6 @@ dependencies = [\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"same-file\"\n-version = \"0.1.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"same-file\"\n version = \"1.0.2\"\n@@ -2779,16 +2771,6 @@ name = \"void\"\n version = \"1.0.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n-[[package]]\n-name = \"walkdir\"\n-version = \"1.0.7\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"same-file 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"walkdir\"\n version = \"2.0.1\"\n@@ -2971,6 +2953,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum memoffset 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0f9dc261e2b62d7a622bf416ea3c5245cdd5d9a7fcc428c0d06804dfce1775b3\"\n \"checksum miniz-sys 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"609ce024854aeb19a0ef7567d348aaa5a746b32fb72e336df7fcc16869d7e2b4\"\n \"checksum miow 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8c1f2f3b1cf331de6896aabf6e9d55dca90356cc9960cca7eaaf408a355ae919\"\n+\"checksum miow 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9224c91f82b3c47cf53dcf78dfaa20d6888fbcc5d272d5f2fcdf8a697f3c987d\"\n \"checksum net2 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3a80f842784ef6c9a958b68b7516bc7e35883c614004dd94959a4dca1b716c09\"\n \"checksum nibble_vec 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"62e678237a4c70c5f2b917cefd7d080dfbf800421f06e8a59d4e28ef5130fd9e\"\n \"checksum nix 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"47e49f6982987135c5e9620ab317623e723bd06738fd85377e8d55f57c8b6487\"\n@@ -3004,7 +2987,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum racer 2.0.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"034f1c4528581c40a60e96875467c03315868084e08ff4ceb46a00f7be3b16b4\"\n \"checksum radix_trie 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"211c49b6a9995cac0fd1dd9ca60b42cf3a51e151a12eb954b3a9e75513426ee8\"\n \"checksum rand 0.3.20 (registry+https://github.com/rust-lang/crates.io-index)\" = \"512870020642bb8c221bf68baa1b2573da814f6ccfe5c9699b1c303047abe9b1\"\n-\"checksum rayon 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ed02d09394c94ffbdfdc755ad62a132e94c3224a8354e78a1200ced34df12edf\"\n \"checksum rayon 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"485541959c8ecc49865526fe6c4de9653dd6e60d829d6edf0be228167b60372d\"\n \"checksum rayon-core 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9d24ad214285a7729b174ed6d3bcfcb80177807f959d95fafd5bfc5c4f201ac8\"\n \"checksum redox_syscall 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0d92eecebad22b767915e4d529f89f28ee96dbbf5a4810d2b844373f136417fd\"\n@@ -3027,7 +3009,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum rustc-ap-syntax_pos 29.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"db9de2e927e280c75b8efab9c5f591ad31082d5d2c4c562c68fdba2ee77286b0\"\n \"checksum rustc-demangle 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aee45432acc62f7b9a108cc054142dac51f979e69e71ddce7d6fc7adf29e817e\"\n \"checksum rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dcf128d1287d2ea9d80910b5f1120d0b8eede3fbf1abe91c40d39ea7d51e6fda\"\n-\"checksum same-file 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d931a44fdaa43b8637009e7632a02adc4f2b2e0733c08caa4cf00e8da4a117a7\"\n \"checksum same-file 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cfb6eded0b06a0b512c8ddbcf04089138c9b4362c2f696f3c3d76039d68f3637\"\n \"checksum schannel 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"acece75e0f987c48863a6c792ec8b7d6c4177d4a027f8ccc72f849794f437016\"\n \"checksum scoped-tls 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f417c22df063e9450888a7561788e9bd46d3bb3c1466435b4eccb903807f147d\"\n@@ -3085,7 +3066,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum vcpkg 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9e0a7d8bed3178a8fb112199d466eeca9ed09a14ba8ad67718179b4fd5487d0b\"\n \"checksum vec_map 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"887b5b631c2ad01628bbbaa7dd4c869f80d3186688f8d0b6f58774fbe324988c\"\n \"checksum void 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6a02e4885ed3bc0f2de90ea6dd45ebcbb66dacffe03547fadbb0eeae2770887d\"\n-\"checksum walkdir 1.0.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bb08f9e670fab86099470b97cd2b252d6527f0b3cc1401acdb595ffc9dd288ff\"\n \"checksum walkdir 2.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"40b6d201f4f8998a837196b6de9c73e35af14c992cbb92c4ab641d2c2dce52de\"\n \"checksum winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"167dc9d6949a9b857f3451275e911c3f44255842c1f7a76f33c55103a909087a\"\n \"checksum winapi 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"04e3bd221fcbe8a271359c04f21a76db7d0c6028862d1bb5512d85e1e2eb5bb3\""}, {"sha": "c62fa0ede709668f96d0057cc14a01ffee2c51c9", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -16,6 +16,12 @@ Q := @\n BOOTSTRAP_ARGS :=\n endif\n \n+ifdef EXCLUDE_CARGO\n+AUX_ARGS := src/tools/cargo src/tools/cargotest\n+else\n+AUX_ARGS :=\n+endif\n+\n BOOTSTRAP := $(CFG_PYTHON) $(CFG_SRC_DIR)src/bootstrap/bootstrap.py\n \n all:\n@@ -52,14 +58,13 @@ check:\n \t$(Q)$(BOOTSTRAP) test $(BOOTSTRAP_ARGS)\n check-aux:\n \t$(Q)$(BOOTSTRAP) test \\\n-\t\tsrc/tools/cargo \\\n-\t\tsrc/tools/cargotest \\\n \t\tsrc/test/pretty \\\n \t\tsrc/test/run-pass/pretty \\\n \t\tsrc/test/run-fail/pretty \\\n \t\tsrc/test/run-pass-valgrind/pretty \\\n \t\tsrc/test/run-pass-fulldeps/pretty \\\n \t\tsrc/test/run-fail-fulldeps/pretty \\\n+\t\t$(AUX_ARGS) \\\n \t\t$(BOOTSTRAP_ARGS)\n check-bootstrap:\n \t$(Q)$(CFG_PYTHON) $(CFG_SRC_DIR)src/bootstrap/bootstrap_test.py"}, {"sha": "79300e08a7d36f7c866f1bdc50f77a728f4ce865", "filename": "src/ci/run.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -104,7 +104,7 @@ else\n     travis_fold start \"make-$1\"\n     travis_time_start\n     echo \"make -j $ncpus $1\"\n-    make -j $ncpus \"$1\"\n+    make -j $ncpus $1\n     local retval=$?\n     travis_fold end \"make-$1\"\n     travis_time_finish"}, {"sha": "762f9565b7802e41a93ca3e693d96ea825fb03c2", "filename": "src/etc/ziggurat_tables.py", "status": "removed", "additions": 0, "deletions": 127, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/4cdbac639af2074b8a07b4391b4e3e28b4118487/src%2Fetc%2Fziggurat_tables.py", "raw_url": "https://github.com/rust-lang/rust/raw/4cdbac639af2074b8a07b4391b4e3e28b4118487/src%2Fetc%2Fziggurat_tables.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fziggurat_tables.py?ref=4cdbac639af2074b8a07b4391b4e3e28b4118487", "patch": "@@ -1,127 +0,0 @@\n-#!/usr/bin/env python\n-#\n-# Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-# This creates the tables used for distributions implemented using the\n-# ziggurat algorithm in `rand::distributions;`. They are\n-# (basically) the tables as used in the ZIGNOR variant (Doornik 2005).\n-# They are changed rarely, so the generated file should be checked in\n-# to git.\n-#\n-# It creates 3 tables: X as in the paper, F which is f(x_i), and\n-# F_DIFF which is f(x_i) - f(x_{i-1}). The latter two are just cached\n-# values which is not done in that paper (but is done in other\n-# variants). Note that the adZigR table is unnecessary because of\n-# algebra.\n-#\n-# It is designed to be compatible with Python 2 and 3.\n-\n-from math import exp, sqrt, log, floor\n-import random\n-\n-# The order should match the return value of `tables`\n-TABLE_NAMES = ['X', 'F']\n-\n-# The actual length of the table is 1 more, to stop\n-# index-out-of-bounds errors. This should match the bitwise operation\n-# to find `i` in `zigurrat` in `libstd/rand/mod.rs`. Also the *_R and\n-# *_V constants below depend on this value.\n-TABLE_LEN = 256\n-\n-# equivalent to `zigNorInit` in Doornik2005, but generalised to any\n-# distribution. r = dR, v = dV, f = probability density function,\n-# f_inv = inverse of f\n-def tables(r, v, f, f_inv):\n-    # compute the x_i\n-    xvec = [0]*(TABLE_LEN+1)\n-\n-    xvec[0] = v / f(r)\n-    xvec[1] = r\n-\n-    for i in range(2, TABLE_LEN):\n-        last = xvec[i-1]\n-        xvec[i] = f_inv(v / last + f(last))\n-\n-    # cache the f's\n-    fvec = [0]*(TABLE_LEN+1)\n-    for i in range(TABLE_LEN+1):\n-        fvec[i] = f(xvec[i])\n-\n-    return xvec, fvec\n-\n-# Distributions\n-# N(0, 1)\n-def norm_f(x):\n-    return exp(-x*x/2.0)\n-def norm_f_inv(y):\n-    return sqrt(-2.0*log(y))\n-\n-NORM_R = 3.6541528853610088\n-NORM_V = 0.00492867323399\n-\n-NORM = tables(NORM_R, NORM_V,\n-              norm_f, norm_f_inv)\n-\n-# Exp(1)\n-def exp_f(x):\n-    return exp(-x)\n-def exp_f_inv(y):\n-    return -log(y)\n-\n-EXP_R = 7.69711747013104972\n-EXP_V = 0.0039496598225815571993\n-\n-EXP = tables(EXP_R, EXP_V,\n-             exp_f, exp_f_inv)\n-\n-\n-# Output the tables/constants/types\n-\n-def render_static(name, type, value):\n-    # no space or\n-    return 'pub static %s: %s =%s;\\n' % (name, type, value)\n-\n-# static `name`: [`type`, .. `len(values)`] =\n-#     [values[0], ..., values[3],\n-#      values[4], ..., values[7],\n-#      ... ];\n-def render_table(name, values):\n-    rows = []\n-    # 4 values on each row\n-    for i in range(0, len(values), 4):\n-        row = values[i:i+4]\n-        rows.append(', '.join('%.18f' % f for f in row))\n-\n-    rendered = '\\n    [%s]' % ',\\n     '.join(rows)\n-    return render_static(name, '[f64, .. %d]' % len(values), rendered)\n-\n-\n-with open('ziggurat_tables.rs', 'w') as f:\n-    f.write('''// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Tables for distributions which are sampled using the ziggurat\n-// algorithm. Autogenerated by `ziggurat_tables.py`.\n-\n-pub type ZigTable = &\\'static [f64, .. %d];\n-'''  % (TABLE_LEN + 1))\n-    for name, tables, r in [('NORM', NORM, NORM_R),\n-                            ('EXP', EXP, EXP_R)]:\n-        f.write(render_static('ZIG_%s_R' % name, 'f64', ' %.18f' % r))\n-        for (tabname, table) in zip(TABLE_NAMES, tables):\n-            f.write(render_table('ZIG_%s_%s' % (name, tabname), table))"}, {"sha": "570f745f8330c78739bd095d97d20416b9e362cc", "filename": "src/libcore/option.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -829,14 +829,13 @@ impl<'a, T: Clone> Option<&'a mut T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(option_ref_mut_cloned)]\n     /// let mut x = 12;\n     /// let opt_x = Some(&mut x);\n     /// assert_eq!(opt_x, Some(&mut 12));\n     /// let cloned = opt_x.cloned();\n     /// assert_eq!(cloned, Some(12));\n     /// ```\n-    #[unstable(feature = \"option_ref_mut_cloned\", issue = \"43738\")]\n+    #[stable(since = \"1.26.0\", feature = \"option_ref_mut_cloned\")]\n     pub fn cloned(self) -> Option<T> {\n         self.map(|t| t.clone())\n     }"}, {"sha": "ed46296389da4ba4f0ad96d6f5f83d3fca4183fe", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -559,6 +559,7 @@ define_dep_nodes!( <'tcx>\n     [] IsReachableNonGeneric(DefId),\n     [] IsMirAvailable(DefId),\n     [] ItemAttrs(DefId),\n+    [] TransFnAttrs(DefId),\n     [] FnArgNames(DefId),\n     [] DylibDepFormats(CrateNum),\n     [] IsPanicRuntime(CrateNum),\n@@ -626,8 +627,6 @@ define_dep_nodes!( <'tcx>\n     [input] AllCrateNums,\n     [] ExportedSymbols(CrateNum),\n     [eval_always] CollectAndPartitionTranslationItems,\n-    [] ExportName(DefId),\n-    [] ContainsExternIndicator(DefId),\n     [] IsTranslatedItem(DefId),\n     [] CodegenUnit(InternedString),\n     [] CompileCodegenUnit(InternedString),\n@@ -637,7 +636,6 @@ define_dep_nodes!( <'tcx>\n     [] SubstituteNormalizeAndTestPredicates { key: (DefId, &'tcx Substs<'tcx>) },\n \n     [input] TargetFeaturesWhitelist,\n-    [] TargetFeaturesEnabled(DefId),\n \n     [] InstanceDefSizeEstimate { instance_def: InstanceDef<'tcx> },\n "}, {"sha": "d22703452605b6bb242a0b91d956ef22fe47d955", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -47,7 +47,7 @@ struct CheckAttrVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n     /// Check any attribute.\n     fn check_attributes(&self, item: &hir::Item, target: Target) {\n-        self.tcx.target_features_enabled(self.tcx.hir.local_def_id(item.id));\n+        self.tcx.trans_fn_attrs(self.tcx.hir.local_def_id(item.id));\n \n         for attr in &item.attrs {\n             if let Some(name) = attr.name() {"}, {"sha": "f4638c23c5f4bf35c721f6e8f7915e42064061fa", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -30,12 +30,14 @@ pub use self::Visibility::{Public, Inherited};\n use hir::def::Def;\n use hir::def_id::{DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX};\n use util::nodemap::{NodeMap, FxHashSet};\n+use mir::mono::Linkage;\n \n use syntax_pos::{Span, DUMMY_SP};\n use syntax::codemap::{self, Spanned};\n use syntax::abi::Abi;\n use syntax::ast::{self, Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, MetaItem};\n+use syntax::attr::InlineAttr;\n use syntax::ext::hygiene::SyntaxContext;\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, keywords};\n@@ -2210,3 +2212,51 @@ pub type GlobMap = NodeMap<FxHashSet<Name>>;\n pub fn provide(providers: &mut Providers) {\n     providers.describe_def = map::describe_def;\n }\n+\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash)]\n+pub struct TransFnAttrs {\n+    pub flags: TransFnAttrFlags,\n+    pub inline: InlineAttr,\n+    pub export_name: Option<Symbol>,\n+    pub target_features: Vec<Symbol>,\n+    pub linkage: Option<Linkage>,\n+}\n+\n+bitflags! {\n+    #[derive(RustcEncodable, RustcDecodable)]\n+    pub struct TransFnAttrFlags: u8 {\n+        const COLD                      = 0b0000_0001;\n+        const ALLOCATOR                 = 0b0000_0010;\n+        const UNWIND                    = 0b0000_0100;\n+        const RUSTC_ALLOCATOR_NOUNWIND  = 0b0000_1000;\n+        const NAKED                     = 0b0001_0000;\n+        const NO_MANGLE                 = 0b0010_0000;\n+        const RUSTC_STD_INTERNAL_SYMBOL = 0b0100_0000;\n+    }\n+}\n+\n+impl TransFnAttrs {\n+    pub fn new() -> TransFnAttrs {\n+        TransFnAttrs {\n+            flags: TransFnAttrFlags::empty(),\n+            inline: InlineAttr::None,\n+            export_name: None,\n+            target_features: vec![],\n+            linkage: None,\n+        }\n+    }\n+\n+    /// True if `#[inline]` or `#[inline(always)]` is present.\n+    pub fn requests_inline(&self) -> bool {\n+        match self.inline {\n+            InlineAttr::Hint | InlineAttr::Always => true,\n+            InlineAttr::None | InlineAttr::Never => false,\n+        }\n+    }\n+\n+    /// True if `#[no_mangle]` or `#[export_name(...)]` is present.\n+    pub fn contains_extern_indicator(&self) -> bool {\n+        self.flags.contains(TransFnAttrFlags::NO_MANGLE) || self.export_name.is_some()\n+    }\n+}\n+"}, {"sha": "faad3f3563164e444e6d9fce75877ff8ce86025c", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -19,6 +19,7 @@ use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,\n                                            StableHasher, StableHasherResult};\n use std::mem;\n use syntax::ast;\n+use syntax::attr;\n \n impl<'gcx> HashStable<StableHashingContext<'gcx>> for DefId {\n     #[inline]\n@@ -1138,6 +1139,43 @@ impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for hir::TraitCandidate {\n     }\n }\n \n+impl<'hir> HashStable<StableHashingContext<'hir>> for hir::TransFnAttrs\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'hir>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let hir::TransFnAttrs {\n+            flags,\n+            inline,\n+            export_name,\n+            ref target_features,\n+            linkage,\n+        } = *self;\n+\n+        flags.hash_stable(hcx, hasher);\n+        inline.hash_stable(hcx, hasher);\n+        export_name.hash_stable(hcx, hasher);\n+        target_features.hash_stable(hcx, hasher);\n+        linkage.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'hir> HashStable<StableHashingContext<'hir>> for hir::TransFnAttrFlags\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'hir>,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.bits().hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'hir> HashStable<StableHashingContext<'hir>> for attr::InlineAttr {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'hir>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+    }\n+}\n \n impl_stable_hash_for!(struct hir::Freevar {\n     def,"}, {"sha": "a8ed885e78d5585dcd7f18469ed44ca9dde09134", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -244,7 +244,6 @@ impl_stable_hash_for!(enum ty::Visibility {\n \n impl_stable_hash_for!(struct ty::TraitRef<'tcx> { def_id, substs });\n impl_stable_hash_for!(struct ty::TraitPredicate<'tcx> { trait_ref });\n-impl_stable_hash_for!(tuple_struct ty::EquatePredicate<'tcx> { t1, t2 });\n impl_stable_hash_for!(struct ty::SubtypePredicate<'tcx> { a_is_expected, a, b });\n \n impl<'gcx, A, B> HashStable<StableHashingContext<'gcx>>\n@@ -274,9 +273,6 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::Predicate<'gcx> {\n             ty::Predicate::Trait(ref pred) => {\n                 pred.hash_stable(hcx, hasher);\n             }\n-            ty::Predicate::Equate(ref pred) => {\n-                pred.hash_stable(hcx, hasher);\n-            }\n             ty::Predicate::Subtype(ref pred) => {\n                 pred.hash_stable(hcx, hasher);\n             }"}, {"sha": "0645bffafe76a058b6793837c16db4e454702ba6", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -1280,7 +1280,6 @@ impl<'tcx> ObligationCause<'tcx> {\n             }),\n             IfExpression => Error0308(\"if and else have incompatible types\"),\n             IfExpressionWithNoElse => Error0317(\"if may be missing an else clause\"),\n-            EquatePredicate => Error0308(\"equality predicate not satisfied\"),\n             MainFunctionType => Error0580(\"main function has wrong type\"),\n             StartFunctionType => Error0308(\"start function has wrong type\"),\n             IntrinsicType => Error0308(\"intrinsic has wrong type\"),\n@@ -1309,7 +1308,6 @@ impl<'tcx> ObligationCause<'tcx> {\n             },\n             IfExpression => \"if and else have compatible types\",\n             IfExpressionWithNoElse => \"if missing an else returns ()\",\n-            EquatePredicate => \"equality where clause is satisfied\",\n             MainFunctionType => \"`main` function has the correct type\",\n             StartFunctionType => \"`start` function has the correct type\",\n             IntrinsicType => \"intrinsic has the correct type\","}, {"sha": "5d44b2043e26ce7cbb48d832a59c1e2a1bce6a34", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -943,23 +943,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.borrow_region_constraints().make_subregion(origin, a, b);\n     }\n \n-    pub fn equality_predicate(&self,\n-                              cause: &ObligationCause<'tcx>,\n-                              param_env: ty::ParamEnv<'tcx>,\n-                              predicate: &ty::PolyEquatePredicate<'tcx>)\n-        -> InferResult<'tcx, ()>\n-    {\n-        self.commit_if_ok(|snapshot| {\n-            let (ty::EquatePredicate(a, b), skol_map) =\n-                self.skolemize_late_bound_regions(predicate, snapshot);\n-            let cause_span = cause.span;\n-            let eqty_ok = self.at(cause, param_env).eq(b, a)?;\n-            self.leak_check(false, cause_span, &skol_map, snapshot)?;\n-            self.pop_skolemized(skol_map, snapshot);\n-            Ok(eqty_ok.unit())\n-        })\n-    }\n-\n     pub fn subtype_predicate(&self,\n                              cause: &ObligationCause<'tcx>,\n                              param_env: ty::ParamEnv<'tcx>,"}, {"sha": "abb35d24d79548379a04556eecd5832b02a5c416", "filename": "src/librustc/infer/outlives/bounds.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Finfer%2Foutlives%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Finfer%2Foutlives%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fbounds.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -117,7 +117,6 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                 assert!(!obligation.has_escaping_regions());\n                 match obligation.predicate {\n                     ty::Predicate::Trait(..) |\n-                    ty::Predicate::Equate(..) |\n                     ty::Predicate::Subtype(..) |\n                     ty::Predicate::Projection(..) |\n                     ty::Predicate::ClosureKind(..) |\n@@ -204,7 +203,6 @@ pub fn explicit_outlives_bounds<'tcx>(\n         .filter_map(move |predicate| match predicate {\n             ty::Predicate::Projection(..) |\n             ty::Predicate::Trait(..) |\n-            ty::Predicate::Equate(..) |\n             ty::Predicate::Subtype(..) |\n             ty::Predicate::WellFormed(..) |\n             ty::Predicate::ObjectSafe(..) |"}, {"sha": "3c451d7ae46a1070cab54d0aa66594cc2d3de843", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -36,13 +36,12 @@ use session::search_paths::PathKind;\n use std::any::Any;\n use std::collections::BTreeMap;\n use std::path::{Path, PathBuf};\n-use rustc_data_structures::owning_ref::ErasedBoxRef;\n use syntax::ast;\n use syntax::ext::base::SyntaxExtension;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use rustc_back::target::Target;\n-use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::sync::{MetadataRef, Lrc};\n \n pub use self::NativeLibraryKind::*;\n \n@@ -186,11 +185,11 @@ pub trait MetadataLoader {\n     fn get_rlib_metadata(&self,\n                          target: &Target,\n                          filename: &Path)\n-                         -> Result<ErasedBoxRef<[u8]>, String>;\n+                         -> Result<MetadataRef, String>;\n     fn get_dylib_metadata(&self,\n                           target: &Target,\n                           filename: &Path)\n-                          -> Result<ErasedBoxRef<[u8]>, String>;\n+                          -> Result<MetadataRef, String>;\n }\n \n #[derive(Clone)]"}, {"sha": "48a62c8c14d6969e00b20916ba05ecd55ee4c682", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -15,6 +15,7 @@\n // makes all other generics or inline functions that it references\n // reachable as well.\n \n+use hir::TransFnAttrs;\n use hir::map as hir_map;\n use hir::def::Def;\n use hir::def_id::{DefId, CrateNum};\n@@ -43,8 +44,8 @@ fn generics_require_inlining(generics: &hir::Generics) -> bool {\n // Returns true if the given item must be inlined because it may be\n // monomorphized or it was marked with `#[inline]`. This will only return\n // true for functions.\n-fn item_might_be_inlined(item: &hir::Item) -> bool {\n-    if attr::requests_inline(&item.attrs) {\n+fn item_might_be_inlined(item: &hir::Item, attrs: TransFnAttrs) -> bool {\n+    if attrs.requests_inline() {\n         return true\n     }\n \n@@ -60,14 +61,15 @@ fn item_might_be_inlined(item: &hir::Item) -> bool {\n fn method_might_be_inlined<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      impl_item: &hir::ImplItem,\n                                      impl_src: DefId) -> bool {\n-    if attr::requests_inline(&impl_item.attrs) ||\n+    let trans_fn_attrs = tcx.trans_fn_attrs(impl_item.hir_id.owner_def_id());\n+    if trans_fn_attrs.requests_inline() ||\n         generics_require_inlining(&impl_item.generics) {\n         return true\n     }\n     if let Some(impl_node_id) = tcx.hir.as_local_node_id(impl_src) {\n         match tcx.hir.find(impl_node_id) {\n             Some(hir_map::NodeItem(item)) =>\n-                item_might_be_inlined(&item),\n+                item_might_be_inlined(&item, trans_fn_attrs),\n             Some(..) | None =>\n                 span_bug!(impl_item.span, \"impl did is not an item\")\n         }\n@@ -160,7 +162,8 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         match self.tcx.hir.find(node_id) {\n             Some(hir_map::NodeItem(item)) => {\n                 match item.node {\n-                    hir::ItemFn(..) => item_might_be_inlined(&item),\n+                    hir::ItemFn(..) =>\n+                        item_might_be_inlined(&item, self.tcx.trans_fn_attrs(def_id)),\n                     _ => false,\n                 }\n             }\n@@ -176,8 +179,9 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 match impl_item.node {\n                     hir::ImplItemKind::Const(..) => true,\n                     hir::ImplItemKind::Method(..) => {\n+                        let attrs = self.tcx.trans_fn_attrs(def_id);\n                         if generics_require_inlining(&impl_item.generics) ||\n-                                attr::requests_inline(&impl_item.attrs) {\n+                                attrs.requests_inline() {\n                             true\n                         } else {\n                             let impl_did = self.tcx\n@@ -229,7 +233,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     false\n                 };\n                 let def_id = self.tcx.hir.local_def_id(item.id);\n-                let is_extern = self.tcx.contains_extern_indicator(def_id);\n+                let is_extern = self.tcx.trans_fn_attrs(def_id).contains_extern_indicator();\n                 if reachable || is_extern {\n                     self.reachable_symbols.insert(search_item);\n                 }\n@@ -246,7 +250,8 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             hir_map::NodeItem(item) => {\n                 match item.node {\n                     hir::ItemFn(.., body) => {\n-                        if item_might_be_inlined(&item) {\n+                        let def_id = self.tcx.hir.local_def_id(item.id);\n+                        if item_might_be_inlined(&item, self.tcx.trans_fn_attrs(def_id)) {\n                             self.visit_nested_body(body);\n                         }\n                     }"}, {"sha": "d8eac2b415989a698fd0f7a1cd74372fbb2698f2", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -73,7 +73,7 @@ pub struct CodegenUnit<'tcx> {\n     size_estimate: Option<usize>,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub enum Linkage {\n     External,\n     AvailableExternally,"}, {"sha": "ce23cb2349609789334e0f1d6aca5132d8b959bd", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -631,16 +631,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         span_bug!(span, \"subtype requirement gave wrong error: `{:?}`\", predicate)\n                     }\n \n-                    ty::Predicate::Equate(ref predicate) => {\n-                        let predicate = self.resolve_type_vars_if_possible(predicate);\n-                        let err = self.equality_predicate(&obligation.cause,\n-                                                          obligation.param_env,\n-                                                          &predicate).err().unwrap();\n-                        struct_span_err!(self.tcx.sess, span, E0278,\n-                            \"the requirement `{}` is not satisfied (`{}`)\",\n-                            predicate, err)\n-                    }\n-\n                     ty::Predicate::RegionOutlives(ref predicate) => {\n                         let predicate = self.resolve_type_vars_if_possible(predicate);\n                         let err = self.region_outlives_predicate(&obligation.cause,\n@@ -1270,7 +1260,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             ObligationCauseCode::MatchExpressionArm { .. } |\n             ObligationCauseCode::IfExpression |\n             ObligationCauseCode::IfExpressionWithNoElse |\n-            ObligationCauseCode::EquatePredicate |\n             ObligationCauseCode::MainFunctionType |\n             ObligationCauseCode::StartFunctionType |\n             ObligationCauseCode::IntrinsicType |"}, {"sha": "2f3e19d92bcda0740ba56918b0093bce2a8e3739", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use infer::{RegionObligation, InferCtxt, InferOk};\n+use infer::{RegionObligation, InferCtxt};\n use ty::{self, Ty, TypeFoldable, ToPolyTraitRef, ToPredicate};\n use ty::error::ExpectedFound;\n use rustc_data_structures::obligation_forest::{ObligationForest, Error};\n@@ -380,17 +380,6 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n             }\n         }\n \n-        ty::Predicate::Equate(ref binder) => {\n-            match selcx.infcx().equality_predicate(&obligation.cause,\n-                                                   obligation.param_env,\n-                                                   binder) {\n-                Ok(InferOk { obligations, value: () }) => {\n-                    Ok(Some(obligations))\n-                },\n-                Err(_) => Err(CodeSelectionError(Unimplemented)),\n-            }\n-        }\n-\n         ty::Predicate::RegionOutlives(ref binder) => {\n             match selcx.infcx().region_outlives_predicate(&obligation.cause, binder) {\n                 Ok(()) => Ok(Some(Vec::new())),"}, {"sha": "8ac69c4b5287a67509d69cce85157ca0d3c4a70b", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -204,9 +204,6 @@ pub enum ObligationCauseCode<'tcx> {\n     /// Computing common supertype of an if expression with no else counter-part\n     IfExpressionWithNoElse,\n \n-    /// `where a == b`\n-    EquatePredicate,\n-\n     /// `main` has wrong type\n     MainFunctionType,\n \n@@ -854,19 +851,6 @@ impl<'tcx, N> Vtable<'tcx, N> {\n         }\n     }\n \n-    fn nested_obligations_mut(&mut self) -> &mut Vec<N> {\n-        match self {\n-            &mut VtableImpl(ref mut i) => &mut i.nested,\n-            &mut VtableParam(ref mut n) => n,\n-            &mut VtableBuiltin(ref mut i) => &mut i.nested,\n-            &mut VtableAutoImpl(ref mut d) => &mut d.nested,\n-            &mut VtableGenerator(ref mut c) => &mut c.nested,\n-            &mut VtableClosure(ref mut c) => &mut c.nested,\n-            &mut VtableObject(ref mut d) => &mut d.nested,\n-            &mut VtableFnPointer(ref mut d) => &mut d.nested,\n-        }\n-    }\n-\n     pub fn map<M, F>(self, f: F) -> Vtable<'tcx, M> where F: FnMut(N) -> M {\n         match self {\n             VtableImpl(i) => VtableImpl(VtableImplData {"}, {"sha": "52a0a897595b211013bf1f47fc71d694c2cb5186", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -175,7 +175,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     ty::Predicate::RegionOutlives(..) |\n                     ty::Predicate::ClosureKind(..) |\n                     ty::Predicate::Subtype(..) |\n-                    ty::Predicate::Equate(..) |\n                     ty::Predicate::ConstEvaluatable(..) => {\n                         false\n                     }\n@@ -204,7 +203,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     }\n                     ty::Predicate::Projection(..) |\n                     ty::Predicate::Trait(..) |\n-                    ty::Predicate::Equate(..) |\n                     ty::Predicate::Subtype(..) |\n                     ty::Predicate::RegionOutlives(..) |\n                     ty::Predicate::WellFormed(..) |"}, {"sha": "600b4a515f0bf969a8764e6bd3cd8a316c5f4b89", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 39, "deletions": 82, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -44,27 +44,17 @@ use ty::relate::TypeRelation;\n use middle::lang_items;\n \n use rustc_data_structures::bitvec::BitVector;\n-use rustc_data_structures::snapshot_vec::{SnapshotVecDelegate, SnapshotVec};\n use std::iter;\n use std::cell::RefCell;\n use std::cmp;\n use std::fmt;\n-use std::marker::PhantomData;\n use std::mem;\n use std::rc::Rc;\n use syntax::abi::Abi;\n use hir;\n use lint;\n use util::nodemap::{FxHashMap, FxHashSet};\n \n-struct InferredObligationsSnapshotVecDelegate<'tcx> {\n-    phantom: PhantomData<&'tcx i32>,\n-}\n-impl<'tcx> SnapshotVecDelegate for InferredObligationsSnapshotVecDelegate<'tcx> {\n-    type Value = PredicateObligation<'tcx>;\n-    type Undo = ();\n-    fn reverse(_: &mut Vec<Self::Value>, _: Self::Undo) {}\n-}\n \n pub struct SelectionContext<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n@@ -92,8 +82,6 @@ pub struct SelectionContext<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     /// would satisfy it. This avoids crippling inference, basically.\n     intercrate: Option<IntercrateMode>,\n \n-    inferred_obligations: SnapshotVec<InferredObligationsSnapshotVecDelegate<'tcx>>,\n-\n     intercrate_ambiguity_causes: Option<Vec<IntercrateAmbiguityCause>>,\n \n     /// Controls whether or not to filter out negative impls when selecting.\n@@ -429,7 +417,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             infcx,\n             freshener: infcx.freshener(),\n             intercrate: None,\n-            inferred_obligations: SnapshotVec::new(),\n             intercrate_ambiguity_causes: None,\n             allow_negative_impls: false,\n         }\n@@ -442,7 +429,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             infcx,\n             freshener: infcx.freshener(),\n             intercrate: Some(mode),\n-            inferred_obligations: SnapshotVec::new(),\n             intercrate_ambiguity_causes: None,\n             allow_negative_impls: false,\n         }\n@@ -455,7 +441,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             infcx,\n             freshener: infcx.freshener(),\n             intercrate: None,\n-            inferred_obligations: SnapshotVec::new(),\n             intercrate_ambiguity_causes: None,\n             allow_negative_impls,\n         }\n@@ -498,8 +483,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn in_snapshot<R, F>(&mut self, f: F) -> R\n         where F: FnOnce(&mut Self, &infer::CombinedSnapshot<'cx, 'tcx>) -> R\n     {\n-        // The irrefutable nature of the operation means we don't need to snapshot the\n-        // inferred_obligations vector.\n         self.infcx.in_snapshot(|snapshot| f(self, snapshot))\n     }\n \n@@ -508,28 +491,15 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn probe<R, F>(&mut self, f: F) -> R\n         where F: FnOnce(&mut Self, &infer::CombinedSnapshot<'cx, 'tcx>) -> R\n     {\n-        let inferred_obligations_snapshot = self.inferred_obligations.start_snapshot();\n-        let result = self.infcx.probe(|snapshot| f(self, snapshot));\n-        self.inferred_obligations.rollback_to(inferred_obligations_snapshot);\n-        result\n+        self.infcx.probe(|snapshot| f(self, snapshot))\n     }\n \n     /// Wraps a commit_if_ok s.t. obligations collected during it are not returned in selection if\n     /// the transaction fails and s.t. old obligations are retained.\n     fn commit_if_ok<T, E, F>(&mut self, f: F) -> Result<T, E> where\n         F: FnOnce(&mut Self, &infer::CombinedSnapshot) -> Result<T, E>\n     {\n-        let inferred_obligations_snapshot = self.inferred_obligations.start_snapshot();\n-        match self.infcx.commit_if_ok(|snapshot| f(self, snapshot)) {\n-            Ok(ok) => {\n-                self.inferred_obligations.commit(inferred_obligations_snapshot);\n-                Ok(ok)\n-            },\n-            Err(err) => {\n-                self.inferred_obligations.rollback_to(inferred_obligations_snapshot);\n-                Err(err)\n-            }\n-        }\n+        self.infcx.commit_if_ok(|snapshot| f(self, snapshot))\n     }\n \n \n@@ -560,12 +530,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let stack = self.push_stack(TraitObligationStackList::empty(), obligation);\n         let ret = match self.candidate_from_obligation(&stack)? {\n             None => None,\n-            Some(candidate) => {\n-                let mut candidate = self.confirm_candidate(obligation, candidate)?;\n-                let inferred_obligations = (*self.inferred_obligations).into_iter().cloned();\n-                candidate.nested_obligations_mut().extend(inferred_obligations);\n-                Some(candidate)\n-            },\n+            Some(candidate) => Some(self.confirm_candidate(obligation, candidate)?)\n         };\n \n         // Test whether this is a `()` which was produced by defaulting a\n@@ -658,7 +623,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                                 stack: TraitObligationStackList<'o, 'tcx>,\n                                                 predicates: I)\n                                                 -> EvaluationResult\n-        where I : Iterator<Item=&'a PredicateObligation<'tcx>>, 'tcx:'a\n+        where I : IntoIterator<Item=&'a PredicateObligation<'tcx>>, 'tcx:'a\n     {\n         let mut result = EvaluatedToOk;\n         for obligation in predicates {\n@@ -691,22 +656,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 self.evaluate_trait_predicate_recursively(previous_stack, obligation)\n             }\n \n-            ty::Predicate::Equate(ref p) => {\n-                // does this code ever run?\n-                match self.infcx.equality_predicate(&obligation.cause, obligation.param_env, p) {\n-                    Ok(InferOk { obligations, .. }) => {\n-                        self.inferred_obligations.extend(obligations);\n-                        EvaluatedToOk\n-                    },\n-                    Err(_) => EvaluatedToErr\n-                }\n-            }\n-\n             ty::Predicate::Subtype(ref p) => {\n                 // does this code ever run?\n                 match self.infcx.subtype_predicate(&obligation.cause, obligation.param_env, p) {\n                     Some(Ok(InferOk { obligations, .. })) => {\n-                        self.inferred_obligations.extend(obligations);\n+                        self.evaluate_predicates_recursively(previous_stack, &obligations);\n                         EvaluatedToOk\n                     },\n                     Some(Err(_)) => EvaluatedToErr,\n@@ -1553,12 +1507,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         -> bool\n     {\n         assert!(!skol_trait_ref.has_escaping_regions());\n-        match self.infcx.at(&obligation.cause, obligation.param_env)\n-                        .sup(ty::Binder(skol_trait_ref), trait_bound) {\n-            Ok(InferOk { obligations, .. }) => {\n-                self.inferred_obligations.extend(obligations);\n-            }\n-            Err(_) => { return false; }\n+        if let Err(_) = self.infcx.at(&obligation.cause, obligation.param_env)\n+                                  .sup(ty::Binder(skol_trait_ref), trait_bound) {\n+            return false;\n         }\n \n         self.infcx.leak_check(false, obligation.cause.span, skol_map, snapshot).is_ok()\n@@ -2644,6 +2595,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         };\n \n         let mut upcast_trait_ref = None;\n+        let mut nested = vec![];\n         let vtable_base;\n \n         {\n@@ -2662,7 +2614,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         self.commit_if_ok(\n                             |this, _| this.match_poly_trait_ref(obligation, t))\n                     {\n-                        Ok(_) => { upcast_trait_ref = Some(t); false }\n+                        Ok(obligations) => {\n+                            upcast_trait_ref = Some(t);\n+                            nested.extend(obligations);\n+                            false\n+                        }\n                         Err(_) => { true }\n                     }\n                 });\n@@ -2680,7 +2636,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         VtableObjectData {\n             upcast_trait_ref: upcast_trait_ref.unwrap(),\n             vtable_base,\n-            nested: vec![]\n+            nested,\n         }\n     }\n \n@@ -2737,7 +2693,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             self.generator_trait_ref_unnormalized(obligation, closure_def_id, substs);\n         let Normalized {\n             value: trait_ref,\n-            obligations\n+            mut obligations\n         } = normalize_with_depth(self,\n                                  obligation.param_env,\n                                  obligation.cause.clone(),\n@@ -2749,10 +2705,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                trait_ref,\n                obligations);\n \n-        self.confirm_poly_trait_refs(obligation.cause.clone(),\n-                                     obligation.param_env,\n-                                     obligation.predicate.to_poly_trait_ref(),\n-                                     trait_ref)?;\n+        obligations.extend(\n+            self.confirm_poly_trait_refs(obligation.cause.clone(),\n+                                        obligation.param_env,\n+                                        obligation.predicate.to_poly_trait_ref(),\n+                                        trait_ref)?);\n \n         Ok(VtableGeneratorData {\n             closure_def_id: closure_def_id,\n@@ -2798,10 +2755,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                trait_ref,\n                obligations);\n \n-        self.confirm_poly_trait_refs(obligation.cause.clone(),\n-                                     obligation.param_env,\n-                                     obligation.predicate.to_poly_trait_ref(),\n-                                     trait_ref)?;\n+        obligations.extend(\n+            self.confirm_poly_trait_refs(obligation.cause.clone(),\n+                                        obligation.param_env,\n+                                        obligation.predicate.to_poly_trait_ref(),\n+                                        trait_ref)?);\n \n         obligations.push(Obligation::new(\n             obligation.cause.clone(),\n@@ -2845,13 +2803,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                obligation_param_env: ty::ParamEnv<'tcx>,\n                                obligation_trait_ref: ty::PolyTraitRef<'tcx>,\n                                expected_trait_ref: ty::PolyTraitRef<'tcx>)\n-                               -> Result<(), SelectionError<'tcx>>\n+                               -> Result<Vec<PredicateObligation<'tcx>>, SelectionError<'tcx>>\n     {\n         let obligation_trait_ref = obligation_trait_ref.clone();\n         self.infcx\n             .at(&obligation_cause, obligation_param_env)\n             .sup(obligation_trait_ref, expected_trait_ref)\n-            .map(|InferOk { obligations, .. }| self.inferred_obligations.extend(obligations))\n+            .map(|InferOk { obligations, .. }| obligations)\n             .map_err(|e| OutputTypeParameterMismatch(expected_trait_ref, obligation_trait_ref, e))\n     }\n \n@@ -2888,7 +2846,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     self.infcx.at(&obligation.cause, obligation.param_env)\n                               .eq(target, new_trait)\n                               .map_err(|_| Unimplemented)?;\n-                self.inferred_obligations.extend(obligations);\n+                nested.extend(obligations);\n \n                 // Register one obligation for 'a: 'b.\n                 let cause = ObligationCause::new(obligation.cause.span,\n@@ -2950,7 +2908,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     self.infcx.at(&obligation.cause, obligation.param_env)\n                               .eq(b, a)\n                               .map_err(|_| Unimplemented)?;\n-                self.inferred_obligations.extend(obligations);\n+                nested.extend(obligations);\n             }\n \n             // Struct<T> -> Struct<U>.\n@@ -3014,7 +2972,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     self.infcx.at(&obligation.cause, obligation.param_env)\n                               .eq(target, new_struct)\n                               .map_err(|_| Unimplemented)?;\n-                self.inferred_obligations.extend(obligations);\n+                nested.extend(obligations);\n \n                 // Construct the nested Field<T>: Unsize<Field<U>> predicate.\n                 nested.push(tcx.predicate_for_trait_def(\n@@ -3045,7 +3003,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     self.infcx.at(&obligation.cause, obligation.param_env)\n                               .eq(target, new_tuple)\n                               .map_err(|_| Unimplemented)?;\n-                self.inferred_obligations.extend(obligations);\n+                nested.extend(obligations);\n \n                 // Construct the nested T: Unsize<U> predicate.\n                 nested.push(tcx.predicate_for_trait_def(\n@@ -3118,7 +3076,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let impl_trait_ref = impl_trait_ref.subst(self.tcx(),\n                                                   impl_substs);\n \n-        let impl_trait_ref =\n+        let Normalized { value: impl_trait_ref, obligations: mut nested_obligations } =\n             project::normalize_with_depth(self,\n                                           obligation.param_env,\n                                           obligation.cause.clone(),\n@@ -3134,12 +3092,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         let InferOk { obligations, .. } =\n             self.infcx.at(&obligation.cause, obligation.param_env)\n-                      .eq(skol_obligation_trait_ref, impl_trait_ref.value)\n+                      .eq(skol_obligation_trait_ref, impl_trait_ref)\n                       .map_err(|e| {\n                           debug!(\"match_impl: failed eq_trait_refs due to `{}`\", e);\n                           ()\n                       })?;\n-        self.inferred_obligations.extend(obligations);\n+        nested_obligations.extend(obligations);\n \n         if let Err(e) = self.infcx.leak_check(false,\n                                               obligation.cause.span,\n@@ -3152,7 +3110,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         debug!(\"match_impl: success impl_substs={:?}\", impl_substs);\n         Ok((Normalized {\n             value: impl_substs,\n-            obligations: impl_trait_ref.obligations\n+            obligations: nested_obligations\n         }, skol_map))\n     }\n \n@@ -3189,24 +3147,23 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                     where_clause_trait_ref: ty::PolyTraitRef<'tcx>)\n                                     -> Result<Vec<PredicateObligation<'tcx>>,()>\n     {\n-        self.match_poly_trait_ref(obligation, where_clause_trait_ref)?;\n-        Ok(Vec::new())\n+        self.match_poly_trait_ref(obligation, where_clause_trait_ref)\n     }\n \n     /// Returns `Ok` if `poly_trait_ref` being true implies that the\n     /// obligation is satisfied.\n     fn match_poly_trait_ref(&mut self,\n                             obligation: &TraitObligation<'tcx>,\n                             poly_trait_ref: ty::PolyTraitRef<'tcx>)\n-                            -> Result<(),()>\n+                            -> Result<Vec<PredicateObligation<'tcx>>,()>\n     {\n         debug!(\"match_poly_trait_ref: obligation={:?} poly_trait_ref={:?}\",\n                obligation,\n                poly_trait_ref);\n \n         self.infcx.at(&obligation.cause, obligation.param_env)\n                   .sup(obligation.predicate.to_poly_trait_ref(), poly_trait_ref)\n-                  .map(|InferOk { obligations, .. }| self.inferred_obligations.extend(obligations))\n+                  .map(|InferOk { obligations, .. }| obligations)\n                   .map_err(|_| ())\n     }\n "}, {"sha": "9dd5aaee7b72f9e5bd956ed667b93bb9aba5937c", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -236,7 +236,6 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n             }\n             super::IfExpression => Some(super::IfExpression),\n             super::IfExpressionWithNoElse => Some(super::IfExpressionWithNoElse),\n-            super::EquatePredicate => Some(super::EquatePredicate),\n             super::MainFunctionType => Some(super::MainFunctionType),\n             super::StartFunctionType => Some(super::StartFunctionType),\n             super::IntrinsicType => Some(super::IntrinsicType),\n@@ -512,7 +511,6 @@ impl<'tcx> TypeFoldable<'tcx> for traits::ObligationCauseCode<'tcx> {\n             super::MatchExpressionArm { arm_span: _, source: _ } |\n             super::IfExpression |\n             super::IfExpressionWithNoElse |\n-            super::EquatePredicate |\n             super::MainFunctionType |\n             super::StartFunctionType |\n             super::IntrinsicType |\n@@ -561,7 +559,6 @@ impl<'tcx> TypeFoldable<'tcx> for traits::ObligationCauseCode<'tcx> {\n             super::MatchExpressionArm { arm_span: _, source: _ } |\n             super::IfExpression |\n             super::IfExpressionWithNoElse |\n-            super::EquatePredicate |\n             super::MainFunctionType |\n             super::StartFunctionType |\n             super::IntrinsicType |"}, {"sha": "c562f2cd48dde37655a449c1b3c1728f6fd8b23b", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -25,9 +25,6 @@ fn anonymize_predicate<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         ty::Predicate::Trait(ref data) =>\n             ty::Predicate::Trait(tcx.anonymize_late_bound_regions(data)),\n \n-        ty::Predicate::Equate(ref data) =>\n-            ty::Predicate::Equate(tcx.anonymize_late_bound_regions(data)),\n-\n         ty::Predicate::RegionOutlives(ref data) =>\n             ty::Predicate::RegionOutlives(tcx.anonymize_late_bound_regions(data)),\n \n@@ -163,11 +160,6 @@ impl<'cx, 'gcx, 'tcx> Elaborator<'cx, 'gcx, 'tcx> {\n                 // Currently, we do not elaborate object-safe\n                 // predicates.\n             }\n-            ty::Predicate::Equate(..) => {\n-                // Currently, we do not \"elaborate\" predicates like\n-                // `X == Y`, though conceivably we might. For example,\n-                // `&X == &Y` implies that `X == Y`.\n-            }\n             ty::Predicate::Subtype(..) => {\n                 // Currently, we do not \"elaborate\" predicates like `X\n                 // <: Y`, though conceivably we might."}, {"sha": "a5f0abb9bc05c2348fccb8e4fb1b2cb4a29d2d82", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -96,7 +96,6 @@ impl<'tcx> InstanceDef<'tcx> {\n         &self,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>\n     ) -> bool {\n-        use syntax::attr::requests_inline;\n         if self.is_inline(tcx) {\n             return true\n         }\n@@ -106,8 +105,8 @@ impl<'tcx> InstanceDef<'tcx> {\n             // available to normal end-users.\n             return true\n         }\n-        requests_inline(&self.attrs(tcx)[..]) ||\n-            tcx.is_const_fn(self.def_id())\n+        let trans_fn_attrs = tcx.trans_fn_attrs(self.def_id());\n+        trans_fn_attrs.requests_inline() || tcx.is_const_fn(self.def_id())\n     }\n }\n "}, {"sha": "5069c59562678a722926951c82222e89aa2b102c", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -1203,7 +1203,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 }\n \n                 let pointee = tcx.normalize_associated_type_in_env(&pointee, param_env);\n-                if pointee.is_sized(tcx, param_env, DUMMY_SP) {\n+                if pointee.is_sized(tcx.at(DUMMY_SP), param_env) {\n                     return Ok(tcx.intern_layout(LayoutDetails::scalar(self, data_ptr)));\n                 }\n \n@@ -1428,7 +1428,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                         let param_env = tcx.param_env(def.did);\n                         let last_field = def.variants[v].fields.last().unwrap();\n                         let always_sized = tcx.type_of(last_field.did)\n-                          .is_sized(tcx, param_env, DUMMY_SP);\n+                          .is_sized(tcx.at(DUMMY_SP), param_env);\n                         if !always_sized { StructKind::MaybeUnsized }\n                         else { StructKind::AlwaysSized }\n                     };"}, {"sha": "d880b022e2f18c90c981882b70a6b79d69bac763", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -687,8 +687,8 @@ impl_disk_cacheable_query!(borrowck, |def_id| def_id.is_local());\n impl_disk_cacheable_query!(mir_borrowck, |def_id| def_id.is_local());\n impl_disk_cacheable_query!(mir_const_qualif, |def_id| def_id.is_local());\n impl_disk_cacheable_query!(check_match, |def_id| def_id.is_local());\n-impl_disk_cacheable_query!(contains_extern_indicator, |_| true);\n impl_disk_cacheable_query!(def_symbol_name, |_| true);\n impl_disk_cacheable_query!(type_of, |def_id| def_id.is_local());\n impl_disk_cacheable_query!(predicates_of, |def_id| def_id.is_local());\n impl_disk_cacheable_query!(used_trait_imports, |def_id| def_id.is_local());\n+impl_disk_cacheable_query!(trans_fn_attrs, |_| true);"}, {"sha": "43a71f1c0d367ab385449be5ecd9a546e202b7d4", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -12,7 +12,7 @@ use dep_graph::{DepConstructor, DepNode};\n use errors::DiagnosticBuilder;\n use hir::def_id::{CrateNum, DefId, DefIndex};\n use hir::def::{Def, Export};\n-use hir::{self, TraitCandidate, ItemLocalId};\n+use hir::{self, TraitCandidate, ItemLocalId, TransFnAttrs};\n use hir::svh::Svh;\n use lint;\n use middle::borrowck::BorrowCheckResult;\n@@ -235,6 +235,7 @@ define_maps! { <'tcx>\n     [] fn lookup_stability: LookupStability(DefId) -> Option<&'tcx attr::Stability>,\n     [] fn lookup_deprecation_entry: LookupDeprecationEntry(DefId) -> Option<DeprecationEntry>,\n     [] fn item_attrs: ItemAttrs(DefId) -> Lrc<[ast::Attribute]>,\n+    [] fn trans_fn_attrs: trans_fn_attrs(DefId) -> TransFnAttrs,\n     [] fn fn_arg_names: FnArgNames(DefId) -> Vec<ast::Name>,\n     [] fn impl_parent: ImplParent(DefId) -> Option<DefId>,\n     [] fn trait_of_item: TraitOfItem(DefId) -> Option<DefId>,\n@@ -362,8 +363,6 @@ define_maps! { <'tcx>\n     [] fn collect_and_partition_translation_items:\n         collect_and_partition_translation_items_node(CrateNum)\n         -> (Arc<DefIdSet>, Arc<Vec<Arc<CodegenUnit<'tcx>>>>),\n-    [] fn export_name: ExportName(DefId) -> Option<Symbol>,\n-    [] fn contains_extern_indicator: ContainsExternIndicator(DefId) -> bool,\n     [] fn symbol_export_level: GetSymbolExportLevel(DefId) -> SymbolExportLevel,\n     [] fn is_translated_item: IsTranslatedItem(DefId) -> bool,\n     [] fn codegen_unit: CodegenUnit(InternedString) -> Arc<CodegenUnit<'tcx>>,\n@@ -385,7 +384,6 @@ define_maps! { <'tcx>\n \n     [] fn target_features_whitelist:\n         target_features_whitelist_node(CrateNum) -> Lrc<FxHashSet<String>>,\n-    [] fn target_features_enabled: TargetFeaturesEnabled(DefId) -> Lrc<Vec<String>>,\n \n     // Get an estimate of the size of an InstanceDef based on its MIR for CGU partitioning.\n     [] fn instance_def_size_estimate: instance_def_size_estimate_dep_node(ty::InstanceDef<'tcx>)\n@@ -403,6 +401,10 @@ fn features_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n     DepConstructor::Features\n }\n \n+fn trans_fn_attrs<'tcx>(id: DefId) -> DepConstructor<'tcx> {\n+    DepConstructor::TransFnAttrs { 0: id }\n+}\n+\n fn erase_regions_ty<'tcx>(ty: Ty<'tcx>) -> DepConstructor<'tcx> {\n     DepConstructor::EraseRegionsTy { ty }\n }"}, {"sha": "b18837ff35aa81b86348e3b47567b0e38c68bea3", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -217,9 +217,9 @@ impl<'sess> OnDiskCache<'sess> {\n                 encode_query_results::<mir_const_qualif, _>(tcx, enc, qri)?;\n                 encode_query_results::<def_symbol_name, _>(tcx, enc, qri)?;\n                 encode_query_results::<const_is_rvalue_promotable_to_static, _>(tcx, enc, qri)?;\n-                encode_query_results::<contains_extern_indicator, _>(tcx, enc, qri)?;\n                 encode_query_results::<symbol_name, _>(tcx, enc, qri)?;\n                 encode_query_results::<check_match, _>(tcx, enc, qri)?;\n+                encode_query_results::<trans_fn_attrs, _>(tcx, enc, qri)?;\n             }\n \n             // Encode diagnostics"}, {"sha": "fcc69f3b2c39ee9e1acce9435222f15f768f432f", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -854,6 +854,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::IsReachableNonGeneric => { force!(is_reachable_non_generic, def_id!()); }\n         DepKind::IsMirAvailable => { force!(is_mir_available, def_id!()); }\n         DepKind::ItemAttrs => { force!(item_attrs, def_id!()); }\n+        DepKind::TransFnAttrs => { force!(trans_fn_attrs, def_id!()); }\n         DepKind::FnArgNames => { force!(fn_arg_names, def_id!()); }\n         DepKind::DylibDepFormats => { force!(dylib_dependency_formats, krate!()); }\n         DepKind::IsPanicRuntime => { force!(is_panic_runtime, krate!()); }\n@@ -925,15 +926,10 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::CollectAndPartitionTranslationItems => {\n             force!(collect_and_partition_translation_items, LOCAL_CRATE);\n         }\n-        DepKind::ExportName => { force!(export_name, def_id!()); }\n-        DepKind::ContainsExternIndicator => {\n-            force!(contains_extern_indicator, def_id!());\n-        }\n         DepKind::IsTranslatedItem => { force!(is_translated_item, def_id!()); }\n         DepKind::OutputFilenames => { force!(output_filenames, LOCAL_CRATE); }\n \n         DepKind::TargetFeaturesWhitelist => { force!(target_features_whitelist, LOCAL_CRATE); }\n-        DepKind::TargetFeaturesEnabled => { force!(target_features_enabled, def_id!()); }\n \n         DepKind::GetSymbolExportLevel => { force!(symbol_export_level, def_id!()); }\n         DepKind::Features => { force!(features_query, LOCAL_CRATE); }\n@@ -997,10 +993,10 @@ impl_load_from_cache!(\n     MirConstQualif => mir_const_qualif,\n     SymbolName => def_symbol_name,\n     ConstIsRvaluePromotableToStatic => const_is_rvalue_promotable_to_static,\n-    ContainsExternIndicator => contains_extern_indicator,\n     CheckMatch => check_match,\n     TypeOfItem => type_of,\n     GenericsOfItem => generics_of,\n     PredicatesOfItem => predicates_of,\n     UsedTraitImports => used_trait_imports,\n+    TransFnAttrs => trans_fn_attrs,\n );"}, {"sha": "be27e3d51529bca6abf0cdcffea20c834d5e1c52", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -912,9 +912,6 @@ pub enum Predicate<'tcx> {\n     /// would be the type parameters.\n     Trait(PolyTraitPredicate<'tcx>),\n \n-    /// where `T1 == T2`.\n-    Equate(PolyEquatePredicate<'tcx>),\n-\n     /// where 'a : 'b\n     RegionOutlives(PolyRegionOutlivesPredicate<'tcx>),\n \n@@ -1023,8 +1020,6 @@ impl<'a, 'gcx, 'tcx> Predicate<'tcx> {\n         match *self {\n             Predicate::Trait(ty::Binder(ref data)) =>\n                 Predicate::Trait(ty::Binder(data.subst(tcx, substs))),\n-            Predicate::Equate(ty::Binder(ref data)) =>\n-                Predicate::Equate(ty::Binder(data.subst(tcx, substs))),\n             Predicate::Subtype(ty::Binder(ref data)) =>\n                 Predicate::Subtype(ty::Binder(data.subst(tcx, substs))),\n             Predicate::RegionOutlives(ty::Binder(ref data)) =>\n@@ -1072,10 +1067,6 @@ impl<'tcx> PolyTraitPredicate<'tcx> {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n-pub struct EquatePredicate<'tcx>(pub Ty<'tcx>, pub Ty<'tcx>); // `0 == 1`\n-pub type PolyEquatePredicate<'tcx> = ty::Binder<EquatePredicate<'tcx>>;\n-\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct OutlivesPredicate<A,B>(pub A, pub B); // `A : B`\n pub type PolyOutlivesPredicate<A,B> = ty::Binder<OutlivesPredicate<A,B>>;\n@@ -1166,12 +1157,6 @@ impl<'tcx> ToPredicate<'tcx> for PolyTraitRef<'tcx> {\n     }\n }\n \n-impl<'tcx> ToPredicate<'tcx> for PolyEquatePredicate<'tcx> {\n-    fn to_predicate(&self) -> Predicate<'tcx> {\n-        Predicate::Equate(self.clone())\n-    }\n-}\n-\n impl<'tcx> ToPredicate<'tcx> for PolyRegionOutlivesPredicate<'tcx> {\n     fn to_predicate(&self) -> Predicate<'tcx> {\n         Predicate::RegionOutlives(self.clone())\n@@ -1199,9 +1184,6 @@ impl<'tcx> Predicate<'tcx> {\n             ty::Predicate::Trait(ref data) => {\n                 data.skip_binder().input_types().collect()\n             }\n-            ty::Predicate::Equate(ty::Binder(ref data)) => {\n-                vec![data.0, data.1]\n-            }\n             ty::Predicate::Subtype(ty::Binder(SubtypePredicate { a, b, a_is_expected: _ })) => {\n                 vec![a, b]\n             }\n@@ -1242,7 +1224,6 @@ impl<'tcx> Predicate<'tcx> {\n                 Some(t.to_poly_trait_ref())\n             }\n             Predicate::Projection(..) |\n-            Predicate::Equate(..) |\n             Predicate::Subtype(..) |\n             Predicate::RegionOutlives(..) |\n             Predicate::WellFormed(..) |\n@@ -1262,7 +1243,6 @@ impl<'tcx> Predicate<'tcx> {\n             }\n             Predicate::Trait(..) |\n             Predicate::Projection(..) |\n-            Predicate::Equate(..) |\n             Predicate::Subtype(..) |\n             Predicate::RegionOutlives(..) |\n             Predicate::WellFormed(..) |"}, {"sha": "055835ed69c1dcfa3142030d674e85ebc4c66cec", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -282,14 +282,6 @@ impl<'a, 'tcx> Lift<'tcx> for ty::TraitPredicate<'a> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for ty::EquatePredicate<'a> {\n-    type Lifted = ty::EquatePredicate<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n-                             -> Option<ty::EquatePredicate<'tcx>> {\n-        tcx.lift(&(self.0, self.1)).map(|(a, b)| ty::EquatePredicate(a, b))\n-    }\n-}\n-\n impl<'a, 'tcx> Lift<'tcx> for ty::SubtypePredicate<'a> {\n     type Lifted = ty::SubtypePredicate<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n@@ -355,9 +347,6 @@ impl<'a, 'tcx> Lift<'tcx> for ty::Predicate<'a> {\n             ty::Predicate::Trait(ref binder) => {\n                 tcx.lift(binder).map(ty::Predicate::Trait)\n             }\n-            ty::Predicate::Equate(ref binder) => {\n-                tcx.lift(binder).map(ty::Predicate::Equate)\n-            }\n             ty::Predicate::Subtype(ref binder) => {\n                 tcx.lift(binder).map(ty::Predicate::Subtype)\n             }\n@@ -1049,8 +1038,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n         match *self {\n             ty::Predicate::Trait(ref a) =>\n                 ty::Predicate::Trait(a.fold_with(folder)),\n-            ty::Predicate::Equate(ref binder) =>\n-                ty::Predicate::Equate(binder.fold_with(folder)),\n             ty::Predicate::Subtype(ref binder) =>\n                 ty::Predicate::Subtype(binder.fold_with(folder)),\n             ty::Predicate::RegionOutlives(ref binder) =>\n@@ -1073,7 +1060,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         match *self {\n             ty::Predicate::Trait(ref a) => a.visit_with(visitor),\n-            ty::Predicate::Equate(ref binder) => binder.visit_with(visitor),\n             ty::Predicate::Subtype(ref binder) => binder.visit_with(visitor),\n             ty::Predicate::RegionOutlives(ref binder) => binder.visit_with(visitor),\n             ty::Predicate::TypeOutlives(ref binder) => binder.visit_with(visitor),\n@@ -1111,16 +1097,6 @@ BraceStructTypeFoldableImpl! {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::EquatePredicate<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::EquatePredicate(self.0.fold_with(folder), self.1.fold_with(folder))\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.0.visit_with(visitor) || self.1.visit_with(visitor)\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for ty::SubtypePredicate<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::SubtypePredicate {"}, {"sha": "785035ee5f4f0d9a852a4e3608b1bf4853e6bb68", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -20,6 +20,7 @@ use traits::{self, Reveal};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use ty::fold::TypeVisitor;\n use ty::subst::{Subst, UnpackedKind};\n+use ty::maps::TyCtxtAt;\n use ty::TypeVariants::*;\n use util::common::ErrorReported;\n use middle::lang_items;\n@@ -385,7 +386,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 match predicate {\n                     ty::Predicate::Projection(..) |\n                     ty::Predicate::Trait(..) |\n-                    ty::Predicate::Equate(..) |\n                     ty::Predicate::Subtype(..) |\n                     ty::Predicate::WellFormed(..) |\n                     ty::Predicate::ObjectSafe(..) |\n@@ -864,11 +864,10 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n     }\n \n     pub fn is_sized(&'tcx self,\n-                    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    param_env: ty::ParamEnv<'tcx>,\n-                    span: Span)-> bool\n+                    tcx_at: TyCtxtAt<'a, 'tcx, 'tcx>,\n+                    param_env: ty::ParamEnv<'tcx>)-> bool\n     {\n-        tcx.at(span).is_sized_raw(param_env.and(self))\n+        tcx_at.is_sized_raw(param_env.and(self))\n     }\n \n     pub fn is_freeze(&'tcx self,"}, {"sha": "ea99bd39e87927ed9fbc7b789daca08f166eb3a5", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -77,10 +77,6 @@ pub fn predicate_obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n         ty::Predicate::Trait(ref t) => {\n             wf.compute_trait_ref(&t.skip_binder().trait_ref, Elaborate::None); // (*)\n         }\n-        ty::Predicate::Equate(ref t) => {\n-            wf.compute(t.skip_binder().0);\n-            wf.compute(t.skip_binder().1);\n-        }\n         ty::Predicate::RegionOutlives(..) => {\n         }\n         ty::Predicate::TypeOutlives(ref t) => {"}, {"sha": "a2620da4c10ca1d98cefc1ae40d0353a1bfc9635", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -939,7 +939,6 @@ define_print_multi! {\n     ('tcx) ty::Binder<ty::TraitRef<'tcx>>,\n     ('tcx) ty::Binder<ty::FnSig<'tcx>>,\n     ('tcx) ty::Binder<ty::TraitPredicate<'tcx>>,\n-    ('tcx) ty::Binder<ty::EquatePredicate<'tcx>>,\n     ('tcx) ty::Binder<ty::SubtypePredicate<'tcx>>,\n     ('tcx) ty::Binder<ty::ProjectionPredicate<'tcx>>,\n     ('tcx) ty::Binder<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>>,\n@@ -1217,14 +1216,6 @@ define_print! {\n     }\n }\n \n-define_print! {\n-    ('tcx) ty::EquatePredicate<'tcx>, (self, f, cx) {\n-        display {\n-            print!(f, cx, print(self.0), write(\" == \"), print(self.1))\n-        }\n-    }\n-}\n-\n define_print! {\n     ('tcx) ty::SubtypePredicate<'tcx>, (self, f, cx) {\n         display {\n@@ -1292,7 +1283,6 @@ define_print! {\n         display {\n             match *self {\n                 ty::Predicate::Trait(ref data) => data.print(f, cx),\n-                ty::Predicate::Equate(ref predicate) => predicate.print(f, cx),\n                 ty::Predicate::Subtype(ref predicate) => predicate.print(f, cx),\n                 ty::Predicate::RegionOutlives(ref predicate) => predicate.print(f, cx),\n                 ty::Predicate::TypeOutlives(ref predicate) => predicate.print(f, cx),\n@@ -1317,7 +1307,6 @@ define_print! {\n         debug {\n             match *self {\n                 ty::Predicate::Trait(ref a) => a.print(f, cx),\n-                ty::Predicate::Equate(ref pair) => pair.print(f, cx),\n                 ty::Predicate::Subtype(ref pair) => pair.print(f, cx),\n                 ty::Predicate::RegionOutlives(ref pair) => pair.print(f, cx),\n                 ty::Predicate::TypeOutlives(ref pair) => pair.print(f, cx),"}, {"sha": "c466b8f8ad1b5acb716db8b2720dd2cadb25c08f", "filename": "src/librustc_data_structures/owning_ref/mod.rs", "status": "modified", "additions": 41, "deletions": 6, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_data_structures%2Fowning_ref%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_data_structures%2Fowning_ref%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fowning_ref%2Fmod.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -243,6 +243,7 @@ fn main() {\n ```\n */\n \n+use std::mem;\n pub use stable_deref_trait::{StableDeref as StableAddress, CloneStableDeref as CloneStableAddress};\n \n /// An owning reference.\n@@ -279,7 +280,7 @@ pub struct OwningRefMut<O, T: ?Sized> {\n pub trait Erased {}\n impl<T> Erased for T {}\n \n-/// Helper trait for erasing the concrete type of what an owner derferences to,\n+/// Helper trait for erasing the concrete type of what an owner dereferences to,\n /// for example `Box<T> -> Box<Erased>`. This would be unneeded with\n /// higher kinded types support in the language.\n pub unsafe trait IntoErased<'a> {\n@@ -289,10 +290,20 @@ pub unsafe trait IntoErased<'a> {\n     fn into_erased(self) -> Self::Erased;\n }\n \n-/// Helper trait for erasing the concrete type of what an owner derferences to,\n+/// Helper trait for erasing the concrete type of what an owner dereferences to,\n+/// for example `Box<T> -> Box<Erased + Send>`. This would be unneeded with\n+/// higher kinded types support in the language.\n+pub unsafe trait IntoErasedSend<'a> {\n+    /// Owner with the dereference type substituted to `Erased + Send`.\n+    type Erased: Send;\n+    /// Perform the type erasure.\n+    fn into_erased_send(self) -> Self::Erased;\n+}\n+\n+/// Helper trait for erasing the concrete type of what an owner dereferences to,\n /// for example `Box<T> -> Box<Erased + Send + Sync>`. This would be unneeded with\n /// higher kinded types support in the language.\n-pub unsafe trait IntoErasedSendSync<'a>: Send + Sync {\n+pub unsafe trait IntoErasedSendSync<'a> {\n     /// Owner with the dereference type substituted to `Erased + Send + Sync`.\n     type Erased: Send + Sync;\n     /// Perform the type erasure.\n@@ -472,6 +483,18 @@ impl<O, T: ?Sized> OwningRef<O, T> {\n         }\n     }\n \n+    /// Erases the concrete base type of the owner with a trait object which implements `Send`.\n+    ///\n+    /// This allows mixing of owned references with different owner base types.\n+    pub fn erase_send_owner<'a>(self) -> OwningRef<O::Erased, T>\n+        where O: IntoErasedSend<'a>,\n+    {\n+        OwningRef {\n+            reference: self.reference,\n+            owner: self.owner.into_erased_send(),\n+        }\n+    }\n+\n     /// Erases the concrete base type of the owner with a trait object which implements `Send` and `Sync`.\n     ///\n     /// This allows mixing of owned references with different owner base types.\n@@ -1161,13 +1184,25 @@ unsafe impl<'a, T: 'a> IntoErased<'a> for Arc<T> {\n     }\n }\n \n-unsafe impl<'a, T: Send + Sync + 'a> IntoErasedSendSync<'a> for Box<T> {\n-    type Erased = Box<Erased + Send + Sync + 'a>;\n-    fn into_erased_send_sync(self) -> Self::Erased {\n+unsafe impl<'a, T: Send + 'a> IntoErasedSend<'a> for Box<T> {\n+    type Erased = Box<Erased + Send + 'a>;\n+    fn into_erased_send(self) -> Self::Erased {\n         self\n     }\n }\n \n+unsafe impl<'a, T: Send + 'a> IntoErasedSendSync<'a> for Box<T> {\n+    type Erased = Box<Erased + Sync + Send + 'a>;\n+    fn into_erased_send_sync(self) -> Self::Erased {\n+        let result: Box<Erased + Send + 'a> = self;\n+        // This is safe since Erased can always implement Sync\n+        // Only the destructor is available and it takes &mut self\n+        unsafe {\n+            mem::transmute(result)\n+        }\n+    }\n+}\n+\n unsafe impl<'a, T: Send + Sync + 'a> IntoErasedSendSync<'a> for Arc<T> {\n     type Erased = Arc<Erased + Send + Sync + 'a>;\n     fn into_erased_send_sync(self) -> Self::Erased {"}, {"sha": "69fc9ef785eb791e645c5767f31870983f9b4a3b", "filename": "src/librustc_data_structures/sync.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_data_structures%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_data_structures%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsync.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -177,7 +177,7 @@ cfg_if! {\n         macro_rules! rustc_erase_owner {\n             ($v:expr) => {{\n                 let v = $v;\n-                ::rustc_data_structures::sync::assert_send_sync_val(&v);\n+                ::rustc_data_structures::sync::assert_send_val(&v);\n                 v.erase_send_sync_owner()\n             }}\n         }\n@@ -262,6 +262,7 @@ cfg_if! {\n }\n \n pub fn assert_sync<T: ?Sized + Sync>() {}\n+pub fn assert_send_val<T: ?Sized + Send>(_t: &T) {}\n pub fn assert_send_sync_val<T: ?Sized + Sync + Send>(_t: &T) {}\n \n #[macro_export]"}, {"sha": "9d8690072709b8670adbe10321b963da977edff3", "filename": "src/librustc_llvm/archive_ro.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_llvm%2Farchive_ro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_llvm%2Farchive_ro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Farchive_ro.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -22,6 +22,8 @@ pub struct ArchiveRO {\n     ptr: ArchiveRef,\n }\n \n+unsafe impl Send for ArchiveRO {}\n+\n pub struct Iter<'a> {\n     archive: &'a ArchiveRO,\n     ptr: ::ArchiveIteratorRef,"}, {"sha": "16bee5b987e2d0a6b333745e0289f20597cf9685", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -221,6 +221,8 @@ pub struct ObjectFile {\n     pub llof: ObjectFileRef,\n }\n \n+unsafe impl Send for ObjectFile {}\n+\n impl ObjectFile {\n     // This will take ownership of llmb\n     pub fn new(llmb: MemoryBufferRef) -> Option<ObjectFile> {"}, {"sha": "202efb9276a81e0f8071e1b9915cee8fcc30080c", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -24,7 +24,6 @@ use rustc::util::nodemap::{FxHashMap, FxHashSet, NodeMap};\n \n use std::cell::{RefCell, Cell};\n use rustc_data_structures::sync::Lrc;\n-use rustc_data_structures::owning_ref::ErasedBoxRef;\n use syntax::{ast, attr};\n use syntax::ext::base::SyntaxExtension;\n use syntax::symbol::Symbol;\n@@ -42,7 +41,9 @@ pub use cstore_impl::{provide, provide_extern};\n // own crate numbers.\n pub type CrateNumMap = IndexVec<CrateNum, CrateNum>;\n \n-pub struct MetadataBlob(pub ErasedBoxRef<[u8]>);\n+pub use rustc_data_structures::sync::MetadataRef;\n+\n+pub struct MetadataBlob(pub MetadataRef);\n \n /// Holds information about a syntax_pos::FileMap imported from another crate.\n /// See `imported_filemaps()` for more information."}, {"sha": "830121b446fca3e565f0a5921f805dcbf9997289", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -832,7 +832,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         } else if let hir::ImplItemKind::Method(ref sig, body) = ast_item.node {\n             let generics = self.tcx.generics_of(def_id);\n             let types = generics.parent_types as usize + generics.types.len();\n-            let needs_inline = types > 0 || attr::requests_inline(&ast_item.attrs);\n+            let needs_inline = types > 0 || tcx.trans_fn_attrs(def_id).requests_inline();\n             let is_const_fn = sig.constness == hir::Constness::Const;\n             let ast = if is_const_fn { Some(body) } else { None };\n             let always_encode_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir;\n@@ -1123,7 +1123,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 hir::ItemConst(..) => self.encode_optimized_mir(def_id),\n                 hir::ItemFn(_, _, constness, _, ref generics, _) => {\n                     let has_tps = generics.ty_params().next().is_some();\n-                    let needs_inline = has_tps || attr::requests_inline(&item.attrs);\n+                    let needs_inline = has_tps || tcx.trans_fn_attrs(def_id).requests_inline();\n                     let always_encode_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir;\n                     if needs_inline || constness == hir::Constness::Const || always_encode_mir {\n                         self.encode_optimized_mir(def_id)"}, {"sha": "da0da622d521424a661ac527921bcc5bded126c4", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -39,6 +39,7 @@ extern crate proc_macro;\n #[macro_use]\n extern crate rustc;\n extern crate rustc_back;\n+#[macro_use]\n extern crate rustc_data_structures;\n \n mod diagnostics;"}, {"sha": "c56674bd6c5a9b959b0f121f52742fe80fa7bc48", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -219,7 +219,7 @@\n //! no means all of the necessary details. Take a look at the rest of\n //! metadata::locator or metadata::creader for all the juicy details!\n \n-use cstore::MetadataBlob;\n+use cstore::{MetadataRef, MetadataBlob};\n use creader::Library;\n use schema::{METADATA_HEADER, rustc_version};\n \n@@ -243,8 +243,8 @@ use std::path::{Path, PathBuf};\n use std::time::Instant;\n \n use flate2::read::DeflateDecoder;\n-use rustc_data_structures::owning_ref::{ErasedBoxRef, OwningRef};\n \n+use rustc_data_structures::owning_ref::OwningRef;\n pub struct CrateMismatch {\n     path: PathBuf,\n     got: String,\n@@ -842,7 +842,7 @@ fn get_metadata_section_imp(target: &Target,\n     if !filename.exists() {\n         return Err(format!(\"no such file: '{}'\", filename.display()));\n     }\n-    let raw_bytes: ErasedBoxRef<[u8]> = match flavor {\n+    let raw_bytes: MetadataRef = match flavor {\n         CrateFlavor::Rlib => loader.get_rlib_metadata(target, filename)?,\n         CrateFlavor::Dylib => {\n             let buf = loader.get_dylib_metadata(target, filename)?;\n@@ -862,7 +862,7 @@ fn get_metadata_section_imp(target: &Target,\n             match DeflateDecoder::new(compressed_bytes).read_to_end(&mut inflated) {\n                 Ok(_) => {\n                     let buf = unsafe { OwningRef::new_assert_stable_address(inflated) };\n-                    buf.map_owner_box().erase_owner()\n+                    rustc_erase_owner!(buf.map_owner_box())\n                 }\n                 Err(_) => {\n                     return Err(format!(\"failed to decompress metadata: {}\", filename.display()));\n@@ -872,7 +872,7 @@ fn get_metadata_section_imp(target: &Target,\n         CrateFlavor::Rmeta => {\n             let buf = fs::read(filename).map_err(|_|\n                 format!(\"failed to read rmeta metadata: '{}'\", filename.display()))?;\n-            OwningRef::new(buf).map_owner_box().erase_owner()\n+            rustc_erase_owner!(OwningRef::new(buf).map_owner_box())\n         }\n     };\n     let blob = MetadataBlob(raw_bytes);"}, {"sha": "bbf4357e5b0f91edf5b2c07d2aa93b8cfa4f9154", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -1208,7 +1208,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         // shouldn't affect `is_sized`.\n         let gcx = self.tcx().global_tcx();\n         let erased_ty = gcx.lift(&self.tcx().erase_regions(&ty)).unwrap();\n-        if !erased_ty.is_sized(gcx, self.param_env, span) {\n+        if !erased_ty.is_sized(gcx.at(span), self.param_env) {\n             // in current MIR construction, all non-control-flow rvalue\n             // expressions evaluate through `as_temp` or `into` a return\n             // slot or local, so to find all unsized rvalues it is enough"}, {"sha": "25f933c5da6e7ce6742aae078413cb3107d2292c", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -286,7 +286,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     }\n \n     pub(super) fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n-        ty.is_sized(self.tcx, self.param_env, DUMMY_SP)\n+        ty.is_sized(self.tcx.at(DUMMY_SP), self.param_env)\n     }\n \n     pub fn load_mir("}, {"sha": "0f512569adf9757f1bd07d1f7e35056105029c36", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -188,7 +188,7 @@\n //! this is not implemented however: a mono item will be produced\n //! regardless of whether it is actually needed or not.\n \n-use rustc::hir;\n+use rustc::hir::{self, TransFnAttrFlags};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n \n use rustc::hir::map as hir_map;\n@@ -211,8 +211,6 @@ use monomorphize::item::{MonoItemExt, DefPathBasedNames, InstantiationMode};\n \n use rustc_data_structures::bitvec::BitVector;\n \n-use syntax::attr;\n-\n use std::iter;\n \n #[derive(PartialEq, Eq, Hash, Clone, Copy, Debug)]\n@@ -796,7 +794,7 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let ptr_vtable = |inner_source: Ty<'tcx>, inner_target: Ty<'tcx>| {\n         let type_has_metadata = |ty: Ty<'tcx>| -> bool {\n             use syntax_pos::DUMMY_SP;\n-            if ty.is_sized(tcx, ty::ParamEnv::empty(traits::Reveal::All), DUMMY_SP) {\n+            if ty.is_sized(tcx.at(DUMMY_SP), ty::ParamEnv::empty(traits::Reveal::All)) {\n                 return false;\n             }\n             let tail = tcx.struct_tail(ty);\n@@ -985,8 +983,8 @@ impl<'b, 'a, 'v> RootCollector<'b, 'a, 'v> {\n             MonoItemCollectionMode::Lazy => {\n                 self.entry_fn == Some(def_id) ||\n                 self.tcx.is_reachable_non_generic(def_id) ||\n-                attr::contains_name(&self.tcx.get_attrs(def_id),\n-                                    \"rustc_std_internal_symbol\")\n+                self.tcx.trans_fn_attrs(def_id).flags.contains(\n+                    TransFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL)\n             }\n         }\n     }"}, {"sha": "38b8ffc6b9c806f6a3b04197b80f575058b26856", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 4, "deletions": 45, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -21,41 +21,14 @@ use rustc::session::config::OptLevel;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n use syntax::ast;\n-use syntax::attr::{self, InlineAttr};\n+use syntax::attr::InlineAttr;\n use std::fmt::{self, Write};\n use std::iter;\n use rustc::mir::mono::Linkage;\n use syntax_pos::symbol::Symbol;\n use syntax::codemap::Span;\n pub use rustc::mir::mono::MonoItem;\n \n-pub fn linkage_by_name(name: &str) -> Option<Linkage> {\n-    use rustc::mir::mono::Linkage::*;\n-\n-    // Use the names from src/llvm/docs/LangRef.rst here. Most types are only\n-    // applicable to variable declarations and may not really make sense for\n-    // Rust code in the first place but whitelist them anyway and trust that\n-    // the user knows what s/he's doing. Who knows, unanticipated use cases\n-    // may pop up in the future.\n-    //\n-    // ghost, dllimport, dllexport and linkonce_odr_autohide are not supported\n-    // and don't have to be, LLVM treats them as no-ops.\n-    match name {\n-        \"appending\" => Some(Appending),\n-        \"available_externally\" => Some(AvailableExternally),\n-        \"common\" => Some(Common),\n-        \"extern_weak\" => Some(ExternalWeak),\n-        \"external\" => Some(External),\n-        \"internal\" => Some(Internal),\n-        \"linkonce\" => Some(LinkOnceAny),\n-        \"linkonce_odr\" => Some(LinkOnceODR),\n-        \"private\" => Some(Private),\n-        \"weak\" => Some(WeakAny),\n-        \"weak_odr\" => Some(WeakODR),\n-        _ => None,\n-    }\n-}\n-\n /// Describes how a translation item will be instantiated in object files.\n #[derive(PartialEq, Eq, Clone, Copy, Debug, Hash)]\n pub enum InstantiationMode {\n@@ -141,8 +114,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n                 // creating one copy of this `#[inline]` function which may\n                 // conflict with upstream crates as it could be an exported\n                 // symbol.\n-                let attrs = instance.def.attrs(tcx);\n-                match attr::find_inline_attr(Some(tcx.sess.diagnostic()), &attrs) {\n+                match tcx.trans_fn_attrs(instance.def_id()).inline {\n                     InlineAttr::Always => InstantiationMode::LocalCopy,\n                     _ => {\n                         InstantiationMode::GloballyShared  { may_conflict: true }\n@@ -165,21 +137,8 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n             MonoItem::GlobalAsm(..) => return None,\n         };\n \n-        let attributes = tcx.get_attrs(def_id);\n-        if let Some(name) = attr::first_attr_value_str_by_name(&attributes, \"linkage\") {\n-            if let Some(linkage) = linkage_by_name(&name.as_str()) {\n-                Some(linkage)\n-            } else {\n-                let span = tcx.hir.span_if_local(def_id);\n-                if let Some(span) = span {\n-                    tcx.sess.span_fatal(span, \"invalid linkage specified\")\n-                } else {\n-                    tcx.sess.fatal(&format!(\"invalid linkage specified: {}\", name))\n-                }\n-            }\n-        } else {\n-            None\n-        }\n+        let trans_fn_attrs = tcx.trans_fn_attrs(def_id);\n+        trans_fn_attrs.linkage\n     }\n \n     /// Returns whether this instance is instantiable - whether it has no unsatisfied"}, {"sha": "64c702b99cdb3940350a841bef58b4717fa5ea70", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -11,6 +11,7 @@\n //! Inlining pass for MIR functions\n \n use rustc::hir;\n+use rustc::hir::TransFnAttrFlags;\n use rustc::hir::def_id::DefId;\n \n use rustc_data_structures::bitvec::BitVector;\n@@ -206,10 +207,9 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n             return false;\n         }\n \n-        let attrs = tcx.get_attrs(callsite.callee);\n-        let hint = attr::find_inline_attr(None, &attrs[..]);\n+        let trans_fn_attrs = tcx.trans_fn_attrs(callsite.callee);\n \n-        let hinted = match hint {\n+        let hinted = match trans_fn_attrs.inline {\n             // Just treat inline(always) as a hint for now,\n             // there are cases that prevent inlining that we\n             // need to check for first.\n@@ -239,7 +239,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         };\n \n         // Significantly lower the threshold for inlining cold functions\n-        if attr::contains_name(&attrs[..], \"cold\") {\n+        if trans_fn_attrs.flags.contains(TransFnAttrFlags::COLD) {\n             threshold /= 5;\n         }\n \n@@ -344,7 +344,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n             }\n         }\n \n-        if let attr::InlineAttr::Always = hint {\n+        if let attr::InlineAttr::Always = trans_fn_attrs.inline {\n             debug!(\"INLINING {:?} because inline(always) [cost={}]\", callsite, cost);\n             true\n         } else {"}, {"sha": "d92025a6787d6f63597ab87accae8599e012f37b", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -1665,17 +1665,23 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                         if !self.span.filter_generated(sub_span, ex.span) {\n                             let span =\n                                 self.span_from_span(sub_span.expect(\"No span found for var ref\"));\n-                            let ref_id =\n-                                ::id_from_def_id(def.non_enum_variant().fields[idx.node].did);\n-                            self.dumper.dump_ref(Ref {\n-                                kind: RefKind::Variable,\n-                                span,\n-                                ref_id,\n-                            });\n+                            if let Some(field) = def.non_enum_variant().fields.get(idx.node) {\n+                                let ref_id = ::id_from_def_id(field.did);\n+                                self.dumper.dump_ref(Ref {\n+                                    kind: RefKind::Variable,\n+                                    span,\n+                                    ref_id,\n+                                });\n+                            } else {\n+                                return;\n+                            }\n                         }\n                     }\n                     ty::TyTuple(..) => {}\n-                    _ => span_bug!(ex.span, \"Expected struct or tuple type, found {:?}\", ty),\n+                    _ => {\n+                        debug!(\"Expected struct or tuple type, found {:?}\", ty);\n+                        return;\n+                    }\n                 }\n             }\n             ast::ExprKind::Closure(_, _, ref decl, ref body, _fn_decl_span) => {"}, {"sha": "d5ec8d1b5526256573cf69552de26dc754f878fd", "filename": "src/librustc_trans/attributes.rs", "status": "modified", "additions": 31, "deletions": 108, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_trans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_trans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fattributes.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -11,19 +11,16 @@\n \n use std::ffi::{CStr, CString};\n \n-use rustc::hir::Unsafety;\n+use rustc::hir::TransFnAttrFlags;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::session::config::Sanitizer;\n-use rustc::ty::TyCtxt;\n use rustc::ty::maps::Providers;\n-use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n \n use llvm::{self, Attribute, ValueRef};\n use llvm::AttributePlace::Function;\n use llvm_util;\n pub use syntax::attr::{self, InlineAttr};\n-use syntax::ast;\n use context::CodegenCx;\n \n /// Mark LLVM function to use provided inline heuristic.\n@@ -102,31 +99,42 @@ pub fn set_probestack(cx: &CodegenCx, llfn: ValueRef) {\n /// Composite function which sets LLVM attributes for function depending on its AST (#[attribute])\n /// attributes.\n pub fn from_fn_attrs(cx: &CodegenCx, llfn: ValueRef, id: DefId) {\n-    use syntax::attr::*;\n-    let attrs = cx.tcx.get_attrs(id);\n-    inline(llfn, find_inline_attr(Some(cx.sess().diagnostic()), &attrs));\n+    let trans_fn_attrs = cx.tcx.trans_fn_attrs(id);\n+\n+    inline(llfn, trans_fn_attrs.inline);\n \n     set_frame_pointer_elimination(cx, llfn);\n     set_probestack(cx, llfn);\n \n-    for attr in attrs.iter() {\n-        if attr.check_name(\"cold\") {\n-            Attribute::Cold.apply_llfn(Function, llfn);\n-        } else if attr.check_name(\"naked\") {\n-            naked(llfn, true);\n-        } else if attr.check_name(\"allocator\") {\n-            Attribute::NoAlias.apply_llfn(\n-                llvm::AttributePlace::ReturnValue, llfn);\n-        } else if attr.check_name(\"unwind\") {\n-            unwind(llfn, true);\n-        } else if attr.check_name(\"rustc_allocator_nounwind\") {\n-            unwind(llfn, false);\n-        }\n+    if trans_fn_attrs.flags.contains(TransFnAttrFlags::COLD) {\n+        Attribute::Cold.apply_llfn(Function, llfn);\n+    }\n+    if trans_fn_attrs.flags.contains(TransFnAttrFlags::NAKED) {\n+        naked(llfn, true);\n+    }\n+    if trans_fn_attrs.flags.contains(TransFnAttrFlags::ALLOCATOR) {\n+        Attribute::NoAlias.apply_llfn(\n+            llvm::AttributePlace::ReturnValue, llfn);\n+    }\n+    if trans_fn_attrs.flags.contains(TransFnAttrFlags::UNWIND) {\n+        unwind(llfn, true);\n+    }\n+    if trans_fn_attrs.flags.contains(TransFnAttrFlags::RUSTC_ALLOCATOR_NOUNWIND) {\n+        unwind(llfn, false);\n     }\n \n-    let target_features = cx.tcx.target_features_enabled(id);\n-    if !target_features.is_empty() {\n-        let val = CString::new(target_features.join(\",\")).unwrap();\n+    let features =\n+        trans_fn_attrs.target_features\n+        .iter()\n+        .map(|f| {\n+            let feature = &*f.as_str();\n+            format!(\"+{}\", llvm_util::to_llvm_feature(cx.tcx.sess, feature))\n+        })\n+        .collect::<Vec<String>>()\n+        .join(\",\");\n+\n+    if !features.is_empty() {\n+        let val = CString::new(features).unwrap();\n         llvm::AddFunctionAttrStringValue(\n             llfn, llvm::AttributePlace::Function,\n             cstr(\"target-features\\0\"), &val);\n@@ -145,89 +153,4 @@ pub fn provide(providers: &mut Providers) {\n             .map(|c| c.to_string())\n             .collect())\n     };\n-\n-    providers.target_features_enabled = |tcx, id| {\n-        let whitelist = tcx.target_features_whitelist(LOCAL_CRATE);\n-        let mut target_features = Vec::new();\n-        for attr in tcx.get_attrs(id).iter() {\n-            if !attr.check_name(\"target_feature\") {\n-                continue\n-            }\n-            if let Some(val) = attr.value_str() {\n-                for feat in val.as_str().split(\",\").map(|f| f.trim()) {\n-                    if !feat.is_empty() && !feat.contains('\\0') {\n-                        target_features.push(feat.to_string());\n-                    }\n-                }\n-                let msg = \"#[target_feature = \\\"..\\\"] is deprecated and will \\\n-                           eventually be removed, use \\\n-                           #[target_feature(enable = \\\"..\\\")] instead\";\n-                tcx.sess.span_warn(attr.span, &msg);\n-                continue\n-            }\n-\n-            if tcx.fn_sig(id).unsafety() == Unsafety::Normal {\n-                let msg = \"#[target_feature(..)] can only be applied to \\\n-                           `unsafe` function\";\n-                tcx.sess.span_err(attr.span, msg);\n-            }\n-            from_target_feature(tcx, attr, &whitelist, &mut target_features);\n-        }\n-        Lrc::new(target_features)\n-    };\n-}\n-\n-fn from_target_feature(\n-    tcx: TyCtxt,\n-    attr: &ast::Attribute,\n-    whitelist: &FxHashSet<String>,\n-    target_features: &mut Vec<String>,\n-) {\n-    let list = match attr.meta_item_list() {\n-        Some(list) => list,\n-        None => {\n-            let msg = \"#[target_feature] attribute must be of the form \\\n-                       #[target_feature(..)]\";\n-            tcx.sess.span_err(attr.span, &msg);\n-            return\n-        }\n-    };\n-\n-    for item in list {\n-        if !item.check_name(\"enable\") {\n-            let msg = \"#[target_feature(..)] only accepts sub-keys of `enable` \\\n-                       currently\";\n-            tcx.sess.span_err(item.span, &msg);\n-            continue\n-        }\n-        let value = match item.value_str() {\n-            Some(list) => list,\n-            None => {\n-                let msg = \"#[target_feature] attribute must be of the form \\\n-                           #[target_feature(enable = \\\"..\\\")]\";\n-                tcx.sess.span_err(item.span, &msg);\n-                continue\n-            }\n-        };\n-        let value = value.as_str();\n-        for feature in value.split(',') {\n-            if whitelist.contains(feature) {\n-                let llvm_feature = llvm_util::to_llvm_feature(&tcx.sess, feature);\n-                target_features.push(format!(\"+{}\", llvm_feature));\n-                continue\n-            }\n-\n-            let msg = format!(\"the feature named `{}` is not valid for \\\n-                               this target\", feature);\n-            let mut err = tcx.sess.struct_span_err(item.span, &msg);\n-\n-            if feature.starts_with(\"+\") {\n-                let valid = whitelist.contains(&feature[1..]);\n-                if valid {\n-                    err.help(\"consider removing the leading `+` in the feature name\");\n-                }\n-            }\n-            err.emit();\n-        }\n-    }\n }"}, {"sha": "fd79ae7435ed1b74857c187b5aaa5d8fcde9b661", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -13,6 +13,7 @@ use std::sync::Arc;\n \n use monomorphize::Instance;\n use rustc::hir;\n+use rustc::hir::TransFnAttrFlags;\n use rustc::hir::def_id::CrateNum;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::middle::exported_symbols::{SymbolExportLevel, ExportedSymbol, metadata_symbol_name};\n@@ -21,7 +22,6 @@ use rustc::ty::{TyCtxt, SymbolName};\n use rustc::ty::maps::Providers;\n use rustc::util::nodemap::{FxHashMap, DefIdSet};\n use rustc_allocator::ALLOCATOR_METHODS;\n-use syntax::attr;\n \n pub type ExportedSymbols = FxHashMap<\n     CrateNum,\n@@ -256,9 +256,10 @@ fn symbol_export_level_provider(tcx: TyCtxt, sym_def_id: DefId) -> SymbolExportL\n     // special symbols in the standard library for various plumbing between\n     // core/std/allocators/etc. For example symbols used to hook up allocation\n     // are not considered for export\n-    let is_extern = tcx.contains_extern_indicator(sym_def_id);\n-    let std_internal = attr::contains_name(&tcx.get_attrs(sym_def_id),\n-                                           \"rustc_std_internal_symbol\");\n+    let trans_fn_attrs = tcx.trans_fn_attrs(sym_def_id);\n+    let is_extern = trans_fn_attrs.contains_extern_indicator();\n+    let std_internal = trans_fn_attrs.flags.contains(TransFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL);\n+\n     if is_extern && !std_internal {\n         SymbolExportLevel::C\n     } else {"}, {"sha": "3708f6f6ec4fcf0124c11a8c762d0d5d592c3335", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -90,7 +90,6 @@ use syntax::ast;\n use mir::operand::OperandValue;\n \n pub use rustc_trans_utils::check_for_rustc_errors_attr;\n-pub use rustc_mir::monomorphize::item::linkage_by_name;\n \n pub struct StatRecorder<'a, 'tcx: 'a> {\n     cx: &'a CodegenCx<'a, 'tcx>,"}, {"sha": "7c4e2340d5bdc4dcaecf9f8ede17c813096c80dc", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -44,7 +44,7 @@ pub fn type_needs_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> b\n }\n \n pub fn type_is_sized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n-    ty.is_sized(tcx, ty::ParamEnv::empty(traits::Reveal::All), DUMMY_SP)\n+    ty.is_sized(tcx.at(DUMMY_SP), ty::ParamEnv::empty(traits::Reveal::All))\n }\n \n pub fn type_is_freeze<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {"}, {"sha": "0ce3f729305b41cac5369c25c62cfabecdbe441b", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -146,20 +146,12 @@ pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n             hir_map::NodeForeignItem(&hir::ForeignItem {\n                 ref attrs, span, node: hir::ForeignItemStatic(..), ..\n             }) => {\n-\n-                let g = if let Some(name) =\n-                        attr::first_attr_value_str_by_name(&attrs, \"linkage\") {\n+                let g = if let Some(linkage) = cx.tcx.trans_fn_attrs(def_id).linkage {\n                     // If this is a static with a linkage specified, then we need to handle\n                     // it a little specially. The typesystem prevents things like &T and\n                     // extern \"C\" fn() from being non-null, so we can't just declare a\n                     // static and call it a day. Some linkages (like weak) will make it such\n                     // that the static actually has a null value.\n-                    let linkage = match base::linkage_by_name(&name.as_str()) {\n-                        Some(linkage) => linkage,\n-                        None => {\n-                            cx.sess().span_fatal(span, \"invalid linkage specified\");\n-                        }\n-                    };\n                     let llty2 = match ty.sty {\n                         ty::TyRawPtr(ref mt) => cx.layout_of(mt.ty).llvm_type(cx),\n                         _ => {"}, {"sha": "dc5e788959448ac6f2e8b4c4ec14695607eb56c8", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -435,7 +435,7 @@ impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n \n     pub fn type_has_metadata(&self, ty: Ty<'tcx>) -> bool {\n         use syntax_pos::DUMMY_SP;\n-        if ty.is_sized(self.tcx, ty::ParamEnv::empty(traits::Reveal::All), DUMMY_SP) {\n+        if ty.is_sized(self.tcx.at(DUMMY_SP), ty::ParamEnv::empty(traits::Reveal::All)) {\n             return false;\n         }\n "}, {"sha": "74df5127269a7d23014ba3ffc7888a0ce97695b9", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -50,7 +50,7 @@ extern crate rustc_allocator;\n extern crate rustc_apfloat;\n extern crate rustc_back;\n extern crate rustc_const_math;\n-extern crate rustc_data_structures;\n+#[macro_use] extern crate rustc_data_structures;\n extern crate rustc_demangle;\n extern crate rustc_incremental;\n extern crate rustc_llvm as llvm;"}, {"sha": "9483420f2f0e79f670f0b4251a18f97fd8dce77f", "filename": "src/librustc_trans/metadata.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_trans%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_trans%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmetadata.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -15,17 +15,19 @@ use llvm;\n use llvm::{False, ObjectFile, mk_section_iter};\n use llvm::archive_ro::ArchiveRO;\n \n-use rustc_data_structures::owning_ref::{ErasedBoxRef, OwningRef};\n+use rustc_data_structures::owning_ref::OwningRef;\n use std::path::Path;\n use std::ptr;\n use std::slice;\n \n+pub use rustc_data_structures::sync::MetadataRef;\n+\n pub const METADATA_FILENAME: &str = \"rust.metadata.bin\";\n \n pub struct LlvmMetadataLoader;\n \n impl MetadataLoader for LlvmMetadataLoader {\n-    fn get_rlib_metadata(&self, _: &Target, filename: &Path) -> Result<ErasedBoxRef<[u8]>, String> {\n+    fn get_rlib_metadata(&self, _: &Target, filename: &Path) -> Result<MetadataRef, String> {\n         // Use ArchiveRO for speed here, it's backed by LLVM and uses mmap\n         // internally to read the file. We also avoid even using a memcpy by\n         // just keeping the archive along while the metadata is in use.\n@@ -47,13 +49,13 @@ impl MetadataLoader for LlvmMetadataLoader {\n                                 filename.display())\n                     })\n             })?;\n-        Ok(buf.erase_owner())\n+        Ok(rustc_erase_owner!(buf))\n     }\n \n     fn get_dylib_metadata(&self,\n                           target: &Target,\n                           filename: &Path)\n-                          -> Result<ErasedBoxRef<[u8]>, String> {\n+                          -> Result<MetadataRef, String> {\n         unsafe {\n             let buf = common::path2cstr(filename);\n             let mb = llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf.as_ptr());\n@@ -65,7 +67,7 @@ impl MetadataLoader for LlvmMetadataLoader {\n                 .ok_or_else(|| format!(\"provided path not an object file: '{}'\",\n                                         filename.display()))?;\n             let buf = of.try_map(|of| search_meta_section(of, target, filename))?;\n-            Ok(buf.erase_owner())\n+            Ok(rustc_erase_owner!(buf))\n         }\n     }\n }"}, {"sha": "13fa15faf4123048174da692bd8aa276b75a7a26", "filename": "src/librustc_trans_utils/diagnostics.rs", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4cdbac639af2074b8a07b4391b4e3e28b4118487/src%2Flibrustc_trans_utils%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cdbac639af2074b8a07b4391b4e3e28b4118487/src%2Flibrustc_trans_utils%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Fdiagnostics.rs?ref=4cdbac639af2074b8a07b4391b4e3e28b4118487", "patch": "@@ -1,38 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(non_snake_case)]\n-\n-register_long_diagnostics! {\n-\n-E0558: r##\"\n-The `export_name` attribute was malformed.\n-\n-Erroneous code example:\n-\n-```ignore (error-emitted-at-codegen-which-cannot-be-handled-by-compile_fail)\n-#[export_name] // error: export_name attribute has invalid format\n-pub fn something() {}\n-\n-fn main() {}\n-```\n-\n-The `export_name` attribute expects a string in order to determine the name of\n-the exported symbol. Example:\n-\n-```\n-#[export_name = \"some_function\"] // ok!\n-pub fn something() {}\n-\n-fn main() {}\n-```\n-\"##,\n-\n-}"}, {"sha": "6a3fd21f3a771580390119ac49ff7e9ff7a02a9a", "filename": "src/librustc_trans_utils/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_trans_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_trans_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Flib.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -37,16 +37,14 @@ extern crate rustc;\n extern crate rustc_back;\n extern crate rustc_mir;\n extern crate rustc_incremental;\n-#[macro_use]\n extern crate syntax;\n extern crate syntax_pos;\n-extern crate rustc_data_structures;\n+#[macro_use] extern crate rustc_data_structures;\n \n pub extern crate rustc as __rustc;\n \n use rustc::ty::TyCtxt;\n \n-pub mod diagnostics;\n pub mod link;\n pub mod trans_crate;\n pub mod symbol_names;"}, {"sha": "f9f93730255e6e302409d59615671653c1030cbf", "filename": "src/librustc_trans_utils/symbol_names.rs", "status": "modified", "additions": 1, "deletions": 24, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_trans_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_trans_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Fsymbol_names.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -120,29 +120,6 @@ pub fn provide(providers: &mut Providers) {\n         def_symbol_name,\n         symbol_name,\n \n-        export_name: |tcx, id| {\n-            tcx.get_attrs(id).iter().fold(None, |ia, attr| {\n-                if attr.check_name(\"export_name\") {\n-                    if let s @ Some(_) = attr.value_str() {\n-                        s\n-                    } else {\n-                        struct_span_err!(tcx.sess, attr.span, E0558,\n-                                         \"export_name attribute has invalid format\")\n-                            .span_label(attr.span, \"did you mean #[export_name=\\\"*\\\"]?\")\n-                            .emit();\n-                        None\n-                    }\n-                } else {\n-                    ia\n-                }\n-            })\n-        },\n-\n-        contains_extern_indicator: |tcx, id| {\n-            attr::contains_name(&tcx.get_attrs(id), \"no_mangle\") ||\n-                tcx.export_name(id).is_some()\n-        },\n-\n         ..*providers\n     };\n }\n@@ -287,7 +264,7 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n         return tcx.item_name(def_id).to_string();\n     }\n \n-    if let Some(name) = tcx.export_name(def_id) {\n+    if let Some(name) = tcx.trans_fn_attrs(def_id).export_name {\n         // Use provided name\n         return name.to_string();\n     }"}, {"sha": "0d4811c4b025dfd05c14eeaf3a9b5ac93f6ed70f", "filename": "src/librustc_trans_utils/trans_crate.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_trans_utils%2Ftrans_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_trans_utils%2Ftrans_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Ftrans_crate.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -28,7 +28,7 @@ use std::fs::File;\n use std::path::Path;\n use std::sync::mpsc;\n \n-use rustc_data_structures::owning_ref::{ErasedBoxRef, OwningRef};\n+use rustc_data_structures::owning_ref::OwningRef;\n use rustc_data_structures::sync::Lrc;\n use ar::{Archive, Builder, Header};\n use flate2::Compression;\n@@ -44,9 +44,12 @@ use rustc::middle::cstore::EncodedMetadata;\n use rustc::middle::cstore::MetadataLoader;\n use rustc::dep_graph::DepGraph;\n use rustc_back::target::Target;\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_mir::monomorphize::collector;\n use link::{build_link_meta, out_filename};\n \n+pub use rustc_data_structures::sync::MetadataRef;\n+\n pub trait TransCrate {\n     fn init(&self, _sess: &Session) {}\n     fn print(&self, _req: PrintRequest, _sess: &Session) {}\n@@ -119,23 +122,23 @@ impl MetadataLoader for DummyMetadataLoader {\n         &self,\n         _target: &Target,\n         _filename: &Path\n-    ) -> Result<ErasedBoxRef<[u8]>, String> {\n+    ) -> Result<MetadataRef, String> {\n         bug!(\"DummyMetadataLoader::get_rlib_metadata\");\n     }\n \n     fn get_dylib_metadata(\n         &self,\n         _target: &Target,\n         _filename: &Path\n-    ) -> Result<ErasedBoxRef<[u8]>, String> {\n+    ) -> Result<MetadataRef, String> {\n         bug!(\"DummyMetadataLoader::get_dylib_metadata\");\n     }\n }\n \n pub struct NoLlvmMetadataLoader;\n \n impl MetadataLoader for NoLlvmMetadataLoader {\n-    fn get_rlib_metadata(&self, _: &Target, filename: &Path) -> Result<ErasedBoxRef<[u8]>, String> {\n+    fn get_rlib_metadata(&self, _: &Target, filename: &Path) -> Result<MetadataRef, String> {\n         let file = File::open(filename)\n             .map_err(|e| format!(\"metadata file open err: {:?}\", e))?;\n         let mut archive = Archive::new(file);\n@@ -147,7 +150,7 @@ impl MetadataLoader for NoLlvmMetadataLoader {\n                 let mut buf = Vec::new();\n                 io::copy(&mut entry, &mut buf).unwrap();\n                 let buf: OwningRef<Vec<u8>, [u8]> = OwningRef::new(buf).into();\n-                return Ok(buf.map_owner_box().erase_owner());\n+                return Ok(rustc_erase_owner!(buf.map_owner_box()));\n             }\n         }\n \n@@ -158,7 +161,7 @@ impl MetadataLoader for NoLlvmMetadataLoader {\n         &self,\n         _target: &Target,\n         _filename: &Path,\n-    ) -> Result<ErasedBoxRef<[u8]>, String> {\n+    ) -> Result<MetadataRef, String> {\n         // FIXME: Support reading dylibs from llvm enabled rustc\n         self.get_rlib_metadata(_target, _filename)\n     }\n@@ -198,8 +201,9 @@ impl TransCrate for MetadataOnlyTransCrate {\n \n     fn provide(&self, providers: &mut Providers) {\n         ::symbol_names::provide(providers);\n-        providers.target_features_enabled = |_tcx, _id| {\n-            Lrc::new(Vec::new()) // Just a dummy\n+\n+        providers.target_features_whitelist = |_tcx, _cnum| {\n+            Lrc::new(FxHashSet()) // Just a dummy\n         };\n     }\n     fn provide_extern(&self, _providers: &mut Providers) {}\n@@ -233,12 +237,8 @@ impl TransCrate for MetadataOnlyTransCrate {\n                 MonoItem::Fn(inst) => {\n                     let def_id = inst.def_id();\n                     if def_id.is_local()  {\n-                        let _ = tcx.export_name(def_id);\n-                        let _ = tcx.contains_extern_indicator(def_id);\n                         let _ = inst.def.is_inline(tcx);\n-                        let attrs = inst.def.attrs(tcx);\n-                        let _ =\n-                            ::syntax::attr::find_inline_attr(Some(tcx.sess.diagnostic()), &attrs);\n+                        let _ = tcx.trans_fn_attrs(def_id);\n                     }\n                 }\n                 _ => {}"}, {"sha": "72e4b726a22b4594b77582b3f6bd20da8662c6a1", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -255,7 +255,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let opt_trait_ref = match obligation.predicate {\n                     ty::Predicate::Projection(ref data) => Some(data.to_poly_trait_ref(self.tcx)),\n                     ty::Predicate::Trait(ref data) => Some(data.to_poly_trait_ref()),\n-                    ty::Predicate::Equate(..) => None,\n                     ty::Predicate::Subtype(..) => None,\n                     ty::Predicate::RegionOutlives(..) => None,\n                     ty::Predicate::TypeOutlives(..) => None,"}, {"sha": "4d344eb2799032f3d293ca72d169a5a3adf450cb", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -635,7 +635,6 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                             _ => None,\n                         }\n                     }\n-                    ty::Predicate::Equate(..) |\n                     ty::Predicate::Subtype(..) |\n                     ty::Predicate::Projection(..) |\n                     ty::Predicate::RegionOutlives(..) |"}, {"sha": "1a7d8bb56780eb7cb7b444e7aa304bcec007648c", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 190, "deletions": 2, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -30,25 +30,29 @@ use constrained_type_params as ctp;\n use middle::lang_items::SizedTraitLangItem;\n use middle::const_val::ConstVal;\n use middle::resolve_lifetime as rl;\n+use rustc::mir::mono::Linkage;\n use rustc::traits::Reveal;\n use rustc::ty::subst::Substs;\n use rustc::ty::{ToPredicate, ReprOptions};\n use rustc::ty::{self, AdtKind, ToPolyTraitRef, Ty, TyCtxt};\n use rustc::ty::maps::Providers;\n use rustc::ty::util::IntTypeExt;\n+use rustc::util::nodemap::FxHashSet;\n use util::nodemap::FxHashMap;\n \n use rustc_const_math::ConstInt;\n \n use syntax::{abi, ast};\n+use syntax::ast::MetaItemKind;\n+use syntax::attr::{InlineAttr, list_contains_name, mark_used};\n use syntax::codemap::Spanned;\n use syntax::symbol::{Symbol, keywords};\n use syntax_pos::{Span, DUMMY_SP};\n \n-use rustc::hir::{self, map as hir_map};\n+use rustc::hir::{self, map as hir_map, TransFnAttrs, TransFnAttrFlags, Unsafety};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::def::{Def, CtorKind};\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n \n ///////////////////////////////////////////////////////////////////////////\n // Main entry point\n@@ -71,6 +75,7 @@ pub fn provide(providers: &mut Providers) {\n         impl_trait_ref,\n         impl_polarity,\n         is_foreign_item,\n+        trans_fn_attrs,\n         ..*providers\n     };\n }\n@@ -1723,3 +1728,186 @@ fn is_foreign_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         _ => bug!(\"is_foreign_item applied to non-local def-id {:?}\", def_id)\n     }\n }\n+\n+fn from_target_feature(\n+    tcx: TyCtxt,\n+    attr: &ast::Attribute,\n+    whitelist: &FxHashSet<String>,\n+    target_features: &mut Vec<Symbol>,\n+) {\n+    let list = match attr.meta_item_list() {\n+        Some(list) => list,\n+        None => {\n+            let msg = \"#[target_feature] attribute must be of the form \\\n+                       #[target_feature(..)]\";\n+            tcx.sess.span_err(attr.span, &msg);\n+            return\n+        }\n+    };\n+\n+    for item in list {\n+        if !item.check_name(\"enable\") {\n+            let msg = \"#[target_feature(..)] only accepts sub-keys of `enable` \\\n+                       currently\";\n+            tcx.sess.span_err(item.span, &msg);\n+            continue\n+        }\n+        let value = match item.value_str() {\n+            Some(list) => list,\n+            None => {\n+                let msg = \"#[target_feature] attribute must be of the form \\\n+                           #[target_feature(enable = \\\"..\\\")]\";\n+                tcx.sess.span_err(item.span, &msg);\n+                continue\n+            }\n+        };\n+        let value = value.as_str();\n+        for feature in value.split(',') {\n+            if whitelist.contains(feature) {\n+                target_features.push(Symbol::intern(feature));\n+                continue\n+            }\n+\n+            let msg = format!(\"the feature named `{}` is not valid for \\\n+                               this target\", feature);\n+            let mut err = tcx.sess.struct_span_err(item.span, &msg);\n+\n+            if feature.starts_with(\"+\") {\n+                let valid = whitelist.contains(&feature[1..]);\n+                if valid {\n+                    err.help(\"consider removing the leading `+` in the feature name\");\n+                }\n+            }\n+            err.emit();\n+        }\n+    }\n+}\n+\n+fn linkage_by_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId, name: &str) -> Linkage {\n+    use rustc::mir::mono::Linkage::*;\n+\n+    // Use the names from src/llvm/docs/LangRef.rst here. Most types are only\n+    // applicable to variable declarations and may not really make sense for\n+    // Rust code in the first place but whitelist them anyway and trust that\n+    // the user knows what s/he's doing. Who knows, unanticipated use cases\n+    // may pop up in the future.\n+    //\n+    // ghost, dllimport, dllexport and linkonce_odr_autohide are not supported\n+    // and don't have to be, LLVM treats them as no-ops.\n+    match name {\n+        \"appending\" => Appending,\n+        \"available_externally\" => AvailableExternally,\n+        \"common\" => Common,\n+        \"extern_weak\" => ExternalWeak,\n+        \"external\" => External,\n+        \"internal\" => Internal,\n+        \"linkonce\" => LinkOnceAny,\n+        \"linkonce_odr\" => LinkOnceODR,\n+        \"private\" => Private,\n+        \"weak\" => WeakAny,\n+        \"weak_odr\" => WeakODR,\n+        _ => {\n+            let span = tcx.hir.span_if_local(def_id);\n+            if let Some(span) = span {\n+                tcx.sess.span_fatal(span, \"invalid linkage specified\")\n+            } else {\n+                tcx.sess.fatal(&format!(\"invalid linkage specified: {}\", name))\n+            }\n+        }\n+    }\n+}\n+\n+fn trans_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> TransFnAttrs {\n+    let attrs = tcx.get_attrs(id);\n+\n+    let mut trans_fn_attrs = TransFnAttrs::new();\n+\n+    let whitelist = tcx.target_features_whitelist(LOCAL_CRATE);\n+\n+    for attr in attrs.iter() {\n+        if attr.check_name(\"cold\") {\n+            trans_fn_attrs.flags |= TransFnAttrFlags::COLD;\n+        } else if attr.check_name(\"allocator\") {\n+            trans_fn_attrs.flags |= TransFnAttrFlags::ALLOCATOR;\n+        } else if attr.check_name(\"unwind\") {\n+            trans_fn_attrs.flags |= TransFnAttrFlags::UNWIND;\n+        } else if attr.check_name(\"rustc_allocator_nounwind\") {\n+            trans_fn_attrs.flags |= TransFnAttrFlags::RUSTC_ALLOCATOR_NOUNWIND;\n+        } else if attr.check_name(\"naked\") {\n+            trans_fn_attrs.flags |= TransFnAttrFlags::NAKED;\n+        } else if attr.check_name(\"no_mangle\") {\n+            trans_fn_attrs.flags |= TransFnAttrFlags::NO_MANGLE;\n+        } else if attr.check_name(\"rustc_std_internal_symbol\") {\n+            trans_fn_attrs.flags |= TransFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL;\n+        } else if attr.check_name(\"inline\") {\n+            trans_fn_attrs.inline = attrs.iter().fold(InlineAttr::None, |ia, attr| {\n+                if attr.path != \"inline\" {\n+                    return ia;\n+                }\n+                let meta = match attr.meta() {\n+                    Some(meta) => meta.node,\n+                    None => return ia,\n+                };\n+                match meta {\n+                    MetaItemKind::Word => {\n+                        mark_used(attr);\n+                        InlineAttr::Hint\n+                    }\n+                    MetaItemKind::List(ref items) => {\n+                        mark_used(attr);\n+                        if items.len() != 1 {\n+                            span_err!(tcx.sess.diagnostic(), attr.span, E0534,\n+                                        \"expected one argument\");\n+                            InlineAttr::None\n+                        } else if list_contains_name(&items[..], \"always\") {\n+                            InlineAttr::Always\n+                        } else if list_contains_name(&items[..], \"never\") {\n+                            InlineAttr::Never\n+                        } else {\n+                            span_err!(tcx.sess.diagnostic(), items[0].span, E0535,\n+                                        \"invalid argument\");\n+\n+                            InlineAttr::None\n+                        }\n+                    }\n+                    _ => ia,\n+                }\n+            });\n+        } else if attr.check_name(\"export_name\") {\n+            if let s @ Some(_) = attr.value_str() {\n+                trans_fn_attrs.export_name = s;\n+            } else {\n+                struct_span_err!(tcx.sess, attr.span, E0558,\n+                                    \"export_name attribute has invalid format\")\n+                    .span_label(attr.span, \"did you mean #[export_name=\\\"*\\\"]?\")\n+                    .emit();\n+            }\n+        } else if attr.check_name(\"target_feature\") {\n+            if let Some(val) = attr.value_str() {\n+                for feat in val.as_str().split(\",\").map(|f| f.trim()) {\n+                    if !feat.is_empty() && !feat.contains('\\0') {\n+                        trans_fn_attrs.target_features.push(Symbol::intern(feat));\n+                    }\n+                }\n+                let msg = \"#[target_feature = \\\"..\\\"] is deprecated and will \\\n+                           eventually be removed, use \\\n+                           #[target_feature(enable = \\\"..\\\")] instead\";\n+                tcx.sess.span_warn(attr.span, &msg);\n+                continue\n+            }\n+\n+            if tcx.fn_sig(id).unsafety() == Unsafety::Normal {\n+                let msg = \"#[target_feature(..)] can only be applied to \\\n+                           `unsafe` function\";\n+                tcx.sess.span_err(attr.span, msg);\n+            }\n+            from_target_feature(tcx, attr, &whitelist, &mut trans_fn_attrs.target_features);\n+        } else if attr.check_name(\"linkage\") {\n+            if let Some(val) = attr.value_str() {\n+                trans_fn_attrs.linkage = Some(linkage_by_name(tcx, id, &val.as_str()));\n+            }\n+        }\n+    }\n+\n+    trans_fn_attrs\n+}"}, {"sha": "96b2ec745f132266794706278fa2fdf2a48d04eb", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -3705,6 +3705,98 @@ match r {\n ```\n \"##,\n \n+E0534: r##\"\n+The `inline` attribute was malformed.\n+\n+Erroneous code example:\n+\n+```ignore (compile_fail not working here; see Issue #43707)\n+#[inline()] // error: expected one argument\n+pub fn something() {}\n+\n+fn main() {}\n+```\n+\n+The parenthesized `inline` attribute requires the parameter to be specified:\n+\n+```\n+#[inline(always)]\n+fn something() {}\n+```\n+\n+or:\n+\n+```\n+#[inline(never)]\n+fn something() {}\n+```\n+\n+Alternatively, a paren-less version of the attribute may be used to hint the\n+compiler about inlining opportunity:\n+\n+```\n+#[inline]\n+fn something() {}\n+```\n+\n+For more information about the inline attribute, read:\n+https://doc.rust-lang.org/reference.html#inline-attributes\n+\"##,\n+\n+E0535: r##\"\n+An unknown argument was given to the `inline` attribute.\n+\n+Erroneous code example:\n+\n+```ignore (compile_fail not working here; see Issue #43707)\n+#[inline(unknown)] // error: invalid argument\n+pub fn something() {}\n+\n+fn main() {}\n+```\n+\n+The `inline` attribute only supports two arguments:\n+\n+ * always\n+ * never\n+\n+All other arguments given to the `inline` attribute will return this error.\n+Example:\n+\n+```\n+#[inline(never)] // ok!\n+pub fn something() {}\n+\n+fn main() {}\n+```\n+\n+For more information about the inline attribute, https:\n+read://doc.rust-lang.org/reference.html#inline-attributes\n+\"##,\n+\n+E0558: r##\"\n+The `export_name` attribute was malformed.\n+\n+Erroneous code example:\n+\n+```ignore (error-emitted-at-codegen-which-cannot-be-handled-by-compile_fail)\n+#[export_name] // error: export_name attribute has invalid format\n+pub fn something() {}\n+\n+fn main() {}\n+```\n+\n+The `export_name` attribute expects a string in order to determine the name of\n+the exported symbol. Example:\n+\n+```\n+#[export_name = \"some_function\"] // ok!\n+pub fn something() {}\n+\n+fn main() {}\n+```\n+\"##,\n+\n E0559: r##\"\n An unknown field was specified into an enum's structure variant.\n "}, {"sha": "d0230a69374d48167f11aa87f5c97d7aa82f2efe", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -1535,7 +1535,6 @@ impl<'a> Clean<WherePredicate> for ty::Predicate<'a> {\n \n         match *self {\n             Predicate::Trait(ref pred) => pred.clean(cx),\n-            Predicate::Equate(ref pred) => pred.clean(cx),\n             Predicate::Subtype(ref pred) => pred.clean(cx),\n             Predicate::RegionOutlives(ref pred) => pred.clean(cx),\n             Predicate::TypeOutlives(ref pred) => pred.clean(cx),\n@@ -1557,16 +1556,6 @@ impl<'a> Clean<WherePredicate> for ty::TraitPredicate<'a> {\n     }\n }\n \n-impl<'tcx> Clean<WherePredicate> for ty::EquatePredicate<'tcx> {\n-    fn clean(&self, cx: &DocContext) -> WherePredicate {\n-        let ty::EquatePredicate(ref lhs, ref rhs) = *self;\n-        WherePredicate::EqPredicate {\n-            lhs: lhs.clean(cx),\n-            rhs: rhs.clean(cx)\n-        }\n-    }\n-}\n-\n impl<'tcx> Clean<WherePredicate> for ty::SubtypePredicate<'tcx> {\n     fn clean(&self, _cx: &DocContext) -> WherePredicate {\n         panic!(\"subtype predicates are an internal rustc artifact \\"}, {"sha": "0151a8c3ab715df645f20d7194b9e478ebb02952", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -28,6 +28,7 @@ pub struct Page<'a> {\n     pub root_path: &'a str,\n     pub description: &'a str,\n     pub keywords: &'a str,\n+    pub resource_suffix: &'a str,\n }\n \n pub fn render<T: fmt::Display, S: fmt::Display>(\n@@ -47,12 +48,13 @@ r##\"<!DOCTYPE html>\n \n     <title>{title}</title>\n \n-    <link rel=\"stylesheet\" type=\"text/css\" href=\"{root_path}normalize.css\">\n-    <link rel=\"stylesheet\" type=\"text/css\" href=\"{root_path}rustdoc.css\" id=\"mainThemeStyle\">\n+    <link rel=\"stylesheet\" type=\"text/css\" href=\"{root_path}normalize{suffix}.css\">\n+    <link rel=\"stylesheet\" type=\"text/css\" href=\"{root_path}rustdoc{suffix}.css\"\n+          id=\"mainThemeStyle\">\n     {themes}\n-    <link rel=\"stylesheet\" type=\"text/css\" href=\"{root_path}dark.css\">\n-    <link rel=\"stylesheet\" type=\"text/css\" href=\"{root_path}main.css\" id=\"themeStyle\">\n-    <script src=\"{root_path}storage.js\"></script>\n+    <link rel=\"stylesheet\" type=\"text/css\" href=\"{root_path}dark{suffix}.css\">\n+    <link rel=\"stylesheet\" type=\"text/css\" href=\"{root_path}main{suffix}.css\" id=\"themeStyle\">\n+    <script src=\"{root_path}storage{suffix}.js\"></script>\n     {css_extension}\n \n     {favicon}\n@@ -76,11 +78,11 @@ r##\"<!DOCTYPE html>\n \n     <div class=\"theme-picker\">\n         <button id=\"theme-picker\" aria-label=\"Pick another theme!\">\n-            <img src=\"{root_path}brush.svg\" width=\"18\" alt=\"Pick another theme!\">\n+            <img src=\"{root_path}brush{suffix}.svg\" width=\"18\" alt=\"Pick another theme!\">\n         </button>\n         <div id=\"theme-choices\"></div>\n     </div>\n-    <script src=\"{root_path}theme.js\"></script>\n+    <script src=\"{root_path}theme{suffix}.js\"></script>\n     <nav class=\"sub\">\n         <form class=\"search-form js-only\">\n             <div class=\"search-container\">\n@@ -153,13 +155,14 @@ r##\"<!DOCTYPE html>\n         window.rootPath = \"{root_path}\";\n         window.currentCrate = \"{krate}\";\n     </script>\n-    <script src=\"{root_path}main.js\"></script>\n+    <script src=\"{root_path}main{suffix}.js\"></script>\n     <script defer src=\"{root_path}search-index.js\"></script>\n </body>\n </html>\"##,\n     css_extension = if css_file_extension {\n-        format!(\"<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"{root_path}theme.css\\\">\",\n-                root_path = page.root_path)\n+        format!(\"<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"{root_path}theme{suffix}.css\\\">\",\n+                root_path = page.root_path,\n+                suffix=page.resource_suffix)\n     } else {\n         \"\".to_owned()\n     },\n@@ -191,8 +194,10 @@ r##\"<!DOCTYPE html>\n                    .filter_map(|t| t.file_stem())\n                    .filter_map(|t| t.to_str())\n                    .map(|t| format!(r#\"<link rel=\"stylesheet\" type=\"text/css\" href=\"{}{}\">\"#,\n-                                    page.root_path, t))\n+                                    page.root_path,\n+                                    t.replace(\".css\", &format!(\"{}.css\", page.resource_suffix))))\n                    .collect::<String>(),\n+    suffix=page.resource_suffix,\n     )\n }\n "}, {"sha": "6945a6f3724d582d951d2d94bbc0f5e84a718edc", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 36, "deletions": 15, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -32,6 +32,7 @@\n //! for creating the corresponding search index and source file renderings.\n //! These threads are not parallelized (they haven't been a bottleneck yet), and\n //! both occur before the crate is rendered.\n+\n pub use self::ExternalLocation::*;\n \n use std::borrow::Cow;\n@@ -128,6 +129,9 @@ pub struct SharedContext {\n     pub sort_modules_alphabetically: bool,\n     /// Additional themes to be added to the generated docs.\n     pub themes: Vec<PathBuf>,\n+    /// Suffix to be added on resource files (if suffix is \"-v2\" then \"main.css\" becomes\n+    /// \"main-v2.css\").\n+    pub resource_suffix: String,\n }\n \n impl SharedContext {\n@@ -492,6 +496,7 @@ pub fn run(mut krate: clean::Crate,\n            external_html: &ExternalHtml,\n            playground_url: Option<String>,\n            dst: PathBuf,\n+           resource_suffix: String,\n            passes: FxHashSet<String>,\n            css_file_extension: Option<PathBuf>,\n            renderinfo: RenderInfo,\n@@ -520,6 +525,7 @@ pub fn run(mut krate: clean::Crate,\n         created_dirs: RefCell::new(FxHashSet()),\n         sort_modules_alphabetically,\n         themes,\n+        resource_suffix,\n     };\n \n     // If user passed in `--playground-url` arg, we fill in crate name here\n@@ -734,7 +740,7 @@ fn write_shared(cx: &Context,\n     // Add all the static files. These may already exist, but we just\n     // overwrite them anyway to make sure that they're fresh and up-to-date.\n \n-    write(cx.dst.join(\"rustdoc.css\"),\n+    write(cx.dst.join(&format!(\"rustdoc{}.css\", cx.shared.resource_suffix)),\n           include_bytes!(\"static/rustdoc.css\"))?;\n \n     // To avoid \"main.css\" to be overwritten, we'll first run over the received themes and only\n@@ -746,24 +752,28 @@ fn write_shared(cx: &Context,\n \n         let mut f = try_err!(File::open(&entry), &entry);\n         try_err!(f.read_to_end(&mut content), &entry);\n-        write(cx.dst.join(try_none!(entry.file_name(), &entry)), content.as_slice())?;\n-        themes.insert(try_none!(try_none!(entry.file_stem(), &entry).to_str(), &entry).to_owned());\n+        let theme = try_none!(try_none!(entry.file_stem(), &entry).to_str(), &entry);\n+        let extension = try_none!(try_none!(entry.extension(), &entry).to_str(), &entry);\n+        write(cx.dst.join(format!(\"{}{}.{}\", theme, cx.shared.resource_suffix, extension)),\n+              content.as_slice())?;\n+        themes.insert(theme.to_owned());\n     }\n \n-    write(cx.dst.join(\"brush.svg\"),\n+    write(cx.dst.join(&format!(\"brush{}.svg\", cx.shared.resource_suffix)),\n           include_bytes!(\"static/brush.svg\"))?;\n-    write(cx.dst.join(\"main.css\"),\n+    write(cx.dst.join(&format!(\"main{}.css\", cx.shared.resource_suffix)),\n           include_bytes!(\"static/themes/main.css\"))?;\n     themes.insert(\"main\".to_owned());\n-    write(cx.dst.join(\"dark.css\"),\n+    write(cx.dst.join(&format!(\"dark{}.css\", cx.shared.resource_suffix)),\n           include_bytes!(\"static/themes/dark.css\"))?;\n     themes.insert(\"dark\".to_owned());\n \n     let mut themes: Vec<&String> = themes.iter().collect();\n     themes.sort();\n     // To avoid theme switch latencies as much as possible, we put everything theme related\n     // at the beginning of the html files into another js file.\n-    write(cx.dst.join(\"theme.js\"), format!(\n+    write(cx.dst.join(&format!(\"theme{}.js\", cx.shared.resource_suffix)),\n+          format!(\n r#\"var themes = document.getElementById(\"theme-choices\");\n var themePicker = document.getElementById(\"theme-picker\");\n themePicker.onclick = function() {{\n@@ -785,19 +795,28 @@ themePicker.onclick = function() {{\n     }};\n     themes.appendChild(but);\n }});\n-\"#, themes.iter()\n-          .map(|s| format!(\"\\\"{}\\\"\", s))\n-          .collect::<Vec<String>>()\n-          .join(\",\")).as_bytes())?;\n+\"#,\n+                 themes.iter()\n+                       .map(|s| format!(\"\\\"{}\\\"\", s))\n+                       .collect::<Vec<String>>()\n+                       .join(\",\")).as_bytes(),\n+    )?;\n+\n+    write(cx.dst.join(&format!(\"main{}.js\", cx.shared.resource_suffix)),\n+                      include_bytes!(\"static/main.js\"))?;\n \n-    write(cx.dst.join(\"main.js\"), include_bytes!(\"static/main.js\"))?;\n-    write(cx.dst.join(\"storage.js\"), include_bytes!(\"static/storage.js\"))?;\n+    {\n+        let mut data = format!(\"var resourcesSuffix = \\\"{}\\\";\\n\",\n+                               cx.shared.resource_suffix).into_bytes();\n+        data.extend_from_slice(include_bytes!(\"static/storage.js\"));\n+        write(cx.dst.join(&format!(\"storage{}.js\", cx.shared.resource_suffix)), &data)?;\n+    }\n \n     if let Some(ref css) = cx.shared.css_file_extension {\n-        let out = cx.dst.join(\"theme.css\");\n+        let out = cx.dst.join(&format!(\"theme{}.css\", cx.shared.resource_suffix));\n         try_err!(fs::copy(css, out), css);\n     }\n-    write(cx.dst.join(\"normalize.css\"),\n+    write(cx.dst.join(&format!(\"normalize{}.css\", cx.shared.resource_suffix)),\n           include_bytes!(\"static/normalize.css\"))?;\n     write(cx.dst.join(\"FiraSans-Regular.woff\"),\n           include_bytes!(\"static/FiraSans-Regular.woff\"))?;\n@@ -1084,6 +1103,7 @@ impl<'a> SourceCollector<'a> {\n             root_path: &root_path,\n             description: &desc,\n             keywords: BASIC_KEYWORDS,\n+            resource_suffix: &self.scx.resource_suffix,\n         };\n         layout::render(&mut w, &self.scx.layout,\n                        &page, &(\"\"), &Source(contents),\n@@ -1446,6 +1466,7 @@ impl Context {\n             title: &title,\n             description: &desc,\n             keywords: &keywords,\n+            resource_suffix: &self.shared.resource_suffix,\n         };\n \n         reset_ids(true);"}, {"sha": "7e9cfbd6763471a88291f7d6e472ecfabf7ddb5e", "filename": "src/librustdoc/html/static/storage.js", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstorage.js", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstorage.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstorage.js?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -41,7 +41,9 @@ function getCurrentValue(name) {\n }\n \n function switchTheme(styleElem, mainStyleElem, newTheme) {\n-    var newHref = mainStyleElem.href.replace(\"rustdoc.css\", newTheme + \".css\");\n+    var fullBasicCss = \"rustdoc\" + resourcesSuffix + \".css\";\n+    var fullNewTheme = newTheme + resourcesSuffix + \".css\";\n+    var newHref = mainStyleElem.href.replace(fullBasicCss, fullNewTheme);\n     var found = false;\n \n     if (savedHref.length === 0) {"}, {"sha": "702031cfaca3372e5bed84dc58d7ea888c1c09be", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -261,6 +261,13 @@ pub fn opts() -> Vec<RustcOptGroup> {\n                        \"check if given theme is valid\",\n                        \"FILES\")\n         }),\n+        unstable(\"resource-suffix\", |o| {\n+            o.optopt(\"\",\n+                     \"resource-suffix\",\n+                     \"suffix to add to CSS and JavaScript files, e.g. \\\"main.css\\\" will become \\\n+                      \\\"main-suffix.css\\\"\",\n+                     \"PATH\")\n+        }),\n     ]\n }\n \n@@ -417,6 +424,7 @@ pub fn main_args(args: &[String]) -> isize {\n     let display_warnings = matches.opt_present(\"display-warnings\");\n     let linker = matches.opt_str(\"linker\").map(PathBuf::from);\n     let sort_modules_alphabetically = !matches.opt_present(\"sort-modules-by-appearance\");\n+    let resource_suffix = matches.opt_str(\"resource-suffix\");\n \n     match (should_test, markdown_input) {\n         (true, true) => {\n@@ -442,6 +450,7 @@ pub fn main_args(args: &[String]) -> isize {\n             Some(\"html\") | None => {\n                 html::render::run(krate, &external_html, playground_url,\n                                   output.unwrap_or(PathBuf::from(\"doc\")),\n+                                  resource_suffix.unwrap_or(String::new()),\n                                   passes.into_iter().collect(),\n                                   css_file_extension,\n                                   renderinfo,"}, {"sha": "d5ac2d19e831f81c6fa4b7c15d1c6800493277ab", "filename": "src/libstd/process.rs", "status": "modified", "additions": 43, "deletions": 28, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -1080,14 +1080,45 @@ impl fmt::Display for ExitStatus {\n     }\n }\n \n-/// This is ridiculously unstable, as it's a completely-punted-upon part\n-/// of the `?`-in-`main` RFC.  It's here only to allow experimenting with\n-/// returning a code directly from main.  It will definitely change\n-/// drastically before being stabilized, if it doesn't just get deleted.\n-#[doc(hidden)]\n+/// This type represents the status code a process can return to its\n+/// parent under normal termination.\n+///\n+/// Numeric values used in this type don't have portable meanings, and\n+/// different platforms may mask different amounts of them.\n+///\n+/// For the platform's canonical successful and unsuccessful codes, see\n+/// the [`SUCCESS`] and [`FAILURE`] associated items.\n+///\n+/// [`SUCCESS`]: #associatedconstant.SUCCESS\n+/// [`FAILURE`]: #associatedconstant.FAILURE\n+///\n+/// **Warning**: While various forms of this were discussed in [RFC #1937],\n+/// it was ultimately cut from that RFC, and thus this type is more subject\n+/// to change even than the usual unstable item churn.\n+///\n+/// [RFC #1937]: https://github.com/rust-lang/rfcs/pull/1937\n #[derive(Clone, Copy, Debug)]\n-#[unstable(feature = \"process_exitcode_placeholder\", issue = \"43301\")]\n-pub struct ExitCode(pub i32);\n+#[unstable(feature = \"process_exitcode_placeholder\", issue = \"48711\")]\n+pub struct ExitCode(imp::ExitCode);\n+\n+#[unstable(feature = \"process_exitcode_placeholder\", issue = \"48711\")]\n+impl ExitCode {\n+    /// The canonical ExitCode for successful termination on this platform.\n+    ///\n+    /// Note that a `()`-returning `main` implicitly results in a successful\n+    /// termination, so there's no need to return this from `main` unless\n+    /// you're also returning other possible codes.\n+    #[unstable(feature = \"process_exitcode_placeholder\", issue = \"48711\")]\n+    pub const SUCCESS: ExitCode = ExitCode(imp::ExitCode::SUCCESS);\n+\n+    /// The canonical ExitCode for unsuccessful termination on this platform.\n+    ///\n+    /// If you're only returning this and `SUCCESS` from `main`, consider\n+    /// instead returning `Err(_)` and `Ok(())` respectively, which will\n+    /// return the same codes (but will also `eprintln!` the error).\n+    #[unstable(feature = \"process_exitcode_placeholder\", issue = \"48711\")]\n+    pub const FAILURE: ExitCode = ExitCode(imp::ExitCode::FAILURE);\n+}\n \n impl Child {\n     /// Forces the child to exit. This is equivalent to sending a\n@@ -1401,18 +1432,6 @@ pub fn id() -> u32 {\n     ::sys::os::getpid()\n }\n \n-#[cfg(target_arch = \"wasm32\")]\n-mod exit {\n-    pub const SUCCESS: i32 = 0;\n-    pub const FAILURE: i32 = 1;\n-}\n-#[cfg(not(target_arch = \"wasm32\"))]\n-mod exit {\n-    use libc;\n-    pub const SUCCESS: i32 = libc::EXIT_SUCCESS;\n-    pub const FAILURE: i32 = libc::EXIT_FAILURE;\n-}\n-\n /// A trait for implementing arbitrary return types in the `main` function.\n ///\n /// The c-main function only supports to return integers as return type.\n@@ -1433,18 +1452,15 @@ pub trait Termination {\n \n #[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\n impl Termination for () {\n-    fn report(self) -> i32 { exit::SUCCESS }\n+    fn report(self) -> i32 { ExitCode::SUCCESS.report() }\n }\n \n #[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\n impl<E: fmt::Debug> Termination for Result<(), E> {\n     fn report(self) -> i32 {\n         match self {\n-            Ok(val) => val.report(),\n-            Err(err) => {\n-                eprintln!(\"Error: {:?}\", err);\n-                exit::FAILURE\n-            }\n+            Ok(()) => ().report(),\n+            Err(err) => Err::<!, _>(err).report(),\n         }\n     }\n }\n@@ -1459,15 +1475,14 @@ impl<E: fmt::Debug> Termination for Result<!, E> {\n     fn report(self) -> i32 {\n         let Err(err) = self;\n         eprintln!(\"Error: {:?}\", err);\n-        exit::FAILURE\n+        ExitCode::FAILURE.report()\n     }\n }\n \n #[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\n impl Termination for ExitCode {\n     fn report(self) -> i32 {\n-        let ExitCode(code) = self;\n-        code\n+        self.0.as_i32()\n     }\n }\n "}, {"sha": "fcd40c15c1708bf77e63559d5103f9461aa3c132", "filename": "src/libstd/sys/cloudabi/shims/process.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fprocess.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -126,6 +126,18 @@ impl fmt::Display for ExitStatus {\n     }\n }\n \n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+pub struct ExitCode(bool);\n+\n+impl ExitCode {\n+    pub const SUCCESS: ExitCode = ExitCode(false);\n+    pub const FAILURE: ExitCode = ExitCode(true);\n+\n+    pub fn as_i32(&self) -> i32 {\n+        self.0 as i32\n+    }\n+}\n+\n pub struct Process(Void);\n \n impl Process {"}, {"sha": "d0b94e14f54e93e1c4bd14ee117ca523b604a45c", "filename": "src/libstd/sys/redox/process.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -13,6 +13,7 @@ use ffi::OsStr;\n use os::unix::ffi::OsStrExt;\n use fmt;\n use io::{self, Error, ErrorKind};\n+use libc::{EXIT_SUCCESS, EXIT_FAILURE};\n use path::{Path, PathBuf};\n use sys::fd::FileDesc;\n use sys::fs::{File, OpenOptions};\n@@ -480,6 +481,18 @@ impl fmt::Display for ExitStatus {\n     }\n }\n \n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+pub struct ExitCode(u8);\n+\n+impl ExitCode {\n+    pub const SUCCESS: ExitCode = ExitCode(EXIT_SUCCESS as _);\n+    pub const FAILURE: ExitCode = ExitCode(EXIT_FAILURE as _);\n+\n+    pub fn as_i32(&self) -> i32 {\n+        self.0 as i32\n+    }\n+}\n+\n /// The unique id of the process (this should never be negative).\n pub struct Process {\n     pid: usize,"}, {"sha": "d8ac26c45b172982e07543a570e8189237b2f632", "filename": "src/libstd/sys/unix/process/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fmod.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::process_common::{Command, ExitStatus, Stdio, StdioPipes};\n+pub use self::process_common::{Command, ExitStatus, ExitCode, Stdio, StdioPipes};\n pub use self::process_inner::Process;\n \n mod process_common;"}, {"sha": "d0486f06a143af2598f3987ed18054583f4bd552", "filename": "src/libstd/sys/unix/process/process_common.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -13,7 +13,7 @@ use os::unix::prelude::*;\n use ffi::{OsString, OsStr, CString, CStr};\n use fmt;\n use io;\n-use libc::{self, c_int, gid_t, uid_t, c_char};\n+use libc::{self, c_int, gid_t, uid_t, c_char, EXIT_SUCCESS, EXIT_FAILURE};\n use ptr;\n use sys::fd::FileDesc;\n use sys::fs::{File, OpenOptions};\n@@ -393,6 +393,18 @@ impl fmt::Display for ExitStatus {\n     }\n }\n \n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+pub struct ExitCode(u8);\n+\n+impl ExitCode {\n+    pub const SUCCESS: ExitCode = ExitCode(EXIT_SUCCESS as _);\n+    pub const FAILURE: ExitCode = ExitCode(EXIT_FAILURE as _);\n+\n+    pub fn as_i32(&self) -> i32 {\n+        self.0 as i32\n+    }\n+}\n+\n #[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests {\n     use super::*;"}, {"sha": "433e9cec7c8accf78195af2536c004396268f89d", "filename": "src/libstd/sys/wasm/process.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibstd%2Fsys%2Fwasm%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibstd%2Fsys%2Fwasm%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fprocess.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -129,6 +129,18 @@ impl fmt::Display for ExitStatus {\n     }\n }\n \n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+pub struct ExitCode(bool);\n+\n+impl ExitCode {\n+    pub const SUCCESS: ExitCode = ExitCode(false);\n+    pub const FAILURE: ExitCode = ExitCode(true);\n+\n+    pub fn as_i32(&self) -> i32 {\n+        self.0 as i32\n+    }\n+}\n+\n pub struct Process(Void);\n \n impl Process {"}, {"sha": "f1ab9c4760965e38efcf59dbb4b98ebd603dcca9", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -18,7 +18,7 @@ use ffi::{OsString, OsStr};\n use fmt;\n use fs;\n use io::{self, Error, ErrorKind};\n-use libc::c_void;\n+use libc::{c_void, EXIT_SUCCESS, EXIT_FAILURE};\n use mem;\n use os::windows::ffi::OsStrExt;\n use path::Path;\n@@ -408,6 +408,18 @@ impl fmt::Display for ExitStatus {\n     }\n }\n \n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+pub struct ExitCode(c::DWORD);\n+\n+impl ExitCode {\n+    pub const SUCCESS: ExitCode = ExitCode(EXIT_SUCCESS as _);\n+    pub const FAILURE: ExitCode = ExitCode(EXIT_FAILURE as _);\n+\n+    pub fn as_i32(&self) -> i32 {\n+        self.0 as i32\n+    }\n+}\n+\n fn zeroed_startupinfo() -> c::STARTUPINFO {\n     c::STARTUPINFO {\n         cb: 0,"}, {"sha": "4818248129e70a1659a06b85c3c8c85bef99fd48", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 45, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -520,51 +520,14 @@ pub fn find_crate_name(attrs: &[Attribute]) -> Option<Symbol> {\n     first_attr_value_str_by_name(attrs, \"crate_name\")\n }\n \n-#[derive(Copy, Clone, PartialEq)]\n+#[derive(Copy, Clone, Hash, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum InlineAttr {\n     None,\n     Hint,\n     Always,\n     Never,\n }\n \n-/// Determine what `#[inline]` attribute is present in `attrs`, if any.\n-pub fn find_inline_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> InlineAttr {\n-    attrs.iter().fold(InlineAttr::None, |ia, attr| {\n-        if attr.path != \"inline\" {\n-            return ia;\n-        }\n-        let meta = match attr.meta() {\n-            Some(meta) => meta.node,\n-            None => return ia,\n-        };\n-        match meta {\n-            MetaItemKind::Word => {\n-                mark_used(attr);\n-                InlineAttr::Hint\n-            }\n-            MetaItemKind::List(ref items) => {\n-                mark_used(attr);\n-                if items.len() != 1 {\n-                    diagnostic.map(|d|{ span_err!(d, attr.span, E0534, \"expected one argument\"); });\n-                    InlineAttr::None\n-                } else if list_contains_name(&items[..], \"always\") {\n-                    InlineAttr::Always\n-                } else if list_contains_name(&items[..], \"never\") {\n-                    InlineAttr::Never\n-                } else {\n-                    diagnostic.map(|d| {\n-                        span_err!(d, items[0].span, E0535, \"invalid argument\");\n-                    });\n-\n-                    InlineAttr::None\n-                }\n-            }\n-            _ => ia,\n-        }\n-    })\n-}\n-\n #[derive(Copy, Clone, PartialEq)]\n pub enum UnwindAttr {\n     Allowed,\n@@ -610,13 +573,6 @@ pub fn find_unwind_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> Op\n     })\n }\n \n-/// True if `#[inline]` or `#[inline(always)]` is present in `attrs`.\n-pub fn requests_inline(attrs: &[Attribute]) -> bool {\n-    match find_inline_attr(None, attrs) {\n-        InlineAttr::Hint | InlineAttr::Always => true,\n-        InlineAttr::None | InlineAttr::Never => false,\n-    }\n-}\n \n /// Tests if a cfg-pattern matches the cfg set\n pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Features>) -> bool {"}, {"sha": "549ef88afcc63b1811be51180469f24c0d836894", "filename": "src/libsyntax/diagnostic_list.rs", "status": "modified", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibsyntax%2Fdiagnostic_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Flibsyntax%2Fdiagnostic_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic_list.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -37,75 +37,6 @@ More details can be found in [RFC 438].\n [RFC 438]: https://github.com/rust-lang/rfcs/pull/438\n \"##,\n \n-E0534: r##\"\n-The `inline` attribute was malformed.\n-\n-Erroneous code example:\n-\n-```ignore (compile_fail not working here; see Issue #43707)\n-#[inline()] // error: expected one argument\n-pub fn something() {}\n-\n-fn main() {}\n-```\n-\n-The parenthesized `inline` attribute requires the parameter to be specified:\n-\n-```\n-#[inline(always)]\n-fn something() {}\n-```\n-\n-or:\n-\n-```\n-#[inline(never)]\n-fn something() {}\n-```\n-\n-Alternatively, a paren-less version of the attribute may be used to hint the\n-compiler about inlining opportunity:\n-\n-```\n-#[inline]\n-fn something() {}\n-```\n-\n-For more information about the inline attribute, read:\n-https://doc.rust-lang.org/reference.html#inline-attributes\n-\"##,\n-\n-E0535: r##\"\n-An unknown argument was given to the `inline` attribute.\n-\n-Erroneous code example:\n-\n-```ignore (compile_fail not working here; see Issue #43707)\n-#[inline(unknown)] // error: invalid argument\n-pub fn something() {}\n-\n-fn main() {}\n-```\n-\n-The `inline` attribute only supports two arguments:\n-\n- * always\n- * never\n-\n-All other arguments given to the `inline` attribute will return this error.\n-Example:\n-\n-```\n-#[inline(never)] // ok!\n-pub fn something() {}\n-\n-fn main() {}\n-```\n-\n-For more information about the inline attribute, https:\n-read://doc.rust-lang.org/reference.html#inline-attributes\n-\"##,\n-\n E0536: r##\"\n The `not` cfg-predicate was malformed.\n "}, {"sha": "0903c72cbbc3dafcb5c88820e4a8a98c3a764cf3", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -1 +1 @@\n-Subproject commit ba2edd794c7def715007931fcd1b4ce62aa711c8\n+Subproject commit 0903c72cbbc3dafcb5c88820e4a8a98c3a764cf3"}, {"sha": "63af7a0d538e947c7ec47fe2b42289181260f3cc", "filename": "src/rustllvm/llvm-rebuild-trigger", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Frustllvm%2Fllvm-rebuild-trigger", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Frustllvm%2Fllvm-rebuild-trigger", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Fllvm-rebuild-trigger?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -1,4 +1,4 @@\n # If this file is modified, then llvm will be (optionally) cleaned and then rebuilt.\n # The actual contents of this file do not matter, but to trigger a change on the\n # build bots then the contents should be changed so git updates the mtime.\n-2018-02-09\n+2018-03-06"}, {"sha": "b844f2e49e71ed1af9d98d85114d55b1e57b8b80", "filename": "src/test/run-make/save-analysis-fail/foo.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Ftest%2Frun-make%2Fsave-analysis-fail%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Ftest%2Frun-make%2Fsave-analysis-fail%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis-fail%2Ffoo.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -459,3 +459,10 @@ struct Rls699 {\n fn new(f: u32) -> Rls699 {\n     Rls699 { fs }\n }\n+\n+fn invalid_tuple_struct_access() {\n+    bar.0;\n+\n+    struct S;\n+    S.0;\n+}"}, {"sha": "80fa4d17b6116904899c5a1e238958208b89526c", "filename": "src/test/run-pass/rfc-1937-termination-trait/termination-trait-for-exitcode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Ftest%2Frun-pass%2Frfc-1937-termination-trait%2Ftermination-trait-for-exitcode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Ftest%2Frun-pass%2Frfc-1937-termination-trait%2Ftermination-trait-for-exitcode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-1937-termination-trait%2Ftermination-trait-for-exitcode.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -14,5 +14,5 @@\n use std::process::ExitCode;\n \n fn main() -> ExitCode {\n-    ExitCode(0)\n+    ExitCode::SUCCESS\n }"}, {"sha": "7d02f0b746d95902050e60dcfc942e55a0477f02", "filename": "src/tools/compiletest/Cargo.toml", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Ftools%2Fcompiletest%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Ftools%2Fcompiletest%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2FCargo.toml?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -10,11 +10,13 @@ filetime = \"0.1\"\n getopts = \"0.2\"\n log = \"0.4\"\n regex = \"0.2\"\n-rustc-serialize = \"0.3\"\n+serde = \"1.0\"\n+serde_json = \"1.0\"\n+serde_derive = \"1.0\"\n \n [target.'cfg(unix)'.dependencies]\n libc = \"0.2\"\n \n [target.'cfg(windows)'.dependencies]\n-miow = \"0.2\"\n-winapi = \"0.2\"\n+miow = \"0.3\"\n+winapi = { version = \"0.3\", features = [\"winerror\"] }"}, {"sha": "08630628b7188b8ab5b9cc002c14e43d56b827fd", "filename": "src/tools/compiletest/src/json.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -9,25 +9,24 @@\n // except according to those terms.\n \n use errors::{Error, ErrorKind};\n-use rustc_serialize::json;\n+use serde_json;\n use std::str::FromStr;\n use std::path::Path;\n use runtest::ProcRes;\n \n // These structs are a subset of the ones found in\n // `syntax::json`.\n \n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(Deserialize)]\n struct Diagnostic {\n     message: String,\n     code: Option<DiagnosticCode>,\n     level: String,\n     spans: Vec<DiagnosticSpan>,\n     children: Vec<Diagnostic>,\n-    rendered: Option<String>,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Clone)]\n+#[derive(Deserialize, Clone)]\n struct DiagnosticSpan {\n     file_name: String,\n     line_start: usize,\n@@ -40,7 +39,7 @@ struct DiagnosticSpan {\n     expansion: Option<Box<DiagnosticSpanMacroExpansion>>,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Clone)]\n+#[derive(Deserialize, Clone)]\n struct DiagnosticSpanMacroExpansion {\n     /// span where macro was applied to generate this code\n     span: DiagnosticSpan,\n@@ -49,7 +48,7 @@ struct DiagnosticSpanMacroExpansion {\n     macro_decl_name: String,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Clone)]\n+#[derive(Deserialize, Clone)]\n struct DiagnosticCode {\n     /// The code itself.\n     code: String,\n@@ -67,7 +66,7 @@ fn parse_line(file_name: &str, line: &str, output: &str, proc_res: &ProcRes) ->\n     // The compiler sometimes intermingles non-JSON stuff into the\n     // output.  This hack just skips over such lines. Yuck.\n     if line.starts_with('{') {\n-        match json::decode::<Diagnostic>(line) {\n+        match serde_json::from_str::<Diagnostic>(line) {\n             Ok(diagnostic) => {\n                 let mut expected_errors = vec![];\n                 push_expected_errors(&mut expected_errors, &diagnostic, &[], file_name);"}, {"sha": "e65c03a6e571c1adbc39237ac4ffaa4bb963184d", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -21,8 +21,10 @@ extern crate getopts;\n extern crate libc;\n #[macro_use]\n extern crate log;\n-extern crate rustc_serialize;\n extern crate regex;\n+#[macro_use]\n+extern crate serde_derive;\n+extern crate serde_json;\n extern crate test;\n \n use std::env;"}, {"sha": "4f55edc58ef2a6204f1ba5dc15e15b3c432337e2", "filename": "src/tools/compiletest/src/read2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2.rs?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -119,7 +119,7 @@ mod imp {\n     use self::miow::iocp::{CompletionPort, CompletionStatus};\n     use self::miow::pipe::NamedPipe;\n     use self::miow::Overlapped;\n-    use self::winapi::ERROR_BROKEN_PIPE;\n+    use self::winapi::shared::winerror::ERROR_BROKEN_PIPE;\n \n     struct Pipe<'a> {\n         dst: &'a mut Vec<u8>,"}, {"sha": "118e078c5badd520d18b92813fd88789c8d341ab", "filename": "src/tools/rust-installer", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer?ref=5430c0c5c0fbdfb8e89358a187d2f9a8d4b796d4", "patch": "@@ -1 +1 @@\n-Subproject commit b55e0fc77590cf5d23a01dedeb2104d8cbb48efc\n+Subproject commit 118e078c5badd520d18b92813fd88789c8d341ab"}]}