{"sha": "59d1e84259b34e1501672f44b1b10e928032622f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5ZDFlODQyNTliMzRlMTUwMTY3MmY0NGIxYjEwZTkyODAzMjYyMmY=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2017-08-31T05:43:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-08-31T05:43:52Z"}, "message": "Merge pull request #1937 from topecongiro/enhance-macro-rewrite\n\nEnhance macro rewrite", "tree": {"sha": "4b63adefc0f017999e531ea069914488b73f90a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b63adefc0f017999e531ea069914488b73f90a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59d1e84259b34e1501672f44b1b10e928032622f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59d1e84259b34e1501672f44b1b10e928032622f", "html_url": "https://github.com/rust-lang/rust/commit/59d1e84259b34e1501672f44b1b10e928032622f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59d1e84259b34e1501672f44b1b10e928032622f/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d08405eed6dede2dbaf0b69fccc8a2225206718e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d08405eed6dede2dbaf0b69fccc8a2225206718e", "html_url": "https://github.com/rust-lang/rust/commit/d08405eed6dede2dbaf0b69fccc8a2225206718e"}, {"sha": "848d4559e1629c4a6a603844217daaee479b486b", "url": "https://api.github.com/repos/rust-lang/rust/commits/848d4559e1629c4a6a603844217daaee479b486b", "html_url": "https://github.com/rust-lang/rust/commit/848d4559e1629c4a6a603844217daaee479b486b"}], "stats": {"total": 228, "additions": 156, "deletions": 72}, "files": [{"sha": "b65383311de9627188cb86fb1554ac73f8743933", "filename": "src/expr.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/59d1e84259b34e1501672f44b1b10e928032622f/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d1e84259b34e1501672f44b1b10e928032622f/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=59d1e84259b34e1501672f44b1b10e928032622f", "patch": "@@ -26,7 +26,7 @@ use items::{span_hi_for_arg, span_lo_for_arg};\n use lists::{definitive_tactic, itemize_list, shape_for_tactic, struct_lit_formatting,\n             struct_lit_shape, struct_lit_tactic, write_list, DefinitiveListTactic, ListFormatting,\n             ListItem, ListTactic, Separator, SeparatorPlace, SeparatorTactic};\n-use macros::{rewrite_macro, MacroPosition};\n+use macros::{rewrite_macro, MacroArg, MacroPosition};\n use patterns::{can_be_overflowed_pat, TuplePatField};\n use rewrite::{Rewrite, RewriteContext};\n use string::{rewrite_string, StringFormat};\n@@ -3012,3 +3012,20 @@ impl<'a> ToExpr for ast::StructField {\n         false\n     }\n }\n+\n+impl<'a> ToExpr for MacroArg {\n+    fn to_expr(&self) -> Option<&ast::Expr> {\n+        match self {\n+            &MacroArg::Expr(ref expr) => Some(expr),\n+            _ => None,\n+        }\n+    }\n+\n+    fn can_be_overflowed(&self, context: &RewriteContext, len: usize) -> bool {\n+        match self {\n+            &MacroArg::Expr(ref expr) => can_be_overflowed_expr(context, expr, len),\n+            &MacroArg::Ty(ref ty) => can_be_overflowed_type(context, ty, len),\n+            &MacroArg::Pat(..) => false,\n+        }\n+    }\n+}"}, {"sha": "2040a9e6e5903c47743d288b5b7c384bd001b7dd", "filename": "src/lib.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/59d1e84259b34e1501672f44b1b10e928032622f/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d1e84259b34e1501672f44b1b10e928032622f/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=59d1e84259b34e1501672f44b1b10e928032622f", "patch": "@@ -34,6 +34,7 @@ use std::rc::Rc;\n \n use errors::{DiagnosticBuilder, Handler};\n use errors::emitter::{ColorConfig, EmitterWriter};\n+use macros::MacroArg;\n use strings::string_buffer::StringBuffer;\n use syntax::ast;\n use syntax::codemap::{CodeMap, FilePathMapping, Span};\n@@ -216,6 +217,16 @@ impl Spanned for ast::TyParamBound {\n     }\n }\n \n+impl Spanned for MacroArg {\n+    fn span(&self) -> Span {\n+        match *self {\n+            MacroArg::Expr(ref expr) => expr.span(),\n+            MacroArg::Ty(ref ty) => ty.span(),\n+            MacroArg::Pat(ref pat) => pat.span(),\n+        }\n+    }\n+}\n+\n #[derive(Copy, Clone, Debug)]\n pub struct Indent {\n     // Width of the block indent, in characters. Must be a multiple of\n@@ -682,7 +693,6 @@ fn format_ast<F>(\n     parse_session: &mut ParseSess,\n     main_file: &Path,\n     config: &Config,\n-    codemap: &Rc<CodeMap>,\n     mut after_file: F,\n ) -> Result<(FileMap, bool), io::Error>\n where\n@@ -703,29 +713,19 @@ where\n         if config.verbose() {\n             println!(\"Formatting {}\", path_str);\n         }\n-        {\n-            let mut visitor = FmtVisitor::from_codemap(parse_session, config);\n-            let filemap = visitor.codemap.lookup_char_pos(module.inner.lo()).file;\n-            // Format inner attributes if available.\n-            if !krate.attrs.is_empty() && path == main_file {\n-                visitor.visit_attrs(&krate.attrs, ast::AttrStyle::Inner);\n-            } else {\n-                visitor.last_pos = filemap.start_pos;\n-            }\n-            visitor.format_separate_mod(module, &*filemap);\n+        let mut visitor = FmtVisitor::from_codemap(parse_session, config);\n+        let filemap = visitor.codemap.lookup_char_pos(module.inner.lo()).file;\n+        // Format inner attributes if available.\n+        if !krate.attrs.is_empty() && path == main_file {\n+            visitor.visit_attrs(&krate.attrs, ast::AttrStyle::Inner);\n+        } else {\n+            visitor.last_pos = filemap.start_pos;\n+        }\n+        visitor.format_separate_mod(module, &*filemap);\n \n-            has_diff |= after_file(path_str, &mut visitor.buffer)?;\n+        has_diff |= after_file(path_str, &mut visitor.buffer)?;\n \n-            result.push((path_str.to_owned(), visitor.buffer));\n-        }\n-        // Reset the error count.\n-        if parse_session.span_diagnostic.has_errors() {\n-            let silent_emitter = Box::new(EmitterWriter::new(\n-                Box::new(Vec::new()),\n-                Some(codemap.clone()),\n-            ));\n-            parse_session.span_diagnostic = Handler::with_emitter(true, false, silent_emitter);\n-        }\n+        result.push((path_str.to_owned(), visitor.buffer));\n     }\n \n     Ok((result, has_diff))\n@@ -912,7 +912,6 @@ pub fn format_input<T: Write>(\n         &mut parse_session,\n         &main_file,\n         config,\n-        &codemap,\n         |file_name, file| {\n             // For some reason, the codemap does not include terminating\n             // newlines so we must add one on for each file. This is sad."}, {"sha": "790056e9a02ec1b673c61389e1d1b057e17999c7", "filename": "src/macros.rs", "status": "modified", "additions": 81, "deletions": 42, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/59d1e84259b34e1501672f44b1b10e928032622f/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d1e84259b34e1501672f44b1b10e928032622f/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=59d1e84259b34e1501672f44b1b10e928032622f", "patch": "@@ -22,6 +22,7 @@\n use syntax::ast;\n use syntax::codemap::BytePos;\n use syntax::parse::new_parser_from_tts;\n+use syntax::parse::parser::Parser;\n use syntax::parse::token::Token;\n use syntax::symbol;\n use syntax::tokenstream::TokenStream;\n@@ -61,6 +62,51 @@ impl MacroStyle {\n     }\n }\n \n+pub enum MacroArg {\n+    Expr(ast::Expr),\n+    Ty(ast::Ty),\n+    Pat(ast::Pat),\n+}\n+\n+impl Rewrite for MacroArg {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        match self {\n+            &MacroArg::Expr(ref expr) => expr.rewrite(context, shape),\n+            &MacroArg::Ty(ref ty) => ty.rewrite(context, shape),\n+            &MacroArg::Pat(ref pat) => pat.rewrite(context, shape),\n+        }\n+    }\n+}\n+\n+fn parse_macro_arg(parser: &mut Parser) -> Option<MacroArg> {\n+    macro_rules! parse_macro_arg {\n+        ($target:tt, $macro_arg:ident, $parser:ident) => {\n+            let mut cloned_parser = (*parser).clone();\n+            match cloned_parser.$parser() {\n+                Ok($target) => {\n+                    if parser.sess.span_diagnostic.has_errors() {\n+                        parser.sess.span_diagnostic.reset_err_count();\n+                    } else {\n+                        // Parsing succeeded.\n+                        *parser = cloned_parser;\n+                        return Some(MacroArg::$macro_arg((*$target).clone()));\n+                    }\n+                }\n+                Err(mut e) => {\n+                    e.cancel();\n+                    parser.sess.span_diagnostic.reset_err_count();\n+                }\n+            }\n+        }\n+    }\n+\n+    parse_macro_arg!(expr, Expr, parse_expr);\n+    parse_macro_arg!(ty, Ty, parse_ty);\n+    parse_macro_arg!(pat, Pat, parse_pat);\n+\n+    return None;\n+}\n+\n pub fn rewrite_macro(\n     mac: &ast::Mac,\n     extra_ident: Option<ast::Ident>,\n@@ -93,7 +139,7 @@ pub fn rewrite_macro(\n         original_style\n     };\n \n-    let ts: TokenStream = mac.node.tts.clone().into();\n+    let ts: TokenStream = mac.node.stream();\n     if ts.is_empty() && !contains_comment(&context.snippet(mac.span)) {\n         return match style {\n             MacroStyle::Parens if position == MacroPosition::Item => {\n@@ -106,32 +152,16 @@ pub fn rewrite_macro(\n     }\n \n     let mut parser = new_parser_from_tts(context.parse_session, ts.trees().collect());\n-    let mut expr_vec = Vec::new();\n+    let mut arg_vec = Vec::new();\n     let mut vec_with_semi = false;\n     let mut trailing_comma = false;\n \n     if MacroStyle::Braces != style {\n         loop {\n-            let expr = match parser.parse_expr() {\n-                Ok(expr) => {\n-                    // Recovered errors.\n-                    if context.parse_session.span_diagnostic.has_errors() {\n-                        return indent_macro_snippet(\n-                            context,\n-                            &context.snippet(mac.span),\n-                            shape.indent,\n-                        );\n-                    }\n-\n-                    expr\n-                }\n-                Err(mut e) => {\n-                    e.cancel();\n-                    return indent_macro_snippet(context, &context.snippet(mac.span), shape.indent);\n-                }\n-            };\n-\n-            expr_vec.push(expr);\n+            match parse_macro_arg(&mut parser) {\n+                Some(arg) => arg_vec.push(arg),\n+                None => return Some(context.snippet(mac.span)),\n+            }\n \n             match parser.token {\n                 Token::Eof => break,\n@@ -141,25 +171,22 @@ pub fn rewrite_macro(\n                     if FORCED_BRACKET_MACROS.contains(&&macro_name[..]) {\n                         parser.bump();\n                         if parser.token != Token::Eof {\n-                            match parser.parse_expr() {\n-                                Ok(expr) => {\n-                                    if context.parse_session.span_diagnostic.has_errors() {\n-                                        return None;\n-                                    }\n-                                    expr_vec.push(expr);\n+                            match parse_macro_arg(&mut parser) {\n+                                Some(arg) => {\n+                                    arg_vec.push(arg);\n                                     parser.bump();\n-                                    if parser.token == Token::Eof && expr_vec.len() == 2 {\n+                                    if parser.token == Token::Eof && arg_vec.len() == 2 {\n                                         vec_with_semi = true;\n                                         break;\n                                     }\n                                 }\n-                                Err(mut e) => e.cancel(),\n+                                None => return Some(context.snippet(mac.span)),\n                             }\n                         }\n                     }\n-                    return None;\n+                    return Some(context.snippet(mac.span));\n                 }\n-                _ => return None,\n+                _ => return Some(context.snippet(mac.span)),\n             }\n \n             parser.bump();\n@@ -178,7 +205,7 @@ pub fn rewrite_macro(\n             let rw = rewrite_call_inner(\n                 context,\n                 &macro_name,\n-                &expr_vec.iter().map(|e| &**e).collect::<Vec<_>>()[..],\n+                &arg_vec.iter().map(|e| &*e).collect::<Vec<_>>()[..],\n                 mac.span,\n                 shape,\n                 context.config.fn_call_width(),\n@@ -201,8 +228,8 @@ pub fn rewrite_macro(\n                 // 6 = `vec!` + `; `\n                 let total_overhead = lbr.len() + rbr.len() + 6;\n                 let nested_shape = mac_shape.block_indent(context.config.tab_spaces());\n-                let lhs = try_opt!(expr_vec[0].rewrite(context, nested_shape));\n-                let rhs = try_opt!(expr_vec[1].rewrite(context, nested_shape));\n+                let lhs = try_opt!(arg_vec[0].rewrite(context, nested_shape));\n+                let rhs = try_opt!(arg_vec[1].rewrite(context, nested_shape));\n                 if !lhs.contains('\\n') && !rhs.contains('\\n') &&\n                     lhs.len() + rhs.len() + total_overhead <= shape.width\n                 {\n@@ -228,14 +255,26 @@ pub fn rewrite_macro(\n                     context.inside_macro = false;\n                     trailing_comma = false;\n                 }\n+                // Convert `MacroArg` into `ast::Expr`, as `rewrite_array` only accepts the latter.\n+                let expr_vec: Vec<_> = arg_vec\n+                    .iter()\n+                    .filter_map(|e| match *e {\n+                        MacroArg::Expr(ref e) => Some(e.clone()),\n+                        _ => None,\n+                    })\n+                    .collect();\n+                if expr_vec.len() != arg_vec.len() {\n+                    return Some(context.snippet(mac.span));\n+                }\n+                let sp = mk_sp(\n+                    context\n+                        .codemap\n+                        .span_after(mac.span, original_style.opener()),\n+                    mac.span.hi() - BytePos(1),\n+                );\n                 let rewrite = try_opt!(rewrite_array(\n-                    expr_vec.iter().map(|x| &**x),\n-                    mk_sp(\n-                        context\n-                            .codemap\n-                            .span_after(mac.span, original_style.opener()),\n-                        mac.span.hi() - BytePos(1),\n-                    ),\n+                    expr_vec.iter(),\n+                    sp,\n                     context,\n                     mac_shape,\n                     trailing_comma,"}, {"sha": "10f6e2d7ea05f3df21ceb96c02530c843e6e5262", "filename": "tests/source/macros.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/59d1e84259b34e1501672f44b1b10e928032622f/tests%2Fsource%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d1e84259b34e1501672f44b1b10e928032622f/tests%2Fsource%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fmacros.rs?ref=59d1e84259b34e1501672f44b1b10e928032622f", "patch": "@@ -164,9 +164,6 @@ fn issue_1921() {\n }\n }\n \n-// Put the following tests with macro invocations whose arguments cannot be parsed as expressioins\n-// at the end of the file for now.\n-\n // #1577\n fn issue1577() {\n     let json = json!({\n@@ -178,3 +175,17 @@ gfx_pipeline!(pipe {\n     vbuf: gfx::VertexBuffer<Vertex> = (),\n     out: gfx::RenderTarget<ColorFormat> = \"Target0\",\n });\n+\n+// #1919\n+#[test]\n+fn __bindgen_test_layout_HandleWithDtor_open0_int_close0_instantiation() {\n+    assert_eq!(\n+        ::std::mem::size_of::<HandleWithDtor<::std::os::raw::c_int>>(),\n+        8usize,\n+        concat!(\n+            \"Size of template specialization: \",\n+            stringify ! ( HandleWithDtor < :: std :: os :: raw :: c_int > )\n+        )\n+    );\n+    assert_eq ! ( :: std :: mem :: align_of :: < HandleWithDtor < :: std :: os :: raw :: c_int > > ( ) , 8usize , concat ! ( \"Alignment of template specialization: \" , stringify ! ( HandleWithDtor < :: std :: os :: raw :: c_int > ) ) );\n+}"}, {"sha": "d47063d255c263a9dc0c223ecc3a5e65e89572af", "filename": "tests/target/macros.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/59d1e84259b34e1501672f44b1b10e928032622f/tests%2Ftarget%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d1e84259b34e1501672f44b1b10e928032622f/tests%2Ftarget%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmacros.rs?ref=59d1e84259b34e1501672f44b1b10e928032622f", "patch": "@@ -208,9 +208,6 @@ fn issue_1921() {\n     }\n }\n \n-// Put the following tests with macro invocations whose arguments cannot be parsed as expressioins\n-// at the end of the file for now.\n-\n // #1577\n fn issue1577() {\n     let json = json!({\n@@ -222,3 +219,24 @@ gfx_pipeline!(pipe {\n     vbuf: gfx::VertexBuffer<Vertex> = (),\n     out: gfx::RenderTarget<ColorFormat> = \"Target0\",\n });\n+\n+// #1919\n+#[test]\n+fn __bindgen_test_layout_HandleWithDtor_open0_int_close0_instantiation() {\n+    assert_eq!(\n+        ::std::mem::size_of::<HandleWithDtor<::std::os::raw::c_int>>(),\n+        8usize,\n+        concat!(\n+            \"Size of template specialization: \",\n+            stringify!(HandleWithDtor<::std::os::raw::c_int>)\n+        )\n+    );\n+    assert_eq!(\n+        ::std::mem::align_of::<HandleWithDtor<::std::os::raw::c_int>>(),\n+        8usize,\n+        concat!(\n+            \"Alignment of template specialization: \",\n+            stringify!(HandleWithDtor<::std::os::raw::c_int>)\n+        )\n+    );\n+}"}]}