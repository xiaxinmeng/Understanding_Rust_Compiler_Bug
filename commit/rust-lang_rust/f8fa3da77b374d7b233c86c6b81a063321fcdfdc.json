{"sha": "f8fa3da77b374d7b233c86c6b81a063321fcdfdc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4ZmEzZGE3N2IzNzRkN2IyMzNjODZjNmI4MWEwNjMzMjFmY2RmZGM=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-10-18T02:47:32Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-10-18T04:55:06Z"}, "message": "Rollup merge of #55122 - ljedrz:cleanup_mir_borrowck, r=Mark-Simulacrum\n\nCleanup mir/borrowck\n\n- remove a redundant `.clone()`\n- a few string tweaks\n- deduplicate assignments and `return`s\n- simplify common patterns\n- remove redundant `return`s", "tree": {"sha": "558460bd79379bcb8037c1439164c03bbd1b32b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/558460bd79379bcb8037c1439164c03bbd1b32b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8fa3da77b374d7b233c86c6b81a063321fcdfdc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAlvIEisACgkQ/vbIBR0O\nATwkew/+Ieb7nU1P9ubs6u4KKLAVr3cLxUstD0WPMuhbo/bi3GlXovE1/8+O4/Ho\nSVI4Qti3UapEhKcD6glI20BwwxGT7Y00XtyE4Lc2IrBOrBxyEtlo4yBAi3HupHom\nycdd/HoyooRPNMZfhWLStJUotfzOWDdZoV2x5D21wHkchU/dR4S5UzaEq3h8zP5z\n+zqGqdHbrDMfk83Q6GqznbLWzVBYFQCEJ9iCbpw0DkwMXJXniyo77CjdmgVv1WTw\ney+bzbQAVl8wKPOcQC4nC4aUiTkfQE69/HnDmsRL+1bB0lPRIV2zInqsH02orLTJ\nppz8LOHKg8siFUhNzetJe8TwaCO3so+Ri7ljeFGjC6CZNCA0R+0veNGdrSWSOkF8\nnp1rrIWcS5Y/gs+ZNHTzfeSp3cLglXVcXz2uTSOwk2diXnBwGYK01lFF5q1dUwC5\nrzZgH4EK1t9IQRg70R3aWDBPbf6R3Kwmr1a8R1dIpBMVZ1V25t44pUUqM8tF3+lg\nQ95BcwnGJ+6Ax2bXKkqx+3T7CxOyL5a2OPE9MxGbnVdcLfuJHOxNSXsNSLbC8lgS\nt+BWqfRPjmLSHuzv4cLjK7hmu+FP4ItXgjWyOscNwLXA8oIXEdG+FNXHYnAzQXzx\nXarPW+yIwFxkQpPst/Z/6A2Oz23XnQ19zGlUGFNxXshM+9ba5ZY=\n=UFge\n-----END PGP SIGNATURE-----", "payload": "tree 558460bd79379bcb8037c1439164c03bbd1b32b0\nparent 2571c1c7833025fd8bd3ad01245e5ce57221aa64\nparent 5620f6d2445c4b699c7cfa9020a2e9813a13a05c\nauthor kennytm <kennytm@gmail.com> 1539830852 +0800\ncommitter kennytm <kennytm@gmail.com> 1539838506 +0800\n\nRollup merge of #55122 - ljedrz:cleanup_mir_borrowck, r=Mark-Simulacrum\n\nCleanup mir/borrowck\n\n- remove a redundant `.clone()`\n- a few string tweaks\n- deduplicate assignments and `return`s\n- simplify common patterns\n- remove redundant `return`s\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8fa3da77b374d7b233c86c6b81a063321fcdfdc", "html_url": "https://github.com/rust-lang/rust/commit/f8fa3da77b374d7b233c86c6b81a063321fcdfdc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8fa3da77b374d7b233c86c6b81a063321fcdfdc/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2571c1c7833025fd8bd3ad01245e5ce57221aa64", "url": "https://api.github.com/repos/rust-lang/rust/commits/2571c1c7833025fd8bd3ad01245e5ce57221aa64", "html_url": "https://github.com/rust-lang/rust/commit/2571c1c7833025fd8bd3ad01245e5ce57221aa64"}, {"sha": "5620f6d2445c4b699c7cfa9020a2e9813a13a05c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5620f6d2445c4b699c7cfa9020a2e9813a13a05c", "html_url": "https://github.com/rust-lang/rust/commit/5620f6d2445c4b699c7cfa9020a2e9813a13a05c"}], "stats": {"total": 480, "additions": 228, "deletions": 252}, "files": [{"sha": "a316fc5ca1029ca2f47f86532b5b0e07bcd18f11", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 48, "deletions": 52, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/f8fa3da77b374d7b233c86c6b81a063321fcdfdc/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fa3da77b374d7b233c86c6b81a063321fcdfdc/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=f8fa3da77b374d7b233c86c6b81a063321fcdfdc", "patch": "@@ -92,12 +92,12 @@ impl<'tcx> fmt::Display for BorrowData<'tcx> {\n             mir::BorrowKind::Mut { .. } => \"mut \",\n         };\n         let region = self.region.to_string();\n-        let region = if region.len() > 0 {\n-            format!(\"{} \", region)\n+        let separator = if !region.is_empty() {\n+            \" \"\n         } else {\n-            region\n+            \"\"\n         };\n-        write!(w, \"&{}{}{:?}\", region, kind, self.borrowed_place)\n+        write!(w, \"&{}{}{}{:?}\", region, separator, kind, self.borrowed_place)\n     }\n }\n \n@@ -244,7 +244,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n             K: Clone + Eq + Hash,\n             V: Eq + Hash,\n         {\n-            map.entry(k.clone()).or_insert(FxHashSet()).insert(v);\n+            map.entry(k.clone()).or_default().insert(v);\n         }\n     }\n \n@@ -261,57 +261,53 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n             // ... check whether we (earlier) saw a 2-phase borrow like\n             //\n             //     TMP = &mut place\n-            match self.pending_activations.get(temp) {\n-                Some(&borrow_index) => {\n-                    let borrow_data = &mut self.idx_vec[borrow_index];\n-\n-                    // Watch out: the use of TMP in the borrow itself\n-                    // doesn't count as an activation. =)\n-                    if borrow_data.reserve_location == location && context == PlaceContext::Store {\n-                        return;\n-                    }\n+            if let Some(&borrow_index) = self.pending_activations.get(temp) {\n+                let borrow_data = &mut self.idx_vec[borrow_index];\n \n-                    if let TwoPhaseActivation::ActivatedAt(other_location) =\n-                            borrow_data.activation_location {\n-                        span_bug!(\n-                            self.mir.source_info(location).span,\n-                            \"found two uses for 2-phase borrow temporary {:?}: \\\n-                             {:?} and {:?}\",\n-                            temp,\n-                            location,\n-                            other_location,\n-                        );\n-                    }\n+                // Watch out: the use of TMP in the borrow itself\n+                // doesn't count as an activation. =)\n+                if borrow_data.reserve_location == location && context == PlaceContext::Store {\n+                    return;\n+                }\n \n-                    // Otherwise, this is the unique later use\n-                    // that we expect.\n-                    borrow_data.activation_location = match context {\n-                        // The use of TMP in a shared borrow does not\n-                        // count as an actual activation.\n-                        PlaceContext::Borrow { kind: mir::BorrowKind::Shared, .. }\n-                        | PlaceContext::Borrow { kind: mir::BorrowKind::Shallow, .. } => {\n-                            TwoPhaseActivation::NotActivated\n-                        }\n-                        _ => {\n-                            // Double check: This borrow is indeed a two-phase borrow (that is,\n-                            // we are 'transitioning' from `NotActivated` to `ActivatedAt`) and\n-                            // we've not found any other activations (checked above).\n-                            assert_eq!(\n-                                borrow_data.activation_location,\n-                                TwoPhaseActivation::NotActivated,\n-                                \"never found an activation for this borrow!\",\n-                            );\n-\n-                            self.activation_map\n-                                .entry(location)\n-                                .or_default()\n-                                .push(borrow_index);\n-                            TwoPhaseActivation::ActivatedAt(location)\n-                        }\n-                    };\n+                if let TwoPhaseActivation::ActivatedAt(other_location) =\n+                        borrow_data.activation_location {\n+                    span_bug!(\n+                        self.mir.source_info(location).span,\n+                        \"found two uses for 2-phase borrow temporary {:?}: \\\n+                         {:?} and {:?}\",\n+                        temp,\n+                        location,\n+                        other_location,\n+                    );\n                 }\n \n-                None => {}\n+                // Otherwise, this is the unique later use\n+                // that we expect.\n+                borrow_data.activation_location = match context {\n+                    // The use of TMP in a shared borrow does not\n+                    // count as an actual activation.\n+                    PlaceContext::Borrow { kind: mir::BorrowKind::Shared, .. }\n+                    | PlaceContext::Borrow { kind: mir::BorrowKind::Shallow, .. } => {\n+                        TwoPhaseActivation::NotActivated\n+                    }\n+                    _ => {\n+                        // Double check: This borrow is indeed a two-phase borrow (that is,\n+                        // we are 'transitioning' from `NotActivated` to `ActivatedAt`) and\n+                        // we've not found any other activations (checked above).\n+                        assert_eq!(\n+                            borrow_data.activation_location,\n+                            TwoPhaseActivation::NotActivated,\n+                            \"never found an activation for this borrow!\",\n+                        );\n+\n+                        self.activation_map\n+                            .entry(location)\n+                            .or_default()\n+                            .push(borrow_index);\n+                        TwoPhaseActivation::ActivatedAt(location)\n+                    }\n+                };\n             }\n         }\n     }"}, {"sha": "759b842e9dfee24731e9fb0493a18d165db6ffba", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 163, "deletions": 178, "changes": 341, "blob_url": "https://github.com/rust-lang/rust/blob/f8fa3da77b374d7b233c86c6b81a063321fcdfdc/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fa3da77b374d7b233c86c6b81a063321fcdfdc/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=f8fa3da77b374d7b233c86c6b81a063321fcdfdc", "patch": "@@ -77,9 +77,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         if move_out_indices.is_empty() {\n             let root_place = self.prefixes(&used_place, PrefixSet::All).last().unwrap();\n \n-            if self.uninitialized_error_reported\n-                .contains(&root_place.clone())\n-            {\n+            if self.uninitialized_error_reported.contains(root_place) {\n                 debug!(\n                     \"report_use_of_moved_or_uninitialized place: error about {:?} suppressed\",\n                     root_place\n@@ -188,11 +186,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         let tables = self.infcx.tcx.typeck_tables_of(id);\n                         let node_id = self.infcx.tcx.hir.as_local_node_id(id).unwrap();\n                         let hir_id = self.infcx.tcx.hir.node_to_hir_id(node_id);\n-                        if tables.closure_kind_origins().get(hir_id).is_some() {\n-                            false\n-                        } else {\n-                            true\n-                        }\n+\n+                        tables.closure_kind_origins().get(hir_id).is_none()\n                     }\n                     _ => true,\n                 };\n@@ -582,7 +577,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     fn report_local_value_does_not_live_long_enough(\n         &mut self,\n         context: Context,\n-        name: &String,\n+        name: &str,\n         scope_tree: &Lrc<ScopeTree>,\n         borrow: &BorrowData<'tcx>,\n         drop_span: Span,\n@@ -1195,10 +1190,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Place::Static(ref static_) => self.describe_field_from_ty(&static_.ty, field),\n             Place::Projection(ref proj) => match proj.elem {\n                 ProjectionElem::Deref => self.describe_field(&proj.base, field),\n-                ProjectionElem::Downcast(def, variant_index) => format!(\n-                    \"{}\",\n-                    def.variants[variant_index].fields[field.index()].ident\n-                ),\n+                ProjectionElem::Downcast(def, variant_index) =>\n+                    def.variants[variant_index].fields[field.index()].ident.to_string(),\n                 ProjectionElem::Field(_, field_type) => {\n                     self.describe_field_from_ty(&field_type, field)\n                 }\n@@ -1366,191 +1359,184 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             \"annotate_argument_and_return_for_borrow: location={:?}\",\n             location\n         );\n-        match &self.mir[location.block]\n-            .statements\n-            .get(location.statement_index)\n+        if let Some(&Statement { kind: StatementKind::Assign(ref reservation, _), ..})\n+             = &self.mir[location.block].statements.get(location.statement_index)\n         {\n-            Some(&Statement {\n-                kind: StatementKind::Assign(ref reservation, _),\n-                ..\n-            }) => {\n+            debug!(\n+                \"annotate_argument_and_return_for_borrow: reservation={:?}\",\n+                reservation\n+            );\n+            // Check that the initial assignment of the reserve location is into a temporary.\n+            let mut target = *match reservation {\n+                Place::Local(local) if self.mir.local_kind(*local) == LocalKind::Temp => local,\n+                _ => return None,\n+            };\n+\n+            // Next, look through the rest of the block, checking if we are assigning the\n+            // `target` (that is, the place that contains our borrow) to anything.\n+            let mut annotated_closure = None;\n+            for stmt in &self.mir[location.block].statements[location.statement_index + 1..] {\n                 debug!(\n-                    \"annotate_argument_and_return_for_borrow: reservation={:?}\",\n-                    reservation\n+                    \"annotate_argument_and_return_for_borrow: target={:?} stmt={:?}\",\n+                    target, stmt\n                 );\n-                // Check that the initial assignment of the reserve location is into a temporary.\n-                let mut target = *match reservation {\n-                    Place::Local(local) if self.mir.local_kind(*local) == LocalKind::Temp => local,\n-                    _ => return None,\n-                };\n-\n-                // Next, look through the rest of the block, checking if we are assigning the\n-                // `target` (that is, the place that contains our borrow) to anything.\n-                let mut annotated_closure = None;\n-                for stmt in &self.mir[location.block].statements[location.statement_index + 1..] {\n+                if let StatementKind::Assign(Place::Local(assigned_to), box rvalue) = &stmt.kind\n+                {\n                     debug!(\n-                        \"annotate_argument_and_return_for_borrow: target={:?} stmt={:?}\",\n-                        target, stmt\n+                        \"annotate_argument_and_return_for_borrow: assigned_to={:?} \\\n+                         rvalue={:?}\",\n+                        assigned_to, rvalue\n                     );\n-                    if let StatementKind::Assign(Place::Local(assigned_to), box rvalue) = &stmt.kind\n+                    // Check if our `target` was captured by a closure.\n+                    if let Rvalue::Aggregate(\n+                        box AggregateKind::Closure(def_id, substs),\n+                        operands,\n+                    ) = rvalue\n                     {\n-                        debug!(\n-                            \"annotate_argument_and_return_for_borrow: assigned_to={:?} \\\n-                             rvalue={:?}\",\n-                            assigned_to, rvalue\n-                        );\n-                        // Check if our `target` was captured by a closure.\n-                        if let Rvalue::Aggregate(\n-                            box AggregateKind::Closure(def_id, substs),\n-                            operands,\n-                        ) = rvalue\n-                        {\n-                            for operand in operands {\n-                                let assigned_from = match operand {\n-                                    Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n-                                        assigned_from\n-                                    }\n-                                    _ => continue,\n-                                };\n-                                debug!(\n-                                    \"annotate_argument_and_return_for_borrow: assigned_from={:?}\",\n+                        for operand in operands {\n+                            let assigned_from = match operand {\n+                                Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n                                     assigned_from\n-                                );\n-\n-                                // Find the local from the operand.\n-                                let assigned_from_local = match assigned_from.local() {\n-                                    Some(local) => local,\n-                                    None => continue,\n-                                };\n-\n-                                if assigned_from_local != target {\n-                                    continue;\n                                 }\n+                                _ => continue,\n+                            };\n+                            debug!(\n+                                \"annotate_argument_and_return_for_borrow: assigned_from={:?}\",\n+                                assigned_from\n+                            );\n \n-                                // If a closure captured our `target` and then assigned\n-                                // into a place then we should annotate the closure in\n-                                // case it ends up being assigned into the return place.\n-                                annotated_closure = self.annotate_fn_sig(\n-                                    *def_id,\n-                                    self.infcx.closure_sig(*def_id, *substs),\n-                                );\n-                                debug!(\n-                                    \"annotate_argument_and_return_for_borrow: \\\n-                                     annotated_closure={:?} assigned_from_local={:?} \\\n-                                     assigned_to={:?}\",\n-                                    annotated_closure, assigned_from_local, assigned_to\n-                                );\n-\n-                                if *assigned_to == mir::RETURN_PLACE {\n-                                    // If it was assigned directly into the return place, then\n-                                    // return now.\n-                                    return annotated_closure;\n-                                } else {\n-                                    // Otherwise, update the target.\n-                                    target = *assigned_to;\n-                                }\n+                            // Find the local from the operand.\n+                            let assigned_from_local = match assigned_from.local() {\n+                                Some(local) => local,\n+                                None => continue,\n+                            };\n+\n+                            if assigned_from_local != target {\n+                                continue;\n                             }\n \n-                            // If none of our closure's operands matched, then skip to the next\n-                            // statement.\n-                            continue;\n+                            // If a closure captured our `target` and then assigned\n+                            // into a place then we should annotate the closure in\n+                            // case it ends up being assigned into the return place.\n+                            annotated_closure = self.annotate_fn_sig(\n+                                *def_id,\n+                                self.infcx.closure_sig(*def_id, *substs),\n+                            );\n+                            debug!(\n+                                \"annotate_argument_and_return_for_borrow: \\\n+                                 annotated_closure={:?} assigned_from_local={:?} \\\n+                                 assigned_to={:?}\",\n+                                annotated_closure, assigned_from_local, assigned_to\n+                            );\n+\n+                            if *assigned_to == mir::RETURN_PLACE {\n+                                // If it was assigned directly into the return place, then\n+                                // return now.\n+                                return annotated_closure;\n+                            } else {\n+                                // Otherwise, update the target.\n+                                target = *assigned_to;\n+                            }\n                         }\n \n-                        // Otherwise, look at other types of assignment.\n-                        let assigned_from = match rvalue {\n-                            Rvalue::Ref(_, _, assigned_from) => assigned_from,\n-                            Rvalue::Use(operand) => match operand {\n-                                Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n-                                    assigned_from\n-                                }\n-                                _ => continue,\n-                            },\n-                            _ => continue,\n-                        };\n-                        debug!(\n-                            \"annotate_argument_and_return_for_borrow: \\\n-                             assigned_from={:?}\",\n-                            assigned_from,\n-                        );\n+                        // If none of our closure's operands matched, then skip to the next\n+                        // statement.\n+                        continue;\n+                    }\n \n-                        // Find the local from the rvalue.\n-                        let assigned_from_local = match assigned_from.local() {\n-                            Some(local) => local,\n-                            None => continue,\n-                        };\n-                        debug!(\n-                            \"annotate_argument_and_return_for_borrow: \\\n-                             assigned_from_local={:?}\",\n-                            assigned_from_local,\n-                        );\n+                    // Otherwise, look at other types of assignment.\n+                    let assigned_from = match rvalue {\n+                        Rvalue::Ref(_, _, assigned_from) => assigned_from,\n+                        Rvalue::Use(operand) => match operand {\n+                            Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n+                                assigned_from\n+                            }\n+                            _ => continue,\n+                        },\n+                        _ => continue,\n+                    };\n+                    debug!(\n+                        \"annotate_argument_and_return_for_borrow: \\\n+                         assigned_from={:?}\",\n+                        assigned_from,\n+                    );\n \n-                        // Check if our local matches the target - if so, we've assigned our\n-                        // borrow to a new place.\n-                        if assigned_from_local != target {\n-                            continue;\n-                        }\n+                    // Find the local from the rvalue.\n+                    let assigned_from_local = match assigned_from.local() {\n+                        Some(local) => local,\n+                        None => continue,\n+                    };\n+                    debug!(\n+                        \"annotate_argument_and_return_for_borrow: \\\n+                         assigned_from_local={:?}\",\n+                        assigned_from_local,\n+                    );\n \n-                        // If we assigned our `target` into a new place, then we should\n-                        // check if it was the return place.\n-                        debug!(\n-                            \"annotate_argument_and_return_for_borrow: \\\n-                             assigned_from_local={:?} assigned_to={:?}\",\n-                            assigned_from_local, assigned_to\n-                        );\n-                        if *assigned_to == mir::RETURN_PLACE {\n-                            // If it was then return the annotated closure if there was one,\n-                            // else, annotate this function.\n-                            return annotated_closure.or_else(fallback);\n-                        }\n+                    // Check if our local matches the target - if so, we've assigned our\n+                    // borrow to a new place.\n+                    if assigned_from_local != target {\n+                        continue;\n+                    }\n \n-                        // If we didn't assign into the return place, then we just update\n-                        // the target.\n-                        target = *assigned_to;\n+                    // If we assigned our `target` into a new place, then we should\n+                    // check if it was the return place.\n+                    debug!(\n+                        \"annotate_argument_and_return_for_borrow: \\\n+                         assigned_from_local={:?} assigned_to={:?}\",\n+                        assigned_from_local, assigned_to\n+                    );\n+                    if *assigned_to == mir::RETURN_PLACE {\n+                        // If it was then return the annotated closure if there was one,\n+                        // else, annotate this function.\n+                        return annotated_closure.or_else(fallback);\n                     }\n+\n+                    // If we didn't assign into the return place, then we just update\n+                    // the target.\n+                    target = *assigned_to;\n                 }\n+            }\n \n-                // Check the terminator if we didn't find anything in the statements.\n-                let terminator = &self.mir[location.block].terminator();\n+            // Check the terminator if we didn't find anything in the statements.\n+            let terminator = &self.mir[location.block].terminator();\n+            debug!(\n+                \"annotate_argument_and_return_for_borrow: target={:?} terminator={:?}\",\n+                target, terminator\n+            );\n+            if let TerminatorKind::Call {\n+                destination: Some((Place::Local(assigned_to), _)),\n+                args,\n+                ..\n+            } = &terminator.kind\n+            {\n                 debug!(\n-                    \"annotate_argument_and_return_for_borrow: target={:?} terminator={:?}\",\n-                    target, terminator\n+                    \"annotate_argument_and_return_for_borrow: assigned_to={:?} args={:?}\",\n+                    assigned_to, args\n                 );\n-                if let TerminatorKind::Call {\n-                    destination: Some((Place::Local(assigned_to), _)),\n-                    args,\n-                    ..\n-                } = &terminator.kind\n-                {\n+                for operand in args {\n+                    let assigned_from = match operand {\n+                        Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n+                            assigned_from\n+                        }\n+                        _ => continue,\n+                    };\n                     debug!(\n-                        \"annotate_argument_and_return_for_borrow: assigned_to={:?} args={:?}\",\n-                        assigned_to, args\n+                        \"annotate_argument_and_return_for_borrow: assigned_from={:?}\",\n+                        assigned_from,\n                     );\n-                    for operand in args {\n-                        let assigned_from = match operand {\n-                            Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n-                                assigned_from\n-                            }\n-                            _ => continue,\n-                        };\n+\n+                    if let Some(assigned_from_local) = assigned_from.local() {\n                         debug!(\n-                            \"annotate_argument_and_return_for_borrow: assigned_from={:?}\",\n-                            assigned_from,\n+                            \"annotate_argument_and_return_for_borrow: assigned_from_local={:?}\",\n+                            assigned_from_local,\n                         );\n \n-                        if let Some(assigned_from_local) = assigned_from.local() {\n-                            debug!(\n-                                \"annotate_argument_and_return_for_borrow: assigned_from_local={:?}\",\n-                                assigned_from_local,\n-                            );\n-\n-                            if *assigned_to == mir::RETURN_PLACE && assigned_from_local == target {\n-                                return annotated_closure.or_else(fallback);\n-                            }\n+                        if *assigned_to == mir::RETURN_PLACE && assigned_from_local == target {\n+                            return annotated_closure.or_else(fallback);\n                         }\n                     }\n                 }\n             }\n-            _ => {}\n         }\n \n         // If we haven't found an assignment into the return place, then we need not add\n@@ -1605,13 +1591,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             // Need to use the `rustc::ty` types to compare against the\n                             // `return_region`. Then use the `rustc::hir` type to get only\n                             // the lifetime span.\n-                            match &fn_decl.inputs[index].node {\n-                                hir::TyKind::Rptr(lifetime, _) => {\n-                                    // With access to the lifetime, we can get\n-                                    // the span of it.\n-                                    arguments.push((*argument, lifetime.span));\n-                                }\n-                                _ => bug!(\"ty type is a ref but hir type is not\"),\n+                            if let hir::TyKind::Rptr(lifetime, _) = &fn_decl.inputs[index].node {\n+                                // With access to the lifetime, we can get\n+                                // the span of it.\n+                                arguments.push((*argument, lifetime.span));\n+                            } else {\n+                                bug!(\"ty type is a ref but hir type is not\");\n                             }\n                         }\n                     }\n@@ -1794,8 +1779,8 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n                 ty::RegionKind::RePlaceholder(ty::Placeholder { name: br, .. }),\n                 _,\n                 _,\n-            ) => with_highlight_region_for_bound_region(*br, counter, || format!(\"{}\", ty)),\n-            _ => format!(\"{}\", ty),\n+            ) => with_highlight_region_for_bound_region(*br, counter, || ty.to_string()),\n+            _ => ty.to_string(),\n         }\n     }\n \n@@ -1806,9 +1791,9 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n             ty::TyKind::Ref(region, _, _) => match region {\n                 ty::RegionKind::ReLateBound(_, br)\n                 | ty::RegionKind::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n-                    with_highlight_region_for_bound_region(*br, counter, || format!(\"{}\", region))\n+                    with_highlight_region_for_bound_region(*br, counter, || region.to_string())\n                 }\n-                _ => format!(\"{}\", region),\n+                _ => region.to_string(),\n             },\n             _ => bug!(\"ty for annotation of borrow region is not a reference\"),\n         }"}, {"sha": "a7b356c146163e1c1d1989990183e64d8a4dcdac", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f8fa3da77b374d7b233c86c6b81a063321fcdfdc/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fa3da77b374d7b233c86c6b81a063321fcdfdc/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=f8fa3da77b374d7b233c86c6b81a063321fcdfdc", "patch": "@@ -284,7 +284,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     let temporary_used_locals: FxHashSet<Local> = mbcx\n         .used_mut\n         .iter()\n-        .filter(|&local| !mbcx.mir.local_decls[*local].is_user_variable.is_some())\n+        .filter(|&local| mbcx.mir.local_decls[*local].is_user_variable.is_none())\n         .cloned()\n         .collect();\n     mbcx.gather_used_muts(temporary_used_locals);\n@@ -342,7 +342,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         diag.buffer(&mut mbcx.errors_buffer);\n     }\n \n-    if mbcx.errors_buffer.len() > 0 {\n+    if !mbcx.errors_buffer.is_empty() {\n         mbcx.errors_buffer.sort_by_key(|diag| diag.span.primary_span());\n \n         if tcx.migrate_borrowck() {\n@@ -1009,13 +1009,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         return Control::Continue;\n                     }\n \n+                    error_reported = true;\n                     match kind {\n                         ReadKind::Copy  => {\n-                            error_reported = true;\n                             this.report_use_while_mutably_borrowed(context, place_span, borrow)\n                         }\n                         ReadKind::Borrow(bk) => {\n-                            error_reported = true;\n                             this.report_conflicting_borrow(context, place_span, bk, &borrow)\n                         }\n                     }\n@@ -1045,25 +1044,22 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         Read(..) | Write(..) => {}\n                     }\n \n+                    error_reported = true;\n                     match kind {\n                         WriteKind::MutableBorrow(bk) => {\n-                            error_reported = true;\n                             this.report_conflicting_borrow(context, place_span, bk, &borrow)\n                         }\n                         WriteKind::StorageDeadOrDrop => {\n-                            error_reported = true;\n                             this.report_borrowed_value_does_not_live_long_enough(\n                                 context,\n                                 borrow,\n                                 place_span,\n                                 Some(kind))\n                         }\n                         WriteKind::Mutate => {\n-                            error_reported = true;\n                             this.report_illegal_mutation_of_borrowed(context, place_span, borrow)\n                         }\n                         WriteKind::Move => {\n-                            error_reported = true;\n                             this.report_move_out_while_borrowed(context, place_span, &borrow)\n                         }\n                     }\n@@ -1593,7 +1589,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Place::Local(_) => panic!(\"should have move path for every Local\"),\n             Place::Projection(_) => panic!(\"PrefixSet::All meant don't stop for Projection\"),\n             Place::Promoted(_) |\n-            Place::Static(_) => return Err(NoMovePathFound::ReachedStatic),\n+            Place::Static(_) => Err(NoMovePathFound::ReachedStatic),\n         }\n     }\n \n@@ -1885,18 +1881,18 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n \n         // at this point, we have set up the error reporting state.\n-        if previously_initialized {\n+        return if previously_initialized {\n             self.report_mutability_error(\n                 place,\n                 span,\n                 the_place_err,\n                 error_access,\n                 location,\n             );\n-            return true;\n+            true\n         } else {\n-            return false;\n-        }\n+            false\n+        };\n     }\n \n     fn is_local_ever_initialized(&self,\n@@ -1911,7 +1907,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 return Some(index);\n             }\n         }\n-        return None;\n+        None\n     }\n \n     /// Adds the place into the used mutable variables set\n@@ -2171,7 +2167,7 @@ impl ContextKind {\n     fn new(self, loc: Location) -> Context {\n         Context {\n             kind: self,\n-            loc: loc,\n+            loc,\n         }\n     }\n }"}, {"sha": "a556199b875bf343d046e73740224d0a6b4adcc1", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f8fa3da77b374d7b233c86c6b81a063321fcdfdc/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fa3da77b374d7b233c86c6b81a063321fcdfdc/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=f8fa3da77b374d7b233c86c6b81a063321fcdfdc", "patch": "@@ -331,7 +331,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                             _ => {\n                                 let source = self.borrowed_content_source(place);\n                                 self.infcx.tcx.cannot_move_out_of(\n-                                    span, &format!(\"{}\", source), origin\n+                                    span, &source.to_string(), origin\n                                 )\n                             },\n                         }\n@@ -469,9 +469,9 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n             let binding_span = bind_to.source_info.span;\n \n             if j == 0 {\n-                err.span_label(binding_span, format!(\"data moved here\"));\n+                err.span_label(binding_span, \"data moved here\");\n             } else {\n-                err.span_label(binding_span, format!(\"...and here\"));\n+                err.span_label(binding_span, \"...and here\");\n             }\n \n             if binds_to.len() == 1 {"}, {"sha": "30f4fc9d5ea231388159297f0850924e507bf7b1", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f8fa3da77b374d7b233c86c6b81a063321fcdfdc/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8fa3da77b374d7b233c86c6b81a063321fcdfdc/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=f8fa3da77b374d7b233c86c6b81a063321fcdfdc", "patch": "@@ -408,7 +408,6 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                             .map(|replacement| (pattern_span, replacement))\n                     }\n \n-                    //\n                     ClearCrossCrate::Set(mir::BindingForm::RefForGuard) => unreachable!(),\n \n                     ClearCrossCrate::Clear => bug!(\"saw cleared local state\"),\n@@ -505,7 +504,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                                 );\n \n                                 let extra = if found {\n-                                    String::from(\"\")\n+                                    String::new()\n                                 } else {\n                                     format!(\", but it is not implemented for `{}`\",\n                                             substs.type_at(0))\n@@ -573,7 +572,7 @@ fn suggest_ampmut<'cx, 'gcx, 'tcx>(\n     opt_ty_info: Option<Span>,\n ) -> (Span, String) {\n     let locations = mir.find_assignments(local);\n-    if locations.len() > 0 {\n+    if !locations.is_empty() {\n         let assignment_rhs_span = mir.source_info(locations[0]).span;\n         if let Ok(src) = tcx.sess.source_map().span_to_snippet(assignment_rhs_span) {\n             if let (true, Some(ws_pos)) = (\n@@ -584,7 +583,7 @@ fn suggest_ampmut<'cx, 'gcx, 'tcx>(\n                 let ty = &src[ws_pos..];\n                 return (assignment_rhs_span, format!(\"&{} mut {}\", lt_name, ty));\n             } else if src.starts_with('&') {\n-                let borrowed_expr = src[1..].to_string();\n+                let borrowed_expr = &src[1..];\n                 return (assignment_rhs_span, format!(\"&mut {}\", borrowed_expr));\n             }\n         }"}]}