{"sha": "99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5YWQ1YTFhMjgyNGZlYTFlY2Y2MDA2OGZkMzYzNmJlYWU3ZWEyZGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-01T00:59:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-01T00:59:12Z"}, "message": "Auto merge of #80566 - Dylan-DPC:rollup-rns6est, r=Dylan-DPC\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #80323 (Update and improve `rustc_codegen_{llvm,ssa}` docs)\n - #80368 (rustdoc: Render visibilities succinctly)\n - #80514 (Fix broken ./x.py install)\n - #80519 (Take type defaults into account in suggestions to reorder generic parameters)\n - #80526 (Update LLVM)\n - #80532 (remove unnecessary trailing semicolon from bootstrap)\n - #80548 (FIx ICE on wf check for foreign fns)\n - #80551 (support pattern as const parents in type_of)\n\nFailed merges:\n\n - #80547 (In which we start to parse const generics defaults)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "f2c6fa747e14362fef92cbdd624b978fe93d3c5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2c6fa747e14362fef92cbdd624b978fe93d3c5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "html_url": "https://github.com/rust-lang/rust/commit/99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44e3daf5eee8263dfc3a2509e78ddd1f6f783a0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/44e3daf5eee8263dfc3a2509e78ddd1f6f783a0e", "html_url": "https://github.com/rust-lang/rust/commit/44e3daf5eee8263dfc3a2509e78ddd1f6f783a0e"}, {"sha": "96c11f98d7148f5d49cb1600101c7f9ce057c08b", "url": "https://api.github.com/repos/rust-lang/rust/commits/96c11f98d7148f5d49cb1600101c7f9ce057c08b", "html_url": "https://github.com/rust-lang/rust/commit/96c11f98d7148f5d49cb1600101c7f9ce057c08b"}], "stats": {"total": 794, "additions": 487, "deletions": 307}, "files": [{"sha": "c40f00bc9e99bbab94a27abb0197825dcf781dfa", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "patch": "@@ -717,35 +717,46 @@ impl<'a> AstValidator<'a> {\n \n /// Checks that generic parameters are in the correct order,\n /// which is lifetimes, then types and then consts. (`<'a, T, const N: usize>`)\n-fn validate_generic_param_order<'a>(\n+fn validate_generic_param_order(\n     sess: &Session,\n     handler: &rustc_errors::Handler,\n-    generics: impl Iterator<Item = (ParamKindOrd, Option<&'a [GenericBound]>, Span, Option<String>)>,\n+    generics: &[GenericParam],\n     span: Span,\n ) {\n     let mut max_param: Option<ParamKindOrd> = None;\n     let mut out_of_order = FxHashMap::default();\n     let mut param_idents = vec![];\n \n-    for (kind, bounds, span, ident) in generics {\n+    for param in generics {\n+        let ident = Some(param.ident.to_string());\n+        let (kind, bounds, span) = (&param.kind, Some(&*param.bounds), param.ident.span);\n+        let (ord_kind, ident) = match &param.kind {\n+            GenericParamKind::Lifetime => (ParamKindOrd::Lifetime, ident),\n+            GenericParamKind::Type { default: _ } => (ParamKindOrd::Type, ident),\n+            GenericParamKind::Const { ref ty, kw_span: _ } => {\n+                let ty = pprust::ty_to_string(ty);\n+                let unordered = sess.features_untracked().const_generics;\n+                (ParamKindOrd::Const { unordered }, Some(format!(\"const {}: {}\", param.ident, ty)))\n+            }\n+        };\n         if let Some(ident) = ident {\n-            param_idents.push((kind, bounds, param_idents.len(), ident));\n+            param_idents.push((kind, ord_kind, bounds, param_idents.len(), ident));\n         }\n         let max_param = &mut max_param;\n         match max_param {\n-            Some(max_param) if *max_param > kind => {\n-                let entry = out_of_order.entry(kind).or_insert((*max_param, vec![]));\n+            Some(max_param) if *max_param > ord_kind => {\n+                let entry = out_of_order.entry(ord_kind).or_insert((*max_param, vec![]));\n                 entry.1.push(span);\n             }\n-            Some(_) | None => *max_param = Some(kind),\n+            Some(_) | None => *max_param = Some(ord_kind),\n         };\n     }\n \n     let mut ordered_params = \"<\".to_string();\n     if !out_of_order.is_empty() {\n-        param_idents.sort_by_key(|&(po, _, i, _)| (po, i));\n+        param_idents.sort_by_key(|&(_, po, _, i, _)| (po, i));\n         let mut first = true;\n-        for (_, bounds, _, ident) in param_idents {\n+        for (kind, _, bounds, _, ident) in param_idents {\n             if !first {\n                 ordered_params += \", \";\n             }\n@@ -756,6 +767,16 @@ fn validate_generic_param_order<'a>(\n                     ordered_params += &pprust::bounds_to_string(&bounds);\n                 }\n             }\n+            match kind {\n+                GenericParamKind::Type { default: Some(default) } => {\n+                    ordered_params += \" = \";\n+                    ordered_params += &pprust::ty_to_string(default);\n+                }\n+                GenericParamKind::Type { default: None } => (),\n+                GenericParamKind::Lifetime => (),\n+                // FIXME(const_generics:defaults)\n+                GenericParamKind::Const { ty: _, kw_span: _ } => (),\n+            }\n             first = false;\n         }\n     }\n@@ -1150,22 +1171,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         validate_generic_param_order(\n             self.session,\n             self.err_handler(),\n-            generics.params.iter().map(|param| {\n-                let ident = Some(param.ident.to_string());\n-                let (kind, ident) = match &param.kind {\n-                    GenericParamKind::Lifetime => (ParamKindOrd::Lifetime, ident),\n-                    GenericParamKind::Type { default: _ } => (ParamKindOrd::Type, ident),\n-                    GenericParamKind::Const { ref ty, kw_span: _ } => {\n-                        let ty = pprust::ty_to_string(ty);\n-                        let unordered = self.session.features_untracked().const_generics;\n-                        (\n-                            ParamKindOrd::Const { unordered },\n-                            Some(format!(\"const {}: {}\", param.ident, ty)),\n-                        )\n-                    }\n-                };\n-                (kind, Some(&*param.bounds), param.ident.span, ident)\n-            }),\n+            &generics.params,\n             generics.span,\n         );\n "}, {"sha": "d5be3132dee10fbe29f8e8667cd82dfe447b8dd7", "filename": "compiler/rustc_codegen_llvm/src/base.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs?ref=99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "patch": "@@ -1,17 +1,15 @@\n-//! Codegen the completed AST to the LLVM IR.\n-//!\n-//! Some functions here, such as codegen_block and codegen_expr, return a value --\n-//! the result of the codegen to LLVM -- while others, such as codegen_fn\n-//! and mono_item, are called only for the side effect of adding a\n-//! particular definition to the LLVM IR output we're producing.\n+//! Codegen the MIR to the LLVM IR.\n //!\n //! Hopefully useful general knowledge about codegen:\n //!\n-//! * There's no way to find out the `Ty` type of a Value. Doing so\n+//! * There's no way to find out the [`Ty`] type of a [`Value`]. Doing so\n //!   would be \"trying to get the eggs out of an omelette\" (credit:\n-//!   pcwalton). You can, instead, find out its `llvm::Type` by calling `val_ty`,\n-//!   but one `llvm::Type` corresponds to many `Ty`s; for instance, `tup(int, int,\n-//!   int)` and `rec(x=int, y=int, z=int)` will have the same `llvm::Type`.\n+//!   pcwalton). You can, instead, find out its [`llvm::Type`] by calling [`val_ty`],\n+//!   but one [`llvm::Type`] corresponds to many [`Ty`]s; for instance, `tup(int, int,\n+//!   int)` and `rec(x=int, y=int, z=int)` will have the same [`llvm::Type`].\n+//!\n+//! [`Ty`]: rustc_middle::ty::Ty\n+//! [`val_ty`]: common::val_ty\n \n use super::ModuleLlvm;\n "}, {"sha": "58af9d4cd04a9d116a1b9e1a91f9123fbb5382de", "filename": "compiler/rustc_codegen_llvm/src/common.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs?ref=99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "patch": "@@ -314,6 +314,7 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     }\n }\n \n+/// Get the [LLVM type][Type] of a [`Value`].\n pub fn val_ty(v: &Value) -> &Type {\n     unsafe { llvm::LLVMTypeOf(v) }\n }"}, {"sha": "f47d2ada61a1441d043fb3a4b562ab3c50d25b61", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "patch": "@@ -1,18 +1,3 @@\n-//! Codegen the completed AST to the LLVM IR.\n-//!\n-//! Some functions here, such as `codegen_block` and `codegen_expr`, return a value --\n-//! the result of the codegen to LLVM -- while others, such as `codegen_fn`\n-//! and `mono_item`, are called only for the side effect of adding a\n-//! particular definition to the LLVM IR output we're producing.\n-//!\n-//! Hopefully useful general knowledge about codegen:\n-//!\n-//! * There's no way to find out the `Ty` type of a `Value`. Doing so\n-//!   would be \"trying to get the eggs out of an omelette\" (credit:\n-//!   pcwalton). You can, instead, find out its `llvm::Type` by calling `val_ty`,\n-//!   but one `llvm::Type` corresponds to many `Ty`s; for instance, `tup(int, int,\n-//!   int)` and `rec(x=int, y=int, z=int)` will have the same `llvm::Type`.\n-\n use crate::back::write::{\n     compute_per_cgu_lto_type, start_async_codegen, submit_codegened_module_to_llvm,\n     submit_post_lto_module_to_llvm, submit_pre_lto_module_to_llvm, ComputedLtoType, OngoingCodegen,"}, {"sha": "47a7651e1d4147170bab4edfa67e66a87e885645", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "patch": "@@ -760,9 +760,9 @@ pub struct Pat<'hir> {\n     pub default_binding_modes: bool,\n }\n \n-impl Pat<'_> {\n+impl<'hir> Pat<'hir> {\n     // FIXME(#19596) this is a workaround, but there should be a better way\n-    fn walk_short_(&self, it: &mut impl FnMut(&Pat<'_>) -> bool) -> bool {\n+    fn walk_short_(&self, it: &mut impl FnMut(&Pat<'hir>) -> bool) -> bool {\n         if !it(self) {\n             return false;\n         }\n@@ -785,12 +785,12 @@ impl Pat<'_> {\n     /// Note that when visiting e.g. `Tuple(ps)`,\n     /// if visiting `ps[0]` returns `false`,\n     /// then `ps[1]` will not be visited.\n-    pub fn walk_short(&self, mut it: impl FnMut(&Pat<'_>) -> bool) -> bool {\n+    pub fn walk_short(&self, mut it: impl FnMut(&Pat<'hir>) -> bool) -> bool {\n         self.walk_short_(&mut it)\n     }\n \n     // FIXME(#19596) this is a workaround, but there should be a better way\n-    fn walk_(&self, it: &mut impl FnMut(&Pat<'_>) -> bool) {\n+    fn walk_(&self, it: &mut impl FnMut(&Pat<'hir>) -> bool) {\n         if !it(self) {\n             return;\n         }\n@@ -810,7 +810,7 @@ impl Pat<'_> {\n     /// Walk the pattern in left-to-right order.\n     ///\n     /// If `it(pat)` returns `false`, the children are not visited.\n-    pub fn walk(&self, mut it: impl FnMut(&Pat<'_>) -> bool) {\n+    pub fn walk(&self, mut it: impl FnMut(&Pat<'hir>) -> bool) {\n         self.walk_(&mut it)\n     }\n "}, {"sha": "777107ed863109854043de0ba6bd3dcf133b53ad", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "patch": "@@ -153,6 +153,7 @@ fn msg_span_from_early_bound_and_free_regions(\n         Some(Node::Item(it)) => item_scope_tag(&it),\n         Some(Node::TraitItem(it)) => trait_item_scope_tag(&it),\n         Some(Node::ImplItem(it)) => impl_item_scope_tag(&it),\n+        Some(Node::ForeignItem(it)) => foreign_item_scope_tag(&it),\n         _ => unreachable!(),\n     };\n     let (prefix, span) = match *region {\n@@ -233,6 +234,13 @@ fn impl_item_scope_tag(item: &hir::ImplItem<'_>) -> &'static str {\n     }\n }\n \n+fn foreign_item_scope_tag(item: &hir::ForeignItem<'_>) -> &'static str {\n+    match item.kind {\n+        hir::ForeignItemKind::Fn(..) => \"method body\",\n+        hir::ForeignItemKind::Static(..) | hir::ForeignItemKind::Type => \"associated item\",\n+    }\n+}\n+\n fn explain_span(tcx: TyCtxt<'tcx>, heading: &str, span: Span) -> (String, Option<Span>) {\n     let lo = tcx.sess.source_map().lookup_char_pos(span.lo());\n     (format!(\"the {} at {}:{}\", heading, lo.line, lo.col.to_usize() + 1), Some(span))"}, {"sha": "2ae9ded3fa0cf47e9fbec66693f88ab9c157dbc7", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "patch": "@@ -51,7 +51,7 @@ impl<'tcx> CheckWfFcxBuilder<'tcx> {\n             let fcx = FnCtxt::new(&inh, param_env, id);\n             if !inh.tcx.features().trivial_bounds {\n                 // As predicates are cached rather than obligations, this\n-                // needsto be called first so that they are checked with an\n+                // needs to be called first so that they are checked with an\n                 // empty `param_env`.\n                 check_false_global_bounds(&fcx, span, id);\n             }"}, {"sha": "3c97b55005c4448b4ac8709e8b001ff8b91eeed3", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 46, "deletions": 6, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "patch": "@@ -6,7 +6,7 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit;\n use rustc_hir::intravisit::Visitor;\n-use rustc_hir::Node;\n+use rustc_hir::{HirId, Node};\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts};\n use rustc_middle::ty::util::IntTypeExt;\n@@ -22,7 +22,6 @@ use super::{bad_placeholder_type, is_suggestable_infer_ty};\n /// This should be called using the query `tcx.opt_const_param_of`.\n pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<DefId> {\n     use hir::*;\n-\n     let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n \n     if let Node::AnonConst(_) = tcx.hir().get(hir_id) {\n@@ -62,9 +61,9 @@ pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<\n             }\n \n             Node::Ty(&Ty { kind: TyKind::Path(_), .. })\n-            | Node::Expr(&Expr { kind: ExprKind::Struct(..), .. })\n-            | Node::Expr(&Expr { kind: ExprKind::Path(_), .. })\n-            | Node::TraitRef(..) => {\n+            | Node::Expr(&Expr { kind: ExprKind::Path(_) | ExprKind::Struct(..), .. })\n+            | Node::TraitRef(..)\n+            | Node::Pat(_) => {\n                 let path = match parent_node {\n                     Node::Ty(&Ty { kind: TyKind::Path(QPath::Resolved(_, path)), .. })\n                     | Node::TraitRef(&TraitRef { path, .. }) => &*path,\n@@ -79,6 +78,20 @@ pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<\n                         let _tables = tcx.typeck(body_owner);\n                         &*path\n                     }\n+                    Node::Pat(pat) => {\n+                        if let Some(path) = get_path_containing_arg_in_pat(pat, hir_id) {\n+                            path\n+                        } else {\n+                            tcx.sess.delay_span_bug(\n+                                tcx.def_span(def_id),\n+                                &format!(\n+                                    \"unable to find const parent for {} in pat {:?}\",\n+                                    hir_id, pat\n+                                ),\n+                            );\n+                            return None;\n+                        }\n+                    }\n                     _ => {\n                         tcx.sess.delay_span_bug(\n                             tcx.def_span(def_id),\n@@ -91,7 +104,6 @@ pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<\n                 // We've encountered an `AnonConst` in some path, so we need to\n                 // figure out which generic parameter it corresponds to and return\n                 // the relevant type.\n-\n                 let (arg_index, segment) = path\n                     .segments\n                     .iter()\n@@ -144,6 +156,34 @@ pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<\n     }\n }\n \n+fn get_path_containing_arg_in_pat<'hir>(\n+    pat: &'hir hir::Pat<'hir>,\n+    arg_id: HirId,\n+) -> Option<&'hir hir::Path<'hir>> {\n+    use hir::*;\n+\n+    let is_arg_in_path = |p: &hir::Path<'_>| {\n+        p.segments\n+            .iter()\n+            .filter_map(|seg| seg.args)\n+            .flat_map(|args| args.args)\n+            .any(|arg| arg.id() == arg_id)\n+    };\n+    let mut arg_path = None;\n+    pat.walk(|pat| match pat.kind {\n+        PatKind::Struct(QPath::Resolved(_, path), _, _)\n+        | PatKind::TupleStruct(QPath::Resolved(_, path), _, _)\n+        | PatKind::Path(QPath::Resolved(_, path))\n+            if is_arg_in_path(path) =>\n+        {\n+            arg_path = Some(path);\n+            false\n+        }\n+        _ => true,\n+    });\n+    arg_path\n+}\n+\n pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n     let def_id = def_id.expect_local();\n     use rustc_hir::*;"}, {"sha": "f4d89a89c14677eeb1a8ccfe1314579cb8e0e381", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "patch": "@@ -335,7 +335,7 @@ impl Merge for TomlConfig {\n                     *x = Some(new);\n                 }\n             }\n-        };\n+        }\n         do_merge(&mut self.build, build);\n         do_merge(&mut self.install, install);\n         do_merge(&mut self.llvm, llvm);"}, {"sha": "daec1656b27cdd00bc08360f4acfbee207ba201b", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "patch": "@@ -19,7 +19,7 @@ use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n use crate::cache::{Interned, INTERNER};\n use crate::compile;\n use crate::config::TargetSelection;\n-use crate::tarball::{OverlayKind, Tarball};\n+use crate::tarball::{GeneratedTarball, OverlayKind, Tarball};\n use crate::tool::{self, Tool};\n use crate::util::{exe, is_dylib, timeit};\n use crate::{Compiler, DependencyType, Mode, LLVM_TOOLS};\n@@ -51,7 +51,7 @@ pub struct Docs {\n }\n \n impl Step for Docs {\n-    type Output = Option<PathBuf>;\n+    type Output = Option<GeneratedTarball>;\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n@@ -63,7 +63,7 @@ impl Step for Docs {\n     }\n \n     /// Builds the `rust-docs` installer component.\n-    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<GeneratedTarball> {\n         let host = self.host;\n         if !builder.config.docs {\n             return None;\n@@ -86,7 +86,7 @@ pub struct RustcDocs {\n }\n \n impl Step for RustcDocs {\n-    type Output = Option<PathBuf>;\n+    type Output = Option<GeneratedTarball>;\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n@@ -98,7 +98,7 @@ impl Step for RustcDocs {\n     }\n \n     /// Builds the `rustc-docs` installer component.\n-    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<GeneratedTarball> {\n         let host = self.host;\n         if !builder.config.compiler_docs {\n             return None;\n@@ -267,7 +267,7 @@ pub struct Mingw {\n }\n \n impl Step for Mingw {\n-    type Output = Option<PathBuf>;\n+    type Output = Option<GeneratedTarball>;\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n@@ -282,7 +282,7 @@ impl Step for Mingw {\n     ///\n     /// This contains all the bits and pieces to run the MinGW Windows targets\n     /// without any extra installed software (e.g., we bundle gcc, libraries, etc).\n-    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<GeneratedTarball> {\n         let host = self.host;\n         if !host.contains(\"pc-windows-gnu\") {\n             return None;\n@@ -307,7 +307,7 @@ pub struct Rustc {\n }\n \n impl Step for Rustc {\n-    type Output = PathBuf;\n+    type Output = GeneratedTarball;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n@@ -321,7 +321,7 @@ impl Step for Rustc {\n     }\n \n     /// Creates the `rustc` installer component.\n-    fn run(self, builder: &Builder<'_>) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> GeneratedTarball {\n         let compiler = self.compiler;\n         let host = self.compiler.host;\n \n@@ -555,7 +555,7 @@ pub struct Std {\n }\n \n impl Step for Std {\n-    type Output = Option<PathBuf>;\n+    type Output = Option<GeneratedTarball>;\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n@@ -573,7 +573,7 @@ impl Step for Std {\n         });\n     }\n \n-    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<GeneratedTarball> {\n         let compiler = self.compiler;\n         let target = self.target;\n \n@@ -601,7 +601,7 @@ pub struct RustcDev {\n }\n \n impl Step for RustcDev {\n-    type Output = Option<PathBuf>;\n+    type Output = Option<GeneratedTarball>;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n@@ -620,7 +620,7 @@ impl Step for RustcDev {\n         });\n     }\n \n-    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<GeneratedTarball> {\n         let compiler = self.compiler;\n         let target = self.target;\n         if skip_host_target_lib(builder, compiler) {\n@@ -660,7 +660,7 @@ pub struct Analysis {\n }\n \n impl Step for Analysis {\n-    type Output = Option<PathBuf>;\n+    type Output = Option<GeneratedTarball>;\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n@@ -683,7 +683,7 @@ impl Step for Analysis {\n     }\n \n     /// Creates a tarball of save-analysis metadata, if available.\n-    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<GeneratedTarball> {\n         let compiler = self.compiler;\n         let target = self.target;\n         assert!(builder.config.extended);\n@@ -796,7 +796,7 @@ pub struct Src;\n \n impl Step for Src {\n     /// The output path of the src installer tarball\n-    type Output = PathBuf;\n+    type Output = GeneratedTarball;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n@@ -809,7 +809,7 @@ impl Step for Src {\n     }\n \n     /// Creates the `rust-src` installer component\n-    fn run(self, builder: &Builder<'_>) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> GeneratedTarball {\n         let tarball = Tarball::new_targetless(builder, \"rust-src\");\n \n         // A lot of tools expect the rust-src component to be entirely in this directory, so if you\n@@ -848,7 +848,7 @@ pub struct PlainSourceTarball;\n \n impl Step for PlainSourceTarball {\n     /// Produces the location of the tarball generated\n-    type Output = PathBuf;\n+    type Output = GeneratedTarball;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n@@ -862,7 +862,7 @@ impl Step for PlainSourceTarball {\n     }\n \n     /// Creates the plain source tarball\n-    fn run(self, builder: &Builder<'_>) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> GeneratedTarball {\n         let tarball = Tarball::new(builder, \"rustc\", \"src\");\n         let plain_dst_src = tarball.image_dir();\n \n@@ -941,7 +941,7 @@ pub struct Cargo {\n }\n \n impl Step for Cargo {\n-    type Output = PathBuf;\n+    type Output = GeneratedTarball;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n@@ -959,7 +959,7 @@ impl Step for Cargo {\n         });\n     }\n \n-    fn run(self, builder: &Builder<'_>) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> GeneratedTarball {\n         let compiler = self.compiler;\n         let target = self.target;\n \n@@ -995,7 +995,7 @@ pub struct Rls {\n }\n \n impl Step for Rls {\n-    type Output = Option<PathBuf>;\n+    type Output = Option<GeneratedTarball>;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n@@ -1013,7 +1013,7 @@ impl Step for Rls {\n         });\n     }\n \n-    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<GeneratedTarball> {\n         let compiler = self.compiler;\n         let target = self.target;\n         assert!(builder.config.extended);\n@@ -1041,7 +1041,7 @@ pub struct RustAnalyzer {\n }\n \n impl Step for RustAnalyzer {\n-    type Output = Option<PathBuf>;\n+    type Output = Option<GeneratedTarball>;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n@@ -1059,7 +1059,7 @@ impl Step for RustAnalyzer {\n         });\n     }\n \n-    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<GeneratedTarball> {\n         let compiler = self.compiler;\n         let target = self.target;\n         assert!(builder.config.extended);\n@@ -1090,7 +1090,7 @@ pub struct Clippy {\n }\n \n impl Step for Clippy {\n-    type Output = PathBuf;\n+    type Output = GeneratedTarball;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n@@ -1108,7 +1108,7 @@ impl Step for Clippy {\n         });\n     }\n \n-    fn run(self, builder: &Builder<'_>) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> GeneratedTarball {\n         let compiler = self.compiler;\n         let target = self.target;\n         assert!(builder.config.extended);\n@@ -1140,7 +1140,7 @@ pub struct Miri {\n }\n \n impl Step for Miri {\n-    type Output = Option<PathBuf>;\n+    type Output = Option<GeneratedTarball>;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n@@ -1158,7 +1158,7 @@ impl Step for Miri {\n         });\n     }\n \n-    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<GeneratedTarball> {\n         let compiler = self.compiler;\n         let target = self.target;\n         assert!(builder.config.extended);\n@@ -1193,7 +1193,7 @@ pub struct Rustfmt {\n }\n \n impl Step for Rustfmt {\n-    type Output = Option<PathBuf>;\n+    type Output = Option<GeneratedTarball>;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n@@ -1211,7 +1211,7 @@ impl Step for Rustfmt {\n         });\n     }\n \n-    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<GeneratedTarball> {\n         let compiler = self.compiler;\n         let target = self.target;\n \n@@ -1316,11 +1316,11 @@ impl Step for Extended {\n             tarballs.push(mingw_installer.unwrap());\n         }\n \n-        let mut tarball = Tarball::new(builder, \"rust\", &target.triple);\n-        let work = tarball.persist_work_dir();\n-        tarball.combine(&tarballs);\n+        let tarball = Tarball::new(builder, \"rust\", &target.triple);\n+        let generated = tarball.combine(&tarballs);\n \n         let tmp = tmpdir(builder).join(\"combined-tarball\");\n+        let work = generated.work_dir();\n \n         let mut license = String::new();\n         license += &builder.read(&builder.src.join(\"COPYRIGHT\"));\n@@ -1870,7 +1870,7 @@ pub struct LlvmTools {\n }\n \n impl Step for LlvmTools {\n-    type Output = Option<PathBuf>;\n+    type Output = Option<GeneratedTarball>;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n@@ -1881,7 +1881,7 @@ impl Step for LlvmTools {\n         run.builder.ensure(LlvmTools { target: run.target });\n     }\n \n-    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<GeneratedTarball> {\n         let target = self.target;\n         assert!(builder.config.extended);\n \n@@ -1924,7 +1924,7 @@ pub struct RustDev {\n }\n \n impl Step for RustDev {\n-    type Output = Option<PathBuf>;\n+    type Output = Option<GeneratedTarball>;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n@@ -1936,7 +1936,7 @@ impl Step for RustDev {\n         run.builder.ensure(RustDev { target: run.target });\n     }\n \n-    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<GeneratedTarball> {\n         let target = self.target;\n \n         /* run only if llvm-config isn't used */\n@@ -1989,7 +1989,7 @@ pub struct BuildManifest {\n }\n \n impl Step for BuildManifest {\n-    type Output = PathBuf;\n+    type Output = GeneratedTarball;\n     const DEFAULT: bool = false;\n     const ONLY_HOSTS: bool = true;\n \n@@ -2001,7 +2001,7 @@ impl Step for BuildManifest {\n         run.builder.ensure(BuildManifest { target: run.target });\n     }\n \n-    fn run(self, builder: &Builder<'_>) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> GeneratedTarball {\n         let build_manifest = builder.tool_exe(Tool::BuildManifest);\n \n         let tarball = Tarball::new(builder, \"build-manifest\", &self.target.triple);\n@@ -2021,7 +2021,7 @@ pub struct ReproducibleArtifacts {\n }\n \n impl Step for ReproducibleArtifacts {\n-    type Output = Option<PathBuf>;\n+    type Output = Option<GeneratedTarball>;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n "}, {"sha": "96164947943ba4760926023f19b2595c083f881c", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 31, "deletions": 75, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "patch": "@@ -10,60 +10,19 @@ use std::process::Command;\n \n use build_helper::t;\n \n-use crate::dist::{self, pkgname, sanitize_sh, tmpdir};\n+use crate::dist::{self, sanitize_sh};\n+use crate::tarball::GeneratedTarball;\n use crate::Compiler;\n \n use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n use crate::config::{Config, TargetSelection};\n \n-pub fn install_docs(builder: &Builder<'_>, stage: u32, host: TargetSelection) {\n-    install_sh(builder, \"docs\", \"rust-docs\", stage, Some(host));\n-}\n-\n-pub fn install_std(builder: &Builder<'_>, stage: u32, target: TargetSelection) {\n-    install_sh(builder, \"std\", \"rust-std\", stage, Some(target));\n-}\n-\n-pub fn install_cargo(builder: &Builder<'_>, stage: u32, host: TargetSelection) {\n-    install_sh(builder, \"cargo\", \"cargo\", stage, Some(host));\n-}\n-\n-pub fn install_rls(builder: &Builder<'_>, stage: u32, host: TargetSelection) {\n-    install_sh(builder, \"rls\", \"rls\", stage, Some(host));\n-}\n-\n-pub fn install_rust_analyzer(builder: &Builder<'_>, stage: u32, host: TargetSelection) {\n-    install_sh(builder, \"rust-analyzer\", \"rust-analyzer\", stage, Some(host));\n-}\n-\n-pub fn install_clippy(builder: &Builder<'_>, stage: u32, host: TargetSelection) {\n-    install_sh(builder, \"clippy\", \"clippy\", stage, Some(host));\n-}\n-pub fn install_miri(builder: &Builder<'_>, stage: u32, host: TargetSelection) {\n-    install_sh(builder, \"miri\", \"miri\", stage, Some(host));\n-}\n-\n-pub fn install_rustfmt(builder: &Builder<'_>, stage: u32, host: TargetSelection) {\n-    install_sh(builder, \"rustfmt\", \"rustfmt\", stage, Some(host));\n-}\n-\n-pub fn install_analysis(builder: &Builder<'_>, stage: u32, host: TargetSelection) {\n-    install_sh(builder, \"analysis\", \"rust-analysis\", stage, Some(host));\n-}\n-\n-pub fn install_src(builder: &Builder<'_>, stage: u32) {\n-    install_sh(builder, \"src\", \"rust-src\", stage, None);\n-}\n-pub fn install_rustc(builder: &Builder<'_>, stage: u32, host: TargetSelection) {\n-    install_sh(builder, \"rustc\", \"rustc\", stage, Some(host));\n-}\n-\n fn install_sh(\n     builder: &Builder<'_>,\n     package: &str,\n-    name: &str,\n     stage: u32,\n     host: Option<TargetSelection>,\n+    tarball: &GeneratedTarball,\n ) {\n     builder.info(&format!(\"Install {} stage{} ({:?})\", package, stage, host));\n \n@@ -108,15 +67,10 @@ fn install_sh(\n     let empty_dir = builder.out.join(\"tmp/empty_dir\");\n \n     t!(fs::create_dir_all(&empty_dir));\n-    let package_name = if let Some(host) = host {\n-        format!(\"{}-{}\", pkgname(builder, name), host.triple)\n-    } else {\n-        pkgname(builder, name)\n-    };\n \n     let mut cmd = Command::new(\"sh\");\n     cmd.current_dir(&empty_dir)\n-        .arg(sanitize_sh(&tmpdir(builder).join(&package_name).join(\"install.sh\")))\n+        .arg(sanitize_sh(&tarball.decompressed_output().join(\"install.sh\")))\n         .arg(format!(\"--prefix={}\", sanitize_sh(&prefix)))\n         .arg(format!(\"--sysconfdir={}\", sanitize_sh(&sysconfdir)))\n         .arg(format!(\"--datadir={}\", sanitize_sh(&datadir)))\n@@ -191,75 +145,77 @@ macro_rules! install {\n \n install!((self, builder, _config),\n     Docs, \"src/doc\", _config.docs, only_hosts: false, {\n-        builder.ensure(dist::Docs { host: self.target });\n-        install_docs(builder, self.compiler.stage, self.target);\n+        let tarball = builder.ensure(dist::Docs { host: self.target }).expect(\"missing docs\");\n+        install_sh(builder, \"docs\", self.compiler.stage, Some(self.target), &tarball);\n     };\n     Std, \"library/std\", true, only_hosts: false, {\n         for target in &builder.targets {\n-            builder.ensure(dist::Std {\n+            let tarball = builder.ensure(dist::Std {\n                 compiler: self.compiler,\n                 target: *target\n-            });\n-            install_std(builder, self.compiler.stage, *target);\n+            }).expect(\"missing std\");\n+            install_sh(builder, \"std\", self.compiler.stage, Some(*target), &tarball);\n         }\n     };\n     Cargo, \"cargo\", Self::should_build(_config), only_hosts: true, {\n-        builder.ensure(dist::Cargo { compiler: self.compiler, target: self.target });\n-        install_cargo(builder, self.compiler.stage, self.target);\n+        let tarball = builder.ensure(dist::Cargo { compiler: self.compiler, target: self.target });\n+        install_sh(builder, \"cargo\", self.compiler.stage, Some(self.target), &tarball);\n     };\n     Rls, \"rls\", Self::should_build(_config), only_hosts: true, {\n-        if builder.ensure(dist::Rls { compiler: self.compiler, target: self.target }).is_some() {\n-            install_rls(builder, self.compiler.stage, self.target);\n+        if let Some(tarball) = builder.ensure(dist::Rls { compiler: self.compiler, target: self.target }) {\n+            install_sh(builder, \"rls\", self.compiler.stage, Some(self.target), &tarball);\n         } else {\n             builder.info(\n                 &format!(\"skipping Install RLS stage{} ({})\", self.compiler.stage, self.target),\n             );\n         }\n     };\n     RustAnalyzer, \"rust-analyzer\", Self::should_build(_config), only_hosts: true, {\n-        builder.ensure(dist::RustAnalyzer { compiler: self.compiler, target: self.target });\n-        install_rust_analyzer(builder, self.compiler.stage, self.target);\n+        let tarball = builder\n+            .ensure(dist::RustAnalyzer { compiler: self.compiler, target: self.target })\n+            .expect(\"missing rust-analyzer\");\n+        install_sh(builder, \"rust-analyzer\", self.compiler.stage, Some(self.target), &tarball);\n     };\n     Clippy, \"clippy\", Self::should_build(_config), only_hosts: true, {\n-        builder.ensure(dist::Clippy { compiler: self.compiler, target: self.target });\n-        install_clippy(builder, self.compiler.stage, self.target);\n+        let tarball = builder.ensure(dist::Clippy { compiler: self.compiler, target: self.target });\n+        install_sh(builder, \"clippy\", self.compiler.stage, Some(self.target), &tarball);\n     };\n     Miri, \"miri\", Self::should_build(_config), only_hosts: true, {\n-        if builder.ensure(dist::Miri { compiler: self.compiler, target: self.target }).is_some() {\n-            install_miri(builder, self.compiler.stage, self.target);\n+        if let Some(tarball) = builder.ensure(dist::Miri { compiler: self.compiler, target: self.target }) {\n+            install_sh(builder, \"miri\", self.compiler.stage, Some(self.target), &tarball);\n         } else {\n             builder.info(\n                 &format!(\"skipping Install miri stage{} ({})\", self.compiler.stage, self.target),\n             );\n         }\n     };\n     Rustfmt, \"rustfmt\", Self::should_build(_config), only_hosts: true, {\n-        if builder.ensure(dist::Rustfmt {\n+        if let Some(tarball) = builder.ensure(dist::Rustfmt {\n             compiler: self.compiler,\n             target: self.target\n-        }).is_some() {\n-            install_rustfmt(builder, self.compiler.stage, self.target);\n+        }) {\n+            install_sh(builder, \"rustfmt\", self.compiler.stage, Some(self.target), &tarball);\n         } else {\n             builder.info(\n                 &format!(\"skipping Install Rustfmt stage{} ({})\", self.compiler.stage, self.target),\n             );\n         }\n     };\n     Analysis, \"analysis\", Self::should_build(_config), only_hosts: false, {\n-        builder.ensure(dist::Analysis {\n+        let tarball = builder.ensure(dist::Analysis {\n             // Find the actual compiler (handling the full bootstrap option) which\n             // produced the save-analysis data because that data isn't copied\n             // through the sysroot uplifting.\n             compiler: builder.compiler_for(builder.top_stage, builder.config.build, self.target),\n             target: self.target\n-        });\n-        install_analysis(builder, self.compiler.stage, self.target);\n+        }).expect(\"missing analysis\");\n+        install_sh(builder, \"analysis\", self.compiler.stage, Some(self.target), &tarball);\n     };\n     Rustc, \"src/librustc\", true, only_hosts: true, {\n-        builder.ensure(dist::Rustc {\n+        let tarball = builder.ensure(dist::Rustc {\n             compiler: builder.compiler(builder.top_stage, self.target),\n         });\n-        install_rustc(builder, self.compiler.stage, self.target);\n+        install_sh(builder, \"rustc\", self.compiler.stage, Some(self.target), &tarball);\n     };\n );\n \n@@ -284,7 +240,7 @@ impl Step for Src {\n     }\n \n     fn run(self, builder: &Builder<'_>) {\n-        builder.ensure(dist::Src);\n-        install_src(builder, self.stage);\n+        let tarball = builder.ensure(dist::Src);\n+        install_sh(builder, \"src\", self.stage, None, &tarball);\n     }\n }"}, {"sha": "7fb03056f1bd3ae7a99a1c125c242c51f37b76e4", "filename": "src/bootstrap/tarball.rs", "status": "modified", "additions": 33, "deletions": 18, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Fbootstrap%2Ftarball.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Fbootstrap%2Ftarball.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftarball.rs?ref=99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "patch": "@@ -97,7 +97,6 @@ pub(crate) struct Tarball<'a> {\n \n     include_target_in_component_name: bool,\n     is_preview: bool,\n-    delete_temp_dir: bool,\n }\n \n impl<'a> Tarball<'a> {\n@@ -136,7 +135,6 @@ impl<'a> Tarball<'a> {\n \n             include_target_in_component_name: false,\n             is_preview: false,\n-            delete_temp_dir: true,\n         }\n     }\n \n@@ -198,12 +196,7 @@ impl<'a> Tarball<'a> {\n         self.builder.cp_r(src.as_ref(), &dest);\n     }\n \n-    pub(crate) fn persist_work_dir(&mut self) -> PathBuf {\n-        self.delete_temp_dir = false;\n-        self.temp_dir.clone()\n-    }\n-\n-    pub(crate) fn generate(self) -> PathBuf {\n+    pub(crate) fn generate(self) -> GeneratedTarball {\n         let mut component_name = self.component.clone();\n         if self.is_preview {\n             component_name.push_str(\"-preview\");\n@@ -227,20 +220,20 @@ impl<'a> Tarball<'a> {\n         })\n     }\n \n-    pub(crate) fn combine(self, tarballs: &[PathBuf]) {\n-        let mut input_tarballs = tarballs[0].as_os_str().to_os_string();\n+    pub(crate) fn combine(self, tarballs: &[GeneratedTarball]) -> GeneratedTarball {\n+        let mut input_tarballs = tarballs[0].path.as_os_str().to_os_string();\n         for tarball in &tarballs[1..] {\n             input_tarballs.push(\",\");\n-            input_tarballs.push(tarball);\n+            input_tarballs.push(&tarball.path);\n         }\n \n         self.run(|this, cmd| {\n             cmd.arg(\"combine\").arg(\"--input-tarballs\").arg(input_tarballs);\n             this.non_bare_args(cmd);\n-        });\n+        })\n     }\n \n-    pub(crate) fn bare(self) -> PathBuf {\n+    pub(crate) fn bare(self) -> GeneratedTarball {\n         // Bare tarballs should have the top level directory match the package\n         // name, not \"image\". We rename the image directory just before passing\n         // into rust-installer.\n@@ -276,7 +269,7 @@ impl<'a> Tarball<'a> {\n             .arg(crate::dist::distdir(self.builder));\n     }\n \n-    fn run(self, build_cli: impl FnOnce(&Tarball<'a>, &mut Command)) -> PathBuf {\n+    fn run(self, build_cli: impl FnOnce(&Tarball<'a>, &mut Command)) -> GeneratedTarball {\n         t!(std::fs::create_dir_all(&self.overlay_dir));\n         self.builder.create(&self.overlay_dir.join(\"version\"), &self.overlay.version(self.builder));\n         if let Some(sha) = self.builder.rust_sha() {\n@@ -299,9 +292,6 @@ impl<'a> Tarball<'a> {\n             cmd.arg(\"--compression-formats\").arg(formats.join(\",\"));\n         }\n         self.builder.run(&mut cmd);\n-        if self.delete_temp_dir {\n-            t!(std::fs::remove_dir_all(&self.temp_dir));\n-        }\n \n         // Use either the first compression format defined, or \"gz\" as the default.\n         let ext = self\n@@ -313,6 +303,31 @@ impl<'a> Tarball<'a> {\n             .map(|s| s.as_str())\n             .unwrap_or(\"gz\");\n \n-        crate::dist::distdir(self.builder).join(format!(\"{}.tar.{}\", package_name, ext))\n+        GeneratedTarball {\n+            path: crate::dist::distdir(self.builder).join(format!(\"{}.tar.{}\", package_name, ext)),\n+            decompressed_output: self.temp_dir.join(package_name),\n+            work: self.temp_dir,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct GeneratedTarball {\n+    path: PathBuf,\n+    decompressed_output: PathBuf,\n+    work: PathBuf,\n+}\n+\n+impl GeneratedTarball {\n+    pub(crate) fn tarball(&self) -> &Path {\n+        &self.path\n+    }\n+\n+    pub(crate) fn decompressed_output(&self) -> &Path {\n+        &self.decompressed_output\n+    }\n+\n+    pub(crate) fn work_dir(&self) -> &Path {\n+        &self.work\n     }\n }"}, {"sha": "33e252a63c9a59728286bdced37d9d1d0515a62a", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "patch": "@@ -1963,7 +1963,7 @@ impl Step for Distcheck {\n \n         let mut cmd = Command::new(\"tar\");\n         cmd.arg(\"-xf\")\n-            .arg(builder.ensure(dist::PlainSourceTarball))\n+            .arg(builder.ensure(dist::PlainSourceTarball).tarball())\n             .arg(\"--strip-components=1\")\n             .current_dir(&dir);\n         builder.run(&mut cmd);\n@@ -1986,7 +1986,10 @@ impl Step for Distcheck {\n         t!(fs::create_dir_all(&dir));\n \n         let mut cmd = Command::new(\"tar\");\n-        cmd.arg(\"-xf\").arg(builder.ensure(dist::Src)).arg(\"--strip-components=1\").current_dir(&dir);\n+        cmd.arg(\"-xf\")\n+            .arg(builder.ensure(dist::Src).tarball())\n+            .arg(\"--strip-components=1\")\n+            .current_dir(&dir);\n         builder.run(&mut cmd);\n \n         let toml = dir.join(\"rust-src/lib/rustlib/src/rust/library/std/Cargo.toml\");"}, {"sha": "f4eb1924e6f7eee811f6acaa10968e3142789dc8", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "patch": "@@ -2325,18 +2325,19 @@ impl Clean<Item> for (&hir::MacroDef<'_>, Option<Symbol>) {\n             )\n         } else {\n             let vis = item.vis.clean(cx);\n+            let def_id = cx.tcx.hir().local_def_id(item.hir_id).to_def_id();\n \n             if matchers.len() <= 1 {\n                 format!(\n                     \"{}macro {}{} {{\\n    ...\\n}}\",\n-                    vis.print_with_space(cx.tcx),\n+                    vis.print_with_space(cx.tcx, def_id),\n                     name,\n                     matchers.iter().map(|span| span.to_src(cx)).collect::<String>(),\n                 )\n             } else {\n                 format!(\n                     \"{}macro {} {{\\n{}}}\",\n-                    vis.print_with_space(cx.tcx),\n+                    vis.print_with_space(cx.tcx, def_id),\n                     name,\n                     matchers\n                         .iter()"}, {"sha": "d4482d6fa9015b9b5e4d2db986f4f2cf67e2f0d9", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "patch": "@@ -14,7 +14,7 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n-use rustc_middle::ty::{self, DefIdTree, Ty};\n+use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt};\n use rustc_span::symbol::{kw, sym, Symbol};\n use std::mem;\n \n@@ -623,3 +623,24 @@ where\n     *cx.impl_trait_bounds.borrow_mut() = old_bounds;\n     r\n }\n+\n+/// Find the nearest parent module of a [`DefId`].\n+///\n+/// **Panics if the item it belongs to [is fake][Item::is_fake].**\n+crate fn find_nearest_parent_module(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n+    if def_id.is_top_level_module() {\n+        // The crate root has no parent. Use it as the root instead.\n+        Some(def_id)\n+    } else {\n+        let mut current = def_id;\n+        // The immediate parent might not always be a module.\n+        // Find the first parent which is.\n+        while let Some(parent) = tcx.parent(current) {\n+            if tcx.def_kind(parent) == DefKind::Mod {\n+                return Some(parent);\n+            }\n+            current = parent;\n+        }\n+        None\n+    }\n+}"}, {"sha": "9b2fb8582f54f678606b64bc3f247b7fc150e49c", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 42, "deletions": 20, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "patch": "@@ -15,7 +15,7 @@ use rustc_middle::ty::TyCtxt;\n use rustc_span::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc_target::spec::abi::Abi;\n \n-use crate::clean::{self, PrimitiveType};\n+use crate::clean::{self, utils::find_nearest_parent_module, PrimitiveType};\n use crate::formats::cache::cache;\n use crate::formats::item_type::ItemType;\n use crate::html::escape::Escape;\n@@ -1085,32 +1085,54 @@ impl Function<'_> {\n }\n \n impl clean::Visibility {\n-    crate fn print_with_space<'tcx>(self, tcx: TyCtxt<'tcx>) -> impl fmt::Display + 'tcx {\n+    crate fn print_with_space<'tcx>(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+        item_did: DefId,\n+    ) -> impl fmt::Display + 'tcx {\n         use rustc_span::symbol::kw;\n \n         display_fn(move |f| match self {\n             clean::Public => f.write_str(\"pub \"),\n             clean::Inherited => Ok(()),\n-            clean::Visibility::Restricted(did) if did.index == CRATE_DEF_INDEX => {\n-                write!(f, \"pub(crate) \")\n-            }\n-            clean::Visibility::Restricted(did) => {\n-                f.write_str(\"pub(\")?;\n-                let path = tcx.def_path(did);\n-                debug!(\"path={:?}\", path);\n-                let first_name =\n-                    path.data[0].data.get_opt_name().expect(\"modules are always named\");\n-                if path.data.len() != 1 || (first_name != kw::SelfLower && first_name != kw::Super)\n+\n+            clean::Visibility::Restricted(vis_did) => {\n+                // FIXME(camelid): This may not work correctly if `item_did` is a module.\n+                //                 However, rustdoc currently never displays a module's\n+                //                 visibility, so it shouldn't matter.\n+                let parent_module = find_nearest_parent_module(tcx, item_did);\n+\n+                if vis_did.index == CRATE_DEF_INDEX {\n+                    write!(f, \"pub(crate) \")\n+                } else if parent_module == Some(vis_did) {\n+                    // `pub(in foo)` where `foo` is the parent module\n+                    // is the same as no visibility modifier\n+                    Ok(())\n+                } else if parent_module\n+                    .map(|parent| find_nearest_parent_module(tcx, parent))\n+                    .flatten()\n+                    == Some(vis_did)\n                 {\n-                    f.write_str(\"in \")?;\n-                }\n-                // modified from `resolved_path()` to work with `DefPathData`\n-                let last_name = path.data.last().unwrap().data.get_opt_name().unwrap();\n-                for seg in &path.data[..path.data.len() - 1] {\n-                    write!(f, \"{}::\", seg.data.get_opt_name().unwrap())?;\n+                    write!(f, \"pub(super) \")\n+                } else {\n+                    f.write_str(\"pub(\")?;\n+                    let path = tcx.def_path(vis_did);\n+                    debug!(\"path={:?}\", path);\n+                    let first_name =\n+                        path.data[0].data.get_opt_name().expect(\"modules are always named\");\n+                    if path.data.len() != 1\n+                        || (first_name != kw::SelfLower && first_name != kw::Super)\n+                    {\n+                        f.write_str(\"in \")?;\n+                    }\n+                    // modified from `resolved_path()` to work with `DefPathData`\n+                    let last_name = path.data.last().unwrap().data.get_opt_name().unwrap();\n+                    for seg in &path.data[..path.data.len() - 1] {\n+                        write!(f, \"{}::\", seg.data.get_opt_name().unwrap())?;\n+                    }\n+                    let path = anchor(vis_did, &last_name.as_str()).to_string();\n+                    write!(f, \"{}) \", path)\n                 }\n-                let path = anchor(did, &last_name.as_str()).to_string();\n-                write!(f, \"{}) \", path)\n             }\n         })\n     }"}, {"sha": "c19262b72cf72a3a7fe4523c2eda30c325f79b01", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "patch": "@@ -2157,14 +2157,14 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                     Some(ref src) => write!(\n                         w,\n                         \"<tr><td><code>{}extern crate {} as {};\",\n-                        myitem.visibility.print_with_space(cx.tcx()),\n+                        myitem.visibility.print_with_space(cx.tcx(), myitem.def_id),\n                         anchor(myitem.def_id, &*src.as_str()),\n                         name\n                     ),\n                     None => write!(\n                         w,\n                         \"<tr><td><code>{}extern crate {};\",\n-                        myitem.visibility.print_with_space(cx.tcx()),\n+                        myitem.visibility.print_with_space(cx.tcx(), myitem.def_id),\n                         anchor(myitem.def_id, &*name.as_str())\n                     ),\n                 }\n@@ -2175,7 +2175,7 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                 write!(\n                     w,\n                     \"<tr><td><code>{}{}</code></td></tr>\",\n-                    myitem.visibility.print_with_space(cx.tcx()),\n+                    myitem.visibility.print_with_space(cx.tcx(), myitem.def_id),\n                     import.print()\n                 );\n             }\n@@ -2392,7 +2392,7 @@ fn item_constant(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, c: &clean::\n     write!(\n         w,\n         \"{vis}const {name}: {typ}\",\n-        vis = it.visibility.print_with_space(cx.tcx()),\n+        vis = it.visibility.print_with_space(cx.tcx(), it.def_id),\n         name = it.name.as_ref().unwrap(),\n         typ = c.type_.print(),\n     );\n@@ -2426,7 +2426,7 @@ fn item_static(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::St\n     write!(\n         w,\n         \"{vis}static {mutability}{name}: {typ}</pre>\",\n-        vis = it.visibility.print_with_space(cx.tcx()),\n+        vis = it.visibility.print_with_space(cx.tcx(), it.def_id),\n         mutability = s.mutability.print_with_space(),\n         name = it.name.as_ref().unwrap(),\n         typ = s.type_.print()\n@@ -2437,7 +2437,7 @@ fn item_static(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::St\n fn item_function(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, f: &clean::Function) {\n     let header_len = format!(\n         \"{}{}{}{}{:#}fn {}{:#}\",\n-        it.visibility.print_with_space(cx.tcx()),\n+        it.visibility.print_with_space(cx.tcx(), it.def_id),\n         f.header.constness.print_with_space(),\n         f.header.asyncness.print_with_space(),\n         f.header.unsafety.print_with_space(),\n@@ -2452,7 +2452,7 @@ fn item_function(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, f: &clean::\n         w,\n         \"{vis}{constness}{asyncness}{unsafety}{abi}fn \\\n          {name}{generics}{decl}{spotlight}{where_clause}</pre>\",\n-        vis = it.visibility.print_with_space(cx.tcx()),\n+        vis = it.visibility.print_with_space(cx.tcx(), it.def_id),\n         constness = f.header.constness.print_with_space(),\n         asyncness = f.header.asyncness.print_with_space(),\n         unsafety = f.header.unsafety.print_with_space(),\n@@ -2578,7 +2578,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n         write!(\n             w,\n             \"{}{}{}trait {}{}{}\",\n-            it.visibility.print_with_space(cx.tcx()),\n+            it.visibility.print_with_space(cx.tcx(), it.def_id),\n             t.unsafety.print_with_space(),\n             if t.is_auto { \"auto \" } else { \"\" },\n             it.name.as_ref().unwrap(),\n@@ -2896,7 +2896,7 @@ fn assoc_const(\n         w,\n         \"{}{}const <a href=\\\"{}\\\" class=\\\"constant\\\"><b>{}</b></a>: {}\",\n         extra,\n-        it.visibility.print_with_space(cx.tcx()),\n+        it.visibility.print_with_space(cx.tcx(), it.def_id),\n         naive_assoc_href(it, link),\n         it.name.as_ref().unwrap(),\n         ty.print()\n@@ -3015,7 +3015,7 @@ fn render_assoc_item(\n         };\n         let mut header_len = format!(\n             \"{}{}{}{}{}{:#}fn {}{:#}\",\n-            meth.visibility.print_with_space(cx.tcx()),\n+            meth.visibility.print_with_space(cx.tcx(), meth.def_id),\n             header.constness.print_with_space(),\n             header.asyncness.print_with_space(),\n             header.unsafety.print_with_space(),\n@@ -3037,7 +3037,7 @@ fn render_assoc_item(\n             \"{}{}{}{}{}{}{}fn <a href=\\\"{href}\\\" class=\\\"fnname\\\">{name}</a>\\\n              {generics}{decl}{spotlight}{where_clause}\",\n             if parent == ItemType::Trait { \"    \" } else { \"\" },\n-            meth.visibility.print_with_space(cx.tcx()),\n+            meth.visibility.print_with_space(cx.tcx(), meth.def_id),\n             header.constness.print_with_space(),\n             header.asyncness.print_with_space(),\n             header.unsafety.print_with_space(),\n@@ -3189,7 +3189,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n         write!(\n             w,\n             \"{}enum {}{}{}\",\n-            it.visibility.print_with_space(cx.tcx()),\n+            it.visibility.print_with_space(cx.tcx(), it.def_id),\n             it.name.as_ref().unwrap(),\n             e.generics.print(),\n             WhereClause { gens: &e.generics, indent: 0, end_newline: true }\n@@ -3365,7 +3365,7 @@ fn render_struct(\n     write!(\n         w,\n         \"{}{}{}\",\n-        it.visibility.print_with_space(cx.tcx()),\n+        it.visibility.print_with_space(cx.tcx(), it.def_id),\n         if structhead { \"struct \" } else { \"\" },\n         it.name.as_ref().unwrap()\n     );\n@@ -3385,7 +3385,7 @@ fn render_struct(\n                         w,\n                         \"\\n{}    {}{}: {},\",\n                         tab,\n-                        field.visibility.print_with_space(cx.tcx()),\n+                        field.visibility.print_with_space(cx.tcx(), field.def_id),\n                         field.name.as_ref().unwrap(),\n                         ty.print()\n                     );\n@@ -3414,7 +3414,12 @@ fn render_struct(\n                 match *field.kind {\n                     clean::StrippedItem(box clean::StructFieldItem(..)) => write!(w, \"_\"),\n                     clean::StructFieldItem(ref ty) => {\n-                        write!(w, \"{}{}\", field.visibility.print_with_space(cx.tcx()), ty.print())\n+                        write!(\n+                            w,\n+                            \"{}{}\",\n+                            field.visibility.print_with_space(cx.tcx(), field.def_id),\n+                            ty.print()\n+                        )\n                     }\n                     _ => unreachable!(),\n                 }\n@@ -3447,7 +3452,7 @@ fn render_union(\n     write!(\n         w,\n         \"{}{}{}\",\n-        it.visibility.print_with_space(cx.tcx()),\n+        it.visibility.print_with_space(cx.tcx(), it.def_id),\n         if structhead { \"union \" } else { \"\" },\n         it.name.as_ref().unwrap()\n     );\n@@ -3462,7 +3467,7 @@ fn render_union(\n             write!(\n                 w,\n                 \"    {}{}: {},\\n{}\",\n-                field.visibility.print_with_space(cx.tcx()),\n+                field.visibility.print_with_space(cx.tcx(), field.def_id),\n                 field.name.as_ref().unwrap(),\n                 ty.print(),\n                 tab\n@@ -4101,7 +4106,7 @@ fn item_foreign_type(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, cache:\n     write!(\n         w,\n         \"    {}type {};\\n}}</pre>\",\n-        it.visibility.print_with_space(cx.tcx()),\n+        it.visibility.print_with_space(cx.tcx(), it.def_id),\n         it.name.as_ref().unwrap(),\n     );\n "}, {"sha": "9f15038a353b51cee52d9f3ae108707437359d1a", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 2, "deletions": 24, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "patch": "@@ -31,7 +31,7 @@ use std::convert::{TryFrom, TryInto};\n use std::mem;\n use std::ops::Range;\n \n-use crate::clean::{self, Crate, Item, ItemLink, PrimitiveType};\n+use crate::clean::{self, utils::find_nearest_parent_module, Crate, Item, ItemLink, PrimitiveType};\n use crate::core::DocContext;\n use crate::fold::DocFolder;\n use crate::html::markdown::markdown_links;\n@@ -830,31 +830,9 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n         use rustc_middle::ty::DefIdTree;\n \n         let parent_node = if item.is_fake() {\n-            // FIXME: is this correct?\n             None\n-        // If we're documenting the crate root itself, it has no parent. Use the root instead.\n-        } else if item.def_id.is_top_level_module() {\n-            Some(item.def_id)\n         } else {\n-            let mut current = item.def_id;\n-            // The immediate parent might not always be a module.\n-            // Find the first parent which is.\n-            loop {\n-                if let Some(parent) = self.cx.tcx.parent(current) {\n-                    if self.cx.tcx.def_kind(parent) == DefKind::Mod {\n-                        break Some(parent);\n-                    }\n-                    current = parent;\n-                } else {\n-                    debug!(\n-                        \"{:?} has no parent (kind={:?}, original was {:?})\",\n-                        current,\n-                        self.cx.tcx.def_kind(current),\n-                        item.def_id\n-                    );\n-                    break None;\n-                }\n-            }\n+            find_nearest_parent_module(self.cx.tcx, item.def_id)\n         };\n \n         if parent_node.is_some() {"}, {"sha": "fb115ee43b77601b237717c21ab0a8f5b5b9d50a", "filename": "src/llvm-project", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm-project?ref=99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "patch": "@@ -1 +1 @@\n-Subproject commit 8d78ad13896b955f630714f386a95ed91b237e3d\n+Subproject commit fb115ee43b77601b237717c21ab0a8f5b5b9d50a"}, {"sha": "6720d848ac3b59e50947fa087a3a8b15a54aa475", "filename": "src/test/rustdoc/pub-restricted.rs", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/44e3daf5eee8263dfc3a2509e78ddd1f6f783a0e/src%2Ftest%2Frustdoc%2Fpub-restricted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44e3daf5eee8263dfc3a2509e78ddd1f6f783a0e/src%2Ftest%2Frustdoc%2Fpub-restricted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fpub-restricted.rs?ref=44e3daf5eee8263dfc3a2509e78ddd1f6f783a0e", "patch": "@@ -1,32 +0,0 @@\n-// compile-flags: --document-private-items\n-\n-#![feature(crate_visibility_modifier)]\n-\n-#![crate_name = \"foo\"]\n-\n-// @has 'foo/struct.FooPublic.html' '//pre' 'pub struct FooPublic'\n-pub struct FooPublic;\n-// @has 'foo/struct.FooJustCrate.html' '//pre' 'pub(crate) struct FooJustCrate'\n-crate struct FooJustCrate;\n-// @has 'foo/struct.FooPubCrate.html' '//pre' 'pub(crate) struct FooPubCrate'\n-pub(crate) struct FooPubCrate;\n-// @has 'foo/struct.FooSelf.html' '//pre' 'pub(crate) struct FooSelf'\n-pub(self) struct FooSelf;\n-// @has 'foo/struct.FooInSelf.html' '//pre' 'pub(crate) struct FooInSelf'\n-pub(in self) struct FooInSelf;\n-mod a {\n-    // @has 'foo/a/struct.FooSuper.html' '//pre' 'pub(crate) struct FooSuper'\n-    pub(super) struct FooSuper;\n-    // @has 'foo/a/struct.FooInSuper.html' '//pre' 'pub(crate) struct FooInSuper'\n-    pub(in super) struct FooInSuper;\n-    // @has 'foo/a/struct.FooInA.html' '//pre' 'pub(in a) struct FooInA'\n-    pub(in a) struct FooInA;\n-    mod b {\n-        // @has 'foo/a/b/struct.FooInSelfSuperB.html' '//pre' 'pub(in a::b) struct FooInSelfSuperB'\n-        pub(in a::b) struct FooInSelfSuperB;\n-        // @has 'foo/a/b/struct.FooInSuperSuper.html' '//pre' 'pub(crate) struct FooInSuperSuper'\n-        pub(in super::super) struct FooInSuperSuper;\n-        // @has 'foo/a/b/struct.FooInAB.html' '//pre' 'pub(in a::b) struct FooInAB'\n-        pub(in a::b) struct FooInAB;\n-    }\n-}"}, {"sha": "59427693c5a5d3c61fef6eaed72e9c87e9e99cbe", "filename": "src/test/rustdoc/visibility.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Ftest%2Frustdoc%2Fvisibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Ftest%2Frustdoc%2Fvisibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fvisibility.rs?ref=99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "patch": "@@ -0,0 +1,44 @@\n+// compile-flags: --document-private-items\n+\n+#![feature(crate_visibility_modifier)]\n+\n+#![crate_name = \"foo\"]\n+\n+// @has 'foo/struct.FooPublic.html' '//pre' 'pub struct FooPublic'\n+pub struct FooPublic;\n+// @has 'foo/struct.FooJustCrate.html' '//pre' 'pub(crate) struct FooJustCrate'\n+crate struct FooJustCrate;\n+// @has 'foo/struct.FooPubCrate.html' '//pre' 'pub(crate) struct FooPubCrate'\n+pub(crate) struct FooPubCrate;\n+// @has 'foo/struct.FooSelf.html' '//pre' 'pub(crate) struct FooSelf'\n+pub(self) struct FooSelf;\n+// @has 'foo/struct.FooInSelf.html' '//pre' 'pub(crate) struct FooInSelf'\n+pub(in self) struct FooInSelf;\n+// @has 'foo/struct.FooPriv.html' '//pre' 'pub(crate) struct FooPriv'\n+struct FooPriv;\n+\n+mod a {\n+    // @has 'foo/a/struct.FooASuper.html' '//pre' 'pub(crate) struct FooASuper'\n+    pub(super) struct FooASuper;\n+    // @has 'foo/a/struct.FooAInSuper.html' '//pre' 'pub(crate) struct FooAInSuper'\n+    pub(in super) struct FooAInSuper;\n+    // @has 'foo/a/struct.FooAInA.html' '//pre' 'struct FooAInA'\n+    // @!has 'foo/a/struct.FooAInA.html' '//pre' 'pub'\n+    pub(in a) struct FooAInA;\n+    // @has 'foo/a/struct.FooAPriv.html' '//pre' 'struct FooAPriv'\n+    // @!has 'foo/a/struct.FooAPriv.html' '//pre' 'pub'\n+    struct FooAPriv;\n+\n+    mod b {\n+        // @has 'foo/a/b/struct.FooBSuper.html' '//pre' 'pub(super) struct FooBSuper'\n+        pub(super) struct FooBSuper;\n+        // @has 'foo/a/b/struct.FooBInSuperSuper.html' '//pre' 'pub(crate) struct FooBInSuperSuper'\n+        pub(in super::super) struct FooBInSuperSuper;\n+        // @has 'foo/a/b/struct.FooBInAB.html' '//pre' 'struct FooBInAB'\n+        // @!has 'foo/a/b/struct.FooBInAB.html' '//pre' 'pub'\n+        pub(in a::b) struct FooBInAB;\n+        // @has 'foo/a/b/struct.FooBPriv.html' '//pre' 'struct FooBPriv'\n+        // @!has 'foo/a/b/struct.FooBPriv.html' '//pre' 'pub'\n+        struct FooBPriv;\n+    }\n+}"}, {"sha": "82555084e418f13c3112f2781b012a36ceafb8ec", "filename": "src/test/ui/const-generics/arg-in-pat-1.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Ftest%2Fui%2Fconst-generics%2Farg-in-pat-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Ftest%2Fui%2Fconst-generics%2Farg-in-pat-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Farg-in-pat-1.rs?ref=99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "patch": "@@ -0,0 +1,23 @@\n+// check-pass\n+enum ConstGenericEnum<const N: usize> {\n+    Foo([i32; N]),\n+    Bar,\n+}\n+\n+fn foo<const N: usize>(val: &ConstGenericEnum<N>) {\n+    if let ConstGenericEnum::<N>::Foo(field, ..) = val {}\n+}\n+\n+fn bar<const N: usize>(val: &ConstGenericEnum<N>) {\n+    match val {\n+        ConstGenericEnum::<N>::Foo(field, ..) => (),\n+        ConstGenericEnum::<N>::Bar => (),\n+    }\n+}\n+\n+fn main() {\n+    match ConstGenericEnum::Bar {\n+        ConstGenericEnum::<3>::Foo(field, ..) => (),\n+        ConstGenericEnum::<3>::Bar => (),\n+    }\n+}"}, {"sha": "dc9e722eda84c94783843c551be481897ba71138", "filename": "src/test/ui/const-generics/arg-in-pat-2.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Ftest%2Fui%2Fconst-generics%2Farg-in-pat-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Ftest%2Fui%2Fconst-generics%2Farg-in-pat-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Farg-in-pat-2.rs?ref=99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "patch": "@@ -0,0 +1,10 @@\n+// check-pass\n+enum Generic<const N: usize> {\n+    Variant,\n+}\n+\n+fn main() {\n+    match todo!() {\n+        Generic::<0usize>::Variant => todo!()\n+    }\n+}"}, {"sha": "24626a3b68ae56b5c99450123ca9d6f89611e958", "filename": "src/test/ui/const-generics/arg-in-pat-3.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Ftest%2Fui%2Fconst-generics%2Farg-in-pat-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Ftest%2Fui%2Fconst-generics%2Farg-in-pat-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Farg-in-pat-3.rs?ref=99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "patch": "@@ -0,0 +1,43 @@\n+// check-pass\n+struct Foo<const N: usize>;\n+\n+fn bindingp() {\n+    match Foo {\n+        mut x @ Foo::<3> => {\n+            let ref mut _x @ Foo::<3> = x;\n+        }\n+    }\n+}\n+\n+struct Bar<const N: usize> {\n+    field: Foo<N>,\n+}\n+\n+fn structp() {\n+    match todo!() {\n+        Bar::<3> {\n+            field: Foo::<3>,\n+        } => (),\n+    }\n+}\n+\n+struct Baz<const N: usize>(Foo<N>);\n+\n+fn tuplestructp() {\n+    match Baz(Foo) {\n+        Baz::<3>(Foo::<3>) => (),\n+    }\n+}\n+\n+impl<const N: usize> Baz<N> {\n+    const ASSOC: usize = 3;\n+}\n+\n+fn pathp() {\n+    match 3 {\n+        Baz::<3>::ASSOC => (),\n+        _ => (),\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "8e8d26a00043d20abf550822b00e45f1f4f601cf", "filename": "src/test/ui/const-generics/defaults/complex-unord-param.min.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fcomplex-unord-param.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fcomplex-unord-param.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fcomplex-unord-param.min.stderr?ref=99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "patch": "@@ -2,7 +2,7 @@ error: type parameters must be declared prior to const parameters\n   --> $DIR/complex-unord-param.rs:8:41\n    |\n LL | struct NestedArrays<'a, const N: usize, A: 'a, const M: usize, T:'a =u32> {\n-   |                    ---------------------^----------------------^--------- help: reorder the parameters: lifetimes, then types, then consts: `<'a, A: 'a, T: 'a, const N: usize, const M: usize>`\n+   |                    ---------------------^----------------------^--------- help: reorder the parameters: lifetimes, then types, then consts: `<'a, A: 'a, T: 'a = u32, const N: usize, const M: usize>`\n \n error: aborting due to previous error\n "}, {"sha": "c4a666a829d8cb0132ff626f9aaaf54edbe02d66", "filename": "src/test/ui/const-generics/defaults/intermixed-lifetime.full.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fintermixed-lifetime.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fintermixed-lifetime.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fintermixed-lifetime.full.stderr?ref=99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "patch": "@@ -2,13 +2,13 @@ error: lifetime parameters must be declared prior to const parameters\n   --> $DIR/intermixed-lifetime.rs:6:28\n    |\n LL | struct Foo<const N: usize, 'a, T = u32>(&'a (), T);\n-   |           -----------------^^---------- help: reorder the parameters: lifetimes, then consts and types: `<'a, const N: usize, T>`\n+   |           -----------------^^---------- help: reorder the parameters: lifetimes, then consts and types: `<'a, const N: usize, T = u32>`\n \n error: lifetime parameters must be declared prior to type parameters\n   --> $DIR/intermixed-lifetime.rs:10:37\n    |\n LL | struct Bar<const N: usize, T = u32, 'a>(&'a (), T);\n-   |           --------------------------^^- help: reorder the parameters: lifetimes, then consts and types: `<'a, const N: usize, T>`\n+   |           --------------------------^^- help: reorder the parameters: lifetimes, then consts and types: `<'a, const N: usize, T = u32>`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "69a490978d1df0c004dd5d4393d4f761457cb6dd", "filename": "src/test/ui/const-generics/defaults/intermixed-lifetime.min.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fintermixed-lifetime.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fintermixed-lifetime.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fintermixed-lifetime.min.stderr?ref=99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "patch": "@@ -2,25 +2,25 @@ error: lifetime parameters must be declared prior to const parameters\n   --> $DIR/intermixed-lifetime.rs:6:28\n    |\n LL | struct Foo<const N: usize, 'a, T = u32>(&'a (), T);\n-   |           -----------------^^---------- help: reorder the parameters: lifetimes, then types, then consts: `<'a, T, const N: usize>`\n+   |           -----------------^^---------- help: reorder the parameters: lifetimes, then types, then consts: `<'a, T = u32, const N: usize>`\n \n error: type parameters must be declared prior to const parameters\n   --> $DIR/intermixed-lifetime.rs:6:32\n    |\n LL | struct Foo<const N: usize, 'a, T = u32>(&'a (), T);\n-   |           ---------------------^------- help: reorder the parameters: lifetimes, then types, then consts: `<'a, T, const N: usize>`\n+   |           ---------------------^------- help: reorder the parameters: lifetimes, then types, then consts: `<'a, T = u32, const N: usize>`\n \n error: lifetime parameters must be declared prior to const parameters\n   --> $DIR/intermixed-lifetime.rs:10:37\n    |\n LL | struct Bar<const N: usize, T = u32, 'a>(&'a (), T);\n-   |           --------------------------^^- help: reorder the parameters: lifetimes, then types, then consts: `<'a, T, const N: usize>`\n+   |           --------------------------^^- help: reorder the parameters: lifetimes, then types, then consts: `<'a, T = u32, const N: usize>`\n \n error: type parameters must be declared prior to const parameters\n   --> $DIR/intermixed-lifetime.rs:10:28\n    |\n LL | struct Bar<const N: usize, T = u32, 'a>(&'a (), T);\n-   |           -----------------^----------- help: reorder the parameters: lifetimes, then types, then consts: `<'a, T, const N: usize>`\n+   |           -----------------^----------- help: reorder the parameters: lifetimes, then types, then consts: `<'a, T = u32, const N: usize>`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "a4006203e4a2730e9e6d0a95d2c34b15efa60240", "filename": "src/test/ui/const-generics/defaults/needs-feature.min.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fneeds-feature.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fneeds-feature.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fneeds-feature.min.stderr?ref=99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "patch": "@@ -2,7 +2,7 @@ error: type parameters must be declared prior to const parameters\n   --> $DIR/needs-feature.rs:9:26\n    |\n LL | struct A<const N: usize, T=u32>(T);\n-   |         -----------------^----- help: reorder the parameters: lifetimes, then types, then consts: `<T, const N: usize>`\n+   |         -----------------^----- help: reorder the parameters: lifetimes, then types, then consts: `<T = u32, const N: usize>`\n \n error: aborting due to previous error\n "}, {"sha": "a4006203e4a2730e9e6d0a95d2c34b15efa60240", "filename": "src/test/ui/const-generics/defaults/needs-feature.none.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fneeds-feature.none.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fneeds-feature.none.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fneeds-feature.none.stderr?ref=99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "patch": "@@ -2,7 +2,7 @@ error: type parameters must be declared prior to const parameters\n   --> $DIR/needs-feature.rs:9:26\n    |\n LL | struct A<const N: usize, T=u32>(T);\n-   |         -----------------^----- help: reorder the parameters: lifetimes, then types, then consts: `<T, const N: usize>`\n+   |         -----------------^----- help: reorder the parameters: lifetimes, then types, then consts: `<T = u32, const N: usize>`\n \n error: aborting due to previous error\n "}, {"sha": "0746c64ac8cf4d710c4f0856f38fa83856aaad5a", "filename": "src/test/ui/const-generics/defaults/simple-defaults.min.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fsimple-defaults.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fsimple-defaults.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fsimple-defaults.min.stderr?ref=99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "patch": "@@ -2,7 +2,7 @@ error: type parameters must be declared prior to const parameters\n   --> $DIR/simple-defaults.rs:8:40\n    |\n LL | struct FixedOutput<'a, const N: usize, T=u32> {\n-   |                   ---------------------^----- help: reorder the parameters: lifetimes, then types, then consts: `<'a, T, const N: usize>`\n+   |                   ---------------------^----- help: reorder the parameters: lifetimes, then types, then consts: `<'a, T = u32, const N: usize>`\n \n error: aborting due to previous error\n "}, {"sha": "fe3e4fbc7e0b603527289236a6cabf3e8066ac88", "filename": "src/test/ui/issues/issue-80512-param-reordering-with-defaults.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Ftest%2Fui%2Fissues%2Fissue-80512-param-reordering-with-defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Ftest%2Fui%2Fissues%2Fissue-80512-param-reordering-with-defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-80512-param-reordering-with-defaults.rs?ref=99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "patch": "@@ -0,0 +1,4 @@\n+#![crate_type = \"lib\"]\n+\n+struct S<T = (), 'a>(&'a T);\n+//~^ ERROR lifetime parameters must be declared prior to type parameters"}, {"sha": "a1e9a903f810276e0ce4babc7333b2d58318e027", "filename": "src/test/ui/issues/issue-80512-param-reordering-with-defaults.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Ftest%2Fui%2Fissues%2Fissue-80512-param-reordering-with-defaults.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Ftest%2Fui%2Fissues%2Fissue-80512-param-reordering-with-defaults.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-80512-param-reordering-with-defaults.stderr?ref=99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "patch": "@@ -0,0 +1,8 @@\n+error: lifetime parameters must be declared prior to type parameters\n+  --> $DIR/issue-80512-param-reordering-with-defaults.rs:3:18\n+   |\n+LL | struct S<T = (), 'a>(&'a T);\n+   |         ---------^^- help: reorder the parameters: lifetimes, then types, then consts: `<'a, T = ()>`\n+\n+error: aborting due to previous error\n+"}, {"sha": "8386959cfb3a83327850c86e6386ffb8ed97c185", "filename": "src/test/ui/wf/wf-in-foreign-fn-decls-issue-80468.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Ftest%2Fui%2Fwf%2Fwf-in-foreign-fn-decls-issue-80468.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Ftest%2Fui%2Fwf%2Fwf-in-foreign-fn-decls-issue-80468.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-in-foreign-fn-decls-issue-80468.rs?ref=99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "patch": "@@ -0,0 +1,17 @@\n+// Regression test for #80468.\n+\n+#![crate_type = \"lib\"]\n+\n+pub trait Trait {}\n+\n+#[repr(transparent)]\n+pub struct Wrapper<T: Trait>(T);\n+\n+#[repr(transparent)]\n+pub struct Ref<'a>(&'a u8);\n+\n+impl Trait for Ref {} //~ ERROR:  implicit elided lifetime not allowed here\n+\n+extern \"C\" {\n+    pub fn repro(_: Wrapper<Ref>); //~ ERROR: mismatched types\n+}"}, {"sha": "bb839d0a5eca685438a24a35def594c617ddc182", "filename": "src/test/ui/wf/wf-in-foreign-fn-decls-issue-80468.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Ftest%2Fui%2Fwf%2Fwf-in-foreign-fn-decls-issue-80468.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/99ad5a1a2824fea1ecf60068fd3636beae7ea2da/src%2Ftest%2Fui%2Fwf%2Fwf-in-foreign-fn-decls-issue-80468.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-in-foreign-fn-decls-issue-80468.stderr?ref=99ad5a1a2824fea1ecf60068fd3636beae7ea2da", "patch": "@@ -0,0 +1,24 @@\n+error[E0726]: implicit elided lifetime not allowed here\n+  --> $DIR/wf-in-foreign-fn-decls-issue-80468.rs:13:16\n+   |\n+LL | impl Trait for Ref {}\n+   |                ^^^- help: indicate the anonymous lifetime: `<'_>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/wf-in-foreign-fn-decls-issue-80468.rs:16:21\n+   |\n+LL |     pub fn repro(_: Wrapper<Ref>);\n+   |                     ^^^^^^^^^^^^ lifetime mismatch\n+   |\n+   = note: expected trait `Trait`\n+              found trait `Trait`\n+note: the anonymous lifetime #1 defined on the method body at 16:5...\n+  --> $DIR/wf-in-foreign-fn-decls-issue-80468.rs:16:5\n+   |\n+LL |     pub fn repro(_: Wrapper<Ref>);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: ...does not necessarily outlive the static lifetime\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}]}