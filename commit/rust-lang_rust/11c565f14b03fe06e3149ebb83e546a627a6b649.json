{"sha": "11c565f14b03fe06e3149ebb83e546a627a6b649", "node_id": "C_kwDOAAsO6NoAKDExYzU2NWYxNGIwM2ZlMDZlMzE0OWViYjgzZTU0NmE2MjdhNmI2NDk", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-03-03T00:00:50Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-03-03T10:45:42Z"}, "message": "Improve if/else formatting in macro_parser.rs.\n\nTo avoid the strange style where comments force `else` onto its own\nline.\n\nThe commit also removes several else-after-return constructs, which can\nbe hard to read.", "tree": {"sha": "c3468c89cac15b0290466cdda79c7ee04604762d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3468c89cac15b0290466cdda79c7ee04604762d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11c565f14b03fe06e3149ebb83e546a627a6b649", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11c565f14b03fe06e3149ebb83e546a627a6b649", "html_url": "https://github.com/rust-lang/rust/commit/11c565f14b03fe06e3149ebb83e546a627a6b649", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11c565f14b03fe06e3149ebb83e546a627a6b649/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a", "html_url": "https://github.com/rust-lang/rust/commit/2f8d1a835b4e7feaf625f74d0d5cb9b84dbc845a"}], "stats": {"total": 60, "additions": 28, "deletions": 32}, "files": [{"sha": "596fee21cdd7176fdb4f83ebf619016d60aaefb3", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 28, "deletions": 32, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/11c565f14b03fe06e3149ebb83e546a627a6b649/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11c565f14b03fe06e3149ebb83e546a627a6b649/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=11c565f14b03fe06e3149ebb83e546a627a6b649", "patch": "@@ -505,25 +505,23 @@ fn inner_parse_loop<'root, 'tt>(\n                         item.idx += 1;\n                         next_items.push(item);\n                     }\n-                }\n-                // We don't need a separator. Move the \"dot\" back to the beginning of the matcher\n-                // and try to match again UNLESS we are only allowed to have _one_ repetition.\n-                else if item.seq_op != Some(mbe::KleeneOp::ZeroOrOne) {\n+                } else if item.seq_op != Some(mbe::KleeneOp::ZeroOrOne) {\n+                    // We don't need a separator. Move the \"dot\" back to the beginning of the\n+                    // matcher and try to match again UNLESS we are only allowed to have _one_\n+                    // repetition.\n                     item.match_cur = item.match_lo;\n                     item.idx = 0;\n                     cur_items.push(item);\n                 }\n-            }\n-            // If we are not in a repetition, then being at the end of a matcher means that we have\n-            // reached the potential end of the input.\n-            else {\n+            } else {\n+                // If we are not in a repetition, then being at the end of a matcher means that we\n+                // have reached the potential end of the input.\n                 eof_items.push(item);\n             }\n-        }\n-        // We are in the middle of a matcher.\n-        else {\n-            // Look at what token in the matcher we are trying to match the current token (`token`)\n-            // against. Depending on that, we may generate new items.\n+        } else {\n+            // We are in the middle of a matcher. Look at what token in the matcher we are trying\n+            // to match the current token (`token`) against. Depending on that, we may generate new\n+            // items.\n             match item.top_elts.get_tt(idx) {\n                 // Need to descend into a sequence\n                 TokenTree::Sequence(sp, seq) => {\n@@ -666,17 +664,14 @@ pub(super) fn parse_tt(\n         // If we reached the EOF, check that there is EXACTLY ONE possible matcher. Otherwise,\n         // either the parse is ambiguous (which should never happen) or there is a syntax error.\n         if parser.token == token::Eof {\n-            if eof_items.len() == 1 {\n+            return if eof_items.len() == 1 {\n                 let matches =\n                     eof_items[0].matches.iter_mut().map(|dv| Lrc::make_mut(dv).pop().unwrap());\n-                return nameize(parser.sess, ms, matches);\n+                nameize(parser.sess, ms, matches)\n             } else if eof_items.len() > 1 {\n-                return Error(\n-                    parser.token.span,\n-                    \"ambiguity: multiple successful parses\".to_string(),\n-                );\n+                Error(parser.token.span, \"ambiguity: multiple successful parses\".to_string())\n             } else {\n-                return Failure(\n+                Failure(\n                     Token::new(\n                         token::Eof,\n                         if parser.token.span.is_dummy() {\n@@ -686,8 +681,8 @@ pub(super) fn parse_tt(\n                         },\n                     ),\n                     \"missing tokens in macro arguments\",\n-                );\n-            }\n+                )\n+            };\n         }\n         // Performance hack: eof_items may share matchers via Rc with other things that we want\n         // to modify. Dropping eof_items now may drop these refcounts to 1, preventing an\n@@ -699,9 +694,10 @@ pub(super) fn parse_tt(\n         if bb_items.is_empty() && next_items.is_empty() {\n             return Failure(parser.token.clone(), \"no rules expected this token in macro call\");\n         }\n-        // Another possibility is that we need to call out to parse some rust nonterminal\n-        // (black-box) parser. However, if there is not EXACTLY ONE of these, something is wrong.\n-        else if (!bb_items.is_empty() && !next_items.is_empty()) || bb_items.len() > 1 {\n+\n+        if (!bb_items.is_empty() && !next_items.is_empty()) || bb_items.len() > 1 {\n+            // We need to call out to parse some rust nonterminal (black-box) parser. But something\n+            // is wrong, because there is not EXACTLY ONE of these.\n             let nts = bb_items\n                 .iter()\n                 .map(|item| match item.top_elts.get_tt(item.idx) {\n@@ -723,15 +719,15 @@ pub(super) fn parse_tt(\n                 ),\n             );\n         }\n-        // Dump all possible `next_items` into `cur_items` for the next iteration.\n-        else if !next_items.is_empty() {\n-            // Now process the next token\n+\n+        if !next_items.is_empty() {\n+            // Dump all possible `next_items` into `cur_items` for the next iteration. Then process\n+            // the next token.\n             cur_items.extend(next_items.drain(..));\n             parser.to_mut().bump();\n-        }\n-        // Finally, we have the case where we need to call the black-box parser to get some\n-        // nonterminal.\n-        else {\n+        } else {\n+            // Finally, we have the case where we need to call the black-box parser to get some\n+            // nonterminal.\n             assert_eq!(bb_items.len(), 1);\n \n             let mut item = bb_items.pop().unwrap();"}]}