{"sha": "595b06a1b8fcd215c828d65ee1dd1a30c2697de9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5NWIwNmExYjhmY2QyMTVjODI4ZDY1ZWUxZGQxYTMwYzI2OTdkZTk=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-01-16T16:33:07Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-01-16T16:33:07Z"}, "message": "Create modules via SourceBinder", "tree": {"sha": "f8c33cb55704c2023a5f999ebb46fda0ba4c48ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8c33cb55704c2023a5f999ebb46fda0ba4c48ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/595b06a1b8fcd215c828d65ee1dd1a30c2697de9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/595b06a1b8fcd215c828d65ee1dd1a30c2697de9", "html_url": "https://github.com/rust-lang/rust/commit/595b06a1b8fcd215c828d65ee1dd1a30c2697de9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/595b06a1b8fcd215c828d65ee1dd1a30c2697de9/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a6c26e34806a05260170029ace4b64adf484a23", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a6c26e34806a05260170029ace4b64adf484a23", "html_url": "https://github.com/rust-lang/rust/commit/9a6c26e34806a05260170029ace4b64adf484a23"}], "stats": {"total": 177, "additions": 65, "deletions": 112}, "files": [{"sha": "eb76aecb1bac6d30c4273103720c24db84de564b", "filename": "crates/ra_hir/src/from_source.rs", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9a6c26e34806a05260170029ace4b64adf484a23/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6c26e34806a05260170029ace4b64adf484a23/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs?ref=9a6c26e34806a05260170029ace4b64adf484a23", "patch": "@@ -1,38 +0,0 @@\n-//! Finds a corresponding hir data structure for a syntax node in a specific\n-//! file.\n-\n-use hir_def::{nameres::ModuleSource, ModuleId};\n-use ra_db::FileId;\n-use ra_prof::profile;\n-\n-use crate::{\n-    db::{DefDatabase, HirDatabase},\n-    InFile, Module,\n-};\n-\n-impl Module {\n-    pub fn from_definition(db: &impl HirDatabase, src: InFile<ModuleSource>) -> Option<Self> {\n-        let _p = profile(\"Module::from_definition\");\n-        let mut sb = crate::SourceBinder::new(db);\n-        match src.value {\n-            ModuleSource::Module(ref module) => {\n-                assert!(!module.has_semi());\n-                return sb.to_def(InFile { file_id: src.file_id, value: module.clone() });\n-            }\n-            ModuleSource::SourceFile(_) => (),\n-        };\n-\n-        let original_file = src.file_id.original_file(db);\n-        Module::from_file(db, original_file)\n-    }\n-\n-    fn from_file(db: &impl DefDatabase, file: FileId) -> Option<Self> {\n-        let _p = profile(\"Module::from_file\");\n-        let (krate, local_id) = db.relevant_crates(file).iter().find_map(|&crate_id| {\n-            let crate_def_map = db.crate_def_map(crate_id);\n-            let local_id = crate_def_map.modules_for_file(file).next()?;\n-            Some((crate_id, local_id))\n-        })?;\n-        Some(Module { id: ModuleId { krate, local_id } })\n-    }\n-}"}, {"sha": "e1c7b7a2020f7c71008bbbbf43182a2251e43fae", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/595b06a1b8fcd215c828d65ee1dd1a30c2697de9/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/595b06a1b8fcd215c828d65ee1dd1a30c2697de9/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=595b06a1b8fcd215c828d65ee1dd1a30c2697de9", "patch": "@@ -36,7 +36,6 @@ mod from_id;\n mod code_model;\n \n mod has_source;\n-mod from_source;\n \n pub use crate::{\n     code_model::{"}, {"sha": "fa225a4ed9735789a762bb9b4cff9bc6a4446aa8", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/595b06a1b8fcd215c828d65ee1dd1a30c2697de9/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/595b06a1b8fcd215c828d65ee1dd1a30c2697de9/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=595b06a1b8fcd215c828d65ee1dd1a30c2697de9", "patch": "@@ -19,7 +19,8 @@ use ra_syntax::{\n };\n use rustc_hash::FxHashMap;\n \n-use crate::{db::HirDatabase, Local, Module, ModuleSource, SourceAnalyzer, TypeParam};\n+use crate::{db::HirDatabase, Local, Module, SourceAnalyzer, TypeParam};\n+use ra_db::FileId;\n \n pub struct SourceBinder<'a, DB> {\n     pub db: &'a DB,\n@@ -60,6 +61,16 @@ impl<DB: HirDatabase> SourceBinder<'_, DB> {\n         T::to_def(self, src)\n     }\n \n+    pub fn to_module_def(&mut self, file: FileId) -> Option<Module> {\n+        let _p = profile(\"SourceBinder::to_module_def\");\n+        let (krate, local_id) = self.db.relevant_crates(file).iter().find_map(|&crate_id| {\n+            let crate_def_map = self.db.crate_def_map(crate_id);\n+            let local_id = crate_def_map.modules_for_file(file).next()?;\n+            Some((crate_id, local_id))\n+        })?;\n+        Some(Module { id: ModuleId { krate, local_id } })\n+    }\n+\n     fn to_id<T: ToId>(&mut self, src: InFile<T>) -> Option<T::ID> {\n         T::to_id(self, src)\n     }\n@@ -107,8 +118,7 @@ impl<DB: HirDatabase> SourceBinder<'_, DB> {\n             return Some(res);\n         }\n \n-        let module_source = ModuleSource::from_child_node(self.db, src);\n-        let c = crate::Module::from_definition(self.db, src.with_value(module_source))?;\n+        let c = self.to_module_def(src.file_id.original_file(self.db))?;\n         Some(c.id.into())\n     }\n \n@@ -248,14 +258,12 @@ impl ToId for ast::MacroCall {\n     ) -> Option<Self::ID> {\n         let kind = MacroDefKind::Declarative;\n \n-        let module_src = ModuleSource::from_child_node(sb.db, src.as_ref().map(|it| it.syntax()));\n-        let module = crate::Module::from_definition(sb.db, InFile::new(src.file_id, module_src))?;\n-        let krate = Some(module.krate().id);\n+        let krate = sb.to_module_def(src.file_id.original_file(sb.db))?.id.krate;\n \n         let ast_id =\n             Some(AstId::new(src.file_id, sb.db.ast_id_map(src.file_id).ast_id(&src.value)));\n \n-        Some(MacroDefId { krate, ast_id, kind })\n+        Some(MacroDefId { krate: Some(krate), ast_id, kind })\n     }\n }\n \n@@ -319,21 +327,22 @@ impl ToDef for ast::Module {\n     ) -> Option<Module> {\n         {\n             let _p = profile(\"ast::Module::to_def\");\n-            let parent_declaration =\n-                src.value.syntax().ancestors().skip(1).find_map(ast::Module::cast);\n+            let parent_declaration = src\n+                .as_ref()\n+                .map(|it| it.syntax())\n+                .cloned()\n+                .ancestors_with_macros(sb.db)\n+                .skip(1)\n+                .find_map(|it| {\n+                    let m = ast::Module::cast(it.value.clone())?;\n+                    Some(it.with_value(m))\n+                });\n \n             let parent_module = match parent_declaration {\n-                Some(parent_declaration) => {\n-                    let src_parent = InFile { file_id: src.file_id, value: parent_declaration };\n-                    sb.to_def(src_parent)\n-                }\n+                Some(parent_declaration) => sb.to_def(parent_declaration),\n                 None => {\n-                    let source_file = sb.db.parse(src.file_id.original_file(sb.db)).tree();\n-                    let src_parent = InFile {\n-                        file_id: src.file_id,\n-                        value: ModuleSource::SourceFile(source_file),\n-                    };\n-                    Module::from_definition(sb.db, src_parent)\n+                    let file_id = src.file_id.original_file(sb.db);\n+                    sb.to_module_def(file_id)\n                 }\n             }?;\n "}, {"sha": "deaacda6cf951d29fa265e5c1be68a7855b1b29c", "filename": "crates/ra_ide/src/completion/completion_context.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/595b06a1b8fcd215c828d65ee1dd1a30c2697de9/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/595b06a1b8fcd215c828d65ee1dd1a30c2697de9/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=595b06a1b8fcd215c828d65ee1dd1a30c2697de9", "patch": "@@ -52,15 +52,11 @@ impl<'a> CompletionContext<'a> {\n         original_parse: &'a Parse<ast::SourceFile>,\n         position: FilePosition,\n     ) -> Option<CompletionContext<'a>> {\n-        let src = hir::ModuleSource::from_position(db, position);\n-        let module = hir::Module::from_definition(\n-            db,\n-            hir::InFile { file_id: position.file_id.into(), value: src },\n-        );\n+        let mut sb = hir::SourceBinder::new(db);\n+        let module = sb.to_module_def(position.file_id);\n         let token =\n             original_parse.tree().syntax().token_at_offset(position.offset).left_biased()?;\n-        let analyzer = hir::SourceAnalyzer::new(\n-            db,\n+        let analyzer = sb.analyze(\n             hir::InFile::new(position.file_id.into(), &token.parent()),\n             Some(position.offset),\n         );"}, {"sha": "f403b3bcf2e9a3e912a51b043cc4b8906dff5626", "filename": "crates/ra_ide/src/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/595b06a1b8fcd215c828d65ee1dd1a30c2697de9/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/595b06a1b8fcd215c828d65ee1dd1a30c2697de9/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs?ref=595b06a1b8fcd215c828d65ee1dd1a30c2697de9", "patch": "@@ -23,6 +23,7 @@ pub enum Severity {\n \n pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic> {\n     let _p = profile(\"diagnostics\");\n+    let mut sb = hir::SourceBinder::new(db);\n     let parse = db.parse(file_id);\n     let mut res = Vec::new();\n \n@@ -108,10 +109,7 @@ pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic>\n             fix: Some(fix),\n         })\n     });\n-    let source_file = db.parse(file_id).tree();\n-    let src =\n-        hir::InFile { file_id: file_id.into(), value: hir::ModuleSource::SourceFile(source_file) };\n-    if let Some(m) = hir::Module::from_definition(db, src) {\n+    if let Some(m) = sb.to_module_def(file_id) {\n         m.diagnostics(db, &mut sink);\n     };\n     drop(sink);"}, {"sha": "9834025d30837028aa5c3a893d68446791c1c1d8", "filename": "crates/ra_ide/src/impls.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/595b06a1b8fcd215c828d65ee1dd1a30c2697de9/crates%2Fra_ide%2Fsrc%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/595b06a1b8fcd215c828d65ee1dd1a30c2697de9/crates%2Fra_ide%2Fsrc%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fimpls.rs?ref=595b06a1b8fcd215c828d65ee1dd1a30c2697de9", "patch": "@@ -1,6 +1,6 @@\n //! FIXME: write short doc here\n \n-use hir::{ImplBlock, SourceBinder};\n+use hir::{Crate, ImplBlock, SourceBinder};\n use ra_db::SourceDatabase;\n use ra_syntax::{algo::find_node_at_offset, ast, AstNode};\n \n@@ -14,21 +14,17 @@ pub(crate) fn goto_implementation(\n     let syntax = parse.tree().syntax().clone();\n     let mut sb = SourceBinder::new(db);\n \n-    let src = hir::ModuleSource::from_position(db, position);\n-    let module = hir::Module::from_definition(\n-        db,\n-        hir::InFile { file_id: position.file_id.into(), value: src },\n-    )?;\n+    let krate = sb.to_module_def(position.file_id)?.krate();\n \n     if let Some(nominal_def) = find_node_at_offset::<ast::NominalDef>(&syntax, position.offset) {\n         return Some(RangeInfo::new(\n             nominal_def.syntax().text_range(),\n-            impls_for_def(&mut sb, position, &nominal_def, module)?,\n+            impls_for_def(&mut sb, position, &nominal_def, krate)?,\n         ));\n     } else if let Some(trait_def) = find_node_at_offset::<ast::TraitDef>(&syntax, position.offset) {\n         return Some(RangeInfo::new(\n             trait_def.syntax().text_range(),\n-            impls_for_trait(&mut sb, position, &trait_def, module)?,\n+            impls_for_trait(&mut sb, position, &trait_def, krate)?,\n         ));\n     }\n \n@@ -39,7 +35,7 @@ fn impls_for_def(\n     sb: &mut SourceBinder<RootDatabase>,\n     position: FilePosition,\n     node: &ast::NominalDef,\n-    module: hir::Module,\n+    krate: Crate,\n ) -> Option<Vec<NavigationTarget>> {\n     let ty = match node {\n         ast::NominalDef::StructDef(def) => {\n@@ -56,7 +52,6 @@ fn impls_for_def(\n         }\n     };\n \n-    let krate = module.krate();\n     let impls = ImplBlock::all_in_crate(sb.db, krate);\n \n     Some(\n@@ -72,12 +67,11 @@ fn impls_for_trait(\n     sb: &mut SourceBinder<RootDatabase>,\n     position: FilePosition,\n     node: &ast::TraitDef,\n-    module: hir::Module,\n+    krate: Crate,\n ) -> Option<Vec<NavigationTarget>> {\n     let src = hir::InFile { file_id: position.file_id.into(), value: node.clone() };\n     let tr = sb.to_def(src)?;\n \n-    let krate = module.krate();\n     let impls = ImplBlock::for_trait(sb.db, krate, tr);\n \n     Some(impls.into_iter().map(|imp| imp.to_nav(sb.db)).collect())"}, {"sha": "2dbccfc3b5072682a66bf512f3ee25ae1b1e66a5", "filename": "crates/ra_ide/src/parent_module.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/595b06a1b8fcd215c828d65ee1dd1a30c2697de9/crates%2Fra_ide%2Fsrc%2Fparent_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/595b06a1b8fcd215c828d65ee1dd1a30c2697de9/crates%2Fra_ide%2Fsrc%2Fparent_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fparent_module.rs?ref=595b06a1b8fcd215c828d65ee1dd1a30c2697de9", "patch": "@@ -1,17 +1,23 @@\n //! FIXME: write short doc here\n \n use ra_db::{CrateId, FileId, FilePosition, SourceDatabase};\n+use ra_syntax::{\n+    algo::find_node_at_offset,\n+    ast::{self, AstNode},\n+};\n \n use crate::{db::RootDatabase, NavigationTarget};\n \n /// This returns `Vec` because a module may be included from several places. We\n /// don't handle this case yet though, so the Vec has length at most one.\n pub(crate) fn parent_module(db: &RootDatabase, position: FilePosition) -> Vec<NavigationTarget> {\n-    let src = hir::ModuleSource::from_position(db, position);\n-    let module = match hir::Module::from_definition(\n-        db,\n-        hir::InFile { file_id: position.file_id.into(), value: src },\n-    ) {\n+    let mut sb = hir::SourceBinder::new(db);\n+    let parse = db.parse(position.file_id);\n+    let module = match find_node_at_offset::<ast::Module>(parse.tree().syntax(), position.offset) {\n+        Some(module) => sb.to_def(hir::InFile::new(position.file_id.into(), module)),\n+        None => sb.to_module_def(position.file_id),\n+    };\n+    let module = match module {\n         None => return Vec::new(),\n         Some(it) => it,\n     };\n@@ -21,14 +27,11 @@ pub(crate) fn parent_module(db: &RootDatabase, position: FilePosition) -> Vec<Na\n \n /// Returns `Vec` for the same reason as `parent_module`\n pub(crate) fn crate_for(db: &RootDatabase, file_id: FileId) -> Vec<CrateId> {\n-    let source_file = db.parse(file_id).tree();\n-    let src = hir::ModuleSource::SourceFile(source_file);\n-    let module =\n-        match hir::Module::from_definition(db, hir::InFile { file_id: file_id.into(), value: src })\n-        {\n-            Some(it) => it,\n-            None => return Vec::new(),\n-        };\n+    let mut sb = hir::SourceBinder::new(db);\n+    let module = match sb.to_module_def(file_id) {\n+        Some(it) => it,\n+        None => return Vec::new(),\n+    };\n     let krate = module.krate();\n     vec![krate.into()]\n }"}, {"sha": "46cba30a38d75dff5c80939b30250207ff49ee84", "filename": "crates/ra_ide/src/references/classify.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/595b06a1b8fcd215c828d65ee1dd1a30c2697de9/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/595b06a1b8fcd215c828d65ee1dd1a30c2697de9/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs?ref=595b06a1b8fcd215c828d65ee1dd1a30c2697de9", "patch": "@@ -1,6 +1,6 @@\n //! Functions that are used to classify an element from its definition or reference.\n \n-use hir::{InFile, Module, ModuleSource, PathResolution, SourceBinder};\n+use hir::{InFile, PathResolution, SourceBinder};\n use ra_prof::profile;\n use ra_syntax::{ast, match_ast, AstNode};\n use test_utils::tested_by;\n@@ -35,16 +35,7 @@ pub(crate) fn classify_name(\n                 Some(from_struct_field(sb.db, field))\n             },\n             ast::Module(it) => {\n-                let def = {\n-                    if !it.has_semi() {\n-                        let ast = hir::ModuleSource::Module(it);\n-                        let src = name.with_value(ast);\n-                        hir::Module::from_definition(sb.db, src)\n-                    } else {\n-                        let src = name.with_value(it);\n-                        sb.to_def(src)\n-                    }\n-                }?;\n+                let def = sb.to_def(name.with_value(it))?;\n                 Some(from_module_def(sb.db, def.into(), None))\n             },\n             ast::StructDef(it) => {\n@@ -103,8 +94,7 @@ pub(crate) fn classify_name(\n                 let src = name.with_value(it);\n                 let def = sb.to_def(src.clone())?;\n \n-                let module_src = ModuleSource::from_child_node(sb.db, src.as_ref().map(|it| it.syntax()));\n-                let module = Module::from_definition(sb.db, src.with_value(module_src))?;\n+                let module = sb.to_module_def(src.file_id.original_file(sb.db))?;\n \n                 Some(NameDefinition {\n                     visibility: None,\n@@ -157,10 +147,9 @@ pub(crate) fn classify_name_ref(\n         }\n     }\n \n-    let ast = ModuleSource::from_child_node(sb.db, name_ref.with_value(&parent));\n     // FIXME: find correct container and visibility for each case\n-    let container = Module::from_definition(sb.db, name_ref.with_value(ast))?;\n     let visibility = None;\n+    let container = sb.to_module_def(name_ref.file_id.original_file(sb.db))?;\n \n     if let Some(macro_call) = parent.ancestors().find_map(ast::MacroCall::cast) {\n         tested_by!(goto_def_for_macros);\n@@ -178,12 +167,13 @@ pub(crate) fn classify_name_ref(\n         PathResolution::Def(def) => Some(from_module_def(sb.db, def, Some(container))),\n         PathResolution::AssocItem(item) => Some(from_assoc_item(sb.db, item)),\n         PathResolution::Local(local) => {\n-            let container = local.module(sb.db);\n             let kind = NameKind::Local(local);\n+            let container = local.module(sb.db);\n             Some(NameDefinition { kind, container, visibility: None })\n         }\n         PathResolution::TypeParam(par) => {\n             let kind = NameKind::TypeParam(par);\n+            let container = par.module(sb.db);\n             Some(NameDefinition { kind, container, visibility })\n         }\n         PathResolution::Macro(def) => {"}, {"sha": "1e4226ab9acaef200b21552fbd108161682b4baf", "filename": "crates/ra_ide/src/references/name_definition.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/595b06a1b8fcd215c828d65ee1dd1a30c2697de9/crates%2Fra_ide%2Fsrc%2Freferences%2Fname_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/595b06a1b8fcd215c828d65ee1dd1a30c2697de9/crates%2Fra_ide%2Fsrc%2Freferences%2Fname_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Fname_definition.rs?ref=595b06a1b8fcd215c828d65ee1dd1a30c2697de9", "patch": "@@ -25,6 +25,8 @@ pub enum NameKind {\n #[derive(PartialEq, Eq)]\n pub(crate) struct NameDefinition {\n     pub visibility: Option<ast::Visibility>,\n+    /// FIXME: this doesn't really make sense. For example, builtin types don't\n+    /// really have a module.\n     pub container: Module,\n     pub kind: NameKind,\n }"}, {"sha": "7533692f637159ca73f2afac69a01784d8575d6a", "filename": "crates/ra_ide/src/runnables.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/595b06a1b8fcd215c828d65ee1dd1a30c2697de9/crates%2Fra_ide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/595b06a1b8fcd215c828d65ee1dd1a30c2697de9/crates%2Fra_ide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Frunnables.rs?ref=595b06a1b8fcd215c828d65ee1dd1a30c2697de9", "patch": "@@ -66,8 +66,8 @@ fn runnable_mod(db: &RootDatabase, file_id: FileId, module: ast::Module) -> Opti\n         return None;\n     }\n     let range = module.syntax().text_range();\n-    let src = hir::ModuleSource::from_child_node(db, InFile::new(file_id.into(), &module.syntax()));\n-    let module = hir::Module::from_definition(db, InFile::new(file_id.into(), src))?;\n+    let mut sb = hir::SourceBinder::new(db);\n+    let module = sb.to_def(InFile::new(file_id.into(), module))?;\n \n     let path = module.path_to_root(db).into_iter().rev().filter_map(|it| it.name(db)).join(\"::\");\n     Some(Runnable { range, kind: RunnableKind::TestMod { path } })"}]}