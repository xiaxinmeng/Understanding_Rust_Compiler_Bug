{"sha": "f19d0833625c382c5d0a8868924cd4620335e659", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxOWQwODMzNjI1YzM4MmM1ZDBhODg2ODkyNGNkNDYyMDMzNWU2NTk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-30T06:31:07Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-03T23:15:42Z"}, "message": "Fill out the remaining functionality in io::file\n\nThis adds bindings to the remaining functions provided by libuv, all of which\nare useful operations on files which need to get exposed somehow.\n\nSome highlights:\n\n* Dropped `FileReader` and `FileWriter` and `FileStream` for one `File` type\n* Moved all file-related methods to be static methods under `File`\n* All directory related methods are still top-level functions\n* Created `io::FilePermission` types (backed by u32) that are what you'd expect\n* Created `io::FileType` and refactored `FileStat` to use FileType and\n  FilePermission\n* Removed the expanding matrix of `FileMode` operations. The mode of reading a\n  file will not have the O_CREAT flag, but a write mode will always have the\n  O_CREAT flag.\n\nCloses #10130\nCloses #10131\nCloses #10121", "tree": {"sha": "9d4d67c3f845aa4f2596c6db94f9c883ab1dd696", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d4d67c3f845aa4f2596c6db94f9c883ab1dd696"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f19d0833625c382c5d0a8868924cd4620335e659", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f19d0833625c382c5d0a8868924cd4620335e659", "html_url": "https://github.com/rust-lang/rust/commit/f19d0833625c382c5d0a8868924cd4620335e659", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f19d0833625c382c5d0a8868924cd4620335e659/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c1851019f1ef9511fa8731b8f1acb0796d1e97f", "html_url": "https://github.com/rust-lang/rust/commit/9c1851019f1ef9511fa8731b8f1acb0796d1e97f"}], "stats": {"total": 2367, "additions": 1359, "deletions": 1008}, "files": [{"sha": "8bfef9da805f25ac270c2efbe706a9faf04aaebd", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f19d0833625c382c5d0a8868924cd4620335e659/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19d0833625c382c5d0a8868924cd4620335e659/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=f19d0833625c382c5d0a8868924cd4620335e659", "patch": "@@ -9,15 +9,15 @@\n // except according to those terms.\n \n use std::rt::io::buffered::BufferedReader;\n-use std::rt::io::file;\n+use std::rt::io::File;\n \n pub struct ExpectedError { line: uint, kind: ~str, msg: ~str }\n \n // Load any test directives embedded in the file\n pub fn load_errors(testfile: &Path) -> ~[ExpectedError] {\n \n     let mut error_patterns = ~[];\n-    let mut rdr = BufferedReader::new(file::open(testfile).unwrap());\n+    let mut rdr = BufferedReader::new(File::open(testfile).unwrap());\n     let mut line_num = 1u;\n     loop {\n         let ln = match rdr.read_line() {"}, {"sha": "5571e159ee31dcaa27071508298ede3cea5a3d34", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f19d0833625c382c5d0a8868924cd4620335e659/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19d0833625c382c5d0a8868924cd4620335e659/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=f19d0833625c382c5d0a8868924cd4620335e659", "patch": "@@ -104,9 +104,9 @@ pub fn is_test_ignored(config: &config, testfile: &Path) -> bool {\n \n fn iter_header(testfile: &Path, it: &fn(&str) -> bool) -> bool {\n     use std::rt::io::buffered::BufferedReader;\n-    use std::rt::io::file;\n+    use std::rt::io::File;\n \n-    let mut rdr = BufferedReader::new(file::open(testfile).unwrap());\n+    let mut rdr = BufferedReader::new(File::open(testfile).unwrap());\n     loop {\n         let ln = match rdr.read_line() {\n             Some(ln) => ln, None => break"}, {"sha": "d55bdc2370327905b286884c43d519d5ba37ff25", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f19d0833625c382c5d0a8868924cd4620335e659/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19d0833625c382c5d0a8868924cd4620335e659/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=f19d0833625c382c5d0a8868924cd4620335e659", "patch": "@@ -23,6 +23,7 @@ use util::logv;\n use std::cell::Cell;\n use std::rt::io;\n use std::rt::io::file;\n+use std::rt::io::File;\n use std::os;\n use std::str;\n use std::task::{spawn_sched, SingleThreaded};\n@@ -171,7 +172,7 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n     let rounds =\n         match props.pp_exact { Some(_) => 1, None => 2 };\n \n-    let src = file::open(testfile).read_to_end();\n+    let src = File::open(testfile).read_to_end();\n     let src = str::from_utf8_owned(src);\n     let mut srcs = ~[src];\n \n@@ -193,7 +194,7 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n     let mut expected = match props.pp_exact {\n         Some(ref file) => {\n             let filepath = testfile.dir_path().join(file);\n-            let s = file::open(&filepath).read_to_end();\n+            let s = File::open(&filepath).read_to_end();\n             str::from_utf8_owned(s)\n           }\n           None => { srcs[srcs.len() - 2u].clone() }\n@@ -764,7 +765,7 @@ fn dump_output(config: &config, testfile: &Path, out: &str, err: &str) {\n fn dump_output_file(config: &config, testfile: &Path,\n                     out: &str, extension: &str) {\n     let outfile = make_out_name(config, testfile, extension);\n-    file::create(&outfile).write(out.as_bytes());\n+    File::create(&outfile).write(out.as_bytes());\n }\n \n fn make_out_name(config: &config, testfile: &Path, extension: &str) -> Path {\n@@ -1015,7 +1016,7 @@ fn disassemble_extract(config: &config, _props: &TestProps,\n \n \n fn count_extracted_lines(p: &Path) -> uint {\n-    let x = file::open(&p.with_extension(\"ll\")).read_to_end();\n+    let x = File::open(&p.with_extension(\"ll\")).read_to_end();\n     let x = str::from_utf8_owned(x);\n     x.line_iter().len()\n }"}, {"sha": "d86ed510361cc3fd0a1e048cd8201b46362270be", "filename": "src/etc/libc.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f19d0833625c382c5d0a8868924cd4620335e659/src%2Fetc%2Flibc.c", "raw_url": "https://github.com/rust-lang/rust/raw/f19d0833625c382c5d0a8868924cd4620335e659/src%2Fetc%2Flibc.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flibc.c?ref=f19d0833625c382c5d0a8868924cd4620335e659", "patch": "@@ -143,6 +143,7 @@ void posix88_consts() {\n   put_const(S_IFBLK, int);\n   put_const(S_IFDIR, int);\n   put_const(S_IFREG, int);\n+  put_const(S_IFLNK, int);\n   put_const(S_IFMT, int);\n \n   put_const(S_IEXEC, int);"}, {"sha": "09ceae66bb12d355ee95c0bc02ec874fa96e08ce", "filename": "src/libextra/terminfo/searcher.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fsearcher.rs?ref=f19d0833625c382c5d0a8868924cd4620335e659", "patch": "@@ -14,7 +14,7 @@\n use std::{os, str};\n use std::os::getenv;\n use std::rt::io;\n-use std::rt::io::file;\n+use std::rt::io::File;\n \n /// Return path to database entry for `term`\n pub fn get_dbpath_for_term(term: &str) -> Option<~Path> {\n@@ -76,7 +76,7 @@ pub fn get_dbpath_for_term(term: &str) -> Option<~Path> {\n /// Return open file for `term`\n pub fn open(term: &str) -> Result<@mut io::Reader, ~str> {\n     match get_dbpath_for_term(term) {\n-        Some(x) => Ok(@mut file::open(x) as @mut io::Reader),\n+        Some(x) => Ok(@mut File::open(x) as @mut io::Reader),\n         None => Err(format!(\"could not find terminfo entry for {}\", term))\n     }\n }"}, {"sha": "4cdb3841acf9b0c91c0c3b67df78d0315e907292", "filename": "src/libextra/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=f19d0833625c382c5d0a8868924cd4620335e659", "patch": "@@ -31,7 +31,7 @@ use treemap::TreeMap;\n use std::clone::Clone;\n use std::comm::{stream, SharedChan, GenericPort, GenericChan};\n use std::rt::io;\n-use std::rt::io::file;\n+use std::rt::io::File;\n use std::task;\n use std::to_str::ToStr;\n use std::f64;\n@@ -353,7 +353,7 @@ struct ConsoleTestState {\n impl ConsoleTestState {\n     pub fn new(opts: &TestOpts) -> ConsoleTestState {\n         let log_out = match opts.logfile {\n-            Some(ref path) => Some(@mut file::create(path) as @mut io::Writer),\n+            Some(ref path) => Some(@mut File::create(path) as @mut io::Writer),\n             None => None\n         };\n         let out = @mut io::stdio::stdout() as @mut io::Writer;\n@@ -936,14 +936,14 @@ impl MetricMap {\n     /// Load MetricDiff from a file.\n     pub fn load(p: &Path) -> MetricMap {\n         assert!(p.exists());\n-        let f = @mut file::open(p) as @mut io::Reader;\n+        let f = @mut File::open(p) as @mut io::Reader;\n         let mut decoder = json::Decoder(json::from_reader(f).unwrap());\n         MetricMap(Decodable::decode(&mut decoder))\n     }\n \n     /// Write MetricDiff to a file.\n     pub fn save(&self, p: &Path) {\n-        self.to_json().to_pretty_writer(@mut file::create(p) as @mut io::Writer);\n+        self.to_json().to_pretty_writer(@mut File::create(p) as @mut io::Writer);\n     }\n \n     /// Compare against another MetricMap. Optionally compare all"}, {"sha": "09d9dd828d4e5252c1aa9b8a1764c7dadff7fe47", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=f19d0833625c382c5d0a8868924cd4620335e659", "patch": "@@ -19,7 +19,7 @@ use std::cell::Cell;\n use std::comm::{PortOne, oneshot};\n use std::{str, task};\n use std::rt::io;\n-use std::rt::io::file;\n+use std::rt::io::File;\n use std::rt::io::Decorator;\n use std::rt::io::mem::MemWriter;\n \n@@ -176,14 +176,14 @@ impl Database {\n \n     // FIXME #4330: This should have &mut self and should set self.db_dirty to false.\n     fn save(&self) {\n-        let f = @mut file::create(&self.db_filename);\n+        let f = @mut File::create(&self.db_filename);\n         self.db_cache.to_json().to_pretty_writer(f as @mut io::Writer);\n     }\n \n     fn load(&mut self) {\n         assert!(!self.db_dirty);\n         assert!(self.db_filename.exists());\n-        match io::result(|| file::open(&self.db_filename)) {\n+        match io::result(|| File::open(&self.db_filename)) {\n             Err(e) => fail!(\"Couldn't load workcache database {}: {}\",\n                             self.db_filename.display(),\n                             e.desc),\n@@ -480,21 +480,20 @@ impl<'self, T:Send +\n #[test]\n fn test() {\n     use std::{os, run};\n-    use std::rt::io::file;\n     use std::str::from_utf8_owned;\n \n     // Create a path to a new file 'filename' in the directory in which\n     // this test is running.\n     fn make_path(filename: ~str) -> Path {\n         let pth = os::self_exe_path().expect(\"workcache::test failed\").with_filename(filename);\n         if pth.exists() {\n-            file::unlink(&pth);\n+            File::unlink(&pth);\n         }\n         return pth;\n     }\n \n     let pth = make_path(~\"foo.c\");\n-    file::create(&pth).write(bytes!(\"int main() { return 0; }\"));\n+    File::create(&pth).write(bytes!(\"int main() { return 0; }\"));\n \n     let db_path = make_path(~\"db.json\");\n \n@@ -507,7 +506,7 @@ fn test() {\n         let subcx = cx.clone();\n         let pth = pth.clone();\n \n-        let file_content = from_utf8_owned(file::open(&pth).read_to_end());\n+        let file_content = from_utf8_owned(File::open(&pth).read_to_end());\n \n         // FIXME (#9639): This needs to handle non-utf8 paths\n         prep.declare_input(\"file\", pth.as_str().unwrap(), file_content);"}, {"sha": "81a205228073e15288c547f94650210ef29642c2", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=f19d0833625c382c5d0a8868924cd4620335e659", "patch": "@@ -31,7 +31,7 @@ use std::ptr;\n use std::run;\n use std::str;\n use std::vec;\n-use std::rt::io::file;\n+use std::rt::io::File;\n use syntax::ast;\n use syntax::ast_map::{path, path_mod, path_name, path_pretty_name};\n use syntax::attr;\n@@ -950,18 +950,17 @@ pub fn link_binary(sess: Session,\n \n     // Remove the temporary object file if we aren't saving temps\n     if !sess.opts.save_temps {\n-        file::unlink(obj_filename);\n+        File::unlink(obj_filename);\n     }\n }\n \n fn is_writeable(p: &Path) -> bool {\n     use std::rt::io;\n-    use std::libc::consts::os::posix88::S_IWUSR;\n \n     !p.exists() ||\n         (match io::result(|| p.stat()) {\n             Err(*) => false,\n-            Ok(m) => (m.mode as uint) & S_IWUSR as uint == S_IWUSR as uint\n+            Ok(m) => m.perm & io::UserWrite == io::UserWrite\n         })\n }\n "}, {"sha": "01035385f97c7cd9a09d793b5e724724325fb0d2", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=f19d0833625c382c5d0a8868924cd4620335e659", "patch": "@@ -27,7 +27,7 @@ use util::ppaux;\n \n use std::hashmap::{HashMap,HashSet};\n use std::rt::io;\n-use std::rt::io::file;\n+use std::rt::io::File;\n use std::rt::io::mem::MemReader;\n use std::os;\n use std::vec;\n@@ -370,7 +370,7 @@ pub fn phase_5_run_llvm_passes(sess: Session,\n \n         // Remove assembly source unless --save-temps was specified\n         if !sess.opts.save_temps {\n-            file::unlink(&asm_filename);\n+            File::unlink(&asm_filename);\n         }\n     } else {\n         time(sess.time_passes(), \"LLVM passes\", (), |_|"}, {"sha": "d0e01d1f423227a3421d04e05c4033198f031a65", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=f19d0833625c382c5d0a8868924cd4620335e659", "patch": "@@ -42,6 +42,7 @@ use std::local_data;\n use std::rt::io::buffered::BufferedWriter;\n use std::rt::io;\n use std::rt::io::file;\n+use std::rt::io::File;\n use std::os;\n use std::str;\n use std::task;\n@@ -263,7 +264,7 @@ pub fn run(mut crate: clean::Crate, dst: Path) {\n     // Publish the search index\n     {\n         dst.push(\"search-index.js\");\n-        let mut w = BufferedWriter::new(file::create(&dst).unwrap());\n+        let mut w = BufferedWriter::new(File::create(&dst).unwrap());\n         let w = &mut w as &mut Writer;\n         write!(w, \"var searchIndex = [\");\n         for (i, item) in cache.search_index.iter().enumerate() {\n@@ -313,7 +314,7 @@ pub fn run(mut crate: clean::Crate, dst: Path) {\n /// Writes the entire contents of a string to a destination, not attempting to\n /// catch any errors.\n fn write(dst: Path, contents: &str) {\n-    file::create(&dst).write(contents.as_bytes());\n+    File::create(&dst).write(contents.as_bytes());\n }\n \n /// Makes a directory on the filesystem, failing the task if an error occurs and\n@@ -419,7 +420,7 @@ impl<'self> SourceCollector<'self> {\n             // If we couldn't open this file, then just returns because it\n             // probably means that it's some standard library macro thing and we\n             // can't have the source to it anyway.\n-            let mut r = match io::result(|| file::open(&p)) {\n+            let mut r = match io::result(|| File::open(&p)) {\n                 Ok(r) => r,\n                 // eew macro hacks\n                 Err(*) => return filename == \"<std-macros>\"\n@@ -445,7 +446,7 @@ impl<'self> SourceCollector<'self> {\n         }\n \n         cur.push(p.filename().expect(\"source has no filename\") + bytes!(\".html\"));\n-        let mut w = BufferedWriter::new(file::create(&cur).unwrap());\n+        let mut w = BufferedWriter::new(File::create(&cur).unwrap());\n \n         let title = cur.filename_display().with_str(|s| format!(\"{} -- source\", s));\n         let page = layout::Page {\n@@ -767,7 +768,7 @@ impl Context {\n     ///\n     /// The rendering driver uses this closure to queue up more work.\n     fn item(&mut self, item: clean::Item, f: &fn(&mut Context, clean::Item)) {\n-        fn render(w: file::FileWriter, cx: &mut Context, it: &clean::Item,\n+        fn render(w: io::File, cx: &mut Context, it: &clean::Item,\n                   pushname: bool) {\n             // A little unfortunate that this is done like this, but it sure\n             // does make formatting *a lot* nicer.\n@@ -804,7 +805,7 @@ impl Context {\n                 do self.recurse(name) |this| {\n                     let item = item.take();\n                     let dst = this.dst.join(\"index.html\");\n-                    render(file::create(&dst).unwrap(), this, &item, false);\n+                    render(File::create(&dst).unwrap(), this, &item, false);\n \n                     let m = match item.inner {\n                         clean::ModuleItem(m) => m,\n@@ -821,7 +822,7 @@ impl Context {\n             // pages dedicated to them.\n             _ if item.name.is_some() => {\n                 let dst = self.dst.join(item_path(&item));\n-                render(file::create(&dst).unwrap(), self, &item, true);\n+                render(File::create(&dst).unwrap(), self, &item, true);\n             }\n \n             _ => {}"}, {"sha": "c69fd9879ce2f6378c6e406be8ace46036402170", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=f19d0833625c382c5d0a8868924cd4620335e659", "patch": "@@ -26,7 +26,7 @@ extern mod extra;\n use std::cell::Cell;\n use std::local_data;\n use std::rt::io;\n-use std::rt::io::file;\n+use std::rt::io::File;\n use std::rt::io::mem::MemWriter;\n use std::rt::io::Decorator;\n use std::str;\n@@ -259,7 +259,7 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n /// This input format purely deserializes the json output file. No passes are\n /// run over the deserialized output.\n fn json_input(input: &str) -> Result<Output, ~str> {\n-    let input = match file::open(&Path::new(input)) {\n+    let input = match File::open(&Path::new(input)) {\n         Some(f) => f,\n         None => return Err(format!(\"couldn't open {} for reading\", input)),\n     };\n@@ -321,7 +321,7 @@ fn json_output(crate: clean::Crate, res: ~[plugins::PluginJson], dst: Path) {\n     json.insert(~\"crate\", crate_json);\n     json.insert(~\"plugins\", json::Object(plugins_json));\n \n-    let mut file = file::create(&dst).unwrap();\n+    let mut file = File::create(&dst).unwrap();\n     let output = json::Object(json).to_str();\n     file.write(output.as_bytes());\n }"}, {"sha": "cc10f15ffb1016fb85447730828bf8d5c4f75155", "filename": "src/librustpkg/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibrustpkg%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibrustpkg%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Flib.rs?ref=f19d0833625c382c5d0a8868924cd4620335e659", "patch": "@@ -28,6 +28,7 @@ use std::{os, result, run, str, task};\n use std::hashmap::HashSet;\n use std::rt::io;\n use std::rt::io::file;\n+use std::rt::io::File;\n pub use std::path::Path;\n \n use extra::workcache;\n@@ -661,7 +662,7 @@ impl CtxMethods for BuildContext {\n                 for exec in subex.iter() {\n                     debug!(\"Copying: {} -> {}\", exec.display(), sub_target_ex.display());\n                     file::mkdir_recursive(&sub_target_ex.dir_path(), io::UserRWX);\n-                    file::copy(exec, &sub_target_ex);\n+                    File::copy(exec, &sub_target_ex);\n                     // FIXME (#9639): This needs to handle non-utf8 paths\n                     exe_thing.discover_output(\"binary\",\n                         sub_target_ex.as_str().unwrap(),\n@@ -674,7 +675,7 @@ impl CtxMethods for BuildContext {\n                                              didn't install it!\", lib.display()));\n                     target_lib.set_filename(lib.filename().expect(\"weird target lib\"));\n                     file::mkdir_recursive(&target_lib.dir_path(), io::UserRWX);\n-                    file::copy(lib, &target_lib);\n+                    File::copy(lib, &target_lib);\n                     debug!(\"3. discovering output {}\", target_lib.display());\n                     exe_thing.discover_output(\"binary\",\n                                               target_lib.as_str().unwrap(),"}, {"sha": "5e3a90bbf58f7905f91da22ff11018ee8bfc19d0", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=f19d0833625c382c5d0a8868924cd4620335e659", "patch": "@@ -14,6 +14,7 @@ use target::*;\n use package_id::PkgId;\n use std::rt::io;\n use std::rt::io::file;\n+use std::rt::io::File;\n use std::os;\n use context::*;\n use crate::Crate;\n@@ -301,7 +302,7 @@ impl PkgSrc {\n                 // Move clone_target to local.\n                 // First, create all ancestor directories.\n                 let moved = make_dir_rwx_recursive(&local.dir_path())\n-                    && io::result(|| file::rename(&clone_target, local)).is_ok();\n+                    && io::result(|| File::rename(&clone_target, local)).is_ok();\n                 if moved { Some(local.clone()) }\n                     else { None }\n             }\n@@ -350,7 +351,7 @@ impl PkgSrc {\n \n         let prefix = self.start_dir.component_iter().len();\n         debug!(\"Matching against {}\", self.id.short_name);\n-        do file::walk_dir(&self.start_dir) |pth| {\n+        for pth in file::walk_dir(&self.start_dir) {\n             let maybe_known_crate_set = match pth.filename_str() {\n                 Some(filename) if filter(filename) => match filename {\n                     \"lib.rs\" => Some(&mut self.libs),\n@@ -363,11 +364,10 @@ impl PkgSrc {\n             };\n \n             match maybe_known_crate_set {\n-                Some(crate_set) => PkgSrc::push_crate(crate_set, prefix, pth),\n+                Some(crate_set) => PkgSrc::push_crate(crate_set, prefix, &pth),\n                 None => ()\n             }\n-            true\n-        };\n+        }\n \n         let crate_sets = [&self.libs, &self.mains, &self.tests, &self.benchs];\n         if crate_sets.iter().all(|crate_set| crate_set.is_empty()) {"}, {"sha": "e8f1b2300c73751e947a8bb418c051c049d8fba1", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=f19d0833625c382c5d0a8868924cd4620335e659", "patch": "@@ -21,6 +21,7 @@ use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n use std::os;\n use std::rt::io;\n use std::rt::io::file;\n+use std::rt::io::File;\n use messages::*;\n \n pub fn default_workspace() -> Path {\n@@ -72,9 +73,9 @@ pub fn workspace_contains_package_id_(pkgid: &PkgId, workspace: &Path,\n     if !src_dir.is_dir() { return None }\n \n     let mut found = None;\n-    do file::walk_dir(&src_dir) |p| {\n+    for p in file::walk_dir(&src_dir) {\n         if p.is_dir() {\n-            if *p == src_dir.join(&pkgid.path) || {\n+            if p == src_dir.join(&pkgid.path) || {\n                 let pf = p.filename_str();\n                 do pf.iter().any |&g| {\n                     match split_version_general(g, '-') {\n@@ -89,9 +90,8 @@ pub fn workspace_contains_package_id_(pkgid: &PkgId, workspace: &Path,\n                 found = Some(p.clone());\n             }\n \n-        };\n-        true\n-    };\n+        }\n+    }\n \n     if found.is_some() {\n         debug!(\"Found {} in {}\", pkgid.to_str(), workspace.display());\n@@ -399,12 +399,12 @@ pub fn uninstall_package_from(workspace: &Path, pkgid: &PkgId) {\n     let mut did_something = false;\n     let installed_bin = target_executable_in_workspace(pkgid, workspace);\n     if installed_bin.exists() {\n-        file::unlink(&installed_bin);\n+        File::unlink(&installed_bin);\n         did_something = true;\n     }\n     let installed_lib = target_library_in_workspace(pkgid, workspace);\n     if installed_lib.exists() {\n-        file::unlink(&installed_lib);\n+        File::unlink(&installed_lib);\n         did_something = true;\n     }\n     if !did_something {"}, {"sha": "e5d1c9b597ffc7142d3fb418339f716d698e0219", "filename": "src/librustpkg/source_control.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibrustpkg%2Fsource_control.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibrustpkg%2Fsource_control.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsource_control.rs?ref=f19d0833625c382c5d0a8868924cd4620335e659", "patch": "@@ -96,12 +96,11 @@ pub enum CloneResult {\n \n pub fn make_read_only(target: &Path) {\n     // Now, make all the files in the target dir read-only\n-    do file::walk_dir(target) |p| {\n+    for p in file::walk_dir(target) {\n         if !p.is_dir() {\n-            assert!(chmod_read_only(p));\n-        };\n-        true\n-    };\n+            assert!(chmod_read_only(&p));\n+        }\n+    }\n }\n \n /// Source can be either a URL or a local file path."}, {"sha": "a2ef80db6d6846994ce405639e888467115be964", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 12, "deletions": 23, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=f19d0833625c382c5d0a8868924cd4620335e659", "patch": "@@ -14,6 +14,7 @@ use context::{BuildContext, Context, RustcFlags};\n use std::{os, run, str, task};\n use std::rt::io;\n use std::rt::io::file;\n+use std::rt::io::File;\n use extra::arc::Arc;\n use extra::arc::RWArc;\n use extra::tempfile::TempDir;\n@@ -83,7 +84,7 @@ fn git_repo_pkg_with_tag(a_tag: ~str) -> PkgId {\n }\n \n fn writeFile(file_path: &Path, contents: &str) {\n-    let mut out = file::create(file_path);\n+    let mut out = File::create(file_path);\n     out.write(contents.as_bytes());\n     out.write(['\\n' as u8]);\n }\n@@ -196,23 +197,13 @@ fn add_git_tag(repo: &Path, tag: ~str) {\n }\n \n fn is_rwx(p: &Path) -> bool {\n-    use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n-\n     if !p.exists() { return false }\n-    let m = p.stat().mode;\n-    (m & S_IRUSR as u64) == S_IRUSR as u64\n-     && (m & S_IWUSR as u64) == S_IWUSR as u64\n-     && (m & S_IXUSR as u64) == S_IXUSR as u64\n+    p.stat().perm & io::UserRWX == io::UserRWX\n }\n \n fn is_read_only(p: &Path) -> bool {\n-    use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n-\n     if !p.exists() { return false }\n-    let m = p.stat().mode;\n-    (m & S_IRUSR as u64) == S_IRUSR as u64\n-     && (m & S_IWUSR as u64) == 0 as u64\n-     && (m & S_IXUSR as u64) == 0 as u64\n+    p.stat().perm & io::UserRWX == io::UserRead\n }\n \n fn test_sysroot() -> Path {\n@@ -398,7 +389,7 @@ fn test_executable_exists(repo: &Path, short_name: &str) -> bool {\n fn remove_executable_file(p: &PkgId, workspace: &Path) {\n     let exec = target_executable_in_workspace(&PkgId::new(p.short_name), workspace);\n     if exec.exists() {\n-        file::unlink(&exec);\n+        File::unlink(&exec);\n     }\n }\n \n@@ -419,7 +410,7 @@ fn built_executable_exists(repo: &Path, short_name: &str) -> bool {\n fn remove_built_executable_file(p: &PkgId, workspace: &Path) {\n     let exec = built_executable_in_workspace(&PkgId::new(p.short_name), workspace);\n     match exec {\n-        Some(r) => file::unlink(&r),\n+        Some(r) => File::unlink(&r),\n         None    => ()\n     }\n }\n@@ -553,7 +544,7 @@ fn frob_source_file(workspace: &Path, pkgid: &PkgId, filename: &str) {\n             do io::io_error::cond.trap(|e| {\n                 cond.raise((p.clone(), format!(\"Bad path: {}\", e.desc)));\n             }).inside {\n-                let mut w = file::open_stream(p, io::Append, io::Write);\n+                let mut w = File::open_mode(p, io::Append, io::Write);\n                 w.write(bytes!(\"/* hi */\\n\"));\n             }\n         }\n@@ -902,7 +893,7 @@ fn package_script_with_default_build() {\n     let source = Path::new(file!()).dir_path().join_many(\n         [~\"testsuite\", ~\"pass\", ~\"src\", ~\"fancy-lib\", ~\"pkg.rs\"]);\n     debug!(\"package_script_with_default_build: {}\", source.display());\n-    file::copy(&source, &dir.join_many([\"src\", \"fancy-lib-0.1\", \"pkg.rs\"]));\n+    File::copy(&source, &dir.join_many([\"src\", \"fancy-lib-0.1\", \"pkg.rs\"]));\n     command_line_test([~\"install\", ~\"fancy-lib\"], dir);\n     assert_lib_exists(dir, &Path::new(\"fancy-lib\"), NoVersion);\n     assert!(target_build_dir(dir).join_many([~\"fancy-lib\", ~\"generated.rs\"]).exists());\n@@ -2288,7 +2279,7 @@ fn test_c_dependency_ok() {\n     debug!(\"dir = {}\", dir.display());\n     let source = Path::new(file!()).dir_path().join_many(\n         [~\"testsuite\", ~\"pass\", ~\"src\", ~\"c-dependencies\", ~\"pkg.rs\"]);\n-    file::copy(&source, &dir.join_many([~\"src\", ~\"cdep-0.1\", ~\"pkg.rs\"]));\n+    File::copy(&source, &dir.join_many([~\"src\", ~\"cdep-0.1\", ~\"pkg.rs\"]));\n     command_line_test([~\"build\", ~\"cdep\"], dir);\n     assert_executable_exists(dir, \"cdep\");\n     let out_dir = target_build_dir(dir).join(\"cdep\");\n@@ -2309,7 +2300,7 @@ fn test_c_dependency_no_rebuilding() {\n     debug!(\"dir = {}\", dir.display());\n     let source = Path::new(file!()).dir_path().join_many(\n         [~\"testsuite\", ~\"pass\", ~\"src\", ~\"c-dependencies\", ~\"pkg.rs\"]);\n-    file::copy(&source, &dir.join_many([~\"src\", ~\"cdep-0.1\", ~\"pkg.rs\"]));\n+    File::copy(&source, &dir.join_many([~\"src\", ~\"cdep-0.1\", ~\"pkg.rs\"]));\n     command_line_test([~\"build\", ~\"cdep\"], dir);\n     assert_executable_exists(dir, \"cdep\");\n     let out_dir = target_build_dir(dir).join(\"cdep\");\n@@ -2342,7 +2333,7 @@ fn test_c_dependency_yes_rebuilding() {\n         [~\"testsuite\", ~\"pass\", ~\"src\", ~\"c-dependencies\", ~\"pkg.rs\"]);\n     let target = dir.join_many([~\"src\", ~\"cdep-0.1\", ~\"pkg.rs\"]);\n     debug!(\"Copying {} -> {}\", source.display(), target.display());\n-    file::copy(&source, &target);\n+    File::copy(&source, &target);\n     command_line_test([~\"build\", ~\"cdep\"], dir);\n     assert_executable_exists(dir, \"cdep\");\n     let out_dir = target_build_dir(dir).join(\"cdep\");\n@@ -2366,7 +2357,5 @@ fn test_c_dependency_yes_rebuilding() {\n \n /// Returns true if p exists and is executable\n fn is_executable(p: &Path) -> bool {\n-    use std::libc::consts::os::posix88::{S_IXUSR};\n-\n-    p.exists() && p.stat().mode & S_IXUSR as u64 == S_IXUSR as u64\n+    p.exists() && p.stat().perm & io::UserExec == io::UserExec\n }"}, {"sha": "1c3bf897bec1d437a76641fd8deb353c3cb88a4c", "filename": "src/librustpkg/testsuite/pass/src/fancy-lib/pkg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs?ref=f19d0833625c382c5d0a8868924cd4620335e659", "patch": "@@ -12,7 +12,7 @@ extern mod rustpkg;\n extern mod rustc;\n \n use std::os;\n-use std::rt::io::file;\n+use std::rt::io::File;\n use rustpkg::api;\n use rustpkg::version::NoVersion;\n \n@@ -43,7 +43,7 @@ pub fn main() {\n     let out_path = os::self_exe_path().expect(\"Couldn't get self_exe path\");\n \n     debug!(\"Writing file\");\n-    let mut file = file::create(&out_path.join(\"generated.rs\"));\n+    let mut file = File::create(&out_path.join(\"generated.rs\"));\n     file.write(\"pub fn wheeeee() { let xs = [1, 2, 3]; \\\n                 for _ in xs.iter() { assert!(true); } }\".as_bytes());\n "}, {"sha": "d8b35f2c0332a424e2764b48c98f3022a0862c14", "filename": "src/librustpkg/workcache_support.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibrustpkg%2Fworkcache_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibrustpkg%2Fworkcache_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkcache_support.rs?ref=f19d0833625c382c5d0a8868924cd4620335e659", "patch": "@@ -9,15 +9,15 @@\n // except according to those terms.\n \n use std::rt::io;\n-use std::rt::io::file;\n+use std::rt::io::File;\n use extra::workcache;\n use sha1::{Digest, Sha1};\n \n /// Hashes the file contents along with the last-modified time\n pub fn digest_file_with_date(path: &Path) -> ~str {\n     use conditions::bad_path::cond;\n \n-    match io::result(|| file::open(path).read_to_end()) {\n+    match io::result(|| File::open(path).read_to_end()) {\n         Ok(bytes) => {\n             let mut sha = Sha1::new();\n             sha.input(bytes);"}, {"sha": "99060de1d2dd2225434671f9bf6eae58e106d75f", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 133, "deletions": 100, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=f19d0833625c382c5d0a8868924cd4620335e659", "patch": "@@ -11,10 +11,9 @@\n use std::ptr::null;\n use std::c_str;\n use std::c_str::CString;\n-use std::libc::c_void;\n use std::cast::transmute;\n use std::libc;\n-use std::libc::{c_int};\n+use std::libc::{c_int, c_char, c_void};\n \n use super::{Request, NativeHandle, Loop, FsCallback, Buf,\n             status_to_maybe_uv_error, UvError};\n@@ -49,61 +48,56 @@ impl FsRequest {\n         assert_eq!(ret, 0);\n     }\n \n-    pub fn open_sync(self, loop_: &Loop, path: &CString,\n+    pub fn open_sync(mut self, loop_: &Loop, path: &CString,\n                      flags: int, mode: int) -> Result<c_int, UvError> {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(None)\n-        };\n+        let complete_cb_ptr = self.req_boilerplate(None);\n         let result = path.with_ref(|p| unsafe {\n             uvll::fs_open(loop_.native_handle(),\n                     self.native_handle(), p, flags, mode, complete_cb_ptr)\n         });\n         self.sync_cleanup(result)\n     }\n \n-    pub fn unlink(self, loop_: &Loop, path: &CString, cb: FsCallback) {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(Some(cb))\n-        };\n+    pub fn unlink(mut self, loop_: &Loop, path: &CString, cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n         let ret = path.with_ref(|p| unsafe {\n             uvll::fs_unlink(loop_.native_handle(),\n                           self.native_handle(), p, complete_cb_ptr)\n         });\n         assert_eq!(ret, 0);\n     }\n \n-    pub fn unlink_sync(self, loop_: &Loop, path: &CString)\n+    pub fn unlink_sync(mut self, loop_: &Loop, path: &CString)\n       -> Result<c_int, UvError> {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(None)\n-        };\n+        let complete_cb_ptr = self.req_boilerplate(None);\n         let result = path.with_ref(|p| unsafe {\n             uvll::fs_unlink(loop_.native_handle(),\n                           self.native_handle(), p, complete_cb_ptr)\n         });\n         self.sync_cleanup(result)\n     }\n \n-    pub fn stat(self, loop_: &Loop, path: &CString, cb: FsCallback) {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(Some(cb))\n-        };\n+    pub fn lstat(mut self, loop_: &Loop, path: &CString, cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n+        let ret = path.with_ref(|p| unsafe {\n+            uvll::uv_fs_lstat(loop_.native_handle(),\n+                              self.native_handle(), p, complete_cb_ptr)\n+        });\n+        assert_eq!(ret, 0);\n+    }\n+\n+    pub fn stat(mut self, loop_: &Loop, path: &CString, cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n         let ret = path.with_ref(|p| unsafe {\n             uvll::fs_stat(loop_.native_handle(),\n                           self.native_handle(), p, complete_cb_ptr)\n         });\n         assert_eq!(ret, 0);\n     }\n \n-    pub fn write(self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64, cb: FsCallback) {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(Some(cb))\n-        };\n+    pub fn write(mut self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64,\n+                 cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n         let base_ptr = buf.base as *c_void;\n         let len = buf.len as uint;\n         let ret = unsafe {\n@@ -113,12 +107,9 @@ impl FsRequest {\n         };\n         assert_eq!(ret, 0);\n     }\n-    pub fn write_sync(self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64)\n+    pub fn write_sync(mut self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64)\n           -> Result<c_int, UvError> {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(None)\n-        };\n+        let complete_cb_ptr = self.req_boilerplate(None);\n         let base_ptr = buf.base as *c_void;\n         let len = buf.len as uint;\n         let result = unsafe {\n@@ -129,11 +120,9 @@ impl FsRequest {\n         self.sync_cleanup(result)\n     }\n \n-    pub fn read(self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64, cb: FsCallback) {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(Some(cb))\n-        };\n+    pub fn read(mut self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64,\n+                cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n         let buf_ptr = buf.base as *c_void;\n         let len = buf.len as uint;\n         let ret = unsafe {\n@@ -143,12 +132,9 @@ impl FsRequest {\n         };\n         assert_eq!(ret, 0);\n     }\n-    pub fn read_sync(self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64)\n+    pub fn read_sync(mut self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64)\n           -> Result<c_int, UvError> {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(None)\n-        };\n+        let complete_cb_ptr = self.req_boilerplate(None);\n         let buf_ptr = buf.base as *c_void;\n         let len = buf.len as uint;\n         let result = unsafe {\n@@ -159,91 +145,136 @@ impl FsRequest {\n         self.sync_cleanup(result)\n     }\n \n-    pub fn close(self, loop_: &Loop, fd: c_int, cb: FsCallback) {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(Some(cb))\n-        };\n-        let ret = unsafe {\n+    pub fn close(mut self, loop_: &Loop, fd: c_int, cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n+        assert_eq!(unsafe {\n             uvll::fs_close(loop_.native_handle(), self.native_handle(),\n                            fd, complete_cb_ptr)\n-        };\n-        assert_eq!(ret, 0);\n+        }, 0);\n     }\n-    pub fn close_sync(self, loop_: &Loop, fd: c_int) -> Result<c_int, UvError> {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(None)\n-        };\n+    pub fn close_sync(mut self, loop_: &Loop,\n+                      fd: c_int) -> Result<c_int, UvError> {\n+        let complete_cb_ptr = self.req_boilerplate(None);\n         let result = unsafe {\n             uvll::fs_close(loop_.native_handle(), self.native_handle(),\n                            fd, complete_cb_ptr)\n         };\n         self.sync_cleanup(result)\n     }\n \n-    pub fn mkdir(self, loop_: &Loop, path: &CString, mode: c_int, cb: FsCallback) {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(Some(cb))\n-        };\n-        let ret = path.with_ref(|p| unsafe {\n+    pub fn mkdir(mut self, loop_: &Loop, path: &CString, mode: c_int,\n+                 cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n+        assert_eq!(path.with_ref(|p| unsafe {\n             uvll::fs_mkdir(loop_.native_handle(),\n                            self.native_handle(), p, mode, complete_cb_ptr)\n-        });\n-        assert_eq!(ret, 0);\n+        }), 0);\n     }\n \n-    pub fn rmdir(self, loop_: &Loop, path: &CString, cb: FsCallback) {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(Some(cb))\n-        };\n-        let ret = path.with_ref(|p| unsafe {\n+    pub fn rmdir(mut self, loop_: &Loop, path: &CString, cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n+        assert_eq!(path.with_ref(|p| unsafe {\n             uvll::fs_rmdir(loop_.native_handle(),\n                            self.native_handle(), p, complete_cb_ptr)\n-        });\n-        assert_eq!(ret, 0);\n+        }), 0);\n     }\n \n-    pub fn rename(self, loop_: &Loop, path: &CString, to: &CString, cb: FsCallback) {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(Some(cb))\n-        };\n-        let ret = unsafe {\n+    pub fn rename(mut self, loop_: &Loop, path: &CString, to: &CString,\n+                  cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n+        assert_eq!(unsafe {\n             uvll::fs_rename(loop_.native_handle(),\n                             self.native_handle(),\n                             path.with_ref(|p| p),\n                             to.with_ref(|p| p),\n                             complete_cb_ptr)\n-        };\n-        assert_eq!(ret, 0);\n+        }, 0);\n     }\n \n-    pub fn chmod(self, loop_: &Loop, path: &CString, mode: c_int, cb: FsCallback) {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(Some(cb))\n-        };\n-        let ret = path.with_ref(|p| unsafe {\n+    pub fn chmod(mut self, loop_: &Loop, path: &CString, mode: c_int,\n+                 cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n+        assert_eq!(path.with_ref(|p| unsafe {\n             uvll::fs_chmod(loop_.native_handle(), self.native_handle(), p, mode,\n                            complete_cb_ptr)\n-        });\n-        assert_eq!(ret, 0);\n+        }), 0);\n     }\n \n-    pub fn readdir(self, loop_: &Loop, path: &CString,\n+    pub fn readdir(mut self, loop_: &Loop, path: &CString,\n                    flags: c_int, cb: FsCallback) {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(Some(cb))\n-        };\n-        let ret = path.with_ref(|p| unsafe {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n+        assert_eq!(path.with_ref(|p| unsafe {\n             uvll::fs_readdir(loop_.native_handle(),\n                              self.native_handle(), p, flags, complete_cb_ptr)\n-        });\n-        assert_eq!(ret, 0);\n+        }), 0);\n+    }\n+\n+    pub fn readlink(mut self, loop_: &Loop, path: &CString, cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n+        assert_eq!(path.with_ref(|p| unsafe {\n+            uvll::uv_fs_readlink(loop_.native_handle(),\n+                                 self.native_handle(), p, complete_cb_ptr)\n+        }), 0);\n+    }\n+\n+    pub fn chown(mut self, loop_: &Loop, path: &CString, uid: int, gid: int,\n+                 cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n+        assert_eq!(path.with_ref(|p| unsafe {\n+            uvll::uv_fs_chown(loop_.native_handle(),\n+                              self.native_handle(), p,\n+                              uid as uvll::uv_uid_t,\n+                              gid as uvll::uv_gid_t,\n+                              complete_cb_ptr)\n+        }), 0);\n+    }\n+\n+    pub fn truncate(mut self, loop_: &Loop, file: c_int, offset: i64,\n+                    cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n+        assert_eq!(unsafe {\n+            uvll::uv_fs_ftruncate(loop_.native_handle(),\n+                                  self.native_handle(), file, offset,\n+                                  complete_cb_ptr)\n+        }, 0);\n+    }\n+\n+    pub fn link(mut self, loop_: &Loop, src: &CString, dst: &CString,\n+                cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n+        assert_eq!(unsafe {\n+            uvll::uv_fs_link(loop_.native_handle(), self.native_handle(),\n+                             src.with_ref(|p| p),\n+                             dst.with_ref(|p| p),\n+                             complete_cb_ptr)\n+        }, 0);\n+    }\n+\n+    pub fn symlink(mut self, loop_: &Loop, src: &CString, dst: &CString,\n+                   cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n+        assert_eq!(unsafe {\n+            uvll::uv_fs_symlink(loop_.native_handle(), self.native_handle(),\n+                                src.with_ref(|p| p),\n+                                dst.with_ref(|p| p),\n+                                complete_cb_ptr)\n+        }, 0);\n+    }\n+\n+    pub fn fsync(mut self, loop_: &Loop, fd: c_int, cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n+        assert_eq!(unsafe {\n+            uvll::uv_fs_fsync(loop_.native_handle(), self.native_handle(), fd,\n+                              complete_cb_ptr)\n+        }, 0);\n+    }\n+\n+    pub fn datasync(mut self, loop_: &Loop, fd: c_int, cb: FsCallback) {\n+        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n+        assert_eq!(unsafe {\n+            uvll::uv_fs_fdatasync(loop_.native_handle(), self.native_handle(), fd,\n+                                  complete_cb_ptr)\n+        }, 0);\n     }\n \n     // accessors/utility funcs\n@@ -284,10 +315,12 @@ impl FsRequest {\n         }\n     }\n \n-    pub fn get_result(&mut self) -> c_int {\n-        unsafe {\n-            uvll::get_result_from_fs_req(self.native_handle())\n-        }\n+    pub fn get_path(&self) -> *c_char {\n+        unsafe { uvll::get_path_from_fs_req(self.native_handle()) }\n+    }\n+\n+    pub fn get_result(&self) -> c_int {\n+        unsafe { uvll::get_result_from_fs_req(self.native_handle()) }\n     }\n \n     pub fn get_loop(&self) -> Loop {\n@@ -380,7 +413,7 @@ extern fn compl_cb(req: *uv_fs_t) {\n mod test {\n     use super::*;\n     //use std::rt::test::*;\n-    use std::libc::{STDOUT_FILENO};\n+    use std::libc::{STDOUT_FILENO, c_int};\n     use std::vec;\n     use std::str;\n     use std::unstable::run_in_bare_thread;"}, {"sha": "25839c429da6acf58141bd2b76b1b9ef907d9cdd", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 180, "deletions": 164, "changes": 344, "blob_url": "https://github.com/rust-lang/rust/blob/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=f19d0833625c382c5d0a8868924cd4620335e659", "patch": "@@ -8,18 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::c_str::{ToCStr, CString};\n+use std::c_str::CString;\n use std::cast::transmute;\n use std::cast;\n use std::cell::Cell;\n-use std::clone::Clone;\n use std::comm::{SendDeferred, SharedChan, Port, PortOne, GenericChan};\n+use std::libc;\n use std::libc::{c_int, c_uint, c_void, pid_t};\n-use std::ops::Drop;\n-use std::option::*;\n use std::ptr;\n use std::str;\n-use std::result::*;\n use std::rt::io;\n use std::rt::io::IoError;\n use std::rt::io::net::ip::{SocketAddr, IpAddr};\n@@ -33,22 +30,16 @@ use std::rt::sched::{Scheduler, SchedHandle};\n use std::rt::tube::Tube;\n use std::rt::task::Task;\n use std::unstable::sync::Exclusive;\n-use std::path::{GenericPath, Path};\n-use std::libc::{lseek, off_t, O_CREAT, O_APPEND, O_TRUNC, O_RDWR, O_RDONLY,\n-                O_WRONLY, S_IRUSR, S_IWUSR};\n-use std::rt::io::{FileMode, FileAccess, OpenOrCreate, Open, Create,\n-                  CreateOrTruncate, Append, Truncate, Read, Write, ReadWrite,\n-                  FileStat};\n+use std::libc::{lseek, off_t};\n+use std::rt::io::{FileMode, FileAccess, FileStat};\n use std::rt::io::signal::Signum;\n use std::task;\n use ai = std::rt::io::net::addrinfo;\n \n-#[cfg(test)] use std::container::Container;\n #[cfg(test)] use std::unstable::run_in_bare_thread;\n #[cfg(test)] use std::rt::test::{spawntask,\n                                  next_test_ip4,\n                                  run_in_mt_newsched_task};\n-#[cfg(test)] use std::iter::{Iterator, range};\n #[cfg(test)] use std::rt::comm::oneshot;\n \n use super::*;\n@@ -418,24 +409,25 @@ impl UvIoFactory {\n     }\n }\n \n-/// Helper for a variety of simple uv_fs_* functions that\n-/// have no ret val\n-fn uv_fs_helper(loop_: &mut Loop, path: &CString,\n-                cb: ~fn(&mut FsRequest, &mut Loop, &CString,\n-                        ~fn(&FsRequest, Option<UvError>)))\n-        -> Result<(), IoError> {\n+/// Helper for a variety of simple uv_fs_* functions that have no ret val. This\n+/// function takes the loop that it will act on, and then invokes the specified\n+/// callback in a situation where the task wil be immediately blocked\n+/// afterwards. The `FsCallback` yielded must be invoked to reschedule the task\n+/// (once the result of the operation is known).\n+fn uv_fs_helper<T>(loop_: &mut Loop,\n+                   retfn: extern \"Rust\" fn(&mut FsRequest) -> T,\n+                   cb: &fn(&mut FsRequest, &mut Loop, FsCallback))\n+        -> Result<T, IoError> {\n     let result_cell = Cell::new_empty();\n-    let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n-    let path_cell = Cell::new(path);\n+    let result_cell_ptr: *Cell<Result<T, IoError>> = &result_cell;\n     do task::unkillable { // FIXME(#8674)\n         let scheduler: ~Scheduler = Local::take();\n         let mut new_req = FsRequest::new();\n         do scheduler.deschedule_running_task_and_then |_, task| {\n             let task_cell = Cell::new(task);\n-            let path = path_cell.take();\n-            do cb(&mut new_req, loop_, path) |_, err| {\n+            do cb(&mut new_req, loop_) |req, err| {\n                 let res = match err {\n-                    None => Ok(()),\n+                    None => Ok(retfn(req)),\n                     Some(err) => Err(uv_error_to_io_error(err))\n                 };\n                 unsafe { (*result_cell_ptr).put_back(res); }\n@@ -448,6 +440,43 @@ fn uv_fs_helper(loop_: &mut Loop, path: &CString,\n     return result_cell.take();\n }\n \n+fn unit(_: &mut FsRequest) {}\n+\n+fn fs_mkstat(f: &mut FsRequest) -> FileStat {\n+    let path = unsafe { Path::new(CString::new(f.get_path(), false)) };\n+    let stat = f.get_stat();\n+    fn to_msec(stat: uvll::uv_timespec_t) -> u64 {\n+        (stat.tv_sec * 1000 + stat.tv_nsec / 1000000) as u64\n+    }\n+    let kind = match (stat.st_mode as c_int) & libc::S_IFMT {\n+        libc::S_IFREG => io::TypeFile,\n+        libc::S_IFDIR => io::TypeDirectory,\n+        libc::S_IFIFO => io::TypeNamedPipe,\n+        libc::S_IFBLK => io::TypeBlockSpecial,\n+        libc::S_IFLNK => io::TypeSymlink,\n+        _ => io::TypeUnknown,\n+    };\n+    FileStat {\n+        path: path,\n+        size: stat.st_size as u64,\n+        kind: kind,\n+        perm: (stat.st_mode as io::FilePermission) & io::AllPermissions,\n+        created: to_msec(stat.st_birthtim),\n+        modified: to_msec(stat.st_mtim),\n+        accessed: to_msec(stat.st_atim),\n+        device: stat.st_dev as u64,\n+        inode: stat.st_ino as u64,\n+        rdev: stat.st_rdev as u64,\n+        nlink: stat.st_nlink as u64,\n+        uid: stat.st_uid as u64,\n+        gid: stat.st_gid as u64,\n+        blksize: stat.st_blksize as u64,\n+        blocks: stat.st_blocks as u64,\n+        flags: stat.st_flags as u64,\n+        gen: stat.st_gen as u64,\n+    }\n+}\n+\n impl IoFactory for UvIoFactory {\n     // Connect to an address and return a new stream\n     // NB: This blocks the task waiting on the connection.\n@@ -552,6 +581,41 @@ impl IoFactory for UvIoFactory {\n         Ok(~UvTimer::new(watcher, home) as ~RtioTimer)\n     }\n \n+    fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n+                          hint: Option<ai::Hint>) -> Result<~[ai::Info], IoError> {\n+        let result_cell = Cell::new_empty();\n+        let result_cell_ptr: *Cell<Result<~[ai::Info], IoError>> = &result_cell;\n+        let host_ptr: *Option<&str> = &host;\n+        let servname_ptr: *Option<&str> = &servname;\n+        let hint_ptr: *Option<ai::Hint> = &hint;\n+        let addrinfo_req = GetAddrInfoRequest::new();\n+        let addrinfo_req_cell = Cell::new(addrinfo_req);\n+\n+        do task::unkillable { // FIXME(#8674)\n+            let scheduler: ~Scheduler = Local::take();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                let mut addrinfo_req = addrinfo_req_cell.take();\n+                unsafe {\n+                    do addrinfo_req.getaddrinfo(self.uv_loop(),\n+                                                *host_ptr, *servname_ptr,\n+                                                *hint_ptr) |_, addrinfo, err| {\n+                        let res = match err {\n+                            None => Ok(accum_addrinfo(addrinfo)),\n+                            Some(err) => Err(uv_error_to_io_error(err))\n+                        };\n+                        (*result_cell_ptr).put_back(res);\n+                        let scheduler: ~Scheduler = Local::take();\n+                        scheduler.resume_blocked_task_immediately(task_cell.take());\n+                    }\n+                }\n+            }\n+        }\n+        addrinfo_req.delete();\n+        assert!(!result_cell.is_empty());\n+        return result_cell.take();\n+    }\n+\n     fn fs_from_raw_fd(&mut self, fd: c_int, close: CloseBehavior) -> ~RtioFileStream {\n         let loop_ = Loop {handle: self.uv_loop().native_handle()};\n         let home = get_handle_to_current_scheduler!();\n@@ -560,35 +624,28 @@ impl IoFactory for UvIoFactory {\n \n     fn fs_open(&mut self, path: &CString, fm: FileMode, fa: FileAccess)\n         -> Result<~RtioFileStream, IoError> {\n-        let mut flags = match fm {\n-            Open => 0,\n-            Create => O_CREAT,\n-            OpenOrCreate => O_CREAT,\n-            Append => O_APPEND,\n-            Truncate => O_TRUNC,\n-            CreateOrTruncate => O_TRUNC | O_CREAT\n-        };\n-        flags = match fa {\n-            Read => flags | O_RDONLY,\n-            Write => flags | O_WRONLY,\n-            ReadWrite => flags | O_RDWR\n+        let flags = match fm {\n+            io::Open => 0,\n+            io::Append => libc::O_APPEND,\n+            io::Truncate => libc::O_TRUNC,\n         };\n-        let create_mode = match fm {\n-            Create|OpenOrCreate|CreateOrTruncate =>\n-                S_IRUSR | S_IWUSR,\n-            _ => 0\n+        // Opening with a write permission must silently create the file.\n+        let (flags, mode) = match fa {\n+            io::Read => (flags | libc::O_RDONLY, 0),\n+            io::Write => (flags | libc::O_WRONLY | libc::O_CREAT,\n+                          libc::S_IRUSR | libc::S_IWUSR),\n+            io::ReadWrite => (flags | libc::O_RDWR | libc::O_CREAT,\n+                              libc::S_IRUSR | libc::S_IWUSR),\n         };\n         let result_cell = Cell::new_empty();\n         let result_cell_ptr: *Cell<Result<~RtioFileStream,\n                                            IoError>> = &result_cell;\n-        let path_cell = Cell::new(path);\n         do task::unkillable { // FIXME(#8674)\n             let scheduler: ~Scheduler = Local::take();\n             let open_req = file::FsRequest::new();\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let task_cell = Cell::new(task);\n-                let path = path_cell.take();\n-                do open_req.open(self.uv_loop(), path, flags as int, create_mode as int)\n+                do open_req.open(self.uv_loop(), path, flags as int, mode as int)\n                       |req,err| {\n                     if err.is_none() {\n                         let loop_ = Loop {handle: req.get_loop().native_handle()};\n@@ -614,125 +671,42 @@ impl IoFactory for UvIoFactory {\n     }\n \n     fn fs_unlink(&mut self, path: &CString) -> Result<(), IoError> {\n-        do uv_fs_helper(self.uv_loop(), path) |unlink_req, l, p, cb| {\n-            do unlink_req.unlink(l, p) |req, err| {\n-                cb(req, err)\n-            };\n+        do uv_fs_helper(self.uv_loop(), unit) |req, l, cb| {\n+            req.unlink(l, path, cb)\n         }\n     }\n-    fn fs_stat(&mut self, path: &CString) -> Result<FileStat, IoError> {\n-        use str::StrSlice;\n-        let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<FileStat,\n-                                           IoError>> = &result_cell;\n-        let path_cell = Cell::new(path);\n-        do task::unkillable { // FIXME(#8674)\n-            let scheduler: ~Scheduler = Local::take();\n-            let stat_req = file::FsRequest::new();\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task_cell = Cell::new(task);\n-                let path = path_cell.take();\n-                // Don't pick up the null byte\n-                let slice = path.as_bytes().slice(0, path.len());\n-                let path_instance = Cell::new(Path::new(slice));\n-                do stat_req.stat(self.uv_loop(), path) |req,err| {\n-                    let res = match err {\n-                        None => {\n-                            let stat = req.get_stat();\n-                            Ok(FileStat {\n-                                path: path_instance.take(),\n-                                is_file: stat.is_file(),\n-                                is_dir: stat.is_dir(),\n-                                device: stat.st_dev,\n-                                mode: stat.st_mode,\n-                                inode: stat.st_ino,\n-                                size: stat.st_size,\n-                                created: stat.st_ctim.tv_sec as u64,\n-                                modified: stat.st_mtim.tv_sec as u64,\n-                                accessed: stat.st_atim.tv_sec as u64\n-                            })\n-                        },\n-                        Some(e) => {\n-                            Err(uv_error_to_io_error(e))\n-                        }\n-                    };\n-                    unsafe { (*result_cell_ptr).put_back(res); }\n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n-                };\n-            };\n-        };\n-        assert!(!result_cell.is_empty());\n-        return result_cell.take();\n+    fn fs_lstat(&mut self, path: &CString) -> Result<FileStat, IoError> {\n+        do uv_fs_helper(self.uv_loop(), fs_mkstat) |req, l, cb| {\n+            req.lstat(l, path, cb)\n+        }\n     }\n-\n-    fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n-                          hint: Option<ai::Hint>) -> Result<~[ai::Info], IoError> {\n-        let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<~[ai::Info], IoError>> = &result_cell;\n-        let host_ptr: *Option<&str> = &host;\n-        let servname_ptr: *Option<&str> = &servname;\n-        let hint_ptr: *Option<ai::Hint> = &hint;\n-        let addrinfo_req = GetAddrInfoRequest::new();\n-        let addrinfo_req_cell = Cell::new(addrinfo_req);\n-\n-        do task::unkillable { // FIXME(#8674)\n-            let scheduler: ~Scheduler = Local::take();\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task_cell = Cell::new(task);\n-                let mut addrinfo_req = addrinfo_req_cell.take();\n-                unsafe {\n-                    do addrinfo_req.getaddrinfo(self.uv_loop(),\n-                                                *host_ptr, *servname_ptr,\n-                                                *hint_ptr) |_, addrinfo, err| {\n-                        let res = match err {\n-                            None => Ok(accum_addrinfo(addrinfo)),\n-                            Some(err) => Err(uv_error_to_io_error(err))\n-                        };\n-                        (*result_cell_ptr).put_back(res);\n-                        let scheduler: ~Scheduler = Local::take();\n-                        scheduler.resume_blocked_task_immediately(task_cell.take());\n-                    }\n-                }\n-            }\n+    fn fs_stat(&mut self, path: &CString) -> Result<FileStat, IoError> {\n+        do uv_fs_helper(self.uv_loop(), fs_mkstat) |req, l, cb| {\n+            req.stat(l, path, cb)\n         }\n-        addrinfo_req.delete();\n-        assert!(!result_cell.is_empty());\n-        return result_cell.take();\n     }\n     fn fs_mkdir(&mut self, path: &CString,\n                 perm: io::FilePermission) -> Result<(), IoError> {\n-        do uv_fs_helper(self.uv_loop(), path) |mkdir_req, l, p, cb| {\n-            do mkdir_req.mkdir(l, p, perm as c_int) |req, err| {\n-                cb(req, err)\n-            };\n+        do uv_fs_helper(self.uv_loop(), unit) |req, l, cb| {\n+            req.mkdir(l, path, perm as c_int, cb)\n         }\n     }\n     fn fs_rmdir(&mut self, path: &CString) -> Result<(), IoError> {\n-        do uv_fs_helper(self.uv_loop(), path) |rmdir_req, l, p, cb| {\n-            do rmdir_req.rmdir(l, p) |req, err| {\n-                cb(req, err)\n-            };\n+        do uv_fs_helper(self.uv_loop(), unit) |req, l, cb| {\n+            req.rmdir(l, path, cb)\n         }\n     }\n     fn fs_rename(&mut self, path: &CString, to: &CString) -> Result<(), IoError> {\n-        let to = to.with_ref(|p| p);\n-        do uv_fs_helper(self.uv_loop(), path) |rename_req, l, p, cb| {\n-            let to = unsafe { CString::new(to, false) };\n-            do rename_req.rename(l, p, &to) |req, err| {\n-                cb(req, err)\n-            };\n+        do uv_fs_helper(self.uv_loop(), unit) |req, l, cb| {\n+            req.rename(l, path, to, cb)\n         }\n     }\n     fn fs_chmod(&mut self, path: &CString,\n                 perm: io::FilePermission) -> Result<(), IoError> {\n-        do uv_fs_helper(self.uv_loop(), path) |chmod_req, l, p, cb| {\n-            do chmod_req.chmod(l, p, perm as c_int) |req, err| {\n-                cb(req, err)\n-            };\n+        do uv_fs_helper(self.uv_loop(), unit) |req, l, cb| {\n+            req.chmod(l, path, perm as c_int, cb)\n         }\n     }\n->>>>>>> Remove all blocking std::os blocking functions\n     fn fs_readdir(&mut self, path: &CString, flags: c_int) ->\n         Result<~[Path], IoError> {\n         use str::StrSlice;\n@@ -773,6 +747,29 @@ impl IoFactory for UvIoFactory {\n         assert!(!result_cell.is_empty());\n         return result_cell.take();\n     }\n+    fn fs_link(&mut self, src: &CString, dst: &CString) -> Result<(), IoError> {\n+        do uv_fs_helper(self.uv_loop(), unit) |req, l, cb| {\n+            req.link(l, src, dst, cb)\n+        }\n+    }\n+    fn fs_symlink(&mut self, src: &CString, dst: &CString) -> Result<(), IoError> {\n+        do uv_fs_helper(self.uv_loop(), unit) |req, l, cb| {\n+            req.symlink(l, src, dst, cb)\n+        }\n+    }\n+    fn fs_chown(&mut self, path: &CString, uid: int, gid: int) -> Result<(), IoError> {\n+        do uv_fs_helper(self.uv_loop(), unit) |req, l, cb| {\n+            req.chown(l, path, uid, gid, cb)\n+        }\n+    }\n+    fn fs_readlink(&mut self, path: &CString) -> Result<Path, IoError> {\n+        fn getlink(f: &mut FsRequest) -> Path {\n+            Path::new(unsafe { CString::new(f.get_path(), false) })\n+        }\n+        do uv_fs_helper(self.uv_loop(), getlink) |req, l, cb| {\n+            req.readlink(l, path, cb)\n+        }\n+    }\n \n     fn spawn(&mut self, config: ProcessConfig)\n             -> Result<(~RtioProcess, ~[Option<~RtioPipe>]), IoError>\n@@ -1581,26 +1578,9 @@ impl UvFileStream {\n         result_cell.take()\n     }\n     fn base_write(&mut self, buf: &[u8], offset: i64) -> Result<(), IoError> {\n-        let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n-        let buf_ptr: *&[u8] = &buf;\n-        do self.home_for_io_with_sched |self_, scheduler| {\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n-                let task_cell = Cell::new(task);\n-                let write_req = file::FsRequest::new();\n-                do write_req.write(&self_.loop_, self_.fd, buf, offset) |_, uverr| {\n-                    let res = match uverr  {\n-                        None => Ok(()),\n-                        Some(err) => Err(uv_error_to_io_error(err))\n-                    };\n-                    unsafe { (*result_cell_ptr).put_back(res); }\n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n-                }\n-            }\n+        do self.nop_req |self_, req, cb| {\n+            req.write(&self_.loop_, self_.fd, slice_to_uv_buf(buf), offset, cb)\n         }\n-        result_cell.take()\n     }\n     fn seek_common(&mut self, pos: i64, whence: c_int) ->\n         Result<u64, IoError>{\n@@ -1618,6 +1598,27 @@ impl UvFileStream {\n             }\n         }\n     }\n+    fn nop_req(&mut self, f: &fn(&mut UvFileStream, file::FsRequest, FsCallback))\n+            -> Result<(), IoError> {\n+        let result_cell = Cell::new_empty();\n+        let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n+        do self.home_for_io_with_sched |self_, sched| {\n+            do sched.deschedule_running_task_and_then |_, task| {\n+                let task = Cell::new(task);\n+                let req = file::FsRequest::new();\n+                do f(self_, req) |_, uverr| {\n+                    let res = match uverr  {\n+                        None => Ok(()),\n+                        Some(err) => Err(uv_error_to_io_error(err))\n+                    };\n+                    unsafe { (*result_cell_ptr).put_back(res); }\n+                    let scheduler: ~Scheduler = Local::take();\n+                    scheduler.resume_blocked_task_immediately(task.take());\n+                }\n+            }\n+        }\n+        result_cell.take()\n+    }\n }\n \n impl Drop for UvFileStream {\n@@ -1672,6 +1673,21 @@ impl RtioFileStream for UvFileStream {\n         let self_ = unsafe { cast::transmute::<&UvFileStream, &mut UvFileStream>(self) };\n         self_.seek_common(0, SEEK_CUR)\n     }\n+    fn fsync(&mut self) -> Result<(), IoError> {\n+        do self.nop_req |self_, req, cb| {\n+            req.fsync(&self_.loop_, self_.fd, cb)\n+        }\n+    }\n+    fn datasync(&mut self) -> Result<(), IoError> {\n+        do self.nop_req |self_, req, cb| {\n+            req.datasync(&self_.loop_, self_.fd, cb)\n+        }\n+    }\n+    fn truncate(&mut self, offset: i64) -> Result<(), IoError> {\n+        do self.nop_req |self_, req, cb| {\n+            req.truncate(&self_.loop_, self_.fd, offset, cb)\n+        }\n+    }\n }\n \n pub struct UvProcess {\n@@ -2489,13 +2505,13 @@ fn test_timer_sleep_simple() {\n }\n \n fn file_test_uvio_full_simple_impl() {\n-    use std::rt::io::{Open, Create, ReadWrite, Read};\n+    use std::rt::io::{Open, ReadWrite, Read};\n     unsafe {\n         let io = local_io();\n         let write_val = \"hello uvio!\";\n         let path = \"./tmp/file_test_uvio_full.txt\";\n         {\n-            let create_fm = Create;\n+            let create_fm = Open;\n             let create_fa = ReadWrite;\n             let mut fd = io.fs_open(&path.to_c_str(), create_fm, create_fa).unwrap();\n             let write_buf = write_val.as_bytes();"}, {"sha": "b8f16db1066dc0b1ad8e58b522d1e10b1f1ff036", "filename": "src/librustuv/uvll.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibrustuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibrustuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvll.rs?ref=f19d0833625c382c5d0a8868924cd4620335e659", "patch": "@@ -222,6 +222,7 @@ pub type uv_exit_cb = extern \"C\" fn(handle: *uv_process_t,\n                                     term_signal: c_int);\n pub type uv_signal_cb = extern \"C\" fn(handle: *uv_signal_t,\n                                       signum: c_int);\n+pub type uv_fs_cb = extern \"C\" fn(req: *uv_fs_t);\n \n pub type sockaddr = c_void;\n pub type sockaddr_in = c_void;\n@@ -886,6 +887,11 @@ pub unsafe fn get_ptr_from_fs_req(req: *uv_fs_t) -> *libc::c_void {\n \n     rust_uv_get_ptr_from_fs_req(req)\n }\n+pub unsafe fn get_path_from_fs_req(req: *uv_fs_t) -> *c_char {\n+    #[fixed_stack_segment]; #[inline(never)];\n+\n+    rust_uv_get_path_from_fs_req(req)\n+}\n pub unsafe fn get_loop_from_fs_req(req: *uv_fs_t) -> *uv_loop_t {\n     #[fixed_stack_segment]; #[inline(never)];\n \n@@ -1129,6 +1135,7 @@ extern {\n     fn rust_uv_populate_uv_stat(req_in: *uv_fs_t, stat_out: *uv_stat_t);\n     fn rust_uv_get_result_from_fs_req(req: *uv_fs_t) -> c_int;\n     fn rust_uv_get_ptr_from_fs_req(req: *uv_fs_t) -> *libc::c_void;\n+    fn rust_uv_get_path_from_fs_req(req: *uv_fs_t) -> *c_char;\n     fn rust_uv_get_loop_from_fs_req(req: *uv_fs_t) -> *uv_loop_t;\n     fn rust_uv_get_loop_from_getaddrinfo_req(req: *uv_fs_t) -> *uv_loop_t;\n \n@@ -1189,7 +1196,24 @@ extern {\n                             signal_cb: uv_signal_cb,\n                             signum: c_int) -> c_int;\n     fn rust_uv_signal_stop(handle: *uv_signal_t) -> c_int;\n+\n }\n+externfn!(fn uv_fs_fsync(handle: *uv_loop_t, req: *uv_fs_t, file: c_int,\n+                         cb: *u8) -> c_int)\n+externfn!(fn uv_fs_fdatasync(handle: *uv_loop_t, req: *uv_fs_t, file: c_int,\n+                             cb: *u8) -> c_int)\n+externfn!(fn uv_fs_ftruncate(handle: *uv_loop_t, req: *uv_fs_t, file: c_int,\n+                             offset: i64, cb: *u8) -> c_int)\n+externfn!(fn uv_fs_readlink(handle: *uv_loop_t, req: *uv_fs_t, file: *c_char,\n+                            cb: *u8) -> c_int)\n+externfn!(fn uv_fs_symlink(handle: *uv_loop_t, req: *uv_fs_t, src: *c_char,\n+                           dst: *c_char, cb: *u8) -> c_int)\n+externfn!(fn uv_fs_link(handle: *uv_loop_t, req: *uv_fs_t, src: *c_char,\n+                        dst: *c_char, cb: *u8) -> c_int)\n+externfn!(fn uv_fs_chown(handle: *uv_loop_t, req: *uv_fs_t, src: *c_char,\n+                         uid: uv_uid_t, gid: uv_gid_t, cb: *u8) -> c_int)\n+externfn!(fn uv_fs_lstat(handle: *uv_loop_t, req: *uv_fs_t, file: *c_char,\n+                         cb: *u8) -> c_int)\n \n // libuv requires various system libraries to successfully link on some\n // platforms"}, {"sha": "f992b327495b55bef2b752d2bfe99451299f94bf", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=f19d0833625c382c5d0a8868924cd4620335e659", "patch": "@@ -142,7 +142,7 @@ pub use libc::consts::os::c95::{SEEK_SET, TMP_MAX};\n pub use libc::consts::os::posix88::{F_OK, O_APPEND, O_CREAT, O_EXCL};\n pub use libc::consts::os::posix88::{O_RDONLY, O_RDWR, O_TRUNC, O_WRONLY};\n pub use libc::consts::os::posix88::{R_OK, S_IEXEC, S_IFBLK, S_IFCHR};\n-pub use libc::consts::os::posix88::{S_IFDIR, S_IFIFO, S_IFMT, S_IFREG};\n+pub use libc::consts::os::posix88::{S_IFDIR, S_IFIFO, S_IFMT, S_IFREG, S_IFLNK};\n pub use libc::consts::os::posix88::{S_IREAD, S_IRUSR, S_IRWXU, S_IWUSR};\n pub use libc::consts::os::posix88::{STDERR_FILENO, STDIN_FILENO};\n pub use libc::consts::os::posix88::{STDOUT_FILENO, W_OK, X_OK};\n@@ -1168,6 +1168,7 @@ pub mod consts {\n             pub static S_IFBLK : c_int = 12288;\n             pub static S_IFDIR : c_int = 16384;\n             pub static S_IFREG : c_int = 32768;\n+            pub static S_IFLNK : c_int = 40960;\n             pub static S_IFMT : c_int = 61440;\n             pub static S_IEXEC : c_int = 64;\n             pub static S_IWRITE : c_int = 128;\n@@ -1345,6 +1346,7 @@ pub mod consts {\n             pub static S_IFBLK : c_int = 24576;\n             pub static S_IFDIR : c_int = 16384;\n             pub static S_IFREG : c_int = 32768;\n+            pub static S_IFLNK : c_int = 40960;\n             pub static S_IFMT : c_int = 61440;\n             pub static S_IEXEC : c_int = 64;\n             pub static S_IWRITE : c_int = 128;\n@@ -1555,6 +1557,7 @@ pub mod consts {\n             pub static S_IFBLK : c_int = 24576;\n             pub static S_IFDIR : c_int = 16384;\n             pub static S_IFREG : c_int = 32768;\n+            pub static S_IFLNK : c_int = 40960;\n             pub static S_IFMT : c_int = 61440;\n             pub static S_IEXEC : c_int = 64;\n             pub static S_IWRITE : c_int = 128;\n@@ -1999,6 +2002,7 @@ pub mod consts {\n             pub static S_IFBLK : c_int = 24576;\n             pub static S_IFDIR : c_int = 16384;\n             pub static S_IFREG : c_int = 32768;\n+            pub static S_IFLNK : c_int = 40960;\n             pub static S_IFMT : c_int = 61440;\n             pub static S_IEXEC : c_int = 64;\n             pub static S_IWRITE : c_int = 128;\n@@ -2341,6 +2345,7 @@ pub mod consts {\n             pub static S_IFBLK : c_int = 24576;\n             pub static S_IFDIR : c_int = 16384;\n             pub static S_IFREG : c_int = 32768;\n+            pub static S_IFLNK : c_int = 40960;\n             pub static S_IFMT : c_int = 61440;\n             pub static S_IEXEC : c_int = 64;\n             pub static S_IWRITE : c_int = 128;"}, {"sha": "f461781e13251af089c6eddce8cc9a06a44e1aeb", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=f19d0833625c382c5d0a8868924cd4620335e659", "patch": "@@ -1495,7 +1495,7 @@ mod tests {\n         use result::{Ok, Err};\n         use os::*;\n         use libc::*;\n-        use rt::io::file;\n+        use rt::io::File;\n \n         #[cfg(unix)]\n         #[fixed_stack_segment]\n@@ -1544,7 +1544,7 @@ mod tests {\n             assert!(*chunk.data == 0xbe);\n             close(fd);\n         }\n-        file::unlink(&path);\n+        File::unlink(&path);\n     }\n \n     // More recursive_mkdir tests are in extra::tempfile"}, {"sha": "8483b504c0137fee61ea1057fb8f30c0caa2c11e", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=f19d0833625c382c5d0a8868924cd4620335e659", "patch": "@@ -23,9 +23,6 @@ use to_bytes::IterBytes;\n use vec::Vector;\n use super::{contains_nul, BytesContainer, GenericPath, GenericPathUnsafe};\n \n-#[cfg(target_os = \"win32\")]\n-use rt::io::{FileStat, file, io_error};\n-\n /// Iterator that yields successive components of a Path as &str\n ///\n /// Each component is yielded as Option<&str> for compatibility with PosixPath, but\n@@ -1056,67 +1053,6 @@ fn prefix_is_sep(p: Option<PathPrefix>, c: u8) -> bool {\n                     else { is_sep_verbatim(c as char) }\n }\n \n-// Stat support\n-#[cfg(target_os = \"win32\")]\n-impl Path {\n-    /// Calls stat() on the represented file and returns the resulting rt::io::FileStat\n-    pub fn stat(&self) -> Option<FileStat> {\n-        let mut file_stat: Option<FileStat> = None;\n-        do io_error::cond.trap(|_| { /* Ignore error, will return None */ }).inside {\n-            file_stat = file::stat(self);\n-        }\n-        file_stat\n-    }\n-\n-    /// Returns whether the represented file exists\n-    pub fn exists(&self) -> bool {\n-        match self.stat() {\n-            None => false,\n-            Some(_) => true\n-        }\n-    }\n-\n-    /// Returns the filesize of the represented file\n-    pub fn get_size(&self) -> Option<u64> {\n-        match self.stat() {\n-            None => None,\n-            Some(st) => Some(st.size)\n-        }\n-    }\n-\n-    /// Returns the mode of the represented file\n-    pub fn get_mode(&self) -> Option<uint> {\n-        match self.stat() {\n-            None => None,\n-            Some(st) => Some(st.mode as uint)\n-        }\n-    }\n-\n-    /// Returns the atime of the represented file, as msecs\n-    pub fn get_atime(&self) -> Option<u64> {\n-        match self.stat() {\n-            None => None,\n-            Some(st) => Some(st.accessed)\n-        }\n-    }\n-\n-    /// Returns the mtime of the represented file, as msecs\n-    pub fn get_mtime(&self) -> Option<u64> {\n-        match self.stat() {\n-            None => None,\n-            Some(st) => Some(st.modified)\n-        }\n-    }\n-\n-    /// Returns the ctime of the represented file, as msecs\n-    pub fn get_ctime(&self) -> Option<u64> {\n-        match self.stat() {\n-            None => None,\n-            Some(st) => Some(st.created)\n-        }\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use super::*;"}, {"sha": "a6d05ea307cdb9bb0351de8b2c14aaf1abc4ea43", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=f19d0833625c382c5d0a8868924cd4620335e659", "patch": "@@ -13,12 +13,11 @@\n \n use rand::Rng;\n use ops::Drop;\n-use path::Path;\n \n #[cfg(unix)]\n use rand::reader::ReaderRng;\n #[cfg(unix)]\n-use rt::io::file;\n+use rt::io::File;\n \n #[cfg(windows)]\n use cast;\n@@ -41,7 +40,7 @@ type HCRYPTPROV = c_long;\n /// This does not block.\n #[cfg(unix)]\n pub struct OSRng {\n-    priv inner: ReaderRng<file::FileReader>\n+    priv inner: ReaderRng<File>\n }\n /// A random number generator that retrieves randomness straight from\n /// the operating system. Platform sources:\n@@ -61,7 +60,8 @@ impl OSRng {\n     /// Create a new `OSRng`.\n     #[cfg(unix)]\n     pub fn new() -> OSRng {\n-        let reader = file::open(&Path::new(\"/dev/urandom\"));\n+        use path::Path;\n+        let reader = File::open(&Path::new(\"/dev/urandom\"));\n         let reader = reader.expect(\"Error opening /dev/urandom\");\n         let reader_rng = ReaderRng::new(reader);\n "}, {"sha": "c3f5f38721151047365c762867207d817de14e65", "filename": "src/libstd/rt/io/file.rs", "status": "modified", "additions": 809, "deletions": 525, "changes": 1334, "blob_url": "https://github.com/rust-lang/rust/blob/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ffile.rs?ref=f19d0833625c382c5d0a8868924cd4620335e659", "patch": "@@ -16,7 +16,7 @@ with regular files & directories on a filesystem.\n At the top-level of the module are a set of freestanding functions, associated\n with various filesystem operations. They all operate on a `Path` object.\n \n-All operations in this module, including those as part of `FileStream` et al\n+All operations in this module, including those as part of `File` et al\n block the task during execution. Most will raise `std::rt::io::io_error`\n conditions in the event of failure.\n \n@@ -28,66 +28,40 @@ particular bits of it, etc.\n */\n \n use c_str::ToCStr;\n+use iter::Iterator;\n use super::{Reader, Writer, Seek};\n-use super::{SeekStyle, Read, Write, Open, CreateOrTruncate,\n+use super::{SeekStyle, Read, Write, Open, IoError, Truncate,\n             FileMode, FileAccess, FileStat, io_error, FilePermission};\n use rt::rtio::{RtioFileStream, IoFactory, with_local_io};\n use rt::io;\n use option::{Some, None, Option};\n-use result::{Ok, Err};\n+use result::{Ok, Err, Result};\n use path;\n use path::{Path, GenericPath};\n+use vec::OwnedVector;\n \n-/// Open a file for reading/writing, as indicated by `path`.\n-///\n-/// # Example\n-///\n-///     use std::rt::{io, file, io_error};\n-///\n-///     let p = Path::new(\"/some/file/path.txt\");\n-///\n-///     do io_error::cond.trap(|_| {\n-///         // hoo-boy...\n-///     }).inside {\n-///         let stream = match file::open_stream(&p, io::Create, io::ReadWrite) {\n-///             Some(s) => s,\n-///             None => fail!(\"whoops! I'm sure this raised, anyways..\")\n-///         };\n-///         // do some stuff with that stream\n-///\n-///         // the file stream will be closed at the end of this block\n-///     }\n-///     // ..\n-///\n-/// `FileMode` and `FileAccess` provide information about the permissions\n-/// context in which a given stream is created. More information about them\n-/// can be found in `std::rt::io`'s docs.\n+/// Unconstrained file access type that exposes read and write operations\n ///\n-/// Note that, with this function, a `FileStream` is returned regardless of\n-/// the access-limitations indicated by `FileAccess` (e.g. calling `write` on a\n-/// `FileStream` opened as `ReadOnly` will raise an `io_error` condition at\n-/// runtime). If you desire a more-correctly-constrained interface to files,\n-/// use the `{open_stream, open, create}` methods that are a part of `Path`.\n+/// Can be retreived via `File::open()` and `Path.File::open_mode()`.\n ///\n /// # Errors\n ///\n-/// This function will raise an `io_error` condition under a number of different\n-/// circumstances, to include but not limited to:\n+/// This type will raise an io_error condition if operations are attempted against\n+/// it for which its underlying file descriptor was not configured at creation\n+/// time, via the `FileAccess` parameter to `file::open()`.\n ///\n-/// * Opening a file that already exists with `FileMode` of `Create` or vice\n-///   versa (e.g.  opening a non-existant file with `FileMode` or `Open`)\n-/// * Attempting to open a file with a `FileAccess` that the user lacks\n-///   permissions for\n-/// * Filesystem-level errors (full disk, etc)\n-pub fn open_stream(path: &Path,\n-                   mode: FileMode,\n-                   access: FileAccess) -> Option<FileStream> {\n+/// For this reason, it is best to use the access-constrained wrappers that are\n+/// exposed via `Path.open()` and `Path.create()`.\n+pub struct File {\n+    priv fd: ~RtioFileStream,\n+    priv path: Path,\n+    priv last_nread: int,\n+}\n+\n+fn io_raise<T>(f: &fn(io: &mut IoFactory) -> Result<T, IoError>) -> Option<T> {\n     do with_local_io |io| {\n-        match io.fs_open(&path.to_c_str(), mode, access) {\n-            Ok(fd) => Some(FileStream {\n-                fd: fd,\n-                last_nread: -1\n-            }),\n+        match f(io) {\n+            Ok(t) => Some(t),\n             Err(ioerr) => {\n                 io_error::cond.raise(ioerr);\n                 None\n@@ -96,54 +70,367 @@ pub fn open_stream(path: &Path,\n     }\n }\n \n-/// Attempts to open a file in read-only mode. This function is equivalent to\n-/// `open_stream(path, Open, Read)`, and will raise all of the same errors that\n-/// `open_stream` does.\n-///\n-/// For more information, see the `open_stream` function.\n-pub fn open(path: &Path) -> Option<FileReader> {\n-    open_stream(path, Open, Read).map(|s| FileReader { stream: s })\n-}\n+impl File {\n+    /// Open a file at `path` in the mode specified by the `mode` and `access`\n+    /// arguments\n+    ///\n+    /// # Example\n+    ///\n+    ///     use std::rt::io::{File, io_error, Open, ReadWrite};\n+    ///\n+    ///     let p = Path::new(\"/some/file/path.txt\");\n+    ///\n+    ///     do io_error::cond.trap(|_| {\n+    ///         // hoo-boy...\n+    ///     }).inside {\n+    ///         let file = match File::open_mode(&p, Open, ReadWrite) {\n+    ///             Some(s) => s,\n+    ///             None => fail!(\"whoops! I'm sure this raised, anyways..\")\n+    ///         };\n+    ///         // do some stuff with that file\n+    ///\n+    ///         // the file will be closed at the end of this block\n+    ///     }\n+    ///     // ..\n+    ///\n+    /// `FileMode` and `FileAccess` provide information about the permissions\n+    /// context in which a given stream is created. More information about them\n+    /// can be found in `std::rt::io`'s docs. If a file is opened with `Write`\n+    /// or `ReadWrite` access, then it will be created it it does not already\n+    /// exist.\n+    ///\n+    /// Note that, with this function, a `File` is returned regardless of the\n+    /// access-limitations indicated by `FileAccess` (e.g. calling `write` on a\n+    /// `File` opened as `Read` will raise an `io_error` condition at runtime).\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function will raise an `io_error` condition under a number of\n+    /// different circumstances, to include but not limited to:\n+    ///\n+    /// * Opening a file that does not exist with `Read` access.\n+    /// * Attempting to open a file with a `FileAccess` that the user lacks\n+    ///   permissions for\n+    /// * Filesystem-level errors (full disk, etc)\n+    pub fn open_mode(path: &Path,\n+                     mode: FileMode,\n+                     access: FileAccess) -> Option<File> {\n+        do with_local_io |io| {\n+            match io.fs_open(&path.to_c_str(), mode, access) {\n+                Ok(fd) => Some(File {\n+                    path: path.clone(),\n+                    fd: fd,\n+                    last_nread: -1\n+                }),\n+                Err(ioerr) => {\n+                    io_error::cond.raise(ioerr);\n+                    None\n+                }\n+            }\n+        }\n+    }\n \n-/// Attempts to create a file in write-only mode. This function is equivalent to\n-/// `open_stream(path, CreateOrTruncate, Write)`, and will raise all of the\n-/// same errors that `open_stream` does.\n-///\n-/// For more information, see the `open_stream` function.\n-pub fn create(path: &Path) -> Option<FileWriter> {\n-    open_stream(path, CreateOrTruncate, Write).map(|s| FileWriter { stream: s })\n-}\n+    /// Attempts to open a file in read-only mode. This function is equivalent to\n+    /// `File::open_mode(path, Open, Read)`, and will raise all of the same\n+    /// errors that `File::open_mode` does.\n+    ///\n+    /// For more information, see the `File::open_mode` function.\n+    ///\n+    /// # Example\n+    ///\n+    ///     use std::rt::io::File;\n+    ///\n+    ///     let contents = File::open(\"foo.txt\").read_to_end();\n+    pub fn open(path: &Path) -> Option<File> {\n+        File::open_mode(path, Open, Read)\n+    }\n \n-/// Unlink a file from the underlying filesystem.\n-///\n-/// # Example\n-///\n-///     use std::rt::io::file;\n-///\n-///     let p = Path::new(\"/some/file/path.txt\");\n-///     file::unlink(&p);\n-///     // if we made it here without failing, then the\n-///     // unlink operation was successful\n-///\n-/// Note that, just because an unlink call was successful, it is not\n-/// guaranteed that a file is immediately deleted (e.g. depending on\n-/// platform, other open file descriptors may prevent immediate removal)\n-///\n-/// # Errors\n-///\n-/// This function will raise an `io_error` condition if the path points to a\n-/// directory, the user lacks permissions to remove the file, or if some other\n-/// filesystem-level error occurs.\n-pub fn unlink(path: &Path) {\n-    do with_local_io |io| {\n-        match io.fs_unlink(&path.to_c_str()) {\n-            Ok(()) => Some(()),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n+    /// Attempts to create a file in write-only mode. This function is\n+    /// equivalent to `File::open_mode(path, Truncate, Write)`, and will\n+    /// raise all of the same errors that `File::open_mode` does.\n+    ///\n+    /// For more information, see the `File::open_mode` function.\n+    ///\n+    /// # Example\n+    ///\n+    ///     use std::rt::io::File;\n+    ///\n+    ///     File::create(\"foo.txt\").write(bytes!(\"This is a sample file\"));\n+    pub fn create(path: &Path) -> Option<File> {\n+        File::open_mode(path, Truncate, Write)\n+    }\n+\n+    /// Unlink a file from the underlying filesystem.\n+    ///\n+    /// # Example\n+    ///\n+    ///     use std::rt::io::File;\n+    ///\n+    ///     let p = Path::new(\"/some/file/path.txt\");\n+    ///     File::unlink(&p);\n+    ///     // if we made it here without failing, then the\n+    ///     // unlink operation was successful\n+    ///\n+    /// Note that, just because an unlink call was successful, it is not\n+    /// guaranteed that a file is immediately deleted (e.g. depending on\n+    /// platform, other open file descriptors may prevent immediate removal)\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function will raise an `io_error` condition if the path points to a\n+    /// directory, the user lacks permissions to remove the file, or if some\n+    /// other filesystem-level error occurs.\n+    pub fn unlink(path: &Path) {\n+        do io_raise |io| { io.fs_unlink(&path.to_c_str()) };\n+    }\n+\n+    /// Given a path, query the file system to get information about a file,\n+    /// directory, etc. This function will traverse symlinks to query\n+    /// information about the destination file.\n+    ///\n+    /// Returns a fully-filled out stat structure on succes, and on failure it\n+    /// will return a dummy stat structure (it is expected that the condition\n+    /// raised is handled as well).\n+    ///\n+    /// # Example\n+    ///\n+    ///     use std::rt::io::{File, io_error};\n+    ///\n+    ///     let p = Path::new(\"/some/file/path.txt\");\n+    ///\n+    ///     do io_error::cond.trap(|_| {\n+    ///         // hoo-boy...\n+    ///     }).inside {\n+    ///         let info = File::stat(p);\n+    ///         if info.is_file {\n+    ///             // just imagine the possibilities ...\n+    ///         }\n+    ///     }\n+    ///\n+    /// # Errors\n+    ///\n+    /// This call will raise an `io_error` condition if the user lacks the\n+    /// requisite permissions to perform a `stat` call on the given path or if\n+    /// there is no entry in the filesystem at the provided path.\n+    pub fn stat(path: &Path) -> FileStat {\n+        do io_raise |io| {\n+            io.fs_stat(&path.to_c_str())\n+        }.unwrap_or_else(File::dummystat)\n+    }\n+\n+    fn dummystat() -> FileStat {\n+        FileStat {\n+            path: Path::new(\"\"),\n+            size: 0,\n+            kind: io::TypeFile,\n+            perm: 0,\n+            created: 0,\n+            modified: 0,\n+            accessed: 0,\n+            device: 0,\n+            inode: 0,\n+            rdev: 0,\n+            nlink: 0,\n+            uid: 0,\n+            gid: 0,\n+            blksize: 0,\n+            blocks: 0,\n+            flags: 0,\n+            gen: 0,\n+        }\n+    }\n+\n+    /// Perform the same operation as the `stat` function, except that this\n+    /// function does not traverse through symlinks. This will return\n+    /// information about the symlink file instead of the file that it points\n+    /// to.\n+    ///\n+    /// # Errors\n+    ///\n+    /// See `stat`\n+    pub fn lstat(path: &Path) -> FileStat {\n+        do io_raise |io| {\n+            io.fs_lstat(&path.to_c_str())\n+        }.unwrap_or_else(File::dummystat)\n+    }\n+\n+    /// Rename a file or directory to a new name.\n+    ///\n+    /// # Example\n+    ///\n+    ///     use std::rt::io::File;\n+    ///\n+    ///     File::rename(Path::new(\"foo\"), Path::new(\"bar\"));\n+    ///     // Oh boy, nothing was raised!\n+    ///\n+    /// # Errors\n+    ///\n+    /// Will raise an `io_error` condition if the provided `path` doesn't exist,\n+    /// the process lacks permissions to view the contents, or if some other\n+    /// intermittent I/O error occurs.\n+    pub fn rename(from: &Path, to: &Path) {\n+        do io_raise |io| {\n+            io.fs_rename(&from.to_c_str(), &to.to_c_str())\n+        };\n+    }\n+\n+    /// Copies the contents of one file to another. This function will also\n+    /// copy the permission bits of the original file to the destination file.\n+    ///\n+    /// Note that if `from` and `to` both point to the same file, then the file\n+    /// will likely get truncated by this operation.\n+    ///\n+    /// # Example\n+    ///\n+    ///     use std::rt::io::File;\n+    ///\n+    ///     File::copy(Path::new(\"foo.txt\"), Path::new(\"bar.txt\"));\n+    ///     // Oh boy, nothing was raised!\n+    ///\n+    /// # Errors\n+    ///\n+    /// Will raise an `io_error` condition is the following situtations, but is\n+    /// not limited to just these cases:\n+    ///\n+    /// * The `from` path is not a file\n+    /// * The `from` file does not exist\n+    /// * The current process does not have the permission rights to access\n+    ///   `from` or write `to`\n+    ///\n+    /// Note that this copy is not atomic in that once the destination is\n+    /// ensured to not exist, the is nothing preventing the destination from\n+    /// being created and then destroyed by this operation.\n+    pub fn copy(from: &Path, to: &Path) {\n+        if !from.is_file() {\n+            return io_error::cond.raise(IoError {\n+                kind: io::MismatchedFileTypeForOperation,\n+                desc: \"the source path is not an existing file\",\n+                detail: None,\n+            });\n+        }\n+\n+        let mut reader = match File::open(from) { Some(f) => f, None => return };\n+        let mut writer = match File::create(to) { Some(f) => f, None => return };\n+        let mut buf = [0, ..io::DEFAULT_BUF_SIZE];\n+\n+        loop {\n+            match reader.read(buf) {\n+                Some(amt) => writer.write(buf.slice_to(amt)),\n+                None => break\n             }\n         }\n-    };\n+\n+        File::chmod(to, from.stat().perm)\n+    }\n+\n+    /// Changes the permission mode bits found on a file or a directory. This\n+    /// function takes a mask from the `io` module\n+    ///\n+    /// # Example\n+    ///\n+    ///     use std::rt::io;\n+    ///     use std::rt::io::File;\n+    ///\n+    ///     File::chmod(&Path::new(\"file.txt\"), io::UserFile);\n+    ///     File::chmod(&Path::new(\"file.txt\"), io::UserRead | io::UserWrite);\n+    ///     File::chmod(&Path::new(\"dir\"),      io::UserDir);\n+    ///     File::chmod(&Path::new(\"file.exe\"), io::UserExec);\n+    ///\n+    /// # Errors\n+    ///\n+    /// If this funciton encounters an I/O error, it will raise on the `io_error`\n+    /// condition. Some possible error situations are not having the permission to\n+    /// change the attributes of a file or the file not existing.\n+    pub fn chmod(path: &Path, mode: io::FilePermission) {\n+        do io_raise |io| {\n+            io.fs_chmod(&path.to_c_str(), mode)\n+        };\n+    }\n+\n+    /// Change the user and group owners of a file at the specified path.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This funtion will raise on the `io_error` condition on failure.\n+    pub fn chown(path: &Path, uid: int, gid: int) {\n+        do io_raise |io| { io.fs_chown(&path.to_c_str(), uid, gid) };\n+    }\n+\n+    /// Creates a new hard link on the filesystem. The `dst` path will be a\n+    /// link pointing to the `src` path. Note that systems often require these\n+    /// two paths to both be located on the same filesystem.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function will raise on the `io_error` condition on failure.\n+    pub fn link(src: &Path, dst: &Path) {\n+        do io_raise |io| { io.fs_link(&src.to_c_str(), &dst.to_c_str()) };\n+    }\n+\n+    /// Creates a new symbolic link on the filesystem. The `dst` path will be a\n+    /// symlink pointing to the `src` path.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function will raise on the `io_error` condition on failure.\n+    pub fn symlink(src: &Path, dst: &Path) {\n+        do io_raise |io| { io.fs_symlink(&src.to_c_str(), &dst.to_c_str()) };\n+    }\n+\n+    /// Reads a symlink, returning the file that the symlink points to.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function will raise on the `io_error` condition on failure.\n+    ///\n+    /// XXX: does this fail if called on files.\n+    pub fn readlink(path: &Path) -> Option<Path> {\n+        do io_raise |io| { io.fs_readlink(&path.to_c_str()) }\n+    }\n+\n+    /// Returns the original path which was used to open this file.\n+    pub fn path<'a>(&'a self) -> &'a Path {\n+        &self.path\n+    }\n+\n+    /// Synchronizes all modifications to this file to its permanent storage\n+    /// device. This will flush any internal buffers necessary to perform this\n+    /// operation.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function will raise on the `io_error` condition on failure.\n+    pub fn fsync(&mut self) {\n+        self.fd.fsync();\n+    }\n+\n+    /// This function is similar to `fsync`, except that it may not synchronize\n+    /// file metadata to the filesystem. This is intended for use case which\n+    /// must synchronize content, but don't need the metadata on disk. The goal\n+    /// of this method is to reduce disk operations.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function will raise on the `io_error` condition on failure.\n+    pub fn datasync(&mut self) {\n+        self.fd.datasync();\n+    }\n+\n+    /// Either truncates or extends the underlying file, as extended from the\n+    /// file's current position. This is equivalent to the unix `truncate`\n+    /// function.\n+    ///\n+    /// The offset given is added to the file's current position and the result\n+    /// is the new size of the file. If the new size is less than the current\n+    /// size, then the file is truncated. If the new size is greater than the\n+    /// current size, then the file is expanded to be filled with 0s.\n+    ///\n+    /// # Errors\n+    ///\n+    /// On error, this function will raise on the `io_error` condition.\n+    pub fn truncate(&mut self, offset: i64) {\n+        self.fd.truncate(offset);\n+    }\n }\n \n /// Create a new, empty directory at the provided path\n@@ -163,14 +450,8 @@ pub fn unlink(path: &Path) {\n /// to make a new directory at the provided path, or if the directory already\n /// exists.\n pub fn mkdir(path: &Path, mode: FilePermission) {\n-    do with_local_io |io| {\n-        match io.fs_mkdir(&path.to_c_str(), mode) {\n-            Ok(_) => Some(()),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n+    do io_raise |io| {\n+        io.fs_mkdir(&path.to_c_str(), mode)\n     };\n }\n \n@@ -190,71 +471,11 @@ pub fn mkdir(path: &Path, mode: FilePermission) {\n /// to remove the directory at the provided path, or if the directory isn't\n /// empty.\n pub fn rmdir(path: &Path) {\n-    do with_local_io |io| {\n-        match io.fs_rmdir(&path.to_c_str()) {\n-            Ok(_) => Some(()),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n+    do io_raise |io| {\n+        io.fs_rmdir(&path.to_c_str())\n     };\n }\n \n-/// Get information on the file, directory, etc at the provided path\n-///\n-/// Given a path, query the file system to get information about a file,\n-/// directory, etc.\n-///\n-/// Returns a fully-filled out stat structure on succes, and on failure it will\n-/// return a dummy stat structure (it is expected that the condition raised is\n-/// handled as well).\n-///\n-/// # Example\n-///\n-///     use std::rt::io::{file, io_error};\n-///\n-///     let p = Path::new(\"/some/file/path.txt\");\n-///\n-///     do io_error::cond.trap(|_| {\n-///         // hoo-boy...\n-///     }).inside {\n-///         let info = file::stat(p);\n-///         if info.is_file {\n-///             // just imagine the possibilities ...\n-///         }\n-///     }\n-///\n-/// # Errors\n-///\n-/// This call will raise an `io_error` condition if the user lacks the requisite\n-/// permissions to perform a `stat` call on the given path or if there is no\n-/// entry in the filesystem at the provided path.\n-pub fn stat(path: &Path) -> FileStat {\n-    do with_local_io |io| {\n-        match io.fs_stat(&path.to_c_str()) {\n-            Ok(p) => Some(p),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n-    }.unwrap_or_else(|| {\n-        FileStat {\n-            path: Path::new(path.to_c_str()),\n-            is_file: false,\n-            is_dir: false,\n-            device: 0,\n-            mode: 0,\n-            inode: 0,\n-            size: 0,\n-            created: 0,\n-            modified: 0,\n-            accessed: 0,\n-        }\n-    })\n-}\n-\n /// Retrieve a vector containing all entries within a provided directory\n ///\n /// # Example\n@@ -278,105 +499,41 @@ pub fn stat(path: &Path) -> FileStat {\n /// the process lacks permissions to view the contents or if the `path` points\n /// at a non-directory file\n pub fn readdir(path: &Path) -> ~[Path] {\n-    do with_local_io |io| {\n-        match io.fs_readdir(&path.to_c_str(), 0) {\n-            Ok(p) => Some(p),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n+    do io_raise |io| {\n+        io.fs_readdir(&path.to_c_str(), 0)\n     }.unwrap_or_else(|| ~[])\n }\n \n-/// Rename a file or directory to a new name.\n-///\n-/// # Example\n-///\n-///     use std::rt::io::file;\n-///\n-///     file::rename(Path::new(\"foo\"), Path::new(\"bar\"));\n-///     // Oh boy, nothing was raised!\n-///\n-/// # Errors\n-///\n-/// Will raise an `io_error` condition if the provided `path` doesn't exist,\n-/// the process lacks permissions to view the contents, or if some other\n-/// intermittent I/O error occurs.\n-pub fn rename(from: &Path, to: &Path) {\n-    do with_local_io |io| {\n-        match io.fs_rename(&from.to_c_str(), &to.to_c_str()) {\n-            Ok(()) => Some(()),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n-    };\n+/// Returns an iterator which will recursively walk the directory structure\n+/// rooted at `path`. The path given will not be iterated over, and this will\n+/// perform iteration in a top-down order.\n+pub fn walk_dir(path: &Path) -> WalkIterator {\n+    WalkIterator { stack: readdir(path) }\n }\n \n-/// Copies the contents of one file to another.\n-///\n-/// # Example\n-///\n-///     use std::rt::io::file;\n-///\n-///     file::copy(Path::new(\"foo.txt\"), Path::new(\"bar.txt\"));\n-///     // Oh boy, nothing was raised!\n-///\n-/// # Errors\n-///\n-/// Will raise an `io_error` condition if the provided `from` doesn't exist,\n-/// the process lacks permissions to view the contents, or if some other\n-/// intermittent I/O error occurs (such as `to` couldn't be created).\n-pub fn copy(from: &Path, to: &Path) {\n-    let mut reader = match open(from) { Some(f) => f, None => return };\n-    let mut writer = match create(to) { Some(f) => f, None => return };\n-    let mut buf = [0, ..io::DEFAULT_BUF_SIZE];\n-\n-    loop {\n-        match reader.read(buf) {\n-            Some(amt) => writer.write(buf.slice_to(amt)),\n-            None => break\n-        }\n-    }\n-\n-    // FIXME(#10131) this is an awful way to pull out the permission bits.\n-    //               If this comment is removed, then there should be a test\n-    //               asserting that permission bits are maintained using the\n-    //               permission interface created.\n-    chmod(to, (from.stat().mode & 0xfff) as u32);\n+/// An iterator which walks over a directory\n+pub struct WalkIterator {\n+    priv stack: ~[Path],\n }\n \n-// This function is not public because it's got a terrible interface for `mode`\n-// FIXME(#10131)\n-fn chmod(path: &Path, mode: u32) {\n-    do with_local_io |io| {\n-        match io.fs_chmod(&path.to_c_str(), mode) {\n-            Ok(()) => Some(()),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n+impl Iterator<Path> for WalkIterator {\n+    fn next(&mut self) -> Option<Path> {\n+        match self.stack.shift_opt() {\n+            Some(path) => {\n+                if path.is_dir() {\n+                    self.stack.push_all_move(readdir(&path));\n+                }\n+                Some(path)\n             }\n+            None => None\n         }\n-    };\n-}\n-\n-/// Recursively walk a directory structure. This function will call the\n-/// provided closure on all directories and files found inside the path\n-/// pointed to by `self`. If the closure returns `false`, then the iteration\n-/// will be short-circuited.\n-pub fn walk_dir(path: &Path, f: &fn(&Path) -> bool) -> bool {\n-    let files = readdir(path);\n-    files.iter().advance(|q| {\n-        f(q) && (!q.is_dir() || walk_dir(q, |p| f(p)))\n-    })\n+    }\n }\n \n /// Recursively create a directory and all of its parent components if they\n /// are missing.\n ///\n-/// # Failure\n+/// # Errors\n ///\n /// This function will raise on the `io_error` condition if an error\n /// happens, see `file::mkdir` for more information about error conditions\n@@ -396,74 +553,25 @@ pub fn mkdir_recursive(path: &Path, mode: FilePermission) {\n /// Removes a directory at this path, after removing all its contents. Use\n /// carefully!\n ///\n-/// # Failure\n+/// # Errors\n ///\n /// This function will raise on the `io_error` condition if an error\n /// happens. See `file::unlink` and `file::readdir` for possible error\n /// conditions.\n pub fn rmdir_recursive(path: &Path) {\n-    do walk_dir(path) |inner| {\n-        if inner.is_dir() {\n-            rmdir_recursive(inner);\n+    let children = readdir(path);\n+    for child in children.iter() {\n+        if child.is_dir() {\n+            rmdir_recursive(child);\n         } else {\n-            unlink(inner);\n+            File::unlink(child);\n         }\n-        true\n-    };\n+    }\n     // Directory should now be empty\n     rmdir(path);\n }\n \n-/// Constrained version of `FileStream` that only exposes read-specific\n-/// operations.\n-///\n-/// Can be retreived via `Path.open()` or `file::open`.\n-pub struct FileReader { priv stream: FileStream }\n-\n-impl Reader for FileReader {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> { self.stream.read(buf) }\n-    fn eof(&mut self) -> bool { self.stream.eof() }\n-}\n-\n-impl Seek for FileReader {\n-    fn tell(&self) -> u64 { self.stream.tell() }\n-    fn seek(&mut self, p: i64, s: SeekStyle) { self.stream.seek(p, s) }\n-}\n-\n-/// Constrained version of `FileStream` that only exposes write-specific\n-/// operations.\n-///\n-/// Can be retreived via `Path.create()` or `file::create`.\n-pub struct FileWriter { priv stream: FileStream }\n-\n-impl Writer for FileWriter {\n-    fn write(&mut self, buf: &[u8]) { self.stream.write(buf); }\n-    fn flush(&mut self) { self.stream.flush(); }\n-}\n-\n-impl Seek for FileWriter {\n-    fn tell(&self) -> u64 { self.stream.tell() }\n-    fn seek(&mut self, p: i64, s: SeekStyle) { self.stream.seek(p, s); }\n-}\n-\n-/// Unconstrained file access type that exposes read and write operations\n-///\n-/// Can be retreived via `file::open()` and `Path.open_stream()`.\n-///\n-/// # Errors\n-///\n-/// This type will raise an io_error condition if operations are attempted against\n-/// it for which its underlying file descriptor was not configured at creation\n-/// time, via the `FileAccess` parameter to `file::open()`.\n-///\n-/// For this reason, it is best to use the access-constrained wrappers that are\n-/// exposed via `Path.open()` and `Path.create()`.\n-pub struct FileStream {\n-    priv fd: ~RtioFileStream,\n-    priv last_nread: int,\n-}\n-\n-impl Reader for FileStream {\n+impl Reader for File {\n     fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n         match self.fd.read(buf) {\n             Ok(read) => {\n@@ -486,18 +594,18 @@ impl Reader for FileStream {\n     fn eof(&mut self) -> bool { self.last_nread == 0 }\n }\n \n-impl Writer for FileStream {\n+impl Writer for File {\n     fn write(&mut self, buf: &[u8]) {\n         match self.fd.write(buf) {\n-            Ok(_) => (),\n+            Ok(()) => (),\n             Err(ioerr) => {\n                 io_error::cond.raise(ioerr);\n             }\n         }\n     }\n }\n \n-impl Seek for FileStream {\n+impl Seek for File {\n     fn tell(&self) -> u64 {\n         let res = self.fd.tell();\n         match res {\n@@ -529,7 +637,7 @@ impl path::Path {\n     /// Consult the `file::stat` documentation for more info.\n     ///\n     /// This call preserves identical runtime/error semantics with `file::stat`.\n-    pub fn stat(&self) -> FileStat { stat(self) }\n+    pub fn stat(&self) -> FileStat { File::stat(self) }\n \n     /// Boolean value indicator whether the underlying file exists on the local\n     /// filesystem. This will return true if the path points to either a\n@@ -552,7 +660,7 @@ impl path::Path {\n     /// Will not raise a condition\n     pub fn is_file(&self) -> bool {\n         match io::result(|| self.stat()) {\n-            Ok(s) => s.is_file,\n+            Ok(s) => s.kind == io::TypeFile,\n             Err(*) => false\n         }\n     }\n@@ -567,27 +675,19 @@ impl path::Path {\n     /// Will not raise a condition\n     pub fn is_dir(&self) -> bool {\n         match io::result(|| self.stat()) {\n-            Ok(s) => s.is_dir,\n+            Ok(s) => s.kind == io::TypeDirectory,\n             Err(*) => false\n         }\n     }\n }\n \n #[cfg(test)]\n mod test {\n-    use path::{Path, GenericPath};\n-    use result::{Ok, Err};\n-    use option::{Some, None};\n-    use iter::range;\n-    use rt::test::run_in_mt_newsched_task;\n-    use super::{open_stream, unlink, stat, copy, rmdir, mkdir, readdir,\n-                open, create, rmdir_recursive, mkdir_recursive};\n-\n+    use prelude::*;\n+    use rt::io::{SeekSet, SeekCur, SeekEnd, io_error, Read, Open, ReadWrite};\n     use rt::io;\n-    use rt::io::Reader;\n-    use super::super::{SeekSet, SeekCur, SeekEnd,\n-                       io_error, Read, Create, Open, ReadWrite};\n-    use vec::Vector;\n+    use str;\n+    use super::{File, rmdir, mkdir, readdir, rmdir_recursive, mkdir_recursive};\n \n     fn tmpdir() -> Path {\n         use os;\n@@ -599,266 +699,236 @@ mod test {\n \n     #[test]\n     fn file_test_io_smoke_test() {\n-        do run_in_mt_newsched_task {\n-            let message = \"it's alright. have a good time\";\n-            let filename = &Path::new(\"./tmp/file_rt_io_file_test.txt\");\n-            {\n-                let mut write_stream = open_stream(filename, Create, ReadWrite);\n-                write_stream.write(message.as_bytes());\n-            }\n-            {\n-                use str;\n-                let mut read_stream = open_stream(filename, Open, Read);\n-                let mut read_buf = [0, .. 1028];\n-                let read_str = match read_stream.read(read_buf).unwrap() {\n-                    -1|0 => fail!(\"shouldn't happen\"),\n-                    n => str::from_utf8(read_buf.slice_to(n))\n-                };\n-                assert!(read_str == message.to_owned());\n-            }\n-            unlink(filename);\n+        let message = \"it's alright. have a good time\";\n+        let filename = &Path::new(\"./tmp/file_rt_io_file_test.txt\");\n+        {\n+            let mut write_stream = File::open_mode(filename, Open, ReadWrite);\n+            write_stream.write(message.as_bytes());\n         }\n+        {\n+            let mut read_stream = File::open_mode(filename, Open, Read);\n+            let mut read_buf = [0, .. 1028];\n+            let read_str = match read_stream.read(read_buf).unwrap() {\n+                -1|0 => fail!(\"shouldn't happen\"),\n+                n => str::from_utf8(read_buf.slice_to(n))\n+            };\n+            assert!(read_str == message.to_owned());\n+        }\n+        File::unlink(filename);\n     }\n \n     #[test]\n     fn file_test_io_invalid_path_opened_without_create_should_raise_condition() {\n-        do run_in_mt_newsched_task {\n-            let filename = &Path::new(\"./tmp/file_that_does_not_exist.txt\");\n-            let mut called = false;\n-            do io_error::cond.trap(|_| {\n-                called = true;\n-            }).inside {\n-                let result = open_stream(filename, Open, Read);\n-                assert!(result.is_none());\n-            }\n-            assert!(called);\n+        let filename = &Path::new(\"./tmp/file_that_does_not_exist.txt\");\n+        let mut called = false;\n+        do io_error::cond.trap(|_| {\n+            called = true;\n+        }).inside {\n+            let result = File::open_mode(filename, Open, Read);\n+            assert!(result.is_none());\n         }\n+        assert!(called);\n     }\n \n     #[test]\n     fn file_test_iounlinking_invalid_path_should_raise_condition() {\n-        do run_in_mt_newsched_task {\n-            let filename = &Path::new(\"./tmp/file_another_file_that_does_not_exist.txt\");\n-            let mut called = false;\n-            do io_error::cond.trap(|_| {\n-                called = true;\n-            }).inside {\n-                unlink(filename);\n-            }\n-            assert!(called);\n+        let filename = &Path::new(\"./tmp/file_another_file_that_does_not_exist.txt\");\n+        let mut called = false;\n+        do io_error::cond.trap(|_| {\n+            called = true;\n+        }).inside {\n+            File::unlink(filename);\n         }\n+        assert!(called);\n     }\n \n     #[test]\n     fn file_test_io_non_positional_read() {\n-        do run_in_mt_newsched_task {\n-            use str;\n-            let message = \"ten-four\";\n-            let mut read_mem = [0, .. 8];\n-            let filename = &Path::new(\"./tmp/file_rt_io_file_test_positional.txt\");\n+        let message = \"ten-four\";\n+        let mut read_mem = [0, .. 8];\n+        let filename = &Path::new(\"./tmp/file_rt_io_file_test_positional.txt\");\n+        {\n+            let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n+            rw_stream.write(message.as_bytes());\n+        }\n+        {\n+            let mut read_stream = File::open_mode(filename, Open, Read);\n             {\n-                let mut rw_stream = open_stream(filename, Create, ReadWrite);\n-                rw_stream.write(message.as_bytes());\n+                let read_buf = read_mem.mut_slice(0, 4);\n+                read_stream.read(read_buf);\n             }\n             {\n-                let mut read_stream = open_stream(filename, Open, Read);\n-                {\n-                    let read_buf = read_mem.mut_slice(0, 4);\n-                    read_stream.read(read_buf);\n-                }\n-                {\n-                    let read_buf = read_mem.mut_slice(4, 8);\n-                    read_stream.read(read_buf);\n-                }\n+                let read_buf = read_mem.mut_slice(4, 8);\n+                read_stream.read(read_buf);\n             }\n-            unlink(filename);\n-            let read_str = str::from_utf8(read_mem);\n-            assert!(read_str == message.to_owned());\n         }\n+        File::unlink(filename);\n+        let read_str = str::from_utf8(read_mem);\n+        assert!(read_str == message.to_owned());\n     }\n \n     #[test]\n     fn file_test_io_seek_and_tell_smoke_test() {\n-        do run_in_mt_newsched_task {\n-            use str;\n-            let message = \"ten-four\";\n-            let mut read_mem = [0, .. 4];\n-            let set_cursor = 4 as u64;\n-            let mut tell_pos_pre_read;\n-            let mut tell_pos_post_read;\n-            let filename = &Path::new(\"./tmp/file_rt_io_file_test_seeking.txt\");\n-            {\n-                let mut rw_stream = open_stream(filename, Create, ReadWrite);\n-                rw_stream.write(message.as_bytes());\n-            }\n-            {\n-                let mut read_stream = open_stream(filename, Open, Read);\n-                read_stream.seek(set_cursor as i64, SeekSet);\n-                tell_pos_pre_read = read_stream.tell();\n-                read_stream.read(read_mem);\n-                tell_pos_post_read = read_stream.tell();\n-            }\n-            unlink(filename);\n-            let read_str = str::from_utf8(read_mem);\n-            assert!(read_str == message.slice(4, 8).to_owned());\n-            assert!(tell_pos_pre_read == set_cursor);\n-            assert!(tell_pos_post_read == message.len() as u64);\n+        let message = \"ten-four\";\n+        let mut read_mem = [0, .. 4];\n+        let set_cursor = 4 as u64;\n+        let mut tell_pos_pre_read;\n+        let mut tell_pos_post_read;\n+        let filename = &Path::new(\"./tmp/file_rt_io_file_test_seeking.txt\");\n+        {\n+            let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n+            rw_stream.write(message.as_bytes());\n+        }\n+        {\n+            let mut read_stream = File::open_mode(filename, Open, Read);\n+            read_stream.seek(set_cursor as i64, SeekSet);\n+            tell_pos_pre_read = read_stream.tell();\n+            read_stream.read(read_mem);\n+            tell_pos_post_read = read_stream.tell();\n         }\n+        File::unlink(filename);\n+        let read_str = str::from_utf8(read_mem);\n+        assert!(read_str == message.slice(4, 8).to_owned());\n+        assert!(tell_pos_pre_read == set_cursor);\n+        assert!(tell_pos_post_read == message.len() as u64);\n     }\n \n     #[test]\n     fn file_test_io_seek_and_write() {\n-        do run_in_mt_newsched_task {\n-            use str;\n-            let initial_msg =   \"food-is-yummy\";\n-            let overwrite_msg =    \"-the-bar!!\";\n-            let final_msg =     \"foo-the-bar!!\";\n-            let seek_idx = 3;\n-            let mut read_mem = [0, .. 13];\n-            let filename = &Path::new(\"./tmp/file_rt_io_file_test_seek_and_write.txt\");\n-            {\n-                let mut rw_stream = open_stream(filename, Create, ReadWrite);\n-                rw_stream.write(initial_msg.as_bytes());\n-                rw_stream.seek(seek_idx as i64, SeekSet);\n-                rw_stream.write(overwrite_msg.as_bytes());\n-            }\n-            {\n-                let mut read_stream = open_stream(filename, Open, Read);\n-                read_stream.read(read_mem);\n-            }\n-            unlink(filename);\n-            let read_str = str::from_utf8(read_mem);\n-            assert!(read_str == final_msg.to_owned());\n+        let initial_msg =   \"food-is-yummy\";\n+        let overwrite_msg =    \"-the-bar!!\";\n+        let final_msg =     \"foo-the-bar!!\";\n+        let seek_idx = 3;\n+        let mut read_mem = [0, .. 13];\n+        let filename = &Path::new(\"./tmp/file_rt_io_file_test_seek_and_write.txt\");\n+        {\n+            let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n+            rw_stream.write(initial_msg.as_bytes());\n+            rw_stream.seek(seek_idx as i64, SeekSet);\n+            rw_stream.write(overwrite_msg.as_bytes());\n         }\n+        {\n+            let mut read_stream = File::open_mode(filename, Open, Read);\n+            read_stream.read(read_mem);\n+        }\n+        File::unlink(filename);\n+        let read_str = str::from_utf8(read_mem);\n+        assert!(read_str == final_msg.to_owned());\n     }\n \n     #[test]\n     fn file_test_io_seek_shakedown() {\n-        do run_in_mt_newsched_task {\n-            use str;          // 01234567890123\n-            let initial_msg =   \"qwer-asdf-zxcv\";\n-            let chunk_one = \"qwer\";\n-            let chunk_two = \"asdf\";\n-            let chunk_three = \"zxcv\";\n-            let mut read_mem = [0, .. 4];\n-            let filename = &Path::new(\"./tmp/file_rt_io_file_test_seek_shakedown.txt\");\n-            {\n-                let mut rw_stream = open_stream(filename, Create, ReadWrite);\n-                rw_stream.write(initial_msg.as_bytes());\n-            }\n-            {\n-                let mut read_stream = open_stream(filename, Open, Read);\n-\n-                read_stream.seek(-4, SeekEnd);\n-                read_stream.read(read_mem);\n-                let read_str = str::from_utf8(read_mem);\n-                assert!(read_str == chunk_three.to_owned());\n-\n-                read_stream.seek(-9, SeekCur);\n-                read_stream.read(read_mem);\n-                let read_str = str::from_utf8(read_mem);\n-                assert!(read_str == chunk_two.to_owned());\n-\n-                read_stream.seek(0, SeekSet);\n-                read_stream.read(read_mem);\n-                let read_str = str::from_utf8(read_mem);\n-                assert!(read_str == chunk_one.to_owned());\n-            }\n-            unlink(filename);\n+        use std::str;          // 01234567890123\n+        let initial_msg =   \"qwer-asdf-zxcv\";\n+        let chunk_one = \"qwer\";\n+        let chunk_two = \"asdf\";\n+        let chunk_three = \"zxcv\";\n+        let mut read_mem = [0, .. 4];\n+        let filename = &Path::new(\"./tmp/file_rt_io_file_test_seek_shakedown.txt\");\n+        {\n+            let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n+            rw_stream.write(initial_msg.as_bytes());\n         }\n+        {\n+            let mut read_stream = File::open_mode(filename, Open, Read);\n+\n+            read_stream.seek(-4, SeekEnd);\n+            read_stream.read(read_mem);\n+            let read_str = str::from_utf8(read_mem);\n+            assert!(read_str == chunk_three.to_owned());\n+\n+            read_stream.seek(-9, SeekCur);\n+            read_stream.read(read_mem);\n+            let read_str = str::from_utf8(read_mem);\n+            assert!(read_str == chunk_two.to_owned());\n+\n+            read_stream.seek(0, SeekSet);\n+            read_stream.read(read_mem);\n+            let read_str = str::from_utf8(read_mem);\n+            assert!(read_str == chunk_one.to_owned());\n+        }\n+        File::unlink(filename);\n     }\n \n     #[test]\n     fn file_test_stat_is_correct_on_is_file() {\n-        do run_in_mt_newsched_task {\n-            let filename = &Path::new(\"./tmp/file_stat_correct_on_is_file.txt\");\n-            {\n-                let mut fs = open_stream(filename, Create, ReadWrite);\n-                let msg = \"hw\";\n-                fs.write(msg.as_bytes());\n-            }\n-            let stat_res = stat(filename);\n-            assert!(stat_res.is_file);\n-            unlink(filename);\n+        let filename = &Path::new(\"./tmp/file_stat_correct_on_is_file.txt\");\n+        {\n+            let mut fs = File::open_mode(filename, Open, ReadWrite);\n+            let msg = \"hw\";\n+            fs.write(msg.as_bytes());\n         }\n+        let stat_res = File::stat(filename);\n+        assert_eq!(stat_res.kind, io::TypeFile);\n+        File::unlink(filename);\n     }\n \n     #[test]\n     fn file_test_stat_is_correct_on_is_dir() {\n-        do run_in_mt_newsched_task {\n-            let filename = &Path::new(\"./tmp/file_stat_correct_on_is_dir\");\n-            mkdir(filename, io::UserRWX);\n-            let stat_res = filename.stat();\n-            assert!(stat_res.is_dir);\n-            rmdir(filename);\n-        }\n+        let filename = &Path::new(\"./tmp/file_stat_correct_on_is_dir\");\n+        mkdir(filename, io::UserRWX);\n+        let stat_res = filename.stat();\n+        assert!(stat_res.kind == io::TypeDirectory);\n+        rmdir(filename);\n     }\n \n     #[test]\n     fn file_test_fileinfo_false_when_checking_is_file_on_a_directory() {\n-        do run_in_mt_newsched_task {\n-            let dir = &Path::new(\"./tmp/fileinfo_false_on_dir\");\n-            mkdir(dir, io::UserRWX);\n-            assert!(dir.is_file() == false);\n-            rmdir(dir);\n-        }\n+        let dir = &Path::new(\"./tmp/fileinfo_false_on_dir\");\n+        mkdir(dir, io::UserRWX);\n+        assert!(dir.is_file() == false);\n+        rmdir(dir);\n     }\n \n     #[test]\n     fn file_test_fileinfo_check_exists_before_and_after_file_creation() {\n-        do run_in_mt_newsched_task {\n-            let file = &Path::new(\"./tmp/fileinfo_check_exists_b_and_a.txt\");\n-            create(file).write(bytes!(\"foo\"));\n-            assert!(file.exists());\n-            unlink(file);\n-            assert!(!file.exists());\n-        }\n+        let file = &Path::new(\"./tmp/fileinfo_check_exists_b_and_a.txt\");\n+        File::create(file).write(bytes!(\"foo\"));\n+        assert!(file.exists());\n+        File::unlink(file);\n+        assert!(!file.exists());\n     }\n \n     #[test]\n     fn file_test_directoryinfo_check_exists_before_and_after_mkdir() {\n-        do run_in_mt_newsched_task {\n-            let dir = &Path::new(\"./tmp/before_and_after_dir\");\n-            assert!(!dir.exists());\n-            mkdir(dir, io::UserRWX);\n-            assert!(dir.exists());\n-            assert!(dir.is_dir());\n-            rmdir(dir);\n-            assert!(!dir.exists());\n-        }\n+        let dir = &Path::new(\"./tmp/before_and_after_dir\");\n+        assert!(!dir.exists());\n+        mkdir(dir, io::UserRWX);\n+        assert!(dir.exists());\n+        assert!(dir.is_dir());\n+        rmdir(dir);\n+        assert!(!dir.exists());\n     }\n \n     #[test]\n     fn file_test_directoryinfo_readdir() {\n-        use str;\n-        do run_in_mt_newsched_task {\n-            let dir = &Path::new(\"./tmp/di_readdir\");\n-            mkdir(dir, io::UserRWX);\n-            let prefix = \"foo\";\n-            for n in range(0,3) {\n-                let f = dir.join(format!(\"{}.txt\", n));\n-                let mut w = create(&f);\n-                let msg_str = (prefix + n.to_str().to_owned()).to_owned();\n-                let msg = msg_str.as_bytes();\n-                w.write(msg);\n-            }\n-            let files = readdir(dir);\n-            let mut mem = [0u8, .. 4];\n-            for f in files.iter() {\n-                {\n-                    let n = f.filestem_str();\n-                    open(f).read(mem);\n-                    let read_str = str::from_utf8(mem);\n-                    let expected = match n {\n-                        None|Some(\"\") => fail!(\"really shouldn't happen..\"),\n-                        Some(n) => prefix+n\n-                    };\n-                    assert!(expected == read_str);\n-                }\n-                unlink(f);\n+        use std::str;\n+        let dir = &Path::new(\"./tmp/di_readdir\");\n+        mkdir(dir, io::UserRWX);\n+        let prefix = \"foo\";\n+        for n in range(0,3) {\n+            let f = dir.join(format!(\"{}.txt\", n));\n+            let mut w = File::create(&f);\n+            let msg_str = (prefix + n.to_str().to_owned()).to_owned();\n+            let msg = msg_str.as_bytes();\n+            w.write(msg);\n+        }\n+        let files = readdir(dir);\n+        let mut mem = [0u8, .. 4];\n+        for f in files.iter() {\n+            {\n+                let n = f.filestem_str();\n+                File::open(f).read(mem);\n+                let read_str = str::from_utf8(mem);\n+                let expected = match n {\n+                    None|Some(\"\") => fail!(\"really shouldn't happen..\"),\n+                    Some(n) => prefix+n\n+                };\n+                assert!(expected == read_str);\n             }\n-            rmdir(dir);\n+            File::unlink(f);\n         }\n+        rmdir(dir);\n     }\n \n     #[test]\n@@ -880,7 +950,7 @@ mod test {\n \n         let mut filepath = dirpath;\n         filepath.push(\"unicode-file-\\uac00\\u4e00\\u30fc\\u4f60\\u597d.rs\");\n-        create(&filepath); // ignore return; touch only\n+        File::create(&filepath); // ignore return; touch only\n         assert!(!filepath.is_dir());\n         assert!(filepath.exists());\n \n@@ -905,7 +975,7 @@ mod test {\n     fn copy_file_does_not_exist() {\n         let from = Path::new(\"test/nonexistent-bogus-path\");\n         let to = Path::new(\"test/other-bogus-path\");\n-        match io::result(|| copy(&from, &to)) {\n+        match io::result(|| File::copy(&from, &to)) {\n             Ok(*) => fail!(),\n             Err(*) => {\n                 assert!(!from.exists());\n@@ -920,12 +990,226 @@ mod test {\n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n \n-        create(&input).write(bytes!(\"hello\"));\n-        copy(&input, &out);\n-        let contents = open(&out).read_to_end();\n+        File::create(&input).write(bytes!(\"hello\"));\n+        File::copy(&input, &out);\n+        let contents = File::open(&out).read_to_end();\n         assert_eq!(contents.as_slice(), bytes!(\"hello\"));\n \n-        assert_eq!(input.stat().mode, out.stat().mode);\n+        assert_eq!(input.stat().perm, out.stat().perm);\n+        rmdir_recursive(&tmpdir);\n+    }\n+\n+    #[test]\n+    fn copy_file_dst_dir() {\n+        let tmpdir = tmpdir();\n+        let out = tmpdir.join(\"out\");\n+\n+        File::create(&out);\n+        match io::result(|| File::copy(&out, &tmpdir)) {\n+            Ok(*) => fail!(), Err(*) => {}\n+        }\n+        rmdir_recursive(&tmpdir);\n+    }\n+\n+    #[test]\n+    fn copy_file_dst_exists() {\n+        let tmpdir = tmpdir();\n+        let input = tmpdir.join(\"in\");\n+        let output = tmpdir.join(\"out\");\n+\n+        File::create(&input).write(\"foo\".as_bytes());\n+        File::create(&output).write(\"bar\".as_bytes());\n+        File::copy(&input, &output);\n+\n+        assert_eq!(File::open(&output).read_to_end(),\n+                   (bytes!(\"foo\")).to_owned());\n+\n+        rmdir_recursive(&tmpdir);\n+    }\n+\n+    #[test]\n+    fn copy_file_src_dir() {\n+        let tmpdir = tmpdir();\n+        let out = tmpdir.join(\"out\");\n+\n+        match io::result(|| File::copy(&tmpdir, &out)) {\n+            Ok(*) => fail!(), Err(*) => {}\n+        }\n+        assert!(!out.exists());\n+        rmdir_recursive(&tmpdir);\n+    }\n+\n+    #[test]\n+    fn copy_file_preserves_perm_bits() {\n+        let tmpdir = tmpdir();\n+        let input = tmpdir.join(\"in.txt\");\n+        let out = tmpdir.join(\"out.txt\");\n+\n+        File::create(&input);\n+        File::chmod(&input, io::UserExec);\n+        File::copy(&input, &out);\n+        assert_eq!(out.stat().perm, io::UserExec);\n+\n+        rmdir_recursive(&tmpdir);\n+    }\n+\n+    #[test]\n+    fn symlinks_work() {\n+        let tmpdir = tmpdir();\n+        let input = tmpdir.join(\"in.txt\");\n+        let out = tmpdir.join(\"out.txt\");\n+\n+        File::create(&input).write(\"foobar\".as_bytes());\n+        File::symlink(&input, &out);\n+        assert_eq!(File::lstat(&out).kind, io::TypeSymlink);\n+        assert_eq!(File::stat(&out).size, File::stat(&input).size);\n+        assert_eq!(File::open(&out).read_to_end(), (bytes!(\"foobar\")).to_owned());\n+\n+        // can't link to yourself\n+        match io::result(|| File::symlink(&input, &input)) {\n+            Ok(*) => fail!(\"wanted a failure\"),\n+            Err(*) => {}\n+        }\n+        // symlinks can point to things that don't exist\n+        File::symlink(&tmpdir.join(\"foo\"), &tmpdir.join(\"bar\"));\n+\n+        assert!(File::readlink(&tmpdir.join(\"bar\")).unwrap() == tmpdir.join(\"bar\"));\n+\n+        match io::result(|| File::readlink(&tmpdir)) {\n+            Ok(*) => fail!(\"wanted a failure\"),\n+            Err(*) => {}\n+        }\n+\n+        rmdir_recursive(&tmpdir);\n+    }\n+\n+    #[test]\n+    fn links_work() {\n+        let tmpdir = tmpdir();\n+        let input = tmpdir.join(\"in.txt\");\n+        let out = tmpdir.join(\"out.txt\");\n+\n+        File::create(&input).write(\"foobar\".as_bytes());\n+        File::link(&input, &out);\n+        assert_eq!(File::lstat(&out).kind, io::TypeFile);\n+        assert_eq!(File::stat(&out).size, File::stat(&input).size);\n+        assert_eq!(File::stat(&out).nlink, 2);\n+        assert_eq!(File::open(&out).read_to_end(), (bytes!(\"foobar\")).to_owned());\n+\n+        // can't link to yourself\n+        match io::result(|| File::link(&input, &input)) {\n+            Ok(*) => fail!(\"wanted a failure\"),\n+            Err(*) => {}\n+        }\n+        // can't link to something that doesn't exist\n+        match io::result(|| File::link(&tmpdir.join(\"foo\"), &tmpdir.join(\"bar\"))) {\n+            Ok(*) => fail!(\"wanted a failure\"),\n+            Err(*) => {}\n+        }\n+\n+        rmdir_recursive(&tmpdir);\n+    }\n+\n+    #[test]\n+    fn chmod_works() {\n+        let tmpdir = tmpdir();\n+        let file = tmpdir.join(\"in.txt\");\n+\n+        File::create(&file);\n+        File::chmod(&file, io::UserRWX);\n+        assert_eq!(File::stat(&file).perm, io::UserRWX);\n+\n+        match io::result(|| File::chmod(&tmpdir.join(\"foo\"), io::UserRWX)) {\n+            Ok(*) => fail!(\"wanted a failure\"),\n+            Err(*) => {}\n+        }\n+\n+        rmdir_recursive(&tmpdir);\n+    }\n+\n+    #[test]\n+    fn sync_doesnt_kill_anything() {\n+        let tmpdir = tmpdir();\n+        let path = tmpdir.join(\"in.txt\");\n+\n+        let mut file = File::open_mode(&path, io::Open, io::ReadWrite).unwrap();\n+        file.fsync();\n+        file.datasync();\n+        file.write(bytes!(\"foo\"));\n+        file.fsync();\n+        file.datasync();\n+\n+        rmdir_recursive(&tmpdir);\n+    }\n+\n+    #[test]\n+    fn truncate_works() {\n+        let tmpdir = tmpdir();\n+        let path = tmpdir.join(\"in.txt\");\n+\n+        let mut file = File::open_mode(&path, io::Open, io::ReadWrite).unwrap();\n+        file.write(bytes!(\"foo\"));\n+\n+        // Do some simple things with truncation\n+        assert_eq!(File::stat(&path).size, 3);\n+        file.truncate(10);\n+        assert_eq!(File::stat(&path).size, 10);\n+        file.write(bytes!(\"bar\"));\n+        assert_eq!(File::stat(&path).size, 10);\n+        assert_eq!(File::open(&path).read_to_end(),\n+                   (bytes!(\"foobar\", 0, 0, 0, 0)).to_owned());\n+\n+        // Truncate to a smaller length, don't seek, and then write something.\n+        // Ensure that the intermediate zeroes are all filled in (we're seeked\n+        // past the end of the file).\n+        file.truncate(2);\n+        assert_eq!(File::stat(&path).size, 2);\n+        file.write(bytes!(\"wut\"));\n+        assert_eq!(File::stat(&path).size, 9);\n+        assert_eq!(File::open(&path).read_to_end(),\n+                   (bytes!(\"fo\", 0, 0, 0, 0, \"wut\")).to_owned());\n+\n+        rmdir_recursive(&tmpdir);\n+    }\n+\n+    #[test]\n+    fn open_flavors() {\n+        let tmpdir = tmpdir();\n+\n+        match io::result(|| File::open_mode(&tmpdir.join(\"a\"), io::Open,\n+                                            io::Read)) {\n+            Ok(*) => fail!(), Err(*) => {}\n+        }\n+        File::open_mode(&tmpdir.join(\"b\"), io::Open, io::Write).unwrap();\n+        File::open_mode(&tmpdir.join(\"c\"), io::Open, io::ReadWrite).unwrap();\n+        File::open_mode(&tmpdir.join(\"d\"), io::Append, io::Write).unwrap();\n+        File::open_mode(&tmpdir.join(\"e\"), io::Append, io::ReadWrite).unwrap();\n+        File::open_mode(&tmpdir.join(\"f\"), io::Truncate, io::Write).unwrap();\n+        File::open_mode(&tmpdir.join(\"g\"), io::Truncate, io::ReadWrite).unwrap();\n+\n+        File::create(&tmpdir.join(\"h\")).write(\"foo\".as_bytes());\n+        File::open_mode(&tmpdir.join(\"h\"), io::Open, io::Read).unwrap();\n+        {\n+            let mut f = File::open_mode(&tmpdir.join(\"h\"), io::Open,\n+                                        io::Read).unwrap();\n+            match io::result(|| f.write(\"wut\".as_bytes())) {\n+                Ok(*) => fail!(), Err(*) => {}\n+            }\n+        }\n+        assert_eq!(File::stat(&tmpdir.join(\"h\")).size, 3);\n+        {\n+            let mut f = File::open_mode(&tmpdir.join(\"h\"), io::Append,\n+                                        io::Write).unwrap();\n+            f.write(\"bar\".as_bytes());\n+        }\n+        assert_eq!(File::stat(&tmpdir.join(\"h\")).size, 6);\n+        {\n+            let mut f = File::open_mode(&tmpdir.join(\"h\"), io::Truncate,\n+                                        io::Write).unwrap();\n+            f.write(\"bar\".as_bytes());\n+        }\n+        assert_eq!(File::stat(&tmpdir.join(\"h\")).size, 3);\n+\n         rmdir_recursive(&tmpdir);\n     }\n }"}, {"sha": "510c3470d06ae721e8f8c302b904fc4b889930da", "filename": "src/libstd/rt/io/mod.rs", "status": "modified", "additions": 82, "deletions": 37, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmod.rs?ref=f19d0833625c382c5d0a8868924cd4620335e659", "patch": "@@ -231,8 +231,6 @@ Out of scope\n * Trait for things that are both readers and writers, Stream?\n * How to handle newline conversion\n * String conversion\n-* File vs. FileStream? File is shorter but could also be used for getting file info\n-  - maybe File is for general file querying and *also* has a static `open` method\n * open vs. connect for generic stream opening\n * Do we need `close` at all? dtors might be good enough\n * How does I/O relate to the Iterator trait?\n@@ -244,7 +242,6 @@ Out of scope\n \n use cast;\n use int;\n-use libc;\n use path::Path;\n use str::{StrSlice, OwnedStr};\n use option::{Option, Some, None};\n@@ -262,7 +259,7 @@ pub use self::stdio::stderr;\n pub use self::stdio::print;\n pub use self::stdio::println;\n \n-pub use self::file::FileStream;\n+pub use self::file::File;\n pub use self::timer::Timer;\n pub use self::net::ip::IpAddr;\n pub use self::net::tcp::TcpListener;\n@@ -465,7 +462,7 @@ pub trait Reader {\n     ///\n     /// # Example\n     ///\n-    ///     let reader = FileStream::new()\n+    ///     let reader = File::open(&Path::new(\"foo.txt\"))\n     ///     while !reader.eof() {\n     ///         println(reader.read_line());\n     ///     }\n@@ -1104,55 +1101,103 @@ pub fn placeholder_error() -> IoError {\n     }\n }\n \n-/// Instructions on how to open a file and return a `FileStream`.\n+/// A mode specifies how a file should be opened or created. These modes are\n+/// passed to `File::open_mode` and are used to control where the file is\n+/// positioned when it is initially opened.\n pub enum FileMode {\n-    /// Opens an existing file. IoError if file does not exist.\n+    /// Opens a file positioned at the beginning.\n     Open,\n-    /// Creates a file. IoError if file exists.\n-    Create,\n-    /// Opens an existing file or creates a new one.\n-    OpenOrCreate,\n-    /// Opens an existing file or creates a new one, positioned at EOF.\n+    /// Opens a file positioned at EOF.\n     Append,\n-    /// Opens an existing file, truncating it to 0 bytes.\n+    /// Opens a file, truncating it if it already exists.\n     Truncate,\n-    /// Opens an existing file or creates a new one, truncating it to 0 bytes.\n-    CreateOrTruncate,\n }\n \n-/// Access permissions with which the file should be opened.\n-/// `FileStream`s opened with `Read` will raise an `io_error` condition if written to.\n+/// Access permissions with which the file should be opened. `File`s\n+/// opened with `Read` will raise an `io_error` condition if written to.\n pub enum FileAccess {\n     Read,\n     Write,\n-    ReadWrite\n+    ReadWrite,\n+}\n+\n+/// Different kinds of files which can be identified by a call to stat\n+#[deriving(Eq)]\n+pub enum FileType {\n+    TypeFile,\n+    TypeDirectory,\n+    TypeNamedPipe,\n+    TypeBlockSpecial,\n+    TypeSymlink,\n+    TypeUnknown,\n }\n \n pub struct FileStat {\n-    /// A `Path` object containing information about the `PathInfo`'s location\n+    /// The path that this stat structure is describing\n     path: Path,\n-    /// `true` if the file pointed at by the `PathInfo` is a regular file\n-    is_file: bool,\n-    /// `true` if the file pointed at by the `PathInfo` is a directory\n-    is_dir: bool,\n-    /// The file pointed at by the `PathInfo`'s device\n-    device: u64,\n-    /// The file pointed at by the `PathInfo`'s mode\n-    mode: u64,\n-    /// The file pointed at by the `PathInfo`'s inode\n-    inode: u64,\n-    /// The file pointed at by the `PathInfo`'s size in bytes\n+    /// The size of the file, in bytes\n     size: u64,\n-    /// The file pointed at by the `PathInfo`'s creation time\n+    /// The kind of file this path points to (directory, file, pipe, etc.)\n+    kind: FileType,\n+    /// The file permissions currently on the file\n+    perm: FilePermission,\n+\n+    // XXX: These time fields are pretty useless without an actual time\n+    //      representation, what are the milliseconds relative to?\n+\n+    /// The time that the file was created at, in platform-dependent\n+    /// milliseconds\n     created: u64,\n-    /// The file pointed at by the `PathInfo`'s last-modification time in\n-    /// platform-dependent msecs\n+    /// The time that this file was last modified, in platform-dependent\n+    /// milliseconds\n     modified: u64,\n-    /// The file pointed at by the `PathInfo`'s last-accessd time (e.g. read) in\n-    /// platform-dependent msecs\n+    /// The time that this file was last accessed, in platform-dependent\n+    /// milliseconds\n     accessed: u64,\n+\n+    // Various filesytem info\n+    device: u64,\n+    inode: u64,\n+    rdev: u64,\n+    nlink: u64,\n+    uid: u64,\n+    gid: u64,\n+    blksize: u64,\n+    blocks: u64,\n+    flags: u64,\n+    gen: u64,\n }\n \n-// FIXME(#10131): this needs to get designed for real\n+/// A set of permissions for a file or directory is represented by a set of\n+/// flags which are or'd together.\n pub type FilePermission = u32;\n-pub static UserRWX: FilePermission = libc::S_IRWXU as FilePermission;\n+\n+// Each permission bit\n+pub static UserRead: FilePermission     = 0x100;\n+pub static UserWrite: FilePermission    = 0x080;\n+pub static UserExecute: FilePermission  = 0x040;\n+pub static GroupRead: FilePermission    = 0x020;\n+pub static GroupWrite: FilePermission   = 0x010;\n+pub static GroupExecute: FilePermission = 0x008;\n+pub static OtherRead: FilePermission    = 0x004;\n+pub static OtherWrite: FilePermission   = 0x002;\n+pub static OtherExecute: FilePermission = 0x001;\n+\n+// Common combinations of these bits\n+pub static UserRWX: FilePermission  = UserRead | UserWrite | UserExecute;\n+pub static GroupRWX: FilePermission = GroupRead | GroupWrite | GroupExecute;\n+pub static OtherRWX: FilePermission = OtherRead | OtherWrite | OtherExecute;\n+\n+/// A set of permissions for user owned files, this is equivalent to 0644 on\n+/// unix-like systems.\n+pub static UserFile: FilePermission = UserRead | UserWrite | GroupRead | OtherRead;\n+/// A set of permissions for user owned directories, this is equivalent to 0755\n+/// on unix-like systems.\n+pub static UserDir: FilePermission = UserRWX | GroupRead | GroupExecute |\n+                                     OtherRead | OtherExecute;\n+/// A set of permissions for user owned executables, this is equivalent to 0755\n+/// on unix-like systems.\n+pub static UserExec: FilePermission = UserDir;\n+\n+/// A mask for all possible permission bits\n+pub static AllPermissions: FilePermission = 0x1ff;"}, {"sha": "4eb473a73a6a3fbd0db98c1a96347a11ee3dacdd", "filename": "src/libstd/rt/io/native/file.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs?ref=f19d0833625c382c5d0a8868924cd4620335e659", "patch": "@@ -309,14 +309,16 @@ mod tests {\n //      get bitrotted instantaneously.\n mod old_os {\n     use prelude::*;\n-    use c_str::CString;\n-    use libc::fclose;\n     use libc::{size_t, c_void, c_int};\n     use libc;\n     use vec;\n \n-    #[cfg(test)] use os;\n+    #[cfg(not(windows))] use c_str::CString;\n+    #[cfg(not(windows))] use libc::fclose;\n+    #[cfg(test)] #[cfg(windows)] use os;\n     #[cfg(test)] use rand;\n+    #[cfg(windows)] use str;\n+    #[cfg(windows)] use ptr;\n \n     // On Windows, wide character version of function must be used to support\n     // unicode, so functions should be split into at least two versions,\n@@ -651,7 +653,7 @@ mod old_os {\n                     return false;\n                 }\n                 // Preserve permissions\n-                let from_mode = from.stat().mode;\n+                let from_mode = from.stat().perm;\n \n                 let ostream = do to.with_c_str |top| {\n                     do \"w+b\".with_c_str |modebuf| {\n@@ -735,8 +737,8 @@ mod old_os {\n \n     #[test]\n     fn test_path_is_dir() {\n-        use rt::io::file::{open_stream, mkdir_recursive};\n-        use rt::io::{OpenOrCreate, Read, UserRWX};\n+        use rt::io::file::{mkdir_recursive};\n+        use rt::io::{File, UserRWX};\n \n         assert!((path_is_dir(&Path::new(\".\"))));\n         assert!((!path_is_dir(&Path::new(\"test/stdtest/fs.rs\"))));\n@@ -754,7 +756,7 @@ mod old_os {\n         filepath.push(\"unicode-file-\\uac00\\u4e00\\u30fc\\u4f60\\u597d.rs\");\n         debug!(\"path_is_dir filepath: {}\", filepath.display());\n \n-        open_stream(&filepath, OpenOrCreate, Read); // ignore return; touch only\n+        File::create(&filepath); // ignore return; touch only\n         assert!((!path_is_dir(&filepath)));\n \n         assert!((!path_is_dir(&Path::new("}, {"sha": "5938252571f515927f18123e335806c7ad93c2c5", "filename": "src/libstd/rt/io/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibstd%2Frt%2Fio%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibstd%2Frt%2Fio%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Foption.rs?ref=f19d0833625c382c5d0a8868924cd4620335e659", "patch": "@@ -11,7 +11,7 @@\n //! Implementations of I/O traits for the Option type\n //!\n //! I/O constructors return option types to allow errors to be handled.\n-//! These implementations allow e.g. `Option<FileStream>` to be used\n+//! These implementations allow e.g. `Option<File>` to be used\n //! as a `Reader` without unwrapping the option first.\n \n use option::*;"}, {"sha": "d24de7cbfee51086fa2585e0a8c680a1fd624878", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=f19d0833625c382c5d0a8868924cd4620335e659", "patch": "@@ -91,12 +91,17 @@ pub fn with_local_io<T>(f: &fn(&mut IoFactory) -> Option<T>) -> Option<T> {\n }\n \n pub trait IoFactory {\n+    // networking\n     fn tcp_connect(&mut self, addr: SocketAddr) -> Result<~RtioTcpStream, IoError>;\n     fn tcp_bind(&mut self, addr: SocketAddr) -> Result<~RtioTcpListener, IoError>;\n     fn udp_bind(&mut self, addr: SocketAddr) -> Result<~RtioUdpSocket, IoError>;\n+    fn unix_bind(&mut self, path: &CString) ->\n+        Result<~RtioUnixListener, IoError>;\n+    fn unix_connect(&mut self, path: &CString) -> Result<~RtioPipe, IoError>;\n     fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n                           hint: Option<ai::Hint>) -> Result<~[ai::Info], IoError>;\n-    fn timer_init(&mut self) -> Result<~RtioTimer, IoError>;\n+\n+    // filesystem operations\n     fn fs_from_raw_fd(&mut self, fd: c_int, close: CloseBehavior) -> ~RtioFileStream;\n     fn fs_open(&mut self, path: &CString, fm: FileMode, fa: FileAccess)\n         -> Result<~RtioFileStream, IoError>;\n@@ -110,13 +115,18 @@ pub trait IoFactory {\n     fn fs_rename(&mut self, path: &CString, to: &CString) -> Result<(), IoError>;\n     fn fs_readdir(&mut self, path: &CString, flags: c_int) ->\n         Result<~[Path], IoError>;\n+    fn fs_lstat(&mut self, path: &CString) -> Result<FileStat, IoError>;\n+    fn fs_chown(&mut self, path: &CString, uid: int, gid: int) ->\n+        Result<(), IoError>;\n+    fn fs_readlink(&mut self, path: &CString) -> Result<Path, IoError>;\n+    fn fs_symlink(&mut self, src: &CString, dst: &CString) -> Result<(), IoError>;\n+    fn fs_link(&mut self, src: &CString, dst: &CString) -> Result<(), IoError>;\n+\n+    // misc\n+    fn timer_init(&mut self) -> Result<~RtioTimer, IoError>;\n     fn spawn(&mut self, config: ProcessConfig)\n             -> Result<(~RtioProcess, ~[Option<~RtioPipe>]), IoError>;\n-\n     fn pipe_open(&mut self, fd: c_int) -> Result<~RtioPipe, IoError>;\n-    fn unix_bind(&mut self, path: &CString) ->\n-        Result<~RtioUnixListener, IoError>;\n-    fn unix_connect(&mut self, path: &CString) -> Result<~RtioPipe, IoError>;\n     fn tty_open(&mut self, fd: c_int, readable: bool)\n             -> Result<~RtioTTY, IoError>;\n     fn signal(&mut self, signal: Signum, channel: SharedChan<Signum>)\n@@ -177,6 +187,9 @@ pub trait RtioFileStream {\n     fn pwrite(&mut self, buf: &[u8], offset: u64) -> Result<(), IoError>;\n     fn seek(&mut self, pos: i64, whence: SeekStyle) -> Result<u64, IoError>;\n     fn tell(&self) -> Result<u64, IoError>;\n+    fn fsync(&mut self) -> Result<(), IoError>;\n+    fn datasync(&mut self) -> Result<(), IoError>;\n+    fn truncate(&mut self, offset: i64) -> Result<(), IoError>;\n }\n \n pub trait RtioProcess {"}, {"sha": "75b5ab81f9bb3324024c84cc3d9f76f8402b1357", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=f19d0833625c382c5d0a8868924cd4620335e659", "patch": "@@ -20,8 +20,7 @@ use parse::token::{get_ident_interner};\n use print::pprust;\n \n use std::rt::io;\n-use std::rt::io::Reader;\n-use std::rt::io::file;\n+use std::rt::io::File;\n use std::str;\n \n // These macros all relate to the file system; they either return\n@@ -92,7 +91,7 @@ pub fn expand_include_str(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include_str!\");\n     let file = res_rel_file(cx, sp, &Path::new(file));\n-    let bytes = match io::result(|| file::open(&file).read_to_end()) {\n+    let bytes = match io::result(|| File::open(&file).read_to_end()) {\n         Err(e) => {\n             cx.span_fatal(sp, format!(\"couldn't read {}: {}\",\n                                       file.display(), e.desc));\n@@ -114,7 +113,7 @@ pub fn expand_include_bin(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n \n     let file = get_single_str_from_tts(cx, sp, tts, \"include_bin!\");\n     let file = res_rel_file(cx, sp, &Path::new(file));\n-    match io::result(|| file::open(&file).read_to_end()) {\n+    match io::result(|| File::open(&file).read_to_end()) {\n         Err(e) => {\n             cx.span_fatal(sp, format!(\"couldn't read {}: {}\",\n                                       file.display(), e.desc));"}, {"sha": "fbe711b5efe9e7cd5f88bf47669cfacf85ba14f5", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19d0833625c382c5d0a8868924cd4620335e659/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=f19d0833625c382c5d0a8868924cd4620335e659", "patch": "@@ -19,9 +19,8 @@ use parse::attr::parser_attr;\n use parse::lexer::reader;\n use parse::parser::Parser;\n \n-use std::path::Path;\n use std::rt::io;\n-use std::rt::io::file;\n+use std::rt::io::File;\n use std::str;\n \n pub mod lexer;\n@@ -268,7 +267,7 @@ pub fn file_to_filemap(sess: @mut ParseSess, path: &Path, spanopt: Option<Span>)\n             None => sess.span_diagnostic.handler().fatal(msg),\n         }\n     };\n-    let bytes = match io::result(|| file::open(path).read_to_end()) {\n+    let bytes = match io::result(|| File::open(path).read_to_end()) {\n         Ok(bytes) => bytes,\n         Err(e) => {\n             err(format!(\"couldn't read {}: {}\", path.display(), e.desc));"}, {"sha": "a4361f14f69b257fe2dfb6cf0898a6deb65ac5c8", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f19d0833625c382c5d0a8868924cd4620335e659/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f19d0833625c382c5d0a8868924cd4620335e659/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=f19d0833625c382c5d0a8868924cd4620335e659", "patch": "@@ -532,6 +532,10 @@ extern \"C\" int\n rust_uv_get_result_from_fs_req(uv_fs_t* req) {\n   return req->result;\n }\n+extern \"C\" const char*\n+rust_uv_get_path_from_fs_req(uv_fs_t* req) {\n+  return req->path;\n+}\n extern \"C\" void*\n rust_uv_get_ptr_from_fs_req(uv_fs_t* req) {\n   return req->ptr;"}, {"sha": "2c86fdfe6ad722d8c498a801d7ee9ba0b9b9f523", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f19d0833625c382c5d0a8868924cd4620335e659/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19d0833625c382c5d0a8868924cd4620335e659/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=f19d0833625c382c5d0a8868924cd4620335e659", "patch": "@@ -21,7 +21,7 @@ use std::rand;\n use std::str;\n use std::util;\n use std::vec;\n-use std::rt::io::file;\n+use std::rt::io::File;\n \n macro_rules! bench (\n     ($argv:expr, $id:ident) => (maybe_run_test($argv, stringify!($id).to_owned(), $id))\n@@ -76,7 +76,7 @@ fn read_line() {\n     path.push(\"src/test/bench/shootout-k-nucleotide.data\");\n \n     for _ in range(0, 3) {\n-        let mut reader = BufferedReader::new(file::open(&path).unwrap());\n+        let mut reader = BufferedReader::new(File::open(&path).unwrap());\n         while !reader.eof() {\n             reader.read_line();\n         }"}, {"sha": "d7d7e9a58f3ca1cce2b10ef18e207a26610ca4b1", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f19d0833625c382c5d0a8868924cd4620335e659/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19d0833625c382c5d0a8868924cd4620335e659/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=f19d0833625c382c5d0a8868924cd4620335e659", "patch": "@@ -19,7 +19,7 @@ extern mod extra;\n \n use std::int;\n use std::rt::io;\n-use std::rt::io::file;\n+use std::rt::io::File;\n use std::os;\n use std::rand::Rng;\n use std::rand;\n@@ -123,7 +123,7 @@ fn main() {\n     };\n \n     let writer = if os::getenv(\"RUST_BENCH\").is_some() {\n-        let file = file::create(&Path::new(\"./shootout-fasta.data\"));\n+        let file = File::create(&Path::new(\"./shootout-fasta.data\"));\n         @mut file as @mut io::Writer\n     } else {\n         @mut io::stdout() as @mut io::Writer"}, {"sha": "7f684e41c75a9e1509e58550c40c83e4f97a5df8", "filename": "src/test/run-pass/glob-std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f19d0833625c382c5d0a8868924cd4620335e659/src%2Ftest%2Frun-pass%2Fglob-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19d0833625c382c5d0a8868924cd4620335e659/src%2Ftest%2Frun-pass%2Fglob-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fglob-std.rs?ref=f19d0833625c382c5d0a8868924cd4620335e659", "patch": "@@ -23,7 +23,7 @@ pub fn main() {\n         if directory {\n             io::file::mkdir(&Path::new(path), io::UserRWX);\n         } else {\n-            io::file::create(&Path::new(path));\n+            io::File::create(&Path::new(path));\n         }\n     }\n "}, {"sha": "0aa4ae40f9e5d22f56ce7e1baef88871ed09d0f6", "filename": "src/test/run-pass/rename-directory.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f19d0833625c382c5d0a8868924cd4620335e659/src%2Ftest%2Frun-pass%2Frename-directory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19d0833625c382c5d0a8868924cd4620335e659/src%2Ftest%2Frun-pass%2Frename-directory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frename-directory.rs?ref=f19d0833625c382c5d0a8868924cd4620335e659", "patch": "@@ -19,6 +19,7 @@ use std::os;\n use std::libc;\n use std::rt::io;\n use std::rt::io::file;\n+use std::rt::io::File;\n \n fn rename_directory() {\n     #[fixed_stack_segment];\n@@ -50,7 +51,7 @@ fn rename_directory() {\n \n         let new_path = tmpdir.join_many([\"quux\", \"blat\"]);\n         file::mkdir_recursive(&new_path, io::UserRWX);\n-        file::rename(&old_path, &new_path.join(\"newdir\"));\n+        File::rename(&old_path, &new_path.join(\"newdir\"));\n         assert!(new_path.join(\"newdir\").is_dir());\n         assert!(new_path.join_many([\"newdir\", \"temp.txt\"]).exists());\n     }"}, {"sha": "9ce3d318064c98274be3da892ceb5af0ee821ebc", "filename": "src/test/run-pass/stat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f19d0833625c382c5d0a8868924cd4620335e659/src%2Ftest%2Frun-pass%2Fstat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19d0833625c382c5d0a8868924cd4620335e659/src%2Ftest%2Frun-pass%2Fstat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstat.rs?ref=f19d0833625c382c5d0a8868924cd4620335e659", "patch": "@@ -13,14 +13,14 @@\n extern mod extra;\n \n use extra::tempfile;\n-use std::rt::io::file;\n+use std::rt::io::File;\n \n pub fn main() {\n     let dir = tempfile::TempDir::new_in(&Path::new(\".\"), \"\").unwrap();\n     let path = dir.path().join(\"file\");\n \n     {\n-        match file::create(&path) {\n+        match File::create(&path) {\n             None => unreachable!(),\n             Some(f) => {\n                 let mut f = f;"}]}