{"sha": "72080954b9deb3a6a5f793d2fd1ef32c3d5acb5d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyMDgwOTU0YjlkZWIzYTZhNWY3OTNkMmZkMWVmMzJjM2Q1YWNiNWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-06T17:32:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-06T17:32:00Z"}, "message": "auto merge of #8317 : bblum/rust/fast-spawn-unlinked, r=brson\n\nThis lazily initializes the taskgroup structs for ```spawn_unlinked``` tasks. If such a task never spawns another task linked to it (or a descendant of it), its taskgroup is simply never initialized at all. Also if an unlinked task spawns another unlinked task, neither of them will need to initialize their taskgroups. This works for the main task too.\r\n\r\nI benchmarked this with the following test case and observed a ~~21% speedup (average over 4 runs: 7.85 sec -> 6.20 sec, 2.5 GHz)~~ 11% speedup, see comment below.\r\n```\r\nuse std::task;\r\nuse std::cell::Cell;\r\nuse std::rt::comm;\r\n\r\nstatic NUM: uint = 1024*256;\r\n\r\nfn run(f: ~fn()) {\r\n    let mut t = task::task();\r\n    t.unlinked();\r\n    t.spawn(f);\r\n}\r\n\r\nfn main() {\r\n    do NUM.times {\r\n        let (p,c) = comm::oneshot();\r\n        let c = Cell::new(c);\r\n        do run { c.take().send(()); }\r\n        p.recv();\r\n    }\r\n}\r\n```", "tree": {"sha": "456eb7e1919d304b7630dd7d89b5bd9b98a1a1ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/456eb7e1919d304b7630dd7d89b5bd9b98a1a1ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72080954b9deb3a6a5f793d2fd1ef32c3d5acb5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72080954b9deb3a6a5f793d2fd1ef32c3d5acb5d", "html_url": "https://github.com/rust-lang/rust/commit/72080954b9deb3a6a5f793d2fd1ef32c3d5acb5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72080954b9deb3a6a5f793d2fd1ef32c3d5acb5d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3dfb55ab09a8533da7c5bf559c923685d5d64dc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/3dfb55ab09a8533da7c5bf559c923685d5d64dc1", "html_url": "https://github.com/rust-lang/rust/commit/3dfb55ab09a8533da7c5bf559c923685d5d64dc1"}, {"sha": "1f95bd768444a4a0318951c2e76f3d28bbf3763a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f95bd768444a4a0318951c2e76f3d28bbf3763a", "html_url": "https://github.com/rust-lang/rust/commit/1f95bd768444a4a0318951c2e76f3d28bbf3763a"}], "stats": {"total": 117, "additions": 67, "deletions": 50}, "files": [{"sha": "3372c13b87703a72cdef5af13fa5b651cc2379fc", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/72080954b9deb3a6a5f793d2fd1ef32c3d5acb5d/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72080954b9deb3a6a5f793d2fd1ef32c3d5acb5d/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=72080954b9deb3a6a5f793d2fd1ef32c3d5acb5d", "patch": "@@ -193,6 +193,10 @@ impl BlockedTask {\n \n     /// Create a blocked task, unless the task was already killed.\n     pub fn try_block(mut task: ~Task) -> Either<~Task, BlockedTask> {\n+        // NB: As an optimization, we could give a free pass to being unkillable\n+        // to tasks whose taskgroups haven't been initialized yet, but that\n+        // introduces complications with select() and with the test cases below,\n+        // and it's not clear the uncommon performance boost is worth it.\n         if task.death.unkillable > 0 {\n             Right(Unkillable(task))\n         } else {\n@@ -205,11 +209,10 @@ impl BlockedTask {\n                 let flag_arc = match task.death.spare_kill_flag.take() {\n                     Some(spare_flag) => spare_flag,\n                     None => {\n-                        // FIXME(#7544): Uncomment this when terminate_current_task\n-                        // stops being *terrible*. That's the only place that violates\n-                        // the assumption of \"becoming unkillable will fail if the\n-                        // task was killed\".\n-                        // rtassert!(task.unwinder.unwinding);\n+                        // A task that kills us won't have a spare kill flag to\n+                        // give back to us, so we restore it ourselves here. This\n+                        // situation should only arise when we're already failing.\n+                        rtassert!(task.unwinder.unwinding);\n                         (*task.death.kill_handle.get_ref().get()).killed.clone()\n                     }\n                 };"}, {"sha": "527b20b0e9027312afc5d66244365fa54b5cb28f", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 59, "deletions": 45, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/72080954b9deb3a6a5f793d2fd1ef32c3d5acb5d/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72080954b9deb3a6a5f793d2fd1ef32c3d5acb5d/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=72080954b9deb3a6a5f793d2fd1ef32c3d5acb5d", "patch": "@@ -568,7 +568,8 @@ impl RuntimeGlue {\n                 let me = Local::unsafe_borrow::<Task>();\n                 blk(match (*me).taskgroup {\n                     None => {\n-                        // Main task, doing first spawn ever. Lazily initialize.\n+                        // First task in its (unlinked/unsupervised) taskgroup.\n+                        // Lazily initialize.\n                         let mut members = TaskSet::new();\n                         let my_handle = (*me).death.kill_handle.get_ref().clone();\n                         members.insert(NewTask(my_handle));\n@@ -591,37 +592,46 @@ impl RuntimeGlue {\n     }\n }\n \n+// Returns 'None' in the case where the child's TG should be lazily initialized.\n fn gen_child_taskgroup(linked: bool, supervised: bool)\n-    -> (TaskGroupArc, AncestorList, bool) {\n-    do RuntimeGlue::with_my_taskgroup |spawner_group| {\n-        let ancestors = AncestorList(spawner_group.ancestors.map(|x| x.clone()));\n-        if linked {\n-            // Child is in the same group as spawner.\n-            // Child's ancestors are spawner's ancestors.\n-            // Propagate main-ness.\n-            (spawner_group.tasks.clone(), ancestors, spawner_group.is_main)\n-        } else {\n-            // Child is in a separate group from spawner.\n-            let g = Exclusive::new(Some(TaskGroupData {\n-                members:     TaskSet::new(),\n-                descendants: TaskSet::new(),\n-            }));\n-            let a = if supervised {\n-                let new_generation = incr_generation(&ancestors);\n-                assert!(new_generation < uint::max_value);\n-                // Child's ancestors start with the spawner.\n-                // Build a new node in the ancestor list.\n-                AncestorList(Some(Exclusive::new(AncestorNode {\n-                    generation: new_generation,\n-                    parent_group: spawner_group.tasks.clone(),\n-                    ancestors: ancestors,\n-                })))\n+    -> Option<(TaskGroupArc, AncestorList, bool)> {\n+    // FIXME(#7544): Not safe to lazily initialize in the old runtime. Remove\n+    // this context check once 'spawn_raw_oldsched' is gone.\n+    if context() == OldTaskContext || linked || supervised {\n+        // with_my_taskgroup will lazily initialize the parent's taskgroup if\n+        // it doesn't yet exist. We don't want to call it in the unlinked case.\n+        do RuntimeGlue::with_my_taskgroup |spawner_group| {\n+            let ancestors = AncestorList(spawner_group.ancestors.map(|x| x.clone()));\n+            if linked {\n+                // Child is in the same group as spawner.\n+                // Child's ancestors are spawner's ancestors.\n+                // Propagate main-ness.\n+                Some((spawner_group.tasks.clone(), ancestors, spawner_group.is_main))\n             } else {\n-                // Child has no ancestors.\n-                AncestorList(None)\n-            };\n-            (g, a, false)\n+                // Child is in a separate group from spawner.\n+                let g = Exclusive::new(Some(TaskGroupData {\n+                    members:     TaskSet::new(),\n+                    descendants: TaskSet::new(),\n+                }));\n+                let a = if supervised {\n+                    let new_generation = incr_generation(&ancestors);\n+                    assert!(new_generation < uint::max_value);\n+                    // Child's ancestors start with the spawner.\n+                    // Build a new node in the ancestor list.\n+                    AncestorList(Some(Exclusive::new(AncestorNode {\n+                        generation: new_generation,\n+                        parent_group: spawner_group.tasks.clone(),\n+                        ancestors: ancestors,\n+                    })))\n+                } else {\n+                    // Child has no ancestors.\n+                    AncestorList(None)\n+                };\n+                Some((g, a, false))\n+            }\n         }\n+    } else {\n+        None\n     }\n }\n \n@@ -670,20 +680,24 @@ fn spawn_raw_newsched(mut opts: TaskOpts, f: ~fn()) {\n \n     let child_wrapper: ~fn() = || {\n         // Child task runs this code.\n-        let child_data = Cell::new(child_data.take()); // :(\n-        let enlist_success = do Local::borrow::<Task, bool> |me| {\n-            let (child_tg, ancestors, is_main) = child_data.take();\n-            let mut ancestors = ancestors;\n-            // FIXME(#7544): Optimize out the xadd in this clone, somehow.\n-            let handle = me.death.kill_handle.get_ref().clone();\n-            // Atomically try to get into all of our taskgroups.\n-            if enlist_many(NewTask(handle), &child_tg, &mut ancestors) {\n-                // Got in. We can run the provided child body, and can also run\n-                // the taskgroup's exit-time-destructor afterward.\n-                me.taskgroup = Some(Taskgroup(child_tg, ancestors, is_main, None));\n-                true\n-            } else {\n-                false\n+\n+        // If child data is 'None', the enlist is vacuously successful.\n+        let enlist_success = do child_data.take().map_consume_default(true) |child_data| {\n+            let child_data = Cell::new(child_data); // :(\n+            do Local::borrow::<Task, bool> |me| {\n+                let (child_tg, ancestors, is_main) = child_data.take();\n+                let mut ancestors = ancestors;\n+                // FIXME(#7544): Optimize out the xadd in this clone, somehow.\n+                let handle = me.death.kill_handle.get_ref().clone();\n+                // Atomically try to get into all of our taskgroups.\n+                if enlist_many(NewTask(handle), &child_tg, &mut ancestors) {\n+                    // Got in. We can run the provided child body, and can also run\n+                    // the taskgroup's exit-time-destructor afterward.\n+                    me.taskgroup = Some(Taskgroup(child_tg, ancestors, is_main, None));\n+                    true\n+                } else {\n+                    false\n+                }\n             }\n         };\n         // Should be run after the local-borrowed task is returned.\n@@ -749,7 +763,7 @@ fn spawn_raw_newsched(mut opts: TaskOpts, f: ~fn()) {\n                 let join_task = join_task_cell.take();\n \n                 let bootstrap_task = ~do Task::new_root(&mut new_sched.stack_pool) || {\n-                    rtdebug!(\"boostraping a 1:1 scheduler\");\n+                    rtdebug!(\"bootstrapping a 1:1 scheduler\");\n                 };\n                 new_sched.bootstrap(bootstrap_task);\n \n@@ -793,7 +807,7 @@ fn spawn_raw_newsched(mut opts: TaskOpts, f: ~fn()) {\n fn spawn_raw_oldsched(mut opts: TaskOpts, f: ~fn()) {\n \n     let (child_tg, ancestors, is_main) =\n-        gen_child_taskgroup(opts.linked, opts.supervised);\n+        gen_child_taskgroup(opts.linked, opts.supervised).expect(\"old runtime needs TG\");\n \n     unsafe {\n         let child_data = Cell::new((child_tg, ancestors, f));"}]}