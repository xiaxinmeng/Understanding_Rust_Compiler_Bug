{"sha": "92708322fd19747100ff5eda2e4584bc9d1f2b38", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyNzA4MzIyZmQxOTc0NzEwMGZmNWVkYTJlNDU4NGJjOWQxZjJiMzg=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2014-07-04T19:18:37Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2014-07-04T20:20:14Z"}, "message": "comments & test cases for IdentRenamers", "tree": {"sha": "a2b1e3aee4833e793c25a7bfc0ff6a6a6166b22e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2b1e3aee4833e793c25a7bfc0ff6a6a6166b22e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92708322fd19747100ff5eda2e4584bc9d1f2b38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92708322fd19747100ff5eda2e4584bc9d1f2b38", "html_url": "https://github.com/rust-lang/rust/commit/92708322fd19747100ff5eda2e4584bc9d1f2b38", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92708322fd19747100ff5eda2e4584bc9d1f2b38/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6bee3c87c94a39fb7d48a119bbc105149c345bfc", "url": "https://api.github.com/repos/rust-lang/rust/commits/6bee3c87c94a39fb7d48a119bbc105149c345bfc", "html_url": "https://github.com/rust-lang/rust/commit/6bee3c87c94a39fb7d48a119bbc105149c345bfc"}], "stats": {"total": 74, "additions": 63, "deletions": 11}, "files": [{"sha": "e2c8782e13c3cf69410fa0324c2bd1dc116a7cf8", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 63, "deletions": 11, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/92708322fd19747100ff5eda2e4584bc9d1f2b38/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92708322fd19747100ff5eda2e4584bc9d1f2b38/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=92708322fd19747100ff5eda2e4584bc9d1f2b38", "patch": "@@ -344,15 +344,16 @@ fn expand_item(it: Gc<ast::Item>, fld: &mut MacroExpander)\n \n fn expand_item_modifiers(mut it: Gc<ast::Item>, fld: &mut MacroExpander)\n                          -> Gc<ast::Item> {\n-    let (modifiers, attrs) = it.attrs.partitioned(|attr| {\n+    // partition the attributes into ItemModifiers and others\n+    let (modifiers, other_attrs) = it.attrs.partitioned(|attr| {\n         match fld.extsbox.find(&intern(attr.name().get())) {\n             Some(&ItemModifier(_)) => true,\n             _ => false\n         }\n     });\n-\n+    // update the attrs, leave everything else alone. Is this mutation really a good idea?\n     it = box(GC) ast::Item {\n-        attrs: attrs,\n+        attrs: other_attrs,\n         ..(*it).clone()\n     };\n \n@@ -1047,13 +1048,14 @@ fn original_span(cx: &ExtCtxt) -> Gc<codemap::ExpnInfo> {\n #[cfg(test)]\n mod test {\n     use super::{pattern_bindings, expand_crate, contains_macro_escape};\n-    use super::{PatIdentFinder};\n+    use super::{PatIdentFinder, IdentRenamer, PatIdentRenamer};\n     use ast;\n     use ast::{Attribute_, AttrOuter, MetaWord};\n     use attr;\n     use codemap;\n     use codemap::Spanned;\n     use ext::mtwt;\n+    use fold::Folder;\n     use parse;\n     use parse::token;\n     use util::parser_testing::{string_to_parser};\n@@ -1091,7 +1093,24 @@ mod test {\n         path_finder.path_accumulator\n     }\n \n+    /// A Visitor that extracts the identifiers from a thingy.\n+    // as a side note, I'm starting to want to abstract over these....\n+    struct IdentFinder{\n+        ident_accumulator: Vec<ast::Ident>\n+    }\n \n+    impl Visitor<()> for IdentFinder {\n+        fn visit_ident(&mut self, _: codemap::Span, id: ast::Ident, _: ()){\n+            self.ident_accumulator.push(id);\n+        }\n+    }\n+\n+    /// Find the idents in a crate\n+    fn crate_idents(the_crate: &ast::Crate) -> Vec<ast::Ident> {\n+        let mut ident_finder = IdentFinder{ident_accumulator: Vec::new()};\n+        visit::walk_crate(&mut ident_finder, the_crate, ());\n+        ident_finder.ident_accumulator\n+    }\n \n     // these following tests are quite fragile, in that they don't test what\n     // *kind* of failure occurs.\n@@ -1316,7 +1335,7 @@ mod test {\n     // but *shouldn't* bind because it was inserted by a different macro....\n     // can't write this test case until we have macro-generating macros.\n \n-    // FIXME #9383 : lambda var hygiene\n+    // lambda var hygiene\n     // expands to fn q(x_1:int){fn g(x_2:int){x_2 + x_1};}\n     #[test]\n     fn issue_9383(){\n@@ -1375,9 +1394,9 @@ mod test {\n                         assert_eq!(varref_marks,binding_marks.clone());\n                     }\n                 } else {\n+                    let varref_name = mtwt::resolve(varref.segments.get(0).identifier);\n                     let fail = (varref.segments.len() == 1)\n-                        && (mtwt::resolve(varref.segments.get(0).identifier)\n-                            == binding_name);\n+                        && (varref_name == binding_name);\n                     // temp debugging:\n                     if fail {\n                         let varref_idents : Vec<ast::Ident>\n@@ -1388,15 +1407,18 @@ mod test {\n                         println!(\"text of test case: \\\"{}\\\"\", teststr);\n                         println!(\"\");\n                         println!(\"uh oh, matches but shouldn't:\");\n-                        println!(\"varref: {}\",varref_idents);\n+                        println!(\"varref #{}: {}, resolves to {}\",idx, varref_idents,\n+                                 varref_name);\n                         // good lord, you can't make a path with 0 segments, can you?\n                         let string = token::get_ident(varref.segments\n                                                             .get(0)\n                                                             .identifier);\n                         println!(\"varref's first segment's uint: {}, and string: \\\"{}\\\"\",\n                                  varref.segments.get(0).identifier.name,\n                                  string.get());\n-                        println!(\"binding: {}\", *bindings.get(binding_idx));\n+                        println!(\"binding #{}: {}, resolves to {}\",\n+                                 binding_idx, *bindings.get(binding_idx),\n+                                 binding_name);\n                         mtwt::with_sctable(|x| mtwt::display_sctable(x));\n                     }\n                     assert!(!fail);\n@@ -1459,13 +1481,43 @@ foo_module!()\n     // 'None' is listed as an identifier pattern because we don't yet know that\n     // it's the name of a 0-ary variant, and that 'i' appears twice in succession.\n     #[test]\n-    fn crate_idents(){\n+    fn crate_bindings_test(){\n         let the_crate = string_to_crate(\"fn main (a : int) -> int {|b| {\n         match 34 {None => 3, Some(i) | i => j, Foo{k:z,l:y} => \\\"banana\\\"}} }\".to_string());\n         let idents = crate_bindings(&the_crate);\n         assert_eq!(idents, strs_to_idents(vec!(\"a\",\"b\",\"None\",\"i\",\"i\",\"z\",\"y\")));\n     }\n \n-    //\n+    // test the IdentRenamer directly\n+    #[test]\n+    fn ident_renamer_test () {\n+        let the_crate = string_to_crate(\"fn f(x : int){let x = x; x}\".to_string());\n+        let f_ident = token::str_to_ident(\"f\");\n+        let x_ident = token::str_to_ident(\"x\");\n+        let int_ident = token::str_to_ident(\"int\");\n+        let renames = vec!((x_ident,16));\n+        let mut renamer = IdentRenamer{renames: &renames};\n+        let renamed_crate = renamer.fold_crate(the_crate);\n+        let idents = crate_idents(&renamed_crate);\n+        let resolved : Vec<ast::Name> = idents.iter().map(|id| mtwt::resolve(*id)).collect();\n+        assert_eq!(resolved,vec!(f_ident.name,16,int_ident.name,16,16,16));\n+    }\n+\n+    // test the PatIdentRenamer; only PatIdents get renamed\n+    #[test]\n+    fn pat_ident_renamer_test () {\n+        let the_crate = string_to_crate(\"fn f(x : int){let x = x; x}\".to_string());\n+        let f_ident = token::str_to_ident(\"f\");\n+        let x_ident = token::str_to_ident(\"x\");\n+        let int_ident = token::str_to_ident(\"int\");\n+        let renames = vec!((x_ident,16));\n+        let mut renamer = PatIdentRenamer{renames: &renames};\n+        let renamed_crate = renamer.fold_crate(the_crate);\n+        let idents = crate_idents(&renamed_crate);\n+        let resolved : Vec<ast::Name> = idents.iter().map(|id| mtwt::resolve(*id)).collect();\n+        let x_name = x_ident.name;\n+        assert_eq!(resolved,vec!(f_ident.name,16,int_ident.name,16,x_name,x_name));\n+    }\n+\n \n }"}]}