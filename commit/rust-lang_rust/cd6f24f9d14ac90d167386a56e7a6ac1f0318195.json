{"sha": "cd6f24f9d14ac90d167386a56e7a6ac1f0318195", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkNmYyNGY5ZDE0YWM5MGQxNjczODZhNTZlN2E2YWMxZjAzMTgxOTU=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-09T23:46:16Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-09T23:46:16Z"}, "message": "Copyedit FFI tutorial", "tree": {"sha": "b211f7f7fa7c231a0dddd87084edd942aa29876e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b211f7f7fa7c231a0dddd87084edd942aa29876e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd6f24f9d14ac90d167386a56e7a6ac1f0318195", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd6f24f9d14ac90d167386a56e7a6ac1f0318195", "html_url": "https://github.com/rust-lang/rust/commit/cd6f24f9d14ac90d167386a56e7a6ac1f0318195", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd6f24f9d14ac90d167386a56e7a6ac1f0318195/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b3be853afcf25a2801dea951e3d6d2ae7cba355", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b3be853afcf25a2801dea951e3d6d2ae7cba355", "html_url": "https://github.com/rust-lang/rust/commit/4b3be853afcf25a2801dea951e3d6d2ae7cba355"}], "stats": {"total": 131, "additions": 65, "deletions": 66}, "files": [{"sha": "771384f41d83708e2e2165b6b0cbf60caaf1a74f", "filename": "doc/tutorial-ffi.md", "status": "modified", "additions": 65, "deletions": 66, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/cd6f24f9d14ac90d167386a56e7a6ac1f0318195/doc%2Ftutorial-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd6f24f9d14ac90d167386a56e7a6ac1f0318195/doc%2Ftutorial-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-ffi.md?ref=cd6f24f9d14ac90d167386a56e7a6ac1f0318195", "patch": "@@ -2,17 +2,15 @@\n \n # Introduction\n \n-One of Rust's aims, as a system programming language, is to\n+Because Rust is a systems programming language, one of its goals is to\n interoperate well with C code.\n \n-We'll start with an example. It's a bit bigger than usual, and\n-contains a number of new concepts. We'll go over it one piece at a\n-time.\n-\n-This is a program that uses OpenSSL's `SHA1` function to compute the\n-hash of its first command-line argument, which it then converts to a\n-hexadecimal string and prints to standard output. If you have the\n-OpenSSL libraries installed, it should 'just work'.\n+We'll start with an example, which is a bit bigger than usual. We'll\n+go over it one piece at a time. This is a program that uses OpenSSL's\n+`SHA1` function to compute the hash of its first command-line\n+argument, which it then converts to a hexadecimal string and prints to\n+standard output. If you have the OpenSSL libraries installed, it\n+should compile and run without any extra effort.\n \n ~~~~ {.xfail-test}\n extern mod std;\n@@ -32,7 +30,7 @@ fn sha1(data: ~str) -> ~str unsafe {\n     let bytes = str::to_bytes(data);\n     let hash = crypto::SHA1(vec::raw::to_ptr(bytes),\n                             vec::len(bytes) as c_uint, ptr::null());\n-    return as_hex(vec::raw::from_buf(hash, 20u));\n+    return as_hex(vec::raw::from_buf(hash, 20));\n }\n \n fn main(args: ~[~str]) {\n@@ -42,26 +40,27 @@ fn main(args: ~[~str]) {\n \n # Foreign modules\n \n-Before we can call `SHA1`, we have to declare it. That is what this\n-part of the program is responsible for:\n+Before we can call the `SHA1` function defined in the OpenSSL library, we have\n+to declare it. That is what this part of the program does:\n \n ~~~~ {.xfail-test}\n extern mod crypto {\n-    fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8;\n-}\n+    fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8; }\n ~~~~\n \n-An `extern` module declaration containing function signatures introduces\n-the functions listed as _foreign functions_, that are implemented in some\n-other language (usually C) and accessed through Rust's foreign function\n-interface (FFI). An extern module like this is called a foreign module, and\n-implicitly tells the compiler to link with a library with the same name as\n-the module, and that it will find the foreign functions in that library.\n+An `extern` module declaration containing function signatures introduces the\n+functions listed as _foreign functions_. Foreign functions differ from regular\n+Rust functions in that they are implemented in some other language (usually C)\n+and called through Rust's foreign function interface (FFI). An extern module\n+like this is called a foreign module, and implicitly tells the compiler to\n+link with a library that contains the listed foreign functions, and has the\n+same name as the module.\n \n-In this case, it'll change the name `crypto` to a shared library name\n-in a platform-specific way (`libcrypto.so` on Linux, for example), and\n-link that in. If you want the module to have a different name from the\n-actual library, you can use the `\"link_name\"` attribute, like:\n+In this case, the Rust compiler changes the name `crypto` to a shared library\n+name in a platform-specific way (`libcrypto.so` on Linux, for example),\n+searches for the shared library with that name, and links the library into the\n+program. If you want the module to have a different name from the actual\n+library, you can use the `\"link_name\"` attribute, like:\n \n ~~~~ {.xfail-test}\n #[link_name = \"crypto\"]\n@@ -72,11 +71,11 @@ extern mod something {\n \n # Foreign calling conventions\n \n-Most foreign code will be C code, which usually uses the `cdecl` calling\n+Most foreign code is C code, which usually uses the `cdecl` calling\n convention, so that is what Rust uses by default when calling foreign\n functions. Some foreign functions, most notably the Windows API, use other\n-calling conventions, so Rust provides a way to hint to the compiler which\n-is expected by using the `\"abi\"` attribute:\n+calling conventions. Rust provides the `\"abi\"` attribute as a way to hint to\n+the compiler which calling convention to use:\n \n ~~~~\n #[cfg(target_os = \"win32\")]\n@@ -86,14 +85,14 @@ extern mod kernel32 {\n }\n ~~~~\n \n-The `\"abi\"` attribute applies to a foreign module (it can not be applied\n+The `\"abi\"` attribute applies to a foreign module (it cannot be applied\n to a single function within a module), and must be either `\"cdecl\"`\n-or `\"stdcall\"`. Other conventions may be defined in the future.\n+or `\"stdcall\"`. We may extend the compiler in the future to support other\n+calling conventions.\n \n # Unsafe pointers\n \n-The foreign `SHA1` function is declared to take three arguments, and\n-return a pointer.\n+The foreign `SHA1` function takes three arguments, and returns a pointer.\n \n ~~~~ {.xfail-test}\n # extern mod crypto {\n@@ -104,21 +103,20 @@ fn SHA1(src: *u8, sz: libc::c_uint, out: *u8) -> *u8;\n When declaring the argument types to a foreign function, the Rust\n compiler has no way to check whether your declaration is correct, so\n you have to be careful. If you get the number or types of the\n-arguments wrong, you're likely to get a segmentation fault. Or,\n+arguments wrong, you're likely to cause a segmentation fault. Or,\n probably even worse, your code will work on one platform, but break on\n another.\n \n-In this case, `SHA1` is defined as taking two `unsigned char*`\n-arguments and one `unsigned long`. The rust equivalents are `*u8`\n+In this case, we declare that `SHA1` takes two `unsigned char*`\n+arguments and one `unsigned long`. The Rust equivalents are `*u8`\n unsafe pointers and an `uint` (which, like `unsigned long`, is a\n machine-word-sized type).\n \n-Unsafe pointers can be created through various functions in the\n-standard lib, usually with `unsafe` somewhere in their name. You can\n-dereference an unsafe pointer with `*` operator, but use\n-caution\u2014unlike Rust's other pointer types, unsafe pointers are\n-completely unmanaged, so they might point at invalid memory, or be\n-null pointers.\n+The standard library provides various functions to create unsafe pointers,\n+such as those in `core::cast`. Most of these functions have `unsafe` in their\n+name.  You can dereference an unsafe pointer with the `*` operator, but use\n+caution: unlike Rust's other pointer types, unsafe pointers are completely\n+unmanaged, so they might point at invalid memory, or be null pointers.\n \n # Unsafe blocks\n \n@@ -134,12 +132,12 @@ fn sha1(data: ~str) -> ~str {\n         let bytes = str::to_bytes(data);\n         let hash = crypto::SHA1(vec::raw::to_ptr(bytes),\n                                 vec::len(bytes), ptr::null());\n-        return as_hex(vec::raw::from_buf(hash, 20u));\n+        return as_hex(vec::raw::from_buf(hash, 20));\n     }\n }\n ~~~~\n \n-Firstly, what does the `unsafe` keyword at the top of the function\n+First, what does the `unsafe` keyword at the top of the function\n mean? `unsafe` is a block modifier\u2014it declares the block following it\n to be known to be unsafe.\n \n@@ -158,8 +156,8 @@ advertise it to the world. An unsafe function is written like this:\n unsafe fn kaboom() { ~\"I'm harmless!\"; }\n ~~~~\n \n-This function can only be called from an unsafe block or another\n-unsafe function.\n+This function can only be called from an `unsafe` block or another\n+`unsafe` function.\n \n # Pointer fiddling\n \n@@ -179,35 +177,36 @@ Let's look at our `sha1` function again.\n let bytes = str::to_bytes(data);\n let hash = crypto::SHA1(vec::raw::to_ptr(bytes),\n                         vec::len(bytes), ptr::null());\n-return as_hex(vec::raw::from_buf(hash, 20u));\n+return as_hex(vec::raw::from_buf(hash, 20));\n # }\n # }\n ~~~~\n \n-The `str::to_bytes` function is perfectly safe: it converts a string to\n-a `[u8]`. This byte array is then fed to `vec::raw::to_ptr`, which\n+The `str::to_bytes` function is perfectly safe: it converts a string to a\n+`~[u8]`. The program then feeds this byte array to `vec::raw::to_ptr`, which\n returns an unsafe pointer to its contents.\n \n-This pointer will become invalid as soon as the vector it points into\n-is cleaned up, so you should be very careful how you use it. In this\n-case, the local variable `bytes` outlives the pointer, so we're good.\n+This pointer will become invalid at the end of the scope in which the vector\n+it points to (`bytes`) is valid, so you should be very careful how you use\n+it. In this case, the local variable `bytes` outlives the pointer, so we're\n+good.\n \n Passing a null pointer as the third argument to `SHA1` makes it use a\n static buffer, and thus save us the effort of allocating memory\n-ourselves. `ptr::null` is a generic function that will return an\n-unsafe null pointer of the correct type (Rust generics are awesome\n-like that\u2014they can take the right form depending on the type that they\n-are expected to return).\n-\n-Finally, `vec::raw::from_buf` builds up a new `[u8]` from the\n-unsafe pointer that was returned by `SHA1`. SHA1 digests are always\n-twenty bytes long, so we can pass `20u` for the length of the new\n+ourselves. `ptr::null` is a generic function that, in this case, returns an\n+unsafe null pointer of type `*u8`. (Rust generics are awesome\n+like that: they can take the right form depending on the type that they\n+are expected to return.)\n+\n+Finally, `vec::raw::from_buf` builds up a new `~[u8]` from the\n+unsafe pointer that `SHA1` returned. SHA1 digests are always\n+twenty bytes long, so we can pass `20` for the length of the new\n vector.\n \n # Passing structures\n \n C functions often take pointers to structs as arguments. Since Rust\n-structs are binary-compatible with C structs, Rust programs can call\n+`struct`s are binary-compatible with C structs, Rust programs can call\n such functions directly.\n \n This program uses the POSIX function `gettimeofday` to get a\n@@ -241,12 +240,12 @@ fn unix_time_in_microseconds() -> u64 unsafe {\n The `#[nolink]` attribute indicates that there's no foreign library to\n link in. The standard C library is already linked with Rust programs.\n \n-A `timeval`, in C, is a struct with two 32-bit integers. Thus, we\n-define a struct type with the same contents, and declare\n-`gettimeofday` to take a pointer to such a struct.\n+In C, a `timeval` is a struct with two 32-bit integer fields. Thus, we\n+define a `struct` type with the same contents, and declare\n+`gettimeofday` to take a pointer to such a `struct`.\n \n-The second argument to `gettimeofday` (the time zone) is not used by\n-this program, so it simply declares it to be a pointer to the nil\n-type. Since all null pointers have the same representation regardless of\n-their referent type, this is safe.\n+This program does not use the second argument to `gettimeofday` (the time\n+ zone), so the `extern mod` declaration for it simply declares this argument\n+ to be a pointer to the unit type (written `()`). Since all null pointers have\n+ the same representation regardless of their referent type, this is safe.\n "}]}