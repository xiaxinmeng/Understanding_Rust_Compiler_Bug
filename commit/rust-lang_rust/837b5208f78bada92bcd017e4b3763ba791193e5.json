{"sha": "837b5208f78bada92bcd017e4b3763ba791193e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzN2I1MjA4Zjc4YmFkYTkyYmNkMDE3ZTRiMzc2M2JhNzkxMTkzZTU=", "commit": {"author": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-06-21T06:14:07Z"}, "committer": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-06-21T06:14:07Z"}, "message": "Fix breakage due to rust-lang/rust#61968", "tree": {"sha": "8aa5a202ed39443b57460adfa5822d022a894ebc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8aa5a202ed39443b57460adfa5822d022a894ebc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/837b5208f78bada92bcd017e4b3763ba791193e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/837b5208f78bada92bcd017e4b3763ba791193e5", "html_url": "https://github.com/rust-lang/rust/commit/837b5208f78bada92bcd017e4b3763ba791193e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/837b5208f78bada92bcd017e4b3763ba791193e5/comments", "author": null, "committer": null, "parents": [{"sha": "7db5d0e6de112440dd13e78e2cc0bb1a7be25641", "url": "https://api.github.com/repos/rust-lang/rust/commits/7db5d0e6de112440dd13e78e2cc0bb1a7be25641", "html_url": "https://github.com/rust-lang/rust/commit/7db5d0e6de112440dd13e78e2cc0bb1a7be25641"}], "stats": {"total": 78, "additions": 37, "deletions": 41}, "files": [{"sha": "caf418c9b5b4bbd9a8668cbd746b6c4d8edfe105", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/837b5208f78bada92bcd017e4b3763ba791193e5/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837b5208f78bada92bcd017e4b3763ba791193e5/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=837b5208f78bada92bcd017e4b3763ba791193e5", "patch": "@@ -2,14 +2,14 @@ use crate::utils::{\n     get_trait_def_id, implements_trait, in_macro, in_macro_or_desugar, match_type, paths, snippet_opt,\n     span_lint_and_then, SpanlessEq,\n };\n+use if_chain::if_chain;\n use rustc::hir::intravisit::*;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_lint_pass, declare_tool_lint};\n-use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::Applicability;\n use syntax::ast::LitKind;\n-use syntax::source_map::{dummy_spanned, Span, DUMMY_SP};\n+use syntax::source_map::Span;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for boolean expressions that can be written more\n@@ -93,6 +93,18 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n     }\n \n     fn run(&mut self, e: &'v Expr) -> Result<Bool, String> {\n+        fn negate(bin_op_kind: BinOpKind) -> Option<BinOpKind> {\n+            match bin_op_kind {\n+                BinOpKind::Eq => Some(BinOpKind::Ne),\n+                BinOpKind::Ne => Some(BinOpKind::Eq),\n+                BinOpKind::Gt => Some(BinOpKind::Le),\n+                BinOpKind::Ge => Some(BinOpKind::Lt),\n+                BinOpKind::Lt => Some(BinOpKind::Ge),\n+                BinOpKind::Le => Some(BinOpKind::Gt),\n+                _ => None,\n+            }\n+        }\n+\n         // prevent folding of `cfg!` macros and the like\n         if !in_macro_or_desugar(e.span) {\n             match &e.node {\n@@ -115,33 +127,18 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n                 #[allow(clippy::cast_possible_truncation)]\n                 return Ok(Bool::Term(n as u8));\n             }\n-            let negated = match &e.node {\n-                ExprKind::Binary(binop, lhs, rhs) => {\n-                    if !implements_ord(self.cx, lhs) {\n-                        continue;\n-                    }\n \n-                    let mk_expr = |op| Expr {\n-                        hir_id: DUMMY_HIR_ID,\n-                        span: DUMMY_SP,\n-                        attrs: ThinVec::new(),\n-                        node: ExprKind::Binary(dummy_spanned(op), lhs.clone(), rhs.clone()),\n-                    };\n-                    match binop.node {\n-                        BinOpKind::Eq => mk_expr(BinOpKind::Ne),\n-                        BinOpKind::Ne => mk_expr(BinOpKind::Eq),\n-                        BinOpKind::Gt => mk_expr(BinOpKind::Le),\n-                        BinOpKind::Ge => mk_expr(BinOpKind::Lt),\n-                        BinOpKind::Lt => mk_expr(BinOpKind::Ge),\n-                        BinOpKind::Le => mk_expr(BinOpKind::Gt),\n-                        _ => continue,\n-                    }\n-                },\n-                _ => continue,\n-            };\n-            if SpanlessEq::new(self.cx).ignore_fn().eq_expr(&negated, expr) {\n-                #[allow(clippy::cast_possible_truncation)]\n-                return Ok(Bool::Not(Box::new(Bool::Term(n as u8))));\n+            if_chain! {\n+                if let ExprKind::Binary(e_binop, e_lhs, e_rhs) = &e.node;\n+                if implements_ord(self.cx, e_lhs);\n+                if let ExprKind::Binary(expr_binop, expr_lhs, expr_rhs) = &expr.node;\n+                if negate(e_binop.node) == Some(expr_binop.node);\n+                if SpanlessEq::new(self.cx).ignore_fn().eq_expr(e_lhs, expr_lhs);\n+                if SpanlessEq::new(self.cx).ignore_fn().eq_expr(e_rhs, expr_rhs);\n+                then {\n+                    #[allow(clippy::cast_possible_truncation)]\n+                    return Ok(Bool::Not(Box::new(Bool::Term(n as u8))));\n+                }\n             }\n         }\n         let n = self.terminals.len();"}, {"sha": "228d53ff11303cfd2b876113624479e0bc54af6f", "filename": "clippy_lints/src/double_comparison.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/837b5208f78bada92bcd017e4b3763ba791193e5/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837b5208f78bada92bcd017e4b3763ba791193e5/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_comparison.rs?ref=837b5208f78bada92bcd017e4b3763ba791193e5", "patch": "@@ -36,7 +36,7 @@ declare_lint_pass!(DoubleComparisons => [DOUBLE_COMPARISONS]);\n impl<'a, 'tcx> DoubleComparisons {\n     #[allow(clippy::similar_names)]\n     fn check_binop(self, cx: &LateContext<'a, 'tcx>, op: BinOpKind, lhs: &'tcx Expr, rhs: &'tcx Expr, span: Span) {\n-        let (lkind, llhs, lrhs, rkind, rlhs, rrhs) = match (lhs.node.clone(), rhs.node.clone()) {\n+        let (lkind, llhs, lrhs, rkind, rlhs, rrhs) = match (&lhs.node, &rhs.node) {\n             (ExprKind::Binary(lb, llhs, lrhs), ExprKind::Binary(rb, rlhs, rrhs)) => {\n                 (lb.node, llhs, lrhs, rb.node, rlhs, rrhs)\n             },"}, {"sha": "27170817def190679fe8070f99bb1a88e6893fa6", "filename": "clippy_lints/src/inherent_impl.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/837b5208f78bada92bcd017e4b3763ba791193e5/clippy_lints%2Fsrc%2Finherent_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837b5208f78bada92bcd017e4b3763ba791193e5/clippy_lints%2Fsrc%2Finherent_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finherent_impl.rs?ref=837b5208f78bada92bcd017e4b3763ba791193e5", "patch": "@@ -42,7 +42,7 @@ declare_clippy_lint! {\n #[allow(clippy::module_name_repetitions)]\n #[derive(Default)]\n pub struct MultipleInherentImpl {\n-    impls: FxHashMap<def_id::DefId, (Span, Generics)>,\n+    impls: FxHashMap<def_id::DefId, Span>,\n }\n \n impl_lint_pass!(MultipleInherentImpl => [MULTIPLE_INHERENT_IMPL]);\n@@ -51,8 +51,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MultipleInherentImpl {\n     fn check_item(&mut self, _: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if let ItemKind::Impl(_, _, _, ref generics, None, _, _) = item.node {\n             // Remember for each inherent implementation encoutered its span and generics\n-            self.impls\n-                .insert(item.hir_id.owner_def_id(), (item.span, generics.clone()));\n+            // but filter out implementations that have generic params (type or lifetime)\n+            if generics.params.len() == 0 {\n+                self.impls.insert(item.hir_id.owner_def_id(), item.span);\n+            }\n         }\n     }\n \n@@ -66,10 +68,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MultipleInherentImpl {\n                 .values()\n             {\n                 // Filter out implementations that have generic params (type or lifetime)\n-                let mut impl_spans = impls\n-                    .iter()\n-                    .filter_map(|impl_def| self.impls.get(impl_def))\n-                    .filter_map(|(span, generics)| if generics.params.len() == 0 { Some(span) } else { None });\n+                let mut impl_spans = impls.iter().filter_map(|impl_def| self.impls.get(impl_def));\n                 if let Some(initial_span) = impl_spans.nth(0) {\n                     impl_spans.for_each(|additional_span| {\n                         span_lint_and_then("}, {"sha": "9e0f7d0f3c2e1abe7b8de0cfbcaedb57cc1faaea", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/837b5208f78bada92bcd017e4b3763ba791193e5/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837b5208f78bada92bcd017e4b3763ba791193e5/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=837b5208f78bada92bcd017e4b3763ba791193e5", "patch": "@@ -129,7 +129,7 @@ impl QuestionMark {\n         }\n     }\n \n-    fn return_expression(block: &Block) -> Option<P<Expr>> {\n+    fn return_expression(block: &Block) -> Option<&P<Expr>> {\n         // Check if last expression is a return statement. Then, return the expression\n         if_chain! {\n             if block.stmts.len() == 1;\n@@ -139,7 +139,7 @@ impl QuestionMark {\n             if let &Some(ref ret_expr) = ret_expr;\n \n             then {\n-                return Some(ret_expr.clone());\n+                return Some(ret_expr);\n             }\n         }\n \n@@ -148,7 +148,7 @@ impl QuestionMark {\n             if block.stmts.len() == 0;\n             if let Some(ExprKind::Ret(Some(ret_expr))) = block.expr.as_ref().map(|e| &e.node);\n             then {\n-                return Some(ret_expr.clone());\n+                return Some(ret_expr);\n             }\n         }\n "}, {"sha": "b7bc4900c5d3ab72baa56bfcb144402116616ece", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/837b5208f78bada92bcd017e4b3763ba791193e5/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/837b5208f78bada92bcd017e4b3763ba791193e5/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=837b5208f78bada92bcd017e4b3763ba791193e5", "patch": "@@ -315,14 +315,14 @@ pub fn implements_trait<'a, 'tcx>(\n ///     }\n /// }\n /// ```\n-pub fn trait_ref_of_method(cx: &LateContext<'_, '_>, hir_id: HirId) -> Option<TraitRef> {\n+pub fn trait_ref_of_method<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, hir_id: HirId) -> Option<&'a TraitRef> {\n     // Get the implemented trait for the current function\n     let parent_impl = cx.tcx.hir().get_parent_item(hir_id);\n     if_chain! {\n         if parent_impl != hir::CRATE_HIR_ID;\n         if let hir::Node::Item(item) = cx.tcx.hir().get_by_hir_id(parent_impl);\n         if let hir::ItemKind::Impl(_, _, _, _, trait_ref, _, _) = &item.node;\n-        then { return trait_ref.clone(); }\n+        then { return trait_ref.as_ref(); }\n     }\n     None\n }"}]}