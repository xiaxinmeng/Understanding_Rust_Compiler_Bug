{"sha": "c70b7aafae283b69762ee809d6b2b5adaf0f3c43", "node_id": "C_kwDOAAsO6NoAKGM3MGI3YWFmYWUyODNiNjk3NjJlZTgwOWQ2YjJiNWFkYWYwZjNjNDM", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2023-01-21T19:49:23Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2023-01-25T06:08:48Z"}, "message": "rustc_metadata: Fix `encode_attrs`\n\nThis function didn't do what the authors intended it to do.\n\n- Due to `move` in the closure `is_public` wasn't captured by mutalbe reference and wasn't used as a cache.\n- Due to iterator cloning all the `should_encode_attr` logic run for the second time to calculate `may_have_doc_links`\n\nThis PR fixes these issues, and calculates all the needed attribute flags in one go.", "tree": {"sha": "0fdfa5e6643b3d38b814cce9176a76a67d91e4b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0fdfa5e6643b3d38b814cce9176a76a67d91e4b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c70b7aafae283b69762ee809d6b2b5adaf0f3c43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c70b7aafae283b69762ee809d6b2b5adaf0f3c43", "html_url": "https://github.com/rust-lang/rust/commit/c70b7aafae283b69762ee809d6b2b5adaf0f3c43", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c70b7aafae283b69762ee809d6b2b5adaf0f3c43/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8e6a9e8b6251bbc8276cb78cabe1998deecbed7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7", "html_url": "https://github.com/rust-lang/rust/commit/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7"}], "stats": {"total": 77, "additions": 48, "deletions": 29}, "files": [{"sha": "e6430d327879f15df5c39a8e82404a856124115a", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 48, "deletions": 29, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/c70b7aafae283b69762ee809d6b2b5adaf0f3c43/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c70b7aafae283b69762ee809d6b2b5adaf0f3c43/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=c70b7aafae283b69762ee809d6b2b5adaf0f3c43", "patch": "@@ -3,6 +3,7 @@ use crate::rmeta::def_path_hash_map::DefPathHashMapRef;\n use crate::rmeta::table::TableBuilder;\n use crate::rmeta::*;\n \n+use rustc_ast::util::comments;\n use rustc_ast::Attribute;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n@@ -760,36 +761,54 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n }\n \n+struct AnalyzeAttrState {\n+    is_exported: bool,\n+    may_have_doc_links: bool,\n+    is_doc_hidden: bool,\n+}\n+\n /// Returns whether an attribute needs to be recorded in metadata, that is, if it's usable and\n /// useful in downstream crates. Local-only attributes are an obvious example, but some\n /// rustdoc-specific attributes can equally be of use while documenting the current crate only.\n ///\n /// Removing these superfluous attributes speeds up compilation by making the metadata smaller.\n ///\n-/// Note: the `is_def_id_public` parameter is used to cache whether the given `DefId` has a public\n+/// Note: the `is_exported` parameter is used to cache whether the given `DefId` has a public\n /// visibility: this is a piece of data that can be computed once per defid, and not once per\n /// attribute. Some attributes would only be usable downstream if they are public.\n #[inline]\n-fn should_encode_attr(\n-    tcx: TyCtxt<'_>,\n-    attr: &Attribute,\n-    def_id: LocalDefId,\n-    is_def_id_public: &mut Option<bool>,\n-) -> bool {\n+fn analyze_attr(attr: &Attribute, state: &mut AnalyzeAttrState) -> bool {\n+    let mut should_encode = false;\n     if rustc_feature::is_builtin_only_local(attr.name_or_empty()) {\n         // Attributes marked local-only don't need to be encoded for downstream crates.\n-        false\n-    } else if attr.doc_str().is_some() {\n-        // We keep all public doc comments because they might be \"imported\" into downstream crates\n-        // if they use `#[doc(inline)]` to copy an item's documentation into their own.\n-        *is_def_id_public.get_or_insert_with(|| tcx.effective_visibilities(()).is_exported(def_id))\n+    } else if let Some(s) = attr.doc_str() {\n+        // We keep all doc comments reachable to rustdoc because they might be \"imported\" into\n+        // downstream crates if they use `#[doc(inline)]` to copy an item's documentation into\n+        // their own.\n+        if state.is_exported {\n+            should_encode = true;\n+            if comments::may_have_doc_links(s.as_str()) {\n+                state.may_have_doc_links = true;\n+            }\n+        }\n     } else if attr.has_name(sym::doc) {\n-        // If this is a `doc` attribute, and it's marked `inline` (as in `#[doc(inline)]`), we can\n-        // remove it. It won't be inlinable in downstream crates.\n-        attr.meta_item_list().map(|l| l.iter().any(|l| !l.has_name(sym::inline))).unwrap_or(false)\n+        // If this is a `doc` attribute that doesn't have anything except maybe `inline` (as in\n+        // `#[doc(inline)]`), then we can remove it. It won't be inlinable in downstream crates.\n+        if let Some(item_list) = attr.meta_item_list() {\n+            for item in item_list {\n+                if !item.has_name(sym::inline) {\n+                    should_encode = true;\n+                    if item.has_name(sym::hidden) {\n+                        state.is_doc_hidden = true;\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n     } else {\n-        true\n+        should_encode = true;\n     }\n+    should_encode\n }\n \n fn should_encode_visibility(def_kind: DefKind) -> bool {\n@@ -1109,24 +1128,24 @@ fn should_encode_trait_impl_trait_tys(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_attrs(&mut self, def_id: LocalDefId) {\n         let tcx = self.tcx;\n-        let mut is_public: Option<bool> = None;\n-\n-        let hir_attrs = tcx.hir().attrs(tcx.hir().local_def_id_to_hir_id(def_id));\n-        let mut attrs = hir_attrs\n+        let mut state = AnalyzeAttrState {\n+            is_exported: tcx.effective_visibilities(()).is_exported(def_id),\n+            may_have_doc_links: false,\n+            is_doc_hidden: false,\n+        };\n+        let attr_iter = tcx\n+            .hir()\n+            .attrs(tcx.hir().local_def_id_to_hir_id(def_id))\n             .iter()\n-            .filter(move |attr| should_encode_attr(tcx, attr, def_id, &mut is_public));\n+            .filter(|attr| analyze_attr(attr, &mut state));\n+\n+        record_array!(self.tables.attributes[def_id.to_def_id()] <- attr_iter);\n \n-        record_array!(self.tables.attributes[def_id.to_def_id()] <- attrs.clone());\n         let mut attr_flags = AttrFlags::empty();\n-        if attrs.any(|attr| attr.may_have_doc_links()) {\n+        if state.may_have_doc_links {\n             attr_flags |= AttrFlags::MAY_HAVE_DOC_LINKS;\n         }\n-        if hir_attrs\n-            .iter()\n-            .filter(|attr| attr.has_name(sym::doc))\n-            .filter_map(|attr| attr.meta_item_list())\n-            .any(|items| items.iter().any(|item| item.has_name(sym::hidden)))\n-        {\n+        if state.is_doc_hidden {\n             attr_flags |= AttrFlags::IS_DOC_HIDDEN;\n         }\n         if !attr_flags.is_empty() {"}]}