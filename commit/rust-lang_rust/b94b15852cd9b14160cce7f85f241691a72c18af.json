{"sha": "b94b15852cd9b14160cce7f85f241691a72c18af", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5NGIxNTg1MmNkOWIxNDE2MGNjZTdmODVmMjQxNjkxYTcyYzE4YWY=", "commit": {"author": {"name": "Emilio Cobos \u00c1lvarez", "email": "me@emiliocobos.me", "date": "2016-05-20T00:43:18Z"}, "committer": {"name": "Emilio Cobos \u00c1lvarez", "email": "me@emiliocobos.me", "date": "2016-06-22T18:48:55Z"}, "message": "std: sync: Implement recv_timeout()", "tree": {"sha": "d15c7db87391d1fb5010e1be886fd731736d7619", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d15c7db87391d1fb5010e1be886fd731736d7619"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b94b15852cd9b14160cce7f85f241691a72c18af", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2\n\niQEcBAABCAAGBQJXat2XAAoJEAVrcnu5wQJ8jI4IAJhmV0/6IfS6eM2RY6bJ1s6i\npiV2N1trpWmMBm9sq/PzPnnILakgEDs6B6yshee80UtcHhGiRkfuwvjqrbnWXUxG\ni+tCkt9rCp3Cf5ibzUWB+Zxr/mOwZYB5MkrNqc13xEQkLPJZ4RpwZb5ofBQRC6FD\nMGIcVYRToBcgoZnXx7mH1nxLWhk7DsWxC2dxBwSpx1zF3uZeYcci5h5v7FoGswj2\nB6jI4zygxuNFsXh30hzAT1UZv7A9EiLGbbCnt/Vb/QWpRiHtVDMdSrn136HOuVKZ\n9eWFCVRKuQKUp8HQWBaE/EV8w67jQJqQUG1xbeV2jWB9T29OBO2t3xjgOUUjlwM=\n=SDuU\n-----END PGP SIGNATURE-----", "payload": "tree d15c7db87391d1fb5010e1be886fd731736d7619\nparent e41cdabc3e5fff02abfef513d3289370fae358b8\nauthor Emilio Cobos \u00c1lvarez <me@emiliocobos.me> 1463704998 +0200\ncommitter Emilio Cobos \u00c1lvarez <me@emiliocobos.me> 1466621335 +0200\n\nstd: sync: Implement recv_timeout()\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b94b15852cd9b14160cce7f85f241691a72c18af", "html_url": "https://github.com/rust-lang/rust/commit/b94b15852cd9b14160cce7f85f241691a72c18af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b94b15852cd9b14160cce7f85f241691a72c18af/comments", "author": {"login": "emilio", "id": 1323194, "node_id": "MDQ6VXNlcjEzMjMxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1323194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emilio", "html_url": "https://github.com/emilio", "followers_url": "https://api.github.com/users/emilio/followers", "following_url": "https://api.github.com/users/emilio/following{/other_user}", "gists_url": "https://api.github.com/users/emilio/gists{/gist_id}", "starred_url": "https://api.github.com/users/emilio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emilio/subscriptions", "organizations_url": "https://api.github.com/users/emilio/orgs", "repos_url": "https://api.github.com/users/emilio/repos", "events_url": "https://api.github.com/users/emilio/events{/privacy}", "received_events_url": "https://api.github.com/users/emilio/received_events", "type": "User", "site_admin": false}, "committer": {"login": "emilio", "id": 1323194, "node_id": "MDQ6VXNlcjEzMjMxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1323194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emilio", "html_url": "https://github.com/emilio", "followers_url": "https://api.github.com/users/emilio/followers", "following_url": "https://api.github.com/users/emilio/following{/other_user}", "gists_url": "https://api.github.com/users/emilio/gists{/gist_id}", "starred_url": "https://api.github.com/users/emilio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emilio/subscriptions", "organizations_url": "https://api.github.com/users/emilio/orgs", "repos_url": "https://api.github.com/users/emilio/repos", "events_url": "https://api.github.com/users/emilio/events{/privacy}", "received_events_url": "https://api.github.com/users/emilio/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e41cdabc3e5fff02abfef513d3289370fae358b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/e41cdabc3e5fff02abfef513d3289370fae358b8", "html_url": "https://github.com/rust-lang/rust/commit/e41cdabc3e5fff02abfef513d3289370fae358b8"}], "stats": {"total": 438, "additions": 396, "deletions": 42}, "files": [{"sha": "4a70de0e7d8fccf7bba8b7de64fc53339c1e5ef2", "filename": "src/libstd/sync/mpsc/blocking.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b94b15852cd9b14160cce7f85f241691a72c18af/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94b15852cd9b14160cce7f85f241691a72c18af/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs?ref=b94b15852cd9b14160cce7f85f241691a72c18af", "patch": "@@ -16,6 +16,7 @@ use sync::Arc;\n use marker::{Sync, Send};\n use mem;\n use clone::Clone;\n+use time::Instant;\n \n struct Inner {\n     thread: Thread,\n@@ -74,7 +75,6 @@ impl SignalToken {\n     pub unsafe fn cast_from_usize(signal_ptr: usize) -> SignalToken {\n         SignalToken { inner: mem::transmute(signal_ptr) }\n     }\n-\n }\n \n impl WaitToken {\n@@ -83,4 +83,16 @@ impl WaitToken {\n             thread::park()\n         }\n     }\n+\n+    /// Returns true if we wake up normally, false otherwise.\n+    pub fn wait_max_until(self, end: Instant) -> bool {\n+        while !self.inner.woken.load(Ordering::SeqCst) {\n+            let now = Instant::now();\n+            if now >= end {\n+                return false;\n+            }\n+            thread::park_timeout(end - now)\n+        }\n+        true\n+    }\n }"}, {"sha": "34bc210b3c8239eb3bfef6261653a5a35a610a82", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 289, "deletions": 13, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/b94b15852cd9b14160cce7f85f241691a72c18af/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94b15852cd9b14160cce7f85f241691a72c18af/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=b94b15852cd9b14160cce7f85f241691a72c18af", "patch": "@@ -134,9 +134,9 @@\n // senders. Under the hood, however, there are actually three flavors of\n // channels in play.\n //\n-// * Flavor::Oneshots - these channels are highly optimized for the one-send use case.\n-//              They contain as few atomics as possible and involve one and\n-//              exactly one allocation.\n+// * Flavor::Oneshots - these channels are highly optimized for the one-send use\n+//                      case. They contain as few atomics as possible and\n+//                      involve one and exactly one allocation.\n // * Streams - these channels are optimized for the non-shared use case. They\n //             use a different concurrent queue that is more tailored for this\n //             use case. The initial allocation of this flavor of channel is not\n@@ -148,9 +148,9 @@\n //\n // ## Concurrent queues\n //\n-// The basic idea of Rust's Sender/Receiver types is that send() never blocks, but\n-// recv() obviously blocks. This means that under the hood there must be some\n-// shared and concurrent queue holding all of the actual data.\n+// The basic idea of Rust's Sender/Receiver types is that send() never blocks,\n+// but recv() obviously blocks. This means that under the hood there must be\n+// some shared and concurrent queue holding all of the actual data.\n //\n // With two flavors of channels, two flavors of queues are also used. We have\n // chosen to use queues from a well-known author that are abbreviated as SPSC\n@@ -271,6 +271,7 @@ use fmt;\n use mem;\n use cell::UnsafeCell;\n use marker::Reflect;\n+use time::{Duration, Instant};\n \n #[unstable(feature = \"mpsc_select\", issue = \"27800\")]\n pub use self::select::{Select, Handle};\n@@ -379,6 +380,19 @@ pub enum TryRecvError {\n     Disconnected,\n }\n \n+/// This enumeration is the list of possible errors that `recv_timeout` could\n+/// not return data when called.\n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+#[unstable(feature = \"mpsc_recv_timeout\", issue = \"34029\")]\n+pub enum RecvTimeoutError {\n+    /// This channel is currently empty, but the sender(s) have not yet\n+    /// disconnected, so data may yet become available.\n+    Timeout,\n+    /// This channel's sending half has become disconnected, and there will\n+    /// never be any more data received on this channel\n+    Disconnected,\n+}\n+\n /// This enumeration is the list of the possible error outcomes for the\n /// `SyncSender::try_send` method.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -838,30 +852,30 @@ impl<T> Receiver<T> {\n         loop {\n             let new_port = match *unsafe { self.inner() } {\n                 Flavor::Oneshot(ref p) => {\n-                    match unsafe { (*p.get()).recv() } {\n+                    match unsafe { (*p.get()).recv(None) } {\n                         Ok(t) => return Ok(t),\n-                        Err(oneshot::Empty) => return unreachable!(),\n                         Err(oneshot::Disconnected) => return Err(RecvError),\n                         Err(oneshot::Upgraded(rx)) => rx,\n+                        Err(oneshot::Empty) => unreachable!(),\n                     }\n                 }\n                 Flavor::Stream(ref p) => {\n-                    match unsafe { (*p.get()).recv() } {\n+                    match unsafe { (*p.get()).recv(None) } {\n                         Ok(t) => return Ok(t),\n-                        Err(stream::Empty) => return unreachable!(),\n                         Err(stream::Disconnected) => return Err(RecvError),\n                         Err(stream::Upgraded(rx)) => rx,\n+                        Err(stream::Empty) => unreachable!(),\n                     }\n                 }\n                 Flavor::Shared(ref p) => {\n-                    match unsafe { (*p.get()).recv() } {\n+                    match unsafe { (*p.get()).recv(None) } {\n                         Ok(t) => return Ok(t),\n-                        Err(shared::Empty) => return unreachable!(),\n                         Err(shared::Disconnected) => return Err(RecvError),\n+                        Err(shared::Empty) => unreachable!(),\n                     }\n                 }\n                 Flavor::Sync(ref p) => return unsafe {\n-                    (*p.get()).recv().map_err(|()| RecvError)\n+                    (*p.get()).recv(None).map_err(|_| RecvError)\n                 }\n             };\n             unsafe {\n@@ -870,6 +884,98 @@ impl<T> Receiver<T> {\n         }\n     }\n \n+    /// Attempts to wait for a value on this receiver, returning an error if the\n+    /// corresponding channel has hung up, or if it waits more than `timeout`.\n+    ///\n+    /// This function will always block the current thread if there is no data\n+    /// available and it's possible for more data to be sent. Once a message is\n+    /// sent to the corresponding `Sender`, then this receiver will wake up and\n+    /// return that message.\n+    ///\n+    /// If the corresponding `Sender` has disconnected, or it disconnects while\n+    /// this call is blocking, this call will wake up and return `Err` to\n+    /// indicate that no more messages can ever be received on this channel.\n+    /// However, since channels are buffered, messages sent before the disconnect\n+    /// will still be properly received.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(mpsc_recv_timeout)]\n+    ///\n+    /// use std::sync::mpsc::{self, RecvTimeoutError};\n+    /// use std::time::Duration;\n+    ///\n+    /// let (send, recv) = mpsc::channel::<()>();\n+    ///\n+    /// let timeout = Duration::from_millis(100);\n+    /// assert_eq!(Err(RecvTimeoutError::Timeout), recv.recv_timeout(timeout));\n+    /// ```\n+    #[unstable(feature = \"mpsc_recv_timeout\", issue = \"34029\")]\n+    pub fn recv_timeout(&self, timeout: Duration) -> Result<T, RecvTimeoutError> {\n+        // Do an optimistic try_recv to avoid the performance impact of\n+        // Instant::now() in the full-channel case.\n+        match self.try_recv() {\n+            Ok(result)\n+                => Ok(result),\n+            Err(TryRecvError::Disconnected)\n+                => Err(RecvTimeoutError::Disconnected),\n+            Err(TryRecvError::Empty)\n+                => self.recv_max_until(Instant::now() + timeout)\n+        }\n+    }\n+\n+    fn recv_max_until(&self, deadline: Instant) -> Result<T, RecvTimeoutError> {\n+        use self::RecvTimeoutError::*;\n+\n+        loop {\n+            let port_or_empty = match *unsafe { self.inner() } {\n+                Flavor::Oneshot(ref p) => {\n+                    match unsafe { (*p.get()).recv(Some(deadline)) } {\n+                        Ok(t) => return Ok(t),\n+                        Err(oneshot::Disconnected) => return Err(Disconnected),\n+                        Err(oneshot::Upgraded(rx)) => Some(rx),\n+                        Err(oneshot::Empty) => None,\n+                    }\n+                }\n+                Flavor::Stream(ref p) => {\n+                    match unsafe { (*p.get()).recv(Some(deadline)) } {\n+                        Ok(t) => return Ok(t),\n+                        Err(stream::Disconnected) => return Err(Disconnected),\n+                        Err(stream::Upgraded(rx)) => Some(rx),\n+                        Err(stream::Empty) => None,\n+                    }\n+                }\n+                Flavor::Shared(ref p) => {\n+                    match unsafe { (*p.get()).recv(Some(deadline)) } {\n+                        Ok(t) => return Ok(t),\n+                        Err(shared::Disconnected) => return Err(Disconnected),\n+                        Err(shared::Empty) => None,\n+                    }\n+                }\n+                Flavor::Sync(ref p) => {\n+                    match unsafe { (*p.get()).recv(Some(deadline)) } {\n+                        Ok(t) => return Ok(t),\n+                        Err(sync::Disconnected) => return Err(Disconnected),\n+                        Err(sync::Empty) => None,\n+                    }\n+                }\n+            };\n+\n+            if let Some(new_port) = port_or_empty {\n+                unsafe {\n+                    mem::swap(self.inner_mut(), new_port.inner_mut());\n+                }\n+            }\n+\n+            // If we're already passed the deadline, and we're here without\n+            // data, return a timeout, else try again.\n+            if Instant::now() >= deadline {\n+                return Err(Timeout);\n+            }\n+        }\n+    }\n+\n     /// Returns an iterator that will block waiting for messages, but never\n     /// `panic!`. It will return `None` when the channel has hung up.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1141,6 +1247,7 @@ mod tests {\n     use env;\n     use super::*;\n     use thread;\n+    use time::{Duration, Instant};\n \n     pub fn stress_factor() -> usize {\n         match env::var(\"RUST_TEST_STRESS\") {\n@@ -1539,6 +1646,87 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    fn oneshot_single_thread_recv_timeout() {\n+        let (tx, rx) = channel();\n+        tx.send(()).unwrap();\n+        assert_eq!(rx.recv_timeout(Duration::from_millis(1)), Ok(()));\n+        assert_eq!(rx.recv_timeout(Duration::from_millis(1)), Err(RecvTimeoutError::Timeout));\n+        tx.send(()).unwrap();\n+        assert_eq!(rx.recv_timeout(Duration::from_millis(1)), Ok(()));\n+    }\n+\n+    #[test]\n+    fn stress_recv_timeout_two_threads() {\n+        let (tx, rx) = channel();\n+        let stress = stress_factor() + 100;\n+        let timeout = Duration::from_millis(100);\n+\n+        thread::spawn(move || {\n+            for i in 0..stress {\n+                if i % 2 == 0 {\n+                    thread::sleep(timeout * 2);\n+                }\n+                tx.send(1usize).unwrap();\n+            }\n+        });\n+\n+        let mut recv_count = 0;\n+        loop {\n+            match rx.recv_timeout(timeout) {\n+                Ok(n) => {\n+                    assert_eq!(n, 1usize);\n+                    recv_count += 1;\n+                }\n+                Err(RecvTimeoutError::Timeout) => continue,\n+                Err(RecvTimeoutError::Disconnected) => break,\n+            }\n+        }\n+\n+        assert_eq!(recv_count, stress);\n+    }\n+\n+    #[test]\n+    fn recv_timeout_upgrade() {\n+        let (tx, rx) = channel::<()>();\n+        let timeout = Duration::from_millis(1);\n+        let _tx_clone = tx.clone();\n+\n+        let start = Instant::now();\n+        assert_eq!(rx.recv_timeout(timeout), Err(RecvTimeoutError::Timeout));\n+        assert!(Instant::now() >= start + timeout);\n+    }\n+\n+    #[test]\n+    fn stress_recv_timeout_shared() {\n+        let (tx, rx) = channel();\n+        let stress = stress_factor() + 100;\n+\n+        for i in 0..stress {\n+            let tx = tx.clone();\n+            thread::spawn(move || {\n+                thread::sleep(Duration::from_millis(i as u64 * 10));\n+                tx.send(1usize).unwrap();\n+            });\n+        }\n+\n+        drop(tx);\n+\n+        let mut recv_count = 0;\n+        loop {\n+            match rx.recv_timeout(Duration::from_millis(10)) {\n+                Ok(n) => {\n+                    assert_eq!(n, 1usize);\n+                    recv_count += 1;\n+                }\n+                Err(RecvTimeoutError::Timeout) => continue,\n+                Err(RecvTimeoutError::Disconnected) => break,\n+            }\n+        }\n+\n+        assert_eq!(recv_count, stress);\n+    }\n+\n     #[test]\n     fn recv_a_lot() {\n         // Regression test that we don't run out of stack in scheduler context\n@@ -1547,6 +1735,24 @@ mod tests {\n         for _ in 0..10000 { rx.recv().unwrap(); }\n     }\n \n+    #[test]\n+    fn shared_recv_timeout() {\n+        let (tx, rx) = channel();\n+        let total = 5;\n+        for _ in 0..total {\n+            let tx = tx.clone();\n+            thread::spawn(move|| {\n+                tx.send(()).unwrap();\n+            });\n+        }\n+\n+        for _ in 0..total { rx.recv().unwrap(); }\n+\n+        assert_eq!(rx.recv_timeout(Duration::from_millis(1)), Err(RecvTimeoutError::Timeout));\n+        tx.send(()).unwrap();\n+        assert_eq!(rx.recv_timeout(Duration::from_millis(1)), Ok(()));\n+    }\n+\n     #[test]\n     fn shared_chan_stress() {\n         let (tx, rx) = channel();\n@@ -1689,6 +1895,7 @@ mod sync_tests {\n     use env;\n     use thread;\n     use super::*;\n+    use time::Duration;\n \n     pub fn stress_factor() -> usize {\n         match env::var(\"RUST_TEST_STRESS\") {\n@@ -1720,6 +1927,14 @@ mod sync_tests {\n         assert_eq!(rx.recv().unwrap(), 1);\n     }\n \n+    #[test]\n+    fn recv_timeout() {\n+        let (tx, rx) = sync_channel::<i32>(1);\n+        assert_eq!(rx.recv_timeout(Duration::from_millis(1)), Err(RecvTimeoutError::Timeout));\n+        tx.send(1).unwrap();\n+        assert_eq!(rx.recv_timeout(Duration::from_millis(1)), Ok(1));\n+    }\n+\n     #[test]\n     fn smoke_threads() {\n         let (tx, rx) = sync_channel::<i32>(0);\n@@ -1801,6 +2016,67 @@ mod sync_tests {\n         }\n     }\n \n+    #[test]\n+    fn stress_recv_timeout_two_threads() {\n+        let (tx, rx) = sync_channel::<i32>(0);\n+\n+        thread::spawn(move|| {\n+            for _ in 0..10000 { tx.send(1).unwrap(); }\n+        });\n+\n+        let mut recv_count = 0;\n+        loop {\n+            match rx.recv_timeout(Duration::from_millis(1)) {\n+                Ok(v) => {\n+                    assert_eq!(v, 1);\n+                    recv_count += 1;\n+                },\n+                Err(RecvTimeoutError::Timeout) => continue,\n+                Err(RecvTimeoutError::Disconnected) => break,\n+            }\n+        }\n+\n+        assert_eq!(recv_count, 10000);\n+    }\n+\n+    #[test]\n+    fn stress_recv_timeout_shared() {\n+        const AMT: u32 = 1000;\n+        const NTHREADS: u32 = 8;\n+        let (tx, rx) = sync_channel::<i32>(0);\n+        let (dtx, drx) = sync_channel::<()>(0);\n+\n+        thread::spawn(move|| {\n+            let mut recv_count = 0;\n+            loop {\n+                match rx.recv_timeout(Duration::from_millis(10)) {\n+                    Ok(v) => {\n+                        assert_eq!(v, 1);\n+                        recv_count += 1;\n+                    },\n+                    Err(RecvTimeoutError::Timeout) => continue,\n+                    Err(RecvTimeoutError::Disconnected) => break,\n+                }\n+            }\n+\n+            assert_eq!(recv_count, AMT * NTHREADS);\n+            assert!(rx.try_recv().is_err());\n+\n+            dtx.send(()).unwrap();\n+        });\n+\n+        for _ in 0..NTHREADS {\n+            let tx = tx.clone();\n+            thread::spawn(move|| {\n+                for _ in 0..AMT { tx.send(1).unwrap(); }\n+            });\n+        }\n+\n+        drop(tx);\n+\n+        drx.recv().unwrap();\n+    }\n+\n     #[test]\n     fn stress_shared() {\n         const AMT: u32 = 1000;"}, {"sha": "7a35ea6bbaaa20c184116b5f1b58be4c17090acf", "filename": "src/libstd/sync/mpsc/oneshot.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b94b15852cd9b14160cce7f85f241691a72c18af/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94b15852cd9b14160cce7f85f241691a72c18af/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs?ref=b94b15852cd9b14160cce7f85f241691a72c18af", "patch": "@@ -41,6 +41,7 @@ use sync::mpsc::Receiver;\n use sync::mpsc::blocking::{self, SignalToken};\n use core::mem;\n use sync::atomic::{AtomicUsize, Ordering};\n+use time::Instant;\n \n // Various states you can find a port in.\n const EMPTY: usize = 0;          // initial state: no data, no blocked receiver\n@@ -136,7 +137,7 @@ impl<T> Packet<T> {\n         }\n     }\n \n-    pub fn recv(&mut self) -> Result<T, Failure<T>> {\n+    pub fn recv(&mut self, deadline: Option<Instant>) -> Result<T, Failure<T>> {\n         // Attempt to not block the thread (it's a little expensive). If it looks\n         // like we're not empty, then immediately go through to `try_recv`.\n         if self.state.load(Ordering::SeqCst) == EMPTY {\n@@ -145,8 +146,16 @@ impl<T> Packet<T> {\n \n             // race with senders to enter the blocking state\n             if self.state.compare_and_swap(EMPTY, ptr, Ordering::SeqCst) == EMPTY {\n-                wait_token.wait();\n-                debug_assert!(self.state.load(Ordering::SeqCst) != EMPTY);\n+                if let Some(deadline) = deadline {\n+                    let timed_out = !wait_token.wait_max_until(deadline);\n+                    // Try to reset the state\n+                    if timed_out {\n+                        try!(self.abort_selection().map_err(Upgraded));\n+                    }\n+                } else {\n+                    wait_token.wait();\n+                    debug_assert!(self.state.load(Ordering::SeqCst) != EMPTY);\n+                }\n             } else {\n                 // drop the signal token, since we never blocked\n                 drop(unsafe { SignalToken::cast_from_usize(ptr) });"}, {"sha": "baa4db7e5c0fa3e8e08b94395ee7c572fe4e2ac4", "filename": "src/libstd/sync/mpsc/shared.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b94b15852cd9b14160cce7f85f241691a72c18af/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94b15852cd9b14160cce7f85f241691a72c18af/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs?ref=b94b15852cd9b14160cce7f85f241691a72c18af", "patch": "@@ -30,6 +30,7 @@ use sync::mpsc::select::StartResult::*;\n use sync::mpsc::select::StartResult;\n use sync::{Mutex, MutexGuard};\n use thread;\n+use time::Instant;\n \n const DISCONNECTED: isize = isize::MIN;\n const FUDGE: isize = 1024;\n@@ -66,7 +67,7 @@ impl<T> Packet<T> {\n     // Creation of a packet *must* be followed by a call to postinit_lock\n     // and later by inherit_blocker\n     pub fn new() -> Packet<T> {\n-        let p = Packet {\n+        Packet {\n             queue: mpsc::Queue::new(),\n             cnt: AtomicIsize::new(0),\n             steals: 0,\n@@ -75,8 +76,7 @@ impl<T> Packet<T> {\n             port_dropped: AtomicBool::new(false),\n             sender_drain: AtomicIsize::new(0),\n             select_lock: Mutex::new(()),\n-        };\n-        return p;\n+        }\n     }\n \n     // This function should be used after newly created Packet\n@@ -216,7 +216,7 @@ impl<T> Packet<T> {\n         Ok(())\n     }\n \n-    pub fn recv(&mut self) -> Result<T, Failure> {\n+    pub fn recv(&mut self, deadline: Option<Instant>) -> Result<T, Failure> {\n         // This code is essentially the exact same as that found in the stream\n         // case (see stream.rs)\n         match self.try_recv() {\n@@ -226,7 +226,14 @@ impl<T> Packet<T> {\n \n         let (wait_token, signal_token) = blocking::tokens();\n         if self.decrement(signal_token) == Installed {\n-            wait_token.wait()\n+            if let Some(deadline) = deadline {\n+                let timed_out = !wait_token.wait_max_until(deadline);\n+                if timed_out {\n+                    self.abort_selection(false);\n+                }\n+            } else {\n+                wait_token.wait();\n+            }\n         }\n \n         match self.try_recv() {"}, {"sha": "aa1254c8641f571aef2f68c16a9be534e97707f8", "filename": "src/libstd/sync/mpsc/stream.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b94b15852cd9b14160cce7f85f241691a72c18af/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94b15852cd9b14160cce7f85f241691a72c18af/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs?ref=b94b15852cd9b14160cce7f85f241691a72c18af", "patch": "@@ -25,6 +25,7 @@ use self::Message::*;\n use core::cmp;\n use core::isize;\n use thread;\n+use time::Instant;\n \n use sync::atomic::{AtomicIsize, AtomicUsize, Ordering, AtomicBool};\n use sync::mpsc::Receiver;\n@@ -172,7 +173,7 @@ impl<T> Packet<T> {\n         Err(unsafe { SignalToken::cast_from_usize(ptr) })\n     }\n \n-    pub fn recv(&mut self) -> Result<T, Failure<T>> {\n+    pub fn recv(&mut self, deadline: Option<Instant>) -> Result<T, Failure<T>> {\n         // Optimistic preflight check (scheduling is expensive).\n         match self.try_recv() {\n             Err(Empty) => {}\n@@ -183,7 +184,15 @@ impl<T> Packet<T> {\n         // initiate the blocking protocol.\n         let (wait_token, signal_token) = blocking::tokens();\n         if self.decrement(signal_token).is_ok() {\n-            wait_token.wait()\n+            if let Some(deadline) = deadline {\n+                let timed_out = !wait_token.wait_max_until(deadline);\n+                if timed_out {\n+                    try!(self.abort_selection(/* was_upgrade = */ false)\n+                             .map_err(Upgraded));\n+                }\n+            } else {\n+                wait_token.wait();\n+            }\n         }\n \n         match self.try_recv() {\n@@ -332,7 +341,7 @@ impl<T> Packet<T> {\n         // the internal state.\n         match self.queue.peek() {\n             Some(&mut GoUp(..)) => {\n-                match self.recv() {\n+                match self.recv(None) {\n                     Err(Upgraded(port)) => Err(port),\n                     _ => unreachable!(),\n                 }"}, {"sha": "f021689acad58849a9bc986d5435e3ee06d0eb0b", "filename": "src/libstd/sync/mpsc/sync.rs", "status": "modified", "additions": 58, "deletions": 17, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/b94b15852cd9b14160cce7f85f241691a72c18af/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94b15852cd9b14160cce7f85f241691a72c18af/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs?ref=b94b15852cd9b14160cce7f85f241691a72c18af", "patch": "@@ -44,6 +44,7 @@ use sync::atomic::{Ordering, AtomicUsize};\n use sync::mpsc::blocking::{self, WaitToken, SignalToken};\n use sync::mpsc::select::StartResult::{self, Installed, Abort};\n use sync::{Mutex, MutexGuard};\n+use time::Instant;\n \n pub struct Packet<T> {\n     /// Only field outside of the mutex. Just done for kicks, but mainly because\n@@ -126,6 +127,38 @@ fn wait<'a, 'b, T>(lock: &'a Mutex<State<T>>,\n     lock.lock().unwrap() // relock\n }\n \n+/// Same as wait, but waiting at most until `deadline`.\n+fn wait_timeout_receiver<'a, 'b, T>(lock: &'a Mutex<State<T>>,\n+                                    deadline: Instant,\n+                                    mut guard: MutexGuard<'b, State<T>>,\n+                                    success: &mut bool)\n+                                    -> MutexGuard<'a, State<T>>\n+{\n+    let (wait_token, signal_token) = blocking::tokens();\n+    match mem::replace(&mut guard.blocker, BlockedReceiver(signal_token)) {\n+        NoneBlocked => {}\n+        _ => unreachable!(),\n+    }\n+    drop(guard);         // unlock\n+    *success = wait_token.wait_max_until(deadline);   // block\n+    let mut new_guard = lock.lock().unwrap(); // relock\n+    if !*success {\n+        abort_selection(&mut new_guard);\n+    }\n+    new_guard\n+}\n+\n+fn abort_selection<'a, T>(guard: &mut MutexGuard<'a , State<T>>) -> bool {\n+    match mem::replace(&mut guard.blocker, NoneBlocked) {\n+        NoneBlocked => true,\n+        BlockedSender(token) => {\n+            guard.blocker = BlockedSender(token);\n+            true\n+        }\n+        BlockedReceiver(token) => { drop(token); false }\n+    }\n+}\n+\n /// Wakes up a thread, dropping the lock at the correct time\n fn wakeup<T>(token: SignalToken, guard: MutexGuard<State<T>>) {\n     // We need to be careful to wake up the waiting thread *outside* of the mutex\n@@ -238,22 +271,37 @@ impl<T> Packet<T> {\n     //\n     // When reading this, remember that there can only ever be one receiver at\n     // time.\n-    pub fn recv(&self) -> Result<T, ()> {\n+    pub fn recv(&self, deadline: Option<Instant>) -> Result<T, Failure> {\n         let mut guard = self.lock.lock().unwrap();\n \n-        // Wait for the buffer to have something in it. No need for a while loop\n-        // because we're the only receiver.\n-        let mut waited = false;\n+        let mut woke_up_after_waiting = false;\n+        // Wait for the buffer to have something in it. No need for a\n+        // while loop because we're the only receiver.\n         if !guard.disconnected && guard.buf.size() == 0 {\n-            guard = wait(&self.lock, guard, BlockedReceiver);\n-            waited = true;\n+            if let Some(deadline) = deadline {\n+                guard = wait_timeout_receiver(&self.lock,\n+                                              deadline,\n+                                              guard,\n+                                              &mut woke_up_after_waiting);\n+            } else {\n+                guard = wait(&self.lock, guard, BlockedReceiver);\n+                woke_up_after_waiting = true;\n+            }\n+        }\n+\n+        // NB: Channel could be disconnected while waiting, so the order of\n+        // these conditionals is important.\n+        if guard.disconnected && guard.buf.size() == 0 {\n+            return Err(Disconnected);\n         }\n-        if guard.disconnected && guard.buf.size() == 0 { return Err(()) }\n \n         // Pick up the data, wake up our neighbors, and carry on\n-        assert!(guard.buf.size() > 0);\n+        assert!(guard.buf.size() > 0 || (deadline.is_some() && !woke_up_after_waiting));\n+\n+        if guard.buf.size() == 0 { return Err(Empty); }\n+\n         let ret = guard.buf.dequeue();\n-        self.wakeup_senders(waited, guard);\n+        self.wakeup_senders(woke_up_after_waiting, guard);\n         Ok(ret)\n     }\n \n@@ -392,14 +440,7 @@ impl<T> Packet<T> {\n     // The return value indicates whether there's data on this port.\n     pub fn abort_selection(&self) -> bool {\n         let mut guard = self.lock.lock().unwrap();\n-        match mem::replace(&mut guard.blocker, NoneBlocked) {\n-            NoneBlocked => true,\n-            BlockedSender(token) => {\n-                guard.blocker = BlockedSender(token);\n-                true\n-            }\n-            BlockedReceiver(token) => { drop(token); false }\n-        }\n+        abort_selection(&mut guard)\n     }\n }\n "}]}