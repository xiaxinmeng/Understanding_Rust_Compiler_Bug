{"sha": "5dbf554bb3f5883a3375e21285f9591e0e118914", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkYmY1NTRiYjNmNTg4M2EzMzc1ZTIxMjg1Zjk1OTFlMGUxMTg5MTQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-21T01:52:04Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-21T21:30:27Z"}, "message": "rustc: Pass a type store around, which does nothing yet", "tree": {"sha": "959a459bf3d73b08ff031e5530994dc3bfa9ec87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/959a459bf3d73b08ff031e5530994dc3bfa9ec87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5dbf554bb3f5883a3375e21285f9591e0e118914", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5dbf554bb3f5883a3375e21285f9591e0e118914", "html_url": "https://github.com/rust-lang/rust/commit/5dbf554bb3f5883a3375e21285f9591e0e118914", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5dbf554bb3f5883a3375e21285f9591e0e118914/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3dbfc9310a705f1a214c13a02cd3a4750eb9be81", "url": "https://api.github.com/repos/rust-lang/rust/commits/3dbfc9310a705f1a214c13a02cd3a4750eb9be81", "html_url": "https://github.com/rust-lang/rust/commit/3dbfc9310a705f1a214c13a02cd3a4750eb9be81"}], "stats": {"total": 1040, "additions": 600, "deletions": 440}, "files": [{"sha": "afef226e27f669008e2777f4c71041f7c6ea2750", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5dbf554bb3f5883a3375e21285f9591e0e118914/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dbf554bb3f5883a3375e21285f9591e0e118914/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=5dbf554bb3f5883a3375e21285f9591e0e118914", "patch": "@@ -68,16 +68,19 @@ fn compile_input(session.session sess,\n     auto p = parser.new_parser(sess, env, def, input, 0u);\n     auto crate = parse_input(sess, p, input);\n     if (ot == trans.output_type_none) {ret;}\n+\n     crate = creader.read_crates(sess, crate, library_search_paths);\n     crate = resolve.resolve_crate(sess, crate);\n     capture.check_for_captures(sess, crate);\n-    auto typeck_result = typeck.check_crate(sess, crate);\n+\n+    auto tystore = ty.mk_type_store();\n+    auto typeck_result = typeck.check_crate(sess, tystore, crate);\n     crate = typeck_result._0;\n     auto type_cache = typeck_result._1;\n     // FIXME: uncomment once typestate_check works\n     // crate = typestate_check.check_crate(crate);\n-    trans.trans_crate(sess, crate, type_cache, output, shared, optimize,\n-                      verify, ot);\n+    trans.trans_crate(sess, crate, tystore, type_cache, output, shared,\n+                      optimize, verify, ot);\n }\n \n fn pretty_print_input(session.session sess,"}, {"sha": "febde3fd477d6c657261f5742b75172a3c31a410", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 45, "deletions": 43, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/5dbf554bb3f5883a3375e21285f9591e0e118914/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dbf554bb3f5883a3375e21285f9591e0e118914/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=5dbf554bb3f5883a3375e21285f9591e0e118914", "patch": "@@ -49,22 +49,23 @@ tag resolve_result {\n // Callback to translate defs to strs or back.\n type str_def = fn(str) -> ast.def_id;\n \n-type pstate = rec(str rep, mutable uint pos, uint len);\n+type pstate = rec(str rep, mutable uint pos, uint len,\n+                  @ty.type_store tystore);\n \n fn peek(@pstate st) -> u8 {\n     if (st.pos < st.len) {ret st.rep.(st.pos) as u8;}\n     else {ret ' ' as u8;}\n }\n-fn next(@pstate st) -> u8 { // ?? somehow not recognized as impure\n+fn next(@pstate st) -> u8 {\n     if (st.pos >= st.len) {fail;}\n     auto ch = st.rep.(st.pos);\n     st.pos = st.pos + 1u;\n     ret ch as u8;\n }\n \n-fn parse_ty_str(str rep, str_def sd) -> @ty.t {\n+fn parse_ty_str(str rep, str_def sd, @ty.type_store tystore) -> @ty.t {\n     auto len = _str.byte_len(rep);\n-    auto st = @rec(rep=rep, mutable pos=0u, len=len);\n+    auto st = @rec(rep=rep, mutable pos=0u, len=len, tystore=tystore);\n     auto result = parse_ty(st, sd);\n     if (st.pos != len) {\n         log_err \"parse_ty_str: incomplete parse, stopped at byte \"\n@@ -76,27 +77,27 @@ fn parse_ty_str(str rep, str_def sd) -> @ty.t {\n \n fn parse_ty(@pstate st, str_def sd) -> @ty.t {\n     alt (next(st) as char) {\n-        case ('n') { ret ty.mk_nil(); }\n-        case ('b') { ret ty.mk_bool(); }\n-        case ('i') { ret ty.mk_int(); }\n-        case ('u') { ret ty.mk_uint(); }\n-        case ('l') { ret ty.mk_float(); }\n+        case ('n') { ret ty.mk_nil(st.tystore); }\n+        case ('b') { ret ty.mk_bool(st.tystore); }\n+        case ('i') { ret ty.mk_int(st.tystore); }\n+        case ('u') { ret ty.mk_uint(st.tystore); }\n+        case ('l') { ret ty.mk_float(st.tystore); }\n         case ('M') {\n             alt (next(st) as char) {\n-                case ('b') { ret ty.mk_mach(common.ty_u8); }\n-                case ('w') { ret ty.mk_mach(common.ty_u16); }\n-                case ('l') { ret ty.mk_mach(common.ty_u32); }\n-                case ('d') { ret ty.mk_mach(common.ty_u64); }\n-                case ('B') { ret ty.mk_mach(common.ty_i8); }\n-                case ('W') { ret ty.mk_mach(common.ty_i16); }\n-                case ('L') { ret ty.mk_mach(common.ty_i32); }\n-                case ('D') { ret ty.mk_mach(common.ty_i64); }\n-                case ('f') { ret ty.mk_mach(common.ty_f32); }\n-                case ('F') { ret ty.mk_mach(common.ty_f64); }\n+                case ('b') { ret ty.mk_mach(st.tystore, common.ty_u8); }\n+                case ('w') { ret ty.mk_mach(st.tystore, common.ty_u16); }\n+                case ('l') { ret ty.mk_mach(st.tystore, common.ty_u32); }\n+                case ('d') { ret ty.mk_mach(st.tystore, common.ty_u64); }\n+                case ('B') { ret ty.mk_mach(st.tystore, common.ty_i8); }\n+                case ('W') { ret ty.mk_mach(st.tystore, common.ty_i16); }\n+                case ('L') { ret ty.mk_mach(st.tystore, common.ty_i32); }\n+                case ('D') { ret ty.mk_mach(st.tystore, common.ty_i64); }\n+                case ('f') { ret ty.mk_mach(st.tystore, common.ty_f32); }\n+                case ('F') { ret ty.mk_mach(st.tystore, common.ty_f64); }\n             }\n         }\n-        case ('c') { ret ty.mk_char(); }\n-        case ('s') { ret ty.mk_str(); }\n+        case ('c') { ret ty.mk_char(st.tystore); }\n+        case ('s') { ret ty.mk_str(st.tystore); }\n         case ('t') {\n             check(next(st) as char == '[');\n             auto def = parse_def(st, sd);\n@@ -105,21 +106,21 @@ fn parse_ty(@pstate st, str_def sd) -> @ty.t {\n                 params += vec(parse_ty(st, sd));\n             }\n             st.pos = st.pos + 1u;\n-            ret ty.mk_tag(def, params);\n+            ret ty.mk_tag(st.tystore, def, params);\n         }\n-        case ('p') { ret ty.mk_param(parse_int(st) as uint); }\n-        case ('@') { ret ty.mk_box(parse_mt(st, sd)); }\n-        case ('V') { ret ty.mk_vec(parse_mt(st, sd)); }\n-        case ('P') { ret ty.mk_port(parse_ty(st, sd)); }\n-        case ('C') { ret ty.mk_chan(parse_ty(st, sd)); }\n+        case ('p') { ret ty.mk_param(st.tystore, parse_int(st) as uint); }\n+        case ('@') { ret ty.mk_box(st.tystore, parse_mt(st, sd)); }\n+        case ('V') { ret ty.mk_vec(st.tystore, parse_mt(st, sd)); }\n+        case ('P') { ret ty.mk_port(st.tystore, parse_ty(st, sd)); }\n+        case ('C') { ret ty.mk_chan(st.tystore, parse_ty(st, sd)); }\n         case ('T') {\n             check(next(st) as char == '[');\n             let vec[ty.mt] params = vec();\n             while (peek(st) as char != ']') {\n                 params += vec(parse_mt(st, sd));\n             }\n             st.pos = st.pos + 1u;\n-            ret ty.mk_tup(params);\n+            ret ty.mk_tup(st.tystore, params);\n         }\n         case ('R') {\n             check(next(st) as char == '[');\n@@ -133,15 +134,15 @@ fn parse_ty(@pstate st, str_def sd) -> @ty.t {\n                 fields += vec(rec(ident=name, mt=parse_mt(st, sd)));\n             }\n             st.pos = st.pos + 1u;\n-            ret ty.mk_rec(fields);\n+            ret ty.mk_rec(st.tystore, fields);\n         }\n         case ('F') {\n             auto func = parse_ty_fn(st, sd);\n-            ret ty.mk_fn(ast.proto_fn, func._0, func._1);\n+            ret ty.mk_fn(st.tystore, ast.proto_fn, func._0, func._1);\n         }\n         case ('W') {\n             auto func = parse_ty_fn(st, sd);\n-            ret ty.mk_fn(ast.proto_iter, func._0, func._1);\n+            ret ty.mk_fn(st.tystore, ast.proto_iter, func._0, func._1);\n         }\n         case ('N') {\n             auto abi;\n@@ -151,7 +152,7 @@ fn parse_ty(@pstate st, str_def sd) -> @ty.t {\n                 case ('l') {abi = ast.native_abi_llvm;}\n             }\n             auto func = parse_ty_fn(st, sd);\n-            ret ty.mk_native_fn(abi,func._0,func._1);\n+            ret ty.mk_native_fn(st.tystore,abi,func._0,func._1);\n         }\n         case ('O') {\n             check(next(st) as char == '[');\n@@ -173,11 +174,11 @@ fn parse_ty(@pstate st, str_def sd) -> @ty.t {\n                                    output=func._1));\n             }\n             st.pos += 1u;\n-            ret ty.mk_obj(methods);\n+            ret ty.mk_obj(st.tystore, methods);\n         }\n-        case ('X') { ret ty.mk_var(parse_int(st)); }\n-        case ('E') { ret ty.mk_native(); }\n-        case ('Y') { ret ty.mk_type(); }\n+        case ('X') { ret ty.mk_var(st.tystore, parse_int(st)); }\n+        case ('E') { ret ty.mk_native(st.tystore); }\n+        case ('Y') { ret ty.mk_type(st.tystore); }\n     }\n }\n \n@@ -330,7 +331,7 @@ fn variant_tag_id(&ebml.doc d) -> ast.def_id {\n     ret parse_def_id(ebml.doc_data(tagdoc));\n }\n \n-fn item_type(&ebml.doc item, int this_cnum) -> @ty.t {\n+fn item_type(&ebml.doc item, int this_cnum, @ty.type_store tystore) -> @ty.t {\n     fn parse_external_def_id(int this_cnum, str s) -> ast.def_id {\n         // FIXME: This is completely wrong when linking against a crate\n         // that, in turn, links against another crate. We need a mapping\n@@ -343,7 +344,7 @@ fn item_type(&ebml.doc item, int this_cnum) -> @ty.t {\n \n     auto tp = ebml.get_doc(item, metadata.tag_items_data_item_type);\n     auto s = _str.unsafe_from_bytes(ebml.doc_data(tp));\n-    ret parse_ty_str(s, bind parse_external_def_id(this_cnum, _));\n+    ret parse_ty_str(s, bind parse_external_def_id(this_cnum, _), tystore);\n }\n \n fn item_ty_param_count(&ebml.doc item, int this_cnum) -> uint {\n@@ -505,12 +506,12 @@ fn lookup_def(session.session sess, int cnum, vec[ast.ident] path)\n     ret some[ast.def](def);\n }\n \n-fn get_type(session.session sess, ast.def_id def)\n+fn get_type(session.session sess, @ty.type_store tystore, ast.def_id def)\n         -> ty.ty_param_count_and_ty {\n     auto external_crate_id = def._0;\n     auto data = sess.get_external_crate(external_crate_id).data;\n     auto item = lookup_item(def._1, data);\n-    auto t = item_type(item, external_crate_id);\n+    auto t = item_type(item, external_crate_id, tystore);\n \n     auto tp_count;\n     auto kind_ch = item_kind(item);\n@@ -531,8 +532,9 @@ fn get_symbol(session.session sess, ast.def_id def) -> str {\n     ret item_symbol(item);\n }\n \n-fn get_tag_variants(session.session sess, ast.def_id def)\n-        -> vec[trans.variant_info] {\n+fn get_tag_variants(session.session sess,\n+                    @ty.type_store tystore,\n+                    ast.def_id def) -> vec[trans.variant_info] {\n     auto external_crate_id = def._0;\n     auto data = sess.get_external_crate(external_crate_id).data;\n     auto items = ebml.get_doc(ebml.new_doc(data), metadata.tag_items);\n@@ -542,7 +544,7 @@ fn get_tag_variants(session.session sess, ast.def_id def)\n     auto variant_ids = tag_variant_ids(item, external_crate_id);\n     for (ast.def_id did in variant_ids) {\n         auto item = find_item(did._1, items);\n-        auto ctor_ty = item_type(item, external_crate_id);\n+        auto ctor_ty = item_type(item, external_crate_id, tystore);\n         let vec[@ty.t] arg_tys = vec();\n         alt (ctor_ty.struct) {\n             case (ty.ty_fn(_, ?args, _)) {"}, {"sha": "4ea6b3e86ca21988dfdf846f2017796be0f2f094", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5dbf554bb3f5883a3375e21285f9591e0e118914/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dbf554bb3f5883a3375e21285f9591e0e118914/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=5dbf554bb3f5883a3375e21285f9591e0e118914", "patch": "@@ -461,7 +461,7 @@ fn encode_info_for_native_item(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n         case (ast.native_item_ty(_, ?did)) {\n             encode_def_id(ebml_w, did);\n             encode_kind(ebml_w, 'T' as u8);\n-            encode_type(ebml_w, ty.mk_native());\n+            encode_type(ebml_w, ty.mk_native(cx.tystore));\n         }\n         case (ast.native_item_fn(_, _, _, ?tps, ?did, ?ann)) {\n             encode_def_id(ebml_w, did);"}, {"sha": "1153047d60e284e742724895ba7f30c92363ccc2", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 115, "deletions": 82, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/5dbf554bb3f5883a3375e21285f9591e0e118914/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dbf554bb3f5883a3375e21285f9591e0e118914/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=5dbf554bb3f5883a3375e21285f9591e0e118914", "patch": "@@ -112,7 +112,8 @@ state type crate_ctxt = rec(session.session sess,\n                             hashmap[@ty.t, TypeRef] lltypes,\n                             @glue_fns glues,\n                             namegen names,\n-                            std.sha1.sha1 sha);\n+                            std.sha1.sha1 sha,\n+                            @ty.type_store tystore);\n \n type local_ctxt = rec(vec[str] path,\n                       vec[str] module_path,\n@@ -638,7 +639,7 @@ fn type_of_fn_full(@crate_ctxt cx,\n             vec(T_fn_pair(cx.tn,\n                           type_of_fn_full(cx, ast.proto_fn, none[TypeRef],\n                                           vec(rec(mode=ast.val, ty=output)),\n-                                          ty.mk_nil(), 0u)));\n+                                          ty.mk_nil(cx.tystore), 0u)));\n     }\n \n     // ... then explicit args.\n@@ -1145,17 +1146,17 @@ fn array_alloca(@block_ctxt cx, TypeRef t, ValueRef n) -> ValueRef {\n // to have (a) the same size as the type that was passed in; (b) to be non-\n // recursive. This is done by replacing all boxes in a type with boxed unit\n // types.\n-fn simplify_type(@ty.t typ) -> @ty.t {\n-    fn simplifier(@ty.t typ) -> @ty.t {\n+fn simplify_type(@crate_ctxt ccx, @ty.t typ) -> @ty.t {\n+    fn simplifier(@crate_ctxt ccx, @ty.t typ) -> @ty.t {\n         alt (typ.struct) {\n             case (ty.ty_box(_)) {\n-                ret ty.mk_imm_box(ty.mk_nil());\n+                ret ty.mk_imm_box(ccx.tystore, ty.mk_nil(ccx.tystore));\n             }\n             case (_) { ret typ; }\n         }\n     }\n-    auto f = simplifier;\n-    ret ty.fold_ty(f, typ);\n+    auto f = bind simplifier(ccx, _);\n+    ret ty.fold_ty(ccx.tystore, f, typ);\n }\n \n // Computes the size of the data part of a non-dynamically-sized tag.\n@@ -1186,11 +1187,12 @@ fn static_size_of_tag(@crate_ctxt cx, @ty.t t) -> uint {\n     auto max_size = 0u;\n     auto variants = tag_variants(cx, tid);\n     for (variant_info variant in variants) {\n-        auto tup_ty = simplify_type(ty.mk_imm_tup(variant.args));\n+        auto tup_ty = simplify_type(cx,\n+                                    ty.mk_imm_tup(cx.tystore, variant.args));\n \n         // Perform any type parameter substitutions.\n-        tup_ty = ty.bind_params_in_type(tup_ty);\n-        tup_ty = ty.substitute_type_params(subtys, tup_ty);\n+        tup_ty = ty.bind_params_in_type(cx.tystore, tup_ty);\n+        tup_ty = ty.substitute_type_params(cx.tystore, subtys, tup_ty);\n \n         // Here we possibly do a recursive call.\n         auto this_size = llsize_of_real(cx, type_of(cx, tup_ty));\n@@ -1262,8 +1264,10 @@ fn dynamic_size_of(@block_ctxt cx, @ty.t t) -> result {\n                 let vec[@ty.t] raw_tys = variant.args;\n                 let vec[@ty.t] tys = vec();\n                 for (@ty.t raw_ty in raw_tys) {\n-                    auto t = ty.bind_params_in_type(raw_ty);\n-                    t = ty.substitute_type_params(tps, t);\n+                    auto t = ty.bind_params_in_type(cx.fcx.lcx.ccx.tystore,\n+                                                    raw_ty);\n+                    t = ty.substitute_type_params(cx.fcx.lcx.ccx.tystore, tps,\n+                                                  t);\n                     tys += vec(t);\n                 }\n \n@@ -1402,7 +1406,7 @@ fn GEP_tup_like(@block_ctxt cx, @ty.t t,\n     // flattened the incoming structure.\n \n     auto s = split_type(t, ixs, 0u);\n-    auto prefix_ty = ty.mk_imm_tup(s.prefix);\n+    auto prefix_ty = ty.mk_imm_tup(cx.fcx.lcx.ccx.tystore, s.prefix);\n     auto bcx = cx;\n     auto sz = size_of(bcx, prefix_ty);\n     bcx = sz.bcx;\n@@ -1433,12 +1437,13 @@ fn GEP_tag(@block_ctxt cx,\n     // Synthesize a tuple type so that GEP_tup_like() can work its magic.\n     // Separately, store the type of the element we're interested in.\n     auto arg_tys = variant.args;\n-    auto elem_ty = ty.mk_nil(); // typestate infelicity\n+    auto elem_ty = ty.mk_nil(cx.fcx.lcx.ccx.tystore); // typestate infelicity\n     auto i = 0;\n     let vec[@ty.t] true_arg_tys = vec();\n     for (@ty.t aty in arg_tys) {\n-        auto arg_ty = ty.bind_params_in_type(aty);\n-        arg_ty = ty.substitute_type_params(ty_substs, arg_ty);\n+        auto arg_ty = ty.bind_params_in_type(cx.fcx.lcx.ccx.tystore, aty);\n+        arg_ty = ty.substitute_type_params(cx.fcx.lcx.ccx.tystore, ty_substs,\n+                                           arg_ty);\n         true_arg_tys += vec(arg_ty);\n         if (i == ix) {\n             elem_ty = arg_ty;\n@@ -1447,7 +1452,7 @@ fn GEP_tag(@block_ctxt cx,\n         i += 1;\n     }\n \n-    auto tup_ty = ty.mk_imm_tup(true_arg_tys);\n+    auto tup_ty = ty.mk_imm_tup(cx.fcx.lcx.ccx.tystore, true_arg_tys);\n \n     // Cast the blob pointer to the appropriate type, if we need to (i.e. if\n     // the blob pointer isn't dynamically sized).\n@@ -1487,8 +1492,10 @@ fn trans_raw_malloc(@block_ctxt cx, TypeRef llptr_ty, ValueRef llsize)\n fn trans_malloc_boxed(@block_ctxt cx, @ty.t t) -> result {\n     // Synthesize a fake box type structurally so we have something\n     // to measure the size of.\n-    auto boxed_body = ty.mk_imm_tup(vec(ty.mk_int(), t));\n-    auto box_ptr = ty.mk_imm_box(t);\n+    auto boxed_body = ty.mk_imm_tup(cx.fcx.lcx.ccx.tystore,\n+                                    vec(ty.mk_int(cx.fcx.lcx.ccx.tystore),\n+                                        t));\n+    auto box_ptr = ty.mk_imm_box(cx.fcx.lcx.ccx.tystore, t);\n     auto sz = size_of(cx, boxed_body);\n     auto llty = type_of(cx.fcx.lcx.ccx, box_ptr);\n     ret trans_raw_malloc(sz.bcx, llty, sz.val);\n@@ -2116,7 +2123,7 @@ fn make_cmp_glue(@block_ctxt cx,\n             auto min_len = umin(r.bcx, vec_fill(r.bcx, lhs),\n                                 vec_fill(r.bcx, rhs));\n             auto rhs_lim = r.bcx.build.GEP(rhs_p0, vec(min_len));\n-            auto elt_ty = ty.sequence_element_type(t);\n+            auto elt_ty = ty.sequence_element_type(cx.fcx.lcx.ccx.tystore, t);\n             r = size_of(r.bcx, elt_ty);\n             r = iter_sequence_raw(r.bcx, lhs_p0, rhs_p0, rhs_lim, r.val,\n                                   bind inner(next, true, flag, llop,\n@@ -2250,7 +2257,7 @@ type variant_info = rec(vec[@ty.t] args, @ty.t ctor_ty, ast.def_id id);\n // Returns information about the variants in a tag.\n fn tag_variants(@crate_ctxt cx, ast.def_id id) -> vec[variant_info] {\n     if (cx.sess.get_targ_crate_num() != id._0) {\n-        ret creader.get_tag_variants(cx.sess, id);\n+        ret creader.get_tag_variants(cx.sess, cx.tystore, id);\n     }\n \n     check (cx.items.contains_key(id));\n@@ -2333,8 +2340,8 @@ fn iter_structural_ty_full(@block_ctxt cx,\n                   val_pair_and_ty_fn f) -> result {\n         auto box_a_ptr = cx.build.Load(box_a_cell);\n         auto box_b_ptr = cx.build.Load(box_b_cell);\n-        auto tnil = ty.mk_nil();\n-        auto tbox = ty.mk_imm_box(tnil);\n+        auto tnil = ty.mk_nil(cx.fcx.lcx.ccx.tystore);\n+        auto tbox = ty.mk_imm_box(cx.fcx.lcx.ccx.tystore, tnil);\n \n         auto inner_cx = new_sub_block_ctxt(cx, \"iter box\");\n         auto next_cx = new_sub_block_ctxt(cx, \"next\");\n@@ -2399,7 +2406,8 @@ fn iter_structural_ty_full(@block_ctxt cx,\n             // NB: we must hit the discriminant first so that structural\n             // comparison know not to proceed when the discriminants differ.\n             auto bcx = cx;\n-            bcx = f(bcx, lldiscrim_a, lldiscrim_b, ty.mk_int()).bcx;\n+            bcx = f(bcx, lldiscrim_a, lldiscrim_b,\n+                    ty.mk_int(cx.fcx.lcx.ccx.tystore)).bcx;\n \n             auto unr_cx = new_sub_block_ctxt(bcx, \"tag-iter-unr\");\n             unr_cx.build.Unreachable();\n@@ -2435,9 +2443,10 @@ fn iter_structural_ty_full(@block_ctxt cx,\n                                 auto llfldp_b = rslt.val;\n                                 variant_cx = rslt.bcx;\n \n-                                auto ty_subst = ty.bind_params_in_type(a.ty);\n-                                ty_subst =\n-                                    ty.substitute_type_params(tps, ty_subst);\n+                                auto ty_subst = ty.bind_params_in_type(\n+                                    cx.fcx.lcx.ccx.tystore, a.ty);\n+                                ty_subst = ty.substitute_type_params(\n+                                    cx.fcx.lcx.ccx.tystore, tps, ty_subst);\n \n                                 auto llfld_a =\n                                     load_if_immediate(variant_cx,\n@@ -2619,7 +2628,7 @@ fn iter_sequence(@block_ctxt cx,\n             ret iter_sequence_body(cx, v, elt.ty, f, false);\n         }\n         case (ty.ty_str) {\n-            auto et = ty.mk_mach(common.ty_u8);\n+            auto et = ty.mk_mach(cx.fcx.lcx.ccx.tystore, common.ty_u8);\n             ret iter_sequence_body(cx, v, et, f, true);\n         }\n         case (_) { fail; }\n@@ -2843,11 +2852,13 @@ fn trans_lit(@crate_ctxt cx, &ast.lit lit, &ast.ann ann) -> ValueRef {\n fn target_type(@crate_ctxt cx, @ty.t t) -> @ty.t {\n     alt (t.struct) {\n         case (ty.ty_int) {\n-            auto struct_ty = ty.mk_mach(cx.sess.get_targ_cfg().int_type);\n+            auto struct_ty = ty.mk_mach(cx.tystore,\n+                                        cx.sess.get_targ_cfg().int_type);\n             ret ty.copy_cname(struct_ty, t);\n         }\n         case (ty.ty_uint) {\n-            auto struct_ty = ty.mk_mach(cx.sess.get_targ_cfg().uint_type);\n+            auto struct_ty = ty.mk_mach(cx.tystore,\n+                                        cx.sess.get_targ_cfg().uint_type);\n             ret ty.copy_cname(struct_ty, t);\n         }\n         case (_) { /* fall through */ }\n@@ -2858,7 +2869,7 @@ fn target_type(@crate_ctxt cx, @ty.t t) -> @ty.t {\n \n // Converts an annotation to a type\n fn node_ann_type(@crate_ctxt cx, &ast.ann a) -> @ty.t {\n-    ret target_type(cx, ty.ann_to_monotype(a));\n+    ret target_type(cx, ty.ann_to_monotype(cx.tystore, a));\n }\n \n fn node_ann_ty_params(&ast.ann a) -> vec[@ty.t] {\n@@ -2887,19 +2898,22 @@ fn trans_unary(@block_ctxt cx, ast.unop op,\n                @ast.expr e, &ast.ann a) -> result {\n \n     auto sub = trans_expr(cx, e);\n-    auto e_ty = ty.expr_ty(e);\n+    auto e_ty = ty.expr_ty(cx.fcx.lcx.ccx.tystore, e);\n \n     alt (op) {\n         case (ast.bitnot) {\n-            sub = autoderef(sub.bcx, sub.val, ty.expr_ty(e));\n+            sub = autoderef(sub.bcx, sub.val,\n+                            ty.expr_ty(cx.fcx.lcx.ccx.tystore, e));\n             ret res(sub.bcx, sub.bcx.build.Not(sub.val));\n         }\n         case (ast.not) {\n-            sub = autoderef(sub.bcx, sub.val, ty.expr_ty(e));\n+            sub = autoderef(sub.bcx, sub.val,\n+                            ty.expr_ty(cx.fcx.lcx.ccx.tystore, e));\n             ret res(sub.bcx, sub.bcx.build.Not(sub.val));\n         }\n         case (ast.neg) {\n-            sub = autoderef(sub.bcx, sub.val, ty.expr_ty(e));\n+            sub = autoderef(sub.bcx, sub.val,\n+                            ty.expr_ty(cx.fcx.lcx.ccx.tystore, e));\n             if(e_ty.struct == ty.ty_float) {\n                 ret res(sub.bcx, sub.bcx.build.FNeg(sub.val));\n             }\n@@ -2908,7 +2922,7 @@ fn trans_unary(@block_ctxt cx, ast.unop op,\n             }\n         }\n         case (ast.box(_)) {\n-            auto e_ty = ty.expr_ty(e);\n+            auto e_ty = ty.expr_ty(cx.fcx.lcx.ccx.tystore, e);\n             auto e_val = sub.val;\n             auto box_ty = node_ann_type(sub.bcx.fcx.lcx.ccx, a);\n             sub = trans_malloc_boxed(sub.bcx, e_ty);\n@@ -2988,7 +3002,7 @@ fn trans_compare(@block_ctxt cx0, ast.binop op, @ty.t t0,\n fn trans_vec_append(@block_ctxt cx, @ty.t t,\n                     ValueRef lhs, ValueRef rhs) -> result {\n \n-    auto elt_ty = ty.sequence_element_type(t);\n+    auto elt_ty = ty.sequence_element_type(cx.fcx.lcx.ccx.tystore, t);\n \n     auto skip_null = C_bool(false);\n     alt (t.struct) {\n@@ -3160,11 +3174,13 @@ fn trans_binary(@block_ctxt cx, ast.binop op,\n         case (ast.and) {\n             // Lazy-eval and\n             auto lhs_res = trans_expr(cx, a);\n-            lhs_res = autoderef(lhs_res.bcx, lhs_res.val, ty.expr_ty(a));\n+            lhs_res = autoderef(lhs_res.bcx, lhs_res.val,\n+                                ty.expr_ty(cx.fcx.lcx.ccx.tystore, a));\n \n             auto rhs_cx = new_scope_block_ctxt(cx, \"rhs\");\n             auto rhs_res = trans_expr(rhs_cx, b);\n-            rhs_res = autoderef(rhs_res.bcx, rhs_res.val, ty.expr_ty(b));\n+            rhs_res = autoderef(rhs_res.bcx, rhs_res.val,\n+                                ty.expr_ty(cx.fcx.lcx.ccx.tystore, b));\n \n             auto lhs_false_cx = new_scope_block_ctxt(cx, \"lhs false\");\n             auto lhs_false_res = res(lhs_false_cx, C_bool(false));\n@@ -3180,11 +3196,13 @@ fn trans_binary(@block_ctxt cx, ast.binop op,\n         case (ast.or) {\n             // Lazy-eval or\n             auto lhs_res = trans_expr(cx, a);\n-            lhs_res = autoderef(lhs_res.bcx, lhs_res.val, ty.expr_ty(a));\n+            lhs_res = autoderef(lhs_res.bcx, lhs_res.val,\n+                                ty.expr_ty(cx.fcx.lcx.ccx.tystore, a));\n \n             auto rhs_cx = new_scope_block_ctxt(cx, \"rhs\");\n             auto rhs_res = trans_expr(rhs_cx, b);\n-            rhs_res = autoderef(rhs_res.bcx, rhs_res.val, ty.expr_ty(b));\n+            rhs_res = autoderef(rhs_res.bcx, rhs_res.val,\n+                                ty.expr_ty(cx.fcx.lcx.ccx.tystore, b));\n \n             auto lhs_true_cx = new_scope_block_ctxt(cx, \"lhs true\");\n             auto lhs_true_res = res(lhs_true_cx, C_bool(true));\n@@ -3200,10 +3218,10 @@ fn trans_binary(@block_ctxt cx, ast.binop op,\n         case (_) {\n             // Remaining cases are eager:\n             auto lhs = trans_expr(cx, a);\n-            auto lhty = ty.expr_ty(a);\n+            auto lhty = ty.expr_ty(cx.fcx.lcx.ccx.tystore, a);\n             lhs = autoderef(lhs.bcx, lhs.val, lhty);\n             auto rhs = trans_expr(lhs.bcx, b);\n-            auto rhty = ty.expr_ty(b);\n+            auto rhty = ty.expr_ty(cx.fcx.lcx.ccx.tystore, b);\n             rhs = autoderef(rhs.bcx, rhs.val, rhty);\n             ret trans_eager_binop(rhs.bcx, op,\n                                   autoderefed_ty(lhty),\n@@ -3281,7 +3299,7 @@ fn trans_if(@block_ctxt cx, @ast.expr cond,\n             // If we have an else expression, then the entire\n             // if expression can have a non-nil type.\n             // FIXME: This isn't quite right, particularly re: dynamic types\n-            auto expr_ty = ty.expr_ty(elexpr);\n+            auto expr_ty = ty.expr_ty(cx.fcx.lcx.ccx.tystore, elexpr);\n             if (ty.type_has_dynamic_size(expr_ty)) {\n                 expr_llty = T_typaram_ptr(cx.fcx.lcx.ccx.tn);\n             } else {\n@@ -3338,7 +3356,7 @@ fn trans_for(@block_ctxt cx,\n     }\n \n     auto next_cx = new_sub_block_ctxt(cx, \"next\");\n-    auto seq_ty = ty.expr_ty(seq);\n+    auto seq_ty = ty.expr_ty(cx.fcx.lcx.ccx.tystore, seq);\n     auto seq_res = trans_expr(cx, seq);\n     auto it = iter_sequence(seq_res.bcx, seq_res.val, seq_ty,\n                             bind inner(_, local, _, _, body, next_cx));\n@@ -3440,7 +3458,7 @@ fn trans_for_each(@block_ctxt cx,\n \n     auto lcx = cx.fcx.lcx;\n     // FIXME: possibly support alias-mode here?\n-    auto decl_ty = ty.mk_nil();\n+    auto decl_ty = ty.mk_nil(lcx.ccx.tystore);\n     auto decl_id;\n     alt (decl.node) {\n         case (ast.decl_local(?local)) {\n@@ -3527,7 +3545,7 @@ fn trans_for_each(@block_ctxt cx,\n     auto iter_body_llty = type_of_fn_full(lcx.ccx, ast.proto_fn,\n                                           none[TypeRef],\n                                           vec(rec(mode=ast.val, ty=decl_ty)),\n-                                          ty.mk_nil(), 0u);\n+                                          ty.mk_nil(lcx.ccx.tystore), 0u);\n \n     let ValueRef lliterbody = decl_internal_fastcall_fn(lcx.ccx.llmod,\n                                                        s, iter_body_llty);\n@@ -3715,8 +3733,7 @@ fn trans_pat_match(@block_ctxt cx, @ast.pat pat, ValueRef llval,\n                     matched_cx = rslt.bcx;\n \n                     auto llsubval = load_if_immediate(matched_cx,\n-                                                         llsubvalptr,\n-                                                         pat_ty(subpat));\n+                        llsubvalptr, pat_ty(cx.fcx.lcx.ccx.tystore, subpat));\n                     auto subpat_res = trans_pat_match(matched_cx, subpat,\n                                                       llsubval, next_cx);\n                     matched_cx = subpat_res.bcx;\n@@ -3770,7 +3787,7 @@ fn trans_pat_binding(@block_ctxt cx, @ast.pat pat, ValueRef llval)\n                 auto llsubvalptr = rslt.val;\n \n                 auto llsubval = load_if_immediate(this_cx, llsubvalptr,\n-                                                     pat_ty(subpat));\n+                    pat_ty(cx.fcx.lcx.ccx.tystore, subpat));\n                 auto subpat_res = trans_pat_binding(this_cx, subpat,\n                                                     llsubval);\n                 this_cx = subpat_res.bcx;\n@@ -3959,16 +3976,19 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n                 }\n                 case (ast.def_fn(?did)) {\n                     auto tyt = ty.lookup_item_type(cx.fcx.lcx.ccx.sess,\n+                        cx.fcx.lcx.ccx.tystore,\n                         cx.fcx.lcx.ccx.type_cache, did);\n                     ret lval_generic_fn(cx, tyt, did, ann);\n                 }\n                 case (ast.def_obj(?did)) {\n                     auto tyt = ty.lookup_item_type(cx.fcx.lcx.ccx.sess,\n+                        cx.fcx.lcx.ccx.tystore,\n                         cx.fcx.lcx.ccx.type_cache, did);\n                     ret lval_generic_fn(cx, tyt, did, ann);\n                 }\n                 case (ast.def_variant(?tid, ?vid)) {\n                     auto v_tyt = ty.lookup_item_type(cx.fcx.lcx.ccx.sess,\n+                        cx.fcx.lcx.ccx.tystore,\n                         cx.fcx.lcx.ccx.type_cache, vid);\n                     alt (v_tyt._1.struct) {\n                         case (ty.ty_fn(_, _, _)) {\n@@ -4010,6 +4030,7 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n                 }\n                 case (ast.def_native_fn(?did)) {\n                     auto tyt = ty.lookup_item_type(cx.fcx.lcx.ccx.sess,\n+                        cx.fcx.lcx.ccx.tystore,\n                         cx.fcx.lcx.ccx.type_cache, did);\n                     ret lval_generic_fn(cx, tyt, did, ann);\n                 }\n@@ -4054,7 +4075,8 @@ fn trans_field(@block_ctxt cx, &ast.span sp, ValueRef v, @ty.t t0,\n                                                 C_int(ix as int)));\n \n             auto lvo = lval_mem(r.bcx, v);\n-            let @ty.t fn_ty = ty.method_ty_to_fn_ty(methods.(ix));\n+            let @ty.t fn_ty = ty.method_ty_to_fn_ty(cx.fcx.lcx.ccx.tystore,\n+                                                    methods.(ix));\n             ret rec(llobj = some[ValueRef](r.val),\n                     method_ty = some[@ty.t](fn_ty)\n                     with lvo);\n@@ -4068,7 +4090,7 @@ fn trans_index(@block_ctxt cx, &ast.span sp, @ast.expr base,\n                @ast.expr idx, &ast.ann ann) -> lval_result {\n \n     auto lv = trans_expr(cx, base);\n-    lv = autoderef(lv.bcx, lv.val, ty.expr_ty(base));\n+    lv = autoderef(lv.bcx, lv.val, ty.expr_ty(cx.fcx.lcx.ccx.tystore, base));\n     auto ix = trans_expr(lv.bcx, idx);\n     auto v = lv.val;\n     auto bcx = ix.bcx;\n@@ -4134,7 +4156,7 @@ fn trans_lval(@block_ctxt cx, @ast.expr e) -> lval_result {\n         }\n         case (ast.expr_field(?base, ?ident, ?ann)) {\n             auto r = trans_expr(cx, base);\n-            auto t = ty.expr_ty(base);\n+            auto t = ty.expr_ty(cx.fcx.lcx.ccx.tystore, base);\n             ret trans_field(r.bcx, e.span, r.val, t, ident, ann);\n         }\n         case (ast.expr_index(?base, ?idx, ?ann)) {\n@@ -4178,7 +4200,7 @@ fn trans_cast(@block_ctxt cx, @ast.expr e, &ast.ann ann) -> result {\n     auto lldsttype = type_of(cx.fcx.lcx.ccx, t);\n     if (!ty.type_is_fp(t)) {\n         // TODO: native-to-native casts\n-        if (ty.type_is_native(ty.expr_ty(e))) {\n+        if (ty.type_is_native(ty.expr_ty(cx.fcx.lcx.ccx.tystore, e))) {\n             e_res.val = e_res.bcx.build.PtrToInt(e_res.val, lldsttype);\n         } else if (ty.type_is_native(t)) {\n             e_res.val = e_res.bcx.build.IntToPtr(e_res.val, lldsttype);\n@@ -4226,7 +4248,8 @@ fn trans_bind_thunk(@local_ctxt cx,\n     auto bcx = new_top_block_ctxt(fcx);\n     auto lltop = bcx.llbb;\n \n-    auto llclosure_ptr_ty = type_of(cx.ccx, ty.mk_imm_box(closure_ty));\n+    auto llclosure_ptr_ty =\n+        type_of(cx.ccx, ty.mk_imm_box(cx.ccx.tystore, closure_ty));\n     auto llclosure = bcx.build.PointerCast(fcx.llenv, llclosure_ptr_ty);\n \n     auto lltarget = GEP_tup_like(bcx, closure_ty, llclosure,\n@@ -4368,7 +4391,7 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n         let vec[ValueRef] lltydescs;\n         alt (f_res.generic) {\n             case (none[generic_info]) {\n-                outgoing_fty = ty.expr_ty(f);\n+                outgoing_fty = ty.expr_ty(cx.fcx.lcx.ccx.tystore, f);\n                 lltydescs = vec();\n             }\n             case (some[generic_info](?ginfo)) {\n@@ -4395,18 +4418,20 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n                 bcx = arg.bcx;\n \n                 _vec.push[ValueRef](bound_vals, arg.val);\n-                _vec.push[@ty.t](bound_tys, ty.expr_ty(e));\n+                _vec.push[@ty.t](bound_tys,\n+                                 ty.expr_ty(cx.fcx.lcx.ccx.tystore, e));\n \n                 i += 1u;\n             }\n \n             // Synthesize a closure type.\n-            let @ty.t bindings_ty = ty.mk_imm_tup(bound_tys);\n+            let @ty.t bindings_ty = ty.mk_imm_tup(cx.fcx.lcx.ccx.tystore,\n+                                                  bound_tys);\n \n             // NB: keep this in sync with T_closure_ptr; we're making\n             // a ty.t structure that has the same \"shape\" as the LLVM type\n             // it constructs.\n-            let @ty.t tydesc_ty = ty.mk_type();\n+            let @ty.t tydesc_ty = ty.mk_type(cx.fcx.lcx.ccx.tystore);\n \n             let vec[@ty.t] captured_tys =\n                 _vec.init_elt[@ty.t](tydesc_ty, ty_param_count);\n@@ -4415,9 +4440,10 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n                 vec(tydesc_ty,\n                     outgoing_fty,\n                     bindings_ty,\n-                    ty.mk_imm_tup(captured_tys));\n+                    ty.mk_imm_tup(cx.fcx.lcx.ccx.tystore, captured_tys));\n \n-            let @ty.t closure_ty = ty.mk_imm_tup(closure_tys);\n+            let @ty.t closure_ty = ty.mk_imm_tup(cx.fcx.lcx.ccx.tystore,\n+                                                 closure_tys);\n \n             auto r = trans_malloc_boxed(bcx, closure_ty);\n             auto box = r.val;\n@@ -4622,7 +4648,7 @@ fn trans_args(@block_ctxt cx,\n         auto mode = args.(i).mode;\n \n         auto val;\n-        if (ty.type_is_structural(ty.expr_ty(e))) {\n+        if (ty.type_is_structural(ty.expr_ty(cx.fcx.lcx.ccx.tystore, e))) {\n             auto re = trans_expr(bcx, e);\n             val = re.val;\n             bcx = re.bcx;\n@@ -4632,7 +4658,8 @@ fn trans_args(@block_ctxt cx,\n                 lv = trans_lval(bcx, e);\n             } else {\n                 auto r = trans_expr(bcx, e);\n-                if (type_is_immediate(ty.expr_ty(e))) {\n+                if (type_is_immediate(ty.expr_ty(cx.fcx.lcx.ccx.tystore,\n+                                                 e))) {\n                     lv = lval_val(r.bcx, r.val);\n                 } else {\n                     lv = lval_mem(r.bcx, r.val);\n@@ -4658,7 +4685,8 @@ fn trans_args(@block_ctxt cx,\n             auto lldestty = arg_tys.(i);\n             if (mode == ast.val) {\n                 // FIXME: we'd prefer to use &&, but rustboot doesn't like it\n-                if (ty.type_is_structural(ty.expr_ty(e))) {\n+                if (ty.type_is_structural(ty.expr_ty(cx.fcx.lcx.ccx.tystore,\n+                                                     e))) {\n                     lldestty = T_ptr(lldestty);\n                 }\n             }\n@@ -4668,7 +4696,8 @@ fn trans_args(@block_ctxt cx,\n \n         if (mode == ast.val) {\n             // FIXME: we'd prefer to use &&, but rustboot doesn't like it\n-            if (ty.type_is_structural(ty.expr_ty(e))) {\n+            if (ty.type_is_structural(ty.expr_ty(cx.fcx.lcx.ccx.tystore,\n+                                                 e))) {\n                 // Until here we've been treating structures by pointer;\n                 // we are now passing it as an arg, so need to load it.\n                 val = bcx.build.Load(val);\n@@ -4723,7 +4752,7 @@ fn trans_call(@block_ctxt cx, @ast.expr f,\n         }\n \n         case (_) {\n-            fn_ty = ty.expr_ty(f);\n+            fn_ty = ty.expr_ty(cx.fcx.lcx.ccx.tystore, f);\n \n         }\n \n@@ -4776,7 +4805,7 @@ fn trans_tup(@block_ctxt cx, vec[ast.elt] elts,\n     let int i = 0;\n \n     for (ast.elt e in elts) {\n-        auto e_ty = ty.expr_ty(e.expr);\n+        auto e_ty = ty.expr_ty(cx.fcx.lcx.ccx.tystore, e.expr);\n         auto src_res = trans_expr(bcx, e.expr);\n         bcx = src_res.bcx;\n         auto dst_res = GEP_tup_like(bcx, t, tup_val, vec(0, i));\n@@ -4819,7 +4848,8 @@ fn trans_vec(@block_ctxt cx, vec[@ast.expr] args,\n                                            C_int(abi.vec_elt_data)));\n \n     auto pseudo_tup_ty =\n-        ty.mk_imm_tup(_vec.init_elt[@ty.t](unit_ty,\n+        ty.mk_imm_tup(cx.fcx.lcx.ccx.tystore,\n+                      _vec.init_elt[@ty.t](unit_ty,\n                                            _vec.len[@ast.expr](args)));\n     let int i = 0;\n \n@@ -5076,7 +5106,7 @@ fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n     // lval cases fall through to trans_lval and then\n     // possibly load the result (if it's non-structural).\n \n-    auto t = ty.expr_ty(e);\n+    auto t = ty.expr_ty(cx.fcx.lcx.ccx.tystore, e);\n     auto sub = trans_lval(cx, e);\n     ret res(sub.res.bcx, load_if_immediate(sub.res.bcx, sub.res.val, t));\n }\n@@ -5135,7 +5165,7 @@ fn trans_log(int lvl, @block_ctxt cx, @ast.expr e) -> result {\n     cx.build.CondBr(test, log_cx.llbb, after_cx.llbb);\n \n     auto sub = trans_expr(log_cx, e);\n-    auto e_ty = ty.expr_ty(e);\n+    auto e_ty = ty.expr_ty(cx.fcx.lcx.ccx.tystore, e);\n \n     if (ty.type_is_fp(e_ty)) {\n         let TypeRef tr;\n@@ -5251,7 +5281,8 @@ fn trans_put(@block_ctxt cx, &option.t[@ast.expr] e) -> result {\n \n             auto llarg = r.val;\n             bcx = r.bcx;\n-            if (ty.type_is_structural(ty.expr_ty(x))) {\n+            if (ty.type_is_structural(ty.expr_ty(cx.fcx.lcx.ccx.tystore,\n+                                                 x))) {\n                 // Until here we've been treating structures by pointer; we\n                 // are now passing it as an arg, so need to load it.\n                 llarg = bcx.build.Load(llarg);\n@@ -5311,7 +5342,7 @@ fn trans_ret(@block_ctxt cx, &option.t[@ast.expr] e) -> result {\n \n     alt (e) {\n         case (some[@ast.expr](?x)) {\n-            auto t = ty.expr_ty(x);\n+            auto t = ty.expr_ty(cx.fcx.lcx.ccx.tystore, x);\n             auto r = trans_expr(cx, x);\n             bcx = r.bcx;\n             val = r.val;\n@@ -5686,7 +5717,7 @@ fn trans_block(@block_ctxt cx, &ast.block b) -> result {\n             if (is_terminated(bcx)) {\n                 ret r;\n             } else {\n-                auto r_ty = ty.expr_ty(e);\n+                auto r_ty = ty.expr_ty(cx.fcx.lcx.ccx.tystore, e);\n                 if (!ty.type_is_nil(r_ty)) {\n                     // The value resulting from the block gets copied into an\n                     // alloca created in an outer scope and its refcount\n@@ -5917,7 +5948,7 @@ fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, self_vt llself) {\n \n     // Synthesize a tuple type for the fields so that GEP_tup_like() can work\n     // its magic.\n-    auto fields_tup_ty = ty.mk_imm_tup(field_tys);\n+    auto fields_tup_ty = ty.mk_imm_tup(fcx.lcx.ccx.tystore, field_tys);\n \n     auto n_typarams = _vec.len[ast.ty_param](bcx.fcx.lcx.obj_typarams);\n     let TypeRef llobj_box_ty = T_obj_ptr(bcx.fcx.lcx.ccx.tn, n_typarams);\n@@ -6142,18 +6173,19 @@ fn trans_obj(@local_ctxt cx, &ast._obj ob, ast.def_id oid,\n         }\n \n         // Synthesize an obj body type.\n-        auto tydesc_ty = ty.mk_type();\n+        auto tydesc_ty = ty.mk_type(cx.ccx.tystore);\n         let vec[@ty.t] tps = vec();\n         for (ast.ty_param tp in ty_params) {\n             _vec.push[@ty.t](tps, tydesc_ty);\n         }\n \n-        let @ty.t typarams_ty = ty.mk_imm_tup(tps);\n-        let @ty.t fields_ty = ty.mk_imm_tup(obj_fields);\n-        let @ty.t body_ty = ty.mk_imm_tup(vec(tydesc_ty,\n+        let @ty.t typarams_ty = ty.mk_imm_tup(cx.ccx.tystore, tps);\n+        let @ty.t fields_ty = ty.mk_imm_tup(cx.ccx.tystore, obj_fields);\n+        let @ty.t body_ty = ty.mk_imm_tup(cx.ccx.tystore,\n+                                          vec(tydesc_ty,\n                                               typarams_ty,\n                                               fields_ty));\n-        let @ty.t boxed_body_ty = ty.mk_imm_box(body_ty);\n+        let @ty.t boxed_body_ty = ty.mk_imm_box(cx.ccx.tystore, body_ty);\n \n         // Malloc a box for the body.\n         auto box = trans_malloc_boxed(bcx, body_ty);\n@@ -6255,7 +6287,7 @@ fn trans_tag_variant(@local_ctxt cx, ast.def_id tag_id,\n     let vec[@ty.t] ty_param_substs = vec();\n     i = 0u;\n     for (ast.ty_param tp in ty_params) {\n-        ty_param_substs += vec(ty.mk_param(i));\n+        ty_param_substs += vec(ty.mk_param(cx.ccx.tystore, i));\n         i += 1u;\n     }\n \n@@ -7450,7 +7482,7 @@ fn create_crate_map(@crate_ctxt ccx) -> ValueRef {\n     ret map;\n }\n \n-fn trans_crate(session.session sess, @ast.crate crate,\n+fn trans_crate(session.session sess, @ast.crate crate, @ty.type_store tystore,\n                &ty.type_cache type_cache, str output, bool shared,\n                bool optimize, bool verify, output_type ot) {\n     auto llmod =\n@@ -7496,7 +7528,8 @@ fn trans_crate(session.session sess, @ast.crate crate,\n                     lltypes = lltypes,\n                     glues = glues,\n                     names = namegen(0),\n-                    sha = std.sha1.mk_sha1());\n+                    sha = std.sha1.mk_sha1(),\n+                    tystore = tystore);\n     auto cx = new_local_ctxt(ccx);\n \n     create_typedefs(ccx);"}, {"sha": "4d94535f53b58e9280dca1b6bbb31853105f45fe", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 155, "deletions": 98, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/5dbf554bb3f5883a3375e21285f9591e0e118914/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dbf554bb3f5883a3375e21285f9591e0e118914/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=5dbf554bb3f5883a3375e21285f9591e0e118914", "patch": "@@ -31,8 +31,8 @@ type mt = rec(@t ty, ast.mutability mut);\n \n // Convert from method type to function type.  Pretty easy; we just drop\n // 'ident'.\n-fn method_ty_to_fn_ty(method m) -> @ty.t {\n-    ret mk_fn(m.proto, m.inputs, m.output);\n+fn method_ty_to_fn_ty(@type_store tystore, method m) -> @ty.t {\n+    ret mk_fn(tystore, m.proto, m.inputs, m.output);\n }\n \n // Do not construct these manually. Soon we want to intern these, at which\n@@ -100,62 +100,99 @@ type ty_param_count_and_ty = tup(uint, @t);\n type type_cache = hashmap[ast.def_id,ty_param_count_and_ty];\n \n \n+type type_store = hashmap[@t,()];\n+\n+fn mk_type_store() -> @hashmap[@t,()] {\n+    auto hasher = hash_ty;\n+    auto eqer = eq_ty;\n+    ret @map.mk_hashmap[@t,()](hasher, eqer);\n+}\n+\n // Type constructors\n \n // This is a private constructor to this module. External users should always\n // use the mk_foo() functions below.\n-fn gen_ty(&sty st) -> @t {\n+fn gen_ty(@type_store tystore, &sty st) -> @t {\n+    // TODO: Intern the type.\n     ret @rec(struct=st, cname=none[str], hash=hash_type_structure(st));\n }\n \n-fn mk_nil() -> @t                        { ret gen_ty(ty_nil); }\n-fn mk_bool() -> @t                       { ret gen_ty(ty_bool); }\n-fn mk_int() -> @t                        { ret gen_ty(ty_int); }\n-fn mk_float() -> @t                      { ret gen_ty(ty_float); }\n-fn mk_uint() -> @t                       { ret gen_ty(ty_uint); }\n-fn mk_mach(util.common.ty_mach tm) -> @t { ret gen_ty(ty_machine(tm)); }\n-fn mk_char() -> @t                       { ret gen_ty(ty_char); }\n-fn mk_str() -> @t                        { ret gen_ty(ty_str); }\n+fn mk_nil(@type_store ts) -> @t          { ret gen_ty(ts, ty_nil); }\n+fn mk_bool(@type_store ts) -> @t         { ret gen_ty(ts, ty_bool); }\n+fn mk_int(@type_store ts) -> @t          { ret gen_ty(ts, ty_int); }\n+fn mk_float(@type_store ts) -> @t        { ret gen_ty(ts, ty_float); }\n+fn mk_uint(@type_store ts) -> @t         { ret gen_ty(ts, ty_uint); }\n \n-fn mk_tag(ast.def_id did, vec[@t] tys) -> @t {\n-    ret gen_ty(ty_tag(did, tys));\n+fn mk_mach(@type_store ts, util.common.ty_mach tm) -> @t {\n+    ret gen_ty(ts, ty_machine(tm));\n }\n \n-fn mk_box(mt tm) -> @t     { ret gen_ty(ty_box(tm)); }\n-fn mk_imm_box(@t ty) -> @t { ret mk_box(rec(ty=ty, mut=ast.imm)); }\n+fn mk_char(@type_store ts) -> @t         { ret gen_ty(ts, ty_char); }\n+fn mk_str(@type_store ts) -> @t          { ret gen_ty(ts, ty_str); }\n \n-fn mk_vec(mt tm) -> @t                   { ret gen_ty(ty_vec(tm)); }\n-fn mk_port(@t ty) -> @t                  { ret gen_ty(ty_port(ty)); }\n-fn mk_chan(@t ty) -> @t                  { ret gen_ty(ty_chan(ty)); }\n-fn mk_task() -> @t                       { ret gen_ty(ty_task); }\n+fn mk_tag(@type_store ts, ast.def_id did, vec[@t] tys) -> @t {\n+    ret gen_ty(ts, ty_tag(did, tys));\n+}\n \n-fn mk_tup(vec[mt] tms) -> @t             { ret gen_ty(ty_tup(tms)); }\n-fn mk_imm_tup(vec[@t] tys) -> @t {\n+fn mk_box(@type_store ts, mt tm) -> @t {\n+    ret gen_ty(ts, ty_box(tm));\n+}\n+\n+fn mk_imm_box(@type_store ts, @t ty) -> @t {\n+    ret mk_box(ts, rec(ty=ty, mut=ast.imm));\n+}\n+\n+fn mk_vec(@type_store ts, mt tm) -> @t   { ret gen_ty(ts, ty_vec(tm)); }\n+fn mk_port(@type_store ts, @t ty) -> @t  { ret gen_ty(ts, ty_port(ty)); }\n+fn mk_chan(@type_store ts, @t ty) -> @t  { ret gen_ty(ts, ty_chan(ty)); }\n+fn mk_task(@type_store ts) -> @t         { ret gen_ty(ts, ty_task); }\n+\n+fn mk_tup(@type_store ts, vec[mt] tms) -> @t {\n+    ret gen_ty(ts, ty_tup(tms));\n+}\n+\n+fn mk_imm_tup(@type_store ts, vec[@t] tys) -> @t {\n     // TODO: map\n     let vec[ty.mt] mts = vec();\n     for (@ty.t typ in tys) {\n         mts += vec(rec(ty=typ, mut=ast.imm));\n     }\n-    ret mk_tup(mts);\n+    ret mk_tup(ts, mts);\n+}\n+\n+fn mk_rec(@type_store ts, vec[field] fs) -> @t {\n+    ret gen_ty(ts, ty_rec(fs));\n }\n \n-fn mk_rec(vec[field] fs) -> @t           { ret gen_ty(ty_rec(fs)); }\n+fn mk_fn(@type_store ts, ast.proto proto, vec[arg] args, @t ty) -> @t {\n+    ret gen_ty(ts, ty_fn(proto, args, ty));\n+}\n+\n+fn mk_native_fn(@type_store ts, ast.native_abi abi, vec[arg] args, @t ty)\n+        -> @t {\n+    ret gen_ty(ts, ty_native_fn(abi, args, ty));\n+}\n \n-fn mk_fn(ast.proto proto, vec[arg] args, @t ty) -> @t {\n-    ret gen_ty(ty_fn(proto, args, ty));\n+fn mk_obj(@type_store ts, vec[method] meths) -> @t {\n+    ret gen_ty(ts, ty_obj(meths));\n }\n \n-fn mk_native_fn(ast.native_abi abi, vec[arg] args, @t ty) -> @t {\n-    ret gen_ty(ty_native_fn(abi, args, ty));\n+fn mk_var(@type_store ts, int v) -> @t   { ret gen_ty(ts, ty_var(v)); }\n+\n+fn mk_local(@type_store ts, ast.def_id did) -> @t {\n+    ret gen_ty(ts, ty_local(did));\n }\n \n-fn mk_obj(vec[method] meths) -> @t       { ret gen_ty(ty_obj(meths)); }\n-fn mk_var(int v) -> @t                   { ret gen_ty(ty_var(v)); }\n-fn mk_local(ast.def_id did) -> @t        { ret gen_ty(ty_local(did)); }\n-fn mk_param(uint n) -> @t                { ret gen_ty(ty_param(n)); }\n-fn mk_bound_param(uint n) -> @t          { ret gen_ty(ty_bound_param(n)); }\n-fn mk_type() -> @t                       { ret gen_ty(ty_type); }\n-fn mk_native() -> @t                     { ret gen_ty(ty_native); }\n+fn mk_param(@type_store ts, uint n) -> @t {\n+    ret gen_ty(ts, ty_param(n));\n+}\n+\n+fn mk_bound_param(@type_store ts, uint n) -> @t {\n+    ret gen_ty(ts, ty_bound_param(n));\n+}\n+\n+fn mk_type(@type_store ts) -> @t         { ret gen_ty(ts, ty_type); }\n+fn mk_native(@type_store ts) -> @t       { ret gen_ty(ts, ty_native); }\n \n \n // Stringification\n@@ -386,7 +423,7 @@ fn walk_ty(ty_walk walker, @t ty) {\n \n type ty_fold = fn(@t) -> @t;\n \n-fn fold_ty(ty_fold fld, @t ty_0) -> @t {\n+fn fold_ty(@type_store tystore, ty_fold fld, @t ty_0) -> @t {\n     auto ty = ty_0;\n     alt (ty.struct) {\n         case (ty_nil)           { /* no-op */ }\n@@ -400,72 +437,81 @@ fn fold_ty(ty_fold fld, @t ty_0) -> @t {\n         case (ty_type)          { /* no-op */ }\n         case (ty_native)        { /* no-op */ }\n         case (ty_box(?tm)) {\n-            ty = copy_cname(mk_box(rec(ty=fold_ty(fld, tm.ty), mut=tm.mut)),\n-                            ty);\n+            ty = copy_cname(mk_box(tystore,\n+                                   rec(ty=fold_ty(tystore, fld, tm.ty),\n+                                       mut=tm.mut)), ty);\n         }\n         case (ty_vec(?tm)) {\n-            ty = copy_cname(mk_vec(rec(ty=fold_ty(fld, tm.ty), mut=tm.mut)),\n-                            ty);\n+            ty = copy_cname(mk_vec(tystore,\n+                                   rec(ty=fold_ty(tystore, fld, tm.ty),\n+                                       mut=tm.mut)), ty);\n         }\n         case (ty_port(?subty)) {\n-            ty = copy_cname(mk_port(fold_ty(fld, subty)), ty);\n+            ty = copy_cname(mk_port(tystore, fold_ty(tystore, fld, subty)),\n+                            ty);\n         }\n         case (ty_chan(?subty)) {\n-            ty = copy_cname(mk_chan(fold_ty(fld, subty)), ty);\n+            ty = copy_cname(mk_chan(tystore, fold_ty(tystore, fld, subty)),\n+                            ty);\n         }\n         case (ty_tag(?tid, ?subtys)) {\n             let vec[@t] new_subtys = vec();\n             for (@t subty in subtys) {\n-                new_subtys += vec(fold_ty(fld, subty));\n+                new_subtys += vec(fold_ty(tystore, fld, subty));\n             }\n-            ty = copy_cname(mk_tag(tid, new_subtys), ty);\n+            ty = copy_cname(mk_tag(tystore, tid, new_subtys), ty);\n         }\n         case (ty_tup(?mts)) {\n             let vec[mt] new_mts = vec();\n             for (mt tm in mts) {\n-                auto new_subty = fold_ty(fld, tm.ty);\n+                auto new_subty = fold_ty(tystore, fld, tm.ty);\n                 new_mts += vec(rec(ty=new_subty, mut=tm.mut));\n             }\n-            ty = copy_cname(mk_tup(new_mts), ty);\n+            ty = copy_cname(mk_tup(tystore, new_mts), ty);\n         }\n         case (ty_rec(?fields)) {\n             let vec[field] new_fields = vec();\n             for (field fl in fields) {\n-                auto new_ty = fold_ty(fld, fl.mt.ty);\n+                auto new_ty = fold_ty(tystore, fld, fl.mt.ty);\n                 auto new_mt = rec(ty=new_ty, mut=fl.mt.mut);\n                 new_fields += vec(rec(ident=fl.ident, mt=new_mt));\n             }\n-            ty = copy_cname(mk_rec(new_fields), ty);\n+            ty = copy_cname(mk_rec(tystore, new_fields), ty);\n         }\n         case (ty_fn(?proto, ?args, ?ret_ty)) {\n             let vec[arg] new_args = vec();\n             for (arg a in args) {\n-                auto new_ty = fold_ty(fld, a.ty);\n+                auto new_ty = fold_ty(tystore, fld, a.ty);\n                 new_args += vec(rec(mode=a.mode, ty=new_ty));\n             }\n-            ty = copy_cname(mk_fn(proto, new_args, fold_ty(fld, ret_ty)), ty);\n+            ty = copy_cname(mk_fn(tystore, proto, new_args,\n+                                  fold_ty(tystore, fld, ret_ty)),\n+                            ty);\n         }\n         case (ty_native_fn(?abi, ?args, ?ret_ty)) {\n             let vec[arg] new_args = vec();\n             for (arg a in args) {\n-                auto new_ty = fold_ty(fld, a.ty);\n+                auto new_ty = fold_ty(tystore, fld, a.ty);\n                 new_args += vec(rec(mode=a.mode, ty=new_ty));\n             }\n-            ty = copy_cname(mk_native_fn(abi, new_args, fold_ty(fld, ret_ty)),\n+            ty = copy_cname(mk_native_fn(tystore, abi, new_args,\n+                                         fold_ty(tystore, fld, ret_ty)),\n                             ty);\n         }\n         case (ty_obj(?methods)) {\n             let vec[method] new_methods = vec();\n             for (method m in methods) {\n                 let vec[arg] new_args = vec();\n                 for (arg a in m.inputs) {\n-                    new_args += vec(rec(mode=a.mode, ty=fold_ty(fld, a.ty)));\n+                    new_args += vec(rec(mode=a.mode,\n+                                        ty=fold_ty(tystore, fld, a.ty)));\n                 }\n                 new_methods += vec(rec(proto=m.proto, ident=m.ident,\n                                        inputs=new_args,\n-                                       output=fold_ty(fld, m.output)));\n+                                       output=fold_ty(tystore, fld,\n+                                                      m.output)));\n             }\n-            ty = copy_cname(mk_obj(new_methods), ty);\n+            ty = copy_cname(mk_obj(tystore, new_methods), ty);\n         }\n         case (ty_var(_))         { /* no-op */ }\n         case (ty_local(_))       { /* no-op */ }\n@@ -536,9 +582,9 @@ fn type_is_sequence(@t ty) -> bool {\n     fail;\n }\n \n-fn sequence_element_type(@t ty) -> @t {\n+fn sequence_element_type(@type_store tystore, @t ty) -> @t {\n     alt (ty.struct) {\n-        case (ty_str)      { ret mk_mach(common.ty_u8); }\n+        case (ty_str)      { ret mk_mach(tystore, common.ty_u8); }\n         case (ty_vec(?mt)) { ret mt.ty; }\n     }\n     fail;\n@@ -1158,7 +1204,7 @@ fn ann_to_type_params(&ast.ann ann) -> vec[@t] {\n \n // Returns the type of an annotation, with type parameter substitutions\n // performed if applicable.\n-fn ann_to_monotype(ast.ann a) -> @ty.t {\n+fn ann_to_monotype(@type_store tystore, ast.ann a) -> @ty.t {\n     // TODO: Refactor to use recursive pattern matching when we're more\n     // confident that it works.\n     alt (a) {\n@@ -1170,7 +1216,7 @@ fn ann_to_monotype(ast.ann a) -> @ty.t {\n             alt (tps_opt) {\n                 case (none[vec[@ty.t]]) { ret typ; }\n                 case (some[vec[@ty.t]](?tps)) {\n-                    ret substitute_type_params(tps, typ);\n+                    ret substitute_type_params(tystore, tps, typ);\n                 }\n             }\n         }\n@@ -1312,32 +1358,32 @@ fn item_ty(@ast.item it) -> ty_param_count_and_ty {\n     ret tup(ty_param_count, result_ty);\n }\n \n-fn stmt_ty(@ast.stmt s) -> @t {\n+fn stmt_ty(@type_store tystore, @ast.stmt s) -> @t {\n     alt (s.node) {\n         case (ast.stmt_expr(?e,_)) {\n-            ret expr_ty(e);\n+            ret expr_ty(tystore, e);\n         }\n         case (_) {\n-            ret mk_nil();\n+            ret mk_nil(tystore);\n         }\n     }\n }\n \n-fn block_ty(&ast.block b) -> @t {\n+fn block_ty(@type_store tystore, &ast.block b) -> @t {\n     alt (b.node.expr) {\n-        case (some[@ast.expr](?e)) { ret expr_ty(e); }\n-        case (none[@ast.expr])     { ret mk_nil(); }\n+        case (some[@ast.expr](?e)) { ret expr_ty(tystore, e); }\n+        case (none[@ast.expr])     { ret mk_nil(tystore); }\n     }\n }\n \n // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n // doesn't provide type parameter substitutions.\n-fn pat_ty(@ast.pat pat) -> @t {\n+fn pat_ty(@type_store ts, @ast.pat pat) -> @t {\n     alt (pat.node) {\n-        case (ast.pat_wild(?ann))           { ret ann_to_monotype(ann); }\n-        case (ast.pat_lit(_, ?ann))         { ret ann_to_monotype(ann); }\n-        case (ast.pat_bind(_, _, ?ann))     { ret ann_to_monotype(ann); }\n-        case (ast.pat_tag(_, _, _, ?ann))   { ret ann_to_monotype(ann); }\n+        case (ast.pat_wild(?ann))           { ret ann_to_monotype(ts, ann); }\n+        case (ast.pat_lit(_, ?ann))         { ret ann_to_monotype(ts, ann); }\n+        case (ast.pat_bind(_, _, ?ann))     { ret ann_to_monotype(ts, ann); }\n+        case (ast.pat_tag(_, _, _, ?ann))   { ret ann_to_monotype(ts, ann); }\n     }\n     fail;   // not reached\n }\n@@ -1394,18 +1440,19 @@ fn expr_ann(@ast.expr expr) -> option.t[ast.ann] {\n // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&int) -> int\"\n // instead of \"fn(&T) -> T with T = int\". If this isn't what you want, see\n // expr_ty_params_and_ty() below.\n-fn expr_ty(@ast.expr expr) -> @t {\n+fn expr_ty(@type_store tystore, @ast.expr expr) -> @t {\n     alt (expr_ann(expr)) {\n-        case (none[ast.ann])     { ret mk_nil(); }\n-        case (some[ast.ann](?a)) { ret ann_to_monotype(a); }\n+        case (none[ast.ann])     { ret mk_nil(tystore); }\n+        case (some[ast.ann](?a)) { ret ann_to_monotype(tystore, a); }\n     }\n }\n \n-fn expr_ty_params_and_ty(@ast.expr expr) -> tup(vec[@t], @t) {\n+fn expr_ty_params_and_ty(@type_store tystore, @ast.expr expr)\n+        -> tup(vec[@t], @t) {\n     alt (expr_ann(expr)) {\n         case (none[ast.ann]) {\n             let vec[@t] tps = vec();\n-            ret tup(tps, mk_nil());\n+            ret tup(tps, mk_nil(tystore));\n         }\n         case (some[ast.ann](?a)) {\n             ret tup(ann_to_type_params(a), ann_to_type(a));\n@@ -1555,7 +1602,8 @@ mod Unify {\n     type ctxt = rec(UFind.ufind sets,\n                     hashmap[int,uint] var_ids,\n                     mutable vec[mutable vec[@t]] types,\n-                    unify_handler handler);\n+                    unify_handler handler,\n+                    @type_store tystore);\n \n     // Wraps the given type in an appropriate cname.\n     //\n@@ -1670,7 +1718,7 @@ mod Unify {\n                 ret r;\n             }\n             case (fn_common_res_ok(?result_ins, ?result_out)) {\n-                auto t2 = mk_fn(e_proto, result_ins, result_out);\n+                auto t2 = mk_fn(cx.tystore, e_proto, result_ins, result_out);\n                 ret ures_ok(t2);\n             }\n         }\n@@ -1696,7 +1744,8 @@ mod Unify {\n                 ret r;\n             }\n             case (fn_common_res_ok(?result_ins, ?result_out)) {\n-                auto t2 = mk_native_fn(e_abi, result_ins, result_out);\n+                auto t2 = mk_native_fn(cx.tystore, e_abi, result_ins,\n+                                       result_out);\n                 ret ures_ok(t2);\n             }\n         }\n@@ -1744,7 +1793,7 @@ mod Unify {\n         }\n         i += 1u;\n       }\n-      auto t = mk_obj(result_meths);\n+      auto t = mk_obj(cx.tystore, result_meths);\n       ret ures_ok(t);\n     }\n \n@@ -1868,7 +1917,8 @@ mod Unify {\n                             i += 1u;\n                         }\n \n-                        ret ures_ok(mk_tag(expected_id, result_tps));\n+                        ret ures_ok(mk_tag(cx.tystore, expected_id,\n+                                           result_tps));\n                     }\n                     case (_) { /* fall through */ }\n                 }\n@@ -1894,7 +1944,7 @@ mod Unify {\n                         alt (result) {\n                             case (ures_ok(?result_sub)) {\n                                 auto mt = rec(ty=result_sub, mut=mut);\n-                                ret ures_ok(mk_box(mt));\n+                                ret ures_ok(mk_box(cx.tystore, mt));\n                             }\n                             case (_) {\n                                 ret result;\n@@ -1926,7 +1976,7 @@ mod Unify {\n                         alt (result) {\n                             case (ures_ok(?result_sub)) {\n                                 auto mt = rec(ty=result_sub, mut=mut);\n-                                ret ures_ok(mk_vec(mt));\n+                                ret ures_ok(mk_vec(cx.tystore, mt));\n                             }\n                             case (_) {\n                                 ret result;\n@@ -1948,7 +1998,7 @@ mod Unify {\n                                                  actual_sub);\n                         alt (result) {\n                             case (ures_ok(?result_sub)) {\n-                                ret ures_ok(mk_port(result_sub));\n+                                ret ures_ok(mk_port(cx.tystore, result_sub));\n                             }\n                             case (_) {\n                                 ret result;\n@@ -1970,7 +2020,7 @@ mod Unify {\n                                                  actual_sub);\n                         alt (result) {\n                             case (ures_ok(?result_sub)) {\n-                                ret ures_ok(mk_chan(result_sub));\n+                                ret ures_ok(mk_chan(cx.tystore, result_sub));\n                             }\n                             case (_) {\n                                 ret result;\n@@ -2029,7 +2079,7 @@ mod Unify {\n                             i += 1u;\n                         }\n \n-                        ret ures_ok(mk_tup(result_elems));\n+                        ret ures_ok(mk_tup(cx.tystore, result_elems));\n                     }\n \n                     case (_) {\n@@ -2093,7 +2143,7 @@ mod Unify {\n                             i += 1u;\n                         }\n \n-                        ret ures_ok(mk_rec(result_fields));\n+                        ret ures_ok(mk_rec(cx.tystore, result_fields));\n                     }\n \n                     case (_) {\n@@ -2202,7 +2252,7 @@ mod Unify {\n         }\n \n         auto f = bind substituter(cx, set_types, _);\n-        ret fold_ty(f, typ);\n+        ret fold_ty(cx.tystore, f, typ);\n     }\n \n     fn unify_sets(@ctxt cx) -> vec[@t] {\n@@ -2235,16 +2285,19 @@ mod Unify {\n         ret result;\n     }\n \n-    fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n-            -> result {\n+    fn unify(@ty.t expected,\n+             @ty.t actual,\n+             &unify_handler handler,\n+             @type_store tystore) -> result {\n         let vec[@t] throwaway = vec();\n         let vec[mutable vec[@t]] types = vec(mutable throwaway);\n         _vec.pop[mutable vec[@t]](types);   // FIXME: botch\n \n         auto cx = @rec(sets=UFind.make(),\n                        var_ids=common.new_int_hash[uint](),\n                        mutable types=types,\n-                       handler=handler);\n+                       handler=handler,\n+                       tystore=tystore);\n \n         auto ures = unify_step(cx, expected, actual);\n         alt (ures) {\n@@ -2307,7 +2360,9 @@ fn type_err_to_str(&ty.type_err err) -> str {\n \n // Performs bound type parameter replacement using the supplied mapping from\n // parameter IDs to types.\n-fn substitute_type_params(vec[@t] bindings, @t typ) -> @t {\n+fn substitute_type_params(@type_store tystore,\n+                          vec[@t] bindings,\n+                          @t typ) -> @t {\n     fn replacer(vec[@t] bindings, @t typ) -> @t {\n         alt (typ.struct) {\n             case (ty_bound_param(?param_index)) {\n@@ -2318,25 +2373,25 @@ fn substitute_type_params(vec[@t] bindings, @t typ) -> @t {\n     }\n \n     auto f = bind replacer(bindings, _);\n-    ret fold_ty(f, typ);\n+    ret fold_ty(tystore, f, typ);\n }\n \n // Converts type parameters in a type to bound type parameters.\n-fn bind_params_in_type(@t typ) -> @t {\n-    fn binder(@t typ) -> @t {\n+fn bind_params_in_type(@type_store tystore, @t typ) -> @t {\n+    fn binder(@type_store tystore, @t typ) -> @t {\n         alt (typ.struct) {\n             case (ty_bound_param(?index)) {\n                 log_err \"bind_params_in_type() called on type that already \" +\n                     \"has bound params in it\";\n                 fail;\n             }\n-            case (ty_param(?index)) { ret mk_bound_param(index); }\n+            case (ty_param(?index)) { ret mk_bound_param(tystore, index); }\n             case (_) { ret typ; }\n         }\n     }\n \n-    auto f = binder;\n-    ret fold_ty(f, typ);\n+    auto f = bind binder(tystore, _);\n+    ret fold_ty(tystore, f, typ);\n }\n \n \n@@ -2361,7 +2416,9 @@ fn def_has_ty_params(&ast.def def) -> bool {\n \n // If the given item is in an external crate, looks up its type and adds it to\n // the type cache. Returns the type parameters and type.\n-fn lookup_item_type(session.session sess, &type_cache cache,\n+fn lookup_item_type(session.session sess,\n+                    @type_store tystore,\n+                    &type_cache cache,\n                     ast.def_id did) -> ty_param_count_and_ty {\n     if (did._0 == sess.get_targ_crate_num()) {\n         // The item is in this crate. The caller should have added it to the\n@@ -2374,7 +2431,7 @@ fn lookup_item_type(session.session sess, &type_cache cache,\n         ret cache.get(did);\n     }\n \n-    auto tyt = creader.get_type(sess, did);\n+    auto tyt = creader.get_type(sess, tystore, did);\n     cache.insert(did, tyt);\n     ret tyt;\n }"}, {"sha": "cf60cb04183a8a9449fd27efffa0307cd7396c44", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 276, "deletions": 211, "changes": 487, "blob_url": "https://github.com/rust-lang/rust/blob/5dbf554bb3f5883a3375e21285f9591e0e118914/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dbf554bb3f5883a3375e21285f9591e0e118914/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=5dbf554bb3f5883a3375e21285f9591e0e118914", "patch": "@@ -62,7 +62,8 @@ type crate_ctxt = rec(session.session sess,\n                       mutable int next_var_id,\n                       unify_cache unify_cache,\n                       mutable uint cache_hits,\n-                      mutable uint cache_misses);\n+                      mutable uint cache_misses,\n+                      @ty.type_store tystore);\n \n type fn_ctxt = rec(@ty.t ret_ty,\n                    @ty_table locals,\n@@ -95,7 +96,7 @@ fn substitute_ty_params(&@crate_ctxt ccx,\n     }\n \n     auto f = bind substituter(ccx, supplied, _);\n-    ret ty.fold_ty(f, typ);\n+    ret ty.fold_ty(ccx.tystore, f, typ);\n }\n \n \n@@ -111,7 +112,7 @@ fn ty_param_count_and_ty_for_def(@fn_ctxt fcx, &ast.def defn)\n             auto t;\n             alt (fcx.locals.find(id)) {\n                 case (some[@ty.t](?t1)) { t = t1; }\n-                case (none[@ty.t]) { t = ty.mk_local(id); }\n+                case (none[@ty.t]) { t = ty.mk_local(fcx.ccx.tystore, id); }\n             }\n             ret tup(0u, t);\n         }\n@@ -120,29 +121,34 @@ fn ty_param_count_and_ty_for_def(@fn_ctxt fcx, &ast.def defn)\n             ret tup(0u, fcx.locals.get(id));\n         }\n         case (ast.def_fn(?id)) {\n-            ret ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.type_cache, id);\n+            ret ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.tystore,\n+                                    fcx.ccx.type_cache, id);\n         }\n         case (ast.def_native_fn(?id)) {\n-            ret ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.type_cache, id);\n+            ret ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.tystore,\n+                                    fcx.ccx.type_cache, id);\n         }\n         case (ast.def_const(?id)) {\n-            ret ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.type_cache, id);\n+            ret ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.tystore,\n+                                    fcx.ccx.type_cache, id);\n         }\n         case (ast.def_variant(_, ?vid)) {\n-            ret ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.type_cache, vid);\n+            ret ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.tystore,\n+                                    fcx.ccx.type_cache, vid);\n         }\n         case (ast.def_binding(?id)) {\n             check (fcx.locals.contains_key(id));\n             ret tup(0u, fcx.locals.get(id));\n         }\n         case (ast.def_obj(?id)) {\n-            ret ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.type_cache, id);\n+            ret ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.tystore,\n+                                    fcx.ccx.type_cache, id);\n         }\n \n         case (ast.def_mod(_)) {\n             // Hopefully part of a path.\n             // TODO: return a type that's more poisonous, perhaps?\n-            ret tup(0u, ty.mk_nil());\n+            ret tup(0u, ty.mk_nil(fcx.ccx.tystore));\n         }\n \n         case (ast.def_ty(_)) {\n@@ -163,7 +169,7 @@ fn ty_param_count_and_ty_for_def(@fn_ctxt fcx, &ast.def defn)\n fn instantiate_path(@fn_ctxt fcx, &ast.path pth, &ty_param_count_and_ty tpt,\n         &span sp) -> ast.ann {\n     auto ty_param_count = tpt._0;\n-    auto t = bind_params_in_type(tpt._1);\n+    auto t = bind_params_in_type(fcx.ccx.tystore, tpt._1);\n \n     auto ty_substs_opt;\n     auto ty_substs_len = _vec.len[@ast.ty](pth.node.types);\n@@ -198,17 +204,25 @@ fn instantiate_path(@fn_ctxt fcx, &ast.path pth, &ty_param_count_and_ty tpt,\n // Parses the programmer's textual representation of a type into our internal\n // notion of a type. `getter` is a function that returns the type\n // corresponding to a definition ID.\n-fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty.t {\n-    fn ast_arg_to_arg(ty_getter getter, &rec(ast.mode mode, @ast.ty ty) arg)\n+fn ast_ty_to_ty(@ty.type_store tystore,\n+                ty_getter getter,\n+                &@ast.ty ast_ty) -> @ty.t {\n+    fn ast_arg_to_arg(@ty.type_store tystore,\n+                      ty_getter getter,\n+                      &rec(ast.mode mode, @ast.ty ty) arg)\n             -> rec(ast.mode mode, @ty.t ty) {\n-        ret rec(mode=arg.mode, ty=ast_ty_to_ty(getter, arg.ty));\n+        ret rec(mode=arg.mode, ty=ast_ty_to_ty(tystore, getter, arg.ty));\n     }\n \n-    fn ast_mt_to_mt(ty_getter getter, &ast.mt mt) -> ty.mt {\n-        ret rec(ty=ast_ty_to_ty(getter, mt.ty), mut=mt.mut);\n+    fn ast_mt_to_mt(@ty.type_store tystore,\n+                    ty_getter getter,\n+                    &ast.mt mt) -> ty.mt {\n+        ret rec(ty=ast_ty_to_ty(tystore, getter, mt.ty), mut=mt.mut);\n     }\n \n-    fn instantiate(ty_getter getter, ast.def_id id,\n+    fn instantiate(@ty.type_store tystore,\n+                   ty_getter getter,\n+                   ast.def_id id,\n                    vec[@ast.ty] args) -> @ty.t {\n         // TODO: maybe record cname chains so we can do\n         // \"foo = int\" like OCaml?\n@@ -222,92 +236,95 @@ fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty.t {\n         //\n         // TODO: Make sure the number of supplied bindings matches the number\n         // of type parameters in the typedef. Emit a friendly error otherwise.\n-        auto bound_ty = bind_params_in_type(params_opt_and_ty._1);\n+        auto bound_ty = bind_params_in_type(tystore, params_opt_and_ty._1);\n         let vec[@ty.t] param_bindings = vec();\n         for (@ast.ty ast_ty in args) {\n-            param_bindings += vec(ast_ty_to_ty(getter, ast_ty));\n+            param_bindings += vec(ast_ty_to_ty(tystore, getter, ast_ty));\n         }\n-        ret ty.substitute_type_params(param_bindings, bound_ty);\n+        ret ty.substitute_type_params(tystore, param_bindings, bound_ty);\n     }\n \n     auto mut = ast.imm;\n     auto typ;\n     auto cname = none[str];\n     alt (ast_ty.node) {\n-        case (ast.ty_nil)          { typ = ty.mk_nil(); }\n-        case (ast.ty_bool)         { typ = ty.mk_bool(); }\n-        case (ast.ty_int)          { typ = ty.mk_int(); }\n-        case (ast.ty_uint)         { typ = ty.mk_uint(); }\n-        case (ast.ty_float)        { typ = ty.mk_float(); }\n-        case (ast.ty_machine(?tm)) { typ = ty.mk_mach(tm); }\n-        case (ast.ty_char)         { typ = ty.mk_char(); }\n-        case (ast.ty_str)          { typ = ty.mk_str(); }\n-        case (ast.ty_box(?mt)) { typ = ty.mk_box(ast_mt_to_mt(getter, mt)); }\n-        case (ast.ty_vec(?mt)) { typ = ty.mk_vec(ast_mt_to_mt(getter, mt)); }\n+        case (ast.ty_nil)          { typ = ty.mk_nil(tystore); }\n+        case (ast.ty_bool)         { typ = ty.mk_bool(tystore); }\n+        case (ast.ty_int)          { typ = ty.mk_int(tystore); }\n+        case (ast.ty_uint)         { typ = ty.mk_uint(tystore); }\n+        case (ast.ty_float)        { typ = ty.mk_float(tystore); }\n+        case (ast.ty_machine(?tm)) { typ = ty.mk_mach(tystore, tm); }\n+        case (ast.ty_char)         { typ = ty.mk_char(tystore); }\n+        case (ast.ty_str)          { typ = ty.mk_str(tystore); }\n+        case (ast.ty_box(?mt)) {\n+            typ = ty.mk_box(tystore, ast_mt_to_mt(tystore, getter, mt));\n+        }\n+        case (ast.ty_vec(?mt)) {\n+            typ = ty.mk_vec(tystore, ast_mt_to_mt(tystore, getter, mt));\n+        }\n \n         case (ast.ty_port(?t)) {\n-            typ = ty.mk_port(ast_ty_to_ty(getter, t));\n+            typ = ty.mk_port(tystore, ast_ty_to_ty(tystore, getter, t));\n         }\n \n         case (ast.ty_chan(?t)) {\n-            typ = ty.mk_chan(ast_ty_to_ty(getter, t));\n+            typ = ty.mk_chan(tystore, ast_ty_to_ty(tystore, getter, t));\n         }\n \n         case (ast.ty_tup(?fields)) {\n             let vec[ty.mt] flds = vec();\n             for (ast.mt field in fields) {\n-                _vec.push[ty.mt](flds, ast_mt_to_mt(getter, field));\n+                _vec.push[ty.mt](flds, ast_mt_to_mt(tystore, getter, field));\n             }\n-            typ = ty.mk_tup(flds);\n+            typ = ty.mk_tup(tystore, flds);\n         }\n         case (ast.ty_rec(?fields)) {\n             let vec[field] flds = vec();\n             for (ast.ty_field f in fields) {\n-                _vec.push[field](flds, rec(ident=f.ident,\n-                                        mt=ast_mt_to_mt(getter, f.mt)));\n+                auto tm = ast_mt_to_mt(tystore, getter, f.mt);\n+                _vec.push[field](flds, rec(ident=f.ident, mt=tm));\n             }\n-            typ = ty.mk_rec(flds);\n+            typ = ty.mk_rec(tystore, flds);\n         }\n \n         case (ast.ty_fn(?proto, ?inputs, ?output)) {\n-            auto f = bind ast_arg_to_arg(getter, _);\n+            auto f = bind ast_arg_to_arg(tystore, getter, _);\n             auto i = _vec.map[ast.ty_arg, arg](f, inputs);\n-            typ = ty.mk_fn(proto, i, ast_ty_to_ty(getter, output));\n+            auto out_ty = ast_ty_to_ty(tystore, getter, output);\n+            typ = ty.mk_fn(tystore, proto, i, out_ty);\n         }\n \n         case (ast.ty_path(?path, ?def)) {\n             check (def != none[ast.def]);\n             alt (option.get[ast.def](def)) {\n                 case (ast.def_ty(?id)) {\n-                    typ = instantiate(getter, id, path.node.types);\n-                }\n-                case (ast.def_native_ty(?id)) {\n-                    typ = getter(id)._1;\n+                    typ = instantiate(tystore, getter, id, path.node.types);\n                 }\n-                case (ast.def_obj(?id))     {\n-                    typ = instantiate(getter, id, path.node.types);\n+                case (ast.def_native_ty(?id)) { typ = getter(id)._1; }\n+                case (ast.def_obj(?id)) {\n+                    typ = instantiate(tystore, getter, id, path.node.types);\n                 }\n-                case (ast.def_ty_arg(?id))  { typ = ty.mk_param(id); }\n-                case (_)                    { fail; }\n+                case (ast.def_ty_arg(?id)) { typ = ty.mk_param(tystore, id); }\n+                case (_)                   { fail; }\n             }\n \n             cname = some(path_to_str(path));\n         }\n \n         case (ast.ty_obj(?meths)) {\n             let vec[ty.method] tmeths = vec();\n-            auto f = bind ast_arg_to_arg(getter, _);\n+            auto f = bind ast_arg_to_arg(tystore, getter, _);\n             for (ast.ty_method m in meths) {\n                 auto ins = _vec.map[ast.ty_arg, arg](f, m.inputs);\n-                auto out = ast_ty_to_ty(getter, m.output);\n+                auto out = ast_ty_to_ty(tystore, getter, m.output);\n                 _vec.push[ty.method](tmeths,\n                                   rec(proto=m.proto,\n                                       ident=m.ident,\n                                       inputs=ins,\n                                       output=out));\n             }\n \n-            typ = ty.mk_obj(ty.sort_methods(tmeths));\n+            typ = ty.mk_obj(tystore, ty.sort_methods(tmeths));\n         }\n     }\n \n@@ -322,10 +339,10 @@ fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty.t {\n // ast_ty_to_ty.\n fn ast_ty_to_ty_crate(@crate_ctxt ccx, &@ast.ty ast_ty) -> @ty.t {\n     fn getter(@crate_ctxt ccx, ast.def_id id) -> ty.ty_param_count_and_ty {\n-        ret ty.lookup_item_type(ccx.sess, ccx.type_cache, id);\n+        ret ty.lookup_item_type(ccx.sess, ccx.tystore, ccx.type_cache, id);\n     }\n     auto f = bind getter(ccx, _);\n-    ret ast_ty_to_ty(f, ast_ty);\n+    ret ast_ty_to_ty(ccx.tystore, f, ast_ty);\n }\n \n \n@@ -343,7 +360,8 @@ fn ast_ty_to_ty_crate(@crate_ctxt ccx, &@ast.ty ast_ty) -> @ty.t {\n mod Collect {\n     type ctxt = rec(session.session sess,\n                     @ty_item_table id_to_ty_item,\n-                    ty.type_cache type_cache);\n+                    ty.type_cache type_cache,\n+                    @ty.type_store tystore);\n     type env = rec(@ctxt cx, ast.native_abi abi);\n \n     fn ty_of_fn_decl(@ctxt cx,\n@@ -355,7 +373,7 @@ mod Collect {\n                      ast.def_id def_id) -> ty.ty_param_count_and_ty {\n         auto input_tys = _vec.map[ast.arg,arg](ty_of_arg, decl.inputs);\n         auto output_ty = convert(decl.output);\n-        auto t_fn = ty.mk_fn(proto, input_tys, output_ty);\n+        auto t_fn = ty.mk_fn(cx.tystore, proto, input_tys, output_ty);\n         auto ty_param_count = _vec.len[ast.ty_param](ty_params);\n         auto tpt = tup(ty_param_count, t_fn);\n         cx.type_cache.insert(def_id, tpt);\n@@ -371,7 +389,7 @@ mod Collect {\n                             ast.def_id def_id) -> ty.ty_param_count_and_ty {\n         auto input_tys = _vec.map[ast.arg,arg](ty_of_arg, decl.inputs);\n         auto output_ty = convert(decl.output);\n-        auto t_fn = ty.mk_native_fn(abi, input_tys, output_ty);\n+        auto t_fn = ty.mk_native_fn(cx.tystore, abi, input_tys, output_ty);\n         auto ty_param_count = _vec.len[ast.ty_param](ty_params);\n         auto tpt = tup(ty_param_count, t_fn);\n         cx.type_cache.insert(def_id, tpt);\n@@ -382,7 +400,7 @@ mod Collect {\n \n         if (id._0 != cx.sess.get_targ_crate_num()) {\n             // This is a type we need to load in from the crate reader.\n-            ret creader.get_type(cx.sess, id);\n+            ret creader.get_type(cx.sess, cx.tystore, id);\n         }\n \n         check (cx.id_to_ty_item.contains_key(id));\n@@ -401,12 +419,12 @@ mod Collect {\n \n     fn ty_of_arg(@ctxt cx, &ast.arg a) -> arg {\n         auto f = bind getter(cx, _);\n-        ret rec(mode=a.mode, ty=ast_ty_to_ty(f, a.ty));\n+        ret rec(mode=a.mode, ty=ast_ty_to_ty(cx.tystore, f, a.ty));\n     }\n \n     fn ty_of_method(@ctxt cx, &@ast.method m) -> method {\n         auto get = bind getter(cx, _);\n-        auto convert = bind ast_ty_to_ty(get, _);\n+        auto convert = bind ast_ty_to_ty(cx.tystore, get, _);\n         auto f = bind ty_of_arg(cx, _);\n         auto inputs = _vec.map[ast.arg,arg](f, m.node.meth.decl.inputs);\n         auto output = convert(m.node.meth.decl.output);\n@@ -421,7 +439,7 @@ mod Collect {\n         auto f = bind ty_of_method(cx, _);\n         auto methods = _vec.map[@ast.method,method](f, obj_info.methods);\n \n-        auto t_obj = ty.mk_obj(ty.sort_methods(methods));\n+        auto t_obj = ty.mk_obj(cx.tystore, ty.sort_methods(methods));\n         t_obj = ty.rename(t_obj, id);\n         auto ty_param_count = _vec.len[ast.ty_param](ty_params);\n         ret tup(ty_param_count, t_obj);\n@@ -437,20 +455,20 @@ mod Collect {\n         let vec[arg] t_inputs = vec();\n         for (ast.obj_field f in obj_info.fields) {\n             auto g = bind getter(cx, _);\n-            auto t_field = ast_ty_to_ty(g, f.ty);\n+            auto t_field = ast_ty_to_ty(cx.tystore, g, f.ty);\n             _vec.push[arg](t_inputs, rec(mode=ast.alias, ty=t_field));\n         }\n \n         cx.type_cache.insert(obj_ty_id, t_obj);\n \n-        auto t_fn = ty.mk_fn(ast.proto_fn, t_inputs, t_obj._1);\n+        auto t_fn = ty.mk_fn(cx.tystore, ast.proto_fn, t_inputs, t_obj._1);\n         ret tup(t_obj._0, t_fn);\n     }\n \n     fn ty_of_item(@ctxt cx, @ast.item it) -> ty.ty_param_count_and_ty {\n \n         auto get = bind getter(cx, _);\n-        auto convert = bind ast_ty_to_ty(get, _);\n+        auto convert = bind ast_ty_to_ty(cx.tystore, get, _);\n \n         alt (it.node) {\n \n@@ -493,11 +511,11 @@ mod Collect {\n \n                 auto i = 0u;\n                 for (ast.ty_param tp in tps) {\n-                    subtys += vec(ty.mk_param(i));\n+                    subtys += vec(ty.mk_param(cx.tystore, i));\n                     i += 1u;\n                 }\n \n-                auto t = ty.mk_tag(def_id, subtys);\n+                auto t = ty.mk_tag(cx.tystore, def_id, subtys);\n \n                 auto ty_param_count = _vec.len[ast.ty_param](tps);\n                 auto tpt = tup(ty_param_count, t);\n@@ -516,7 +534,7 @@ mod Collect {\n             case (ast.native_item_fn(?ident, ?lname, ?fn_decl,\n                                      ?params, ?def_id, _)) {\n                 auto get = bind getter(cx, _);\n-                auto convert = bind ast_ty_to_ty(get, _);\n+                auto convert = bind ast_ty_to_ty(cx.tystore, get, _);\n                 auto f = bind ty_of_arg(cx, _);\n                 ret ty_of_native_fn_decl(cx, convert, f, fn_decl, abi, params,\n                                          def_id);\n@@ -527,7 +545,7 @@ mod Collect {\n                     ret cx.type_cache.get(def_id);\n                 }\n \n-                auto t = ty.mk_native();\n+                auto t = ty.mk_native(cx.tystore);\n                 auto tpt = tup(0u, t);\n                 cx.type_cache.insert(def_id, tpt);\n                 ret tpt;\n@@ -545,7 +563,7 @@ mod Collect {\n         let vec[@ty.t] ty_param_tys = vec();\n         auto i = 0u;\n         for (ast.ty_param tp in ty_params) {\n-            ty_param_tys += vec(ty.mk_param(i));\n+            ty_param_tys += vec(ty.mk_param(cx.tystore, i));\n             i += 1u;\n         }\n \n@@ -556,19 +574,19 @@ mod Collect {\n             // constructors get turned into functions.\n             auto result_ty;\n             if (_vec.len[ast.variant_arg](variant.node.args) == 0u) {\n-                result_ty = ty.mk_tag(tag_id, ty_param_tys);\n+                result_ty = ty.mk_tag(cx.tystore, tag_id, ty_param_tys);\n             } else {\n                 // As above, tell ast_ty_to_ty() that trans_ty_item_to_ty()\n                 // should be called to resolve named types.\n                 auto f = bind getter(cx, _);\n \n                 let vec[arg] args = vec();\n                 for (ast.variant_arg va in variant.node.args) {\n-                    auto arg_ty = ast_ty_to_ty(f, va.ty);\n+                    auto arg_ty = ast_ty_to_ty(cx.tystore, f, va.ty);\n                     args += vec(rec(mode=ast.alias, ty=arg_ty));\n                 }\n-                auto tag_t = ty.mk_tag(tag_id, ty_param_tys);\n-                result_ty = ty.mk_fn(ast.proto_fn, args, tag_t);\n+                auto tag_t = ty.mk_tag(cx.tystore, tag_id, ty_param_tys);\n+                result_ty = ty.mk_fn(cx.tystore, ast.proto_fn, args, tag_t);\n             }\n \n             auto tpt = tup(ty_param_count, result_ty);\n@@ -702,7 +720,8 @@ mod Collect {\n             let method meth_ty = meth_tys.(ix);\n             let ast.method_ m_;\n             let @ast.method m;\n-            auto meth_tfn = ty.mk_fn(meth_ty.proto,\n+            auto meth_tfn = ty.mk_fn(e.cx.tystore,\n+                                     meth_ty.proto,\n                                      meth_ty.inputs,\n                                      meth_ty.output);\n             m_ = rec(ann=triv_ann(meth_tfn)\n@@ -713,7 +732,7 @@ mod Collect {\n         }\n         auto g = bind getter(e.cx, _);\n         for (ast.obj_field fld in ob.fields) {\n-            let @ty.t fty = ast_ty_to_ty(g, fld.ty);\n+            let @ty.t fty = ast_ty_to_ty(e.cx.tystore, g, fld.ty);\n             let ast.obj_field f = rec(ann=triv_ann(fty)\n                 with fld\n             );\n@@ -724,8 +743,9 @@ mod Collect {\n         alt (ob.dtor) {\n             case (some[@ast.method](?d)) {\n                 let vec[arg] inputs = vec();\n-                let @ty.t output = ty.mk_nil();\n-                auto dtor_tfn = ty.mk_fn(ast.proto_fn, inputs, output);\n+                let @ty.t output = ty.mk_nil(e.cx.tystore);\n+                auto dtor_tfn = ty.mk_fn(e.cx.tystore, ast.proto_fn, inputs,\n+                                         output);\n                 auto d_ = rec(ann=triv_ann(dtor_tfn) with d.node);\n                 dtor = some[@ast.method](@rec(node=d_ with *d));\n             }\n@@ -762,7 +782,9 @@ mod Collect {\n         ret @fold.respan[ast.item_](sp, item);\n     }\n \n-    fn collect_item_types(session.session sess, @ast.crate crate)\n+    fn collect_item_types(session.session sess,\n+                          @ty.type_store tystore,\n+                          @ast.crate crate)\n             -> tup(@ast.crate, ty.type_cache, @ty_item_table) {\n         // First pass: collect all type item IDs.\n         auto module = crate.node.module;\n@@ -779,7 +801,8 @@ mod Collect {\n \n         auto cx = @rec(sess=sess,\n                        id_to_ty_item=id_to_ty_item,\n-                       type_cache=type_cache);\n+                       type_cache=type_cache,\n+                       tystore=tystore);\n \n         let @env e = @rec(cx=cx, abi=ast.native_abi_cdecl);\n \n@@ -806,7 +829,8 @@ mod Collect {\n mod Unify {\n     fn simple(@fn_ctxt fcx, @ty.t expected, @ty.t actual) -> ty.Unify.result {\n         // FIXME: horrid botch\n-        let vec[mutable @ty.t] param_substs = vec(mutable ty.mk_nil());\n+        let vec[mutable @ty.t] param_substs =\n+            vec(mutable ty.mk_nil(fcx.ccx.tystore));\n         _vec.pop[mutable @ty.t](param_substs);\n         ret with_params(fcx, expected, actual, param_substs);\n     }\n@@ -855,7 +879,8 @@ mod Unify {\n                 }\n \n                 unified_type =\n-                    ty.substitute_type_params(param_substs_1, unified_type);\n+                    ty.substitute_type_params(fcx.ccx.tystore, param_substs_1,\n+                                              unified_type);\n                 fcx.locals.insert(id, unified_type);\n             }\n             fn record_param(uint index, @ty.t binding) -> ty.Unify.result {\n@@ -868,7 +893,8 @@ mod Unify {\n                 alt (result) {\n                     case (ures_ok(?new_subst)) {\n                         param_substs.(index) = new_subst;\n-                        ret ures_ok(ty.mk_bound_param(index));\n+                        ret ures_ok(ty.mk_bound_param(fcx.ccx.tystore,\n+                                                      index));\n                     }\n                     case (_) { ret result; }\n                 }\n@@ -877,7 +903,10 @@ mod Unify {\n \n \n         auto handler = unify_handler(fcx, param_substs);\n-        auto result = ty.Unify.unify(expected, actual, handler);\n+        auto result = ty.Unify.unify(expected,\n+                                     actual,\n+                                     handler,\n+                                     fcx.ccx.tystore);\n         fcx.ccx.unify_cache.insert(cache_key, result);\n         ret result;\n     }\n@@ -900,10 +929,10 @@ fn strip_boxes(@ty.t t) -> @ty.t {\n     fail;\n }\n \n-fn add_boxes(uint n, @ty.t t) -> @ty.t {\n+fn add_boxes(@crate_ctxt ccx, uint n, @ty.t t) -> @ty.t {\n     auto t1 = t;\n     while (n != 0u) {\n-        t1 = ty.mk_imm_box(t1);\n+        t1 = ty.mk_imm_box(ccx.tystore, t1);\n         n -= 1u;\n     }\n     ret t1;\n@@ -957,7 +986,8 @@ mod Demand {\n             implicit_boxes = count_boxes(actual);\n         }\n \n-        let vec[mutable @ty.t] ty_param_substs = vec(mutable ty.mk_nil());\n+        let vec[mutable @ty.t] ty_param_substs =\n+            vec(mutable ty.mk_nil(fcx.ccx.tystore));\n         _vec.pop[mutable @ty.t](ty_param_substs);   // FIXME: horrid botch\n         for (@ty.t ty_param_subst in ty_param_substs_0) {\n             ty_param_substs += vec(mutable ty_param_subst);\n@@ -971,7 +1001,8 @@ mod Demand {\n                     result_ty_param_substs += vec(ty_param_subst);\n                 }\n \n-                ret tup(result_ty_param_substs, add_boxes(implicit_boxes, t));\n+                ret tup(result_ty_param_substs,\n+                        add_boxes(fcx.ccx, implicit_boxes, t));\n             }\n \n             case (ures_err(?err, ?expected, ?actual)) {\n@@ -1004,12 +1035,13 @@ fn variant_arg_types(@crate_ctxt ccx, &span sp, ast.def_id vid,\n \n     let vec[@ty.t] result = vec();\n \n-    auto tpt = ty.lookup_item_type(ccx.sess, ccx.type_cache, vid);\n+    auto tpt = ty.lookup_item_type(ccx.sess, ccx.tystore, ccx.type_cache,\n+                                   vid);\n     alt (tpt._1.struct) {\n         case (ty.ty_fn(_, ?ins, _)) {\n             // N-ary variant.\n             for (ty.arg arg in ins) {\n-                auto arg_ty = bind_params_in_type(arg.ty);\n+                auto arg_ty = bind_params_in_type(ccx.tystore, arg.ty);\n                 arg_ty = substitute_ty_params(ccx, arg_ty, ty_param_count,\n                                               tag_ty_params, sp);\n                 result += vec(arg_ty);\n@@ -1380,7 +1412,7 @@ mod Pushdown {\n                 let @ast.expr es_1;\n                 alt (t.struct) {\n                     case (ty.ty_chan(?subty)) {\n-                        auto pt = ty.mk_port(subty);\n+                        auto pt = ty.mk_port(fcx.ccx.tystore, subty);\n                         es_1 = pushdown_expr(fcx, pt, es);\n                     }\n                     case (_) {\n@@ -1396,7 +1428,8 @@ mod Pushdown {\n                 let vec[ast.arm] arms_1 = vec();\n                 for (ast.arm arm_0 in arms_0) {\n                     auto block_1 = pushdown_block(fcx, expected, arm_0.block);\n-                    t = Demand.simple(fcx, e.span, t, block_ty(block_1));\n+                    t = Demand.simple(fcx, e.span, t,\n+                                      block_ty(fcx.ccx.tystore, block_1));\n                     auto arm_1 = rec(pat=arm_0.pat, block=block_1,\n                                      index=arm_0.index);\n                     arms_1 += vec(arm_1);\n@@ -1407,16 +1440,20 @@ mod Pushdown {\n             case (ast.expr_recv(?lval_0, ?expr_0, ?ann)) {\n                 auto lval_1 = pushdown_expr(fcx, next_ty_var(fcx.ccx),\n                                             lval_0);\n-                auto t = expr_ty(lval_1);\n-                auto expr_1 = pushdown_expr(fcx, ty.mk_port(t), expr_0);\n+                auto t = expr_ty(fcx.ccx.tystore, lval_1);\n+                auto expr_1 = pushdown_expr(fcx,\n+                                            ty.mk_port(fcx.ccx.tystore, t),\n+                                            expr_0);\n                 e_1 = ast.expr_recv(lval_1, expr_1, ann);\n             }\n \n             case (ast.expr_send(?lval_0, ?expr_0, ?ann)) {\n                 auto expr_1 = pushdown_expr(fcx, next_ty_var(fcx.ccx),\n                                             expr_0);\n-                auto t = expr_ty(expr_1);\n-                auto lval_1 = pushdown_expr(fcx, ty.mk_chan(t), lval_0);\n+                auto t = expr_ty(fcx.ccx.tystore, expr_1);\n+                auto lval_1 = pushdown_expr(fcx,\n+                                            ty.mk_chan(fcx.ccx.tystore, t),\n+                                            lval_0);\n                 e_1 = ast.expr_send(lval_1, expr_1, ann);\n             }\n \n@@ -1440,13 +1477,14 @@ mod Pushdown {\n                 auto block_ = rec(stmts=bloc.node.stmts,\n                                   expr=some[@ast.expr](e_1),\n                                   index=bloc.node.index,\n-                                  a=plain_ann());\n+                                  a=plain_ann(fcx.ccx.tystore));\n                 ret fold.respan[ast.block_](bloc.span, block_);\n             }\n             case (none[@ast.expr]) {\n-                Demand.simple(fcx, bloc.span, expected, ty.mk_nil());\n+                Demand.simple(fcx, bloc.span, expected,\n+                              ty.mk_nil(fcx.ccx.tystore));\n                 ret fold.respan[ast.block_](bloc.span,\n-                      rec(a = plain_ann() with bloc.node));\n+                      rec(a = plain_ann(fcx.ccx.tystore) with bloc.node));\n             }\n         }\n     }\n@@ -1488,7 +1526,7 @@ fn resolve_local_types_in_annotation(&option.t[@fn_ctxt] env, ast.ann ann)\n         }\n         case (ast.ann_type(?typ, ?tps, ?ts_info)) {\n             auto f = bind resolver(fcx, _);\n-            auto new_type = ty.fold_ty(f, ann_to_type(ann));\n+            auto new_type = ty.fold_ty(fcx.ccx.tystore, f, ann_to_type(ann));\n             ret ast.ann_type(new_type, tps, ts_info);\n         }\n     }\n@@ -1522,18 +1560,18 @@ fn resolve_local_types_in_block(&@fn_ctxt fcx, &ast.block block)\n \n // AST fragment checking\n \n-fn check_lit(@ast.lit lit) -> @ty.t {\n+fn check_lit(@crate_ctxt ccx, @ast.lit lit) -> @ty.t {\n     alt (lit.node) {\n-        case (ast.lit_str(_))           { ret ty.mk_str(); }\n-        case (ast.lit_char(_))          { ret ty.mk_char(); }\n-        case (ast.lit_int(_))           { ret ty.mk_int();  }\n-        case (ast.lit_float(_))         { ret ty.mk_float();  }\n+        case (ast.lit_str(_))           { ret ty.mk_str(ccx.tystore); }\n+        case (ast.lit_char(_))          { ret ty.mk_char(ccx.tystore); }\n+        case (ast.lit_int(_))           { ret ty.mk_int(ccx.tystore);  }\n+        case (ast.lit_float(_))         { ret ty.mk_float(ccx.tystore);  }\n         case (ast.lit_mach_float(?tm, _))\n-                                        { ret ty.mk_mach(tm); }\n-        case (ast.lit_uint(_))          { ret ty.mk_uint(); }\n-        case (ast.lit_mach_int(?tm, _)) { ret ty.mk_mach(tm); }\n-        case (ast.lit_nil)              { ret ty.mk_nil();  }\n-        case (ast.lit_bool(_))          { ret ty.mk_bool(); }\n+                                        { ret ty.mk_mach(ccx.tystore, tm); }\n+        case (ast.lit_uint(_))          { ret ty.mk_uint(ccx.tystore); }\n+        case (ast.lit_mach_int(?tm, _)) { ret ty.mk_mach(ccx.tystore, tm); }\n+        case (ast.lit_nil)              { ret ty.mk_nil(ccx.tystore);  }\n+        case (ast.lit_bool(_))          { ret ty.mk_bool(ccx.tystore); }\n     }\n \n     fail; // not reached\n@@ -1546,21 +1584,21 @@ fn check_pat(&@fn_ctxt fcx, @ast.pat pat) -> @ast.pat {\n             new_pat = ast.pat_wild(triv_ann(next_ty_var(fcx.ccx)));\n         }\n         case (ast.pat_lit(?lt, _)) {\n-            new_pat = ast.pat_lit(lt, triv_ann(check_lit(lt)));\n+            new_pat = ast.pat_lit(lt, triv_ann(check_lit(fcx.ccx, lt)));\n         }\n         case (ast.pat_bind(?id, ?def_id, _)) {\n             auto ann = triv_ann(next_ty_var(fcx.ccx));\n             new_pat = ast.pat_bind(id, def_id, ann);\n         }\n         case (ast.pat_tag(?p, ?subpats, ?vdef_opt, _)) {\n             auto vdef = option.get[ast.variant_def](vdef_opt);\n-            auto t = ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.type_cache,\n-                                         vdef._1)._1;\n+            auto t = ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.tystore,\n+                                         fcx.ccx.type_cache, vdef._1)._1;\n             auto len = _vec.len[ast.ident](p.node.idents);\n             auto last_id = p.node.idents.(len - 1u);\n \n-            auto tpt = ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.type_cache,\n-                                           vdef._0);\n+            auto tpt = ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.tystore,\n+                                           fcx.ccx.type_cache, vdef._0);\n             auto ann = instantiate_path(fcx, p, tpt, pat.span);\n \n             alt (t.struct) {\n@@ -1635,7 +1673,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                     args_0 += vec(some[@ast.expr](a_0));\n \n                     // FIXME: this breaks aliases. We need a ty_fn_arg.\n-                    auto arg_ty = rec(mode=ast.val, ty=expr_ty(a_0));\n+                    auto arg_ty = rec(mode=ast.val,\n+                                      ty=expr_ty(fcx.ccx.tystore, a_0));\n                     _vec.push[arg](arg_tys_0, arg_ty);\n                 }\n                 case (none[@ast.expr]) {\n@@ -1650,12 +1689,12 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n         auto rt_0 = next_ty_var(fcx.ccx);\n         auto t_0;\n-        alt (expr_ty(f_0).struct) {\n+        alt (expr_ty(fcx.ccx.tystore, f_0).struct) {\n             case (ty.ty_fn(?proto, _, _))   {\n-                t_0 = ty.mk_fn(proto, arg_tys_0, rt_0);\n+                t_0 = ty.mk_fn(fcx.ccx.tystore, proto, arg_tys_0, rt_0);\n             }\n             case (ty.ty_native_fn(?abi, _, _))   {\n-                t_0 = ty.mk_native_fn(abi, arg_tys_0, rt_0);\n+                t_0 = ty.mk_native_fn(fcx.ccx.tystore, abi, arg_tys_0, rt_0);\n             }\n             case (_) {\n                 log_err \"check_call_or_bind(): fn expr doesn't have fn type\";\n@@ -1664,7 +1703,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         }\n \n         // Unify the callee and arguments.\n-        auto tpt_0 = ty.expr_ty_params_and_ty(f_0);\n+        auto tpt_0 = ty.expr_ty_params_and_ty(fcx.ccx.tystore, f_0);\n         auto tpt_1 = Demand.full(fcx, f.span, tpt_0._1, t_0, tpt_0._0,\n                                  NO_AUTODEREF);\n         auto f_1 = ty.replace_expr_type(f_0, tpt_1);\n@@ -1677,13 +1716,15 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         -> tup(@ast.expr, @ast.expr, ast.ann) {\n         auto lhs_0 = check_expr(fcx, lhs);\n         auto rhs_0 = check_expr(fcx, rhs);\n-        auto lhs_t0 = expr_ty(lhs_0);\n-        auto rhs_t0 = expr_ty(rhs_0);\n+        auto lhs_t0 = expr_ty(fcx.ccx.tystore, lhs_0);\n+        auto rhs_t0 = expr_ty(fcx.ccx.tystore, rhs_0);\n \n         auto lhs_1 = Pushdown.pushdown_expr(fcx, rhs_t0, lhs_0);\n-        auto rhs_1 = Pushdown.pushdown_expr(fcx, expr_ty(lhs_1), rhs_0);\n+        auto rhs_1 = Pushdown.pushdown_expr(fcx,\n+                                            expr_ty(fcx.ccx.tystore, lhs_1),\n+                                            rhs_0);\n \n-        auto ann = triv_ann(expr_ty(rhs_1));\n+        auto ann = triv_ann(expr_ty(fcx.ccx.tystore, rhs_1));\n         ret tup(lhs_1, rhs_1, ann);\n     }\n \n@@ -1710,7 +1751,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n     alt (expr.node) {\n         case (ast.expr_lit(?lit, _)) {\n-            auto typ = check_lit(lit);\n+            auto typ = check_lit(fcx.ccx, lit);\n             auto ann = triv_ann(typ);\n             ret @fold.respan[ast.expr_](expr.span, ast.expr_lit(lit, ann));\n         }\n@@ -1719,23 +1760,25 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         case (ast.expr_binary(?binop, ?lhs, ?rhs, _)) {\n             auto lhs_0 = check_expr(fcx, lhs);\n             auto rhs_0 = check_expr(fcx, rhs);\n-            auto lhs_t0 = expr_ty(lhs_0);\n-            auto rhs_t0 = expr_ty(rhs_0);\n+            auto lhs_t0 = expr_ty(fcx.ccx.tystore, lhs_0);\n+            auto rhs_t0 = expr_ty(fcx.ccx.tystore, rhs_0);\n \n             // FIXME: Binops have a bit more subtlety than this.\n             auto lhs_1 = Pushdown.pushdown_expr_full(fcx, rhs_t0, lhs_0,\n                                                      AUTODEREF_OK);\n-            auto rhs_1 = Pushdown.pushdown_expr_full(fcx, expr_ty(lhs_1),\n-                                                     rhs_0, AUTODEREF_OK);\n+            auto rhs_1 =\n+                Pushdown.pushdown_expr_full(fcx,\n+                                            expr_ty(fcx.ccx.tystore, lhs_1),\n+                                            rhs_0, AUTODEREF_OK);\n \n             auto t = strip_boxes(lhs_t0);\n             alt (binop) {\n-                case (ast.eq) { t = ty.mk_bool(); }\n-                case (ast.lt) { t = ty.mk_bool(); }\n-                case (ast.le) { t = ty.mk_bool(); }\n-                case (ast.ne) { t = ty.mk_bool(); }\n-                case (ast.ge) { t = ty.mk_bool(); }\n-                case (ast.gt) { t = ty.mk_bool(); }\n+                case (ast.eq) { t = ty.mk_bool(fcx.ccx.tystore); }\n+                case (ast.lt) { t = ty.mk_bool(fcx.ccx.tystore); }\n+                case (ast.le) { t = ty.mk_bool(fcx.ccx.tystore); }\n+                case (ast.ne) { t = ty.mk_bool(fcx.ccx.tystore); }\n+                case (ast.ge) { t = ty.mk_bool(fcx.ccx.tystore); }\n+                case (ast.gt) { t = ty.mk_bool(fcx.ccx.tystore); }\n                 case (_) { /* fall through */ }\n             }\n \n@@ -1748,10 +1791,11 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n         case (ast.expr_unary(?unop, ?oper, _)) {\n             auto oper_1 = check_expr(fcx, oper);\n-            auto oper_t = expr_ty(oper_1);\n+            auto oper_t = expr_ty(fcx.ccx.tystore, oper_1);\n             alt (unop) {\n                 case (ast.box(?mut)) {\n-                    oper_t = ty.mk_box(rec(ty=oper_t, mut=mut));\n+                    oper_t = ty.mk_box(fcx.ccx.tystore,\n+                                       rec(ty=oper_t, mut=mut));\n                 }\n                 case (ast.deref) {\n                     alt (oper_t.struct) {\n@@ -1775,7 +1819,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         }\n \n         case (ast.expr_path(?pth, ?defopt, _)) {\n-            auto t = ty.mk_nil();\n+            auto t = ty.mk_nil(fcx.ccx.tystore);\n             check (defopt != none[ast.def]);\n             auto defn = option.get[ast.def](defopt);\n \n@@ -1801,7 +1845,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n         case (ast.expr_ext(?p, ?args, ?body, ?expanded, _)) {\n             auto exp_ = check_expr(fcx, expanded);\n-            auto t = expr_ty(exp_);\n+            auto t = expr_ty(fcx.ccx.tystore, exp_);\n             auto ann = triv_ann(t);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_ext(p, args, body, exp_,\n@@ -1810,63 +1854,66 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n         case (ast.expr_fail(_)) {\n             ret @fold.respan[ast.expr_](expr.span,\n-                                        ast.expr_fail(plain_ann()));\n+                ast.expr_fail(plain_ann(fcx.ccx.tystore)));\n         }\n \n         case (ast.expr_break(_)) {\n             ret @fold.respan[ast.expr_](expr.span,\n-                                        ast.expr_break(plain_ann()));\n+                ast.expr_break(plain_ann(fcx.ccx.tystore)));\n         }\n \n         case (ast.expr_cont(_)) {\n             ret @fold.respan[ast.expr_](expr.span,\n-                                        ast.expr_cont(plain_ann()));\n+                ast.expr_cont(plain_ann(fcx.ccx.tystore)));\n         }\n \n         case (ast.expr_ret(?expr_opt, _)) {\n             alt (expr_opt) {\n                 case (none[@ast.expr]) {\n-                    auto nil = ty.mk_nil();\n+                    auto nil = ty.mk_nil(fcx.ccx.tystore);\n                     if (!are_compatible(fcx, fcx.ret_ty, nil)) {\n                         fcx.ccx.sess.err(\"ret; in function \"\n                                          + \"returning non-nil\");\n                     }\n \n                     ret @fold.respan[ast.expr_]\n                         (expr.span,\n-                         ast.expr_ret(none[@ast.expr], plain_ann()));\n+                         ast.expr_ret(none[@ast.expr],\n+                                      plain_ann(fcx.ccx.tystore)));\n                 }\n \n                 case (some[@ast.expr](?e)) {\n                     auto expr_0 = check_expr(fcx, e);\n                     auto expr_1 = Pushdown.pushdown_expr(fcx, fcx.ret_ty,\n                                                          expr_0);\n                     ret @fold.respan[ast.expr_]\n-                        (expr.span, ast.expr_ret(some(expr_1), plain_ann()));\n+                        (expr.span, ast.expr_ret(some(expr_1),\n+                                                 plain_ann(fcx.ccx.tystore)));\n                 }\n             }\n         }\n \n         case (ast.expr_put(?expr_opt, _)) {\n             alt (expr_opt) {\n                 case (none[@ast.expr]) {\n-                    auto nil = ty.mk_nil();\n+                    auto nil = ty.mk_nil(fcx.ccx.tystore);\n                     if (!are_compatible(fcx, fcx.ret_ty, nil)) {\n                         fcx.ccx.sess.err(\"put; in function \"\n                                          + \"putting non-nil\");\n                     }\n \n                     ret @fold.respan[ast.expr_]\n                         (expr.span, ast.expr_put(none[@ast.expr],\n-                                                 plain_ann()));\n+                         plain_ann(fcx.ccx.tystore)));\n                 }\n \n                 case (some[@ast.expr](?e)) {\n                     auto expr_0 = check_expr(fcx, e);\n                     auto expr_1 = Pushdown.pushdown_expr(fcx, fcx.ret_ty,\n                                                          expr_0);\n                     ret @fold.respan[ast.expr_]\n-                        (expr.span, ast.expr_put(some(expr_1), plain_ann()));\n+                        (expr.span, ast.expr_put(some(expr_1),\n+                                                 plain_ann(fcx.ccx.tystore)));\n                 }\n             }\n         }\n@@ -1877,21 +1924,23 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto expr_0 = check_expr(fcx, e);\n             auto expr_1 = Pushdown.pushdown_expr(fcx, fcx.ret_ty, expr_0);\n             ret @fold.respan[ast.expr_](expr.span,\n-                                        ast.expr_be(expr_1,\n-                                                    plain_ann()));\n+                ast.expr_be(expr_1, plain_ann(fcx.ccx.tystore)));\n         }\n \n         case (ast.expr_log(?l,?e,_)) {\n             auto expr_t = check_expr(fcx, e);\n             ret @fold.respan[ast.expr_]\n-                (expr.span, ast.expr_log(l, expr_t, plain_ann()));\n+                (expr.span, ast.expr_log(l, expr_t,\n+                                         plain_ann(fcx.ccx.tystore)));\n         }\n \n         case (ast.expr_check_expr(?e, _)) {\n             auto expr_t = check_expr(fcx, e);\n-            Demand.simple(fcx, expr.span, ty.mk_bool(), expr_ty(expr_t));\n+            Demand.simple(fcx, expr.span, ty.mk_bool(fcx.ccx.tystore),\n+                          expr_ty(fcx.ccx.tystore, expr_t));\n             ret @fold.respan[ast.expr_]\n-                (expr.span, ast.expr_check_expr(expr_t, plain_ann()));\n+                (expr.span, ast.expr_check_expr(expr_t,\n+                                                plain_ann(fcx.ccx.tystore)));\n         }\n \n         case (ast.expr_assign(?lhs, ?rhs, _)) {\n@@ -1914,12 +1963,12 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         case (ast.expr_send(?lhs, ?rhs, _)) {\n             auto lhs_0 = check_expr(fcx, lhs);\n             auto rhs_0 = check_expr(fcx, rhs);\n-            auto rhs_t = expr_ty(rhs_0);\n+            auto rhs_t = expr_ty(fcx.ccx.tystore, rhs_0);\n \n-            auto chan_t = ty.mk_chan(rhs_t);\n+            auto chan_t = ty.mk_chan(fcx.ccx.tystore, rhs_t);\n             auto lhs_1 = Pushdown.pushdown_expr(fcx, chan_t, lhs_0);\n             auto item_t;\n-            alt (expr_ty(lhs_1).struct) {\n+            alt (expr_ty(fcx.ccx.tystore, lhs_1).struct) {\n                 case (ty.ty_chan(?it)) {\n                     item_t = it;\n                 }\n@@ -1937,12 +1986,12 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         case (ast.expr_recv(?lhs, ?rhs, _)) {\n             auto lhs_0 = check_expr(fcx, lhs);\n             auto rhs_0 = check_expr(fcx, rhs);\n-            auto lhs_t1 = expr_ty(lhs_0);\n+            auto lhs_t1 = expr_ty(fcx.ccx.tystore, lhs_0);\n \n-            auto port_t = ty.mk_port(lhs_t1);\n+            auto port_t = ty.mk_port(fcx.ccx.tystore, lhs_t1);\n             auto rhs_1 = Pushdown.pushdown_expr(fcx, port_t, rhs_0);\n             auto item_t;\n-            alt (expr_ty(rhs_0).struct) {\n+            alt (expr_ty(fcx.ccx.tystore, rhs_0).struct) {\n                 case (ty.ty_port(?it)) {\n                     item_t = it;\n                 }\n@@ -1959,10 +2008,12 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n         case (ast.expr_if(?cond, ?thn, ?elsopt, _)) {\n             auto cond_0 = check_expr(fcx, cond);\n-            auto cond_1 = Pushdown.pushdown_expr(fcx, ty.mk_bool(), cond_0);\n+            auto cond_1 = Pushdown.pushdown_expr(fcx,\n+                                                 ty.mk_bool(fcx.ccx.tystore),\n+                                                 cond_0);\n \n             auto thn_0 = check_block(fcx, thn);\n-            auto thn_t = block_ty(thn_0);\n+            auto thn_t = block_ty(fcx.ccx.tystore, thn_0);\n \n             auto elsopt_1;\n             auto elsopt_t;\n@@ -1971,11 +2022,11 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                     auto els_0 = check_expr(fcx, els);\n                     auto els_1 = Pushdown.pushdown_expr(fcx, thn_t, els_0);\n                     elsopt_1 = some[@ast.expr](els_1);\n-                    elsopt_t = expr_ty(els_1);\n+                    elsopt_t = expr_ty(fcx.ccx.tystore, els_1);\n                 }\n                 case (none[@ast.expr]) {\n                     elsopt_1 = none[@ast.expr];\n-                    elsopt_t = ty.mk_nil();\n+                    elsopt_t = ty.mk_nil(fcx.ccx.tystore);\n                 }\n             }\n \n@@ -1995,7 +2046,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             // FIXME: enforce that the type of the decl is the element type\n             // of the seq.\n \n-            auto ann = triv_ann(ty.mk_nil());\n+            auto ann = triv_ann(ty.mk_nil(fcx.ccx.tystore));\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_for(decl_1, seq_1,\n                                                      body_1, ann));\n@@ -2006,28 +2057,32 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto seq_1 = check_expr(fcx, seq);\n             auto body_1 = check_block(fcx, body);\n \n-            auto ann = triv_ann(ty.mk_nil());\n+            auto ann = triv_ann(ty.mk_nil(fcx.ccx.tystore));\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_for_each(decl_1, seq_1,\n                                                           body_1, ann));\n         }\n \n         case (ast.expr_while(?cond, ?body, _)) {\n             auto cond_0 = check_expr(fcx, cond);\n-            auto cond_1 = Pushdown.pushdown_expr(fcx, ty.mk_bool(), cond_0);\n+            auto cond_1 = Pushdown.pushdown_expr(fcx,\n+                                                 ty.mk_bool(fcx.ccx.tystore),\n+                                                 cond_0);\n             auto body_1 = check_block(fcx, body);\n \n-            auto ann = triv_ann(ty.mk_nil());\n+            auto ann = triv_ann(ty.mk_nil(fcx.ccx.tystore));\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_while(cond_1, body_1, ann));\n         }\n \n         case (ast.expr_do_while(?body, ?cond, _)) {\n             auto cond_0 = check_expr(fcx, cond);\n-            auto cond_1 = Pushdown.pushdown_expr(fcx, ty.mk_bool(), cond_0);\n+            auto cond_1 = Pushdown.pushdown_expr(fcx,\n+                                                 ty.mk_bool(fcx.ccx.tystore),\n+                                                 cond_0);\n             auto body_1 = check_block(fcx, body);\n \n-            auto ann = triv_ann(block_ty(body_1));\n+            auto ann = triv_ann(block_ty(fcx.ccx.tystore, body_1));\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_do_while(body_1, cond_1,\n                                                           ann));\n@@ -2038,13 +2093,13 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n             // Typecheck the patterns first, so that we get types for all the\n             // bindings.\n-            auto pattern_ty = expr_ty(expr_0);\n+            auto pattern_ty = expr_ty(fcx.ccx.tystore, expr_0);\n \n             let vec[@ast.pat] pats_0 = vec();\n             for (ast.arm arm in arms) {\n                 auto pat_0 = check_pat(fcx, arm.pat);\n                 pattern_ty = Demand.simple(fcx, pat_0.span, pattern_ty,\n-                                           pat_ty(pat_0));\n+                                           pat_ty(fcx.ccx.tystore, pat_0));\n                 pats_0 += vec(pat_0);\n             }\n \n@@ -2060,7 +2115,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             for (ast.arm arm in arms) {\n                 auto block_0 = check_block(fcx, arm.block);\n                 result_ty = Demand.simple(fcx, block_0.span, result_ty,\n-                                          block_ty(block_0));\n+                                          block_ty(fcx.ccx.tystore, block_0));\n                 blocks_0 += vec(block_0);\n             }\n \n@@ -2088,10 +2143,10 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto ann;\n             alt (b_0.node.expr) {\n                 case (some[@ast.expr](?expr)) {\n-                    ann = triv_ann(expr_ty(expr));\n+                    ann = triv_ann(expr_ty(fcx.ccx.tystore, expr));\n                 }\n                 case (none[@ast.expr]) {\n-                    ann = triv_ann(ty.mk_nil());\n+                    ann = triv_ann(ty.mk_nil(fcx.ccx.tystore));\n                 }\n             }\n             ret @fold.respan[ast.expr_](expr.span,\n@@ -2106,7 +2161,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto proto_1;\n             let vec[ty.arg] arg_tys_1 = vec();\n             auto rt_1;\n-            alt (expr_ty(result._0).struct) {\n+            alt (expr_ty(fcx.ccx.tystore, result._0).struct) {\n                 case (ty.ty_fn(?proto, ?arg_tys, ?rt)) {\n                     proto_1 = proto;\n                     rt_1 = rt;\n@@ -2130,7 +2185,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 }\n             }\n \n-            auto t_1 = ty.mk_fn(proto_1, arg_tys_1, rt_1);\n+            auto t_1 = ty.mk_fn(fcx.ccx.tystore, proto_1, arg_tys_1, rt_1);\n             auto ann = triv_ann(t_1);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_bind(result._0, result._1,\n@@ -2143,8 +2198,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto args_1 = result._1;\n \n             // Pull the return type out of the type of the function.\n-            auto rt_1 = ty.mk_nil();    // FIXME: typestate botch\n-            alt (expr_ty(f_1).struct) {\n+            auto rt_1 = ty.mk_nil(fcx.ccx.tystore);  // FIXME: typestate botch\n+            alt (expr_ty(fcx.ccx.tystore, f_1).struct) {\n                 case (ty.ty_fn(_,_,?rt))    { rt_1 = rt; }\n                 case (ty.ty_native_fn(_, _, ?rt))    { rt_1 = rt; }\n                 case (_) {\n@@ -2159,15 +2214,15 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         }\n \n         case (ast.expr_self_method(?id, _)) {\n-            auto t = ty.mk_nil();\n+            auto t = ty.mk_nil(fcx.ccx.tystore);\n             let @ty.t this_obj_ty;\n \n             // Grab the type of the current object\n             auto this_obj_id = fcx.ccx.this_obj;\n             alt (this_obj_id) {\n                 case (some[ast.def_id](?def_id)) {\n                     this_obj_ty = ty.lookup_item_type(fcx.ccx.sess,\n-                        fcx.ccx.type_cache, def_id)._1;\n+                        fcx.ccx.tystore, fcx.ccx.type_cache, def_id)._1;\n                 }\n                 case (_) { fail; }\n             }\n@@ -2180,7 +2235,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 case (ty.ty_obj(?methods)) {\n                     for (ty.method method in methods) {\n                         if (method.ident == id) {\n-                            t = ty.method_ty_to_fn_ty(method);\n+                            t = ty.method_ty_to_fn_ty(fcx.ccx.tystore,\n+                                                      method);\n                         }\n                     }\n                 }\n@@ -2199,7 +2255,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto args_1 = result._1;\n \n             // Check the return type\n-            alt (expr_ty(f_1).struct) {\n+            alt (expr_ty(fcx.ccx.tystore, f_1).struct) {\n                 case (ty.ty_fn(_,_,?rt)) {\n                     alt (rt.struct) {\n                         case (ty.ty_nil) {\n@@ -2217,7 +2273,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n             // FIXME: Other typechecks needed\n \n-            auto ann = triv_ann(ty.mk_task());\n+            auto ann = triv_ann(ty.mk_task(fcx.ccx.tystore));\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_spawn(dom, name,\n                                                        f_1, args_1, ann));\n@@ -2227,13 +2283,12 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto e_1 = check_expr(fcx, e);\n             auto t_1 = ast_ty_to_ty_crate(fcx.ccx, t);\n             // FIXME: there are more forms of cast to support, eventually.\n-            if (! (type_is_scalar(expr_ty(e_1)) &&\n+            if (! (type_is_scalar(expr_ty(fcx.ccx.tystore, e_1)) &&\n                    type_is_scalar(t_1))) {\n                 fcx.ccx.sess.span_err(expr.span,\n-                                      \"non-scalar cast: \"\n-                                      + ty_to_str(expr_ty(e_1))\n-                                      + \" as \"\n-                                      +  ty_to_str(t_1));\n+                    \"non-scalar cast: \" +\n+                    ty_to_str(expr_ty(fcx.ccx.tystore, e_1)) + \" as \" +\n+                    ty_to_str(t_1));\n             }\n \n             auto ann = triv_ann(t_1);\n@@ -2249,17 +2304,18 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 t = next_ty_var(fcx.ccx);\n             } else {\n                 auto expr_1 = check_expr(fcx, args.(0));\n-                t = expr_ty(expr_1);\n+                t = expr_ty(fcx.ccx.tystore, expr_1);\n             }\n \n             for (@ast.expr e in args) {\n                 auto expr_1 = check_expr(fcx, e);\n-                auto expr_t = expr_ty(expr_1);\n+                auto expr_t = expr_ty(fcx.ccx.tystore, expr_1);\n                 Demand.simple(fcx, expr.span, t, expr_t);\n                 _vec.push[@ast.expr](args_1,expr_1);\n             }\n \n-            auto ann = triv_ann(ty.mk_vec(rec(ty=t, mut=mut)));\n+            auto ann = triv_ann(ty.mk_vec(fcx.ccx.tystore,\n+                                          rec(ty=t, mut=mut)));\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_vec(args_1, mut, ann));\n         }\n@@ -2270,12 +2326,12 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n             for (ast.elt e in elts) {\n                 auto expr_1 = check_expr(fcx, e.expr);\n-                auto expr_t = expr_ty(expr_1);\n+                auto expr_t = expr_ty(fcx.ccx.tystore, expr_1);\n                 _vec.push[ast.elt](elts_1, rec(expr=expr_1 with e));\n                 elts_mt += vec(rec(ty=expr_t, mut=e.mut));\n             }\n \n-            auto ann = triv_ann(ty.mk_tup(elts_mt));\n+            auto ann = triv_ann(ty.mk_tup(fcx.ccx.tystore, elts_mt));\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_tup(elts_1, ann));\n         }\n@@ -2295,7 +2351,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n             for (ast.field f in fields) {\n                 auto expr_1 = check_expr(fcx, f.expr);\n-                auto expr_t = expr_ty(expr_1);\n+                auto expr_t = expr_ty(fcx.ccx.tystore, expr_1);\n                 _vec.push[ast.field](fields_1, rec(expr=expr_1 with f));\n \n                 auto expr_mt = rec(ty=expr_t, mut=f.mut);\n@@ -2306,12 +2362,12 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n             alt (base) {\n                 case (none[@ast.expr]) {\n-                    ann = triv_ann(ty.mk_rec(fields_t));\n+                    ann = triv_ann(ty.mk_rec(fcx.ccx.tystore, fields_t));\n                 }\n \n                 case (some[@ast.expr](?bexpr)) {\n                     auto bexpr_1 = check_expr(fcx, bexpr);\n-                    auto bexpr_t = expr_ty(bexpr_1);\n+                    auto bexpr_t = expr_ty(fcx.ccx.tystore, bexpr_1);\n \n                     let vec[field] base_fields = vec();\n \n@@ -2353,7 +2409,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n         case (ast.expr_field(?base, ?field, _)) {\n             auto base_1 = check_expr(fcx, base);\n-            auto base_t = strip_boxes(expr_ty(base_1));\n+            auto base_t = strip_boxes(expr_ty(fcx.ccx.tystore, base_1));\n             alt (base_t.struct) {\n                 case (ty.ty_tup(?args)) {\n                     let uint ix = ty.field_num(fcx.ccx.sess,\n@@ -2391,7 +2447,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                               \"bad index on obj\");\n                     }\n                     auto meth = methods.(ix);\n-                    auto t = ty.mk_fn(meth.proto, meth.inputs, meth.output);\n+                    auto t = ty.mk_fn(fcx.ccx.tystore, meth.proto,\n+                                      meth.inputs, meth.output);\n                     auto ann = triv_ann(t);\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_field(base_1,\n@@ -2409,10 +2466,10 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n         case (ast.expr_index(?base, ?idx, _)) {\n             auto base_1 = check_expr(fcx, base);\n-            auto base_t = strip_boxes(expr_ty(base_1));\n+            auto base_t = strip_boxes(expr_ty(fcx.ccx.tystore, base_1));\n \n             auto idx_1 = check_expr(fcx, idx);\n-            auto idx_t = expr_ty(idx_1);\n+            auto idx_t = expr_ty(fcx.ccx.tystore, idx_1);\n \n             alt (base_t.struct) {\n                 case (ty.ty_vec(?mt)) {\n@@ -2435,7 +2492,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                              \"non-integral type of str index: \"\n                              + ty_to_str(idx_t));\n                     }\n-                    auto ann = triv_ann(ty.mk_mach(common.ty_u8));\n+                    auto ann = triv_ann(ty.mk_mach(fcx.ccx.tystore,\n+                                                   common.ty_u8));\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_index(base_1,\n                                                                idx_1,\n@@ -2452,17 +2510,17 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n         case (ast.expr_port(_)) {\n             auto t = next_ty_var(fcx.ccx);\n-            auto pt = ty.mk_port(t);\n+            auto pt = ty.mk_port(fcx.ccx.tystore, t);\n             auto ann = triv_ann(pt);\n             ret @fold.respan[ast.expr_](expr.span, ast.expr_port(ann));\n         }\n \n         case (ast.expr_chan(?x, _)) {\n             auto expr_1 = check_expr(fcx, x);\n-            auto port_t = expr_ty(expr_1);\n+            auto port_t = expr_ty(fcx.ccx.tystore, expr_1);\n             alt (port_t.struct) {\n                 case (ty.ty_port(?subtype)) {\n-                    auto ct = ty.mk_chan(subtype);\n+                    auto ct = ty.mk_chan(fcx.ccx.tystore, subtype);\n                     auto ann = triv_ann(ct);\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_chan(expr_1, ann));\n@@ -2484,7 +2542,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n }\n \n fn next_ty_var(@crate_ctxt ccx) -> @ty.t {\n-    auto t = ty.mk_var(ccx.next_var_id);\n+    auto t = ty.mk_var(ccx.tystore, ccx.next_var_id);\n     ccx.next_var_id += 1;\n     ret t;\n }\n@@ -2495,7 +2553,7 @@ fn check_decl_local(&@fn_ctxt fcx, &@ast.decl decl) -> @ast.decl {\n \n             auto t;\n \n-            t = middle.ty.mk_nil();\n+            t = ty.mk_nil(fcx.ccx.tystore);\n             \n             alt (local.ty) {\n                 case (none[@ast.ty]) {\n@@ -2521,14 +2579,14 @@ fn check_decl_local(&@fn_ctxt fcx, &@ast.decl decl) -> @ast.decl {\n             alt (local.init) {\n                 case (some[ast.initializer](?init)) {\n                     auto expr_0 = check_expr(fcx, init.expr);\n-                    auto lty = ty.mk_local(local.id);\n+                    auto lty = ty.mk_local(fcx.ccx.tystore, local.id);\n                     auto expr_1;\n                     alt (init.op) {\n                         case (ast.init_assign) {\n                             expr_1 = Pushdown.pushdown_expr(fcx, lty, expr_0);\n                         }\n                         case (ast.init_recv) {\n-                            auto port_ty = ty.mk_port(lty);\n+                            auto port_ty = ty.mk_port(fcx.ccx.tystore, lty);\n                             expr_1 = Pushdown.pushdown_expr(fcx, port_ty,\n                                                             expr_0);\n                         }\n@@ -2566,7 +2624,9 @@ fn check_stmt(&@fn_ctxt fcx, &@ast.stmt stmt) -> @ast.stmt {\n \n         case (ast.stmt_expr(?expr,?a)) {\n             auto expr_t = check_expr(fcx, expr);\n-            expr_t = Pushdown.pushdown_expr(fcx, expr_ty(expr_t), expr_t);\n+            expr_t = Pushdown.pushdown_expr(fcx,\n+                                            expr_ty(fcx.ccx.tystore, expr_t),\n+                                            expr_t);\n             ret @fold.respan[ast.stmt_](stmt.span, ast.stmt_expr(expr_t, a));\n         }\n     }\n@@ -2585,15 +2645,17 @@ fn check_block(&@fn_ctxt fcx, &ast.block block) -> ast.block {\n         case (none[@ast.expr]) { /* empty */ }\n         case (some[@ast.expr](?e)) {\n             auto expr_t = check_expr(fcx, e);\n-            expr_t = Pushdown.pushdown_expr(fcx, expr_ty(expr_t), expr_t);\n+            expr_t = Pushdown.pushdown_expr(fcx,\n+                                            expr_ty(fcx.ccx.tystore, expr_t),\n+                                            expr_t);\n             expr = some[@ast.expr](expr_t);\n         }\n     }\n \n     ret fold.respan[ast.block_](block.span,\n                                 rec(stmts=stmts, expr=expr,\n                                     index=block.node.index,\n-                                    a=plain_ann()));\n+                                    a=plain_ann(fcx.ccx.tystore)));\n }\n \n fn check_const(&@crate_ctxt ccx, &span sp, ast.ident ident, @ast.ty t,\n@@ -2660,7 +2722,7 @@ fn check_item_fn(&@crate_ctxt ccx, &span sp, ast.ident ident, &ast._fn f,\n     }\n \n     auto output_ty = ast_ty_to_ty_crate(ccx, f.decl.output);\n-    auto fn_ann = triv_ann(ty.mk_fn(f.proto, inputs, output_ty));\n+    auto fn_ann = triv_ann(ty.mk_fn(ccx.tystore, f.proto, inputs, output_ty));\n \n     auto item = ast.item_fn(ident, f, ty_params, id, fn_ann);\n     ret @fold.respan[ast.item_](sp, item);\n@@ -2714,8 +2776,10 @@ fn eq_unify_cache_entry(&unify_cache_entry a, &unify_cache_entry b) -> bool {\n \n type typecheck_result = tup(@ast.crate, ty.type_cache);\n \n-fn check_crate(session.session sess, @ast.crate crate) -> typecheck_result {\n-    auto result = Collect.collect_item_types(sess, crate);\n+fn check_crate(session.session sess,\n+               @ty.type_store tystore,\n+               @ast.crate crate) -> typecheck_result {\n+    auto result = Collect.collect_item_types(sess, tystore, crate);\n \n     let vec[ast.obj_field] fields = vec();\n \n@@ -2732,7 +2796,8 @@ fn check_crate(session.session sess, @ast.crate crate) -> typecheck_result {\n                     mutable next_var_id=0,\n                     unify_cache=unify_cache,\n                     mutable cache_hits=0u,\n-                    mutable cache_misses=0u);\n+                    mutable cache_misses=0u,\n+                    tystore=tystore);\n \n     auto fld = fold.new_identity_fold[@crate_ctxt]();\n "}, {"sha": "afec418c4e53cc76747693f1236dead70fa419f0", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5dbf554bb3f5883a3375e21285f9591e0e118914/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dbf554bb3f5883a3375e21285f9591e0e118914/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=5dbf554bb3f5883a3375e21285f9591e0e118914", "patch": "@@ -110,8 +110,8 @@ fn field_exprs(vec[ast.field] fields) -> vec [@ast.expr] {\n     ret _vec.map[ast.field, @ast.expr](f, fields);\n }\n \n-fn plain_ann() -> ast.ann {\n-  ret ast.ann_type(middle.ty.mk_nil(),\n+fn plain_ann(@middle.ty.type_store tystore) -> ast.ann {\n+  ret ast.ann_type(middle.ty.mk_nil(tystore),\n                    none[vec[@middle.ty.t]], none[@ts_ann]);\n }\n "}]}