{"sha": "5fc2e5623bd9dc53daf144626c9da2feb9daf682", "node_id": "C_kwDOAAsO6NoAKDVmYzJlNTYyM2JkOWRjNTNkYWYxNDQ2MjZjOWRhMmZlYjlkYWY2ODI", "commit": {"author": {"name": "Jakub Ber\u00e1nek", "email": "berykubik@gmail.com", "date": "2022-02-04T15:26:36Z"}, "committer": {"name": "Jakub Ber\u00e1nek", "email": "berykubik@gmail.com", "date": "2022-02-05T18:55:44Z"}, "message": "Use const generics in SipHasher128's short_write", "tree": {"sha": "ee5e2114230d8277091e8c4e68c68a1a577dbf07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee5e2114230d8277091e8c4e68c68a1a577dbf07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5fc2e5623bd9dc53daf144626c9da2feb9daf682", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEg8FrwI85f934CWFa28VT5UDC9hkFAmH+yDAACgkQ28VT5UDC\n9hk5aAv+ORzZMy4i6J9q3nQeepyiBTlbxcoaSdtOBLkFaQo+hJVyZ9M/615PqB1V\nggLTzTllahAXHQcXK5RyhOKjU65DDAeTouU4DhHgHkqOM7IHV8ZMK+FYcBmJMGsA\nYsDHDHIJMhSSa8ZneNYxAtkkIDpfWSt6a1s2JzOucBxKhG+/i6UK+DCM+reJGYP0\nFSGWO1h0No8kdg1TsdFXMV/jwmqAYcQzGqHCjPJUY9jRT1EH6zvgAwbnX2Ygu4CH\nkClh3vFVo5/haPcwTgs5upFWwXe38R32ePaen10+WoKLby7nfqIMYOejlcXh1dpc\nJnT+cC31CrVvfOr2uSemvoBy1lqSY602VTTI7kB/kaeqr9xJZlRPSKHWF1fCUQIo\nFi7+fGaAGqyWXP/z6LxyYwqcFst5wHT34WGfk3aGSU4baHsu1LGfFTm0GgdKS20P\neksdSs83wl5GzbZOi3ZlJNPcFewYW92ZFg2+hJ981IZuifTKbBPLuVePYW6dNiUT\nzYfxQf41\n=PVP7\n-----END PGP SIGNATURE-----", "payload": "tree ee5e2114230d8277091e8c4e68c68a1a577dbf07\nparent 4c55c8362de32be1530b2441c3e3a51e73edeb21\nauthor Jakub Ber\u00e1nek <berykubik@gmail.com> 1643988396 +0100\ncommitter Jakub Ber\u00e1nek <berykubik@gmail.com> 1644087344 +0100\n\nUse const generics in SipHasher128's short_write\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5fc2e5623bd9dc53daf144626c9da2feb9daf682", "html_url": "https://github.com/rust-lang/rust/commit/5fc2e5623bd9dc53daf144626c9da2feb9daf682", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5fc2e5623bd9dc53daf144626c9da2feb9daf682/comments", "author": {"login": "Kobzol", "id": 4539057, "node_id": "MDQ6VXNlcjQ1MzkwNTc=", "avatar_url": "https://avatars.githubusercontent.com/u/4539057?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kobzol", "html_url": "https://github.com/Kobzol", "followers_url": "https://api.github.com/users/Kobzol/followers", "following_url": "https://api.github.com/users/Kobzol/following{/other_user}", "gists_url": "https://api.github.com/users/Kobzol/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kobzol/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kobzol/subscriptions", "organizations_url": "https://api.github.com/users/Kobzol/orgs", "repos_url": "https://api.github.com/users/Kobzol/repos", "events_url": "https://api.github.com/users/Kobzol/events{/privacy}", "received_events_url": "https://api.github.com/users/Kobzol/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kobzol", "id": 4539057, "node_id": "MDQ6VXNlcjQ1MzkwNTc=", "avatar_url": "https://avatars.githubusercontent.com/u/4539057?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kobzol", "html_url": "https://github.com/Kobzol", "followers_url": "https://api.github.com/users/Kobzol/followers", "following_url": "https://api.github.com/users/Kobzol/following{/other_user}", "gists_url": "https://api.github.com/users/Kobzol/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kobzol/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kobzol/subscriptions", "organizations_url": "https://api.github.com/users/Kobzol/orgs", "repos_url": "https://api.github.com/users/Kobzol/repos", "events_url": "https://api.github.com/users/Kobzol/events{/privacy}", "received_events_url": "https://api.github.com/users/Kobzol/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c55c8362de32be1530b2441c3e3a51e73edeb21", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c55c8362de32be1530b2441c3e3a51e73edeb21", "html_url": "https://github.com/rust-lang/rust/commit/4c55c8362de32be1530b2441c3e3a51e73edeb21"}], "stats": {"total": 85, "additions": 39, "deletions": 46}, "files": [{"sha": "6e5c0617bf34cb089c3942c5ca4831d874e7129b", "filename": "compiler/rustc_data_structures/src/sip128.rs", "status": "modified", "additions": 29, "deletions": 32, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/5fc2e5623bd9dc53daf144626c9da2feb9daf682/compiler%2Frustc_data_structures%2Fsrc%2Fsip128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fc2e5623bd9dc53daf144626c9da2feb9daf682/compiler%2Frustc_data_structures%2Fsrc%2Fsip128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsip128.rs?ref=5fc2e5623bd9dc53daf144626c9da2feb9daf682", "patch": "@@ -202,28 +202,26 @@ impl SipHasher128 {\n         hasher\n     }\n \n-    // A specialized write function for values with size <= 8.\n     #[inline]\n-    fn short_write<T>(&mut self, x: T) {\n-        let size = mem::size_of::<T>();\n+    pub fn short_write<const LEN: usize>(&mut self, bytes: [u8; LEN]) {\n         let nbuf = self.nbuf;\n-        debug_assert!(size <= 8);\n+        debug_assert!(LEN <= 8);\n         debug_assert!(nbuf < BUFFER_SIZE);\n-        debug_assert!(nbuf + size < BUFFER_WITH_SPILL_SIZE);\n+        debug_assert!(nbuf + LEN < BUFFER_WITH_SPILL_SIZE);\n \n-        if nbuf + size < BUFFER_SIZE {\n+        if nbuf + LEN < BUFFER_SIZE {\n             unsafe {\n                 // The memcpy call is optimized away because the size is known.\n                 let dst = (self.buf.as_mut_ptr() as *mut u8).add(nbuf);\n-                ptr::copy_nonoverlapping(&x as *const _ as *const u8, dst, size);\n+                ptr::copy_nonoverlapping(bytes.as_ptr(), dst, LEN);\n             }\n \n-            self.nbuf = nbuf + size;\n+            self.nbuf = nbuf + LEN;\n \n             return;\n         }\n \n-        unsafe { self.short_write_process_buffer(x) }\n+        unsafe { self.short_write_process_buffer(bytes) }\n     }\n \n     // A specialized write function for values with size <= 8 that should only\n@@ -233,18 +231,17 @@ impl SipHasher128 {\n     // `self.nbuf` must cause `self.buf` to become fully initialized (and not\n     // overflow) if it wasn't already.\n     #[inline(never)]\n-    unsafe fn short_write_process_buffer<T>(&mut self, x: T) {\n-        let size = mem::size_of::<T>();\n+    unsafe fn short_write_process_buffer<const LEN: usize>(&mut self, bytes: [u8; LEN]) {\n         let nbuf = self.nbuf;\n-        debug_assert!(size <= 8);\n+        debug_assert!(LEN <= 8);\n         debug_assert!(nbuf < BUFFER_SIZE);\n-        debug_assert!(nbuf + size >= BUFFER_SIZE);\n-        debug_assert!(nbuf + size < BUFFER_WITH_SPILL_SIZE);\n+        debug_assert!(nbuf + LEN >= BUFFER_SIZE);\n+        debug_assert!(nbuf + LEN < BUFFER_WITH_SPILL_SIZE);\n \n         // Copy first part of input into end of buffer, possibly into spill\n         // element. The memcpy call is optimized away because the size is known.\n         let dst = (self.buf.as_mut_ptr() as *mut u8).add(nbuf);\n-        ptr::copy_nonoverlapping(&x as *const _ as *const u8, dst, size);\n+        ptr::copy_nonoverlapping(bytes.as_ptr(), dst, LEN);\n \n         // Process buffer.\n         for i in 0..BUFFER_CAPACITY {\n@@ -254,17 +251,17 @@ impl SipHasher128 {\n             self.state.v0 ^= elem;\n         }\n \n-        // Copy remaining input into start of buffer by copying size - 1\n-        // elements from spill (at most size - 1 bytes could have overflowed\n+        // Copy remaining input into start of buffer by copying LEN - 1\n+        // elements from spill (at most LEN - 1 bytes could have overflowed\n         // into the spill). The memcpy call is optimized away because the size\n-        // is known. And the whole copy is optimized away for size == 1.\n+        // is known. And the whole copy is optimized away for LEN == 1.\n         let src = self.buf.get_unchecked(BUFFER_SPILL_INDEX) as *const _ as *const u8;\n-        ptr::copy_nonoverlapping(src, self.buf.as_mut_ptr() as *mut u8, size - 1);\n+        ptr::copy_nonoverlapping(src, self.buf.as_mut_ptr() as *mut u8, LEN - 1);\n \n         // This function should only be called when the write fills the buffer.\n-        // Therefore, when size == 1, the new `self.nbuf` must be zero. The size\n-        // is statically known, so the branch is optimized away.\n-        self.nbuf = if size == 1 { 0 } else { nbuf + size - BUFFER_SIZE };\n+        // Therefore, when LEN == 1, the new `self.nbuf` must be zero.\n+        // LEN is statically known, so the branch is optimized away.\n+        self.nbuf = if LEN == 1 { 0 } else { nbuf + LEN - BUFFER_SIZE };\n         self.processed += BUFFER_SIZE;\n     }\n \n@@ -412,52 +409,52 @@ impl SipHasher128 {\n impl Hasher for SipHasher128 {\n     #[inline]\n     fn write_u8(&mut self, i: u8) {\n-        self.short_write(i);\n+        self.short_write(i.to_ne_bytes());\n     }\n \n     #[inline]\n     fn write_u16(&mut self, i: u16) {\n-        self.short_write(i);\n+        self.short_write(i.to_ne_bytes());\n     }\n \n     #[inline]\n     fn write_u32(&mut self, i: u32) {\n-        self.short_write(i);\n+        self.short_write(i.to_ne_bytes());\n     }\n \n     #[inline]\n     fn write_u64(&mut self, i: u64) {\n-        self.short_write(i);\n+        self.short_write(i.to_ne_bytes());\n     }\n \n     #[inline]\n     fn write_usize(&mut self, i: usize) {\n-        self.short_write(i);\n+        self.short_write(i.to_ne_bytes());\n     }\n \n     #[inline]\n     fn write_i8(&mut self, i: i8) {\n-        self.short_write(i as u8);\n+        self.short_write((i as u8).to_ne_bytes());\n     }\n \n     #[inline]\n     fn write_i16(&mut self, i: i16) {\n-        self.short_write(i as u16);\n+        self.short_write((i as u16).to_ne_bytes());\n     }\n \n     #[inline]\n     fn write_i32(&mut self, i: i32) {\n-        self.short_write(i as u32);\n+        self.short_write((i as u32).to_ne_bytes());\n     }\n \n     #[inline]\n     fn write_i64(&mut self, i: i64) {\n-        self.short_write(i as u64);\n+        self.short_write((i as u64).to_ne_bytes());\n     }\n \n     #[inline]\n     fn write_isize(&mut self, i: isize) {\n-        self.short_write(i as usize);\n+        self.short_write((i as usize).to_ne_bytes());\n     }\n \n     #[inline]"}, {"sha": "31d6a42cf288405d8e624f2fc40247227135b6cc", "filename": "compiler/rustc_data_structures/src/stable_hasher.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5fc2e5623bd9dc53daf144626c9da2feb9daf682/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fc2e5623bd9dc53daf144626c9da2feb9daf682/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs?ref=5fc2e5623bd9dc53daf144626c9da2feb9daf682", "patch": "@@ -80,30 +80,30 @@ impl Hasher for StableHasher {\n \n     #[inline]\n     fn write_u16(&mut self, i: u16) {\n-        self.state.write_u16(i.to_le());\n+        self.state.short_write(i.to_le_bytes());\n     }\n \n     #[inline]\n     fn write_u32(&mut self, i: u32) {\n-        self.state.write_u32(i.to_le());\n+        self.state.short_write(i.to_le_bytes());\n     }\n \n     #[inline]\n     fn write_u64(&mut self, i: u64) {\n-        self.state.write_u64(i.to_le());\n+        self.state.short_write(i.to_le_bytes());\n     }\n \n     #[inline]\n     fn write_u128(&mut self, i: u128) {\n-        self.state.write_u128(i.to_le());\n+        self.state.write(&i.to_le_bytes());\n     }\n \n     #[inline]\n     fn write_usize(&mut self, i: usize) {\n         // Always treat usize as u64 so we get the same results on 32 and 64 bit\n         // platforms. This is important for symbol hashes when cross compiling,\n         // for example.\n-        self.state.write_u64((i as u64).to_le());\n+        self.state.short_write((i as u64).to_le_bytes());\n     }\n \n     #[inline]\n@@ -113,22 +113,22 @@ impl Hasher for StableHasher {\n \n     #[inline]\n     fn write_i16(&mut self, i: i16) {\n-        self.state.write_i16(i.to_le());\n+        self.state.short_write((i as u16).to_le_bytes());\n     }\n \n     #[inline]\n     fn write_i32(&mut self, i: i32) {\n-        self.state.write_i32(i.to_le());\n+        self.state.short_write((i as u32).to_le_bytes());\n     }\n \n     #[inline]\n     fn write_i64(&mut self, i: i64) {\n-        self.state.write_i64(i.to_le());\n+        self.state.short_write((i as u64).to_le_bytes());\n     }\n \n     #[inline]\n     fn write_i128(&mut self, i: i128) {\n-        self.state.write_i128(i.to_le());\n+        self.state.write(&(i as u128).to_le_bytes());\n     }\n \n     #[inline]\n@@ -144,7 +144,7 @@ impl Hasher for StableHasher {\n         #[inline(never)]\n         fn hash_value(state: &mut SipHasher128, value: u64) {\n             state.write_u8(0xFF);\n-            state.write_u64(value.to_le());\n+            state.short_write(value.to_le_bytes());\n         }\n \n         // `isize` values often seem to have a small (positive) numeric value in practice.\n@@ -161,10 +161,6 @@ impl Hasher for StableHasher {\n         // 8 bytes. Since this prefix cannot occur when we hash a single byte, when we hash two\n         // `isize`s that fit within a different amount of bytes, they should always produce a different\n         // byte stream for the hasher.\n-        //\n-        // To ensure that this optimization hashes the exact same bytes on both little-endian and\n-        // big-endian architectures, we compare the value with 0xFF before we convert the number\n-        // into a unified representation (little-endian).\n         if value < 0xFF {\n             self.state.write_u8(value as u8);\n         } else {"}]}