{"sha": "3ab1519cb27b927074ed7fbbb18a856e6e7fabb8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhYjE1MTljYjI3YjkyNzA3NGVkN2ZiYmIxOGE4NTZlNmU3ZmFiYjg=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-23T20:14:13Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-24T10:29:19Z"}, "message": "Change ids strategy\n\nthis is a part of larghish hir refactoring which aims to\n\n* replace per-source-root module trees with per crate trees\n* switch from a monotyped DedId to type-specific ids", "tree": {"sha": "692c7a256604e188d38890966290bd1637d7dd60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/692c7a256604e188d38890966290bd1637d7dd60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8", "html_url": "https://github.com/rust-lang/rust/commit/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfb085ded8d61d7b744d0a83ecbb3da254f6ab9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfb085ded8d61d7b744d0a83ecbb3da254f6ab9f", "html_url": "https://github.com/rust-lang/rust/commit/cfb085ded8d61d7b744d0a83ecbb3da254f6ab9f"}], "stats": {"total": 797, "additions": 366, "deletions": 431}, "files": [{"sha": "9825d52cfcc119fae8c27509cb93f12d806873ed", "filename": "crates/ra_db/src/input.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Finput.rs?ref=3ab1519cb27b927074ed7fbbb18a856e6e7fabb8", "patch": "@@ -160,6 +160,7 @@ pub trait FilesDatabase: salsa::Database {\n     /// Contents of the source root.\n     #[salsa::input]\n     fn source_root(&self, id: SourceRootId) -> Arc<SourceRoot>;\n+    fn source_root_crates(&self, id: SourceRootId) -> Arc<Vec<CrateId>>;\n     /// The set of \"local\" (that is, from the current workspace) roots.\n     /// Files in local roots are assumed to change frequently.\n     #[salsa::input]\n@@ -173,6 +174,17 @@ pub trait FilesDatabase: salsa::Database {\n     fn crate_graph(&self) -> Arc<CrateGraph>;\n }\n \n+fn source_root_crates(db: &impl FilesDatabase, id: SourceRootId) -> Arc<Vec<CrateId>> {\n+    let root = db.source_root(id);\n+    let graph = db.crate_graph();\n+    let res = root\n+        .files\n+        .values()\n+        .filter_map(|&it| graph.crate_id_for_crate_root(it))\n+        .collect::<Vec<_>>();\n+    Arc::new(res)\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::{CrateGraph, FileId, SmolStr};"}, {"sha": "84759c75afe14c381d2fccdc8950d397afff41ce", "filename": "crates/ra_db/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Flib.rs?ref=3ab1519cb27b927074ed7fbbb18a856e6e7fabb8", "patch": "@@ -13,7 +13,7 @@ pub use crate::{\n     cancellation::Canceled,\n     input::{\n         FilesDatabase, FileId, CrateId, SourceRoot, SourceRootId, CrateGraph, Dependency,\n-        FileTextQuery, FileSourceRootQuery, SourceRootQuery, LocalRootsQuery, LibraryRootsQuery, CrateGraphQuery,\n+        FileTextQuery, FileSourceRootQuery, SourceRootQuery, SourceRootCratesQuery, LocalRootsQuery, LibraryRootsQuery, CrateGraphQuery,\n         FileRelativePathQuery\n     },\n     loc2id::LocationIntener,"}, {"sha": "4cca0935171a5a857216881bd50b97099bb16445", "filename": "crates/ra_hir/src/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_hir%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_hir%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fadt.rs?ref=3ab1519cb27b927074ed7fbbb18a856e6e7fabb8", "patch": "@@ -64,9 +64,9 @@ fn get_def_id(\n         ..same_file_loc.source_item_id\n     };\n     let loc = DefLoc {\n+        module: same_file_loc.module,\n         kind: expected_kind,\n         source_item_id,\n-        ..*same_file_loc\n     };\n     loc.id(db)\n }"}, {"sha": "f59a60c07e1b45440e5af90d80504bce48ebb720", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=3ab1519cb27b927074ed7fbbb18a856e6e7fabb8", "patch": "@@ -14,13 +14,14 @@ use crate::{\n     adt::VariantData,\n     generics::GenericParams,\n     code_model_impl::def_id_to_ast,\n-    docs::{Documentation, Docs, docs_from_ast}\n+    docs::{Documentation, Docs, docs_from_ast},\n+    module_tree::ModuleId,\n };\n \n /// hir::Crate describes a single crate. It's the main interface with which\n /// a crate's dependencies interact. Mostly, it should be just a proxy for the\n /// root module.\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Crate {\n     pub(crate) crate_id: CrateId,\n }\n@@ -45,7 +46,6 @@ impl Crate {\n \n #[derive(Debug)]\n pub enum Def {\n-    Module(Module),\n     Struct(Struct),\n     Enum(Enum),\n     EnumVariant(EnumVariant),\n@@ -57,9 +57,29 @@ pub enum Def {\n     Item,\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Module {\n-    pub(crate) def_id: DefId,\n+    pub(crate) krate: CrateId,\n+    pub(crate) module_id: ModuleId,\n+}\n+\n+/// The defs which can be visible in the module.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub enum ModuleDef {\n+    Module(Module),\n+    Def(DefId),\n+}\n+\n+impl Into<ModuleDef> for Module {\n+    fn into(self) -> ModuleDef {\n+        ModuleDef::Module(self)\n+    }\n+}\n+\n+impl Into<ModuleDef> for DefId {\n+    fn into(self) -> ModuleDef {\n+        ModuleDef::Def(self)\n+    }\n }\n \n pub enum ModuleSource {\n@@ -149,7 +169,7 @@ impl Module {\n         self.scope_impl(db)\n     }\n \n-    pub fn resolve_path(&self, db: &impl HirDatabase, path: &Path) -> PerNs<DefId> {\n+    pub fn resolve_path(&self, db: &impl HirDatabase, path: &Path) -> PerNs<ModuleDef> {\n         self.resolve_path_impl(db, path)\n     }\n "}, {"sha": "cdd30b402cf336bf48f891d7cc6c032b09ad862a", "filename": "crates/ra_hir/src/code_model_impl/krate.rs", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fkrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fkrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fkrate.rs?ref=3ab1519cb27b927074ed7fbbb18a856e6e7fabb8", "patch": "@@ -1,7 +1,7 @@\n use ra_db::CrateId;\n \n use crate::{\n-    HirFileId, Crate, CrateDependency, AsName, DefLoc, DefKind, Module, SourceItemId,\n+    Crate, CrateDependency, AsName, Module,\n     db::HirDatabase,\n };\n \n@@ -21,27 +21,13 @@ impl Crate {\n             .collect()\n     }\n     pub(crate) fn root_module_impl(&self, db: &impl HirDatabase) -> Option<Module> {\n-        let crate_graph = db.crate_graph();\n-        let file_id = crate_graph.crate_root(self.crate_id);\n-        let source_root_id = db.file_source_root(file_id);\n-        let file_id = HirFileId::from(file_id);\n-        let module_tree = db.module_tree(source_root_id);\n-        // FIXME: teach module tree about crate roots instead of guessing\n-        let source = SourceItemId {\n-            file_id,\n-            item_id: None,\n-        };\n-        let module_id = module_tree.find_module_by_source(source)?;\n+        let module_tree = db.module_tree(self.crate_id);\n+        let module_id = module_tree.modules().next()?;\n \n-        let def_loc = DefLoc {\n-            kind: DefKind::Module,\n-            source_root_id,\n+        let module = Module {\n+            krate: self.crate_id,\n             module_id,\n-            source_item_id: module_id.source(&module_tree),\n         };\n-        let def_id = def_loc.id(db);\n-\n-        let module = Module::new(def_id);\n         Some(module)\n     }\n }"}, {"sha": "5d00e905b621186a9d2491ddbe49cbf8727a1f7b", "filename": "crates/ra_hir/src/code_model_impl/module.rs", "status": "modified", "additions": 74, "deletions": 106, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs?ref=3ab1519cb27b927074ed7fbbb18a856e6e7fabb8", "patch": "@@ -1,62 +1,42 @@\n-use ra_db::{SourceRootId, FileId};\n-use ra_syntax::{ast, SyntaxNode, AstNode, TreeArc};\n+use ra_db::FileId;\n+use ra_syntax::{ast, SyntaxNode, TreeArc};\n \n use crate::{\n-    Module, ModuleSource, Problem,\n-    Crate, DefId, DefLoc, DefKind, Name, Path, PathKind, PerNs, Def,\n+    Module, ModuleSource, Problem, ModuleDef,\n+    Crate, Name, Path, PathKind, PerNs, Def,\n     module_tree::ModuleId,\n     nameres::{ModuleScope, lower::ImportId},\n     db::HirDatabase,\n };\n \n impl Module {\n-    pub(crate) fn new(def_id: DefId) -> Self {\n-        crate::code_model_api::Module { def_id }\n-    }\n-\n-    pub(crate) fn from_module_id(\n-        db: &impl HirDatabase,\n-        source_root_id: SourceRootId,\n-        module_id: ModuleId,\n-    ) -> Self {\n-        let module_tree = db.module_tree(source_root_id);\n-        let def_loc = DefLoc {\n-            kind: DefKind::Module,\n-            source_root_id,\n+    fn with_module_id(&self, module_id: ModuleId) -> Module {\n+        Module {\n             module_id,\n-            source_item_id: module_id.source(&module_tree),\n-        };\n-        let def_id = def_loc.id(db);\n-        Module::new(def_id)\n+            krate: self.krate,\n+        }\n     }\n \n     pub(crate) fn name_impl(&self, db: &impl HirDatabase) -> Option<Name> {\n-        let loc = self.def_id.loc(db);\n-        let module_tree = db.module_tree(loc.source_root_id);\n-        let link = loc.module_id.parent_link(&module_tree)?;\n+        let module_tree = db.module_tree(self.krate);\n+        let link = self.module_id.parent_link(&module_tree)?;\n         Some(link.name(&module_tree).clone())\n     }\n \n     pub(crate) fn definition_source_impl(&self, db: &impl HirDatabase) -> (FileId, ModuleSource) {\n-        let loc = self.def_id.loc(db);\n-        let file_id = loc.source_item_id.file_id.as_original_file();\n-        let syntax_node = db.file_item(loc.source_item_id);\n-        let module_source = if let Some(source_file) = ast::SourceFile::cast(&syntax_node) {\n-            ModuleSource::SourceFile(source_file.to_owned())\n-        } else {\n-            let module = ast::Module::cast(&syntax_node).unwrap();\n-            ModuleSource::Module(module.to_owned())\n-        };\n+        let module_tree = db.module_tree(self.krate);\n+        let source = self.module_id.source(&module_tree);\n+        let module_source = ModuleSource::from_source_item_id(db, source);\n+        let file_id = source.file_id.as_original_file();\n         (file_id, module_source)\n     }\n \n     pub(crate) fn declaration_source_impl(\n         &self,\n         db: &impl HirDatabase,\n     ) -> Option<(FileId, TreeArc<ast::Module>)> {\n-        let loc = self.def_id.loc(db);\n-        let module_tree = db.module_tree(loc.source_root_id);\n-        let link = loc.module_id.parent_link(&module_tree)?;\n+        let module_tree = db.module_tree(self.krate);\n+        let link = self.module_id.parent_link(&module_tree)?;\n         let file_id = link\n             .owner(&module_tree)\n             .source(&module_tree)\n@@ -71,85 +51,67 @@ impl Module {\n         db: &impl HirDatabase,\n         import: ImportId,\n     ) -> TreeArc<ast::PathSegment> {\n-        let loc = self.def_id.loc(db);\n-        let source_map = db.lower_module_source_map(loc.source_root_id, loc.module_id);\n+        let source_map = db.lower_module_source_map(self.clone());\n         let (_, source) = self.definition_source(db);\n         source_map.get(&source, import)\n     }\n \n-    pub(crate) fn krate_impl(&self, db: &impl HirDatabase) -> Option<Crate> {\n-        let root = self.crate_root(db);\n-        let loc = root.def_id.loc(db);\n-        let file_id = loc.source_item_id.file_id.as_original_file();\n-\n-        let crate_graph = db.crate_graph();\n-        let crate_id = crate_graph.crate_id_for_crate_root(file_id)?;\n-        Some(Crate::new(crate_id))\n+    pub(crate) fn krate_impl(&self, _db: &impl HirDatabase) -> Option<Crate> {\n+        Some(Crate::new(self.krate))\n     }\n \n     pub(crate) fn crate_root_impl(&self, db: &impl HirDatabase) -> Module {\n-        let loc = self.def_id.loc(db);\n-        let module_tree = db.module_tree(loc.source_root_id);\n-        let module_id = loc.module_id.crate_root(&module_tree);\n-        Module::from_module_id(db, loc.source_root_id, module_id)\n+        let module_tree = db.module_tree(self.krate);\n+        let module_id = self.module_id.crate_root(&module_tree);\n+        self.with_module_id(module_id)\n     }\n \n     /// Finds a child module with the specified name.\n     pub(crate) fn child_impl(&self, db: &impl HirDatabase, name: &Name) -> Option<Module> {\n-        let loc = self.def_id.loc(db);\n-        let module_tree = db.module_tree(loc.source_root_id);\n-        let child_id = loc.module_id.child(&module_tree, name)?;\n-        Some(Module::from_module_id(db, loc.source_root_id, child_id))\n+        let module_tree = db.module_tree(self.krate);\n+        let child_id = self.module_id.child(&module_tree, name)?;\n+        Some(self.with_module_id(child_id))\n     }\n \n     /// Iterates over all child modules.\n     pub(crate) fn children_impl(&self, db: &impl HirDatabase) -> impl Iterator<Item = Module> {\n-        // FIXME this should be implementable without collecting into a vec, but\n-        // it's kind of hard since the iterator needs to keep a reference to the\n-        // module tree.\n-        let loc = self.def_id.loc(db);\n-        let module_tree = db.module_tree(loc.source_root_id);\n-        let children = loc\n+        let module_tree = db.module_tree(self.krate);\n+        let children = self\n             .module_id\n             .children(&module_tree)\n-            .map(|(_, module_id)| Module::from_module_id(db, loc.source_root_id, module_id))\n+            .map(|(_, module_id)| self.with_module_id(module_id))\n             .collect::<Vec<_>>();\n         children.into_iter()\n     }\n \n     pub(crate) fn parent_impl(&self, db: &impl HirDatabase) -> Option<Module> {\n-        let loc = self.def_id.loc(db);\n-        let module_tree = db.module_tree(loc.source_root_id);\n-        let parent_id = loc.module_id.parent(&module_tree)?;\n-        Some(Module::from_module_id(db, loc.source_root_id, parent_id))\n+        let module_tree = db.module_tree(self.krate);\n+        let parent_id = self.module_id.parent(&module_tree)?;\n+        Some(self.with_module_id(parent_id))\n     }\n \n     /// Returns a `ModuleScope`: a set of items, visible in this module.\n     pub(crate) fn scope_impl(&self, db: &impl HirDatabase) -> ModuleScope {\n-        let loc = self.def_id.loc(db);\n-        let item_map = db.item_map(loc.source_root_id);\n-        item_map.per_module[&loc.module_id].clone()\n+        let item_map = db.item_map(self.krate);\n+        item_map.per_module[&self.module_id].clone()\n     }\n \n-    pub(crate) fn resolve_path_impl(&self, db: &impl HirDatabase, path: &Path) -> PerNs<DefId> {\n-        let mut curr_per_ns = PerNs::types(\n-            match path.kind {\n-                PathKind::Crate => self.crate_root(db),\n-                PathKind::Self_ | PathKind::Plain => self.clone(),\n-                PathKind::Super => {\n-                    if let Some(p) = self.parent(db) {\n-                        p\n-                    } else {\n-                        return PerNs::none();\n-                    }\n-                }\n-                PathKind::Abs => {\n-                    // TODO: absolute use is not supported\n+    pub(crate) fn resolve_path_impl(&self, db: &impl HirDatabase, path: &Path) -> PerNs<ModuleDef> {\n+        let mut curr_per_ns: PerNs<ModuleDef> = PerNs::types(match path.kind {\n+            PathKind::Crate => self.crate_root(db).into(),\n+            PathKind::Self_ | PathKind::Plain => self.clone().into(),\n+            PathKind::Super => {\n+                if let Some(p) = self.parent(db) {\n+                    p.into()\n+                } else {\n                     return PerNs::none();\n                 }\n             }\n-            .def_id,\n-        );\n+            PathKind::Abs => {\n+                // TODO: absolute use is not supported\n+                return PerNs::none();\n+            }\n+        });\n \n         for segment in path.segments.iter() {\n             let curr = match curr_per_ns.as_ref().take_types() {\n@@ -164,32 +126,39 @@ impl Module {\n                 }\n             };\n             // resolve segment in curr\n-            curr_per_ns = match curr.resolve(db) {\n-                Def::Module(m) => {\n+\n+            curr_per_ns = match curr {\n+                ModuleDef::Module(m) => {\n                     let scope = m.scope(db);\n                     match scope.get(&segment.name) {\n-                        Some(r) => r.def_id,\n+                        Some(r) => r.def_id.clone(),\n                         None => PerNs::none(),\n                     }\n                 }\n-                Def::Enum(e) => {\n-                    // enum variant\n-                    let matching_variant = e\n-                        .variants(db)\n-                        .into_iter()\n-                        .find(|(n, _variant)| n == &segment.name);\n-\n-                    match matching_variant {\n-                        Some((_n, variant)) => PerNs::both(variant.def_id(), e.def_id()),\n-                        None => PerNs::none(),\n+                ModuleDef::Def(def) => {\n+                    match def.resolve(db) {\n+                        Def::Enum(e) => {\n+                            // enum variant\n+                            let matching_variant = e\n+                                .variants(db)\n+                                .into_iter()\n+                                .find(|(n, _variant)| n == &segment.name);\n+\n+                            match matching_variant {\n+                                Some((_n, variant)) => {\n+                                    PerNs::both(variant.def_id().into(), e.def_id().into())\n+                                }\n+                                None => PerNs::none(),\n+                            }\n+                        }\n+                        _ => {\n+                            // could be an inherent method call in UFCS form\n+                            // (`Struct::method`), or some other kind of associated\n+                            // item... Which we currently don't handle (TODO)\n+                            PerNs::none()\n+                        }\n                     }\n                 }\n-                _ => {\n-                    // could be an inherent method call in UFCS form\n-                    // (`Struct::method`), or some other kind of associated\n-                    // item... Which we currently don't handle (TODO)\n-                    PerNs::none()\n-                }\n             };\n         }\n         curr_per_ns\n@@ -199,8 +168,7 @@ impl Module {\n         &self,\n         db: &impl HirDatabase,\n     ) -> Vec<(TreeArc<SyntaxNode>, Problem)> {\n-        let loc = self.def_id.loc(db);\n-        let module_tree = db.module_tree(loc.source_root_id);\n-        loc.module_id.problems(&module_tree, db)\n+        let module_tree = db.module_tree(self.krate);\n+        self.module_id.problems(&module_tree, db)\n     }\n }"}, {"sha": "0898daa3c4f24f514ffbb06ec062b5aa520b1b54", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 10, "deletions": 26, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=3ab1519cb27b927074ed7fbbb18a856e6e7fabb8", "patch": "@@ -1,15 +1,15 @@\n use std::sync::Arc;\n \n use ra_syntax::{SyntaxNode, TreeArc, SourceFile};\n-use ra_db::{SourceRootId, SyntaxDatabase, salsa};\n+use ra_db::{SyntaxDatabase, CrateId, salsa};\n \n use crate::{\n-    HirInterner, DefId, MacroCallId, Name, HirFileId,\n-    SourceFileItems, SourceItemId, Crate,\n+    DefId, MacroCallId, Name, HirFileId,\n+    SourceFileItems, SourceItemId, Crate, Module, HirInterner,\n     query_definitions,\n     FnSignature, FnScopes,\n     macros::MacroExpansion,\n-    module_tree::{ModuleId, ModuleTree},\n+    module_tree::ModuleTree,\n     nameres::{ItemMap, lower::{LoweredModule, ImportSourceMap}},\n     ty::{InferenceResult, Ty, method_resolution::CrateImplBlocks},\n     adt::{StructData, EnumData, EnumVariantData},\n@@ -56,38 +56,22 @@ pub trait HirDatabase: SyntaxDatabase + AsRef<HirInterner> {\n     fn submodules(&self, source: SourceItemId) -> Arc<Vec<crate::module_tree::Submodule>>;\n \n     #[salsa::invoke(crate::nameres::lower::LoweredModule::lower_module_query)]\n-    fn lower_module(\n-        &self,\n-        source_root_id: SourceRootId,\n-        module_id: ModuleId,\n-    ) -> (Arc<LoweredModule>, Arc<ImportSourceMap>);\n+    fn lower_module(&self, module: Module) -> (Arc<LoweredModule>, Arc<ImportSourceMap>);\n \n     #[salsa::invoke(crate::nameres::lower::LoweredModule::lower_module_module_query)]\n-    fn lower_module_module(\n-        &self,\n-        source_root_id: SourceRootId,\n-        module_id: ModuleId,\n-    ) -> Arc<LoweredModule>;\n+    fn lower_module_module(&self, module: Module) -> Arc<LoweredModule>;\n \n     #[salsa::invoke(crate::nameres::lower::LoweredModule::lower_module_source_map_query)]\n-    fn lower_module_source_map(\n-        &self,\n-        source_root_id: SourceRootId,\n-        module_id: ModuleId,\n-    ) -> Arc<ImportSourceMap>;\n+    fn lower_module_source_map(&self, module: Module) -> Arc<ImportSourceMap>;\n \n     #[salsa::invoke(query_definitions::item_map)]\n-    fn item_map(&self, source_root_id: SourceRootId) -> Arc<ItemMap>;\n+    fn item_map(&self, crate_id: CrateId) -> Arc<ItemMap>;\n \n     #[salsa::invoke(crate::module_tree::ModuleTree::module_tree_query)]\n-    fn module_tree(&self, source_root_id: SourceRootId) -> Arc<ModuleTree>;\n+    fn module_tree(&self, crate_id: CrateId) -> Arc<ModuleTree>;\n \n     #[salsa::invoke(crate::impl_block::impls_in_module)]\n-    fn impls_in_module(\n-        &self,\n-        source_root_id: SourceRootId,\n-        module_id: ModuleId,\n-    ) -> Arc<ModuleImplBlocks>;\n+    fn impls_in_module(&self, module: Module) -> Arc<ModuleImplBlocks>;\n \n     #[salsa::invoke(crate::ty::method_resolution::CrateImplBlocks::impls_in_crate_query)]\n     fn impls_in_crate(&self, krate: Crate) -> Arc<CrateImplBlocks>;"}, {"sha": "99f04e4ef5bbdc13d49b44fad67a7584d9fda8e9", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=3ab1519cb27b927074ed7fbbb18a856e6e7fabb8", "patch": "@@ -1,11 +1,10 @@\n-use ra_db::{SourceRootId, LocationIntener, FileId};\n+use ra_db::{LocationIntener, FileId};\n use ra_syntax::{TreeArc, SyntaxNode, SourceFile, AstNode, ast};\n use ra_arena::{Arena, RawId, impl_arena_id};\n \n use crate::{\n     HirDatabase, Def, Function, Struct, Enum, EnumVariant, ImplBlock, Crate,\n     Module, Trait, Type, Static, Const,\n-    module_tree::ModuleId,\n };\n \n #[derive(Debug, Default)]\n@@ -110,10 +109,9 @@ impl From<MacroCallId> for HirFileId {\n pub struct MacroCallId(RawId);\n impl_arena_id!(MacroCallId);\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MacroCallLoc {\n-    pub(crate) source_root_id: SourceRootId,\n-    pub(crate) module_id: ModuleId,\n+    pub(crate) module: Module,\n     pub(crate) source_item_id: SourceItemId,\n }\n \n@@ -139,14 +137,12 @@ impl_arena_id!(DefId);\n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n pub struct DefLoc {\n     pub(crate) kind: DefKind,\n-    pub(crate) source_root_id: SourceRootId,\n-    pub(crate) module_id: ModuleId,\n+    pub(crate) module: Module,\n     pub(crate) source_item_id: SourceItemId,\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub(crate) enum DefKind {\n-    Module,\n     Function,\n     Struct,\n     Enum,\n@@ -177,10 +173,6 @@ impl DefId {\n     pub fn resolve(self, db: &impl HirDatabase) -> Def {\n         let loc = self.loc(db);\n         match loc.kind {\n-            DefKind::Module => {\n-                let module = Module::from_module_id(db, loc.source_root_id, loc.module_id);\n-                Def::Module(module)\n-            }\n             DefKind::Function => {\n                 let function = Function::new(self);\n                 Def::Function(function)\n@@ -221,8 +213,7 @@ impl DefId {\n \n     /// For a module, returns that module; for any other def, returns the containing module.\n     pub fn module(self, db: &impl HirDatabase) -> Module {\n-        let loc = self.loc(db);\n-        Module::from_module_id(db, loc.source_root_id, loc.module_id)\n+        self.loc(db).module\n     }\n \n     /// Returns the containing crate.\n@@ -232,8 +223,7 @@ impl DefId {\n \n     /// Returns the containing impl block, if this is an impl item.\n     pub fn impl_block(self, db: &impl HirDatabase) -> Option<ImplBlock> {\n-        let loc = self.loc(db);\n-        let module_impls = db.impls_in_module(loc.source_root_id, loc.module_id);\n+        let module_impls = db.impls_in_module(self.loc(db).module);\n         ImplBlock::containing(module_impls, self)\n     }\n }"}, {"sha": "ba8b84da2c9e6285963885dc39ae636c0ac4caea", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=3ab1519cb27b927074ed7fbbb18a856e6e7fabb8", "patch": "@@ -3,14 +3,12 @@ use rustc_hash::FxHashMap;\n \n use ra_arena::{Arena, RawId, impl_arena_id};\n use ra_syntax::ast::{self, AstNode};\n-use ra_db::{SourceRootId};\n \n use crate::{\n     DefId, DefLoc, DefKind, SourceItemId, SourceFileItems,\n-    Function, HirInterner,\n+    Function, HirFileId, HirInterner,\n     db::HirDatabase,\n     type_ref::TypeRef,\n-    module_tree::ModuleId,\n };\n \n use crate::code_model_api::{Module, ModuleSource};\n@@ -67,13 +65,13 @@ pub struct ImplData {\n impl ImplData {\n     pub(crate) fn from_ast(\n         db: &impl AsRef<HirInterner>,\n+        file_id: HirFileId,\n         file_items: &SourceFileItems,\n-        module: &Module,\n+        module: Module,\n         node: &ast::ImplBlock,\n     ) -> Self {\n         let target_trait = node.target_trait().map(TypeRef::from_ast);\n         let target_type = TypeRef::from_ast_opt(node.target_type());\n-        let module_loc = module.def_id.loc(db);\n         let items = if let Some(item_list) = node.item_list() {\n             item_list\n                 .impl_items()\n@@ -85,13 +83,13 @@ impl ImplData {\n                     };\n                     let item_id = file_items.id_of_unchecked(item_node.syntax());\n                     let source_item_id = SourceItemId {\n-                        file_id: module_loc.source_item_id.file_id,\n+                        file_id,\n                         item_id: Some(item_id),\n                     };\n                     let def_loc = DefLoc {\n+                        module,\n                         kind,\n                         source_item_id,\n-                        ..module_loc\n                     };\n                     let def_id = def_loc.id(db);\n                     match item_node.kind() {\n@@ -168,6 +166,7 @@ impl ModuleImplBlocks {\n \n     fn collect(&mut self, db: &impl HirDatabase, module: Module) {\n         let (file_id, module_source) = module.definition_source(db);\n+        let file_id: HirFileId = file_id.into();\n         let node = match &module_source {\n             ModuleSource::SourceFile(node) => node.syntax(),\n             ModuleSource::Module(node) => node\n@@ -176,10 +175,11 @@ impl ModuleImplBlocks {\n                 .syntax(),\n         };\n \n-        let source_file_items = db.file_items(file_id.into());\n+        let source_file_items = db.file_items(file_id);\n \n         for impl_block_ast in node.children().filter_map(ast::ImplBlock::cast) {\n-            let impl_block = ImplData::from_ast(db, &source_file_items, &module, impl_block_ast);\n+            let impl_block =\n+                ImplData::from_ast(db, file_id, &source_file_items, module, impl_block_ast);\n             let id = self.impls.alloc(impl_block);\n             for impl_item in &self.impls[id].items {\n                 self.impls_by_def.insert(impl_item.def_id(), id);\n@@ -188,13 +188,8 @@ impl ModuleImplBlocks {\n     }\n }\n \n-pub(crate) fn impls_in_module(\n-    db: &impl HirDatabase,\n-    source_root_id: SourceRootId,\n-    module_id: ModuleId,\n-) -> Arc<ModuleImplBlocks> {\n+pub(crate) fn impls_in_module(db: &impl HirDatabase, module: Module) -> Arc<ModuleImplBlocks> {\n     let mut result = ModuleImplBlocks::new();\n-    let module = Module::from_module_id(db, source_root_id, module_id);\n     result.collect(db, module);\n     Arc::new(result)\n }"}, {"sha": "a6246a5e940e3229da66f7a499b3ad43e9d373d4", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=3ab1519cb27b927074ed7fbbb18a856e6e7fabb8", "patch": "@@ -52,7 +52,7 @@ pub use self::{\n pub use self::code_model_api::{\n     Crate, CrateDependency,\n     Def,\n-    Module, ModuleSource, Problem,\n+    Module, ModuleDef, ModuleSource, Problem,\n     Struct, Enum, EnumVariant,\n     Function, FnSignature, ScopeEntryWithSyntax,\n     StructField,"}, {"sha": "361366f6a1d462961192f0b21e49e64fc4915162", "filename": "crates/ra_hir/src/mock.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_hir%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_hir%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmock.rs?ref=3ab1519cb27b927074ed7fbbb18a856e6e7fabb8", "patch": "@@ -35,10 +35,6 @@ impl MockDatabase {\n         let file_id = db.add_file(WORKSPACE, &mut source_root, \"/main.rs\", text);\n         db.query_mut(ra_db::SourceRootQuery)\n             .set(WORKSPACE, Arc::new(source_root.clone()));\n-\n-        let mut crate_graph = CrateGraph::default();\n-        crate_graph.add_crate_root(file_id);\n-        db.set_crate_graph(crate_graph);\n         (db, source_root, file_id)\n     }\n \n@@ -97,6 +93,8 @@ impl MockDatabase {\n         text: &str,\n     ) -> FileId {\n         assert!(path.starts_with('/'));\n+        let is_crate_root = path == \"/lib.rs\" || path == \"/main.rs\";\n+\n         let path = RelativePathBuf::from_path(&path[1..]).unwrap();\n         let file_id = FileId(self.file_counter);\n         self.file_counter += 1;\n@@ -107,6 +105,12 @@ impl MockDatabase {\n         self.query_mut(ra_db::FileSourceRootQuery)\n             .set(file_id, source_root_id);\n         source_root.files.insert(path, file_id);\n+\n+        if is_crate_root {\n+            let mut crate_graph = CrateGraph::default();\n+            crate_graph.add_crate_root(file_id);\n+            self.set_crate_graph(crate_graph);\n+        }\n         file_id\n     }\n \n@@ -202,6 +206,7 @@ salsa::database_storage! {\n             fn file_relative_path() for ra_db::FileRelativePathQuery;\n             fn file_source_root() for ra_db::FileSourceRootQuery;\n             fn source_root() for ra_db::SourceRootQuery;\n+            fn source_root_crates() for ra_db::SourceRootCratesQuery;\n             fn local_roots() for ra_db::LocalRootsQuery;\n             fn library_roots() for ra_db::LibraryRootsQuery;\n             fn crate_graph() for ra_db::CrateGraphQuery;"}, {"sha": "c00834c4c1206887eaf11204348a867883df9a90", "filename": "crates/ra_hir/src/module_tree.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs?ref=3ab1519cb27b927074ed7fbbb18a856e6e7fabb8", "patch": "@@ -3,7 +3,7 @@ use std::sync::Arc;\n use rustc_hash::{FxHashMap, FxHashSet};\n use arrayvec::ArrayVec;\n use relative_path::RelativePathBuf;\n-use ra_db::{FileId, SourceRootId, SourceRoot};\n+use ra_db::{FileId, SourceRoot, CrateId};\n use ra_syntax::{\n     SyntaxNode, TreeArc,\n     algo::generate,\n@@ -126,13 +126,10 @@ struct LinkData {\n }\n \n impl ModuleTree {\n-    pub(crate) fn module_tree_query(\n-        db: &impl HirDatabase,\n-        source_root: SourceRootId,\n-    ) -> Arc<ModuleTree> {\n+    pub(crate) fn module_tree_query(db: &impl HirDatabase, crate_id: CrateId) -> Arc<ModuleTree> {\n         db.check_canceled();\n         let mut res = ModuleTree::default();\n-        res.init(db, source_root);\n+        res.init_crate(db, crate_id);\n         Arc::new(res)\n     }\n \n@@ -145,24 +142,21 @@ impl ModuleTree {\n         Some(res)\n     }\n \n-    fn init(&mut self, db: &impl HirDatabase, source_root: SourceRootId) {\n+    fn init_crate(&mut self, db: &impl HirDatabase, crate_id: CrateId) {\n+        let crate_graph = db.crate_graph();\n+        let file_id = crate_graph.crate_root(crate_id);\n+        let source_root_id = db.file_source_root(file_id);\n+\n         let mut roots = FxHashMap::default();\n         let mut visited = FxHashSet::default();\n \n-        let source_root = db.source_root(source_root);\n-        for &file_id in source_root.files.values() {\n-            let source = SourceItemId {\n-                file_id: file_id.into(),\n-                item_id: None,\n-            };\n-            if visited.contains(&source) {\n-                continue; // TODO: use explicit crate_roots here\n-            }\n-            assert!(!roots.contains_key(&file_id));\n-            let module_id =\n-                self.init_subtree(db, &source_root, &mut visited, &mut roots, None, source);\n-            roots.insert(file_id, module_id);\n-        }\n+        let source_root = db.source_root(source_root_id);\n+        let source = SourceItemId {\n+            file_id: file_id.into(),\n+            item_id: None,\n+        };\n+        let module_id = self.init_subtree(db, &source_root, &mut visited, &mut roots, None, source);\n+        roots.insert(file_id, module_id);\n     }\n \n     fn init_subtree("}, {"sha": "a3bc989580ad1cedbef59a74fdfb5b302a57ccaf", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 26, "deletions": 30, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=3ab1519cb27b927074ed7fbbb18a856e6e7fabb8", "patch": "@@ -16,19 +16,19 @@\n //! structure itself is modified.\n pub(crate) mod lower;\n \n-use crate::nameres::lower::*;\n-\n use std::sync::Arc;\n \n+use ra_db::CrateId;\n use rustc_hash::{FxHashMap, FxHashSet};\n-use ra_db::SourceRootId;\n \n use crate::{\n-    DefId, DefLoc, DefKind,\n+    Module, ModuleDef,\n     Path, PathKind,\n     HirDatabase, Crate,\n     Name,\n     module_tree::{ModuleId, ModuleTree},\n+//FIXME: deglobify\n+    nameres::lower::*,\n };\n \n /// `ItemMap` is the result of name resolution. It contains, for each\n@@ -58,7 +58,7 @@ impl ModuleScope {\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct Resolution {\n     /// None for unresolved\n-    pub def_id: PerNs<DefId>,\n+    pub def_id: PerNs<ModuleDef>,\n     /// ident by which this is imported into local scope.\n     pub import: Option<ImportId>,\n }\n@@ -152,7 +152,7 @@ impl<T> PerNs<T> {\n pub(crate) struct Resolver<'a, DB> {\n     db: &'a DB,\n     input: &'a FxHashMap<ModuleId, Arc<LoweredModule>>,\n-    source_root: SourceRootId,\n+    krate: CrateId,\n     module_tree: Arc<ModuleTree>,\n     processed_imports: FxHashSet<(ModuleId, ImportId)>,\n     result: ItemMap,\n@@ -165,13 +165,13 @@ where\n     pub(crate) fn new(\n         db: &'a DB,\n         input: &'a FxHashMap<ModuleId, Arc<LoweredModule>>,\n-        source_root: SourceRootId,\n-        module_tree: Arc<ModuleTree>,\n+        krate: CrateId,\n     ) -> Resolver<'a, DB> {\n+        let module_tree = db.module_tree(krate);\n         Resolver {\n             db,\n             input,\n-            source_root,\n+            krate,\n             module_tree,\n             processed_imports: FxHashSet::default(),\n             result: ItemMap::default(),\n@@ -210,7 +210,7 @@ where\n                 let krate = Crate::new(crate_id);\n                 for dep in krate.dependencies(self.db) {\n                     if let Some(module) = dep.krate.root_module(self.db) {\n-                        let def_id = module.def_id;\n+                        let def_id = module.into();\n                         self.add_module_item(\n                             &mut module_items,\n                             dep.name.clone(),\n@@ -244,20 +244,22 @@ where\n \n         // Populate modules\n         for (name, module_id) in module_id.children(&self.module_tree) {\n-            let def_loc = DefLoc {\n-                kind: DefKind::Module,\n-                source_root_id: self.source_root,\n+            let module = Module {\n                 module_id,\n-                source_item_id: module_id.source(&self.module_tree),\n+                krate: self.krate,\n             };\n-            let def_id = def_loc.id(self.db);\n-            self.add_module_item(&mut module_items, name, PerNs::types(def_id));\n+            self.add_module_item(&mut module_items, name, PerNs::types(module.into()));\n         }\n \n         self.result.per_module.insert(module_id, module_items);\n     }\n \n-    fn add_module_item(&self, module_items: &mut ModuleScope, name: Name, def_id: PerNs<DefId>) {\n+    fn add_module_item(\n+        &self,\n+        module_items: &mut ModuleScope,\n+        name: Name,\n+        def_id: PerNs<ModuleDef>,\n+    ) {\n         let resolution = Resolution {\n             def_id,\n             import: None,\n@@ -329,17 +331,11 @@ where\n                     );\n                     return false;\n                 };\n-                curr = match type_def_id.loc(self.db) {\n-                    DefLoc {\n-                        kind: DefKind::Module,\n-                        module_id: target_module_id,\n-                        source_root_id,\n-                        ..\n-                    } => {\n-                        if source_root_id == self.source_root {\n-                            target_module_id\n+                curr = match type_def_id {\n+                    ModuleDef::Module(module) => {\n+                        if module.krate == self.krate {\n+                            module.module_id\n                         } else {\n-                            let module = crate::code_model_api::Module::new(type_def_id);\n                             let path = Path {\n                                 segments: import.path.segments[i + 1..].iter().cloned().collect(),\n                                 kind: PathKind::Crate,\n@@ -359,7 +355,7 @@ where\n                                     \"resolved import {:?} ({:?}) cross-source root to {:?}\",\n                                     last_segment.name,\n                                     import,\n-                                    def_id.map(|did| did.loc(self.db))\n+                                    def_id,\n                                 );\n                                 return true;\n                             } else {\n@@ -372,7 +368,7 @@ where\n                         log::debug!(\n                             \"path segment {:?} resolved to non-module {:?}, but is not last\",\n                             segment.name,\n-                            type_def_id.loc(self.db)\n+                            type_def_id,\n                         );\n                         return true; // this resolved to a non-module, so the path won't ever resolve\n                     }\n@@ -382,7 +378,7 @@ where\n                     \"resolved import {:?} ({:?}) within source root to {:?}\",\n                     segment.name,\n                     import,\n-                    def_id.map(|did| did.loc(self.db))\n+                    def_id,\n                 );\n                 self.update(module_id, |items| {\n                     let res = Resolution {"}, {"sha": "6f003bd6664279b7f92ee7a9829515b782b87176", "filename": "crates/ra_hir/src/nameres/lower.rs", "status": "modified", "additions": 22, "deletions": 52, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs?ref=3ab1519cb27b927074ed7fbbb18a856e6e7fabb8", "patch": "@@ -4,14 +4,13 @@ use ra_syntax::{\n     SyntaxKind, AstNode, SourceFile, TreeArc, AstPtr,\n     ast::{self, ModuleItemOwner, NameOwner},\n };\n-use ra_db::SourceRootId;\n use ra_arena::{Arena, RawId, impl_arena_id, map::ArenaMap};\n use rustc_hash::FxHashMap;\n \n use crate::{\n     SourceItemId, Path, ModuleSource, HirDatabase, Name, SourceFileItems,\n-    HirFileId, MacroCallLoc, AsName, PerNs, DefId, DefKind, DefLoc,\n-    module_tree::ModuleId\n+    HirFileId, MacroCallLoc, AsName, PerNs, DefKind, DefLoc,\n+    ModuleDef, Module,\n };\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -32,7 +31,7 @@ pub(super) struct ImportData {\n /// can avoid redoing name resolution.\n #[derive(Debug, Default, PartialEq, Eq)]\n pub struct LoweredModule {\n-    pub(crate) declarations: FxHashMap<Name, PerNs<DefId>>,\n+    pub(crate) declarations: FxHashMap<Name, PerNs<ModuleDef>>,\n     pub(super) imports: Arena<ImportId, ImportData>,\n }\n \n@@ -59,37 +58,31 @@ impl ImportSourceMap {\n impl LoweredModule {\n     pub(crate) fn lower_module_module_query(\n         db: &impl HirDatabase,\n-        source_root_id: SourceRootId,\n-        module_id: ModuleId,\n+        module: Module,\n     ) -> Arc<LoweredModule> {\n-        db.lower_module(source_root_id, module_id).0\n+        db.lower_module(module).0\n     }\n \n     pub(crate) fn lower_module_source_map_query(\n         db: &impl HirDatabase,\n-        source_root_id: SourceRootId,\n-        module_id: ModuleId,\n+        module: Module,\n     ) -> Arc<ImportSourceMap> {\n-        db.lower_module(source_root_id, module_id).1\n+        db.lower_module(module).1\n     }\n \n     pub(crate) fn lower_module_query(\n         db: &impl HirDatabase,\n-        source_root_id: SourceRootId,\n-        module_id: ModuleId,\n+        module: Module,\n     ) -> (Arc<LoweredModule>, Arc<ImportSourceMap>) {\n-        let module_tree = db.module_tree(source_root_id);\n-        let source = module_id.source(&module_tree);\n-        let file_id = source.file_id;\n-        let source = ModuleSource::from_source_item_id(db, source);\n+        let (file_id, source) = module.definition_source(db);\n+        let file_id: HirFileId = file_id.into();\n         let mut source_map = ImportSourceMap::default();\n         let mut res = LoweredModule::default();\n         match source {\n             ModuleSource::SourceFile(it) => res.fill(\n                 &mut source_map,\n                 db,\n-                source_root_id,\n-                module_id,\n+                module,\n                 file_id,\n                 &mut it.items_with_macros(),\n             ),\n@@ -98,8 +91,7 @@ impl LoweredModule {\n                     res.fill(\n                         &mut source_map,\n                         db,\n-                        source_root_id,\n-                        module_id,\n+                        module,\n                         file_id,\n                         &mut item_list.items_with_macros(),\n                     )\n@@ -113,8 +105,7 @@ impl LoweredModule {\n         &mut self,\n         source_map: &mut ImportSourceMap,\n         db: &impl HirDatabase,\n-        source_root_id: SourceRootId,\n-        module_id: ModuleId,\n+        module: Module,\n         file_id: HirFileId,\n         items: &mut Iterator<Item = ast::ItemOrMacro>,\n     ) {\n@@ -123,21 +114,12 @@ impl LoweredModule {\n         for item in items {\n             match item {\n                 ast::ItemOrMacro::Item(it) => {\n-                    self.add_def_id(\n-                        source_map,\n-                        db,\n-                        source_root_id,\n-                        module_id,\n-                        file_id,\n-                        &file_items,\n-                        it,\n-                    );\n+                    self.add_def_id(source_map, db, module, file_id, &file_items, it);\n                 }\n                 ast::ItemOrMacro::Macro(macro_call) => {\n                     let item_id = file_items.id_of_unchecked(macro_call.syntax());\n                     let loc = MacroCallLoc {\n-                        source_root_id,\n-                        module_id,\n+                        module,\n                         source_item_id: SourceItemId {\n                             file_id,\n                             item_id: Some(item_id),\n@@ -148,15 +130,7 @@ impl LoweredModule {\n                     let file_items = db.file_items(file_id);\n                     //FIXME: expand recursively\n                     for item in db.hir_source_file(file_id).items() {\n-                        self.add_def_id(\n-                            source_map,\n-                            db,\n-                            source_root_id,\n-                            module_id,\n-                            file_id,\n-                            &file_items,\n-                            item,\n-                        );\n+                        self.add_def_id(source_map, db, module, file_id, &file_items, item);\n                     }\n                 }\n             }\n@@ -167,8 +141,7 @@ impl LoweredModule {\n         &mut self,\n         source_map: &mut ImportSourceMap,\n         db: &impl HirDatabase,\n-        source_root_id: SourceRootId,\n-        module_id: ModuleId,\n+        module: Module,\n         file_id: HirFileId,\n         file_items: &SourceFileItems,\n         item: &ast::ModuleItem,\n@@ -199,7 +172,7 @@ impl LoweredModule {\n             }\n         };\n         if let Some(name) = name {\n-            let def_id = assign_def_id(db, source_root_id, module_id, file_id, file_items, item);\n+            let def_id = assign_def_id(db, module, file_id, file_items, item);\n             self.declarations.insert(name.as_name(), def_id);\n         }\n     }\n@@ -219,27 +192,25 @@ impl LoweredModule {\n \n fn assign_def_id(\n     db: &impl HirDatabase,\n-    source_root_id: SourceRootId,\n-    module_id: ModuleId,\n+    module: Module,\n     file_id: HirFileId,\n     file_items: &SourceFileItems,\n     item: &ast::ModuleItem,\n-) -> PerNs<DefId> {\n+) -> PerNs<ModuleDef> {\n     // depending on the item kind, the location can define something in\n     // the values namespace, the types namespace, or both\n     let kind = DefKind::for_syntax_kind(item.syntax().kind());\n     let def_id = kind.map(|k| {\n         let item_id = file_items.id_of_unchecked(item.syntax());\n         let def_loc = DefLoc {\n             kind: k,\n-            source_root_id,\n-            module_id,\n+            module,\n             source_item_id: SourceItemId {\n                 file_id,\n                 item_id: Some(item_id),\n             },\n         };\n-        def_loc.id(db)\n+        def_loc.id(db).into()\n     });\n     def_id\n }\n@@ -248,7 +219,6 @@ impl DefKind {\n     fn for_syntax_kind(kind: SyntaxKind) -> PerNs<DefKind> {\n         match kind {\n             SyntaxKind::FN_DEF => PerNs::values(DefKind::Function),\n-            SyntaxKind::MODULE => PerNs::types(DefKind::Module),\n             SyntaxKind::STRUCT_DEF => PerNs::both(DefKind::Struct, DefKind::StructCtor),\n             SyntaxKind::ENUM_DEF => PerNs::types(DefKind::Enum),\n             SyntaxKind::TRAIT_DEF => PerNs::types(DefKind::Trait),"}, {"sha": "9322bf08ce9735c4528fa5eae37bfb0c1f32348e", "filename": "crates/ra_hir/src/nameres/tests.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs?ref=3ab1519cb27b927074ed7fbbb18a856e6e7fabb8", "patch": "@@ -1,6 +1,6 @@\n use std::sync::Arc;\n \n-use ra_db::{FilesDatabase, CrateGraph, SourceRootId, salsa::Database};\n+use ra_db::{CrateGraph, SourceRootId, salsa::Database};\n use relative_path::RelativePath;\n use test_utils::{assert_eq_text, covers};\n \n@@ -13,10 +13,10 @@ use crate::{\n \n fn item_map(fixture: &str) -> (Arc<ItemMap>, ModuleId) {\n     let (db, pos) = MockDatabase::with_position(fixture);\n-    let source_root = db.file_source_root(pos.file_id);\n     let module = crate::source_binder::module_from_position(&db, pos).unwrap();\n-    let module_id = module.def_id.loc(&db).module_id;\n-    (db.item_map(source_root), module_id)\n+    let krate = module.krate(&db).unwrap();\n+    let module_id = module.module_id;\n+    (db.item_map(krate.crate_id), module_id)\n }\n \n fn check_module_item_map(map: &ItemMap, module_id: ModuleId, expected: &str) {\n@@ -238,14 +238,13 @@ fn item_map_across_crates() {\n \n     db.set_crate_graph(crate_graph);\n \n-    let source_root = db.file_source_root(main_id);\n     let module = crate::source_binder::module_from_file_id(&db, main_id).unwrap();\n-    let module_id = module.def_id.loc(&db).module_id;\n-    let item_map = db.item_map(source_root);\n+    let krate = module.krate(&db).unwrap();\n+    let item_map = db.item_map(krate.crate_id);\n \n     check_module_item_map(\n         &item_map,\n-        module_id,\n+        module.module_id,\n         \"\n             Baz: t v\n             test_crate: t\n@@ -292,12 +291,12 @@ fn import_across_source_roots() {\n     db.set_crate_graph(crate_graph);\n \n     let module = crate::source_binder::module_from_file_id(&db, main_id).unwrap();\n-    let module_id = module.def_id.loc(&db).module_id;\n-    let item_map = db.item_map(source_root);\n+    let krate = module.krate(&db).unwrap();\n+    let item_map = db.item_map(krate.crate_id);\n \n     check_module_item_map(\n         &item_map,\n-        module_id,\n+        module.module_id,\n         \"\n             C: t v\n             test_crate: t\n@@ -333,14 +332,13 @@ fn reexport_across_crates() {\n \n     db.set_crate_graph(crate_graph);\n \n-    let source_root = db.file_source_root(main_id);\n     let module = crate::source_binder::module_from_file_id(&db, main_id).unwrap();\n-    let module_id = module.def_id.loc(&db).module_id;\n-    let item_map = db.item_map(source_root);\n+    let krate = module.krate(&db).unwrap();\n+    let item_map = db.item_map(krate.crate_id);\n \n     check_module_item_map(\n         &item_map,\n-        module_id,\n+        module.module_id,\n         \"\n             Baz: t v\n             test_crate: t\n@@ -350,10 +348,11 @@ fn reexport_across_crates() {\n \n fn check_item_map_is_not_recomputed(initial: &str, file_change: &str) {\n     let (mut db, pos) = MockDatabase::with_position(initial);\n-    let source_root = db.file_source_root(pos.file_id);\n+    let module = crate::source_binder::module_from_file_id(&db, pos.file_id).unwrap();\n+    let krate = module.krate(&db).unwrap();\n     {\n         let events = db.log_executed(|| {\n-            db.item_map(source_root);\n+            db.item_map(krate.crate_id);\n         });\n         assert!(format!(\"{:?}\", events).contains(\"item_map\"))\n     }\n@@ -362,7 +361,7 @@ fn check_item_map_is_not_recomputed(initial: &str, file_change: &str) {\n \n     {\n         let events = db.log_executed(|| {\n-            db.item_map(source_root);\n+            db.item_map(krate.crate_id);\n         });\n         assert!(\n             !format!(\"{:?}\", events).contains(\"item_map\"),"}, {"sha": "a8ed887b34402e2d4beb2c2685a10f02c605c83c", "filename": "crates/ra_hir/src/query_definitions.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs?ref=3ab1519cb27b927074ed7fbbb18a856e6e7fabb8", "patch": "@@ -7,11 +7,11 @@ use rustc_hash::FxHashMap;\n use ra_syntax::{\n     AstNode, SyntaxNode, TreeArc,\n };\n-use ra_db::SourceRootId;\n+use ra_db::{CrateId};\n \n use crate::{\n     SourceFileItems, SourceItemId, DefId, HirFileId,\n-    FnScopes,\n+    FnScopes, Module,\n     db::HirDatabase,\n     nameres::{ItemMap, Resolver},\n };\n@@ -41,15 +41,23 @@ pub(super) fn file_item(\n     }\n }\n \n-pub(super) fn item_map(db: &impl HirDatabase, source_root: SourceRootId) -> Arc<ItemMap> {\n+pub(super) fn item_map(db: &impl HirDatabase, crate_id: CrateId) -> Arc<ItemMap> {\n     let start = Instant::now();\n-    let module_tree = db.module_tree(source_root);\n+    let module_tree = db.module_tree(crate_id);\n     let input = module_tree\n         .modules()\n-        .map(|id| (id, db.lower_module_module(source_root, id)))\n+        .map(|module_id| {\n+            (\n+                module_id,\n+                db.lower_module_module(Module {\n+                    krate: crate_id,\n+                    module_id,\n+                }),\n+            )\n+        })\n         .collect::<FxHashMap<_, _>>();\n \n-    let resolver = Resolver::new(db, &input, source_root, module_tree);\n+    let resolver = Resolver::new(db, &input, crate_id);\n     let res = resolver.resolve();\n     let elapsed = start.elapsed();\n     log::info!(\"item_map: {:?}\", elapsed);"}, {"sha": "c3bd31d6b1e3aad1b1d2c927dfdf3f552e38f9dc", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=3ab1519cb27b927074ed7fbbb18a856e6e7fabb8", "patch": "@@ -13,7 +13,7 @@ use ra_syntax::{\n };\n \n use crate::{\n-    HirDatabase, Function, SourceItemId,\n+    HirDatabase, Function, SourceItemId, ModuleDef,\n     DefKind, DefLoc, AsName, Module,\n };\n \n@@ -84,9 +84,13 @@ pub fn module_from_child_node(\n \n fn module_from_source(db: &impl HirDatabase, source: SourceItemId) -> Option<Module> {\n     let source_root_id = db.file_source_root(source.file_id.as_original_file());\n-    let module_tree = db.module_tree(source_root_id);\n-    let module_id = module_tree.find_module_by_source(source)?;\n-    Some(Module::from_module_id(db, source_root_id, module_id))\n+    db.source_root_crates(source_root_id)\n+        .iter()\n+        .find_map(|&krate| {\n+            let module_tree = db.module_tree(krate);\n+            let module_id = module_tree.find_module_by_source(source)?;\n+            Some(Module { krate, module_id })\n+        })\n }\n \n pub fn function_from_position(db: &impl HirDatabase, position: FilePosition) -> Option<Function> {\n@@ -110,18 +114,17 @@ pub fn function_from_module(\n     module: &Module,\n     fn_def: &ast::FnDef,\n ) -> Function {\n-    let loc = module.def_id.loc(db);\n-    let file_id = loc.source_item_id.file_id;\n+    let (file_id, _) = module.definition_source(db);\n+    let file_id = file_id.into();\n     let file_items = db.file_items(file_id);\n     let item_id = file_items.id_of(file_id, fn_def.syntax());\n     let source_item_id = SourceItemId {\n         file_id,\n         item_id: Some(item_id),\n     };\n     let def_loc = DefLoc {\n+        module: module.clone(),\n         kind: DefKind::Function,\n-        source_root_id: loc.source_root_id,\n-        module_id: loc.module_id,\n         source_item_id,\n     };\n     Function::new(def_loc.id(db))\n@@ -141,14 +144,17 @@ pub fn macro_symbols(db: &impl HirDatabase, file_id: FileId) -> Vec<(SmolStr, Te\n         Some(it) => it,\n         None => return Vec::new(),\n     };\n-    let loc = module.def_id.loc(db);\n-    let items = db.lower_module_module(loc.source_root_id, loc.module_id);\n+    let items = db.lower_module_module(module);\n     let mut res = Vec::new();\n \n     for macro_call_id in items\n         .declarations\n         .iter()\n-        .filter_map(|(_, it)| it.take_types())\n+        .filter_map(|(_, it)| it.clone().take_types())\n+        .filter_map(|it| match it {\n+            ModuleDef::Def(it) => Some(it),\n+            _ => None,\n+        })\n         .filter_map(|it| it.loc(db).source_item_id.file_id.as_macro_call_id())\n     {\n         if let Some(exp) = db.expand_macro_invocation(macro_call_id) {"}, {"sha": "4c96579eeba2b0134364a54f6349f4a9cbbbcf42", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=3ab1519cb27b927074ed7fbbb18a856e6e7fabb8", "patch": "@@ -32,7 +32,7 @@ use rustc_hash::FxHashMap;\n \n use crate::{\n     Def, DefId, Module, Function, Struct, StructField, Enum, EnumVariant, Path, Name, ImplBlock,\n-    FnSignature, FnScopes,\n+    FnSignature, FnScopes, ModuleDef,\n     db::HirDatabase,\n     type_ref::{TypeRef, Mutability},\n     name::KnownName,\n@@ -382,8 +382,8 @@ impl Ty {\n \n         // Resolve in module (in type namespace)\n         let resolved = match module.resolve_path(db, path).take_types() {\n-            Some(r) => r,\n-            None => return Ty::Unknown,\n+            Some(ModuleDef::Def(r)) => r,\n+            None | Some(ModuleDef::Module(_)) => return Ty::Unknown,\n         };\n         let ty = db.type_for_def(resolved);\n         let substs = Ty::substs_from_path(db, module, impl_block, generics, path, resolved);\n@@ -663,10 +663,6 @@ pub(crate) fn type_for_enum_variant(db: &impl HirDatabase, ev: EnumVariant) -> T\n pub(super) fn type_for_def(db: &impl HirDatabase, def_id: DefId) -> Ty {\n     let def = def_id.resolve(db);\n     match def {\n-        Def::Module(..) => {\n-            log::debug!(\"trying to get type for module {:?}\", def_id);\n-            Ty::Unknown\n-        }\n         Def::Function(f) => type_for_fn(db, f),\n         Def::Struct(s) => type_for_struct(db, s),\n         Def::Enum(e) => type_for_enum(db, e),\n@@ -1063,7 +1059,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         };\n \n         // resolve in module\n-        let resolved = self.module.resolve_path(self.db, &path).take_values()?;\n+        let resolved = match self.module.resolve_path(self.db, &path).take_values()? {\n+            ModuleDef::Def(it) => it,\n+            ModuleDef::Module(_) => return None,\n+        };\n         let ty = self.db.type_for_def(resolved);\n         let ty = self.insert_type_vars(ty);\n         Some(ty)\n@@ -1075,7 +1074,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             None => return (Ty::Unknown, None),\n         };\n         let def_id = match self.module.resolve_path(self.db, &path).take_types() {\n-            Some(def_id) => def_id,\n+            Some(ModuleDef::Def(def_id)) => def_id,\n             _ => return (Ty::Unknown, None),\n         };\n         // TODO remove the duplication between here and `Ty::from_path`?\n@@ -1216,6 +1215,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 .module\n                 .resolve_path(self.db, &path)\n                 .take_values()\n+                .and_then(|module_def| match module_def {\n+                    ModuleDef::Def(it) => Some(it),\n+                    ModuleDef::Module(_) => None,\n+                })\n                 .map_or(Ty::Unknown, |resolved| self.db.type_for_def(resolved)),\n             Pat::Bind {\n                 mode,"}, {"sha": "a5567a78fbd2fc33f04d90e610d323508b2908d9", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=3ab1519cb27b927074ed7fbbb18a856e6e7fabb8", "patch": "@@ -6,8 +6,6 @@ use std::sync::Arc;\n \n use rustc_hash::FxHashMap;\n \n-use ra_db::SourceRootId;\n-\n use crate::{\n     HirDatabase, DefId, module_tree::ModuleId, Module, Crate, Name, Function,\n     impl_block::{ImplId, ImplBlock, ImplItem},\n@@ -37,7 +35,7 @@ impl TyFingerprint {\n #[derive(Debug, PartialEq, Eq)]\n pub struct CrateImplBlocks {\n     /// To make sense of the ModuleIds, we need the source root.\n-    source_root_id: SourceRootId,\n+    krate: Crate,\n     impls: FxHashMap<TyFingerprint, Vec<(ModuleId, ImplId)>>,\n }\n \n@@ -53,14 +51,17 @@ impl CrateImplBlocks {\n             .into_iter()\n             .flat_map(|i| i.iter())\n             .map(move |(module_id, impl_id)| {\n-                let module_impl_blocks = db.impls_in_module(self.source_root_id, *module_id);\n+                let module = Module {\n+                    krate: self.krate.crate_id,\n+                    module_id: *module_id,\n+                };\n+                let module_impl_blocks = db.impls_in_module(module);\n                 ImplBlock::from_id(module_impl_blocks, *impl_id)\n             })\n     }\n \n-    fn collect_recursive(&mut self, db: &impl HirDatabase, module: Module) {\n-        let module_id = module.def_id.loc(db).module_id;\n-        let module_impl_blocks = db.impls_in_module(self.source_root_id, module_id);\n+    fn collect_recursive(&mut self, db: &impl HirDatabase, module: &Module) {\n+        let module_impl_blocks = db.impls_in_module(module.clone());\n \n         for (impl_id, impl_data) in module_impl_blocks.impls.iter() {\n             let impl_block = ImplBlock::from_id(Arc::clone(&module_impl_blocks), impl_id);\n@@ -81,29 +82,26 @@ impl CrateImplBlocks {\n                     self.impls\n                         .entry(target_ty_fp)\n                         .or_insert_with(Vec::new)\n-                        .push((module_id, impl_id));\n+                        .push((module.module_id, impl_id));\n                 }\n             }\n         }\n \n         for child in module.children(db) {\n-            self.collect_recursive(db, child);\n+            self.collect_recursive(db, &child);\n         }\n     }\n \n     pub(crate) fn impls_in_crate_query(\n         db: &impl HirDatabase,\n         krate: Crate,\n     ) -> Arc<CrateImplBlocks> {\n-        let crate_graph = db.crate_graph();\n-        let file_id = crate_graph.crate_root(krate.crate_id);\n-        let source_root_id = db.file_source_root(file_id);\n         let mut crate_impl_blocks = CrateImplBlocks {\n-            source_root_id,\n+            krate: krate.clone(),\n             impls: FxHashMap::default(),\n         };\n         if let Some(module) = krate.root_module(db) {\n-            crate_impl_blocks.collect_recursive(db, module);\n+            crate_impl_blocks.collect_recursive(db, &module);\n         }\n         Arc::new(crate_impl_blocks)\n     }"}, {"sha": "0d794249682bc28613d36dafefbc8fee89f53a50", "filename": "crates/ra_ide_api/src/completion/complete_path.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=3ab1519cb27b927074ed7fbbb18a856e6e7fabb8", "patch": "@@ -13,8 +13,8 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n         Some(it) => it,\n         None => return,\n     };\n-    match def_id.resolve(ctx.db) {\n-        hir::Def::Module(module) => {\n+    match def_id {\n+        hir::ModuleDef::Module(module) => {\n             let module_scope = module.scope(ctx.db);\n             for (name, res) in module_scope.entries() {\n                 CompletionItem::new(\n@@ -26,21 +26,24 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n                 .add_to(acc);\n             }\n         }\n-        hir::Def::Enum(e) => {\n-            e.variants(ctx.db)\n-                .into_iter()\n-                .for_each(|(variant_name, variant)| {\n-                    CompletionItem::new(\n-                        CompletionKind::Reference,\n-                        ctx.source_range(),\n-                        variant_name.to_string(),\n-                    )\n-                    .kind(CompletionItemKind::EnumVariant)\n-                    .set_documentation(variant.docs(ctx.db))\n-                    .add_to(acc)\n-                });\n-        }\n-        _ => return,\n+\n+        hir::ModuleDef::Def(def_id) => match def_id.resolve(ctx.db) {\n+            hir::Def::Enum(e) => {\n+                e.variants(ctx.db)\n+                    .into_iter()\n+                    .for_each(|(variant_name, variant)| {\n+                        CompletionItem::new(\n+                            CompletionKind::Reference,\n+                            ctx.source_range(),\n+                            variant_name.to_string(),\n+                        )\n+                        .kind(CompletionItemKind::EnumVariant)\n+                        .set_documentation(variant.docs(ctx.db))\n+                        .add_to(acc)\n+                    });\n+            }\n+            _ => return,\n+        },\n     };\n }\n "}, {"sha": "5d6718a8d0d93e58598d147fafddca7c5a3a44f7", "filename": "crates/ra_ide_api/src/completion/completion_item.rs", "status": "modified", "additions": 23, "deletions": 38, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_item.rs?ref=3ab1519cb27b927074ed7fbbb18a856e6e7fabb8", "patch": "@@ -1,13 +1,13 @@\n-use hir::{Docs, Documentation, PerNs};\n-\n-use crate::completion::completion_context::CompletionContext;\n+use hir::{Docs, Documentation};\n use ra_syntax::{\n     ast::{self, AstNode},\n     TextRange,\n };\n use ra_text_edit::TextEdit;\n use test_utils::tested_by;\n \n+use crate::completion::completion_context::CompletionContext;\n+\n /// `CompletionItem` describes a single completion variant in the editor pop-up.\n /// It is basically a POD with various properties. To construct a\n /// `CompletionItem`, use `new` method and the `Builder` struct.\n@@ -209,41 +209,26 @@ impl Builder {\n         ctx: &CompletionContext,\n         resolution: &hir::Resolution,\n     ) -> Builder {\n-        let resolved = resolution.def_id.map(|d| d.resolve(ctx.db));\n-        let (kind, docs) = match resolved {\n-            PerNs {\n-                types: Some(hir::Def::Module(..)),\n-                ..\n-            } => (CompletionItemKind::Module, None),\n-            PerNs {\n-                types: Some(hir::Def::Struct(s)),\n-                ..\n-            } => (CompletionItemKind::Struct, s.docs(ctx.db)),\n-            PerNs {\n-                types: Some(hir::Def::Enum(e)),\n-                ..\n-            } => (CompletionItemKind::Enum, e.docs(ctx.db)),\n-            PerNs {\n-                types: Some(hir::Def::Trait(t)),\n-                ..\n-            } => (CompletionItemKind::Trait, t.docs(ctx.db)),\n-            PerNs {\n-                types: Some(hir::Def::Type(t)),\n-                ..\n-            } => (CompletionItemKind::TypeAlias, t.docs(ctx.db)),\n-            PerNs {\n-                values: Some(hir::Def::Const(c)),\n-                ..\n-            } => (CompletionItemKind::Const, c.docs(ctx.db)),\n-            PerNs {\n-                values: Some(hir::Def::Static(s)),\n-                ..\n-            } => (CompletionItemKind::Static, s.docs(ctx.db)),\n-            PerNs {\n-                values: Some(hir::Def::Function(function)),\n-                ..\n-            } => return self.from_function(ctx, function),\n-            _ => return self,\n+        let def = resolution\n+            .def_id\n+            .take_types()\n+            .or(resolution.def_id.take_values());\n+        let def = match def {\n+            None => return self,\n+            Some(it) => it,\n+        };\n+        let (kind, docs) = match def {\n+            hir::ModuleDef::Module(_) => (CompletionItemKind::Module, None),\n+            hir::ModuleDef::Def(def_id) => match def_id.resolve(ctx.db) {\n+                hir::Def::Struct(it) => (CompletionItemKind::Struct, it.docs(ctx.db)),\n+                hir::Def::Enum(it) => (CompletionItemKind::Enum, it.docs(ctx.db)),\n+                hir::Def::Trait(it) => (CompletionItemKind::Trait, it.docs(ctx.db)),\n+                hir::Def::Type(it) => (CompletionItemKind::TypeAlias, it.docs(ctx.db)),\n+                hir::Def::Const(it) => (CompletionItemKind::Const, it.docs(ctx.db)),\n+                hir::Def::Static(it) => (CompletionItemKind::Static, it.docs(ctx.db)),\n+                hir::Def::Function(function) => return self.from_function(ctx, function),\n+                _ => return self,\n+            },\n         };\n         self.kind = Some(kind);\n         self.documentation = docs;"}, {"sha": "bff6b7237ac68e2c19687f3eec418661fc7365f9", "filename": "crates/ra_ide_api/src/db.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_ide_api%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_ide_api%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdb.rs?ref=3ab1519cb27b927074ed7fbbb18a856e6e7fabb8", "patch": "@@ -72,6 +72,7 @@ salsa::database_storage! {\n             fn file_relative_path() for ra_db::FileRelativePathQuery;\n             fn file_source_root() for ra_db::FileSourceRootQuery;\n             fn source_root() for ra_db::SourceRootQuery;\n+            fn source_root_crates() for ra_db::SourceRootCratesQuery;\n             fn local_roots() for ra_db::LocalRootsQuery;\n             fn library_roots() for ra_db::LibraryRootsQuery;\n             fn crate_graph() for ra_db::CrateGraphQuery;"}, {"sha": "323bb1cc111841a33488907435b754eadc068668", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=3ab1519cb27b927074ed7fbbb18a856e6e7fabb8", "patch": "@@ -67,7 +67,7 @@ pub(crate) fn reference_definition(\n                 .node_expr(expr)\n                 .and_then(|it| infer_result.method_resolution(it))\n             {\n-                if let Some(target) = NavigationTarget::from_def(db, def_id.resolve(db)) {\n+                if let Some(target) = NavigationTarget::from_def(db, hir::ModuleDef::Def(def_id)) {\n                     return Exact(target);\n                 }\n             };\n@@ -84,7 +84,7 @@ pub(crate) fn reference_definition(\n         {\n             let resolved = module.resolve_path(db, &path);\n             if let Some(def_id) = resolved.take_types().or(resolved.take_values()) {\n-                if let Some(target) = NavigationTarget::from_def(db, def_id.resolve(db)) {\n+                if let Some(target) = NavigationTarget::from_def(db, def_id) {\n                     return Exact(target);\n                 }\n             }"}, {"sha": "1eb1776653c21ea69e26579391e9d493325afeda", "filename": "crates/ra_ide_api/src/navigation_target.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_ide_api%2Fsrc%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_ide_api%2Fsrc%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fnavigation_target.rs?ref=3ab1519cb27b927074ed7fbbb18a856e6e7fabb8", "patch": "@@ -97,7 +97,17 @@ impl NavigationTarget {\n     }\n \n     // TODO once Def::Item is gone, this should be able to always return a NavigationTarget\n-    pub(crate) fn from_def(db: &RootDatabase, def: Def) -> Option<NavigationTarget> {\n+    pub(crate) fn from_def(\n+        db: &RootDatabase,\n+        module_def: hir::ModuleDef,\n+    ) -> Option<NavigationTarget> {\n+        let def = match module_def {\n+            hir::ModuleDef::Def(def_id) => def_id.resolve(db),\n+            hir::ModuleDef::Module(module) => {\n+                return Some(NavigationTarget::from_module(db, module));\n+            }\n+        };\n+\n         let res = match def {\n             Def::Struct(s) => {\n                 let (file_id, node) = s.source(db);\n@@ -131,7 +141,6 @@ impl NavigationTarget {\n                 let (file_id, node) = f.source(db);\n                 NavigationTarget::from_named(file_id.original_file(db), &*node)\n             }\n-            Def::Module(m) => NavigationTarget::from_module(db, m),\n             Def::Item => return None,\n         };\n         Some(res)"}, {"sha": "5b767addd3c38d6e7494df37a7cea1946fabe53b", "filename": "crates/ra_ide_api/src/rename.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_ide_api%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_ide_api%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Frename.rs?ref=3ab1519cb27b927074ed7fbbb18a856e6e7fabb8", "patch": "@@ -57,7 +57,6 @@ fn rename_mod(\n ) -> Option<SourceChange> {\n     let mut source_file_edits = Vec::new();\n     let mut file_system_edits = Vec::new();\n-\n     if let Some(module) = module_from_declaration(db, position.file_id, &ast_module) {\n         let (file_id, module_source) = module.definition_source(db);\n         match module_source {\n@@ -223,11 +222,15 @@ mod tests {\n     fn test_rename_mod() {\n         let (analysis, position) = analysis_and_position(\n             \"\n-        //- /bar.rs\n-        mod fo<|>o;\n-        //- /bar/foo.rs\n-        // emtpy\n-    \",\n+            //- /lib.rs\n+            mod bar;\n+\n+            //- /bar.rs\n+            mod foo<|>;\n+\n+            //- /bar/foo.rs\n+            // emtpy\n+            \",\n         );\n         let new_name = \"foo2\";\n         let source_change = analysis.rename(position, new_name).unwrap();\n@@ -238,11 +241,11 @@ mod tests {\n     fn test_rename_mod_in_dir() {\n         let (analysis, position) = analysis_and_position(\n             \"\n-        //- /lib.rs\n-        mod fo<|>o;\n-        //- /foo/mod.rs\n-        // emtpy\n-    \",\n+            //- /lib.rs\n+            mod fo<|>o;\n+            //- /foo/mod.rs\n+            // emtpy\n+            \",\n         );\n         let new_name = \"foo2\";\n         let source_change = analysis.rename(position, new_name).unwrap();"}, {"sha": "890426db77192a79cf390fe6b24e0e4ca679c35d", "filename": "crates/ra_ide_api/src/snapshots/tests__rename_mod.snap", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_ide_api%2Fsrc%2Fsnapshots%2Ftests__rename_mod.snap", "raw_url": "https://github.com/rust-lang/rust/raw/3ab1519cb27b927074ed7fbbb18a856e6e7fabb8/crates%2Fra_ide_api%2Fsrc%2Fsnapshots%2Ftests__rename_mod.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsnapshots%2Ftests__rename_mod.snap?ref=3ab1519cb27b927074ed7fbbb18a856e6e7fabb8", "patch": "@@ -1,16 +1,16 @@\n ---\n-created: \"2019-01-22T14:45:00.975229300+00:00\"\n-creator: insta@0.4.0\n+created: \"2019-01-24T08:39:53.759318522+00:00\"\n+creator: insta@0.5.2\n expression: \"&source_change\"\n-source: \"crates\\\\ra_ide_api\\\\src\\\\rename.rs\"\n+source: crates/ra_ide_api/src/rename.rs\n ---\n Some(\n     SourceChange {\n         label: \"rename\",\n         source_file_edits: [\n             SourceFileEdit {\n                 file_id: FileId(\n-                    1\n+                    2\n                 ),\n                 edit: TextEdit {\n                     atoms: [\n@@ -25,7 +25,7 @@ Some(\n         file_system_edits: [\n             MoveFile {\n                 src: FileId(\n-                    2\n+                    3\n                 ),\n                 dst_source_root: SourceRootId(\n                     0"}]}