{"sha": "33294c7293f101d3a0fd02aeb8976751e343f46f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzMjk0YzcyOTNmMTAxZDNhMGZkMDJhZWI4OTc2NzUxZTM0M2Y0NmY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-06-27T22:20:17Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-06-27T23:30:27Z"}, "message": "Extract llvm-independent code from cwriter to metadata::encoder", "tree": {"sha": "dffa5fb88f40f5f2804bde0cbc5d4f616e2dd45c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dffa5fb88f40f5f2804bde0cbc5d4f616e2dd45c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33294c7293f101d3a0fd02aeb8976751e343f46f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33294c7293f101d3a0fd02aeb8976751e343f46f", "html_url": "https://github.com/rust-lang/rust/commit/33294c7293f101d3a0fd02aeb8976751e343f46f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33294c7293f101d3a0fd02aeb8976751e343f46f/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "279a229414bea59804548f8c7606c518a15261e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/279a229414bea59804548f8c7606c518a15261e2", "html_url": "https://github.com/rust-lang/rust/commit/279a229414bea59804548f8c7606c518a15261e2"}], "stats": {"total": 971, "additions": 485, "deletions": 486}, "files": [{"sha": "afea8b85e8ae121df233a2625a067cf06a695726", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/33294c7293f101d3a0fd02aeb8976751e343f46f/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33294c7293f101d3a0fd02aeb8976751e343f46f/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=33294c7293f101d3a0fd02aeb8976751e343f46f", "patch": "@@ -398,7 +398,7 @@ fn symbol_hash(ty::ctxt tcx, sha1 sha, &ty::t t, str crate_meta_name,\n     // to be independent of one another in the crate.\n \n     auto cx =\n-        @rec(ds=metadata::cwriter::def_to_str,\n+        @rec(ds=metadata::encoder::def_to_str,\n              tcx=tcx,\n              abbrevs=metadata::tyencode::ac_no_abbrevs);\n     sha.reset();\n@@ -452,7 +452,6 @@ fn mangle_exported_name(&@crate_ctxt ccx, &vec[str] path, &ty::t t) -> str {\n \n fn mangle_internal_name_by_type_only(&@crate_ctxt ccx, &ty::t t, &str name) ->\n    str {\n-    auto f = metadata::cwriter::def_to_str;\n     auto s = pretty::ppaux::ty_to_short_str(ccx.tcx, t);\n     auto hash = get_symbol_hash(ccx, t);\n     ret mangle([name, s, hash]);"}, {"sha": "7642b80fa4190106e1326c5c75bbdc504893d487", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33294c7293f101d3a0fd02aeb8976751e343f46f/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33294c7293f101d3a0fd02aeb8976751e343f46f/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=33294c7293f101d3a0fd02aeb8976751e343f46f", "patch": "@@ -435,7 +435,7 @@ fn resolve_path(vec[ast::ident] path, vec[u8] data) -> vec[ast::def_id] {\n     auto paths = ebml::get_doc(md, tag_paths);\n     auto eqer = bind eq_item(_, s);\n     let vec[ast::def_id] result = [];\n-    for (ebml::doc doc in lookup_hash(paths, eqer, cwriter::hash_path(s))) {\n+    for (ebml::doc doc in lookup_hash(paths, eqer, encoder::hash_path(s))) {\n         auto did_doc = ebml::get_doc(doc, tag_def_id);\n         vec::push(result, parse_def_id(ebml::doc_data(did_doc)));\n     }\n@@ -447,7 +447,7 @@ fn maybe_find_item(int item_id, &ebml::doc items) -> option::t[ebml::doc] {\n         ret ebml::be_uint_from_bytes(bytes, 0u, 4u) as int == item_id;\n     }\n     auto eqer = bind eq_item(_, item_id);\n-    auto found = lookup_hash(items, eqer, cwriter::hash_def_id(item_id));\n+    auto found = lookup_hash(items, eqer, encoder::hash_def_id(item_id));\n     if (vec::len(found) == 0u) {\n         ret option::none[ebml::doc];\n     } else { ret option::some[ebml::doc](found.(0)); }"}, {"sha": "bd3d691ee39bf85e970079028cfbcb4c5f39394a", "filename": "src/comp/metadata/cwriter.rs", "status": "modified", "additions": 3, "deletions": 482, "changes": 485, "blob_url": "https://github.com/rust-lang/rust/blob/33294c7293f101d3a0fd02aeb8976751e343f46f/src%2Fcomp%2Fmetadata%2Fcwriter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33294c7293f101d3a0fd02aeb8976751e343f46f/src%2Fcomp%2Fmetadata%2Fcwriter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcwriter.rs?ref=33294c7293f101d3a0fd02aeb8976751e343f46f", "patch": "@@ -1,509 +1,30 @@\n \n import std::str;\n-import std::uint;\n-import std::vec;\n-import std::map::hashmap;\n-import std::ebml;\n-import std::io;\n-import std::option;\n-import std::option::some;\n-import std::option::none;\n-import front::ast::*;\n import middle::trans;\n-import middle::ty;\n-import middle::ty::path_to_str;\n+import front::ast::crate;\n import back::x86;\n-import back::link;\n-import util::common;\n-import pretty::ppaux::lit_to_str;\n import lib::llvm::llvm;\n import lib::llvm::llvm::ValueRef;\n import lib::llvm::False;\n-import defs::*;\n \n-export ac_no_abbrevs;\n-export def_to_str;\n-export encode;\n-export hash_def_id;\n-export hash_path;\n-export ty_abbrev;\n export write_metadata;\n \n-\n // Returns a Plain Old LLVM String:\n fn C_postr(&str s) -> ValueRef {\n     ret llvm::LLVMConstString(str::buf(s), str::byte_len(s), False);\n }\n \n-\n-// Path table encoding\n-fn encode_name(&ebml::writer ebml_w, &str name) {\n-    ebml::start_tag(ebml_w, tag_paths_data_name);\n-    ebml_w.writer.write(str::bytes(name));\n-    ebml::end_tag(ebml_w);\n-}\n-\n-fn encode_def_id(&ebml::writer ebml_w, &def_id id) {\n-    ebml::start_tag(ebml_w, tag_def_id);\n-    ebml_w.writer.write(str::bytes(def_to_str(id)));\n-    ebml::end_tag(ebml_w);\n-}\n-\n-fn encode_tag_variant_paths(&ebml::writer ebml_w, &vec[variant] variants,\n-                            &vec[str] path,\n-                            &mutable vec[tup(str, uint)] index) {\n-    for (variant variant in variants) {\n-        add_to_index(ebml_w, path, index, variant.node.name);\n-        ebml::start_tag(ebml_w, tag_paths_data_item);\n-        encode_name(ebml_w, variant.node.name);\n-        encode_def_id(ebml_w, local_def(variant.node.id));\n-        ebml::end_tag(ebml_w);\n-    }\n-}\n-\n-fn add_to_index(&ebml::writer ebml_w, &vec[str] path,\n-                &mutable vec[tup(str, uint)] index, &str name) {\n-    auto full_path = path + [name];\n-    index += [tup(str::connect(full_path, \"::\"), ebml_w.writer.tell())];\n-}\n-\n-fn encode_native_module_item_paths(&ebml::writer ebml_w,\n-                                   &native_mod nmod, &vec[str] path,\n-                                   &mutable vec[tup(str, uint)] index) {\n-    for (@native_item nitem in nmod.items) {\n-        add_to_index(ebml_w, path, index, nitem.ident);\n-        ebml::start_tag(ebml_w, tag_paths_data_item);\n-        encode_name(ebml_w, nitem.ident);\n-        encode_def_id(ebml_w, local_def(nitem.id));\n-        ebml::end_tag(ebml_w);\n-    }\n-}\n-\n-fn encode_module_item_paths(&ebml::writer ebml_w, &_mod module,\n-                            &vec[str] path,\n-                            &mutable vec[tup(str, uint)] index) {\n-    for (@item it in module.items) {\n-        if (!is_exported(it.ident, module)) { cont; }\n-        alt (it.node) {\n-            case (item_const(_, _)) {\n-                add_to_index(ebml_w, path, index, it.ident);\n-                ebml::start_tag(ebml_w, tag_paths_data_item);\n-                encode_name(ebml_w, it.ident);\n-                encode_def_id(ebml_w, local_def(it.id));\n-                ebml::end_tag(ebml_w);\n-            }\n-            case (item_fn(_, ?tps)) {\n-                add_to_index(ebml_w, path, index, it.ident);\n-                ebml::start_tag(ebml_w, tag_paths_data_item);\n-                encode_name(ebml_w, it.ident);\n-                encode_def_id(ebml_w, local_def(it.id));\n-                ebml::end_tag(ebml_w);\n-            }\n-            case (item_mod(?_mod)) {\n-                add_to_index(ebml_w, path, index, it.ident);\n-                ebml::start_tag(ebml_w, tag_paths_data_mod);\n-                encode_name(ebml_w, it.ident);\n-                encode_def_id(ebml_w, local_def(it.id));\n-                encode_module_item_paths(ebml_w, _mod, path + [it.ident],\n-                                         index);\n-                ebml::end_tag(ebml_w);\n-            }\n-            case (item_native_mod(?nmod)) {\n-                add_to_index(ebml_w, path, index, it.ident);\n-                ebml::start_tag(ebml_w, tag_paths_data_mod);\n-                encode_name(ebml_w, it.ident);\n-                encode_def_id(ebml_w, local_def(it.id));\n-                encode_native_module_item_paths(ebml_w, nmod,\n-                                                path + [it.ident], index);\n-                ebml::end_tag(ebml_w);\n-            }\n-            case (item_ty(_, ?tps)) {\n-                add_to_index(ebml_w, path, index, it.ident);\n-                ebml::start_tag(ebml_w, tag_paths_data_item);\n-                encode_name(ebml_w, it.ident);\n-                encode_def_id(ebml_w, local_def(it.id));\n-                ebml::end_tag(ebml_w);\n-            }\n-            case (item_res(_, _, ?tps, ?ctor_id)) {\n-                add_to_index(ebml_w, path, index, it.ident);\n-                ebml::start_tag(ebml_w, tag_paths_data_item);\n-                encode_name(ebml_w, it.ident);\n-                encode_def_id(ebml_w, local_def(ctor_id));\n-                ebml::end_tag(ebml_w);\n-                add_to_index(ebml_w, path, index, it.ident);\n-                ebml::start_tag(ebml_w, tag_paths_data_item);\n-                encode_name(ebml_w, it.ident);\n-                encode_def_id(ebml_w, local_def(it.id));\n-                ebml::end_tag(ebml_w);\n-            }\n-            case (item_tag(?variants, ?tps)) {\n-                add_to_index(ebml_w, path, index, it.ident);\n-                ebml::start_tag(ebml_w, tag_paths_data_item);\n-                encode_name(ebml_w, it.ident);\n-                encode_def_id(ebml_w, local_def(it.id));\n-                ebml::end_tag(ebml_w);\n-                encode_tag_variant_paths(ebml_w, variants, path, index);\n-            }\n-            case (item_obj(_, ?tps, ?ctor_id)) {\n-                add_to_index(ebml_w, path, index, it.ident);\n-                ebml::start_tag(ebml_w, tag_paths_data_item);\n-                encode_name(ebml_w, it.ident);\n-                encode_def_id(ebml_w, local_def(ctor_id));\n-                ebml::end_tag(ebml_w);\n-                add_to_index(ebml_w, path, index, it.ident);\n-                ebml::start_tag(ebml_w, tag_paths_data_item);\n-                encode_name(ebml_w, it.ident);\n-                encode_def_id(ebml_w, local_def(it.id));\n-                ebml::end_tag(ebml_w);\n-            }\n-        }\n-    }\n-}\n-\n-fn encode_item_paths(&ebml::writer ebml_w, &@crate crate) ->\n-   vec[tup(str, uint)] {\n-    let vec[tup(str, uint)] index = [];\n-    let vec[str] path = [];\n-    ebml::start_tag(ebml_w, tag_paths);\n-    encode_module_item_paths(ebml_w, crate.node.module, path, index);\n-    ebml::end_tag(ebml_w);\n-    ret index;\n-}\n-\n-\n-// Item info table encoding\n-fn encode_kind(&ebml::writer ebml_w, u8 c) {\n-    ebml::start_tag(ebml_w, tag_items_data_item_kind);\n-    ebml_w.writer.write([c]);\n-    ebml::end_tag(ebml_w);\n-}\n-\n-fn def_to_str(&def_id did) -> str { ret #fmt(\"%d:%d\", did._0, did._1); }\n-\n-fn encode_type_param_count(&ebml::writer ebml_w, &vec[ty_param] tps) {\n-    ebml::start_tag(ebml_w, tag_items_data_item_ty_param_count);\n-    ebml::write_vint(ebml_w.writer, vec::len[ty_param](tps));\n-    ebml::end_tag(ebml_w);\n-}\n-\n-fn encode_variant_id(&ebml::writer ebml_w, &def_id vid) {\n-    ebml::start_tag(ebml_w, tag_items_data_item_variant);\n-    ebml_w.writer.write(str::bytes(def_to_str(vid)));\n-    ebml::end_tag(ebml_w);\n-}\n-\n-fn encode_type(&@trans::crate_ctxt cx, &ebml::writer ebml_w, &ty::t typ) {\n-    ebml::start_tag(ebml_w, tag_items_data_item_type);\n-    auto f = def_to_str;\n-    auto ty_str_ctxt =\n-        @rec(ds=f, tcx=cx.tcx, abbrevs=tyencode::ac_use_abbrevs(cx.type_abbrevs));\n-    tyencode::enc_ty(io::new_writer_(ebml_w.writer), ty_str_ctxt, typ);\n-    ebml::end_tag(ebml_w);\n-}\n-\n-fn encode_symbol(&@trans::crate_ctxt cx, &ebml::writer ebml_w,\n-                 node_id id) {\n-    ebml::start_tag(ebml_w, tag_items_data_item_symbol);\n-    ebml_w.writer.write(str::bytes(cx.item_symbols.get(id)));\n-    ebml::end_tag(ebml_w);\n-}\n-\n-fn encode_discriminant(&@trans::crate_ctxt cx, &ebml::writer ebml_w,\n-                       node_id id) {\n-    ebml::start_tag(ebml_w, tag_items_data_item_symbol);\n-    ebml_w.writer.write(str::bytes(cx.discrim_symbols.get(id)));\n-    ebml::end_tag(ebml_w);\n-}\n-\n-fn encode_tag_id(&ebml::writer ebml_w, &def_id id) {\n-    ebml::start_tag(ebml_w, tag_items_data_item_tag_id);\n-    ebml_w.writer.write(str::bytes(def_to_str(id)));\n-    ebml::end_tag(ebml_w);\n-}\n-\n-fn encode_tag_variant_info(&@trans::crate_ctxt cx, &ebml::writer ebml_w,\n-                           node_id id, &vec[variant] variants,\n-                           &mutable vec[tup(int, uint)] index,\n-                           &vec[ty_param] ty_params) {\n-    for (variant variant in variants) {\n-        index += [tup(variant.node.id, ebml_w.writer.tell())];\n-        ebml::start_tag(ebml_w, tag_items_data_item);\n-        encode_def_id(ebml_w, local_def(variant.node.id));\n-        encode_kind(ebml_w, 'v' as u8);\n-        encode_tag_id(ebml_w, local_def(id));\n-        encode_type(cx, ebml_w, trans::node_id_type(cx, variant.node.id));\n-        if (vec::len[variant_arg](variant.node.args) > 0u) {\n-            encode_symbol(cx, ebml_w, variant.node.id);\n-        }\n-        encode_discriminant(cx, ebml_w, variant.node.id);\n-        encode_type_param_count(ebml_w, ty_params);\n-        ebml::end_tag(ebml_w);\n-    }\n-}\n-\n-fn encode_info_for_item(@trans::crate_ctxt cx, &ebml::writer ebml_w,\n-                        @item item, &mutable vec[tup(int, uint)] index) {\n-    alt (item.node) {\n-        case (item_const(_, _)) {\n-            ebml::start_tag(ebml_w, tag_items_data_item);\n-            encode_def_id(ebml_w, local_def(item.id));\n-            encode_kind(ebml_w, 'c' as u8);\n-            encode_type(cx, ebml_w, trans::node_id_type(cx, item.id));\n-            encode_symbol(cx, ebml_w, item.id);\n-            ebml::end_tag(ebml_w);\n-        }\n-        case (item_fn(?fd, ?tps)) {\n-            ebml::start_tag(ebml_w, tag_items_data_item);\n-            encode_def_id(ebml_w, local_def(item.id));\n-            encode_kind(ebml_w, alt (fd.decl.purity) {\n-                                  case (pure_fn) { 'p' }\n-                                  case (impure_fn) { 'f' } } as u8);\n-            encode_type_param_count(ebml_w, tps);\n-            encode_type(cx, ebml_w, trans::node_id_type(cx, item.id));\n-            encode_symbol(cx, ebml_w, item.id);\n-            ebml::end_tag(ebml_w);\n-        }\n-        case (item_mod(_)) {\n-            ebml::start_tag(ebml_w, tag_items_data_item);\n-            encode_def_id(ebml_w, local_def(item.id));\n-            encode_kind(ebml_w, 'm' as u8);\n-            ebml::end_tag(ebml_w);\n-        }\n-        case (item_native_mod(_)) {\n-            ebml::start_tag(ebml_w, tag_items_data_item);\n-            encode_def_id(ebml_w, local_def(item.id));\n-            encode_kind(ebml_w, 'n' as u8);\n-            ebml::end_tag(ebml_w);\n-        }\n-        case (item_ty(_, ?tps)) {\n-            ebml::start_tag(ebml_w, tag_items_data_item);\n-            encode_def_id(ebml_w, local_def(item.id));\n-            encode_kind(ebml_w, 'y' as u8);\n-            encode_type_param_count(ebml_w, tps);\n-            encode_type(cx, ebml_w, trans::node_id_type(cx, item.id));\n-            ebml::end_tag(ebml_w);\n-        }\n-        case (item_tag(?variants, ?tps)) {\n-            ebml::start_tag(ebml_w, tag_items_data_item);\n-            encode_def_id(ebml_w, local_def(item.id));\n-            encode_kind(ebml_w, 't' as u8);\n-            encode_type_param_count(ebml_w, tps);\n-            encode_type(cx, ebml_w, trans::node_id_type(cx, item.id));\n-            for (variant v in variants) {\n-                encode_variant_id(ebml_w, local_def(v.node.id));\n-            }\n-            ebml::end_tag(ebml_w);\n-            encode_tag_variant_info(cx, ebml_w, item.id, variants, index,\n-                                    tps);\n-        }\n-        case (item_res(_, _, ?tps, ?ctor_id)) {\n-            auto fn_ty = trans::node_id_type(cx, item.id);\n-\n-            ebml::start_tag(ebml_w, tag_items_data_item);\n-            encode_def_id(ebml_w, local_def(item.id));\n-            encode_kind(ebml_w, 'y' as u8);\n-            encode_type_param_count(ebml_w, tps);\n-            encode_type(cx, ebml_w, ty::ty_fn_ret(cx.tcx, fn_ty));\n-            ebml::end_tag(ebml_w);\n-\n-            index += [tup(ctor_id, ebml_w.writer.tell())];\n-            ebml::start_tag(ebml_w, tag_items_data_item);\n-            encode_def_id(ebml_w, local_def(ctor_id));\n-            encode_kind(ebml_w, 'f' as u8);\n-            encode_type_param_count(ebml_w, tps);\n-            encode_type(cx, ebml_w, fn_ty);\n-            encode_symbol(cx, ebml_w, ctor_id);\n-            ebml::end_tag(ebml_w);\n-        }\n-        case (item_obj(_, ?tps, ?ctor_id)) {\n-            auto fn_ty = trans::node_id_type(cx, ctor_id);\n-\n-            ebml::start_tag(ebml_w, tag_items_data_item);\n-            encode_def_id(ebml_w, local_def(item.id));\n-            encode_kind(ebml_w, 'y' as u8);\n-            encode_type_param_count(ebml_w, tps);\n-            encode_type(cx, ebml_w, ty::ty_fn_ret(cx.tcx, fn_ty));\n-            ebml::end_tag(ebml_w);\n-\n-            index += [tup(ctor_id, ebml_w.writer.tell())];\n-            ebml::start_tag(ebml_w, tag_items_data_item);\n-            encode_def_id(ebml_w, local_def(ctor_id));\n-            encode_kind(ebml_w, 'f' as u8);\n-            encode_type_param_count(ebml_w, tps);\n-            encode_type(cx, ebml_w, fn_ty);\n-            encode_symbol(cx, ebml_w, ctor_id);\n-            ebml::end_tag(ebml_w);\n-        }\n-    }\n-}\n-\n-fn encode_info_for_native_item(&@trans::crate_ctxt cx, &ebml::writer ebml_w,\n-                               &@native_item nitem) {\n-    ebml::start_tag(ebml_w, tag_items_data_item);\n-    alt (nitem.node) {\n-        case (native_item_ty) {\n-            encode_def_id(ebml_w, local_def(nitem.id));\n-            encode_kind(ebml_w, 'T' as u8);\n-            encode_type(cx, ebml_w, ty::mk_native(cx.tcx));\n-        }\n-        case (native_item_fn(_, _, ?tps)) {\n-            encode_def_id(ebml_w, local_def(nitem.id));\n-            encode_kind(ebml_w, 'F' as u8);\n-            encode_type_param_count(ebml_w, tps);\n-            encode_type(cx, ebml_w, trans::node_id_type(cx, nitem.id));\n-            encode_symbol(cx, ebml_w, nitem.id);\n-        }\n-    }\n-    ebml::end_tag(ebml_w);\n-}\n-\n-fn encode_info_for_items(&@trans::crate_ctxt cx, &ebml::writer ebml_w) ->\n-   vec[tup(int, uint)] {\n-    let vec[tup(int, uint)] index = [];\n-    ebml::start_tag(ebml_w, tag_items_data);\n-    for each (@tup(node_id, middle::ast_map::ast_node) kvp in cx.ast_map.items()) {\n-        alt (kvp._1) {\n-            case (middle::ast_map::node_item(?i)) {\n-                index += [tup(kvp._0, ebml_w.writer.tell())];\n-                encode_info_for_item(cx, ebml_w, i, index);\n-            }\n-            case (middle::ast_map::node_native_item(?i)) {\n-                index += [tup(kvp._0, ebml_w.writer.tell())];\n-                encode_info_for_native_item(cx, ebml_w, i);\n-            }\n-            case (_) {}\n-        }\n-    }\n-    ebml::end_tag(ebml_w);\n-    ret index;\n-}\n-\n-\n-// Path and definition ID indexing\n-\n-// djb's cdb hashes.\n-fn hash_def_id(&int def_id) -> uint { ret 177573u ^ (def_id as uint); }\n-\n-fn hash_path(&str s) -> uint {\n-    auto h = 5381u;\n-    for (u8 ch in str::bytes(s)) { h = (h << 5u) + h ^ (ch as uint); }\n-    ret h;\n-}\n-\n-fn create_index[T](&vec[tup(T, uint)] index, fn(&T) -> uint  hash_fn) ->\n-   vec[vec[tup(T, uint)]] {\n-    let vec[mutable vec[tup(T, uint)]] buckets = vec::empty_mut();\n-    for each (uint i in uint::range(0u, 256u)) { buckets += [mutable []]; }\n-    for (tup(T, uint) elt in index) {\n-        auto h = hash_fn(elt._0);\n-        buckets.(h % 256u) += [elt];\n-    }\n-    ret vec::freeze(buckets);\n-}\n-\n-fn encode_index[T](&ebml::writer ebml_w, &vec[vec[tup(T, uint)]] buckets,\n-                   fn(&io::writer, &T)  write_fn) {\n-    auto writer = io::new_writer_(ebml_w.writer);\n-    ebml::start_tag(ebml_w, tag_index);\n-    let vec[uint] bucket_locs = [];\n-    ebml::start_tag(ebml_w, tag_index_buckets);\n-    for (vec[tup(T, uint)] bucket in buckets) {\n-        bucket_locs += [ebml_w.writer.tell()];\n-        ebml::start_tag(ebml_w, tag_index_buckets_bucket);\n-        for (tup(T, uint) elt in bucket) {\n-            ebml::start_tag(ebml_w, tag_index_buckets_bucket_elt);\n-            writer.write_be_uint(elt._1, 4u);\n-            write_fn(writer, elt._0);\n-            ebml::end_tag(ebml_w);\n-        }\n-        ebml::end_tag(ebml_w);\n-    }\n-    ebml::end_tag(ebml_w);\n-    ebml::start_tag(ebml_w, tag_index_table);\n-    for (uint pos in bucket_locs) { writer.write_be_uint(pos, 4u); }\n-    ebml::end_tag(ebml_w);\n-    ebml::end_tag(ebml_w);\n-}\n-\n-fn write_str(&io::writer writer, &str s) { writer.write_str(s); }\n-\n-fn write_int(&io::writer writer, &int n) {\n-    writer.write_be_uint(n as uint, 4u);\n-}\n-\n-fn encode_meta_items(&ebml::writer ebml_w, &crate crate) {\n-    fn encode_meta_item(&ebml::writer ebml_w, &meta_item mi) {\n-        // FIXME (#487): Support all forms of meta item\n-        ebml::start_tag(ebml_w, tag_meta_item);\n-        alt (mi.node) {\n-            case (meta_key_value(?key, ?value)) {\n-                ebml::start_tag(ebml_w, tag_meta_item_key);\n-                ebml_w.writer.write(str::bytes(key));\n-                ebml::end_tag(ebml_w);\n-                ebml::start_tag(ebml_w, tag_meta_item_value);\n-                ebml_w.writer.write(str::bytes(value));\n-                ebml::end_tag(ebml_w);\n-            }\n-            case (_) {\n-                log_err \"unimplemented meta_item type\";\n-            }\n-        }\n-        ebml::end_tag(ebml_w);\n-    }\n-    ebml::start_tag(ebml_w, tag_meta_export);\n-    for each (@meta_item mi in link::crate_export_metas(crate)) {\n-        encode_meta_item(ebml_w, *mi);\n-    }\n-    ebml::end_tag(ebml_w);\n-    ebml::start_tag(ebml_w, tag_meta_local);\n-    for each (@meta_item mi in link::crate_local_metas(crate)) {\n-        encode_meta_item(ebml_w, *mi);\n-    }\n-    ebml::end_tag(ebml_w);\n-}\n-\n-fn encode_metadata(&@trans::crate_ctxt cx, &@crate crate) -> ValueRef {\n-    auto string_w = io::string_writer();\n-    auto buf_w = string_w.get_writer().get_buf_writer();\n-    auto ebml_w = ebml::create_writer(buf_w);\n-    // Encode the meta items\n-\n-    encode_meta_items(ebml_w, *crate);\n-    // Encode and index the paths.\n-\n-    ebml::start_tag(ebml_w, tag_paths);\n-    auto paths_index = encode_item_paths(ebml_w, crate);\n-    auto str_writer = write_str;\n-    auto path_hasher = hash_path;\n-    auto paths_buckets = create_index[str](paths_index, path_hasher);\n-    encode_index[str](ebml_w, paths_buckets, str_writer);\n-    ebml::end_tag(ebml_w);\n-    // Encode and index the items.\n-\n-    ebml::start_tag(ebml_w, tag_items);\n-    auto items_index = encode_info_for_items(cx, ebml_w);\n-    auto int_writer = write_int;\n-    auto item_hasher = hash_def_id;\n-    auto items_buckets = create_index[int](items_index, item_hasher);\n-    encode_index[int](ebml_w, items_buckets, int_writer);\n-    ebml::end_tag(ebml_w);\n-    // Pad this, since something (LLVM, presumably) is cutting off the\n-    // remaining % 4 bytes.\n-\n-    buf_w.write([0u8, 0u8, 0u8, 0u8]);\n-    ret C_postr(string_w.get_str());\n-}\n-\n fn write_metadata(&@trans::crate_ctxt cx, &@crate crate) {\n     if (!cx.sess.get_opts().shared) { ret; }\n-    auto llmeta = encode_metadata(cx, crate);\n+    auto llmeta = C_postr(encoder::encode_metadata(cx, crate));\n     auto llconst = trans::C_struct([llmeta]);\n     auto llglobal =\n         llvm::LLVMAddGlobal(cx.llmod, trans::val_ty(llconst),\n                             str::buf(\"rust_metadata\"));\n     llvm::LLVMSetInitializer(llglobal, llconst);\n     llvm::LLVMSetSection(llglobal, str::buf(x86::get_meta_sect_name()));\n }\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "88804a344c362b8fb4640da6c8f480b0e668071a", "filename": "src/comp/metadata/encoder.rs", "status": "added", "additions": 478, "deletions": 0, "changes": 478, "blob_url": "https://github.com/rust-lang/rust/blob/33294c7293f101d3a0fd02aeb8976751e343f46f/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33294c7293f101d3a0fd02aeb8976751e343f46f/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=33294c7293f101d3a0fd02aeb8976751e343f46f", "patch": "@@ -0,0 +1,478 @@\n+import std::str;\n+import std::vec;\n+import std::uint;\n+import std::io;\n+import std::option;\n+import std::option::some;\n+import std::option::none;\n+import std::ebml;\n+import front::ast::*;\n+import defs::*;\n+import middle::trans::crate_ctxt;\n+import middle::trans::node_id_type;\n+import middle::ty;\n+import back::link::crate_export_metas;\n+import back::link::crate_local_metas;\n+\n+export def_to_str;\n+export hash_path;\n+export hash_def_id;\n+export encode_metadata;\n+\n+// Path table encoding\n+fn encode_name(&ebml::writer ebml_w, &str name) {\n+    ebml::start_tag(ebml_w, tag_paths_data_name);\n+    ebml_w.writer.write(str::bytes(name));\n+    ebml::end_tag(ebml_w);\n+}\n+\n+fn encode_def_id(&ebml::writer ebml_w, &def_id id) {\n+    ebml::start_tag(ebml_w, tag_def_id);\n+    ebml_w.writer.write(str::bytes(def_to_str(id)));\n+    ebml::end_tag(ebml_w);\n+}\n+\n+fn encode_tag_variant_paths(&ebml::writer ebml_w, &vec[variant] variants,\n+                            &vec[str] path,\n+                            &mutable vec[tup(str, uint)] index) {\n+    for (variant variant in variants) {\n+        add_to_index(ebml_w, path, index, variant.node.name);\n+        ebml::start_tag(ebml_w, tag_paths_data_item);\n+        encode_name(ebml_w, variant.node.name);\n+        encode_def_id(ebml_w, local_def(variant.node.id));\n+        ebml::end_tag(ebml_w);\n+    }\n+}\n+\n+fn add_to_index(&ebml::writer ebml_w, &vec[str] path,\n+                &mutable vec[tup(str, uint)] index, &str name) {\n+    auto full_path = path + [name];\n+    index += [tup(str::connect(full_path, \"::\"), ebml_w.writer.tell())];\n+}\n+\n+fn encode_native_module_item_paths(&ebml::writer ebml_w,\n+                                   &native_mod nmod, &vec[str] path,\n+                                   &mutable vec[tup(str, uint)] index) {\n+    for (@native_item nitem in nmod.items) {\n+        add_to_index(ebml_w, path, index, nitem.ident);\n+        ebml::start_tag(ebml_w, tag_paths_data_item);\n+        encode_name(ebml_w, nitem.ident);\n+        encode_def_id(ebml_w, local_def(nitem.id));\n+        ebml::end_tag(ebml_w);\n+    }\n+}\n+\n+fn encode_module_item_paths(&ebml::writer ebml_w, &_mod module,\n+                            &vec[str] path,\n+                            &mutable vec[tup(str, uint)] index) {\n+    for (@item it in module.items) {\n+        if (!is_exported(it.ident, module)) { cont; }\n+        alt (it.node) {\n+            case (item_const(_, _)) {\n+                add_to_index(ebml_w, path, index, it.ident);\n+                ebml::start_tag(ebml_w, tag_paths_data_item);\n+                encode_name(ebml_w, it.ident);\n+                encode_def_id(ebml_w, local_def(it.id));\n+                ebml::end_tag(ebml_w);\n+            }\n+            case (item_fn(_, ?tps)) {\n+                add_to_index(ebml_w, path, index, it.ident);\n+                ebml::start_tag(ebml_w, tag_paths_data_item);\n+                encode_name(ebml_w, it.ident);\n+                encode_def_id(ebml_w, local_def(it.id));\n+                ebml::end_tag(ebml_w);\n+            }\n+            case (item_mod(?_mod)) {\n+                add_to_index(ebml_w, path, index, it.ident);\n+                ebml::start_tag(ebml_w, tag_paths_data_mod);\n+                encode_name(ebml_w, it.ident);\n+                encode_def_id(ebml_w, local_def(it.id));\n+                encode_module_item_paths(ebml_w, _mod, path + [it.ident],\n+                                         index);\n+                ebml::end_tag(ebml_w);\n+            }\n+            case (item_native_mod(?nmod)) {\n+                add_to_index(ebml_w, path, index, it.ident);\n+                ebml::start_tag(ebml_w, tag_paths_data_mod);\n+                encode_name(ebml_w, it.ident);\n+                encode_def_id(ebml_w, local_def(it.id));\n+                encode_native_module_item_paths(ebml_w, nmod,\n+                                                path + [it.ident], index);\n+                ebml::end_tag(ebml_w);\n+            }\n+            case (item_ty(_, ?tps)) {\n+                add_to_index(ebml_w, path, index, it.ident);\n+                ebml::start_tag(ebml_w, tag_paths_data_item);\n+                encode_name(ebml_w, it.ident);\n+                encode_def_id(ebml_w, local_def(it.id));\n+                ebml::end_tag(ebml_w);\n+            }\n+            case (item_res(_, _, ?tps, ?ctor_id)) {\n+                add_to_index(ebml_w, path, index, it.ident);\n+                ebml::start_tag(ebml_w, tag_paths_data_item);\n+                encode_name(ebml_w, it.ident);\n+                encode_def_id(ebml_w, local_def(ctor_id));\n+                ebml::end_tag(ebml_w);\n+                add_to_index(ebml_w, path, index, it.ident);\n+                ebml::start_tag(ebml_w, tag_paths_data_item);\n+                encode_name(ebml_w, it.ident);\n+                encode_def_id(ebml_w, local_def(it.id));\n+                ebml::end_tag(ebml_w);\n+            }\n+            case (item_tag(?variants, ?tps)) {\n+                add_to_index(ebml_w, path, index, it.ident);\n+                ebml::start_tag(ebml_w, tag_paths_data_item);\n+                encode_name(ebml_w, it.ident);\n+                encode_def_id(ebml_w, local_def(it.id));\n+                ebml::end_tag(ebml_w);\n+                encode_tag_variant_paths(ebml_w, variants, path, index);\n+            }\n+            case (item_obj(_, ?tps, ?ctor_id)) {\n+                add_to_index(ebml_w, path, index, it.ident);\n+                ebml::start_tag(ebml_w, tag_paths_data_item);\n+                encode_name(ebml_w, it.ident);\n+                encode_def_id(ebml_w, local_def(ctor_id));\n+                ebml::end_tag(ebml_w);\n+                add_to_index(ebml_w, path, index, it.ident);\n+                ebml::start_tag(ebml_w, tag_paths_data_item);\n+                encode_name(ebml_w, it.ident);\n+                encode_def_id(ebml_w, local_def(it.id));\n+                ebml::end_tag(ebml_w);\n+            }\n+        }\n+    }\n+}\n+\n+fn encode_item_paths(&ebml::writer ebml_w, &@crate crate) ->\n+   vec[tup(str, uint)] {\n+    let vec[tup(str, uint)] index = [];\n+    let vec[str] path = [];\n+    ebml::start_tag(ebml_w, tag_paths);\n+    encode_module_item_paths(ebml_w, crate.node.module, path, index);\n+    ebml::end_tag(ebml_w);\n+    ret index;\n+}\n+\n+\n+// Item info table encoding\n+fn encode_kind(&ebml::writer ebml_w, u8 c) {\n+    ebml::start_tag(ebml_w, tag_items_data_item_kind);\n+    ebml_w.writer.write([c]);\n+    ebml::end_tag(ebml_w);\n+}\n+\n+fn def_to_str(&def_id did) -> str { ret #fmt(\"%d:%d\", did._0, did._1); }\n+\n+fn encode_type_param_count(&ebml::writer ebml_w, &vec[ty_param] tps) {\n+    ebml::start_tag(ebml_w, tag_items_data_item_ty_param_count);\n+    ebml::write_vint(ebml_w.writer, vec::len[ty_param](tps));\n+    ebml::end_tag(ebml_w);\n+}\n+\n+fn encode_variant_id(&ebml::writer ebml_w, &def_id vid) {\n+    ebml::start_tag(ebml_w, tag_items_data_item_variant);\n+    ebml_w.writer.write(str::bytes(def_to_str(vid)));\n+    ebml::end_tag(ebml_w);\n+}\n+\n+fn encode_type(&@crate_ctxt cx, &ebml::writer ebml_w, &ty::t typ) {\n+    ebml::start_tag(ebml_w, tag_items_data_item_type);\n+    auto f = def_to_str;\n+    auto ty_str_ctxt =\n+        @rec(ds=f, tcx=cx.tcx, abbrevs=tyencode::ac_use_abbrevs(cx.type_abbrevs));\n+    tyencode::enc_ty(io::new_writer_(ebml_w.writer), ty_str_ctxt, typ);\n+    ebml::end_tag(ebml_w);\n+}\n+\n+fn encode_symbol(&@crate_ctxt cx, &ebml::writer ebml_w,\n+                 node_id id) {\n+    ebml::start_tag(ebml_w, tag_items_data_item_symbol);\n+    ebml_w.writer.write(str::bytes(cx.item_symbols.get(id)));\n+    ebml::end_tag(ebml_w);\n+}\n+\n+fn encode_discriminant(&@crate_ctxt cx, &ebml::writer ebml_w,\n+                       node_id id) {\n+    ebml::start_tag(ebml_w, tag_items_data_item_symbol);\n+    ebml_w.writer.write(str::bytes(cx.discrim_symbols.get(id)));\n+    ebml::end_tag(ebml_w);\n+}\n+\n+fn encode_tag_id(&ebml::writer ebml_w, &def_id id) {\n+    ebml::start_tag(ebml_w, tag_items_data_item_tag_id);\n+    ebml_w.writer.write(str::bytes(def_to_str(id)));\n+    ebml::end_tag(ebml_w);\n+}\n+\n+fn encode_tag_variant_info(&@crate_ctxt cx, &ebml::writer ebml_w,\n+                           node_id id, &vec[variant] variants,\n+                           &mutable vec[tup(int, uint)] index,\n+                           &vec[ty_param] ty_params) {\n+    for (variant variant in variants) {\n+        index += [tup(variant.node.id, ebml_w.writer.tell())];\n+        ebml::start_tag(ebml_w, tag_items_data_item);\n+        encode_def_id(ebml_w, local_def(variant.node.id));\n+        encode_kind(ebml_w, 'v' as u8);\n+        encode_tag_id(ebml_w, local_def(id));\n+        encode_type(cx, ebml_w, node_id_type(cx, variant.node.id));\n+        if (vec::len[variant_arg](variant.node.args) > 0u) {\n+            encode_symbol(cx, ebml_w, variant.node.id);\n+        }\n+        encode_discriminant(cx, ebml_w, variant.node.id);\n+        encode_type_param_count(ebml_w, ty_params);\n+        ebml::end_tag(ebml_w);\n+    }\n+}\n+\n+fn encode_info_for_item(@crate_ctxt cx, &ebml::writer ebml_w,\n+                        @item item, &mutable vec[tup(int, uint)] index) {\n+    alt (item.node) {\n+        case (item_const(_, _)) {\n+            ebml::start_tag(ebml_w, tag_items_data_item);\n+            encode_def_id(ebml_w, local_def(item.id));\n+            encode_kind(ebml_w, 'c' as u8);\n+            encode_type(cx, ebml_w, node_id_type(cx, item.id));\n+            encode_symbol(cx, ebml_w, item.id);\n+            ebml::end_tag(ebml_w);\n+        }\n+        case (item_fn(?fd, ?tps)) {\n+            ebml::start_tag(ebml_w, tag_items_data_item);\n+            encode_def_id(ebml_w, local_def(item.id));\n+            encode_kind(ebml_w, alt (fd.decl.purity) {\n+                                  case (pure_fn) { 'p' }\n+                                  case (impure_fn) { 'f' } } as u8);\n+            encode_type_param_count(ebml_w, tps);\n+            encode_type(cx, ebml_w, node_id_type(cx, item.id));\n+            encode_symbol(cx, ebml_w, item.id);\n+            ebml::end_tag(ebml_w);\n+        }\n+        case (item_mod(_)) {\n+            ebml::start_tag(ebml_w, tag_items_data_item);\n+            encode_def_id(ebml_w, local_def(item.id));\n+            encode_kind(ebml_w, 'm' as u8);\n+            ebml::end_tag(ebml_w);\n+        }\n+        case (item_native_mod(_)) {\n+            ebml::start_tag(ebml_w, tag_items_data_item);\n+            encode_def_id(ebml_w, local_def(item.id));\n+            encode_kind(ebml_w, 'n' as u8);\n+            ebml::end_tag(ebml_w);\n+        }\n+        case (item_ty(_, ?tps)) {\n+            ebml::start_tag(ebml_w, tag_items_data_item);\n+            encode_def_id(ebml_w, local_def(item.id));\n+            encode_kind(ebml_w, 'y' as u8);\n+            encode_type_param_count(ebml_w, tps);\n+            encode_type(cx, ebml_w, node_id_type(cx, item.id));\n+            ebml::end_tag(ebml_w);\n+        }\n+        case (item_tag(?variants, ?tps)) {\n+            ebml::start_tag(ebml_w, tag_items_data_item);\n+            encode_def_id(ebml_w, local_def(item.id));\n+            encode_kind(ebml_w, 't' as u8);\n+            encode_type_param_count(ebml_w, tps);\n+            encode_type(cx, ebml_w, node_id_type(cx, item.id));\n+            for (variant v in variants) {\n+                encode_variant_id(ebml_w, local_def(v.node.id));\n+            }\n+            ebml::end_tag(ebml_w);\n+            encode_tag_variant_info(cx, ebml_w, item.id, variants, index,\n+                                    tps);\n+        }\n+        case (item_res(_, _, ?tps, ?ctor_id)) {\n+            auto fn_ty = node_id_type(cx, item.id);\n+\n+            ebml::start_tag(ebml_w, tag_items_data_item);\n+            encode_def_id(ebml_w, local_def(item.id));\n+            encode_kind(ebml_w, 'y' as u8);\n+            encode_type_param_count(ebml_w, tps);\n+            encode_type(cx, ebml_w, ty::ty_fn_ret(cx.tcx, fn_ty));\n+            ebml::end_tag(ebml_w);\n+\n+            index += [tup(ctor_id, ebml_w.writer.tell())];\n+            ebml::start_tag(ebml_w, tag_items_data_item);\n+            encode_def_id(ebml_w, local_def(ctor_id));\n+            encode_kind(ebml_w, 'f' as u8);\n+            encode_type_param_count(ebml_w, tps);\n+            encode_type(cx, ebml_w, fn_ty);\n+            encode_symbol(cx, ebml_w, ctor_id);\n+            ebml::end_tag(ebml_w);\n+        }\n+        case (item_obj(_, ?tps, ?ctor_id)) {\n+            auto fn_ty = node_id_type(cx, ctor_id);\n+\n+            ebml::start_tag(ebml_w, tag_items_data_item);\n+            encode_def_id(ebml_w, local_def(item.id));\n+            encode_kind(ebml_w, 'y' as u8);\n+            encode_type_param_count(ebml_w, tps);\n+            encode_type(cx, ebml_w, ty::ty_fn_ret(cx.tcx, fn_ty));\n+            ebml::end_tag(ebml_w);\n+\n+            index += [tup(ctor_id, ebml_w.writer.tell())];\n+            ebml::start_tag(ebml_w, tag_items_data_item);\n+            encode_def_id(ebml_w, local_def(ctor_id));\n+            encode_kind(ebml_w, 'f' as u8);\n+            encode_type_param_count(ebml_w, tps);\n+            encode_type(cx, ebml_w, fn_ty);\n+            encode_symbol(cx, ebml_w, ctor_id);\n+            ebml::end_tag(ebml_w);\n+        }\n+    }\n+}\n+\n+fn encode_info_for_native_item(&@crate_ctxt cx, &ebml::writer ebml_w,\n+                               &@native_item nitem) {\n+    ebml::start_tag(ebml_w, tag_items_data_item);\n+    alt (nitem.node) {\n+        case (native_item_ty) {\n+            encode_def_id(ebml_w, local_def(nitem.id));\n+            encode_kind(ebml_w, 'T' as u8);\n+            encode_type(cx, ebml_w, ty::mk_native(cx.tcx));\n+        }\n+        case (native_item_fn(_, _, ?tps)) {\n+            encode_def_id(ebml_w, local_def(nitem.id));\n+            encode_kind(ebml_w, 'F' as u8);\n+            encode_type_param_count(ebml_w, tps);\n+            encode_type(cx, ebml_w, node_id_type(cx, nitem.id));\n+            encode_symbol(cx, ebml_w, nitem.id);\n+        }\n+    }\n+    ebml::end_tag(ebml_w);\n+}\n+\n+fn encode_info_for_items(&@crate_ctxt cx, &ebml::writer ebml_w) ->\n+   vec[tup(int, uint)] {\n+    let vec[tup(int, uint)] index = [];\n+    ebml::start_tag(ebml_w, tag_items_data);\n+    for each (@tup(node_id, middle::ast_map::ast_node) kvp in cx.ast_map.items()) {\n+        alt (kvp._1) {\n+            case (middle::ast_map::node_item(?i)) {\n+                index += [tup(kvp._0, ebml_w.writer.tell())];\n+                encode_info_for_item(cx, ebml_w, i, index);\n+            }\n+            case (middle::ast_map::node_native_item(?i)) {\n+                index += [tup(kvp._0, ebml_w.writer.tell())];\n+                encode_info_for_native_item(cx, ebml_w, i);\n+            }\n+            case (_) {}\n+        }\n+    }\n+    ebml::end_tag(ebml_w);\n+    ret index;\n+}\n+\n+\n+// Path and definition ID indexing\n+\n+// djb's cdb hashes.\n+fn hash_def_id(&int def_id) -> uint { ret 177573u ^ (def_id as uint); }\n+\n+fn hash_path(&str s) -> uint {\n+    auto h = 5381u;\n+    for (u8 ch in str::bytes(s)) { h = (h << 5u) + h ^ (ch as uint); }\n+    ret h;\n+}\n+\n+fn create_index[T](&vec[tup(T, uint)] index, fn(&T) -> uint  hash_fn) ->\n+   vec[vec[tup(T, uint)]] {\n+    let vec[mutable vec[tup(T, uint)]] buckets = vec::empty_mut();\n+    for each (uint i in uint::range(0u, 256u)) { buckets += [mutable []]; }\n+    for (tup(T, uint) elt in index) {\n+        auto h = hash_fn(elt._0);\n+        buckets.(h % 256u) += [elt];\n+    }\n+    ret vec::freeze(buckets);\n+}\n+\n+fn encode_index[T](&ebml::writer ebml_w, &vec[vec[tup(T, uint)]] buckets,\n+                   fn(&io::writer, &T)  write_fn) {\n+    auto writer = io::new_writer_(ebml_w.writer);\n+    ebml::start_tag(ebml_w, tag_index);\n+    let vec[uint] bucket_locs = [];\n+    ebml::start_tag(ebml_w, tag_index_buckets);\n+    for (vec[tup(T, uint)] bucket in buckets) {\n+        bucket_locs += [ebml_w.writer.tell()];\n+        ebml::start_tag(ebml_w, tag_index_buckets_bucket);\n+        for (tup(T, uint) elt in bucket) {\n+            ebml::start_tag(ebml_w, tag_index_buckets_bucket_elt);\n+            writer.write_be_uint(elt._1, 4u);\n+            write_fn(writer, elt._0);\n+            ebml::end_tag(ebml_w);\n+        }\n+        ebml::end_tag(ebml_w);\n+    }\n+    ebml::end_tag(ebml_w);\n+    ebml::start_tag(ebml_w, tag_index_table);\n+    for (uint pos in bucket_locs) { writer.write_be_uint(pos, 4u); }\n+    ebml::end_tag(ebml_w);\n+    ebml::end_tag(ebml_w);\n+}\n+\n+fn write_str(&io::writer writer, &str s) { writer.write_str(s); }\n+\n+fn write_int(&io::writer writer, &int n) {\n+    writer.write_be_uint(n as uint, 4u);\n+}\n+\n+fn encode_meta_items(&ebml::writer ebml_w, &crate crate) {\n+    fn encode_meta_item(&ebml::writer ebml_w, &meta_item mi) {\n+        // FIXME (#487): Support all forms of meta item\n+        ebml::start_tag(ebml_w, tag_meta_item);\n+        alt (mi.node) {\n+            case (meta_key_value(?key, ?value)) {\n+                ebml::start_tag(ebml_w, tag_meta_item_key);\n+                ebml_w.writer.write(str::bytes(key));\n+                ebml::end_tag(ebml_w);\n+                ebml::start_tag(ebml_w, tag_meta_item_value);\n+                ebml_w.writer.write(str::bytes(value));\n+                ebml::end_tag(ebml_w);\n+            }\n+            case (_) {\n+                log_err \"unimplemented meta_item type\";\n+            }\n+        }\n+        ebml::end_tag(ebml_w);\n+    }\n+    ebml::start_tag(ebml_w, tag_meta_export);\n+    for each (@meta_item mi in crate_export_metas(crate)) {\n+        encode_meta_item(ebml_w, *mi);\n+    }\n+    ebml::end_tag(ebml_w);\n+    ebml::start_tag(ebml_w, tag_meta_local);\n+    for each (@meta_item mi in crate_local_metas(crate)) {\n+        encode_meta_item(ebml_w, *mi);\n+    }\n+    ebml::end_tag(ebml_w);\n+}\n+\n+fn encode_metadata(&@crate_ctxt cx, &@crate crate) -> str {\n+    auto string_w = io::string_writer();\n+    auto buf_w = string_w.get_writer().get_buf_writer();\n+    auto ebml_w = ebml::create_writer(buf_w);\n+    // Encode the meta items\n+\n+    encode_meta_items(ebml_w, *crate);\n+    // Encode and index the paths.\n+\n+    ebml::start_tag(ebml_w, tag_paths);\n+    auto paths_index = encode_item_paths(ebml_w, crate);\n+    auto str_writer = write_str;\n+    auto path_hasher = hash_path;\n+    auto paths_buckets = create_index[str](paths_index, path_hasher);\n+    encode_index[str](ebml_w, paths_buckets, str_writer);\n+    ebml::end_tag(ebml_w);\n+    // Encode and index the items.\n+\n+    ebml::start_tag(ebml_w, tag_items);\n+    auto items_index = encode_info_for_items(cx, ebml_w);\n+    auto int_writer = write_int;\n+    auto item_hasher = hash_def_id;\n+    auto items_buckets = create_index[int](items_index, item_hasher);\n+    encode_index[int](ebml_w, items_buckets, int_writer);\n+    ebml::end_tag(ebml_w);\n+    // Pad this, since something (LLVM, presumably) is cutting off the\n+    // remaining % 4 bytes.\n+\n+    buf_w.write([0u8, 0u8, 0u8, 0u8]);\n+    ret string_w.get_str();\n+}"}, {"sha": "0cc2aa27048c4d285ba3f5be6a2964ba96357e95", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/33294c7293f101d3a0fd02aeb8976751e343f46f/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/33294c7293f101d3a0fd02aeb8976751e343f46f/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=33294c7293f101d3a0fd02aeb8976751e343f46f", "patch": "@@ -65,6 +65,7 @@ mod back {\n mod metadata {\n     mod defs;\n     mod tyencode;\n+    mod encoder;\n     mod creader;\n     mod cwriter;\n }"}]}