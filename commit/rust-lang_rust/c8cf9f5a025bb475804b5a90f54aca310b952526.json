{"sha": "c8cf9f5a025bb475804b5a90f54aca310b952526", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4Y2Y5ZjVhMDI1YmI0NzU4MDRiNWE5MGY1NGFjYTMxMGI5NTI1MjY=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-28T09:41:29Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-09-05T14:07:17Z"}, "message": "Add `with_{def_site,call_site,legacy}_ctxt,` methods to `Span`\n\nUse these to create call-site spans for AST passes when needed.", "tree": {"sha": "1c456dab13065396aa1ee1ac79a9574143b82663", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c456dab13065396aa1ee1ac79a9574143b82663"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8cf9f5a025bb475804b5a90f54aca310b952526", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8cf9f5a025bb475804b5a90f54aca310b952526", "html_url": "https://github.com/rust-lang/rust/commit/c8cf9f5a025bb475804b5a90f54aca310b952526", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8cf9f5a025bb475804b5a90f54aca310b952526/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b86782058c27ba694ec81ebe7108dceb0968a2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b86782058c27ba694ec81ebe7108dceb0968a2b", "html_url": "https://github.com/rust-lang/rust/commit/0b86782058c27ba694ec81ebe7108dceb0968a2b"}], "stats": {"total": 255, "additions": 138, "deletions": 117}, "files": [{"sha": "02022c98c3502dba49a7d9ae407c6b3d29d8971a", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c8cf9f5a025bb475804b5a90f54aca310b952526/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8cf9f5a025bb475804b5a90f54aca310b952526/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=c8cf9f5a025bb475804b5a90f54aca310b952526", "patch": "@@ -17,7 +17,7 @@ use syntax::edition::Edition;\n use syntax::ext::base::{self, Indeterminate, SpecialDerives};\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax::ext::expand::{AstFragment, Invocation, InvocationKind};\n-use syntax::ext::hygiene::{self, ExpnId, ExpnData, ExpnKind, Transparency};\n+use syntax::ext::hygiene::{self, ExpnId, ExpnData, ExpnKind};\n use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::{emit_feature_err, is_builtin_attr_name};\n use syntax::feature_gate::GateIssue;\n@@ -131,23 +131,20 @@ impl<'a> base::Resolver for Resolver<'a> {\n     // Create a Span with modern hygiene with a definition site of the provided\n     // module, or a fake empty `#[no_implicit_prelude]` module if no module is\n     // provided.\n-    fn span_for_ast_pass(\n+    fn expansion_for_ast_pass(\n         &mut self,\n-        base_span: Span,\n+        call_site: Span,\n         pass: AstPass,\n         features: &[Symbol],\n         parent_module_id: Option<NodeId>,\n-    ) -> Span {\n-        let span = base_span.fresh_expansion_with_transparency(\n-            ExpnData::allow_unstable(\n-                ExpnKind::AstPass(pass),\n-                base_span,\n-                self.session.edition(),\n-                features.into(),\n-            ),\n-            Transparency::Opaque,\n-        );\n-        let expn_id = span.ctxt().outer_expn();\n+    ) -> ExpnId {\n+        let expn_id = ExpnId::fresh(Some(ExpnData::allow_unstable(\n+            ExpnKind::AstPass(pass),\n+            call_site,\n+            self.session.edition(),\n+            features.into(),\n+        )));\n+\n         let parent_scope = if let Some(module_id) = parent_module_id {\n             let parent_def_id = self.definitions.local_def_id(module_id);\n             self.definitions.add_parent_module_of_macro_def(expn_id, parent_def_id);\n@@ -160,7 +157,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n             self.empty_module\n         };\n         self.ast_transform_scopes.insert(expn_id, parent_scope);\n-        span\n+        expn_id\n     }\n \n     fn resolve_imports(&mut self) {"}, {"sha": "4c146611deab6ff3724adccb9e25b0d0ca9a7c22", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c8cf9f5a025bb475804b5a90f54aca310b952526/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8cf9f5a025bb475804b5a90f54aca310b952526/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=c8cf9f5a025bb475804b5a90f54aca310b952526", "patch": "@@ -3,7 +3,7 @@ use crate::attr::{HasAttrs, Stability, Deprecation};\n use crate::source_map::SourceMap;\n use crate::edition::Edition;\n use crate::ext::expand::{self, AstFragment, Invocation};\n-use crate::ext::hygiene::{ExpnId, Transparency};\n+use crate::ext::hygiene::ExpnId;\n use crate::mut_visit::{self, MutVisitor};\n use crate::parse::{self, parser, DirectoryOwnership};\n use crate::parse::token;\n@@ -658,13 +658,13 @@ pub trait Resolver {\n                                             extra_placeholders: &[NodeId]);\n     fn register_builtin_macro(&mut self, ident: ast::Ident, ext: SyntaxExtension);\n \n-    fn span_for_ast_pass(\n+    fn expansion_for_ast_pass(\n         &mut self,\n-        span: Span,\n+        call_site: Span,\n         pass: AstPass,\n         features: &[Symbol],\n         parent_module_id: Option<NodeId>,\n-    ) -> Span;\n+    ) -> ExpnId;\n \n     fn resolve_imports(&mut self);\n \n@@ -750,20 +750,20 @@ impl<'a> ExtCtxt<'a> {\n     /// Equivalent of `Span::def_site` from the proc macro API,\n     /// except that the location is taken from the span passed as an argument.\n     pub fn with_def_site_ctxt(&self, span: Span) -> Span {\n-        span.with_ctxt_from_mark(self.current_expansion.id, Transparency::Opaque)\n+        span.with_def_site_ctxt(self.current_expansion.id)\n     }\n \n     /// Equivalent of `Span::call_site` from the proc macro API,\n     /// except that the location is taken from the span passed as an argument.\n     pub fn with_call_site_ctxt(&self, span: Span) -> Span {\n-        span.with_ctxt_from_mark(self.current_expansion.id, Transparency::Transparent)\n+        span.with_call_site_ctxt(self.current_expansion.id)\n     }\n \n     /// Span with a context reproducing `macro_rules` hygiene (hygienic locals, unhygienic items).\n     /// FIXME: This should be eventually replaced either with `with_def_site_ctxt` (preferably),\n     /// or with `with_call_site_ctxt` (where necessary).\n     pub fn with_legacy_ctxt(&self, span: Span) -> Span {\n-        span.with_ctxt_from_mark(self.current_expansion.id, Transparency::SemiTransparent)\n+        span.with_legacy_ctxt(self.current_expansion.id)\n     }\n \n     /// Returns span for the macro which originally caused the current expansion to happen."}, {"sha": "8a4b78a3efa31abbc6e0fced223d365ac4575450", "filename": "src/libsyntax_ext/proc_macro_harness.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c8cf9f5a025bb475804b5a90f54aca310b952526/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8cf9f5a025bb475804b5a90f54aca310b952526/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_harness.rs?ref=c8cf9f5a025bb475804b5a90f54aca310b952526", "patch": "@@ -326,12 +326,13 @@ fn mk_decls(\n     custom_attrs: &[ProcMacroDef],\n     custom_macros: &[ProcMacroDef],\n ) -> P<ast::Item> {\n-    let span = cx.resolver.span_for_ast_pass(\n+    let expn_id = cx.resolver.expansion_for_ast_pass(\n         DUMMY_SP,\n         AstPass::ProcMacroHarness,\n         &[sym::rustc_attrs, sym::proc_macro_internals],\n         None,\n     );\n+    let span = DUMMY_SP.with_def_site_ctxt(expn_id);\n \n     let proc_macro = Ident::new(sym::proc_macro, span);\n     let krate = cx.item(span,"}, {"sha": "e5dded9ea53197e5b342c670de0ac0278de18016", "filename": "src/libsyntax_ext/standard_library_imports.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c8cf9f5a025bb475804b5a90f54aca310b952526/src%2Flibsyntax_ext%2Fstandard_library_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8cf9f5a025bb475804b5a90f54aca310b952526/src%2Flibsyntax_ext%2Fstandard_library_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fstandard_library_imports.rs?ref=c8cf9f5a025bb475804b5a90f54aca310b952526", "patch": "@@ -28,19 +28,21 @@ pub fn inject(\n         &[sym::std]\n     };\n \n-    let span = resolver.span_for_ast_pass(\n+    let expn_id = resolver.expansion_for_ast_pass(\n         DUMMY_SP,\n         AstPass::StdImports,\n         &[sym::prelude_import],\n         None,\n     );\n+    let span = DUMMY_SP.with_def_site_ctxt(expn_id);\n+    let call_site = DUMMY_SP.with_call_site_ctxt(expn_id);\n \n     // .rev() to preserve ordering above in combination with insert(0, ...)\n     for &orig_name_sym in names.iter().rev() {\n         let (rename, orig_name) = if rust_2018 {\n             (Ident::new(kw::Underscore, span), Some(orig_name_sym))\n         } else {\n-            (Ident::with_dummy_span(orig_name_sym), None)\n+            (Ident::new(orig_name_sym, call_site), None)\n         };\n         krate.module.items.insert(0, P(ast::Item {\n             attrs: vec![attr::mk_attr_outer(\n@@ -65,7 +67,7 @@ pub fn inject(\n             .collect()\n     } else {\n         [kw::PathRoot, name, sym::prelude, sym::v1].iter()\n-            .map(|symbol| ast::PathSegment::from_ident(ast::Ident::with_dummy_span(*symbol)))\n+            .map(|symbol| ast::PathSegment::from_ident(ast::Ident::new(*symbol, call_site)))\n             .collect()\n     };\n "}, {"sha": "eedd7fbee3806777f93bba83ade8a8ba87187395", "filename": "src/libsyntax_ext/test_harness.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c8cf9f5a025bb475804b5a90f54aca310b952526/src%2Flibsyntax_ext%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8cf9f5a025bb475804b5a90f54aca310b952526/src%2Flibsyntax_ext%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_harness.rs?ref=c8cf9f5a025bb475804b5a90f54aca310b952526", "patch": "@@ -97,15 +97,16 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n                 };\n                 // Create an identifier that will hygienically resolve the test\n                 // case name, even in another module.\n-                let sp = self.cx.ext_cx.resolver.span_for_ast_pass(\n+                let expn_id = self.cx.ext_cx.resolver.expansion_for_ast_pass(\n                     module.inner,\n                     AstPass::TestHarness,\n                     &[],\n                     Some(parent),\n                 );\n-                let expn = sp.ctxt().outer_expn();\n                 for test in &mut tests {\n-                    test.ident.span = test.ident.span.apply_mark(expn, Transparency::Opaque);\n+                    // See the comment on `mk_main` for why we're using\n+                    // `apply_mark` directly.\n+                    test.ident.span = test.ident.span.apply_mark(expn_id, Transparency::Opaque);\n                 }\n                 self.cx.test_cases.extend(tests);\n             }\n@@ -207,12 +208,13 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n     //            #![main]\n     //            test::test_main_static(&[..tests]);\n     //        }\n-    let sp = cx.ext_cx.resolver.span_for_ast_pass(\n+    let expn_id = cx.ext_cx.resolver.expansion_for_ast_pass(\n         DUMMY_SP,\n         AstPass::TestHarness,\n         &[sym::main, sym::test, sym::rustc_attrs],\n         None,\n     );\n+    let sp = DUMMY_SP.with_def_site_ctxt(expn_id);\n     let ecx = &cx.ext_cx;\n     let test_id = Ident::new(sym::test, sp);\n "}, {"sha": "f0e7344c1b9860ff950da975c486b457f2e752d2", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8cf9f5a025bb475804b5a90f54aca310b952526/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8cf9f5a025bb475804b5a90f54aca310b952526/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=c8cf9f5a025bb475804b5a90f54aca310b952526", "patch": "@@ -360,7 +360,7 @@ impl SyntaxContext {\n     }\n \n     /// Extend a syntax context with a given expansion and transparency.\n-    pub fn apply_mark(self, expn_id: ExpnId, transparency: Transparency) -> SyntaxContext {\n+    crate fn apply_mark(self, expn_id: ExpnId, transparency: Transparency) -> SyntaxContext {\n         HygieneData::with(|data| data.apply_mark(self, expn_id, transparency))\n     }\n "}, {"sha": "9a296f17aaf4aa26cc274ba2b0644b4e8e1887f6", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c8cf9f5a025bb475804b5a90f54aca310b952526/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8cf9f5a025bb475804b5a90f54aca310b952526/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=c8cf9f5a025bb475804b5a90f54aca310b952526", "patch": "@@ -514,6 +514,25 @@ impl Span {\n                   span.ctxt)\n     }\n \n+    /// Equivalent of `Span::def_site` from the proc macro API,\n+    /// except that the location is taken from the `self` span.\n+    pub fn with_def_site_ctxt(self, expn_id: ExpnId) -> Span {\n+        self.with_ctxt_from_mark(expn_id, Transparency::Opaque)\n+    }\n+\n+    /// Equivalent of `Span::call_site` from the proc macro API,\n+    /// except that the location is taken from the `self` span.\n+    pub fn with_call_site_ctxt(&self, expn_id: ExpnId) -> Span {\n+        self.with_ctxt_from_mark(expn_id, Transparency::Transparent)\n+    }\n+\n+    /// Span with a context reproducing `macro_rules` hygiene (hygienic locals, unhygienic items).\n+    /// FIXME: This should be eventually replaced either with `with_def_site_ctxt` (preferably),\n+    /// or with `with_call_site_ctxt` (where necessary).\n+    pub fn with_legacy_ctxt(&self, expn_id: ExpnId) -> Span {\n+        self.with_ctxt_from_mark(expn_id, Transparency::SemiTransparent)\n+    }\n+\n     /// Produces a span with the same location as `self` and context produced by a macro with the\n     /// given ID and transparency, assuming that macro was defined directly and not produced by\n     /// some other macro (which is the case for built-in and procedural macros)."}, {"sha": "ea06f6c1acaf993b948b6c64543e0c6c6cfe597b", "filename": "src/test/ui/proc-macro/dollar-crate-issue-57089.stdout", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c8cf9f5a025bb475804b5a90f54aca310b952526/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-57089.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/c8cf9f5a025bb475804b5a90f54aca310b952526/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-57089.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-57089.stdout?ref=c8cf9f5a025bb475804b5a90f54aca310b952526", "patch": "@@ -2,80 +2,80 @@ PRINT-BANG INPUT (DISPLAY): struct M ($crate :: S) ;\n PRINT-BANG INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Ident {\n         ident: \"M\",\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Group {\n         delimiter: Parenthesis,\n         stream: TokenStream [\n             Ident {\n                 ident: \"$crate\",\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Joint,\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Alone,\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Ident {\n                 ident: \"S\",\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n         ],\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n ]\n PRINT-ATTR INPUT (DISPLAY): struct A(crate::S);\n PRINT-ATTR RE-COLLECTED (DISPLAY): struct A ($crate :: S) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Ident {\n         ident: \"A\",\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Group {\n         delimiter: Parenthesis,\n         stream: TokenStream [\n             Ident {\n                 ident: \"$crate\",\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Joint,\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Alone,\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Ident {\n                 ident: \"S\",\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n         ],\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n ]"}, {"sha": "7ee8078b2c5d2210f7aacefc22ab4cad1da28656", "filename": "src/test/ui/proc-macro/dollar-crate-issue-62325.stdout", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c8cf9f5a025bb475804b5a90f54aca310b952526/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-62325.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/c8cf9f5a025bb475804b5a90f54aca310b952526/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-62325.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-62325.stdout?ref=c8cf9f5a025bb475804b5a90f54aca310b952526", "patch": "@@ -3,110 +3,110 @@ PRINT-ATTR RE-COLLECTED (DISPLAY): struct A (identity ! ($crate :: S)) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Ident {\n         ident: \"A\",\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Group {\n         delimiter: Parenthesis,\n         stream: TokenStream [\n             Ident {\n                 ident: \"identity\",\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Punct {\n                 ch: '!',\n                 spacing: Alone,\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Group {\n                 delimiter: Parenthesis,\n                 stream: TokenStream [\n                     Ident {\n                         ident: \"$crate\",\n-                        span: #2 bytes(LO..HI),\n+                        span: #3 bytes(LO..HI),\n                     },\n                     Punct {\n                         ch: ':',\n                         spacing: Joint,\n-                        span: #2 bytes(LO..HI),\n+                        span: #3 bytes(LO..HI),\n                     },\n                     Punct {\n                         ch: ':',\n                         spacing: Alone,\n-                        span: #2 bytes(LO..HI),\n+                        span: #3 bytes(LO..HI),\n                     },\n                     Ident {\n                         ident: \"S\",\n-                        span: #2 bytes(LO..HI),\n+                        span: #3 bytes(LO..HI),\n                     },\n                 ],\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n         ],\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n ]\n PRINT-ATTR INPUT (DISPLAY): struct B(identity!(::dollar_crate_external :: S));\n PRINT-ATTR RE-COLLECTED (DISPLAY): struct B (identity ! ($crate :: S)) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n-        span: #7 bytes(LO..HI),\n+        span: #8 bytes(LO..HI),\n     },\n     Ident {\n         ident: \"B\",\n-        span: #7 bytes(LO..HI),\n+        span: #8 bytes(LO..HI),\n     },\n     Group {\n         delimiter: Parenthesis,\n         stream: TokenStream [\n             Ident {\n                 ident: \"identity\",\n-                span: #7 bytes(LO..HI),\n+                span: #8 bytes(LO..HI),\n             },\n             Punct {\n                 ch: '!',\n                 spacing: Alone,\n-                span: #7 bytes(LO..HI),\n+                span: #8 bytes(LO..HI),\n             },\n             Group {\n                 delimiter: Parenthesis,\n                 stream: TokenStream [\n                     Ident {\n                         ident: \"$crate\",\n-                        span: #7 bytes(LO..HI),\n+                        span: #8 bytes(LO..HI),\n                     },\n                     Punct {\n                         ch: ':',\n                         spacing: Joint,\n-                        span: #7 bytes(LO..HI),\n+                        span: #8 bytes(LO..HI),\n                     },\n                     Punct {\n                         ch: ':',\n                         spacing: Alone,\n-                        span: #7 bytes(LO..HI),\n+                        span: #8 bytes(LO..HI),\n                     },\n                     Ident {\n                         ident: \"S\",\n-                        span: #7 bytes(LO..HI),\n+                        span: #8 bytes(LO..HI),\n                     },\n                 ],\n-                span: #7 bytes(LO..HI),\n+                span: #8 bytes(LO..HI),\n             },\n         ],\n-        span: #7 bytes(LO..HI),\n+        span: #8 bytes(LO..HI),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: #7 bytes(LO..HI),\n+        span: #8 bytes(LO..HI),\n     },\n ]"}, {"sha": "4f7e000265eb02fd757f6160b04b79851662940f", "filename": "src/test/ui/proc-macro/dollar-crate.stdout", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/c8cf9f5a025bb475804b5a90f54aca310b952526/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/c8cf9f5a025bb475804b5a90f54aca310b952526/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stdout?ref=c8cf9f5a025bb475804b5a90f54aca310b952526", "patch": "@@ -2,243 +2,243 @@ PRINT-BANG INPUT (DISPLAY): struct M ($crate :: S) ;\n PRINT-BANG INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Ident {\n         ident: \"M\",\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Group {\n         delimiter: Parenthesis,\n         stream: TokenStream [\n             Ident {\n                 ident: \"$crate\",\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Joint,\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Alone,\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Ident {\n                 ident: \"S\",\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n         ],\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n ]\n PRINT-ATTR INPUT (DISPLAY): struct A(crate::S);\n PRINT-ATTR RE-COLLECTED (DISPLAY): struct A ($crate :: S) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Ident {\n         ident: \"A\",\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Group {\n         delimiter: Parenthesis,\n         stream: TokenStream [\n             Ident {\n                 ident: \"$crate\",\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Joint,\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Alone,\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Ident {\n                 ident: \"S\",\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n         ],\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n ]\n PRINT-DERIVE INPUT (DISPLAY): struct D(crate::S);\n PRINT-DERIVE RE-COLLECTED (DISPLAY): struct D ($crate :: S) ;\n PRINT-DERIVE INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Ident {\n         ident: \"D\",\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Group {\n         delimiter: Parenthesis,\n         stream: TokenStream [\n             Ident {\n                 ident: \"$crate\",\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Joint,\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Alone,\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Ident {\n                 ident: \"S\",\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n         ],\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n ]\n PRINT-BANG INPUT (DISPLAY): struct M ($crate :: S) ;\n PRINT-BANG INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n-        span: #9 bytes(LO..HI),\n+        span: #10 bytes(LO..HI),\n     },\n     Ident {\n         ident: \"M\",\n-        span: #9 bytes(LO..HI),\n+        span: #10 bytes(LO..HI),\n     },\n     Group {\n         delimiter: Parenthesis,\n         stream: TokenStream [\n             Ident {\n                 ident: \"$crate\",\n-                span: #9 bytes(LO..HI),\n+                span: #10 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Joint,\n-                span: #9 bytes(LO..HI),\n+                span: #10 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Alone,\n-                span: #9 bytes(LO..HI),\n+                span: #10 bytes(LO..HI),\n             },\n             Ident {\n                 ident: \"S\",\n-                span: #9 bytes(LO..HI),\n+                span: #10 bytes(LO..HI),\n             },\n         ],\n-        span: #9 bytes(LO..HI),\n+        span: #10 bytes(LO..HI),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: #9 bytes(LO..HI),\n+        span: #10 bytes(LO..HI),\n     },\n ]\n PRINT-ATTR INPUT (DISPLAY): struct A(::dollar_crate_external::S);\n PRINT-ATTR RE-COLLECTED (DISPLAY): struct A ($crate :: S) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n-        span: #9 bytes(LO..HI),\n+        span: #10 bytes(LO..HI),\n     },\n     Ident {\n         ident: \"A\",\n-        span: #9 bytes(LO..HI),\n+        span: #10 bytes(LO..HI),\n     },\n     Group {\n         delimiter: Parenthesis,\n         stream: TokenStream [\n             Ident {\n                 ident: \"$crate\",\n-                span: #9 bytes(LO..HI),\n+                span: #10 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Joint,\n-                span: #9 bytes(LO..HI),\n+                span: #10 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Alone,\n-                span: #9 bytes(LO..HI),\n+                span: #10 bytes(LO..HI),\n             },\n             Ident {\n                 ident: \"S\",\n-                span: #9 bytes(LO..HI),\n+                span: #10 bytes(LO..HI),\n             },\n         ],\n-        span: #9 bytes(LO..HI),\n+        span: #10 bytes(LO..HI),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: #9 bytes(LO..HI),\n+        span: #10 bytes(LO..HI),\n     },\n ]\n PRINT-DERIVE INPUT (DISPLAY): struct D(::dollar_crate_external::S);\n PRINT-DERIVE RE-COLLECTED (DISPLAY): struct D ($crate :: S) ;\n PRINT-DERIVE INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n-        span: #9 bytes(LO..HI),\n+        span: #10 bytes(LO..HI),\n     },\n     Ident {\n         ident: \"D\",\n-        span: #9 bytes(LO..HI),\n+        span: #10 bytes(LO..HI),\n     },\n     Group {\n         delimiter: Parenthesis,\n         stream: TokenStream [\n             Ident {\n                 ident: \"$crate\",\n-                span: #9 bytes(LO..HI),\n+                span: #10 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Joint,\n-                span: #9 bytes(LO..HI),\n+                span: #10 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Alone,\n-                span: #9 bytes(LO..HI),\n+                span: #10 bytes(LO..HI),\n             },\n             Ident {\n                 ident: \"S\",\n-                span: #9 bytes(LO..HI),\n+                span: #10 bytes(LO..HI),\n             },\n         ],\n-        span: #9 bytes(LO..HI),\n+        span: #10 bytes(LO..HI),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: #9 bytes(LO..HI),\n+        span: #10 bytes(LO..HI),\n     },\n ]"}]}