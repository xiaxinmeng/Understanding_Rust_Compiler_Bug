{"sha": "08a6d6e16b5efe217123e780398969946266268f", "node_id": "C_kwDOAAsO6NoAKDA4YTZkNmUxNmI1ZWZlMjE3MTIzZTc4MDM5ODk2OTk0NjI2NjI2OGY", "commit": {"author": {"name": "antoyo", "email": "antoyo@users.noreply.github.com", "date": "2023-03-05T01:21:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-05T01:21:03Z"}, "message": "Merge pull request #255 from rust-lang/sync_from_rust_2023_feb_28_2\n\nSync from rust 2023 feb 28", "tree": {"sha": "e808314f0051d65991ba4f93e83a3a42d3eb643e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e808314f0051d65991ba4f93e83a3a42d3eb643e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08a6d6e16b5efe217123e780398969946266268f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkA+5/CRBK7hj4Ov3rIwAA4HQIAG+eKAeKsSwvPLYjjZa1ryN6\nYBTdLWqntw6FrHpANM9Gof+ib8glD8h5VGpRsSXcXrboKwp7z6xHkfkGMBPscwx5\nXobVaoMjZcPpE/lbBdO7ZN3ghobmUzPA/VqPN+T1Wc1kq1TlGzJuN3Hqe6j58Mgm\n0pJp2Ga+SBUJoNRs52l1v/NtYzrVNU02husYiw3Bya2yYXCecbSAuuIrPFhwnbXX\nABlmaSZ1x51HuSVIJV5K4eqBMDfR89w95vW9JA+DPbeTU4L2iZOEoGMuCYH8VJiT\nockRLcNwHwXhE0FdYSB2smyXsTqsBpaqgHYVBuOa9TprBXyb1JlzRGQfpEY5wuY=\n=dVI2\n-----END PGP SIGNATURE-----\n", "payload": "tree e808314f0051d65991ba4f93e83a3a42d3eb643e\nparent 8c3c02097d9d7be20a576bc067cbefc258d8c592\nparent 4b878ccab4cc9e68119a30bc2227522e301c674c\nauthor antoyo <antoyo@users.noreply.github.com> 1677979263 -0500\ncommitter GitHub <noreply@github.com> 1677979263 -0500\n\nMerge pull request #255 from rust-lang/sync_from_rust_2023_feb_28_2\n\nSync from rust 2023 feb 28"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08a6d6e16b5efe217123e780398969946266268f", "html_url": "https://github.com/rust-lang/rust/commit/08a6d6e16b5efe217123e780398969946266268f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08a6d6e16b5efe217123e780398969946266268f/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c3c02097d9d7be20a576bc067cbefc258d8c592", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c3c02097d9d7be20a576bc067cbefc258d8c592", "html_url": "https://github.com/rust-lang/rust/commit/8c3c02097d9d7be20a576bc067cbefc258d8c592"}, {"sha": "4b878ccab4cc9e68119a30bc2227522e301c674c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b878ccab4cc9e68119a30bc2227522e301c674c", "html_url": "https://github.com/rust-lang/rust/commit/4b878ccab4cc9e68119a30bc2227522e301c674c"}], "stats": {"total": 1995, "additions": 1125, "deletions": 870}, "files": [{"sha": "d2b7724a2215fc82381804e3031e7df191707ebb", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -108,14 +108,14 @@ jobs:\n         path: target\n         key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain') }}\n \n-    - name: Cache rust repository\n-      # We only clone the rust repository for rustc tests\n-      if: ${{ contains(matrix.commands, 'rustc') }}\n-      uses: actions/cache@v3\n-      id: cache-rust-repository\n-      with:\n-        path: rust\n-        key: ${{ runner.os }}-packages-${{ hashFiles('rust/.git/HEAD') }}\n+    #- name: Cache rust repository\n+      ## We only clone the rust repository for rustc tests\n+      #if: ${{ contains(matrix.commands, 'rustc') }}\n+      #uses: actions/cache@v3\n+      #id: cache-rust-repository\n+      #with:\n+        #path: rust\n+        #key: ${{ runner.os }}-packages-${{ hashFiles('rust/.git/HEAD') }}\n \n     - name: Build\n       run: |"}, {"sha": "ac0fc0eeb7e945427e182a9f74d907bb0edf535a", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -11,12 +11,6 @@ dependencies = [\n  \"memchr\",\n ]\n \n-[[package]]\n-name = \"ar\"\n-version = \"0.8.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"450575f58f7bee32816abbff470cbc47797397c2a81e0eaced4b98436daf52e1\"\n-\n [[package]]\n name = \"bitflags\"\n version = \"1.3.2\"\n@@ -41,15 +35,15 @@ dependencies = [\n [[package]]\n name = \"gccjit\"\n version = \"1.0.0\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#1bd270d0d130fe31807cfbe509ca095c082e5848\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#eefb8c662d61477f34b7c32d26bcda5f1ef08432\"\n dependencies = [\n  \"gccjit_sys\",\n ]\n \n [[package]]\n name = \"gccjit_sys\"\n version = \"0.0.1\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#1bd270d0d130fe31807cfbe509ca095c082e5848\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#eefb8c662d61477f34b7c32d26bcda5f1ef08432\"\n dependencies = [\n  \"libc 0.1.12\",\n ]\n@@ -212,11 +206,9 @@ dependencies = [\n name = \"rustc_codegen_gcc\"\n version = \"0.1.0\"\n dependencies = [\n- \"ar\",\n  \"gccjit\",\n  \"lang_tester\",\n  \"smallvec\",\n- \"target-lexicon\",\n  \"tempfile\",\n ]\n \n@@ -235,12 +227,6 @@ version = \"1.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"f2dd574626839106c320a323308629dcb1acfc96e32a8cba364ddc61ac23ee83\"\n \n-[[package]]\n-name = \"target-lexicon\"\n-version = \"0.10.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ab0e7238dcc7b40a7be719a25365910f6807bd864f4cce6b2e6b873658e2b19d\"\n-\n [[package]]\n name = \"tempfile\"\n version = \"3.2.0\""}, {"sha": "81066d9ce1f0acd9686f452d201db46eee17bc77", "filename": "Cargo.toml", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -28,9 +28,6 @@ gccjit = { git = \"https://github.com/antoyo/gccjit.rs\" }\n #gccjit = { path = \"../gccjit.rs\" }\n \n smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }\n-target-lexicon = \"0.10.0\"\n-\n-ar = \"0.8.0\"\n \n [dev-dependencies]\n lang_tester = \"0.3.9\""}, {"sha": "fd01fcf1fc82c071e954c87da03120df72d26a67", "filename": "example/alloc_system.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/example%2Falloc_system.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/example%2Falloc_system.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Falloc_system.rs?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -13,17 +13,17 @@\n \n // The minimum alignment guaranteed by the architecture. This value is used to\n // add fast paths for low alignment values.\n-#[cfg(all(any(target_arch = \"x86\",\n+#[cfg(any(target_arch = \"x86\",\n               target_arch = \"arm\",\n               target_arch = \"mips\",\n               target_arch = \"powerpc\",\n-              target_arch = \"powerpc64\")))]\n+              target_arch = \"powerpc64\"))]\n const MIN_ALIGN: usize = 8;\n-#[cfg(all(any(target_arch = \"x86_64\",\n+#[cfg(any(target_arch = \"x86_64\",\n               target_arch = \"aarch64\",\n               target_arch = \"mips64\",\n               target_arch = \"s390x\",\n-              target_arch = \"sparc64\")))]\n+              target_arch = \"sparc64\"))]\n const MIN_ALIGN: usize = 16;\n \n pub struct System;"}, {"sha": "637b8dc53fefd6045253163f4eedde382035def8", "filename": "example/mini_core.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/example%2Fmini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/example%2Fmini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fmini_core.rs?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -17,6 +17,9 @@ pub trait Sized {}\n #[lang = \"destruct\"]\n pub trait Destruct {}\n \n+#[lang = \"tuple_trait\"]\n+pub trait Tuple {}\n+\n #[lang = \"unsize\"]\n pub trait Unsize<T: ?Sized> {}\n \n@@ -396,7 +399,7 @@ pub struct PhantomData<T: ?Sized>;\n \n #[lang = \"fn_once\"]\n #[rustc_paren_sugar]\n-pub trait FnOnce<Args> {\n+pub trait FnOnce<Args: Tuple> {\n     #[lang = \"fn_once_output\"]\n     type Output;\n \n@@ -405,7 +408,7 @@ pub trait FnOnce<Args> {\n \n #[lang = \"fn_mut\"]\n #[rustc_paren_sugar]\n-pub trait FnMut<Args>: FnOnce<Args> {\n+pub trait FnMut<Args: Tuple>: FnOnce<Args> {\n     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n }\n \n@@ -418,8 +421,8 @@ pub fn panic(_msg: &'static str) -> ! {\n     }\n }\n \n-#[lang = \"panic_no_unwind\"]\n-fn panic_no_unwind() -> ! {\n+#[lang = \"panic_cannot_unwind\"]\n+fn panic_cannot_unwind() -> ! {\n     unsafe {\n         libc::puts(\"Panicking\\n\\0\" as *const str as *const u8);\n         intrinsics::abort();\n@@ -531,16 +534,22 @@ pub mod intrinsics {\n     use crate::Sized;\n \n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n+        #[rustc_safe_intrinsic]\n         pub fn size_of<T>() -> usize;\n         pub fn size_of_val<T: ?Sized>(val: *const T) -> usize;\n+        #[rustc_safe_intrinsic]\n         pub fn min_align_of<T>() -> usize;\n         pub fn min_align_of_val<T: ?Sized>(val: *const T) -> usize;\n         pub fn copy<T>(src: *const T, dst: *mut T, count: usize);\n         pub fn transmute<T, U>(e: T) -> U;\n         pub fn ctlz_nonzero<T>(x: T) -> T;\n+        #[rustc_safe_intrinsic]\n         pub fn needs_drop<T: ?Sized>() -> bool;\n+        #[rustc_safe_intrinsic]\n         pub fn bitreverse<T>(x: T) -> T;\n+        #[rustc_safe_intrinsic]\n         pub fn bswap<T>(x: T) -> T;\n         pub fn write_bytes<T>(dst: *mut T, val: u8, count: usize);\n         pub fn unreachable() -> !;"}, {"sha": "993a31e68eabc1ce647b1177da81474a29670ace", "filename": "example/mini_core_hello_world.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/example%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/example%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fmini_core_hello_world.rs?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -85,6 +85,7 @@ fn start<T: Termination + 'static>(\n     main: fn() -> T,\n     argc: isize,\n     argv: *const *const u8,\n+    _sigpipe: u8,\n ) -> isize {\n     if argc == 3 {\n         unsafe { puts(*argv); }"}, {"sha": "8539e27ea6a58352f5dc0f77b3b598051b37c05e", "filename": "failing-ui-tests.txt", "status": "modified", "additions": 68, "deletions": 60, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/failing-ui-tests.txt", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/failing-ui-tests.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/failing-ui-tests.txt?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -1,60 +1,68 @@\n-src/test/ui/alloc-error/default-alloc-error-hook.rs\n-src/test/ui/allocator/custom-in-block.rs\n-src/test/ui/allocator/custom-in-submodule.rs\n-src/test/ui/allocator/custom.rs\n-src/test/ui/allocator/hygiene.rs\n-src/test/ui/allocator/no_std-alloc-error-handler-custom.rs\n-src/test/ui/allocator/no_std-alloc-error-handler-default.rs\n-src/test/ui/allocator/xcrate-use.rs\n-src/test/ui/allocator/xcrate-use2.rs\n-src/test/ui/asm/may_unwind.rs\n-src/test/ui/asm/x86_64/multiple-clobber-abi.rs\n-src/test/ui/debuginfo/debuginfo-emit-llvm-ir-and-split-debuginfo.rs\n-src/test/ui/functions-closures/parallel-codegen-closures.rs\n-src/test/ui/linkage-attr/linkage1.rs\n-src/test/ui/lto/dylib-works.rs\n-src/test/ui/numbers-arithmetic/saturating-float-casts.rs\n-src/test/ui/polymorphization/promoted-function.rs\n-src/test/ui/process/nofile-limit.rs\n-src/test/ui/sepcomp/sepcomp-cci.rs\n-src/test/ui/sepcomp/sepcomp-extern.rs\n-src/test/ui/sepcomp/sepcomp-fns-backwards.rs\n-src/test/ui/sepcomp/sepcomp-fns.rs\n-src/test/ui/sepcomp/sepcomp-statics.rs\n-src/test/ui/simd/intrinsic/generic-arithmetic-pass.rs\n-src/test/ui/sse2.rs\n-src/test/ui/target-feature/missing-plusminus.rs\n-src/test/ui/asm/x86_64/may_unwind.rs\n-src/test/ui/backtrace.rs\n-src/test/ui/catch-unwind-bang.rs\n-src/test/ui/cfg/cfg-panic-abort.rs\n-src/test/ui/drop/dynamic-drop-async.rs\n-src/test/ui/drop/repeat-drop.rs\n-src/test/ui/fmt/format-args-capture.rs\n-src/test/ui/generator/panic-drops-resume.rs\n-src/test/ui/generator/panic-drops.rs\n-src/test/ui/generator/panic-safe.rs\n-src/test/ui/intrinsics/panic-uninitialized-zeroed.rs\n-src/test/ui/iterators/iter-sum-overflow-debug.rs\n-src/test/ui/iterators/iter-sum-overflow-overflow-checks.rs\n-src/test/ui/mir/mir_calls_to_shims.rs\n-src/test/ui/mir/mir_drop_order.rs\n-src/test/ui/mir/mir_let_chains_drop_order.rs\n-src/test/ui/oom_unwind.rs\n-src/test/ui/panic-runtime/abort-link-to-unwinding-crates.rs\n-src/test/ui/panic-runtime/abort.rs\n-src/test/ui/panic-runtime/link-to-abort.rs\n-src/test/ui/unwind-no-uwtable.rs\n-src/test/ui/issues/issue-14875.rs\n-src/test/ui/issues/issue-29948.rs\n-src/test/ui/issues/issue-40883.rs\n-src/test/ui/issues/issue-43853.rs\n-src/test/ui/issues/issue-47364.rs\n-src/test/ui/simd/issue-17170.rs\n-src/test/ui/simd/issue-39720.rs\n-src/test/ui/simd/issue-89193.rs\n-src/test/ui/statics/issue-91050-1.rs\n-src/test/ui/statics/issue-91050-2.rs\n-src/test/ui/macros/rfc-2011-nicer-assert-messages/assert-without-captures-does-not-create-unnecessary-code.rs\n-src/test/ui/rfc-2091-track-caller/std-panic-locations.rs\n-src/test/ui/rfcs/rfc1857-drop-order.rs\n+tests/ui/allocator/custom-in-block.rs\n+tests/ui/allocator/custom-in-submodule.rs\n+tests/ui/allocator/custom.rs\n+tests/ui/allocator/hygiene.rs\n+tests/ui/allocator/no_std-alloc-error-handler-custom.rs\n+tests/ui/allocator/no_std-alloc-error-handler-default.rs\n+tests/ui/allocator/xcrate-use.rs\n+tests/ui/allocator/xcrate-use2.rs\n+tests/ui/asm/may_unwind.rs\n+tests/ui/asm/x86_64/multiple-clobber-abi.rs\n+tests/ui/debuginfo/debuginfo-emit-llvm-ir-and-split-debuginfo.rs\n+tests/ui/functions-closures/parallel-codegen-closures.rs\n+tests/ui/linkage-attr/linkage1.rs\n+tests/ui/lto/dylib-works.rs\n+tests/ui/numbers-arithmetic/saturating-float-casts.rs\n+tests/ui/polymorphization/promoted-function.rs\n+tests/ui/process/nofile-limit.rs\n+tests/ui/sepcomp/sepcomp-cci.rs\n+tests/ui/sepcomp/sepcomp-extern.rs\n+tests/ui/sepcomp/sepcomp-fns-backwards.rs\n+tests/ui/sepcomp/sepcomp-fns.rs\n+tests/ui/sepcomp/sepcomp-statics.rs\n+tests/ui/simd/intrinsic/generic-arithmetic-pass.rs\n+tests/ui/sse2.rs\n+tests/ui/target-feature/missing-plusminus.rs\n+tests/ui/asm/x86_64/may_unwind.rs\n+tests/ui/backtrace.rs\n+tests/ui/catch-unwind-bang.rs\n+tests/ui/cfg/cfg-panic-abort.rs\n+tests/ui/drop/dynamic-drop-async.rs\n+tests/ui/drop/repeat-drop.rs\n+tests/ui/fmt/format-args-capture.rs\n+tests/ui/generator/panic-drops-resume.rs\n+tests/ui/generator/panic-drops.rs\n+tests/ui/intrinsics/panic-uninitialized-zeroed.rs\n+tests/ui/iterators/iter-sum-overflow-debug.rs\n+tests/ui/iterators/iter-sum-overflow-overflow-checks.rs\n+tests/ui/mir/mir_calls_to_shims.rs\n+tests/ui/mir/mir_drop_order.rs\n+tests/ui/mir/mir_let_chains_drop_order.rs\n+tests/ui/oom_unwind.rs\n+tests/ui/panic-runtime/abort-link-to-unwinding-crates.rs\n+tests/ui/panic-runtime/abort.rs\n+tests/ui/panic-runtime/link-to-abort.rs\n+tests/ui/unwind-no-uwtable.rs\n+tests/ui/parser/unclosed-delimiter-in-dep.rs\n+tests/ui/runtime/rt-explody-panic-payloads.rs\n+tests/ui/simd/intrinsic/ptr-cast.rs\n+tests/ui/binding/fn-arg-incomplete-pattern-drop-order.rs\n+tests/ui/consts/missing_span_in_backtrace.rs\n+tests/ui/drop/dynamic-drop.rs\n+tests/ui/dyn-star/box.rs\n+tests/ui/issues/issue-40883.rs\n+tests/ui/issues/issue-43853.rs\n+tests/ui/issues/issue-47364.rs\n+tests/ui/macros/rfc-2011-nicer-assert-messages/assert-without-captures-does-not-create-unnecessary-code.rs\n+tests/ui/rfc-2091-track-caller/std-panic-locations.rs\n+tests/ui/rfcs/rfc1857-drop-order.rs\n+tests/ui/simd/issue-17170.rs\n+tests/ui/simd/issue-39720.rs\n+tests/ui/simd/issue-89193.rs\n+tests/ui/statics/issue-91050-1.rs\n+tests/ui/statics/issue-91050-2.rs\n+tests/ui/alloc-error/default-alloc-error-hook.rs\n+tests/ui/generator/panic-safe.rs\n+tests/ui/issues/issue-14875.rs\n+tests/ui/issues/issue-29948.rs\n+tests/ui/panic-while-printing.rs"}, {"sha": "8c27bd8b8ca89f133210fa477dca33946f3e11e0", "filename": "failing-ui-tests12.txt", "status": "modified", "additions": 39, "deletions": 41, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/failing-ui-tests12.txt", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/failing-ui-tests12.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/failing-ui-tests12.txt?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -1,41 +1,39 @@\n-src/test/ui/asm/x86_64/issue-96797.rs\n-src/test/ui/intrinsics/const-eval-select-x86_64.rs\n-src/test/ui/packed/packed-struct-drop-aligned.rs\n-src/test/ui/packed/packed-struct-generic-layout.rs\n-src/test/ui/packed/packed-struct-layout.rs\n-src/test/ui/packed/packed-struct-optimized-enum.rs\n-src/test/ui/packed/packed-struct-size.rs\n-src/test/ui/packed/packed-struct-vec.rs\n-src/test/ui/packed/packed-tuple-struct-layout.rs\n-src/test/ui/simd/array-type.rs\n-src/test/ui/simd/intrinsic/float-minmax-pass.rs\n-src/test/ui/simd/intrinsic/generic-arithmetic-saturating-pass.rs\n-src/test/ui/simd/intrinsic/generic-as.rs\n-src/test/ui/simd/intrinsic/generic-cast-pass.rs\n-src/test/ui/simd/intrinsic/generic-cast-pointer-width.rs\n-src/test/ui/simd/intrinsic/generic-comparison-pass.rs\n-src/test/ui/simd/intrinsic/generic-elements-pass.rs\n-src/test/ui/simd/intrinsic/generic-reduction-pass.rs\n-src/test/ui/simd/intrinsic/generic-select-pass.rs\n-src/test/ui/simd/intrinsic/inlining-issue67557-ice.rs\n-src/test/ui/simd/intrinsic/inlining-issue67557.rs\n-src/test/ui/simd/monomorphize-shuffle-index.rs\n-src/test/ui/simd/shuffle.rs\n-src/test/ui/simd/simd-bitmask.rs\n-src/test/ui/binding/fn-arg-incomplete-pattern-drop-order.rs\n-src/test/ui/drop/dynamic-drop.rs\n-src/test/ui/generator/resume-after-return.rs\n-src/test/ui/iterators/iter-step-overflow-debug.rs\n-src/test/ui/macros/rfc-2011-nicer-assert-messages/all-expr-kinds.rs\n-src/test/ui/numbers-arithmetic/next-power-of-two-overflow-debug.rs\n-src/test/ui/panic-while-printing.rs\n-src/test/ui/privacy/reachable-unnameable-items.rs\n-src/test/ui/rfc-1937-termination-trait/termination-trait-in-test.rs\n-src/test/ui/async-await/async-fn-size-moved-locals.rs\n-src/test/ui/async-await/async-fn-size-uninit-locals.rs\n-src/test/ui/cfg/cfg-panic.rs\n-src/test/ui/generator/size-moved-locals.rs\n-src/test/ui/macros/rfc-2011-nicer-assert-messages/all-not-available-cases.rs\n-src/test/ui/runtime/rt-explody-panic-payloads.rs\n-src/test/ui/simd/intrinsic/generic-gather-pass.rs\n-src/test/ui/simd/issue-85915-simd-ptrs.rs\n+tests/ui/asm/x86_64/issue-96797.rs\n+tests/ui/intrinsics/const-eval-select-x86_64.rs\n+tests/ui/packed/packed-struct-drop-aligned.rs\n+tests/ui/packed/packed-struct-generic-layout.rs\n+tests/ui/packed/packed-struct-layout.rs\n+tests/ui/packed/packed-struct-optimized-enum.rs\n+tests/ui/packed/packed-struct-size.rs\n+tests/ui/packed/packed-struct-vec.rs\n+tests/ui/packed/packed-tuple-struct-layout.rs\n+tests/ui/simd/array-type.rs\n+tests/ui/simd/intrinsic/float-minmax-pass.rs\n+tests/ui/simd/intrinsic/generic-arithmetic-saturating-pass.rs\n+tests/ui/simd/intrinsic/generic-as.rs\n+tests/ui/simd/intrinsic/generic-cast-pass.rs\n+tests/ui/simd/intrinsic/generic-cast-pointer-width.rs\n+tests/ui/simd/intrinsic/generic-comparison-pass.rs\n+tests/ui/simd/intrinsic/generic-elements-pass.rs\n+tests/ui/simd/intrinsic/generic-reduction-pass.rs\n+tests/ui/simd/intrinsic/generic-select-pass.rs\n+tests/ui/simd/intrinsic/inlining-issue67557-ice.rs\n+tests/ui/simd/intrinsic/inlining-issue67557.rs\n+tests/ui/simd/monomorphize-shuffle-index.rs\n+tests/ui/simd/shuffle.rs\n+tests/ui/simd/simd-bitmask.rs\n+tests/ui/generator/resume-after-return.rs\n+tests/ui/iterators/iter-step-overflow-debug.rs\n+tests/ui/macros/rfc-2011-nicer-assert-messages/all-expr-kinds.rs\n+tests/ui/numbers-arithmetic/next-power-of-two-overflow-debug.rs\n+tests/ui/privacy/reachable-unnameable-items.rs\n+tests/ui/rfc-1937-termination-trait/termination-trait-in-test.rs\n+tests/ui/async-await/async-fn-size-moved-locals.rs\n+tests/ui/async-await/async-fn-size-uninit-locals.rs\n+tests/ui/cfg/cfg-panic.rs\n+tests/ui/generator/size-moved-locals.rs\n+tests/ui/macros/rfc-2011-nicer-assert-messages/all-not-available-cases.rs\n+tests/ui/simd/intrinsic/generic-gather-pass.rs\n+tests/ui/simd/issue-85915-simd-ptrs.rs\n+tests/ui/issues/issue-68010-large-zst-consts.rs\n+tests/ui/rust-2018/proc-macro-crate-in-paths.rs"}, {"sha": "2181d49eeef6bcce00c2a9207bf44c72f7cc95ef", "filename": "locales/en-US.ftl", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/locales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/locales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/locales%2Fen-US.ftl?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -0,0 +1,65 @@\n+codegen_gcc_unwinding_inline_asm =\n+    GCC backend does not support unwinding from inline asm\n+\n+codegen_gcc_lto_not_supported =\n+    LTO is not supported. You may get a linker error.\n+\n+codegen_gcc_invalid_monomorphization_basic_integer =\n+    invalid monomorphization of `{$name}` intrinsic: expected basic integer type, found `{$ty}`\n+\n+codegen_gcc_invalid_monomorphization_invalid_float_vector =\n+    invalid monomorphization of `{$name}` intrinsic: unsupported element type `{$elem_ty}` of floating-point vector `{$vec_ty}`\n+\n+codegen_gcc_invalid_monomorphization_not_float =\n+    invalid monomorphization of `{$name}` intrinsic: `{$ty}` is not a floating-point type\n+\n+codegen_gcc_invalid_monomorphization_unrecognized =\n+    invalid monomorphization of `{$name}` intrinsic: unrecognized intrinsic `{$name}`\n+\n+codegen_gcc_invalid_monomorphization_expected_signed_unsigned =\n+    invalid monomorphization of `{$name}` intrinsic: expected element type `{$elem_ty}` of vector type `{$vec_ty}` to be a signed or unsigned integer type\n+\n+codegen_gcc_invalid_monomorphization_unsupported_element =\n+    invalid monomorphization of `{$name}` intrinsic: unsupported {$name} from `{$in_ty}` with element `{$elem_ty}` to `{$ret_ty}`\n+\n+codegen_gcc_invalid_monomorphization_invalid_bitmask =\n+    invalid monomorphization of `{$name}` intrinsic: invalid bitmask `{$ty}`, expected `u{$expected_int_bits}` or `[u8; {$expected_bytes}]`\n+\n+codegen_gcc_invalid_monomorphization_simd_shuffle =\n+    invalid monomorphization of `{$name}` intrinsic: simd_shuffle index must be an array of `u32`, got `{$ty}`\n+\n+codegen_gcc_invalid_monomorphization_expected_simd =\n+    invalid monomorphization of `{$name}` intrinsic: expected SIMD {$expected_ty} type, found non-SIMD `{$found_ty}`\n+\n+codegen_gcc_invalid_monomorphization_mask_type =\n+    invalid monomorphization of `{$name}` intrinsic: mask element type is `{$ty}`, expected `i_`\n+\n+codegen_gcc_invalid_monomorphization_return_length =\n+    invalid monomorphization of `{$name}` intrinsic: expected return type of length {$in_len}, found `{$ret_ty}` with length {$out_len}\n+\n+codegen_gcc_invalid_monomorphization_return_length_input_type =\n+    invalid monomorphization of `{$name}` intrinsic: expected return type with length {$in_len} (same as input type `{$in_ty}`), found `{$ret_ty}` with length {$out_len}\n+\n+codegen_gcc_invalid_monomorphization_return_element =\n+    invalid monomorphization of `{$name}` intrinsic: expected return element type `{$in_elem}` (element of input `{$in_ty}`), found `{$ret_ty}` with element type `{$out_ty}`\n+\n+codegen_gcc_invalid_monomorphization_return_type =\n+    invalid monomorphization of `{$name}` intrinsic: expected return type `{$in_elem}` (element of input `{$in_ty}`), found `{$ret_ty}`\n+\n+codegen_gcc_invalid_monomorphization_inserted_type =\n+    invalid monomorphization of `{$name}` intrinsic: expected inserted type `{$in_elem}` (element of input `{$in_ty}`), found `{$out_ty}`\n+\n+codegen_gcc_invalid_monomorphization_return_integer_type =\n+    invalid monomorphization of `{$name}` intrinsic: expected return type with integer elements, found `{$ret_ty}` with non-integer `{$out_ty}`\n+\n+codegen_gcc_invalid_monomorphization_mismatched_lengths =\n+    invalid monomorphization of `{$name}` intrinsic: mismatched lengths: mask length `{$m_len}` != other vector length `{$v_len}`\n+\n+codegen_gcc_invalid_monomorphization_unsupported_cast =\n+    invalid monomorphization of `{$name}` intrinsic: unsupported cast from `{$in_ty}` with element `{$in_elem}` to `{$ret_ty}` with element `{$out_elem}`\n+\n+codegen_gcc_invalid_monomorphization_unsupported_operation =\n+    invalid monomorphization of `{$name}` intrinsic: unsupported operation on `{$in_ty}` with element `{$in_elem}`\n+\n+codegen_gcc_invalid_minimum_alignment =\n+    invalid minimum global alignment: {$err}"}, {"sha": "4db56fa3bd2c7667f525f8db752ef5c84d75f290", "filename": "patches/0022-core-Disable-not-compiling-tests.patch", "status": "modified", "additions": 14, "deletions": 33, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/patches%2F0022-core-Disable-not-compiling-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/patches%2F0022-core-Disable-not-compiling-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/patches%2F0022-core-Disable-not-compiling-tests.patch?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -18,7 +18,7 @@ new file mode 100644\n index 0000000..46fd999\n --- /dev/null\n +++ b/library/core/tests/Cargo.toml\n-@@ -0,0 +1,8 @@\n+@@ -0,0 +1,12 @@\n +[package]\n +name = \"core\"\n +version = \"0.0.0\"\n@@ -27,37 +27,18 @@ index 0000000..46fd999\n +[lib]\n +name = \"coretests\"\n +path = \"lib.rs\"\n-diff --git a/library/core/tests/num/flt2dec/mod.rs b/library/core/tests/num/flt2dec/mod.rs\n-index a35897e..f0bf645 100644\n---- a/library/core/tests/num/flt2dec/mod.rs\n-+++ b/library/core/tests/num/flt2dec/mod.rs\n-@@ -13,7 +13,6 @@ mod strategy {\n-     mod dragon;\n-     mod grisu;\n- }\n--mod random;\n- \n- pub fn decode_finite<T: DecodableFloat>(v: T) -> Decoded {\n-     match decode(v).1 {\n-diff --git a/library/core/tests/slice.rs b/library/core/tests/slice.rs\n-index 6609bc3..241b497 100644\n---- a/library/core/tests/slice.rs\n-+++ b/library/core/tests/slice.rs\n-@@ -1209,6 +1209,7 @@ fn brute_force_rotate_test_1() {\n-     }\n- }\n- \n-+/*\n- #[test]\n- #[cfg(not(target_arch = \"wasm32\"))]\n- fn sort_unstable() {\n-@@ -1394,6 +1395,7 @@ fn partition_at_index() {\n-     v.select_nth_unstable(0);\n-     assert!(v == [0xDEADBEEF]);\n- }\n-+*/\n- \n- #[test]\n- #[should_panic(expected = \"index 0 greater than length of slice\")]\n++\n++[dependencies]\n++rand = { version = \"0.8.5\", default-features = false }\n++rand_xorshift = { version = \"0.3.0\", default-features = false }\n+diff --git a/library/core/tests/lib.rs b/library/core/tests/lib.rs\n+index 42a26ae..5ac1042 100644\n+--- a/library/core/tests/lib.rs\n++++ b/library/core/tests/lib.rs\n+@@ -1,3 +1,4 @@\n++#![cfg(test)]\n+ #![feature(alloc_layout_extra)]\n+ #![feature(array_chunks)]\n+ #![feature(array_methods)]\n --\n 2.21.0 (Apple Git-122)"}, {"sha": "7ea0eebe6a128c64f1f8918009f080099eb83222", "filename": "patches/0024-core-Disable-portable-simd-test.patch", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8c3c02097d9d7be20a576bc067cbefc258d8c592/patches%2F0024-core-Disable-portable-simd-test.patch", "raw_url": "https://github.com/rust-lang/rust/raw/8c3c02097d9d7be20a576bc067cbefc258d8c592/patches%2F0024-core-Disable-portable-simd-test.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/patches%2F0024-core-Disable-portable-simd-test.patch?ref=8c3c02097d9d7be20a576bc067cbefc258d8c592", "patch": "@@ -1,32 +0,0 @@\n-From f845df4056f5ba16b9f5bd703460c4ac40ea03b9 Mon Sep 17 00:00:00 2001\n-From: Antoni Boucher <bouanto@zoho.com>\n-Date: Fri, 26 Aug 2022 20:38:58 -0400\n-Subject: [PATCH] Edit\n-\n----\n- library/core/tests/lib.rs | 2 --\n- 1 file changed, 2 deletions(-)\n-\n-diff --git a/library/core/tests/lib.rs b/library/core/tests/lib.rs\n-index 59510d3..179bf26 100644\n---- a/library/core/tests/lib.rs\n-+++ b/library/core/tests/lib.rs\n-@@ -77,7 +77,6 @@\n- #![feature(unwrap_infallible)]\n- #![feature(result_into_ok_or_err)]\n- #![feature(pointer_byte_offsets)]\n--#![feature(portable_simd)]\n- #![feature(ptr_metadata)]\n- #![feature(once_cell)]\n- #![feature(option_result_contains)]\n-@@ -135,7 +134,6 @@ mod pin;\n- mod pin_macro;\n- mod ptr;\n- mod result;\n--mod simd;\n- mod slice;\n- mod str;\n- mod str_lossy;\n--- \n-2.26.2.7.g19db9cfb68.dirty\n-"}, {"sha": "933ecd45baadb63632cbd08ba7431e1a9e6ef077", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2022-08-26\"\n+channel = \"nightly-2023-03-02\"\n components = [\"rust-src\", \"rustc-dev\", \"llvm-tools-preview\"]"}, {"sha": "6fb1cbfad8cd3a422ef427b0797e8ac9af1b97cf", "filename": "src/abi.rs", "status": "modified", "additions": 12, "deletions": 31, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/src%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/src%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi.rs?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -11,10 +11,6 @@ use crate::intrinsic::ArgAbiExt;\n use crate::type_of::LayoutGccExt;\n \n impl<'a, 'gcc, 'tcx> AbiBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n-    fn apply_attrs_callsite(&mut self, _fn_abi: &FnAbi<'tcx, Ty<'tcx>>, _callsite: Self::Value) {\n-        // TODO(antoyo)\n-    }\n-\n     fn get_param(&mut self, index: usize) -> Self::Value {\n         let func = self.current_func();\n         let param = func.get_param(index as i32);\n@@ -107,45 +103,24 @@ pub trait FnAbiGccExt<'gcc, 'tcx> {\n impl<'gcc, 'tcx> FnAbiGccExt<'gcc, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n     fn gcc_type(&self, cx: &CodegenCx<'gcc, 'tcx>) -> (Type<'gcc>, Vec<Type<'gcc>>, bool, FxHashSet<usize>) {\n         let mut on_stack_param_indices = FxHashSet::default();\n-        let args_capacity: usize = self.args.iter().map(|arg|\n-            if arg.pad.is_some() {\n-                1\n-            }\n-            else {\n-                0\n-            } +\n-            if let PassMode::Pair(_, _) = arg.mode {\n-                2\n-            } else {\n-                1\n-            }\n-        ).sum();\n+\n+        // This capacity calculation is approximate.\n         let mut argument_tys = Vec::with_capacity(\n-            if let PassMode::Indirect { .. } = self.ret.mode {\n-                1\n-            }\n-            else {\n-                0\n-            } + args_capacity,\n+            self.args.len() + if let PassMode::Indirect { .. } = self.ret.mode { 1 } else { 0 }\n         );\n \n         let return_ty =\n             match self.ret.mode {\n                 PassMode::Ignore => cx.type_void(),\n                 PassMode::Direct(_) | PassMode::Pair(..) => self.ret.layout.immediate_gcc_type(cx),\n-                PassMode::Cast(cast) => cast.gcc_type(cx),\n+                PassMode::Cast(ref cast, _) => cast.gcc_type(cx),\n                 PassMode::Indirect { .. } => {\n                     argument_tys.push(cx.type_ptr_to(self.ret.memory_ty(cx)));\n                     cx.type_void()\n                 }\n             };\n \n-        for arg in &self.args {\n-            // add padding\n-            if let Some(ty) = arg.pad {\n-                argument_tys.push(ty.gcc_type(cx));\n-            }\n-\n+        for arg in self.args.iter() {\n             let arg_ty = match arg.mode {\n                 PassMode::Ignore => continue,\n                 PassMode::Direct(_) => arg.layout.immediate_gcc_type(cx),\n@@ -157,7 +132,13 @@ impl<'gcc, 'tcx> FnAbiGccExt<'gcc, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n                 PassMode::Indirect { extra_attrs: Some(_), .. } => {\n                     unimplemented!();\n                 }\n-                PassMode::Cast(cast) => cast.gcc_type(cx),\n+                PassMode::Cast(ref cast, pad_i32) => {\n+                    // add padding\n+                    if pad_i32 {\n+                        argument_tys.push(Reg::i32().gcc_type(cx));\n+                    }\n+                    cast.gcc_type(cx)\n+                }\n                 PassMode::Indirect { extra_attrs: None, on_stack: true, .. } => {\n                     on_stack_param_indices.insert(argument_tys.len());\n                     arg.memory_ty(cx)"}, {"sha": "4bad33ee879ee4f1c27ba1c2e1352f98c483d9e1", "filename": "src/allocator.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/src%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/src%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fallocator.rs?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -9,7 +9,7 @@ use rustc_span::symbol::sym;\n \n use crate::GccContext;\n \n-pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_name: &str, kind: AllocatorKind, has_alloc_error_handler: bool) {\n+pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_name: &str, kind: AllocatorKind, alloc_error_handler_kind: AllocatorKind) {\n     let context = &mods.context;\n     let usize =\n         match tcx.sess.target.pointer_width {\n@@ -99,14 +99,7 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_nam\n         func.add_attribute(FnAttribute::Visibility(gccjit::Visibility::Hidden));\n     }\n \n-    let kind =\n-        if has_alloc_error_handler {\n-            AllocatorKind::Global\n-        }\n-        else {\n-            AllocatorKind::Default\n-        };\n-    let callee = kind.fn_name(sym::oom);\n+    let callee = alloc_error_handler_kind.fn_name(sym::oom);\n     let args: Vec<_> = types.iter().enumerate()\n         .map(|(index, typ)| context.new_parameter(None, *typ, &format!(\"param{}\", index)))\n         .collect();"}, {"sha": "11fa074f5ac79e81a9902d8b93c5ce9839727423", "filename": "src/archive.rs", "status": "modified", "additions": 7, "deletions": 169, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/src%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/src%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Farchive.rs?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -1,42 +1,17 @@\n-use std::fs::File;\n use std::path::{Path, PathBuf};\n \n-use rustc_codegen_ssa::back::archive::{ArchiveBuilder, ArchiveBuilderBuilder};\n+use rustc_codegen_ssa::back::archive::{\n+    get_native_object_symbols, ArArchiveBuilder, ArchiveBuilder, ArchiveBuilderBuilder,\n+};\n use rustc_session::Session;\n \n use rustc_session::cstore::DllImport;\n \n-struct ArchiveConfig<'a> {\n-    sess: &'a Session,\n-    use_native_ar: bool,\n-    use_gnu_style_archive: bool,\n-}\n-\n-#[derive(Debug)]\n-enum ArchiveEntry {\n-    FromArchive {\n-        archive_index: usize,\n-        entry_index: usize,\n-    },\n-    File(PathBuf),\n-}\n-\n-pub struct ArArchiveBuilderBuilder;\n+pub(crate) struct ArArchiveBuilderBuilder;\n \n impl ArchiveBuilderBuilder for ArArchiveBuilderBuilder {\n     fn new_archive_builder<'a>(&self, sess: &'a Session) -> Box<dyn ArchiveBuilder<'a> + 'a> {\n-        let config = ArchiveConfig {\n-            sess,\n-            use_native_ar: false,\n-            // FIXME test for linux and System V derivatives instead\n-            use_gnu_style_archive: sess.target.options.archive_format == \"gnu\",\n-        };\n-\n-        Box::new(ArArchiveBuilder {\n-            config,\n-            src_archives: vec![],\n-            entries: vec![],\n-        })\n+        Box::new(ArArchiveBuilder::new(sess, get_native_object_symbols))\n     }\n \n     fn create_dll_import_lib(\n@@ -45,145 +20,8 @@ impl ArchiveBuilderBuilder for ArArchiveBuilderBuilder {\n         _lib_name: &str,\n         _dll_imports: &[DllImport],\n         _tmpdir: &Path,\n+        _is_direct_dependency: bool,\n     ) -> PathBuf {\n-        unimplemented!();\n-    }\n-}\n-\n-pub struct ArArchiveBuilder<'a> {\n-    config: ArchiveConfig<'a>,\n-    src_archives: Vec<(PathBuf, ar::Archive<File>)>,\n-    // Don't use `HashMap` here, as the order is important. `rust.metadata.bin` must always be at\n-    // the end of an archive for linkers to not get confused.\n-    entries: Vec<(String, ArchiveEntry)>,\n-}\n-\n-impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n-    fn add_file(&mut self, file: &Path) {\n-        self.entries.push((\n-            file.file_name().unwrap().to_str().unwrap().to_string(),\n-            ArchiveEntry::File(file.to_owned()),\n-        ));\n-    }\n-\n-    fn add_archive(\n-        &mut self,\n-        archive_path: &Path,\n-        mut skip: Box<dyn FnMut(&str) -> bool + 'static>,\n-    ) -> std::io::Result<()> {\n-        let mut archive = ar::Archive::new(std::fs::File::open(&archive_path)?);\n-        let archive_index = self.src_archives.len();\n-\n-        let mut i = 0;\n-        while let Some(entry) = archive.next_entry() {\n-            let entry = entry?;\n-            let file_name = String::from_utf8(entry.header().identifier().to_vec())\n-                .map_err(|err| std::io::Error::new(std::io::ErrorKind::InvalidData, err))?;\n-            if !skip(&file_name) {\n-                self.entries\n-                    .push((file_name, ArchiveEntry::FromArchive { archive_index, entry_index: i }));\n-            }\n-            i += 1;\n-        }\n-\n-        self.src_archives.push((archive_path.to_owned(), archive));\n-        Ok(())\n-    }\n-\n-    fn build(mut self: Box<Self>, output: &Path) -> bool {\n-        use std::process::Command;\n-\n-        fn add_file_using_ar(archive: &Path, file: &Path) {\n-            Command::new(\"ar\")\n-                .arg(\"r\") // add or replace file\n-                .arg(\"-c\") // silence created file message\n-                .arg(archive)\n-                .arg(&file)\n-                .status()\n-                .unwrap();\n-        }\n-\n-        enum BuilderKind<'a> {\n-            Bsd(ar::Builder<File>),\n-            Gnu(ar::GnuBuilder<File>),\n-            NativeAr(&'a Path),\n-        }\n-\n-        let mut builder = if self.config.use_native_ar {\n-            BuilderKind::NativeAr(output)\n-        } else if self.config.use_gnu_style_archive {\n-            BuilderKind::Gnu(ar::GnuBuilder::new(\n-                File::create(output).unwrap(),\n-                self.entries\n-                    .iter()\n-                    .map(|(name, _)| name.as_bytes().to_vec())\n-                    .collect(),\n-            ))\n-        } else {\n-            BuilderKind::Bsd(ar::Builder::new(File::create(output).unwrap()))\n-        };\n-\n-        let any_members = !self.entries.is_empty();\n-\n-        // Add all files\n-        for (entry_name, entry) in self.entries.into_iter() {\n-            match entry {\n-                ArchiveEntry::FromArchive {\n-                    archive_index,\n-                    entry_index,\n-                } => {\n-                    let (ref src_archive_path, ref mut src_archive) =\n-                        self.src_archives[archive_index];\n-                    let entry = src_archive.jump_to_entry(entry_index).unwrap();\n-                    let header = entry.header().clone();\n-\n-                    match builder {\n-                        BuilderKind::Bsd(ref mut builder) => {\n-                            builder.append(&header, entry).unwrap()\n-                        }\n-                        BuilderKind::Gnu(ref mut builder) => {\n-                            builder.append(&header, entry).unwrap()\n-                        }\n-                        BuilderKind::NativeAr(archive_file) => {\n-                            Command::new(\"ar\")\n-                                .arg(\"x\")\n-                                .arg(src_archive_path)\n-                                .arg(&entry_name)\n-                                .status()\n-                                .unwrap();\n-                            add_file_using_ar(archive_file, Path::new(&entry_name));\n-                            std::fs::remove_file(entry_name).unwrap();\n-                        }\n-                    }\n-                }\n-                ArchiveEntry::File(file) =>\n-                    match builder {\n-                        BuilderKind::Bsd(ref mut builder) => {\n-                            builder\n-                                .append_file(entry_name.as_bytes(), &mut File::open(file).expect(\"file for bsd builder\"))\n-                                .unwrap()\n-                        },\n-                        BuilderKind::Gnu(ref mut builder) => {\n-                            builder\n-                                .append_file(entry_name.as_bytes(), &mut File::open(&file).expect(&format!(\"file {:?} for gnu builder\", file)))\n-                                .unwrap()\n-                        },\n-                        BuilderKind::NativeAr(archive_file) => add_file_using_ar(archive_file, &file),\n-                    },\n-            }\n-        }\n-\n-        // Finalize archive\n-        std::mem::drop(builder);\n-\n-        // Run ranlib to be able to link the archive\n-        let status =\n-            std::process::Command::new(\"ranlib\").arg(output).status().expect(\"Couldn't run ranlib\");\n-\n-        if !status.success() {\n-            self.config.sess.fatal(&format!(\"Ranlib exited with code {:?}\", status.code()));\n-        }\n-\n-        any_members\n+        unimplemented!(\"creating dll imports is not yet supported\");\n     }\n }"}, {"sha": "41e9d61a10e50b53dd5b280cc7c1a1e236d163a8", "filename": "src/asm.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/src%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/src%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fasm.rs?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -12,6 +12,7 @@ use std::borrow::Cow;\n \n use crate::builder::Builder;\n use crate::context::CodegenCx;\n+use crate::errors::UnwindingInlineAsm;\n use crate::type_of::LayoutGccExt;\n use crate::callee::get_fn;\n \n@@ -109,7 +110,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n     fn codegen_inline_asm(&mut self, template: &[InlineAsmTemplatePiece], rust_operands: &[InlineAsmOperandRef<'tcx, Self>], options: InlineAsmOptions, span: &[Span], _instance: Instance<'_>, _dest_catch_funclet: Option<(Self::BasicBlock, Self::BasicBlock, Option<&Self::Funclet>)>) {\n         if options.contains(InlineAsmOptions::MAY_UNWIND) {\n             self.sess()\n-                .struct_span_err(span[0], \"GCC backend does not support unwinding from inline asm\")\n+                .create_err(UnwindingInlineAsm { span: span[0] })\n                 .emit();\n             return;\n         }\n@@ -500,7 +501,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n         if options.contains(InlineAsmOptions::NORETURN) {\n             let builtin_unreachable = self.context.get_builtin_function(\"__builtin_unreachable\");\n             let builtin_unreachable: RValue<'gcc> = unsafe { std::mem::transmute(builtin_unreachable) };\n-            self.call(self.type_void(), builtin_unreachable, &[], None);\n+            self.call(self.type_void(), None, builtin_unreachable, &[], None);\n         }\n \n         // Write results to outputs."}, {"sha": "dcd560b3dcd952efe7d81228ac4403d1f8b748ab", "filename": "src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -63,7 +63,7 @@ pub fn linkage_to_gcc(linkage: Linkage) -> FunctionType {\n     }\n }\n \n-pub fn compile_codegen_unit<'tcx>(tcx: TyCtxt<'tcx>, cgu_name: Symbol, supports_128bit_integers: bool) -> (ModuleCodegen<GccContext>, u64) {\n+pub fn compile_codegen_unit(tcx: TyCtxt<'_>, cgu_name: Symbol, supports_128bit_integers: bool) -> (ModuleCodegen<GccContext>, u64) {\n     let prof_timer = tcx.prof.generic_activity(\"codegen_module\");\n     let start_time = Instant::now();\n "}, {"sha": "a3c8142bea2db08c0f669a9112e1878bc723d81b", "filename": "src/builder.rs", "status": "modified", "additions": 211, "deletions": 47, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/src%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/src%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuilder.rs?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -15,8 +15,11 @@ use gccjit::{\n     Type,\n     UnaryOp,\n };\n+use rustc_apfloat::{ieee, Float, Round, Status};\n use rustc_codegen_ssa::MemFlags;\n-use rustc_codegen_ssa::common::{AtomicOrdering, AtomicRmwBinOp, IntPredicate, RealPredicate, SynchronizationScope};\n+use rustc_codegen_ssa::common::{\n+    AtomicOrdering, AtomicRmwBinOp, IntPredicate, RealPredicate, SynchronizationScope, TypeKind,\n+};\n use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{\n@@ -31,6 +34,7 @@ use rustc_codegen_ssa::traits::{\n     StaticBuilderMethods,\n };\n use rustc_data_structures::fx::FxHashSet;\n+use rustc_middle::bug;\n use rustc_middle::ty::{ParamEnv, Ty, TyCtxt};\n use rustc_middle::ty::layout::{FnAbiError, FnAbiOfHelpers, FnAbiRequest, HasParamEnv, HasTyCtxt, LayoutError, LayoutOfHelpers, TyAndLayout};\n use rustc_span::Span;\n@@ -451,12 +455,12 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     #[cfg(feature=\"master\")]\n-    fn invoke(&mut self, typ: Type<'gcc>, func: RValue<'gcc>, args: &[RValue<'gcc>], then: Block<'gcc>, catch: Block<'gcc>, _funclet: Option<&Funclet>) -> RValue<'gcc> {\n+    fn invoke(&mut self, typ: Type<'gcc>, _fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>, func: RValue<'gcc>, args: &[RValue<'gcc>], then: Block<'gcc>, catch: Block<'gcc>, _funclet: Option<&Funclet>) -> RValue<'gcc> {\n         let try_block = self.current_func().new_block(\"try\");\n \n         let current_block = self.block.clone();\n         self.block = try_block;\n-        let call = self.call(typ, func, args, None); // TODO(antoyo): use funclet here?\n+        let call = self.call(typ, None, func, args, None); // TODO(antoyo): use funclet here?\n         self.block = current_block;\n \n         let return_value = self.current_func()\n@@ -479,10 +483,13 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     #[cfg(not(feature=\"master\"))]\n-    fn invoke(&mut self, typ: Type<'gcc>, func: RValue<'gcc>, args: &[RValue<'gcc>], then: Block<'gcc>, catch: Block<'gcc>, _funclet: Option<&Funclet>) -> RValue<'gcc> {\n-        let call_site = self.call(typ, func, args, None);\n+    fn invoke(&mut self, typ: Type<'gcc>, fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>, func: RValue<'gcc>, args: &[RValue<'gcc>], then: Block<'gcc>, catch: Block<'gcc>, _funclet: Option<&Funclet>) -> RValue<'gcc> {\n+        let call_site = self.call(typ, None, func, args, None);\n         let condition = self.context.new_rvalue_from_int(self.bool_type, 1);\n         self.llbb().end_with_conditional(None, condition, then, catch);\n+        if let Some(_fn_abi) = fn_abi {\n+            // TODO(bjorn3): Apply function attributes\n+        }\n         call_site\n     }\n \n@@ -707,11 +714,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         self.current_func().new_local(None, aligned_type, &format!(\"stack_var_{}\", self.stack_var_count.get())).get_address(None)\n     }\n \n-    fn dynamic_alloca(&mut self, _ty: Type<'gcc>, _align: Align) -> RValue<'gcc> {\n-        unimplemented!();\n-    }\n-\n-    fn array_alloca(&mut self, _ty: Type<'gcc>, _len: RValue<'gcc>, _align: Align) -> RValue<'gcc> {\n+    fn byte_array_alloca(&mut self, _len: RValue<'gcc>, _align: Align) -> RValue<'gcc> {\n         unimplemented!();\n     }\n \n@@ -765,7 +768,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n                         bx.range_metadata(load, vr);\n                     }\n                 }\n-                abi::Pointer if vr.start < vr.end && !vr.contains(0) => {\n+                abi::Pointer(_) if vr.start < vr.end && !vr.contains(0) => {\n                     bx.nonnull_metadata(load);\n                 }\n                 _ => {}\n@@ -811,11 +814,11 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         OperandRef { val, layout: place.layout }\n     }\n \n-    fn write_operand_repeatedly(mut self, cg_elem: OperandRef<'tcx, RValue<'gcc>>, count: u64, dest: PlaceRef<'tcx, RValue<'gcc>>) -> Self {\n+    fn write_operand_repeatedly(&mut self, cg_elem: OperandRef<'tcx, RValue<'gcc>>, count: u64, dest: PlaceRef<'tcx, RValue<'gcc>>) {\n         let zero = self.const_usize(0);\n         let count = self.const_usize(count);\n-        let start = dest.project_index(&mut self, zero).llval;\n-        let end = dest.project_index(&mut self, count).llval;\n+        let start = dest.project_index(self, zero).llval;\n+        let end = dest.project_index(self, count).llval;\n \n         let header_bb = self.append_sibling_block(\"repeat_loop_header\");\n         let body_bb = self.append_sibling_block(\"repeat_loop_body\");\n@@ -834,14 +837,13 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n \n         self.switch_to_block(body_bb);\n         let align = dest.align.restrict_for_offset(dest.layout.field(self.cx(), 0).size);\n-        cg_elem.val.store(&mut self, PlaceRef::new_sized_aligned(current_val, cg_elem.layout, align));\n+        cg_elem.val.store(self, PlaceRef::new_sized_aligned(current_val, cg_elem.layout, align));\n \n         let next = self.inbounds_gep(self.backend_type(cg_elem.layout), current.to_rvalue(), &[self.const_usize(1)]);\n         self.llbb().add_assignment(None, current, next);\n         self.br(header_bb);\n \n         self.switch_to_block(next_bb);\n-        self\n     }\n \n     fn range_metadata(&mut self, _load: RValue<'gcc>, _range: WrappingRange) {\n@@ -1106,7 +1108,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         let vector_type = vec.get_type().unqualified().dyncast_vector().expect(\"Called extract_element on a non-vector type\");\n         let element_type = vector_type.get_element_type();\n         let vec_num_units = vector_type.get_num_units();\n-        let array_type = self.context.new_array_type(None, element_type, vec_num_units as i32);\n+        let array_type = self.context.new_array_type(None, element_type, vec_num_units as u64);\n         let array = self.context.new_bitcast(None, vec, array_type).to_rvalue();\n         self.context.new_array_access(None, array, idx).to_rvalue()\n     }\n@@ -1197,7 +1199,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     #[cfg(feature=\"master\")]\n-    fn cleanup_landing_pad(&mut self, _ty: Type<'gcc>, pers_fn: RValue<'gcc>) -> RValue<'gcc> {\n+    fn cleanup_landing_pad(&mut self, pers_fn: RValue<'gcc>) -> (RValue<'gcc>, RValue<'gcc>) {\n         self.set_personality_fn(pers_fn);\n \n         // NOTE: insert the current block in a variable so that a later call to invoke knows to\n@@ -1208,42 +1210,33 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         let zero = self.cx.context.new_rvalue_zero(self.int_type);\n         let ptr = self.cx.context.new_call(None, eh_pointer_builtin, &[zero]);\n \n-        let field1_type = self.u8_type.make_pointer();\n-        let field1 = self.context.new_field(None, field1_type, \"landing_pad_field_1\");\n-        let field2 = self.context.new_field(None, self.i32_type, \"landing_pad_field_2\");\n-        let struct_type = self.context.new_struct_type(None, \"landing_pad\", &[field1, field2]);\n-        let value = self.current_func().new_local(None, struct_type.as_type(), \"landing_pad\");\n-        let ptr = self.cx.context.new_cast(None, ptr, field1_type);\n-        self.block.add_assignment(None, value.access_field(None, field1), ptr);\n-        self.block.add_assignment(None, value.access_field(None, field2), zero); // TODO(antoyo): set the proper value here (the type of exception?).\n+        let value1_type = self.u8_type.make_pointer();\n+        let ptr = self.cx.context.new_cast(None, ptr, value1_type);\n+        let value1 = ptr;\n+        let value2 = zero; // TODO(antoyo): set the proper value here (the type of exception?).\n \n-        value.to_rvalue()\n+        (value1, value2)\n     }\n \n     #[cfg(not(feature=\"master\"))]\n-    fn cleanup_landing_pad(&mut self, _ty: Type<'gcc>, _pers_fn: RValue<'gcc>) -> RValue<'gcc> {\n-        let field1 = self.context.new_field(None, self.u8_type.make_pointer(), \"landing_pad_field_1\");\n-        let field2 = self.context.new_field(None, self.i32_type, \"landing_pad_field_1\");\n-        let struct_type = self.context.new_struct_type(None, \"landing_pad\", &[field1, field2]);\n-        self.current_func().new_local(None, struct_type.as_type(), \"landing_pad\")\n-            .to_rvalue()\n+    fn cleanup_landing_pad(&mut self, _pers_fn: RValue<'gcc>) -> (RValue<'gcc>, RValue<'gcc>) {\n+        let value1 = self.current_func().new_local(None, self.u8_type.make_pointer(), \"landing_pad0\")\n+                .to_rvalue();\n+        let value2 = self.current_func().new_local(None, self.i32_type, \"landing_pad1\").to_rvalue();\n+        (value1, value2)\n     }\n \n     #[cfg(feature=\"master\")]\n-    fn resume(&mut self, exn: RValue<'gcc>) {\n-        // TODO(antoyo): check if this is normal that we need to dereference the value.\n-        // NOTE: the type is wrong, so in order to get a pointer for parameter, cast it to a\n-        // pointer of pointer that is later dereferenced.\n-        let exn_type = exn.get_type().make_pointer();\n-        let exn = self.context.new_cast(None, exn, exn_type);\n-        let exn = exn.dereference(None).to_rvalue();\n+    fn resume(&mut self, exn0: RValue<'gcc>, _exn1: RValue<'gcc>) {\n+        let exn_type = exn0.get_type();\n+        let exn = self.context.new_cast(None, exn0, exn_type);\n         let unwind_resume = self.context.get_target_builtin_function(\"__builtin_unwind_resume\");\n         self.llbb().add_eval(None, self.context.new_call(None, unwind_resume, &[exn]));\n         self.unreachable();\n     }\n \n     #[cfg(not(feature=\"master\"))]\n-    fn resume(&mut self, _exn: RValue<'gcc>) {\n+    fn resume(&mut self, _exn0: RValue<'gcc>, _exn1: RValue<'gcc>) {\n         self.unreachable();\n     }\n \n@@ -1355,16 +1348,27 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         // TODO(antoyo)\n     }\n \n-    fn call(&mut self, _typ: Type<'gcc>, func: RValue<'gcc>, args: &[RValue<'gcc>], funclet: Option<&Funclet>) -> RValue<'gcc> {\n+    fn call(\n+        &mut self,\n+        _typ: Type<'gcc>,\n+        fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>,\n+        func: RValue<'gcc>,\n+        args: &[RValue<'gcc>],\n+        funclet: Option<&Funclet>,\n+    ) -> RValue<'gcc> {\n         // FIXME(antoyo): remove when having a proper API.\n         let gcc_func = unsafe { std::mem::transmute(func) };\n-        if self.functions.borrow().values().find(|value| **value == gcc_func).is_some() {\n+        let call = if self.functions.borrow().values().any(|value| *value == gcc_func) {\n             self.function_call(func, args, funclet)\n         }\n         else {\n             // If it's a not function that was defined, it's a function pointer.\n             self.function_ptr_call(func, args, funclet)\n+        };\n+        if let Some(_fn_abi) = fn_abi {\n+            // TODO(bjorn3): Apply function attributes\n         }\n+        call\n     }\n \n     fn zext(&mut self, value: RValue<'gcc>, dest_typ: Type<'gcc>) -> RValue<'gcc> {\n@@ -1403,12 +1407,12 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         val\n     }\n \n-    fn fptoui_sat(&mut self, _val: RValue<'gcc>, _dest_ty: Type<'gcc>) -> Option<RValue<'gcc>> {\n-        None\n+    fn fptoui_sat(&mut self, val: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n+        self.fptoint_sat(false, val, dest_ty)\n     }\n \n-    fn fptosi_sat(&mut self, _val: RValue<'gcc>, _dest_ty: Type<'gcc>) -> Option<RValue<'gcc>> {\n-        None\n+    fn fptosi_sat(&mut self, val: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n+        self.fptoint_sat(true, val, dest_ty)\n     }\n \n     fn instrprof_increment(&mut self, _fn_name: RValue<'gcc>, _hash: RValue<'gcc>, _num_counters: RValue<'gcc>, _index: RValue<'gcc>) {\n@@ -1417,6 +1421,166 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n }\n \n impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n+    fn fptoint_sat(&mut self, signed: bool, val: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n+        let src_ty = self.cx.val_ty(val);\n+        let (float_ty, int_ty) = if self.cx.type_kind(src_ty) == TypeKind::Vector {\n+            assert_eq!(self.cx.vector_length(src_ty), self.cx.vector_length(dest_ty));\n+            (self.cx.element_type(src_ty), self.cx.element_type(dest_ty))\n+        } else {\n+            (src_ty, dest_ty)\n+        };\n+\n+        // FIXME(jistone): the following was originally the fallback SSA implementation, before LLVM 13\n+        // added native `fptosi.sat` and `fptoui.sat` conversions, but it was used by GCC as well.\n+        // Now that LLVM always relies on its own, the code has been moved to GCC, but the comments are\n+        // still LLVM-specific. This should be updated, and use better GCC specifics if possible.\n+\n+        let int_width = self.cx.int_width(int_ty);\n+        let float_width = self.cx.float_width(float_ty);\n+        // LLVM's fpto[su]i returns undef when the input val is infinite, NaN, or does not fit into the\n+        // destination integer type after rounding towards zero. This `undef` value can cause UB in\n+        // safe code (see issue #10184), so we implement a saturating conversion on top of it:\n+        // Semantically, the mathematical value of the input is rounded towards zero to the next\n+        // mathematical integer, and then the result is clamped into the range of the destination\n+        // integer type. Positive and negative infinity are mapped to the maximum and minimum value of\n+        // the destination integer type. NaN is mapped to 0.\n+        //\n+        // Define f_min and f_max as the largest and smallest (finite) floats that are exactly equal to\n+        // a value representable in int_ty.\n+        // They are exactly equal to int_ty::{MIN,MAX} if float_ty has enough significand bits.\n+        // Otherwise, int_ty::MAX must be rounded towards zero, as it is one less than a power of two.\n+        // int_ty::MIN, however, is either zero or a negative power of two and is thus exactly\n+        // representable. Note that this only works if float_ty's exponent range is sufficiently large.\n+        // f16 or 256 bit integers would break this property. Right now the smallest float type is f32\n+        // with exponents ranging up to 127, which is barely enough for i128::MIN = -2^127.\n+        // On the other hand, f_max works even if int_ty::MAX is greater than float_ty::MAX. Because\n+        // we're rounding towards zero, we just get float_ty::MAX (which is always an integer).\n+        // This already happens today with u128::MAX = 2^128 - 1 > f32::MAX.\n+        let int_max = |signed: bool, int_width: u64| -> u128 {\n+            let shift_amount = 128 - int_width;\n+            if signed { i128::MAX as u128 >> shift_amount } else { u128::MAX >> shift_amount }\n+        };\n+        let int_min = |signed: bool, int_width: u64| -> i128 {\n+            if signed { i128::MIN >> (128 - int_width) } else { 0 }\n+        };\n+\n+        let compute_clamp_bounds_single = |signed: bool, int_width: u64| -> (u128, u128) {\n+            let rounded_min =\n+                ieee::Single::from_i128_r(int_min(signed, int_width), Round::TowardZero);\n+            assert_eq!(rounded_min.status, Status::OK);\n+            let rounded_max =\n+                ieee::Single::from_u128_r(int_max(signed, int_width), Round::TowardZero);\n+            assert!(rounded_max.value.is_finite());\n+            (rounded_min.value.to_bits(), rounded_max.value.to_bits())\n+        };\n+        let compute_clamp_bounds_double = |signed: bool, int_width: u64| -> (u128, u128) {\n+            let rounded_min =\n+                ieee::Double::from_i128_r(int_min(signed, int_width), Round::TowardZero);\n+            assert_eq!(rounded_min.status, Status::OK);\n+            let rounded_max =\n+                ieee::Double::from_u128_r(int_max(signed, int_width), Round::TowardZero);\n+            assert!(rounded_max.value.is_finite());\n+            (rounded_min.value.to_bits(), rounded_max.value.to_bits())\n+        };\n+        // To implement saturation, we perform the following steps:\n+        //\n+        // 1. Cast val to an integer with fpto[su]i. This may result in undef.\n+        // 2. Compare val to f_min and f_max, and use the comparison results to select:\n+        //  a) int_ty::MIN if val < f_min or val is NaN\n+        //  b) int_ty::MAX if val > f_max\n+        //  c) the result of fpto[su]i otherwise\n+        // 3. If val is NaN, return 0.0, otherwise return the result of step 2.\n+        //\n+        // This avoids resulting undef because values in range [f_min, f_max] by definition fit into the\n+        // destination type. It creates an undef temporary, but *producing* undef is not UB. Our use of\n+        // undef does not introduce any non-determinism either.\n+        // More importantly, the above procedure correctly implements saturating conversion.\n+        // Proof (sketch):\n+        // If val is NaN, 0 is returned by definition.\n+        // Otherwise, val is finite or infinite and thus can be compared with f_min and f_max.\n+        // This yields three cases to consider:\n+        // (1) if val in [f_min, f_max], the result of fpto[su]i is returned, which agrees with\n+        //     saturating conversion for inputs in that range.\n+        // (2) if val > f_max, then val is larger than int_ty::MAX. This holds even if f_max is rounded\n+        //     (i.e., if f_max < int_ty::MAX) because in those cases, nextUp(f_max) is already larger\n+        //     than int_ty::MAX. Because val is larger than int_ty::MAX, the return value of int_ty::MAX\n+        //     is correct.\n+        // (3) if val < f_min, then val is smaller than int_ty::MIN. As shown earlier, f_min exactly equals\n+        //     int_ty::MIN and therefore the return value of int_ty::MIN is correct.\n+        // QED.\n+\n+        let float_bits_to_llval = |bx: &mut Self, bits| {\n+            let bits_llval = match float_width {\n+                32 => bx.cx().const_u32(bits as u32),\n+                64 => bx.cx().const_u64(bits as u64),\n+                n => bug!(\"unsupported float width {}\", n),\n+            };\n+            bx.bitcast(bits_llval, float_ty)\n+        };\n+        let (f_min, f_max) = match float_width {\n+            32 => compute_clamp_bounds_single(signed, int_width),\n+            64 => compute_clamp_bounds_double(signed, int_width),\n+            n => bug!(\"unsupported float width {}\", n),\n+        };\n+        let f_min = float_bits_to_llval(self, f_min);\n+        let f_max = float_bits_to_llval(self, f_max);\n+        let int_max = self.cx.const_uint_big(int_ty, int_max(signed, int_width));\n+        let int_min = self.cx.const_uint_big(int_ty, int_min(signed, int_width) as u128);\n+        let zero = self.cx.const_uint(int_ty, 0);\n+\n+        // If we're working with vectors, constants must be \"splatted\": the constant is duplicated\n+        // into each lane of the vector.  The algorithm stays the same, we are just using the\n+        // same constant across all lanes.\n+        let maybe_splat = |bx: &mut Self, val| {\n+            if bx.cx().type_kind(dest_ty) == TypeKind::Vector {\n+                bx.vector_splat(bx.vector_length(dest_ty), val)\n+            } else {\n+                val\n+            }\n+        };\n+        let f_min = maybe_splat(self, f_min);\n+        let f_max = maybe_splat(self, f_max);\n+        let int_max = maybe_splat(self, int_max);\n+        let int_min = maybe_splat(self, int_min);\n+        let zero = maybe_splat(self, zero);\n+\n+        // Step 1 ...\n+        let fptosui_result = if signed { self.fptosi(val, dest_ty) } else { self.fptoui(val, dest_ty) };\n+        let less_or_nan = self.fcmp(RealPredicate::RealULT, val, f_min);\n+        let greater = self.fcmp(RealPredicate::RealOGT, val, f_max);\n+\n+        // Step 2: We use two comparisons and two selects, with %s1 being the\n+        // result:\n+        //     %less_or_nan = fcmp ult %val, %f_min\n+        //     %greater = fcmp olt %val, %f_max\n+        //     %s0 = select %less_or_nan, int_ty::MIN, %fptosi_result\n+        //     %s1 = select %greater, int_ty::MAX, %s0\n+        // Note that %less_or_nan uses an *unordered* comparison. This\n+        // comparison is true if the operands are not comparable (i.e., if val is\n+        // NaN). The unordered comparison ensures that s1 becomes int_ty::MIN if\n+        // val is NaN.\n+        //\n+        // Performance note: Unordered comparison can be lowered to a \"flipped\"\n+        // comparison and a negation, and the negation can be merged into the\n+        // select. Therefore, it not necessarily any more expensive than an\n+        // ordered (\"normal\") comparison. Whether these optimizations will be\n+        // performed is ultimately up to the backend, but at least x86 does\n+        // perform them.\n+        let s0 = self.select(less_or_nan, int_min, fptosui_result);\n+        let s1 = self.select(greater, int_max, s0);\n+\n+        // Step 3: NaN replacement.\n+        // For unsigned types, the above step already yielded int_ty::MIN == 0 if val is NaN.\n+        // Therefore we only need to execute this step for signed integer types.\n+        if signed {\n+            // LLVM has no isNaN predicate, so we use (val == val) instead\n+            let cmp = self.fcmp(RealPredicate::RealOEQ, val, val);\n+            self.select(cmp, s1, zero)\n+        } else {\n+            s1\n+        }\n+    }\n+\n     #[cfg(feature=\"master\")]\n     pub fn shuffle_vector(&mut self, v1: RValue<'gcc>, v2: RValue<'gcc>, mask: RValue<'gcc>) -> RValue<'gcc> {\n         let struct_type = mask.get_type().is_struct().expect(\"mask should be of struct type\");"}, {"sha": "ba1e86562089e756e167d2cbf14990a7560c596f", "filename": "src/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/src%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/src%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcallee.rs?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -1,7 +1,7 @@\n #[cfg(feature=\"master\")]\n use gccjit::{FnAttribute, Visibility};\n use gccjit::{FunctionType, Function};\n-use rustc_middle::ty::{self, Instance, TypeVisitable};\n+use rustc_middle::ty::{self, Instance, TypeVisitableExt};\n use rustc_middle::ty::layout::{FnAbiOf, HasTyCtxt};\n \n use crate::attributes;"}, {"sha": "76fc7bd222e1e072e13cd5ebdb2221bf9585bda8", "filename": "src/common.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -36,15 +36,15 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n pub fn bytes_in_context<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, bytes: &[u8]) -> RValue<'gcc> {\n     let context = &cx.context;\n     let byte_type = context.new_type::<u8>();\n-    let typ = context.new_array_type(None, byte_type, bytes.len() as i32);\n+    let typ = context.new_array_type(None, byte_type, bytes.len() as u64);\n     let elements: Vec<_> =\n         bytes.iter()\n         .map(|&byte| context.new_rvalue_from_int(byte_type, byte as i32))\n         .collect();\n     context.new_array_constructor(None, typ, &elements)\n }\n \n-pub fn type_is_pointer<'gcc>(typ: Type<'gcc>) -> bool {\n+pub fn type_is_pointer(typ: Type<'_>) -> bool {\n     typ.get_pointee().is_some()\n }\n \n@@ -115,8 +115,8 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         self.const_uint(self.usize_type, i)\n     }\n \n-    fn const_u8(&self, _i: u8) -> RValue<'gcc> {\n-        unimplemented!();\n+    fn const_u8(&self, i: u8) -> RValue<'gcc> {\n+        self.const_uint(self.type_u8(), i as u64)\n     }\n \n     fn const_real(&self, typ: Type<'gcc>, val: f64) -> RValue<'gcc> {\n@@ -158,10 +158,6 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         None\n     }\n \n-    fn zst_to_backend(&self, _ty: Type<'gcc>) -> RValue<'gcc> {\n-        self.const_undef(self.type_ix(0))\n-    }\n-\n     fn scalar_to_backend(&self, cv: Scalar, layout: abi::Scalar, ty: Type<'gcc>) -> RValue<'gcc> {\n         let bitsize = if layout.is_bool() { 1 } else { layout.size(self).bits() };\n         match cv {\n@@ -225,7 +221,7 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n                 let base_addr = self.const_bitcast(base_addr, self.usize_type);\n                 let offset = self.context.new_rvalue_from_long(self.usize_type, offset.bytes() as i64);\n                 let ptr = self.const_bitcast(base_addr + offset, ptr_type);\n-                if layout.primitive() != Pointer {\n+                if !matches!(layout.primitive(), Pointer(_)) {\n                     self.const_bitcast(ptr.dereference(None).to_rvalue(), ty)\n                 }\n                 else {\n@@ -245,7 +241,7 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         let value =\n             if layout.size == Size::ZERO {\n                 let value = self.const_usize(alloc.inner().align.bytes());\n-                self.context.new_cast(None, value, ty)\n+                self.const_bitcast(value, ty)\n             }\n             else {\n                 let init = const_alloc_to_gcc(self, alloc);"}, {"sha": "792ab8f890d8feab0f2c7cabdf30d293c1551c17", "filename": "src/consts.rs", "status": "modified", "additions": 39, "deletions": 34, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -8,12 +8,12 @@ use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::ty::{self, Instance, Ty};\n use rustc_middle::ty::layout::LayoutOf;\n use rustc_middle::mir::interpret::{self, ConstAllocation, ErrorHandled, Scalar as InterpScalar, read_target_uint};\n-use rustc_span::Span;\n use rustc_span::def_id::DefId;\n use rustc_target::abi::{self, Align, HasDataLayout, Primitive, Size, WrappingRange};\n \n use crate::base;\n use crate::context::CodegenCx;\n+use crate::errors::InvalidMinimumAlignment;\n use crate::type_of::LayoutGccExt;\n \n impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n@@ -31,6 +31,21 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n     }\n }\n \n+fn set_global_alignment<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, gv: LValue<'gcc>, mut align: Align) {\n+    // The target may require greater alignment for globals than the type does.\n+    // Note: GCC and Clang also allow `__attribute__((aligned))` on variables,\n+    // which can force it to be smaller. Rust doesn't support this yet.\n+    if let Some(min) = cx.sess().target.min_global_align {\n+        match Align::from_bits(min) {\n+            Ok(min) => align = align.max(min),\n+            Err(err) => {\n+                cx.sess().emit_err(InvalidMinimumAlignment { err });\n+            }\n+        }\n+    }\n+    gv.set_alignment(align.bytes() as i32);\n+}\n+\n impl<'gcc, 'tcx> StaticMethods for CodegenCx<'gcc, 'tcx> {\n     fn static_addr_of(&self, cv: RValue<'gcc>, align: Align, kind: Option<&str>) -> RValue<'gcc> {\n         // TODO(antoyo): implement a proper rvalue comparison in libgccjit instead of doing the\n@@ -82,7 +97,7 @@ impl<'gcc, 'tcx> StaticMethods for CodegenCx<'gcc, 'tcx> {\n         let ty = instance.ty(self.tcx, ty::ParamEnv::reveal_all());\n         let gcc_type = self.layout_of(ty).gcc_type(self);\n \n-        // TODO(antoyo): set alignment.\n+        set_global_alignment(self, global, self.align_of(ty));\n \n         let value = self.bitcast_if_needed(value, gcc_type);\n         global.global_set_initializer_rvalue(value);\n@@ -127,7 +142,7 @@ impl<'gcc, 'tcx> StaticMethods for CodegenCx<'gcc, 'tcx> {\n             //\n             // We could remove this hack whenever we decide to drop macOS 10.10 support.\n             if self.tcx.sess.target.options.is_like_osx {\n-                // The `inspect` method is okay here because we checked relocations, and\n+                // The `inspect` method is okay here because we checked for provenance, and\n                 // because we are doing this access to inspect the final interpreter state\n                 // (not as part of the interpreter execution).\n                 //\n@@ -215,7 +230,8 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         let ty = instance.ty(self.tcx, ty::ParamEnv::reveal_all());\n         let sym = self.tcx.symbol_name(instance).name;\n \n-        let global = if def_id.is_local() && !self.tcx.is_foreign_item(def_id) {\n+        let global =\n+            if def_id.is_local() && !self.tcx.is_foreign_item(def_id) {\n             let llty = self.layout_of(ty).gcc_type(self);\n             if let Some(global) = self.get_declared_value(sym) {\n                 if self.val_ty(global) != self.type_ptr_to(llty) {\n@@ -238,7 +254,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n \n             global\n         } else {\n-            check_and_apply_linkage(&self, &fn_attrs, ty, sym, self.tcx.def_span(def_id))\n+            check_and_apply_linkage(&self, &fn_attrs, ty, sym)\n         };\n \n         if !def_id.is_local() {\n@@ -278,17 +294,17 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n \n pub fn const_alloc_to_gcc<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, alloc: ConstAllocation<'tcx>) -> RValue<'gcc> {\n     let alloc = alloc.inner();\n-    let mut llvals = Vec::with_capacity(alloc.relocations().len() + 1);\n+    let mut llvals = Vec::with_capacity(alloc.provenance().ptrs().len() + 1);\n     let dl = cx.data_layout();\n     let pointer_size = dl.pointer_size.bytes() as usize;\n \n     let mut next_offset = 0;\n-    for &(offset, alloc_id) in alloc.relocations().iter() {\n+    for &(offset, alloc_id) in alloc.provenance().ptrs().iter() {\n         let offset = offset.bytes();\n         assert_eq!(offset as usize as u64, offset);\n         let offset = offset as usize;\n         if offset > next_offset {\n-            // This `inspect` is okay since we have checked that it is not within a relocation, it\n+            // This `inspect` is okay since we have checked that it is not within a pointer with provenance, it\n             // is within the bounds of the allocation, and it doesn't affect interpreter execution\n             // (we inspect the result after interpreter execution). Any undef byte is replaced with\n             // some arbitrary byte value.\n@@ -301,24 +317,27 @@ pub fn const_alloc_to_gcc<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, alloc: ConstAl\n             read_target_uint( dl.endian,\n                 // This `inspect` is okay since it is within the bounds of the allocation, it doesn't\n                 // affect interpreter execution (we inspect the result after interpreter execution),\n-                // and we properly interpret the relocation as a relocation pointer offset.\n+                // and we properly interpret the provenance as a relocation pointer offset.\n                 alloc.inspect_with_uninit_and_ptr_outside_interpreter(offset..(offset + pointer_size)),\n             )\n             .expect(\"const_alloc_to_llvm: could not read relocation pointer\")\n             as u64;\n+\n+        let address_space = cx.tcx.global_alloc(alloc_id).address_space(cx);\n+\n         llvals.push(cx.scalar_to_backend(\n             InterpScalar::from_pointer(\n                 interpret::Pointer::new(alloc_id, Size::from_bytes(ptr_offset)),\n                 &cx.tcx,\n             ),\n-            abi::Scalar::Initialized { value: Primitive::Pointer, valid_range: WrappingRange::full(dl.pointer_size) },\n-            cx.type_i8p(),\n+            abi::Scalar::Initialized { value: Primitive::Pointer(address_space), valid_range: WrappingRange::full(dl.pointer_size) },\n+            cx.type_i8p_ext(address_space),\n         ));\n         next_offset = offset + pointer_size;\n     }\n     if alloc.len() >= next_offset {\n         let range = next_offset..alloc.len();\n-        // This `inspect` is okay since we have check that it is after all relocations, it is\n+        // This `inspect` is okay since we have check that it is after all provenance, it is\n         // within the bounds of the allocation, and it doesn't affect interpreter execution (we\n         // inspect the result after interpreter execution). Any undef byte is replaced with some\n         // arbitrary byte value.\n@@ -336,27 +355,12 @@ pub fn codegen_static_initializer<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, def_id\n     Ok((const_alloc_to_gcc(cx, alloc), alloc))\n }\n \n-fn check_and_apply_linkage<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, attrs: &CodegenFnAttrs, ty: Ty<'tcx>, sym: &str, span: Span) -> LValue<'gcc> {\n+fn check_and_apply_linkage<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, attrs: &CodegenFnAttrs, ty: Ty<'tcx>, sym: &str) -> LValue<'gcc> {\n     let is_tls = attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL);\n-    let llty = cx.layout_of(ty).gcc_type(cx);\n-    if let Some(linkage) = attrs.linkage {\n-        // If this is a static with a linkage specified, then we need to handle\n-        // it a little specially. The typesystem prevents things like &T and\n-        // extern \"C\" fn() from being non-null, so we can't just declare a\n-        // static and call it a day. Some linkages (like weak) will make it such\n-        // that the static actually has a null value.\n-        let llty2 =\n-            if let ty::RawPtr(ref mt) = ty.kind() {\n-                cx.layout_of(mt.ty).gcc_type(cx)\n-            }\n-            else {\n-                cx.sess().span_fatal(\n-                    span,\n-                    \"must have type `*const T` or `*mut T` due to `#[linkage]` attribute\",\n-                )\n-            };\n+    let gcc_type = cx.layout_of(ty).gcc_type(cx);\n+    if let Some(linkage) = attrs.import_linkage {\n         // Declare a symbol `foo` with the desired linkage.\n-        let global1 = cx.declare_global_with_linkage(&sym, llty2, base::global_linkage_to_gcc(linkage));\n+        let global1 = cx.declare_global_with_linkage(&sym, cx.type_i8(), base::global_linkage_to_gcc(linkage));\n \n         // Declare an internal global `extern_with_linkage_foo` which\n         // is initialized with the address of `foo`.  If `foo` is\n@@ -366,9 +370,10 @@ fn check_and_apply_linkage<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, attrs: &Codeg\n         // zero.\n         let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n         real_name.push_str(&sym);\n-        let global2 = cx.define_global(&real_name, llty, is_tls, attrs.link_section);\n+        let global2 = cx.define_global(&real_name, gcc_type, is_tls, attrs.link_section);\n         // TODO(antoyo): set linkage.\n-        global2.global_set_initializer_rvalue(global1.get_address(None));\n+        let value = cx.const_ptrcast(global1.get_address(None), gcc_type);\n+        global2.global_set_initializer_rvalue(value);\n         // TODO(antoyo): use global_set_initializer() when it will work.\n         global2\n     }\n@@ -382,6 +387,6 @@ fn check_and_apply_linkage<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, attrs: &Codeg\n         // don't do this then linker errors can be generated where the linker\n         // complains that one object files has a thread local version of the\n         // symbol and another one doesn't.\n-        cx.declare_global(&sym, llty, GlobalKind::Imported, is_tls, attrs.link_section)\n+        cx.declare_global(&sym, gcc_type, GlobalKind::Imported, is_tls, attrs.link_section)\n     }\n }"}, {"sha": "661681bdb50f2f1094b0f18736ad43846110cc64", "filename": "src/context.rs", "status": "modified", "additions": 12, "deletions": 27, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/src%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/src%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcontext.rs?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -14,7 +14,7 @@ use rustc_middle::mir::mono::CodegenUnit;\n use rustc_middle::ty::{self, Instance, ParamEnv, PolyExistentialTraitRef, Ty, TyCtxt};\n use rustc_middle::ty::layout::{FnAbiError, FnAbiOf, FnAbiOfHelpers, FnAbiRequest, HasParamEnv, HasTyCtxt, LayoutError, TyAndLayout, LayoutOfHelpers};\n use rustc_session::Session;\n-use rustc_span::Span;\n+use rustc_span::{Span, source_map::respan};\n use rustc_target::abi::{call::FnAbi, HasDataLayout, PointeeInfo, Size, TargetDataLayout, VariantIdx};\n use rustc_target::spec::{HasTargetSpec, Target, TlsModel};\n \n@@ -88,9 +88,9 @@ pub struct CodegenCx<'gcc, 'tcx> {\n     pub vtables: RefCell<FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), RValue<'gcc>>>,\n \n     // TODO(antoyo): improve the SSA API to not require those.\n-    // Mapping from function pointer type to indexes of on stack parameters.\n+    /// Mapping from function pointer type to indexes of on stack parameters.\n     pub on_stack_params: RefCell<FxHashMap<FunctionPtrType<'gcc>, FxHashSet<usize>>>,\n-    // Mapping from function to indexes of on stack parameters.\n+    /// Mapping from function to indexes of on stack parameters.\n     pub on_stack_function_params: RefCell<FxHashMap<Function<'gcc>, FxHashSet<usize>>>,\n \n     /// Cache of emitted const globals (value -> global)\n@@ -258,8 +258,8 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n \n     pub fn rvalue_as_function(&self, value: RValue<'gcc>) -> Function<'gcc> {\n         let function: Function<'gcc> = unsafe { std::mem::transmute(value) };\n-        debug_assert!(self.functions.borrow().values().find(|value| **value == function).is_some(),\n-            \"{:?} is not a function\", function);\n+        debug_assert!(self.functions.borrow().values().any(|value| *value == function),\n+            \"{:?} ({:?}) is not a function\", value, value.get_type());\n         function\n     }\n \n@@ -298,7 +298,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         self.is_native_int_type(typ) || self.is_non_native_int_type(typ) || typ.is_compatible_with(self.bool_type)\n     }\n \n-    pub fn sess(&self) -> &Session {\n+    pub fn sess(&self) -> &'tcx Session {\n         &self.tcx.sess\n     }\n \n@@ -391,7 +391,7 @@ impl<'gcc, 'tcx> MiscMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n                             tcx,\n                             ty::ParamEnv::reveal_all(),\n                             def_id,\n-                            tcx.intern_substs(&[]),\n+                            ty::List::empty(),\n                         )\n                         .unwrap().unwrap();\n \n@@ -431,10 +431,6 @@ impl<'gcc, 'tcx> MiscMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         self.codegen_unit\n     }\n \n-    fn used_statics(&self) -> &RefCell<Vec<RValue<'gcc>>> {\n-        unimplemented!();\n-    }\n-\n     fn set_frame_pointer_type(&self, _llfn: RValue<'gcc>) {\n         // TODO(antoyo)\n     }\n@@ -443,13 +439,10 @@ impl<'gcc, 'tcx> MiscMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         // TODO(antoyo)\n     }\n \n-    fn create_used_variable(&self) {\n-        unimplemented!();\n-    }\n-\n     fn declare_c_main(&self, fn_type: Self::Type) -> Option<Self::Function> {\n-        if self.get_declared_value(\"main\").is_none() {\n-            Some(self.declare_cfn(\"main\", fn_type))\n+        let entry_name = self.sess().target.entry_name.as_ref();\n+        if self.get_declared_value(entry_name).is_none() {\n+            Some(self.declare_entry_fn(entry_name, fn_type, ()))\n         }\n         else {\n             // If the symbol already exists, it is an error: for example, the user wrote\n@@ -458,14 +451,6 @@ impl<'gcc, 'tcx> MiscMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n             None\n         }\n     }\n-\n-    fn compiler_used_statics(&self) -> &RefCell<Vec<RValue<'gcc>>> {\n-        unimplemented!()\n-    }\n-\n-    fn create_compiler_used_variable(&self) {\n-        unimplemented!()\n-    }\n }\n \n impl<'gcc, 'tcx> HasTyCtxt<'tcx> for CodegenCx<'gcc, 'tcx> {\n@@ -492,7 +477,7 @@ impl<'gcc, 'tcx> LayoutOfHelpers<'tcx> for CodegenCx<'gcc, 'tcx> {\n     #[inline]\n     fn handle_layout_err(&self, err: LayoutError<'tcx>, span: Span, ty: Ty<'tcx>) -> ! {\n         if let LayoutError::SizeOverflow(_) = err {\n-            self.sess().span_fatal(span, &err.to_string())\n+            self.sess().emit_fatal(respan(span, err))\n         } else {\n             span_bug!(span, \"failed to get layout for `{}`: {}\", ty, err)\n         }\n@@ -510,7 +495,7 @@ impl<'gcc, 'tcx> FnAbiOfHelpers<'tcx> for CodegenCx<'gcc, 'tcx> {\n         fn_abi_request: FnAbiRequest<'tcx>,\n     ) -> ! {\n         if let FnAbiError::Layout(LayoutError::SizeOverflow(_)) = err {\n-            self.sess().span_fatal(span, &err.to_string())\n+            self.sess().emit_fatal(respan(span, err))\n         } else {\n             match fn_abi_request {\n                 FnAbiRequest::OfFnPtr { sig, extra_args } => {"}, {"sha": "a81585d412846e641c968302f4540944e264ab0b", "filename": "src/debuginfo.rs", "status": "modified", "additions": 49, "deletions": 8, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/src%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/src%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo.rs?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -4,16 +4,25 @@ use rustc_codegen_ssa::traits::{DebugInfoBuilderMethods, DebugInfoMethods};\n use rustc_middle::mir;\n use rustc_middle::ty::{Instance, PolyExistentialTraitRef, Ty};\n use rustc_span::{SourceFile, Span, Symbol};\n-use rustc_target::abi::Size;\n use rustc_target::abi::call::FnAbi;\n+use rustc_target::abi::Size;\n+use std::ops::Range;\n \n use crate::builder::Builder;\n use crate::context::CodegenCx;\n \n impl<'a, 'gcc, 'tcx> DebugInfoBuilderMethods for Builder<'a, 'gcc, 'tcx> {\n     // FIXME(eddyb) find a common convention for all of the debuginfo-related\n     // names (choose between `dbg`, `debug`, `debuginfo`, `debug_info` etc.).\n-    fn dbg_var_addr(&mut self, _dbg_var: Self::DIVariable, _scope_metadata: Self::DIScope, _variable_alloca: Self::Value, _direct_offset: Size, _indirect_offsets: &[Size]) {\n+    fn dbg_var_addr(\n+        &mut self,\n+        _dbg_var: Self::DIVariable,\n+        _scope_metadata: Self::DIScope,\n+        _variable_alloca: Self::Value,\n+        _direct_offset: Size,\n+        _indirect_offsets: &[Size],\n+        _fragment: Option<Range<Size>>,\n+    ) {\n         unimplemented!();\n     }\n \n@@ -31,32 +40,64 @@ impl<'a, 'gcc, 'tcx> DebugInfoBuilderMethods for Builder<'a, 'gcc, 'tcx> {\n }\n \n impl<'gcc, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n-    fn create_vtable_debuginfo(&self, _ty: Ty<'tcx>, _trait_ref: Option<PolyExistentialTraitRef<'tcx>>, _vtable: Self::Value) {\n+    fn create_vtable_debuginfo(\n+        &self,\n+        _ty: Ty<'tcx>,\n+        _trait_ref: Option<PolyExistentialTraitRef<'tcx>>,\n+        _vtable: Self::Value,\n+    ) {\n         // TODO(antoyo)\n     }\n \n-    fn create_function_debug_context(&self, _instance: Instance<'tcx>, _fn_abi: &FnAbi<'tcx, Ty<'tcx>>, _llfn: RValue<'gcc>, _mir: &mir::Body<'tcx>) -> Option<FunctionDebugContext<Self::DIScope, Self::DILocation>> {\n+    fn create_function_debug_context(\n+        &self,\n+        _instance: Instance<'tcx>,\n+        _fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n+        _llfn: RValue<'gcc>,\n+        _mir: &mir::Body<'tcx>,\n+    ) -> Option<FunctionDebugContext<Self::DIScope, Self::DILocation>> {\n         // TODO(antoyo)\n         None\n     }\n \n-    fn extend_scope_to_file(&self, _scope_metadata: Self::DIScope, _file: &SourceFile) -> Self::DIScope {\n+    fn extend_scope_to_file(\n+        &self,\n+        _scope_metadata: Self::DIScope,\n+        _file: &SourceFile,\n+    ) -> Self::DIScope {\n         unimplemented!();\n     }\n \n     fn debuginfo_finalize(&self) {\n         // TODO(antoyo)\n     }\n \n-    fn create_dbg_var(&self, _variable_name: Symbol, _variable_type: Ty<'tcx>, _scope_metadata: Self::DIScope, _variable_kind: VariableKind, _span: Span) -> Self::DIVariable {\n+    fn create_dbg_var(\n+        &self,\n+        _variable_name: Symbol,\n+        _variable_type: Ty<'tcx>,\n+        _scope_metadata: Self::DIScope,\n+        _variable_kind: VariableKind,\n+        _span: Span,\n+    ) -> Self::DIVariable {\n         unimplemented!();\n     }\n \n-    fn dbg_scope_fn(&self, _instance: Instance<'tcx>, _fn_abi: &FnAbi<'tcx, Ty<'tcx>>, _maybe_definition_llfn: Option<RValue<'gcc>>) -> Self::DIScope {\n+    fn dbg_scope_fn(\n+        &self,\n+        _instance: Instance<'tcx>,\n+        _fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n+        _maybe_definition_llfn: Option<RValue<'gcc>>,\n+    ) -> Self::DIScope {\n         unimplemented!();\n     }\n \n-    fn dbg_loc(&self, _scope: Self::DIScope, _inlined_at: Option<Self::DILocation>, _span: Span) -> Self::DILocation {\n+    fn dbg_loc(\n+        &self,\n+        _scope: Self::DIScope,\n+        _inlined_at: Option<Self::DILocation>,\n+        _span: Span,\n+    ) -> Self::DILocation {\n         unimplemented!();\n     }\n }"}, {"sha": "4748e7e4be2a3afe401ed49886cc7ae9a862c6b3", "filename": "src/declare.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/src%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/src%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdeclare.rs?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -63,13 +63,13 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         global\n     }\n \n-    pub fn declare_cfn(&self, name: &str, _fn_type: Type<'gcc>) -> RValue<'gcc> {\n+    pub fn declare_entry_fn(&self, name: &str, _fn_type: Type<'gcc>, callconv: () /*llvm::CCallConv*/) -> RValue<'gcc> {\n         // TODO(antoyo): use the fn_type parameter.\n         let const_string = self.context.new_type::<u8>().make_pointer().make_pointer();\n         let return_type = self.type_i32();\n         let variadic = false;\n         self.linkage.set(FunctionType::Exported);\n-        let func = declare_raw_fn(self, name, () /*llvm::CCallConv*/, return_type, &[self.type_i32(), const_string], variadic);\n+        let func = declare_raw_fn(self, name, callconv, return_type, &[self.type_i32(), const_string], variadic);\n         // NOTE: it is needed to set the current_func here as well, because get_fn() is not called\n         // for the main function.\n         *self.current_func.borrow_mut() = Some(func);"}, {"sha": "5ea39606c086d54963a8b2770831b60403e4f8f8", "filename": "src/errors.rs", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/src%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/src%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferrors.rs?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -0,0 +1,229 @@\n+use rustc_errors::{DiagnosticArgValue, IntoDiagnosticArg};\n+use rustc_macros::Diagnostic;\n+use rustc_middle::ty::Ty;\n+use rustc_span::{Span, Symbol};\n+use std::borrow::Cow;\n+\n+struct ExitCode(Option<i32>);\n+\n+impl IntoDiagnosticArg for ExitCode {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        let ExitCode(exit_code) = self;\n+        match exit_code {\n+            Some(t) => t.into_diagnostic_arg(),\n+            None => DiagnosticArgValue::Str(Cow::Borrowed(\"<signal>\")),\n+        }\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc_invalid_monomorphization_basic_integer, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationBasicInteger<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc_invalid_monomorphization_invalid_float_vector, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationInvalidFloatVector<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub elem_ty: &'a str,\n+    pub vec_ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc_invalid_monomorphization_not_float, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationNotFloat<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc_invalid_monomorphization_unrecognized, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationUnrecognized {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc_invalid_monomorphization_expected_signed_unsigned, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationExpectedSignedUnsigned<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub elem_ty: Ty<'a>,\n+    pub vec_ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc_invalid_monomorphization_unsupported_element, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationUnsupportedElement<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_ty: Ty<'a>,\n+    pub elem_ty: Ty<'a>,\n+    pub ret_ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc_invalid_monomorphization_invalid_bitmask, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationInvalidBitmask<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub ty: Ty<'a>,\n+    pub expected_int_bits: u64,\n+    pub expected_bytes: u64,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc_invalid_monomorphization_simd_shuffle, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationSimdShuffle<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc_invalid_monomorphization_expected_simd, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationExpectedSimd<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub position: &'a str,\n+    pub found_ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc_invalid_monomorphization_mask_type, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationMaskType<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc_invalid_monomorphization_return_length, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationReturnLength<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_len: u64,\n+    pub ret_ty: Ty<'a>,\n+    pub out_len: u64,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc_invalid_monomorphization_return_length_input_type, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationReturnLengthInputType<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_len: u64,\n+    pub in_ty: Ty<'a>,\n+    pub ret_ty: Ty<'a>,\n+    pub out_len: u64,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc_invalid_monomorphization_return_element, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationReturnElement<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_elem: Ty<'a>,\n+    pub in_ty: Ty<'a>,\n+    pub ret_ty: Ty<'a>,\n+    pub out_ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc_invalid_monomorphization_return_type, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationReturnType<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_elem: Ty<'a>,\n+    pub in_ty: Ty<'a>,\n+    pub ret_ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc_invalid_monomorphization_inserted_type, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationInsertedType<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_elem: Ty<'a>,\n+    pub in_ty: Ty<'a>,\n+    pub out_ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc_invalid_monomorphization_return_integer_type, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationReturnIntegerType<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub ret_ty: Ty<'a>,\n+    pub out_ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc_invalid_monomorphization_mismatched_lengths, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationMismatchedLengths {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub m_len: u64,\n+    pub v_len: u64,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc_invalid_monomorphization_unsupported_cast, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationUnsupportedCast<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_ty: Ty<'a>,\n+    pub in_elem: Ty<'a>,\n+    pub ret_ty: Ty<'a>,\n+    pub out_elem: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc_invalid_monomorphization_unsupported_operation, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationUnsupportedOperation<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_ty: Ty<'a>,\n+    pub in_elem: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc_lto_not_supported)]\n+pub(crate) struct LTONotSupported;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc_unwinding_inline_asm)]\n+pub(crate) struct UnwindingInlineAsm {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc_invalid_minimum_alignment)]\n+pub(crate) struct InvalidMinimumAlignment {\n+    pub err: String,\n+}"}, {"sha": "0edec566be309987bac044515be59f69d4ab8c86", "filename": "src/intrinsic/llvm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/src%2Fintrinsic%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/src%2Fintrinsic%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fllvm.rs?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -407,7 +407,7 @@ pub fn ignore_arg_cast(func_name: &str, index: usize, args_len: usize) -> bool {\n #[cfg(not(feature=\"master\"))]\n pub fn intrinsic<'gcc, 'tcx>(name: &str, cx: &CodegenCx<'gcc, 'tcx>) -> Function<'gcc> {\n     match name {\n-        \"llvm.x86.xgetbv\" => {\n+        \"llvm.x86.xgetbv\" | \"llvm.x86.sse2.pause\" => {\n             let gcc_name = \"__builtin_trap\";\n             let func = cx.context.get_builtin_function(gcc_name);\n             cx.functions.borrow_mut().insert(gcc_name.to_string(), func);"}, {"sha": "2590e0e3af4443efca8bb055c363b26e002dc691", "filename": "src/intrinsic/mod.rs", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/src%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/src%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fmod.rs?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -7,7 +7,7 @@ use std::iter;\n use gccjit::{ComparisonOp, Function, RValue, ToRValue, Type, UnaryOp, FunctionType};\n use rustc_codegen_ssa::MemFlags;\n use rustc_codegen_ssa::base::wants_msvc_seh;\n-use rustc_codegen_ssa::common::{IntPredicate, span_invalid_monomorphization_error};\n+use rustc_codegen_ssa::common::IntPredicate;\n use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{ArgAbiMethods, BaseTypeMethods, BuilderMethods, ConstMethods, IntrinsicCallMethods};\n@@ -31,6 +31,7 @@ use crate::abi::FnAbiGccExt;\n use crate::builder::Builder;\n use crate::common::{SignType, TypeReflection};\n use crate::context::CodegenCx;\n+use crate::errors::InvalidMonomorphizationBasicInteger;\n use crate::type_of::LayoutGccExt;\n use crate::intrinsic::simd::generic_simd_intrinsic;\n \n@@ -110,7 +111,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                 _ if simple.is_some() => {\n                     // FIXME(antoyo): remove this cast when the API supports function.\n                     let func = unsafe { std::mem::transmute(simple.expect(\"simple\")) };\n-                    self.call(self.type_void(), func, &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(), None)\n+                    self.call(self.type_void(), None, func, &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(), None)\n                 },\n                 sym::likely => {\n                     self.expect(args[0].immediate(), true)\n@@ -141,7 +142,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                 sym::volatile_load | sym::unaligned_volatile_load => {\n                     let tp_ty = substs.type_at(0);\n                     let mut ptr = args[0].immediate();\n-                    if let PassMode::Cast(ty) = fn_abi.ret.mode {\n+                    if let PassMode::Cast(ty, _) = &fn_abi.ret.mode {\n                         ptr = self.pointercast(ptr, self.type_ptr_to(ty.gcc_type(self)));\n                     }\n                     let load = self.volatile_load(ptr.get_type(), ptr);\n@@ -253,15 +254,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                                 _ => bug!(),\n                             },\n                             None => {\n-                                span_invalid_monomorphization_error(\n-                                    tcx.sess,\n-                                    span,\n-                                    &format!(\n-                                        \"invalid monomorphization of `{}` intrinsic: \\\n-                                      expected basic integer type, found `{}`\",\n-                                      name, ty\n-                                    ),\n-                                );\n+                                tcx.sess.emit_err(InvalidMonomorphizationBasicInteger { span, name, ty });\n                                 return;\n                             }\n                         }\n@@ -320,6 +313,18 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                     return;\n                 }\n \n+                sym::ptr_mask => {\n+                    let usize_type = self.context.new_type::<usize>();\n+                    let void_ptr_type = self.context.new_type::<*const ()>();\n+\n+                    let ptr = args[0].immediate();\n+                    let mask = args[1].immediate();\n+\n+                    let addr = self.bitcast(ptr, usize_type);\n+                    let masked = self.and(addr, mask);\n+                    self.bitcast(masked, void_ptr_type)\n+                },\n+                \n                 _ if name_str.starts_with(\"simd_\") => {\n                     match generic_simd_intrinsic(self, name, callee_ty, args, ret_ty, llret_ty, span) {\n                         Ok(llval) => llval,\n@@ -331,7 +336,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n             };\n \n         if !fn_abi.ret.is_ignore() {\n-            if let PassMode::Cast(ty) = fn_abi.ret.mode {\n+            if let PassMode::Cast(ty, _) = &fn_abi.ret.mode {\n                 let ptr_llty = self.type_ptr_to(ty.gcc_type(self));\n                 let ptr = self.pointercast(result.llval, ptr_llty);\n                 self.store(llval, ptr, result.align);\n@@ -347,7 +352,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n     fn abort(&mut self) {\n         let func = self.context.get_builtin_function(\"abort\");\n         let func: RValue<'gcc> = unsafe { std::mem::transmute(func) };\n-        self.call(self.type_void(), func, &[], None);\n+        self.call(self.type_void(), None, func, &[], None);\n     }\n \n     fn assume(&mut self, value: Self::Value) {\n@@ -427,7 +432,7 @@ impl<'gcc, 'tcx> ArgAbiExt<'gcc, 'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n         else if self.is_unsized_indirect() {\n             bug!(\"unsized `ArgAbi` must be handled through `store_fn_arg`\");\n         }\n-        else if let PassMode::Cast(cast) = self.mode {\n+        else if let PassMode::Cast(ref cast, _) = self.mode {\n             // FIXME(eddyb): Figure out when the simpler Store is safe, clang\n             // uses it for i16 -> {i8, i8}, but not for i24 -> {i8, i8, i8}.\n             let can_store_through_cast_ptr = false;\n@@ -492,7 +497,7 @@ impl<'gcc, 'tcx> ArgAbiExt<'gcc, 'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n             PassMode::Indirect { extra_attrs: Some(_), .. } => {\n                 OperandValue::Ref(next(), Some(next()), self.layout.align.abi).store(bx, dst);\n             },\n-            PassMode::Direct(_) | PassMode::Indirect { extra_attrs: None, .. } | PassMode::Cast(_) => {\n+            PassMode::Direct(_) | PassMode::Indirect { extra_attrs: None, .. } | PassMode::Cast(..) => {\n                 let next_arg = next();\n                 self.store(bx, next_arg, dst);\n             },\n@@ -1128,7 +1133,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n fn try_intrinsic<'a, 'b, 'gcc, 'tcx>(bx: &'b mut Builder<'a, 'gcc, 'tcx>, try_func: RValue<'gcc>, data: RValue<'gcc>, _catch_func: RValue<'gcc>, dest: RValue<'gcc>) {\n     if bx.sess().panic_strategy() == PanicStrategy::Abort {\n-        bx.call(bx.type_void(), try_func, &[data], None);\n+        bx.call(bx.type_void(), None, try_func, &[data], None);\n         // Return 0 unconditionally from the intrinsic call;\n         // we can never unwind.\n         let ret_align = bx.tcx.data_layout.i32_align.abi;\n@@ -1197,21 +1202,21 @@ fn codegen_gnu_try<'gcc>(bx: &mut Builder<'_, 'gcc, '_>, try_func: RValue<'gcc>,\n         let zero = bx.cx.context.new_rvalue_zero(bx.int_type);\n         let ptr = bx.cx.context.new_call(None, eh_pointer_builtin, &[zero]);\n         let catch_ty = bx.type_func(&[bx.type_i8p(), bx.type_i8p()], bx.type_void());\n-        bx.call(catch_ty, catch_func, &[data, ptr], None);\n+        bx.call(catch_ty, None, catch_func, &[data, ptr], None);\n         bx.ret(bx.const_i32(1));\n \n         // NOTE: the blocks must be filled before adding the try/catch, otherwise gcc will not\n         // generate a try/catch.\n         // FIXME(antoyo): add a check in the libgccjit API to prevent this.\n         bx.switch_to_block(current_block);\n-        bx.invoke(try_func_ty, try_func, &[data], then, catch, None);\n+        bx.invoke(try_func_ty, None, try_func, &[data], then, catch, None);\n     });\n \n     let func = unsafe { std::mem::transmute(func) };\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n-    let ret = bx.call(llty, func, &[try_func, data, catch_func], None);\n+    let ret = bx.call(llty, None, func, &[try_func, data, catch_func], None);\n     let i32_align = bx.tcx().data_layout.i32_align.abi;\n     bx.store(ret, dest, i32_align);\n }\n@@ -1248,8 +1253,8 @@ fn get_rust_try_fn<'a, 'gcc, 'tcx>(cx: &'a CodegenCx<'gcc, 'tcx>, codegen: &mut\n     )));\n     // `unsafe fn(unsafe fn(*mut i8) -> (), *mut i8, unsafe fn(*mut i8, *mut i8) -> ()) -> i32`\n     let rust_fn_sig = ty::Binder::dummy(cx.tcx.mk_fn_sig(\n-        [try_fn_ty, i8p, catch_fn_ty].iter(),\n-        &tcx.types.i32,\n+        [try_fn_ty, i8p, catch_fn_ty],\n+        tcx.types.i32,\n         false,\n         rustc_hir::Unsafety::Unsafe,\n         Abi::Rust,"}, {"sha": "b59c3a64f5728bdd2ad61fd728ccc64b4e9709b9", "filename": "src/intrinsic/simd.rs", "status": "modified", "additions": 211, "deletions": 235, "changes": 446, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/src%2Fintrinsic%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/src%2Fintrinsic%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fsimd.rs?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -1,57 +1,74 @@\n-#[cfg_attr(not(feature=\"master\"), allow(unused_imports))]\n-use gccjit::{ToRValue, ComparisonOp, UnaryOp};\n+#[cfg(feature=\"master\")]\n+use gccjit::{ComparisonOp, UnaryOp};\n+use gccjit::ToRValue;\n use gccjit::{BinaryOp, RValue, Type};\n+\n use rustc_codegen_ssa::base::compare_simd_types;\n-use rustc_codegen_ssa::common::{IntPredicate, TypeKind, span_invalid_monomorphization_error};\n+use rustc_codegen_ssa::common::{IntPredicate, TypeKind};\n+#[cfg(feature=\"master\")]\n+use rustc_codegen_ssa::errors::ExpectedPointerMutability;\n+use rustc_codegen_ssa::errors::InvalidMonomorphization;\n use rustc_codegen_ssa::mir::operand::OperandRef;\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{BaseTypeMethods, BuilderMethods};\n use rustc_hir as hir;\n use rustc_middle::span_bug;\n use rustc_middle::ty::layout::HasTyCtxt;\n use rustc_middle::ty::{self, Ty};\n-use rustc_span::{Span, Symbol, sym};\n+use rustc_span::{sym, Span, Symbol};\n use rustc_target::abi::Align;\n \n use crate::builder::Builder;\n #[cfg(feature=\"master\")]\n use crate::context::CodegenCx;\n-\n-pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>, name: Symbol, callee_ty: Ty<'tcx>, args: &[OperandRef<'tcx, RValue<'gcc>>], ret_ty: Ty<'tcx>, llret_ty: Type<'gcc>, span: Span) -> Result<RValue<'gcc>, ()> {\n+#[cfg(feature=\"master\")]\n+use crate::errors::{InvalidMonomorphizationExpectedSignedUnsigned, InvalidMonomorphizationInsertedType};\n+use crate::errors::{\n+    InvalidMonomorphizationExpectedSimd,\n+    InvalidMonomorphizationInvalidBitmask,\n+    InvalidMonomorphizationInvalidFloatVector, InvalidMonomorphizationMaskType,\n+    InvalidMonomorphizationMismatchedLengths, InvalidMonomorphizationNotFloat,\n+    InvalidMonomorphizationReturnElement, InvalidMonomorphizationReturnIntegerType,\n+    InvalidMonomorphizationReturnLength, InvalidMonomorphizationReturnLengthInputType,\n+    InvalidMonomorphizationReturnType, InvalidMonomorphizationSimdShuffle,\n+    InvalidMonomorphizationUnrecognized, InvalidMonomorphizationUnsupportedElement,\n+    InvalidMonomorphizationUnsupportedOperation,\n+};\n+\n+pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n+    bx: &mut Builder<'a, 'gcc, 'tcx>,\n+    name: Symbol,\n+    callee_ty: Ty<'tcx>,\n+    args: &[OperandRef<'tcx, RValue<'gcc>>],\n+    ret_ty: Ty<'tcx>,\n+    llret_ty: Type<'gcc>,\n+    span: Span,\n+) -> Result<RValue<'gcc>, ()> {\n     // macros for error handling:\n-    #[allow(unused_macro_rules)]\n-    macro_rules! emit_error {\n-        ($msg: tt) => {\n-            emit_error!($msg, )\n-        };\n-        ($msg: tt, $($fmt: tt)*) => {\n-            span_invalid_monomorphization_error(\n-                bx.sess(), span,\n-                &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \", $msg),\n-                         name, $($fmt)*));\n-        }\n-    }\n-\n     macro_rules! return_error {\n-        ($($fmt: tt)*) => {\n-            {\n-                emit_error!($($fmt)*);\n-                return Err(());\n-            }\n-        }\n+        ($err:expr) => {{\n+            bx.sess().emit_err($err);\n+            return Err(());\n+        }};\n     }\n-\n     macro_rules! require {\n-        ($cond: expr, $($fmt: tt)*) => {\n+        ($cond:expr, $err:expr) => {\n             if !$cond {\n-                return_error!($($fmt)*);\n+                return_error!($err);\n             }\n         };\n     }\n-\n     macro_rules! require_simd {\n         ($ty: expr, $position: expr) => {\n-            require!($ty.is_simd(), \"expected SIMD {} type, found non-SIMD `{}`\", $position, $ty)\n+            require!(\n+                $ty.is_simd(),\n+                InvalidMonomorphizationExpectedSimd {\n+                    span,\n+                    name,\n+                    position: $position,\n+                    found_ty: $ty\n+                }\n+            )\n         };\n     }\n \n@@ -73,7 +90,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n             ty::Uint(i) if i.bit_width() == Some(expected_int_bits) => args[0].immediate(),\n             ty::Array(elem, len)\n                 if matches!(elem.kind(), ty::Uint(ty::UintTy::U8))\n-                    && len.try_eval_usize(bx.tcx, ty::ParamEnv::reveal_all())\n+                    && len.try_eval_target_usize(bx.tcx, ty::ParamEnv::reveal_all())\n                         == Some(expected_bytes) =>\n             {\n                 let place = PlaceRef::alloca(bx, args[0].layout);\n@@ -82,12 +99,13 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                 let ptr = bx.pointercast(place.llval, bx.cx.type_ptr_to(int_ty));\n                 bx.load(int_ty, ptr, Align::ONE)\n             }\n-            _ => return_error!(\n-                \"invalid bitmask `{}`, expected `u{}` or `[u8; {}]`\",\n-                mask_ty,\n+            _ => return_error!(InvalidMonomorphizationInvalidBitmask {\n+                span,\n+                name,\n+                ty: mask_ty,\n                 expected_int_bits,\n                 expected_bytes\n-            ),\n+            }),\n         };\n \n         let arg1 = args[1].immediate();\n@@ -133,18 +151,18 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let (out_len, out_ty) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n-            \"expected return type with length {} (same as input type `{}`), \\\n-             found `{}` with length {}\",\n-            in_len,\n-            in_ty,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphizationReturnLengthInputType {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                ret_ty,\n+                out_len\n+            }\n         );\n         require!(\n             bx.type_kind(bx.element_type(llret_ty)) == TypeKind::Integer,\n-            \"expected return type with integer elements, found `{}` with non-integer `{}`\",\n-            ret_ty,\n-            out_ty\n+            InvalidMonomorphizationReturnIntegerType { span, name, ret_ty, out_ty }\n         );\n \n         return Ok(compare_simd_types(\n@@ -158,65 +176,49 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n     }\n \n     if let Some(stripped) = name.as_str().strip_prefix(\"simd_shuffle\") {\n-        let n: u64 =\n-            if stripped.is_empty() {\n-                // Make sure this is actually an array, since typeck only checks the length-suffixed\n-                // version of this intrinsic.\n-                match args[2].layout.ty.kind() {\n-                    ty::Array(ty, len) if matches!(ty.kind(), ty::Uint(ty::UintTy::U32)) => {\n-                        len.try_eval_usize(bx.cx.tcx, ty::ParamEnv::reveal_all()).unwrap_or_else(|| {\n-                            span_bug!(span, \"could not evaluate shuffle index array length\")\n-                        })\n-                    }\n-                    _ => return_error!(\n-                        \"simd_shuffle index must be an array of `u32`, got `{}`\",\n-                        args[2].layout.ty\n-                    ),\n+        let n: u64 = if stripped.is_empty() {\n+            // Make sure this is actually an array, since typeck only checks the length-suffixed\n+            // version of this intrinsic.\n+            match args[2].layout.ty.kind() {\n+                ty::Array(ty, len) if matches!(ty.kind(), ty::Uint(ty::UintTy::U32)) => {\n+                    len.try_eval_target_usize(bx.cx.tcx, ty::ParamEnv::reveal_all()).unwrap_or_else(\n+                        || span_bug!(span, \"could not evaluate shuffle index array length\"),\n+                    )\n                 }\n+                _ => return_error!(InvalidMonomorphizationSimdShuffle {\n+                    span,\n+                    name,\n+                    ty: args[2].layout.ty\n+                }),\n             }\n-            else {\n-                stripped.parse().unwrap_or_else(|_| {\n-                    span_bug!(span, \"bad `simd_shuffle` instruction only caught in codegen?\")\n-                })\n-            };\n+        } else {\n+            stripped.parse().unwrap_or_else(|_| {\n+                span_bug!(span, \"bad `simd_shuffle` instruction only caught in codegen?\")\n+            })\n+        };\n \n         require_simd!(ret_ty, \"return\");\n \n         let (out_len, out_ty) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             out_len == n,\n-            \"expected return type of length {}, found `{}` with length {}\",\n-            n,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphizationReturnLength { span, name, in_len: n, ret_ty, out_len }\n         );\n         require!(\n             in_elem == out_ty,\n-            \"expected return element type `{}` (element of input `{}`), \\\n-             found `{}` with element type `{}`\",\n-            in_elem,\n-            in_ty,\n-            ret_ty,\n-            out_ty\n+            InvalidMonomorphizationReturnElement { span, name, in_elem, in_ty, ret_ty, out_ty }\n         );\n \n         let vector = args[2].immediate();\n \n-        return Ok(bx.shuffle_vector(\n-            args[0].immediate(),\n-            args[1].immediate(),\n-            vector,\n-        ));\n+        return Ok(bx.shuffle_vector(args[0].immediate(), args[1].immediate(), vector));\n     }\n \n-    #[cfg(feature=\"master\")]\n+    #[cfg(feature = \"master\")]\n     if name == sym::simd_insert {\n         require!(\n             in_elem == arg_tys[2],\n-            \"expected inserted type `{}` (element of input `{}`), found `{}`\",\n-            in_elem,\n-            in_ty,\n-            arg_tys[2]\n+            InvalidMonomorphizationInsertedType { span, name, in_elem, in_ty, out_ty: arg_tys[2] }\n         );\n         let vector = args[0].immediate();\n         let index = args[1].immediate();\n@@ -229,14 +231,11 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         return Ok(variable.to_rvalue());\n     }\n \n-    #[cfg(feature=\"master\")]\n+    #[cfg(feature = \"master\")]\n     if name == sym::simd_extract {\n         require!(\n             ret_ty == in_elem,\n-            \"expected return type `{}` (element of input `{}`), found `{}`\",\n-            in_elem,\n-            in_ty,\n-            ret_ty\n+            InvalidMonomorphizationReturnType { span, name, in_elem, in_ty, ret_ty }\n         );\n         let vector = args[0].immediate();\n         return Ok(bx.context.new_vector_access(None, vector, args[1].immediate()).to_rvalue());\n@@ -249,13 +248,11 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let (v_len, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n         require!(\n             m_len == v_len,\n-            \"mismatched lengths: mask length `{}` != other vector length `{}`\",\n-            m_len,\n-            v_len\n+            InvalidMonomorphizationMismatchedLengths { span, name, m_len, v_len }\n         );\n         match m_elem_ty.kind() {\n             ty::Int(_) => {}\n-            _ => return_error!(\"mask element type is `{}`, expected `i_`\", m_elem_ty),\n+            _ => return_error!(InvalidMonomorphizationMaskType { span, name, ty: m_elem_ty }),\n         }\n         return Ok(bx.vector_select(args[0].immediate(), args[1].immediate(), args[2].immediate()));\n     }\n@@ -266,12 +263,14 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n-            \"expected return type with length {} (same as input type `{}`), \\\n-                  found `{}` with length {}\",\n-            in_len,\n-            in_ty,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphizationReturnLengthInputType {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                ret_ty,\n+                out_len\n+            }\n         );\n         // casting cares about nominal type, not just structural type\n         if in_elem == out_elem {\n@@ -302,11 +301,14 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n             (Style::Unsupported, Style::Unsupported) => {\n                 require!(\n                     false,\n-                    \"unsupported cast from `{}` with element `{}` to `{}` with element `{}`\",\n-                    in_ty,\n-                    in_elem,\n-                    ret_ty,\n-                    out_elem\n+                    InvalidMonomorphization::UnsupportedCast {\n+                        span,\n+                        name,\n+                        in_ty,\n+                        in_elem,\n+                        ret_ty,\n+                        out_elem\n+                    }\n                 );\n             },\n             _ => return Ok(bx.context.convert_vector(None, args[0].immediate(), llret_ty)),\n@@ -322,10 +324,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                     })*\n                     _ => {},\n                 }\n-                require!(false,\n-                         \"unsupported operation on `{}` with element `{}`\",\n-                         in_ty,\n-                         in_elem)\n+                return_error!(InvalidMonomorphizationUnsupportedOperation { span, name, in_ty, in_elem })\n             })*\n         }\n     }\n@@ -372,7 +371,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n             }\n             ty::Array(elem, len)\n                 if matches!(elem.kind(), ty::Uint(ty::UintTy::U8))\n-                    && len.try_eval_usize(bx.tcx, ty::ParamEnv::reveal_all())\n+                    && len.try_eval_target_usize(bx.tcx, ty::ParamEnv::reveal_all())\n                         == Some(expected_bytes) =>\n             {\n                 // Zero-extend iN to the array length:\n@@ -385,12 +384,13 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                 let ptr = bx.pointercast(ptr, bx.cx.type_ptr_to(array_ty));\n                 return Ok(bx.load(array_ty, ptr, Align::ONE));\n             }\n-            _ => return_error!(\n-                \"cannot return `{}`, expected `u{}` or `[u8; {}]`\",\n+            _ => return_error!(InvalidMonomorphization::CannotReturn {\n+                span,\n+                name,\n                 ret_ty,\n                 expected_int_bits,\n                 expected_bytes\n-            ),\n+            }),\n         }\n     }\n \n@@ -403,40 +403,25 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         span: Span,\n         args: &[OperandRef<'tcx, RValue<'gcc>>],\n     ) -> Result<RValue<'gcc>, ()> {\n-        macro_rules! emit_error {\n-            ($msg: tt, $($fmt: tt)*) => {\n-                span_invalid_monomorphization_error(\n-                    bx.sess(), span,\n-                    &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \", $msg),\n-                             name, $($fmt)*));\n-            }\n-        }\n         macro_rules! return_error {\n-            ($($fmt: tt)*) => {\n-                {\n-                    emit_error!($($fmt)*);\n-                    return Err(());\n-                }\n-            }\n+            ($err:expr) => {{\n+                bx.sess().emit_err($err);\n+                return Err(());\n+            }};\n         }\n-\n         let (elem_ty_str, elem_ty) =\n             if let ty::Float(f) = in_elem.kind() {\n                 let elem_ty = bx.cx.type_float_from_ty(*f);\n                 match f.bit_width() {\n                     32 => (\"f\", elem_ty),\n                     64 => (\"\", elem_ty),\n                     _ => {\n-                        return_error!(\n-                            \"unsupported element type `{}` of floating-point vector `{}`\",\n-                            f.name_str(),\n-                            in_ty\n-                        );\n+                        return_error!(InvalidMonomorphizationInvalidFloatVector { span, name, elem_ty: f.name_str(), vec_ty: in_ty });\n                     }\n                 }\n             }\n             else {\n-                return_error!(\"`{}` is not a floating-point type\", in_ty);\n+                return_error!(InvalidMonomorphizationNotFloat { span, name, ty: in_ty });\n             };\n \n         let vec_ty = bx.cx.type_vector(elem_ty, in_len);\n@@ -459,7 +444,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                 sym::simd_fsqrt => \"sqrt\",\n                 sym::simd_round => \"round\",\n                 sym::simd_trunc => \"trunc\",\n-                _ => return_error!(\"unrecognized intrinsic `{}`\", name),\n+                _ => return_error!(InvalidMonomorphizationUnrecognized { span, name })\n             };\n         let builtin_name = format!(\"{}{}\", intr_name, elem_ty_str);\n         let funcs = bx.cx.functions.borrow();\n@@ -585,27 +570,32 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let (out_len2, _) = arg_tys[2].simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n-            \"expected {} argument with length {} (same as input type `{}`), \\\n-            found `{}` with length {}\",\n-            \"second\",\n-            in_len,\n-            in_ty,\n-            arg_tys[1],\n-            out_len\n+            InvalidMonomorphization::SecondArgumentLength {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                arg_ty: arg_tys[1],\n+                out_len\n+            }\n         );\n         require!(\n             in_len == out_len2,\n-            \"expected {} argument with length {} (same as input type `{}`), \\\n-            found `{}` with length {}\",\n-            \"third\",\n-            in_len,\n-            in_ty,\n-            arg_tys[2],\n-            out_len2\n+            InvalidMonomorphization::ThirdArgumentLength {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                arg_ty: arg_tys[2],\n+                out_len: out_len2\n+            }\n         );\n \n         // The return type must match the first argument type\n-        require!(ret_ty == in_ty, \"expected return type `{}`, found `{}`\", in_ty, ret_ty);\n+        require!(\n+            ret_ty == in_ty,\n+            InvalidMonomorphization::ExpectedReturnType { span, name, in_ty, ret_ty }\n+        );\n \n         // This counts how many pointers\n         fn ptr_count(t: Ty<'_>) -> usize {\n@@ -632,15 +622,15 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n             _ => {\n                 require!(\n                     false,\n-                    \"expected element type `{}` of second argument `{}` \\\n-                    to be a pointer to the element type `{}` of the first \\\n-                        argument `{}`, found `{}` != `*_ {}`\",\n-                        element_ty1,\n-                        arg_tys[1],\n+                    InvalidMonomorphization::ExpectedElementType {\n+                        span,\n+                        name,\n+                        expected_element: element_ty1,\n+                        second_arg: arg_tys[1],\n                         in_elem,\n                         in_ty,\n-                        element_ty1,\n-                        in_elem\n+                        mutability: ExpectedPointerMutability::Not,\n+                    }\n                 );\n                 unreachable!();\n             }\n@@ -656,10 +646,12 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n             _ => {\n                 require!(\n                     false,\n-                    \"expected element type `{}` of third argument `{}` \\\n-                    to be a signed integer type\",\n-                    element_ty2,\n-                    arg_tys[2]\n+                    InvalidMonomorphization::ThirdArgElementType {\n+                        span,\n+                        name,\n+                        expected_element: element_ty2,\n+                        third_arg: arg_tys[2]\n+                    }\n                 );\n             }\n         }\n@@ -685,23 +677,25 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let (element_len2, _) = arg_tys[2].simd_size_and_type(bx.tcx());\n         require!(\n             in_len == element_len1,\n-            \"expected {} argument with length {} (same as input type `{}`), \\\n-            found `{}` with length {}\",\n-            \"second\",\n-            in_len,\n-            in_ty,\n-            arg_tys[1],\n-            element_len1\n+            InvalidMonomorphization::SecondArgumentLength {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                arg_ty: arg_tys[1],\n+                out_len: element_len1\n+            }\n         );\n         require!(\n             in_len == element_len2,\n-            \"expected {} argument with length {} (same as input type `{}`), \\\n-            found `{}` with length {}\",\n-            \"third\",\n-            in_len,\n-            in_ty,\n-            arg_tys[2],\n-            element_len2\n+            InvalidMonomorphization::ThirdArgumentLength {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                arg_ty: arg_tys[2],\n+                out_len: element_len2\n+            }\n         );\n \n         // This counts how many pointers\n@@ -732,15 +726,15 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n             _ => {\n                 require!(\n                     false,\n-                    \"expected element type `{}` of second argument `{}` \\\n-                    to be a pointer to the element type `{}` of the first \\\n-                        argument `{}`, found `{}` != `*mut {}`\",\n-                        element_ty1,\n-                        arg_tys[1],\n+                    InvalidMonomorphization::ExpectedElementType {\n+                        span,\n+                        name,\n+                        expected_element: element_ty1,\n+                        second_arg: arg_tys[1],\n                         in_elem,\n                         in_ty,\n-                        element_ty1,\n-                        in_elem\n+                        mutability: ExpectedPointerMutability::Mut,\n+                    }\n                 );\n                 unreachable!();\n             }\n@@ -755,10 +749,12 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n             _ => {\n                 require!(\n                     false,\n-                    \"expected element type `{}` of third argument `{}` \\\n-                    be a signed integer type\",\n-                    element_ty2,\n-                    arg_tys[2]\n+                    InvalidMonomorphization::ThirdArgElementType {\n+                        span,\n+                        name,\n+                        expected_element: element_ty2,\n+                        third_arg: arg_tys[2]\n+                    }\n                 );\n             }\n         }\n@@ -813,10 +809,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                     })*\n                     _ => {},\n                 }\n-                require!(false,\n-                         \"unsupported operation on `{}` with element `{}`\",\n-                         in_ty,\n-                         in_elem)\n+                return_error!(InvalidMonomorphizationUnsupportedOperation { span, name, in_ty, in_elem })\n             })*\n         }\n     }\n@@ -825,7 +818,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         simd_neg: Int => neg, Float => fneg;\n     }\n \n-    #[cfg(feature=\"master\")]\n+    #[cfg(feature = \"master\")]\n     if name == sym::simd_saturating_add || name == sym::simd_saturating_sub {\n         let lhs = args[0].immediate();\n         let rhs = args[1].immediate();\n@@ -836,14 +829,14 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                 ty::Int(i) => (true, i.bit_width().unwrap_or(ptr_bits) / 8, bx.cx.type_int_from_ty(i)),\n                 ty::Uint(i) => (false, i.bit_width().unwrap_or(ptr_bits) / 8, bx.cx.type_uint_from_ty(i)),\n                 _ => {\n-                    return_error!(\n-                        \"expected element type `{}` of vector type `{}` \\\n-                     to be a signed or unsigned integer type\",\n-                     arg_tys[0].simd_size_and_type(bx.tcx()).1,\n-                     arg_tys[0]\n-                    );\n-                }\n-            };\n+                return_error!(InvalidMonomorphizationExpectedSignedUnsigned {\n+                    span,\n+                    name,\n+                    elem_ty: arg_tys[0].simd_size_and_type(bx.tcx()).1,\n+                    vec_ty: arg_tys[0],\n+                });\n+            }\n+        };\n \n         let result =\n             match (signed, is_add) {\n@@ -924,10 +917,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n             if name == sym::$name {\n                 require!(\n                     ret_ty == in_elem,\n-                    \"expected return type `{}` (element of input `{}`), found `{}`\",\n-                    in_elem,\n-                    in_ty,\n-                    ret_ty\n+                    InvalidMonomorphizationReturnType { span, name, in_elem, in_ty, ret_ty }\n                 );\n                 return match in_elem.kind() {\n                     ty::Int(_) | ty::Uint(_) => {\n@@ -936,8 +926,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                             // if overflow occurs, the result is the\n                             // mathematical result modulo 2^n:\n                             Ok(bx.$op(args[1].immediate(), r))\n-                        }\n-                        else {\n+                        } else {\n                             Ok(bx.vector_reduce_op(args[0].immediate(), $vec_op))\n                         }\n                     }\n@@ -946,18 +935,17 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                             // ordered arithmetic reductions take an accumulator\n                             let acc = args[1].immediate();\n                             Ok(bx.$float_reduce(acc, args[0].immediate()))\n-                        }\n-                        else {\n+                        } else {\n                             Ok(bx.vector_reduce_op(args[0].immediate(), $vec_op))\n                         }\n                     }\n-                    _ => return_error!(\n-                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                        sym::$name,\n+                    _ => return_error!(InvalidMonomorphizationUnsupportedElement {\n+                        span,\n+                        name,\n                         in_ty,\n-                        in_elem,\n+                        elem_ty: in_elem,\n                         ret_ty\n-                    ),\n+                    }),\n                 };\n             }\n         };\n@@ -998,21 +986,12 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n             if name == sym::$name {\n                 require!(\n                     ret_ty == in_elem,\n-                    \"expected return type `{}` (element of input `{}`), found `{}`\",\n-                    in_elem,\n-                    in_ty,\n-                    ret_ty\n+                    InvalidMonomorphizationReturnType { span, name, in_elem, in_ty, ret_ty }\n                 );\n                 return match in_elem.kind() {\n                     ty::Int(_) | ty::Uint(_) => Ok(bx.$int_red(args[0].immediate())),\n                     ty::Float(_) => Ok(bx.$float_red(args[0].immediate())),\n-                    _ => return_error!(\n-                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                        sym::$name,\n-                        in_ty,\n-                        in_elem,\n-                        ret_ty\n-                    ),\n+                    _ => return_error!(InvalidMonomorphizationUnsupportedElement { span, name, in_ty, elem_ty: in_elem, ret_ty }),\n                 };\n             }\n         };\n@@ -1030,22 +1009,19 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                 let input = if !$boolean {\n                     require!(\n                         ret_ty == in_elem,\n-                        \"expected return type `{}` (element of input `{}`), found `{}`\",\n-                        in_elem,\n-                        in_ty,\n-                        ret_ty\n+                        InvalidMonomorphizationReturnType { span, name, in_elem, in_ty, ret_ty }\n                     );\n                     args[0].immediate()\n                 } else {\n                     match in_elem.kind() {\n                         ty::Int(_) | ty::Uint(_) => {}\n-                        _ => return_error!(\n-                            \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                            sym::$name,\n+                        _ => return_error!(InvalidMonomorphizationUnsupportedElement {\n+                            span,\n+                            name,\n                             in_ty,\n-                            in_elem,\n+                            elem_ty: in_elem,\n                             ret_ty\n-                        ),\n+                        }),\n                     }\n \n                     args[0].immediate()\n@@ -1055,13 +1031,13 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                         let r = bx.vector_reduce_op(input, $op);\n                         Ok(if !$boolean { r } else { bx.icmp(IntPredicate::IntNE, r, bx.context.new_rvalue_zero(r.get_type())) })\n                     }\n-                    _ => return_error!(\n-                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                        sym::$name,\n+                    _ => return_error!(InvalidMonomorphizationUnsupportedElement {\n+                        span,\n+                        name,\n                         in_ty,\n-                        in_elem,\n+                        elem_ty: in_elem,\n                         ret_ty\n-                    ),\n+                    }),\n                 };\n             }\n         };"}, {"sha": "1b7feb5f8a18e77edd9edd8f6c74b5bc619b205b", "filename": "src/lib.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -18,13 +18,17 @@\n #![recursion_limit=\"256\"]\n #![warn(rust_2018_idioms)]\n #![warn(unused_lifetimes)]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n+extern crate rustc_apfloat;\n extern crate rustc_ast;\n extern crate rustc_attr;\n extern crate rustc_codegen_ssa;\n extern crate rustc_data_structures;\n extern crate rustc_errors;\n extern crate rustc_hir;\n+extern crate rustc_macros;\n extern crate rustc_metadata;\n extern crate rustc_middle;\n extern crate rustc_session;\n@@ -51,6 +55,7 @@ mod context;\n mod coverageinfo;\n mod debuginfo;\n mod declare;\n+mod errors;\n mod int;\n mod intrinsic;\n mod mono_item;\n@@ -60,6 +65,7 @@ mod type_of;\n use std::any::Any;\n use std::sync::{Arc, Mutex};\n \n+use crate::errors::LTONotSupported;\n use gccjit::{Context, OptimizationLevel, CType};\n use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_codegen_ssa::{CodegenResults, CompiledModule, ModuleCodegen};\n@@ -69,7 +75,8 @@ use rustc_codegen_ssa::back::lto::{LtoModuleCodegen, SerializedModule, ThinModul\n use rustc_codegen_ssa::target_features::supported_target_features;\n use rustc_codegen_ssa::traits::{CodegenBackend, ExtraBackendMethods, ModuleBufferMethods, ThinBufferMethods, WriteBackendMethods};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{ErrorGuaranteed, Handler};\n+use rustc_errors::{DiagnosticMessage, ErrorGuaranteed, Handler, SubdiagnosticMessage};\n+use rustc_macros::fluent_messages;\n use rustc_metadata::EncodedMetadata;\n use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n use rustc_middle::ty::TyCtxt;\n@@ -80,6 +87,8 @@ use rustc_span::Symbol;\n use rustc_span::fatal_error::FatalError;\n use tempfile::TempDir;\n \n+fluent_messages! { \"../locales/en-US.ftl\" }\n+\n pub struct PrintOnPanic<F: Fn() -> String>(pub F);\n \n impl<F: Fn() -> String> Drop for PrintOnPanic<F> {\n@@ -96,9 +105,13 @@ pub struct GccCodegenBackend {\n }\n \n impl CodegenBackend for GccCodegenBackend {\n+    fn locale_resource(&self) -> &'static str {\n+        crate::DEFAULT_LOCALE_RESOURCE\n+    }\n+\n     fn init(&self, sess: &Session) {\n         if sess.lto() != Lto::No {\n-            sess.warn(\"LTO is not supported. You may get a linker error.\");\n+            sess.emit_warning(LTONotSupported {});\n         }\n \n         let temp_dir = TempDir::new().expect(\"cannot create temporary directory\");\n@@ -149,15 +162,15 @@ impl CodegenBackend for GccCodegenBackend {\n }\n \n impl ExtraBackendMethods for GccCodegenBackend {\n-    fn codegen_allocator<'tcx>(&self, tcx: TyCtxt<'tcx>, module_name: &str, kind: AllocatorKind, has_alloc_error_handler: bool) -> Self::Module {\n+    fn codegen_allocator<'tcx>(&self, tcx: TyCtxt<'tcx>, module_name: &str, kind: AllocatorKind, alloc_error_handler_kind: AllocatorKind) -> Self::Module {\n         let mut mods = GccContext {\n             context: Context::default(),\n         };\n-        unsafe { allocator::codegen(tcx, &mut mods, module_name, kind, has_alloc_error_handler); }\n+        unsafe { allocator::codegen(tcx, &mut mods, module_name, kind, alloc_error_handler_kind); }\n         mods\n     }\n \n-    fn compile_codegen_unit<'tcx>(&self, tcx: TyCtxt<'tcx>, cgu_name: Symbol) -> (ModuleCodegen<Self::Module>, u64) {\n+    fn compile_codegen_unit(&self, tcx: TyCtxt<'_>, cgu_name: Symbol) -> (ModuleCodegen<Self::Module>, u64) {\n         base::compile_codegen_unit(tcx, cgu_name, *self.supports_128bit_integers.lock().expect(\"lock\"))\n     }\n \n@@ -167,15 +180,6 @@ impl ExtraBackendMethods for GccCodegenBackend {\n             Ok(())\n         })\n     }\n-\n-    fn target_cpu<'b>(&self, _sess: &'b Session) -> &'b str {\n-        unimplemented!();\n-    }\n-\n-    fn tune_cpu<'b>(&self, _sess: &'b Session) -> Option<&'b str> {\n-        None\n-        // TODO(antoyo)\n-    }\n }\n \n pub struct ModuleBuffer;\n@@ -205,8 +209,8 @@ unsafe impl Sync for GccContext {}\n impl WriteBackendMethods for GccCodegenBackend {\n     type Module = GccContext;\n     type TargetMachine = ();\n+    type TargetMachineError = ();\n     type ModuleBuffer = ModuleBuffer;\n-    type Context = ();\n     type ThinData = ();\n     type ThinBuffer = ThinBuffer;\n \n@@ -324,10 +328,10 @@ pub fn target_features(sess: &Session, allow_unstable: bool) -> Vec<Symbol> {\n                 false\n             }\n             /*\n-               adx, aes, avx, avx2, avx512bf16, avx512bitalg, avx512bw, avx512cd, avx512dq, avx512er, avx512f, avx512gfni,\n-               avx512ifma, avx512pf, avx512vaes, avx512vbmi, avx512vbmi2, avx512vl, avx512vnni, avx512vp2intersect, avx512vpclmulqdq,\n-               avx512vpopcntdq, bmi1, bmi2, cmpxchg16b, ermsb, f16c, fma, fxsr, lzcnt, movbe, pclmulqdq, popcnt, rdrand, rdseed, rtm,\n-               sha, sse, sse2, sse3, sse4.1, sse4.2, sse4a, ssse3, tbm, xsave, xsavec, xsaveopt, xsaves\n+               adx, aes, avx, avx2, avx512bf16, avx512bitalg, avx512bw, avx512cd, avx512dq, avx512er, avx512f, avx512ifma,\n+               avx512pf, avx512vbmi, avx512vbmi2, avx512vl, avx512vnni, avx512vp2intersect, avx512vpopcntdq,\n+               bmi1, bmi2, cmpxchg16b, ermsb, f16c, fma, fxsr, gfni, lzcnt, movbe, pclmulqdq, popcnt, rdrand, rdseed, rtm,\n+               sha, sse, sse2, sse3, sse4.1, sse4.2, sse4a, ssse3, tbm, vaes, vpclmulqdq, xsave, xsavec, xsaveopt, xsaves\n              */\n             //false\n         })"}, {"sha": "c1f6340866cacc5edc6e13276f47f2fa4be140cd", "filename": "src/mono_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/src%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/src%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmono_item.rs?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -4,7 +4,7 @@ use rustc_codegen_ssa::traits::PreDefineMethods;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::mono::{Linkage, Visibility};\n-use rustc_middle::ty::{self, Instance, TypeVisitable};\n+use rustc_middle::ty::{self, Instance, TypeVisitableExt};\n use rustc_middle::ty::layout::{FnAbiOf, LayoutOf};\n \n use crate::attributes;"}, {"sha": "daa661f35c4c108767b9bfde5476544944506b47", "filename": "src/type_.rs", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/src%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/src%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftype_.rs?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -1,5 +1,3 @@\n-use std::convert::TryInto;\n-\n use gccjit::{RValue, Struct, Type};\n use rustc_codegen_ssa::traits::{BaseTypeMethods, DerivedTypeMethods, TypeMembershipMethods};\n use rustc_codegen_ssa::common::TypeKind;\n@@ -201,6 +199,21 @@ impl<'gcc, 'tcx> BaseTypeMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n     fn val_ty(&self, value: RValue<'gcc>) -> Type<'gcc> {\n         value.get_type()\n     }\n+\n+    fn type_array(&self, ty: Type<'gcc>, len: u64) -> Type<'gcc> {\n+        // TODO: remove this as well?\n+        /*if let Some(struct_type) = ty.is_struct() {\n+            if struct_type.get_field_count() == 0 {\n+                // NOTE: since gccjit only supports i32 for the array size and libcore's tests uses a\n+                // size of usize::MAX in test_binary_search, we workaround this by setting the size to\n+                // zero for ZSTs.\n+                // FIXME(antoyo): fix gccjit API.\n+                len = 0;\n+            }\n+        }*/\n+\n+        self.context.new_array_type(None, ty, len)\n+    }\n }\n \n impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n@@ -226,27 +239,6 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n     pub fn type_named_struct(&self, name: &str) -> Struct<'gcc> {\n         self.context.new_opaque_struct_type(None, name)\n     }\n-\n-    pub fn type_array(&self, ty: Type<'gcc>, mut len: u64) -> Type<'gcc> {\n-        if let Some(struct_type) = ty.is_struct() {\n-            if struct_type.get_field_count() == 0 {\n-                // NOTE: since gccjit only supports i32 for the array size and libcore's tests uses a\n-                // size of usize::MAX in test_binary_search, we workaround this by setting the size to\n-                // zero for ZSTs.\n-                // FIXME(antoyo): fix gccjit API.\n-                len = 0;\n-            }\n-        }\n-\n-        // NOTE: see note above. Some other test uses usize::MAX.\n-        if len == u64::MAX {\n-            len = 0;\n-        }\n-\n-        let len: i32 = len.try_into().expect(\"array len\");\n-\n-        self.context.new_array_type(None, ty, len)\n-    }\n }\n \n pub fn struct_fields<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLayout<'tcx>) -> (Vec<Type<'gcc>>, bool) {\n@@ -273,7 +265,7 @@ pub fn struct_fields<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLayout\n         offset = target_offset + field.size;\n         prev_effective_align = effective_field_align;\n     }\n-    if !layout.is_unsized() && field_count > 0 {\n+    if layout.is_sized() && field_count > 0 {\n         if offset > layout.size {\n             bug!(\"layout: {:#?} stride: {:?} offset: {:?}\", layout, layout.size, offset);\n         }\n@@ -296,4 +288,8 @@ impl<'gcc, 'tcx> TypeMembershipMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         // Unsupported.\n         self.context.new_rvalue_from_int(self.int_type, 0)\n     }\n+\n+    fn set_kcfi_type_metadata(&self, _function: RValue<'gcc>, _kcfi_typeid: u32) {\n+        // Unsupported.\n+    }\n }"}, {"sha": "5df8c1a209db2e8f9301edb488379200f66832a9", "filename": "src/type_of.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/src%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/src%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftype_of.rs?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -3,10 +3,10 @@ use std::fmt::Write;\n use gccjit::{Struct, Type};\n use crate::rustc_codegen_ssa::traits::{BaseTypeMethods, DerivedTypeMethods, LayoutTypeMethods};\n use rustc_middle::bug;\n-use rustc_middle::ty::{self, Ty, TypeVisitable};\n+use rustc_middle::ty::{self, Ty, TypeVisitableExt};\n use rustc_middle::ty::layout::{FnAbiOf, LayoutOf, TyAndLayout};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n-use rustc_target::abi::{self, Abi, F32, F64, FieldsShape, Int, Integer, Pointer, PointeeInfo, Size, TyAbiInterface, Variants};\n+use rustc_target::abi::{self, Abi, Align, F32, F64, FieldsShape, Int, Integer, Pointer, PointeeInfo, Size, TyAbiInterface, Variants};\n use rustc_target::abi::call::{CastTarget, FnAbi, Reg};\n \n use crate::abi::{FnAbiGccExt, GccType};\n@@ -50,6 +50,12 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n     }\n }\n \n+impl<'a, 'tcx> CodegenCx<'a, 'tcx> {\n+    pub fn align_of(&self, ty: Ty<'tcx>) -> Align {\n+        self.layout_of(ty).align.abi\n+    }\n+}\n+\n fn uncached_gcc_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLayout<'tcx>, defer: &mut Option<(Struct<'gcc>, TyAndLayout<'tcx>)>) -> Type<'gcc> {\n     match layout.abi {\n         Abi::Scalar(_) => bug!(\"handled elsewhere\"),\n@@ -253,7 +259,7 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n             Int(i, false) => cx.type_from_unsigned_integer(i),\n             F32 => cx.type_f32(),\n             F64 => cx.type_f64(),\n-            Pointer => {\n+            Pointer(address_space) => {\n                 // If we know the alignment, pick something better than i8.\n                 let pointee =\n                     if let Some(pointee) = self.pointee_info_at(cx, offset) {\n@@ -262,7 +268,7 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n                     else {\n                         cx.type_i8()\n                     };\n-                cx.type_ptr_to(pointee)\n+                cx.type_ptr_to_ext(pointee, address_space)\n             }\n         }\n     }"}, {"sha": "6139892aefca7d2d42bf35aad2bb9de2726e7f40", "filename": "test.sh", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/test.sh", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/test.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test.sh?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -225,18 +225,21 @@ rustc = \"$HOME/.rustup/toolchains/$rust_toolchain-$TARGET_TRIPLE/bin/rustc\"\n \n [target.x86_64-unknown-linux-gnu]\n llvm-filecheck = \"`which FileCheck-10 || which FileCheck-11 || which FileCheck-12 || which FileCheck-13 || which FileCheck-14`\"\n+\n+[llvm]\n+download-ci-llvm = false\n EOF\n \n     rustc -V | cut -d' ' -f3 | tr -d '('\n-    git checkout $(rustc -V | cut -d' ' -f3 | tr -d '(') src/test\n+    git checkout $(rustc -V | cut -d' ' -f3 | tr -d '(') tests\n }\n \n function asm_tests() {\n     setup_rustc\n \n     echo \"[TEST] rustc test suite\"\n     RUSTC_ARGS=\"-Zpanic-abort-tests -Csymbol-mangling-version=v0 -Zcodegen-backend=\"$(pwd)\"/../target/\"$CHANNEL\"/librustc_codegen_gcc.\"$dylib_ext\" --sysroot \"$(pwd)\"/../build_sysroot/sysroot -Cpanic=abort\"\n-    COMPILETEST_FORCE_STAGE0=1 ./x.py test --run always --stage 0 src/test/assembly/asm --rustc-args \"$RUSTC_ARGS\"\n+    COMPILETEST_FORCE_STAGE0=1 ./x.py test --run always --stage 0 tests/assembly/asm --rustc-args \"$RUSTC_ARGS\"\n }\n \n # FIXME(antoyo): linker gives multiple definitions error on Linux\n@@ -332,21 +335,21 @@ function test_rustc() {\n \n     setup_rustc\n \n-    for test in $(rg -i --files-with-matches \"//(\\[\\w+\\])?~|// error-pattern:|// build-fail|// run-fail|-Cllvm-args\" src/test/ui); do\n+    for test in $(rg -i --files-with-matches \"//(\\[\\w+\\])?~|// error-pattern:|// build-fail|// run-fail|-Cllvm-args\" tests/ui); do\n       rm $test\n     done\n \n-    git checkout -- src/test/ui/issues/auxiliary/issue-3136-a.rs # contains //~ERROR, but shouldn't be removed\n+    git checkout -- tests/ui/issues/auxiliary/issue-3136-a.rs # contains //~ERROR, but shouldn't be removed\n \n-    rm -r src/test/ui/{abi*,extern/,unsized-locals/,proc-macro/,threads-sendsync/,thinlto/,borrowck/,chalkify/bugs/,test*,*lto*.rs,consts/const-float-bits-reject-conv.rs,consts/issue-miri-1910.rs} || true\n-    rm src/test/ui/mir/mir_heavy_promoted.rs # this tests is oom-killed in the CI.\n-    for test in $(rg --files-with-matches \"thread|lto\" src/test/ui); do\n+    rm -r tests/ui/{abi*,extern/,unsized-locals/,proc-macro/,threads-sendsync/,thinlto/,borrowck/,chalkify/bugs/,test*,*lto*.rs,consts/const-float-bits-reject-conv.rs,consts/issue-miri-1910.rs} || true\n+    rm tests/ui/mir/mir_heavy_promoted.rs # this tests is oom-killed in the CI.\n+    for test in $(rg --files-with-matches \"thread|lto\" tests/ui); do\n       rm $test\n     done\n-    git checkout src/test/ui/lto/auxiliary/dylib.rs\n-    git checkout src/test/ui/type-alias-impl-trait/auxiliary/cross_crate_ice.rs\n-    git checkout src/test/ui/type-alias-impl-trait/auxiliary/cross_crate_ice2.rs\n-    git checkout src/test/ui/macros/rfc-2011-nicer-assert-messages/auxiliary/common.rs\n+    git checkout tests/ui/lto/auxiliary/dylib.rs\n+    git checkout tests/ui/type-alias-impl-trait/auxiliary/cross_crate_ice.rs\n+    git checkout tests/ui/type-alias-impl-trait/auxiliary/cross_crate_ice2.rs\n+    git checkout tests/ui/macros/rfc-2011-nicer-assert-messages/auxiliary/common.rs\n \n     RUSTC_ARGS=\"$TEST_FLAGS -Csymbol-mangling-version=v0 -Zcodegen-backend=\"$(pwd)\"/../target/\"$CHANNEL\"/librustc_codegen_gcc.\"$dylib_ext\" --sysroot \"$(pwd)\"/../build_sysroot/sysroot\"\n \n@@ -358,14 +361,14 @@ function test_rustc() {\n         xargs -a ../failing-ui-tests.txt -d'\\n' rm\n     else\n         # Removing all tests.\n-        find src/test/ui -type f -name '*.rs' -not -path '*/auxiliary/*' -delete\n+        find tests/ui -type f -name '*.rs' -not -path '*/auxiliary/*' -delete\n         # Putting back only the failing ones.\n         xargs -a ../failing-ui-tests.txt -d'\\n' git checkout --\n     fi\n \n     if [ $nb_parts -gt 0 ]; then\n         echo \"Splitting ui_test into $nb_parts parts (and running part $current_part)\"\n-        find src/test/ui -type f -name '*.rs' -not -path \"*/auxiliary/*\" > ui_tests\n+        find tests/ui -type f -name '*.rs' -not -path \"*/auxiliary/*\" > ui_tests\n         # To ensure it'll be always the same sub files, we sort the content.\n         sort ui_tests -o ui_tests\n         count=$((`wc -l < ui_tests` / $nb_parts))\n@@ -374,13 +377,13 @@ function test_rustc() {\n         count=$((count + 1))\n         split -d -l $count -a 1 ui_tests ui_tests.split\n         # Removing all tests.\n-        find src/test/ui -type f -name '*.rs' -not -path \"*/auxiliary/*\" -delete\n+        find tests/ui -type f -name '*.rs' -not -path \"*/auxiliary/*\" -delete\n         # Putting back only the ones we want to test.\n         xargs -a \"ui_tests.split$current_part\" -d'\\n' git checkout --\n     fi\n \n     echo \"[TEST] rustc test suite\"\n-    COMPILETEST_FORCE_STAGE0=1 ./x.py test --run always --stage 0 src/test/ui/ --rustc-args \"$RUSTC_ARGS\"\n+    COMPILETEST_FORCE_STAGE0=1 ./x.py test --run always --stage 0 tests/ui/ --rustc-args \"$RUSTC_ARGS\"\n }\n \n function test_failing_rustc() {"}, {"sha": "25041d93e748a6feb2acbd7c14aff9011bb1e7a4", "filename": "tests/run/abort1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/tests%2Frun%2Fabort1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/tests%2Frun%2Fabort1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun%2Fabort1.rs?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -33,6 +33,7 @@ mod intrinsics {\n     use super::Sized;\n \n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }"}, {"sha": "e7443c8dbe5b2f5574784f0b85ea54644904e082", "filename": "tests/run/abort2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/tests%2Frun%2Fabort2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/tests%2Frun%2Fabort2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun%2Fabort2.rs?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -33,6 +33,7 @@ mod intrinsics {\n     use super::Sized;\n \n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }"}, {"sha": "49b28d98f2fecaa4d0bb0f6935cf460ca441f012", "filename": "tests/run/array.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/tests%2Frun%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/tests%2Frun%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun%2Farray.rs?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -105,6 +105,7 @@ fn panic_bounds_check(index: usize, len: usize) -> ! {\n \n mod intrinsics {\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }"}, {"sha": "38c1eac7adf6966c9d8b6d88ce0df853ed4152b7", "filename": "tests/run/asm.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/tests%2Frun%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/tests%2Frun%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun%2Fasm.rs?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -3,11 +3,12 @@\n // Run-time:\n //   status: 0\n \n-#![feature(asm_const, asm_sym)]\n+#![feature(asm_const)]\n \n use std::arch::{asm, global_asm};\n \n-global_asm!(\"\n+global_asm!(\n+    \"\n     .global add_asm\n add_asm:\n      mov rax, rdi\n@@ -132,7 +133,9 @@ fn main() {\n     assert_eq!(x, 43);\n \n     // check sym fn\n-    extern \"C\" fn foo() -> u64 { 42 }\n+    extern \"C\" fn foo() -> u64 {\n+        42\n+    }\n     let x: u64;\n     unsafe {\n         asm!(\"call {}\", sym foo, lateout(\"rax\") x);"}, {"sha": "427c1a250339749f41627b0d6e7dd40f6886cf7a", "filename": "tests/run/assign.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/tests%2Frun%2Fassign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/tests%2Frun%2Fassign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun%2Fassign.rs?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -57,6 +57,7 @@ mod libc {\n \n mod intrinsics {\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }"}, {"sha": "8daa681abf7dac19c0838b9717890a8c1119094e", "filename": "tests/run/closure.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/tests%2Frun%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/tests%2Frun%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun%2Fclosure.rs?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -97,10 +97,14 @@ fn panic_bounds_check(index: usize, len: usize) -> ! {\n \n mod intrinsics {\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }\n \n+#[lang = \"tuple_trait\"]\n+pub trait Tuple {}\n+\n #[lang = \"unsize\"]\n pub trait Unsize<T: ?Sized> {}\n \n@@ -114,7 +118,7 @@ impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for *mut T {}\n \n #[lang = \"fn_once\"]\n #[rustc_paren_sugar]\n-pub trait FnOnce<Args> {\n+pub trait FnOnce<Args: Tuple> {\n     #[lang = \"fn_once_output\"]\n     type Output;\n \n@@ -123,7 +127,7 @@ pub trait FnOnce<Args> {\n \n #[lang = \"fn_mut\"]\n #[rustc_paren_sugar]\n-pub trait FnMut<Args>: FnOnce<Args> {\n+pub trait FnMut<Args: Tuple>: FnOnce<Args> {\n     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n }\n "}, {"sha": "b7a13081deae0df4babd931ae1f968ff3cbfe05e", "filename": "tests/run/condition.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/tests%2Frun%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/tests%2Frun%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun%2Fcondition.rs?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -108,6 +108,7 @@ fn panic_bounds_check(index: usize, len: usize) -> ! {\n \n mod intrinsics {\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }"}, {"sha": "8a196f774c82bcd6cb5930cee4a823124513db07", "filename": "tests/run/fun_ptr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/tests%2Frun%2Ffun_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/tests%2Frun%2Ffun_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun%2Ffun_ptr.rs?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -102,6 +102,7 @@ fn panic_bounds_check(index: usize, len: usize) -> ! {\n \n mod intrinsics {\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }"}, {"sha": "bfe73c38435a31ec68ccdeff5bd861b392cec3d7", "filename": "tests/run/int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/tests%2Frun%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/tests%2Frun%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun%2Fint.rs?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -3,7 +3,7 @@\n // Run-time:\n //   status: 0\n \n-#![feature(bench_black_box, const_black_box)]\n+#![feature(const_black_box)]\n \n /*\n  * Code"}, {"sha": "c3fcb3c0a2a069ac97b36066be3f3abe9fab5f0d", "filename": "tests/run/int_overflow.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/tests%2Frun%2Fint_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/tests%2Frun%2Fint_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun%2Fint_overflow.rs?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -55,6 +55,7 @@ mod libc {\n \n mod intrinsics {\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }"}, {"sha": "2a2ea8b8bf0ab0152cb618ce84fd1f3194292891", "filename": "tests/run/mut_ref.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/tests%2Frun%2Fmut_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/tests%2Frun%2Fmut_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun%2Fmut_ref.rs?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -59,6 +59,7 @@ mod libc {\n \n mod intrinsics {\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }"}, {"sha": "67b9f241dbbb3d06bbba2c3571824a56d54de35a", "filename": "tests/run/operations.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/tests%2Frun%2Foperations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/tests%2Frun%2Foperations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun%2Foperations.rs?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -65,6 +65,7 @@ mod libc {\n \n mod intrinsics {\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }"}, {"sha": "da8a8295d564cc31012f6baac799d5180ac644a4", "filename": "tests/run/ptr_cast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/tests%2Frun%2Fptr_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/tests%2Frun%2Fptr_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun%2Fptr_cast.rs?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -102,6 +102,7 @@ fn panic_bounds_check(index: usize, len: usize) -> ! {\n \n mod intrinsics {\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }"}, {"sha": "96f1c4792e58fa199f794bfd9f6565691bc301da", "filename": "tests/run/slice.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/tests%2Frun%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/tests%2Frun%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun%2Fslice.rs?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -102,6 +102,7 @@ mod intrinsics {\n     use super::Sized;\n \n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }"}, {"sha": "19201f1df2667ca9a6e21450690415865b85f63e", "filename": "tests/run/static.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08a6d6e16b5efe217123e780398969946266268f/tests%2Frun%2Fstatic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6d6e16b5efe217123e780398969946266268f/tests%2Frun%2Fstatic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun%2Fstatic.rs?ref=08a6d6e16b5efe217123e780398969946266268f", "patch": "@@ -45,6 +45,7 @@ mod intrinsics {\n     use super::Sized;\n \n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }"}]}