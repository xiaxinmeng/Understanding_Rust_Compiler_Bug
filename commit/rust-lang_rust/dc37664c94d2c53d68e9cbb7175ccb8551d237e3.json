{"sha": "dc37664c94d2c53d68e9cbb7175ccb8551d237e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjMzc2NjRjOTRkMmM1M2Q2OGU5Y2JiNzE3NWNjYjg1NTFkMjM3ZTM=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-02-21T16:57:30Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-09T14:45:29Z"}, "message": "infer: Take the origin in report_mismatched_types.", "tree": {"sha": "f2277d89c4334ca27eaed4a0d792f6bd80c5a1a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2277d89c4334ca27eaed4a0d792f6bd80c5a1a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc37664c94d2c53d68e9cbb7175ccb8551d237e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc37664c94d2c53d68e9cbb7175ccb8551d237e3", "html_url": "https://github.com/rust-lang/rust/commit/dc37664c94d2c53d68e9cbb7175ccb8551d237e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc37664c94d2c53d68e9cbb7175ccb8551d237e3/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "871a1e1cf8e58c51416954d3afac5d681a3d27eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/871a1e1cf8e58c51416954d3afac5d681a3d27eb", "html_url": "https://github.com/rust-lang/rust/commit/871a1e1cf8e58c51416954d3afac5d681a3d27eb"}], "stats": {"total": 66, "additions": 19, "deletions": 47}, "files": [{"sha": "1e3546269dbc279508346d1babeb58b8d8ff4782", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc37664c94d2c53d68e9cbb7175ccb8551d237e3/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc37664c94d2c53d68e9cbb7175ccb8551d237e3/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=dc37664c94d2c53d68e9cbb7175ccb8551d237e3", "patch": "@@ -1351,18 +1351,18 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn report_mismatched_types(&self,\n-                                   span: Span,\n+                                   origin: TypeOrigin,\n                                    expected: Ty<'tcx>,\n                                    actual: Ty<'tcx>,\n-                                   err: &TypeError<'tcx>) {\n+                                   err: TypeError<'tcx>) {\n         let trace = TypeTrace {\n-            origin: TypeOrigin::Misc(span),\n+            origin: origin,\n             values: Types(ExpectedFound {\n                 expected: expected,\n                 found: actual\n             })\n         };\n-        self.report_and_explain_type_error(trace, err);\n+        self.report_and_explain_type_error(trace, &err);\n     }\n \n     pub fn report_conflicting_default_types(&self,"}, {"sha": "4dd5a6f5909b33f9a4096ac68a14e404f624e937", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 12, "deletions": 32, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/dc37664c94d2c53d68e9cbb7175ccb8551d237e3/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc37664c94d2c53d68e9cbb7175ccb8551d237e3/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=dc37664c94d2c53d68e9cbb7175ccb8551d237e3", "patch": "@@ -10,45 +10,27 @@\n \n \n use check::{coercion, FnCtxt};\n-use middle::ty::{self, Ty};\n-use middle::infer::{self, TypeOrigin};\n+use middle::ty::Ty;\n+use middle::infer::TypeOrigin;\n \n-use std::result::Result::{Err, Ok};\n use syntax::codemap::Span;\n use rustc_front::hir;\n \n // Requires that the two types unify, and prints an error message if\n // they don't.\n pub fn suptype<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n-                         ty_expected: Ty<'tcx>, ty_actual: Ty<'tcx>) {\n-    suptype_with_fn(fcx, sp, false, ty_expected, ty_actual,\n-        |sp, e, a, s| { fcx.report_mismatched_types(sp, e, a, s) })\n-}\n-\n-/// As `suptype`, but call `handle_err` if unification for subtyping fails.\n-pub fn suptype_with_fn<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n-                                    sp: Span,\n-                                    b_is_expected: bool,\n-                                    ty_a: Ty<'tcx>,\n-                                    ty_b: Ty<'tcx>,\n-                                    handle_err: F) where\n-    F: FnOnce(Span, Ty<'tcx>, Ty<'tcx>, &ty::error::TypeError<'tcx>),\n-{\n-    // n.b.: order of actual, expected is reversed\n-    match infer::mk_subty(fcx.infcx(), b_is_expected, TypeOrigin::Misc(sp),\n-                          ty_b, ty_a) {\n-      Ok(()) => { /* ok */ }\n-      Err(ref err) => {\n-          handle_err(sp, ty_a, ty_b, err);\n-      }\n+                         expected: Ty<'tcx>, actual: Ty<'tcx>) {\n+    let origin = TypeOrigin::Misc(sp);\n+    if let Err(e) = fcx.infcx().sub_types(false, origin, actual, expected) {\n+        fcx.infcx().report_mismatched_types(origin, expected, actual, e);\n     }\n }\n \n pub fn eqtype<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n                         expected: Ty<'tcx>, actual: Ty<'tcx>) {\n-    match infer::mk_eqty(fcx.infcx(), false, TypeOrigin::Misc(sp), actual, expected) {\n-        Ok(()) => { /* ok */ }\n-        Err(ref err) => { fcx.report_mismatched_types(sp, expected, actual, err); }\n+    let origin = TypeOrigin::Misc(sp);\n+    if let Err(e) = fcx.infcx().eq_types(false, origin, actual, expected) {\n+        fcx.infcx().report_mismatched_types(origin, expected, actual, e);\n     }\n }\n \n@@ -63,10 +45,8 @@ pub fn coerce<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n            expr_ty);\n     let expr_ty = fcx.resolve_type_vars_if_possible(expr_ty);\n     let expected = fcx.resolve_type_vars_if_possible(expected);\n-    match coercion::mk_assignty(fcx, expr, expr_ty, expected) {\n-      Ok(()) => { /* ok */ }\n-      Err(ref err) => {\n-        fcx.report_mismatched_types(sp, expected, expr_ty, err);\n-      }\n+    let origin = TypeOrigin::Misc(sp);\n+    if let Err(e) = coercion::try(fcx, expr, expr_ty, expected) {\n+        fcx.infcx().report_mismatched_types(origin, expected, expr_ty, e);\n     }\n }"}, {"sha": "e3578559c9b66b51067937cb8cabde518377455f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc37664c94d2c53d68e9cbb7175ccb8551d237e3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc37664c94d2c53d68e9cbb7175ccb8551d237e3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=dc37664c94d2c53d68e9cbb7175ccb8551d237e3", "patch": "@@ -1622,14 +1622,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.infcx().type_error_struct(sp, mk_msg, actual_ty, err)\n     }\n \n-    pub fn report_mismatched_types(&self,\n-                                   sp: Span,\n-                                   e: Ty<'tcx>,\n-                                   a: Ty<'tcx>,\n-                                   err: &TypeError<'tcx>) {\n-        self.infcx().report_mismatched_types(sp, e, a, err)\n-    }\n-\n     /// Registers an obligation for checking later, during regionck, that the type `ty` must\n     /// outlive the region `r`.\n     pub fn register_region_obligation(&self,"}, {"sha": "cad321c0b237480f2a61478d3b65bda7a36b6a26", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc37664c94d2c53d68e9cbb7175ccb8551d237e3/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc37664c94d2c53d68e9cbb7175ccb8551d237e3/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=dc37664c94d2c53d68e9cbb7175ccb8551d237e3", "patch": "@@ -385,11 +385,12 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n             let infcx = new_infer_ctxt(tcx, &tcx.tables, Some(param_env));\n \n+            let origin = TypeOrigin::Misc(span);\n             let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>, mt_b: ty::TypeAndMut<'tcx>,\n                                mk_ptr: &Fn(Ty<'tcx>) -> Ty<'tcx>| {\n                 if (mt_a.mutbl, mt_b.mutbl) == (hir::MutImmutable, hir::MutMutable) {\n-                    infcx.report_mismatched_types(span, mk_ptr(mt_b.ty),\n-                                                  target, &ty::error::TypeError::Mutability);\n+                    infcx.report_mismatched_types(origin, mk_ptr(mt_b.ty),\n+                                                  target, ty::error::TypeError::Mutability);\n                 }\n                 (mt_a.ty, mt_b.ty, unsize_trait, None)\n             };\n@@ -418,7 +419,6 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                         return;\n                     }\n \n-                    let origin = TypeOrigin::Misc(span);\n                     let fields = &def_a.struct_variant().fields;\n                     let diff_fields = fields.iter().enumerate().filter_map(|(i, f)| {\n                         let (a, b) = (f.ty(tcx, substs_a), f.ty(tcx, substs_b));"}]}