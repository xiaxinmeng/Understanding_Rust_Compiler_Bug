{"sha": "3863834d9c75230224e36783780d260f52e10d49", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4NjM4MzRkOWM3NTIzMDIyNGUzNjc4Mzc4MGQyNjBmNTJlMTBkNDk=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-09-06T05:57:58Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-09-22T19:19:31Z"}, "message": "reviewer comments and rebasing", "tree": {"sha": "cd33399603c779cc68c7c399ff2433ccc05e1154", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd33399603c779cc68c7c399ff2433ccc05e1154"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3863834d9c75230224e36783780d260f52e10d49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3863834d9c75230224e36783780d260f52e10d49", "html_url": "https://github.com/rust-lang/rust/commit/3863834d9c75230224e36783780d260f52e10d49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3863834d9c75230224e36783780d260f52e10d49/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a2d2c949581c710eeb505000e56ffa1e5a860b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a2d2c949581c710eeb505000e56ffa1e5a860b5", "html_url": "https://github.com/rust-lang/rust/commit/6a2d2c949581c710eeb505000e56ffa1e5a860b5"}], "stats": {"total": 327, "additions": 173, "deletions": 154}, "files": [{"sha": "7b048c0670d5a70d4b69df3a97a4400ef3b0e71e", "filename": "src/librustc_plugin/registry.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3863834d9c75230224e36783780d260f52e10d49/src%2Flibrustc_plugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3863834d9c75230224e36783780d260f52e10d49/src%2Flibrustc_plugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fregistry.rs?ref=3863834d9c75230224e36783780d260f52e10d49", "patch": "@@ -15,8 +15,7 @@ use rustc::session::Session;\n \n use rustc::mir::transform::MirMapPass;\n \n-use syntax::ext::base::{SyntaxExtension, NamedSyntaxExtension, NormalTT};\n-use syntax::ext::base::{IdentTT, MultiModifier, MultiDecorator};\n+use syntax::ext::base::{SyntaxExtension, NamedSyntaxExtension, NormalTT, IdentTT};\n use syntax::ext::base::MacroExpanderFn;\n use syntax::parse::token;\n use syntax::ast;\n@@ -109,10 +108,7 @@ impl<'a> Registry<'a> {\n             IdentTT(ext, _, allow_internal_unstable) => {\n                 IdentTT(ext, Some(self.krate_span), allow_internal_unstable)\n             }\n-            MultiDecorator(ext) => MultiDecorator(ext),\n-            MultiModifier(ext) => MultiModifier(ext),\n-            SyntaxExtension::ProcMacro(ext) => SyntaxExtension::ProcMacro(ext),\n-            SyntaxExtension::AttrProcMacro(ext) => SyntaxExtension::AttrProcMacro(ext),\n+            _ => extension,\n         }));\n     }\n "}, {"sha": "67e725b6e727da30b234bd1c27b25089214b4846", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3863834d9c75230224e36783780d260f52e10d49/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3863834d9c75230224e36783780d260f52e10d49/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=3863834d9c75230224e36783780d260f52e10d49", "patch": "@@ -73,7 +73,9 @@ impl<'a> base::Resolver for Resolver<'a> {\n             let name = intern(&attrs[i].name());\n             match self.expansion_data[0].module.macros.borrow().get(&name) {\n                 Some(ext) => match **ext {\n-                    MultiModifier(..) | MultiDecorator(..) => return Some(attrs.remove(i)),\n+                    MultiModifier(..) | MultiDecorator(..) | SyntaxExtension::AttrProcMacro(..) => {\n+                        return Some(attrs.remove(i))\n+                    }\n                     _ => {}\n                 },\n                 None => {}"}, {"sha": "917426807110eb97d4eb7608bf4da595f935c062", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 86, "deletions": 62, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/3863834d9c75230224e36783780d260f52e10d49/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3863834d9c75230224e36783780d260f52e10d49/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=3863834d9c75230224e36783780d260f52e10d49", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::SyntaxExtension::{MultiDecorator, MultiModifier, NormalTT, IdentTT, MacroRulesTT};\n+pub use self::SyntaxExtension::{MultiDecorator, MultiModifier, NormalTT, IdentTT};\n \n use ast::{self, Attribute, Name, PatKind};\n use attr::HasAttrs;\n@@ -18,6 +18,7 @@ use errors::DiagnosticBuilder;\n use ext::expand::{self, Invocation, Expansion};\n use ext::hygiene::Mark;\n use ext::tt::macro_rules;\n+use fold;\n use parse;\n use parse::parser::{self, Parser};\n use parse::token;\n@@ -61,14 +62,6 @@ impl HasAttrs for Annotatable {\n }\n \n impl Annotatable {\n-    pub fn span(&self) -> Span {\n-        match *self {\n-            Annotatable::Item(ref item) => item.span,\n-            Annotatable::TraitItem(ref trait_item) => trait_item.span,\n-            Annotatable::ImplItem(ref impl_item) => impl_item.span,\n-        }\n-    }\n-\n     pub fn expect_item(self) -> P<ast::Item> {\n         match self {\n             Annotatable::Item(i) => i,\n@@ -160,21 +153,19 @@ pub trait ProcMacro {\n                    ecx: &'cx mut ExtCtxt,\n                    span: Span,\n                    ts: TokenStream)\n-                   -> Box<MacResult+'cx>;\n+                   -> TokenStream;\n }\n \n impl<F> ProcMacro for F\n     where F: Fn(TokenStream) -> TokenStream\n {\n     fn expand<'cx>(&self,\n-                   ecx: &'cx mut ExtCtxt,\n-                   span: Span,\n+                   _ecx: &'cx mut ExtCtxt,\n+                   _span: Span,\n                    ts: TokenStream)\n-                   -> Box<MacResult+'cx> {\n-        let result = (*self)(ts);\n+                   -> TokenStream {\n         // FIXME setup implicit context in TLS before calling self.\n-        let parser = ecx.new_parser_from_tts(&result.to_tts());\n-        Box::new(TokResult { parser: parser, span: span })\n+        (*self)(ts)\n     }\n }\n \n@@ -184,50 +175,63 @@ pub trait AttrProcMacro {\n                    span: Span,\n                    annotation: TokenStream,\n                    annotated: TokenStream)\n-                   -> Box<MacResult+'cx>;\n+                   -> TokenStream;\n }\n \n impl<F> AttrProcMacro for F\n     where F: Fn(TokenStream, TokenStream) -> TokenStream\n {\n     fn expand<'cx>(&self,\n-                   ecx: &'cx mut ExtCtxt,\n-                   span: Span,\n+                   _ecx: &'cx mut ExtCtxt,\n+                   _span: Span,\n                    annotation: TokenStream,\n                    annotated: TokenStream)\n-                   -> Box<MacResult+'cx> {\n+                   -> TokenStream {\n         // FIXME setup implicit context in TLS before calling self.\n-        let parser = ecx.new_parser_from_tts(&(*self)(annotation, annotated).to_tts());\n-        Box::new(TokResult { parser: parser, span: span })\n+        (*self)(annotation, annotated)\n     }\n }\n \n-struct TokResult<'a> {\n-    parser: Parser<'a>,\n-    span: Span,\n+pub struct TokResult<'a> {\n+    pub parser: Parser<'a>,\n+    pub span: Span,\n+}\n+\n+impl<'a> TokResult<'a> {\n+    // There is quite a lot of overlap here with ParserAnyMacro in ext/tt/macro_rules.rs\n+    // We could probably share more code.\n+    // FIXME(#36641) Unify TokResult and ParserAnyMacro.\n+    fn ensure_complete_parse(&mut self, allow_semi: bool) {\n+        let macro_span = &self.span;\n+        self.parser.ensure_complete_parse(allow_semi, |parser| {\n+            let token_str = parser.this_token_to_string();\n+            let msg = format!(\"macro expansion ignores token `{}` and any following\", token_str);\n+            let span = parser.span;\n+            parser.diagnostic()\n+                  .struct_span_err(span, &msg)\n+                  .span_note(*macro_span, \"caused by the macro expansion here\")\n+                  .emit();\n+        });\n+    }\n }\n \n impl<'a> MacResult for TokResult<'a> {\n     fn make_items(mut self: Box<Self>) -> Option<SmallVector<P<ast::Item>>> {\n         if self.parser.sess.span_diagnostic.has_errors() {\n-            return None;\n+            return Some(SmallVector::zero());\n         }\n \n         let mut items = SmallVector::zero();\n         loop {\n             match self.parser.parse_item() {\n-                Ok(Some(item)) => {\n-                    // FIXME better span info.\n-                    let mut item = item.unwrap();\n-                    item.span = self.span;\n-                    items.push(P(item));\n-                }\n+                Ok(Some(item)) => items.push(item),\n                 Ok(None) => {\n+                    self.ensure_complete_parse(false);\n                     return Some(items);\n                 }\n                 Err(mut e) => {\n                     e.emit();\n-                    return None;\n+                    return Some(SmallVector::zero());\n                 }\n             }\n         }\n@@ -236,57 +240,61 @@ impl<'a> MacResult for TokResult<'a> {\n     fn make_impl_items(mut self: Box<Self>) -> Option<SmallVector<ast::ImplItem>> {\n         let mut items = SmallVector::zero();\n         loop {\n+            if self.parser.token == token::Eof {\n+                break;\n+            }\n             match self.parser.parse_impl_item() {\n-                Ok(mut item) => {\n-                    // FIXME better span info.\n-                    item.span = self.span;\n-                    items.push(item);\n-\n-                    return Some(items);\n-                }\n+                Ok(item) => items.push(item),\n                 Err(mut e) => {\n                     e.emit();\n-                    return None;\n+                    return Some(SmallVector::zero());\n                 }\n             }\n         }\n+        self.ensure_complete_parse(false);\n+        Some(items)\n     }\n \n     fn make_trait_items(mut self: Box<Self>) -> Option<SmallVector<ast::TraitItem>> {\n         let mut items = SmallVector::zero();\n         loop {\n+            if self.parser.token == token::Eof {\n+                break;\n+            }\n             match self.parser.parse_trait_item() {\n-                Ok(mut item) => {\n-                    // FIXME better span info.\n-                    item.span = self.span;\n-                    items.push(item);\n-\n-                    return Some(items);\n-                }\n+                Ok(item) => items.push(item),\n                 Err(mut e) => {\n                     e.emit();\n-                    return None;\n+                    return Some(SmallVector::zero());\n                 }\n             }\n         }\n+        self.ensure_complete_parse(false);\n+        Some(items)\n     }\n \n     fn make_expr(mut self: Box<Self>) -> Option<P<ast::Expr>> {\n         match self.parser.parse_expr() {\n-            Ok(e) => Some(e),\n+            Ok(e) => {\n+                self.ensure_complete_parse(true);\n+                Some(e)\n+            }\n             Err(mut e) => {\n                 e.emit();\n-                return None;\n+                Some(DummyResult::raw_expr(self.span))\n             }\n         }\n     }\n \n     fn make_pat(mut self: Box<Self>) -> Option<P<ast::Pat>> {\n         match self.parser.parse_pat() {\n-            Ok(e) => Some(e),\n+            Ok(e) => {\n+                self.ensure_complete_parse(false);\n+                Some(e)\n+            }\n             Err(mut e) => {\n                 e.emit();\n-                return None;\n+                Some(P(DummyResult::raw_pat(self.span)))\n             }\n         }\n     }\n@@ -295,28 +303,30 @@ impl<'a> MacResult for TokResult<'a> {\n         let mut stmts = SmallVector::zero();\n         loop {\n             if self.parser.token == token::Eof {\n-                return Some(stmts);\n+                break;\n             }\n-            match self.parser.parse_full_stmt(true) {\n-                Ok(Some(mut stmt)) => {\n-                    stmt.span = self.span;\n-                    stmts.push(stmt);\n-                }\n+            match self.parser.parse_full_stmt(false) {\n+                Ok(Some(stmt)) => stmts.push(stmt),\n                 Ok(None) => { /* continue */ }\n                 Err(mut e) => {\n                     e.emit();\n-                    return None;\n+                    return Some(SmallVector::zero());\n                 }\n             }\n         }\n+        self.ensure_complete_parse(false);\n+        Some(stmts)\n     }\n \n     fn make_ty(mut self: Box<Self>) -> Option<P<ast::Ty>> {\n         match self.parser.parse_ty() {\n-            Ok(e) => Some(e),\n+            Ok(e) => {\n+                self.ensure_complete_parse(false);\n+                Some(e)\n+            }\n             Err(mut e) => {\n                 e.emit();\n-                return None;\n+                Some(DummyResult::raw_ty(self.span))\n             }\n         }\n     }\n@@ -1004,3 +1014,17 @@ pub fn get_exprs_from_tts(cx: &mut ExtCtxt,\n     }\n     Some(es)\n }\n+\n+pub struct ChangeSpan {\n+    pub span: Span\n+}\n+\n+impl Folder for ChangeSpan {\n+    fn new_span(&mut self, _sp: Span) -> Span {\n+        self.span\n+    }\n+\n+    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n+        fold::noop_fold_mac(mac, self)\n+    }\n+}"}, {"sha": "eaa7684d8fb3bb68baa004bbb544ff07a8ca74bd", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 57, "deletions": 29, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/3863834d9c75230224e36783780d260f52e10d49/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3863834d9c75230224e36783780d260f52e10d49/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=3863834d9c75230224e36783780d260f52e10d49", "patch": "@@ -21,8 +21,10 @@ use ext::base::*;\n use feature_gate::{self, Features};\n use fold;\n use fold::*;\n+use parse::{ParseSess, lexer};\n+use parse::parser::Parser;\n use parse::token::{intern, keywords};\n-use parse::span_to_tts;\n+use print::pprust;\n use ptr::P;\n use tokenstream::{TokenTree, TokenStream};\n use util::small_vector::SmallVector;\n@@ -310,29 +312,18 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 kind.expect_from_annotatables(items)\n             }\n             SyntaxExtension::AttrProcMacro(ref mac) => {\n-                let attr_toks = TokenStream::from_tts(span_to_tts(&fld.cx.parse_sess,\n-                                                                  attr.span));\n-                let item_toks = TokenStream::from_tts(span_to_tts(&fld.cx.parse_sess,\n-                                                                  item.span()));\n-                let result = mac.expand(self.cx, attr.span, attr_toks, item_toks);\n-                let items = match item {\n-                    Annotatable::Item(_) => result.make_items()\n-                                                  .unwrap_or(SmallVector::zero())\n-                                                  .into_iter()\n-                                                  .map(|i| Annotatable::Item(i))\n-                                                  .collect(),\n-                    Annotatable::TraitItem(_) => result.make_trait_items()\n-                                                       .unwrap_or(SmallVector::zero())\n-                                                       .into_iter()\n-                                                       .map(|i| Annotatable::TraitItem(P(i)))\n-                                                       .collect(),\n-                    Annotatable::ImplItem(_) => result.make_impl_items()\n-                                                      .unwrap_or(SmallVector::zero())\n-                                                      .into_iter()\n-                                                      .map(|i| Annotatable::ImplItem(P(i)))\n-                                                      .collect(),\n-                };\n-                kind.expect_from_annotatables(items)\n+                let attr_toks = TokenStream::from_tts(tts_for_attr(&attr, &self.cx.parse_sess));\n+                let item_toks = TokenStream::from_tts(tts_for_item(&item, &self.cx.parse_sess));\n+\n+                let tok_result = mac.expand(self.cx, attr.span, attr_toks, item_toks);\n+                let parser = self.cx.new_parser_from_tts(&tok_result.to_tts());\n+                let result = Box::new(TokResult { parser: parser, span: attr.span });\n+\n+                kind.make_from(result).unwrap_or_else(|| {\n+                    let msg = format!(\"macro could not be expanded into {} position\", kind.name());\n+                    self.cx.span_err(attr.span, &msg);\n+                    kind.dummy(attr.span)\n+                })\n             }\n             _ => unreachable!(),\n         }\n@@ -413,12 +404,12 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 if ident.name != keywords::Invalid.name() {\n                     let msg =\n                         format!(\"macro {}! expects no ident argument, given '{}'\", extname, ident);\n-                    fld.cx.span_err(path.span, &msg);\n-                    return None;\n+                    self.cx.span_err(path.span, &msg);\n+                    return kind.dummy(span);\n                 }\n \n-                fld.cx.bt_push(ExpnInfo {\n-                    call_site: call_site,\n+                self.cx.bt_push(ExpnInfo {\n+                    call_site: span,\n                     callee: NameAndSpan {\n                         format: MacroBang(extname),\n                         // FIXME procedural macros do not have proper span info\n@@ -429,7 +420,14 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     },\n                 });\n \n-                Some(expandfun.expand(fld.cx, call_site, TokenStream::from_tts(marked_tts)))\n+\n+                let tok_result = expandfun.expand(self.cx,\n+                                                  span,\n+                                                  TokenStream::from_tts(marked_tts));\n+                let parser = self.cx.new_parser_from_tts(&tok_result.to_tts());\n+                let result = Box::new(TokResult { parser: parser, span: span });\n+                // FIXME better span info.\n+                kind.make_from(result).map(|i| i.fold_with(&mut ChangeSpan { span: span }))\n             }\n         };\n \n@@ -502,6 +500,36 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n     }\n }\n \n+// These are pretty nasty. Ideally, we would keep the tokens around, linked from\n+// the AST. However, we don't so we need to create new ones. Since the item might\n+// have come from a macro expansion (possibly only in part), we can't use the\n+// existing codemap.\n+//\n+// Therefore, we must use the pretty printer (yuck) to turn the AST node into a\n+// string, which we then re-tokenise (double yuck), but first we have to patch\n+// the pretty-printed string on to the end of the existing codemap (infinity-yuck).\n+fn tts_for_item(item: &Annotatable, parse_sess: &ParseSess) -> Vec<TokenTree> {\n+    let text = match *item {\n+        Annotatable::Item(ref i) => pprust::item_to_string(i),\n+        Annotatable::TraitItem(ref ti) => pprust::trait_item_to_string(ti),\n+        Annotatable::ImplItem(ref ii) => pprust::impl_item_to_string(ii),\n+    };\n+    string_to_tts(text, parse_sess)\n+}\n+\n+fn tts_for_attr(attr: &ast::Attribute, parse_sess: &ParseSess) -> Vec<TokenTree> {\n+    string_to_tts(pprust::attr_to_string(attr), parse_sess)\n+}\n+\n+fn string_to_tts(text: String, parse_sess: &ParseSess) -> Vec<TokenTree> {\n+    let filemap = parse_sess.codemap()\n+                            .new_filemap(String::from(\"<macro expansion>\"), None, text);\n+\n+    let lexer = lexer::StringReader::new(&parse_sess.span_diagnostic, filemap);\n+    let mut parser = Parser::new(parse_sess, Vec::new(), Box::new(lexer));\n+    panictry!(parser.parse_all_token_trees())\n+}\n+\n impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n         let mut expr = self.cfg.configure_expr(expr).unwrap();"}, {"sha": "3746a51d359bde4ce21b1859d8a38ffc228ae329", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3863834d9c75230224e36783780d260f52e10d49/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3863834d9c75230224e36783780d260f52e10d49/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=3863834d9c75230224e36783780d260f52e10d49", "patch": "@@ -49,22 +49,19 @@ impl<'a> ParserAnyMacro<'a> {\n     /// allowed to be there.\n     fn ensure_complete_parse(&self, allow_semi: bool, context: &str) {\n         let mut parser = self.parser.borrow_mut();\n-        if allow_semi && parser.token == token::Semi {\n-            parser.bump();\n-        }\n-        if parser.token != token::Eof {\n+        parser.ensure_complete_parse(allow_semi, |parser| {\n             let token_str = parser.this_token_to_string();\n             let msg = format!(\"macro expansion ignores token `{}` and any \\\n                                following\",\n                               token_str);\n             let span = parser.span;\n-            let mut err = parser.diagnostic().struct_span_err(span, &msg[..]);\n+            let mut err = parser.diagnostic().struct_span_err(span, &msg);\n             let msg = format!(\"caused by the macro expansion here; the usage \\\n                                of `{}!` is likely invalid in {} context\",\n                                self.macro_ident, context);\n-            err.span_note(self.site_span, &msg[..])\n+            err.span_note(self.site_span, &msg)\n                .emit();\n-        }\n+        });\n     }\n }\n "}, {"sha": "6c0e2425d37ad6288ca8757e9edd63ca7580cfd3", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3863834d9c75230224e36783780d260f52e10d49/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3863834d9c75230224e36783780d260f52e10d49/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=3863834d9c75230224e36783780d260f52e10d49", "patch": "@@ -110,7 +110,6 @@ impl<'a> Reader for StringReader<'a> {\n             Some(t) => self.pos > t,\n             None => false,\n         }\n-\n     }\n     /// Return the next token. EFFECT: advances the string_reader.\n     fn try_next_token(&mut self) -> Result<TokenAndSpan, ()> {\n@@ -222,28 +221,6 @@ impl<'a> StringReader<'a> {\n         sr\n     }\n \n-    pub fn from_span<'b>(span_diagnostic: &'b Handler,\n-                         span: Span,\n-                         codemap: &CodeMap)\n-                         -> StringReader<'b> {\n-        let start_pos = codemap.lookup_byte_offset(span.lo);\n-        let last_pos = codemap.lookup_byte_offset(span.hi);\n-        assert!(start_pos.fm.name == last_pos.fm.name, \"Attempt to lex span which crosses files\");\n-        let mut sr = StringReader::new_raw_internal(span_diagnostic, start_pos.fm.clone());\n-        sr.pos = span.lo;\n-        sr.last_pos = span.lo;\n-        sr.terminator = Some(span.hi);\n-        sr.save_new_lines = false;\n-\n-        sr.bump();\n-\n-        if let Err(_) = sr.advance_token() {\n-            sr.emit_fatal_errors();\n-            panic!(FatalError);\n-        }\n-        sr\n-    }\n-\n     pub fn curr_is(&self, c: char) -> bool {\n         self.curr == Some(c)\n     }"}, {"sha": "5aa0efdec11a2565a75323770dbf1817502a6dd0", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3863834d9c75230224e36783780d260f52e10d49/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3863834d9c75230224e36783780d260f52e10d49/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=3863834d9c75230224e36783780d260f52e10d49", "patch": "@@ -258,13 +258,6 @@ fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n     }\n }\n \n-pub fn span_to_tts(sess: &ParseSess, span: Span) -> Vec<tokenstream::TokenTree> {\n-    let cfg = Vec::new();\n-    let srdr = lexer::StringReader::from_span(&sess.span_diagnostic, span, &sess.code_map);\n-    let mut p1 = Parser::new(sess, cfg, Box::new(srdr));\n-    panictry!(p1.parse_all_token_trees())\n-}\n-\n /// Given a filemap, produce a sequence of token-trees\n pub fn filemap_to_tts(sess: &ParseSess, filemap: Rc<FileMap>)\n     -> Vec<tokenstream::TokenTree> {"}, {"sha": "23085fadc5e6068c3c32bb217fd05a655a08da32", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3863834d9c75230224e36783780d260f52e10d49/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3863834d9c75230224e36783780d260f52e10d49/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=3863834d9c75230224e36783780d260f52e10d49", "patch": "@@ -3872,15 +3872,17 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn parse_stmt_(&mut self, macro_expanded: bool) -> Option<Stmt> {\n-        self.parse_stmt_without_recovery(macro_expanded).unwrap_or_else(|mut e| {\n+    fn parse_stmt_(&mut self, macro_legacy_warnings: bool) -> Option<Stmt> {\n+        self.parse_stmt_without_recovery(macro_legacy_warnings).unwrap_or_else(|mut e| {\n             e.emit();\n             self.recover_stmt_(SemiColonMode::Break);\n             None\n         })\n     }\n \n-    fn parse_stmt_without_recovery(&mut self, macro_expanded: bool) -> PResult<'a, Option<Stmt>> {\n+    fn parse_stmt_without_recovery(&mut self,\n+                                   macro_legacy_warnings: bool)\n+                                   -> PResult<'a, Option<Stmt>> {\n         maybe_whole!(Some deref self, NtStmt);\n \n         let attrs = self.parse_outer_attributes()?;\n@@ -3950,7 +3952,7 @@ impl<'a> Parser<'a> {\n                 // We used to incorrectly stop parsing macro-expanded statements here.\n                 // If the next token will be an error anyway but could have parsed with the\n                 // earlier behavior, stop parsing here and emit a warning to avoid breakage.\n-                else if macro_expanded && self.token.can_begin_expr() && match self.token {\n+                else if macro_legacy_warnings && self.token.can_begin_expr() && match self.token {\n                     // These can continue an expression, so we can't stop parsing and warn.\n                     token::OpenDelim(token::Paren) | token::OpenDelim(token::Bracket) |\n                     token::BinOp(token::Minus) | token::BinOp(token::Star) |\n@@ -4125,8 +4127,8 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a statement, including the trailing semicolon.\n-    pub fn parse_full_stmt(&mut self, macro_expanded: bool) -> PResult<'a, Option<Stmt>> {\n-        let mut stmt = match self.parse_stmt_(macro_expanded) {\n+    pub fn parse_full_stmt(&mut self, macro_legacy_warnings: bool) -> PResult<'a, Option<Stmt>> {\n+        let mut stmt = match self.parse_stmt_(macro_legacy_warnings) {\n             Some(stmt) => stmt,\n             None => return Ok(None),\n         };\n@@ -4146,7 +4148,7 @@ impl<'a> Parser<'a> {\n             }\n             StmtKind::Local(..) => {\n                 // We used to incorrectly allow a macro-expanded let statement to lack a semicolon.\n-                if macro_expanded && self.token != token::Semi {\n+                if macro_legacy_warnings && self.token != token::Semi {\n                     self.warn_missing_semicolon();\n                 } else {\n                     self.expect_one_of(&[token::Semi], &[])?;\n@@ -6169,4 +6171,15 @@ impl<'a> Parser<'a> {\n             _ =>  Err(self.fatal(\"expected string literal\"))\n         }\n     }\n+\n+    pub fn ensure_complete_parse<F>(&mut self, allow_semi: bool, on_err: F)\n+        where F: FnOnce(&Parser)\n+    {\n+        if allow_semi && self.token == token::Semi {\n+            self.bump();\n+        }\n+        if self.token != token::Eof {\n+            on_err(self);\n+        }\n+    }\n }"}, {"sha": "624fabd1424e158bcc96d013a4d27aea06e60180", "filename": "src/libsyntax_ext/deriving/custom.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3863834d9c75230224e36783780d260f52e10d49/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3863834d9c75230224e36783780d260f52e10d49/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs?ref=3863834d9c75230224e36783780d260f52e10d49", "patch": "@@ -15,7 +15,7 @@ use rustc_macro::{TokenStream, __internal};\n use syntax::ast::{self, ItemKind};\n use syntax::codemap::{ExpnInfo, MacroAttribute, NameAndSpan, Span};\n use syntax::ext::base::*;\n-use syntax::fold::{self, Folder};\n+use syntax::fold::Folder;\n use syntax::parse::token::intern;\n use syntax::print::pprust;\n \n@@ -97,14 +97,3 @@ impl MultiItemModifier for CustomDerive {\n     }\n }\n \n-struct ChangeSpan { span: Span }\n-\n-impl Folder for ChangeSpan {\n-    fn new_span(&mut self, _sp: Span) -> Span {\n-        self.span\n-    }\n-\n-    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n-        fold::noop_fold_mac(mac, self)\n-    }\n-}"}]}