{"sha": "b762ba08902e6bcbc6a7e7fcb5d6d2978c909e1a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3NjJiYTA4OTAyZTZiY2JjNmE3ZTdmY2I1ZDZkMjk3OGM5MDllMWE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-12T04:37:27Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-12T19:11:12Z"}, "message": "Convert benchmarks to ivecs", "tree": {"sha": "ec34d93858a00d287427a9d40ba566f90d440a12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec34d93858a00d287427a9d40ba566f90d440a12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b762ba08902e6bcbc6a7e7fcb5d6d2978c909e1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b762ba08902e6bcbc6a7e7fcb5d6d2978c909e1a", "html_url": "https://github.com/rust-lang/rust/commit/b762ba08902e6bcbc6a7e7fcb5d6d2978c909e1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b762ba08902e6bcbc6a7e7fcb5d6d2978c909e1a/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ed5ae89188a7051e32be0da39a0420c68a05dd0", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ed5ae89188a7051e32be0da39a0420c68a05dd0", "html_url": "https://github.com/rust-lang/rust/commit/5ed5ae89188a7051e32be0da39a0420c68a05dd0"}], "stats": {"total": 80, "additions": 41, "deletions": 39}, "files": [{"sha": "e2841f499b9d65c32c85a653cb7dca578d535ca1", "filename": "src/test/bench/shootout-fannkuchredux.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b762ba08902e6bcbc6a7e7fcb5d6d2978c909e1a/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b762ba08902e6bcbc6a7e7fcb5d6d2978c909e1a/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs?ref=b762ba08902e6bcbc6a7e7fcb5d6d2978c909e1a", "patch": "@@ -1,15 +1,15 @@\n // Based on Isaac Gouy's fannkuchredux.csharp\n use std;\n import std::int;\n-import std::vec;\n+import std::ivec;\n \n fn fannkuch(n: int) -> int {\n     fn perm1init(i: uint) -> int { ret i as int; }\n     let perm1init_ = perm1init; // Rustboot workaround\n \n-    let perm = vec::init_elt_mut(0, n as uint);\n-    let perm1 = vec::init_fn_mut(perm1init_, n as uint);\n-    let count = vec::init_elt_mut(0, n as uint);\n+    let perm = ivec::init_elt_mut(0, n as uint);\n+    let perm1 = ivec::init_fn_mut(perm1init_, n as uint);\n+    let count = ivec::init_elt_mut(0, n as uint);\n     let f = 0;\n     let i = 0;\n     let k = 0;"}, {"sha": "c7d50e5b387117bdec2b6f30248c3d351a784dcb", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b762ba08902e6bcbc6a7e7fcb5d6d2978c909e1a/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b762ba08902e6bcbc6a7e7fcb5d6d2978c909e1a/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=b762ba08902e6bcbc6a7e7fcb5d6d2978c909e1a", "patch": "@@ -6,7 +6,7 @@\n  * http://shootout.alioth.debian.org/\n  */\n use std;\n-import std::vec;\n+import std::ivec;\n import std::str;\n import std::uint;\n import std::int;\n@@ -23,27 +23,27 @@ obj myrandom(mutable last: u32) {\n \n type aminoacids = {ch: char, prob: u32};\n \n-fn make_cumulative(aa: vec[aminoacids]) -> vec[aminoacids] {\n+fn make_cumulative(aa: &[aminoacids]) -> [aminoacids] {\n     let cp: u32 = 0u32;\n-    let ans: vec[aminoacids] = [];\n-    for a: aminoacids  in aa { cp += a.prob; ans += [{ch: a.ch, prob: cp}]; }\n+    let ans: [aminoacids] = ~[];\n+    for a: aminoacids  in aa { cp += a.prob; ans += ~[{ch: a.ch, prob: cp}]; }\n     ret ans;\n }\n \n-fn select_random(r: u32, genelist: vec[aminoacids]) -> char {\n+fn select_random(r: u32, genelist: &[aminoacids]) -> char {\n     if r < genelist.(0).prob { ret genelist.(0).ch; }\n-    fn bisect(v: vec[aminoacids], lo: uint, hi: uint, target: u32) -> char {\n+    fn bisect(v: &[aminoacids], lo: uint, hi: uint, target: u32) -> char {\n         if hi > lo + 1u {\n             let mid: uint = lo + (hi - lo) / 2u;\n             if target < v.(mid).prob {\n                 be bisect(v, lo, mid, target);\n             } else { be bisect(v, mid, hi, target); }\n         } else { ret v.(hi).ch; }\n     }\n-    ret bisect(genelist, 0u, vec::len[aminoacids](genelist) - 1u, r);\n+    ret bisect(genelist, 0u, ivec::len[aminoacids](genelist) - 1u, r);\n }\n \n-fn make_random_fasta(id: str, desc: str, genelist: vec[aminoacids], n: int) {\n+fn make_random_fasta(id: str, desc: str, genelist: &[aminoacids], n: int) {\n     log \">\" + id + \" \" + desc;\n     let rng = myrandom(std::rand::mk_rng().next());\n     let op: str = \"\";\n@@ -68,15 +68,17 @@ fn make_repeat_fasta(id: str, desc: str, s: str, n: int) {\n fn acid(ch: char, prob: u32) -> aminoacids { ret {ch: ch, prob: prob}; }\n \n fn main(args: vec[str]) {\n-    let iub: vec[aminoacids] =\n-        make_cumulative([acid('a', 27u32), acid('c', 12u32), acid('g', 12u32),\n-                         acid('t', 27u32), acid('B', 2u32), acid('D', 2u32),\n-                         acid('H', 2u32), acid('K', 2u32), acid('M', 2u32),\n-                         acid('N', 2u32), acid('R', 2u32), acid('S', 2u32),\n-                         acid('V', 2u32), acid('W', 2u32), acid('Y', 2u32)]);\n-    let homosapiens: vec[aminoacids] =\n-        make_cumulative([acid('a', 30u32), acid('c', 20u32), acid('g', 20u32),\n-                         acid('t', 30u32)]);\n+    let iub: [aminoacids] =\n+        make_cumulative(\n+            ~[acid('a', 27u32), acid('c', 12u32), acid('g', 12u32),\n+              acid('t', 27u32), acid('B', 2u32), acid('D', 2u32),\n+              acid('H', 2u32), acid('K', 2u32), acid('M', 2u32),\n+              acid('N', 2u32), acid('R', 2u32), acid('S', 2u32),\n+              acid('V', 2u32), acid('W', 2u32), acid('Y', 2u32)]);\n+    let homosapiens: [aminoacids] =\n+        make_cumulative(\n+            ~[acid('a', 30u32), acid('c', 20u32), acid('g', 20u32),\n+              acid('t', 30u32)]);\n     let alu: str =\n         \"GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG\" +\n             \"GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA\" +"}, {"sha": "6b1f4ff23e7507bb5b1a790159f8c96d22bf3b0f", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b762ba08902e6bcbc6a7e7fcb5d6d2978c909e1a/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b762ba08902e6bcbc6a7e7fcb5d6d2978c909e1a/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=b762ba08902e6bcbc6a7e7fcb5d6d2978c909e1a", "patch": "@@ -11,7 +11,6 @@\n \n use std;\n \n-import std::vec;\n import std::ivec;\n import std::uint;\n import std::time;\n@@ -47,13 +46,13 @@ fn fib(n: int) -> int {\n \n type config = {stress: bool};\n \n-fn parse_opts(argv: vec[str]) -> config {\n-    let opts = [getopts::optflag(\"stress\")];\n+fn parse_opts(argv: [str]) -> config {\n+    let opts = ~[getopts::optflag(\"stress\")];\n \n-    let opt_args = vec::slice(argv, 1u, vec::len(argv));\n+    let opt_args = ivec::slice(argv, 1u, ivec::len(argv));\n \n \n-    alt getopts::getopts(opt_args, opts) {\n+    alt getopts::getopts_ivec(opt_args, opts) {\n       getopts::success(m) { ret {stress: getopts::opt_present(m, \"stress\")} }\n       getopts::failure(_) { fail; }\n     }\n@@ -78,18 +77,19 @@ fn stress(num_tasks: int) {\n }\n \n fn main(argv: vec[str]) {\n-    if vec::len(argv) == 1u {\n+    let iargv = ivec::from_vec(argv);\n+    if ivec::len(iargv) == 1u {\n         assert (fib(8) == 21);\n         log fib(8);\n     } else {\n         // Interactive mode! Wooo!!!!\n-        let opts = parse_opts(argv);\n+        let opts = parse_opts(iargv);\n \n \n         if opts.stress {\n             stress(2);\n         } else {\n-            let max = uint::parse_buf(ivec::to_vec(str::bytes(argv.(1))),\n+            let max = uint::parse_buf(ivec::to_vec(str::bytes(iargv.(1))),\n                                       10u) as int;\n \n             let num_trials = 10;"}, {"sha": "447de996b8b7ea106c9ef19ec005ab034a5c8861", "filename": "src/test/bench/task-perf-spawnalot.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b762ba08902e6bcbc6a7e7fcb5d6d2978c909e1a/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b762ba08902e6bcbc6a7e7fcb5d6d2978c909e1a/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs?ref=b762ba08902e6bcbc6a7e7fcb5d6d2978c909e1a", "patch": "@@ -1,5 +1,4 @@\n use std;\n-import std::vec;\n import std::ivec;\n import std::task;\n import std::uint;\n@@ -17,10 +16,11 @@ fn g() {}\n \n fn main(args: vec[str]) {\n \n-    let n = if vec::len(args) < 2u {\n+    let iargs = ivec::from_vec(args);\n+    let n = if ivec::len(iargs) < 2u {\n         10u\n     } else {\n-        uint::parse_buf(ivec::to_vec(str::bytes(args.(1))), 10u)\n+        uint::parse_buf(ivec::to_vec(str::bytes(iargs.(1))), 10u)\n     };\n     let i = 0u;\n     while i < n {"}, {"sha": "de5ce7c8be9b29caae44efe09a0453dfe031f7f8", "filename": "src/test/bench/task-perf-word-count.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b762ba08902e6bcbc6a7e7fcb5d6d2978c909e1a/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b762ba08902e6bcbc6a7e7fcb5d6d2978c909e1a/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs?ref=b762ba08902e6bcbc6a7e7fcb5d6d2978c909e1a", "patch": "@@ -14,7 +14,6 @@ import option = std::option::t;\n import std::option::some;\n import std::option::none;\n import std::str;\n-import std::vec;\n import std::map;\n import std::ivec;\n import std::io;\n@@ -79,7 +78,7 @@ mod map_reduce {\n \n     tag reduce_proto { emit_val(int); done; ref; release; }\n \n-    fn start_mappers(ctrl: chan[ctrl_proto], inputs: vec[str]) -> [task] {\n+    fn start_mappers(ctrl: chan[ctrl_proto], inputs: &[str]) -> [task] {\n         let tasks = ~[];\n         // log_err \"starting mappers\";\n         for i: str  in inputs {\n@@ -166,7 +165,7 @@ mod map_reduce {\n         // log_err \"~reduce_task \" + key;\n     }\n \n-    fn map_reduce(inputs: vec[str]) {\n+    fn map_reduce(inputs: &[str]) {\n         let ctrl = port[ctrl_proto]();\n \n         // This task becomes the master control task. It spawns others\n@@ -178,7 +177,7 @@ mod map_reduce {\n \n         let tasks = start_mappers(chan(ctrl), inputs);\n \n-        let num_mappers = vec::len(inputs) as int;\n+        let num_mappers = ivec::len(inputs) as int;\n \n         while num_mappers > 0 {\n             let m;\n@@ -225,10 +224,11 @@ mod map_reduce {\n }\n \n fn main(argv: vec[str]) {\n-    if vec::len(argv) < 2u {\n+    let iargv = ivec::from_vec(argv);\n+    if ivec::len(iargv) < 2u {\n         let out = io::stdout();\n \n-        out.write_line(#fmt(\"Usage: %s <filename> ...\", argv.(0)));\n+        out.write_line(#fmt(\"Usage: %s <filename> ...\", iargv.(0)));\n \n         // TODO: run something just to make sure the code hasn't\n         // broken yet. This is the unit test mode of this program.\n@@ -242,7 +242,7 @@ fn main(argv: vec[str]) {\n \n     let start = time::precise_time_ns();\n \n-    map_reduce::map_reduce(vec::slice(argv, 1u, vec::len(argv)));\n+    map_reduce::map_reduce(ivec::slice(iargv, 1u, ivec::len(iargv)));\n     let stop = time::precise_time_ns();\n \n     let elapsed = stop - start;"}]}