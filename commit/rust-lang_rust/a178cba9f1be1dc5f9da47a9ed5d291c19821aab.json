{"sha": "a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExNzhjYmE5ZjFiZTFkYzVmOWRhNDdhOWVkNWQyOTFjMTk4MjFhYWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-06T23:36:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-06T23:36:16Z"}, "message": "Auto merge of #52021 - nikomatsakis:nll-region-errors, r=estebank\n\nrefactor and cleanup region errors for NLL\n\nThis is a WIP commit. It simplifies some of the code from https://github.com/rust-lang/rust/pull/51536 and extends a few more steps towards the errors that @davidtwco and I were shooting for. These are intended as a replacement for the general \"unable to infer lifetime\" messages -- one that is actually actionable. We're certainly not there yet, but the overall shape hopefully gets a bit clearer.\n\nI'm thinking about trying to open up an internals thread to sketch out the overall plan and perhaps discuss how to get the wording right, which special cases to handle, etc.\n\nr? @estebank\ncc @davidtwco", "tree": {"sha": "6092e66b90efa909adba9a82198f148dd6d1c12f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6092e66b90efa909adba9a82198f148dd6d1c12f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "html_url": "https://github.com/rust-lang/rust/commit/a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e06c875442e91cc2c597135d1e807a69e73eee26", "url": "https://api.github.com/repos/rust-lang/rust/commits/e06c875442e91cc2c597135d1e807a69e73eee26", "html_url": "https://github.com/rust-lang/rust/commit/e06c875442e91cc2c597135d1e807a69e73eee26"}, {"sha": "727f01700b074181bddf49caa07ac5e34455680d", "url": "https://api.github.com/repos/rust-lang/rust/commits/727f01700b074181bddf49caa07ac5e34455680d", "html_url": "https://github.com/rust-lang/rust/commit/727f01700b074181bddf49caa07ac5e34455680d"}], "stats": {"total": 989, "additions": 694, "deletions": 295}, "files": [{"sha": "6217f6c9fdd33d9a7ebb06bbbd1b02e1cc1a8624", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -30,7 +30,7 @@ impl_stable_hash_for!(struct mir::LocalDecl<'tcx> {\n     internal,\n     is_user_variable\n });\n-impl_stable_hash_for!(struct mir::UpvarDecl { debug_name, by_ref, mutability });\n+impl_stable_hash_for!(struct mir::UpvarDecl { debug_name, var_hir_id, by_ref, mutability });\n impl_stable_hash_for!(struct mir::BasicBlockData<'tcx> { statements, terminator, is_cleanup });\n impl_stable_hash_for!(struct mir::UnsafetyViolation { source_info, description, kind });\n impl_stable_hash_for!(struct mir::UnsafetyCheckResult { violations, unsafe_blocks });"}, {"sha": "cd4b32735e57a220f0f395da909f91f9e364803c", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -15,7 +15,7 @@\n use graphviz::IntoCow;\n use hir::def::CtorKind;\n use hir::def_id::DefId;\n-use hir::{self, InlineAsm};\n+use hir::{self, HirId, InlineAsm};\n use middle::region;\n use mir::interpret::{EvalErrorKind, Scalar, Value};\n use mir::visit::MirVisitable;\n@@ -380,6 +380,15 @@ pub enum ClearCrossCrate<T> {\n     Set(T),\n }\n \n+impl<T> ClearCrossCrate<T> {\n+    pub fn assert_crate_local(self) -> T {\n+        match self {\n+            ClearCrossCrate::Clear => bug!(\"unwrapping cross-crate data\"),\n+            ClearCrossCrate::Set(v) => v,\n+        }\n+    }\n+}\n+\n impl<T: serialize::Encodable> serialize::UseSpecializedEncodable for ClearCrossCrate<T> {}\n impl<T: serialize::Decodable> serialize::UseSpecializedDecodable for ClearCrossCrate<T> {}\n \n@@ -785,6 +794,9 @@ impl<'tcx> LocalDecl<'tcx> {\n pub struct UpvarDecl {\n     pub debug_name: Name,\n \n+    /// `HirId` of the captured variable\n+    pub var_hir_id: ClearCrossCrate<HirId>,\n+\n     /// If true, the capture is behind a reference.\n     pub by_ref: bool,\n "}, {"sha": "076a19fb4ed7216ddd9e9a385348a29eb48fa7ea", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 32, "deletions": 14, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -253,13 +253,34 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         value.fold_with(&mut RegionFolder::new(self, skipped_regions, &mut f))\n     }\n \n-    pub fn for_each_free_region<T,F>(self,\n-                                     value: &T,\n-                                     callback: F)\n-        where F: FnMut(ty::Region<'tcx>),\n-              T: TypeFoldable<'tcx>,\n-    {\n-        value.visit_with(&mut RegionVisitor {\n+    /// Invoke `callback` on every region appearing free in `value`.\n+    pub fn for_each_free_region(\n+        self,\n+        value: &impl TypeFoldable<'tcx>,\n+        mut callback: impl FnMut(ty::Region<'tcx>),\n+    ) {\n+        self.any_free_region_meets(value, |r| {\n+            callback(r);\n+            false\n+        });\n+    }\n+\n+    /// True if `callback` returns true for every region appearing free in `value`.\n+    pub fn all_free_regions_meet(\n+        self,\n+        value: &impl TypeFoldable<'tcx>,\n+        mut callback: impl FnMut(ty::Region<'tcx>) -> bool,\n+    ) -> bool {\n+        !self.any_free_region_meets(value, |r| !callback(r))\n+    }\n+\n+    /// True if `callback` returns true for some region appearing free in `value`.\n+    pub fn any_free_region_meets(\n+        self,\n+        value: &impl TypeFoldable<'tcx>,\n+        callback: impl FnMut(ty::Region<'tcx>) -> bool,\n+    ) -> bool {\n+        return value.visit_with(&mut RegionVisitor {\n             outer_index: ty::INNERMOST,\n             callback\n         });\n@@ -287,25 +308,22 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         impl<'tcx, F> TypeVisitor<'tcx> for RegionVisitor<F>\n-            where F : FnMut(ty::Region<'tcx>)\n+            where F: FnMut(ty::Region<'tcx>) -> bool\n         {\n             fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> bool {\n                 self.outer_index.shift_in(1);\n-                t.skip_binder().visit_with(self);\n+                let result = t.skip_binder().visit_with(self);\n                 self.outer_index.shift_out(1);\n-\n-                false // keep visiting\n+                result\n             }\n \n             fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n                 match *r {\n                     ty::ReLateBound(debruijn, _) if debruijn < self.outer_index => {\n-                        /* ignore bound regions */\n+                        false // ignore bound regions, keep visiting\n                     }\n                     _ => (self.callback)(r),\n                 }\n-\n-                false // keep visiting\n             }\n         }\n     }"}, {"sha": "29f13d669fa9ac3dfe0b23ca51daf12ef6c8ed7f", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -128,6 +128,8 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     input_mir: &Mir<'gcx>,\n     def_id: DefId,\n ) -> BorrowCheckResult<'gcx> {\n+    debug!(\"do_mir_borrowck(def_id = {:?})\", def_id);\n+\n     let tcx = infcx.tcx;\n     let attributes = tcx.get_attrs(def_id);\n     let param_env = tcx.param_env(def_id);\n@@ -319,10 +321,14 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         }\n     }\n \n-    BorrowCheckResult {\n+    let result = BorrowCheckResult {\n         closure_requirements: opt_closure_req,\n         used_mut_upvars: mbcx.used_mut_upvars,\n-    }\n+    };\n+\n+    debug!(\"do_mir_borrowck: result = {:#?}\", result);\n+\n+    result\n }\n \n #[allow(dead_code)]"}, {"sha": "786b6a77d2bdbc77a4a8091f63a24066d7b1cc30", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "renamed", "additions": 133, "deletions": 132, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -8,19 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::fmt;\n-use borrow_check::nll::region_infer::{ConstraintIndex, RegionInferenceContext};\n use borrow_check::nll::region_infer::values::ToElementIndex;\n+use borrow_check::nll::region_infer::{ConstraintIndex, RegionInferenceContext};\n use borrow_check::nll::type_check::Locations;\n use rustc::hir::def_id::DefId;\n-use rustc::infer::InferCtxt;\n use rustc::infer::error_reporting::nice_region_error::NiceRegionError;\n-use rustc::mir::{self, Location, Mir, Place, StatementKind, TerminatorKind, Rvalue};\n+use rustc::infer::InferCtxt;\n+use rustc::mir::{self, Location, Mir, Place, Rvalue, StatementKind, TerminatorKind};\n use rustc::ty::RegionVid;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n+use std::fmt;\n use syntax_pos::Span;\n \n+mod region_name;\n+\n /// Constraints that are considered interesting can be categorized to\n /// determine why they are interesting. Order of variants indicates\n /// sort order of the category, thereby influencing diagnostic output.\n@@ -47,115 +49,105 @@ impl fmt::Display for ConstraintCategory {\n }\n \n impl<'tcx> RegionInferenceContext<'tcx> {\n-    /// When reporting an error, it is useful to be able to determine which constraints influenced\n-    /// the region being reported as an error. This function finds all of the paths from the\n+    /// Walks the graph of constraints (where `'a: 'b` is considered\n+    /// an edge `'b -> 'a`) to find all paths from `from_region` to\n+    /// `to_region`. The paths are accumulated into the vector\n+    /// `results`. The paths are stored as a series of\n+    /// `ConstraintIndex` values -- in other words, a list of *edges*.\n+    ///\n+    /// # Parameters\n+    ///\n+    /// - `from_region`\n+    /// When reporting an error, it is useful to be able to determine\n+    /// which constraints influenced the region being reported as an\n+    /// error. This function finds all of the paths from the\n     /// constraint.\n-    fn find_constraint_paths_from_region(\n+    fn find_constraint_paths_between_regions(\n         &self,\n-        r0: RegionVid\n+        from_region: RegionVid,\n+        target_test: impl Fn(RegionVid) -> bool,\n     ) -> Vec<Vec<ConstraintIndex>> {\n-        let constraints = self.constraints.clone();\n-\n-        // Mapping of regions to the previous region and constraint index that led to it.\n-        let mut previous = FxHashMap();\n-        // Regions yet to be visited.\n-        let mut next = vec! [ r0 ];\n-        // Regions that have been visited.\n-        let mut visited = FxHashSet();\n-        // Ends of paths.\n-        let mut end_regions = FxHashSet();\n-\n-        // When we've still got points to visit...\n-        while let Some(current) = next.pop() {\n-            // ...take the next point...\n-            debug!(\"find_constraint_paths_from_region: current={:?} visited={:?} next={:?}\",\n-                   current, visited, next);\n-            // ...but make sure not to visit this point again...\n-            visited.insert(current);\n-\n-            // ...find the edges containing it...\n-            let mut upcoming = Vec::new();\n-            for (index, constraint) in constraints.iter_enumerated() {\n-                if constraint.sub == current {\n-                    // ...add the regions that join us with to the path we've taken...\n-                    debug!(\"find_constraint_paths_from_region: index={:?} constraint={:?}\",\n-                           index, constraint);\n-                    let next_region = constraint.sup.clone();\n-\n-                    // ...unless we've visited it since this was added...\n-                    if visited.contains(&next_region) {\n-                        debug!(\"find_constraint_paths_from_region: skipping as visited\");\n-                        continue;\n-                    }\n-\n-                    previous.insert(next_region, (index, Some(current)));\n-                    upcoming.push(next_region);\n-                }\n-            }\n+        let mut results = vec![];\n+        self.find_constraint_paths_between_regions_helper(\n+            from_region,\n+            from_region,\n+            &target_test,\n+            &mut FxHashSet::default(),\n+            &mut vec![],\n+            &mut results,\n+        );\n+        results\n+    }\n \n-            if upcoming.is_empty() {\n-                // If we didn't find any edges then this is the end of a path...\n-                debug!(\"find_constraint_paths_from_region: new end region current={:?}\", current);\n-                end_regions.insert(current);\n-            } else {\n-                // ...but, if we did find edges, then add these to the regions yet to visit.\n-                debug!(\"find_constraint_paths_from_region: extend next upcoming={:?}\", upcoming);\n-                next.extend(upcoming);\n-            }\n+    /// Helper for `find_constraint_paths_between_regions`.\n+    fn find_constraint_paths_between_regions_helper(\n+        &self,\n+        from_region: RegionVid,\n+        current_region: RegionVid,\n+        target_test: &impl Fn(RegionVid) -> bool,\n+        visited: &mut FxHashSet<RegionVid>,\n+        stack: &mut Vec<ConstraintIndex>,\n+        results: &mut Vec<Vec<ConstraintIndex>>,\n+    ) {\n+        let dependency_map = self.dependency_map.as_ref().unwrap();\n \n+        // Check if we already visited this region.\n+        if !visited.insert(current_region) {\n+            return;\n         }\n \n-        // Now we've visited each point, compute the final paths.\n-        let mut paths: Vec<Vec<ConstraintIndex>> = Vec::new();\n-        debug!(\"find_constraint_paths_from_region: end_regions={:?}\", end_regions);\n-        for end_region in end_regions {\n-            debug!(\"find_constraint_paths_from_region: end_region={:?}\", end_region);\n-\n-            // Get the constraint and region that led to this end point.\n-            // We can unwrap as we know if end_point was in the vector that it\n-            // must also be in our previous map.\n-            let (mut index, mut region) = previous.get(&end_region).unwrap();\n-            debug!(\"find_constraint_paths_from_region: index={:?} region={:?}\", index, region);\n-\n-            // Keep track of the indices.\n-            let mut path: Vec<ConstraintIndex> = vec![index];\n-\n-            while region.is_some() && region != Some(r0) {\n-                let p = previous.get(&region.unwrap()).unwrap();\n-                index = p.0;\n-                region = p.1;\n-\n-                debug!(\"find_constraint_paths_from_region: index={:?} region={:?}\", index, region);\n-                path.push(index);\n+        // Check if we reached the region we were looking for.\n+        if target_test(current_region) {\n+            if !stack.is_empty() {\n+                assert_eq!(self.constraints[stack[0]].sub, from_region);\n+                results.push(stack.clone());\n             }\n-\n-            // Add to our paths.\n-            paths.push(path);\n+            return;\n         }\n \n-        debug!(\"find_constraint_paths_from_region: paths={:?}\", paths);\n-        paths\n+        self.constraints\n+            .each_affected_by_dirty(dependency_map[current_region], |constraint| {\n+                assert_eq!(self.constraints[constraint].sub, current_region);\n+                stack.push(constraint);\n+                self.find_constraint_paths_between_regions_helper(\n+                    from_region,\n+                    self.constraints[constraint].sup,\n+                    target_test,\n+                    visited,\n+                    stack,\n+                    results,\n+                );\n+                stack.pop();\n+            });\n     }\n \n     /// This function will return true if a constraint is interesting and false if a constraint\n     /// is not. It is useful in filtering constraint paths to only interesting points.\n-    fn constraint_is_interesting(&self, index: &ConstraintIndex) -> bool {\n-        self.constraints.get(*index).filter(|constraint| {\n-            debug!(\"constraint_is_interesting: locations={:?} constraint={:?}\",\n-                   constraint.locations, constraint);\n-            if let Locations::Interesting(_) = constraint.locations { true } else { false }\n-        }).is_some()\n+    fn constraint_is_interesting(&self, index: ConstraintIndex) -> bool {\n+        let constraint = self.constraints[index];\n+        debug!(\n+            \"constraint_is_interesting: locations={:?} constraint={:?}\",\n+            constraint.locations, constraint\n+        );\n+        if let Locations::Interesting(_) = constraint.locations {\n+            true\n+        } else {\n+            false\n+        }\n     }\n \n     /// This function classifies a constraint from a location.\n-    fn classify_constraint(&self, index: &ConstraintIndex,\n-                           mir: &Mir<'tcx>) -> Option<(ConstraintCategory, Span)> {\n-        let constraint = self.constraints.get(*index)?;\n+    fn classify_constraint(\n+        &self,\n+        index: ConstraintIndex,\n+        mir: &Mir<'tcx>,\n+    ) -> (ConstraintCategory, Span) {\n+        let constraint = self.constraints[index];\n         let span = constraint.locations.span(mir);\n-        let location = constraint.locations.from_location()?;\n+        let location = constraint.locations.from_location().unwrap_or(Location::START);\n \n         if !self.constraint_is_interesting(index) {\n-            return Some((ConstraintCategory::Boring, span));\n+            return (ConstraintCategory::Boring, span);\n         }\n \n         let data = &mir[location.block];\n@@ -182,12 +174,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                             _ => ConstraintCategory::Other,\n                         }\n                     }\n-                },\n+                }\n                 _ => ConstraintCategory::Other,\n             }\n         };\n \n-        Some((category, span))\n+        (category, span)\n     }\n \n     /// Report an error because the universal region `fr` was required to outlive\n@@ -207,56 +199,62 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         outlived_fr: RegionVid,\n         blame_span: Span,\n     ) {\n-        // Obviously uncool error reporting.\n-\n-        let fr_name = self.to_error_region(fr);\n-        let outlived_fr_name = self.to_error_region(outlived_fr);\n+        debug!(\"report_error(fr={:?}, outlived_fr={:?})\", fr, outlived_fr);\n \n-        if let (Some(f), Some(o)) = (fr_name, outlived_fr_name) {\n+        if let (Some(f), Some(o)) = (self.to_error_region(fr), self.to_error_region(outlived_fr)) {\n             let tables = infcx.tcx.typeck_tables_of(mir_def_id);\n             let nice = NiceRegionError::new_from_span(infcx.tcx, blame_span, o, f, Some(tables));\n             if let Some(_error_reported) = nice.try_report() {\n                 return;\n             }\n         }\n \n-        let fr_string = match fr_name {\n-            Some(r) => format!(\"free region `{}`\", r),\n-            None => format!(\"free region `{:?}`\", fr),\n-        };\n-\n-        let outlived_fr_string = match outlived_fr_name {\n-            Some(r) => format!(\"free region `{}`\", r),\n-            None => format!(\"free region `{:?}`\", outlived_fr),\n-        };\n+        // Find all paths\n+        let constraint_paths = self.find_constraint_paths_between_regions(outlived_fr, |r| r == fr);\n+        debug!(\"report_error: constraint_paths={:#?}\", constraint_paths);\n \n-        let constraints = self.find_constraint_paths_from_region(fr.clone());\n-        let path = constraints.iter().min_by_key(|p| p.len()).unwrap();\n+        // Find the shortest such path.\n+        let path = constraint_paths.iter().min_by_key(|p| p.len()).unwrap();\n         debug!(\"report_error: shortest_path={:?}\", path);\n \n-        let mut categorized_path = path.iter().filter_map(|index| {\n-            self.classify_constraint(index, mir)\n-        }).collect::<Vec<(ConstraintCategory, Span)>>();\n+        // Classify each of the constraints along the path.\n+        let mut categorized_path: Vec<(ConstraintCategory, Span)> = path.iter()\n+            .map(|&index| self.classify_constraint(index, mir))\n+            .collect();\n         debug!(\"report_error: categorized_path={:?}\", categorized_path);\n \n+        // Find what appears to be the most interesting path to report to the user.\n         categorized_path.sort_by(|p0, p1| p0.0.cmp(&p1.0));\n         debug!(\"report_error: sorted_path={:?}\", categorized_path);\n \n-        if let Some((category, span)) = &categorized_path.first() {\n-            let mut diag = infcx.tcx.sess.struct_span_err(\n-                *span, &format!(\"{} requires that data must outlive {}\",\n-                                category, outlived_fr_string),\n-            );\n-\n-            diag.emit();\n-        } else {\n-            let mut diag = infcx.tcx.sess.struct_span_err(\n-                blame_span,\n-                &format!(\"{} does not outlive {}\", fr_string, outlived_fr_string,),\n-            );\n-\n-            diag.emit();\n-        }\n+        // Get a span\n+        let (category, span) = categorized_path.first().unwrap();\n+        let diag = &mut infcx.tcx.sess.struct_span_err(\n+            *span,\n+            &format!(\"unsatisfied lifetime constraints\"), // FIXME\n+        );\n+\n+        // Figure out how we can refer\n+        let counter = &mut 1;\n+        let fr_name = self.give_region_a_name(infcx.tcx, mir, mir_def_id, fr, counter, diag);\n+        let outlived_fr_name = self.give_region_a_name(\n+            infcx.tcx,\n+            mir,\n+            mir_def_id,\n+            outlived_fr,\n+            counter,\n+            diag,\n+        );\n+\n+        diag.span_label(\n+            *span,\n+            format!(\n+                \"{} requires that `{}` must outlive `{}`\",\n+                category, fr_name, outlived_fr_name,\n+            ),\n+        );\n+\n+        diag.emit();\n     }\n \n     // Find some constraint `X: Y` where:\n@@ -269,8 +267,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     /// Tries to finds a good span to blame for the fact that `fr1`\n     /// contains `fr2`.\n-    pub(super) fn blame_constraint(&self, fr1: RegionVid,\n-                                   elem: impl ToElementIndex) -> ConstraintIndex {\n+    pub(super) fn blame_constraint(\n+        &self,\n+        fr1: RegionVid,\n+        elem: impl ToElementIndex,\n+    ) -> ConstraintIndex {\n         // Find everything that influenced final value of `fr`.\n         let influenced_fr1 = self.dependencies(fr1);\n ", "previous_filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting.rs"}, {"sha": "bf8c9c8c3bef43053f2fe419da4f97fdd2603c34", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "added", "additions": 256, "deletions": 0, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -0,0 +1,256 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use borrow_check::nll::region_infer::RegionInferenceContext;\n+use borrow_check::nll::ToRegionVid;\n+use rustc::hir::def_id::DefId;\n+use rustc::mir::{Local, Mir};\n+use rustc::ty::{self, RegionVid, TyCtxt};\n+use rustc_data_structures::indexed_vec::Idx;\n+use rustc_errors::DiagnosticBuilder;\n+use syntax::ast::Name;\n+use syntax::symbol::keywords;\n+use syntax_pos::symbol::InternedString;\n+\n+impl<'tcx> RegionInferenceContext<'tcx> {\n+    /// Maps from an internal MIR region vid to something that we can\n+    /// report to the user. In some cases, the region vids will map\n+    /// directly to lifetimes that the user has a name for (e.g.,\n+    /// `'static`). But frequently they will not, in which case we\n+    /// have to find some way to identify the lifetime to the user. To\n+    /// that end, this function takes a \"diagnostic\" so that it can\n+    /// create auxiliary notes as needed.\n+    ///\n+    /// Example (function arguments):\n+    ///\n+    /// Suppose we are trying to give a name to the lifetime of the\n+    /// reference `x`:\n+    ///\n+    /// ```\n+    /// fn foo(x: &u32) { .. }\n+    /// ```\n+    ///\n+    /// This function would create a label like this:\n+    ///\n+    /// ```\n+    ///  | fn foo(x: &u32) { .. }\n+    ///           ------- fully elaborated type of `x` is `&'1 u32`\n+    /// ```\n+    ///\n+    /// and then return the name `'1` for us to use.\n+    crate fn give_region_a_name(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        mir: &Mir<'tcx>,\n+        mir_def_id: DefId,\n+        fr: RegionVid,\n+        counter: &mut usize,\n+        diag: &mut DiagnosticBuilder,\n+    ) -> InternedString {\n+        debug!(\"give_region_a_name(fr={:?}, counter={})\", fr, counter);\n+\n+        assert!(self.universal_regions.is_universal_region(fr));\n+\n+        self.give_name_from_error_region(tcx, mir_def_id, fr, counter, diag)\n+            .or_else(|| {\n+                self.give_name_if_anonymous_region_appears_in_arguments(tcx, mir, fr, counter, diag)\n+            })\n+            .or_else(|| {\n+                self.give_name_if_anonymous_region_appears_in_upvars(tcx, mir, fr, counter, diag)\n+            })\n+            .or_else(|| {\n+                self.give_name_if_anonymous_region_appears_in_output(tcx, mir, fr, counter, diag)\n+            })\n+            .unwrap_or_else(|| span_bug!(mir.span, \"can't make a name for free region {:?}\", fr))\n+    }\n+\n+    /// Check for the case where `fr` maps to something that the\n+    /// *user* has a name for. In that case, we'll be able to map\n+    /// `fr` to a `Region<'tcx>`, and that region will be one of\n+    /// named variants.\n+    fn give_name_from_error_region(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        mir_def_id: DefId,\n+        fr: RegionVid,\n+        counter: &mut usize,\n+        diag: &mut DiagnosticBuilder<'_>,\n+    ) -> Option<InternedString> {\n+        let error_region = self.to_error_region(fr)?;\n+        debug!(\"give_region_a_name: error_region = {:?}\", error_region);\n+        match error_region {\n+            ty::ReEarlyBound(ebr) => Some(ebr.name),\n+\n+            ty::ReStatic => Some(keywords::StaticLifetime.name().as_interned_str()),\n+\n+            ty::ReFree(free_region) => match free_region.bound_region {\n+                ty::BoundRegion::BrNamed(_, name) => Some(name),\n+\n+                ty::BoundRegion::BrEnv => {\n+                    let closure_span = tcx.hir.span_if_local(mir_def_id).unwrap();\n+                    let region_name = self.synthesize_region_name(counter);\n+                    diag.span_label(\n+                        closure_span,\n+                        format!(\"lifetime `{}` represents the closure body\", region_name),\n+                    );\n+                    Some(region_name)\n+                }\n+\n+                ty::BoundRegion::BrAnon(_) | ty::BoundRegion::BrFresh(_) => None,\n+            },\n+\n+            ty::ReLateBound(..)\n+            | ty::ReScope(..)\n+            | ty::ReVar(..)\n+            | ty::ReSkolemized(..)\n+            | ty::ReEmpty\n+            | ty::ReErased\n+            | ty::ReClosureBound(..)\n+            | ty::ReCanonical(..) => None,\n+        }\n+    }\n+\n+    /// Find an argument that contains `fr` and label it with a fully\n+    /// elaborated type, returning something like `'1`. Result looks\n+    /// like:\n+    ///\n+    /// ```\n+    ///  | fn foo(x: &u32) { .. }\n+    ///           ------- fully elaborated type of `x` is `&'1 u32`\n+    /// ```\n+    fn give_name_if_anonymous_region_appears_in_arguments(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        mir: &Mir<'tcx>,\n+        fr: RegionVid,\n+        counter: &mut usize,\n+        diag: &mut DiagnosticBuilder<'_>,\n+    ) -> Option<InternedString> {\n+        let implicit_inputs = self.universal_regions.defining_ty.implicit_inputs();\n+        let argument_index = self.universal_regions\n+            .unnormalized_input_tys\n+            .iter()\n+            .skip(implicit_inputs)\n+            .position(|arg_ty| {\n+                debug!(\"give_name_if_anonymous_region_appears_in_arguments: arg_ty = {:?}\", arg_ty);\n+                tcx.any_free_region_meets(arg_ty, |r| r.to_region_vid() == fr)\n+            })?\n+            + implicit_inputs;\n+\n+        debug!(\n+            \"give_name_if_anonymous_region_appears_in_arguments: \\\n+             found {:?} in argument {} which has type {:?}\",\n+            fr, argument_index, self.universal_regions.unnormalized_input_tys[argument_index],\n+        );\n+\n+        let region_name = self.synthesize_region_name(counter);\n+\n+        let argument_local = Local::new(argument_index + 1);\n+        let argument_span = mir.local_decls[argument_local].source_info.span;\n+        diag.span_label(\n+            argument_span,\n+            format!(\"lifetime `{}` appears in this argument\", region_name,),\n+        );\n+\n+        Some(region_name)\n+    }\n+\n+    /// Find a closure upvar that contains `fr` and label it with a\n+    /// fully elaborated type, returning something like `'1`. Result\n+    /// looks like:\n+    ///\n+    /// ```\n+    ///  | let x = Some(&22);\n+    ///        - fully elaborated type of `x` is `Option<&'1 u32>`\n+    /// ```\n+    fn give_name_if_anonymous_region_appears_in_upvars(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        mir: &Mir<'tcx>,\n+        fr: RegionVid,\n+        counter: &mut usize,\n+        diag: &mut DiagnosticBuilder<'_>,\n+    ) -> Option<InternedString> {\n+        let upvar_index = self.universal_regions\n+            .defining_ty\n+            .upvar_tys(tcx)\n+            .position(|upvar_ty| {\n+                debug!(\n+                    \"give_name_if_anonymous_region_appears_in_upvars: upvar_ty = {:?}\",\n+                    upvar_ty,\n+                );\n+                tcx.any_free_region_meets(&upvar_ty, |r| r.to_region_vid() == fr)\n+            })?;\n+\n+        debug!(\n+            \"give_name_if_anonymous_region_appears_in_upvars: \\\n+             found {:?} in upvar {} which has type {:?}\",\n+            fr,\n+            upvar_index,\n+            self.universal_regions\n+                .defining_ty\n+                .upvar_tys(tcx)\n+                .nth(upvar_index),\n+        );\n+\n+        let region_name = self.synthesize_region_name(counter);\n+\n+        let upvar_hir_id = mir.upvar_decls[upvar_index].var_hir_id.assert_crate_local();\n+        let upvar_node_id = tcx.hir.hir_to_node_id(upvar_hir_id);\n+        let upvar_span = tcx.hir.span(upvar_node_id);\n+        let upvar_name = tcx.hir.name(upvar_node_id);\n+        diag.span_label(\n+            upvar_span,\n+            format!(\n+                \"lifetime `{}` appears in the type of `{}`\",\n+                region_name, upvar_name,\n+            ),\n+        );\n+\n+        Some(region_name)\n+    }\n+\n+    /// Check for arguments appearing in the (closure) return type. It\n+    /// must be a closure since, in a free fn, such an argument would\n+    /// have to either also appear in an argument (if using elision)\n+    /// or be early bound (named, not in argument).\n+    fn give_name_if_anonymous_region_appears_in_output(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        mir: &Mir<'tcx>,\n+        fr: RegionVid,\n+        counter: &mut usize,\n+        diag: &mut DiagnosticBuilder<'_>,\n+    ) -> Option<InternedString> {\n+        let return_ty = self.universal_regions\n+            .unnormalized_output_ty;\n+        debug!(\"give_name_if_anonymous_region_appears_in_output: return_ty = {:?}\", return_ty);\n+        if !tcx.any_free_region_meets(&return_ty, |r| r.to_region_vid() == fr) {\n+            return None;\n+        }\n+\n+        let region_name = self.synthesize_region_name(counter);\n+        diag.span_label(\n+            mir.span,\n+            format!(\"lifetime `{}` appears in return type\", region_name),\n+        );\n+\n+        Some(region_name)\n+    }\n+\n+    /// Create a synthetic region named `'1`, incrementing the\n+    /// counter.\n+    fn synthesize_region_name(&self, counter: &mut usize) -> InternedString {\n+        let c = *counter;\n+        *counter += 1;\n+\n+        Name::intern(&format!(\"'{:?}\", c)).as_interned_str()\n+    }\n+}"}, {"sha": "164941203e05443a2319c59aac6ed8f5bc54ca15", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -256,6 +256,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn init_universal_regions(&mut self) {\n         // Update the names (if any)\n         for (external_name, variable) in self.universal_regions.named_universal_regions() {\n+            debug!(\n+                \"init_universal_regions: region {:?} has external name {:?}\",\n+                variable,\n+                external_name\n+            );\n             self.definitions[variable].external_name = Some(external_name);\n         }\n "}, {"sha": "8590e3d0765f0c9f77adbab6fba903a4bbae64a7", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 52, "deletions": 24, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -22,15 +22,16 @@\n //! The code in this file doesn't *do anything* with those results; it\n //! just returns them for other code to use.\n \n-use rustc::hir::{self, BodyOwnerKind, HirId};\n+use either::Either;\n use rustc::hir::def_id::DefId;\n-use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n-use rustc::infer::region_constraints::GenericKind;\n+use rustc::hir::{self, BodyOwnerKind, HirId};\n use rustc::infer::outlives::bounds::{self, OutlivesBound};\n use rustc::infer::outlives::free_region_map::FreeRegionRelations;\n-use rustc::ty::{self, RegionVid, Ty, TyCtxt, ClosureSubsts, GeneratorSubsts};\n+use rustc::infer::region_constraints::GenericKind;\n+use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::Substs;\n+use rustc::ty::{self, ClosureSubsts, GeneratorSubsts, RegionVid, Ty, TyCtxt};\n use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::transitive_relation::TransitiveRelation;\n@@ -128,6 +129,34 @@ pub enum DefiningTy<'tcx> {\n     Const(DefId, &'tcx Substs<'tcx>),\n }\n \n+impl<'tcx> DefiningTy<'tcx> {\n+    /// Returns a list of all the upvar types for this MIR. If this is\n+    /// not a closure or generator, there are no upvars, and hence it\n+    /// will be an empty list. The order of types in this list will\n+    /// match up with the `upvar_decls` field of `Mir`.\n+    pub fn upvar_tys(self, tcx: TyCtxt<'_, '_, 'tcx>) -> impl Iterator<Item = Ty<'tcx>> + 'tcx {\n+        match self {\n+            DefiningTy::Closure(def_id, substs) => Either::Left(substs.upvar_tys(def_id, tcx)),\n+            DefiningTy::Generator(def_id, substs, _) => {\n+                Either::Right(Either::Left(substs.upvar_tys(def_id, tcx)))\n+            }\n+            DefiningTy::FnDef(..) | DefiningTy::Const(..) => {\n+                Either::Right(Either::Right(iter::empty()))\n+            }\n+        }\n+    }\n+\n+    /// Number of implicit inputs -- notably the \"environment\"\n+    /// parameter for closures -- that appear in MIR but not in the\n+    /// user's code.\n+    pub fn implicit_inputs(self) -> usize {\n+        match self {\n+            DefiningTy::Closure(..) | DefiningTy::Generator(..) => 1,\n+            DefiningTy::FnDef(..) | DefiningTy::Const(..) => 0,\n+        }\n+    }\n+}\n+\n #[derive(Debug)]\n struct UniversalRegionIndices<'tcx> {\n     /// For those regions that may appear in the parameter environment\n@@ -493,18 +522,15 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n \n         debug!(\n             \"build: global regions = {}..{}\",\n-            FIRST_GLOBAL_INDEX,\n-            first_extern_index\n+            FIRST_GLOBAL_INDEX, first_extern_index\n         );\n         debug!(\n             \"build: extern regions = {}..{}\",\n-            first_extern_index,\n-            first_local_index\n+            first_extern_index, first_local_index\n         );\n         debug!(\n             \"build: local regions  = {}..{}\",\n-            first_local_index,\n-            num_universals\n+            first_local_index, num_universals\n         );\n \n         let yield_ty = match defining_ty {\n@@ -545,10 +571,12 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n                     tables.node_id_to_type(self.mir_hir_id)\n                 };\n \n+                debug!(\"defining_ty (pre-replacement): {:?}\", defining_ty);\n+\n                 let defining_ty = self.infcx\n                     .replace_free_regions_with_nll_infer_vars(FR, &defining_ty);\n \n-                match defining_ty.sty  {\n+                match defining_ty.sty {\n                     ty::TyClosure(def_id, substs) => DefiningTy::Closure(def_id, substs),\n                     ty::TyGenerator(def_id, substs, movability) => {\n                         DefiningTy::Generator(def_id, substs, movability)\n@@ -587,8 +615,8 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n         let closure_base_def_id = tcx.closure_base_def_id(self.mir_def_id);\n         let identity_substs = Substs::identity_for_item(gcx, closure_base_def_id);\n         let fr_substs = match defining_ty {\n-            DefiningTy::Closure(_, ClosureSubsts { ref substs }) |\n-            DefiningTy::Generator(_, GeneratorSubsts { ref substs }, _) => {\n+            DefiningTy::Closure(_, ClosureSubsts { ref substs })\n+            | DefiningTy::Generator(_, GeneratorSubsts { ref substs }, _) => {\n                 // In the case of closures, we rely on the fact that\n                 // the first N elements in the ClosureSubsts are\n                 // inherited from the `closure_base_def_id`.\n@@ -726,8 +754,7 @@ impl UniversalRegionRelations {\n     fn relate_universal_regions(&mut self, fr_a: RegionVid, fr_b: RegionVid) {\n         debug!(\n             \"relate_universal_regions: fr_a={:?} outlives fr_b={:?}\",\n-            fr_a,\n-            fr_b\n+            fr_a, fr_b\n         );\n         self.outlives.add(fr_a, fr_b);\n         self.inverse_outlives.add(fr_b, fr_a);\n@@ -780,8 +807,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'gcx, 'tcx> {\n     {\n         debug!(\n             \"replace_bound_regions_with_nll_infer_vars(value={:?}, all_outlive_scope={:?})\",\n-            value,\n-            all_outlive_scope,\n+            value, all_outlive_scope,\n         );\n         let (value, _map) = self.tcx.replace_late_bound_regions(value, |br| {\n             let liberated_region = self.tcx.mk_region(ty::ReFree(ty::FreeRegion {\n@@ -790,7 +816,10 @@ impl<'cx, 'gcx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'gcx, 'tcx> {\n             }));\n             let region_vid = self.next_nll_region_var(origin);\n             indices.insert_late_bound_region(liberated_region, region_vid.to_region_vid());\n-            debug!(\"liberated_region={:?} => {:?}\", liberated_region, region_vid);\n+            debug!(\n+                \"liberated_region={:?} => {:?}\",\n+                liberated_region, region_vid\n+            );\n             region_vid\n         });\n         value\n@@ -803,9 +832,8 @@ impl<'tcx> UniversalRegionIndices<'tcx> {\n     /// in later and instantiate the late-bound regions, and then we\n     /// insert the `ReFree` version of those into the map as\n     /// well. These are used for error reporting.\n-    fn insert_late_bound_region(&mut self, r: ty::Region<'tcx>,\n-                                vid: ty::RegionVid)\n-    {\n+    fn insert_late_bound_region(&mut self, r: ty::Region<'tcx>, vid: ty::RegionVid) {\n+        debug!(\"insert_late_bound_region({:?}, {:?})\", r, vid);\n         self.indices.insert(r, vid);\n     }\n \n@@ -821,9 +849,9 @@ impl<'tcx> UniversalRegionIndices<'tcx> {\n         if let ty::ReVar(..) = r {\n             r.to_region_vid()\n         } else {\n-            *self.indices.get(&r).unwrap_or_else(|| {\n-                bug!(\"cannot convert `{:?}` to a region vid\", r)\n-            })\n+            *self.indices\n+                .get(&r)\n+                .unwrap_or_else(|| bug!(\"cannot convert `{:?}` to a region vid\", r))\n         }\n     }\n "}, {"sha": "a3f97376e90d386e62b62cba08f773a259264c6d", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -534,6 +534,7 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n             };\n             let mut decl = UpvarDecl {\n                 debug_name: keywords::Invalid.name(),\n+                var_hir_id: ClearCrossCrate::Set(var_hir_id),\n                 by_ref,\n                 mutability: Mutability::Not,\n             };"}, {"sha": "b821c7cfa34ff97029aa489ee569e7381e38e61f", "filename": "src/test/compile-fail/borrowck/borrowck-describe-lvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-describe-lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-describe-lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-describe-lvalue.rs?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -302,7 +302,7 @@ fn main() {\n         // FIXME(#49824) -- the free region error below should probably not be there\n         let mut x = 0;\n            || {\n-               || { //[mir]~ ERROR free region `` does not outlive\n+               || { //[mir]~ ERROR unsatisfied lifetime constraints\n                    let y = &mut x;\n                    &mut x; //[ast]~ ERROR cannot borrow `**x` as mutable more than once at a time\n                    //[mir]~^ ERROR cannot borrow `x` as mutable more than once at a time"}, {"sha": "2200c1569e5728c388c4d3c1c60b093ac3e7f846", "filename": "src/test/compile-fail/mir_check_cast_closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_closure.rs?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -14,7 +14,7 @@\n \n fn bar<'a, 'b>() -> fn(&'a u32, &'b u32) -> &'a u32 {\n     let g: fn(_, _) -> _ = |_x, y| y;\n-    //~^ ERROR free region `'b` does not outlive free region `'a`\n+    //~^ ERROR unsatisfied lifetime constraints\n     g\n     //~^ WARNING not reporting region error due to nll\n }"}, {"sha": "f85104dff867f6402898941a06469070147173a8", "filename": "src/test/compile-fail/mir_check_cast_reify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_reify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_reify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_reify.rs?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -45,7 +45,7 @@ fn bar<'a>(x: &'a u32) -> &'static u32 {\n     // as part of checking the `ReifyFnPointer`.\n     let f: fn(_) -> _ = foo;\n     //~^ WARNING not reporting region error due to nll\n-    //~| ERROR free region `'a` does not outlive free region `'static`\n+    //~| ERROR unsatisfied lifetime constraints\n     f(x)\n }\n "}, {"sha": "e90242f3f87dac42d7bc4b9d8db330cb4995565f", "filename": "src/test/compile-fail/mir_check_cast_unsafe_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_unsafe_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_unsafe_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_unsafe_fn.rs?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -17,7 +17,7 @@ fn bar<'a>(input: &'a u32, f: fn(&'a u32) -> &'a u32) -> &'static u32 {\n     // in `g`. These are related via the `UnsafeFnPointer` cast.\n     let g: unsafe fn(_) -> _ = f;\n     //~^ WARNING not reporting region error due to nll\n-    //~| ERROR free region `'a` does not outlive free region `'static`\n+    //~| ERROR unsatisfied lifetime constraints\n     unsafe { g(input) }\n }\n "}, {"sha": "d242186a6f7ea6983efbdde21cb04db7ec480ee5", "filename": "src/test/compile-fail/mir_check_cast_unsize.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_unsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_unsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_unsize.rs?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -15,8 +15,7 @@\n use std::fmt::Debug;\n \n fn bar<'a>(x: &'a u32) -> &'static dyn Debug {\n-    //~^ ERROR free region `'a` does not outlive free region `'static`\n-    x\n+    x //~ ERROR unsatisfied lifetime constraints\n     //~^ WARNING not reporting region error due to nll\n }\n "}, {"sha": "0a37df4f0c788d11bc04249a830ed71bb96af32c", "filename": "src/test/compile-fail/regions-static-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fcompile-fail%2Fregions-static-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fcompile-fail%2Fregions-static-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-static-bound.rs?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -18,7 +18,7 @@ fn static_id_indirect<'a,'b>(t: &'a ()) -> &'static ()\n fn static_id_wrong_way<'a>(t: &'a ()) -> &'static () where 'static: 'a {\n     t //[ll]~ ERROR E0312\n         //[nll]~^ WARNING not reporting region error due to nll\n-        //[nll]~| ERROR free region `'a` does not outlive free region `'static`\n+        //[nll]~| ERROR unsatisfied lifetime constraints\n }\n \n fn error(u: &(), v: &()) {"}, {"sha": "68a039262c129310dba029023d6ee39b3cf5844e", "filename": "src/test/ui/borrowck/issue-45983.nll.stderr", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fborrowck%2Fissue-45983.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fborrowck%2Fissue-45983.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-45983.nll.stderr?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -4,11 +4,15 @@ warning: not reporting region error due to nll\n LL |     give_any(|y| x = Some(y));\n    |                           ^\n \n-error: free region `` does not outlive free region `'_#2r`\n-  --> $DIR/issue-45983.rs:17:27\n+error: unsatisfied lifetime constraints\n+  --> $DIR/issue-45983.rs:17:18\n    |\n+LL |     let x = None;\n+   |         - lifetime `'2` appears in the type of `x`\n LL |     give_any(|y| x = Some(y));\n-   |                           ^\n+   |               -  ^^^^^^^^^^^ free region requires that `'1` must outlive `'2`\n+   |               |\n+   |               lifetime `'1` appears in this argument\n \n error[E0594]: cannot assign to immutable item `x`\n   --> $DIR/issue-45983.rs:17:18"}, {"sha": "daa0a320b88d6cc8b69f04a58c12f1357ca61635", "filename": "src/test/ui/borrowck/issue-7573.nll.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fborrowck%2Fissue-7573.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fborrowck%2Fissue-7573.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-7573.nll.stderr?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -4,11 +4,17 @@ warning: not reporting region error due to nll\n LL |     let mut lines_to_use: Vec<&CrateId> = Vec::new();\n    |                               ^\n \n-error: free region `` does not outlive free region `'_#2r`\n+error: unsatisfied lifetime constraints\n   --> $DIR/issue-7573.rs:32:9\n    |\n+LL |     let mut lines_to_use: Vec<&CrateId> = Vec::new();\n+   |         ---------------- lifetime `'2` appears in the type of `lines_to_use`\n+LL |         //~^ NOTE cannot infer an appropriate lifetime\n+LL |     let push_id = |installed_id: &CrateId| {\n+   |                    ------------ lifetime `'1` appears in this argument\n+...\n LL |         lines_to_use.push(installed_id);\n-   |         ^^^^^^^^^^^^\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'1` must outlive `'2`\n \n error: aborting due to previous error\n "}, {"sha": "4f7843b72489c9524f7a9178c0e6917c7a5d833b", "filename": "src/test/ui/borrowck/regions-escape-bound-fn-2.nll.stderr", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-bound-fn-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-bound-fn-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-bound-fn-2.nll.stderr?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -4,11 +4,15 @@ warning: not reporting region error due to nll\n LL |     with_int(|y| x = Some(y));\n    |                           ^\n \n-error: free region `` does not outlive free region `'_#2r`\n-  --> $DIR/regions-escape-bound-fn-2.rs:18:27\n+error: unsatisfied lifetime constraints\n+  --> $DIR/regions-escape-bound-fn-2.rs:18:18\n    |\n+LL |     let mut x = None;\n+   |         ----- lifetime `'2` appears in the type of `x`\n LL |     with_int(|y| x = Some(y));\n-   |                           ^\n+   |               -  ^^^^^^^^^^^ free region requires that `'1` must outlive `'2`\n+   |               |\n+   |               lifetime `'1` appears in this argument\n \n error: aborting due to previous error\n "}, {"sha": "9b107ae08b477ef2040d040dbcb5cd92da96ea7b", "filename": "src/test/ui/borrowck/regions-escape-bound-fn.nll.stderr", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-bound-fn.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-bound-fn.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-bound-fn.nll.stderr?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -4,11 +4,15 @@ warning: not reporting region error due to nll\n LL |     with_int(|y| x = Some(y));\n    |                      ^^^^^^^\n \n-error: free region `` does not outlive free region `'_#2r`\n-  --> $DIR/regions-escape-bound-fn.rs:18:27\n+error: unsatisfied lifetime constraints\n+  --> $DIR/regions-escape-bound-fn.rs:18:18\n    |\n+LL |     let mut x: Option<&isize> = None;\n+   |         ----- lifetime `'2` appears in the type of `x`\n LL |     with_int(|y| x = Some(y));\n-   |                           ^\n+   |               -  ^^^^^^^^^^^ free region requires that `'1` must outlive `'2`\n+   |               |\n+   |               lifetime `'1` appears in this argument\n \n error: aborting due to previous error\n "}, {"sha": "8095330154d4c87ad819935c9444b487015d1387", "filename": "src/test/ui/borrowck/regions-escape-unboxed-closure.nll.stderr", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-unboxed-closure.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-unboxed-closure.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-unboxed-closure.nll.stderr?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -4,11 +4,15 @@ warning: not reporting region error due to nll\n LL |     with_int(&mut |y| x = Some(y));\n    |                           ^^^^^^^\n \n-error: free region `` does not outlive free region `'_#2r`\n-  --> $DIR/regions-escape-unboxed-closure.rs:16:32\n+error: unsatisfied lifetime constraints\n+  --> $DIR/regions-escape-unboxed-closure.rs:16:23\n    |\n+LL |     let mut x: Option<&isize> = None;\n+   |         ----- lifetime `'2` appears in the type of `x`\n LL |     with_int(&mut |y| x = Some(y));\n-   |                                ^\n+   |                    -  ^^^^^^^^^^^ free region requires that `'1` must outlive `'2`\n+   |                    |\n+   |                    lifetime `'1` appears in this argument\n \n error: aborting due to previous error\n "}, {"sha": "5487d34813b47a36a5f0b21bc2c28da537575086", "filename": "src/test/ui/closure-expected-type/expect-region-supply-region.nll.stderr", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-region-supply-region.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-region-supply-region.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-region-supply-region.nll.stderr?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -22,23 +22,37 @@ warning: not reporting region error due to nll\n LL |         f = Some(x);\n    |             ^^^^^^^\n \n-error: free region `` does not outlive free region `'_#2r`\n-  --> $DIR/expect-region-supply-region.rs:28:18\n+error: unsatisfied lifetime constraints\n+  --> $DIR/expect-region-supply-region.rs:28:9\n    |\n+LL |     let mut f: Option<&u32> = None;\n+   |         ----- lifetime `'2` appears in the type of `f`\n+LL |     closure_expecting_bound(|x| {\n+   |                              - lifetime `'1` appears in this argument\n LL |         f = Some(x); //~ ERROR borrowed data cannot be stored outside of its closure\n-   |                  ^\n+   |         ^^^^^^^^^^^ free region requires that `'1` must outlive `'2`\n \n-error: free region `` does not outlive free region `'_#2r`\n-  --> $DIR/expect-region-supply-region.rs:38:18\n+error: unsatisfied lifetime constraints\n+  --> $DIR/expect-region-supply-region.rs:38:9\n    |\n+LL |     let mut f: Option<&u32> = None;\n+   |         ----- lifetime `'2` appears in the type of `f`\n+LL |     closure_expecting_bound(|x: &u32| {\n+   |                              - lifetime `'1` appears in this argument\n LL |         f = Some(x); //~ ERROR borrowed data cannot be stored outside of its closure\n-   |                  ^\n+   |         ^^^^^^^^^^^ free region requires that `'1` must outlive `'2`\n \n-error: free region `` does not outlive free region `'_#2r`\n-  --> $DIR/expect-region-supply-region.rs:52:18\n+error: unsatisfied lifetime constraints\n+  --> $DIR/expect-region-supply-region.rs:52:9\n    |\n+LL |     let mut f: Option<&u32> = None;\n+   |         ----- lifetime `'2` appears in the type of `f`\n+...\n+LL |     closure_expecting_bound(|x: &'x u32| {\n+   |                              - lifetime `'1` appears in this argument\n+...\n LL |         f = Some(x);\n-   |                  ^\n+   |         ^^^^^^^^^^^ free region requires that `'1` must outlive `'2`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "9c7e3db67a611a55676afa41b85e1ec1671e59ca", "filename": "src/test/ui/error-codes/E0621-does-not-trigger-for-closures.nll.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Ferror-codes%2FE0621-does-not-trigger-for-closures.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Ferror-codes%2FE0621-does-not-trigger-for-closures.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0621-does-not-trigger-for-closures.nll.stderr?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -4,11 +4,15 @@ warning: not reporting region error due to nll\n LL |     invoke(&x, |a, b| if a > b { a } else { b }); //~ ERROR E0495\n    |     ^^^^^^\n \n-error: free region `` does not outlive free region `'_#2r`\n+error: unsatisfied lifetime constraints\n   --> $DIR/E0621-does-not-trigger-for-closures.rs:25:26\n    |\n LL |     invoke(&x, |a, b| if a > b { a } else { b }); //~ ERROR E0495\n-   |                          ^^^^^\n+   |                ----------^^^^^-----------------\n+   |                |   |     |\n+   |                |   |     free region requires that `'1` must outlive `'2`\n+   |                |   lifetime `'1` appears in this argument\n+   |                lifetime `'2` appears in return type\n \n error: aborting due to previous error\n "}, {"sha": "9aad7efdee5b277ae8c26490f2e691ab60a293a8", "filename": "src/test/ui/impl-trait/static-return-lifetime-infered.nll.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.nll.stderr?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -10,17 +10,19 @@ warning: not reporting region error due to nll\n LL |         self.x.iter().map(|a| a.0)\n    |                ^^^^\n \n-error: free region `` does not outlive free region `'static`\n+error: unsatisfied lifetime constraints\n   --> $DIR/static-return-lifetime-infered.rs:17:9\n    |\n+LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n+   |                         ----- lifetime `'1` appears in this argument\n LL |         self.x.iter().map(|a| a.0)\n-   |         ^^^^^^^^^^^^^\n+   |         ^^^^^^ cast requires that `'1` must outlive `'static`\n \n-error: free region `'a` does not outlive free region `'static`\n+error: unsatisfied lifetime constraints\n   --> $DIR/static-return-lifetime-infered.rs:21:9\n    |\n LL |         self.x.iter().map(|a| a.0)\n-   |         ^^^^^^^^^^^^^\n+   |         ^^^^^^ cast requires that `'a` must outlive `'static`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "19e10ba6da8b99ec52b83297ab71d9998dff3dd2", "filename": "src/test/ui/in-band-lifetimes/impl/dyn-trait.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fimpl%2Fdyn-trait.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fimpl%2Fdyn-trait.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fimpl%2Fdyn-trait.nll.stderr?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -4,11 +4,11 @@ warning: not reporting region error due to nll\n LL |     static_val(x); //~ ERROR cannot infer\n    |                ^\n \n-error: free region `'a` does not outlive free region `'static`\n+error: unsatisfied lifetime constraints\n   --> $DIR/dyn-trait.rs:32:5\n    |\n LL |     static_val(x); //~ ERROR cannot infer\n-   |     ^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^ argument requires that `'a` must outlive `'static`\n \n error: aborting due to previous error\n "}, {"sha": "78208d6d7db7d0c0f7df7bab15af4735dd88333f", "filename": "src/test/ui/nll/closure-requirements/escape-argument-callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.rs?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -34,7 +34,7 @@ fn test() {\n     {\n         let y = 22;\n         let mut closure = expect_sig(|p, y| *p = y);\n-        //~^ ERROR does not outlive free region\n+        //~^ ERROR\n         //~| WARNING not reporting region error due to nll\n         closure(&mut p, &y);\n     }"}, {"sha": "d6f542183603ec522f9cce71ea9312659b47a7c9", "filename": "src/test/ui/nll/closure-requirements/escape-argument-callee.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.stderr?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -4,11 +4,14 @@ warning: not reporting region error due to nll\n LL |         let mut closure = expect_sig(|p, y| *p = y);\n    |                                                  ^\n \n-error: free region `ReFree(DefId(0/1:9 ~ escape_argument_callee[317d]::test[0]::{{closure}}[0]), BrAnon(3))` does not outlive free region `ReFree(DefId(0/1:9 ~ escape_argument_callee[317d]::test[0]::{{closure}}[0]), BrAnon(2))`\n+error: unsatisfied lifetime constraints\n   --> $DIR/escape-argument-callee.rs:36:45\n    |\n LL |         let mut closure = expect_sig(|p, y| *p = y);\n-   |                                             ^^^^^^\n+   |                                       -  -  ^^^^^^ free region requires that `'1` must outlive `'2`\n+   |                                       |  |\n+   |                                       |  lifetime `'1` appears in this argument\n+   |                                       lifetime `'2` appears in this argument\n \n note: No external requirements\n   --> $DIR/escape-argument-callee.rs:36:38"}, {"sha": "b879f9a33986d0b8c184a73f28d9378f38fa3aaa", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-fail-no-postdom.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.rs?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -54,8 +54,7 @@ fn supply<'a, 'b, 'c>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>, cell_c: Cell\n             // Only works if 'x: 'y:\n             let p = x.get();\n             //~^ WARN not reporting region error due to nll\n-            //~| ERROR does not outlive free region\n-            demand_y(x, y, p)\n+            demand_y(x, y, p) //~ ERROR\n         },\n     );\n }"}, {"sha": "a7a50a3a029817e099b4a2433a4ac47608c4f135", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-fail-no-postdom.stderr", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -4,11 +4,16 @@ warning: not reporting region error due to nll\n LL |             let p = x.get();\n    |                     ^^^^^^^\n \n-error: free region `ReFree(DefId(0/1:20 ~ propagate_approximated_fail_no_postdom[317d]::supply[0]::{{closure}}[0]), BrAnon(1))` does not outlive free region `ReFree(DefId(0/1:20 ~ propagate_approximated_fail_no_postdom[317d]::supply[0]::{{closure}}[0]), BrAnon(2))`\n-  --> $DIR/propagate-approximated-fail-no-postdom.rs:55:17\n+error: unsatisfied lifetime constraints\n+  --> $DIR/propagate-approximated-fail-no-postdom.rs:57:13\n    |\n-LL |             let p = x.get();\n-   |                 ^\n+LL |         |_outlives1, _outlives2, _outlives3, x, y| {\n+   |          ----------              ---------- lifetime `'2` appears in this argument\n+   |          |\n+   |          lifetime `'1` appears in this argument\n+...\n+LL |             demand_y(x, y, p) //~ ERROR\n+   |             ^^^^^^^^^^^^^^^^^ argument requires that `'1` must outlive `'2`\n \n note: No external requirements\n   --> $DIR/propagate-approximated-fail-no-postdom.rs:53:9\n@@ -17,8 +22,7 @@ LL | /         |_outlives1, _outlives2, _outlives3, x, y| {\n LL | |             // Only works if 'x: 'y:\n LL | |             let p = x.get();\n LL | |             //~^ WARN not reporting region error due to nll\n-LL | |             //~| ERROR does not outlive free region\n-LL | |             demand_y(x, y, p)\n+LL | |             demand_y(x, y, p) //~ ERROR\n LL | |         },\n    | |_________^\n    |"}, {"sha": "a8ab41cebacced2fd79e17c78990ff081618567a", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-comparing-against-free.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.rs?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -31,7 +31,7 @@ fn case1() {\n     foo(cell, |cell_a, cell_x| {\n         //~^ WARNING not reporting region error due to nll\n         cell_a.set(cell_x.get()); // forces 'x: 'a, error in closure\n-        //~^ ERROR argument requires that data must outlive free region\n+        //~^ ERROR\n     })\n }\n "}, {"sha": "96f3d6a6a533ab69ce8cde1c86487c072ed76632", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-comparing-against-free.stderr", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -4,11 +4,16 @@ warning: not reporting region error due to nll\n LL |     foo(cell, |cell_a, cell_x| {\n    |     ^^^\n \n-error: argument requires that data must outlive free region `'_#1r`\n-  --> $DIR/propagate-approximated-shorter-to-static-comparing-against-free.rs:33:20\n+error: unsatisfied lifetime constraints\n+  --> $DIR/propagate-approximated-shorter-to-static-comparing-against-free.rs:33:9\n    |\n+LL |     foo(cell, |cell_a, cell_x| {\n+   |                ------  ------ lifetime `'1` appears in this argument\n+   |                |\n+   |                lifetime `'2` appears in this argument\n+LL |         //~^ WARNING not reporting region error due to nll\n LL |         cell_a.set(cell_x.get()); // forces 'x: 'a, error in closure\n-   |                    ^^^^^^^^^^^^\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'1` must outlive `'2`\n \n note: No external requirements\n   --> $DIR/propagate-approximated-shorter-to-static-comparing-against-free.rs:31:15\n@@ -17,7 +22,7 @@ LL |       foo(cell, |cell_a, cell_x| {\n    |  _______________^\n LL | |         //~^ WARNING not reporting region error due to nll\n LL | |         cell_a.set(cell_x.get()); // forces 'x: 'a, error in closure\n-LL | |         //~^ ERROR argument requires that data must outlive free region\n+LL | |         //~^ ERROR\n LL | |     })\n    | |_____^\n    |"}, {"sha": "26faccdde71aee990210966ee6eba507cc3dcb5c", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-no-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.rs?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -43,7 +43,7 @@ fn demand_y<'x, 'y>(_cell_x: &Cell<&'x u32>, _cell_y: &Cell<&'y u32>, _y: &'y u3\n #[rustc_regions]\n fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n     establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n-        //~^ ERROR argument requires that data must outlive free region\n+        //~^ ERROR\n \n         // Only works if 'x: 'y:\n         demand_y(x, y, x.get()) //~ WARNING not reporting region error due to nll"}, {"sha": "f65e7161ca8c5e058654246bd5371a56c6d04097", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-no-bound.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -9,7 +9,7 @@ note: External requirements\n    |\n LL |       establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n    |  _______________________________________________^\n-LL | |         //~^ ERROR argument requires that data must outlive free region\n+LL | |         //~^ ERROR\n LL | |\n LL | |         // Only works if 'x: 'y:\n LL | |         demand_y(x, y, x.get()) //~ WARNING not reporting region error due to nll\n@@ -23,23 +23,23 @@ LL | |     });\n    = note: number of external vids: 2\n    = note: where '_#1r: '_#0r\n \n-error: argument requires that data must outlive free region `ReStatic`\n+error: unsatisfied lifetime constraints\n   --> $DIR/propagate-approximated-shorter-to-static-no-bound.rs:45:5\n    |\n LL | /     establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n-LL | |         //~^ ERROR argument requires that data must outlive free region\n+LL | |         //~^ ERROR\n LL | |\n LL | |         // Only works if 'x: 'y:\n LL | |         demand_y(x, y, x.get()) //~ WARNING not reporting region error due to nll\n LL | |     });\n-   | |______^\n+   | |______^ argument requires that `'a` must outlive `'static`\n \n note: No external requirements\n   --> $DIR/propagate-approximated-shorter-to-static-no-bound.rs:44:1\n    |\n LL | / fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n LL | |     establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n-LL | |         //~^ ERROR argument requires that data must outlive free region\n+LL | |         //~^ ERROR\n LL | |\n ...  |\n LL | |     });"}, {"sha": "703d60371cdfc43f74cd8aab05859b243a6e9c2e", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-wrong-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.rs?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -46,7 +46,7 @@ fn demand_y<'x, 'y>(_cell_x: &Cell<&'x u32>, _cell_y: &Cell<&'y u32>, _y: &'y u3\n #[rustc_regions]\n fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n     establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n-        //~^ ERROR argument requires that data must outlive free region\n+        //~^ ERROR\n         // Only works if 'x: 'y:\n         demand_y(x, y, x.get())\n         //~^ WARNING not reporting region error due to nll"}, {"sha": "f1b2c9f198d69d4474e2d29d4fb0e2eee48748da", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-wrong-bound.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -9,7 +9,7 @@ note: External requirements\n    |\n LL |       establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n    |  _______________________________________________^\n-LL | |         //~^ ERROR argument requires that data must outlive free region\n+LL | |         //~^ ERROR\n LL | |         // Only works if 'x: 'y:\n LL | |         demand_y(x, y, x.get())\n LL | |         //~^ WARNING not reporting region error due to nll\n@@ -23,23 +23,23 @@ LL | |     });\n    = note: number of external vids: 3\n    = note: where '_#1r: '_#0r\n \n-error: argument requires that data must outlive free region `ReStatic`\n+error: unsatisfied lifetime constraints\n   --> $DIR/propagate-approximated-shorter-to-static-wrong-bound.rs:48:5\n    |\n LL | /     establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n-LL | |         //~^ ERROR argument requires that data must outlive free region\n+LL | |         //~^ ERROR\n LL | |         // Only works if 'x: 'y:\n LL | |         demand_y(x, y, x.get())\n LL | |         //~^ WARNING not reporting region error due to nll\n LL | |     });\n-   | |______^\n+   | |______^ argument requires that `'a` must outlive `'static`\n \n note: No external requirements\n   --> $DIR/propagate-approximated-shorter-to-static-wrong-bound.rs:47:1\n    |\n LL | / fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n LL | |     establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n-LL | |         //~^ ERROR argument requires that data must outlive free region\n+LL | |         //~^ ERROR\n LL | |         // Only works if 'x: 'y:\n ...  |\n LL | |     });"}, {"sha": "4b1f5231b3e878bb4f49510a2352ff24873c89c1", "filename": "src/test/ui/nll/closure-requirements/propagate-fail-to-approximate-longer-no-bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.rs?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -46,7 +46,7 @@ fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n         // Only works if 'x: 'y:\n         demand_y(x, y, x.get())\n         //~^ WARN not reporting region error due to nll\n-        //~| ERROR argument requires that data must outlive free region\n+        //~| ERROR\n     });\n }\n "}, {"sha": "fb98c506c7d280a913b785441d731b06f4f7c1d7", "filename": "src/test/ui/nll/closure-requirements/propagate-fail-to-approximate-longer-no-bounds.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -4,11 +4,16 @@ warning: not reporting region error due to nll\n LL |         demand_y(x, y, x.get())\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: argument requires that data must outlive free region `ReFree(DefId(0/1:18 ~ propagate_fail_to_approximate_longer_no_bounds[317d]::supply[0]::{{closure}}[0]), BrAnon(2))`\n+error: unsatisfied lifetime constraints\n   --> $DIR/propagate-fail-to-approximate-longer-no-bounds.rs:47:9\n    |\n+LL |     establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n+   |                                                ---------  - lifetime `'1` appears in this argument\n+   |                                                |\n+   |                                                lifetime `'2` appears in this argument\n+LL |         // Only works if 'x: 'y:\n LL |         demand_y(x, y, x.get())\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'1` must outlive `'2`\n \n note: No external requirements\n   --> $DIR/propagate-fail-to-approximate-longer-no-bounds.rs:45:47\n@@ -18,7 +23,7 @@ LL |       establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n LL | |         // Only works if 'x: 'y:\n LL | |         demand_y(x, y, x.get())\n LL | |         //~^ WARN not reporting region error due to nll\n-LL | |         //~| ERROR argument requires that data must outlive free region\n+LL | |         //~| ERROR\n LL | |     });\n    | |_____^\n    |"}, {"sha": "62a20c1bfe76ef5893aed0c59338b6e420375fdf", "filename": "src/test/ui/nll/closure-requirements/propagate-fail-to-approximate-longer-wrong-bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.rs?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -50,7 +50,7 @@ fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n         // Only works if 'x: 'y:\n         demand_y(x, y, x.get())\n         //~^ WARN not reporting region error due to nll\n-        //~| ERROR does not outlive free region\n+        //~| ERROR\n     });\n }\n "}, {"sha": "73d39a8502b6438060cf366c70aad478c2dd4daa", "filename": "src/test/ui/nll/closure-requirements/propagate-fail-to-approximate-longer-wrong-bounds.stderr", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -4,11 +4,16 @@ warning: not reporting region error due to nll\n LL |         demand_y(x, y, x.get())\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: free region `ReFree(DefId(0/1:18 ~ propagate_fail_to_approximate_longer_wrong_bounds[317d]::supply[0]::{{closure}}[0]), BrAnon(2))` does not outlive free region `ReFree(DefId(0/1:18 ~ propagate_fail_to_approximate_longer_wrong_bounds[317d]::supply[0]::{{closure}}[0]), BrAnon(4))`\n-  --> $DIR/propagate-fail-to-approximate-longer-wrong-bounds.rs:51:18\n+error: unsatisfied lifetime constraints\n+  --> $DIR/propagate-fail-to-approximate-longer-wrong-bounds.rs:51:9\n    |\n+LL |     establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n+   |                                                ----------  ---------- lifetime `'2` appears in this argument\n+   |                                                |\n+   |                                                lifetime `'1` appears in this argument\n+LL |         // Only works if 'x: 'y:\n LL |         demand_y(x, y, x.get())\n-   |                  ^\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'1` must outlive `'2`\n \n note: No external requirements\n   --> $DIR/propagate-fail-to-approximate-longer-wrong-bounds.rs:49:47\n@@ -18,7 +23,7 @@ LL |       establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x,\n LL | |         // Only works if 'x: 'y:\n LL | |         demand_y(x, y, x.get())\n LL | |         //~^ WARN not reporting region error due to nll\n-LL | |         //~| ERROR does not outlive free region\n+LL | |         //~| ERROR\n LL | |     });\n    | |_____^\n    |"}, {"sha": "b5e8c95bc13b7c0601021185f6da26584222ee29", "filename": "src/test/ui/nll/closure-requirements/region-lbr-named-does-not-outlive-static.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-named-does-not-outlive-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-named-does-not-outlive-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-named-does-not-outlive-static.rs?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -18,7 +18,7 @@\n fn foo<'a>(x: &'a u32) -> &'static u32 {\n     &*x\n         //~^ WARN not reporting region error due to nll\n-        //~| ERROR does not outlive free region\n+        //~| ERROR\n }\n \n fn main() { }"}, {"sha": "d012dca25271c62af9e2a6ccd4fbfac91dd8bf9a", "filename": "src/test/ui/nll/closure-requirements/region-lbr-named-does-not-outlive-static.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-named-does-not-outlive-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-named-does-not-outlive-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fregion-lbr-named-does-not-outlive-static.stderr?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -4,11 +4,11 @@ warning: not reporting region error due to nll\n LL |     &*x\n    |     ^^^\n \n-error: free region `ReFree(DefId(0/0:3 ~ region_lbr_named_does_not_outlive_static[317d]::foo[0]), BrNamed(crate0:DefIndex(1:9), 'a))` does not outlive free region `ReStatic`\n+error: unsatisfied lifetime constraints\n   --> $DIR/region-lbr-named-does-not-outlive-static.rs:19:5\n    |\n LL |     &*x\n-   |     ^^^\n+   |     ^^^ free region requires that `'a` must outlive `'static`\n \n error: aborting due to previous error\n "}, {"sha": "d88729d04d95bb733c777a33d89af9b8fdc52607", "filename": "src/test/ui/nll/closure-requirements/return-wrong-bound-region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.rs?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -20,7 +20,7 @@\n fn test() {\n     expect_sig(|a, b| b); // ought to return `a`\n     //~^ WARN not reporting region error due to nll\n-    //~| ERROR does not outlive free region\n+    //~| ERROR\n }\n \n fn expect_sig<F>(f: F) -> F"}, {"sha": "5724cdbd8c95be1fb5f557863315c69626baacdf", "filename": "src/test/ui/nll/closure-requirements/return-wrong-bound-region.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.stderr?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -4,11 +4,14 @@ warning: not reporting region error due to nll\n LL |     expect_sig(|a, b| b); // ought to return `a`\n    |                       ^\n \n-error: free region `ReFree(DefId(0/1:9 ~ return_wrong_bound_region[317d]::test[0]::{{closure}}[0]), BrAnon(2))` does not outlive free region `ReFree(DefId(0/1:9 ~ return_wrong_bound_region[317d]::test[0]::{{closure}}[0]), BrAnon(1))`\n+error: unsatisfied lifetime constraints\n   --> $DIR/return-wrong-bound-region.rs:21:23\n    |\n LL |     expect_sig(|a, b| b); // ought to return `a`\n-   |                       ^\n+   |                 -  -  ^ free region requires that `'1` must outlive `'2`\n+   |                 |  |\n+   |                 |  lifetime `'1` appears in this argument\n+   |                 lifetime `'2` appears in this argument\n \n note: No external requirements\n   --> $DIR/return-wrong-bound-region.rs:21:16\n@@ -27,7 +30,7 @@ note: No external requirements\n LL | / fn test() {\n LL | |     expect_sig(|a, b| b); // ought to return `a`\n LL | |     //~^ WARN not reporting region error due to nll\n-LL | |     //~| ERROR does not outlive free region\n+LL | |     //~| ERROR\n LL | | }\n    | |_^\n    |"}, {"sha": "7c5527ae1e7b1fa15b5a7287c958740fef8bbd3f", "filename": "src/test/ui/nll/issue-48238.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fissue-48238.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fissue-48238.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-48238.rs?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -18,5 +18,5 @@ fn use_val<'a>(val: &'a u8) -> &'a u8 {\n \n fn main() {\n     let orig: u8 = 5;\n-    move || use_val(&orig); //~ ERROR free region `` does not outlive free region `'_#1r`\n+    move || use_val(&orig); //~ ERROR\n }"}, {"sha": "7bdac345e9047a881e2c7555d0067b4131bfa34e", "filename": "src/test/ui/nll/issue-48238.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fissue-48238.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fissue-48238.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-48238.stderr?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -1,8 +1,12 @@\n-error: free region `` does not outlive free region `'_#1r`\n-  --> $DIR/issue-48238.rs:21:21\n+error: unsatisfied lifetime constraints\n+  --> $DIR/issue-48238.rs:21:13\n    |\n-LL |     move || use_val(&orig); //~ ERROR free region `` does not outlive free region `'_#1r`\n-   |                     ^^^^^\n+LL |     move || use_val(&orig); //~ ERROR\n+   |     --------^^^^^^^^^^^^^^\n+   |     |       |\n+   |     |       argument requires that `'1` must outlive `'2`\n+   |     lifetime `'1` represents the closure body\n+   |     lifetime `'2` appears in return type\n \n error: aborting due to previous error\n "}, {"sha": "beb2ff79e902b474179806c25ea2ac70fc30ae8f", "filename": "src/test/ui/nll/issue-50716.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fissue-50716.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fissue-50716.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-50716.rs?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -22,7 +22,7 @@ where\n     for<'b> &'b T: A,\n     <&'static T as A>::X: Sized\n {\n-    let _x = *s; //~ ERROR assignment requires that data must outlive free region `'static`\n+    let _x = *s; //~ ERROR\n }\n \n fn main() {}"}, {"sha": "48862166f897f6507e7af8ba33814339002d15c0", "filename": "src/test/ui/nll/issue-50716.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fissue-50716.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fissue-50716.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-50716.stderr?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -1,8 +1,8 @@\n-error: assignment requires that data must outlive free region `'static`\n+error: unsatisfied lifetime constraints\n   --> $DIR/issue-50716.rs:25:14\n    |\n-LL |     let _x = *s; //~ ERROR assignment requires that data must outlive free region `'static`\n-   |              ^^\n+LL |     let _x = *s; //~ ERROR\n+   |              ^^ assignment requires that `'a` must outlive `'static`\n \n error: aborting due to previous error\n "}, {"sha": "0a8801a3c4d6d1ad9c3098d700563059f4ff558a", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.rs?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -55,7 +55,7 @@ where\n     with_signature(cell, t, |cell, t| require(cell, t));\n     //~^ WARNING not reporting region error due to nll\n     //~| ERROR the parameter type `T` may not live long enough\n-    //~| ERROR argument requires that data must outlive free region\n+    //~| ERROR\n }\n \n #[rustc_regions]\n@@ -67,7 +67,7 @@ where\n     with_signature(cell, t, |cell, t| require(cell, t));\n     //~^ WARNING not reporting region error due to nll\n     //~| ERROR the parameter type `T` may not live long enough\n-    //~| ERROR argument requires that data must outlive free region\n+    //~| ERROR\n }\n \n #[rustc_regions]\n@@ -89,7 +89,7 @@ where\n     with_signature(cell, t, |cell, t| require(cell, t));\n     //~^ WARNING not reporting region error due to nll\n     //~| ERROR the parameter type `T` may not live long enough\n-    //~| ERROR argument requires that data must outlive free region\n+    //~| ERROR\n }\n \n #[rustc_regions]"}, {"sha": "b84ee4de5a3cc953b6c7b0ffaca387e99146b9d0", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-closure.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -40,11 +40,11 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    |\n    = help: consider adding an explicit lifetime bound `T: ReFree(DefId(0/0:8 ~ projection_one_region_closure[317d]::no_relationships_late[0]), BrNamed(crate0:DefIndex(1:16), 'a))`...\n \n-error: argument requires that data must outlive free region `ReFree(DefId(0/0:8 ~ projection_one_region_closure[317d]::no_relationships_late[0]), BrNamed(crate0:DefIndex(1:16), 'a))`\n+error: unsatisfied lifetime constraints\n   --> $DIR/projection-one-region-closure.rs:55:5\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'b` must outlive `'a`\n \n note: No external requirements\n   --> $DIR/projection-one-region-closure.rs:51:1\n@@ -54,7 +54,7 @@ LL | | where\n LL | |     T: Anything<'b>,\n LL | | {\n ...  |\n-LL | |     //~| ERROR argument requires that data must outlive free region\n+LL | |     //~| ERROR\n LL | | }\n    | |_^\n    |\n@@ -88,11 +88,11 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    |\n    = help: consider adding an explicit lifetime bound `T: ReEarlyBound(0, 'a)`...\n \n-error: argument requires that data must outlive free region `ReEarlyBound(0, 'a)`\n+error: unsatisfied lifetime constraints\n   --> $DIR/projection-one-region-closure.rs:67:5\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'b` must outlive `'a`\n \n note: No external requirements\n   --> $DIR/projection-one-region-closure.rs:62:1\n@@ -102,7 +102,7 @@ LL | | where\n LL | |     T: Anything<'b>,\n LL | |     'a: 'a,\n ...  |\n-LL | |     //~| ERROR argument requires that data must outlive free region\n+LL | |     //~| ERROR\n LL | | }\n    | |_^\n    |\n@@ -137,11 +137,11 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    |\n    = help: consider adding an explicit lifetime bound `T: ReEarlyBound(0, 'a)`...\n \n-error: argument requires that data must outlive free region `ReEarlyBound(0, 'a)`\n+error: unsatisfied lifetime constraints\n   --> $DIR/projection-one-region-closure.rs:89:5\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'b` must outlive `'a`\n \n note: No external requirements\n   --> $DIR/projection-one-region-closure.rs:74:1\n@@ -151,7 +151,7 @@ LL | | where\n LL | |     T: Anything<'b>,\n LL | |     T::AssocType: 'a,\n ...  |\n-LL | |     //~| ERROR argument requires that data must outlive free region\n+LL | |     //~| ERROR\n LL | | }\n    | |_^\n    |"}, {"sha": "6317d6eca1f1de29a400aa1e0dd17a5a00fe6b85", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-trait-bound-closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.rs?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -46,7 +46,7 @@ where\n {\n     with_signature(cell, t, |cell, t| require(cell, t));\n     //~^ WARNING not reporting region error due to nll\n-    //~| ERROR argument requires that data must outlive free region\n+    //~| ERROR\n }\n \n #[rustc_regions]\n@@ -57,7 +57,7 @@ where\n {\n     with_signature(cell, t, |cell, t| require(cell, t));\n     //~^ WARNING not reporting region error due to nll\n-    //~| ERROR argument requires that data must outlive free region\n+    //~| ERROR\n }\n \n #[rustc_regions]\n@@ -78,7 +78,7 @@ where\n \n     with_signature(cell, t, |cell, t| require(cell, t));\n     //~^ WARNING not reporting region error due to nll\n-    //~| ERROR argument requires that data must outlive free region\n+    //~| ERROR\n }\n \n #[rustc_regions]"}, {"sha": "42ecd6f986075130d1e6da857d4d502cd84b99ff", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-trait-bound-closure.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -31,11 +31,11 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: number of external vids: 3\n    = note: where '_#1r: '_#2r\n \n-error: argument requires that data must outlive free region `ReFree(DefId(0/0:8 ~ projection_one_region_trait_bound_closure[317d]::no_relationships_late[0]), BrNamed(crate0:DefIndex(1:16), 'a))`\n+error: unsatisfied lifetime constraints\n   --> $DIR/projection-one-region-trait-bound-closure.rs:47:5\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'b` must outlive `'a`\n \n note: No external requirements\n   --> $DIR/projection-one-region-trait-bound-closure.rs:43:1\n@@ -45,7 +45,7 @@ LL | | where\n LL | |     T: Anything<'b>,\n LL | | {\n ...  |\n-LL | |     //~| ERROR argument requires that data must outlive free region\n+LL | |     //~| ERROR\n LL | | }\n    | |_^\n    |\n@@ -70,11 +70,11 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: number of external vids: 4\n    = note: where '_#2r: '_#3r\n \n-error: argument requires that data must outlive free region `ReEarlyBound(0, 'a)`\n+error: unsatisfied lifetime constraints\n   --> $DIR/projection-one-region-trait-bound-closure.rs:58:5\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'b` must outlive `'a`\n \n note: No external requirements\n   --> $DIR/projection-one-region-trait-bound-closure.rs:53:1\n@@ -84,7 +84,7 @@ LL | | where\n LL | |     T: Anything<'b>,\n LL | |     'a: 'a,\n ...  |\n-LL | |     //~| ERROR argument requires that data must outlive free region\n+LL | |     //~| ERROR\n LL | | }\n    | |_^\n    |\n@@ -110,11 +110,11 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: number of external vids: 4\n    = note: where '_#2r: '_#3r\n \n-error: argument requires that data must outlive free region `ReEarlyBound(0, 'a)`\n+error: unsatisfied lifetime constraints\n   --> $DIR/projection-one-region-trait-bound-closure.rs:79:5\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'b` must outlive `'a`\n \n note: No external requirements\n   --> $DIR/projection-one-region-trait-bound-closure.rs:64:1\n@@ -124,7 +124,7 @@ LL | | where\n LL | |     T: Anything<'b>,\n LL | |     T::AssocType: 'a,\n ...  |\n-LL | |     //~| ERROR argument requires that data must outlive free region\n+LL | |     //~| ERROR\n LL | | }\n    | |_^\n    |"}, {"sha": "2552054fd5f423553516446fd04ae4f971f176c0", "filename": "src/test/ui/nll/ty-outlives/projection-two-region-trait-bound-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.rs?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -107,7 +107,7 @@ where\n {\n     with_signature(cell, t, |cell, t| require(cell, t));\n     //~^ WARNING not reporting region error due to nll\n-    //~| ERROR argument requires that data must outlive free region\n+    //~| ERROR\n }\n \n #[rustc_regions]"}, {"sha": "b0f823ad3d56b52500550c879b6219c433997943", "filename": "src/test/ui/nll/ty-outlives/projection-two-region-trait-bound-closure.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -239,11 +239,11 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: number of external vids: 3\n    = note: where <T as Anything<ReClosureBound('_#1r), ReClosureBound('_#1r)>>::AssocType: '_#2r\n \n-error: argument requires that data must outlive free region `ReFree(DefId(0/0:13 ~ projection_two_region_trait_bound_closure[317d]::two_regions[0]), BrNamed(crate0:DefIndex(1:43), 'a))`\n+error: unsatisfied lifetime constraints\n   --> $DIR/projection-two-region-trait-bound-closure.rs:108:5\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'b` must outlive `'a`\n \n note: No external requirements\n   --> $DIR/projection-two-region-trait-bound-closure.rs:104:1\n@@ -253,7 +253,7 @@ LL | | where\n LL | |     T: Anything<'b, 'b>,\n LL | | {\n ...  |\n-LL | |     //~| ERROR argument requires that data must outlive free region\n+LL | |     //~| ERROR\n LL | | }\n    | |_^\n    |"}, {"sha": "04c3ed2d6ee19ec71a299aab2e4c4005f584de84", "filename": "src/test/ui/underscore-lifetime/dyn-trait-underscore.nll.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a178cba9f1be1dc5f9da47a9ed5d291c19821aab/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.nll.stderr?ref=a178cba9f1be1dc5f9da47a9ed5d291c19821aab", "patch": "@@ -22,11 +22,14 @@ warning: not reporting region error due to nll\n LL |     Box::new(items.iter()) //~ ERROR cannot infer an appropriate lifetime\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n-error: cast requires that data must outlive free region `'static`\n+error: unsatisfied lifetime constraints\n   --> $DIR/dyn-trait-underscore.rs:18:5\n    |\n+LL | fn a<T>(items: &[T]) -> Box<dyn Iterator<Item=&T>> {\n+   |         ----- lifetime `'1` appears in this argument\n+LL |     //                      ^^^^^^^^^^^^^^^^^^^^^ bound *here* defaults to `'static`\n LL |     Box::new(items.iter()) //~ ERROR cannot infer an appropriate lifetime\n-   |     ^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^ cast requires that `'1` must outlive `'static`\n \n error: aborting due to previous error\n "}]}