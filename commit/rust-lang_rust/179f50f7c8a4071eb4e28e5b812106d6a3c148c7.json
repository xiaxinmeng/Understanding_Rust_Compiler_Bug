{"sha": "179f50f7c8a4071eb4e28e5b812106d6a3c148c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3OWY1MGY3YzhhNDA3MWViNGUyOGU1YjgxMjEwNmQ2YTNjMTQ4Yzc=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-09-26T21:38:26Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-10-16T03:10:11Z"}, "message": "path2: Rename pop_opt() to pop() and add each_parent()", "tree": {"sha": "818652d8fdaf1914148613b26a83f5562e50f1c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/818652d8fdaf1914148613b26a83f5562e50f1c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/179f50f7c8a4071eb4e28e5b812106d6a3c148c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/179f50f7c8a4071eb4e28e5b812106d6a3c148c7", "html_url": "https://github.com/rust-lang/rust/commit/179f50f7c8a4071eb4e28e5b812106d6a3c148c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/179f50f7c8a4071eb4e28e5b812106d6a3c148c7/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56b96a3bfcbb37856c333a0042c365c314a54e6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/56b96a3bfcbb37856c333a0042c365c314a54e6a", "html_url": "https://github.com/rust-lang/rust/commit/56b96a3bfcbb37856c333a0042c365c314a54e6a"}], "stats": {"total": 170, "additions": 152, "deletions": 18}, "files": [{"sha": "ba572cce78a6d068706cc7feee27a2d36e21ecd3", "filename": "src/libstd/path2/mod.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/179f50f7c8a4071eb4e28e5b812106d6a3c148c7/src%2Flibstd%2Fpath2%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/179f50f7c8a4071eb4e28e5b812106d6a3c148c7/src%2Flibstd%2Fpath2%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath2%2Fmod.rs?ref=179f50f7c8a4071eb4e28e5b812106d6a3c148c7", "patch": "@@ -540,13 +540,13 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     }\n     /// Pops the last path component off of `self` and returns it.\n     /// If `self` represents the root of the file hierarchy, None is returned.\n-    fn pop_opt(&mut self) -> Option<~[u8]>;\n+    fn pop(&mut self) -> Option<~[u8]>;\n     /// Pops the last path component off of `self` and returns it as a string, if possible.\n     /// `self` will still be modified even if None is returned.\n-    /// See `pop_opt` for details.\n+    /// See `pop` for details.\n     #[inline]\n-    fn pop_opt_str(&mut self) -> Option<~str> {\n-        self.pop_opt().and_then(|v| str::from_utf8_owned_opt(v))\n+    fn pop_str(&mut self) -> Option<~str> {\n+        self.pop().and_then(|v| str::from_utf8_owned_opt(v))\n     }\n \n     /// Returns a new Path constructed by joining `self` with the given path (as a byte vector).\n@@ -593,6 +593,21 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// If `self` is absolute and `base` is relative, or on Windows if both\n     /// paths refer to separate drives, an absolute path is returned.\n     fn path_relative_from(&self, base: &Self) -> Option<Self>;\n+\n+    /// Executes a callback with the receiver and every parent\n+    fn each_parent(&self, f: &fn(&Self) -> bool) -> bool {\n+        let mut p = self.clone();\n+        loop {\n+            if !f(&p) {\n+                return false;\n+            }\n+            let f = p.pop();\n+            if f.is_none() || bytes!(\"..\") == f.unwrap() {\n+                break;\n+            }\n+        }\n+        true\n+    }\n }\n \n /// A trait that represents the unsafe operations on GenericPaths"}, {"sha": "233458dfc9b12816a1ef9724e2f0602852f7ea74", "filename": "src/libstd/path2/posix.rs", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/179f50f7c8a4071eb4e28e5b812106d6a3c148c7/src%2Flibstd%2Fpath2%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/179f50f7c8a4071eb4e28e5b812106d6a3c148c7/src%2Flibstd%2Fpath2%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath2%2Fposix.rs?ref=179f50f7c8a4071eb4e28e5b812106d6a3c148c7", "patch": "@@ -196,7 +196,7 @@ impl GenericPath for Path {\n         }\n     }\n \n-    fn pop_opt(&mut self) -> Option<~[u8]> {\n+    fn pop(&mut self) -> Option<~[u8]> {\n         match self.sepidx {\n             None if bytes!(\".\") == self.repr => None,\n             None => {\n@@ -400,7 +400,7 @@ fn normalize_helper<'a>(v: &'a [u8], is_abs: bool) -> Option<~[&'a [u8]]> {\n         else if comp == bytes!(\"..\") {\n             if is_abs && comps.is_empty() { changed = true }\n             else if comps.len() == n_up { comps.push(dot_dot_static); n_up += 1 }\n-            else { comps.pop_opt(); changed = true }\n+            else { comps.pop(); changed = true }\n         } else { comps.push(comp) }\n     }\n     if changed {\n@@ -861,23 +861,23 @@ mod tests {\n             (s: $path:expr, $left:expr, $right:expr) => (\n                 {\n                     let mut p = Path::from_str($path);\n-                    let file = p.pop_opt_str();\n+                    let file = p.pop_str();\n                     assert_eq!(p.as_str(), Some($left));\n                     assert_eq!(file.map(|s| s.as_slice()), $right);\n                 }\n             );\n             (v: [$($path:expr),+], [$($left:expr),+], Some($($right:expr),+)) => (\n                 {\n                     let mut p = Path::from_vec(b!($($path),+));\n-                    let file = p.pop_opt();\n+                    let file = p.pop();\n                     assert_eq!(p.as_vec(), b!($($left),+));\n                     assert_eq!(file.map(|v| v.as_slice()), Some(b!($($right),+)));\n                 }\n             );\n             (v: [$($path:expr),+], [$($left:expr),+], None) => (\n                 {\n                     let mut p = Path::from_vec(b!($($path),+));\n-                    let file = p.pop_opt();\n+                    let file = p.pop();\n                     assert_eq!(p.as_vec(), b!($($left),+));\n                     assert_eq!(file, None);\n                 }\n@@ -899,8 +899,8 @@ mod tests {\n         t!(s: \"/a\", \"/\", Some(\"a\"));\n         t!(s: \"/\", \"/\", None);\n \n-        assert_eq!(Path::from_vec(b!(\"foo/bar\", 0x80)).pop_opt_str(), None);\n-        assert_eq!(Path::from_vec(b!(\"foo\", 0x80, \"/bar\")).pop_opt_str(), Some(~\"bar\"));\n+        assert_eq!(Path::from_vec(b!(\"foo/bar\", 0x80)).pop_str(), None);\n+        assert_eq!(Path::from_vec(b!(\"foo\", 0x80, \"/bar\")).pop_str(), Some(~\"bar\"));\n     }\n \n     #[test]\n@@ -1310,4 +1310,58 @@ mod tests {\n         t!(s: \"../..\", [\"..\", \"..\"]);\n         t!(s: \"../../foo\", [\"..\", \"..\", \"foo\"]);\n     }\n+\n+    #[test]\n+    fn test_each_parent() {\n+        assert!(Path::from_str(\"/foo/bar\").each_parent(|_| true));\n+        assert!(!Path::from_str(\"/foo/bar\").each_parent(|_| false));\n+\n+        macro_rules! t(\n+            (s: $path:expr, $exp:expr) => (\n+                {\n+                    let path = Path::from_str($path);\n+                    let exp: &[&str] = $exp;\n+                    let mut comps = exp.iter().map(|&x|x);\n+                    do path.each_parent |p| {\n+                        let p = p.as_str();\n+                        assert!(p.is_some());\n+                        let e = comps.next();\n+                        assert!(e.is_some());\n+                        assert_eq!(p.unwrap(), e.unwrap());\n+                        true\n+                    };\n+                    assert!(comps.next().is_none());\n+                }\n+            );\n+            (v: $path:expr, $exp:expr) => (\n+                {\n+                    let path = Path::from_vec($path);\n+                    let exp: &[&[u8]] = $exp;\n+                    let mut comps = exp.iter().map(|&x|x);\n+                    do path.each_parent |p| {\n+                        let p = p.as_vec();\n+                        let e = comps.next();\n+                        assert!(e.is_some());\n+                        assert_eq!(p, e.unwrap());\n+                        true\n+                    };\n+                    assert!(comps.next().is_none());\n+                }\n+            )\n+        )\n+\n+        t!(s: \"/foo/bar\", [\"/foo/bar\", \"/foo\", \"/\"]);\n+        t!(s: \"/foo/bar/baz\", [\"/foo/bar/baz\", \"/foo/bar\", \"/foo\", \"/\"]);\n+        t!(s: \"/foo\", [\"/foo\", \"/\"]);\n+        t!(s: \"/\", [\"/\"]);\n+        t!(s: \"foo/bar/baz\", [\"foo/bar/baz\", \"foo/bar\", \"foo\", \".\"]);\n+        t!(s: \"foo/bar\", [\"foo/bar\", \"foo\", \".\"]);\n+        t!(s: \"foo\", [\"foo\", \".\"]);\n+        t!(s: \".\", [\".\"]);\n+        t!(s: \"..\", [\"..\"]);\n+        t!(s: \"../../foo\", [\"../../foo\", \"../..\"]);\n+\n+        t!(v: b!(\"foo/bar\", 0x80), [b!(\"foo/bar\", 0x80), b!(\"foo\"), b!(\".\")]);\n+        t!(v: b!(0xff, \"/bar\"), [b!(0xff, \"/bar\"), b!(0xff), b!(\".\")]);\n+    }\n }"}, {"sha": "c23dc86d7dfb2eaaf47960c50e3d252775f1c06d", "filename": "src/libstd/path2/windows.rs", "status": "modified", "additions": 72, "deletions": 7, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/179f50f7c8a4071eb4e28e5b812106d6a3c148c7/src%2Flibstd%2Fpath2%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/179f50f7c8a4071eb4e28e5b812106d6a3c148c7/src%2Flibstd%2Fpath2%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath2%2Fwindows.rs?ref=179f50f7c8a4071eb4e28e5b812106d6a3c148c7", "patch": "@@ -446,11 +446,11 @@ impl GenericPath for Path {\n     }\n \n     #[inline]\n-    fn pop_opt(&mut self) -> Option<~[u8]> {\n-        self.pop_opt_str().map_move(|s| s.into_bytes())\n+    fn pop(&mut self) -> Option<~[u8]> {\n+        self.pop_str().map_move(|s| s.into_bytes())\n     }\n \n-    fn pop_opt_str(&mut self) -> Option<~str> {\n+    fn pop_str(&mut self) -> Option<~str> {\n         match self.sepidx_or_prefix_len() {\n             None if \".\" == self.repr => None,\n             None => {\n@@ -599,6 +599,21 @@ impl GenericPath for Path {\n             Some(Path::from_str(comps.connect(\"\\\\\")))\n         }\n     }\n+\n+    /// Executes a callback with the receiver and every parent\n+    fn each_parent(&self, f: &fn(&Path) -> bool) -> bool {\n+        let mut p = self.clone();\n+        loop {\n+            if !f(&p) {\n+                return false;\n+            }\n+            let f = p.pop();\n+            if f.is_none() || (!p.is_verbatim() && bytes!(\"..\") == f.unwrap()) {\n+                break;\n+            }\n+        }\n+        true\n+    }\n }\n \n impl Path {\n@@ -1013,7 +1028,7 @@ fn normalize_helper<'a>(s: &'a str, prefix: Option<PathPrefix>) -> (bool,Option<\n             };\n             if (is_abs || has_abs_prefix) && comps.is_empty() { changed = true }\n             else if comps.len() == n_up { comps.push(\"..\"); n_up += 1 }\n-            else { comps.pop_opt(); changed = true }\n+            else { comps.pop(); changed = true }\n         } else { comps.push(comp) }\n     }\n     if !changed && !prefix_is_verbatim(prefix) {\n@@ -1654,7 +1669,7 @@ mod tests {\n                 {\n                     let pstr = $path;\n                     let mut p = Path::from_str(pstr);\n-                    let file = p.pop_opt_str();\n+                    let file = p.pop_str();\n                     let left = $left;\n                     assert!(p.as_str() == Some(left),\n                         \"`%s`.pop() failed; expected remainder `%s`, found `%s`\",\n@@ -1668,15 +1683,15 @@ mod tests {\n             (v: [$($path:expr),+], [$($left:expr),+], Some($($right:expr),+)) => (\n                 {\n                     let mut p = Path::from_vec(b!($($path),+));\n-                    let file = p.pop_opt();\n+                    let file = p.pop();\n                     assert_eq!(p.as_vec(), b!($($left),+));\n                     assert_eq!(file.map(|v| v.as_slice()), Some(b!($($right),+)));\n                 }\n             );\n             (v: [$($path:expr),+], [$($left:expr),+], None) => (\n                 {\n                     let mut p = Path::from_vec(b!($($path),+));\n-                    let file = p.pop_opt();\n+                    let file = p.pop();\n                     assert_eq!(p.as_vec(), b!($($left),+));\n                     assert_eq!(file, None);\n                 }\n@@ -2373,4 +2388,54 @@ mod tests {\n         t!(s: \"\\\\\\\\.\\\\foo\\\\bar\", [\"bar\"]);\n         t!(s: \"\\\\\\\\.\\\\foo\", []);\n     }\n+\n+    #[test]\n+    fn test_each_parent() {\n+        assert!(Path::from_str(\"/foo/bar\").each_parent(|_| true));\n+        assert!(!Path::from_str(\"/foo/bar\").each_parent(|_| false));\n+\n+        macro_rules! t(\n+            (s: $path:expr, $exp:expr) => (\n+                {\n+                    let path = Path::from_str($path);\n+                    let exp: &[&str] = $exp;\n+                    let mut comps = exp.iter().map(|&x|x);\n+                    do path.each_parent |p| {\n+                        let p = p.as_str();\n+                        assert!(p.is_some());\n+                        let e = comps.next();\n+                        assert!(e.is_some());\n+                        assert_eq!(p.unwrap(), e.unwrap());\n+                        true\n+                    };\n+                    assert!(comps.next().is_none());\n+                }\n+            )\n+        )\n+\n+        t!(s: \"\\\\foo\\\\bar\", [\"\\\\foo\\\\bar\", \"\\\\foo\", \"\\\\\"]);\n+        t!(s: \"\\\\foo\\\\bar\\\\baz\", [\"\\\\foo\\\\bar\\\\baz\", \"\\\\foo\\\\bar\", \"\\\\foo\", \"\\\\\"]);\n+        t!(s: \"\\\\foo\", [\"\\\\foo\", \"\\\\\"]);\n+        t!(s: \"\\\\\", [\"\\\\\"]);\n+        t!(s: \"foo\\\\bar\\\\baz\", [\"foo\\\\bar\\\\baz\", \"foo\\\\bar\", \"foo\", \".\"]);\n+        t!(s: \"foo\\\\bar\", [\"foo\\\\bar\", \"foo\", \".\"]);\n+        t!(s: \"foo\", [\"foo\", \".\"]);\n+        t!(s: \".\", [\".\"]);\n+        t!(s: \"..\", [\"..\"]);\n+        t!(s: \"..\\\\..\\\\foo\", [\"..\\\\..\\\\foo\", \"..\\\\..\"]);\n+        t!(s: \"C:\\\\a\\\\b\", [\"C:\\\\a\\\\b\", \"C:\\\\a\", \"C:\\\\\"]);\n+        t!(s: \"C:\\\\\", [\"C:\\\\\"]);\n+        t!(s: \"C:a\\\\b\", [\"C:a\\\\b\", \"C:a\", \"C:\"]);\n+        t!(s: \"C:\", [\"C:\"]);\n+        t!(s: \"C:..\\\\..\\\\a\", [\"C:..\\\\..\\\\a\", \"C:..\\\\..\"]);\n+        t!(s: \"C:..\", [\"C:..\"]);\n+        t!(s: \"\\\\\\\\a\\\\b\\\\c\", [\"\\\\\\\\a\\\\b\\\\c\", \"\\\\\\\\a\\\\b\"]);\n+        t!(s: \"\\\\\\\\a\\\\b\", [\"\\\\\\\\a\\\\b\"]);\n+        t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\c\", [\"\\\\\\\\?\\\\a\\\\b\\\\c\", \"\\\\\\\\?\\\\a\\\\b\", \"\\\\\\\\?\\\\a\"]);\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\b\", [\"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"\\\\\\\\?\\\\C:\\\\a\", \"\\\\\\\\?\\\\C:\\\\\"]);\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\", [\"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\", \"\\\\\\\\?\\\\UNC\\\\a\\\\b\"]);\n+        t!(s: \"\\\\\\\\.\\\\a\\\\b\\\\c\", [\"\\\\\\\\.\\\\a\\\\b\\\\c\", \"\\\\\\\\.\\\\a\\\\b\", \"\\\\\\\\.\\\\a\"]);\n+        t!(s: \"\\\\\\\\?\\\\a\\\\..\\\\b\\\\.\\\\c/d\", [\"\\\\\\\\?\\\\a\\\\..\\\\b\\\\.\\\\c/d\", \"\\\\\\\\?\\\\a\\\\..\\\\b\\\\.\",\n+                                          \"\\\\\\\\?\\\\a\\\\..\\\\b\", \"\\\\\\\\?\\\\a\\\\..\", \"\\\\\\\\?\\\\a\"]);\n+    }\n }"}]}