{"sha": "55438fe5bf2eee99511d811898dd48a70a0cecd1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1NDM4ZmU1YmYyZWVlOTk1MTFkODExODk4ZGQ0OGE3MGEwY2VjZDE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-05-26T19:25:25Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-05-30T17:41:38Z"}, "message": "unify the way we intercept missing MIR and C ABI calls; only intercept C ABI calls if MIR is missing", "tree": {"sha": "46cfec80acd40fd8a2d93ec27e394fd2309f5ac9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46cfec80acd40fd8a2d93ec27e394fd2309f5ac9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55438fe5bf2eee99511d811898dd48a70a0cecd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55438fe5bf2eee99511d811898dd48a70a0cecd1", "html_url": "https://github.com/rust-lang/rust/commit/55438fe5bf2eee99511d811898dd48a70a0cecd1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55438fe5bf2eee99511d811898dd48a70a0cecd1/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14b16dcf45d00875e87e609362efb7d7d6cd84c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/14b16dcf45d00875e87e609362efb7d7d6cd84c3", "html_url": "https://github.com/rust-lang/rust/commit/14b16dcf45d00875e87e609362efb7d7d6cd84c3"}], "stats": {"total": 90, "additions": 55, "deletions": 35}, "files": [{"sha": "119e7249a7c0cd94411ee374d5fd530121cf3b9c", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 55, "deletions": 35, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/55438fe5bf2eee99511d811898dd48a70a0cecd1/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55438fe5bf2eee99511d811898dd48a70a0cecd1/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=55438fe5bf2eee99511d811898dd48a70a0cecd1", "patch": "@@ -172,7 +172,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 if self.eval_fn_call_inner(\n                     instance,\n                     destination,\n+                    arg_operands,\n                     span,\n+                    sig,\n                 )? {\n                     return Ok(());\n                 }\n@@ -202,18 +204,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 Ok(())\n             }\n             ty::InstanceDef::Item(_) => {\n-                match sig.abi {\n-                    Abi::C => {\n-                        let ty = sig.output();\n-                        let (ret, target) = destination.unwrap();\n-                        self.call_c_abi(instance.def_id(), arg_operands, ret, ty)?;\n-                        self.dump_local(ret);\n-                        self.goto_block(target);\n-                        return Ok(());\n-                    },\n-                    Abi::Rust | Abi::RustCall => {},\n-                    _ => unimplemented!(),\n-                }\n                 let mut args = Vec::new();\n                 for arg in arg_operands {\n                     let arg_val = self.eval_operand(arg)?;\n@@ -225,7 +215,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 if self.eval_fn_call_inner(\n                     instance,\n                     destination,\n+                    arg_operands,\n                     span,\n+                    sig,\n                 )? {\n                     return Ok(());\n                 }\n@@ -236,7 +228,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 trace!(\"arg_locals: {:?}\", self.frame().mir.args_iter().collect::<Vec<_>>());\n                 trace!(\"arg_operands: {:?}\", arg_operands);\n                 match sig.abi {\n-                    Abi::Rust => {\n+                    Abi::Rust | Abi::C => {\n                         for (arg_local, (arg_val, arg_ty)) in arg_locals.zip(args) {\n                             let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n                             self.write_value(arg_val, dest, arg_ty)?;\n@@ -316,7 +308,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 if self.eval_fn_call_inner(\n                     instance,\n                     destination,\n+                    arg_operands,\n                     span,\n+                    sig,\n                 )? {\n                     return Ok(());\n                 }\n@@ -363,7 +357,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         &mut self,\n         instance: ty::Instance<'tcx>,\n         destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        arg_operands: &[mir::Operand<'tcx>],\n         span: Span,\n+        sig: ty::FnSig<'tcx>,\n     ) -> EvalResult<'tcx, bool> {\n         trace!(\"eval_fn_call_inner: {:#?}, {:#?}\", instance, destination);\n \n@@ -372,28 +368,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let mir = match self.load_mir(instance.def) {\n             Ok(mir) => mir,\n             Err(EvalError::NoMirFor(path)) => {\n-                return match &path[..] {\n-                    // Intercept some methods if we cannot find their MIR.\n-                    \"std::io::_print\" => {\n-                        trace!(\"Ignoring output.\");\n-                        self.goto_block(destination.unwrap().1);\n-                        Ok(true)\n-                    },\n-                    \"std::thread::Builder::new\" => Err(EvalError::Unimplemented(\"miri does not support threading\".to_owned())),\n-                    \"std::env::args\" => Err(EvalError::Unimplemented(\"miri does not support program arguments\".to_owned())),\n-                    \"std::panicking::rust_panic_with_hook\" |\n-                    \"std::rt::begin_panic_fmt\" => Err(EvalError::Panic),\n-                    \"std::panicking::panicking\" |\n-                    \"std::rt::panicking\" => {\n-                        let (lval, block) = destination.expect(\"std::rt::panicking does not diverge\");\n-                        // we abort on panic -> `std::rt::panicking` always returns false\n-                        let bool = self.tcx.types.bool;\n-                        self.write_primval(lval, PrimVal::from_bool(false), bool)?;\n-                        self.goto_block(block);\n-                        Ok(true)\n-                    }\n-                    _ => Err(EvalError::NoMirFor(path)),\n-                };\n+                self.call_missing_fn(instance, destination, arg_operands, sig, path)?;\n+                return Ok(true);\n             },\n             Err(other) => return Err(other),\n         };\n@@ -466,6 +442,50 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         assert!(nndiscr == 0 || nndiscr == 1);\n         Ok(if not_null { nndiscr } else { 1 - nndiscr })\n     }\n+    \n+    /// Returns Ok() when the function was handled, fail otherwise\n+    fn call_missing_fn(\n+        &mut self,\n+        instance: ty::Instance<'tcx>,\n+        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        arg_operands: &[mir::Operand<'tcx>],\n+        sig: ty::FnSig<'tcx>,\n+        path: String,\n+    ) -> EvalResult<'tcx> {\n+        if sig.abi == Abi::C {\n+            // An external C function\n+            let ty = sig.output();\n+            let (ret, target) = destination.unwrap();\n+            self.call_c_abi(instance.def_id(), arg_operands, ret, ty)?;\n+            self.dump_local(ret);\n+            self.goto_block(target);\n+            return Ok(());\n+        }\n+    \n+        // A Rust function is missing, which means we are running with MIR missing for libstd (or other dependencies).\n+        // Still, we can make many things mostly work by \"emulating\" or ignoring some functions.\n+        match &path[..] {\n+            \"std::io::_print\" => {\n+                trace!(\"Ignoring output.\");\n+                self.goto_block(destination.unwrap().1);\n+                Ok(())\n+            },\n+            \"std::thread::Builder::new\" => Err(EvalError::Unimplemented(\"miri does not support threading\".to_owned())),\n+            \"std::env::args\" => Err(EvalError::Unimplemented(\"miri does not support program arguments\".to_owned())),\n+            \"std::panicking::rust_panic_with_hook\" |\n+            \"std::rt::begin_panic_fmt\" => Err(EvalError::Panic),\n+            \"std::panicking::panicking\" |\n+            \"std::rt::panicking\" => {\n+                let (lval, block) = destination.expect(\"std::rt::panicking does not diverge\");\n+                // we abort on panic -> `std::rt::panicking` always returns false\n+                let bool = self.tcx.types.bool;\n+                self.write_primval(lval, PrimVal::from_bool(false), bool)?;\n+                self.goto_block(block);\n+                Ok(())\n+            }\n+            _ => Err(EvalError::NoMirFor(path)),\n+        }\n+    }\n \n     fn call_c_abi(\n         &mut self,"}]}