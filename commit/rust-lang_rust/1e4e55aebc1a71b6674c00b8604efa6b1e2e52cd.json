{"sha": "1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlNGU1NWFlYmMxYTcxYjY2NzRjMDBiODYwNGVmYTZiMWUyZTUyY2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-14T18:17:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-14T18:17:28Z"}, "message": "auto merge of #18880 : barosl/rust/doc-fail-to-panic, r=alexcrichton\n\nI found some occurrences of \"failure\" and \"fails\" in the documentation. I changed them to \"panics\" if it means a task panic. Otherwise I left it as is, or changed it to \"errors\" to clearly distinguish them.\r\n\r\nAlso, I made a minor fix that is breaking the layout of a module page. \"Example\" is shown in an irrelevant place from the following page: http://doc.rust-lang.org/std/os/index.html", "tree": {"sha": "d57cb32a69c139630345db9c9a52fda4bf900b6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d57cb32a69c139630345db9c9a52fda4bf900b6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd", "html_url": "https://github.com/rust-lang/rust/commit/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1bf06495443584539b958873e04cc2f864ab10e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/1bf06495443584539b958873e04cc2f864ab10e4", "html_url": "https://github.com/rust-lang/rust/commit/1bf06495443584539b958873e04cc2f864ab10e4"}, {"sha": "5969bf663ef6ea4c62d27b88a957d401dad4227b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5969bf663ef6ea4c62d27b88a957d401dad4227b", "html_url": "https://github.com/rust-lang/rust/commit/5969bf663ef6ea4c62d27b88a957d401dad4227b"}], "stats": {"total": 269, "additions": 135, "deletions": 134}, "files": [{"sha": "f44f700ae5e422ffdc150c88a4a065cfb9bfd020", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd", "patch": "@@ -258,9 +258,9 @@ impl Bitv {\n \n     /// Retrieves the value at index `i`.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails if `i` is out of bounds.\n+    /// Panics if `i` is out of bounds.\n     ///\n     /// # Example\n     ///\n@@ -285,9 +285,9 @@ impl Bitv {\n \n     /// Sets the value of a bit at a index `i`.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails if `i` is out of bounds.\n+    /// Panics if `i` is out of bounds.\n     ///\n     /// # Example\n     ///\n@@ -353,9 +353,9 @@ impl Bitv {\n     /// Sets `self` to the union of `self` and `other`. Both bitvectors must be\n     /// the same length. Returns `true` if `self` changed.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails if the bitvectors are of different lengths.\n+    /// Panics if the bitvectors are of different lengths.\n     ///\n     /// # Example\n     ///\n@@ -383,9 +383,9 @@ impl Bitv {\n     /// Sets `self` to the intersection of `self` and `other`. Both bitvectors\n     /// must be the same length. Returns `true` if `self` changed.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails if the bitvectors are of different lengths.\n+    /// Panics if the bitvectors are of different lengths.\n     ///\n     /// # Example\n     ///\n@@ -413,9 +413,9 @@ impl Bitv {\n     /// element of `other` at the same index. Both bitvectors must be the same\n     /// length. Returns `true` if `self` changed.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails if the bitvectors are of different length.\n+    /// Panics if the bitvectors are of different length.\n     ///\n     /// # Example\n     ///\n@@ -580,9 +580,9 @@ impl Bitv {\n     /// Compares a `Bitv` to a slice of `bool`s.\n     /// Both the `Bitv` and slice must have the same length.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails if the the `Bitv` and slice are of different length.\n+    /// Panics if the the `Bitv` and slice are of different length.\n     ///\n     /// # Example\n     ///\n@@ -718,7 +718,7 @@ impl Bitv {\n \n     /// Shortens by one element and returns the removed element.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n     /// Assert if empty.\n     ///"}, {"sha": "5872afc6fde5fe5c8c244d2abaef2f0ab14f46cc", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd", "patch": "@@ -498,9 +498,9 @@ impl String {\n \n     /// Shortens a string to the specified length.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails if `new_len` > current length,\n+    /// Panics if `new_len` > current length,\n     /// or if `new_len` is not a character boundary.\n     ///\n     /// # Example"}, {"sha": "2b68de932d2b75f351a2e827dd8cf80f8da68418", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd", "patch": "@@ -941,9 +941,9 @@ impl<T> Vec<T> {\n \n     /// Appends an element to the back of a collection.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails if the number of elements in the vector overflows a `uint`.\n+    /// Panics if the number of elements in the vector overflows a `uint`.\n     ///\n     /// # Example\n     ///\n@@ -1462,9 +1462,9 @@ impl<T> Vec<T> {\n     /// Converts a `Vec<T>` to a `Vec<U>` where `T` and `U` have the same\n     /// size and in case they are not zero-sized the same minimal alignment.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails if `T` and `U` have differing sizes or are not zero-sized and\n+    /// Panics if `T` and `U` have differing sizes or are not zero-sized and\n     /// have differing minimal alignments.\n     ///\n     /// # Example"}, {"sha": "352beeb473a8608974cb2a48e24182a19a25973f", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd", "patch": "@@ -102,19 +102,19 @@ impl AtomicBool {\n \n     /// Load the value\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails if `order` is `Release` or `AcqRel`.\n+    /// Panics if `order` is `Release` or `AcqRel`.\n     #[inline]\n     pub fn load(&self, order: Ordering) -> bool {\n         unsafe { atomic_load(self.v.get() as *const uint, order) > 0 }\n     }\n \n     /// Store the value\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails if `order` is `Acquire` or `AcqRel`.\n+    /// Panics if `order` is `Acquire` or `AcqRel`.\n     #[inline]\n     pub fn store(&self, val: bool, order: Ordering) {\n         let val = if val { UINT_TRUE } else { 0 };\n@@ -313,19 +313,19 @@ impl AtomicInt {\n \n     /// Load the value\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails if `order` is `Release` or `AcqRel`.\n+    /// Panics if `order` is `Release` or `AcqRel`.\n     #[inline]\n     pub fn load(&self, order: Ordering) -> int {\n         unsafe { atomic_load(self.v.get() as *const int, order) }\n     }\n \n     /// Store the value\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails if `order` is `Acquire` or `AcqRel`.\n+    /// Panics if `order` is `Acquire` or `AcqRel`.\n     #[inline]\n     pub fn store(&self, val: int, order: Ordering) {\n         unsafe { atomic_store(self.v.get(), val, order); }\n@@ -435,19 +435,19 @@ impl AtomicUint {\n \n     /// Load the value\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails if `order` is `Release` or `AcqRel`.\n+    /// Panics if `order` is `Release` or `AcqRel`.\n     #[inline]\n     pub fn load(&self, order: Ordering) -> uint {\n         unsafe { atomic_load(self.v.get() as *const uint, order) }\n     }\n \n     /// Store the value\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails if `order` is `Acquire` or `AcqRel`.\n+    /// Panics if `order` is `Acquire` or `AcqRel`.\n     #[inline]\n     pub fn store(&self, val: uint, order: Ordering) {\n         unsafe { atomic_store(self.v.get(), val, order); }\n@@ -557,9 +557,9 @@ impl<T> AtomicPtr<T> {\n \n     /// Load the value\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails if `order` is `Release` or `AcqRel`.\n+    /// Panics if `order` is `Release` or `AcqRel`.\n     #[inline]\n     pub fn load(&self, order: Ordering) -> *mut T {\n         unsafe {\n@@ -569,9 +569,9 @@ impl<T> AtomicPtr<T> {\n \n     /// Store the value\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails if `order` is `Acquire` or `AcqRel`.\n+    /// Panics if `order` is `Acquire` or `AcqRel`.\n     #[inline]\n     pub fn store(&self, ptr: *mut T, order: Ordering) {\n         unsafe { atomic_store(self.p.get(), ptr as uint, order); }\n@@ -729,9 +729,9 @@ unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n ///\n /// Accepts `Acquire`, `Release`, `AcqRel` and `SeqCst` orderings.\n ///\n-/// # Failure\n+/// # Panics\n ///\n-/// Fails if `order` is `Relaxed`\n+/// Panics if `order` is `Relaxed`\n #[inline]\n #[stable]\n pub fn fence(order: Ordering) {"}, {"sha": "6f87ff52662b65ae1396543ae8a07db94aa8d6e3", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd", "patch": "@@ -274,9 +274,9 @@ impl<T> RefCell<T> {\n     /// The borrow lasts until the returned `Ref` exits scope. Multiple\n     /// immutable borrows can be taken out at the same time.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails if the value is currently mutably borrowed.\n+    /// Panics if the value is currently mutably borrowed.\n     #[unstable]\n     pub fn borrow<'a>(&'a self) -> Ref<'a, T> {\n         match self.try_borrow() {\n@@ -307,9 +307,9 @@ impl<T> RefCell<T> {\n     /// The borrow lasts until the returned `RefMut` exits scope. The value\n     /// cannot be borrowed while this borrow is active.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails if the value is currently borrowed.\n+    /// Panics if the value is currently borrowed.\n     #[unstable]\n     pub fn borrow_mut<'a>(&'a self) -> RefMut<'a, T> {\n         match self.try_borrow_mut() {"}, {"sha": "e4dc9ce5bd46f4afc0428ba15711b65e1a124718", "filename": "src/libcore/char.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd", "patch": "@@ -87,9 +87,9 @@ pub fn from_u32(i: u32) -> Option<char> {\n /// Returns `true` if `c` is a valid digit under `radix`, and `false`\n /// otherwise.\n ///\n-/// # Failure\n+/// # Panics\n ///\n-/// Fails if given a `radix` > 36.\n+/// Panics if given a `radix` > 36.\n ///\n /// # Note\n ///\n@@ -113,9 +113,9 @@ pub fn is_digit_radix(c: char, radix: uint) -> bool {\n /// 'b' or 'B', 11, etc. Returns none if the `char` does not\n /// refer to a digit in the given radix.\n ///\n-/// # Failure\n+/// # Panics\n ///\n-/// Fails if given a `radix` outside the range `[0..36]`.\n+/// Panics if given a `radix` outside the range `[0..36]`.\n ///\n #[inline]\n pub fn to_digit(c: char, radix: uint) -> Option<uint> {\n@@ -140,9 +140,9 @@ pub fn to_digit(c: char, radix: uint) -> Option<uint> {\n /// Returns `Some(char)` if `num` represents one digit under `radix`,\n /// using one character of `0-9` or `a-z`, or `None` if it doesn't.\n ///\n-/// # Failure\n+/// # Panics\n ///\n-/// Fails if given an `radix` > 36.\n+/// Panics if given an `radix` > 36.\n ///\n #[inline]\n pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n@@ -240,9 +240,9 @@ pub trait Char {\n     /// Returns `true` if `c` is a valid digit under `radix`, and `false`\n     /// otherwise.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails if given a radix > 36.\n+    /// Panics if given a radix > 36.\n     fn is_digit_radix(&self, radix: uint) -> bool;\n \n     /// Converts a character to the corresponding digit.\n@@ -253,9 +253,9 @@ pub trait Char {\n     /// 9. If `c` is 'a' or 'A', 10. If `c` is 'b' or 'B', 11, etc. Returns\n     /// none if the character does not refer to a digit in the given radix.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails if given a radix outside the range [0..36].\n+    /// Panics if given a radix outside the range [0..36].\n     fn to_digit(&self, radix: uint) -> Option<uint>;\n \n     /// Converts a number to the character representing it.\n@@ -265,9 +265,9 @@ pub trait Char {\n     /// Returns `Some(char)` if `num` represents one digit under `radix`,\n     /// using one character of `0-9` or `a-z`, or `None` if it doesn't.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails if given a radix > 36.\n+    /// Panics if given a radix > 36.\n     fn from_digit(num: uint, radix: uint) -> Option<Self>;\n \n     /// Returns the hexadecimal Unicode escape of a character."}, {"sha": "6a6a2fe4a6d73aca1d09220d7a018aca8bfa3b09", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd", "patch": "@@ -72,11 +72,11 @@ static DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n  * - `f`             - A closure to invoke with the bytes representing the\n  *                     float.\n  *\n- * # Failure\n- * - Fails if `radix` < 2 or `radix` > 36.\n- * - Fails if `radix` > 14 and `exp_format` is `ExpDec` due to conflict\n+ * # Panics\n+ * - Panics if `radix` < 2 or `radix` > 36.\n+ * - Panics if `radix` > 14 and `exp_format` is `ExpDec` due to conflict\n  *   between digit and exponent sign `'e'`.\n- * - Fails if `radix` > 25 and `exp_format` is `ExpBin` due to conflict\n+ * - Panics if `radix` > 25 and `exp_format` is `ExpBin` due to conflict\n  *   between digit and exponent sign `'p'`.\n  */\n pub fn float_to_str_bytes_common<T: Float, U>("}, {"sha": "432178e281e2373485de5953e5914188f587b91e", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd", "patch": "@@ -62,7 +62,7 @@ use raw::Slice as RawSlice;\n pub trait SlicePrelude<T> for Sized? {\n     /// Returns a subslice spanning the interval [`start`, `end`).\n     ///\n-    /// Fails when the end of the new slice lies beyond the end of the\n+    /// Panics when the end of the new slice lies beyond the end of the\n     /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n     ///\n     /// Slicing with `start` equal to `end` yields an empty slice.\n@@ -71,15 +71,15 @@ pub trait SlicePrelude<T> for Sized? {\n \n     /// Returns a subslice from `start` to the end of the slice.\n     ///\n-    /// Fails when `start` is strictly greater than the length of the original slice.\n+    /// Panics when `start` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing from `self.len()` yields an empty slice.\n     #[unstable = \"waiting on final error conventions/slicing syntax\"]\n     fn slice_from<'a>(&'a self, start: uint) -> &'a [T];\n \n     /// Returns a subslice from the start of the slice to `end`.\n     ///\n-    /// Fails when `end` is strictly greater than the length of the original slice.\n+    /// Panics when `end` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing to `0` yields an empty slice.\n     #[unstable = \"waiting on final error conventions/slicing syntax\"]\n@@ -91,7 +91,7 @@ pub trait SlicePrelude<T> for Sized? {\n     /// the index `mid` itself) and the second will contain all\n     /// indices from `[mid, len)` (excluding the index `len` itself).\n     ///\n-    /// Fails if `mid > len`.\n+    /// Panics if `mid > len`.\n     #[unstable = \"waiting on final error conventions\"]\n     fn split_at<'a>(&'a self, mid: uint) -> (&'a [T], &'a [T]);\n \n@@ -121,9 +121,9 @@ pub trait SlicePrelude<T> for Sized? {\n     /// `size`. The windows overlap. If the slice is shorter than\n     /// `size`, the iterator returns no values.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails if `size` is 0.\n+    /// Panics if `size` is 0.\n     ///\n     /// # Example\n     ///\n@@ -144,9 +144,9 @@ pub trait SlicePrelude<T> for Sized? {\n     /// length of the slice, then the last chunk will not have length\n     /// `size`.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails if `size` is 0.\n+    /// Panics if `size` is 0.\n     ///\n     /// # Example\n     ///\n@@ -267,7 +267,7 @@ pub trait SlicePrelude<T> for Sized? {\n \n     /// Returns a mutable subslice spanning the interval [`start`, `end`).\n     ///\n-    /// Fails when the end of the new slice lies beyond the end of the\n+    /// Panics when the end of the new slice lies beyond the end of the\n     /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n     ///\n     /// Slicing with `start` equal to `end` yields an empty slice.\n@@ -276,15 +276,15 @@ pub trait SlicePrelude<T> for Sized? {\n \n     /// Returns a mutable subslice from `start` to the end of the slice.\n     ///\n-    /// Fails when `start` is strictly greater than the length of the original slice.\n+    /// Panics when `start` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing from `self.len()` yields an empty slice.\n     #[unstable = \"waiting on final error conventions\"]\n     fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [T];\n \n     /// Returns a mutable subslice from the start of the slice to `end`.\n     ///\n-    /// Fails when `end` is strictly greater than the length of the original slice.\n+    /// Panics when `end` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing to `0` yields an empty slice.\n     #[unstable = \"waiting on final error conventions\"]\n@@ -333,15 +333,15 @@ pub trait SlicePrelude<T> for Sized? {\n     /// not divide the length of the slice, then the last chunk will not\n     /// have length `chunk_size`.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails if `chunk_size` is 0.\n+    /// Panics if `chunk_size` is 0.\n     #[unstable = \"waiting on iterator type name conventions\"]\n     fn chunks_mut<'a>(&'a mut self, chunk_size: uint) -> MutChunks<'a, T>;\n \n     /// Swaps two elements in a slice.\n     ///\n-    /// Fails if `a` or `b` are out of bounds.\n+    /// Panics if `a` or `b` are out of bounds.\n     ///\n     /// # Arguments\n     ///\n@@ -364,7 +364,7 @@ pub trait SlicePrelude<T> for Sized? {\n     /// the index `mid` itself) and the second will contain all\n     /// indices from `[mid, len)` (excluding the index `len` itself).\n     ///\n-    /// Fails if `mid > len`.\n+    /// Panics if `mid > len`.\n     ///\n     /// # Example\n     ///\n@@ -1641,7 +1641,7 @@ pub mod bytes {\n \n     /// Copies data from `src` to `dst`\n     ///\n-    /// `src` and `dst` must not overlap. Fails if the length of `dst`\n+    /// `src` and `dst` must not overlap. Panics if the length of `dst`\n     /// is less than the length of `src`.\n     #[inline]\n     pub fn copy_memory(dst: &mut [u8], src: &[u8]) {"}, {"sha": "745de5f179e7cd326b49cdcd6cbf315e88cc249d", "filename": "src/libcore/str.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd", "patch": "@@ -1084,7 +1084,7 @@ pub mod raw {\n     ///\n     /// Returns the substring from [`begin`..`end`).\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n     /// If begin is greater than end.\n     /// If end is greater than the length of the string.\n@@ -1432,7 +1432,7 @@ pub trait StrPrelude for Sized? {\n     ///\n     /// This operation is `O(1)`.\n     ///\n-    /// Fails when `begin` and `end` do not point to valid characters\n+    /// Panics when `begin` and `end` do not point to valid characters\n     /// or point beyond the last character of the string.\n     ///\n     /// See also `slice_to` and `slice_from` for slicing prefixes and\n@@ -1463,7 +1463,7 @@ pub trait StrPrelude for Sized? {\n     ///\n     /// Equivalent to `self.slice(begin, self.len())`.\n     ///\n-    /// Fails when `begin` does not point to a valid character, or is\n+    /// Panics when `begin` does not point to a valid character, or is\n     /// out of bounds.\n     ///\n     /// See also `slice`, `slice_to` and `slice_chars`.\n@@ -1474,7 +1474,7 @@ pub trait StrPrelude for Sized? {\n     ///\n     /// Equivalent to `self.slice(0, end)`.\n     ///\n-    /// Fails when `end` does not point to a valid character, or is\n+    /// Panics when `end` does not point to a valid character, or is\n     /// out of bounds.\n     ///\n     /// See also `slice`, `slice_from` and `slice_chars`.\n@@ -1493,7 +1493,7 @@ pub trait StrPrelude for Sized? {\n     /// variants that use byte indices rather than code point\n     /// indices.\n     ///\n-    /// Fails if `begin` > `end` or the either `begin` or `end` are\n+    /// Panics if `begin` > `end` or the either `begin` or `end` are\n     /// beyond the last character of the string.\n     ///\n     /// # Example\n@@ -1577,7 +1577,7 @@ pub trait StrPrelude for Sized? {\n     /// The start and end of the string (when `index == self.len()`)\n     /// are considered to be boundaries.\n     ///\n-    /// Fails if `index` is greater than `self.len()`.\n+    /// Panics if `index` is greater than `self.len()`.\n     ///\n     /// # Example\n     ///\n@@ -1645,7 +1645,7 @@ pub trait StrPrelude for Sized? {\n     /// A record {ch: char, next: uint} containing the char value and the byte\n     /// index of the next Unicode character.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n     /// If `i` is greater than or equal to the length of the string.\n     /// If `i` is not the index of the beginning of a valid UTF-8 character.\n@@ -1657,7 +1657,7 @@ pub trait StrPrelude for Sized? {\n     ///\n     /// Returns 0 for next index if called on start index 0.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n     /// If `i` is greater than the length of the string.\n     /// If `i` is not an index following a valid UTF-8 character.\n@@ -1674,15 +1674,15 @@ pub trait StrPrelude for Sized? {\n     /// assert_eq!(s.char_at(4), 'c');\n     /// ```\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n     /// If `i` is greater than or equal to the length of the string.\n     /// If `i` is not the index of the beginning of a valid UTF-8 character.\n     fn char_at(&self, i: uint) -> char;\n \n     /// Plucks the character ending at the `i`th byte of a string.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n     /// If `i` is greater than the length of the string.\n     /// If `i` is not an index following a valid UTF-8 character.\n@@ -1790,7 +1790,7 @@ pub trait StrPrelude for Sized? {\n \n     /// Returns the byte offset of an inner slice relative to an enclosing outer slice.\n     ///\n-    /// Fails if `inner` is not a direct slice contained within self.\n+    /// Panics if `inner` is not a direct slice contained within self.\n     ///\n     /// # Example\n     ///"}, {"sha": "4aaa9b9f48d85b242a38788a25a9083bd70c84a0", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd", "patch": "@@ -562,7 +562,7 @@ impl fmt::Show for Fail_ {\n ///\n /// On success returns `Ok(Matches)`. Use methods such as `opt_present`\n /// `opt_str`, etc. to interrogate results.\n-/// # Failure\n+/// # Errors\n ///\n /// Returns `Err(Fail_)` on failure: use the `Show` implementation of `Fail_` to display\n /// information about it."}, {"sha": "25c24a9a33580c9ca2e691bc88503047817b22ab", "filename": "src/librustrt/c_str.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibrustrt%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibrustrt%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fc_str.rs?ref=1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd", "patch": "@@ -141,9 +141,9 @@ impl CString {\n     /// API, so avoid calling it with a pointer to memory managed by Rust's\n     /// allocator API, as the behaviour would not be well defined.\n     ///\n-    ///# Failure\n+    ///# Panics\n     ///\n-    /// Fails if `buf` is null\n+    /// Panics if `buf` is null\n     pub unsafe fn new(buf: *const libc::c_char, owns_buffer: bool) -> CString {\n         assert!(!buf.is_null());\n         CString { buf: buf, owns_buffer_: owns_buffer }\n@@ -291,9 +291,9 @@ impl fmt::Show for CString {\n pub trait ToCStr for Sized? {\n     /// Copy the receiver into a CString.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails the task if the receiver has an interior null.\n+    /// Panics the task if the receiver has an interior null.\n     fn to_c_str(&self) -> CString;\n \n     /// Unsafe variant of `to_c_str()` that doesn't check for nulls.\n@@ -314,9 +314,9 @@ pub trait ToCStr for Sized? {\n     /// }\n     /// ```\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails the task if the receiver has an interior null.\n+    /// Panics the task if the receiver has an interior null.\n     #[inline]\n     fn with_c_str<T>(&self, f: |*const libc::c_char| -> T) -> T {\n         let c_str = self.to_c_str();"}, {"sha": "4d26fa7e26c090d5111b3c0d2ab3c0f43f60df15", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd", "patch": "@@ -1237,9 +1237,9 @@ impl<K: Eq + Hash<S>, V: Clone, S, H: Hasher<S>> HashMap<K, V, H> {\n \n     /// Return a copy of the value corresponding to the key.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails if the key is not present.\n+    /// Panics if the key is not present.\n     ///\n     /// # Example\n     ///"}, {"sha": "05faba4950b29144cb52285ffc68949d8b444d28", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd", "patch": "@@ -489,9 +489,9 @@ impl<K, V, M: Deref<RawTable<K, V>>> GapThenFull<K, V, M> {\n /// Rounds up to a multiple of a power of two. Returns the closest multiple\n /// of `target_alignment` that is higher or equal to `unrounded`.\n ///\n-/// # Failure\n+/// # Panics\n ///\n-/// Fails if `target_alignment` is not a power of two.\n+/// Panics if `target_alignment` is not a power of two.\n fn round_up_to_next(unrounded: uint, target_alignment: uint) -> uint {\n     assert!(target_alignment.is_power_of_two());\n     (unrounded + target_alignment - 1) & !(target_alignment - 1)"}, {"sha": "64fed1a544249ede7d11523257e5ef148c9d65a4", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd", "patch": "@@ -914,9 +914,9 @@ impl<'a> Reader for &'a mut Reader+'a {\n /// Similar to `slice()` except this function only bounds the slice on the\n /// capacity of `v`, not the length.\n ///\n-/// # Failure\n+/// # Panics\n ///\n-/// Fails when `start` or `end` point outside the capacity of `v`, or when\n+/// Panics when `start` or `end` point outside the capacity of `v`, or when\n /// `start` > `end`.\n // Private function here because we aren't sure if we want to expose this as\n // API yet. If so, it should be a method on Vec."}, {"sha": "fff31b332e17991d72db8e3a18adc0ffefbf0306", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd", "patch": "@@ -88,8 +88,8 @@ pub enum SignFormat {\n  * It returns a tuple because there can be ambiguity between a special value\n  * and a number representation at higher bases.\n  *\n- * # Failure\n- * - Fails if `radix` < 2 or `radix` > 36.\n+ * # Panics\n+ * - Panics if `radix` < 2 or `radix` > 36.\n  */\n fn int_to_str_bytes_common<T: Int>(num: T, radix: uint, sign: SignFormat, f: |u8|) {\n     assert!(2 <= radix && radix <= 36);\n@@ -172,11 +172,11 @@ fn int_to_str_bytes_common<T: Int>(num: T, radix: uint, sign: SignFormat, f: |u8\n  * It returns a tuple because there can be ambiguity between a special value\n  * and a number representation at higher bases.\n  *\n- * # Failure\n- * - Fails if `radix` < 2 or `radix` > 36.\n- * - Fails if `radix` > 14 and `exp_format` is `ExpDec` due to conflict\n+ * # Panics\n+ * - Panics if `radix` < 2 or `radix` > 36.\n+ * - Panics if `radix` > 14 and `exp_format` is `ExpDec` due to conflict\n  *   between digit and exponent sign `'e'`.\n- * - Fails if `radix` > 25 and `exp_format` is `ExpBin` due to conflict\n+ * - Panics if `radix` > 25 and `exp_format` is `ExpBin` due to conflict\n  *   between digit and exponent sign `'p'`.\n  */\n pub fn float_to_str_bytes_common<T: Float>("}, {"sha": "1402d3a3559056486688c98eefaf6a44c0f5c979", "filename": "src/libstd/os.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd", "patch": "@@ -322,9 +322,9 @@ pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> {\n /// Any invalid UTF-8 bytes in the value are replaced by \\uFFFD. See\n /// `String::from_utf8_lossy()` for details.\n ///\n-/// # Failure\n+/// # Panics\n ///\n-/// Fails if `n` has any interior NULs.\n+/// Panics if `n` has any interior NULs.\n ///\n /// # Example\n ///\n@@ -345,9 +345,9 @@ pub fn getenv(n: &str) -> Option<String> {\n /// Fetches the environment variable `n` byte vector from the current process,\n /// returning None if the variable isn't set.\n ///\n-/// # Failure\n+/// # Panics\n ///\n-/// Fails if `n` has any interior NULs.\n+/// Panics if `n` has any interior NULs.\n pub fn getenv_as_bytes(n: &str) -> Option<Vec<u8>> {\n     use c_str::CString;\n \n@@ -889,6 +889,7 @@ pub fn errno() -> uint {\n }\n \n /// Return the string corresponding to an `errno()` value of `errnum`.\n+///\n /// # Example\n /// ```rust\n /// use std::os;\n@@ -1474,7 +1475,7 @@ impl MemoryMap {\n \n #[cfg(windows)]\n impl Drop for MemoryMap {\n-    /// Unmap the mapping. Fails the task if any of `VirtualFree`,\n+    /// Unmap the mapping. Panics the task if any of `VirtualFree`,\n     /// `UnmapViewOfFile`, or `CloseHandle` fail.\n     fn drop(&mut self) {\n         use libc::types::os::arch::extra::{LPCVOID, HANDLE};"}, {"sha": "a185a29a7006e2830f5831842c4dd2bec801113c", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd", "patch": "@@ -154,9 +154,9 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # }\n     /// ```\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails the task if the path contains a NUL.\n+    /// Panics the task if the path contains a NUL.\n     ///\n     /// See individual Path impls for additional restrictions.\n     #[inline]\n@@ -443,9 +443,9 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # }\n     /// ```\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails the task if the filename contains a NUL.\n+    /// Panics the task if the filename contains a NUL.\n     #[inline]\n     fn set_filename<T: BytesContainer>(&mut self, filename: T) {\n         assert!(!contains_nul(&filename));\n@@ -469,9 +469,9 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # }\n     /// ```\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails the task if the extension contains a NUL.\n+    /// Panics the task if the extension contains a NUL.\n     fn set_extension<T: BytesContainer>(&mut self, extension: T) {\n         assert!(!contains_nul(&extension));\n \n@@ -518,9 +518,9 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # }\n     /// ```\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails the task if the filename contains a NUL.\n+    /// Panics the task if the filename contains a NUL.\n     #[inline]\n     fn with_filename<T: BytesContainer>(&self, filename: T) -> Self {\n         let mut p = self.clone();\n@@ -543,9 +543,9 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # }\n     /// ```\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails the task if the extension contains a NUL.\n+    /// Panics the task if the extension contains a NUL.\n     #[inline]\n     fn with_extension<T: BytesContainer>(&self, extension: T) -> Self {\n         let mut p = self.clone();\n@@ -602,9 +602,9 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # }\n     /// ```\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails the task if the path contains a NUL.\n+    /// Panics the task if the path contains a NUL.\n     #[inline]\n     fn push<T: BytesContainer>(&mut self, path: T) {\n         assert!(!contains_nul(&path));\n@@ -671,9 +671,9 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # }\n     /// ```\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails the task if the path contains a NUL.\n+    /// Panics the task if the path contains a NUL.\n     #[inline]\n     fn join<T: BytesContainer>(&self, path: T) -> Self {\n         let mut p = self.clone();"}, {"sha": "794f6978642cf7cd8872f419b49730f2b3f60eea", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd", "patch": "@@ -327,9 +327,9 @@ impl GenericPath for Path {\n impl Path {\n     /// Returns a new Path from a byte vector or string\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails the task if the vector contains a NUL.\n+    /// Panics the task if the vector contains a NUL.\n     #[inline]\n     pub fn new<T: BytesContainer>(path: T) -> Path {\n         GenericPath::new(path)"}, {"sha": "2da2159653e9a46e2346c9f28bd7f2bbf9ab0883", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd", "patch": "@@ -159,9 +159,9 @@ impl BytesContainer for Path {\n impl GenericPathUnsafe for Path {\n     /// See `GenericPathUnsafe::from_vec_unchecked`.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails if not valid UTF-8.\n+    /// Panics if not valid UTF-8.\n     #[inline]\n     unsafe fn new_unchecked<T: BytesContainer>(path: T) -> Path {\n         let (prefix, path) = Path::normalize_(path.container_as_str().unwrap());\n@@ -173,9 +173,9 @@ impl GenericPathUnsafe for Path {\n \n     /// See `GenericPathUnsafe::set_filename_unchecked`.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails if not valid UTF-8.\n+    /// Panics if not valid UTF-8.\n     unsafe fn set_filename_unchecked<T: BytesContainer>(&mut self, filename: T) {\n         let filename = filename.container_as_str().unwrap();\n         match self.sepidx_or_prefix_len() {\n@@ -600,9 +600,9 @@ impl GenericPath for Path {\n impl Path {\n     /// Returns a new `Path` from a `BytesContainer`.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Fails if the vector contains a `NUL`, or if it contains invalid UTF-8.\n+    /// Panics if the vector contains a `NUL`, or if it contains invalid UTF-8.\n     ///\n     /// # Example\n     ///"}, {"sha": "65b3e30c2b919044167f324e2c7d26b6a6863126", "filename": "src/libsync/comm/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibsync%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibsync%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fmod.rs?ref=1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd", "patch": "@@ -43,7 +43,7 @@\n //!    \"rendezvous\" channel where each sender atomically hands off a message to\n //!    a receiver.\n //!\n-//! ## Failure Propagation\n+//! ## Panic Propagation\n //!\n //! In addition to being a core primitive for communicating in rust, channels\n //! are the points at which panics are propagated among tasks.  Whenever the one"}, {"sha": "0ef3e77da00b4544c435463db59322e51946314d", "filename": "src/libsync/lock.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibsync%2Flock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibsync%2Flock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Flock.rs?ref=1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd", "patch": "@@ -345,9 +345,9 @@ impl<T: Send + Sync> RWLock<T> {\n     /// Access the underlying data immutably. May run concurrently with other\n     /// reading tasks.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n-    /// Failing will unlock the lock while unwinding. However, unlike all other\n+    /// Panicking will unlock the lock while unwinding. However, unlike all other\n     /// access modes, this will not poison the lock.\n     pub fn read<'a>(&'a self) -> RWLockReadGuard<'a, T> {\n         let guard = self.lock.read();"}, {"sha": "986f90389e769ff9c0981be987357a49c402e962", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=1e4e55aebc1a71b6674c00b8604efa6b1e2e52cd", "patch": "@@ -1116,7 +1116,7 @@ impl MetricMap {\n \n     /// Load MetricDiff from a file.\n     ///\n-    /// # Failure\n+    /// # Panics\n     ///\n     /// This function will panic if the path does not exist or the path does not\n     /// contain a valid metric map."}]}