{"sha": "1768b1090a844a0833250d408ca32e871ea0b16c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3NjhiMTA5MGE4NDRhMDgzMzI1MGQ0MDhjYTMyZTg3MWVhMGIxNmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-02T01:40:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-02T01:40:28Z"}, "message": "Auto merge of #26688 - nrc:map-parent-2, r=manishearth\n\nr? @Manishearth", "tree": {"sha": "1c38f6002e7fb652b7215d52651a2c991f7a0b79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c38f6002e7fb652b7215d52651a2c991f7a0b79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1768b1090a844a0833250d408ca32e871ea0b16c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1768b1090a844a0833250d408ca32e871ea0b16c", "html_url": "https://github.com/rust-lang/rust/commit/1768b1090a844a0833250d408ca32e871ea0b16c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1768b1090a844a0833250d408ca32e871ea0b16c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2cf9f9632746701f72ded3a50de2c5d8e05b1b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2cf9f9632746701f72ded3a50de2c5d8e05b1b5", "html_url": "https://github.com/rust-lang/rust/commit/d2cf9f9632746701f72ded3a50de2c5d8e05b1b5"}, {"sha": "8261599e62a7930cec372e637e5ab58f5a26532c", "url": "https://api.github.com/repos/rust-lang/rust/commits/8261599e62a7930cec372e637e5ab58f5a26532c", "html_url": "https://github.com/rust-lang/rust/commit/8261599e62a7930cec372e637e5ab58f5a26532c"}], "stats": {"total": 175, "additions": 138, "deletions": 37}, "files": [{"sha": "3205141e604c2769d9b4721822d8fb21f4ffbfc2", "filename": "src/librustc/ast_map/mod.rs", "status": "modified", "additions": 130, "deletions": 29, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/1768b1090a844a0833250d408ca32e871ea0b16c/src%2Flibrustc%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1768b1090a844a0833250d408ca32e871ea0b16c/src%2Flibrustc%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fast_map%2Fmod.rs?ref=1768b1090a844a0833250d408ca32e871ea0b16c", "patch": "@@ -121,7 +121,7 @@ pub enum Node<'ast> {\n     NodeLifetime(&'ast Lifetime),\n }\n \n-/// Represents an entry and its parent Node ID\n+/// Represents an entry and its parent NodeID.\n /// The odd layout is to bring down the total size.\n #[derive(Copy, Debug)]\n enum MapEntry<'ast> {\n@@ -179,7 +179,7 @@ impl<'ast> MapEntry<'ast> {\n         }\n     }\n \n-    fn parent(self) -> Option<NodeId> {\n+    fn parent_node(self) -> Option<NodeId> {\n         Some(match self {\n             EntryItem(id, _) => id,\n             EntryForeignItem(id, _) => id,\n@@ -283,10 +283,88 @@ impl<'ast> Map<'ast> {\n         self.find_entry(id).and_then(|x| x.to_node())\n     }\n \n-    /// Retrieve the parent NodeId for `id`, or `id` itself if no\n-    /// parent is registered in this map.\n+    /// Similar to get_parent, returns the parent node id or id if there is no\n+    /// parent.\n+    /// This function returns the immediate parent in the AST, whereas get_parent\n+    /// returns the enclosing item. Note that this might not be the actual parent\n+    /// node in the AST - some kinds of nodes are not in the map and these will\n+    /// never appear as the parent_node. So you can always walk the parent_nodes\n+    /// from a node to the root of the ast (unless you get the same id back here\n+    /// that can happen if the id is not in the map itself or is just weird).\n+    pub fn get_parent_node(&self, id: NodeId) -> NodeId {\n+        self.find_entry(id).and_then(|x| x.parent_node()).unwrap_or(id)\n+    }\n+\n+    /// If there is some error when walking the parents (e.g., a node does not\n+    /// have a parent in the map or a node can't be found), then we return the\n+    /// last good node id we found. Note that reaching the crate root (id == 0),\n+    /// is not an error, since items in the crate module have the crate root as\n+    /// parent.\n+    fn walk_parent_nodes<F>(&self, start_id: NodeId, found: F) -> Result<NodeId, NodeId>\n+        where F: Fn(&Node<'ast>) -> bool\n+    {\n+        let mut id = start_id;\n+        loop {\n+            let parent_node = self.get_parent_node(id);\n+            if parent_node == 0 {\n+                return Ok(0);\n+            }\n+            if parent_node == id {\n+                return Err(id);\n+            }\n+\n+            let node = self.find_entry(parent_node);\n+            if node.is_none() {\n+                return Err(id);\n+            }\n+            let node = node.unwrap().to_node();\n+            match node {\n+                Some(ref node) => {\n+                    if found(node) {\n+                        return Ok(parent_node);\n+                    }\n+                }\n+                None => {\n+                    return Err(parent_node);\n+                }\n+            }\n+            id = parent_node;\n+        }\n+    }\n+\n+    /// Retrieve the NodeId for `id`'s parent item, or `id` itself if no\n+    /// parent item is in this map. The \"parent item\" is the closest parent node\n+    /// in the AST which is recorded by the map and is an item, either an item\n+    /// in a module, trait, or impl.\n     pub fn get_parent(&self, id: NodeId) -> NodeId {\n-        self.find_entry(id).and_then(|x| x.parent()).unwrap_or(id)\n+        match self.walk_parent_nodes(id, |node| match *node {\n+            NodeItem(_) |\n+            NodeForeignItem(_) |\n+            NodeTraitItem(_) |\n+            NodeImplItem(_) => true,\n+            _ => false,\n+        }) {\n+            Ok(id) => id,\n+            Err(id) => id,\n+        }\n+    }\n+\n+    /// Returns the nearest enclosing scope. A scope is an item or block.\n+    /// FIXME it is not clear to me that all items qualify as scopes - statics\n+    /// and associated types probably shouldn't, for example. Behaviour in this\n+    /// regard should be expected to be highly unstable.\n+    pub fn get_enclosing_scope(&self, id: NodeId) -> Option<NodeId> {\n+        match self.walk_parent_nodes(id, |node| match *node {\n+            NodeItem(_) |\n+            NodeForeignItem(_) |\n+            NodeTraitItem(_) |\n+            NodeImplItem(_) |\n+            NodeBlock(_) => true,\n+            _ => false,\n+        }) {\n+            Ok(id) => Some(id),\n+            Err(_) => None,\n+        }\n     }\n \n     pub fn get_parent_did(&self, id: NodeId) -> DefId {\n@@ -590,15 +668,15 @@ impl<'a, 'ast> Iterator for NodesMatchingSuffix<'a, 'ast> {\n                 return None;\n             }\n             self.idx += 1;\n-            let (p, name) = match self.map.find_entry(idx) {\n-                Some(EntryItem(p, n))       => (p, n.name()),\n-                Some(EntryForeignItem(p, n))=> (p, n.name()),\n-                Some(EntryTraitItem(p, n))  => (p, n.name()),\n-                Some(EntryImplItem(p, n))   => (p, n.name()),\n-                Some(EntryVariant(p, n))    => (p, n.name()),\n+            let name = match self.map.find_entry(idx) {\n+                Some(EntryItem(_, n))       => n.name(),\n+                Some(EntryForeignItem(_, n))=> n.name(),\n+                Some(EntryTraitItem(_, n))  => n.name(),\n+                Some(EntryImplItem(_, n))   => n.name(),\n+                Some(EntryVariant(_, n))    => n.name(),\n                 _ => continue,\n             };\n-            if self.matches_names(p, name) {\n+            if self.matches_names(self.map.get_parent(idx), name) {\n                 return Some(idx)\n             }\n         }\n@@ -647,8 +725,7 @@ impl<F: FoldOps> Folder for IdAndSpanUpdater<F> {\n /// A Visitor that walks over an AST and collects Node's into an AST Map.\n struct NodeCollector<'ast> {\n     map: Vec<MapEntry<'ast>>,\n-    /// The node in which we are currently mapping (an item or a method).\n-    parent: NodeId\n+    parent_node: NodeId,\n }\n \n impl<'ast> NodeCollector<'ast> {\n@@ -662,7 +739,7 @@ impl<'ast> NodeCollector<'ast> {\n     }\n \n     fn insert(&mut self, id: NodeId, node: Node<'ast>) {\n-        let entry = MapEntry::from_node(self.parent, node);\n+        let entry = MapEntry::from_node(self.parent_node, node);\n         self.insert_entry(id, entry);\n     }\n \n@@ -676,8 +753,10 @@ impl<'ast> NodeCollector<'ast> {\n impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     fn visit_item(&mut self, i: &'ast Item) {\n         self.insert(i.id, NodeItem(i));\n-        let parent = self.parent;\n-        self.parent = i.id;\n+\n+        let parent_node = self.parent_node;\n+        self.parent_node = i.id;\n+\n         match i.node {\n             ItemImpl(_, _, _, _, _, ref impl_items) => {\n                 for ii in impl_items {\n@@ -727,21 +806,23 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n             _ => {}\n         }\n         visit::walk_item(self, i);\n-        self.parent = parent;\n+        self.parent_node = parent_node;\n     }\n \n     fn visit_trait_item(&mut self, ti: &'ast TraitItem) {\n-        let parent = self.parent;\n-        self.parent = ti.id;\n+        let parent_node = self.parent_node;\n+        self.parent_node = ti.id;\n         visit::walk_trait_item(self, ti);\n-        self.parent = parent;\n+        self.parent_node = parent_node;\n     }\n \n     fn visit_impl_item(&mut self, ii: &'ast ImplItem) {\n-        let parent = self.parent;\n-        self.parent = ii.id;\n+        let parent_node = self.parent_node;\n+        self.parent_node = ii.id;\n+\n         visit::walk_impl_item(self, ii);\n-        self.parent = parent;\n+\n+        self.parent_node = parent_node;\n     }\n \n     fn visit_pat(&mut self, pat: &'ast Pat) {\n@@ -750,38 +831,58 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n             PatIdent(..) => NodeLocal(pat),\n             _ => NodePat(pat)\n         });\n+\n+        let parent_node = self.parent_node;\n+        self.parent_node = pat.id;\n         visit::walk_pat(self, pat);\n+        self.parent_node = parent_node;\n     }\n \n     fn visit_expr(&mut self, expr: &'ast Expr) {\n         self.insert(expr.id, NodeExpr(expr));\n+        let parent_node = self.parent_node;\n+        self.parent_node = expr.id;\n         visit::walk_expr(self, expr);\n+        self.parent_node = parent_node;\n     }\n \n     fn visit_stmt(&mut self, stmt: &'ast Stmt) {\n-        self.insert(ast_util::stmt_id(stmt), NodeStmt(stmt));\n+        let id = ast_util::stmt_id(stmt);\n+        self.insert(id, NodeStmt(stmt));\n+        let parent_node = self.parent_node;\n+        self.parent_node = id;\n         visit::walk_stmt(self, stmt);\n+        self.parent_node = parent_node;\n     }\n \n     fn visit_fn(&mut self, fk: visit::FnKind<'ast>, fd: &'ast FnDecl,\n-                b: &'ast Block, s: Span, _: NodeId) {\n+                b: &'ast Block, s: Span, id: NodeId) {\n+        let parent_node = self.parent_node;\n+        self.parent_node = id;\n         self.visit_fn_decl(fd);\n         visit::walk_fn(self, fk, fd, b, s);\n+        self.parent_node = parent_node;\n     }\n \n     fn visit_ty(&mut self, ty: &'ast Ty) {\n+        let parent_node = self.parent_node;\n+        self.parent_node = ty.id;\n         match ty.node {\n             TyBareFn(ref fd) => {\n                 self.visit_fn_decl(&*fd.decl);\n             }\n             _ => {}\n         }\n         visit::walk_ty(self, ty);\n+        self.parent_node = parent_node;\n     }\n \n     fn visit_block(&mut self, block: &'ast Block) {\n         self.insert(block.id, NodeBlock(block));\n+        let parent_node = self.parent_node;\n+        self.parent_node = block.id;\n         visit::walk_block(self, block);\n+        self.parent_node = parent_node;\n     }\n \n     fn visit_lifetime_ref(&mut self, lifetime: &'ast Lifetime) {\n@@ -809,7 +910,7 @@ pub fn map_crate<'ast, F: FoldOps>(forest: &'ast mut Forest, fold_ops: F) -> Map\n \n     let mut collector = NodeCollector {\n         map: vec![],\n-        parent: CRATE_NODE_ID\n+        parent_node: CRATE_NODE_ID,\n     };\n     collector.insert_entry(CRATE_NODE_ID, RootCrate);\n     visit::walk_crate(&mut collector, &forest.krate);\n@@ -864,11 +965,11 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n         ii: ii\n     });\n \n+    let ii_parent_id = fld.new_id(DUMMY_NODE_ID);\n     let mut collector = NodeCollector {\n         map: mem::replace(&mut *map.map.borrow_mut(), vec![]),\n-        parent: fld.new_id(DUMMY_NODE_ID)\n+        parent_node: ii_parent_id,\n     };\n-    let ii_parent_id = collector.parent;\n     collector.insert_entry(ii_parent_id, RootInlinedParent(ii_parent));\n     visit::walk_inlined_item(&mut collector, &ii_parent.ii);\n "}, {"sha": "9d66e99df3057fd82265ab4f1ca9694812be2b8d", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1768b1090a844a0833250d408ca32e871ea0b16c/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1768b1090a844a0833250d408ca32e871ea0b16c/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=1768b1090a844a0833250d408ca32e871ea0b16c", "patch": "@@ -172,7 +172,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     qualname: qualname,\n                     declaration: None,\n                     span: sub_span.unwrap(),\n-                    scope: self.tcx.map.get_parent(item.id),\n+                    scope: self.tcx.map.get_enclosing_scope(item.id).unwrap_or(0),\n                 })\n             }\n             ast::ItemStatic(ref typ, mt, ref expr) => {\n@@ -191,7 +191,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     name: get_ident(item.ident).to_string(),\n                     qualname: qualname,\n                     span: sub_span.unwrap(),\n-                    scope: self.tcx.map.get_parent(item.id),\n+                    scope: self.tcx.map.get_enclosing_scope(item.id).unwrap_or(0),\n                     value: value,\n                     type_value: ty_to_string(&typ),\n                 })\n@@ -205,7 +205,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     name: get_ident(item.ident).to_string(),\n                     qualname: qualname,\n                     span: sub_span.unwrap(),\n-                    scope: self.tcx.map.get_parent(item.id),\n+                    scope: self.tcx.map.get_enclosing_scope(item.id).unwrap_or(0),\n                     value: self.span_utils.snippet(expr.span),\n                     type_value: ty_to_string(&typ),\n                 })\n@@ -223,7 +223,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     name: get_ident(item.ident).to_string(),\n                     qualname: qualname,\n                     span: sub_span.unwrap(),\n-                    scope: self.tcx.map.get_parent(item.id),\n+                    scope: self.tcx.map.get_enclosing_scope(item.id).unwrap_or(0),\n                     filename: filename,\n                 })\n             },\n@@ -237,14 +237,14 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     value: val,\n                     span: sub_span.unwrap(),\n                     qualname: enum_name,\n-                    scope: self.tcx.map.get_parent(item.id),\n+                    scope: self.tcx.map.get_enclosing_scope(item.id).unwrap_or(0),\n                 })\n             },\n             ast::ItemImpl(_, _, _, ref trait_ref, ref typ, _) => {\n                 let mut type_data = None;\n                 let sub_span;\n \n-                let parent = self.tcx.map.get_parent(item.id);\n+                let parent = self.tcx.map.get_enclosing_scope(item.id).unwrap_or(0);\n \n                 match typ.node {\n                     // Common case impl for a struct or something basic.\n@@ -337,7 +337,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                                 return Some(Data::VariableRefData(VariableRefData {\n                                     name: get_ident(ident.node).to_string(),\n                                     span: sub_span.unwrap(),\n-                                    scope: self.tcx.map.get_parent(expr.id),\n+                                    scope: self.tcx.map.get_enclosing_scope(expr.id).unwrap_or(0),\n                                     ref_id: f.id,\n                                 }));\n                             }\n@@ -360,7 +360,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                         let sub_span = self.span_utils.span_for_last_ident(path.span);\n                         Some(Data::TypeRefData(TypeRefData {\n                             span: sub_span.unwrap(),\n-                            scope: self.tcx.map.get_parent(expr.id),\n+                            scope: self.tcx.map.get_enclosing_scope(expr.id).unwrap_or(0),\n                             ref_id: def_id,\n                         }))\n                     }"}]}