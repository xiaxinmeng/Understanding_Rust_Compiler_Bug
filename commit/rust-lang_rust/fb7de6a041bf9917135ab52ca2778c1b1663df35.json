{"sha": "fb7de6a041bf9917135ab52ca2778c1b1663df35", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiN2RlNmEwNDFiZjk5MTcxMzVhYjUyY2EyNzc4YzFiMTY2M2RmMzU=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-01-05T05:01:54Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-01-14T06:55:57Z"}, "message": "rustc_trans: rename CrateContext to CodegenCx.", "tree": {"sha": "569cb00d958b00f82885fef4a3b92a04180a0290", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/569cb00d958b00f82885fef4a3b92a04180a0290"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb7de6a041bf9917135ab52ca2778c1b1663df35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb7de6a041bf9917135ab52ca2778c1b1663df35", "html_url": "https://github.com/rust-lang/rust/commit/fb7de6a041bf9917135ab52ca2778c1b1663df35", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb7de6a041bf9917135ab52ca2778c1b1663df35/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2931af62f0d2dbac3e85dbfca618d54be2ae6b0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a", "html_url": "https://github.com/rust-lang/rust/commit/2931af62f0d2dbac3e85dbfca618d54be2ae6b0a"}], "stats": {"total": 546, "additions": 273, "deletions": 273}, "files": [{"sha": "47e4d748e3f0922afda8edf653ef07a78454d2de", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -12,7 +12,7 @@ use llvm::{self, ValueRef, AttributePlace};\n use base;\n use builder::Builder;\n use common::{ty_fn_sig, C_usize};\n-use context::CrateContext;\n+use context::CodegenCx;\n use cabi_x86;\n use cabi_x86_64;\n use cabi_x86_win64;\n@@ -209,7 +209,7 @@ impl Reg {\n }\n \n impl Reg {\n-    pub fn align(&self, ccx: &CrateContext) -> Align {\n+    pub fn align(&self, ccx: &CodegenCx) -> Align {\n         let dl = ccx.data_layout();\n         match self.kind {\n             RegKind::Integer => {\n@@ -234,7 +234,7 @@ impl Reg {\n         }\n     }\n \n-    pub fn llvm_type(&self, ccx: &CrateContext) -> Type {\n+    pub fn llvm_type(&self, ccx: &CodegenCx) -> Type {\n         match self.kind {\n             RegKind::Integer => Type::ix(ccx, self.size.bits()),\n             RegKind::Float => {\n@@ -276,11 +276,11 @@ impl From<Reg> for Uniform {\n }\n \n impl Uniform {\n-    pub fn align(&self, ccx: &CrateContext) -> Align {\n+    pub fn align(&self, ccx: &CodegenCx) -> Align {\n         self.unit.align(ccx)\n     }\n \n-    pub fn llvm_type(&self, ccx: &CrateContext) -> Type {\n+    pub fn llvm_type(&self, ccx: &CodegenCx) -> Type {\n         let llunit = self.unit.llvm_type(ccx);\n \n         if self.total <= self.unit.size {\n@@ -307,7 +307,7 @@ impl Uniform {\n \n pub trait LayoutExt<'tcx> {\n     fn is_aggregate(&self) -> bool;\n-    fn homogeneous_aggregate<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Option<Reg>;\n+    fn homogeneous_aggregate<'a>(&self, ccx: &CodegenCx<'a, 'tcx>) -> Option<Reg>;\n }\n \n impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n@@ -321,7 +321,7 @@ impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n         }\n     }\n \n-    fn homogeneous_aggregate<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Option<Reg> {\n+    fn homogeneous_aggregate<'a>(&self, ccx: &CodegenCx<'a, 'tcx>) -> Option<Reg> {\n         match self.abi {\n             layout::Abi::Uninhabited => None,\n \n@@ -423,7 +423,7 @@ impl From<Uniform> for CastTarget {\n }\n \n impl CastTarget {\n-    pub fn size(&self, ccx: &CrateContext) -> Size {\n+    pub fn size(&self, ccx: &CodegenCx) -> Size {\n         match *self {\n             CastTarget::Uniform(u) => u.total,\n             CastTarget::Pair(a, b) => {\n@@ -433,7 +433,7 @@ impl CastTarget {\n         }\n     }\n \n-    pub fn align(&self, ccx: &CrateContext) -> Align {\n+    pub fn align(&self, ccx: &CodegenCx) -> Align {\n         match *self {\n             CastTarget::Uniform(u) => u.align(ccx),\n             CastTarget::Pair(a, b) => {\n@@ -444,7 +444,7 @@ impl CastTarget {\n         }\n     }\n \n-    pub fn llvm_type(&self, ccx: &CrateContext) -> Type {\n+    pub fn llvm_type(&self, ccx: &CodegenCx) -> Type {\n         match *self {\n             CastTarget::Uniform(u) => u.llvm_type(ccx),\n             CastTarget::Pair(a, b) => {\n@@ -547,7 +547,7 @@ impl<'a, 'tcx> ArgType<'tcx> {\n \n     /// Get the LLVM type for an place of the original Rust type of\n     /// this argument/return, i.e. the result of `type_of::type_of`.\n-    pub fn memory_ty(&self, ccx: &CrateContext<'a, 'tcx>) -> Type {\n+    pub fn memory_ty(&self, ccx: &CodegenCx<'a, 'tcx>) -> Type {\n         self.layout.llvm_type(ccx)\n     }\n \n@@ -647,23 +647,23 @@ pub struct FnType<'tcx> {\n }\n \n impl<'a, 'tcx> FnType<'tcx> {\n-    pub fn of_instance(ccx: &CrateContext<'a, 'tcx>, instance: &ty::Instance<'tcx>)\n+    pub fn of_instance(ccx: &CodegenCx<'a, 'tcx>, instance: &ty::Instance<'tcx>)\n                        -> Self {\n         let fn_ty = instance.ty(ccx.tcx);\n         let sig = ty_fn_sig(ccx, fn_ty);\n         let sig = ccx.tcx.erase_late_bound_regions_and_normalize(&sig);\n         FnType::new(ccx, sig, &[])\n     }\n \n-    pub fn new(ccx: &CrateContext<'a, 'tcx>,\n+    pub fn new(ccx: &CodegenCx<'a, 'tcx>,\n                sig: ty::FnSig<'tcx>,\n                extra_args: &[Ty<'tcx>]) -> FnType<'tcx> {\n         let mut fn_ty = FnType::unadjusted(ccx, sig, extra_args);\n         fn_ty.adjust_for_abi(ccx, sig.abi);\n         fn_ty\n     }\n \n-    pub fn new_vtable(ccx: &CrateContext<'a, 'tcx>,\n+    pub fn new_vtable(ccx: &CodegenCx<'a, 'tcx>,\n                       sig: ty::FnSig<'tcx>,\n                       extra_args: &[Ty<'tcx>]) -> FnType<'tcx> {\n         let mut fn_ty = FnType::unadjusted(ccx, sig, extra_args);\n@@ -688,7 +688,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n         fn_ty\n     }\n \n-    pub fn unadjusted(ccx: &CrateContext<'a, 'tcx>,\n+    pub fn unadjusted(ccx: &CodegenCx<'a, 'tcx>,\n                       sig: ty::FnSig<'tcx>,\n                       extra_args: &[Ty<'tcx>]) -> FnType<'tcx> {\n         debug!(\"FnType::unadjusted({:?}, {:?})\", sig, extra_args);\n@@ -863,7 +863,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n     }\n \n     fn adjust_for_abi(&mut self,\n-                      ccx: &CrateContext<'a, 'tcx>,\n+                      ccx: &CodegenCx<'a, 'tcx>,\n                       abi: Abi) {\n         if abi == Abi::Unadjusted { return }\n \n@@ -939,7 +939,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n         }\n     }\n \n-    pub fn llvm_type(&self, ccx: &CrateContext<'a, 'tcx>) -> Type {\n+    pub fn llvm_type(&self, ccx: &CodegenCx<'a, 'tcx>) -> Type {\n         let mut llargument_tys = Vec::new();\n \n         let llreturn_ty = match self.ret.mode {"}, {"sha": "fd8bcef924e51ff4ddfedbfda74cfd97c6d9cd17", "filename": "src/librustc_trans/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fasm.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -119,7 +119,7 @@ pub fn trans_inline_asm<'a, 'tcx>(\n     }\n }\n \n-pub fn trans_global_asm<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+pub fn trans_global_asm<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n                                   ga: &hir::GlobalAsm) {\n     let asm = CString::new(ga.asm.as_str().as_bytes()).unwrap();\n     unsafe {"}, {"sha": "8619577560c46ed4d5219a3e25c080939030b17a", "filename": "src/librustc_trans/attributes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fattributes.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -24,7 +24,7 @@ use llvm::AttributePlace::Function;\n use llvm_util;\n pub use syntax::attr::{self, InlineAttr};\n use syntax::ast;\n-use context::CrateContext;\n+use context::CodegenCx;\n \n /// Mark LLVM function to use provided inline heuristic.\n #[inline]\n@@ -67,7 +67,7 @@ pub fn naked(val: ValueRef, is_naked: bool) {\n     Attribute::Naked.toggle_llfn(Function, val, is_naked);\n }\n \n-pub fn set_frame_pointer_elimination(ccx: &CrateContext, llfn: ValueRef) {\n+pub fn set_frame_pointer_elimination(ccx: &CodegenCx, llfn: ValueRef) {\n     // FIXME: #11906: Omitting frame pointers breaks retrieving the value of a\n     // parameter.\n     if ccx.sess().must_not_eliminate_frame_pointers() {\n@@ -77,7 +77,7 @@ pub fn set_frame_pointer_elimination(ccx: &CrateContext, llfn: ValueRef) {\n     }\n }\n \n-pub fn set_probestack(ccx: &CrateContext, llfn: ValueRef) {\n+pub fn set_probestack(ccx: &CodegenCx, llfn: ValueRef) {\n     // Only use stack probes if the target specification indicates that we\n     // should be using stack probes\n     if !ccx.sess().target.target.options.stack_probes {\n@@ -101,7 +101,7 @@ pub fn set_probestack(ccx: &CrateContext, llfn: ValueRef) {\n \n /// Composite function which sets LLVM attributes for function depending on its AST (#[attribute])\n /// attributes.\n-pub fn from_fn_attrs(ccx: &CrateContext, llfn: ValueRef, id: DefId) {\n+pub fn from_fn_attrs(ccx: &CodegenCx, llfn: ValueRef, id: DefId) {\n     use syntax::attr::*;\n     let attrs = ccx.tcx.get_attrs(id);\n     inline(llfn, find_inline_attr(Some(ccx.sess().diagnostic()), &attrs));"}, {"sha": "593c5699245faf723723f518ac4567a9d5f3cdd2", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -59,7 +59,7 @@ use common::{C_bool, C_bytes_in_context, C_i32, C_usize};\n use rustc_mir::monomorphize::collector::{self, MonoItemCollectionMode};\n use common::{self, C_struct_in_context, C_array, val_ty};\n use consts;\n-use context::{self, CrateContext};\n+use context::{self, CodegenCx};\n use debuginfo;\n use declare;\n use meth;\n@@ -94,13 +94,13 @@ pub use rustc_trans_utils::{find_exported_symbols, check_for_rustc_errors_attr};\n pub use rustc_mir::monomorphize::item::linkage_by_name;\n \n pub struct StatRecorder<'a, 'tcx: 'a> {\n-    ccx: &'a CrateContext<'a, 'tcx>,\n+    ccx: &'a CodegenCx<'a, 'tcx>,\n     name: Option<String>,\n     istart: usize,\n }\n \n impl<'a, 'tcx> StatRecorder<'a, 'tcx> {\n-    pub fn new(ccx: &'a CrateContext<'a, 'tcx>, name: String) -> StatRecorder<'a, 'tcx> {\n+    pub fn new(ccx: &'a CodegenCx<'a, 'tcx>, name: String) -> StatRecorder<'a, 'tcx> {\n         let istart = ccx.stats.borrow().n_llvm_insns;\n         StatRecorder {\n             ccx,\n@@ -189,7 +189,7 @@ pub fn compare_simd_types<'a, 'tcx>(\n /// The `old_info` argument is a bit funny. It is intended for use\n /// in an upcast, where the new vtable for an object will be derived\n /// from the old one.\n-pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n+pub fn unsized_info<'ccx, 'tcx>(ccx: &CodegenCx<'ccx, 'tcx>,\n                                 source: Ty<'tcx>,\n                                 target: Ty<'tcx>,\n                                 old_info: Option<ValueRef>)\n@@ -455,7 +455,7 @@ pub fn call_memset<'a, 'tcx>(b: &Builder<'a, 'tcx>,\n     b.call(llintrinsicfn, &[ptr, fill_byte, size, align, volatile], None)\n }\n \n-pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance<'tcx>) {\n+pub fn trans_instance<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, instance: Instance<'tcx>) {\n     let _s = if ccx.sess().trans_stats() {\n         let mut instance_name = String::new();\n         DefPathBasedNames::new(ccx.tcx, true, true)\n@@ -506,7 +506,7 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance\n     mir::trans_mir(ccx, lldecl, &mir, instance, sig);\n }\n \n-pub fn set_link_section(ccx: &CrateContext,\n+pub fn set_link_section(ccx: &CodegenCx,\n                         llval: ValueRef,\n                         attrs: &[ast::Attribute]) {\n     if let Some(sect) = attr::first_attr_value_str_by_name(attrs, \"link_section\") {\n@@ -522,7 +522,7 @@ pub fn set_link_section(ccx: &CrateContext,\n \n /// Create the `main` function which will initialize the rust runtime and call\n /// users main function.\n-fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n+fn maybe_create_entry_wrapper(ccx: &CodegenCx) {\n     let (main_def_id, span) = match *ccx.sess().entry_fn.borrow() {\n         Some((id, span)) => {\n             (ccx.tcx.hir.local_def_id(id), span)\n@@ -547,7 +547,7 @@ fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n         config::EntryNone => {}    // Do nothing.\n     }\n \n-    fn create_entry_fn<'ccx>(ccx: &'ccx CrateContext,\n+    fn create_entry_fn<'ccx>(ccx: &'ccx CodegenCx,\n                        sp: Span,\n                        rust_main: ValueRef,\n                        rust_main_def_id: DefId,\n@@ -1203,7 +1203,7 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    .to_fingerprint().to_hex());\n \n         // Instantiate translation items without filling out definitions yet...\n-        let ccx = CrateContext::new(tcx, cgu, &llmod_id);\n+        let ccx = CodegenCx::new(tcx, cgu, &llmod_id);\n         let module = {\n             let trans_items = ccx.codegen_unit\n                                  .items_in_deterministic_order(ccx.tcx);"}, {"sha": "cbc3f5e0c124c0586ff21f6379ee776bb16efb99", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -32,7 +32,7 @@ use syntax_pos::Span;\n #[must_use]\n pub struct Builder<'a, 'tcx: 'a> {\n     pub llbuilder: BuilderRef,\n-    pub ccx: &'a CrateContext<'a, 'tcx>,\n+    pub ccx: &'a CodegenCx<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> Drop for Builder<'a, 'tcx> {\n@@ -51,7 +51,7 @@ fn noname() -> *const c_char {\n }\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n-    pub fn new_block<'b>(ccx: &'a CrateContext<'a, 'tcx>, llfn: ValueRef, name: &'b str) -> Self {\n+    pub fn new_block<'b>(ccx: &'a CodegenCx<'a, 'tcx>, llfn: ValueRef, name: &'b str) -> Self {\n         let builder = Builder::with_ccx(ccx);\n         let llbb = unsafe {\n             let name = CString::new(name).unwrap();\n@@ -65,7 +65,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         builder\n     }\n \n-    pub fn with_ccx(ccx: &'a CrateContext<'a, 'tcx>) -> Self {\n+    pub fn with_ccx(ccx: &'a CodegenCx<'a, 'tcx>) -> Self {\n         // Create a fresh builder from the crate context.\n         let llbuilder = unsafe {\n             llvm::LLVMCreateBuilderInContext(ccx.llcx)"}, {"sha": "a6f5844711976df71f74b921ceebea596087092a", "filename": "src/librustc_trans/cabi_aarch64.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fcabi_aarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fcabi_aarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_aarch64.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -9,9 +9,9 @@\n // except according to those terms.\n \n use abi::{FnType, ArgType, LayoutExt, Reg, RegKind, Uniform};\n-use context::CrateContext;\n+use context::CodegenCx;\n \n-fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n+fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n                                      -> Option<Uniform> {\n     arg.layout.homogeneous_aggregate(ccx).and_then(|unit| {\n         let size = arg.layout.size;\n@@ -38,7 +38,7 @@ fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut Ar\n     })\n }\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n         return;\n@@ -69,7 +69,7 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n     ret.make_indirect();\n }\n \n-fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+fn classify_arg_ty<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n     if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(32);\n         return;\n@@ -100,7 +100,7 @@ fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tc\n     arg.make_indirect();\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(ccx, &mut fty.ret);\n     }"}, {"sha": "ca53918ddec815a467659be607a4b76dfce16fb1", "filename": "src/librustc_trans/cabi_arm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_arm.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n use abi::{FnType, ArgType, LayoutExt, Reg, RegKind, Uniform};\n-use context::CrateContext;\n+use context::CodegenCx;\n use llvm::CallConv;\n \n-fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n+fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n                                      -> Option<Uniform> {\n     arg.layout.homogeneous_aggregate(ccx).and_then(|unit| {\n         let size = arg.layout.size;\n@@ -39,7 +39,7 @@ fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut Ar\n     })\n }\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>, vfp: bool) {\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>, vfp: bool) {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n         return;\n@@ -71,7 +71,7 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n     ret.make_indirect();\n }\n \n-fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>, vfp: bool) {\n+fn classify_arg_ty<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>, vfp: bool) {\n     if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(32);\n         return;\n@@ -92,7 +92,7 @@ fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tc\n     });\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     // If this is a target with a hard-float ABI, and the function is not explicitly\n     // `extern \"aapcs\"`, then we must use the VFP registers for homogeneous aggregates.\n     let vfp = ccx.sess().target.target.llvm_target.ends_with(\"hf\")"}, {"sha": "4f966cf450c2ed04b73fbb7240a4cecb2efd2a7a", "filename": "src/librustc_trans/cabi_asmjs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fcabi_asmjs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fcabi_asmjs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_asmjs.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -9,14 +9,14 @@\n // except according to those terms.\n \n use abi::{FnType, ArgType, LayoutExt, Uniform};\n-use context::CrateContext;\n+use context::CodegenCx;\n \n // Data layout: e-p:32:32-i64:64-v128:32:128-n32-S128\n \n // See the https://github.com/kripken/emscripten-fastcomp-clang repository.\n // The class `EmscriptenABIInfo` in `/lib/CodeGen/TargetInfo.cpp` contains the ABI definitions.\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n     if ret.layout.is_aggregate() {\n         if let Some(unit) = ret.layout.homogeneous_aggregate(ccx) {\n             let size = ret.layout.size;\n@@ -39,7 +39,7 @@ fn classify_arg_ty(arg: &mut ArgType) {\n     }\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(ccx, &mut fty.ret);\n     }"}, {"sha": "3cba9aeb7a85a17de32ecd4a3e286535ff428752", "filename": "src/librustc_trans/cabi_mips.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_mips.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n use abi::{ArgType, FnType, LayoutExt, Reg, Uniform};\n-use context::CrateContext;\n+use context::CodegenCx;\n \n use rustc::ty::layout::Size;\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n                              ret: &mut ArgType<'tcx>,\n                              offset: &mut Size) {\n     if !ret.layout.is_aggregate() {\n@@ -24,7 +24,7 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut Size) {\n+fn classify_arg_ty(ccx: &CodegenCx, arg: &mut ArgType, offset: &mut Size) {\n     let dl = &ccx.tcx.data_layout;\n     let size = arg.layout.size;\n     let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align);\n@@ -44,7 +44,7 @@ fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut Size) {\n     *offset = offset.abi_align(align) + size.abi_align(align);\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     let mut offset = Size::from_bytes(0);\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(ccx, &mut fty.ret, &mut offset);"}, {"sha": "332412900de75bce74c1976be7a5a5390027a436", "filename": "src/librustc_trans/cabi_mips64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fcabi_mips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fcabi_mips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_mips64.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n use abi::{ArgType, FnType, LayoutExt, Reg, Uniform};\n-use context::CrateContext;\n+use context::CodegenCx;\n \n use rustc::ty::layout::Size;\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n                              ret: &mut ArgType<'tcx>,\n                              offset: &mut Size) {\n     if !ret.layout.is_aggregate() {\n@@ -24,7 +24,7 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut Size) {\n+fn classify_arg_ty(ccx: &CodegenCx, arg: &mut ArgType, offset: &mut Size) {\n     let dl = &ccx.tcx.data_layout;\n     let size = arg.layout.size;\n     let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align);\n@@ -44,7 +44,7 @@ fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut Size) {\n     *offset = offset.abi_align(align) + size.abi_align(align);\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     let mut offset = Size::from_bytes(0);\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(ccx, &mut fty.ret, &mut offset);"}, {"sha": "e8360544a3019f4518adc905ff01a06ab72e365c", "filename": "src/librustc_trans/cabi_powerpc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fcabi_powerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fcabi_powerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_powerpc.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n use abi::{ArgType, FnType, LayoutExt, Reg, Uniform};\n-use context::CrateContext;\n+use context::CodegenCx;\n \n use rustc::ty::layout::Size;\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n                              ret: &mut ArgType<'tcx>,\n                              offset: &mut Size) {\n     if !ret.layout.is_aggregate() {\n@@ -24,7 +24,7 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut Size) {\n+fn classify_arg_ty(ccx: &CodegenCx, arg: &mut ArgType, offset: &mut Size) {\n     let dl = &ccx.tcx.data_layout;\n     let size = arg.layout.size;\n     let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align);\n@@ -44,7 +44,7 @@ fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut Size) {\n     *offset = offset.abi_align(align) + size.abi_align(align);\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     let mut offset = Size::from_bytes(0);\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(ccx, &mut fty.ret, &mut offset);"}, {"sha": "8012017f8fd7d7e56b067cf3421cffd8cd932bc8", "filename": "src/librustc_trans/cabi_powerpc64.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fcabi_powerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fcabi_powerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_powerpc64.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -13,7 +13,7 @@\n // need to be fixed when PowerPC vector support is added.\n \n use abi::{FnType, ArgType, LayoutExt, Reg, RegKind, Uniform};\n-use context::CrateContext;\n+use context::CodegenCx;\n use rustc::ty::layout;\n \n #[derive(Debug, Clone, Copy, PartialEq)]\n@@ -23,7 +23,7 @@ enum ABI {\n }\n use self::ABI::*;\n \n-fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n                                       arg: &mut ArgType<'tcx>,\n                                       abi: ABI)\n                                      -> Option<Uniform> {\n@@ -52,7 +52,7 @@ fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     })\n }\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>, abi: ABI) {\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>, abi: ABI) {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(64);\n         return;\n@@ -92,7 +92,7 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n     ret.make_indirect();\n }\n \n-fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>, abi: ABI) {\n+fn classify_arg_ty<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>, abi: ABI) {\n     if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(64);\n         return;\n@@ -128,7 +128,7 @@ fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tc\n     });\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     let abi = match ccx.sess().target.target.target_endian.as_str() {\n         \"big\" => ELFv1,\n         \"little\" => ELFv2,"}, {"sha": "b9db1a9c0aa6e1e761260b1281d26e184f452ac2", "filename": "src/librustc_trans/cabi_s390x.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fcabi_s390x.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fcabi_s390x.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_s390x.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -12,7 +12,7 @@\n // for a pre-z13 machine or using -mno-vx.\n \n use abi::{FnType, ArgType, LayoutExt, Reg};\n-use context::CrateContext;\n+use context::CodegenCx;\n \n use rustc::ty::layout::{self, TyLayout};\n \n@@ -24,7 +24,7 @@ fn classify_ret_ty(ret: &mut ArgType) {\n     }\n }\n \n-fn is_single_fp_element<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+fn is_single_fp_element<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n                                   layout: TyLayout<'tcx>) -> bool {\n     match layout.abi {\n         layout::Abi::Scalar(ref scalar) => {\n@@ -44,7 +44,7 @@ fn is_single_fp_element<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+fn classify_arg_ty<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n     if !arg.layout.is_aggregate() && arg.layout.size.bits() <= 64 {\n         arg.extend_integer_width_to(64);\n         return;\n@@ -67,7 +67,7 @@ fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tc\n     }\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(&mut fty.ret);\n     }"}, {"sha": "3cba9aeb7a85a17de32ecd4a3e286535ff428752", "filename": "src/librustc_trans/cabi_sparc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fcabi_sparc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fcabi_sparc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_sparc.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n use abi::{ArgType, FnType, LayoutExt, Reg, Uniform};\n-use context::CrateContext;\n+use context::CodegenCx;\n \n use rustc::ty::layout::Size;\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n                              ret: &mut ArgType<'tcx>,\n                              offset: &mut Size) {\n     if !ret.layout.is_aggregate() {\n@@ -24,7 +24,7 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut Size) {\n+fn classify_arg_ty(ccx: &CodegenCx, arg: &mut ArgType, offset: &mut Size) {\n     let dl = &ccx.tcx.data_layout;\n     let size = arg.layout.size;\n     let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align);\n@@ -44,7 +44,7 @@ fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut Size) {\n     *offset = offset.abi_align(align) + size.abi_align(align);\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     let mut offset = Size::from_bytes(0);\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(ccx, &mut fty.ret, &mut offset);"}, {"sha": "c7bef67eba9c18917439ea51659eca155bcf9975", "filename": "src/librustc_trans/cabi_sparc64.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fcabi_sparc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fcabi_sparc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_sparc64.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -11,9 +11,9 @@\n // FIXME: This needs an audit for correctness and completeness.\n \n use abi::{FnType, ArgType, LayoutExt, Reg, RegKind, Uniform};\n-use context::CrateContext;\n+use context::CodegenCx;\n \n-fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n+fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n                                      -> Option<Uniform> {\n     arg.layout.homogeneous_aggregate(ccx).and_then(|unit| {\n         // Ensure we have at most eight uniquely addressable members.\n@@ -38,7 +38,7 @@ fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut Ar\n     })\n }\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(64);\n         return;\n@@ -72,7 +72,7 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n     ret.make_indirect();\n }\n \n-fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+fn classify_arg_ty<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n     if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(64);\n         return;\n@@ -90,7 +90,7 @@ fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tc\n     });\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(ccx, &mut fty.ret);\n     }"}, {"sha": "54131ecb5da63206f46d7b42b73d3df0ef21c092", "filename": "src/librustc_trans/cabi_x86.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use abi::{ArgAttribute, FnType, LayoutExt, PassMode, Reg, RegKind};\n-use common::CrateContext;\n+use common::CodegenCx;\n \n use rustc::ty::layout::{self, TyLayout};\n \n@@ -19,7 +19,7 @@ pub enum Flavor {\n     Fastcall\n }\n \n-fn is_single_fp_element<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+fn is_single_fp_element<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n                                   layout: TyLayout<'tcx>) -> bool {\n     match layout.abi {\n         layout::Abi::Scalar(ref scalar) => {\n@@ -39,7 +39,7 @@ fn is_single_fp_element<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n                                   fty: &mut FnType<'tcx>,\n                                   flavor: Flavor) {\n     if !fty.ret.is_ignore() {"}, {"sha": "50fb37424639fbdc4655ef42dbdf1b5bde61f035", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -12,7 +12,7 @@\n // https://github.com/jckarter/clay/blob/master/compiler/src/externals.cpp\n \n use abi::{ArgType, CastTarget, FnType, LayoutExt, Reg, RegKind};\n-use context::CrateContext;\n+use context::CodegenCx;\n \n use rustc::ty::layout::{self, TyLayout, Size};\n \n@@ -31,7 +31,7 @@ struct Memory;\n const LARGEST_VECTOR_SIZE: usize = 512;\n const MAX_EIGHTBYTES: usize = LARGEST_VECTOR_SIZE / 64;\n \n-fn classify_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &ArgType<'tcx>)\n+fn classify_arg<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, arg: &ArgType<'tcx>)\n                           -> Result<[Class; MAX_EIGHTBYTES], Memory> {\n     fn unify(cls: &mut [Class],\n              off: Size,\n@@ -52,7 +52,7 @@ fn classify_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &ArgType<'tcx>)\n         cls[i] = to_write;\n     }\n \n-    fn classify<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+    fn classify<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n                           layout: TyLayout<'tcx>,\n                           cls: &mut [Class],\n                           off: Size)\n@@ -189,7 +189,7 @@ fn cast_target(cls: &[Class], size: Size) -> CastTarget {\n     target\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     let mut int_regs = 6; // RDI, RSI, RDX, RCX, R8, R9\n     let mut sse_regs = 8; // XMM0-7\n "}, {"sha": "ad2f69213e1899ceb7401d7aea68f4be43313dda", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -15,7 +15,7 @@\n //! closure.\n \n use attributes;\n-use common::{self, CrateContext};\n+use common::{self, CodegenCx};\n use consts;\n use declare;\n use llvm::{self, ValueRef};\n@@ -36,7 +36,7 @@ use rustc_back::PanicStrategy;\n ///\n /// - `ccx`: the crate context\n /// - `instance`: the instance to be instantiated\n-pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+pub fn get_fn<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n                         instance: Instance<'tcx>)\n                         -> ValueRef\n {\n@@ -176,7 +176,7 @@ pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     llfn\n }\n \n-pub fn resolve_and_get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+pub fn resolve_and_get_fn<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n                                     def_id: DefId,\n                                     substs: &'tcx Substs<'tcx>)\n                                     -> ValueRef"}, {"sha": "8f294da860900ea9e0b47bac11928517187d998f", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -38,7 +38,7 @@ use syntax::abi::Abi;\n use syntax::symbol::InternedString;\n use syntax_pos::{Span, DUMMY_SP};\n \n-pub use context::CrateContext;\n+pub use context::CodegenCx;\n \n pub fn type_needs_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n     ty.needs_drop(tcx, ty::ParamEnv::empty(traits::Reveal::All))\n@@ -152,23 +152,23 @@ pub fn C_uint_big(t: Type, u: u128) -> ValueRef {\n     }\n }\n \n-pub fn C_bool(ccx: &CrateContext, val: bool) -> ValueRef {\n+pub fn C_bool(ccx: &CodegenCx, val: bool) -> ValueRef {\n     C_uint(Type::i1(ccx), val as u64)\n }\n \n-pub fn C_i32(ccx: &CrateContext, i: i32) -> ValueRef {\n+pub fn C_i32(ccx: &CodegenCx, i: i32) -> ValueRef {\n     C_int(Type::i32(ccx), i as i64)\n }\n \n-pub fn C_u32(ccx: &CrateContext, i: u32) -> ValueRef {\n+pub fn C_u32(ccx: &CodegenCx, i: u32) -> ValueRef {\n     C_uint(Type::i32(ccx), i as u64)\n }\n \n-pub fn C_u64(ccx: &CrateContext, i: u64) -> ValueRef {\n+pub fn C_u64(ccx: &CodegenCx, i: u64) -> ValueRef {\n     C_uint(Type::i64(ccx), i)\n }\n \n-pub fn C_usize(ccx: &CrateContext, i: u64) -> ValueRef {\n+pub fn C_usize(ccx: &CodegenCx, i: u64) -> ValueRef {\n     let bit_size = ccx.data_layout().pointer_size.bits();\n     if bit_size < 64 {\n         // make sure it doesn't overflow\n@@ -178,14 +178,14 @@ pub fn C_usize(ccx: &CrateContext, i: u64) -> ValueRef {\n     C_uint(ccx.isize_ty, i)\n }\n \n-pub fn C_u8(ccx: &CrateContext, i: u8) -> ValueRef {\n+pub fn C_u8(ccx: &CodegenCx, i: u8) -> ValueRef {\n     C_uint(Type::i8(ccx), i as u64)\n }\n \n \n // This is a 'c-like' raw string, which differs from\n // our boxed-and-length-annotated strings.\n-pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> ValueRef {\n+pub fn C_cstr(cx: &CodegenCx, s: InternedString, null_terminated: bool) -> ValueRef {\n     unsafe {\n         if let Some(&llval) = cx.const_cstr_cache.borrow().get(&s) {\n             return llval;\n@@ -210,20 +210,20 @@ pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> Va\n \n // NB: Do not use `do_spill_noroot` to make this into a constant string, or\n // you will be kicked off fast isel. See issue #4352 for an example of this.\n-pub fn C_str_slice(cx: &CrateContext, s: InternedString) -> ValueRef {\n+pub fn C_str_slice(cx: &CodegenCx, s: InternedString) -> ValueRef {\n     let len = s.len();\n     let cs = consts::ptrcast(C_cstr(cx, s, false),\n         cx.layout_of(cx.tcx.mk_str()).llvm_type(cx).ptr_to());\n     C_fat_ptr(cx, cs, C_usize(cx, len as u64))\n }\n \n-pub fn C_fat_ptr(cx: &CrateContext, ptr: ValueRef, meta: ValueRef) -> ValueRef {\n+pub fn C_fat_ptr(cx: &CodegenCx, ptr: ValueRef, meta: ValueRef) -> ValueRef {\n     assert_eq!(abi::FAT_PTR_ADDR, 0);\n     assert_eq!(abi::FAT_PTR_EXTRA, 1);\n     C_struct(cx, &[ptr, meta], false)\n }\n \n-pub fn C_struct(cx: &CrateContext, elts: &[ValueRef], packed: bool) -> ValueRef {\n+pub fn C_struct(cx: &CodegenCx, elts: &[ValueRef], packed: bool) -> ValueRef {\n     C_struct_in_context(cx.llcx, elts, packed)\n }\n \n@@ -247,7 +247,7 @@ pub fn C_vector(elts: &[ValueRef]) -> ValueRef {\n     }\n }\n \n-pub fn C_bytes(cx: &CrateContext, bytes: &[u8]) -> ValueRef {\n+pub fn C_bytes(cx: &CodegenCx, bytes: &[u8]) -> ValueRef {\n     C_bytes_in_context(cx.llcx, bytes)\n }\n \n@@ -382,7 +382,7 @@ pub fn shift_mask_val<'a, 'tcx>(\n     }\n }\n \n-pub fn ty_fn_sig<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+pub fn ty_fn_sig<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n                            ty: Ty<'tcx>)\n                            -> ty::PolyFnSig<'tcx>\n {"}, {"sha": "d86f68c84b7b660f5380808a5c6c53a89774f230", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -17,7 +17,7 @@ use rustc::middle::const_val::ConstEvalErr;\n use debuginfo;\n use base;\n use monomorphize::{MonoItem, MonoItemExt};\n-use common::{CrateContext, val_ty};\n+use common::{CodegenCx, val_ty};\n use declare;\n use monomorphize::Instance;\n use type_::Type;\n@@ -43,7 +43,7 @@ pub fn bitcast(val: ValueRef, ty: Type) -> ValueRef {\n     }\n }\n \n-fn set_global_alignment(ccx: &CrateContext,\n+fn set_global_alignment(ccx: &CodegenCx,\n                         gv: ValueRef,\n                         mut align: Align) {\n     // The target may require greater alignment for globals than the type does.\n@@ -62,7 +62,7 @@ fn set_global_alignment(ccx: &CrateContext,\n     }\n }\n \n-pub fn addr_of_mut(ccx: &CrateContext,\n+pub fn addr_of_mut(ccx: &CodegenCx,\n                    cv: ValueRef,\n                    align: Align,\n                    kind: &str)\n@@ -80,7 +80,7 @@ pub fn addr_of_mut(ccx: &CrateContext,\n     }\n }\n \n-pub fn addr_of(ccx: &CrateContext,\n+pub fn addr_of(ccx: &CodegenCx,\n                cv: ValueRef,\n                align: Align,\n                kind: &str)\n@@ -104,7 +104,7 @@ pub fn addr_of(ccx: &CrateContext,\n     gv\n }\n \n-pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n+pub fn get_static(ccx: &CodegenCx, def_id: DefId) -> ValueRef {\n     let instance = Instance::mono(ccx.tcx, def_id);\n     if let Some(&g) = ccx.instances.borrow().get(&instance) {\n         return g;\n@@ -244,7 +244,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n     g\n }\n \n-pub fn trans_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+pub fn trans_static<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n                               m: hir::Mutability,\n                               id: ast::NodeId,\n                               attrs: &[ast::Attribute])"}, {"sha": "2530ac3d231c84061a873002de13cf5ff67b29b4", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -42,10 +42,10 @@ use std::sync::Arc;\n use syntax::symbol::InternedString;\n use abi::Abi;\n \n-/// There is one `CrateContext` per compilation unit. Each one has its own LLVM\n+/// There is one `CodegenCx` per compilation unit. Each one has its own LLVM\n /// `ContextRef` so that several compilation units may be optimized in parallel.\n-/// All other LLVM data structures in the `CrateContext` are tied to that `ContextRef`.\n-pub struct CrateContext<'a, 'tcx: 'a> {\n+/// All other LLVM data structures in the `CodegenCx` are tied to that `ContextRef`.\n+pub struct CodegenCx<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pub check_overflow: bool,\n     pub use_dll_storage_attrs: bool,\n@@ -107,7 +107,7 @@ pub struct CrateContext<'a, 'tcx: 'a> {\n     local_gen_sym_counter: Cell<usize>,\n }\n \n-impl<'a, 'tcx> DepGraphSafe for CrateContext<'a, 'tcx> {\n+impl<'a, 'tcx> DepGraphSafe for CodegenCx<'a, 'tcx> {\n }\n \n pub fn get_reloc_model(sess: &Session) -> llvm::RelocMode {\n@@ -212,11 +212,11 @@ pub unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (Cont\n     (llcx, llmod)\n }\n \n-impl<'a, 'tcx> CrateContext<'a, 'tcx> {\n+impl<'a, 'tcx> CodegenCx<'a, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                codegen_unit: Arc<CodegenUnit<'tcx>>,\n                llmod_id: &str)\n-               -> CrateContext<'a, 'tcx> {\n+               -> CodegenCx<'a, 'tcx> {\n         // An interesting part of Windows which MSVC forces our hand on (and\n         // apparently MinGW didn't) is the usage of `dllimport` and `dllexport`\n         // attributes in LLVM IR as well as native dependencies (in C these\n@@ -280,7 +280,7 @@ impl<'a, 'tcx> CrateContext<'a, 'tcx> {\n                 None\n             };\n \n-            let mut ccx = CrateContext {\n+            let mut ccx = CodegenCx {\n                 tcx,\n                 check_overflow,\n                 use_dll_storage_attrs,\n@@ -318,7 +318,7 @@ impl<'a, 'tcx> CrateContext<'a, 'tcx> {\n     }\n }\n \n-impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n+impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n     pub fn sess<'a>(&'a self) -> &'a Session {\n         &self.tcx.sess\n     }\n@@ -448,19 +448,19 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> ty::layout::HasDataLayout for &'a CrateContext<'a, 'tcx> {\n+impl<'a, 'tcx> ty::layout::HasDataLayout for &'a CodegenCx<'a, 'tcx> {\n     fn data_layout(&self) -> &ty::layout::TargetDataLayout {\n         &self.tcx.data_layout\n     }\n }\n \n-impl<'a, 'tcx> ty::layout::HasTyCtxt<'tcx> for &'a CrateContext<'a, 'tcx> {\n+impl<'a, 'tcx> ty::layout::HasTyCtxt<'tcx> for &'a CodegenCx<'a, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n         self.tcx\n     }\n }\n \n-impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for &'a CrateContext<'a, 'tcx> {\n+impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for &'a CodegenCx<'a, 'tcx> {\n     type TyLayout = TyLayout<'tcx>;\n \n     fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n@@ -474,7 +474,7 @@ impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for &'a CrateContext<'a, 'tcx> {\n }\n \n /// Declare any llvm intrinsics that you might need\n-fn declare_intrinsic(ccx: &CrateContext, key: &str) -> Option<ValueRef> {\n+fn declare_intrinsic(ccx: &CodegenCx, key: &str) -> Option<ValueRef> {\n     macro_rules! ifn {\n         ($name:expr, fn() -> $ret:expr) => (\n             if key == $name {"}, {"sha": "36131d687aead48e35b0faf761eeb07c7394026e", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -14,7 +14,7 @@ use super::utils::{DIB, span_start};\n \n use llvm;\n use llvm::debuginfo::DIScope;\n-use common::CrateContext;\n+use common::CodegenCx;\n use rustc::mir::{Mir, VisibilityScope};\n \n use libc::c_uint;\n@@ -44,7 +44,7 @@ impl MirDebugScope {\n \n /// Produce DIScope DIEs for each MIR Scope which has variables defined in it.\n /// If debuginfo is disabled, the returned vector is empty.\n-pub fn create_mir_scopes(ccx: &CrateContext, mir: &Mir, debug_context: &FunctionDebugContext)\n+pub fn create_mir_scopes(ccx: &CodegenCx, mir: &Mir, debug_context: &FunctionDebugContext)\n     -> IndexVec<VisibilityScope, MirDebugScope> {\n     let null_scope = MirDebugScope {\n         scope_metadata: ptr::null_mut(),\n@@ -77,7 +77,7 @@ pub fn create_mir_scopes(ccx: &CrateContext, mir: &Mir, debug_context: &Function\n     scopes\n }\n \n-fn make_mir_scope(ccx: &CrateContext,\n+fn make_mir_scope(ccx: &CodegenCx,\n                   mir: &Mir,\n                   has_variables: &BitVector,\n                   debug_context: &FunctionDebugContextData,"}, {"sha": "2dea6b9dabe10b7702dd3418145176c0ccd56fc3", "filename": "src/librustc_trans/debuginfo/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fdebuginfo%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fdebuginfo%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fdoc.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -44,7 +44,7 @@\n //! that exact file path.\n //!\n //! All private state used by the module is stored within either the\n-//! CrateDebugContext struct (owned by the CrateContext) or the\n+//! CrateDebugContext struct (owned by the CodegenCx) or the\n //! FunctionDebugContext (owned by the MirContext).\n //!\n //! This file consists of three conceptual sections:"}, {"sha": "53d9c638197c3cf8429cf74b9f827057c222597d", "filename": "src/librustc_trans/debuginfo/gdb.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fgdb.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -12,7 +12,7 @@\n \n use llvm;\n \n-use common::{C_bytes, CrateContext, C_i32};\n+use common::{C_bytes, CodegenCx, C_i32};\n use builder::Builder;\n use declare;\n use type_::Type;\n@@ -24,7 +24,7 @@ use syntax::attr;\n \n /// Inserts a side-effect free instruction sequence that makes sure that the\n /// .debug_gdb_scripts global is referenced, so it isn't removed by the linker.\n-pub fn insert_reference_to_gdb_debug_scripts_section_global(ccx: &CrateContext, builder: &Builder) {\n+pub fn insert_reference_to_gdb_debug_scripts_section_global(ccx: &CodegenCx, builder: &Builder) {\n     if needs_gdb_debug_scripts_section(ccx) {\n         let gdb_debug_scripts_section_global = get_or_insert_gdb_debug_scripts_section_global(ccx);\n         // Load just the first byte as that's all that's necessary to force\n@@ -40,7 +40,7 @@ pub fn insert_reference_to_gdb_debug_scripts_section_global(ccx: &CrateContext,\n \n /// Allocates the global variable responsible for the .debug_gdb_scripts binary\n /// section.\n-pub fn get_or_insert_gdb_debug_scripts_section_global(ccx: &CrateContext)\n+pub fn get_or_insert_gdb_debug_scripts_section_global(ccx: &CodegenCx)\n                                                   -> llvm::ValueRef {\n     let c_section_var_name = \"__rustc_debug_gdb_scripts_section__\\0\";\n     let section_var_name = &c_section_var_name[..c_section_var_name.len()-1];\n@@ -77,7 +77,7 @@ pub fn get_or_insert_gdb_debug_scripts_section_global(ccx: &CrateContext)\n     }\n }\n \n-pub fn needs_gdb_debug_scripts_section(ccx: &CrateContext) -> bool {\n+pub fn needs_gdb_debug_scripts_section(ccx: &CodegenCx) -> bool {\n     let omit_gdb_pretty_printer_section =\n         attr::contains_name(&ccx.tcx.hir.krate_attrs(),\n                             \"omit_gdb_pretty_printer_section\");"}, {"sha": "e3e4e1414fc952c500b7f26531f77794d98212eb", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -29,7 +29,7 @@ use rustc::ty::fold::TypeVisitor;\n use rustc::ty::util::TypeIdHasher;\n use rustc::ich::Fingerprint;\n use rustc::ty::Instance;\n-use common::CrateContext;\n+use common::CodegenCx;\n use rustc::ty::{self, AdtKind, Ty, TyCtxt};\n use rustc::ty::layout::{self, Align, LayoutOf, Size, TyLayout};\n use rustc::session::config;\n@@ -133,7 +133,7 @@ impl<'tcx> TypeMap<'tcx> {\n     // Get the UniqueTypeId for the given type. If the UniqueTypeId for the given\n     // type has been requested before, this is just a table lookup. Otherwise an\n     // ID will be generated and stored for later lookup.\n-    fn get_unique_type_id_of_type<'a>(&mut self, cx: &CrateContext<'a, 'tcx>,\n+    fn get_unique_type_id_of_type<'a>(&mut self, cx: &CodegenCx<'a, 'tcx>,\n                                       type_: Ty<'tcx>) -> UniqueTypeId {\n         // Let's see if we already have something in the cache\n         match self.type_to_unique_id.get(&type_).cloned() {\n@@ -157,7 +157,7 @@ impl<'tcx> TypeMap<'tcx> {\n     // types of their own, so they need special handling. We still need a\n     // UniqueTypeId for them, since to debuginfo they *are* real types.\n     fn get_unique_type_id_of_enum_variant<'a>(&mut self,\n-                                              cx: &CrateContext<'a, 'tcx>,\n+                                              cx: &CodegenCx<'a, 'tcx>,\n                                               enum_type: Ty<'tcx>,\n                                               variant_name: &str)\n                                               -> UniqueTypeId {\n@@ -186,7 +186,7 @@ enum RecursiveTypeDescription<'tcx> {\n }\n \n fn create_and_register_recursive_type_forward_declaration<'a, 'tcx>(\n-    cx: &CrateContext<'a, 'tcx>,\n+    cx: &CodegenCx<'a, 'tcx>,\n     unfinished_type: Ty<'tcx>,\n     unique_type_id: UniqueTypeId,\n     metadata_stub: DICompositeType,\n@@ -210,7 +210,7 @@ impl<'tcx> RecursiveTypeDescription<'tcx> {\n     // Finishes up the description of the type in question (mostly by providing\n     // descriptions of the fields of the given type) and returns the final type\n     // metadata.\n-    fn finalize<'a>(&self, cx: &CrateContext<'a, 'tcx>) -> MetadataCreationResult {\n+    fn finalize<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> MetadataCreationResult {\n         match *self {\n             FinalMetadata(metadata) => MetadataCreationResult::new(metadata, false),\n             UnfinishedMetadata {\n@@ -262,7 +262,7 @@ macro_rules! return_if_metadata_created_in_meantime {\n     )\n }\n \n-fn fixed_vec_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+fn fixed_vec_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                 unique_type_id: UniqueTypeId,\n                                 array_or_slice_type: Ty<'tcx>,\n                                 element_type: Ty<'tcx>,\n@@ -298,7 +298,7 @@ fn fixed_vec_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     return MetadataCreationResult::new(metadata, false);\n }\n \n-fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+fn vec_slice_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                 slice_ptr_type: Ty<'tcx>,\n                                 element_type: Ty<'tcx>,\n                                 unique_type_id: UniqueTypeId,\n@@ -347,7 +347,7 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     MetadataCreationResult::new(metadata, false)\n }\n \n-fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+fn subroutine_type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                       unique_type_id: UniqueTypeId,\n                                       signature: ty::PolyFnSig<'tcx>,\n                                       span: Span)\n@@ -386,7 +386,7 @@ fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n // trait_type should be the actual trait (e.g., Trait). Where the trait is part\n // of a DST struct, there is no trait_object_type and the results of this\n // function will be a little bit weird.\n-fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+fn trait_pointer_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                     trait_type: Ty<'tcx>,\n                                     trait_object_type: Option<Ty<'tcx>>,\n                                     unique_type_id: UniqueTypeId)\n@@ -453,7 +453,7 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                             syntax_pos::DUMMY_SP)\n }\n \n-pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+pub fn type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                t: Ty<'tcx>,\n                                usage_site_span: Span)\n                                -> DIType {\n@@ -673,7 +673,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     metadata\n }\n \n-pub fn file_metadata(cx: &CrateContext,\n+pub fn file_metadata(cx: &CodegenCx,\n                      file_name: &FileName,\n                      defining_crate: CrateNum) -> DIFile {\n     debug!(\"file_metadata: file_name: {}, defining_crate: {}\",\n@@ -691,11 +691,11 @@ pub fn file_metadata(cx: &CrateContext,\n     file_metadata_raw(cx, &file_name.to_string(), &directory.to_string_lossy())\n }\n \n-pub fn unknown_file_metadata(cx: &CrateContext) -> DIFile {\n+pub fn unknown_file_metadata(cx: &CodegenCx) -> DIFile {\n     file_metadata_raw(cx, \"<unknown>\", \"\")\n }\n \n-fn file_metadata_raw(cx: &CrateContext,\n+fn file_metadata_raw(cx: &CodegenCx,\n                      file_name: &str,\n                      directory: &str)\n                      -> DIFile {\n@@ -721,7 +721,7 @@ fn file_metadata_raw(cx: &CrateContext,\n     file_metadata\n }\n \n-fn basic_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+fn basic_type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                  t: Ty<'tcx>) -> DIType {\n \n     debug!(\"basic_type_metadata: {:?}\", t);\n@@ -758,7 +758,7 @@ fn basic_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     return ty_metadata;\n }\n \n-fn foreign_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+fn foreign_type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                    t: Ty<'tcx>,\n                                    unique_type_id: UniqueTypeId) -> DIType {\n     debug!(\"foreign_type_metadata: {:?}\", t);\n@@ -767,7 +767,7 @@ fn foreign_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     create_struct_stub(cx, t, &name, unique_type_id, NO_SCOPE_METADATA)\n }\n \n-fn pointer_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+fn pointer_type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                    pointer_type: Ty<'tcx>,\n                                    pointee_type_metadata: DIType)\n                                    -> DIType {\n@@ -901,7 +901,7 @@ enum MemberDescriptionFactory<'tcx> {\n }\n \n impl<'tcx> MemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n+    fn create_member_descriptions<'a>(&self, cx: &CodegenCx<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n         match *self {\n             StructMDF(ref this) => {\n@@ -935,7 +935,7 @@ struct StructMemberDescriptionFactory<'tcx> {\n }\n \n impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n+    fn create_member_descriptions<'a>(&self, cx: &CodegenCx<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n         let layout = cx.layout_of(self.ty);\n         self.variant.fields.iter().enumerate().map(|(i, f)| {\n@@ -959,7 +959,7 @@ impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n }\n \n \n-fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+fn prepare_struct_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                      struct_type: Ty<'tcx>,\n                                      unique_type_id: UniqueTypeId,\n                                      span: Span)\n@@ -1004,7 +1004,7 @@ struct TupleMemberDescriptionFactory<'tcx> {\n }\n \n impl<'tcx> TupleMemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n+    fn create_member_descriptions<'a>(&self, cx: &CodegenCx<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n         let layout = cx.layout_of(self.ty);\n         self.component_types.iter().enumerate().map(|(i, &component_type)| {\n@@ -1021,7 +1021,7 @@ impl<'tcx> TupleMemberDescriptionFactory<'tcx> {\n     }\n }\n \n-fn prepare_tuple_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+fn prepare_tuple_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                     tuple_type: Ty<'tcx>,\n                                     component_types: &[Ty<'tcx>],\n                                     unique_type_id: UniqueTypeId,\n@@ -1057,7 +1057,7 @@ struct UnionMemberDescriptionFactory<'tcx> {\n }\n \n impl<'tcx> UnionMemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n+    fn create_member_descriptions<'a>(&self, cx: &CodegenCx<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n         self.variant.fields.iter().enumerate().map(|(i, f)| {\n             let field = self.layout.field(cx, i);\n@@ -1074,7 +1074,7 @@ impl<'tcx> UnionMemberDescriptionFactory<'tcx> {\n     }\n }\n \n-fn prepare_union_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+fn prepare_union_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                     union_type: Ty<'tcx>,\n                                     unique_type_id: UniqueTypeId,\n                                     span: Span)\n@@ -1125,7 +1125,7 @@ struct EnumMemberDescriptionFactory<'tcx> {\n }\n \n impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n+    fn create_member_descriptions<'a>(&self, cx: &CodegenCx<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n         let adt = &self.enum_type.ty_adt_def().unwrap();\n         match self.layout.variants {\n@@ -1210,7 +1210,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 // of discriminant instead of us having to recover its path.\n                 // Right now it's not even going to work for `niche_start > 0`,\n                 // and for multiple niche variants it only supports the first.\n-                fn compute_field_path<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                fn compute_field_path<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n                                                 name: &mut String,\n                                                 layout: TyLayout<'tcx>,\n                                                 offset: Size,\n@@ -1260,7 +1260,7 @@ struct VariantMemberDescriptionFactory<'tcx> {\n }\n \n impl<'tcx> VariantMemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n+    fn create_member_descriptions<'a>(&self, cx: &CodegenCx<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n         self.args.iter().enumerate().map(|(i, &(ref name, ty))| {\n             let (size, align) = cx.size_and_align_of(ty);\n@@ -1290,7 +1290,7 @@ enum EnumDiscriminantInfo {\n // of the variant, and (3) a MemberDescriptionFactory for producing the\n // descriptions of the fields of the variant. This is a rudimentary version of a\n // full RecursiveTypeDescription.\n-fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+fn describe_enum_variant<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                    layout: layout::TyLayout<'tcx>,\n                                    variant: &'tcx ty::VariantDef,\n                                    discriminant_info: EnumDiscriminantInfo,\n@@ -1350,7 +1350,7 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     (metadata_stub, member_description_factory)\n }\n \n-fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+fn prepare_enum_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                    enum_type: Ty<'tcx>,\n                                    enum_def_id: DefId,\n                                    unique_type_id: UniqueTypeId,\n@@ -1470,7 +1470,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }),\n     );\n \n-    fn get_enum_discriminant_name(cx: &CrateContext,\n+    fn get_enum_discriminant_name(cx: &CodegenCx,\n                                   def_id: DefId)\n                                   -> InternedString {\n         cx.tcx.item_name(def_id)\n@@ -1481,7 +1481,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n /// results in a LLVM struct.\n ///\n /// Examples of Rust types to use this are: structs, tuples, boxes, vecs, and enums.\n-fn composite_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+fn composite_type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                      composite_type: Ty<'tcx>,\n                                      composite_type_name: &str,\n                                      composite_type_unique_id: UniqueTypeId,\n@@ -1507,7 +1507,7 @@ fn composite_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     return composite_type_metadata;\n }\n \n-fn set_members_of_composite_type(cx: &CrateContext,\n+fn set_members_of_composite_type(cx: &CodegenCx,\n                                  composite_type_metadata: DICompositeType,\n                                  member_descriptions: &[MemberDescription]) {\n     // In some rare cases LLVM metadata uniquing would lead to an existing type\n@@ -1558,7 +1558,7 @@ fn set_members_of_composite_type(cx: &CrateContext,\n // A convenience wrapper around LLVMRustDIBuilderCreateStructType(). Does not do\n // any caching, does not add any fields to the struct. This can be done later\n // with set_members_of_composite_type().\n-fn create_struct_stub<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+fn create_struct_stub<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                 struct_type: Ty<'tcx>,\n                                 struct_type_name: &str,\n                                 unique_type_id: UniqueTypeId,\n@@ -1595,7 +1595,7 @@ fn create_struct_stub<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     return metadata_stub;\n }\n \n-fn create_union_stub<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+fn create_union_stub<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                union_type: Ty<'tcx>,\n                                union_type_name: &str,\n                                unique_type_id: UniqueTypeId,\n@@ -1633,7 +1633,7 @@ fn create_union_stub<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n /// Creates debug information for the given global variable.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_global_var_metadata(cx: &CrateContext,\n+pub fn create_global_var_metadata(cx: &CodegenCx,\n                                   node_id: ast::NodeId,\n                                   global: ValueRef) {\n     if cx.dbg_cx.is_none() {\n@@ -1689,7 +1689,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n }\n \n // Creates an \"extension\" of an existing DIScope into another file.\n-pub fn extend_scope_to_file(ccx: &CrateContext,\n+pub fn extend_scope_to_file(ccx: &CodegenCx,\n                             scope_metadata: DIScope,\n                             file: &syntax_pos::FileMap,\n                             defining_crate: CrateNum)\n@@ -1707,7 +1707,7 @@ pub fn extend_scope_to_file(ccx: &CrateContext,\n /// given type.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_vtable_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+pub fn create_vtable_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                         ty: ty::Ty<'tcx>,\n                                         vtable: ValueRef) {\n     if cx.dbg_cx.is_none() {"}, {"sha": "d1609b9bf38225609b972b24f42931b8df5a01aa", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -27,7 +27,7 @@ use rustc::hir::def_id::{DefId, CrateNum};\n use rustc::ty::subst::Substs;\n \n use abi::Abi;\n-use common::CrateContext;\n+use common::CodegenCx;\n use builder::Builder;\n use monomorphize::Instance;\n use rustc::ty::{self, Ty};\n@@ -150,7 +150,7 @@ pub enum VariableKind {\n }\n \n /// Create any deferred debug metadata nodes\n-pub fn finalize(cx: &CrateContext) {\n+pub fn finalize(cx: &CodegenCx) {\n     if cx.dbg_cx.is_none() {\n         return;\n     }\n@@ -201,7 +201,7 @@ pub fn finalize(cx: &CrateContext) {\n /// for debug info creation. The function may also return another variant of the\n /// FunctionDebugContext enum which indicates why no debuginfo should be created\n /// for the function.\n-pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+pub fn create_function_debug_context<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                                instance: Instance<'tcx>,\n                                                sig: ty::FnSig<'tcx>,\n                                                llfn: ValueRef,\n@@ -299,7 +299,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     return FunctionDebugContext::RegularContext(fn_debug_context);\n \n-    fn get_function_signature<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+    fn get_function_signature<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                         sig: ty::FnSig<'tcx>) -> DIArray {\n         if cx.sess().opts.debuginfo == LimitedDebugInfo {\n             return create_DIArray(DIB(cx), &[]);\n@@ -358,7 +358,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         return create_DIArray(DIB(cx), &signature[..]);\n     }\n \n-    fn get_template_parameters<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+    fn get_template_parameters<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                          generics: &ty::Generics,\n                                          substs: &Substs<'tcx>,\n                                          file_metadata: DIFile,\n@@ -409,15 +409,15 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         return create_DIArray(DIB(cx), &template_params[..]);\n     }\n \n-    fn get_type_parameter_names(cx: &CrateContext, generics: &ty::Generics) -> Vec<ast::Name> {\n+    fn get_type_parameter_names(cx: &CodegenCx, generics: &ty::Generics) -> Vec<ast::Name> {\n         let mut names = generics.parent.map_or(vec![], |def_id| {\n             get_type_parameter_names(cx, cx.tcx.generics_of(def_id))\n         });\n         names.extend(generics.types.iter().map(|param| param.name));\n         names\n     }\n \n-    fn get_containing_scope<'ccx, 'tcx>(cx: &CrateContext<'ccx, 'tcx>,\n+    fn get_containing_scope<'ccx, 'tcx>(cx: &CodegenCx<'ccx, 'tcx>,\n                                         instance: Instance<'tcx>)\n                                         -> DIScope {\n         // First, let's see if this is a method within an inherent impl. Because"}, {"sha": "5031ad66dd5bd5c7ccb3910ec07b22218d8ccdcd", "filename": "src/librustc_trans/debuginfo/namespace.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -20,21 +20,21 @@ use llvm;\n use llvm::debuginfo::DIScope;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n-use common::CrateContext;\n+use common::CodegenCx;\n \n use std::ffi::CString;\n use std::ptr;\n \n pub fn mangled_name_of_instance<'a, 'tcx>(\n-    ccx: &CrateContext<'a, 'tcx>,\n+    ccx: &CodegenCx<'a, 'tcx>,\n     instance: Instance<'tcx>,\n ) -> ty::SymbolName {\n      let tcx = ccx.tcx;\n      tcx.symbol_name(instance)\n }\n \n pub fn mangled_name_of_item<'a, 'tcx>(\n-    ccx: &CrateContext<'a, 'tcx>,\n+    ccx: &CodegenCx<'a, 'tcx>,\n     node_id: ast::NodeId,\n ) -> ty::SymbolName {\n     let tcx = ccx.tcx;\n@@ -43,7 +43,7 @@ pub fn mangled_name_of_item<'a, 'tcx>(\n     tcx.symbol_name(instance)\n }\n \n-pub fn item_namespace(ccx: &CrateContext, def_id: DefId) -> DIScope {\n+pub fn item_namespace(ccx: &CodegenCx, def_id: DefId) -> DIScope {\n     if let Some(&scope) = debug_context(ccx).namespace_map.borrow().get(&def_id) {\n         return scope;\n     }"}, {"sha": "0aec92b0d66cf3b4c6b4ffbc2879056f4c9be818", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -10,7 +10,7 @@\n \n // Type Names for Debug Info.\n \n-use common::CrateContext;\n+use common::CodegenCx;\n use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty};\n@@ -21,7 +21,7 @@ use rustc::hir;\n // any caching, i.e. calling the function twice with the same type will also do\n // the work twice. The `qualified` parameter only affects the first level of the\n // type name, further levels (i.e. type parameters) are always fully qualified.\n-pub fn compute_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+pub fn compute_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                              t: Ty<'tcx>,\n                                              qualified: bool)\n                                              -> String {\n@@ -32,7 +32,7 @@ pub fn compute_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n // Pushes the name of the type as it should be stored in debuginfo on the\n // `output` String. See also compute_debuginfo_type_name().\n-pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                           t: Ty<'tcx>,\n                                           qualified: bool,\n                                           output: &mut String) {\n@@ -179,7 +179,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n     }\n \n-    fn push_item_name(cx: &CrateContext,\n+    fn push_item_name(cx: &CodegenCx,\n                       def_id: DefId,\n                       qualified: bool,\n                       output: &mut String) {\n@@ -199,7 +199,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     // reconstructed for items from non-local crates. For local crates, this\n     // would be possible but with inlining and LTO we have to use the least\n     // common denominator - otherwise we would run into conflicts.\n-    fn push_type_params<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+    fn push_type_params<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                   substs: &Substs<'tcx>,\n                                   output: &mut String) {\n         if substs.types().next().is_none() {"}, {"sha": "c571b84b8e9edd64c8268f5ec9f6be5490c3343f", "filename": "src/librustc_trans/debuginfo/utils.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -18,12 +18,12 @@ use rustc::ty::DefIdTree;\n \n use llvm;\n use llvm::debuginfo::{DIScope, DIBuilderRef, DIDescriptor, DIArray};\n-use common::{CrateContext};\n+use common::{CodegenCx};\n \n use syntax_pos::{self, Span};\n use syntax::ast;\n \n-pub fn is_node_local_to_unit(cx: &CrateContext, node_id: ast::NodeId) -> bool\n+pub fn is_node_local_to_unit(cx: &CodegenCx, node_id: ast::NodeId) -> bool\n {\n     // The is_local_to_unit flag indicates whether a function is local to the\n     // current compilation unit (i.e. if it is *static* in the C-sense). The\n@@ -45,23 +45,23 @@ pub fn create_DIArray(builder: DIBuilderRef, arr: &[DIDescriptor]) -> DIArray {\n }\n \n /// Return syntax_pos::Loc corresponding to the beginning of the span\n-pub fn span_start(cx: &CrateContext, span: Span) -> syntax_pos::Loc {\n+pub fn span_start(cx: &CodegenCx, span: Span) -> syntax_pos::Loc {\n     cx.sess().codemap().lookup_char_pos(span.lo())\n }\n \n #[inline]\n-pub fn debug_context<'a, 'tcx>(cx: &'a CrateContext<'a, 'tcx>)\n+pub fn debug_context<'a, 'tcx>(cx: &'a CodegenCx<'a, 'tcx>)\n                            -> &'a CrateDebugContext<'tcx> {\n     cx.dbg_cx.as_ref().unwrap()\n }\n \n #[inline]\n #[allow(non_snake_case)]\n-pub fn DIB(cx: &CrateContext) -> DIBuilderRef {\n+pub fn DIB(cx: &CodegenCx) -> DIBuilderRef {\n     cx.dbg_cx.as_ref().unwrap().builder\n }\n \n-pub fn get_namespace_for_item(cx: &CrateContext, def_id: DefId) -> DIScope {\n+pub fn get_namespace_for_item(cx: &CodegenCx, def_id: DefId) -> DIScope {\n     item_namespace(cx, cx.tcx.parent(def_id)\n         .expect(\"get_namespace_for_item: missing parent?\"))\n }"}, {"sha": "e92670f0abb11b2c96936f0f48fbf3ef034d1d91", "filename": "src/librustc_trans/declare.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdeclare.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -27,7 +27,7 @@ use rustc::session::config::Sanitizer;\n use rustc_back::PanicStrategy;\n use abi::{Abi, FnType};\n use attributes;\n-use context::CrateContext;\n+use context::CodegenCx;\n use common;\n use type_::Type;\n use value::Value;\n@@ -39,7 +39,7 @@ use std::ffi::CString;\n ///\n /// If there\u2019s a value with the same name already declared, the function will\n /// return its ValueRef instead.\n-pub fn declare_global(ccx: &CrateContext, name: &str, ty: Type) -> llvm::ValueRef {\n+pub fn declare_global(ccx: &CodegenCx, name: &str, ty: Type) -> llvm::ValueRef {\n     debug!(\"declare_global(name={:?})\", name);\n     let namebuf = CString::new(name).unwrap_or_else(|_|{\n         bug!(\"name {:?} contains an interior null byte\", name)\n@@ -54,7 +54,7 @@ pub fn declare_global(ccx: &CrateContext, name: &str, ty: Type) -> llvm::ValueRe\n ///\n /// If there\u2019s a value with the same name already declared, the function will\n /// update the declaration and return existing ValueRef instead.\n-fn declare_raw_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, ty: Type) -> ValueRef {\n+fn declare_raw_fn(ccx: &CodegenCx, name: &str, callconv: llvm::CallConv, ty: Type) -> ValueRef {\n     debug!(\"declare_raw_fn(name={:?}, ty={:?})\", name, ty);\n     let namebuf = CString::new(name).unwrap_or_else(|_|{\n         bug!(\"name {:?} contains an interior null byte\", name)\n@@ -114,7 +114,7 @@ fn declare_raw_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, ty:\n ///\n /// If there\u2019s a value with the same name already declared, the function will\n /// update the declaration and return existing ValueRef instead.\n-pub fn declare_cfn(ccx: &CrateContext, name: &str, fn_type: Type) -> ValueRef {\n+pub fn declare_cfn(ccx: &CodegenCx, name: &str, fn_type: Type) -> ValueRef {\n     declare_raw_fn(ccx, name, llvm::CCallConv, fn_type)\n }\n \n@@ -123,7 +123,7 @@ pub fn declare_cfn(ccx: &CrateContext, name: &str, fn_type: Type) -> ValueRef {\n ///\n /// If there\u2019s a value with the same name already declared, the function will\n /// update the declaration and return existing ValueRef instead.\n-pub fn declare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n+pub fn declare_fn<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>, name: &str,\n                             fn_type: Ty<'tcx>) -> ValueRef {\n     debug!(\"declare_rust_fn(name={:?}, fn_type={:?})\", name, fn_type);\n     let sig = common::ty_fn_sig(ccx, fn_type);\n@@ -154,7 +154,7 @@ pub fn declare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n /// return None if the name already has a definition associated with it. In that\n /// case an error should be reported to the user, because it usually happens due\n /// to user\u2019s fault (e.g. misuse of #[no_mangle] or #[export_name] attributes).\n-pub fn define_global(ccx: &CrateContext, name: &str, ty: Type) -> Option<ValueRef> {\n+pub fn define_global(ccx: &CodegenCx, name: &str, ty: Type) -> Option<ValueRef> {\n     if get_defined_value(ccx, name).is_some() {\n         None\n     } else {\n@@ -167,7 +167,7 @@ pub fn define_global(ccx: &CrateContext, name: &str, ty: Type) -> Option<ValueRe\n /// Use this function when you intend to define a function. This function will\n /// return panic if the name already has a definition associated with it. This\n /// can happen with #[no_mangle] or #[export_name], for example.\n-pub fn define_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+pub fn define_fn<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n                            name: &str,\n                            fn_type: Ty<'tcx>) -> ValueRef {\n     if get_defined_value(ccx, name).is_some() {\n@@ -182,7 +182,7 @@ pub fn define_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n /// Use this function when you intend to define a function. This function will\n /// return panic if the name already has a definition associated with it. This\n /// can happen with #[no_mangle] or #[export_name], for example.\n-pub fn define_internal_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+pub fn define_internal_fn<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n                                     name: &str,\n                                     fn_type: Ty<'tcx>) -> ValueRef {\n     let llfn = define_fn(ccx, name, fn_type);\n@@ -192,7 +192,7 @@ pub fn define_internal_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n \n /// Get declared value by name.\n-pub fn get_declared_value(ccx: &CrateContext, name: &str) -> Option<ValueRef> {\n+pub fn get_declared_value(ccx: &CodegenCx, name: &str) -> Option<ValueRef> {\n     debug!(\"get_declared_value(name={:?})\", name);\n     let namebuf = CString::new(name).unwrap_or_else(|_|{\n         bug!(\"name {:?} contains an interior null byte\", name)\n@@ -209,7 +209,7 @@ pub fn get_declared_value(ccx: &CrateContext, name: &str) -> Option<ValueRef> {\n \n /// Get defined or externally defined (AvailableExternally linkage) value by\n /// name.\n-pub fn get_defined_value(ccx: &CrateContext, name: &str) -> Option<ValueRef> {\n+pub fn get_defined_value(ccx: &CodegenCx, name: &str) -> Option<ValueRef> {\n     get_declared_value(ccx, name).and_then(|val|{\n         let declaration = unsafe {\n             llvm::LLVMIsDeclaration(val) != 0"}, {"sha": "fa8ed74493118f8ace7586718910ecbd571b0d75", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -35,7 +35,7 @@ use syntax_pos::Span;\n use std::cmp::Ordering;\n use std::iter;\n \n-fn get_simple_intrinsic(ccx: &CrateContext, name: &str) -> Option<ValueRef> {\n+fn get_simple_intrinsic(ccx: &CodegenCx, name: &str) -> Option<ValueRef> {\n     let llvm_name = match name {\n         \"sqrtf32\" => \"llvm.sqrt.f32\",\n         \"sqrtf64\" => \"llvm.sqrt.f64\",\n@@ -565,7 +565,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 assert_eq!(x.len(), 1);\n                 x.into_iter().next().unwrap()\n             }\n-            fn ty_to_type(ccx: &CrateContext, t: &intrinsics::Type) -> Vec<Type> {\n+            fn ty_to_type(ccx: &CodegenCx, t: &intrinsics::Type) -> Vec<Type> {\n                 use intrinsics::Type::*;\n                 match *t {\n                     Void => vec![Type::void(ccx)],\n@@ -750,7 +750,7 @@ fn memset_intrinsic<'a, 'tcx>(\n \n fn try_intrinsic<'a, 'tcx>(\n     bcx: &Builder<'a, 'tcx>,\n-    ccx: &CrateContext,\n+    ccx: &CodegenCx,\n     func: ValueRef,\n     data: ValueRef,\n     local_ptr: ValueRef,\n@@ -775,7 +775,7 @@ fn try_intrinsic<'a, 'tcx>(\n // writing, however, LLVM does not recommend the usage of these new instructions\n // as the old ones are still more optimized.\n fn trans_msvc_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n-                            ccx: &CrateContext,\n+                            ccx: &CodegenCx,\n                             func: ValueRef,\n                             data: ValueRef,\n                             local_ptr: ValueRef,\n@@ -883,7 +883,7 @@ fn trans_msvc_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n // functions in play. By calling a shim we're guaranteed that our shim will have\n // the right personality function.\n fn trans_gnu_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n-                           ccx: &CrateContext,\n+                           ccx: &CodegenCx,\n                            func: ValueRef,\n                            data: ValueRef,\n                            local_ptr: ValueRef,\n@@ -942,7 +942,7 @@ fn trans_gnu_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n // Helper function to give a Block to a closure to translate a shim function.\n // This is currently primarily used for the `try` intrinsic functions above.\n-fn gen_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+fn gen_fn<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n                     name: &str,\n                     inputs: Vec<Ty<'tcx>>,\n                     output: Ty<'tcx>,\n@@ -965,7 +965,7 @@ fn gen_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n // catch exceptions.\n //\n // This function is only generated once and is then cached.\n-fn get_rust_try_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+fn get_rust_try_fn<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n                              trans: &mut for<'b> FnMut(Builder<'b, 'tcx>))\n                              -> ValueRef {\n     if let Some(llfn) = ccx.rust_try_fn.get() {\n@@ -1243,7 +1243,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n // Returns None if the type is not an integer\n // FIXME: there\u2019s multiple of this functions, investigate using some of the already existing\n // stuffs.\n-fn int_type_width_signed(ty: Ty, ccx: &CrateContext) -> Option<(u64, bool)> {\n+fn int_type_width_signed(ty: Ty, ccx: &CodegenCx) -> Option<(u64, bool)> {\n     match ty.sty {\n         ty::TyInt(t) => Some((match t {\n             ast::IntTy::Isize => {"}, {"sha": "be6f035e08959d9efd35d604bd63f2685b0d080e", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -69,7 +69,7 @@ impl<'a, 'tcx> VirtualIndex {\n /// The `trait_ref` encodes the erased self type. Hence if we are\n /// making an object `Foo<Trait>` from a value of type `Foo<T>`, then\n /// `trait_ref` would map `T:Trait`.\n-pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+pub fn get_vtable<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n                             ty: Ty<'tcx>,\n                             trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>)\n                             -> ValueRef"}, {"sha": "bce0cb868f5e04c588bb1d0ab931459e72d081b4", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -27,7 +27,7 @@ use base;\n use abi::{self, Abi};\n use callee;\n use builder::Builder;\n-use common::{self, CrateContext, const_get_elt, val_ty};\n+use common::{self, CodegenCx, const_get_elt, val_ty};\n use common::{C_array, C_bool, C_bytes, C_int, C_uint, C_uint_big, C_u32, C_u64};\n use common::{C_null, C_struct, C_str_slice, C_undef, C_usize, C_vector, C_fat_ptr};\n use common::const_to_opt_u128;\n@@ -62,7 +62,7 @@ impl<'a, 'tcx> Const<'tcx> {\n         }\n     }\n \n-    pub fn from_constint(ccx: &CrateContext<'a, 'tcx>, ci: &ConstInt) -> Const<'tcx> {\n+    pub fn from_constint(ccx: &CodegenCx<'a, 'tcx>, ci: &ConstInt) -> Const<'tcx> {\n         let tcx = ccx.tcx;\n         let (llval, ty) = match *ci {\n             I8(v) => (C_int(Type::i8(ccx), v as i64), tcx.types.i8),\n@@ -82,7 +82,7 @@ impl<'a, 'tcx> Const<'tcx> {\n     }\n \n     /// Translate ConstVal into a LLVM constant value.\n-    pub fn from_constval(ccx: &CrateContext<'a, 'tcx>,\n+    pub fn from_constval(ccx: &CodegenCx<'a, 'tcx>,\n                          cv: &ConstVal,\n                          ty: Ty<'tcx>)\n                          -> Const<'tcx> {\n@@ -115,7 +115,7 @@ impl<'a, 'tcx> Const<'tcx> {\n         Const::new(val, ty)\n     }\n \n-    fn get_field(&self, ccx: &CrateContext<'a, 'tcx>, i: usize) -> ValueRef {\n+    fn get_field(&self, ccx: &CodegenCx<'a, 'tcx>, i: usize) -> ValueRef {\n         let layout = ccx.layout_of(self.ty);\n         let field = layout.field(ccx, i);\n         if field.is_zst() {\n@@ -145,11 +145,11 @@ impl<'a, 'tcx> Const<'tcx> {\n         }\n     }\n \n-    fn get_pair(&self, ccx: &CrateContext<'a, 'tcx>) -> (ValueRef, ValueRef) {\n+    fn get_pair(&self, ccx: &CodegenCx<'a, 'tcx>) -> (ValueRef, ValueRef) {\n         (self.get_field(ccx, 0), self.get_field(ccx, 1))\n     }\n \n-    fn get_fat_ptr(&self, ccx: &CrateContext<'a, 'tcx>) -> (ValueRef, ValueRef) {\n+    fn get_fat_ptr(&self, ccx: &CodegenCx<'a, 'tcx>) -> (ValueRef, ValueRef) {\n         assert_eq!(abi::FAT_PTR_ADDR, 0);\n         assert_eq!(abi::FAT_PTR_EXTRA, 1);\n         self.get_pair(ccx)\n@@ -163,7 +163,7 @@ impl<'a, 'tcx> Const<'tcx> {\n         }\n     }\n \n-    pub fn to_operand(&self, ccx: &CrateContext<'a, 'tcx>) -> OperandRef<'tcx> {\n+    pub fn to_operand(&self, ccx: &CodegenCx<'a, 'tcx>) -> OperandRef<'tcx> {\n         let layout = ccx.layout_of(self.ty);\n         let llty = layout.immediate_llvm_type(ccx);\n         let llvalty = val_ty(self.llval);\n@@ -232,7 +232,7 @@ impl<'tcx> ConstPlace<'tcx> {\n         }\n     }\n \n-    pub fn len<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> ValueRef {\n+    pub fn len<'a>(&self, ccx: &CodegenCx<'a, 'tcx>) -> ValueRef {\n         match self.ty.sty {\n             ty::TyArray(_, n) => {\n                 C_usize(ccx, n.val.to_const_int().unwrap().to_u64().unwrap())\n@@ -249,7 +249,7 @@ impl<'tcx> ConstPlace<'tcx> {\n /// Machinery for translating a constant's MIR to LLVM values.\n /// FIXME(eddyb) use miri and lower its allocations to LLVM.\n struct MirConstContext<'a, 'tcx: 'a> {\n-    ccx: &'a CrateContext<'a, 'tcx>,\n+    ccx: &'a CodegenCx<'a, 'tcx>,\n     mir: &'a mir::Mir<'tcx>,\n \n     /// Type parameters for const fn and associated constants.\n@@ -270,7 +270,7 @@ fn add_err<'tcx, U, V>(failure: &mut Result<U, ConstEvalErr<'tcx>>,\n }\n \n impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n-    fn new(ccx: &'a CrateContext<'a, 'tcx>,\n+    fn new(ccx: &'a CodegenCx<'a, 'tcx>,\n            mir: &'a mir::Mir<'tcx>,\n            substs: &'tcx Substs<'tcx>,\n            args: IndexVec<mir::Local, Result<Const<'tcx>, ConstEvalErr<'tcx>>>)\n@@ -289,7 +289,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n         context\n     }\n \n-    fn trans_def(ccx: &'a CrateContext<'a, 'tcx>,\n+    fn trans_def(ccx: &'a CodegenCx<'a, 'tcx>,\n                  def_id: DefId,\n                  substs: &'tcx Substs<'tcx>,\n                  args: IndexVec<mir::Local, Result<Const<'tcx>, ConstEvalErr<'tcx>>>)\n@@ -1060,7 +1060,7 @@ pub fn const_scalar_checked_binop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-unsafe fn cast_const_float_to_int(ccx: &CrateContext,\n+unsafe fn cast_const_float_to_int(ccx: &CodegenCx,\n                                   operand: &Const,\n                                   signed: bool,\n                                   int_ty: Type,\n@@ -1095,7 +1095,7 @@ unsafe fn cast_const_float_to_int(ccx: &CrateContext,\n     C_uint_big(int_ty, cast_result.value)\n }\n \n-unsafe fn cast_const_int_to_float(ccx: &CrateContext,\n+unsafe fn cast_const_int_to_float(ccx: &CodegenCx,\n                                   llval: ValueRef,\n                                   signed: bool,\n                                   float_ty: Type) -> ValueRef {\n@@ -1154,7 +1154,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n \n pub fn trans_static_initializer<'a, 'tcx>(\n-    ccx: &CrateContext<'a, 'tcx>,\n+    ccx: &CodegenCx<'a, 'tcx>,\n     def_id: DefId)\n     -> Result<ValueRef, ConstEvalErr<'tcx>>\n {\n@@ -1182,7 +1182,7 @@ pub fn trans_static_initializer<'a, 'tcx>(\n /// this could be changed in the future to avoid allocating unnecessary\n /// space after values of shorter-than-maximum cases.\n fn trans_const_adt<'a, 'tcx>(\n-    ccx: &CrateContext<'a, 'tcx>,\n+    ccx: &CodegenCx<'a, 'tcx>,\n     t: Ty<'tcx>,\n     kind: &mir::AggregateKind,\n     vals: &[Const<'tcx>]\n@@ -1272,7 +1272,7 @@ fn trans_const_adt<'a, 'tcx>(\n /// initializer is 4-byte aligned then simply translating the tuple as\n /// a two-element struct will locate it at offset 4, and accesses to it\n /// will read the wrong memory.\n-fn build_const_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+fn build_const_struct<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n                                 layout: layout::TyLayout<'tcx>,\n                                 vals: &[Const<'tcx>],\n                                 discr: Option<Const<'tcx>>)\n@@ -1332,6 +1332,6 @@ fn build_const_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     Const::new(C_struct(ccx, &cfields, packed), layout.ty)\n }\n \n-fn padding(ccx: &CrateContext, size: Size) -> ValueRef {\n+fn padding(ccx: &CodegenCx, size: Size) -> ValueRef {\n     C_undef(Type::array(&Type::i8(ccx), size.bytes()))\n }"}, {"sha": "4b24f0cf671a14d5676755b3ff8c5b9613baf299", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -19,7 +19,7 @@ use rustc::infer::TransNormalize;\n use rustc::session::config::FullDebugInfo;\n use base;\n use builder::Builder;\n-use common::{CrateContext, Funclet};\n+use common::{CodegenCx, Funclet};\n use debuginfo::{self, declare_local, VariableAccess, VariableKind, FunctionDebugContext};\n use monomorphize::Instance;\n use abi::{ArgAttribute, FnType, PassMode};\n@@ -48,7 +48,7 @@ pub struct MirContext<'a, 'tcx:'a> {\n \n     llfn: ValueRef,\n \n-    ccx: &'a CrateContext<'a, 'tcx>,\n+    ccx: &'a CodegenCx<'a, 'tcx>,\n \n     fn_ty: FnType<'tcx>,\n \n@@ -176,7 +176,7 @@ enum LocalRef<'tcx> {\n }\n \n impl<'a, 'tcx> LocalRef<'tcx> {\n-    fn new_operand(ccx: &CrateContext<'a, 'tcx>, layout: TyLayout<'tcx>) -> LocalRef<'tcx> {\n+    fn new_operand(ccx: &CodegenCx<'a, 'tcx>, layout: TyLayout<'tcx>) -> LocalRef<'tcx> {\n         if layout.is_zst() {\n             // Zero-size temporaries aren't always initialized, which\n             // doesn't matter because they don't contain data, but\n@@ -191,7 +191,7 @@ impl<'a, 'tcx> LocalRef<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n \n pub fn trans_mir<'a, 'tcx: 'a>(\n-    ccx: &'a CrateContext<'a, 'tcx>,\n+    ccx: &'a CodegenCx<'a, 'tcx>,\n     llfn: ValueRef,\n     mir: &'a Mir<'tcx>,\n     instance: Instance<'tcx>,"}, {"sha": "daf2a36d7a2e0df656625d5886adeae2d3cd779a", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -15,7 +15,7 @@ use rustc::mir;\n use rustc_data_structures::indexed_vec::Idx;\n \n use base;\n-use common::{self, CrateContext, C_undef, C_usize};\n+use common::{self, CodegenCx, C_undef, C_usize};\n use builder::Builder;\n use value::Value;\n use type_of::LayoutLlvmExt;\n@@ -81,7 +81,7 @@ impl<'tcx> fmt::Debug for OperandRef<'tcx> {\n }\n \n impl<'a, 'tcx> OperandRef<'tcx> {\n-    pub fn new_zst(ccx: &CrateContext<'a, 'tcx>,\n+    pub fn new_zst(ccx: &CodegenCx<'a, 'tcx>,\n                    layout: TyLayout<'tcx>) -> OperandRef<'tcx> {\n         assert!(layout.is_zst());\n         OperandRef {\n@@ -99,7 +99,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n         }\n     }\n \n-    pub fn deref(self, ccx: &CrateContext<'a, 'tcx>) -> PlaceRef<'tcx> {\n+    pub fn deref(self, ccx: &CodegenCx<'a, 'tcx>) -> PlaceRef<'tcx> {\n         let projected_ty = self.layout.ty.builtin_deref(true, ty::NoPreference)\n             .unwrap_or_else(|| bug!(\"deref of non-pointer {:?}\", self)).ty;\n         let (llptr, llextra) = match self.val {"}, {"sha": "748bea1fc7539a27bc7d5b2f9b1c109eada65737", "filename": "src/librustc_trans/mir/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fplace.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -16,7 +16,7 @@ use rustc::mir::tcx::PlaceTy;\n use rustc_data_structures::indexed_vec::Idx;\n use base;\n use builder::Builder;\n-use common::{CrateContext, C_usize, C_u8, C_u32, C_uint, C_int, C_null, C_uint_big};\n+use common::{CodegenCx, C_usize, C_u8, C_u32, C_uint, C_int, C_null, C_uint_big};\n use consts;\n use type_of::LayoutLlvmExt;\n use type_::Type;\n@@ -63,7 +63,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n         Self::new_sized(tmp, layout, layout.align)\n     }\n \n-    pub fn len(&self, ccx: &CrateContext<'a, 'tcx>) -> ValueRef {\n+    pub fn len(&self, ccx: &CodegenCx<'a, 'tcx>) -> ValueRef {\n         if let layout::FieldPlacement::Array { count, .. } = self.layout.fields {\n             if self.layout.is_unsized() {\n                 assert!(self.has_extra());"}, {"sha": "eafc3d2fafba34c770eef59337825d30f40d7970", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -18,7 +18,7 @@ use asm;\n use attributes;\n use base;\n use consts;\n-use context::CrateContext;\n+use context::CodegenCx;\n use declare;\n use llvm;\n use monomorphize::Instance;\n@@ -38,7 +38,7 @@ pub use rustc_mir::monomorphize::item::*;\n pub use rustc_mir::monomorphize::item::MonoItemExt as BaseMonoItemExt;\n \n pub trait MonoItemExt<'a, 'tcx>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n-    fn define(&self, ccx: &CrateContext<'a, 'tcx>) {\n+    fn define(&self, ccx: &CodegenCx<'a, 'tcx>) {\n         debug!(\"BEGIN IMPLEMENTING '{} ({})' in cgu {}\",\n                self.to_string(ccx.tcx),\n                self.to_raw_string(),\n@@ -79,7 +79,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n     }\n \n     fn predefine(&self,\n-                 ccx: &CrateContext<'a, 'tcx>,\n+                 ccx: &CodegenCx<'a, 'tcx>,\n                  linkage: Linkage,\n                  visibility: Visibility) {\n         debug!(\"BEGIN PREDEFINING '{} ({})' in cgu {}\",\n@@ -138,7 +138,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n \n impl<'a, 'tcx> MonoItemExt<'a, 'tcx> for MonoItem<'tcx> {}\n \n-fn predefine_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+fn predefine_static<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n                               node_id: ast::NodeId,\n                               linkage: Linkage,\n                               visibility: Visibility,\n@@ -162,7 +162,7 @@ fn predefine_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     ccx.statics.borrow_mut().insert(g, def_id);\n }\n \n-fn predefine_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+fn predefine_fn<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n                           instance: Instance<'tcx>,\n                           linkage: Linkage,\n                           visibility: Visibility,"}, {"sha": "75145eb4416d03223fe17cc787e53f5c21480248", "filename": "src/librustc_trans/type_.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -14,7 +14,7 @@ use llvm;\n use llvm::{ContextRef, TypeRef, Bool, False, True, TypeKind};\n use llvm::{Float, Double, X86_FP80, PPC_FP128, FP128};\n \n-use context::CrateContext;\n+use context::CodegenCx;\n \n use syntax::ast;\n use rustc::ty::layout::{self, Align, Size};\n@@ -62,72 +62,72 @@ impl Type {\n         unsafe { mem::transmute(slice) }\n     }\n \n-    pub fn void(ccx: &CrateContext) -> Type {\n+    pub fn void(ccx: &CodegenCx) -> Type {\n         ty!(llvm::LLVMVoidTypeInContext(ccx.llcx))\n     }\n \n-    pub fn metadata(ccx: &CrateContext) -> Type {\n+    pub fn metadata(ccx: &CodegenCx) -> Type {\n         ty!(llvm::LLVMRustMetadataTypeInContext(ccx.llcx))\n     }\n \n-    pub fn i1(ccx: &CrateContext) -> Type {\n+    pub fn i1(ccx: &CodegenCx) -> Type {\n         ty!(llvm::LLVMInt1TypeInContext(ccx.llcx))\n     }\n \n-    pub fn i8(ccx: &CrateContext) -> Type {\n+    pub fn i8(ccx: &CodegenCx) -> Type {\n         ty!(llvm::LLVMInt8TypeInContext(ccx.llcx))\n     }\n \n     pub fn i8_llcx(llcx: ContextRef) -> Type {\n         ty!(llvm::LLVMInt8TypeInContext(llcx))\n     }\n \n-    pub fn i16(ccx: &CrateContext) -> Type {\n+    pub fn i16(ccx: &CodegenCx) -> Type {\n         ty!(llvm::LLVMInt16TypeInContext(ccx.llcx))\n     }\n \n-    pub fn i32(ccx: &CrateContext) -> Type {\n+    pub fn i32(ccx: &CodegenCx) -> Type {\n         ty!(llvm::LLVMInt32TypeInContext(ccx.llcx))\n     }\n \n-    pub fn i64(ccx: &CrateContext) -> Type {\n+    pub fn i64(ccx: &CodegenCx) -> Type {\n         ty!(llvm::LLVMInt64TypeInContext(ccx.llcx))\n     }\n \n-    pub fn i128(ccx: &CrateContext) -> Type {\n+    pub fn i128(ccx: &CodegenCx) -> Type {\n         ty!(llvm::LLVMIntTypeInContext(ccx.llcx, 128))\n     }\n \n     // Creates an integer type with the given number of bits, e.g. i24\n-    pub fn ix(ccx: &CrateContext, num_bits: u64) -> Type {\n+    pub fn ix(ccx: &CodegenCx, num_bits: u64) -> Type {\n         ty!(llvm::LLVMIntTypeInContext(ccx.llcx, num_bits as c_uint))\n     }\n \n-    pub fn f32(ccx: &CrateContext) -> Type {\n+    pub fn f32(ccx: &CodegenCx) -> Type {\n         ty!(llvm::LLVMFloatTypeInContext(ccx.llcx))\n     }\n \n-    pub fn f64(ccx: &CrateContext) -> Type {\n+    pub fn f64(ccx: &CodegenCx) -> Type {\n         ty!(llvm::LLVMDoubleTypeInContext(ccx.llcx))\n     }\n \n-    pub fn bool(ccx: &CrateContext) -> Type {\n+    pub fn bool(ccx: &CodegenCx) -> Type {\n         Type::i8(ccx)\n     }\n \n-    pub fn char(ccx: &CrateContext) -> Type {\n+    pub fn char(ccx: &CodegenCx) -> Type {\n         Type::i32(ccx)\n     }\n \n-    pub fn i8p(ccx: &CrateContext) -> Type {\n+    pub fn i8p(ccx: &CodegenCx) -> Type {\n         Type::i8(ccx).ptr_to()\n     }\n \n     pub fn i8p_llcx(llcx: ContextRef) -> Type {\n         Type::i8_llcx(llcx).ptr_to()\n     }\n \n-    pub fn isize(ccx: &CrateContext) -> Type {\n+    pub fn isize(ccx: &CodegenCx) -> Type {\n         match &ccx.tcx.sess.target.target.target_pointer_width[..] {\n             \"16\" => Type::i16(ccx),\n             \"32\" => Type::i32(ccx),\n@@ -136,7 +136,7 @@ impl Type {\n         }\n     }\n \n-    pub fn c_int(ccx: &CrateContext) -> Type {\n+    pub fn c_int(ccx: &CodegenCx) -> Type {\n         match &ccx.tcx.sess.target.target.target_c_int_width[..] {\n             \"16\" => Type::i16(ccx),\n             \"32\" => Type::i32(ccx),\n@@ -145,7 +145,7 @@ impl Type {\n         }\n     }\n \n-    pub fn int_from_ty(ccx: &CrateContext, t: ast::IntTy) -> Type {\n+    pub fn int_from_ty(ccx: &CodegenCx, t: ast::IntTy) -> Type {\n         match t {\n             ast::IntTy::Isize => ccx.isize_ty,\n             ast::IntTy::I8 => Type::i8(ccx),\n@@ -156,7 +156,7 @@ impl Type {\n         }\n     }\n \n-    pub fn uint_from_ty(ccx: &CrateContext, t: ast::UintTy) -> Type {\n+    pub fn uint_from_ty(ccx: &CodegenCx, t: ast::UintTy) -> Type {\n         match t {\n             ast::UintTy::Usize => ccx.isize_ty,\n             ast::UintTy::U8 => Type::i8(ccx),\n@@ -167,7 +167,7 @@ impl Type {\n         }\n     }\n \n-    pub fn float_from_ty(ccx: &CrateContext, t: ast::FloatTy) -> Type {\n+    pub fn float_from_ty(ccx: &CodegenCx, t: ast::FloatTy) -> Type {\n         match t {\n             ast::FloatTy::F32 => Type::f32(ccx),\n             ast::FloatTy::F64 => Type::f64(ccx),\n@@ -186,14 +186,14 @@ impl Type {\n                                    args.len() as c_uint, True))\n     }\n \n-    pub fn struct_(ccx: &CrateContext, els: &[Type], packed: bool) -> Type {\n+    pub fn struct_(ccx: &CodegenCx, els: &[Type], packed: bool) -> Type {\n         let els: &[TypeRef] = Type::to_ref_slice(els);\n         ty!(llvm::LLVMStructTypeInContext(ccx.llcx, els.as_ptr(),\n                                           els.len() as c_uint,\n                                           packed as Bool))\n     }\n \n-    pub fn named_struct(ccx: &CrateContext, name: &str) -> Type {\n+    pub fn named_struct(ccx: &CodegenCx, name: &str) -> Type {\n         let name = CString::new(name).unwrap();\n         ty!(llvm::LLVMStructCreateNamed(ccx.llcx, name.as_ptr()))\n     }\n@@ -265,7 +265,7 @@ impl Type {\n         }\n     }\n \n-    pub fn from_integer(cx: &CrateContext, i: layout::Integer) -> Type {\n+    pub fn from_integer(cx: &CodegenCx, i: layout::Integer) -> Type {\n         use rustc::ty::layout::Integer::*;\n         match i {\n             I8 => Type::i8(cx),\n@@ -278,23 +278,23 @@ impl Type {\n \n     /// Return a LLVM type that has at most the required alignment,\n     /// as a conservative approximation for unknown pointee types.\n-    pub fn pointee_for_abi_align(ccx: &CrateContext, align: Align) -> Type {\n+    pub fn pointee_for_abi_align(ccx: &CodegenCx, align: Align) -> Type {\n         // FIXME(eddyb) We could find a better approximation if ity.align < align.\n         let ity = layout::Integer::approximate_abi_align(ccx, align);\n         Type::from_integer(ccx, ity)\n     }\n \n     /// Return a LLVM type that has at most the required alignment,\n     /// and exactly the required size, as a best-effort padding array.\n-    pub fn padding_filler(ccx: &CrateContext, size: Size, align: Align) -> Type {\n+    pub fn padding_filler(ccx: &CodegenCx, size: Size, align: Align) -> Type {\n         let unit = layout::Integer::approximate_abi_align(ccx, align);\n         let size = size.bytes();\n         let unit_size = unit.size().bytes();\n         assert_eq!(size % unit_size, 0);\n         Type::array(&Type::from_integer(ccx, unit), size / unit_size)\n     }\n \n-    pub fn x86_mmx(ccx: &CrateContext) -> Type {\n+    pub fn x86_mmx(ccx: &CodegenCx) -> Type {\n         ty!(llvm::LLVMX86MMXTypeInContext(ccx.llcx))\n     }\n }"}, {"sha": "47c9f5661df223abe7ef90f835244d982331c119", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb7de6a041bf9917135ab52ca2778c1b1663df35/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=fb7de6a041bf9917135ab52ca2778c1b1663df35", "patch": "@@ -19,7 +19,7 @@ use type_::Type;\n \n use std::fmt::Write;\n \n-fn uncached_llvm_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+fn uncached_llvm_type<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n                                 layout: TyLayout<'tcx>,\n                                 defer: &mut Option<(Type, TyLayout<'tcx>)>)\n                                 -> Type {\n@@ -110,7 +110,7 @@ fn uncached_llvm_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-fn struct_llfields<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+fn struct_llfields<'a, 'tcx>(ccx: &CodegenCx<'a, 'tcx>,\n                              layout: TyLayout<'tcx>)\n                              -> (Vec<Type>, bool) {\n     debug!(\"struct_llfields: {:#?}\", layout);\n@@ -158,7 +158,7 @@ fn struct_llfields<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     (result, packed)\n }\n \n-impl<'a, 'tcx> CrateContext<'a, 'tcx> {\n+impl<'a, 'tcx> CodegenCx<'a, 'tcx> {\n     pub fn align_of(&self, ty: Ty<'tcx>) -> Align {\n         self.layout_of(ty).align\n     }\n@@ -197,14 +197,14 @@ pub struct PointeeInfo {\n pub trait LayoutLlvmExt<'tcx> {\n     fn is_llvm_immediate(&self) -> bool;\n     fn is_llvm_scalar_pair<'a>(&self) -> bool;\n-    fn llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Type;\n-    fn immediate_llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Type;\n-    fn scalar_llvm_type_at<'a>(&self, ccx: &CrateContext<'a, 'tcx>,\n+    fn llvm_type<'a>(&self, ccx: &CodegenCx<'a, 'tcx>) -> Type;\n+    fn immediate_llvm_type<'a>(&self, ccx: &CodegenCx<'a, 'tcx>) -> Type;\n+    fn scalar_llvm_type_at<'a>(&self, ccx: &CodegenCx<'a, 'tcx>,\n                                scalar: &layout::Scalar, offset: Size) -> Type;\n-    fn scalar_pair_element_llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>,\n+    fn scalar_pair_element_llvm_type<'a>(&self, ccx: &CodegenCx<'a, 'tcx>,\n                                          index: usize) -> Type;\n     fn llvm_field_index(&self, index: usize) -> u64;\n-    fn pointee_info_at<'a>(&self, ccx: &CrateContext<'a, 'tcx>, offset: Size)\n+    fn pointee_info_at<'a>(&self, ccx: &CodegenCx<'a, 'tcx>, offset: Size)\n                            -> Option<PointeeInfo>;\n }\n \n@@ -240,7 +240,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n     /// with the inner-most trailing unsized field using the \"minimal unit\"\n     /// of that field's type - this is useful for taking the address of\n     /// that field and ensuring the struct has the right alignment.\n-    fn llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Type {\n+    fn llvm_type<'a>(&self, ccx: &CodegenCx<'a, 'tcx>) -> Type {\n         if let layout::Abi::Scalar(ref scalar) = self.abi {\n             // Use a different cache for scalars because pointers to DSTs\n             // can be either fat or thin (data pointers of fat pointers).\n@@ -305,7 +305,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n         llty\n     }\n \n-    fn immediate_llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Type {\n+    fn immediate_llvm_type<'a>(&self, ccx: &CodegenCx<'a, 'tcx>) -> Type {\n         if let layout::Abi::Scalar(ref scalar) = self.abi {\n             if scalar.is_bool() {\n                 return Type::i1(ccx);\n@@ -314,7 +314,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n         self.llvm_type(ccx)\n     }\n \n-    fn scalar_llvm_type_at<'a>(&self, ccx: &CrateContext<'a, 'tcx>,\n+    fn scalar_llvm_type_at<'a>(&self, ccx: &CodegenCx<'a, 'tcx>,\n                                scalar: &layout::Scalar, offset: Size) -> Type {\n         match scalar.value {\n             layout::Int(i, _) => Type::from_integer(ccx, i),\n@@ -332,7 +332,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n         }\n     }\n \n-    fn scalar_pair_element_llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>,\n+    fn scalar_pair_element_llvm_type<'a>(&self, ccx: &CodegenCx<'a, 'tcx>,\n                                          index: usize) -> Type {\n         // HACK(eddyb) special-case fat pointers until LLVM removes\n         // pointee types, to avoid bitcasting every `OperandRef::deref`.\n@@ -396,7 +396,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n         }\n     }\n \n-    fn pointee_info_at<'a>(&self, ccx: &CrateContext<'a, 'tcx>, offset: Size)\n+    fn pointee_info_at<'a>(&self, ccx: &CodegenCx<'a, 'tcx>, offset: Size)\n                            -> Option<PointeeInfo> {\n         if let Some(&pointee) = ccx.pointee_infos.borrow().get(&(self.ty, offset)) {\n             return pointee;"}]}