{"sha": "8f0edba6e991973dc67fc1e2ff51200c695c57fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmMGVkYmE2ZTk5MTk3M2RjNjdmYzFlMmZmNTEyMDBjNjk1YzU3ZmQ=", "commit": {"author": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-06-11T13:33:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-06-11T13:33:26Z"}, "message": "Merge pull request #2815 from darArch/master\n\nWarn if non-trivial work is done inside .expect", "tree": {"sha": "938692d7dc04bd559815614a53a6442bc83a8b2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/938692d7dc04bd559815614a53a6442bc83a8b2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f0edba6e991973dc67fc1e2ff51200c695c57fd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbHnomCRBK7hj4Ov3rIwAAdHIIAAI6sqBgJ9dRBU06lWE4PY3n\nRt7+vDQ/EmrH6/bpJdSAqHBR3c4C20jUH2liB4kqDSqz9/7Pk1ejLZpIwWNawIKx\n2jpRvvYca8N4OdUwJHJYWyfzrDytfpwnteKoJh3ZDnomKnFA6JS6EqzLi6NwfV8F\nn/wpBWI9pCrB0zQL/yEsQshGDsGT4fFja8NV8GSF9EbIBJAxURrJZ+H9Xxxyw2Az\nQqn7stEhiOcLCtAow/xJXcRKnb/VoJrVq+3ILmWN4+iZW53qxwcE8AR2kImC8K+Q\nJOSGLOhe1OpmsvkVOgCC9a/lIvKPPWAnl9L1HQ6fIwS1L196DMzlbgYg8Fns9KY=\n=F/Q9\n-----END PGP SIGNATURE-----\n", "payload": "tree 938692d7dc04bd559815614a53a6442bc83a8b2a\nparent 8fe90e41d05cf92b4bcc35055c4a825342d4eae4\nparent c6fb47331a3396a11d4e552f6afb176c7833c1a4\nauthor Oliver Schneider <github35764891676564198441@oli-obk.de> 1528724006 -0700\ncommitter GitHub <noreply@github.com> 1528724006 -0700\n\nMerge pull request #2815 from darArch/master\n\nWarn if non-trivial work is done inside .expect"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f0edba6e991973dc67fc1e2ff51200c695c57fd", "html_url": "https://github.com/rust-lang/rust/commit/8f0edba6e991973dc67fc1e2ff51200c695c57fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f0edba6e991973dc67fc1e2ff51200c695c57fd/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8fe90e41d05cf92b4bcc35055c4a825342d4eae4", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fe90e41d05cf92b4bcc35055c4a825342d4eae4", "html_url": "https://github.com/rust-lang/rust/commit/8fe90e41d05cf92b4bcc35055c4a825342d4eae4"}, {"sha": "c6fb47331a3396a11d4e552f6afb176c7833c1a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6fb47331a3396a11d4e552f6afb176c7833c1a4", "html_url": "https://github.com/rust-lang/rust/commit/c6fb47331a3396a11d4e552f6afb176c7833c1a4"}], "stats": {"total": 262, "additions": 235, "deletions": 27}, "files": [{"sha": "e49cc0cec28b100af72e900a6f71c04a8512b563", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f0edba6e991973dc67fc1e2ff51200c695c57fd/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f0edba6e991973dc67fc1e2ff51200c695c57fd/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=8f0edba6e991973dc67fc1e2ff51200c695c57fd", "patch": "@@ -592,6 +592,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         methods::OK_EXPECT,\n         methods::OPTION_MAP_OR_NONE,\n         methods::OR_FUN_CALL,\n+        methods::EXPECT_FUN_CALL,\n         methods::SEARCH_IS_SOME,\n         methods::SHOULD_IMPLEMENT_TRAIT,\n         methods::SINGLE_CHAR_PATTERN,\n@@ -907,6 +908,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         loops::UNUSED_COLLECT,\n         methods::ITER_NTH,\n         methods::OR_FUN_CALL,\n+        methods::EXPECT_FUN_CALL,\n         methods::SINGLE_CHAR_PATTERN,\n         misc::CMP_OWNED,\n         mutex_atomic::MUTEX_ATOMIC,"}, {"sha": "d2bad6f58be2bedba4ec397b5fd434d8c2527937", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 134, "deletions": 2, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/8f0edba6e991973dc67fc1e2ff51200c695c57fd/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f0edba6e991973dc67fc1e2ff51200c695c57fd/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=8f0edba6e991973dc67fc1e2ff51200c695c57fd", "patch": "@@ -7,8 +7,8 @@ use std::fmt;\n use std::iter;\n use syntax::ast;\n use syntax::codemap::{Span, BytePos};\n-use crate::utils::{get_arg_name, get_trait_def_id, implements_trait, in_external_macro, in_macro, is_copy, is_self, is_self_ty,\n-            iter_input_pats, last_path_segment, match_def_path, match_path, match_qpath, match_trait_method,\n+use crate::utils::{get_arg_name, get_trait_def_id, implements_trait, in_external_macro, in_macro, is_copy, is_expn_of, is_self, \n+            is_self_ty, iter_input_pats, last_path_segment, match_def_path, match_path, match_qpath, match_trait_method,\n             match_type, method_chain_args, match_var, return_ty, remove_blocks, same_tys, single_segment_path, snippet,\n             span_lint, span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth};\n use crate::utils::paths;\n@@ -329,6 +329,36 @@ declare_clippy_lint! {\n     \"using any `*or` method with a function call, which suggests `*or_else`\"\n }\n \n+/// **What it does:** Checks for calls to `.expect(&format!(...))`, `.expect(foo(..))`,\n+/// etc., and suggests to use `unwrap_or_else` instead\n+///\n+/// **Why is this bad?** The function will always be called.\n+///\n+/// **Known problems:** If the function has side-effects, not calling it will\n+/// change the semantic of the program, but you shouldn't rely on that anyway.\n+/// \n+/// **Example:**\n+/// ```rust\n+/// foo.expect(&format(\"Err {}: {}\", err_code, err_msg))\n+/// ```\n+/// or\n+/// ```rust\n+/// foo.expect(format(\"Err {}: {}\", err_code, err_msg).as_str())\n+/// ```\n+/// this can instead be written:\n+/// ```rust\n+/// foo.unwrap_or_else(|_| panic!(\"Err {}: {}\", err_code, err_msg))\n+/// ```\n+/// or\n+/// ```rust\n+/// foo.unwrap_or_else(|_| panic!(format(\"Err {}: {}\", err_code, err_msg).as_str()))\n+/// ```\n+declare_clippy_lint! {\n+    pub EXPECT_FUN_CALL,\n+    perf,\n+    \"using any `expect` method with a function call\"\n+}\n+\n /// **What it does:** Checks for usage of `.clone()` on a `Copy` type.\n ///\n /// **Why is this bad?** The only reason `Copy` types implement `Clone` is for\n@@ -657,6 +687,7 @@ impl LintPass for Pass {\n             RESULT_MAP_UNWRAP_OR_ELSE,\n             OPTION_MAP_OR_NONE,\n             OR_FUN_CALL,\n+            EXPECT_FUN_CALL,\n             CHARS_NEXT_CMP,\n             CHARS_LAST_CMP,\n             CLONE_ON_COPY,\n@@ -741,6 +772,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 }\n \n                 lint_or_fun_call(cx, expr, *method_span, &method_call.name.as_str(), args);\n+                lint_expect_fun_call(cx, expr, *method_span, &method_call.name.as_str(), args);\n \n                 let self_ty = cx.tables.expr_ty_adjusted(&args[0]);\n                 if args.len() == 1 && method_call.name == \"clone\" {\n@@ -964,6 +996,106 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, name:\n     }\n }\n \n+/// Checks for the `EXPECT_FUN_CALL` lint.\n+fn lint_expect_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, name: &str, args: &[hir::Expr]) {\n+    fn extract_format_args(arg: &hir::Expr) -> Option<&hir::HirVec<hir::Expr>> {\n+        if let hir::ExprAddrOf(_, ref addr_of) = arg.node {\n+            if let hir::ExprCall(ref inner_fun, ref inner_args) = addr_of.node {\n+                if is_expn_of(inner_fun.span, \"format\").is_some() && inner_args.len() == 1 {\n+                    if let hir::ExprCall(_, ref format_args) = inner_args[0].node {\n+                        return Some(format_args);\n+                    }\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    fn generate_format_arg_snippet(cx: &LateContext, a: &hir::Expr) -> String {\n+        if let hir::ExprAddrOf(_, ref format_arg) = a.node {\n+            if let hir::ExprMatch(ref format_arg_expr, _, _) = format_arg.node {\n+                if let hir::ExprTup(ref format_arg_expr_tup) = format_arg_expr.node {\n+                    return snippet(cx, format_arg_expr_tup[0].span, \"..\").into_owned();\n+                }\n+            }\n+        };\n+        \n+        snippet(cx, a.span, \"..\").into_owned()\n+    }\n+\n+    fn check_general_case(\n+        cx: &LateContext,\n+        name: &str,\n+        method_span: Span,\n+        self_expr: &hir::Expr,\n+        arg: &hir::Expr,\n+        span: Span,\n+    ) {\n+        if name != \"expect\" {\n+            return;\n+        }\n+\n+        let self_type = cx.tables.expr_ty(self_expr);\n+        let known_types = &[&paths::OPTION, &paths::RESULT];\n+\n+        // if not a known type, return early\n+        if known_types.iter().all(|&k| !match_type(cx, self_type, k)) {\n+            return;\n+        }\n+\n+        // don't lint for constant values\n+        let owner_def = cx.tcx.hir.get_parent_did(arg.id);\n+        let promotable = cx.tcx.rvalue_promotable_map(owner_def).contains(&arg.hir_id.local_id);\n+        if promotable {\n+            return;\n+        }\n+\n+        let closure = if match_type(cx, self_type, &paths::OPTION) { \"||\" } else { \"|_|\" };\n+        let span_replace_word = method_span.with_hi(span.hi());\n+\n+        if let Some(format_args) = extract_format_args(arg) {\n+            let args_len = format_args.len();\n+            let args: Vec<String> = format_args\n+                .into_iter()\n+                .take(args_len - 1)\n+                .map(|a| generate_format_arg_snippet(cx, a))\n+                .collect();\n+\n+            let sugg = args.join(\", \");\n+\n+            span_lint_and_sugg(\n+                cx,\n+                EXPECT_FUN_CALL,\n+                span_replace_word,\n+                &format!(\"use of `{}` followed by a function call\", name),\n+                \"try this\",\n+                format!(\"unwrap_or_else({} panic!({}))\", closure, sugg),\n+            );\n+\n+            return;\n+        }\n+\n+        let sugg: Cow<_> = snippet(cx, arg.span, \"..\");\n+        \n+        span_lint_and_sugg(\n+            cx,\n+            EXPECT_FUN_CALL,\n+            span_replace_word,\n+            &format!(\"use of `{}` followed by a function call\", name),\n+            \"try this\",\n+            format!(\"unwrap_or_else({} panic!({}))\", closure, sugg),\n+        );\n+    }\n+\n+    if args.len() == 2 {\n+        match args[1].node {\n+            hir::ExprLit(_) => {},\n+            _ => check_general_case(cx, name, method_span, &args[0], &args[1], expr.span),\n+        }\n+    }\n+}\n+\n /// Checks for the `CLONE_ON_COPY` lint.\n fn lint_clone_on_copy(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, arg_ty: Ty) {\n     let ty = cx.tables.expr_ty(expr);"}, {"sha": "b04c008ba239138be1099b88e308fa8df2239d52", "filename": "tests/ui/methods.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8f0edba6e991973dc67fc1e2ff51200c695c57fd/tests%2Fui%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f0edba6e991973dc67fc1e2ff51200c695c57fd/tests%2Fui%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.rs?ref=8f0edba6e991973dc67fc1e2ff51200c695c57fd", "patch": "@@ -342,6 +342,54 @@ fn or_fun_call() {\n     let _ = stringy.unwrap_or(\"\".to_owned());\n }\n \n+/// Checks implementation of the `EXPECT_FUN_CALL` lint\n+fn expect_fun_call() {\n+    struct Foo;\n+\n+    impl Foo {\n+        fn new() -> Self { Foo }\n+\n+        fn expect(&self, msg: &str) {\n+            panic!(\"{}\", msg)\n+        }\n+    }\n+\n+    let with_some = Some(\"value\");\n+    with_some.expect(\"error\");\n+\n+    let with_none: Option<i32> = None;\n+    with_none.expect(\"error\");\n+\n+    let error_code = 123_i32;\n+    let with_none_and_format: Option<i32> = None;\n+    with_none_and_format.expect(&format!(\"Error {}: fake error\", error_code));\n+\n+    let with_none_and_as_str: Option<i32> = None;\n+    with_none_and_as_str.expect(format!(\"Error {}: fake error\", error_code).as_str());\n+\n+    let with_ok: Result<(), ()> = Ok(());\n+    with_ok.expect(\"error\");\n+\n+    let with_err: Result<(), ()> = Err(());\n+    with_err.expect(\"error\");\n+\n+    let error_code = 123_i32;\n+    let with_err_and_format: Result<(), ()> = Err(());\n+    with_err_and_format.expect(&format!(\"Error {}: fake error\", error_code));\n+\n+    let with_err_and_as_str: Result<(), ()> = Err(());\n+    with_err_and_as_str.expect(format!(\"Error {}: fake error\", error_code).as_str());\n+\n+    let with_dummy_type = Foo::new();\n+    with_dummy_type.expect(\"another test string\");\n+\n+    let with_dummy_type_and_format = Foo::new();\n+    with_dummy_type_and_format.expect(&format!(\"Error {}: fake error\", error_code));\n+\n+    let with_dummy_type_and_as_str = Foo::new();\n+    with_dummy_type_and_as_str.expect(format!(\"Error {}: fake error\", error_code).as_str());\n+}\n+\n /// Checks implementation of `ITER_NTH` lint\n fn iter_nth() {\n     let mut some_vec = vec![0, 1, 2, 3];"}, {"sha": "edf081aaa470e54a09a907ab506b82d024aa7598", "filename": "tests/ui/methods.stderr", "status": "modified", "additions": 51, "deletions": 25, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/8f0edba6e991973dc67fc1e2ff51200c695c57fd/tests%2Fui%2Fmethods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8f0edba6e991973dc67fc1e2ff51200c695c57fd/tests%2Fui%2Fmethods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.stderr?ref=8f0edba6e991973dc67fc1e2ff51200c695c57fd", "patch": "@@ -423,83 +423,109 @@ error: use of `unwrap_or` followed by a function call\n 342 |     let _ = stringy.unwrap_or(\"\".to_owned());\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| \"\".to_owned())`\n \n+error: use of `expect` followed by a function call\n+   --> $DIR/methods.rs:365:26\n+    |\n+365 |     with_none_and_format.expect(&format!(\"Error {}: fake error\", error_code));\n+    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| panic!(\"Error {}: fake error\", error_code))`\n+    |\n+    = note: `-D expect-fun-call` implied by `-D warnings`\n+\n+error: use of `expect` followed by a function call\n+   --> $DIR/methods.rs:368:26\n+    |\n+368 |     with_none_and_as_str.expect(format!(\"Error {}: fake error\", error_code).as_str());\n+    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| panic!(format!(\"Error {}: fake error\", error_code).as_str()))`\n+\n+error: use of `expect` followed by a function call\n+   --> $DIR/methods.rs:378:25\n+    |\n+378 |     with_err_and_format.expect(&format!(\"Error {}: fake error\", error_code));\n+    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|_| panic!(\"Error {}: fake error\", error_code))`\n+\n+error: use of `expect` followed by a function call\n+   --> $DIR/methods.rs:381:25\n+    |\n+381 |     with_err_and_as_str.expect(format!(\"Error {}: fake error\", error_code).as_str());\n+    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|_| panic!(format!(\"Error {}: fake error\", error_code).as_str()))`\n+\n error: called `.iter().nth()` on a Vec. Calling `.get()` is both faster and more readable\n-   --> $DIR/methods.rs:353:23\n+   --> $DIR/methods.rs:401:23\n     |\n-353 |         let bad_vec = some_vec.iter().nth(3);\n+401 |         let bad_vec = some_vec.iter().nth(3);\n     |                       ^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `-D iter-nth` implied by `-D warnings`\n \n error: called `.iter().nth()` on a slice. Calling `.get()` is both faster and more readable\n-   --> $DIR/methods.rs:354:26\n+   --> $DIR/methods.rs:402:26\n     |\n-354 |         let bad_slice = &some_vec[..].iter().nth(3);\n+402 |         let bad_slice = &some_vec[..].iter().nth(3);\n     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter().nth()` on a slice. Calling `.get()` is both faster and more readable\n-   --> $DIR/methods.rs:355:31\n+   --> $DIR/methods.rs:403:31\n     |\n-355 |         let bad_boxed_slice = boxed_slice.iter().nth(3);\n+403 |         let bad_boxed_slice = boxed_slice.iter().nth(3);\n     |                               ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter().nth()` on a VecDeque. Calling `.get()` is both faster and more readable\n-   --> $DIR/methods.rs:356:29\n+   --> $DIR/methods.rs:404:29\n     |\n-356 |         let bad_vec_deque = some_vec_deque.iter().nth(3);\n+404 |         let bad_vec_deque = some_vec_deque.iter().nth(3);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter_mut().nth()` on a Vec. Calling `.get_mut()` is both faster and more readable\n-   --> $DIR/methods.rs:361:23\n+   --> $DIR/methods.rs:409:23\n     |\n-361 |         let bad_vec = some_vec.iter_mut().nth(3);\n+409 |         let bad_vec = some_vec.iter_mut().nth(3);\n     |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter_mut().nth()` on a slice. Calling `.get_mut()` is both faster and more readable\n-   --> $DIR/methods.rs:364:26\n+   --> $DIR/methods.rs:412:26\n     |\n-364 |         let bad_slice = &some_vec[..].iter_mut().nth(3);\n+412 |         let bad_slice = &some_vec[..].iter_mut().nth(3);\n     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter_mut().nth()` on a VecDeque. Calling `.get_mut()` is both faster and more readable\n-   --> $DIR/methods.rs:367:29\n+   --> $DIR/methods.rs:415:29\n     |\n-367 |         let bad_vec_deque = some_vec_deque.iter_mut().nth(3);\n+415 |         let bad_vec_deque = some_vec_deque.iter_mut().nth(3);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `skip(x).next()` on an iterator. This is more succinctly expressed by calling `nth(x)`\n-   --> $DIR/methods.rs:379:13\n+   --> $DIR/methods.rs:427:13\n     |\n-379 |     let _ = some_vec.iter().skip(42).next();\n+427 |     let _ = some_vec.iter().skip(42).next();\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `-D iter-skip-next` implied by `-D warnings`\n \n error: called `skip(x).next()` on an iterator. This is more succinctly expressed by calling `nth(x)`\n-   --> $DIR/methods.rs:380:13\n+   --> $DIR/methods.rs:428:13\n     |\n-380 |     let _ = some_vec.iter().cycle().skip(42).next();\n+428 |     let _ = some_vec.iter().cycle().skip(42).next();\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `skip(x).next()` on an iterator. This is more succinctly expressed by calling `nth(x)`\n-   --> $DIR/methods.rs:381:13\n+   --> $DIR/methods.rs:429:13\n     |\n-381 |     let _ = (1..10).skip(10).next();\n+429 |     let _ = (1..10).skip(10).next();\n     |             ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `skip(x).next()` on an iterator. This is more succinctly expressed by calling `nth(x)`\n-   --> $DIR/methods.rs:382:14\n+   --> $DIR/methods.rs:430:14\n     |\n-382 |     let _ = &some_vec[..].iter().skip(3).next();\n+430 |     let _ = &some_vec[..].iter().skip(3).next();\n     |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: used unwrap() on an Option value. If you don't want to handle the None case gracefully, consider using expect() to provide a better panic message\n-   --> $DIR/methods.rs:391:13\n+   --> $DIR/methods.rs:439:13\n     |\n-391 |     let _ = opt.unwrap();\n+439 |     let _ = opt.unwrap();\n     |             ^^^^^^^^^^^^\n     |\n     = note: `-D option-unwrap-used` implied by `-D warnings`\n \n-error: aborting due to 66 previous errors\n+error: aborting due to 70 previous errors\n "}]}