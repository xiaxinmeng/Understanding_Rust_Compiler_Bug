{"sha": "74a1041a4d7ae08d223f5ec623f6a698962d5667", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0YTEwNDFhNGQ3YWUwOGQyMjNmNWVjNjIzZjZhNjk4OTYyZDU2Njc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-20T20:05:29Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-26T16:42:05Z"}, "message": "Implement the new parsing rules for types in the parser, modifying the AST appropriately.", "tree": {"sha": "adea38306fefbe0f040e336eca718692cedff0a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/adea38306fefbe0f040e336eca718692cedff0a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74a1041a4d7ae08d223f5ec623f6a698962d5667", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74a1041a4d7ae08d223f5ec623f6a698962d5667", "html_url": "https://github.com/rust-lang/rust/commit/74a1041a4d7ae08d223f5ec623f6a698962d5667", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74a1041a4d7ae08d223f5ec623f6a698962d5667/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8fb027e398ef756b7b02a270ef0304be92e70f4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fb027e398ef756b7b02a270ef0304be92e70f4d", "html_url": "https://github.com/rust-lang/rust/commit/8fb027e398ef756b7b02a270ef0304be92e70f4d"}], "stats": {"total": 496, "additions": 262, "deletions": 234}, "files": [{"sha": "1873213fadf1da05fdbb28fe3038e17d60463280", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74a1041a4d7ae08d223f5ec623f6a698962d5667/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74a1041a4d7ae08d223f5ec623f6a698962d5667/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=74a1041a4d7ae08d223f5ec623f6a698962d5667", "patch": "@@ -145,5 +145,7 @@ register_diagnostics!(\n     E0166,\n     E0167,\n     E0168,\n-    E0169\n+    E0169,\n+    E0170,\n+    E0171\n )"}, {"sha": "d334395e9117f2c54c027fa920c566288d1f8454", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 56, "deletions": 39, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/74a1041a4d7ae08d223f5ec623f6a698962d5667/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74a1041a4d7ae08d223f5ec623f6a698962d5667/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=74a1041a4d7ae08d223f5ec623f6a698962d5667", "patch": "@@ -1396,29 +1396,53 @@ impl<'a> Resolver<'a> {\n                 // methods within to a new module, if the type was defined\n                 // within this module.\n \n-                // Create the module and add all methods.\n-                match ty.node {\n-                    TyPath(ref path, _, _) if path.segments.len() == 1 => {\n+                let mod_name = match ty.node {\n+                    TyPath(ref path, _) if path.segments.len() == 1 => {\n                         // FIXME(18446) we should distinguish between the name of\n                         // a trait and the name of an impl of that trait.\n-                        let mod_name = path.segments.last().unwrap().identifier.name;\n+                        Some(path.segments.last().unwrap().identifier.name)\n+                    }\n+                    TyObjectSum(ref lhs_ty, _) => {\n+                        match lhs_ty.node {\n+                            TyPath(ref path, _) if path.segments.len() == 1 => {\n+                                Some(path.segments.last().unwrap().identifier.name)\n+                            }\n+                            _ => {\n+                                None\n+                            }\n+                        }\n+                    }\n+                    _ => {\n+                        None\n+                    }\n+                };\n \n+                match mod_name {\n+                    None => {\n+                        self.resolve_error(ty.span,\n+                                           \"inherent implementations may \\\n+                                            only be implemented in the same \\\n+                                            module as the type they are \\\n+                                            implemented for\")\n+                    }\n+                    Some(mod_name) => {\n+                        // Create the module and add all methods.\n                         let parent_opt = parent.module().children.borrow()\n-                                               .get(&mod_name).cloned();\n+                            .get(&mod_name).cloned();\n                         let new_parent = match parent_opt {\n                             // It already exists\n                             Some(ref child) if child.get_module_if_available()\n-                                                .is_some() &&\n-                                           (child.get_module().kind.get() == ImplModuleKind ||\n-                                            child.get_module().kind.get() == TraitModuleKind) => {\n-                                ModuleReducedGraphParent(child.get_module())\n-                            }\n+                                .is_some() &&\n+                                (child.get_module().kind.get() == ImplModuleKind ||\n+                                 child.get_module().kind.get() == TraitModuleKind) => {\n+                                    ModuleReducedGraphParent(child.get_module())\n+                                }\n                             Some(ref child) if child.get_module_if_available()\n-                                                .is_some() &&\n-                                           child.get_module().kind.get() ==\n-                                                EnumModuleKind => {\n-                                ModuleReducedGraphParent(child.get_module())\n-                            }\n+                                .is_some() &&\n+                                child.get_module().kind.get() ==\n+                                EnumModuleKind => {\n+                                    ModuleReducedGraphParent(child.get_module())\n+                                }\n                             // Create the module\n                             _ => {\n                                 let name_bindings =\n@@ -1433,7 +1457,7 @@ impl<'a> Resolver<'a> {\n                                 let ns = TypeNS;\n                                 let is_public =\n                                     !name_bindings.defined_in_namespace(ns) ||\n-                                     name_bindings.defined_in_public_namespace(ns);\n+                                    name_bindings.defined_in_public_namespace(ns);\n \n                                 name_bindings.define_module(parent_link,\n                                                             Some(def_id),\n@@ -1459,21 +1483,21 @@ impl<'a> Resolver<'a> {\n                                                        ForbidDuplicateValues,\n                                                        method.span);\n                                     let def = match method.pe_explicit_self()\n-                                                          .node {\n-                                        SelfStatic => {\n-                                            // Static methods become\n-                                            // `DefStaticMethod`s.\n-                                            DefStaticMethod(local_def(method.id),\n-                                                            FromImpl(local_def(item.id)))\n-                                        }\n-                                        _ => {\n-                                            // Non-static methods become\n-                                            // `DefMethod`s.\n-                                            DefMethod(local_def(method.id),\n-                                                      None,\n-                                                      FromImpl(local_def(item.id)))\n-                                        }\n-                                    };\n+                                        .node {\n+                                            SelfStatic => {\n+                                                // Static methods become\n+                                                // `DefStaticMethod`s.\n+                                                DefStaticMethod(local_def(method.id),\n+                                                                FromImpl(local_def(item.id)))\n+                                            }\n+                                            _ => {\n+                                                // Non-static methods become\n+                                                // `DefMethod`s.\n+                                                DefMethod(local_def(method.id),\n+                                                          None,\n+                                                          FromImpl(local_def(item.id)))\n+                                            }\n+                                        };\n \n                                     // NB: not IMPORTABLE\n                                     let modifiers = if method.pe_vis() == ast::Public {\n@@ -1496,7 +1520,7 @@ impl<'a> Resolver<'a> {\n                                             ForbidDuplicateTypesAndModules,\n                                             typedef.span);\n                                     let def = DefAssociatedTy(local_def(\n-                                            typedef.id));\n+                                        typedef.id));\n                                     // NB: not IMPORTABLE\n                                     let modifiers = if typedef.vis == ast::Public {\n                                         PUBLIC\n@@ -1511,13 +1535,6 @@ impl<'a> Resolver<'a> {\n                             }\n                         }\n                     }\n-                    _ => {\n-                        self.resolve_error(ty.span,\n-                                           \"inherent implementations may \\\n-                                            only be implemented in the same \\\n-                                            module as the type they are \\\n-                                            implemented for\")\n-                    }\n                 }\n \n                 parent"}, {"sha": "8f1e2d115d3f139f831d71c920262afc7996dc0e", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 98, "deletions": 77, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/74a1041a4d7ae08d223f5ec623f6a698962d5667/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74a1041a4d7ae08d223f5ec623f6a698962d5667/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=74a1041a4d7ae08d223f5ec623f6a698962d5667", "patch": "@@ -59,8 +59,9 @@ use middle::typeck::rscope::{UnelidableRscope, RegionScope, SpecificRscope,\n                              ShiftedRscope, BindingRscope};\n use middle::typeck::rscope;\n use middle::typeck::TypeAndSubsts;\n+use util::common::ErrorReported;\n use util::nodemap::DefIdMap;\n-use util::ppaux::{Repr, UserString};\n+use util::ppaux::{mod, Repr, UserString};\n \n use std::rc::Rc;\n use std::iter::AdditiveIterator;\n@@ -585,7 +586,7 @@ fn check_path_args(tcx: &ty::ctxt,\n pub fn ast_ty_to_prim_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ast_ty: &ast::Ty)\n                                -> Option<Ty<'tcx>> {\n     match ast_ty.node {\n-        ast::TyPath(ref path, _, id) => {\n+        ast::TyPath(ref path, id) => {\n             let a_def = match tcx.def_map.borrow().get(&id) {\n                 None => {\n                     tcx.sess.span_bug(ast_ty.span,\n@@ -642,7 +643,7 @@ pub fn ast_ty_to_builtin_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n     }\n \n     match ast_ty.node {\n-        ast::TyPath(ref path, _, id) => {\n+        ast::TyPath(ref path, id) => {\n             let a_def = match this.tcx().def_map.borrow().get(&id) {\n                 None => {\n                     this.tcx()\n@@ -682,64 +683,92 @@ pub fn ast_ty_to_builtin_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n     }\n }\n \n-// Handle `~`, `Box`, and `&` being able to mean strs and vecs.\n-// If a_seq_ty is a str or a vec, make it a str/vec.\n-// Also handle first-class trait types.\n-fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n-        this: &AC,\n-        rscope: &RS,\n-        a_seq_mutbl: ast::Mutability,\n-        a_seq_ty: &ast::Ty,\n-        region: ty::Region,\n-        constr: |Ty<'tcx>| -> Ty<'tcx>)\n-        -> Ty<'tcx>\n+fn ast_ty_to_trait_ref<'tcx,AC,RS>(this: &AC,\n+                                   rscope: &RS,\n+                                   ty: &ast::Ty,\n+                                   bounds: &[ast::TyParamBound])\n+                                   -> Result<ty::TraitRef<'tcx>, ErrorReported>\n+    where AC : AstConv<'tcx>, RS : RegionScope\n {\n-    let tcx = this.tcx();\n-\n-    debug!(\"mk_pointer(region={}, a_seq_ty={})\",\n-           region,\n-           a_seq_ty.repr(tcx));\n+    /*!\n+     * In a type like `Foo + Send`, we want to wait to collect the\n+     * full set of bounds before we make the object type, because we\n+     * need them to infer a region bound.  (For example, if we tried\n+     * made a type from just `Foo`, then it wouldn't be enough to\n+     * infer a 'static bound, and hence the user would get an error.)\n+     * So this function is used when we're dealing with a sum type to\n+     * convert the LHS. It only accepts a type that refers to a trait\n+     * name, and reports an error otherwise.\n+     */\n \n-    match a_seq_ty.node {\n-        ast::TyVec(ref ty) => {\n-            let ty = ast_ty_to_ty(this, rscope, &**ty);\n-            return constr(ty::mk_vec(tcx, ty, None));\n+    match ty.node {\n+        ast::TyPath(ref path, id) => {\n+            match this.tcx().def_map.borrow().get(&id) {\n+                Some(&def::DefTrait(trait_def_id)) => {\n+                    return Ok(ast_path_to_trait_ref(this,\n+                                                    rscope,\n+                                                    trait_def_id,\n+                                                    None,\n+                                                    path));\n+                }\n+                _ => {\n+                    span_err!(this.tcx().sess, ty.span, E0170, \"expected a reference to a trait\");\n+                    Err(ErrorReported)\n+                }\n+            }\n         }\n-        ast::TyPath(ref path, ref opt_bounds, id) => {\n-            // Note that the \"bounds must be empty if path is not a trait\"\n-            // restriction is enforced in the below case for ty_path, which\n-            // will run after this as long as the path isn't a trait.\n-            match tcx.def_map.borrow().get(&id) {\n-                Some(&def::DefPrimTy(ast::TyStr)) => {\n-                    check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                    return ty::mk_str_slice(tcx, region, a_seq_mutbl);\n+        _ => {\n+            span_err!(this.tcx().sess, ty.span, E0171,\n+                      \"expected a path on the left-hand side of `+`, not `{}`\",\n+                      pprust::ty_to_string(ty));\n+            match ty.node {\n+                ast::TyRptr(None, ref mut_ty) => {\n+                    span_note!(this.tcx().sess, ty.span,\n+                               \"perhaps you meant `&{}({} +{})`? (per RFC 248)\",\n+                               ppaux::mutability_to_string(mut_ty.mutbl),\n+                               pprust::ty_to_string(&*mut_ty.ty),\n+                               pprust::bounds_to_string(bounds));\n                 }\n-                Some(&def::DefTrait(trait_def_id)) => {\n-                    let result = ast_path_to_trait_ref(this,\n-                                                       rscope,\n-                                                       trait_def_id,\n-                                                       None,\n-                                                       path);\n-                    let empty_vec = [];\n-                    let bounds = match *opt_bounds { None => empty_vec.as_slice(),\n-                                                     Some(ref bounds) => bounds.as_slice() };\n-                    let existential_bounds = conv_existential_bounds(this,\n-                                                                     rscope,\n-                                                                     path.span,\n-                                                                     &[Rc::new(result.clone())],\n-                                                                     bounds);\n-                    let tr = ty::mk_trait(tcx,\n-                                          result,\n-                                          existential_bounds);\n-                    return ty::mk_rptr(tcx, region, ty::mt{mutbl: a_seq_mutbl, ty: tr});\n+\n+                ast::TyRptr(Some(ref lt), ref mut_ty) => {\n+                    span_note!(this.tcx().sess, ty.span,\n+                               \"perhaps you meant `&{} {}({} +{})`? (per RFC 248)\",\n+                               pprust::lifetime_to_string(lt),\n+                               ppaux::mutability_to_string(mut_ty.mutbl),\n+                               pprust::ty_to_string(&*mut_ty.ty),\n+                               pprust::bounds_to_string(bounds));\n+                }\n+\n+                _ => {\n+                    span_note!(this.tcx().sess, ty.span,\n+                               \"perhaps you forget parentheses? (per RFC 248)\");\n                 }\n-                _ => {}\n             }\n+            Err(ErrorReported)\n         }\n-        _ => {}\n     }\n \n-    constr(ast_ty_to_ty(this, rscope, a_seq_ty))\n+}\n+\n+fn trait_ref_to_object_type<'tcx,AC,RS>(this: &AC,\n+                                        rscope: &RS,\n+                                        span: Span,\n+                                        trait_ref: ty::TraitRef<'tcx>,\n+                                        bounds: &[ast::TyParamBound])\n+                                        -> Ty<'tcx>\n+    where AC : AstConv<'tcx>, RS : RegionScope\n+{\n+    let existential_bounds = conv_existential_bounds(this,\n+                                                     rscope,\n+                                                     span,\n+                                                     &[Rc::new(trait_ref.clone())],\n+                                                     bounds);\n+\n+    let result = ty::mk_trait(this.tcx(), trait_ref, existential_bounds);\n+    debug!(\"trait_ref_to_object_type: result={}\",\n+           result.repr(this.tcx()));\n+\n+    result\n }\n \n fn qpath_to_ty<'tcx,AC,RS>(this: &AC,\n@@ -806,6 +835,17 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n             ast::TyVec(ref ty) => {\n                 ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty), None)\n             }\n+            ast::TyObjectSum(ref ty, ref bounds) => {\n+                match ast_ty_to_trait_ref(this, rscope, &**ty, bounds.as_slice()) {\n+                    Ok(trait_ref) => {\n+                        trait_ref_to_object_type(this, rscope, ast_ty.span,\n+                                                 trait_ref, bounds.as_slice())\n+                    }\n+                    Err(ErrorReported) => {\n+                        ty::mk_err()\n+                    }\n+                }\n+            }\n             ast::TyPtr(ref mt) => {\n                 ty::mk_ptr(tcx, ty::mt {\n                     ty: ast_ty_to_ty(this, rscope, &*mt.ty),\n@@ -815,8 +855,8 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n             ast::TyRptr(ref region, ref mt) => {\n                 let r = opt_ast_region_to_region(this, rscope, ast_ty.span, region);\n                 debug!(\"ty_rptr r={}\", r.repr(this.tcx()));\n-                mk_pointer(this, rscope, mt.mutbl, &*mt.ty, r,\n-                           |ty| ty::mk_rptr(tcx, r, ty::mt {ty: ty, mutbl: mt.mutbl}))\n+                let t = ast_ty_to_ty(this, rscope, &*mt.ty);\n+                ty::mk_rptr(tcx, r, ty::mt {ty: t, mutbl: mt.mutbl})\n             }\n             ast::TyTup(ref fields) => {\n                 let flds = fields.iter()\n@@ -874,7 +914,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n             ast::TyPolyTraitRef(ref bounds) => {\n                 conv_ty_poly_trait_ref(this, rscope, ast_ty.span, bounds.as_slice())\n             }\n-            ast::TyPath(ref path, ref bounds, id) => {\n+            ast::TyPath(ref path, id) => {\n                 let a_def = match tcx.def_map.borrow().get(&id) {\n                     None => {\n                         tcx.sess\n@@ -884,35 +924,16 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                     }\n                     Some(&d) => d\n                 };\n-                // Kind bounds on path types are only supported for traits.\n-                match a_def {\n-                    // But don't emit the error if the user meant to do a trait anyway.\n-                    def::DefTrait(..) => { },\n-                    _ if bounds.is_some() =>\n-                        tcx.sess.span_err(ast_ty.span,\n-                                          \"kind bounds can only be used on trait types\"),\n-                    _ => { },\n-                }\n                 match a_def {\n                     def::DefTrait(trait_def_id) => {\n+                        // N.B. this case overlaps somewhat with\n+                        // TyObjectSum, see that fn for details\n                         let result = ast_path_to_trait_ref(this,\n                                                            rscope,\n                                                            trait_def_id,\n                                                            None,\n                                                            path);\n-                        let empty_bounds: &[ast::TyParamBound] = &[];\n-                        let ast_bounds = match *bounds {\n-                            Some(ref b) => b.as_slice(),\n-                            None => empty_bounds\n-                        };\n-                        let bounds = conv_existential_bounds(this,\n-                                                             rscope,\n-                                                             ast_ty.span,\n-                                                             &[Rc::new(result.clone())],\n-                                                             ast_bounds);\n-                        let result_ty = ty::mk_trait(tcx, result, bounds);\n-                        debug!(\"ast_ty_to_ty: result_ty={}\", result_ty.repr(this.tcx()));\n-                        result_ty\n+                        trait_ref_to_object_type(this, rscope, path.span, result, &[])\n                     }\n                     def::DefTy(did, _) | def::DefStruct(did) => {\n                         ast_path_to_ty(this, rscope, did, path).ty"}, {"sha": "14f164ff23b825143ceb9cedb2aa057be4b389d7", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74a1041a4d7ae08d223f5ec623f6a698962d5667/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74a1041a4d7ae08d223f5ec623f6a698962d5667/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=74a1041a4d7ae08d223f5ec623f6a698962d5667", "patch": "@@ -1151,7 +1151,9 @@ pub enum Ty_ {\n     /// A path (`module::module::...::Type`) or primitive\n     ///\n     /// Type parameters are stored in the Path itself\n-    TyPath(Path, Option<TyParamBounds>, NodeId), // for #7264; see above\n+    TyPath(Path, NodeId),\n+    /// Something like `A+B`. Note that `B` must always be a path.\n+    TyObjectSum(P<Ty>, TyParamBounds),\n     /// A type like `for<'a> Foo<&'a Bar>`\n     TyPolyTraitRef(TyParamBounds),\n     /// A \"qualified path\", e.g. `<Vec<T> as SomeTrait>::SomeType`"}, {"sha": "b46f7cdfe22ad1b43e3d9d6633781eca3db6cf4a", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74a1041a4d7ae08d223f5ec623f6a698962d5667/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74a1041a4d7ae08d223f5ec623f6a698962d5667/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=74a1041a4d7ae08d223f5ec623f6a698962d5667", "patch": "@@ -1029,7 +1029,7 @@ mod test {\n                                                 parameters: ast::PathParameters::none(),\n                                             }\n                                         ),\n-                                        }, None, ast::DUMMY_NODE_ID),\n+                                        }, ast::DUMMY_NODE_ID),\n                                         span:sp(10,13)\n                                     }),\n                                     pat: P(ast::Pat {"}, {"sha": "35187ebb5221065a5e0482ae59ae0f8b599cdb4f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 85, "deletions": 107, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/74a1041a4d7ae08d223f5ec623f6a698962d5667/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74a1041a4d7ae08d223f5ec623f6a698962d5667/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=74a1041a4d7ae08d223f5ec623f6a698962d5667", "patch": "@@ -111,16 +111,6 @@ pub enum PathParsingMode {\n     /// A path with a lifetime and type parameters with double colons before\n     /// the type parameters; e.g. `foo::bar::<'a>::Baz::<T>`\n     LifetimeAndTypesWithColons,\n-    /// A path with a lifetime and type parameters with bounds before the last\n-    /// set of type parameters only; e.g. `foo::bar<'a>::Baz+X+Y<T>` This\n-    /// form does not use extra double colons.\n-    LifetimeAndTypesAndBounds,\n-}\n-\n-/// A path paired with optional type bounds.\n-pub struct PathAndBounds {\n-    pub path: ast::Path,\n-    pub bounds: Option<ast::TyParamBounds>,\n }\n \n enum ItemOrViewItem {\n@@ -1053,17 +1043,9 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub fn parse_ty_path(&mut self, plus_allowed: bool) -> Ty_ {\n-        let mode = if plus_allowed {\n-            LifetimeAndTypesAndBounds\n-        } else {\n-            LifetimeAndTypesWithoutColons\n-        };\n-        let PathAndBounds {\n-            path,\n-            bounds\n-        } = self.parse_path(mode);\n-        TyPath(path, bounds, ast::DUMMY_NODE_ID)\n+    pub fn parse_ty_path(&mut self) -> Ty_ {\n+        let path = self.parse_path(LifetimeAndTypesWithoutColons);\n+        TyPath(path, ast::DUMMY_NODE_ID)\n     }\n \n     /// parse a TyBareFn type:\n@@ -1286,7 +1268,7 @@ impl<'a> Parser<'a> {\n         let lo = self.span.lo;\n         let ident = self.parse_ident();\n         self.expect(&token::Eq);\n-        let typ = self.parse_ty(true);\n+        let typ = self.parse_ty_sum();\n         let hi = self.span.hi;\n         self.expect(&token::Semi);\n         Typedef {\n@@ -1385,7 +1367,7 @@ impl<'a> Parser<'a> {\n     /// Parse a possibly mutable type\n     pub fn parse_mt(&mut self) -> MutTy {\n         let mutbl = self.parse_mutability();\n-        let t = self.parse_ty(true);\n+        let t = self.parse_ty();\n         MutTy { ty: t, mutbl: mutbl }\n     }\n \n@@ -1396,7 +1378,7 @@ impl<'a> Parser<'a> {\n         let mutbl = self.parse_mutability();\n         let id = self.parse_ident();\n         self.expect(&token::Colon);\n-        let ty = self.parse_ty(true);\n+        let ty = self.parse_ty_sum();\n         let hi = ty.span.hi;\n         ast::TypeField {\n             ident: id,\n@@ -1411,7 +1393,19 @@ impl<'a> Parser<'a> {\n             if self.eat(&token::Not) {\n                 NoReturn(self.span)\n             } else {\n-                Return(self.parse_ty(true))\n+                let t = self.parse_ty();\n+\n+                // We used to allow `fn foo() -> &T + U`, but don't\n+                // anymore. If we see it, report a useful error.  This\n+                // only makes sense because `parse_ret_ty` is only\n+                // used in fn *declarations*, not fn types or where\n+                // clauses (i.e., not when parsing something like\n+                // `FnMut() -> T + Send`, where the `+` is legal).\n+                if self.token == token::BinOp(token::Plus) {\n+                    self.warn(\"deprecated syntax: `()` are required, see RFC 248 for details\");\n+                }\n+\n+                Return(t)\n             }\n         } else {\n             let pos = self.span.lo;\n@@ -1423,11 +1417,36 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    /// Parse a type in a context where `T1+T2` is allowed.\n+    pub fn parse_ty_sum(&mut self) -> P<Ty> {\n+        let lo = self.span.lo;\n+        let lhs = self.parse_ty();\n+\n+        if !self.eat(&token::BinOp(token::Plus)) {\n+            return lhs;\n+        }\n+\n+        let bounds = self.parse_ty_param_bounds();\n+\n+        // In type grammar, `+` is treated like a binary operator,\n+        // and hence both L and R side are required.\n+        if bounds.len() == 0 {\n+            let last_span = self.last_span;\n+            self.span_err(last_span,\n+                          \"at least one type parameter bound \\\n+                          must be specified\");\n+        }\n+\n+        let sp = mk_sp(lo, self.last_span.hi);\n+        let sum = ast::TyObjectSum(lhs, bounds);\n+        P(Ty {id: ast::DUMMY_NODE_ID, node: sum, span: sp})\n+    }\n+\n     /// Parse a type.\n     ///\n     /// The second parameter specifies whether the `+` binary operator is\n     /// allowed in the type grammar.\n-    pub fn parse_ty(&mut self, plus_allowed: bool) -> P<Ty> {\n+    pub fn parse_ty(&mut self) -> P<Ty> {\n         maybe_whole!(no_clone self, NtTy);\n \n         let lo = self.span.lo;\n@@ -1441,7 +1460,7 @@ impl<'a> Parser<'a> {\n             let mut ts = vec![];\n             let mut last_comma = false;\n             while self.token != token::CloseDelim(token::Paren) {\n-                ts.push(self.parse_ty(true));\n+                ts.push(self.parse_ty_sum());\n                 if self.token == token::Comma {\n                     last_comma = true;\n                     self.bump();\n@@ -1465,15 +1484,15 @@ impl<'a> Parser<'a> {\n                 token::OpenDelim(token::Bracket) => self.obsolete(last_span, ObsoleteOwnedVector),\n                 _ => self.obsolete(last_span, ObsoleteOwnedType)\n             }\n-            TyTup(vec![self.parse_ty(false)])\n+            TyTup(vec![self.parse_ty()])\n         } else if self.token == token::BinOp(token::Star) {\n             // STAR POINTER (bare pointer?)\n             self.bump();\n             TyPtr(self.parse_ptr())\n         } else if self.token == token::OpenDelim(token::Bracket) {\n             // VECTOR\n             self.expect(&token::OpenDelim(token::Bracket));\n-            let t = self.parse_ty(true);\n+            let t = self.parse_ty_sum();\n \n             // Parse the `, ..e` in `[ int, ..e ]`\n             // where `e` is a const expression\n@@ -1514,7 +1533,7 @@ impl<'a> Parser<'a> {\n         } else if self.token == token::Lt {\n             // QUALIFIED PATH `<TYPE as TRAIT_REF>::item`\n             self.bump();\n-            let self_type = self.parse_ty(true);\n+            let self_type = self.parse_ty_sum();\n             self.expect_keyword(keywords::As);\n             let trait_ref = self.parse_trait_ref();\n             self.expect(&token::Gt);\n@@ -1529,7 +1548,7 @@ impl<'a> Parser<'a> {\n                   self.token.is_ident() ||\n                   self.token.is_path() {\n             // NAMED TYPE\n-            self.parse_ty_path(plus_allowed)\n+            self.parse_ty_path()\n         } else if self.eat(&token::Underscore) {\n             // TYPE TO BE INFERRED\n             TyInfer\n@@ -1563,7 +1582,7 @@ impl<'a> Parser<'a> {\n                            known as `*const T`\");\n             MutImmutable\n         };\n-        let t = self.parse_ty(true);\n+        let t = self.parse_ty();\n         MutTy { ty: t, mutbl: mutbl }\n     }\n \n@@ -1603,7 +1622,7 @@ impl<'a> Parser<'a> {\n                                    special_idents::invalid)\n         };\n \n-        let t = self.parse_ty(true);\n+        let t = self.parse_ty_sum();\n \n         Arg {\n             ty: t,\n@@ -1621,7 +1640,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_fn_block_arg(&mut self) -> Arg {\n         let pat = self.parse_pat();\n         let t = if self.eat(&token::Colon) {\n-            self.parse_ty(true)\n+            self.parse_ty_sum()\n         } else {\n             P(Ty {\n                 id: ast::DUMMY_NODE_ID,\n@@ -1739,18 +1758,15 @@ impl<'a> Parser<'a> {\n     /// mode. The `mode` parameter determines whether lifetimes, types, and/or\n     /// bounds are permitted and whether `::` must precede type parameter\n     /// groups.\n-    pub fn parse_path(&mut self, mode: PathParsingMode) -> PathAndBounds {\n+    pub fn parse_path(&mut self, mode: PathParsingMode) -> ast::Path {\n         // Check for a whole path...\n         let found = match self.token {\n             token::Interpolated(token::NtPath(_)) => Some(self.bump_and_get()),\n             _ => None,\n         };\n         match found {\n             Some(token::Interpolated(token::NtPath(box path))) => {\n-                return PathAndBounds {\n-                    path: path,\n-                    bounds: None\n-                }\n+                return path;\n             }\n             _ => {}\n         }\n@@ -1762,8 +1778,7 @@ impl<'a> Parser<'a> {\n         // identifier followed by an optional lifetime and a set of types.\n         // A bound set is a set of type parameter bounds.\n         let segments = match mode {\n-            LifetimeAndTypesWithoutColons |\n-            LifetimeAndTypesAndBounds => {\n+            LifetimeAndTypesWithoutColons => {\n                 self.parse_path_segments_without_colons()\n             }\n             LifetimeAndTypesWithColons => {\n@@ -1774,44 +1789,14 @@ impl<'a> Parser<'a> {\n             }\n         };\n \n-        // Next, parse a plus and bounded type parameters, if\n-        // applicable. We need to remember whether the separate was\n-        // present for later, because in some contexts it's a parse\n-        // error.\n-        let opt_bounds = {\n-            if mode == LifetimeAndTypesAndBounds &&\n-                self.eat(&token::BinOp(token::Plus))\n-            {\n-                let bounds = self.parse_ty_param_bounds();\n-\n-                // For some reason that I do not fully understand, we\n-                // do not permit an empty list in the case where it is\n-                // introduced by a `+`, but we do for `:` and other\n-                // separators. -nmatsakis\n-                if bounds.len() == 0 {\n-                    let last_span = self.last_span;\n-                    self.span_err(last_span,\n-                                  \"at least one type parameter bound \\\n-                                   must be specified\");\n-                }\n-\n-                Some(bounds)\n-            } else {\n-                None\n-            }\n-        };\n-\n         // Assemble the span.\n         let span = mk_sp(lo, self.last_span.hi);\n \n         // Assemble the result.\n-        PathAndBounds {\n-            path: ast::Path {\n-                span: span,\n-                global: is_global,\n-                segments: segments,\n-            },\n-            bounds: opt_bounds,\n+        ast::Path {\n+            span: span,\n+            global: is_global,\n+            segments: segments,\n         }\n     }\n \n@@ -1837,10 +1822,10 @@ impl<'a> Parser<'a> {\n                 let inputs = self.parse_seq_to_end(\n                     &token::CloseDelim(token::Paren),\n                     seq_sep_trailing_allowed(token::Comma),\n-                    |p| p.parse_ty(true));\n+                    |p| p.parse_ty_sum());\n \n                 let output_ty = if self.eat(&token::RArrow) {\n-                    Some(self.parse_ty(true))\n+                    Some(self.parse_ty())\n                 } else {\n                     None\n                 };\n@@ -2327,7 +2312,7 @@ impl<'a> Parser<'a> {\n                         !self.token.is_keyword(keywords::True) &&\n                         !self.token.is_keyword(keywords::False) {\n                     let pth =\n-                        self.parse_path(LifetimeAndTypesWithColons).path;\n+                        self.parse_path(LifetimeAndTypesWithColons);\n \n                     // `!`, as an operator, is prefix, so we know this isn't that\n                     if self.token == token::Not {\n@@ -2898,7 +2883,7 @@ impl<'a> Parser<'a> {\n             }\n             None => {\n                 if as_prec > min_prec && self.eat_keyword(keywords::As) {\n-                    let rhs = self.parse_ty(false);\n+                    let rhs = self.parse_ty();\n                     let _as = self.mk_expr(lhs.span.lo,\n                                            rhs.span.hi,\n                                            ExprCast(lhs, rhs));\n@@ -3362,8 +3347,7 @@ impl<'a> Parser<'a> {\n                     }) {\n                 self.bump();\n                 let end = if self.token.is_ident() || self.token.is_path() {\n-                    let path = self.parse_path(LifetimeAndTypesWithColons)\n-                                   .path;\n+                    let path = self.parse_path(LifetimeAndTypesWithColons);\n                     let hi = self.span.hi;\n                     self.mk_expr(lo, hi, ExprPath(path))\n                 } else {\n@@ -3433,8 +3417,7 @@ impl<'a> Parser<'a> {\n                 }\n             } else {\n                 // parse an enum pat\n-                let enum_path = self.parse_path(LifetimeAndTypesWithColons)\n-                                    .path;\n+                let enum_path = self.parse_path(LifetimeAndTypesWithColons);\n                 match self.token {\n                     token::OpenDelim(token::Brace) => {\n                         self.bump();\n@@ -3548,7 +3531,7 @@ impl<'a> Parser<'a> {\n             span: mk_sp(lo, lo),\n         });\n         if self.eat(&token::Colon) {\n-            ty = self.parse_ty(true);\n+            ty = self.parse_ty_sum();\n         }\n         let init = self.parse_initializer();\n         P(ast::Local {\n@@ -3577,7 +3560,7 @@ impl<'a> Parser<'a> {\n         }\n         let name = self.parse_ident();\n         self.expect(&token::Colon);\n-        let ty = self.parse_ty(true);\n+        let ty = self.parse_ty_sum();\n         spanned(lo, self.last_span.hi, ast::StructField_ {\n             kind: NamedField(name, pr),\n             id: ast::DUMMY_NODE_ID,\n@@ -3624,7 +3607,7 @@ impl<'a> Parser<'a> {\n \n             // Potential trouble: if we allow macros with paths instead of\n             // idents, we'd need to look ahead past the whole path here...\n-            let pth = self.parse_path(NoTypesAllowed).path;\n+            let pth = self.parse_path(NoTypesAllowed);\n             self.bump();\n \n             let id = match self.token {\n@@ -3976,7 +3959,7 @@ impl<'a> Parser<'a> {\n \n         let default = if self.token == token::Eq {\n             self.bump();\n-            Some(self.parse_ty(true))\n+            Some(self.parse_ty_sum())\n         }\n         else { None };\n \n@@ -4032,7 +4015,7 @@ impl<'a> Parser<'a> {\n             Some(token::Comma),\n             |p| {\n                 p.forbid_lifetime();\n-                p.parse_ty(true)\n+                p.parse_ty_sum()\n             }\n         );\n         (lifetimes, result.into_vec())\n@@ -4265,7 +4248,7 @@ impl<'a> Parser<'a> {\n                     // Determine whether this is the fully explicit form, `self:\n                     // TYPE`.\n                     if self.eat(&token::Colon) {\n-                        SelfExplicit(self.parse_ty(false), self_ident)\n+                        SelfExplicit(self.parse_ty_sum(), self_ident)\n                     } else {\n                         SelfValue(self_ident)\n                     }\n@@ -4277,7 +4260,7 @@ impl<'a> Parser<'a> {\n                     // Determine whether this is the fully explicit form,\n                     // `self: TYPE`.\n                     if self.eat(&token::Colon) {\n-                        SelfExplicit(self.parse_ty(false), self_ident)\n+                        SelfExplicit(self.parse_ty_sum(), self_ident)\n                     } else {\n                         SelfValue(self_ident)\n                     }\n@@ -4466,7 +4449,7 @@ impl<'a> Parser<'a> {\n                 && (self.look_ahead(2, |t| *t == token::OpenDelim(token::Paren))\n                     || self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace))) {\n                 // method macro.\n-                let pth = self.parse_path(NoTypesAllowed).path;\n+                let pth = self.parse_path(NoTypesAllowed);\n                 self.expect(&token::Not);\n \n                 // eat a matched-delimiter token tree:\n@@ -4564,30 +4547,25 @@ impl<'a> Parser<'a> {\n         let could_be_trait = self.token != token::OpenDelim(token::Paren);\n \n         // Parse the trait.\n-        let mut ty = self.parse_ty(true);\n+        let mut ty = self.parse_ty_sum();\n \n         // Parse traits, if necessary.\n         let opt_trait = if could_be_trait && self.eat_keyword(keywords::For) {\n             // New-style trait. Reinterpret the type as a trait.\n             let opt_trait_ref = match ty.node {\n-                TyPath(ref path, None, node_id) => {\n+                TyPath(ref path, node_id) => {\n                     Some(TraitRef {\n                         path: (*path).clone(),\n                         ref_id: node_id,\n                     })\n                 }\n-                TyPath(_, Some(_), _) => {\n-                    self.span_err(ty.span,\n-                                  \"bounded traits are only valid in type position\");\n-                    None\n-                }\n                 _ => {\n                     self.span_err(ty.span, \"not a trait\");\n                     None\n                 }\n             };\n \n-            ty = self.parse_ty(true);\n+            ty = self.parse_ty_sum();\n             opt_trait_ref\n         } else {\n             None\n@@ -4606,7 +4584,7 @@ impl<'a> Parser<'a> {\n     /// Parse a::B<String,int>\n     fn parse_trait_ref(&mut self) -> TraitRef {\n         ast::TraitRef {\n-            path: self.parse_path(LifetimeAndTypesWithoutColons).path,\n+            path: self.parse_path(LifetimeAndTypesWithoutColons),\n             ref_id: ast::DUMMY_NODE_ID,\n         }\n     }\n@@ -4638,7 +4616,7 @@ impl<'a> Parser<'a> {\n         let mut generics = self.parse_generics();\n \n         if self.eat(&token::Colon) {\n-            let ty = self.parse_ty(true);\n+            let ty = self.parse_ty_sum();\n             self.span_err(ty.span, \"`virtual` structs have been removed from the language\");\n         }\n \n@@ -4673,7 +4651,7 @@ impl<'a> Parser<'a> {\n                 let struct_field_ = ast::StructField_ {\n                     kind: UnnamedField(p.parse_visibility()),\n                     id: ast::DUMMY_NODE_ID,\n-                    ty: p.parse_ty(true),\n+                    ty: p.parse_ty_sum(),\n                     attrs: attrs,\n                 };\n                 spanned(lo, p.span.hi, struct_field_)\n@@ -4830,7 +4808,7 @@ impl<'a> Parser<'a> {\n     fn parse_item_const(&mut self, m: Option<Mutability>) -> ItemInfo {\n         let id = self.parse_ident();\n         self.expect(&token::Colon);\n-        let ty = self.parse_ty(true);\n+        let ty = self.parse_ty_sum();\n         self.expect(&token::Eq);\n         let e = self.parse_expr();\n         self.commit_expr_expecting(&*e, token::Semi);\n@@ -5023,7 +5001,7 @@ impl<'a> Parser<'a> {\n \n         let ident = self.parse_ident();\n         self.expect(&token::Colon);\n-        let ty = self.parse_ty(true);\n+        let ty = self.parse_ty_sum();\n         let hi = self.span.hi;\n         self.expect(&token::Semi);\n         P(ForeignItem {\n@@ -5181,7 +5159,7 @@ impl<'a> Parser<'a> {\n         let mut tps = self.parse_generics();\n         self.parse_where_clause(&mut tps);\n         self.expect(&token::Eq);\n-        let ty = self.parse_ty(true);\n+        let ty = self.parse_ty_sum();\n         self.expect(&token::Semi);\n         (ident, ItemTy(ty, tps), None)\n     }\n@@ -5235,7 +5213,7 @@ impl<'a> Parser<'a> {\n                     &token::OpenDelim(token::Paren),\n                     &token::CloseDelim(token::Paren),\n                     seq_sep_trailing_allowed(token::Comma),\n-                    |p| p.parse_ty(true)\n+                    |p| p.parse_ty_sum()\n                 );\n                 for ty in arg_tys.into_iter() {\n                     args.push(ast::VariantArg {\n@@ -5593,7 +5571,7 @@ impl<'a> Parser<'a> {\n             // MACRO INVOCATION ITEM\n \n             // item macro.\n-            let pth = self.parse_path(NoTypesAllowed).path;\n+            let pth = self.parse_path(NoTypesAllowed);\n             self.expect(&token::Not);\n \n             // a 'special' identifier (like what `macro_rules!` uses)"}, {"sha": "78412a76bfeb8d4f008419eff6d8f44af2ffbf85", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/74a1041a4d7ae08d223f5ec623f6a698962d5667/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74a1041a4d7ae08d223f5ec623f6a698962d5667/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=74a1041a4d7ae08d223f5ec623f6a698962d5667", "patch": "@@ -293,6 +293,10 @@ pub fn ty_to_string(ty: &ast::Ty) -> String {\n     $to_string(|s| s.print_type(ty))\n }\n \n+pub fn bounds_to_string(bounds: &[ast::TyParamBound]) -> String {\n+    $to_string(|s| s.print_bounds(\"\", bounds))\n+}\n+\n pub fn pat_to_string(pat: &ast::Pat) -> String {\n     $to_string(|s| s.print_pat(pat))\n }\n@@ -739,11 +743,15 @@ impl<'a> State<'a> {\n                                       Some(&generics),\n                                       None));\n             }\n-            ast::TyPath(ref path, ref bounds, _) => {\n-                try!(self.print_bounded_path(path, bounds));\n+            ast::TyPath(ref path, _) => {\n+                try!(self.print_path(path, false));\n+            }\n+            ast::TyObjectSum(ref ty, ref bounds) => {\n+                try!(self.print_type(&**ty));\n+                try!(self.print_bounds(\"+\", bounds.as_slice()));\n             }\n             ast::TyPolyTraitRef(ref bounds) => {\n-                try!(self.print_bounds(\"\", bounds));\n+                try!(self.print_bounds(\"\", bounds.as_slice()));\n             }\n             ast::TyQPath(ref qpath) => {\n                 try!(word(&mut self.s, \"<\"));\n@@ -970,7 +978,7 @@ impl<'a> State<'a> {\n                     }\n                     _ => {}\n                 }\n-                try!(self.print_bounds(\":\", bounds));\n+                try!(self.print_bounds(\":\", bounds.as_slice()));\n                 try!(self.print_where_clause(generics));\n                 try!(word(&mut self.s, \" \"));\n                 try!(self.bopen());\n@@ -2329,7 +2337,7 @@ impl<'a> State<'a> {\n \n     pub fn print_bounds(&mut self,\n                         prefix: &str,\n-                        bounds: &OwnedSlice<ast::TyParamBound>)\n+                        bounds: &[ast::TyParamBound])\n                         -> IoResult<()> {\n         if !bounds.is_empty() {\n             try!(word(&mut self.s, prefix));\n@@ -2418,7 +2426,7 @@ impl<'a> State<'a> {\n             _ => {}\n         }\n         try!(self.print_ident(param.ident));\n-        try!(self.print_bounds(\":\", &param.bounds));\n+        try!(self.print_bounds(\":\", param.bounds.as_slice()));\n         match param.default {\n             Some(ref default) => {\n                 try!(space(&mut self.s));\n@@ -2447,7 +2455,7 @@ impl<'a> State<'a> {\n             }\n \n             try!(self.print_ident(predicate.ident));\n-            try!(self.print_bounds(\":\", &predicate.bounds));\n+            try!(self.print_bounds(\":\", predicate.bounds.as_slice()));\n         }\n \n         Ok(())\n@@ -2664,7 +2672,7 @@ impl<'a> State<'a> {\n             try!(self.pclose());\n         }\n \n-        try!(self.print_bounds(\":\", bounds));\n+        try!(self.print_bounds(\":\", bounds.as_slice()));\n \n         try!(self.print_fn_output(decl));\n "}]}