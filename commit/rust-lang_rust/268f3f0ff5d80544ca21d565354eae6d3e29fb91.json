{"sha": "268f3f0ff5d80544ca21d565354eae6d3e29fb91", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2OGYzZjBmZjVkODA1NDRjYTIxZDU2NTM1NGVhZTZkM2UyOWZiOTE=", "commit": {"author": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2013-08-15T20:28:54Z"}, "committer": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2013-09-16T11:26:48Z"}, "message": "Add rustdoc_ng", "tree": {"sha": "43efc1d4b198196c24075581f1cf879452b0551b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43efc1d4b198196c24075581f1cf879452b0551b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/268f3f0ff5d80544ca21d565354eae6d3e29fb91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/268f3f0ff5d80544ca21d565354eae6d3e29fb91", "html_url": "https://github.com/rust-lang/rust/commit/268f3f0ff5d80544ca21d565354eae6d3e29fb91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/268f3f0ff5d80544ca21d565354eae6d3e29fb91/comments", "author": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "committer": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d87078be727f06581b0d1fc6642abcc3ea6aae31", "url": "https://api.github.com/repos/rust-lang/rust/commits/d87078be727f06581b0d1fc6642abcc3ea6aae31", "html_url": "https://github.com/rust-lang/rust/commit/d87078be727f06581b0d1fc6642abcc3ea6aae31"}], "stats": {"total": 2001, "additions": 2001, "deletions": 0}, "files": [{"sha": "171ce8f19253d57014b80c7962dbc03c67143faa", "filename": "Makefile.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/268f3f0ff5d80544ca21d565354eae6d3e29fb91/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/268f3f0ff5d80544ca21d565354eae6d3e29fb91/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=268f3f0ff5d80544ca21d565354eae6d3e29fb91", "patch": "@@ -214,6 +214,7 @@ CFG_LIBRUSTC_$(1) :=$(call CFG_LIB_NAME_$(1),rustc)\n CFG_LIBSYNTAX_$(1) :=$(call CFG_LIB_NAME_$(1),syntax)\n CFG_LIBRUSTPKG_$(1) :=$(call CFG_LIB_NAME_$(1),rustpkg)\n CFG_LIBRUSTDOC_$(1) :=$(call CFG_LIB_NAME_$(1),rustdoc)\n+CFG_LIBRUSTDOCNG_$(1) :=$(call CFG_LIB_NAME_$(1),rustdoc_ng)\n CFG_LIBRUSTI_$(1) :=$(call CFG_LIB_NAME_$(1),rusti)\n CFG_LIBRUST_$(1) :=$(call CFG_LIB_NAME_$(1),rust)\n \n@@ -223,6 +224,7 @@ LIBRUSTC_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),rustc)\n LIBSYNTAX_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),syntax)\n LIBRUSTPKG_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),rustpkg)\n LIBRUSTDOC_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),rustdoc)\n+LIBRUSTDOCNG_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),rustdoc_ng)\n LIBRUSTI_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),rusti)\n LIBRUST_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),rust)\n EXTRALIB_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),extra)\n@@ -231,6 +233,7 @@ LIBRUSTC_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),rustc)\n LIBSYNTAX_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),syntax)\n LIBRUSTPKG_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),rustpkg)\n LIBRUSTDOC_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),rustdoc)\n+LIBRUSTDOCNG_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),rustdoc_ng)\n LIBRUSTI_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),rusti)\n LIBRUST_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),rust)\n \n@@ -443,6 +446,7 @@ CSREQ$(1)_T_$(2)_H_$(3) = \\\n \t$$(HBIN$(1)_H_$(3))/rust$$(X_$(3)) \\\n \t$$(HLIB$(1)_H_$(3))/$(CFG_LIBRUSTPKG_$(3)) \\\n \t$$(HLIB$(1)_H_$(3))/$(CFG_LIBRUSTDOC_$(3)) \\\n+\t$$(HLIB$(1)_H_$(3))/$(CFG_LIBRUSTDOCNG_$(3)) \\\n \t$$(HLIB$(1)_H_$(3))/$(CFG_LIBRUSTI_$(3)) \\\n \t$$(HLIB$(1)_H_$(3))/$(CFG_LIBRUST_$(3)) \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_STDLIB_$(2)) \\\n@@ -451,6 +455,7 @@ CSREQ$(1)_T_$(2)_H_$(3) = \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTC_$(2)) \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTPKG_$(2)) \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTDOC_$(2)) \\\n+\t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTDOCNG_$(2)) \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTI_$(2)) \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUST_$(2))\n "}, {"sha": "5e8d9835db20f2b80d98542e2d5563a36b122964", "filename": "mk/clean.mk", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/268f3f0ff5d80544ca21d565354eae6d3e29fb91/mk%2Fclean.mk", "raw_url": "https://github.com/rust-lang/rust/raw/268f3f0ff5d80544ca21d565354eae6d3e29fb91/mk%2Fclean.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fclean.mk?ref=268f3f0ff5d80544ca21d565354eae6d3e29fb91", "patch": "@@ -72,6 +72,7 @@ clean$(1)_H_$(2):\n \t$(Q)rm -f $$(HBIN$(1)_H_$(2))/rust$(X_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_LIBRUSTPKG_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_LIBRUSTDOC_$(2))\n+\t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_LIBRUSTDOCNG_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_RUNTIME_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_STDLIB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_EXTRALIB_$(2))\n@@ -85,6 +86,7 @@ clean$(1)_H_$(2):\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBSYNTAX_GLOB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBRUSTPKG_GLOB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBRUSTDOC_GLOB_$(2))\n+\t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBRUSTDOCNG_GLOB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBRUSTI_GLOB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBRUST_GLOB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_RUSTLLVM_$(2))\n@@ -107,6 +109,7 @@ clean$(1)_T_$(2)_H_$(3):\n \t$(Q)rm -f $$(TBIN$(1)_T_$(2)_H_$(3))/rust$(X_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTPKG_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTDOC_$(2))\n+\t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTDOCNG_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_RUNTIME_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_STDLIB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_EXTRALIB_$(2))\n@@ -120,6 +123,7 @@ clean$(1)_T_$(2)_H_$(3):\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBSYNTAX_GLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBRUSTPKG_GLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBRUSTDOC_GLOB_$(2))\n+\t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBRUSTDOCNG_GLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBRUSTI_GLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBRUST_GLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_RUSTLLVM_$(2))"}, {"sha": "bc4633b8225c4b6d8b46abbd98a082c457e288e2", "filename": "mk/install.mk", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/268f3f0ff5d80544ca21d565354eae6d3e29fb91/mk%2Finstall.mk", "raw_url": "https://github.com/rust-lang/rust/raw/268f3f0ff5d80544ca21d565354eae6d3e29fb91/mk%2Finstall.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Finstall.mk?ref=268f3f0ff5d80544ca21d565354eae6d3e29fb91", "patch": "@@ -104,6 +104,7 @@ install-target-$(1)-host-$(2): $$(CSREQ$$(ISTAGE)_T_$(1)_H_$(2))\n \t$$(Q)$$(call INSTALL_LIB,$$(LIBSYNTAX_GLOB_$(1)))\n \t$$(Q)$$(call INSTALL_LIB,$$(LIBRUSTPKG_GLOB_$(1)))\n \t$$(Q)$$(call INSTALL_LIB,$$(LIBRUSTDOC_GLOB_$(1)))\n+\t$$(Q)$$(call INSTALL_LIB,$$(LIBRUSTDOCNG_GLOB_$(1)))\n \t$$(Q)$$(call INSTALL_LIB,$$(LIBRUSTI_GLOB_$(1)))\n \t$$(Q)$$(call INSTALL_LIB,$$(LIBRUST_GLOB_$(1)))\n \t$$(Q)$$(call INSTALL_LIB,libmorestack.a)\n@@ -149,6 +150,7 @@ install-host: $(CSREQ$(ISTAGE)_T_$(CFG_BUILD_TRIPLE)_H_$(CFG_BUILD_TRIPLE))\n \t$(Q)$(call INSTALL_LIB,$(LIBRUST_GLOB_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL_LIB,$(LIBRUSTPKG_GLOB_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL_LIB,$(LIBRUSTDOC_GLOB_$(CFG_BUILD_TRIPLE)))\n+\t$(Q)$(call INSTALL_LIB,$(LIBRUSTDOCNG_GLOB_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL,$(HL),$(PHL),$(CFG_RUNTIME_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL,$(HL),$(PHL),$(CFG_RUSTLLVM_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL,$(S)/man, $(PREFIX_ROOT)/share/man/man1,rust.1)"}, {"sha": "b5e413804ec4d73821856af9677689f52904d64f", "filename": "mk/tools.mk", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/268f3f0ff5d80544ca21d565354eae6d3e29fb91/mk%2Ftools.mk", "raw_url": "https://github.com/rust-lang/rust/raw/268f3f0ff5d80544ca21d565354eae6d3e29fb91/mk%2Ftools.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftools.mk?ref=268f3f0ff5d80544ca21d565354eae6d3e29fb91", "patch": "@@ -23,6 +23,11 @@ RUSTPKG_INPUTS := $(wildcard $(S)src/librustpkg/*.rs)\n RUSTDOC_LIB := $(S)src/librustdoc/rustdoc.rs\n RUSTDOC_INPUTS := $(wildcard $(S)src/librustdoc/*.rs)\n \n+# rustdoc_ng, the next generation documentation tool\n+\n+RUSTDOCNG_LIB := $(S)src/rustdoc/lib.rs\n+RUSTDOCNG_INPUTS := $(wildcard $(S)src/rustdoc/*.rs)\n+\n # Rusti, the JIT REPL\n RUSTI_LIB := $(S)src/librusti/rusti.rs\n RUSTI_INPUTS := $(wildcard $(S)src/librusti/*.rs)\n@@ -78,6 +83,14 @@ $$(TBIN$(1)_T_$(4)_H_$(3))/rustdoc$$(X_$(4)):\t\t\t\\\n \t@$$(call E, compile_and_link: $$@)\n \t$$(STAGE$(1)_T_$(4)_H_$(3)) --cfg rustdoc -o $$@ $$<\n \n+$$(TBIN$(1)_T_$(4)_H_$(3))/rustdoc_ng$$(X_$(4)):\t\t\t\\\n+\t\t$$(DRIVER_CRATE) \t\t\t\t\t\t\t\\\n+\t\t$$(TSREQ$(1)_T_$(4)_H_$(3))\t\t\t\t\t\t\\\n+\t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBRUSTDOCNG_$(4))\t\t\t\\\n+\t\t| $$(TBIN$(1)_T_$(4)_H_$(3))/\n+\t@$$(call E, compile_and_link: $$@)\n+\t$$(STAGE$(1)_T_$(4)_H_$(3)) --cfg rustdoc_ng -o $$@ $$<\n+\n $$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBRUSTI_$(4)):\t\t\\\n \t\t$$(RUSTI_LIB) $$(RUSTI_INPUTS)\t\t\t\\\n \t\t$$(SREQ$(1)_T_$(4)_H_$(3))\t\t\t\\"}, {"sha": "62f94a1a44e985ed44164503a675c968be6b473f", "filename": "src/rustdoc_ng/.gitignore", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/268f3f0ff5d80544ca21d565354eae6d3e29fb91/src%2Frustdoc_ng%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/268f3f0ff5d80544ca21d565354eae6d3e29fb91/src%2Frustdoc_ng%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc_ng%2F.gitignore?ref=268f3f0ff5d80544ca21d565354eae6d3e29fb91", "patch": "@@ -0,0 +1,2 @@\n+*.swp\n+main"}, {"sha": "ed18fc04fade0a857e6020c7b20f0bbd91f15733", "filename": "src/rustdoc_ng/clean.rs", "status": "added", "additions": 1081, "deletions": 0, "changes": 1081, "blob_url": "https://github.com/rust-lang/rust/blob/268f3f0ff5d80544ca21d565354eae6d3e29fb91/src%2Frustdoc_ng%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/268f3f0ff5d80544ca21d565354eae6d3e29fb91/src%2Frustdoc_ng%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc_ng%2Fclean.rs?ref=268f3f0ff5d80544ca21d565354eae6d3e29fb91", "patch": "@@ -0,0 +1,1081 @@\n+//! This module contains the \"cleaned\" pieces of the AST, and the functions\n+//! that clean them.\n+\n+use its = syntax::parse::token::ident_to_str;\n+\n+use rustc::metadata::{csearch,decoder,cstore};\n+use syntax;\n+use syntax::ast;\n+\n+use std;\n+use doctree;\n+use visit_ast;\n+use std::local_data;\n+\n+pub trait Clean<T> {\n+    fn clean(&self) -> T;\n+}\n+\n+impl<T: Clean<U>, U> Clean<~[U]> for ~[T] {\n+    fn clean(&self) -> ~[U] {\n+        self.iter().map(|x| x.clean()).collect()\n+    }\n+}\n+impl<T: Clean<U>, U> Clean<U> for @T {\n+    fn clean(&self) -> U {\n+        (**self).clean()\n+    }\n+}\n+\n+impl<T: Clean<U>, U> Clean<Option<U>> for Option<T> {\n+    fn clean(&self) -> Option<U> {\n+        match self {\n+            &None => None,\n+            &Some(ref v) => Some(v.clean())\n+        }\n+    }\n+}\n+\n+impl<T: Clean<U>, U> Clean<~[U]> for syntax::opt_vec::OptVec<T> {\n+    fn clean(&self) -> ~[U] {\n+        match self {\n+            &syntax::opt_vec::Empty => ~[],\n+            &syntax::opt_vec::Vec(ref v) => v.clean()\n+        }\n+    }\n+}\n+\n+#[deriving(Clone, Encodable, Decodable)]\n+pub struct Crate {\n+    name: ~str,\n+    module: Option<Item>,\n+}\n+\n+impl Clean<Crate> for visit_ast::RustdocVisitor {\n+    fn clean(&self) -> Crate {\n+        use syntax::attr::{find_linkage_metas, last_meta_item_value_str_by_name};\n+        let maybe_meta = last_meta_item_value_str_by_name(find_linkage_metas(self.attrs), \"name\");\n+\n+        Crate {\n+            name: match maybe_meta {\n+                Some(x) => x.to_owned(),\n+                None => fail!(\"rustdoc_ng requires a #[link(name=\\\"foo\\\")] crate attribute\"),\n+            },\n+            module: Some(self.module.clean()),\n+        }\n+    }\n+}\n+\n+/// Anything with a source location and set of attributes and, optionally, a\n+/// name. That is, anything that can be documented. This doesn't correspond\n+/// directly to the AST's concept of an item; it's a strict superset.\n+#[deriving(Clone, Encodable, Decodable)]\n+pub struct Item {\n+    /// Stringified span\n+    source: ~str,\n+    /// Not everything has a name. E.g., impls\n+    name: Option<~str>,\n+    attrs: ~[Attribute],\n+    inner: ItemEnum,\n+    visibility: Option<Visibility>,\n+    id: ast::NodeId,\n+}\n+\n+#[deriving(Clone, Encodable, Decodable)]\n+pub enum ItemEnum {\n+    StructItem(Struct),\n+    EnumItem(Enum),\n+    FunctionItem(Function),\n+    ModuleItem(Module),\n+    TypedefItem(Typedef),\n+    StaticItem(Static),\n+    TraitItem(Trait),\n+    ImplItem(Impl),\n+    ViewItemItem(ViewItem),\n+    TyMethodItem(TyMethod),\n+    MethodItem(Method),\n+    StructFieldItem(StructField),\n+    VariantItem(Variant),\n+}\n+\n+#[deriving(Clone, Encodable, Decodable)]\n+pub struct Module {\n+    items: ~[Item],\n+}\n+\n+impl Clean<Item> for doctree::Module {\n+    fn clean(&self) -> Item {\n+        let name = if self.name.is_some() {\n+            self.name.unwrap().clean()\n+        } else {\n+            ~\"\"\n+        };\n+        Item {\n+            name: Some(name),\n+            attrs: self.attrs.clean(),\n+            source: self.where.clean(),\n+            visibility: self.vis.clean(),\n+            id: self.id,\n+            inner: ModuleItem(Module {\n+               items: std::vec::concat(&[self.structs.clean(),\n+                              self.enums.clean(), self.fns.clean(),\n+                              self.mods.clean(), self.typedefs.clean(),\n+                              self.statics.clean(), self.traits.clean(),\n+                              self.impls.clean(), self.view_items.clean()])\n+            })\n+        }\n+    }\n+}\n+\n+#[deriving(Clone, Encodable, Decodable)]\n+pub enum Attribute {\n+    Word(~str),\n+    List(~str, ~[Attribute]),\n+    NameValue(~str, ~str)\n+}\n+\n+impl Clean<Attribute> for ast::MetaItem {\n+    fn clean(&self) -> Attribute {\n+        match self.node {\n+            ast::MetaWord(s) => Word(s.to_owned()),\n+            ast::MetaList(ref s, ref l) => List(s.to_owned(), l.clean()),\n+            ast::MetaNameValue(s, ref v) => NameValue(s.to_owned(), lit_to_str(v))\n+        }\n+    }\n+}\n+\n+impl Clean<Attribute> for ast::Attribute {\n+    fn clean(&self) -> Attribute {\n+        self.node.value.clean()\n+    }\n+}\n+\n+#[deriving(Clone, Encodable, Decodable)]\n+pub struct TyParam {\n+    name: ~str,\n+    id: ast::NodeId,\n+    bounds: ~[TyParamBound]\n+}\n+\n+impl Clean<TyParam> for ast::TyParam {\n+    fn clean(&self) -> TyParam {\n+        TyParam {\n+            name: self.ident.clean(),\n+            id: self.id,\n+            bounds: self.bounds.clean(),\n+        }\n+    }\n+}\n+\n+#[deriving(Clone, Encodable, Decodable)]\n+pub enum TyParamBound {\n+    RegionBound,\n+    TraitBound(Type)\n+}\n+\n+impl Clean<TyParamBound> for ast::TyParamBound {\n+    fn clean(&self) -> TyParamBound {\n+        match *self {\n+            ast::RegionTyParamBound => RegionBound,\n+            ast::TraitTyParamBound(ref t) => TraitBound(t.clean()),\n+        }\n+    }\n+}\n+\n+#[deriving(Clone, Encodable, Decodable)]\n+pub struct Lifetime(~str);\n+\n+impl Clean<Lifetime> for ast::Lifetime {\n+    fn clean(&self) -> Lifetime {\n+        Lifetime(self.ident.clean())\n+    }\n+}\n+\n+// maybe use a Generic enum and use ~[Generic]?\n+#[deriving(Clone, Encodable, Decodable)]\n+pub struct Generics {\n+    lifetimes: ~[Lifetime],\n+    type_params: ~[TyParam]\n+}\n+\n+impl Generics {\n+    fn new() -> Generics {\n+        Generics {\n+            lifetimes: ~[],\n+            type_params: ~[]\n+        }\n+    }\n+}\n+\n+impl Clean<Generics> for ast::Generics {\n+    fn clean(&self) -> Generics {\n+        Generics {\n+            lifetimes: self.lifetimes.clean(),\n+            type_params: self.ty_params.clean(),\n+        }\n+    }\n+}\n+\n+#[deriving(Clone, Encodable, Decodable)]\n+pub struct Method {\n+    generics: Generics,\n+    self_: SelfTy,\n+    purity: ast::purity,\n+    decl: FnDecl,\n+}\n+\n+impl Clean<Item> for ast::method {\n+    fn clean(&self) -> Item {\n+        Item {\n+            name: Some(self.ident.clean()),\n+            attrs: self.attrs.clean(),\n+            source: self.span.clean(),\n+            id: self.self_id.clone(),\n+            visibility: None,\n+            inner: MethodItem(Method {\n+                generics: self.generics.clean(),\n+                self_: self.explicit_self.clean(),\n+                purity: self.purity.clone(),\n+                decl: self.decl.clean(),\n+            }),\n+        }\n+    }\n+}\n+\n+#[deriving(Clone, Encodable, Decodable)]\n+pub struct TyMethod {\n+    purity: ast::purity,\n+    decl: FnDecl,\n+    generics: Generics,\n+    self_: SelfTy,\n+}\n+\n+impl Clean<Item> for ast::TypeMethod {\n+    fn clean(&self) -> Item {\n+        Item {\n+            name: Some(self.ident.clean()),\n+            attrs: self.attrs.clean(),\n+            source: self.span.clean(),\n+            id: self.id,\n+            visibility: None,\n+            inner: TyMethodItem(TyMethod {\n+                purity: self.purity.clone(),\n+                decl: self.decl.clean(),\n+                self_: self.explicit_self.clean(),\n+                generics: self.generics.clean(),\n+            }),\n+        }\n+    }\n+}\n+\n+#[deriving(Clone, Encodable, Decodable)]\n+pub enum SelfTy {\n+    SelfStatic,\n+    SelfValue,\n+    SelfBorrowed(Option<Lifetime>, Mutability),\n+    SelfManaged(Mutability),\n+    SelfOwned,\n+}\n+\n+impl Clean<SelfTy> for ast::explicit_self {\n+    fn clean(&self) -> SelfTy {\n+        match self.node {\n+            ast::sty_static => SelfStatic,\n+            ast::sty_value => SelfValue,\n+            ast::sty_uniq => SelfOwned,\n+            ast::sty_region(lt, mt) => SelfBorrowed(lt.clean(), mt.clean()),\n+            ast::sty_box(mt) => SelfManaged(mt.clean()),\n+        }\n+    }\n+}\n+\n+#[deriving(Clone, Encodable, Decodable)]\n+pub struct Function {\n+    decl: FnDecl,\n+    generics: Generics,\n+}\n+\n+impl Clean<Item> for doctree::Function {\n+    fn clean(&self) -> Item {\n+        Item {\n+            name: Some(self.name.clean()),\n+            attrs: self.attrs.clean(),\n+            source: self.where.clean(),\n+            visibility: self.vis.clean(),\n+            id: self.id,\n+            inner: FunctionItem(Function {\n+                decl: self.decl.clean(),\n+                generics: self.generics.clean(),\n+            }),\n+        }\n+    }\n+}\n+\n+#[deriving(Clone, Encodable, Decodable)]\n+pub struct ClosureDecl {\n+    sigil: ast::Sigil,\n+    region: Option<Lifetime>,\n+    lifetimes: ~[Lifetime],\n+    decl: FnDecl,\n+    onceness: ast::Onceness,\n+    purity: ast::purity,\n+    bounds: ~[TyParamBound]\n+}\n+\n+impl Clean<ClosureDecl> for ast::TyClosure {\n+    fn clean(&self) -> ClosureDecl {\n+        ClosureDecl {\n+            sigil: self.sigil,\n+            region: self.region.clean(),\n+            lifetimes: self.lifetimes.clean(),\n+            decl: self.decl.clean(),\n+            onceness: self.onceness,\n+            purity: self.purity,\n+            bounds: match self.bounds {\n+                Some(ref x) => x.clean(),\n+                None        => ~[]\n+            },\n+        }\n+    }\n+}\n+\n+#[deriving(Clone, Encodable, Decodable)]\n+pub struct FnDecl {\n+    inputs: ~[Argument],\n+    output: Type,\n+    cf: RetStyle,\n+    attrs: ~[Attribute]\n+}\n+\n+impl Clean<FnDecl> for ast::fn_decl {\n+    fn clean(&self) -> FnDecl {\n+        FnDecl {\n+            inputs: self.inputs.iter().map(|x| x.clean()).collect(),\n+            output: (self.output.clean()),\n+            cf: self.cf.clean(),\n+            attrs: ~[]\n+        }\n+    }\n+}\n+\n+#[deriving(Clone, Encodable, Decodable)]\n+pub struct Argument {\n+    type_: Type,\n+    name: ~str,\n+    id: ast::NodeId\n+}\n+\n+impl Clean<Argument> for ast::arg {\n+    fn clean(&self) -> Argument {\n+        Argument {\n+            name: name_from_pat(self.pat),\n+            type_: (self.ty.clean()),\n+            id: self.id\n+        }\n+    }\n+}\n+\n+#[deriving(Clone, Encodable, Decodable)]\n+pub enum RetStyle {\n+    NoReturn,\n+    Return\n+}\n+\n+impl Clean<RetStyle> for ast::ret_style {\n+    fn clean(&self) -> RetStyle {\n+        match *self {\n+            ast::return_val => Return,\n+            ast::noreturn => NoReturn\n+        }\n+    }\n+}\n+\n+#[deriving(Clone, Encodable, Decodable)]\n+pub struct Trait {\n+    methods: ~[TraitMethod],\n+    generics: Generics,\n+    parents: ~[Type],\n+}\n+\n+impl Clean<Item> for doctree::Trait {\n+    fn clean(&self) -> Item {\n+        Item {\n+            name: Some(self.name.clean()),\n+            attrs: self.attrs.clean(),\n+            source: self.where.clean(),\n+            id: self.id,\n+            visibility: self.vis.clean(),\n+            inner: TraitItem(Trait {\n+                methods: self.methods.clean(),\n+                generics: self.generics.clean(),\n+                parents: self.parents.clean(),\n+            }),\n+        }\n+    }\n+}\n+\n+impl Clean<Type> for ast::trait_ref {\n+    fn clean(&self) -> Type {\n+        let t = Unresolved(self.path.clean(), None, self.ref_id);\n+        resolve_type(&t)\n+    }\n+}\n+\n+#[deriving(Clone, Encodable, Decodable)]\n+pub enum TraitMethod {\n+    Required(Item),\n+    Provided(Item),\n+}\n+\n+impl TraitMethod {\n+    fn is_req(&self) -> bool {\n+        match self {\n+            &Required(*) => true,\n+            _ => false,\n+        }\n+    }\n+    fn is_def(&self) -> bool {\n+        match self {\n+            &Provided(*) => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+impl Clean<TraitMethod> for ast::trait_method {\n+    fn clean(&self) -> TraitMethod {\n+        match self {\n+            &ast::required(ref t) => Required(t.clean()),\n+            &ast::provided(ref t) => Provided(t.clean()),\n+        }\n+    }\n+}\n+\n+/// A representation of a Type suitable for hyperlinking purposes. Ideally one can get the original\n+/// type out of the AST/ty::ctxt given one of these, if more information is needed. Most importantly\n+/// it does not preserve mutability or boxes.\n+#[deriving(Clone, Encodable, Decodable)]\n+pub enum Type {\n+    /// Most types start out as \"Unresolved\". It serves as an intermediate stage between cleaning\n+    /// and type resolution.\n+    Unresolved(Path, Option<~[TyParamBound]>, ast::NodeId),\n+    /// structs/enums/traits (anything that'd be an ast::ty_path)\n+    ResolvedPath { path: Path, typarams: Option<~[TyParamBound]>, id: ast::NodeId },\n+    /// Reference to an item in an external crate (fully qualified path)\n+    External(~str, ~str),\n+    // I have no idea how to usefully use this.\n+    TyParamBinder(ast::NodeId),\n+    /// For parameterized types, so the consumer of the JSON don't go looking\n+    /// for types which don't exist anywhere.\n+    Generic(ast::NodeId),\n+    /// For references to self\n+    Self(ast::NodeId),\n+    /// Primitives are just the fixed-size numeric types (plus int/uint/float), and char.\n+    Primitive(ast::prim_ty),\n+    Closure(~ClosureDecl),\n+    /// extern \"ABI\" fn\n+    BareFunction(~BareFunctionDecl),\n+    Tuple(~[Type]),\n+    Vector(~Type),\n+    FixedVector(~Type, ~str),\n+    String,\n+    Bool,\n+    /// aka ty_nil\n+    Unit,\n+    /// aka ty_bot\n+    Bottom,\n+    Unique(~Type),\n+    Managed(Mutability, ~Type),\n+    RawPointer(Mutability, ~Type),\n+    BorrowedRef { lifetime: Option<Lifetime>, mutability: Mutability, type_: ~Type},\n+    // region, raw, other boxes, mutable\n+}\n+\n+impl Clean<Type> for ast::Ty {\n+    fn clean(&self) -> Type {\n+        use syntax::ast::*;\n+        debug!(\"cleaning type `%?`\", self);\n+        let codemap = local_data::get(super::ctxtkey, |x| *x.unwrap()).sess.codemap;\n+        debug!(\"span corresponds to `%s`\", codemap.span_to_str(self.span));\n+        let t = match self.node {\n+            ty_nil => Unit,\n+            ty_ptr(ref m) =>  RawPointer(m.mutbl.clean(), ~resolve_type(&m.ty.clean())),\n+            ty_rptr(ref l, ref m) => \n+                BorrowedRef {lifetime: l.clean(), mutability: m.mutbl.clean(),\n+                             type_: ~resolve_type(&m.ty.clean())},\n+            ty_box(ref m) => Managed(m.mutbl.clean(), ~resolve_type(&m.ty.clean())),\n+            ty_uniq(ref m) => Unique(~resolve_type(&m.ty.clean())),\n+            ty_vec(ref m) => Vector(~resolve_type(&m.ty.clean())),\n+            ty_fixed_length_vec(ref m, ref e) => FixedVector(~resolve_type(&m.ty.clean()),\n+                                                             e.span.to_src()),\n+            ty_tup(ref tys) => Tuple(tys.iter().map(|x| resolve_type(&x.clean())).collect()),\n+            ty_path(ref p, ref tpbs, id) => Unresolved(p.clean(), tpbs.clean(), id),\n+            ty_closure(ref c) => Closure(~c.clean()),\n+            ty_bare_fn(ref barefn) => BareFunction(~barefn.clean()),\n+            ty_bot => Bottom,\n+            ref x => fail!(\"Unimplemented type %?\", x),\n+        };\n+        resolve_type(&t)\n+    }\n+}\n+\n+#[deriving(Clone, Encodable, Decodable)]\n+pub struct StructField {\n+    type_: Type,\n+}\n+\n+impl Clean<Item> for ast::struct_field {\n+    fn clean(&self) -> Item {\n+        let (name, vis) = match self.node.kind {\n+            ast::named_field(id, vis) => (Some(id), Some(vis)),\n+            _ => (None, None)\n+        };\n+        Item {\n+            name: name.clean(),\n+            attrs: self.node.attrs.clean(),\n+            source: self.span.clean(),\n+            visibility: vis,\n+            id: self.node.id,\n+            inner: StructFieldItem(StructField {\n+                type_: self.node.ty.clean(),\n+            }),\n+        }\n+    }\n+}\n+\n+pub type Visibility = ast::visibility;\n+\n+impl Clean<Option<Visibility>> for ast::visibility {\n+    fn clean(&self) -> Option<Visibility> {\n+        Some(*self)\n+    }\n+}\n+\n+#[deriving(Clone, Encodable, Decodable)]\n+pub struct Struct {\n+    struct_type: doctree::StructType,\n+    generics: Generics,\n+    fields: ~[Item],\n+}\n+\n+impl Clean<Item> for doctree::Struct {\n+    fn clean(&self) -> Item {\n+        Item {\n+            name: Some(self.name.clean()),\n+            attrs: self.attrs.clean(),\n+            source: self.where.clean(),\n+            id: self.id,\n+            visibility: self.vis.clean(),\n+            inner: StructItem(Struct {\n+                struct_type: self.struct_type,\n+                generics: self.generics.clean(),\n+                fields: self.fields.clean(),\n+            }),\n+        }\n+    }\n+}\n+\n+/// This is a more limited form of the standard Struct, different in that it\n+/// it lacks the things most items have (name, id, parameterization). Found\n+/// only as a variant in an enum.\n+#[deriving(Clone, Encodable, Decodable)]\n+pub struct VariantStruct {\n+    struct_type: doctree::StructType,\n+    fields: ~[Item],\n+}\n+\n+impl Clean<VariantStruct> for syntax::ast::struct_def {\n+    fn clean(&self) -> VariantStruct {\n+        VariantStruct {\n+            struct_type: doctree::struct_type_from_def(self),\n+            fields: self.fields.clean(),\n+        }\n+    }\n+}\n+\n+#[deriving(Clone, Encodable, Decodable)]\n+pub struct Enum {\n+    variants: ~[Item],\n+    generics: Generics,\n+}\n+\n+impl Clean<Item> for doctree::Enum {\n+    fn clean(&self) -> Item {\n+        Item {\n+            name: Some(self.name.clean()),\n+            attrs: self.attrs.clean(),\n+            source: self.where.clean(),\n+            id: self.id,\n+            visibility: self.vis.clean(),\n+            inner: EnumItem(Enum {\n+                variants: self.variants.clean(),\n+                generics: self.generics.clean(),\n+            }),\n+        }\n+    }\n+}\n+\n+#[deriving(Clone, Encodable, Decodable)]\n+pub struct Variant {\n+    kind: VariantKind,\n+}\n+\n+impl Clean<Item> for doctree::Variant {\n+    fn clean(&self) -> Item {\n+        Item {\n+            name: Some(self.name.clean()),\n+            attrs: self.attrs.clean(),\n+            source: self.where.clean(),\n+            visibility: self.vis.clean(),\n+            id: self.id,\n+            inner: VariantItem(Variant {\n+                kind: self.kind.clean(),\n+            }),\n+        }\n+    }\n+}\n+\n+#[deriving(Clone, Encodable, Decodable)]\n+pub enum VariantKind {\n+    CLikeVariant,\n+    TupleVariant(~[Type]),\n+    StructVariant(VariantStruct),\n+}\n+\n+impl Clean<VariantKind> for ast::variant_kind {\n+    fn clean(&self) -> VariantKind {\n+        match self {\n+            &ast::tuple_variant_kind(ref args) => {\n+                if args.len() == 0 {\n+                    CLikeVariant\n+                } else {\n+                    TupleVariant(args.iter().map(|x| x.ty.clean()).collect())\n+                }\n+            },\n+            &ast::struct_variant_kind(ref sd) => StructVariant(sd.clean()),\n+        }\n+    }\n+}\n+\n+impl Clean<~str> for syntax::codemap::span {\n+    fn clean(&self) -> ~str {\n+        let cm = local_data::get(super::ctxtkey, |x| x.unwrap().clone()).sess.codemap;\n+        cm.span_to_str(*self)\n+    }\n+}\n+\n+#[deriving(Clone, Encodable, Decodable)]\n+pub struct Path {\n+    name: ~str,\n+    lifetime: Option<Lifetime>,\n+    typarams: ~[Type]\n+}\n+\n+impl Clean<Path> for ast::Path {\n+    fn clean(&self) -> Path {\n+        Path {\n+            name: path_to_str(self),\n+            lifetime: self.rp.clean(),\n+            typarams: self.types.clean(),\n+        }\n+    }\n+}\n+\n+fn path_to_str(p: &ast::Path) -> ~str {\n+    use syntax::parse::token::interner_get;\n+\n+    let mut s = ~\"\";\n+    let mut first = true;\n+    for i in p.idents.iter().map(|x| interner_get(x.name)) {\n+        if !first || p.global {\n+            s.push_str(\"::\");\n+        } else {\n+            first = false;\n+        }\n+        s.push_str(i);\n+    }\n+    s\n+}\n+\n+impl Clean<~str> for ast::ident {\n+    fn clean(&self) -> ~str {\n+        its(self).to_owned()\n+    }\n+}\n+\n+#[deriving(Clone, Encodable, Decodable)]\n+pub struct Typedef {\n+    type_: Type,\n+    generics: Generics,\n+}\n+\n+impl Clean<Item> for doctree::Typedef {\n+    fn clean(&self) -> Item {\n+        Item {\n+            name: Some(self.name.clean()),\n+            attrs: self.attrs.clean(),\n+            source: self.where.clean(),\n+            id: self.id.clone(),\n+            visibility: self.vis.clean(),\n+            inner: TypedefItem(Typedef {\n+                type_: self.ty.clean(),\n+                generics: self.gen.clean(),\n+            }),\n+        }\n+    }\n+}\n+\n+#[deriving(Clone, Encodable, Decodable)]\n+pub struct BareFunctionDecl {\n+    purity: ast::purity,\n+    generics: Generics,\n+    decl: FnDecl,\n+    abi: ~str\n+}\n+\n+impl Clean<BareFunctionDecl> for ast::TyBareFn {\n+    fn clean(&self) -> BareFunctionDecl {\n+        BareFunctionDecl {\n+            purity: self.purity,\n+            generics: Generics {\n+                lifetimes: self.lifetimes.clean(),\n+                type_params: ~[],\n+            },\n+            decl: self.decl.clean(),\n+            abi: self.abis.to_str(),\n+        }\n+    }\n+}\n+\n+#[deriving(Clone, Encodable, Decodable)]\n+pub struct Static {\n+    type_: Type,\n+    mutability: Mutability,\n+    /// It's useful to have the value of a static documented, but I have no\n+    /// desire to represent expressions (that'd basically be all of the AST,\n+    /// which is huge!). So, have a string.\n+    expr: ~str,\n+}\n+\n+impl Clean<Item> for doctree::Static {\n+    fn clean(&self) -> Item {\n+        debug!(\"claning static %s: %?\", self.name.clean(), self);\n+        Item {\n+            name: Some(self.name.clean()),\n+            attrs: self.attrs.clean(),\n+            source: self.where.clean(),\n+            id: self.id,\n+            visibility: self.vis.clean(),\n+            inner: StaticItem(Static {\n+                type_: self.type_.clean(),\n+                mutability: self.mutability.clean(),\n+                expr: self.expr.span.to_src(),\n+            }),\n+        }\n+    }\n+}\n+\n+#[deriving(ToStr, Clone, Encodable, Decodable)]\n+pub enum Mutability {\n+    Mutable,\n+    Immutable,\n+    Const,\n+}\n+\n+impl Clean<Mutability> for ast::mutability {\n+    fn clean(&self) -> Mutability {\n+        match self {\n+            &ast::m_mutbl => Mutable,\n+            &ast::m_imm => Immutable,\n+            &ast::m_const => Const\n+        }\n+    }\n+}\n+\n+#[deriving(Clone, Encodable, Decodable)]\n+pub struct Impl {\n+    generics: Generics,\n+    trait_: Option<Type>,\n+    for_: Type,\n+    methods: ~[Item],\n+}\n+\n+impl Clean<Item> for doctree::Impl {\n+    fn clean(&self) -> Item {\n+        Item {\n+            name: None,\n+            attrs: self.attrs.clean(),\n+            source: self.where.clean(),\n+            id: self.id,\n+            visibility: self.vis.clean(),\n+            inner: ImplItem(Impl {\n+                generics: self.generics.clean(),\n+                trait_: self.trait_.clean(),\n+                for_: self.for_.clean(),\n+                methods: self.methods.clean(),\n+            }),\n+        }\n+    }\n+}\n+\n+#[deriving(Clone, Encodable, Decodable)]\n+pub struct ViewItem {\n+    inner: ViewItemInner\n+}\n+\n+impl Clean<Item> for ast::view_item {\n+    fn clean(&self) -> Item {\n+        Item {\n+            name: None,\n+            attrs: self.attrs.clean(),\n+            source: self.span.clean(),\n+            id: 0,\n+            visibility: self.vis.clean(),\n+            inner: ViewItemItem(ViewItem {\n+                inner: self.node.clean()\n+            }),\n+        }\n+    }\n+}\n+\n+#[deriving(Clone, Encodable, Decodable)]\n+pub enum ViewItemInner {\n+    ExternMod(~str, Option<~str>, ~[Attribute], ast::NodeId),\n+    Import(~[ViewPath])\n+}\n+\n+impl Clean<ViewItemInner> for ast::view_item_ {\n+    fn clean(&self) -> ViewItemInner {\n+        match self {\n+            &ast::view_item_extern_mod(ref i, ref p, ref mi, ref id) =>\n+                ExternMod(i.clean(), p.map(|x| x.to_owned()),  mi.clean(), *id),\n+            &ast::view_item_use(ref vp) => Import(vp.clean())\n+        }\n+    }\n+}\n+\n+#[deriving(Clone, Encodable, Decodable)]\n+pub enum ViewPath {\n+    SimpleImport(~str, Path, ast::NodeId),\n+    GlobImport(Path, ast::NodeId),\n+    ImportList(Path, ~[ViewListIdent], ast::NodeId)\n+}\n+\n+impl Clean<ViewPath> for ast::view_path {\n+    fn clean(&self) -> ViewPath {\n+        match self.node {\n+            ast::view_path_simple(ref i, ref p, ref id) => SimpleImport(i.clean(), p.clean(), *id),\n+            ast::view_path_glob(ref p, ref id) => GlobImport(p.clean(), *id),\n+            ast::view_path_list(ref p, ref pl, ref id) => ImportList(p.clean(), pl.clean(), *id),\n+        }\n+    }\n+}\n+\n+pub type ViewListIdent = ~str;\n+\n+impl Clean<ViewListIdent> for ast::path_list_ident {\n+    fn clean(&self) -> ViewListIdent {\n+        self.node.name.clean()\n+    }\n+}\n+\n+// Utilities\n+\n+trait ToSource {\n+    fn to_src(&self) -> ~str;\n+}\n+\n+impl ToSource for syntax::codemap::span {\n+    fn to_src(&self) -> ~str {\n+        debug!(\"converting span %s to snippet\", self.clean());\n+        let cm = local_data::get(super::ctxtkey, |x| x.unwrap().clone()).sess.codemap.clone();\n+        let sn = match cm.span_to_snippet(*self) {\n+            Some(x) => x,\n+            None    => ~\"\"\n+        };\n+        debug!(\"got snippet %s\", sn);\n+        sn\n+    }\n+}\n+\n+fn lit_to_str(lit: &ast::lit) -> ~str {\n+    match lit.node {\n+        ast::lit_str(st) => st.to_owned(),\n+        ast::lit_int(ch, ast::ty_char) => ~\"'\" + ch.to_str() + \"'\",\n+        ast::lit_int(i, _t) => i.to_str(),\n+        ast::lit_uint(u, _t) => u.to_str(),\n+        ast::lit_int_unsuffixed(i) => i.to_str(),\n+        ast::lit_float(f, _t) => f.to_str(),\n+        ast::lit_float_unsuffixed(f) => f.to_str(),\n+        ast::lit_bool(b) => b.to_str(),\n+        ast::lit_nil => ~\"\",\n+    }\n+}\n+\n+fn name_from_pat(p: &ast::pat) -> ~str {\n+    use syntax::ast::*;\n+    match p.node {\n+        pat_wild => ~\"_\",\n+        pat_ident(_, ref p, _) => path_to_str(p),\n+        pat_enum(ref p, _) => path_to_str(p),\n+        pat_struct(*) => fail!(\"tried to get argument name from pat_struct, \\\n+                                 which is not allowed in function arguments\"),\n+        pat_tup(*) => ~\"(tuple arg NYI)\",\n+        pat_box(p) => name_from_pat(p),\n+        pat_uniq(p) => name_from_pat(p),\n+        pat_region(p) => name_from_pat(p),\n+        pat_lit(*) => fail!(\"tried to get argument name from pat_lit, \\\n+                             which is not allowed in function arguments\"),\n+        pat_range(*) => fail!(\"tried to get argument name from pat_range, \\\n+                               which is not allowed in function arguments\"),\n+        pat_vec(*) => fail!(\"tried to get argument name from pat_vec, \\\n+                             which is not allowed in function arguments\")\n+    }\n+}\n+\n+fn remove_comment_tags(s: &str) -> ~str {\n+    if s.starts_with(\"/\") {\n+        match s.slice(0,3) {\n+            &\"///\" => return s.slice(3, s.len()).trim().to_owned(),\n+            &\"/**\" | &\"/*!\" => return s.slice(3, s.len() - 2).trim().to_owned(),\n+            _ => return s.trim().to_owned()\n+        }\n+    } else {\n+        return s.to_owned();\n+    }\n+}\n+\n+/*fn collapse_docs(attrs: ~[Attribute]) -> ~[Attribute] {\n+    let mut docstr = ~\"\";\n+    for at in attrs.iter() {\n+        match *at {\n+            //XXX how should these be separated?\n+            NameValue(~\"doc\", ref s) => docstr.push_str(fmt!(\"%s \", clean_comment_body(s.clone()))),\n+            _ => ()\n+        }\n+    }\n+    let mut a = attrs.iter().filter(|&a| match a {\n+        &NameValue(~\"doc\", _) => false,\n+        _ => true\n+    }).map(|x| x.clone()).collect::<~[Attribute]>();\n+    a.push(NameValue(~\"doc\", docstr.trim().to_owned()));\n+    a\n+}*/\n+\n+/// Given a Type, resolve it using the def_map\n+fn resolve_type(t: &Type) -> Type {\n+    use syntax::ast::*;\n+\n+    let (path, tpbs, id) = match t {\n+        &Unresolved(ref path, ref tbps, id) => (path, tbps, id),\n+        _ => return (*t).clone(),\n+    };\n+\n+    let dm = local_data::get(super::ctxtkey, |x| *x.unwrap()).tycx.def_map;\n+    debug!(\"searching for %? in defmap\", id);\n+    let d = match dm.find(&id) {\n+        Some(k) => k,\n+        None => {\n+            let ctxt = local_data::get(super::ctxtkey, |x| *x.unwrap());\n+            debug!(\"could not find %? in defmap (`%s`)\", id,\n+                   syntax::ast_map::node_id_to_str(ctxt.tycx.items, id, ctxt.sess.intr()));\n+            fail!(\"Unexpected failure: unresolved id not in defmap (this is a bug!)\")\n+        }\n+    };\n+\n+    let def_id = match *d {\n+        def_fn(i, _) => i,\n+        def_self(i, _) | def_self_ty(i) => return Self(i),\n+        def_ty(i) => i,\n+        def_trait(i) => {\n+            debug!(\"saw def_trait in def_to_id\");\n+            i\n+        },\n+        def_prim_ty(p) => match p {\n+            ty_str => return String,\n+            ty_bool => return Bool,\n+            _ => return Primitive(p)\n+        },\n+        def_ty_param(i, _) => return Generic(i.node),\n+        def_struct(i) => i,\n+        def_typaram_binder(i) => { \n+            debug!(\"found a typaram_binder, what is it? %d\", i);\n+            return TyParamBinder(i);\n+        },\n+        x => fail!(\"resolved type maps to a weird def %?\", x),\n+    };\n+\n+    if def_id.crate != ast::CRATE_NODE_ID {\n+        let sess = local_data::get(super::ctxtkey, |x| *x.unwrap()).sess;\n+        let mut path = ~\"\";\n+        let mut ty = ~\"\";\n+        do csearch::each_path(sess.cstore, def_id.crate) |pathstr, deflike, _vis| {\n+            match deflike {\n+                decoder::dl_def(di) => {\n+                    let d2 = match di {\n+                        def_fn(i, _) | def_ty(i) | def_trait(i) |\n+                            def_struct(i) | def_mod(i) => Some(i),\n+                        _ => None,\n+                    };\n+                    if d2.is_some() {\n+                        let d2 = d2.unwrap();\n+                        if def_id.node == d2.node {\n+                            debug!(\"found external def: %?\", di);\n+                            path = pathstr.to_owned();\n+                            ty = match di {\n+                                def_fn(*) => ~\"fn\",\n+                                def_ty(*) => ~\"enum\",\n+                                def_trait(*) => ~\"trait\",\n+                                def_prim_ty(p) => match p {\n+                                    ty_str => ~\"str\",\n+                                    ty_bool => ~\"bool\",\n+                                    ty_int(t) => match t.to_str() {\n+                                        ~\"\" => ~\"i\",\n+                                        s => s\n+                                    },\n+                                    ty_uint(t) => t.to_str(),\n+                                    ty_float(t) => t.to_str()\n+                                },\n+                                def_ty_param(*) => ~\"generic\",\n+                                def_struct(*) => ~\"struct\",\n+                                def_typaram_binder(*) => ~\"typaram_binder\",\n+                                x => fail!(\"resolved external maps to a weird def %?\", x),\n+                            };\n+\n+                        }\n+                    }\n+                },\n+                _ => (),\n+            };\n+            true\n+        };\n+        let cname = cstore::get_crate_data(sess.cstore, def_id.crate).name.to_owned();\n+        External(cname + \"::\" + path, ty)\n+    } else {\n+        ResolvedPath {path: path.clone(), typarams: tpbs.clone(), id: def_id.node}\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::NameValue;\n+\n+    #[test]\n+    fn test_doc_collapsing() {\n+        assert_eq!(collapse_docs(~\"// Foo\\n//Bar\\n // Baz\\n\"), ~\"Foo\\nBar\\nBaz\");\n+        assert_eq!(collapse_docs(~\"* Foo\\n *  Bar\\n *Baz\\n\"), ~\"Foo\\n Bar\\nBaz\");\n+        assert_eq!(collapse_docs(~\"* Short desc\\n *\\n * Bar\\n *Baz\\n\"), ~\"Short desc\\n\\nBar\\nBaz\");\n+        assert_eq!(collapse_docs(~\" * Foo\"), ~\"Foo\");\n+        assert_eq!(collapse_docs(~\"\\n *\\n *\\n * Foo\"), ~\"Foo\");\n+    }\n+\n+    fn collapse_docs(input: ~str) -> ~str {\n+        let attrs = ~[NameValue(~\"doc\", input)];\n+        let attrs_clean = super::collapse_docs(attrs);\n+\n+        match attrs_clean[0] {\n+            NameValue(~\"doc\", s) => s,\n+            _ => (fail!(\"dude where's my doc?\"))\n+        }\n+    }\n+}"}, {"sha": "8e12dbdce4dbc19aeac2a2fa9be9787a62e83826", "filename": "src/rustdoc_ng/core.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/268f3f0ff5d80544ca21d565354eae6d3e29fb91/src%2Frustdoc_ng%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/268f3f0ff5d80544ca21d565354eae6d3e29fb91/src%2Frustdoc_ng%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc_ng%2Fcore.rs?ref=268f3f0ff5d80544ca21d565354eae6d3e29fb91", "patch": "@@ -0,0 +1,68 @@\n+use rustc;\n+use rustc::{driver, middle};\n+\n+use syntax;\n+use syntax::parse;\n+use syntax::ast;\n+\n+use std::os;\n+use std::local_data;\n+\n+use visit_ast::RustdocVisitor;\n+use clean;\n+use clean::Clean;\n+\n+pub struct DocContext {\n+    crate: @ast::Crate,\n+    tycx: middle::ty::ctxt,\n+    sess: driver::session::Session\n+}\n+\n+/// Parses, resolves, and typechecks the given crate\n+fn get_ast_and_resolve(cpath: &Path, libs: ~[Path]) -> DocContext {\n+    use syntax::codemap::dummy_spanned;\n+    use rustc::driver::driver::*;\n+\n+    let parsesess = parse::new_parse_sess(None);\n+    let input = file_input(cpath.clone());\n+\n+    let sessopts = @driver::session::options {\n+        binary: @\"rustdoc\",\n+        maybe_sysroot: Some(@os::self_exe_path().unwrap().pop()),\n+        addl_lib_search_paths: @mut libs,\n+        .. (*rustc::driver::session::basic_options()).clone()\n+    };\n+\n+\n+    let diagnostic_handler = syntax::diagnostic::mk_handler(None);\n+    let span_diagnostic_handler =\n+        syntax::diagnostic::mk_span_handler(diagnostic_handler, parsesess.cm);\n+\n+    let sess = driver::driver::build_session_(sessopts, parsesess.cm,\n+                                                  syntax::diagnostic::emit,\n+                                                  span_diagnostic_handler);\n+\n+    let mut cfg = build_configuration(sess, @\"rustdoc_ng\", &input);\n+    cfg.push(@dummy_spanned(ast::MetaWord(@\"stage2\")));\n+\n+    let mut crate = phase_1_parse_input(sess, cfg.clone(), &input);\n+    crate = phase_2_configure_and_expand(sess, cfg, crate);\n+    let analysis = phase_3_run_analysis_passes(sess, crate);\n+\n+    debug!(\"crate: %?\", crate);\n+    DocContext { crate: crate, tycx: analysis.ty_cx, sess: sess }\n+}\n+\n+pub fn run_core (libs: ~[Path], path: &Path) -> clean::Crate {\n+    let ctxt = @get_ast_and_resolve(path, libs);\n+    debug!(\"defmap:\");\n+    for (k, v) in ctxt.tycx.def_map.iter() {\n+        debug!(\"%?: %?\", k, v);\n+    }\n+    local_data::set(super::ctxtkey, ctxt);\n+\n+    let v = @mut RustdocVisitor::new();\n+    v.visit(ctxt.crate);\n+\n+    v.clean()\n+}"}, {"sha": "d5ad0fca30fc5d3491bbe4b5e8214f80088cdf16", "filename": "src/rustdoc_ng/doctree.rs", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/268f3f0ff5d80544ca21d565354eae6d3e29fb91/src%2Frustdoc_ng%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/268f3f0ff5d80544ca21d565354eae6d3e29fb91/src%2Frustdoc_ng%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc_ng%2Fdoctree.rs?ref=268f3f0ff5d80544ca21d565354eae6d3e29fb91", "patch": "@@ -0,0 +1,158 @@\n+//! This module is used to store stuff from Rust's AST in a more convenient\n+//! manner (and with prettier names) before cleaning.\n+\n+use syntax;\n+use syntax::codemap::span;\n+use syntax::ast;\n+use syntax::ast::{ident, NodeId};\n+\n+pub struct Module {\n+    name: Option<ident>,\n+    attrs: ~[ast::Attribute],\n+    where: span,\n+    structs: ~[Struct],\n+    enums: ~[Enum],\n+    fns: ~[Function],\n+    mods: ~[Module],\n+    id: NodeId,\n+    typedefs: ~[Typedef],\n+    statics: ~[Static],\n+    traits: ~[Trait],\n+    vis: ast::visibility,\n+    impls: ~[Impl],\n+    view_items: ~[ast::view_item],\n+}\n+\n+impl Module {\n+    pub fn new(name: Option<ident>) -> Module {\n+        Module {\n+            name       : name,\n+            id: 0,\n+            vis: ast::private,\n+            where: syntax::codemap::dummy_sp(),\n+            attrs      : ~[],\n+            structs    : ~[],\n+            enums      : ~[],\n+            fns        : ~[],\n+            mods       : ~[],\n+            typedefs   : ~[],\n+            statics    : ~[],\n+            traits     : ~[],\n+            impls      : ~[],\n+            view_items : ~[],\n+        }\n+    }\n+}\n+\n+#[deriving(ToStr, Clone, Encodable, Decodable)]\n+pub enum StructType {\n+    /// A normal struct\n+    Plain,\n+    /// A tuple struct\n+    Tuple,\n+    /// A newtype struct (tuple struct with one element)\n+    Newtype,\n+    /// A unit struct\n+    Unit\n+}\n+\n+pub enum TypeBound {\n+    RegionBound,\n+    TraitBound(ast::trait_ref)\n+}\n+\n+pub struct Struct {\n+    vis: ast::visibility,\n+    id: NodeId,\n+    struct_type: StructType,\n+    name: ident,\n+    generics: ast::Generics,\n+    attrs: ~[ast::Attribute],\n+    fields: ~[@ast::struct_field],\n+    where: span,\n+}\n+\n+pub struct Enum {\n+    vis: ast::visibility,\n+    variants: ~[Variant],\n+    generics: ast::Generics,\n+    attrs: ~[ast::Attribute],\n+    id: NodeId,\n+    where: span,\n+    name: ident,\n+}\n+\n+pub struct Variant {\n+    name: ident,\n+    attrs: ~[ast::Attribute],\n+    kind: ast::variant_kind,\n+    id: ast::NodeId,\n+    vis: ast::visibility,\n+    where: span,\n+}\n+\n+pub struct Function {\n+    decl: ast::fn_decl,\n+    attrs: ~[ast::Attribute],\n+    id: NodeId,\n+    name: ident,\n+    vis: ast::visibility,\n+    where: span,\n+    generics: ast::Generics,\n+}\n+\n+pub struct Typedef {\n+    ty: ast::Ty,\n+    gen: ast::Generics,\n+    name: ast::ident,\n+    id: ast::NodeId,\n+    attrs: ~[ast::Attribute],\n+    where: span,\n+    vis: ast::visibility,\n+}\n+\n+pub struct Static {\n+    type_: ast::Ty,\n+    mutability: ast::mutability,\n+    expr: @ast::expr,\n+    name: ast::ident,\n+    attrs: ~[ast::Attribute],\n+    vis: ast::visibility,\n+    id: ast::NodeId,\n+    where: span,\n+}\n+\n+pub struct Trait {\n+    name: ast::ident,\n+    methods: ~[ast::trait_method], //should be TraitMethod\n+    generics: ast::Generics,\n+    parents: ~[ast::trait_ref],\n+    attrs: ~[ast::Attribute],\n+    id: ast::NodeId,\n+    where: span,\n+    vis: ast::visibility,\n+}\n+\n+pub struct Impl {\n+    generics: ast::Generics,\n+    trait_: Option<ast::trait_ref>,\n+    for_: ast::Ty,\n+    methods: ~[@ast::method],\n+    attrs: ~[ast::Attribute],\n+    where: span,\n+    vis: ast::visibility,\n+    id: ast::NodeId,\n+}\n+\n+pub fn struct_type_from_def(sd: &ast::struct_def) -> StructType {\n+    if sd.ctor_id.is_some() {\n+        // We are in a tuple-struct\n+        match sd.fields.len() {\n+            0 => Unit,\n+            1 => Newtype,\n+            _ => Tuple\n+        }\n+    } else {\n+        Plain\n+    }\n+}"}, {"sha": "740e434f465cd75feb389da430c7e19890bf7e84", "filename": "src/rustdoc_ng/fold.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/268f3f0ff5d80544ca21d565354eae6d3e29fb91/src%2Frustdoc_ng%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/268f3f0ff5d80544ca21d565354eae6d3e29fb91/src%2Frustdoc_ng%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc_ng%2Ffold.rs?ref=268f3f0ff5d80544ca21d565354eae6d3e29fb91", "patch": "@@ -0,0 +1,101 @@\n+use std;\n+use clean::*;\n+use std::iterator::Extendable;\n+\n+pub trait DocFolder {\n+    fn fold_item(&mut self, item: Item) -> Option<Item> {\n+        self.fold_item_recur(item)\n+    }\n+\n+    /// don't override!\n+    fn fold_item_recur(&mut self, item: Item) -> Option<Item> {\n+        use std::util::swap;\n+        let Item { attrs, name, source, visibility, id, inner } = item;\n+        let inner = inner;\n+        let c = |x| self.fold_item(x);\n+        let inner = match inner {\n+            StructItem(i) => {\n+                let mut i = i;\n+                let mut foo = ~[]; swap(&mut foo, &mut i.fields);\n+                i.fields.extend(&mut foo.move_iter().filter_map(|x| self.fold_item(x)));\n+                StructItem(i)\n+            },\n+            ModuleItem(i) => {\n+                ModuleItem(self.fold_mod(i))\n+            },\n+            EnumItem(i) => {\n+                let mut i = i;\n+                let mut foo = ~[]; swap(&mut foo, &mut i.variants);\n+                i.variants.extend(&mut foo.move_iter().filter_map(|x| self.fold_item(x)));\n+                EnumItem(i)\n+            },\n+            TraitItem(i) => {\n+                fn vtrm<T: DocFolder>(this: &mut T, trm: TraitMethod) -> Option<TraitMethod> {\n+                    match trm {\n+                        Required(it) => {\n+                            match this.fold_item(it) {\n+                                Some(x) => return Some(Required(x)),\n+                                None => return None,\n+                            }\n+                        },\n+                        Provided(it) => {\n+                            match this.fold_item(it) {\n+                                Some(x) => return Some(Provided(x)),\n+                                None => return None,\n+                            }\n+                        },\n+                    }\n+                }\n+                let mut i = i;\n+                let mut foo = ~[]; swap(&mut foo, &mut i.methods);\n+                i.methods.extend(&mut foo.move_iter().filter_map(|x| vtrm(self, x)));\n+                TraitItem(i)\n+            },\n+            ImplItem(i) => {\n+                let mut i = i;\n+                let mut foo = ~[]; swap(&mut foo, &mut i.methods);\n+                i.methods.extend(&mut foo.move_iter().filter_map(|x| self.fold_item(x)));\n+                ImplItem(i)\n+            },\n+            VariantItem(i) => {\n+                let i2 = i.clone(); // this clone is small\n+                match i.kind {\n+                    StructVariant(j) => {\n+                        let mut j = j;\n+                        let mut foo = ~[]; swap(&mut foo, &mut j.fields);\n+                        j.fields.extend(&mut foo.move_iter().filter_map(c));\n+                        VariantItem(Variant {kind: StructVariant(j), ..i2})\n+                    },\n+                    _ => VariantItem(i2)\n+                }\n+            },\n+            x => x\n+        };\n+\n+        Some(Item { attrs: attrs, name: name, source: source, inner: inner,\n+                    visibility: visibility, id: id })\n+    }\n+\n+    fn fold_mod(&mut self, m: Module) -> Module {\n+        Module { items: m.items.move_iter().filter_map(|i| self.fold_item(i)).collect() }\n+    }\n+\n+    fn fold_crate(&mut self, mut c: Crate) -> Crate {\n+        let mut mod_ = None;\n+        std::util::swap(&mut mod_, &mut c.module);\n+        let mod_ = mod_.unwrap();\n+        c.module = self.fold_item(mod_);\n+        let Crate { name, module } = c;\n+        match module {\n+            Some(Item { inner: ModuleItem(m), name: name_, attrs: attrs_,\n+            source, visibility: vis, id }) => {\n+                return Crate { module: Some(Item { inner:\n+                                            ModuleItem(self.fold_mod(m)),\n+                                            name: name_, attrs: attrs_,\n+                                            source: source, id: id, visibility: vis }), name: name};\n+            },\n+            Some(_) => fail!(\"non-module item set as module of crate\"),\n+            None => return Crate { module: None, name: name},\n+        }\n+    }\n+}"}, {"sha": "6d34fae6090008f72b522c6dbfccb9e9ed0aff9c", "filename": "src/rustdoc_ng/lib.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/268f3f0ff5d80544ca21d565354eae6d3e29fb91/src%2Frustdoc_ng%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/268f3f0ff5d80544ca21d565354eae6d3e29fb91/src%2Frustdoc_ng%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc_ng%2Flib.rs?ref=268f3f0ff5d80544ca21d565354eae6d3e29fb91", "patch": "@@ -0,0 +1,27 @@\n+#[link(name = \"rustdoc_ng\",\n+       vers = \"0.1.0\",\n+       uuid = \"8c6e4598-1596-4aa5-a24c-b811914bbbc6\")];\n+#[desc = \"rustdoc, the Rust documentation extractor\"];\n+#[license = \"MIT/ASL2\"];\n+#[crate_type = \"lib\"];\n+\n+#[deny(warnings)];\n+\n+extern mod syntax;\n+extern mod rustc;\n+\n+extern mod extra;\n+\n+use extra::serialize::Encodable;\n+\n+pub mod core;\n+pub mod doctree;\n+pub mod clean;\n+pub mod visit_ast;\n+pub mod fold;\n+pub mod plugins;\n+pub mod passes;\n+\n+pub static SCHEMA_VERSION: &'static str = \"0.8.0\";\n+\n+pub static ctxtkey: std::local_data::Key<@core::DocContext> = &std::local_data::Key;"}, {"sha": "47b37052917041341564c946f570a63f2ecedff6", "filename": "src/rustdoc_ng/main.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/268f3f0ff5d80544ca21d565354eae6d3e29fb91/src%2Frustdoc_ng%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/268f3f0ff5d80544ca21d565354eae6d3e29fb91/src%2Frustdoc_ng%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc_ng%2Fmain.rs?ref=268f3f0ff5d80544ca21d565354eae6d3e29fb91", "patch": "@@ -0,0 +1,94 @@\n+#[link(name = \"rustdoc_ng\",\n+       vers = \"0.1.0\",\n+       uuid = \"8c6e4598-1596-4aa5-a24c-b811914bbbc6\")];\n+#[desc = \"rustdoc, the Rust documentation extractor\"];\n+#[license = \"MIT/ASL2\"];\n+#[crate_type = \"bin\"];\n+\n+extern mod extra;\n+extern mod rustdoc_ng;\n+\n+use rustdoc_ng::*;\n+use std::cell::Cell;\n+\n+use extra::serialize::Encodable;\n+\n+fn main() {\n+    use extra::getopts::*;\n+    use extra::getopts::groups::*;\n+\n+    let args = std::os::args();\n+    let opts = ~[\n+        optmulti(\"L\", \"library-path\", \"directory to add to crate search path\", \"DIR\"),\n+        optmulti(\"p\", \"plugin\", \"plugin to load and run\", \"NAME\"),\n+        optmulti(\"\", \"plugin-path\", \"directory to load plugins from\", \"DIR\"),\n+        // auxillary pass (defaults to hidden_strip\n+        optmulti(\"a\", \"pass\", \"auxillary pass to run\", \"NAME\"),\n+        optflag(\"n\", \"no-defult-passes\", \"do not run the default passes\"),\n+        optflag(\"h\", \"help\", \"show this help message\"),\n+    ];\n+\n+    let matches = getopts(args.tail(), opts).unwrap();\n+\n+    if opt_present(&matches, \"h\") || opt_present(&matches, \"help\") {\n+        println(usage(args[0], opts));\n+        return;\n+    }\n+\n+    let libs = Cell::new(opt_strs(&matches, \"L\").map(|s| Path(*s)));\n+\n+    let mut passes = if opt_present(&matches, \"n\") {\n+        ~[]\n+    } else {\n+        ~[~\"collapse-docs\", ~\"clean-comments\", ~\"collapse-privacy\" ]\n+    };\n+\n+    opt_strs(&matches, \"a\").map(|x| passes.push(x.clone()));\n+\n+    if matches.free.len() != 1 {\n+        println(usage(args[0], opts));\n+        return;\n+    }\n+\n+    let cr = Cell::new(Path(matches.free[0]));\n+\n+    let crate = std::task::try(|| {let cr = cr.take(); core::run_core(libs.take(), &cr)}).unwrap();\n+\n+    // { \"schema\": version, \"crate\": { parsed crate ... }, \"plugins\": { output of plugins ... }}\n+    let mut json = ~extra::treemap::TreeMap::new();\n+    json.insert(~\"schema\", extra::json::String(SCHEMA_VERSION.to_owned()));\n+\n+    let mut pm = plugins::PluginManager::new(Path(\"/tmp/rustdoc_ng/plugins\"));\n+\n+    for pass in passes.iter() {\n+        pm.add_plugin(match pass.as_slice() {\n+            \"strip-hidden\" => passes::strip_hidden,\n+            \"clean-comments\" => passes::clean_comments,\n+            \"collapse-docs\" => passes::collapse_docs,\n+            \"collapse-privacy\" => passes::collapse_privacy,\n+            s => { error!(\"unknown pass %s, skipping\", s); passes::noop },\n+        })\n+    }\n+\n+    for pname in opt_strs(&matches, \"p\").move_iter() {\n+        pm.load_plugin(pname);\n+    }\n+\n+    let (crate, res) = pm.run_plugins(crate);\n+    let plugins_json = ~res.move_iter().filter_map(|opt| opt).collect();\n+\n+    // FIXME: yuck, Rust -> str -> JSON round trip! No way to .encode\n+    // straight to the Rust JSON representation.\n+    let crate_json_str = do std::io::with_str_writer |w| {\n+        crate.encode(&mut extra::json::Encoder(w));\n+    };\n+    let crate_json = match extra::json::from_str(crate_json_str) {\n+        Ok(j) => j,\n+        Err(_) => fail!(\"Rust generated JSON is invalid??\")\n+    };\n+\n+    json.insert(~\"crate\", crate_json);\n+    json.insert(~\"plugins\", extra::json::Object(plugins_json));\n+\n+    println(extra::json::Object(json).to_str());\n+}"}, {"sha": "73f94ef0f270e0dfe7d49b02a54290462023c8a5", "filename": "src/rustdoc_ng/passes.rs", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/268f3f0ff5d80544ca21d565354eae6d3e29fb91/src%2Frustdoc_ng%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/268f3f0ff5d80544ca21d565354eae6d3e29fb91/src%2Frustdoc_ng%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc_ng%2Fpasses.rs?ref=268f3f0ff5d80544ca21d565354eae6d3e29fb91", "patch": "@@ -0,0 +1,193 @@\n+use std;\n+use clean;\n+use syntax::ast;\n+use clean::Item;\n+use plugins;\n+use fold;\n+use fold::DocFolder;\n+\n+/// A sample pass showing the minimum required work for a plugin.\n+pub fn noop(crate: clean::Crate) -> plugins::PluginResult {\n+    (crate, None)\n+}\n+\n+/// Strip items marked `#[doc(hidden)]`\n+pub fn strip_hidden(crate: clean::Crate) -> plugins::PluginResult {\n+    struct Stripper;\n+    impl fold::DocFolder for Stripper {\n+        fn fold_item(&mut self, i: Item) -> Option<Item> {\n+            for attr in i.attrs.iter() {\n+                match attr {\n+                    &clean::List(~\"doc\", ref l) => {\n+                        for innerattr in l.iter() {\n+                            match innerattr {\n+                                &clean::Word(ref s) if \"hidden\" == *s => {\n+                                    info!(\"found one in strip_hidden; removing\");\n+                                    return None;\n+                                },\n+                                _ => (),\n+                            }\n+                        }\n+                    },\n+                    _ => ()\n+                }\n+            }\n+            self.fold_item_recur(i)\n+        }\n+    }\n+    let mut stripper = Stripper;\n+    let crate = stripper.fold_crate(crate);\n+    (crate, None)\n+}\n+\n+pub fn clean_comments(crate: clean::Crate) -> plugins::PluginResult {\n+    struct CommentCleaner;\n+    impl fold::DocFolder for CommentCleaner {\n+        fn fold_item(&mut self, i: Item) -> Option<Item> {\n+            let mut i = i;\n+            let mut avec: ~[clean::Attribute] = ~[];\n+            for attr in i.attrs.iter() {\n+                match attr {\n+                    &clean::NameValue(~\"doc\", ref s) => avec.push(\n+                        clean::NameValue(~\"doc\", clean_comment_body(s.clone()))),\n+                    x => avec.push(x.clone())\n+                }\n+            }\n+            i.attrs = avec;\n+            self.fold_item_recur(i)\n+        }\n+    }\n+    let mut cleaner = CommentCleaner;\n+    let crate = cleaner.fold_crate(crate);\n+    (crate, None)\n+}\n+\n+pub fn collapse_privacy(crate: clean::Crate) -> plugins::PluginResult {\n+    struct PrivacyCollapser {\n+        stack: ~[clean::Visibility]\n+    }\n+    impl fold::DocFolder for PrivacyCollapser {\n+        fn fold_item(&mut self, mut i: Item) -> Option<Item> {\n+            if i.visibility.is_some() {\n+                if i.visibility == Some(ast::inherited) {\n+                    i.visibility = Some(self.stack.last().clone());\n+                } else {\n+                    self.stack.push(i.visibility.clone().unwrap());\n+                }\n+            }\n+            self.fold_item_recur(i)\n+        }\n+    }\n+    let mut privacy = PrivacyCollapser { stack: ~[] };\n+    let crate = privacy.fold_crate(crate);\n+    (crate, None)\n+}\n+\n+pub fn collapse_docs(crate: clean::Crate) -> plugins::PluginResult {\n+    struct Collapser;\n+    impl fold::DocFolder for Collapser {\n+        fn fold_item(&mut self, i: Item) -> Option<Item> {\n+            let mut docstr = ~\"\";\n+            let mut i = i;\n+            for attr in i.attrs.iter() {\n+                match *attr {\n+                    clean::NameValue(~\"doc\", ref s) => {\n+                        docstr.push_str(s.clone());\n+                        docstr.push_char('\\n');\n+                    },\n+                    _ => ()\n+                }\n+            }\n+            let mut a: ~[clean::Attribute] = i.attrs.iter().filter(|&a| match a {\n+                &clean::NameValue(~\"doc\", _) => false,\n+                _ => true\n+            }).map(|x| x.clone()).collect();\n+            if \"\" != docstr {\n+                a.push(clean::NameValue(~\"doc\", docstr.trim().to_owned()));\n+            }\n+            i.attrs = a;\n+            self.fold_item_recur(i)\n+        }\n+    }\n+    let mut collapser = Collapser;\n+    let crate = collapser.fold_crate(crate);\n+    (crate, None)\n+}\n+\n+//Utility\n+enum CleanCommentStates {\n+    Collect,\n+    Strip,\n+    Stripped,\n+}\n+\n+/// Returns the index of the last character all strings have common in their\n+/// prefix.\n+fn longest_common_prefix(s: ~[~str]) -> uint {\n+    // find the longest common prefix\n+\n+    debug!(\"lcp: looking into %?\", s);\n+    // index of the last character all the strings share\n+    let mut index = 0u;\n+\n+    if s.len() <= 1 {\n+        return 0;\n+    }\n+\n+    // whether one of the strings has been exhausted of characters yet\n+    let mut exhausted = false;\n+\n+    // character iterators for all the lines\n+    let mut lines = s.iter().filter(|x| x.len() != 0).map(|x| x.iter()).to_owned_vec();\n+\n+    'outer: loop {\n+        // because you can't label a while loop\n+        if exhausted == true {\n+            break;\n+        }\n+        debug!(\"lcp: index %u\", index);\n+        let mut lines = lines.mut_iter();\n+        let ch = match lines.next().unwrap().next() {\n+            Some(c) => c,\n+            None => { exhausted = true; loop },\n+        };\n+        debug!(\"looking for char %c\", ch);\n+        for line in lines {\n+            match line.next() {\n+                Some(c) => if c == ch { loop } else { exhausted = true; loop 'outer },\n+                None => { exhausted = true; loop 'outer }\n+            }\n+        }\n+        index += 1;\n+    }\n+\n+    debug!(\"lcp: last index %u\", index);\n+    index\n+}\n+\n+fn clean_comment_body(s: ~str) -> ~str {\n+    // FIXME #31: lots of copies in here.\n+    let lines = s.line_iter().to_owned_vec();\n+    match lines.len() {\n+        0 => return ~\"\",\n+        1 => return lines[0].slice_from(2).trim().to_owned(),\n+        _ => (),\n+    }\n+            \n+    let mut ol = std::vec::with_capacity(lines.len());\n+    for line in lines.clone().move_iter() {\n+        // replace meaningless things with a single newline\n+        match line {\n+            x if [\"/**\", \"/*!\", \"///\", \"//!\", \"*/\"].contains(&x.trim()) => ol.push(~\"\"),\n+            x if x.trim() == \"\" => ol.push(~\"\"),\n+            x => ol.push(x.to_owned())\n+        }\n+    }\n+    let li = longest_common_prefix(ol.clone());\n+    \n+    let x = ol.iter()\n+         .filter(|x| { debug!(\"cleaning line: %s\", **x); true })\n+         .map(|x| if x.len() == 0 { ~\"\" } else { x.slice_chars(li, x.char_len()).to_owned() })\n+         .to_owned_vec().connect(\"\\n\");\n+    x.trim().to_owned()\n+}"}, {"sha": "db243c9e21c1a2e29778b0b0e160740d82dab082", "filename": "src/rustdoc_ng/plugins.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/268f3f0ff5d80544ca21d565354eae6d3e29fb91/src%2Frustdoc_ng%2Fplugins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/268f3f0ff5d80544ca21d565354eae6d3e29fb91/src%2Frustdoc_ng%2Fplugins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc_ng%2Fplugins.rs?ref=268f3f0ff5d80544ca21d565354eae6d3e29fb91", "patch": "@@ -0,0 +1,80 @@\n+use clean;\n+\n+use extra;\n+use dl = std::unstable::dynamic_lib;\n+\n+pub type PluginJson = Option<(~str, extra::json::Json)>;\n+pub type PluginResult = (clean::Crate, PluginJson);\n+pub type plugin_callback = extern fn (clean::Crate) -> PluginResult;\n+\n+/// Manages loading and running of plugins\n+pub struct PluginManager {\n+    priv dylibs: ~[dl::DynamicLibrary],\n+    priv callbacks: ~[plugin_callback],\n+    /// The directory plugins will be loaded from\n+    prefix: Path,\n+}\n+\n+impl PluginManager {\n+    /// Create a new plugin manager\n+    pub fn new(prefix: Path) -> PluginManager {\n+        PluginManager {\n+            dylibs: ~[],\n+            callbacks: ~[],\n+            prefix: prefix,\n+        }\n+    }\n+\n+    /// Load a plugin with the given name.\n+    ///\n+    /// Turns `name` into the proper dynamic library filename for the given\n+    /// platform. On windows, it turns into name.dll, on OS X, name.dylib, and\n+    /// elsewhere, libname.so.\n+    pub fn load_plugin(&mut self, name: ~str) {\n+        let x = self.prefix.push(libname(name));\n+        let lib_result = dl::DynamicLibrary::open(Some(&x));\n+        let lib = lib_result.unwrap();\n+        let plugin = unsafe { lib.symbol(\"rustdoc_plugin_entrypoint\") }.unwrap();\n+        self.dylibs.push(lib);\n+        self.callbacks.push(plugin);\n+    }\n+\n+    /// Load a normal Rust function as a plugin.\n+    ///\n+    /// This is to run passes over the cleaned crate. Plugins run this way\n+    /// correspond to the A-aux tag on Github.\n+    pub fn add_plugin(&mut self, plugin: plugin_callback) {\n+        self.callbacks.push(plugin);\n+    }\n+    /// Run all the loaded plugins over the crate, returning their results\n+    pub fn run_plugins(&self, crate: clean::Crate) -> (clean::Crate, ~[PluginJson]) {\n+        let mut out_json = ~[];\n+        let mut crate = crate;\n+        for &callback in self.callbacks.iter() {\n+            let (c, res) = callback(crate);\n+            crate = c;\n+            out_json.push(res);\n+        }\n+        (crate, out_json)\n+    }\n+}\n+\n+#[cfg(target_os=\"win32\")]\n+fn libname(mut n: ~str) -> ~str {\n+    n.push_str(\".dll\");\n+    n\n+}\n+\n+#[cfg(target_os=\"macos\")]\n+fn libname(mut n: ~str) -> ~str {\n+    n.push_str(\".dylib\");\n+    n\n+}\n+\n+#[cfg(not(target_os=\"win32\"), not(target_os=\"macos\"))]\n+fn libname(n: ~str) -> ~str {\n+    let mut i = ~\"lib\";\n+    i.push_str(n);\n+    i.push_str(\".so\");\n+    i\n+}"}, {"sha": "2e437a028ec93f4cc4837e6a350c77f43beae9ce", "filename": "src/rustdoc_ng/visit_ast.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/268f3f0ff5d80544ca21d565354eae6d3e29fb91/src%2Frustdoc_ng%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/268f3f0ff5d80544ca21d565354eae6d3e29fb91/src%2Frustdoc_ng%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc_ng%2Fvisit_ast.rs?ref=268f3f0ff5d80544ca21d565354eae6d3e29fb91", "patch": "@@ -0,0 +1,173 @@\n+//! Rust AST Visitor. Extracts useful information and massages it into a form\n+//! usable for clean\n+\n+use syntax::abi::AbiSet;\n+use syntax::{ast, ast_map};\n+use syntax::codemap::span;\n+\n+use doctree::*;\n+use std::local_data;\n+\n+pub struct RustdocVisitor {\n+    module: Module,\n+    attrs: ~[ast::Attribute],\n+}\n+\n+impl RustdocVisitor {\n+    pub fn new() -> RustdocVisitor {\n+        RustdocVisitor {\n+            module: Module::new(None),\n+            attrs: ~[],\n+        }\n+    }\n+}\n+\n+impl RustdocVisitor {\n+    pub fn visit(@mut self, crate: &ast::Crate) {\n+        self.attrs = crate.attrs.clone();\n+        fn visit_struct_def(item: &ast::item, sd: @ast::struct_def, generics:\n+                            &ast::Generics) -> Struct {\n+            debug!(\"Visiting struct\");\n+            let struct_type = struct_type_from_def(sd);\n+            Struct {\n+                id: item.id,\n+                struct_type: struct_type,\n+                name: item.ident,\n+                vis: item.vis,\n+                attrs: item.attrs.clone(),\n+                generics: generics.clone(),\n+                fields: sd.fields.iter().map(|x| (*x).clone()).to_owned_vec(),\n+                where: item.span\n+            }\n+        }\n+\n+        fn visit_enum_def(it: &ast::item, def: &ast::enum_def, params: &ast::Generics) -> Enum {\n+            debug!(\"Visiting enum\");\n+            let mut vars: ~[Variant] = ~[];\n+            for x in def.variants.iter() {\n+                vars.push(Variant {\n+                    name: x.node.name,\n+                    attrs: x.node.attrs.clone(),\n+                    vis: x.node.vis,\n+                    id: x.node.id,\n+                    kind: x.node.kind.clone(),\n+                    where: x.span,\n+                });\n+            }\n+            Enum {\n+                name: it.ident,\n+                variants: vars,\n+                vis: it.vis,\n+                generics: params.clone(),\n+                attrs: it.attrs.clone(),\n+                id: it.id,\n+                where: it.span,\n+            }\n+        }\n+\n+        fn visit_fn(item: &ast::item, fd: &ast::fn_decl, _purity: &ast::purity,\n+                     _abi: &AbiSet, gen: &ast::Generics) -> Function {\n+            debug!(\"Visiting fn\");\n+            Function {\n+                id: item.id,\n+                vis: item.vis,\n+                attrs: item.attrs.clone(),\n+                decl: fd.clone(),\n+                name: item.ident,\n+                where: item.span,\n+                generics: gen.clone(),\n+            }\n+        }\n+\n+        fn visit_mod_contents(span: span, attrs: ~[ast::Attribute], vis:\n+                              ast::visibility, id: ast::NodeId, m: &ast::_mod) -> Module {\n+            let am = local_data::get(super::ctxtkey, |x| *x.unwrap()).tycx.items;\n+            let name = match am.find(&id) {\n+                Some(m) => match m {\n+                    &ast_map::node_item(ref it, _) => Some(it.ident),\n+                    _ => fail!(\"mod id mapped to non-item in the ast map\")\n+                },\n+                None => None\n+            };\n+            let mut om = Module::new(name);\n+            om.view_items = m.view_items.clone();\n+            om.where = span;\n+            om.attrs = attrs;\n+            om.vis = vis;\n+            om.id = id;\n+            for i in m.items.iter() {\n+                visit_item(*i, &mut om);\n+            }\n+            om\n+        }\n+\n+        fn visit_item(item: &ast::item, om: &mut Module) {\n+            debug!(\"Visiting item %?\", item);\n+            match item.node {\n+                ast::item_mod(ref m) => {\n+                    om.mods.push(visit_mod_contents(item.span, item.attrs.clone(),\n+                                                    item.vis, item.id, m));\n+                },\n+                ast::item_enum(ref ed, ref gen) => om.enums.push(visit_enum_def(item, ed, gen)),\n+                ast::item_struct(sd, ref gen) => om.structs.push(visit_struct_def(item, sd, gen)),\n+                ast::item_fn(ref fd, ref pur, ref abi, ref gen, _) =>\n+                    om.fns.push(visit_fn(item, fd, pur, abi, gen)),\n+                ast::item_ty(ref ty, ref gen) => {\n+                    let t = Typedef {\n+                        ty: ty.clone(),\n+                        gen: gen.clone(),\n+                        name: item.ident,\n+                        id: item.id,\n+                        attrs: item.attrs.clone(),\n+                        where: item.span,\n+                        vis: item.vis,\n+                    };\n+                    om.typedefs.push(t);\n+                },\n+                ast::item_static(ref ty, ref mut_, ref exp) => {\n+                    let s = Static {\n+                        type_: ty.clone(),\n+                        mutability: mut_.clone(),\n+                        expr: exp.clone(),\n+                        id: item.id,\n+                        name: item.ident,\n+                        attrs: item.attrs.clone(),\n+                        where: item.span,\n+                        vis: item.vis,\n+                    };\n+                    om.statics.push(s);\n+                },\n+                ast::item_trait(ref gen, ref tr, ref met) => {\n+                    let t = Trait {\n+                        name: item.ident,\n+                        methods: met.clone(),\n+                        generics: gen.clone(),\n+                        parents: tr.clone(),\n+                        id: item.id,\n+                        attrs: item.attrs.clone(),\n+                        where: item.span,\n+                        vis: item.vis,\n+                    };\n+                    om.traits.push(t);\n+                },\n+                ast::item_impl(ref gen, ref tr, ref ty, ref meths) => {\n+                    let i = Impl {\n+                        generics: gen.clone(),\n+                        trait_: tr.clone(),\n+                        for_: ty.clone(),\n+                        methods: meths.clone(),\n+                        attrs: item.attrs.clone(),\n+                        id: item.id,\n+                        where: item.span,\n+                        vis: item.vis,\n+                    };\n+                    om.impls.push(i);\n+                },\n+                _ => (),\n+            }\n+        }\n+\n+        self.module = visit_mod_contents(crate.span, crate.attrs.clone(),\n+                                         ast::public, ast::CRATE_NODE_ID, &crate.module);\n+    }\n+}"}]}