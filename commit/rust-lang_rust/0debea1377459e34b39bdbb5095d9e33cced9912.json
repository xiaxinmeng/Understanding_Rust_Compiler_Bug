{"sha": "0debea1377459e34b39bdbb5095d9e33cced9912", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkZWJlYTEzNzc0NTllMzRiMzliZGJiNTA5NWQ5ZTMzY2NlZDk5MTI=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2021-07-20T11:51:21Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2021-09-14T11:53:55Z"}, "message": "Allow taking an OwningRef of the crate metadata blob.", "tree": {"sha": "a2822f6b6fe107f6609e57d0814922a07d3112b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2822f6b6fe107f6609e57d0814922a07d3112b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0debea1377459e34b39bdbb5095d9e33cced9912", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0debea1377459e34b39bdbb5095d9e33cced9912", "html_url": "https://github.com/rust-lang/rust/commit/0debea1377459e34b39bdbb5095d9e33cced9912", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0debea1377459e34b39bdbb5095d9e33cced9912/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f85cd6f2ab2769c16e89dcdddb3e11d9736b351", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f85cd6f2ab2769c16e89dcdddb3e11d9736b351", "html_url": "https://github.com/rust-lang/rust/commit/9f85cd6f2ab2769c16e89dcdddb3e11d9736b351"}], "stats": {"total": 80, "additions": 62, "deletions": 18}, "files": [{"sha": "06b3ef2add21b53d9519d4a1c8de99ba83b946b8", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 61, "deletions": 17, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/0debea1377459e34b39bdbb5095d9e33cced9912/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0debea1377459e34b39bdbb5095d9e33cced9912/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=0debea1377459e34b39bdbb5095d9e33cced9912", "patch": "@@ -48,7 +48,26 @@ use rustc_span::hygiene::HygieneDecodeContext;\n \n mod cstore_impl;\n \n-crate struct MetadataBlob(MetadataRef);\n+/// A reference to the raw binary version of crate metadata.\n+/// A `MetadataBlob` internally is just a reference counted pointer to\n+/// the actual data, so cloning it is cheap.\n+#[derive(Clone)]\n+crate struct MetadataBlob(Lrc<MetadataRef>);\n+\n+// This is needed so we can create an OwningRef into the blob.\n+// The data behind a `MetadataBlob` has a stable address because it\n+// contained within an Rc/Arc.\n+unsafe impl rustc_data_structures::owning_ref::StableAddress for MetadataBlob {}\n+\n+// This is needed so we can create an OwningRef into the blob.\n+impl std::ops::Deref for MetadataBlob {\n+    type Target = [u8];\n+\n+    #[inline]\n+    fn deref(&self) -> &[u8] {\n+        &self.0[..]\n+    }\n+}\n \n // A map from external crate numbers (as decoded from some crate file) to\n // local crate numbers (as generated during this session). Each external\n@@ -134,6 +153,7 @@ struct ImportedSourceFile {\n pub(super) struct DecodeContext<'a, 'tcx> {\n     opaque: opaque::Decoder<'a>,\n     cdata: Option<CrateMetadataRef<'a>>,\n+    blob: &'a MetadataBlob,\n     sess: Option<&'tcx Session>,\n     tcx: Option<TyCtxt<'tcx>>,\n \n@@ -148,7 +168,11 @@ pub(super) struct DecodeContext<'a, 'tcx> {\n \n /// Abstract over the various ways one can create metadata decoders.\n pub(super) trait Metadata<'a, 'tcx>: Copy {\n-    fn raw_bytes(self) -> &'a [u8];\n+    fn blob(self) -> &'a MetadataBlob;\n+    #[inline]\n+    fn raw_bytes(self) -> &'a [u8] {\n+        self.blob()\n+    }\n     fn cdata(self) -> Option<CrateMetadataRef<'a>> {\n         None\n     }\n@@ -164,6 +188,7 @@ pub(super) trait Metadata<'a, 'tcx>: Copy {\n         DecodeContext {\n             opaque: opaque::Decoder::new(self.raw_bytes(), pos),\n             cdata: self.cdata(),\n+            blob: self.blob(),\n             sess: self.sess().or(tcx.map(|tcx| tcx.sess)),\n             tcx,\n             last_source_file_index: 0,\n@@ -176,51 +201,61 @@ pub(super) trait Metadata<'a, 'tcx>: Copy {\n }\n \n impl<'a, 'tcx> Metadata<'a, 'tcx> for &'a MetadataBlob {\n-    fn raw_bytes(self) -> &'a [u8] {\n-        &self.0\n+    #[inline]\n+    fn blob(self) -> &'a MetadataBlob {\n+        self\n     }\n }\n \n impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a MetadataBlob, &'tcx Session) {\n-    fn raw_bytes(self) -> &'a [u8] {\n-        let (blob, _) = self;\n-        &blob.0\n+    #[inline]\n+    fn blob(self) -> &'a MetadataBlob {\n+        self.0\n     }\n \n+    #[inline]\n     fn sess(self) -> Option<&'tcx Session> {\n         let (_, sess) = self;\n         Some(sess)\n     }\n }\n \n impl<'a, 'tcx> Metadata<'a, 'tcx> for &'a CrateMetadataRef<'a> {\n-    fn raw_bytes(self) -> &'a [u8] {\n-        self.blob.raw_bytes()\n+    #[inline]\n+    fn blob(self) -> &'a MetadataBlob {\n+        &self.blob\n     }\n+    #[inline]\n     fn cdata(self) -> Option<CrateMetadataRef<'a>> {\n         Some(*self)\n     }\n }\n \n impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadataRef<'a>, &'tcx Session) {\n-    fn raw_bytes(self) -> &'a [u8] {\n-        self.0.raw_bytes()\n+    #[inline]\n+    fn blob(self) -> &'a MetadataBlob {\n+        &self.0.blob\n     }\n+    #[inline]\n     fn cdata(self) -> Option<CrateMetadataRef<'a>> {\n         Some(*self.0)\n     }\n+    #[inline]\n     fn sess(self) -> Option<&'tcx Session> {\n         Some(&self.1)\n     }\n }\n \n impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadataRef<'a>, TyCtxt<'tcx>) {\n-    fn raw_bytes(self) -> &'a [u8] {\n-        self.0.raw_bytes()\n+    #[inline]\n+    fn blob(self) -> &'a MetadataBlob {\n+        &self.0.blob\n     }\n+    #[inline]\n     fn cdata(self) -> Option<CrateMetadataRef<'a>> {\n         Some(*self.0)\n     }\n+    #[inline]\n     fn tcx(self) -> Option<TyCtxt<'tcx>> {\n         Some(self.1)\n     }\n@@ -246,12 +281,21 @@ impl<'a: 'x, 'tcx: 'x, 'x, T: Decodable<DecodeContext<'a, 'tcx>>> Lazy<[T]> {\n }\n \n impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n+    #[inline]\n     fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.tcx.expect(\"missing TyCtxt in DecodeContext\")\n+        debug_assert!(self.tcx.is_some(), \"missing TyCtxt in DecodeContext\");\n+        self.tcx.unwrap()\n     }\n \n-    fn cdata(&self) -> CrateMetadataRef<'a> {\n-        self.cdata.expect(\"missing CrateMetadata in DecodeContext\")\n+    #[inline]\n+    pub fn blob(&self) -> &'a MetadataBlob {\n+        self.blob\n+    }\n+\n+    #[inline]\n+    pub fn cdata(&self) -> CrateMetadataRef<'a> {\n+        debug_assert!(self.cdata.is_some(), \"missing CrateMetadata in DecodeContext\");\n+        self.cdata.unwrap()\n     }\n \n     fn map_encoded_cnum_to_current(&self, cnum: CrateNum) -> CrateNum {\n@@ -586,7 +630,7 @@ implement_ty_decoder!(DecodeContext<'a, 'tcx>);\n \n impl MetadataBlob {\n     crate fn new(metadata_ref: MetadataRef) -> MetadataBlob {\n-        MetadataBlob(metadata_ref)\n+        MetadataBlob(Lrc::new(metadata_ref))\n     }\n \n     crate fn is_compatible(&self) -> bool {"}, {"sha": "4dfefda490b3deeea6878c4f97787aecd747da5c", "filename": "compiler/rustc_metadata/src/rmeta/table.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0debea1377459e34b39bdbb5095d9e33cced9912/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0debea1377459e34b39bdbb5095d9e33cced9912/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs?ref=0debea1377459e34b39bdbb5095d9e33cced9912", "patch": "@@ -199,7 +199,7 @@ where\n         debug!(\"Table::lookup: index={:?} len={:?}\", i, self.meta);\n \n         let start = self.position.get();\n-        let bytes = &metadata.raw_bytes()[start..start + self.meta];\n+        let bytes = &metadata.blob()[start..start + self.meta];\n         <Option<T>>::maybe_read_from_bytes_at(bytes, i.index())?\n     }\n "}]}