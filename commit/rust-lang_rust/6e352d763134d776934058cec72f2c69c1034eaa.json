{"sha": "6e352d763134d776934058cec72f2c69c1034eaa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlMzUyZDc2MzEzNGQ3NzY5MzQwNThjZWM3MmYyYzY5YzEwMzRlYWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-13T00:16:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-13T00:16:34Z"}, "message": "auto merge of #11504 : bjz/rust/std-num-cleanups, r=brson\n\nThe gamma and bessel functions are of little utility outside a small specialized subset of use cases, and so they don't really make sense for inclusion in the standard library. The only reason they were included in the first place was to mirror libm, which is not a very good justification. If people need them for their own projects then they can make their own bindings to libm (which isn't too hard).", "tree": {"sha": "ce1492d55ae6498f49e9c088e26afd50ab7841e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce1492d55ae6498f49e9c088e26afd50ab7841e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e352d763134d776934058cec72f2c69c1034eaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e352d763134d776934058cec72f2c69c1034eaa", "html_url": "https://github.com/rust-lang/rust/commit/6e352d763134d776934058cec72f2c69c1034eaa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e352d763134d776934058cec72f2c69c1034eaa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0091a15a43db8d742f960837def2058550e8156c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0091a15a43db8d742f960837def2058550e8156c", "html_url": "https://github.com/rust-lang/rust/commit/0091a15a43db8d742f960837def2058550e8156c"}, {"sha": "cd248e29b14e58dc583d71b6bcdf2b8091fb9a9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd248e29b14e58dc583d71b6bcdf2b8091fb9a9f", "html_url": "https://github.com/rust-lang/rust/commit/cd248e29b14e58dc583d71b6bcdf2b8091fb9a9f"}], "stats": {"total": 317, "additions": 81, "deletions": 236}, "files": [{"sha": "8d4c4471c89ffb7fa96a830ffd35b6d9e2762c65", "filename": "src/libextra/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e352d763134d776934058cec72f2c69c1034eaa/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e352d763134d776934058cec72f2c69c1034eaa/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=6e352d763134d776934058cec72f2c69c1034eaa", "patch": "@@ -979,7 +979,7 @@ impl MetricMap {\n                     if delta.abs() <= noise {\n                         LikelyNoise\n                     } else {\n-                        let pct = delta.abs() / (vold.value).max(&f64::epsilon) * 100.0;\n+                        let pct = delta.abs() / (vold.value).max(&f64::EPSILON) * 100.0;\n                         if vold.noise < 0.0 {\n                             // When 'noise' is negative, it means we want\n                             // to see deltas that go up over time, and can"}, {"sha": "4c1752d556cb42441f25aedce0c31097e45a03cc", "filename": "src/libstd/num/cmath.rs", "status": "modified", "additions": 9, "deletions": 108, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/6e352d763134d776934058cec72f2c69c1034eaa/src%2Flibstd%2Fnum%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e352d763134d776934058cec72f2c69c1034eaa/src%2Flibstd%2Fnum%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fcmath.rs?ref=6e352d763134d776934058cec72f2c69c1034eaa", "patch": "@@ -9,20 +9,19 @@\n // except according to those terms.\n \n #[allow(missing_doc)];\n-#[allow(non_uppercase_statics)];\n #[allow(dead_code)];\n \n //! Bindings for the C math library (for basic mathematic functions)\n \n-// function names are almost identical to C's libmath, a few have been\n+// Function names are almost identical to C's libmath, a few have been\n // renamed, grep for \"rename:\"\n \n-pub mod c_double_utils {\n+pub mod c_double {\n     use libc::{c_double, c_int};\n \n     #[link_name = \"m\"]\n     extern {\n-        // Alpabetically sorted by link_name\n+        // Alphabetically sorted by link_name\n \n         pub fn acos(n: c_double) -> c_double;\n         pub fn asin(n: c_double) -> c_double;\n@@ -79,8 +78,8 @@ pub mod c_double_utils {\n         pub fn ilog_radix(n: c_double) -> c_int;\n         pub fn modf(n: c_double, iptr: &mut c_double) -> c_double;\n         pub fn pow(n: c_double, e: c_double) -> c_double;\n-    // FIXME (#1379): enable when rounding modes become available\n-    //    fn rint(n: c_double) -> c_double;\n+        // FIXME (#1379): enable when rounding modes become available\n+        //    fn rint(n: c_double) -> c_double;\n         pub fn round(n: c_double) -> c_double;\n         // rename: for consistency with logradix\n         #[link_name=\"scalbn\"]\n@@ -105,12 +104,12 @@ pub mod c_double_utils {\n     }\n }\n \n-pub mod c_float_utils {\n+pub mod c_float {\n     use libc::{c_float, c_int};\n \n     #[link_name = \"m\"]\n     extern {\n-        // Alpabetically sorted by link_name\n+        // Alphabetically sorted by link_name\n \n         #[link_name=\"acosf\"]\n         pub fn acos(n: c_float) -> c_float;\n@@ -185,8 +184,8 @@ pub mod c_float_utils {\n         pub fn modf(n: c_float, iptr: &mut c_float) -> c_float;\n         #[link_name=\"powf\"]\n         pub fn pow(n: c_float, e: c_float) -> c_float;\n-    // FIXME (#1379): enable when rounding modes become available\n-    //    #[link_name=\"rintf\"] fn rint(n: c_float) -> c_float;\n+        // FIXME (#1379): enable when rounding modes become available\n+        //    #[link_name=\"rintf\"] fn rint(n: c_float) -> c_float;\n         #[link_name=\"roundf\"]\n         pub fn round(n: c_float) -> c_float;\n         #[link_name=\"scalbnf\"]\n@@ -207,101 +206,3 @@ pub mod c_float_utils {\n         pub fn trunc(n: c_float) -> c_float;\n     }\n }\n-\n-// PORT check these by running src/etc/machconsts.c for your architecture\n-\n-// FIXME obtain machine float/math constants automatically (Issue #1986)\n-\n-pub mod c_float_targ_consts {\n-    pub static radix: uint = 2u;\n-    pub static mantissa_digits: uint = 24u;\n-    pub static digits: uint = 6u;\n-    pub static min_exp: uint = -125u;\n-    pub static max_exp: uint = 128u;\n-    pub static min_10_exp: int = -37;\n-    pub static max_10_exp: int = 38;\n-    // FIXME (#1433): this is wrong, replace with hexadecimal (%a) staticants\n-    // below.\n-    pub static min_value: f32 = 1.175494e-38_f32;\n-    pub static max_value: f32 = 3.402823e+38_f32;\n-    pub static epsilon: f32 = 0.000000_f32;\n-}\n-\n-pub mod c_double_targ_consts {\n-    pub static radix: uint = 2u;\n-    pub static mantissa_digits: uint = 53u;\n-    pub static digits: uint = 15u;\n-    pub static min_exp: uint = -1021u;\n-    pub static max_exp: uint = 1024u;\n-    pub static min_10_exp: int = -307;\n-    pub static max_10_exp: int = 308;\n-    // FIXME (#1433): this is wrong, replace with hexadecimal (%a) staticants\n-    // below.\n-    pub static min_value: f64 = 2.225074e-308_f64;\n-    pub static max_value: f64 = 1.797693e+308_f64;\n-    pub static epsilon: f64 = 2.220446e-16_f64;\n-}\n-\n-/*\n-\n-FIXME use these once they can be parsed (see Issue #1433)\n-\n-pub mod c_float_math_consts {\n-    pub static pi: c_float = 0x1.921fb6p+1_f32;\n-    pub static div_1_pi: c_float = 0x1.45f306p-2_f32;\n-    pub static div_2_pi: c_float = 0x1.45f306p-1_f32;\n-    pub static div_pi_2: c_float = 0x1.921fb6p+0_f32;\n-    pub static div_pi_4: c_float = 0x1.921fb6p-1_f32;\n-    pub static div_2_sqrtpi: c_float = 0x1.20dd76p+0_f32;\n-    pub static e: c_float = 0x1.5bf0a8p+1_f32;\n-    pub static log2_e: c_float = 0x1.715476p+0_f32;\n-    pub static log10_e: c_float = 0x1.bcb7b2p-2_f32;\n-    pub static ln_2: c_float = 0x1.62e43p-1_f32;\n-    pub static ln_10: c_float = 0x1.26bb1cp+1_f32;\n-    pub static sqrt2: c_float = 0x1.6a09e6p+0_f32;\n-    pub static div_1_sqrt2: c_float = 0x1.6a09e6p-1_f32;\n-}\n-\n-pub mod c_double_math_consts {\n-    pub static pi: c_double = 0x1.921fb54442d18p+1_f64;\n-    pub static div_1_pi: c_double = 0x1.45f306dc9c883p-2_f64;\n-    pub static div_2_pi: c_double = 0x1.45f306dc9c883p-1_f64;\n-    pub static div_pi_2: c_double = 0x1.921fb54442d18p+0_f64;\n-    pub static div_pi_4: c_double = 0x1.921fb54442d18p-1_f64;\n-    pub static div_2_sqrtpi: c_double = 0x1.20dd750429b6dp+0_f64;\n-    pub static e: c_double = 0x1.5bf0a8b145769p+1_f64;\n-    pub static log2_e: c_double = 0x1.71547652b82fep+0_f64;\n-    pub static log10_e: c_double = 0x1.bcb7b1526e50ep-2_f64;\n-    pub static ln_2: c_double = 0x1.62e42fefa39efp-1_f64;\n-    pub static ln_10: c_double = 0x1.26bb1bbb55516p+1_f64;\n-    pub static sqrt2: c_double = 0x1.6a09e667f3bcdp+0_f64;\n-    pub static div_1_sqrt2: c_double = 0x1.6a09e667f3bcdp-1_f64;\n-}\n-\n-pub mod c_float_targ_consts {\n-    pub static radix: uint = 2u;\n-    pub static mantissa_digits: uint = 24u;\n-    pub static digits: uint = 6u;\n-    pub static min_exp: int = -125;\n-    pub static max_exp: int = 128;\n-    pub static min_10_exp: int = -37;\n-    pub static max_10_exp: int = 38;\n-    pub static min_value: c_float = 0x1p-126_f32;\n-    pub static max_value: c_float = 0x1.fffffep+127_f32;\n-    pub static epsilon: c_float = 0x1p-23_f32;\n-}\n-\n-pub mod c_double_targ_consts {\n-    pub static radix: uint = 2u;\n-    pub static mantissa_digits: uint = 53u;\n-    pub static digits: uint = 15u;\n-    pub static min_exp: int = -1021;\n-    pub static max_exp: int = 1024;\n-    pub static min_10_exp: int = -307;\n-    pub static max_10_exp: int = 308;\n-    pub static min_value: c_double = 0x1p-1022_f64;\n-    pub static max_value: c_double = 0x1.fffffffffffffp+1023_f64;\n-    pub static epsilon: c_double = 0x1p-52_f64;\n-}\n-\n-*/"}, {"sha": "beecf8a44f6325d4c86aead191690df05122cc39", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 43, "deletions": 39, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/6e352d763134d776934058cec72f2c69c1034eaa/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e352d763134d776934058cec72f2c69c1034eaa/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=6e352d763134d776934058cec72f2c69c1034eaa", "patch": "@@ -13,7 +13,7 @@\n \n use prelude::*;\n \n-use cmath::c_float_utils;\n+use cmath;\n use default::Default;\n use libc::{c_float, c_int};\n use num::{FPCategory, FPNaN, FPInfinite , FPZero, FPSubnormal, FPNormal};\n@@ -22,8 +22,6 @@ use num;\n use to_str;\n use unstable::intrinsics;\n \n-pub use cmath::c_float_targ_consts::*;\n-\n macro_rules! delegate(\n     (\n         $(\n@@ -62,8 +60,8 @@ delegate!(\n     fn sqrt(n: f32) -> f32 = intrinsics::sqrtf32,\n \n     // LLVM 3.3 required to use intrinsics for these four\n-    fn ceil(n: c_float) -> c_float = c_float_utils::ceil,\n-    fn trunc(n: c_float) -> c_float = c_float_utils::trunc,\n+    fn ceil(n: c_float) -> c_float = cmath::c_float::ceil,\n+    fn trunc(n: c_float) -> c_float = cmath::c_float::trunc,\n     /*\n     fn ceil(n: f32) -> f32 = intrinsics::ceilf32,\n     fn trunc(n: f32) -> f32 = intrinsics::truncf32,\n@@ -72,47 +70,53 @@ delegate!(\n     */\n \n     // cmath\n-    fn acos(n: c_float) -> c_float = c_float_utils::acos,\n-    fn asin(n: c_float) -> c_float = c_float_utils::asin,\n-    fn atan(n: c_float) -> c_float = c_float_utils::atan,\n-    fn atan2(a: c_float, b: c_float) -> c_float = c_float_utils::atan2,\n-    fn cbrt(n: c_float) -> c_float = c_float_utils::cbrt,\n-    fn copysign(x: c_float, y: c_float) -> c_float = c_float_utils::copysign,\n-    fn cosh(n: c_float) -> c_float = c_float_utils::cosh,\n-    // fn erf(n: c_float) -> c_float = c_float_utils::erf,\n-    // fn erfc(n: c_float) -> c_float = c_float_utils::erfc,\n-    fn exp_m1(n: c_float) -> c_float = c_float_utils::exp_m1,\n-    fn abs_sub(a: c_float, b: c_float) -> c_float = c_float_utils::abs_sub,\n-    fn next_after(x: c_float, y: c_float) -> c_float = c_float_utils::next_after,\n-    fn frexp(n: c_float, value: &mut c_int) -> c_float = c_float_utils::frexp,\n-    fn hypot(x: c_float, y: c_float) -> c_float = c_float_utils::hypot,\n-    fn ldexp(x: c_float, n: c_int) -> c_float = c_float_utils::ldexp,\n-    // fn lgamma(n: c_float, sign: &mut c_int) -> c_float = c_float_utils::lgamma,\n-    // fn log_radix(n: c_float) -> c_float = c_float_utils::log_radix,\n-    fn ln_1p(n: c_float) -> c_float = c_float_utils::ln_1p,\n-    // fn ilog_radix(n: c_float) -> c_int = c_float_utils::ilog_radix,\n-    // fn modf(n: c_float, iptr: &mut c_float) -> c_float = c_float_utils::modf,\n-    fn round(n: c_float) -> c_float = c_float_utils::round,\n-    // fn ldexp_radix(n: c_float, i: c_int) -> c_float = c_float_utils::ldexp_radix,\n-    fn sinh(n: c_float) -> c_float = c_float_utils::sinh,\n-    fn tan(n: c_float) -> c_float = c_float_utils::tan,\n-    fn tanh(n: c_float) -> c_float = c_float_utils::tanh\n-    // fn tgamma(n: c_float) -> c_float = c_float_utils::tgamma\n+    fn acos(n: c_float) -> c_float = cmath::c_float::acos,\n+    fn asin(n: c_float) -> c_float = cmath::c_float::asin,\n+    fn atan(n: c_float) -> c_float = cmath::c_float::atan,\n+    fn atan2(a: c_float, b: c_float) -> c_float = cmath::c_float::atan2,\n+    fn cbrt(n: c_float) -> c_float = cmath::c_float::cbrt,\n+    fn copysign(x: c_float, y: c_float) -> c_float = cmath::c_float::copysign,\n+    fn cosh(n: c_float) -> c_float = cmath::c_float::cosh,\n+    // fn erf(n: c_float) -> c_float = cmath::c_float::erf,\n+    // fn erfc(n: c_float) -> c_float = cmath::c_float::erfc,\n+    fn exp_m1(n: c_float) -> c_float = cmath::c_float::exp_m1,\n+    fn abs_sub(a: c_float, b: c_float) -> c_float = cmath::c_float::abs_sub,\n+    fn next_after(x: c_float, y: c_float) -> c_float = cmath::c_float::next_after,\n+    fn frexp(n: c_float, value: &mut c_int) -> c_float = cmath::c_float::frexp,\n+    fn hypot(x: c_float, y: c_float) -> c_float = cmath::c_float::hypot,\n+    fn ldexp(x: c_float, n: c_int) -> c_float = cmath::c_float::ldexp,\n+    // fn log_radix(n: c_float) -> c_float = cmath::c_float::log_radix,\n+    fn ln_1p(n: c_float) -> c_float = cmath::c_float::ln_1p,\n+    // fn ilog_radix(n: c_float) -> c_int = cmath::c_float::ilog_radix,\n+    // fn modf(n: c_float, iptr: &mut c_float) -> c_float = cmath::c_float::modf,\n+    fn round(n: c_float) -> c_float = cmath::c_float::round,\n+    // fn ldexp_radix(n: c_float, i: c_int) -> c_float = cmath::c_float::ldexp_radix,\n+    fn sinh(n: c_float) -> c_float = cmath::c_float::sinh,\n+    fn tan(n: c_float) -> c_float = cmath::c_float::tan,\n+    fn tanh(n: c_float) -> c_float = cmath::c_float::tanh\n )\n \n-// These are not defined inside consts:: for consistency with\n-// the integer types\n+pub static RADIX: uint = 2u;\n \n-pub static NAN: f32 = 0.0_f32/0.0_f32;\n+pub static MANTISSA_DIGITS: uint = 53u;\n+pub static DIGITS: uint = 15u;\n \n-pub static INFINITY: f32 = 1.0_f32/0.0_f32;\n+pub static EPSILON: f64 = 2.220446e-16_f64;\n \n-pub static NEG_INFINITY: f32 = -1.0_f32/0.0_f32;\n+// FIXME (#1433): this is wrong, replace with hexadecimal (%a) statics\n+// below.\n+pub static MIN_VALUE: f64 = 2.225074e-308_f64;\n+pub static MAX_VALUE: f64 = 1.797693e+308_f64;\n \n-// FIXME (#1999): replace the predicates below with llvm intrinsics or\n-// calls to the libmath macros in the rust runtime for performance.\n+pub static MIN_EXP: uint = -1021u;\n+pub static MAX_EXP: uint = 1024u;\n \n-// FIXME (#1999): add is_normal, is_subnormal, and fpclassify.\n+pub static MIN_10_EXP: int = -307;\n+pub static MAX_10_EXP: int = 308;\n+\n+pub static NAN: f32 = 0.0_f32/0.0_f32;\n+pub static INFINITY: f32 = 1.0_f32/0.0_f32;\n+pub static NEG_INFINITY: f32 = -1.0_f32/0.0_f32;\n \n /* Module: consts */\n pub mod consts {"}, {"sha": "6a266c6c59f7ac4f1305de6fda9ac0ea1383cbb7", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 28, "deletions": 70, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/6e352d763134d776934058cec72f2c69c1034eaa/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e352d763134d776934058cec72f2c69c1034eaa/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=6e352d763134d776934058cec72f2c69c1034eaa", "patch": "@@ -14,16 +14,15 @@\n \n use prelude::*;\n \n-use cmath::c_double_utils;\n+use cmath;\n use default::Default;\n use libc::{c_double, c_int};\n use num::{FPCategory, FPNaN, FPInfinite , FPZero, FPSubnormal, FPNormal};\n-use num::{Zero, One, RealExt, strconv};\n+use num::{Zero, One, strconv};\n use num;\n use to_str;\n use unstable::intrinsics;\n \n-pub use cmath::c_double_targ_consts::*;\n pub use cmp::{min, max};\n \n macro_rules! delegate(\n@@ -64,8 +63,8 @@ delegate!(\n     fn sqrt(n: f64) -> f64 = intrinsics::sqrtf64,\n \n     // LLVM 3.3 required to use intrinsics for these four\n-    fn ceil(n: c_double) -> c_double = c_double_utils::ceil,\n-    fn trunc(n: c_double) -> c_double = c_double_utils::trunc,\n+    fn ceil(n: c_double) -> c_double = cmath::c_double::ceil,\n+    fn trunc(n: c_double) -> c_double = cmath::c_double::trunc,\n     /*\n     fn ceil(n: f64) -> f64 = intrinsics::ceilf64,\n     fn trunc(n: f64) -> f64 = intrinsics::truncf64,\n@@ -74,45 +73,34 @@ delegate!(\n     */\n \n     // cmath\n-    fn acos(n: c_double) -> c_double = c_double_utils::acos,\n-    fn asin(n: c_double) -> c_double = c_double_utils::asin,\n-    fn atan(n: c_double) -> c_double = c_double_utils::atan,\n-    fn atan2(a: c_double, b: c_double) -> c_double = c_double_utils::atan2,\n-    fn cbrt(n: c_double) -> c_double = c_double_utils::cbrt,\n-    fn copysign(x: c_double, y: c_double) -> c_double = c_double_utils::copysign,\n-    fn cosh(n: c_double) -> c_double = c_double_utils::cosh,\n-    // fn erf(n: c_double) -> c_double = c_double_utils::erf,\n-    // fn erfc(n: c_double) -> c_double = c_double_utils::erfc,\n-    fn exp_m1(n: c_double) -> c_double = c_double_utils::exp_m1,\n-    fn abs_sub(a: c_double, b: c_double) -> c_double = c_double_utils::abs_sub,\n-    fn next_after(x: c_double, y: c_double) -> c_double = c_double_utils::next_after,\n-    fn frexp(n: c_double, value: &mut c_int) -> c_double = c_double_utils::frexp,\n-    fn hypot(x: c_double, y: c_double) -> c_double = c_double_utils::hypot,\n-    fn ldexp(x: c_double, n: c_int) -> c_double = c_double_utils::ldexp,\n-    fn lgamma(n: c_double, sign: &mut c_int) -> c_double = c_double_utils::lgamma,\n-    // fn log_radix(n: c_double) -> c_double = c_double_utils::log_radix,\n-    fn ln_1p(n: c_double) -> c_double = c_double_utils::ln_1p,\n-    // fn ilog_radix(n: c_double) -> c_int = c_double_utils::ilog_radix,\n-    // fn modf(n: c_double, iptr: &mut c_double) -> c_double = c_double_utils::modf,\n-    fn round(n: c_double) -> c_double = c_double_utils::round,\n-    // fn ldexp_radix(n: c_double, i: c_int) -> c_double = c_double_utils::ldexp_radix,\n-    fn sinh(n: c_double) -> c_double = c_double_utils::sinh,\n-    fn tan(n: c_double) -> c_double = c_double_utils::tan,\n-    fn tanh(n: c_double) -> c_double = c_double_utils::tanh,\n-    fn tgamma(n: c_double) -> c_double = c_double_utils::tgamma,\n-    fn j0(n: c_double) -> c_double = c_double_utils::j0,\n-    fn j1(n: c_double) -> c_double = c_double_utils::j1,\n-    fn jn(i: c_int, n: c_double) -> c_double = c_double_utils::jn,\n-    fn y0(n: c_double) -> c_double = c_double_utils::y0,\n-    fn y1(n: c_double) -> c_double = c_double_utils::y1,\n-    fn yn(i: c_int, n: c_double) -> c_double = c_double_utils::yn\n+    fn acos(n: c_double) -> c_double = cmath::c_double::acos,\n+    fn asin(n: c_double) -> c_double = cmath::c_double::asin,\n+    fn atan(n: c_double) -> c_double = cmath::c_double::atan,\n+    fn atan2(a: c_double, b: c_double) -> c_double = cmath::c_double::atan2,\n+    fn cbrt(n: c_double) -> c_double = cmath::c_double::cbrt,\n+    fn copysign(x: c_double, y: c_double) -> c_double = cmath::c_double::copysign,\n+    fn cosh(n: c_double) -> c_double = cmath::c_double::cosh,\n+    // fn erf(n: c_double) -> c_double = cmath::c_double::erf,\n+    // fn erfc(n: c_double) -> c_double = cmath::c_double::erfc,\n+    fn exp_m1(n: c_double) -> c_double = cmath::c_double::exp_m1,\n+    fn abs_sub(a: c_double, b: c_double) -> c_double = cmath::c_double::abs_sub,\n+    fn next_after(x: c_double, y: c_double) -> c_double = cmath::c_double::next_after,\n+    fn frexp(n: c_double, value: &mut c_int) -> c_double = cmath::c_double::frexp,\n+    fn hypot(x: c_double, y: c_double) -> c_double = cmath::c_double::hypot,\n+    fn ldexp(x: c_double, n: c_int) -> c_double = cmath::c_double::ldexp,\n+    // fn log_radix(n: c_double) -> c_double = cmath::c_double::log_radix,\n+    fn ln_1p(n: c_double) -> c_double = cmath::c_double::ln_1p,\n+    // fn ilog_radix(n: c_double) -> c_int = cmath::c_double::ilog_radix,\n+    // fn modf(n: c_double, iptr: &mut c_double) -> c_double = cmath::c_double::modf,\n+    fn round(n: c_double) -> c_double = cmath::c_double::round,\n+    // fn ldexp_radix(n: c_double, i: c_int) -> c_double = cmath::c_double::ldexp_radix,\n+    fn sinh(n: c_double) -> c_double = cmath::c_double::sinh,\n+    fn tan(n: c_double) -> c_double = cmath::c_double::tan,\n+    fn tanh(n: c_double) -> c_double = cmath::c_double::tanh\n )\n \n // FIXME (#1433): obtain these in a different way\n \n-// These are not defined inside consts:: for consistency with\n-// the integer types\n-\n pub static RADIX: uint = 2u;\n \n pub static MANTISSA_DIGITS: uint = 53u;\n@@ -560,36 +548,6 @@ impl Real for f64 {\n     }\n }\n \n-impl RealExt for f64 {\n-    #[inline]\n-    fn lgamma(&self) -> (int, f64) {\n-        let mut sign = 0;\n-        let result = lgamma(*self, &mut sign);\n-        (sign as int, result)\n-    }\n-\n-    #[inline]\n-    fn tgamma(&self) -> f64 { tgamma(*self) }\n-\n-    #[inline]\n-    fn j0(&self) -> f64 { j0(*self) }\n-\n-    #[inline]\n-    fn j1(&self) -> f64 { j1(*self) }\n-\n-    #[inline]\n-    fn jn(&self, n: int) -> f64 { jn(n as c_int, *self) }\n-\n-    #[inline]\n-    fn y0(&self) -> f64 { y0(*self) }\n-\n-    #[inline]\n-    fn y1(&self) -> f64 { y1(*self) }\n-\n-    #[inline]\n-    fn yn(&self, n: int) -> f64 { yn(n as c_int, *self) }\n-}\n-\n impl Bounded for f64 {\n     #[inline]\n     fn min_value() -> f64 { 2.2250738585072014e-308 }"}, {"sha": "2bf3158e6b4355c866bb06b0c3201945a9eb1d7e", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6e352d763134d776934058cec72f2c69c1034eaa/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e352d763134d776934058cec72f2c69c1034eaa/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=6e352d763134d776934058cec72f2c69c1034eaa", "patch": "@@ -324,24 +324,6 @@ pub trait Real: Signed\n /// Inverse hyperbolic tangent function.\n #[inline(always)] pub fn atanh<T: Real>(value: T) -> T { value.atanh() }\n \n-/// Methods that are harder to implement and not commonly used.\n-pub trait RealExt: Real {\n-    // FIXME (#5527): usages of `int` should be replaced with an associated\n-    // integer type once these are implemented\n-\n-    // Gamma functions\n-    fn lgamma(&self) -> (int, Self);\n-    fn tgamma(&self) -> Self;\n-\n-    // Bessel functions\n-    fn j0(&self) -> Self;\n-    fn j1(&self) -> Self;\n-    fn jn(&self, n: int) -> Self;\n-    fn y0(&self) -> Self;\n-    fn y1(&self) -> Self;\n-    fn yn(&self, n: int) -> Self;\n-}\n-\n /// Collects the bitwise operators under one trait.\n pub trait Bitwise: Not<Self>\n                  + BitAnd<Self,Self>"}]}