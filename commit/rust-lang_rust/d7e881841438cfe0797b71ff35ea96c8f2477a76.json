{"sha": "d7e881841438cfe0797b71ff35ea96c8f2477a76", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3ZTg4MTg0MTQzOGNmZTA3OTdiNzFmZjM1ZWE5NmM4ZjI0NzdhNzY=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-04-12T19:16:21Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-04-12T21:31:46Z"}, "message": "Further work on typestate. Handles expr_rec and expr_assign now.\n\nAlso changed the ts_ann field on statements to be an ann instead,\nwhich explains most of the changes.\n\nAs well, got rid of the \"warning: no type for expression\" error\nby filling in annotations for local decls in typeck (not sure whether\nthis was my fault or not).\n\nFinally, in bitv, added a clone() function to copy a bit vector,\nand fixed is_true, is_false, and to_str to not be nonsense.", "tree": {"sha": "727e73ccf9138df34a1ad3585ef00559e526b2c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/727e73ccf9138df34a1ad3585ef00559e526b2c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7e881841438cfe0797b71ff35ea96c8f2477a76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7e881841438cfe0797b71ff35ea96c8f2477a76", "html_url": "https://github.com/rust-lang/rust/commit/d7e881841438cfe0797b71ff35ea96c8f2477a76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7e881841438cfe0797b71ff35ea96c8f2477a76/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87d17c3a2cfbdaf3d860a9df171c6be220aaab5e", "url": "https://api.github.com/repos/rust-lang/rust/commits/87d17c3a2cfbdaf3d860a9df171c6be220aaab5e", "html_url": "https://github.com/rust-lang/rust/commit/87d17c3a2cfbdaf3d860a9df171c6be220aaab5e"}], "stats": {"total": 800, "additions": 548, "deletions": 252}, "files": [{"sha": "50517f003c33089b3f55727c6705bef11b10dd6b", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7e881841438cfe0797b71ff35ea96c8f2477a76/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e881841438cfe0797b71ff35ea96c8f2477a76/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=d7e881841438cfe0797b71ff35ea96c8f2477a76", "patch": "@@ -215,8 +215,10 @@ tag mode {\n \n type stmt = spanned[stmt_];\n tag stmt_ {\n-    stmt_decl(@decl, option.t[@ts_ann]);\n-    stmt_expr(@expr, option.t[@ts_ann]);\n+/* Only the ts_ann field is meaningful for statements,\n+   but we make it an ann to make traversals simpler */\n+    stmt_decl(@decl, ann); \n+    stmt_expr(@expr, ann);\n     // These only exist in crate-level blocks.\n     stmt_crate_directive(@crate_directive);\n }"}, {"sha": "9410465579c637e63e1b9586b655f17cceebf75c", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d7e881841438cfe0797b71ff35ea96c8f2477a76/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e881841438cfe0797b71ff35ea96c8f2477a76/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=d7e881841438cfe0797b71ff35ea96c8f2477a76", "patch": "@@ -11,7 +11,7 @@ import util.common;\n import util.common.filename;\n import util.common.span;\n import util.common.new_str_hash;\n-import util.typestate_ann.ts_ann;\n+import util.common.plain_ann;\n \n tag restriction {\n     UNRESTRICTED;\n@@ -1562,14 +1562,15 @@ impure fn parse_source_stmt(parser p) -> @ast.stmt {\n \n         case (token.LET) {\n             auto decl = parse_let(p);\n-            ret @spanned(lo, decl.span.hi,\n-                         ast.stmt_decl(decl, none[@ts_ann]));\n+            auto hi = p.get_span();\n+            ret @spanned\n+                (lo, decl.span.hi, ast.stmt_decl(decl, plain_ann()));\n         }\n \n         case (token.AUTO) {\n             auto decl = parse_auto(p);\n-            ret @spanned(lo, decl.span.hi,\n-                         ast.stmt_decl(decl, none[@ts_ann]));\n+            auto hi = p.get_span();\n+            ret @spanned(lo, decl.span.hi, ast.stmt_decl(decl, plain_ann()));\n         }\n \n         case (_) {\n@@ -1578,12 +1579,13 @@ impure fn parse_source_stmt(parser p) -> @ast.stmt {\n                 auto i = parse_item(p);\n                 auto hi = i.span.hi;\n                 auto decl = @spanned(lo, hi, ast.decl_item(i));\n-                ret @spanned(lo, hi, ast.stmt_decl(decl, none[@ts_ann]));\n+                ret @spanned(lo, hi, ast.stmt_decl(decl, plain_ann()));\n \n             } else {\n                 // Remainder are line-expr stmts.\n                 auto e = parse_expr(p);\n-                ret @spanned(lo, e.span.hi, ast.stmt_expr(e, none[@ts_ann]));\n+                auto hi = p.get_span();\n+                ret @spanned(lo, e.span.hi, ast.stmt_expr(e, plain_ann()));\n             }\n         }\n     }"}, {"sha": "e9c4ee2a0ba50fa86a595d431bdfa462e1236eb4", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d7e881841438cfe0797b71ff35ea96c8f2477a76/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e881841438cfe0797b71ff35ea96c8f2477a76/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=d7e881841438cfe0797b71ff35ea96c8f2477a76", "patch": "@@ -232,11 +232,11 @@ type ast_fold[ENV] =\n \n      // Stmt folds.\n      (fn(&ENV e, &span sp,\n-         @decl decl, option.t[@ts_ann] a)\n+         @decl decl, ann a)\n       -> @stmt)                                   fold_stmt_decl,\n \n      (fn(&ENV e, &span sp,\n-         @expr e, option.t[@ts_ann] a)\n+         @expr e, ann a)\n       -> @stmt)                                   fold_stmt_expr,\n \n      // Item folds.\n@@ -470,7 +470,9 @@ fn fold_decl[ENV](&ENV env, ast_fold[ENV] fld, @decl d) -> @decl {\n                 }\n                 case (_) { /* fall through */  }\n             }\n-            let @ast.local local_ = @rec(ty=ty_, init=init_ with *local);\n+            auto ann_ = fld.fold_ann(env_, local.ann);\n+            let @ast.local local_ =\n+                @rec(ty=ty_, init=init_, ann=ann_ with *local);\n             ret fld.fold_decl_local(env_, d.span, local_);\n         }\n \n@@ -830,12 +832,14 @@ fn fold_stmt[ENV](&ENV env, ast_fold[ENV] fld, &@stmt s) -> @stmt {\n     alt (s.node) {\n         case (ast.stmt_decl(?d, ?a)) {\n             auto dd = fold_decl(env_, fld, d);\n-            ret fld.fold_stmt_decl(env_, s.span, dd, a);\n+            auto aa = fld.fold_ann(env_, a);\n+            ret fld.fold_stmt_decl(env_, s.span, dd, aa);\n         }\n \n         case (ast.stmt_expr(?e, ?a)) {\n             auto ee = fold_expr(env_, fld, e);\n-            ret fld.fold_stmt_expr(env_, s.span, ee, a);\n+            auto aa = fld.fold_ann(env_, a);\n+            ret fld.fold_stmt_expr(env_, s.span, ee, aa);\n         }\n     }\n     fail;\n@@ -1426,13 +1430,11 @@ fn identity_fold_pat_tag[ENV](&ENV e, &span sp, path p, vec[@pat] args,\n \n // Stmt identities.\n \n-fn identity_fold_stmt_decl[ENV](&ENV env, &span sp, @decl d,\n-                                option.t[@ts_ann] a) -> @stmt {\n+fn identity_fold_stmt_decl[ENV](&ENV env, &span sp, @decl d, ann a) -> @stmt {\n     ret @respan(sp, ast.stmt_decl(d, a));\n }\n \n-fn identity_fold_stmt_expr[ENV](&ENV e, &span sp, @expr x,\n-                                option.t[@ts_ann] a) -> @stmt {\n+fn identity_fold_stmt_expr[ENV](&ENV e, &span sp, @expr x, ann a) -> @stmt {\n     ret @respan(sp, ast.stmt_expr(x, a));\n }\n \n@@ -1705,7 +1707,7 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n              bind identity_fold_native_item_ty[ENV](_,_,_,_),\n          fold_item_tag  = bind identity_fold_item_tag[ENV](_,_,_,_,_,_,_),\n          fold_item_obj  = bind identity_fold_item_obj[ENV](_,_,_,_,_,_,_),\n-\n+       \n          fold_view_item_use =\n              bind identity_fold_view_item_use[ENV](_,_,_,_,_,_),\n          fold_view_item_import ="}, {"sha": "663c0bb90eeff71cbe249c0224ecd1e3b9b01e20", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d7e881841438cfe0797b71ff35ea96c8f2477a76/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e881841438cfe0797b71ff35ea96c8f2477a76/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=d7e881841438cfe0797b71ff35ea96c8f2477a76", "patch": "@@ -1541,7 +1541,7 @@ fn resolve_local_types_in_block(&@fn_ctxt fcx, &ast.block block)\n     // FIXME: rustboot bug prevents us from using these functions directly\n     auto fld = fold.new_identity_fold[option.t[@fn_ctxt]]();\n     auto wbl = writeback_local;\n-    auto rltia = resolve_local_types_in_annotation;\n+    auto rltia = bind resolve_local_types_in_annotation(_,_);\n     auto uefi = update_env_for_item;\n     auto kg = keep_going;\n     fld = @rec(\n@@ -2551,6 +2551,10 @@ fn check_decl_local(&@fn_ctxt fcx, &@ast.decl decl) -> @ast.decl {\n     alt (decl.node) {\n         case (ast.decl_local(?local)) {\n \n+            auto t;\n+\n+            t = plain_ty(middle.ty.ty_nil);\n+            \n             alt (local.ty) {\n                 case (none[@ast.ty]) {\n                     // Auto slot. Do nothing for now.\n@@ -2559,7 +2563,16 @@ fn check_decl_local(&@fn_ctxt fcx, &@ast.decl decl) -> @ast.decl {\n                 case (some[@ast.ty](?ast_ty)) {\n                     auto local_ty = ast_ty_to_ty_crate(fcx.ccx, ast_ty);\n                     fcx.locals.insert(local.id, local_ty);\n+                    t = local_ty;\n+                }\n+            }\n+\n+            auto a_res = local.ann; \n+            alt (a_res) {\n+                case (ann_none) {\n+                    a_res = triv_ann(t);\n                 }\n+                case (_) {}\n             }\n \n             auto initopt = local.init;\n@@ -2583,7 +2596,7 @@ fn check_decl_local(&@fn_ctxt fcx, &@ast.decl decl) -> @ast.decl {\n                 }\n                 case (_) { /* fall through */  }\n             }\n-            auto local_1 = @rec(init = initopt with *local);\n+            auto local_1 = @rec(init = initopt, ann = a_res with *local);\n             ret @rec(node=ast.decl_local(local_1)\n                      with *decl);\n         }"}, {"sha": "8b51e1be72e0b5d7acfc0836edc77871c6473227", "filename": "src/comp/middle/typestate_check.rs", "status": "modified", "additions": 423, "deletions": 216, "changes": 639, "blob_url": "https://github.com/rust-lang/rust/blob/d7e881841438cfe0797b71ff35ea96c8f2477a76/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e881841438cfe0797b71ff35ea96c8f2477a76/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs?ref=d7e881841438cfe0797b71ff35ea96c8f2477a76", "patch": "@@ -22,8 +22,12 @@ import front.ast.expr_call;\n import front.ast.expr_vec;\n import front.ast.expr_tup;\n import front.ast.expr_path;\n+import front.ast.expr_field;\n+import front.ast.expr_index;\n import front.ast.expr_log;\n import front.ast.expr_block;\n+import front.ast.expr_rec;\n+import front.ast.expr_assign;\n import front.ast.expr_lit;\n import front.ast.path;\n import front.ast.crate_directive;\n@@ -63,6 +67,7 @@ import util.common.new_str_hash;\n import util.common.new_def_hash;\n import util.common.uistr;\n import util.common.elt_exprs;\n+import util.common.field_exprs;\n import util.typestate_ann;\n import util.typestate_ann.ts_ann;\n import util.typestate_ann.empty_pre_post;\n@@ -82,12 +87,14 @@ import util.typestate_ann.set_postcondition;\n import util.typestate_ann.set_prestate;\n import util.typestate_ann.set_poststate;\n import util.typestate_ann.set_in_postcond;\n+import util.typestate_ann.set_in_poststate;\n import util.typestate_ann.implies;\n import util.typestate_ann.pre_and_post_state;\n import util.typestate_ann.empty_states;\n import util.typestate_ann.empty_prestate;\n import util.typestate_ann.empty_ann;\n import util.typestate_ann.extend_prestate;\n+import util.typestate_ann.extend_poststate;\n \n import middle.ty;\n import middle.ty.ann_to_type;\n@@ -136,16 +143,6 @@ import util.typestate_ann.pps_len;\n import util.typestate_ann.require_and_preserve;\n \n /**** debugging junk  ****/\n-fn log_expr(@expr e) -> () {\n-  let str_writer s = string_writer();\n-  auto out_ = mkstate(s.get_writer(), 80u);\n-  auto out = @rec(s=out_,\n-                  comments=option.none[vec[front.lexer.cmnt]],\n-                  mutable cur_cmnt=0u);\n-\n-  print_expr(out, e);\n-  log(s.get_str());\n-}\n \n fn log_stmt(stmt st) -> () {\n   let str_writer s = string_writer();\n@@ -409,13 +406,38 @@ fn ann_to_ts_ann(ann a, uint nv) -> ts_ann {\n   }\n }\n \n-fn stmt_ann(&stmt s) -> option.t[@ts_ann] {\n+fn ann_to_ts_ann_fail(ann a) -> option.t[@ts_ann] {\n+  alt (a) {\n+      case (ann_none) { \n+          log(\"ann_to_ts_ann_fail: didn't expect ann_none here\");\n+          fail;\n+      }\n+      case (ann_type(_,_,?t)) {\n+          ret t;\n+      }\n+  }\n+}\n+\n+fn ann_to_ts_ann_fail_more(ann a) -> @ts_ann {\n+  alt (a) {\n+      case (ann_none) { \n+          log(\"ann_to_ts_ann_fail: didn't expect ann_none here\");\n+          fail;\n+      }\n+      case (ann_type(_,_,?t)) {\n+          check (! is_none[@ts_ann](t));\n+          ret get[@ts_ann](t);\n+      }\n+  }\n+}\n+\n+fn stmt_to_ann(&stmt s) -> option.t[@ts_ann] {\n   alt (s.node) {\n     case (stmt_decl(_,?a)) {\n-      ret a;\n+        ret ann_to_ts_ann_fail(a);\n     }\n     case (stmt_expr(_,?a)) {\n-      ret a;\n+        ret ann_to_ts_ann_fail(a);\n     }\n     case (stmt_crate_directive(_)) {\n       ret none[@ts_ann];\n@@ -473,7 +495,7 @@ fn expr_pp(&expr e) -> pre_and_post {\n }\n \n fn stmt_states(&stmt s, uint nv) -> pre_and_post_state {\n-  alt (stmt_ann(s)) {\n+  alt (stmt_to_ann(s)) {\n     case (none[@ts_ann]) {\n       ret empty_states(nv);\n     }\n@@ -545,22 +567,21 @@ fn with_pp(ann a, pre_and_post p) -> ann {\n // precondition shouldn't include x.\n fn seq_preconds(uint num_vars, vec[pre_and_post] pps) -> precond {\n   let uint sz = len[pre_and_post](pps);\n-  \n-  if (sz == 0u) {\n-    ret true_precond(num_vars);\n-  }\n-  else {\n-    auto first   = pps.(0);\n+  check(sz >= 1u);\n+  auto first   = pps.(0);\n+\n+  if (sz > 1u) {\n     check (pps_len(first) == num_vars);\n     let precond rest = seq_preconds(num_vars,\n                          slice[pre_and_post](pps, 1u, sz));\n     difference(rest, first.postcondition);\n     union(first.precondition, rest);\n-    ret (first.precondition);\n   }\n+\n+  ret (first.precondition);\n }\n \n-fn union_postconds_go(postcond first, &vec[postcond] rest) -> postcond {\n+fn union_postconds_go(&postcond first, &vec[postcond] rest) -> postcond {\n   auto sz = _vec.len[postcond](rest);\n \n   if (sz > 0u) {\n@@ -575,7 +596,7 @@ fn union_postconds_go(postcond first, &vec[postcond] rest) -> postcond {\n fn union_postconds(&vec[postcond] pcs) -> postcond {\n   check (len[postcond](pcs) > 0u);\n \n-  be union_postconds_go(pcs.(0), pcs);\n+  ret union_postconds_go(bitv.clone(pcs.(0)), pcs);\n }\n \n /******* AST-traversing code ********/\n@@ -592,90 +613,64 @@ fn find_pre_post_obj(_obj o) -> _obj {\n   ret o; /* FIXME */\n }\n \n-fn find_pre_post_item(_fn_info_map fm, fn_info enclosing, &item i) -> item {\n+fn find_pre_post_item(_fn_info_map fm, fn_info enclosing, &item i) -> () {\n   alt (i.node) {\n     case (ast.item_const(?id, ?t, ?e, ?di, ?a)) {\n-      auto e_pp = find_pre_post_expr(enclosing, *e);\n-      log(\"1\");\n-      ret (respan(i.span,\n-                  ast.item_const(id, t, e_pp, di, a)));\n+      find_pre_post_expr(enclosing, *e);\n     }\n     case (ast.item_fn(?id, ?f, ?ps, ?di, ?a)) {\n       check (fm.contains_key(di));\n-      auto f_pp = find_pre_post_fn(fm, fm.get(di), f);\n-      ret (respan(i.span, \n-                   ast.item_fn(id, f_pp, ps, di, a)));\n+      find_pre_post_fn(fm, fm.get(di), f);\n     }\n     case (ast.item_mod(?id, ?m, ?di)) {\n-      auto m_pp = find_pre_post_mod(m);\n-      log(\"3\");\n-      ret (respan(i.span,\n-                   ast.item_mod(id, m_pp, di)));\n+      find_pre_post_mod(m);\n     }\n     case (ast.item_native_mod(?id, ?nm, ?di)) {\n-      auto n_pp = find_pre_post_native_mod(nm);\n-      log(\"4\");\n-      ret (respan(i.span,\n-                   ast.item_native_mod(id, n_pp, di)));\n+      find_pre_post_native_mod(nm);\n     }\n     case (ast.item_ty(_,_,_,_,_)) {\n-      ret i;\n+      ret;\n     }\n     case (ast.item_tag(_,_,_,_,_)) {\n-      ret i;\n+      ret;\n     }\n     case (ast.item_obj(?id, ?o, ?ps, ?di, ?a)) {\n-      auto o_pp = find_pre_post_obj(o);\n-      log(\"5\");\n-      ret (respan(i.span,\n-                   ast.item_obj(id, o_pp, ps, di, a)));\n+      find_pre_post_obj(o);\n     }\n   }\n }\n \n-fn find_pre_post_expr(&fn_info enclosing, &expr e) -> @expr {\n+/* Fills in annotations as a side effect. Does not rebuild the expr */\n+fn find_pre_post_expr(&fn_info enclosing, &expr e) -> () {\n   auto num_local_vars = num_locals(enclosing);\n \n-  fn do_rand_(fn_info enclosing, &@expr e) -> @expr {\n-    log(\"for rand \" );\n-    log_expr(e);\n-    log(\"pp = \");\n-    auto res = find_pre_post_expr(enclosing, *e);\n-    log_pp(expr_pp(*res));\n-    ret res;\n+  fn do_rand_(fn_info enclosing, &@expr e) -> () {\n+    find_pre_post_expr(enclosing, *e);\n+  }\n+  fn pp_one(&@expr e) -> pre_and_post {\n+      be expr_pp(*e);\n   }\n-\n-  auto do_rand = bind do_rand_(enclosing,_);\n \n   alt(e.node) {\n-    case(expr_call(?oper, ?rands, ?a)) {\n-      auto pp_oper = find_pre_post_expr(enclosing, *oper);\n-      log(\"pp_oper =\");\n-      log_pp(expr_pp(*pp_oper));\n-      \n+    case(expr_call(?operator, ?operands, ?a)) {\n+      find_pre_post_expr(enclosing, *operator);\n+\n+      auto do_rand = bind do_rand_(enclosing,_);\n       auto f = do_rand;\n-      auto pp_rands = _vec.map[@expr, @expr](f, rands);\n+      _vec.map[@expr, ()](f, operands);\n       \n-      fn pp_one(&@expr e) -> pre_and_post {\n-        be expr_pp(*e);\n-      }\n       auto g = pp_one;\n-      auto pps = _vec.map[@expr, pre_and_post](g, pp_rands);\n-      _vec.push[pre_and_post](pps, expr_pp(*pp_oper));\n+      auto pps = _vec.map[@expr, pre_and_post](g, operands);\n+      _vec.push[pre_and_post](pps, expr_pp(*operator));\n       auto h = get_post;\n       auto res_postconds = _vec.map[pre_and_post, postcond](h, pps);\n       auto res_postcond = union_postconds(res_postconds);\n+      \n       let pre_and_post pp =\n         rec(precondition=seq_preconds(num_local_vars, pps),\n              postcondition=res_postcond);\n-      let ann a_res = with_pp(a, pp);\n-      log(\"result for call\");\n-      log_expr(@e);\n-      log(\"is:\");\n-      log_pp(pp);\n-      ret (@respan(e.span,\n-                   expr_call(pp_oper, pp_rands, a_res)));\n-                        \n+      set_pre_and_post(a, pp);\n+      ret;\n     }\n     case(expr_path(?p, ?maybe_def, ?a)) {\n       auto df;\n@@ -696,32 +691,111 @@ fn find_pre_post_expr(&fn_info enclosing, &expr e) -> @expr {\n       }\n \n       // Otherwise, variable is global, so it must be initialized\n-      log(\"pre/post for:\\n\");\n-      log_expr(@e);\n-      log(\"is\");\n-      log_pp(res);\n-      ret (@respan\n-           (e.span,\n-            expr_path(p, maybe_def,\n-                      with_pp(a, res))));\n+      set_pre_and_post(a, res);\n     }\n     case(expr_log(?arg, ?a)) {\n-      log(\"log\");\n-      auto e_pp = find_pre_post_expr(enclosing, *arg);\n-      log(\"pre/post for: \");\n-      log_expr(arg);\n-      log(\"is\");\n-      log_pp(expr_pp(*e_pp));\n-      ret (@respan(e.span,\n-                   expr_log(e_pp, with_pp(a, expr_pp(*e_pp)))));\n+      find_pre_post_expr(enclosing, *arg);\n+      set_pre_and_post(a, expr_pp(*arg));\n     }\n     case (expr_block(?b, ?a)) {\n       log(\"block!\");\n       fail;\n     }\n-    case (expr_lit(?l, ?a)) {\n-      ret @respan(e.span,\n-                  expr_lit(l, with_pp(a, empty_pre_post(num_local_vars))));\n+    case (expr_rec(?fields,?maybe_base,?a)) {\n+        /* factor out this code */\n+        auto es = field_exprs(fields);\n+        auto do_rand = bind do_rand_(enclosing,_);\n+        auto f = do_rand;\n+        _vec.map[@expr, ()](f, es);\n+        auto g = pp_one;\n+        auto h = get_post;\n+        /* FIXME avoid repeated code */\n+        alt (maybe_base) {\n+            case (none[@expr]) {\n+                auto pps = _vec.map[@expr, pre_and_post](g, es);\n+                auto res_postconds = _vec.map[pre_and_post, postcond](h, pps);\n+                auto res_postcond = union_postconds(res_postconds);\n+                let pre_and_post pp =\n+                    rec(precondition=seq_preconds(num_local_vars, pps),\n+                        postcondition=res_postcond);\n+                set_pre_and_post(a, pp);\n+            }\n+            case (some[@expr](?base_exp)) {\n+                find_pre_post_expr(enclosing, *base_exp);\n+        \n+                es += vec(base_exp);\n+                auto pps = _vec.map[@expr, pre_and_post](g, es);\n+                auto res_postconds = _vec.map[pre_and_post, postcond](h, pps);\n+                auto res_postcond = union_postconds(res_postconds);\n+\n+                let pre_and_post pp =\n+                    rec(precondition=seq_preconds(num_local_vars, pps),\n+                        postcondition=res_postcond);\n+                set_pre_and_post(a, pp);\n+            }\n+        }\n+        ret;\n+    }\n+    case (expr_assign(?lhs, ?rhs, ?a)) {\n+        // what's below should be compressed into two cases:\n+        // path of a local, and non-path-of-a-local\n+        alt (lhs.node) {\n+            case (expr_field(?e,?id,?a_lhs)) {\n+                // lhs is already initialized, so this doesn't initialize\n+                // anything anew\n+                find_pre_post_expr(enclosing, *e);\n+                set_pre_and_post(a_lhs, expr_pp(*e));\n+\n+                find_pre_post_expr(enclosing, *rhs);\n+                let pre_and_post expr_assign_pp = \n+                    rec(precondition=seq_preconds\n+                         (num_local_vars,\n+                          vec(expr_pp(*e), expr_pp(*rhs))),\n+                        postcondition=union_postconds\n+                        (vec(expr_postcond(*e), expr_postcond(*rhs))));\n+                set_pre_and_post(a, expr_assign_pp);\n+            }\n+            case (expr_path(?p,?maybe_def,?a_lhs)) {\n+                find_pre_post_expr(enclosing, *rhs);\n+                set_pre_and_post(a_lhs, empty_pre_post(num_local_vars));\n+                find_pre_post_expr(enclosing, *rhs);\n+                alt (maybe_def) {\n+                    // is this a local variable?\n+                    // if so, the only case in which an assign actually\n+                    // causes a variable to become initialized\n+                    case (some[def](def_local(?d_id))) {\n+                        set_pre_and_post(a, expr_pp(*rhs));\n+                        gen(enclosing, a, d_id);\n+                    }\n+                    case (_) {\n+                        // already initialized\n+                        set_pre_and_post(a, expr_pp(*rhs));\n+                    }\n+                }\n+            }\n+            case (expr_index(?e,?sub,_)) {\n+                // lhs is already initialized\n+                // assuming the array subscript gets evaluated before the\n+                // array\n+                find_pre_post_expr(enclosing, *lhs);\n+                find_pre_post_expr(enclosing, *rhs);\n+                set_pre_and_post(a, \n+                   rec(precondition=\n+                        seq_preconds\n+                          (num_local_vars, vec(expr_pp(*lhs), expr_pp(*rhs))),\n+                       postcondition=\n+                          union_postconds(vec(expr_postcond(*lhs),\n+                                              expr_postcond(*rhs)))));\n+                \n+            }\n+            case (_) {\n+                log(\"find_pre_post_for_expr: non-lval on lhs of assign\");\n+                fail;\n+            }\n+        }\n+    }\n+    case (expr_lit(_,?a)) {\n+        set_pre_and_post(a, empty_pre_post(num_local_vars));\n     }\n     case(_) {\n       log(\"this sort of expr isn't implemented!\");\n@@ -730,118 +804,85 @@ fn find_pre_post_expr(&fn_info enclosing, &expr e) -> @expr {\n   }\n }\n \n-impure fn gen(&fn_info enclosing, ts_ann a, def_id id) {\n+impure fn gen(&fn_info enclosing, &ann a, def_id id) -> bool {\n   check(enclosing.contains_key(id));\n   let uint i = (enclosing.get(id))._0;\n \n-  set_in_postcond(i, a.conditions);\n+  ret set_in_postcond(i, (ann_to_ts_ann_fail_more(a)).conditions);\n+}\n+\n+impure fn gen_poststate(&fn_info enclosing, &ann a, def_id id) -> bool {\n+  check(enclosing.contains_key(id));\n+  let uint i = (enclosing.get(id))._0;\n+\n+  ret set_in_poststate(i, (ann_to_ts_ann_fail_more(a)).states);\n }\n \n fn find_pre_post_stmt(_fn_info_map fm, &fn_info enclosing, &ast.stmt s)\n-  -> ast.stmt {\n+    -> () {\n   auto num_local_vars = num_locals(enclosing);\n-\n   alt(s.node) {\n     case(ast.stmt_decl(?adecl, ?a)) {\n-      alt(adecl.node) {\n-        case(ast.decl_local(?alocal)) {\n-          alt(alocal.init) {\n-            case(some[ast.initializer](?an_init)) {\n-              let @expr r = find_pre_post_expr(enclosing, *an_init.expr);\n-              let init_op o = an_init.op;\n-              let initializer a_i = rec(op=o, expr=r);\n-              let ann res_ann = with_pp(alocal.ann, expr_pp(*r));\n-              let @local res_local =\n-                @rec(ty=alocal.ty, infer=alocal.infer,\n-                     ident=alocal.ident, init=some[initializer](a_i),\n-                     id=alocal.id, ann=res_ann);\n-\n-              let ts_ann stmt_ann;\n-              alt (a) {\n-                case (none[@ts_ann]) {\n-                  stmt_ann = empty_ann(num_local_vars);\n+        alt(adecl.node) {\n+            case(ast.decl_local(?alocal)) {\n+                alt(alocal.init) {\n+                    case(some[ast.initializer](?an_init)) {\n+                        find_pre_post_expr(enclosing, *an_init.expr);\n+                        auto rhs_pp = expr_pp(*an_init.expr);\n+                        set_pre_and_post(alocal.ann, rhs_pp);\n+\n+                        /* Inherit ann from initializer, and add var being\n+                           initialized to the postcondition */\n+                        set_pre_and_post(a, rhs_pp);\n+                        gen(enclosing, a, alocal.id); \n+                    }\n+                    case(none[ast.initializer]) {\n+                        auto pp = empty_pre_post(num_local_vars);\n+                        set_pre_and_post(alocal.ann, pp);\n+                        set_pre_and_post(a, pp);\n+                    }\n                 }\n-                case (some[@ts_ann](?aa)) {\n-                  stmt_ann = *aa;\n-                }\n-              }\n-              /* Inherit ann from initializer, and add var being\n-                 initialized to the postcondition */\n-              set_precondition(stmt_ann, expr_precond(*r));\n-              set_postcondition(stmt_ann, expr_postcond(*r));\n-              gen(enclosing, stmt_ann, alocal.id); \n-              let stmt_ res = stmt_decl(@respan(adecl.span,\n-                                                decl_local(res_local)),\n-                                        some[@ts_ann](@stmt_ann));\n-              ret (respan(s.span, res)); \n             }\n-            case(none[ast.initializer]) {\n-              // log(\"pre/post for init of \" + alocal.ident + \": none\");\n-              let ann res_ann = with_pp(alocal.ann,\n-                                        empty_pre_post(num_local_vars));\n-              let @local res_local =\n-                @rec(ty=alocal.ty, infer=alocal.infer,\n-                     ident=alocal.ident, init=none[initializer],\n-                     id=alocal.id, ann=res_ann);\n-              let stmt_ res =\n-                stmt_decl\n-                (@respan(adecl.span, decl_local(res_local)),\n-                 some[@ts_ann](@empty_ann(num_local_vars)));\n-              ret respan(s.span, res); /* inherit ann from initializer */\n+            case(decl_item(?anitem)) {\n+                auto pp = empty_pre_post(num_local_vars);\n+                set_pre_and_post(a, pp);\n+                find_pre_post_item(fm, enclosing, *anitem);\n             }\n-          }\n         }\n-        case(decl_item(?anitem)) {\n-          auto res_item = find_pre_post_item(fm, enclosing, *anitem);\n-          ret respan(s.span,\n-                     stmt_decl(@respan(adecl.span,\n-                                       decl_item(@res_item)),\n-                               some[@ts_ann](@empty_ann(num_local_vars))));\n-        }\n-      }\n     }\n-    case(stmt_expr(?e,_)) {\n-      log_expr(e);\n-      let @expr e_pp = find_pre_post_expr(enclosing, *e);\n-      /* inherit ann from expr */\n-      ret respan(s.span,\n-                 stmt_expr(e_pp,\n-                           some[@ts_ann]\n-                           (@ann_to_ts_ann(expr_ann(*e_pp),\n-                                           num_local_vars)))); \n+    case(stmt_expr(?e,?a)) {\n+        find_pre_post_expr(enclosing, *e);\n+        set_pre_and_post(a, expr_pp(*e));\n     }    \n   }\n }\n \n fn find_pre_post_block(&_fn_info_map fm, &fn_info enclosing, block b)\n-  -> block {\n-  fn do_one_(_fn_info_map fm, fn_info i, &@stmt s) -> @stmt {\n-    ret (@find_pre_post_stmt(fm, i, *s));\n-  }\n-  auto do_one = bind do_one_(fm, enclosing, _);\n- \n-  auto ss = _vec.map[@stmt, @stmt](do_one, b.node.stmts);\n-  fn do_inner_(fn_info i, &@expr e) -> @expr {\n-    ret find_pre_post_expr(i, *e);\n-  }\n-  auto do_inner = bind do_inner_(enclosing, _);\n-  let option.t[@expr] e_ = option.map[@expr, @expr](do_inner, b.node.expr);\n-  let block_ b_res = rec(stmts=ss, expr=e_, index=b.node.index);\n-  ret respan(b.span, b_res);\n+    -> () {\n+    fn do_one_(_fn_info_map fm, fn_info i, &@stmt s) -> () {\n+        find_pre_post_stmt(fm, i, *s);\n+    }\n+    auto do_one = bind do_one_(fm, enclosing, _);\n+    \n+    _vec.map[@stmt, ()](do_one, b.node.stmts);\n+    fn do_inner_(fn_info i, &@expr e) -> () {\n+        find_pre_post_expr(i, *e);\n+    }\n+    auto do_inner = bind do_inner_(enclosing, _);\n+    option.map[@expr, ()](do_inner, b.node.expr);\n }\n \n-fn find_pre_post_fn(&_fn_info_map fm, &fn_info fi, &_fn f) -> _fn {\n-  ret rec(decl=f.decl, proto=f.proto,\n-          body=find_pre_post_block(fm, fi, f.body));\n+fn find_pre_post_fn(&_fn_info_map fm, &fn_info fi, &_fn f) -> () {\n+    find_pre_post_block(fm, fi, f.body);\n }\n \n fn check_item_fn(&_fn_info_map fm, &span sp, ident i, &ast._fn f,\n                  vec[ast.ty_param] ty_params, def_id id, ann a) -> @item {\n \n   check (fm.contains_key(id));\n-  auto res_f = find_pre_post_fn(fm, fm.get(id), f);  \n+  find_pre_post_fn(fm, fm.get(id), f);  \n \n-  ret @respan(sp, ast.item_fn(i, res_f, ty_params, id, a));\n+  ret @respan(sp, ast.item_fn(i, f, ty_params, id, a));\n }\n \n /* FIXME */\n@@ -850,11 +891,11 @@ fn find_pre_post_state_item(_fn_info_map fm, @item i) -> bool {\n   fail;\n }\n \n-impure fn set_prestate_ann(ann a, prestate pre) -> () {\n+impure fn set_prestate_ann(ann a, prestate pre) -> bool {\n   alt (a) {\n     case (ann_type(_,_,?ts_a)) {\n       check (! is_none[@ts_ann](ts_a));\n-      set_prestate(*get[@ts_ann](ts_a), pre);\n+      ret set_prestate(*get[@ts_ann](ts_a), pre);\n     }\n     case (ann_none) {\n       log(\"set_prestate_ann: expected an ann_type here\");\n@@ -863,11 +904,25 @@ impure fn set_prestate_ann(ann a, prestate pre) -> () {\n   }\n }\n \n-impure fn set_poststate_ann(ann a, poststate post) -> () {\n+\n+impure fn extend_prestate_ann(ann a, prestate pre) -> bool {\n+  alt (a) {\n+    case (ann_type(_,_,?ts_a)) {\n+      check (! is_none[@ts_ann](ts_a));\n+      ret extend_prestate((*get[@ts_ann](ts_a)).states.prestate, pre);\n+    }\n+    case (ann_none) {\n+      log(\"set_prestate_ann: expected an ann_type here\");\n+      fail;\n+    }\n+  }\n+}\n+\n+impure fn set_poststate_ann(ann a, poststate post) -> bool {\n   alt (a) {\n     case (ann_type(_,_,?ts_a)) {\n       check (! is_none[@ts_ann](ts_a));\n-      set_poststate(*get[@ts_ann](ts_a), post);\n+      ret set_poststate(*get[@ts_ann](ts_a), post);\n     }\n     case (ann_none) {\n       log(\"set_poststate_ann: expected an ann_type here\");\n@@ -876,6 +931,34 @@ impure fn set_poststate_ann(ann a, poststate post) -> () {\n   }\n }\n \n+impure fn extend_poststate_ann(ann a, poststate post) -> bool {\n+  alt (a) {\n+    case (ann_type(_,_,?ts_a)) {\n+      check (! is_none[@ts_ann](ts_a));\n+      ret extend_poststate((*get[@ts_ann](ts_a)).states.poststate, post);\n+    }\n+    case (ann_none) {\n+      log(\"set_poststate_ann: expected an ann_type here\");\n+      fail;\n+    }\n+  }\n+}\n+\n+impure fn set_pre_and_post(&ann a, pre_and_post pp) -> () {\n+    alt (a) {\n+        case (ann_type(_,_,?ts_a)) {\n+            check (! is_none[@ts_ann](ts_a));\n+            auto t = *get[@ts_ann](ts_a);\n+            set_precondition(t, pp.precondition);\n+            set_postcondition(t, pp.postcondition);\n+        }\n+        case (ann_none) {\n+            log(\"set_pre_and_post: expected an ann_type here\");\n+            fail;\n+        }\n+    }\n+}\n+\n fn seq_states(&_fn_info_map fm, &fn_info enclosing,\n     prestate pres, vec[@expr] exprs) -> tup(bool, poststate) {\n   auto changed = false;\n@@ -894,20 +977,25 @@ fn find_pre_post_state_exprs(&_fn_info_map fm,\n                              &prestate pres,\n                              &ann a, &vec[@expr] es) -> bool {\n   auto res = seq_states(fm, enclosing, pres, es);\n-  set_prestate_ann(a, pres);\n-  set_poststate_ann(a, res._1);\n-  ret res._0;\n+  auto changed = res._0;\n+  changed = extend_prestate_ann(a, pres) || changed;\n+  changed = extend_poststate_ann(a, res._1) || changed;\n+  ret changed;\n }\n \n-impure fn pure_exp(&ann a, &prestate p) -> () {\n-  set_prestate_ann(a, p);\n-  set_poststate_ann(a, p);\n+impure fn pure_exp(&ann a, &prestate p) -> bool {\n+  auto changed = false;\n+  changed = extend_prestate_ann(a, p) || changed;\n+  changed = extend_poststate_ann(a, p) || changed;\n+  ret changed;\n }\n \n fn find_pre_post_state_expr(&_fn_info_map fm, &fn_info enclosing,\n                             &prestate pres, &@expr e) -> bool {\n   auto changed = false;\n \n+  /* a bit confused about when setting the states happens */\n+\n   alt (e.node) {\n     case (expr_vec(?elts, _, ?a)) {\n       be find_pre_post_state_exprs(fm, enclosing, pres, a, elts); \n@@ -925,13 +1013,58 @@ fn find_pre_post_state_expr(&_fn_info_map fm, &fn_info enclosing,\n           || changed);\n     }\n     case (expr_path(_,_,?a)) {\n-      pure_exp(a, pres);\n-      ret false;\n+      ret pure_exp(a, pres);\n     }\n     case (expr_log(?e,?a)) {\n         changed = find_pre_post_state_expr(fm, enclosing, pres, e);\n-        set_prestate_ann(a, pres);\n-        set_poststate_ann(a, expr_poststate(*e));\n+        changed = extend_prestate_ann(a, pres) || changed;\n+        changed = extend_poststate_ann(a, expr_poststate(*e)) || changed;\n+        ret changed;\n+    }\n+    case (expr_lit(?l,?a)) {\n+        ret pure_exp(a, pres);\n+    }\n+    case (expr_block(?b,?a)) {\n+        log(\"find_pre_post_state_expr: block!\");\n+        fail;\n+    }\n+    case (expr_rec(?fields,?maybe_base,?a)) {\n+        changed = find_pre_post_state_exprs(fm, enclosing, pres, a,\n+                                            field_exprs(fields)) || changed;\n+        alt (maybe_base) {\n+            case (none[@expr]) { /* do nothing */ }\n+            case (some[@expr](?base)) {\n+                changed = find_pre_post_state_expr(fm, enclosing, pres, base)\n+                    || changed;\n+                changed = extend_poststate_ann(a, expr_poststate(*base))\n+                    || changed;\n+            }\n+        }\n+        ret changed;\n+    }\n+    case (expr_assign(?lhs, ?rhs, ?a)) {\n+        extend_prestate_ann(a, pres);\n+\n+        alt (lhs.node) {\n+            case (expr_path(?p, some[def](def_local(?d_id)), ?a_lhs)) {\n+                // assignment to local var\n+                changed = pure_exp(a_lhs, pres) || changed;\n+                changed = find_pre_post_state_expr(fm, enclosing, pres, rhs)\n+                    || changed;\n+                changed = extend_poststate_ann(a, expr_poststate(*rhs))\n+                    || changed;\n+                changed = gen_poststate(enclosing, a, d_id) || changed;\n+            }\n+            case (_) {\n+                // assignment to something that must already have been init'd\n+                changed = find_pre_post_state_expr(fm, enclosing, pres, lhs)\n+                    || changed;\n+                changed = find_pre_post_state_expr(fm, enclosing,\n+                     expr_poststate(*lhs), rhs) || changed;\n+                changed = extend_poststate_ann(a, expr_poststate(*rhs))\n+                    || changed;\n+            }\n+        }\n         ret changed;\n     }\n     case (_) {\n@@ -945,26 +1078,52 @@ fn find_pre_post_state_expr(&_fn_info_map fm, &fn_info enclosing,\n fn find_pre_post_state_stmt(&_fn_info_map fm, &fn_info enclosing,\n                             &prestate pres, @stmt s) -> bool {\n   auto changed = false;\n+  auto stmt_ann_ = stmt_to_ann(*s);\n+  check (!is_none[@ts_ann](stmt_ann_));\n+  auto stmt_ann = *(get[@ts_ann](stmt_ann_));\n+  /*                  \n+              log(\"*At beginning: stmt = \");\n+              log_stmt(*s);\n+              log(\"*prestate = \");\n+              log(bitv.to_str(stmt_ann.states.prestate));\n+              log(\"*poststate =\");\n+              log(bitv.to_str(stmt_ann.states.poststate));\n+              log(\"*changed =\");\n+              log(changed);\n+  */       \n   alt (s.node) {\n     case (stmt_decl(?adecl, ?a)) {\n-      /* a must be some(a') at this point */\n-      check (! is_none[@ts_ann](a));\n-      auto stmt_ann = *(get[@ts_ann](a));\n       alt (adecl.node) {\n         case (ast.decl_local(?alocal)) {\n           alt (alocal.init) {\n             case (some[ast.initializer](?an_init)) {\n               changed = find_pre_post_state_expr\n                 (fm, enclosing, pres, an_init.expr) || changed;\n-              set_prestate(stmt_ann, expr_prestate(*an_init.expr));\n-              set_poststate(stmt_ann, expr_poststate(*an_init.expr));\n-              gen(enclosing, stmt_ann, alocal.id);\n+              changed = extend_poststate(stmt_ann.states.poststate,\n+                                         expr_poststate(*an_init.expr))\n+                  || changed;\n+              changed = gen_poststate(enclosing, a, alocal.id) || changed;\n+    \n+              /*\n+              log(\"Summary: stmt = \");\n+              log_stmt(*s);\n+              log(\"prestate = \");\n+              log(bitv.to_str(stmt_ann.states.prestate));\n+              log_bitv(enclosing, stmt_ann.states.prestate);\n+              log(\"poststate =\");\n+              log_bitv(enclosing, stmt_ann.states.poststate);\n+              log(\"changed =\");\n+              log(changed);\n+              */\n+\n               ret changed;\n             }\n             case (none[ast.initializer]) {\n-              set_prestate(stmt_ann, pres);\n-              set_poststate(stmt_ann, pres);\n-              ret false;\n+              changed = extend_prestate(stmt_ann.states.prestate, pres)\n+                  || changed;\n+              changed = extend_poststate(stmt_ann.states.poststate, pres)\n+                  || changed;\n+              ret changed;\n             }\n           }\n         }\n@@ -973,12 +1132,23 @@ fn find_pre_post_state_stmt(&_fn_info_map fm, &fn_info enclosing,\n         }\n       }\n     }\n-    case (stmt_expr(?e, ?a)) {\n-      check (! is_none[@ts_ann](a));\n-      auto stmt_ann = *(get[@ts_ann](a));\n+    case (stmt_expr(?e, _)) {\n       changed = find_pre_post_state_expr(fm, enclosing, pres, e) || changed;\n-      set_prestate(stmt_ann, expr_prestate(*e));\n-      set_poststate(stmt_ann, expr_poststate(*e));\n+      changed = extend_prestate(stmt_ann.states.prestate, expr_prestate(*e))\n+          || changed;\n+      changed = extend_poststate(stmt_ann.states.poststate,\n+                                 expr_poststate(*e)) || changed;\n+      /*\n+              log(\"Summary: stmt = \");\n+              log_stmt(*s);\n+              log(\"prestate = \");\n+              log(bitv.to_str(stmt_ann.states.prestate));\n+              log_bitv(enclosing, stmt_ann.states.prestate);\n+              log(\"poststate =\");\n+              log_bitv(enclosing, stmt_ann.states.poststate);\n+              log(\"changed =\");\n+              log(changed);\n+      */\n       ret changed;\n     }\n     case (_) { ret false; }\n@@ -1000,25 +1170,22 @@ fn find_pre_post_state_block(&_fn_info_map fm, &fn_info enclosing, block b)\n    consist of improving <pres> with whatever variables this stmt initializes.\n   Then <pres> becomes the new poststate. */ \n   for (@stmt s in b.node.stmts) {\n-    changed = changed || find_pre_post_state_stmt(fm, enclosing, pres, s);\n-      /* Shouldn't need to rebuild the stmt.\n-         This just updates bit-vectors\n-         in a side-effecting way. */\n-    extend_prestate(pres, stmt_poststate(*s, num_local_vars));\n+    changed = find_pre_post_state_stmt(fm, enclosing, pres, s) || changed;\n+    pres = stmt_poststate(*s, num_local_vars);\n   }\n \n   alt (b.node.expr) {\n     case (none[@expr]) {}\n     case (some[@expr](?e)) {\n-      changed = changed || find_pre_post_state_expr(fm, enclosing, pres, e);\n+      changed = find_pre_post_state_expr(fm, enclosing, pres, e) || changed;\n     }\n   }\n   ret changed;\n }\n \n fn find_pre_post_state_fn(&_fn_info_map f_info, &fn_info fi, &ast._fn f)\n   -> bool {\n-  be find_pre_post_state_block(f_info, fi, f.body);\n+  ret find_pre_post_state_block(f_info, fi, f.body);\n }\n \n fn fixed_point_states(_fn_info_map fm, fn_info f_info,\n@@ -1028,7 +1195,7 @@ fn fixed_point_states(_fn_info_map fm, fn_info f_info,\n   auto changed = f(fm, f_info, start);\n \n   if (changed) {\n-    be fixed_point_states(fm, f_info, f, start);\n+    ret fixed_point_states(fm, f_info, f, start);\n   }\n   else {\n     // we're done!\n@@ -1047,14 +1214,23 @@ impure fn check_states_expr(fn_info enclosing, &expr e) -> () {\n }\n \n fn check_states_stmt(fn_info enclosing, &stmt s) -> () {\n-  alt (stmt_ann(s)) {\n+  alt (stmt_to_ann(s)) {\n     case (none[@ts_ann]) {\n       ret;\n     }\n     case (some[@ts_ann](?a)) {\n       let precond prec    = ann_precond(*a);\n       let prestate pres   = ann_prestate(*a);\n \n+      /*\n+      log(\"check_states_stmt:\");\n+      log_stmt(s);\n+      log(\"prec = \");\n+      log_bitv(enclosing, prec);\n+      log(\"pres = \");\n+      log_bitv(enclosing, pres);\n+      */\n+\n       if (!implies(pres, prec)) {\n         log(\"check_states_stmt: unsatisfied precondition for \");\n         log_stmt(s);\n@@ -1103,16 +1279,47 @@ fn check_item_fn_state(&_fn_info_map f_info_map, &span sp, ident i,\n   ret @respan(sp, ast.item_fn(i, f, ty_params, id, a));\n }\n \n+fn init_ann(&fn_info fi, ann a) -> ann {\n+    alt (a) {\n+        case (ann_none) {\n+            log(\"init_ann: shouldn't see ann_none\");\n+            fail;\n+        }\n+        case (ann_type(?t,?ps,_)) {\n+            ret ann_type(t, ps, some[@ts_ann](@empty_ann(num_locals(fi))));\n+        }\n+    }\n+}\n+\n+fn item_fn_anns(&_fn_info_map fm, &span sp, ident i, &ast._fn f,\n+                vec[ast.ty_param] ty_params, def_id id, ann a) -> @item {\n+\n+    check(fm.contains_key(id));\n+    auto f_info = fm.get(id);\n+\n+    auto fld0 = fold.new_identity_fold[fn_info]();\n+\n+    fld0 = @rec(fold_ann = bind init_ann(_,_) with *fld0);\n+\n+    ret fold.fold_item[fn_info]\n+           (f_info, fld0, @respan(sp, item_fn(i, f, ty_params, id, a))); \n+}\n+\n fn check_crate(@ast.crate crate) -> @ast.crate {\n \n   /* Build the global map from function id to var-to-bit-num-map */\n   auto fn_info_map = mk_f_to_fn_info(crate);\n-\n+  \n+  /* Add a blank ts_ann to every statement (and expression) */\n+  auto fld0 = fold.new_identity_fold[_fn_info_map]();\n+  fld0 = @rec(fold_item_fn = bind item_fn_anns(_,_,_,_,_,_,_) with *fld0);\n+  auto with_anns = fold.fold_crate[_fn_info_map](fn_info_map, fld0, crate);\n+  \n   /* Compute the pre and postcondition for every subexpression */\n   auto fld = fold.new_identity_fold[_fn_info_map]();\n   fld = @rec(fold_item_fn = bind check_item_fn(_,_,_,_,_,_,_) with *fld);\n   auto with_pre_postconditions = fold.fold_crate[_fn_info_map]\n-    (fn_info_map, fld, crate);\n+    (fn_info_map, fld, with_anns);\n \n   auto fld1 = fold.new_identity_fold[_fn_info_map]();\n "}, {"sha": "58109126a3d1ca46ee71f31cebef76a17997b332", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d7e881841438cfe0797b71ff35ea96c8f2477a76/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e881841438cfe0797b71ff35ea96c8f2477a76/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=d7e881841438cfe0797b71ff35ea96c8f2477a76", "patch": "@@ -1,8 +1,17 @@\n import std._uint;\n import std._int;\n import std._vec;\n+import std.option.none;\n import front.ast;\n+import util.typestate_ann.ts_ann;\n \n+import std.io.stdout;\n+import std.io.str_writer;\n+import std.io.string_writer;\n+import pretty.pprust.print_block;\n+import pretty.pprust.print_expr;\n+import pretty.pprust.print_decl;\n+import pretty.pp.mkstate;\n \n type filename = str;\n type span = rec(uint lo, uint hi);\n@@ -94,6 +103,40 @@ fn elt_exprs(vec[ast.elt] elts) -> vec[@ast.expr] {\n     be _vec.map[ast.elt, @ast.expr](f, elts);\n }\n \n+fn field_expr(&ast.field f) -> @ast.expr { ret f.expr; }\n+\n+fn field_exprs(vec[ast.field] fields) -> vec [@ast.expr] {\n+    auto f = field_expr;\n+    ret _vec.map[ast.field, @ast.expr](f, fields);\n+}\n+\n+fn plain_ann() -> ast.ann {\n+  ret ast.ann_type(middle.ty.plain_ty(middle.ty.ty_nil),\n+                   none[vec[@middle.ty.t]], none[@ts_ann]);\n+}\n+\n+fn log_expr(@ast.expr e) -> () {\n+  let str_writer s = string_writer();\n+  auto out_ = mkstate(s.get_writer(), 80u);\n+  auto out = @rec(s=out_,\n+                  comments=none[vec[front.lexer.cmnt]],\n+                  mutable cur_cmnt=0u);\n+\n+  print_expr(out, e);\n+  log(s.get_str());\n+}\n+\n+fn log_block(&ast.block b) -> () {\n+  let str_writer s = string_writer();\n+  auto out_ = mkstate(s.get_writer(), 80u);\n+  auto out = @rec(s=out_,\n+                  comments=none[vec[front.lexer.cmnt]],\n+                  mutable cur_cmnt=0u);\n+\n+  print_block(out, b);\n+  log(s.get_str());\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "0218df1c570c63b085eafad650670cf9e4dca1c2", "filename": "src/comp/util/typestate_ann.rs", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d7e881841438cfe0797b71ff35ea96c8f2477a76/src%2Fcomp%2Futil%2Ftypestate_ann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e881841438cfe0797b71ff35ea96c8f2477a76/src%2Fcomp%2Futil%2Ftypestate_ann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Ftypestate_ann.rs?ref=d7e881841438cfe0797b71ff35ea96c8f2477a76", "patch": "@@ -72,7 +72,7 @@ fn difference(&precond p1, &precond p2) -> bool {\n }\n \n fn union(&precond p1, &precond p2) -> bool {\n-  be bitv.difference(p1, p2);\n+  be bitv.union(p1, p2);\n }\n \n fn pps_len(&pre_and_post p) -> uint {\n@@ -87,38 +87,52 @@ impure fn require_and_preserve(uint i, &pre_and_post p) -> () {\n   bitv.set(p.postcondition, i, true);\n }\n \n-impure fn set_in_postcond(uint i, &pre_and_post p) -> () {\n+impure fn set_in_postcond(uint i, &pre_and_post p) -> bool {\n   // sets the ith bit in p's post\n+  auto was_set = bitv.get(p.postcondition, i);\n   bitv.set(p.postcondition, i, true);\n+  ret !was_set;\n+}\n+\n+impure fn set_in_poststate(uint i, &pre_and_post_state s) -> bool {\n+  // sets the ith bit in p's post\n+  auto was_set = bitv.get(s.poststate, i);\n+  bitv.set(s.poststate, i, true);\n+  ret !was_set;\n }\n \n // Sets all the bits in a's precondition to equal the\n // corresponding bit in p's precondition.\n impure fn set_precondition(&ts_ann a, &precond p) -> () {\n-  bitv.copy(p, a.conditions.precondition);\n+  bitv.copy(a.conditions.precondition, p);\n }\n \n // Sets all the bits in a's postcondition to equal the\n // corresponding bit in p's postcondition.\n impure fn set_postcondition(&ts_ann a, &postcond p) -> () {\n-  bitv.copy(p, a.conditions.postcondition);\n+  bitv.copy(a.conditions.postcondition, p);\n }\n \n // Sets all the bits in a's prestate to equal the\n // corresponding bit in p's prestate.\n-impure fn set_prestate(&ts_ann a, &prestate p) -> () {\n-  bitv.copy(p, a.states.prestate);\n+impure fn set_prestate(&ts_ann a, &prestate p) -> bool {\n+  ret bitv.copy(a.states.prestate, p);\n }\n \n // Sets all the bits in a's postcondition to equal the\n // corresponding bit in p's postcondition.\n-impure fn set_poststate(&ts_ann a, &poststate p) -> () {\n-  bitv.copy(p, a.states.poststate);\n+impure fn set_poststate(&ts_ann a, &poststate p) -> bool {\n+  ret bitv.copy(a.states.poststate, p);\n+}\n+\n+// Set all the bits in p that are set in new\n+impure fn extend_prestate(&prestate p, &poststate new) -> bool {\n+  ret bitv.union(p, new);\n }\n \n // Set all the bits in p that are set in new\n-impure fn extend_prestate(&prestate p, &poststate new) -> () {\n-  bitv.union(p, new);\n+impure fn extend_poststate(&poststate p, &poststate new) -> bool {\n+  ret bitv.union(p, new);\n }\n \n fn ann_precond(&ts_ann a) -> precond {\n@@ -129,7 +143,11 @@ fn ann_prestate(&ts_ann a) -> prestate {\n   ret a.states.prestate;\n }\n \n+// returns true if a implies b\n+// that is, returns true except if for some bits c and d,\n+// c = 1 and d = 0\n impure fn implies(bitv.t a, bitv.t b) -> bool {\n-  bitv.difference(b, a);\n-  ret bitv.is_false(b);\n+  auto tmp = bitv.clone(b);\n+  bitv.difference(tmp, a);\n+  ret bitv.is_false(tmp);\n }"}, {"sha": "fab40ac8332f67f92be5150f7a14b0309f2f99a9", "filename": "src/lib/bitv.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d7e881841438cfe0797b71ff35ea96c8f2477a76/src%2Flib%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e881841438cfe0797b71ff35ea96c8f2477a76/src%2Flib%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fbitv.rs?ref=d7e881841438cfe0797b71ff35ea96c8f2477a76", "patch": "@@ -74,6 +74,15 @@ impure fn copy(&t v0, t v1) -> bool {\n     ret process(sub, v0, v1);\n }\n \n+fn clone(t v) -> t {\n+    auto storage = _vec.init_elt_mut[uint](0u, v.nbits / uint_bits() + 1u);\n+    auto len = _vec.len[mutable uint](v.storage);\n+    for each (uint i in _uint.range(0u, len)) {\n+        storage.(i) = v.storage.(i);\n+    }\n+    ret rec(storage = storage, nbits = v.nbits);\n+}\n+\n fn get(&t v, uint i) -> bool {\n     check (i < v.nbits);\n \n@@ -137,7 +146,7 @@ impure fn set(&t v, uint i, bool x) {\n \n /* true if all bits are 1 */\n fn is_true(&t v) -> bool {\n-    for(uint i in v.storage) {\n+    for (uint i in to_vec(v)) {\n         if (i != 1u) {\n             ret false;\n         }\n@@ -148,7 +157,7 @@ fn is_true(&t v) -> bool {\n \n /* true if all bits are non-1 */\n fn is_false(&t v) -> bool {\n-    for(uint i in v.storage) {\n+    for (uint i in to_vec(v)) {\n         if (i == 1u) {\n             ret false;\n         }\n@@ -173,7 +182,7 @@ fn to_vec(&t v) -> vec[uint] {\n fn to_str(&t v) -> str {\n     auto res = \"\";\n \n-    for(uint i in v.storage) {\n+    for (uint i in bitv.to_vec(v)) {\n         if (i == 1u) {\n             res += \"1\";\n         }"}]}