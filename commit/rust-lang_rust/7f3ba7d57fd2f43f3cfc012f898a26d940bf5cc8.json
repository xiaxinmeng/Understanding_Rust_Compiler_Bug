{"sha": "7f3ba7d57fd2f43f3cfc012f898a26d940bf5cc8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmM2JhN2Q1N2ZkMmY0M2YzY2ZjMDEyZjg5OGEyNmQ5NDBiZjVjYzg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-11-28T15:10:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-28T15:10:00Z"}, "message": "Merge #6645\n\n6645: Publish diagnostics for macro expansion errors r=matklad a=jonas-schievink\n\nThis adds 2 new diagnostics, emitted during name resolution:\r\n\r\n* `unresolved-proc-macro`, a weak warning that is emitted when a proc macro is supposed to be expanded, but was not provided by the build system. This usually means that proc macro support is turned off, but may also indicate setup issues when using rust-project.json. Being a weak warning, this should help set expectations when users see it, while not being too obstructive. We do not yet emit this for attribute macros though, just custom derives and `!` macros.\r\n* `macro-error`, which is emitted when any macro (procedural or `macro_rules!`) fails to expand due to some error. This is an error-level diagnostic, but currently still marked as experimental, because there might be spurious errors and this hasn't been tested too well.\r\n\r\nThis does not yet emit diagnostics when expansion in item bodies fails, just for module-level macros.\r\n\r\nKnown bug: The \"proc macro not found\" diagnostic points at the whole item for custom derives, it should just point at the macro's name in the `#[derive]` list, but I haven't found an easy way to do that.\r\n\r\nScreenshots:\r\n\r\n![screenshot-2020-11-26-19:54:14](https://user-images.githubusercontent.com/1786438/100385782-f8bc2300-3023-11eb-9f27-e8f8ce9d6114.png)\r\n![screenshot-2020-11-26-19:55:39](https://user-images.githubusercontent.com/1786438/100385784-f954b980-3023-11eb-9617-ac2eb0a0a9dc.png)\r\n\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "8262e9c458f5b1a120422c89962f7cf37a97cb69", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8262e9c458f5b1a120422c89962f7cf37a97cb69"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f3ba7d57fd2f43f3cfc012f898a26d940bf5cc8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfwmhICRBK7hj4Ov3rIwAAdHIIAGg5MrNqTc//1RYKMNk2ylAn\nerUeIW30RqmSfMiYnb50l7yVdx6L0RpLaAjDiTn0ZRTiOuMElgXUfFVb8PvIHA3S\ngut5jr19EKxKFIgI8QyO2imlairgBm7JVSm0fZssUAqFfs9oJQRlil6pK2s4wKE/\nvl98Yr4ByNTtF5kq5otSst0SEEsaPjcAd+cwYuug25XzwAIYxUEgJUS9s+iSlKl5\nbC61m3T+8cSdMKn8+2uGmWq8ID7CN5tmN9AaNHTgPypOTzo4PpLOdT5doRc/C/hx\n8iAIJFNX9deh1OnfIlLKGoRAN7D79SeMEnomRDcZyjpYOPu4tBoTdwiAezDnNxY=\n=G0+Q\n-----END PGP SIGNATURE-----\n", "payload": "tree 8262e9c458f5b1a120422c89962f7cf37a97cb69\nparent b7ece77af49ce59762fc3246a4c721411efe637e\nparent d171838d63907d004ab935d6564bfeb4238d5540\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1606576200 +0000\ncommitter GitHub <noreply@github.com> 1606576200 +0000\n\nMerge #6645\n\n6645: Publish diagnostics for macro expansion errors r=matklad a=jonas-schievink\n\nThis adds 2 new diagnostics, emitted during name resolution:\r\n\r\n* `unresolved-proc-macro`, a weak warning that is emitted when a proc macro is supposed to be expanded, but was not provided by the build system. This usually means that proc macro support is turned off, but may also indicate setup issues when using rust-project.json. Being a weak warning, this should help set expectations when users see it, while not being too obstructive. We do not yet emit this for attribute macros though, just custom derives and `!` macros.\r\n* `macro-error`, which is emitted when any macro (procedural or `macro_rules!`) fails to expand due to some error. This is an error-level diagnostic, but currently still marked as experimental, because there might be spurious errors and this hasn't been tested too well.\r\n\r\nThis does not yet emit diagnostics when expansion in item bodies fails, just for module-level macros.\r\n\r\nKnown bug: The \"proc macro not found\" diagnostic points at the whole item for custom derives, it should just point at the macro's name in the `#[derive]` list, but I haven't found an easy way to do that.\r\n\r\nScreenshots:\r\n\r\n![screenshot-2020-11-26-19:54:14](https://user-images.githubusercontent.com/1786438/100385782-f8bc2300-3023-11eb-9f27-e8f8ce9d6114.png)\r\n![screenshot-2020-11-26-19:55:39](https://user-images.githubusercontent.com/1786438/100385784-f954b980-3023-11eb-9617-ac2eb0a0a9dc.png)\r\n\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f3ba7d57fd2f43f3cfc012f898a26d940bf5cc8", "html_url": "https://github.com/rust-lang/rust/commit/7f3ba7d57fd2f43f3cfc012f898a26d940bf5cc8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f3ba7d57fd2f43f3cfc012f898a26d940bf5cc8/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7ece77af49ce59762fc3246a4c721411efe637e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7ece77af49ce59762fc3246a4c721411efe637e", "html_url": "https://github.com/rust-lang/rust/commit/b7ece77af49ce59762fc3246a4c721411efe637e"}, {"sha": "d171838d63907d004ab935d6564bfeb4238d5540", "url": "https://api.github.com/repos/rust-lang/rust/commits/d171838d63907d004ab935d6564bfeb4238d5540", "html_url": "https://github.com/rust-lang/rust/commit/d171838d63907d004ab935d6564bfeb4238d5540"}], "stats": {"total": 221, "additions": 212, "deletions": 9}, "files": [{"sha": "eaf1a14ec348020f712a09082153d1cee8833c12", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f3ba7d57fd2f43f3cfc012f898a26d940bf5cc8/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3ba7d57fd2f43f3cfc012f898a26d940bf5cc8/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=7f3ba7d57fd2f43f3cfc012f898a26d940bf5cc8", "patch": "@@ -1,5 +1,5 @@\n //! FIXME: write short doc here\n-pub use hir_def::diagnostics::{InactiveCode, UnresolvedModule};\n+pub use hir_def::diagnostics::{InactiveCode, UnresolvedModule, UnresolvedProcMacro};\n pub use hir_expand::diagnostics::{\n     Diagnostic, DiagnosticCode, DiagnosticSink, DiagnosticSinkBuilder,\n };"}, {"sha": "c71266dc09137e2ecb2117cc7e10604b5e20c200", "filename": "crates/hir_def/src/diagnostics.rs", "status": "modified", "additions": 66, "deletions": 1, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/7f3ba7d57fd2f43f3cfc012f898a26d940bf5cc8/crates%2Fhir_def%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3ba7d57fd2f43f3cfc012f898a26d940bf5cc8/crates%2Fhir_def%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdiagnostics.rs?ref=7f3ba7d57fd2f43f3cfc012f898a26d940bf5cc8", "patch": "@@ -6,7 +6,7 @@ use stdx::format_to;\n use cfg::{CfgExpr, CfgOptions, DnfExpr};\n use hir_expand::diagnostics::{Diagnostic, DiagnosticCode, DiagnosticSink};\n use hir_expand::{HirFileId, InFile};\n-use syntax::{ast, AstPtr, SyntaxNodePtr};\n+use syntax::{ast, AstPtr, SyntaxNodePtr, TextRange};\n \n use crate::{db::DefDatabase, DefWithBodyId};\n \n@@ -127,3 +127,68 @@ impl Diagnostic for InactiveCode {\n         self\n     }\n }\n+\n+// Diagnostic: unresolved-proc-macro\n+//\n+// This diagnostic is shown when a procedural macro can not be found. This usually means that\n+// procedural macro support is simply disabled (and hence is only a weak hint instead of an error),\n+// but can also indicate project setup problems.\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct UnresolvedProcMacro {\n+    pub file: HirFileId,\n+    pub node: SyntaxNodePtr,\n+    /// If the diagnostic can be pinpointed more accurately than via `node`, this is the `TextRange`\n+    /// to use instead.\n+    pub precise_location: Option<TextRange>,\n+    pub macro_name: Option<String>,\n+}\n+\n+impl Diagnostic for UnresolvedProcMacro {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"unresolved-proc-macro\")\n+    }\n+\n+    fn message(&self) -> String {\n+        match &self.macro_name {\n+            Some(name) => format!(\"proc macro `{}` not expanded\", name),\n+            None => \"proc macro not expanded\".to_string(),\n+        }\n+    }\n+\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile::new(self.file, self.node.clone())\n+    }\n+\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+}\n+\n+// Diagnostic: macro-error\n+//\n+// This diagnostic is shown for macro expansion errors.\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct MacroError {\n+    pub file: HirFileId,\n+    pub node: SyntaxNodePtr,\n+    pub message: String,\n+}\n+\n+impl Diagnostic for MacroError {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"macro-error\")\n+    }\n+    fn message(&self) -> String {\n+        self.message.clone()\n+    }\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile::new(self.file, self.node.clone())\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+    fn is_experimental(&self) -> bool {\n+        // Newly added and not very well-tested, might contain false positives.\n+        true\n+    }\n+}"}, {"sha": "ffd0381d43ec84aac20c43fcee8bf5b36de13a23", "filename": "crates/hir_def/src/nameres.rs", "status": "modified", "additions": 85, "deletions": 2, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/7f3ba7d57fd2f43f3cfc012f898a26d940bf5cc8/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3ba7d57fd2f43f3cfc012f898a26d940bf5cc8/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres.rs?ref=7f3ba7d57fd2f43f3cfc012f898a26d940bf5cc8", "patch": "@@ -286,8 +286,9 @@ mod diagnostics {\n     use cfg::{CfgExpr, CfgOptions};\n     use hir_expand::diagnostics::DiagnosticSink;\n     use hir_expand::hygiene::Hygiene;\n-    use hir_expand::InFile;\n-    use syntax::{ast, AstPtr};\n+    use hir_expand::{InFile, MacroCallKind};\n+    use syntax::ast::AttrsOwner;\n+    use syntax::{ast, AstNode, AstPtr, SyntaxKind, SyntaxNodePtr};\n \n     use crate::path::ModPath;\n     use crate::{db::DefDatabase, diagnostics::*, nameres::LocalModuleId, AstId};\n@@ -301,6 +302,10 @@ mod diagnostics {\n         UnresolvedImport { ast: AstId<ast::Use>, index: usize },\n \n         UnconfiguredCode { ast: AstId<ast::Item>, cfg: CfgExpr, opts: CfgOptions },\n+\n+        UnresolvedProcMacro { ast: MacroCallKind },\n+\n+        MacroError { ast: MacroCallKind, message: String },\n     }\n \n     #[derive(Debug, PartialEq, Eq)]\n@@ -348,6 +353,18 @@ mod diagnostics {\n             Self { in_module: container, kind: DiagnosticKind::UnconfiguredCode { ast, cfg, opts } }\n         }\n \n+        pub(super) fn unresolved_proc_macro(container: LocalModuleId, ast: MacroCallKind) -> Self {\n+            Self { in_module: container, kind: DiagnosticKind::UnresolvedProcMacro { ast } }\n+        }\n+\n+        pub(super) fn macro_error(\n+            container: LocalModuleId,\n+            ast: MacroCallKind,\n+            message: String,\n+        ) -> Self {\n+            Self { in_module: container, kind: DiagnosticKind::MacroError { ast, message } }\n+        }\n+\n         pub(super) fn add_to(\n             &self,\n             db: &dyn DefDatabase,\n@@ -407,6 +424,72 @@ mod diagnostics {\n                         opts: opts.clone(),\n                     });\n                 }\n+\n+                DiagnosticKind::UnresolvedProcMacro { ast } => {\n+                    let mut precise_location = None;\n+                    let (file, ast, name) = match ast {\n+                        MacroCallKind::FnLike(ast) => {\n+                            let node = ast.to_node(db.upcast());\n+                            (ast.file_id, SyntaxNodePtr::from(AstPtr::new(&node)), None)\n+                        }\n+                        MacroCallKind::Attr(ast, name) => {\n+                            let node = ast.to_node(db.upcast());\n+\n+                            // Compute the precise location of the macro name's token in the derive\n+                            // list.\n+                            // FIXME: This does not handle paths to the macro, but neither does the\n+                            // rest of r-a.\n+                            let derive_attrs =\n+                                node.attrs().filter_map(|attr| match attr.as_simple_call() {\n+                                    Some((name, args)) if name == \"derive\" => Some(args),\n+                                    _ => None,\n+                                });\n+                            'outer: for attr in derive_attrs {\n+                                let tokens =\n+                                    attr.syntax().children_with_tokens().filter_map(|elem| {\n+                                        match elem {\n+                                            syntax::NodeOrToken::Node(_) => None,\n+                                            syntax::NodeOrToken::Token(tok) => Some(tok),\n+                                        }\n+                                    });\n+                                for token in tokens {\n+                                    if token.kind() == SyntaxKind::IDENT\n+                                        && token.to_string() == *name\n+                                    {\n+                                        precise_location = Some(token.text_range());\n+                                        break 'outer;\n+                                    }\n+                                }\n+                            }\n+\n+                            (\n+                                ast.file_id,\n+                                SyntaxNodePtr::from(AstPtr::new(&node)),\n+                                Some(name.clone()),\n+                            )\n+                        }\n+                    };\n+                    sink.push(UnresolvedProcMacro {\n+                        file,\n+                        node: ast,\n+                        precise_location,\n+                        macro_name: name,\n+                    });\n+                }\n+\n+                DiagnosticKind::MacroError { ast, message } => {\n+                    let (file, ast) = match ast {\n+                        MacroCallKind::FnLike(ast) => {\n+                            let node = ast.to_node(db.upcast());\n+                            (ast.file_id, SyntaxNodePtr::from(AstPtr::new(&node)))\n+                        }\n+                        MacroCallKind::Attr(ast, _) => {\n+                            let node = ast.to_node(db.upcast());\n+                            (ast.file_id, SyntaxNodePtr::from(AstPtr::new(&node)))\n+                        }\n+                    };\n+                    sink.push(MacroError { file, node: ast, message: message.clone() });\n+                }\n             }\n         }\n     }"}, {"sha": "19cd713ba0497a72194e6f2e74d3a6e152ee0591", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7f3ba7d57fd2f43f3cfc012f898a26d940bf5cc8/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3ba7d57fd2f43f3cfc012f898a26d940bf5cc8/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=7f3ba7d57fd2f43f3cfc012f898a26d940bf5cc8", "patch": "@@ -7,7 +7,6 @@ use std::iter;\n \n use base_db::{CrateId, FileId, ProcMacroId};\n use cfg::{CfgExpr, CfgOptions};\n-use hir_expand::InFile;\n use hir_expand::{\n     ast_id_map::FileAstId,\n     builtin_derive::find_builtin_derive,\n@@ -16,6 +15,7 @@ use hir_expand::{\n     proc_macro::ProcMacroExpander,\n     HirFileId, MacroCallId, MacroDefId, MacroDefKind,\n };\n+use hir_expand::{InFile, MacroCallLoc};\n use rustc_hash::{FxHashMap, FxHashSet};\n use syntax::ast;\n use test_utils::mark;\n@@ -812,7 +812,30 @@ impl DefCollector<'_> {\n             log::warn!(\"macro expansion is too deep\");\n             return;\n         }\n-        let file_id: HirFileId = macro_call_id.as_file();\n+        let file_id = macro_call_id.as_file();\n+\n+        // First, fetch the raw expansion result for purposes of error reporting. This goes through\n+        // `macro_expand_error` to avoid depending on the full expansion result (to improve\n+        // incrementality).\n+        let err = self.db.macro_expand_error(macro_call_id);\n+        if let Some(err) = err {\n+            if let MacroCallId::LazyMacro(id) = macro_call_id {\n+                let loc: MacroCallLoc = self.db.lookup_intern_macro(id);\n+\n+                let diag = match err {\n+                    hir_expand::ExpandError::UnresolvedProcMacro => {\n+                        // Missing proc macros are non-fatal, so they are handled specially.\n+                        DefDiagnostic::unresolved_proc_macro(module_id, loc.kind)\n+                    }\n+                    _ => DefDiagnostic::macro_error(module_id, loc.kind, err.to_string()),\n+                };\n+\n+                self.def_map.diagnostics.push(diag);\n+            }\n+            // FIXME: Handle eager macros.\n+        }\n+\n+        // Then, fetch and process the item tree. This will reuse the expansion result from above.\n         let item_tree = self.db.item_tree(file_id);\n         let mod_dir = self.mod_dirs[&module_id].clone();\n         ModCollector {"}, {"sha": "ff50bfd82fa08f70fcee1e56d923e6fa6f65e06d", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7f3ba7d57fd2f43f3cfc012f898a26d940bf5cc8/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3ba7d57fd2f43f3cfc012f898a26d940bf5cc8/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=7f3ba7d57fd2f43f3cfc012f898a26d940bf5cc8", "patch": "@@ -3,7 +3,7 @@\n use std::sync::Arc;\n \n use base_db::{salsa, SourceDatabase};\n-use mbe::{ExpandResult, MacroRules};\n+use mbe::{ExpandError, ExpandResult, MacroRules};\n use parser::FragmentKind;\n use syntax::{algo::diff, AstNode, GreenNode, Parse, SyntaxKind::*, SyntaxNode};\n \n@@ -81,6 +81,9 @@ pub trait AstDatabase: SourceDatabase {\n     ) -> ExpandResult<Option<(Parse<SyntaxNode>, Arc<mbe::TokenMap>)>>;\n     fn macro_expand(&self, macro_call: MacroCallId) -> ExpandResult<Option<Arc<tt::Subtree>>>;\n \n+    /// Firewall query that returns the error from the `macro_expand` query.\n+    fn macro_expand_error(&self, macro_call: MacroCallId) -> Option<ExpandError>;\n+\n     #[salsa::interned]\n     fn intern_eager_expansion(&self, eager: EagerCallLoc) -> EagerMacroId;\n \n@@ -171,6 +174,10 @@ fn macro_expand(db: &dyn AstDatabase, id: MacroCallId) -> ExpandResult<Option<Ar\n     macro_expand_with_arg(db, id, None)\n }\n \n+fn macro_expand_error(db: &dyn AstDatabase, macro_call: MacroCallId) -> Option<ExpandError> {\n+    db.macro_expand(macro_call).err\n+}\n+\n fn expander(db: &dyn AstDatabase, id: MacroCallId) -> Option<Arc<(TokenExpander, mbe::TokenMap)>> {\n     let lazy_id = match id {\n         MacroCallId::LazyMacro(id) => id,"}, {"sha": "6dad2507bf3b2ab82bfc2d056c413755871666e9", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f3ba7d57fd2f43f3cfc012f898a26d940bf5cc8/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3ba7d57fd2f43f3cfc012f898a26d940bf5cc8/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=7f3ba7d57fd2f43f3cfc012f898a26d940bf5cc8", "patch": "@@ -255,7 +255,7 @@ pub enum MacroDefKind {\n pub struct MacroCallLoc {\n     pub(crate) def: MacroDefId,\n     pub(crate) krate: CrateId,\n-    pub(crate) kind: MacroCallKind,\n+    pub kind: MacroCallKind,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]"}, {"sha": "97edf0fb6d182943d9fd0c7cb9566b0338a725ca", "filename": "crates/hir_expand/src/proc_macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f3ba7d57fd2f43f3cfc012f898a26d940bf5cc8/crates%2Fhir_expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3ba7d57fd2f43f3cfc012f898a26d940bf5cc8/crates%2Fhir_expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fproc_macro.rs?ref=7f3ba7d57fd2f43f3cfc012f898a26d940bf5cc8", "patch": "@@ -50,7 +50,7 @@ impl ProcMacroExpander {\n \n                 proc_macro.expander.expand(&tt, None).map_err(mbe::ExpandError::from)\n             }\n-            None => Err(err!(\"Unresolved proc macro\")),\n+            None => Err(mbe::ExpandError::UnresolvedProcMacro),\n         }\n     }\n }"}, {"sha": "9d3d8828956f5be8ffc91cf97a38a9880abc4734", "filename": "crates/ide/src/diagnostics.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7f3ba7d57fd2f43f3cfc012f898a26d940bf5cc8/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3ba7d57fd2f43f3cfc012f898a26d940bf5cc8/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics.rs?ref=7f3ba7d57fd2f43f3cfc012f898a26d940bf5cc8", "patch": "@@ -142,6 +142,15 @@ pub(crate) fn diagnostics(\n                     .with_code(Some(d.code())),\n             );\n         })\n+        .on::<hir::diagnostics::UnresolvedProcMacro, _>(|d| {\n+            // Use more accurate position if available.\n+            let display_range =\n+                d.precise_location.unwrap_or_else(|| sema.diagnostics_display_range(d).range);\n+\n+            // FIXME: it would be nice to tell the user whether proc macros are currently disabled\n+            res.borrow_mut()\n+                .push(Diagnostic::hint(display_range, d.message()).with_code(Some(d.code())));\n+        })\n         // Only collect experimental diagnostics when they're enabled.\n         .filter(|diag| !(diag.is_experimental() && config.disable_experimental))\n         .filter(|diag| !config.disabled.contains(diag.code().as_str()));"}, {"sha": "3ad609a005d604c1289ec9384ef10a899ab50887", "filename": "crates/mbe/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f3ba7d57fd2f43f3cfc012f898a26d940bf5cc8/crates%2Fmbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3ba7d57fd2f43f3cfc012f898a26d940bf5cc8/crates%2Fmbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Flib.rs?ref=7f3ba7d57fd2f43f3cfc012f898a26d940bf5cc8", "patch": "@@ -35,6 +35,7 @@ pub enum ExpandError {\n     ConversionError,\n     InvalidRepeat,\n     ProcMacroError(tt::ExpansionError),\n+    UnresolvedProcMacro,\n     Other(String),\n }\n \n@@ -53,6 +54,7 @@ impl fmt::Display for ExpandError {\n             ExpandError::ConversionError => f.write_str(\"could not convert tokens\"),\n             ExpandError::InvalidRepeat => f.write_str(\"invalid repeat expression\"),\n             ExpandError::ProcMacroError(e) => e.fmt(f),\n+            ExpandError::UnresolvedProcMacro => f.write_str(\"unresolved proc macro\"),\n             ExpandError::Other(e) => f.write_str(e),\n         }\n     }"}, {"sha": "ec8581a03cb39d370da3266091b29d155f6944da", "filename": "docs/user/generated_diagnostic.adoc", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7f3ba7d57fd2f43f3cfc012f898a26d940bf5cc8/docs%2Fuser%2Fgenerated_diagnostic.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/7f3ba7d57fd2f43f3cfc012f898a26d940bf5cc8/docs%2Fuser%2Fgenerated_diagnostic.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fgenerated_diagnostic.adoc?ref=7f3ba7d57fd2f43f3cfc012f898a26d940bf5cc8", "patch": "@@ -17,6 +17,12 @@ This diagnostic is shown for code with inactive `#[cfg]` attributes.\n This diagnostic is triggered if item name doesn't follow https://doc.rust-lang.org/1.0.0/style/style/naming/README.html[Rust naming convention].\n \n \n+=== macro-error\n+**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/hir_def/src/diagnostics.rs#L167[diagnostics.rs]\n+\n+This diagnostic is shown for macro expansion errors.\n+\n+\n === mismatched-arg-count\n **Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/hir_ty/src/diagnostics.rs#L267[diagnostics.rs]\n \n@@ -103,3 +109,11 @@ This diagnostic is triggered if rust-analyzer is unable to discover imported mod\n **Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/hir_def/src/diagnostics.rs#L18[diagnostics.rs]\n \n This diagnostic is triggered if rust-analyzer is unable to discover referred module.\n+\n+\n+=== unresolved-proc-macro\n+**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/hir_def/src/diagnostics.rs#L131[diagnostics.rs]\n+\n+This diagnostic is shown when a procedural macro can not be found. This usually means that\n+procedural macro support is simply disabled (and hence is only a weak hint instead of an error),\n+but can also indicate project setup problems."}]}