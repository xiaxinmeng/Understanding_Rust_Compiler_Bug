{"sha": "825e6b328790a94f29959517b40f8758896ed3f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyNWU2YjMyODc5MGE5NGYyOTk1OTUxN2I0MGY4NzU4ODk2ZWQzZjY=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-10-04T09:54:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-04T09:54:02Z"}, "message": "Rollup merge of #36903 - frewsxcv:typekind, r=jseyfried\n\nMinor librustdoc cleanup and refactoring.", "tree": {"sha": "cc6bbe66a27f732fb3637a39f65f8666cd86ee6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc6bbe66a27f732fb3637a39f65f8666cd86ee6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/825e6b328790a94f29959517b40f8758896ed3f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/825e6b328790a94f29959517b40f8758896ed3f6", "html_url": "https://github.com/rust-lang/rust/commit/825e6b328790a94f29959517b40f8758896ed3f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/825e6b328790a94f29959517b40f8758896ed3f6/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d25aeb0ef1c4472e853eb9f3bc0acef7bf9a6536", "url": "https://api.github.com/repos/rust-lang/rust/commits/d25aeb0ef1c4472e853eb9f3bc0acef7bf9a6536", "html_url": "https://github.com/rust-lang/rust/commit/d25aeb0ef1c4472e853eb9f3bc0acef7bf9a6536"}, {"sha": "35d214afe6af62d1532135875e73b3218b85fbf0", "url": "https://api.github.com/repos/rust-lang/rust/commits/35d214afe6af62d1532135875e73b3218b85fbf0", "html_url": "https://github.com/rust-lang/rust/commit/35d214afe6af62d1532135875e73b3218b85fbf0"}], "stats": {"total": 215, "additions": 107, "deletions": 108}, "files": [{"sha": "208a5d810922aa62a725b7f37446e37a20d108e1", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/825e6b328790a94f29959517b40f8758896ed3f6/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825e6b328790a94f29959517b40f8758896ed3f6/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=825e6b328790a94f29959517b40f8758896ed3f6", "patch": "@@ -73,49 +73,49 @@ fn try_inline_def<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let did = def.def_id();\n     let inner = match def {\n         Def::Trait(did) => {\n-            record_extern_fqn(cx, did, clean::TypeTrait);\n+            record_extern_fqn(cx, did, clean::TypeKind::Trait);\n             ret.extend(build_impls(cx, tcx, did));\n             clean::TraitItem(build_external_trait(cx, tcx, did))\n         }\n         Def::Fn(did) => {\n-            record_extern_fqn(cx, did, clean::TypeFunction);\n+            record_extern_fqn(cx, did, clean::TypeKind::Function);\n             clean::FunctionItem(build_external_function(cx, tcx, did))\n         }\n         Def::Struct(did)\n                 // If this is a struct constructor, we skip it\n                 if tcx.def_key(did).disambiguated_data.data != DefPathData::StructCtor => {\n-            record_extern_fqn(cx, did, clean::TypeStruct);\n+            record_extern_fqn(cx, did, clean::TypeKind::Struct);\n             ret.extend(build_impls(cx, tcx, did));\n             clean::StructItem(build_struct(cx, tcx, did))\n         }\n         Def::Union(did) => {\n-            record_extern_fqn(cx, did, clean::TypeUnion);\n+            record_extern_fqn(cx, did, clean::TypeKind::Union);\n             ret.extend(build_impls(cx, tcx, did));\n             clean::UnionItem(build_union(cx, tcx, did))\n         }\n         Def::TyAlias(did) => {\n-            record_extern_fqn(cx, did, clean::TypeTypedef);\n+            record_extern_fqn(cx, did, clean::TypeKind::Typedef);\n             ret.extend(build_impls(cx, tcx, did));\n             clean::TypedefItem(build_type_alias(cx, tcx, did), false)\n         }\n         Def::Enum(did) => {\n-            record_extern_fqn(cx, did, clean::TypeEnum);\n+            record_extern_fqn(cx, did, clean::TypeKind::Enum);\n             ret.extend(build_impls(cx, tcx, did));\n             clean::EnumItem(build_enum(cx, tcx, did))\n         }\n         // Assume that the enum type is reexported next to the variant, and\n         // variants don't show up in documentation specially.\n         Def::Variant(..) => return Some(Vec::new()),\n         Def::Mod(did) => {\n-            record_extern_fqn(cx, did, clean::TypeModule);\n+            record_extern_fqn(cx, did, clean::TypeKind::Module);\n             clean::ModuleItem(build_module(cx, tcx, did))\n         }\n         Def::Static(did, mtbl) => {\n-            record_extern_fqn(cx, did, clean::TypeStatic);\n+            record_extern_fqn(cx, did, clean::TypeKind::Static);\n             clean::StaticItem(build_static(cx, tcx, did, mtbl))\n         }\n         Def::Const(did) | Def::AssociatedConst(did) => {\n-            record_extern_fqn(cx, did, clean::TypeConst);\n+            record_extern_fqn(cx, did, clean::TypeKind::Const);\n             clean::ConstantItem(build_const(cx, tcx, did))\n         }\n         _ => return None,\n@@ -577,7 +577,7 @@ fn filter_non_trait_generics(trait_did: DefId, mut g: clean::Generics)\n             _ => true,\n         }\n     });\n-    return g;\n+    g\n }\n \n /// Supertrait bounds for a trait are also listed in the generics coming from"}, {"sha": "cf20572510b5c81eb49cda40bc89cf369976d6da", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 56, "deletions": 58, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/825e6b328790a94f29959517b40f8758896ed3f6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825e6b328790a94f29959517b40f8758896ed3f6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=825e6b328790a94f29959517b40f8758896ed3f6", "patch": "@@ -12,10 +12,7 @@\n //! that clean them.\n \n pub use self::Type::*;\n-pub use self::TypeKind::*;\n-pub use self::VariantKind::*;\n pub use self::Mutability::*;\n-pub use self::Import::*;\n pub use self::ItemEnum::*;\n pub use self::Attribute::*;\n pub use self::TyParamBound::*;\n@@ -319,7 +316,7 @@ impl Item {\n         match self.inner {\n             StructItem(ref _struct) => Some(_struct.fields_stripped),\n             UnionItem(ref union) => Some(union.fields_stripped),\n-            VariantItem(Variant { kind: StructVariant(ref vstruct)} ) => {\n+            VariantItem(Variant { kind: VariantKind::Struct(ref vstruct)} ) => {\n                 Some(vstruct.fields_stripped)\n             },\n             _ => None,\n@@ -688,7 +685,7 @@ impl Clean<TyParamBound> for ty::BuiltinBound {\n                 (tcx.lang_items.sync_trait().unwrap(),\n                  external_path(cx, \"Sync\", None, false, vec![], empty)),\n         };\n-        inline::record_extern_fqn(cx, did, TypeTrait);\n+        inline::record_extern_fqn(cx, did, TypeKind::Trait);\n         TraitBound(PolyTrait {\n             trait_: ResolvedPath {\n                 path: path,\n@@ -707,7 +704,7 @@ impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n             Some(tcx) => tcx,\n             None => return RegionBound(Lifetime::statik())\n         };\n-        inline::record_extern_fqn(cx, self.def_id, TypeTrait);\n+        inline::record_extern_fqn(cx, self.def_id, TypeKind::Trait);\n         let path = external_path(cx, &tcx.item_name(self.def_id).as_str(),\n                                  Some(self.def_id), true, vec![], self.substs);\n \n@@ -765,7 +762,7 @@ impl Lifetime {\n     pub fn get_ref<'a>(&'a self) -> &'a str {\n         let Lifetime(ref s) = *self;\n         let s: &'a str = s;\n-        return s;\n+        s\n     }\n \n     pub fn statik() -> Lifetime {\n@@ -1130,7 +1127,7 @@ pub struct FnDecl {\n \n impl FnDecl {\n     pub fn has_self(&self) -> bool {\n-        return self.inputs.values.len() > 0 && self.inputs.values[0].name == \"self\";\n+        self.inputs.values.len() > 0 && self.inputs.values[0].name == \"self\"\n     }\n \n     pub fn self_type(&self) -> Option<SelfTy> {\n@@ -1480,16 +1477,16 @@ pub enum PrimitiveType {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Copy, Debug)]\n pub enum TypeKind {\n-    TypeEnum,\n-    TypeFunction,\n-    TypeModule,\n-    TypeConst,\n-    TypeStatic,\n-    TypeStruct,\n-    TypeUnion,\n-    TypeTrait,\n-    TypeVariant,\n-    TypeTypedef,\n+    Enum,\n+    Function,\n+    Module,\n+    Const,\n+    Static,\n+    Struct,\n+    Union,\n+    Trait,\n+    Variant,\n+    Typedef,\n }\n \n pub trait GetDefId {\n@@ -1572,7 +1569,7 @@ impl PrimitiveType {\n         None\n     }\n \n-    pub fn to_string(&self) -> &'static str {\n+    pub fn as_str(&self) -> &'static str {\n         match *self {\n             PrimitiveType::Isize => \"isize\",\n             PrimitiveType::I8 => \"i8\",\n@@ -1597,7 +1594,7 @@ impl PrimitiveType {\n     }\n \n     pub fn to_url_str(&self) -> &'static str {\n-        self.to_string()\n+        self.as_str()\n     }\n \n     /// Creates a rustdoc-specific node id for primitive types.\n@@ -1795,9 +1792,9 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n             ty::TyAdt(def, substs) => {\n                 let did = def.did;\n                 let kind = match def.adt_kind() {\n-                    AdtKind::Struct => TypeStruct,\n-                    AdtKind::Union => TypeUnion,\n-                    AdtKind::Enum => TypeEnum,\n+                    AdtKind::Struct => TypeKind::Struct,\n+                    AdtKind::Union => TypeKind::Union,\n+                    AdtKind::Enum => TypeKind::Enum,\n                 };\n                 inline::record_extern_fqn(cx, did, kind);\n                 let path = external_path(cx, &cx.tcx().item_name(did).as_str(),\n@@ -1811,7 +1808,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n             }\n             ty::TyTrait(ref obj) => {\n                 let did = obj.principal.def_id();\n-                inline::record_extern_fqn(cx, did, TypeTrait);\n+                inline::record_extern_fqn(cx, did, TypeKind::Trait);\n \n                 let mut typarams = vec![];\n                 obj.region_bound.clean(cx).map(|b| typarams.push(RegionBound(b)));\n@@ -2027,7 +2024,7 @@ impl Clean<Item> for doctree::Variant {\n             deprecation: self.depr.clean(cx),\n             def_id: cx.map.local_def_id(self.def.id()),\n             inner: VariantItem(Variant {\n-                kind: struct_def_to_variant_kind(&self.def, cx),\n+                kind: self.def.clean(cx),\n             }),\n         }\n     }\n@@ -2036,14 +2033,14 @@ impl Clean<Item> for doctree::Variant {\n impl<'tcx> Clean<Item> for ty::VariantDefData<'tcx, 'static> {\n     fn clean(&self, cx: &DocContext) -> Item {\n         let kind = match self.kind {\n-            ty::VariantKind::Unit => CLikeVariant,\n+            ty::VariantKind::Unit => VariantKind::CLike,\n             ty::VariantKind::Tuple => {\n-                TupleVariant(\n+                VariantKind::Tuple(\n                     self.fields.iter().map(|f| f.unsubst_ty().clean(cx)).collect()\n                 )\n             }\n             ty::VariantKind::Struct => {\n-                StructVariant(VariantStruct {\n+                VariantKind::Struct(VariantStruct {\n                     struct_type: doctree::Plain,\n                     fields_stripped: false,\n                     fields: self.fields.iter().map(|field| {\n@@ -2076,18 +2073,20 @@ impl<'tcx> Clean<Item> for ty::VariantDefData<'tcx, 'static> {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum VariantKind {\n-    CLikeVariant,\n-    TupleVariant(Vec<Type>),\n-    StructVariant(VariantStruct),\n+    CLike,\n+    Tuple(Vec<Type>),\n+    Struct(VariantStruct),\n }\n \n-fn struct_def_to_variant_kind(struct_def: &hir::VariantData, cx: &DocContext) -> VariantKind {\n-    if struct_def.is_struct() {\n-        StructVariant(struct_def.clean(cx))\n-    } else if struct_def.is_unit() {\n-        CLikeVariant\n-    } else {\n-        TupleVariant(struct_def.fields().iter().map(|x| x.ty.clean(cx)).collect())\n+impl Clean<VariantKind> for hir::VariantData {\n+    fn clean(&self, cx: &DocContext) -> VariantKind {\n+        if self.is_struct() {\n+            VariantKind::Struct(self.clean(cx))\n+        } else if self.is_unit() {\n+            VariantKind::CLike\n+        } else {\n+            VariantKind::Tuple(self.fields().iter().map(|x| x.ty.clean(cx)).collect())\n+        }\n     }\n }\n \n@@ -2526,7 +2525,7 @@ impl Clean<Vec<Item>> for doctree::Import {\n         });\n         let (mut ret, inner) = match self.node {\n             hir::ViewPathGlob(ref p) => {\n-                (vec![], GlobImport(resolve_use_source(cx, p.clean(cx), self.id)))\n+                (vec![], Import::Glob(resolve_use_source(cx, p.clean(cx), self.id)))\n             }\n             hir::ViewPathList(ref p, ref list) => {\n                 // Attempt to inline all reexported items, but be sure\n@@ -2552,17 +2551,16 @@ impl Clean<Vec<Item>> for doctree::Import {\n                 if remaining.is_empty() {\n                     return ret;\n                 }\n-                (ret, ImportList(resolve_use_source(cx, p.clean(cx), self.id),\n-                                 remaining))\n+                (ret, Import::List(resolve_use_source(cx, p.clean(cx), self.id), remaining))\n             }\n             hir::ViewPathSimple(name, ref p) => {\n                 if !denied {\n                     if let Some(items) = inline::try_inline(cx, self.id, Some(name)) {\n                         return items;\n                     }\n                 }\n-                (vec![], SimpleImport(name.clean(cx),\n-                                      resolve_use_source(cx, p.clean(cx), self.id)))\n+                (vec![], Import::Simple(name.clean(cx),\n+                                        resolve_use_source(cx, p.clean(cx), self.id)))\n             }\n         };\n         ret.push(Item {\n@@ -2582,11 +2580,11 @@ impl Clean<Vec<Item>> for doctree::Import {\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum Import {\n     // use source as str;\n-    SimpleImport(String, ImportSource),\n+    Simple(String, ImportSource),\n     // use source::*;\n-    GlobImport(ImportSource),\n+    Glob(ImportSource),\n     // use source::{a, b, c};\n-    ImportList(ImportSource, Vec<ViewListIdent>),\n+    List(ImportSource, Vec<ViewListIdent>),\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n@@ -2761,24 +2759,24 @@ fn register_def(cx: &DocContext, def: Def) -> DefId {\n     let tcx = cx.tcx();\n \n     let (did, kind) = match def {\n-        Def::Fn(i) => (i, TypeFunction),\n-        Def::TyAlias(i) => (i, TypeTypedef),\n-        Def::Enum(i) => (i, TypeEnum),\n-        Def::Trait(i) => (i, TypeTrait),\n-        Def::Struct(i) => (i, TypeStruct),\n-        Def::Union(i) => (i, TypeUnion),\n-        Def::Mod(i) => (i, TypeModule),\n-        Def::Static(i, _) => (i, TypeStatic),\n-        Def::Variant(i) => (tcx.parent_def_id(i).unwrap(), TypeEnum),\n-        Def::SelfTy(Some(def_id), _) => (def_id, TypeTrait),\n+        Def::Fn(i) => (i, TypeKind::Function),\n+        Def::TyAlias(i) => (i, TypeKind::Typedef),\n+        Def::Enum(i) => (i, TypeKind::Enum),\n+        Def::Trait(i) => (i, TypeKind::Trait),\n+        Def::Struct(i) => (i, TypeKind::Struct),\n+        Def::Union(i) => (i, TypeKind::Union),\n+        Def::Mod(i) => (i, TypeKind::Module),\n+        Def::Static(i, _) => (i, TypeKind::Static),\n+        Def::Variant(i) => (tcx.parent_def_id(i).unwrap(), TypeKind::Enum),\n+        Def::SelfTy(Some(def_id), _) => (def_id, TypeKind::Trait),\n         Def::SelfTy(_, Some(impl_def_id)) => {\n             return impl_def_id\n         }\n         _ => return def.def_id()\n     };\n     if did.is_local() { return did }\n     inline::record_extern_fqn(cx, did, kind);\n-    if let TypeTrait = kind {\n+    if let TypeKind::Trait = kind {\n         let t = inline::build_external_trait(cx, tcx, did);\n         cx.external_traits.borrow_mut().insert(did, t);\n     }\n@@ -2966,7 +2964,7 @@ fn lang_struct(cx: &DocContext, did: Option<DefId>,\n         Some(did) => did,\n         None => return fallback(box t.clean(cx)),\n     };\n-    inline::record_extern_fqn(cx, did, TypeStruct);\n+    inline::record_extern_fqn(cx, did, TypeKind::Struct);\n     ResolvedPath {\n         typarams: None,\n         did: did,"}, {"sha": "15e042f8c0809287fe23171d7d9d1ff5cfe06b88", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/825e6b328790a94f29959517b40f8758896ed3f6/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825e6b328790a94f29959517b40f8758896ed3f6/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=825e6b328790a94f29959517b40f8758896ed3f6", "patch": "@@ -141,7 +141,7 @@ pub fn ty_params(mut params: Vec<clean::TyParam>) -> Vec<clean::TyParam> {\n     for param in &mut params {\n         param.bounds = ty_bounds(mem::replace(&mut param.bounds, Vec::new()));\n     }\n-    return params;\n+    params\n }\n \n fn ty_bounds(bounds: Vec<clean::TyParamBound>) -> Vec<clean::TyParamBound> {"}, {"sha": "e269d940bfabf8a79931f0b4a8869ca88f654da1", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/825e6b328790a94f29959517b40f8758896ed3f6/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825e6b328790a94f29959517b40f8758896ed3f6/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=825e6b328790a94f29959517b40f8758896ed3f6", "patch": "@@ -74,12 +74,12 @@ pub trait DocFolder : Sized {\n             VariantItem(i) => {\n                 let i2 = i.clone(); // this clone is small\n                 match i.kind {\n-                    StructVariant(mut j) => {\n+                    VariantKind::Struct(mut j) => {\n                         let num_fields = j.fields.len();\n                         j.fields = j.fields.into_iter().filter_map(|x| self.fold_item(x)).collect();\n                         j.fields_stripped |= num_fields != j.fields.len() ||\n                                              j.fields.iter().any(|f| f.is_stripped());\n-                        VariantItem(Variant {kind: StructVariant(j), ..i2})\n+                        VariantItem(Variant {kind: VariantKind::Struct(j), ..i2})\n                     },\n                     _ => VariantItem(i2)\n                 }"}, {"sha": "3f7f01a9a3b51708691317dd5ae6686d3e100f25", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/825e6b328790a94f29959517b40f8758896ed3f6/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825e6b328790a94f29959517b40f8758896ed3f6/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=825e6b328790a94f29959517b40f8758896ed3f6", "patch": "@@ -457,7 +457,7 @@ impl fmt::Display for clean::Type {\n                 tybounds(f, typarams)\n             }\n             clean::Infer => write!(f, \"_\"),\n-            clean::Primitive(prim) => primitive_link(f, prim, prim.to_string()),\n+            clean::Primitive(prim) => primitive_link(f, prim, prim.as_str()),\n             clean::BareFunction(ref decl) => {\n                 write!(f, \"{}{}fn{}{}\",\n                        UnsafetySpace(decl.unsafety),\n@@ -708,17 +708,17 @@ impl fmt::Display for ConstnessSpace {\n impl fmt::Display for clean::Import {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            clean::SimpleImport(ref name, ref src) => {\n+            clean::Import::Simple(ref name, ref src) => {\n                 if *name == src.path.last_name() {\n                     write!(f, \"use {};\", *src)\n                 } else {\n                     write!(f, \"use {} as {};\", *src, *name)\n                 }\n             }\n-            clean::GlobImport(ref src) => {\n+            clean::Import::Glob(ref src) => {\n                 write!(f, \"use {}::*;\", *src)\n             }\n-            clean::ImportList(ref src, ref names) => {\n+            clean::Import::List(ref src, ref names) => {\n                 write!(f, \"use {}::{{\", *src)?;\n                 for (i, n) in names.iter().enumerate() {\n                     if i > 0 {"}, {"sha": "f584c4e2f4d9cae0b61b6ff687b866ed673bc875", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/825e6b328790a94f29959517b40f8758896ed3f6/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825e6b328790a94f29959517b40f8758896ed3f6/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=825e6b328790a94f29959517b40f8758896ed3f6", "patch": "@@ -90,16 +90,16 @@ impl<'a> From<&'a clean::Item> for ItemType {\n impl From<clean::TypeKind> for ItemType {\n     fn from(kind: clean::TypeKind) -> ItemType {\n         match kind {\n-            clean::TypeStruct   => ItemType::Struct,\n-            clean::TypeUnion    => ItemType::Union,\n-            clean::TypeEnum     => ItemType::Enum,\n-            clean::TypeFunction => ItemType::Function,\n-            clean::TypeTrait    => ItemType::Trait,\n-            clean::TypeModule   => ItemType::Module,\n-            clean::TypeStatic   => ItemType::Static,\n-            clean::TypeConst    => ItemType::Constant,\n-            clean::TypeVariant  => ItemType::Variant,\n-            clean::TypeTypedef  => ItemType::Typedef,\n+            clean::TypeKind::Struct   => ItemType::Struct,\n+            clean::TypeKind::Union    => ItemType::Union,\n+            clean::TypeKind::Enum     => ItemType::Enum,\n+            clean::TypeKind::Function => ItemType::Function,\n+            clean::TypeKind::Trait    => ItemType::Trait,\n+            clean::TypeKind::Module   => ItemType::Module,\n+            clean::TypeKind::Static   => ItemType::Static,\n+            clean::TypeKind::Const    => ItemType::Constant,\n+            clean::TypeKind::Variant  => ItemType::Variant,\n+            clean::TypeKind::Typedef  => ItemType::Typedef,\n         }\n     }\n }"}, {"sha": "5a6e167188226a660299e4b7593f745af05f0d8b", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/825e6b328790a94f29959517b40f8758896ed3f6/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825e6b328790a94f29959517b40f8758896ed3f6/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=825e6b328790a94f29959517b40f8758896ed3f6", "patch": "@@ -722,7 +722,7 @@ fn write_shared(cx: &Context,\n                 ret.push(line.to_string());\n             }\n         }\n-        return Ok(ret);\n+        Ok(ret)\n     }\n \n     // Update the search index\n@@ -1208,7 +1208,7 @@ impl DocFolder for Cache {\n         self.seen_mod = orig_seen_mod;\n         self.stripped_mod = orig_stripped_mod;\n         self.parent_is_trait_impl = orig_parent_is_trait_impl;\n-        return ret;\n+        ret\n     }\n }\n \n@@ -1249,7 +1249,7 @@ impl Context {\n         self.dst = prev;\n         self.current.pop().unwrap();\n \n-        return ret;\n+        ret\n     }\n \n     /// Main method for rendering a crate.\n@@ -1450,7 +1450,7 @@ impl Context {\n         for (_, items) in &mut map {\n             items.sort();\n         }\n-        return map;\n+        map\n     }\n }\n \n@@ -1647,7 +1647,7 @@ fn full_path(cx: &Context, item: &clean::Item) -> String {\n     let mut s = cx.current.join(\"::\");\n     s.push_str(\"::\");\n     s.push_str(item.name.as_ref().unwrap());\n-    return s\n+    s\n }\n \n fn shorter<'a>(s: Option<&'a str>) -> String {\n@@ -2378,8 +2378,8 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             match v.inner {\n                 clean::VariantItem(ref var) => {\n                     match var.kind {\n-                        clean::CLikeVariant => write!(w, \"{}\", name)?,\n-                        clean::TupleVariant(ref tys) => {\n+                        clean::VariantKind::CLike => write!(w, \"{}\", name)?,\n+                        clean::VariantKind::Tuple(ref tys) => {\n                             write!(w, \"{}(\", name)?;\n                             for (i, ty) in tys.iter().enumerate() {\n                                 if i > 0 {\n@@ -2389,7 +2389,7 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                             }\n                             write!(w, \")\")?;\n                         }\n-                        clean::StructVariant(ref s) => {\n+                        clean::VariantKind::Struct(ref s) => {\n                             render_struct(w,\n                                           v,\n                                           None,\n@@ -2429,7 +2429,7 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                    ns_id = ns_id,\n                    name = variant.name.as_ref().unwrap())?;\n             if let clean::VariantItem(ref var) = variant.inner {\n-                if let clean::TupleVariant(ref tys) = var.kind {\n+                if let clean::VariantKind::Tuple(ref tys) = var.kind {\n                     write!(w, \"(\")?;\n                     for (i, ty) in tys.iter().enumerate() {\n                         if i > 0 {\n@@ -2443,8 +2443,10 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             write!(w, \"</code></span></span>\")?;\n             document(w, cx, variant)?;\n \n-            use clean::{Variant, StructVariant};\n-            if let clean::VariantItem( Variant { kind: StructVariant(ref s) } ) = variant.inner {\n+            use clean::{Variant, VariantKind};\n+            if let clean::VariantItem(Variant {\n+                kind: VariantKind::Struct(ref s)\n+            }) = variant.inner {\n                 write!(w, \"<h3 class='fields'>Fields</h3>\\n\n                            <table>\")?;\n                 for field in &s.fields {"}, {"sha": "006dda7d661995d9e67041b156d54765d4a48d98", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/825e6b328790a94f29959517b40f8758896ed3f6/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825e6b328790a94f29959517b40f8758896ed3f6/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=825e6b328790a94f29959517b40f8758896ed3f6", "patch": "@@ -288,15 +288,14 @@ pub fn main_args(args: &[String]) -> isize {\n                               passes.into_iter().collect(),\n                               css_file_extension,\n                               renderinfo)\n-                .expect(\"failed to generate documentation\")\n+                .expect(\"failed to generate documentation\");\n+            0\n         }\n         Some(s) => {\n             println!(\"unknown output format: {}\", s);\n-            return 1;\n+            1\n         }\n     }\n-\n-    return 0;\n }\n \n /// Looks inside the command line arguments to extract the relevant input format"}, {"sha": "1cc4f9371cb68689e02b0b3339e8731b237474fc", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/825e6b328790a94f29959517b40f8758896ed3f6/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825e6b328790a94f29959517b40f8758896ed3f6/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=825e6b328790a94f29959517b40f8758896ed3f6", "patch": "@@ -131,7 +131,7 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n             clean::ImplItem(ref imp) if imp.trait_.is_some() => true,\n             // Struct variant fields have inherited visibility\n             clean::VariantItem(clean::Variant {\n-                kind: clean::StructVariant(..)\n+                kind: clean::VariantKind::Struct(..)\n             }) => true,\n             _ => false,\n         };"}, {"sha": "ed9efca77e7a96f03ac36d1bf025fe86cf9604ad", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/825e6b328790a94f29959517b40f8758896ed3f6/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825e6b328790a94f29959517b40f8758896ed3f6/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=825e6b328790a94f29959517b40f8758896ed3f6", "patch": "@@ -169,7 +169,7 @@ fn scrape_test_config(krate: &::rustc::hir::Crate) -> TestOptions {\n         }\n     }\n \n-    return opts;\n+    opts\n }\n \n fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n@@ -264,9 +264,9 @@ fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n         Ok(r) => {\n             match r {\n                 Err(count) => {\n-                    if count > 0 && compile_fail == false {\n+                    if count > 0 && !compile_fail {\n                         sess.fatal(\"aborting due to previous error(s)\")\n-                    } else if count == 0 && compile_fail == true {\n+                    } else if count == 0 && compile_fail {\n                         panic!(\"test compiled while it wasn't supposed to\")\n                     }\n                     if count > 0 && error_codes.len() > 0 {\n@@ -279,7 +279,7 @@ fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n             }\n         }\n         Err(_) => {\n-            if compile_fail == false {\n+            if !compile_fail {\n                 panic!(\"couldn't compile the test\");\n             }\n             if error_codes.len() > 0 {\n@@ -363,7 +363,7 @@ pub fn maketest(s: &str, cratename: Option<&str>, dont_insert_main: bool,\n \n     info!(\"final test program: {}\", prog);\n \n-    return prog\n+    prog\n }\n \n fn partition_source(s: &str) -> (String, String) {\n@@ -387,7 +387,7 @@ fn partition_source(s: &str) -> (String, String) {\n         }\n     }\n \n-    return (before, after);\n+    (before, after)\n }\n \n pub struct Collector {"}, {"sha": "4d1af1622724a37bdae20bb8d7e071b6e892f0b4", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/825e6b328790a94f29959517b40f8758896ed3f6/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/825e6b328790a94f29959517b40f8758896ed3f6/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=825e6b328790a94f29959517b40f8758896ed3f6", "patch": "@@ -328,7 +328,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             _ => false,\n         };\n         self.view_item_stack.remove(&def_node_id);\n-        return ret;\n+        ret\n     }\n \n     pub fn visit_item(&mut self, item: &hir::Item,"}]}