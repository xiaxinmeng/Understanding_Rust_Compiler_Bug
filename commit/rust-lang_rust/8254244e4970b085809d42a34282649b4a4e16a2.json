{"sha": "8254244e4970b085809d42a34282649b4a4e16a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyNTQyNDRlNDk3MGIwODU4MDlkNDJhMzQyODI2NDliNGE0ZTE2YTI=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-03-26T11:19:38Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-03-26T11:19:38Z"}, "message": "Merge #1055\n\n1055: store macro def inside macro id r=matklad a=matklad\n\nThis makes macro expansion resilient to changes to code inside the macro\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "380b2c4835bd7ad75a66d26cab8e25e0be801182", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/380b2c4835bd7ad75a66d26cab8e25e0be801182"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8254244e4970b085809d42a34282649b4a4e16a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8254244e4970b085809d42a34282649b4a4e16a2", "html_url": "https://github.com/rust-lang/rust/commit/8254244e4970b085809d42a34282649b4a4e16a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8254244e4970b085809d42a34282649b4a4e16a2/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "71f8619b4e614aa9c61be6b2851498050e7f63ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/71f8619b4e614aa9c61be6b2851498050e7f63ae", "html_url": "https://github.com/rust-lang/rust/commit/71f8619b4e614aa9c61be6b2851498050e7f63ae"}, {"sha": "e231277ab2f1ebb3040457e89b92540e599dbb3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e231277ab2f1ebb3040457e89b92540e599dbb3e", "html_url": "https://github.com/rust-lang/rust/commit/e231277ab2f1ebb3040457e89b92540e599dbb3e"}], "stats": {"total": 249, "additions": 105, "deletions": 144}, "files": [{"sha": "790e2b80f7139e135ce3cc4b8eb8cd97b0e83fef", "filename": "crates/ra_hir/src/code_model_impl/module.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8254244e4970b085809d42a34282649b4a4e16a2/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8254244e4970b085809d42a34282649b4a4e16a2/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs?ref=8254244e4970b085809d42a34282649b4a4e16a2", "patch": "@@ -76,7 +76,7 @@ impl Module {\n         import: ImportId,\n     ) -> TreeArc<ast::PathSegment> {\n         let (file_id, source) = self.definition_source(db);\n-        let (_, source_map) = db.raw_items_with_source_map(file_id.original_file(db));\n+        let (_, source_map) = db.raw_items_with_source_map(file_id);\n         source_map.get(&source, import)\n     }\n "}, {"sha": "492814cbbcbd19e42a2af40ca284f7025c5c77ae", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8254244e4970b085809d42a34282649b4a4e16a2/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8254244e4970b085809d42a34282649b4a4e16a2/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=8254244e4970b085809d42a34282649b4a4e16a2", "patch": "@@ -1,10 +1,10 @@\n use std::sync::Arc;\n \n use ra_syntax::{SyntaxNode, TreeArc, SourceFile};\n-use ra_db::{SourceDatabase, salsa, FileId};\n+use ra_db::{SourceDatabase, salsa};\n \n use crate::{\n-    HirFileId, SourceFileItems, SourceItemId, Crate, Module, HirInterner,\n+    HirFileId, MacroDefId, SourceFileItems, SourceItemId, Crate, Module, HirInterner,\n     Function, FnSignature, ExprScopes, TypeAlias,\n     Struct, Enum, StructField,\n     Const, ConstSignature, Static,\n@@ -19,6 +19,9 @@ use crate::{\n \n #[salsa::query_group(DefDatabaseStorage)]\n pub trait DefDatabase: SourceDatabase + AsRef<HirInterner> {\n+    #[salsa::invoke(crate::ids::macro_def_query)]\n+    fn macro_def(&self, macro_id: MacroDefId) -> Option<Arc<mbe::MacroRules>>;\n+\n     #[salsa::invoke(HirFileId::hir_parse)]\n     fn hir_parse(&self, file_id: HirFileId) -> TreeArc<SourceFile>;\n \n@@ -38,10 +41,13 @@ pub trait DefDatabase: SourceDatabase + AsRef<HirInterner> {\n     fn file_item(&self, source_item_id: SourceItemId) -> TreeArc<SyntaxNode>;\n \n     #[salsa::invoke(RawItems::raw_items_query)]\n-    fn raw_items(&self, file_id: FileId) -> Arc<RawItems>;\n+    fn raw_items(&self, file_id: HirFileId) -> Arc<RawItems>;\n \n     #[salsa::invoke(RawItems::raw_items_with_source_map_query)]\n-    fn raw_items_with_source_map(&self, file_id: FileId) -> (Arc<RawItems>, Arc<ImportSourceMap>);\n+    fn raw_items_with_source_map(\n+        &self,\n+        file_id: HirFileId,\n+    ) -> (Arc<RawItems>, Arc<ImportSourceMap>);\n \n     #[salsa::invoke(CrateDefMap::crate_def_map_query)]\n     fn crate_def_map(&self, krate: Crate) -> Arc<CrateDefMap>;"}, {"sha": "bac7b9e46b9513b2bc2ab69518874ac66bf4f79f", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8254244e4970b085809d42a34282649b4a4e16a2/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8254244e4970b085809d42a34282649b4a4e16a2/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=8254244e4970b085809d42a34282649b4a4e16a2", "patch": "@@ -7,6 +7,7 @@ use std::{\n use ra_db::{LocationInterner, FileId};\n use ra_syntax::{TreeArc, SyntaxNode, SourceFile, AstNode, SyntaxNodePtr, ast};\n use ra_arena::{Arena, RawId, ArenaId, impl_arena_id};\n+use mbe::MacroRules;\n \n use crate::{\n     Module,\n@@ -100,10 +101,7 @@ fn parse_macro(db: &impl DefDatabase, macro_call_id: MacroCallId) -> Option<Tree\n     let macro_call = ast::MacroCall::cast(&syntax).unwrap();\n     let (macro_arg, _) = macro_call.token_tree().and_then(mbe::ast_to_token_tree)?;\n \n-    let def_map = db.crate_def_map(loc.module.krate);\n-    let (krate, macro_id) = def_map.resolve_macro(macro_call_id)?;\n-    let def_map = db.crate_def_map(krate);\n-    let macro_rules = &def_map[macro_id];\n+    let macro_rules = db.macro_def(loc.def)?;\n     let tt = macro_rules.expand(&macro_arg).ok()?;\n     Some(mbe::token_tree_to_ast_item_list(&tt))\n }\n@@ -126,6 +124,22 @@ impl From<MacroCallId> for HirFileId {\n     }\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum MacroDefId {\n+    MacroByExample { source_item_id: SourceItemId },\n+}\n+\n+pub(crate) fn macro_def_query(db: &impl DefDatabase, id: MacroDefId) -> Option<Arc<MacroRules>> {\n+    let syntax_node = match id {\n+        MacroDefId::MacroByExample { source_item_id } => db.file_item(source_item_id),\n+    };\n+    let macro_call = ast::MacroCall::cast(&syntax_node).unwrap();\n+    let arg = macro_call.token_tree()?;\n+    let (tt, _) = mbe::ast_to_token_tree(arg)?;\n+    let rules = MacroRules::parse(&tt).ok()?;\n+    Some(Arc::new(rules))\n+}\n+\n /// `MacroCallId` identifies a particular macro invocation, like\n /// `println!(\"Hello, {}\", world)`.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -134,7 +148,7 @@ impl_arena_id!(MacroCallId);\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MacroCallLoc {\n-    pub(crate) module: Module,\n+    pub(crate) def: MacroDefId,\n     pub(crate) source_item_id: SourceItemId,\n }\n "}, {"sha": "87bc8009d3603c419ff3a104a81a4ed0e411d6bb", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8254244e4970b085809d42a34282649b4a4e16a2/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8254244e4970b085809d42a34282649b4a4e16a2/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=8254244e4970b085809d42a34282649b4a4e16a2", "patch": "@@ -53,7 +53,7 @@ use crate::{\n pub use self::{\n     path::{Path, PathKind},\n     name::Name,\n-    ids::{HirFileId, MacroCallId, MacroCallLoc, HirInterner},\n+    ids::{HirFileId, MacroDefId, MacroCallId, MacroCallLoc, HirInterner},\n     nameres::{PerNs, Namespace},\n     ty::{Ty, ApplicationTy, TypeCtor, Substs, display::HirDisplay},\n     impl_block::{ImplBlock, ImplItem},"}, {"sha": "93c11f271d6a31f988ba8b0150fffc5e6d828445", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8254244e4970b085809d42a34282649b4a4e16a2/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8254244e4970b085809d42a34282649b4a4e16a2/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=8254244e4970b085809d42a34282649b4a4e16a2", "patch": "@@ -63,7 +63,7 @@ use test_utils::tested_by;\n use crate::{\n     ModuleDef, Name, Crate, Module,\n     DefDatabase, Path, PathKind, HirFileId, Trait,\n-    ids::{SourceItemId, SourceFileItemId, MacroCallId},\n+    ids::{SourceItemId, SourceFileItemId, MacroCallId, MacroDefId},\n     diagnostics::DiagnosticSink,\n     nameres::diagnostics::DefDiagnostic,\n };\n@@ -85,7 +85,7 @@ pub struct CrateDefMap {\n     root: CrateModuleId,\n     modules: Arena<CrateModuleId, ModuleData>,\n     macros: Arena<CrateMacroId, mbe::MacroRules>,\n-    public_macros: FxHashMap<Name, CrateMacroId>,\n+    public_macros: FxHashMap<Name, MacroDefId>,\n     macro_resolutions: FxHashMap<MacroCallId, (Crate, CrateMacroId)>,\n     diagnostics: Vec<DefDiagnostic>,\n }\n@@ -238,13 +238,6 @@ impl CrateDefMap {\n         self.diagnostics.iter().for_each(|it| it.add_to(db, module, sink))\n     }\n \n-    pub(crate) fn resolve_macro(\n-        &self,\n-        macro_call_id: MacroCallId,\n-    ) -> Option<(Crate, CrateMacroId)> {\n-        self.macro_resolutions.get(&macro_call_id).map(|&it| it)\n-    }\n-\n     pub(crate) fn find_module_by_source(\n         &self,\n         file_id: HirFileId,"}, {"sha": "89300d2eccdb7f0986973a439974166c399c09d3", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 31, "deletions": 62, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/8254244e4970b085809d42a34282649b4a4e16a2/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8254244e4970b085809d42a34282649b4a4e16a2/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=8254244e4970b085809d42a34282649b4a4e16a2", "patch": "@@ -6,15 +6,15 @@ use ra_db::FileId;\n \n use crate::{\n     Function, Module, Struct, Enum, Const, Static, Trait, TypeAlias,\n-    DefDatabase, HirFileId, Name, Path, Crate,\n+    DefDatabase, HirFileId, Name, Path,\n     KnownName,\n     nameres::{\n         Resolution, PerNs, ModuleDef, ReachedFixedPoint, ResolveMode,\n-        CrateDefMap, CrateModuleId, ModuleData, CrateMacroId,\n+        CrateDefMap, CrateModuleId, ModuleData,\n         diagnostics::DefDiagnostic,\n         raw,\n     },\n-    ids::{AstItemDef, LocationCtx, MacroCallLoc, SourceItemId, MacroCallId},\n+    ids::{AstItemDef, LocationCtx, MacroCallLoc, SourceItemId, MacroCallId, MacroDefId},\n };\n \n pub(super) fn collect_defs(db: &impl DefDatabase, mut def_map: CrateDefMap) -> CrateDefMap {\n@@ -51,8 +51,8 @@ struct DefCollector<DB> {\n     def_map: CrateDefMap,\n     glob_imports: FxHashMap<CrateModuleId, Vec<(CrateModuleId, raw::ImportId)>>,\n     unresolved_imports: Vec<(CrateModuleId, raw::ImportId, raw::ImportData)>,\n-    unexpanded_macros: Vec<(CrateModuleId, MacroCallId, Path, tt::Subtree)>,\n-    global_macro_scope: FxHashMap<Name, CrateMacroId>,\n+    unexpanded_macros: Vec<(CrateModuleId, SourceItemId, Path)>,\n+    global_macro_scope: FxHashMap<Name, MacroDefId>,\n }\n \n impl<'a, DB> DefCollector<&'a DB>\n@@ -62,7 +62,7 @@ where\n     fn collect(&mut self) {\n         let crate_graph = self.db.crate_graph();\n         let file_id = crate_graph.crate_root(self.def_map.krate.crate_id());\n-        let raw_items = self.db.raw_items(file_id);\n+        let raw_items = self.db.raw_items(file_id.into());\n         let module_id = self.def_map.root;\n         self.def_map.modules[module_id].definition = Some(file_id);\n         ModCollector {\n@@ -93,14 +93,11 @@ where\n         }\n     }\n \n-    fn define_macro(&mut self, name: Name, tt: &tt::Subtree, export: bool) {\n-        if let Ok(rules) = mbe::MacroRules::parse(tt) {\n-            let macro_id = self.def_map.macros.alloc(rules);\n-            if export {\n-                self.def_map.public_macros.insert(name.clone(), macro_id);\n-            }\n-            self.global_macro_scope.insert(name, macro_id);\n+    fn define_macro(&mut self, name: Name, macro_id: MacroDefId, export: bool) {\n+        if export {\n+            self.def_map.public_macros.insert(name.clone(), macro_id);\n         }\n+        self.global_macro_scope.insert(name, macro_id);\n     }\n \n     fn resolve_imports(&mut self) -> ReachedFixedPoint {\n@@ -296,7 +293,7 @@ where\n         let mut macros = std::mem::replace(&mut self.unexpanded_macros, Vec::new());\n         let mut resolved = Vec::new();\n         let mut res = ReachedFixedPoint::Yes;\n-        macros.retain(|(module_id, call_id, path, tt)| {\n+        macros.retain(|(module_id, source_item_id, path)| {\n             if path.segments.len() != 2 {\n                 return true;\n             }\n@@ -312,47 +309,24 @@ where\n             res = ReachedFixedPoint::No;\n             let def_map = self.db.crate_def_map(krate);\n             if let Some(macro_id) = def_map.public_macros.get(&path.segments[1].name).cloned() {\n-                resolved.push((*module_id, *call_id, (krate, macro_id), tt.clone()));\n+                let call_id =\n+                    MacroCallLoc { def: macro_id, source_item_id: *source_item_id }.id(self.db);\n+                resolved.push((*module_id, call_id));\n             }\n             false\n         });\n \n-        for (module_id, macro_call_id, macro_def_id, arg) in resolved {\n-            self.collect_macro_expansion(module_id, macro_call_id, macro_def_id, arg);\n+        for (module_id, macro_call_id) in resolved {\n+            self.collect_macro_expansion(module_id, macro_call_id);\n         }\n         res\n     }\n \n-    fn collect_macro_expansion(\n-        &mut self,\n-        module_id: CrateModuleId,\n-        macro_call_id: MacroCallId,\n-        macro_def_id: (Crate, CrateMacroId),\n-        macro_arg: tt::Subtree,\n-    ) {\n-        let (macro_krate, macro_id) = macro_def_id;\n-        let dm;\n-        let rules = if macro_krate == self.def_map.krate {\n-            &self.def_map[macro_id]\n-        } else {\n-            dm = self.db.crate_def_map(macro_krate);\n-            &dm[macro_id]\n-        };\n-        if let Ok(expansion) = rules.expand(&macro_arg) {\n-            self.def_map.macro_resolutions.insert(macro_call_id, macro_def_id);\n-            // XXX: this **does not** go through a database, because we can't\n-            // identify macro_call without adding the whole state of name resolution\n-            // as a parameter to the query.\n-            //\n-            // So, we run the queries \"manually\" and we must ensure that\n-            // `db.hir_parse(macro_call_id)` returns the same source_file.\n-            let file_id: HirFileId = macro_call_id.into();\n-            let source_file = mbe::token_tree_to_ast_item_list(&expansion);\n-\n-            let raw_items = raw::RawItems::from_source_file(&source_file, file_id);\n-            ModCollector { def_collector: &mut *self, file_id, module_id, raw_items: &raw_items }\n-                .collect(raw_items.items())\n-        }\n+    fn collect_macro_expansion(&mut self, module_id: CrateModuleId, macro_call_id: MacroCallId) {\n+        let file_id: HirFileId = macro_call_id.into();\n+        let raw_items = self.db.raw_items(file_id);\n+        ModCollector { def_collector: &mut *self, file_id, module_id, raw_items: &raw_items }\n+            .collect(raw_items.items())\n     }\n \n     fn finish(self) -> CrateDefMap {\n@@ -412,7 +386,7 @@ where\n                     Ok(file_id) => {\n                         let module_id =\n                             self.push_child_module(name.clone(), source_item_id, Some(file_id));\n-                        let raw_items = self.def_collector.db.raw_items(file_id);\n+                        let raw_items = self.def_collector.db.raw_items(file_id.into());\n                         ModCollector {\n                             def_collector: &mut *self.def_collector,\n                             module_id,\n@@ -484,38 +458,33 @@ where\n         // Case 1: macro rules, define a macro in crate-global mutable scope\n         if is_macro_rules(&mac.path) {\n             if let Some(name) = &mac.name {\n-                self.def_collector.define_macro(name.clone(), &mac.arg, mac.export)\n+                let macro_id = MacroDefId::MacroByExample {\n+                    source_item_id: mac.source_item_id.with_file_id(self.file_id),\n+                };\n+                self.def_collector.define_macro(name.clone(), macro_id, mac.export)\n             }\n             return;\n         }\n \n         let source_item_id = SourceItemId { file_id: self.file_id, item_id: mac.source_item_id };\n-        let macro_call_id = MacroCallLoc {\n-            module: Module { krate: self.def_collector.def_map.krate, module_id: self.module_id },\n-            source_item_id,\n-        }\n-        .id(self.def_collector.db);\n \n         // Case 2: try to expand macro_rules from this crate, triggering\n         // recursive item collection.\n         if let Some(&macro_id) =\n             mac.path.as_ident().and_then(|name| self.def_collector.global_macro_scope.get(name))\n         {\n-            self.def_collector.collect_macro_expansion(\n-                self.module_id,\n-                macro_call_id,\n-                (self.def_collector.def_map.krate, macro_id),\n-                mac.arg.clone(),\n-            );\n+            let macro_call_id =\n+                MacroCallLoc { def: macro_id, source_item_id }.id(self.def_collector.db);\n+\n+            self.def_collector.collect_macro_expansion(self.module_id, macro_call_id);\n             return;\n         }\n \n         // Case 3: path to a macro from another crate, expand during name resolution\n         self.def_collector.unexpanded_macros.push((\n             self.module_id,\n-            macro_call_id,\n+            source_item_id,\n             mac.path.clone(),\n-            mac.arg.clone(),\n         ))\n     }\n }"}, {"sha": "ee0719ee0e75f8ea02fd9578c075c7e6b7d1ee4f", "filename": "crates/ra_hir/src/nameres/raw.rs", "status": "modified", "additions": 33, "deletions": 47, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/8254244e4970b085809d42a34282649b4a4e16a2/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8254244e4970b085809d42a34282649b4a4e16a2/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs?ref=8254244e4970b085809d42a34282649b4a4e16a2", "patch": "@@ -4,7 +4,6 @@ use std::{\n };\n \n use test_utils::tested_by;\n-use ra_db::FileId;\n use ra_arena::{Arena, impl_arena_id, RawId, map::ArenaMap};\n use ra_syntax::{\n     AstNode, SourceFile, AstPtr, TreeArc,\n@@ -16,6 +15,10 @@ use crate::{\n     ids::{SourceFileItemId, SourceFileItems},\n };\n \n+/// `RawItems` is a set of top-level items in a file (except for impls).\n+///\n+/// It is the input to name resolution algorithm. `RawItems` are not invalidated\n+/// on most edits.\n #[derive(Debug, Default, PartialEq, Eq)]\n pub struct RawItems {\n     modules: Arena<Module, ModuleData>,\n@@ -32,11 +35,11 @@ pub struct ImportSourceMap {\n }\n \n impl ImportSourceMap {\n-    pub(crate) fn insert(&mut self, import: ImportId, segment: &ast::PathSegment) {\n+    fn insert(&mut self, import: ImportId, segment: &ast::PathSegment) {\n         self.map.insert(import, AstPtr::new(segment))\n     }\n \n-    pub fn get(&self, source: &ModuleSource, import: ImportId) -> TreeArc<ast::PathSegment> {\n+    pub(crate) fn get(&self, source: &ModuleSource, import: ImportId) -> TreeArc<ast::PathSegment> {\n         let file = match source {\n             ModuleSource::SourceFile(file) => &*file,\n             ModuleSource::Module(m) => m.syntax().ancestors().find_map(SourceFile::cast).unwrap(),\n@@ -47,40 +50,27 @@ impl ImportSourceMap {\n }\n \n impl RawItems {\n-    pub(crate) fn raw_items_query(db: &impl DefDatabase, file_id: FileId) -> Arc<RawItems> {\n+    pub(crate) fn raw_items_query(db: &impl DefDatabase, file_id: HirFileId) -> Arc<RawItems> {\n         db.raw_items_with_source_map(file_id).0\n     }\n \n     pub(crate) fn raw_items_with_source_map_query(\n         db: &impl DefDatabase,\n-        file_id: FileId,\n+        file_id: HirFileId,\n     ) -> (Arc<RawItems>, Arc<ImportSourceMap>) {\n         let mut collector = RawItemsCollector {\n             raw_items: RawItems::default(),\n             source_file_items: db.file_items(file_id.into()),\n             source_map: ImportSourceMap::default(),\n         };\n-        let source_file = db.parse(file_id);\n+        let source_file = db.hir_parse(file_id);\n         collector.process_module(None, &*source_file);\n         (Arc::new(collector.raw_items), Arc::new(collector.source_map))\n     }\n \n-    pub(crate) fn items(&self) -> &[RawItem] {\n+    pub(super) fn items(&self) -> &[RawItem] {\n         &self.items\n     }\n-\n-    // We can't use queries during name resolution for fear of cycles, so this\n-    // is a query-less variant of the above function.\n-    pub(crate) fn from_source_file(source_file: &SourceFile, file_id: HirFileId) -> RawItems {\n-        let source_file_items = SourceFileItems::from_source_file(source_file, file_id);\n-        let mut collector = RawItemsCollector {\n-            raw_items: RawItems::default(),\n-            source_file_items: Arc::new(source_file_items),\n-            source_map: ImportSourceMap::default(),\n-        };\n-        collector.process_module(None, &*source_file);\n-        collector.raw_items\n-    }\n }\n \n impl Index<Module> for RawItems {\n@@ -112,19 +102,19 @@ impl Index<Macro> for RawItems {\n }\n \n #[derive(Debug, PartialEq, Eq, Clone, Copy)]\n-pub(crate) enum RawItem {\n+pub(super) enum RawItem {\n     Module(Module),\n     Import(ImportId),\n     Def(Def),\n     Macro(Macro),\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub(crate) struct Module(RawId);\n+pub(super) struct Module(RawId);\n impl_arena_id!(Module);\n \n #[derive(Debug, PartialEq, Eq)]\n-pub(crate) enum ModuleData {\n+pub(super) enum ModuleData {\n     Declaration { name: Name, source_item_id: SourceFileItemId },\n     Definition { name: Name, source_item_id: SourceFileItemId, items: Vec<RawItem> },\n }\n@@ -135,26 +125,26 @@ impl_arena_id!(ImportId);\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct ImportData {\n-    pub(crate) path: Path,\n-    pub(crate) alias: Option<Name>,\n-    pub(crate) is_glob: bool,\n-    pub(crate) is_prelude: bool,\n-    pub(crate) is_extern_crate: bool,\n+    pub(super) path: Path,\n+    pub(super) alias: Option<Name>,\n+    pub(super) is_glob: bool,\n+    pub(super) is_prelude: bool,\n+    pub(super) is_extern_crate: bool,\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub(crate) struct Def(RawId);\n+pub(super) struct Def(RawId);\n impl_arena_id!(Def);\n \n #[derive(Debug, PartialEq, Eq)]\n-pub(crate) struct DefData {\n-    pub(crate) source_item_id: SourceFileItemId,\n-    pub(crate) name: Name,\n-    pub(crate) kind: DefKind,\n+pub(super) struct DefData {\n+    pub(super) source_item_id: SourceFileItemId,\n+    pub(super) name: Name,\n+    pub(super) kind: DefKind,\n }\n \n #[derive(Debug, PartialEq, Eq, Clone, Copy)]\n-pub(crate) enum DefKind {\n+pub(super) enum DefKind {\n     Function,\n     Struct,\n     Enum,\n@@ -165,16 +155,15 @@ pub(crate) enum DefKind {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub(crate) struct Macro(RawId);\n+pub(super) struct Macro(RawId);\n impl_arena_id!(Macro);\n \n #[derive(Debug, PartialEq, Eq)]\n-pub(crate) struct MacroData {\n-    pub(crate) source_item_id: SourceFileItemId,\n-    pub(crate) path: Path,\n-    pub(crate) name: Option<Name>,\n-    pub(crate) arg: tt::Subtree,\n-    pub(crate) export: bool,\n+pub(super) struct MacroData {\n+    pub(super) source_item_id: SourceFileItemId,\n+    pub(super) path: Path,\n+    pub(super) name: Option<Name>,\n+    pub(super) export: bool,\n }\n \n struct RawItemsCollector {\n@@ -291,18 +280,15 @@ impl RawItemsCollector {\n     }\n \n     fn add_macro(&mut self, current_module: Option<Module>, m: &ast::MacroCall) {\n-        let (path, arg) = match (\n-            m.path().and_then(Path::from_ast),\n-            m.token_tree().and_then(mbe::ast_to_token_tree),\n-        ) {\n-            (Some(path), Some((token_tree, _token_map))) => (path, token_tree),\n+        let path = match m.path().and_then(Path::from_ast) {\n+            Some(it) => it,\n             _ => return,\n         };\n \n         let name = m.name().map(|it| it.as_name());\n         let source_item_id = self.source_file_items.id_of_unchecked(m.syntax());\n         let export = m.has_atom_attr(\"macro_export\");\n-        let m = self.raw_items.macros.alloc(MacroData { source_item_id, path, arg, name, export });\n+        let m = self.raw_items.macros.alloc(MacroData { source_item_id, path, name, export });\n         self.push_item(current_module, RawItem::Macro(m));\n     }\n "}, {"sha": "a059634e2003a8fa48b21f8238fca43f15202aeb", "filename": "crates/ra_hir/src/nameres/tests/incremental.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8254244e4970b085809d42a34282649b4a4e16a2/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8254244e4970b085809d42a34282649b4a4e16a2/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs?ref=8254244e4970b085809d42a34282649b4a4e16a2", "patch": "@@ -90,34 +90,27 @@ fn adding_inner_items_should_not_invalidate_def_map() {\n     );\n }\n \n-// It would be awesome to make this work, but it's unclear how\n #[test]\n-#[ignore]\n-fn typing_inside_a_function_inside_a_macro_should_not_invalidate_def_map() {\n+fn typing_inside_a_macro_should_not_invalidate_def_map() {\n     check_def_map_is_not_recomputed(\n         \"\n         //- /lib.rs\n+        macro_rules! m {\n+            ($ident:ident) => {\n+                struct Foo;\n+            }\n+        }\n         mod foo;\n \n-        use crate::foo::bar::Baz;\n-\n         //- /foo/mod.rs\n         pub mod bar;\n \n         //- /foo/bar.rs\n         <|>\n-        salsa::query_group! {\n-            trait Baz {\n-                fn foo() -> i32 { 1 + 1 }\n-            }\n-        }\n+        m!(X);\n         \",\n         \"\n-        salsa::query_group! {\n-            trait Baz {\n-                fn foo() -> i32 { 92 }\n-            }\n-        }\n+        m!(Y);\n         \",\n     );\n }"}]}