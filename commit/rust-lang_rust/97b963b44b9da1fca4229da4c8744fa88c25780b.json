{"sha": "97b963b44b9da1fca4229da4c8744fa88c25780b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3Yjk2M2I0NGI5ZGExZmNhNDIyOWRhNGM4NzQ0ZmE4OGMyNTc4MGI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-04-07T12:53:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-07T12:53:47Z"}, "message": "Merge #3706\n\n3706: missing match arms diagnostic r=flodiebold a=JoshMcguigan\n\nFollowing up on https://github.com/rust-analyzer/rust-analyzer/pull/3689#issuecomment-602718222, this PR creates a missing match arms diagnostic.\r\n\r\nAt the moment this is a very early draft, but I wanted to open it just to get some initial feedback.\r\n\r\nInitial questions:\r\n\r\n* Have I roughly created the correct boilerplate? \r\n* Inside the new `validate_match` function:\r\n  * Am I correct in thinking I want to do validation by comparing the match arms against `match_expr`? And when analyzing `match_expr` I should be looking at it as a `hir_def::expr::Expr`?\r\n  * I mostly copied the chained if-let statements from the struct validation. Shouldn't there be a non-failable way to get an AstPtr from the hir data structures? \r\n\r\nThanks for all the guidance.\n\nCo-authored-by: Josh Mcguigan <joshmcg88@gmail.com>", "tree": {"sha": "f25e0db350072cf8d084ce81adcaeeeaac3f4c42", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f25e0db350072cf8d084ce81adcaeeeaac3f4c42"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97b963b44b9da1fca4229da4c8744fa88c25780b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJejHfbCRBK7hj4Ov3rIwAAdHIIAI0E9hIY4Ty0tSP4Z+0JxyeZ\nmeNW1m0xD7aof7B1itaAEtmAvkIyOCTY4siZfevb4KIqSL7sKJm7o5eNCsBlmYM3\nlQJGp8IlZrNNeQ3Gmo/3c4G1unJLS+UAIUv6uW9dxONHLJOK+1LOq4mU+MA49RKi\nvLyKCuVOCENmJs32Zmd5LsOIzxAirnPatY2cXoaC9AtLmJV06z7IxUvQYOZ6DSuU\npg7JpvXI/7DncZJakCLi1l41vUZQsaol3NUUPVDXCi5of+LB5N16Hlq74aBUEDWq\nr+vQkcgTgY3UPOrsFuTorZyjKIfkON/BR1D9S8vvaPHewVs9oX0XOaKedoFU2aU=\n=1E9M\n-----END PGP SIGNATURE-----\n", "payload": "tree f25e0db350072cf8d084ce81adcaeeeaac3f4c42\nparent b7e5d94bda362ffc21174a79aa0be113c3288e1e\nparent 9fc1f51b7ade2cda7d410450ab1347311eb074af\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1586264027 +0000\ncommitter GitHub <noreply@github.com> 1586264027 +0000\n\nMerge #3706\n\n3706: missing match arms diagnostic r=flodiebold a=JoshMcguigan\n\nFollowing up on https://github.com/rust-analyzer/rust-analyzer/pull/3689#issuecomment-602718222, this PR creates a missing match arms diagnostic.\r\n\r\nAt the moment this is a very early draft, but I wanted to open it just to get some initial feedback.\r\n\r\nInitial questions:\r\n\r\n* Have I roughly created the correct boilerplate? \r\n* Inside the new `validate_match` function:\r\n  * Am I correct in thinking I want to do validation by comparing the match arms against `match_expr`? And when analyzing `match_expr` I should be looking at it as a `hir_def::expr::Expr`?\r\n  * I mostly copied the chained if-let statements from the struct validation. Shouldn't there be a non-failable way to get an AstPtr from the hir data structures? \r\n\r\nThanks for all the guidance.\n\nCo-authored-by: Josh Mcguigan <joshmcg88@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97b963b44b9da1fca4229da4c8744fa88c25780b", "html_url": "https://github.com/rust-lang/rust/commit/97b963b44b9da1fca4229da4c8744fa88c25780b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97b963b44b9da1fca4229da4c8744fa88c25780b/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7e5d94bda362ffc21174a79aa0be113c3288e1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7e5d94bda362ffc21174a79aa0be113c3288e1e", "html_url": "https://github.com/rust-lang/rust/commit/b7e5d94bda362ffc21174a79aa0be113c3288e1e"}, {"sha": "9fc1f51b7ade2cda7d410450ab1347311eb074af", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fc1f51b7ade2cda7d410450ab1347311eb074af", "html_url": "https://github.com/rust-lang/rust/commit/9fc1f51b7ade2cda7d410450ab1347311eb074af"}], "stats": {"total": 1563, "additions": 1552, "deletions": 11}, "files": [{"sha": "eb9824218f3ec55513cad57507738d12c7b19195", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/97b963b44b9da1fca4229da4c8744fa88c25780b/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/97b963b44b9da1fca4229da4c8744fa88c25780b/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=97b963b44b9da1fca4229da4c8744fa88c25780b", "patch": "@@ -995,6 +995,7 @@ dependencies = [\n  \"ra_prof\",\n  \"ra_syntax\",\n  \"rustc-hash\",\n+ \"smallvec\",\n  \"stdx\",\n  \"test_utils\",\n ]"}, {"sha": "c82883d0c1611fadf6255223950a99ff5e2e6ffb", "filename": "crates/ra_hir/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97b963b44b9da1fca4229da4c8744fa88c25780b/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97b963b44b9da1fca4229da4c8744fa88c25780b/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs?ref=97b963b44b9da1fca4229da4c8744fa88c25780b", "patch": "@@ -1,4 +1,4 @@\n //! FIXME: write short doc here\n pub use hir_def::diagnostics::UnresolvedModule;\n pub use hir_expand::diagnostics::{AstDiagnostic, Diagnostic, DiagnosticSink};\n-pub use hir_ty::diagnostics::{MissingFields, MissingOkInTailExpr, NoSuchField};\n+pub use hir_ty::diagnostics::{MissingFields, MissingMatchArms, MissingOkInTailExpr, NoSuchField};"}, {"sha": "9a4a7aa6f7e60f3d8ec806526f89b2fb6a133717", "filename": "crates/ra_hir_ty/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/97b963b44b9da1fca4229da4c8744fa88c25780b/crates%2Fra_hir_ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/97b963b44b9da1fca4229da4c8744fa88c25780b/crates%2Fra_hir_ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2FCargo.toml?ref=97b963b44b9da1fca4229da4c8744fa88c25780b", "patch": "@@ -9,6 +9,7 @@ doctest = false\n \n [dependencies]\n arrayvec = \"0.5.1\"\n+smallvec = \"1.2.0\"\n ena = \"0.13.1\"\n log = \"0.4.8\"\n rustc-hash = \"1.1.0\""}, {"sha": "f29a25505b98bfc863c8083b28992b5bab0ce498", "filename": "crates/ra_hir_ty/src/_match.rs", "status": "added", "additions": 1411, "deletions": 0, "changes": 1411, "blob_url": "https://github.com/rust-lang/rust/blob/97b963b44b9da1fca4229da4c8744fa88c25780b/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97b963b44b9da1fca4229da4c8744fa88c25780b/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2F_match.rs?ref=97b963b44b9da1fca4229da4c8744fa88c25780b", "patch": "@@ -0,0 +1,1411 @@\n+//! This module implements match statement exhaustiveness checking and usefulness checking\n+//! for match arms.\n+//!\n+//! It is modeled on the rustc module `librustc_mir_build::hair::pattern::_match`, which\n+//! contains very detailed documentation about the algorithms used here. I've duplicated\n+//! most of that documentation below.\n+//!\n+//! This file includes the logic for exhaustiveness and usefulness checking for\n+//! pattern-matching. Specifically, given a list of patterns for a type, we can\n+//! tell whether:\n+//! (a) the patterns cover every possible constructor for the type [exhaustiveness]\n+//! (b) each pattern is necessary [usefulness]\n+//!\n+//! The algorithm implemented here is a modified version of the one described in:\n+//! http://moscova.inria.fr/~maranget/papers/warn/index.html\n+//! However, to save future implementors from reading the original paper, we\n+//! summarise the algorithm here to hopefully save time and be a little clearer\n+//! (without being so rigorous).\n+//!\n+//! The core of the algorithm revolves about a \"usefulness\" check. In particular, we\n+//! are trying to compute a predicate `U(P, p)` where `P` is a list of patterns (we refer to this as\n+//! a matrix). `U(P, p)` represents whether, given an existing list of patterns\n+//! `P_1 ..= P_m`, adding a new pattern `p` will be \"useful\" (that is, cover previously-\n+//! uncovered values of the type).\n+//!\n+//! If we have this predicate, then we can easily compute both exhaustiveness of an\n+//! entire set of patterns and the individual usefulness of each one.\n+//! (a) the set of patterns is exhaustive iff `U(P, _)` is false (i.e., adding a wildcard\n+//! match doesn't increase the number of values we're matching)\n+//! (b) a pattern `P_i` is not useful if `U(P[0..=(i-1), P_i)` is false (i.e., adding a\n+//! pattern to those that have come before it doesn't increase the number of values\n+//! we're matching).\n+//!\n+//! During the course of the algorithm, the rows of the matrix won't just be individual patterns,\n+//! but rather partially-deconstructed patterns in the form of a list of patterns. The paper\n+//! calls those pattern-vectors, and we will call them pattern-stacks. The same holds for the\n+//! new pattern `p`.\n+//!\n+//! For example, say we have the following:\n+//! ```\n+//!     // x: (Option<bool>, Result<()>)\n+//!     match x {\n+//!         (Some(true), _) => {}\n+//!         (None, Err(())) => {}\n+//!         (None, Err(_)) => {}\n+//!     }\n+//! ```\n+//! Here, the matrix `P` starts as:\n+//! [\n+//!     [(Some(true), _)],\n+//!     [(None, Err(()))],\n+//!     [(None, Err(_))],\n+//! ]\n+//! We can tell it's not exhaustive, because `U(P, _)` is true (we're not covering\n+//! `[(Some(false), _)]`, for instance). In addition, row 3 is not useful, because\n+//! all the values it covers are already covered by row 2.\n+//!\n+//! A list of patterns can be thought of as a stack, because we are mainly interested in the top of\n+//! the stack at any given point, and we can pop or apply constructors to get new pattern-stacks.\n+//! To match the paper, the top of the stack is at the beginning / on the left.\n+//!\n+//! There are two important operations on pattern-stacks necessary to understand the algorithm:\n+//!     1. We can pop a given constructor off the top of a stack. This operation is called\n+//!        `specialize`, and is denoted `S(c, p)` where `c` is a constructor (like `Some` or\n+//!        `None`) and `p` a pattern-stack.\n+//!        If the pattern on top of the stack can cover `c`, this removes the constructor and\n+//!        pushes its arguments onto the stack. It also expands OR-patterns into distinct patterns.\n+//!        Otherwise the pattern-stack is discarded.\n+//!        This essentially filters those pattern-stacks whose top covers the constructor `c` and\n+//!        discards the others.\n+//!\n+//!        For example, the first pattern above initially gives a stack `[(Some(true), _)]`. If we\n+//!        pop the tuple constructor, we are left with `[Some(true), _]`, and if we then pop the\n+//!        `Some` constructor we get `[true, _]`. If we had popped `None` instead, we would get\n+//!        nothing back.\n+//!\n+//!        This returns zero or more new pattern-stacks, as follows. We look at the pattern `p_1`\n+//!        on top of the stack, and we have four cases:\n+//!             1.1. `p_1 = c(r_1, .., r_a)`, i.e. the top of the stack has constructor `c`. We\n+//!                  push onto the stack the arguments of this constructor, and return the result:\n+//!                     r_1, .., r_a, p_2, .., p_n\n+//!             1.2. `p_1 = c'(r_1, .., r_a')` where `c \u2260 c'`. We discard the current stack and\n+//!                  return nothing.\n+//!             1.3. `p_1 = _`. We push onto the stack as many wildcards as the constructor `c` has\n+//!                  arguments (its arity), and return the resulting stack:\n+//!                     _, .., _, p_2, .., p_n\n+//!             1.4. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n+//!                  stack:\n+//!                     S(c, (r_1, p_2, .., p_n))\n+//!                     S(c, (r_2, p_2, .., p_n))\n+//!\n+//!     2. We can pop a wildcard off the top of the stack. This is called `D(p)`, where `p` is\n+//!        a pattern-stack.\n+//!        This is used when we know there are missing constructor cases, but there might be\n+//!        existing wildcard patterns, so to check the usefulness of the matrix, we have to check\n+//!        all its *other* components.\n+//!\n+//!        It is computed as follows. We look at the pattern `p_1` on top of the stack,\n+//!        and we have three cases:\n+//!             1.1. `p_1 = c(r_1, .., r_a)`. We discard the current stack and return nothing.\n+//!             1.2. `p_1 = _`. We return the rest of the stack:\n+//!                     p_2, .., p_n\n+//!             1.3. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n+//!               stack.\n+//!                     D((r_1, p_2, .., p_n))\n+//!                     D((r_2, p_2, .., p_n))\n+//!\n+//!     Note that the OR-patterns are not always used directly in Rust, but are used to derive the\n+//!     exhaustive integer matching rules, so they're written here for posterity.\n+//!\n+//! Both those operations extend straightforwardly to a list or pattern-stacks, i.e. a matrix, by\n+//! working row-by-row. Popping a constructor ends up keeping only the matrix rows that start with\n+//! the given constructor, and popping a wildcard keeps those rows that start with a wildcard.\n+//!\n+//!\n+//! The algorithm for computing `U`\n+//! -------------------------------\n+//! The algorithm is inductive (on the number of columns: i.e., components of tuple patterns).\n+//! That means we're going to check the components from left-to-right, so the algorithm\n+//! operates principally on the first component of the matrix and new pattern-stack `p`.\n+//! This algorithm is realised in the `is_useful` function.\n+//!\n+//! Base case. (`n = 0`, i.e., an empty tuple pattern)\n+//!     - If `P` already contains an empty pattern (i.e., if the number of patterns `m > 0`),\n+//!       then `U(P, p)` is false.\n+//!     - Otherwise, `P` must be empty, so `U(P, p)` is true.\n+//!\n+//! Inductive step. (`n > 0`, i.e., whether there's at least one column\n+//!                  [which may then be expanded into further columns later])\n+//!     We're going to match on the top of the new pattern-stack, `p_1`.\n+//!         - If `p_1 == c(r_1, .., r_a)`, i.e. we have a constructor pattern.\n+//!           Then, the usefulness of `p_1` can be reduced to whether it is useful when\n+//!           we ignore all the patterns in the first column of `P` that involve other constructors.\n+//!           This is where `S(c, P)` comes in:\n+//!           `U(P, p) := U(S(c, P), S(c, p))`\n+//!           This special case is handled in `is_useful_specialized`.\n+//!\n+//!           For example, if `P` is:\n+//!           [\n+//!               [Some(true), _],\n+//!               [None, 0],\n+//!           ]\n+//!           and `p` is [Some(false), 0], then we don't care about row 2 since we know `p` only\n+//!           matches values that row 2 doesn't. For row 1 however, we need to dig into the\n+//!           arguments of `Some` to know whether some new value is covered. So we compute\n+//!           `U([[true, _]], [false, 0])`.\n+//!\n+//!         - If `p_1 == _`, then we look at the list of constructors that appear in the first\n+//!               component of the rows of `P`:\n+//!             + If there are some constructors that aren't present, then we might think that the\n+//!               wildcard `_` is useful, since it covers those constructors that weren't covered\n+//!               before.\n+//!               That's almost correct, but only works if there were no wildcards in those first\n+//!               components. So we need to check that `p` is useful with respect to the rows that\n+//!               start with a wildcard, if there are any. This is where `D` comes in:\n+//!               `U(P, p) := U(D(P), D(p))`\n+//!\n+//!               For example, if `P` is:\n+//!               [\n+//!                   [_, true, _],\n+//!                   [None, false, 1],\n+//!               ]\n+//!               and `p` is [_, false, _], the `Some` constructor doesn't appear in `P`. So if we\n+//!               only had row 2, we'd know that `p` is useful. However row 1 starts with a\n+//!               wildcard, so we need to check whether `U([[true, _]], [false, 1])`.\n+//!\n+//!             + Otherwise, all possible constructors (for the relevant type) are present. In this\n+//!               case we must check whether the wildcard pattern covers any unmatched value. For\n+//!               that, we can think of the `_` pattern as a big OR-pattern that covers all\n+//!               possible constructors. For `Option`, that would mean `_ = None | Some(_)` for\n+//!               example. The wildcard pattern is useful in this case if it is useful when\n+//!               specialized to one of the possible constructors. So we compute:\n+//!               `U(P, p) := \u2203(k \u03f5 constructors) U(S(k, P), S(k, p))`\n+//!\n+//!               For example, if `P` is:\n+//!               [\n+//!                   [Some(true), _],\n+//!                   [None, false],\n+//!               ]\n+//!               and `p` is [_, false], both `None` and `Some` constructors appear in the first\n+//!               components of `P`. We will therefore try popping both constructors in turn: we\n+//!               compute U([[true, _]], [_, false]) for the `Some` constructor, and U([[false]],\n+//!               [false]) for the `None` constructor. The first case returns true, so we know that\n+//!               `p` is useful for `P`. Indeed, it matches `[Some(false), _]` that wasn't matched\n+//!               before.\n+//!\n+//!         - If `p_1 == r_1 | r_2`, then the usefulness depends on each `r_i` separately:\n+//!           `U(P, p) := U(P, (r_1, p_2, .., p_n))\n+//!                    || U(P, (r_2, p_2, .., p_n))`\n+use std::sync::Arc;\n+\n+use smallvec::{smallvec, SmallVec};\n+\n+use crate::{\n+    db::HirDatabase,\n+    expr::{Body, Expr, Literal, Pat, PatId},\n+    InferenceResult,\n+};\n+use hir_def::{adt::VariantData, EnumVariantId, VariantId};\n+\n+#[derive(Debug, Clone, Copy)]\n+/// Either a pattern from the source code being analyzed, represented as\n+/// as `PatId`, or a `Wild` pattern which is created as an intermediate\n+/// step in the match checking algorithm and thus is not backed by a\n+/// real `PatId`.\n+///\n+/// Note that it is totally valid for the `PatId` variant to contain\n+/// a `PatId` which resolves to a `Wild` pattern, if that wild pattern\n+/// exists in the source code being analyzed.\n+enum PatIdOrWild {\n+    PatId(PatId),\n+    Wild,\n+}\n+\n+impl PatIdOrWild {\n+    fn as_pat(self, cx: &MatchCheckCtx) -> Pat {\n+        match self {\n+            PatIdOrWild::PatId(id) => cx.body.pats[id].clone(),\n+            PatIdOrWild::Wild => Pat::Wild,\n+        }\n+    }\n+\n+    fn as_id(self) -> Option<PatId> {\n+        match self {\n+            PatIdOrWild::PatId(id) => Some(id),\n+            PatIdOrWild::Wild => None,\n+        }\n+    }\n+}\n+\n+impl From<PatId> for PatIdOrWild {\n+    fn from(pat_id: PatId) -> Self {\n+        Self::PatId(pat_id)\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq)]\n+pub struct MatchCheckNotImplemented;\n+\n+/// The return type of `is_useful` is either an indication of usefulness\n+/// of the match arm, or an error in the case the match statement\n+/// is made up of types for which exhaustiveness checking is currently\n+/// not completely implemented.\n+///\n+/// The `std::result::Result` type is used here rather than a custom enum\n+/// to allow the use of `?`.\n+pub type MatchCheckResult<T> = Result<T, MatchCheckNotImplemented>;\n+\n+#[derive(Debug)]\n+/// A row in a Matrix.\n+///\n+/// This type is modeled from the struct of the same name in `rustc`.\n+pub(crate) struct PatStack(PatStackInner);\n+type PatStackInner = SmallVec<[PatIdOrWild; 2]>;\n+\n+impl PatStack {\n+    pub(crate) fn from_pattern(pat_id: PatId) -> PatStack {\n+        Self(smallvec!(pat_id.into()))\n+    }\n+\n+    pub(crate) fn from_wild() -> PatStack {\n+        Self(smallvec!(PatIdOrWild::Wild))\n+    }\n+\n+    fn from_slice(slice: &[PatIdOrWild]) -> PatStack {\n+        Self(SmallVec::from_slice(slice))\n+    }\n+\n+    fn from_vec(v: PatStackInner) -> PatStack {\n+        Self(v)\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.0.is_empty()\n+    }\n+\n+    fn head(&self) -> PatIdOrWild {\n+        self.0[0]\n+    }\n+\n+    fn get_head(&self) -> Option<PatIdOrWild> {\n+        self.0.first().copied()\n+    }\n+\n+    fn to_tail(&self) -> PatStack {\n+        Self::from_slice(&self.0[1..])\n+    }\n+\n+    fn replace_head_with(&self, pat_ids: &[PatId]) -> PatStack {\n+        let mut patterns: PatStackInner = smallvec![];\n+        for pat in pat_ids {\n+            patterns.push((*pat).into());\n+        }\n+        for pat in &self.0[1..] {\n+            patterns.push(*pat);\n+        }\n+        PatStack::from_vec(patterns)\n+    }\n+\n+    /// Computes `D(self)`.\n+    ///\n+    /// See the module docs and the associated documentation in rustc for details.\n+    fn specialize_wildcard(&self, cx: &MatchCheckCtx) -> Option<PatStack> {\n+        if matches!(self.head().as_pat(cx), Pat::Wild) {\n+            Some(self.to_tail())\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Computes `S(constructor, self)`.\n+    ///\n+    /// See the module docs and the associated documentation in rustc for details.\n+    fn specialize_constructor(\n+        &self,\n+        cx: &MatchCheckCtx,\n+        constructor: &Constructor,\n+    ) -> MatchCheckResult<Option<PatStack>> {\n+        let result = match (self.head().as_pat(cx), constructor) {\n+            (Pat::Tuple(ref pat_ids), Constructor::Tuple { arity }) => {\n+                debug_assert_eq!(\n+                    pat_ids.len(),\n+                    *arity,\n+                    \"we type check before calling this code, so we should never hit this case\",\n+                );\n+\n+                Some(self.replace_head_with(pat_ids))\n+            }\n+            (Pat::Lit(lit_expr), Constructor::Bool(constructor_val)) => {\n+                match cx.body.exprs[lit_expr] {\n+                    Expr::Literal(Literal::Bool(pat_val)) if *constructor_val == pat_val => {\n+                        Some(self.to_tail())\n+                    }\n+                    // it was a bool but the value doesn't match\n+                    Expr::Literal(Literal::Bool(_)) => None,\n+                    // perhaps this is actually unreachable given we have\n+                    // already checked that these match arms have the appropriate type?\n+                    _ => return Err(MatchCheckNotImplemented),\n+                }\n+            }\n+            (Pat::Wild, constructor) => Some(self.expand_wildcard(cx, constructor)?),\n+            (Pat::Path(_), Constructor::Enum(constructor)) => {\n+                // enums with no associated data become `Pat::Path`\n+                let pat_id = self.head().as_id().expect(\"we know this isn't a wild\");\n+                if !enum_variant_matches(cx, pat_id, *constructor) {\n+                    None\n+                } else {\n+                    Some(self.to_tail())\n+                }\n+            }\n+            (Pat::TupleStruct { args: ref pat_ids, .. }, Constructor::Enum(constructor)) => {\n+                let pat_id = self.head().as_id().expect(\"we know this isn't a wild\");\n+                if !enum_variant_matches(cx, pat_id, *constructor) {\n+                    None\n+                } else {\n+                    Some(self.replace_head_with(pat_ids))\n+                }\n+            }\n+            (Pat::Or(_), _) => return Err(MatchCheckNotImplemented),\n+            (_, _) => return Err(MatchCheckNotImplemented),\n+        };\n+\n+        Ok(result)\n+    }\n+\n+    /// A special case of `specialize_constructor` where the head of the pattern stack\n+    /// is a Wild pattern.\n+    ///\n+    /// Replaces the Wild pattern at the head of the pattern stack with N Wild patterns\n+    /// (N >= 0), where N is the arity of the given constructor.\n+    fn expand_wildcard(\n+        &self,\n+        cx: &MatchCheckCtx,\n+        constructor: &Constructor,\n+    ) -> MatchCheckResult<PatStack> {\n+        assert_eq!(\n+            Pat::Wild,\n+            self.head().as_pat(cx),\n+            \"expand_wildcard must only be called on PatStack with wild at head\",\n+        );\n+\n+        let mut patterns: PatStackInner = smallvec![];\n+\n+        for _ in 0..constructor.arity(cx)? {\n+            patterns.push(PatIdOrWild::Wild);\n+        }\n+\n+        for pat in &self.0[1..] {\n+            patterns.push(*pat);\n+        }\n+\n+        Ok(PatStack::from_vec(patterns))\n+    }\n+}\n+\n+#[derive(Debug)]\n+/// A collection of PatStack.\n+///\n+/// This type is modeled from the struct of the same name in `rustc`.\n+pub(crate) struct Matrix(Vec<PatStack>);\n+\n+impl Matrix {\n+    pub(crate) fn empty() -> Self {\n+        Self(vec![])\n+    }\n+\n+    pub(crate) fn push(&mut self, cx: &MatchCheckCtx, row: PatStack) {\n+        if let Some(Pat::Or(pat_ids)) = row.get_head().map(|pat_id| pat_id.as_pat(cx)) {\n+            // Or patterns are expanded here\n+            for pat_id in pat_ids {\n+                self.0.push(PatStack::from_pattern(pat_id));\n+            }\n+        } else {\n+            self.0.push(row);\n+        }\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.0.is_empty()\n+    }\n+\n+    fn heads(&self) -> Vec<PatIdOrWild> {\n+        self.0.iter().map(|p| p.head()).collect()\n+    }\n+\n+    /// Computes `D(self)` for each contained PatStack.\n+    ///\n+    /// See the module docs and the associated documentation in rustc for details.\n+    fn specialize_wildcard(&self, cx: &MatchCheckCtx) -> Self {\n+        Self::collect(cx, self.0.iter().filter_map(|r| r.specialize_wildcard(cx)))\n+    }\n+\n+    /// Computes `S(constructor, self)` for each contained PatStack.\n+    ///\n+    /// See the module docs and the associated documentation in rustc for details.\n+    fn specialize_constructor(\n+        &self,\n+        cx: &MatchCheckCtx,\n+        constructor: &Constructor,\n+    ) -> MatchCheckResult<Self> {\n+        let mut new_matrix = Matrix::empty();\n+        for pat in &self.0 {\n+            if let Some(pat) = pat.specialize_constructor(cx, constructor)? {\n+                new_matrix.push(cx, pat);\n+            }\n+        }\n+\n+        Ok(new_matrix)\n+    }\n+\n+    fn collect<T: IntoIterator<Item = PatStack>>(cx: &MatchCheckCtx, iter: T) -> Self {\n+        let mut matrix = Matrix::empty();\n+\n+        for pat in iter {\n+            // using push ensures we expand or-patterns\n+            matrix.push(cx, pat);\n+        }\n+\n+        matrix\n+    }\n+}\n+\n+#[derive(Clone, Debug, PartialEq)]\n+/// An indication of the usefulness of a given match arm, where\n+/// usefulness is defined as matching some patterns which were\n+/// not matched by an prior match arms.\n+///\n+/// We may eventually need an `Unknown` variant here.\n+pub enum Usefulness {\n+    Useful,\n+    NotUseful,\n+}\n+\n+pub struct MatchCheckCtx<'a> {\n+    pub body: Arc<Body>,\n+    pub infer: Arc<InferenceResult>,\n+    pub db: &'a dyn HirDatabase,\n+}\n+\n+/// Given a set of patterns `matrix`, and pattern to consider `v`, determines\n+/// whether `v` is useful. A pattern is useful if it covers cases which were\n+/// not previously covered.\n+///\n+/// When calling this function externally (that is, not the recursive calls) it\n+/// expected that you have already type checked the match arms. All patterns in\n+/// matrix should be the same type as v, as well as they should all be the same\n+/// type as the match expression.\n+pub(crate) fn is_useful(\n+    cx: &MatchCheckCtx,\n+    matrix: &Matrix,\n+    v: &PatStack,\n+) -> MatchCheckResult<Usefulness> {\n+    if v.is_empty() {\n+        let result = if matrix.is_empty() { Usefulness::Useful } else { Usefulness::NotUseful };\n+\n+        return Ok(result);\n+    }\n+\n+    if let Pat::Or(pat_ids) = v.head().as_pat(cx) {\n+        let mut found_unimplemented = false;\n+        let any_useful = pat_ids.iter().any(|&pat_id| {\n+            let v = PatStack::from_pattern(pat_id);\n+\n+            match is_useful(cx, matrix, &v) {\n+                Ok(Usefulness::Useful) => true,\n+                Ok(Usefulness::NotUseful) => false,\n+                _ => {\n+                    found_unimplemented = true;\n+                    false\n+                }\n+            }\n+        });\n+\n+        return if any_useful {\n+            Ok(Usefulness::Useful)\n+        } else if found_unimplemented {\n+            Err(MatchCheckNotImplemented)\n+        } else {\n+            Ok(Usefulness::NotUseful)\n+        };\n+    }\n+\n+    if let Some(constructor) = pat_constructor(cx, v.head())? {\n+        let matrix = matrix.specialize_constructor(&cx, &constructor)?;\n+        let v = v\n+            .specialize_constructor(&cx, &constructor)?\n+            .expect(\"we know this can't fail because we get the constructor from `v.head()` above\");\n+\n+        is_useful(&cx, &matrix, &v)\n+    } else {\n+        // expanding wildcard\n+        let mut used_constructors: Vec<Constructor> = vec![];\n+        for pat in matrix.heads() {\n+            if let Some(constructor) = pat_constructor(cx, pat)? {\n+                used_constructors.push(constructor);\n+            }\n+        }\n+\n+        // We assume here that the first constructor is the \"correct\" type. Since we\n+        // only care about the \"type\" of the constructor (i.e. if it is a bool we\n+        // don't care about the value), this assumption should be valid as long as\n+        // the match statement is well formed. We currently uphold this invariant by\n+        // filtering match arms before calling `is_useful`, only passing in match arms\n+        // whose type matches the type of the match expression.\n+        match &used_constructors.first() {\n+            Some(constructor) if all_constructors_covered(&cx, constructor, &used_constructors) => {\n+                // If all constructors are covered, then we need to consider whether\n+                // any values are covered by this wildcard.\n+                //\n+                // For example, with matrix '[[Some(true)], [None]]', all\n+                // constructors are covered (`Some`/`None`), so we need\n+                // to perform specialization to see that our wildcard will cover\n+                // the `Some(false)` case.\n+                //\n+                // Here we create a constructor for each variant and then check\n+                // usefulness after specializing for that constructor.\n+                let mut found_unimplemented = false;\n+                for constructor in constructor.all_constructors(cx) {\n+                    let matrix = matrix.specialize_constructor(&cx, &constructor)?;\n+                    let v = v.expand_wildcard(&cx, &constructor)?;\n+\n+                    match is_useful(&cx, &matrix, &v) {\n+                        Ok(Usefulness::Useful) => return Ok(Usefulness::Useful),\n+                        Ok(Usefulness::NotUseful) => continue,\n+                        _ => found_unimplemented = true,\n+                    };\n+                }\n+\n+                if found_unimplemented {\n+                    Err(MatchCheckNotImplemented)\n+                } else {\n+                    Ok(Usefulness::NotUseful)\n+                }\n+            }\n+            _ => {\n+                // Either not all constructors are covered, or the only other arms\n+                // are wildcards. Either way, this pattern is useful if it is useful\n+                // when compared to those arms with wildcards.\n+                let matrix = matrix.specialize_wildcard(&cx);\n+                let v = v.to_tail();\n+\n+                is_useful(&cx, &matrix, &v)\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy)]\n+/// Similar to TypeCtor, but includes additional information about the specific\n+/// value being instantiated. For example, TypeCtor::Bool doesn't contain the\n+/// boolean value.\n+enum Constructor {\n+    Bool(bool),\n+    Tuple { arity: usize },\n+    Enum(EnumVariantId),\n+}\n+\n+impl Constructor {\n+    fn arity(&self, cx: &MatchCheckCtx) -> MatchCheckResult<usize> {\n+        let arity = match self {\n+            Constructor::Bool(_) => 0,\n+            Constructor::Tuple { arity } => *arity,\n+            Constructor::Enum(e) => {\n+                match cx.db.enum_data(e.parent).variants[e.local_id].variant_data.as_ref() {\n+                    VariantData::Tuple(struct_field_data) => struct_field_data.len(),\n+                    VariantData::Unit => 0,\n+                    _ => return Err(MatchCheckNotImplemented),\n+                }\n+            }\n+        };\n+\n+        Ok(arity)\n+    }\n+\n+    fn all_constructors(&self, cx: &MatchCheckCtx) -> Vec<Constructor> {\n+        match self {\n+            Constructor::Bool(_) => vec![Constructor::Bool(true), Constructor::Bool(false)],\n+            Constructor::Tuple { .. } => vec![*self],\n+            Constructor::Enum(e) => cx\n+                .db\n+                .enum_data(e.parent)\n+                .variants\n+                .iter()\n+                .map(|(local_id, _)| {\n+                    Constructor::Enum(EnumVariantId { parent: e.parent, local_id })\n+                })\n+                .collect(),\n+        }\n+    }\n+}\n+\n+/// Returns the constructor for the given pattern. Should only return None\n+/// in the case of a Wild pattern.\n+fn pat_constructor(cx: &MatchCheckCtx, pat: PatIdOrWild) -> MatchCheckResult<Option<Constructor>> {\n+    let res = match pat.as_pat(cx) {\n+        Pat::Wild => None,\n+        Pat::Tuple(pats) => Some(Constructor::Tuple { arity: pats.len() }),\n+        Pat::Lit(lit_expr) => match cx.body.exprs[lit_expr] {\n+            Expr::Literal(Literal::Bool(val)) => Some(Constructor::Bool(val)),\n+            _ => return Err(MatchCheckNotImplemented),\n+        },\n+        Pat::TupleStruct { .. } | Pat::Path(_) => {\n+            let pat_id = pat.as_id().expect(\"we already know this pattern is not a wild\");\n+            let variant_id =\n+                cx.infer.variant_resolution_for_pat(pat_id).ok_or(MatchCheckNotImplemented)?;\n+            match variant_id {\n+                VariantId::EnumVariantId(enum_variant_id) => {\n+                    Some(Constructor::Enum(enum_variant_id))\n+                }\n+                _ => return Err(MatchCheckNotImplemented),\n+            }\n+        }\n+        _ => return Err(MatchCheckNotImplemented),\n+    };\n+\n+    Ok(res)\n+}\n+\n+fn all_constructors_covered(\n+    cx: &MatchCheckCtx,\n+    constructor: &Constructor,\n+    used_constructors: &[Constructor],\n+) -> bool {\n+    match constructor {\n+        Constructor::Tuple { arity } => {\n+            used_constructors.iter().any(|constructor| match constructor {\n+                Constructor::Tuple { arity: used_arity } => arity == used_arity,\n+                _ => false,\n+            })\n+        }\n+        Constructor::Bool(_) => {\n+            if used_constructors.is_empty() {\n+                return false;\n+            }\n+\n+            let covers_true =\n+                used_constructors.iter().any(|c| matches!(c, Constructor::Bool(true)));\n+            let covers_false =\n+                used_constructors.iter().any(|c| matches!(c, Constructor::Bool(false)));\n+\n+            covers_true && covers_false\n+        }\n+        Constructor::Enum(e) => cx.db.enum_data(e.parent).variants.iter().all(|(id, _)| {\n+            for constructor in used_constructors {\n+                if let Constructor::Enum(e) = constructor {\n+                    if id == e.local_id {\n+                        return true;\n+                    }\n+                }\n+            }\n+\n+            false\n+        }),\n+    }\n+}\n+\n+fn enum_variant_matches(cx: &MatchCheckCtx, pat_id: PatId, enum_variant_id: EnumVariantId) -> bool {\n+    Some(enum_variant_id.into()) == cx.infer.variant_resolution_for_pat(pat_id)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    pub(super) use insta::assert_snapshot;\n+    pub(super) use ra_db::fixture::WithFixture;\n+\n+    pub(super) use crate::test_db::TestDB;\n+\n+    pub(super) fn check_diagnostic_message(content: &str) -> String {\n+        TestDB::with_single_file(content).0.diagnostics().0\n+    }\n+\n+    pub(super) fn check_diagnostic(content: &str) {\n+        let diagnostic_count = TestDB::with_single_file(content).0.diagnostics().1;\n+\n+        assert_eq!(1, diagnostic_count, \"no diagnostic reported\");\n+    }\n+\n+    pub(super) fn check_no_diagnostic(content: &str) {\n+        let diagnostic_count = TestDB::with_single_file(content).0.diagnostics().1;\n+\n+        assert_eq!(0, diagnostic_count, \"expected no diagnostic, found one\");\n+    }\n+\n+    #[test]\n+    fn empty_tuple_no_arms_diagnostic_message() {\n+        let content = r\"\n+            fn test_fn() {\n+                match () {\n+                }\n+            }\n+        \";\n+\n+        assert_snapshot!(\n+            check_diagnostic_message(content),\n+            @\"\\\"()\\\": Missing match arm\\n\"\n+        );\n+    }\n+\n+    #[test]\n+    fn empty_tuple_no_arms() {\n+        let content = r\"\n+            fn test_fn() {\n+                match () {\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn empty_tuple_wild() {\n+        let content = r\"\n+            fn test_fn() {\n+                match () {\n+                    _ => {}\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn empty_tuple_no_diagnostic() {\n+        let content = r\"\n+            fn test_fn() {\n+                match () {\n+                    () => {}\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_empty_tuple_no_arms() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (()) {\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_empty_tuple_no_diagnostic() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (()) {\n+                    (()) => {}\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_two_empty_tuple_no_arms() {\n+        let content = r\"\n+            fn test_fn() {\n+                match ((), ()) {\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_two_empty_tuple_no_diagnostic() {\n+        let content = r\"\n+            fn test_fn() {\n+                match ((), ()) {\n+                    ((), ()) => {}\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn bool_no_arms() {\n+        let content = r\"\n+            fn test_fn() {\n+                match false {\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn bool_missing_arm() {\n+        let content = r\"\n+            fn test_fn() {\n+                match false {\n+                    true => {}\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn bool_no_diagnostic() {\n+        let content = r\"\n+            fn test_fn() {\n+                match false {\n+                    true => {}\n+                    false => {}\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_bools_no_arms() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (false, true) {\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_bools_missing_arms() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (false, true) {\n+                    (true, true) => {},\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_bools_missing_arm() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (false, true) {\n+                    (false, true) => {},\n+                    (false, false) => {},\n+                    (true, false) => {},\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_bools_with_wilds() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (false, true) {\n+                    (false, _) => {},\n+                    (true, false) => {},\n+                    (_, true) => {},\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_bools_no_diagnostic() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (false, true) {\n+                    (true, true) => {},\n+                    (true, false) => {},\n+                    (false, true) => {},\n+                    (false, false) => {},\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_bools_binding_missing_arms() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (false, true) {\n+                    (true, _x) => {},\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_bools_binding_no_diagnostic() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (false, true) {\n+                    (true, _x) => {},\n+                    (false, true) => {},\n+                    (false, false) => {},\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_tuple_and_bools_no_arms() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (false, ((), false)) {\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_tuple_and_bools_missing_arms() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (false, ((), false)) {\n+                    (true, ((), true)) => {},\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_tuple_and_bools_no_diagnostic() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (false, ((), false)) {\n+                    (true, ((), true)) => {},\n+                    (true, ((), false)) => {},\n+                    (false, ((), true)) => {},\n+                    (false, ((), false)) => {},\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_tuple_and_bools_wildcard_missing_arms() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (false, ((), false)) {\n+                    (true, _) => {},\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_tuple_and_bools_wildcard_no_diagnostic() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (false, ((), false)) {\n+                    (true, ((), true)) => {},\n+                    (true, ((), false)) => {},\n+                    (false, _) => {},\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_no_arms() {\n+        let content = r\"\n+            enum Either {\n+                A,\n+                B,\n+            }\n+            fn test_fn() {\n+                match Either::A {\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_missing_arms() {\n+        let content = r\"\n+            enum Either {\n+                A,\n+                B,\n+            }\n+            fn test_fn() {\n+                match Either::B {\n+                    Either::A => {},\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_no_diagnostic() {\n+        let content = r\"\n+            enum Either {\n+                A,\n+                B,\n+            }\n+            fn test_fn() {\n+                match Either::B {\n+                    Either::A => {},\n+                    Either::B => {},\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_ref_missing_arms() {\n+        let content = r\"\n+            enum Either {\n+                A,\n+                B,\n+            }\n+            fn test_fn() {\n+                match &Either::B {\n+                    Either::A => {},\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_ref_no_diagnostic() {\n+        let content = r\"\n+            enum Either {\n+                A,\n+                B,\n+            }\n+            fn test_fn() {\n+                match &Either::B {\n+                    Either::A => {},\n+                    Either::B => {},\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_containing_bool_no_arms() {\n+        let content = r\"\n+            enum Either {\n+                A(bool),\n+                B,\n+            }\n+            fn test_fn() {\n+                match Either::B {\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_containing_bool_missing_arms() {\n+        let content = r\"\n+            enum Either {\n+                A(bool),\n+                B,\n+            }\n+            fn test_fn() {\n+                match Either::B {\n+                    Either::A(true) => (),\n+                    Either::B => (),\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_containing_bool_no_diagnostic() {\n+        let content = r\"\n+            enum Either {\n+                A(bool),\n+                B,\n+            }\n+            fn test_fn() {\n+                match Either::B {\n+                    Either::A(true) => (),\n+                    Either::A(false) => (),\n+                    Either::B => (),\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_containing_bool_with_wild_no_diagnostic() {\n+        let content = r\"\n+            enum Either {\n+                A(bool),\n+                B,\n+            }\n+            fn test_fn() {\n+                match Either::B {\n+                    Either::B => (),\n+                    _ => (),\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_containing_bool_with_wild_2_no_diagnostic() {\n+        let content = r\"\n+            enum Either {\n+                A(bool),\n+                B,\n+            }\n+            fn test_fn() {\n+                match Either::B {\n+                    Either::A(_) => (),\n+                    Either::B => (),\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_different_sizes_missing_arms() {\n+        let content = r\"\n+            enum Either {\n+                A(bool),\n+                B(bool, bool),\n+            }\n+            fn test_fn() {\n+                match Either::A(false) {\n+                    Either::A(_) => (),\n+                    Either::B(false, _) => (),\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_different_sizes_no_diagnostic() {\n+        let content = r\"\n+            enum Either {\n+                A(bool),\n+                B(bool, bool),\n+            }\n+            fn test_fn() {\n+                match Either::A(false) {\n+                    Either::A(_) => (),\n+                    Either::B(true, _) => (),\n+                    Either::B(false, _) => (),\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn or_no_diagnostic() {\n+        let content = r\"\n+            enum Either {\n+                A(bool),\n+                B(bool, bool),\n+            }\n+            fn test_fn() {\n+                match Either::A(false) {\n+                    Either::A(true) | Either::A(false) => (),\n+                    Either::B(true, _) => (),\n+                    Either::B(false, _) => (),\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_enum_no_diagnostic() {\n+        let content = r\"\n+            enum Either {\n+                A(bool),\n+                B(bool, bool),\n+            }\n+            enum Either2 {\n+                C,\n+                D,\n+            }\n+            fn test_fn() {\n+                match (Either::A(false), Either2::C) {\n+                    (Either::A(true), _) | (Either::A(false), _) => (),\n+                    (Either::B(true, _), Either2::C) => (),\n+                    (Either::B(false, _), Either2::C) => (),\n+                    (Either::B(_, _), Either2::D) => (),\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn mismatched_types() {\n+        let content = r\"\n+            enum Either {\n+                A,\n+                B,\n+            }\n+            enum Either2 {\n+                C,\n+                D,\n+            }\n+            fn test_fn() {\n+                match Either::A {\n+                    Either2::C => (),\n+                    Either2::D => (),\n+                }\n+            }\n+        \";\n+\n+        // Match arms with the incorrect type are filtered out.\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn mismatched_types_with_different_arity() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (true, false) {\n+                    (true, false, true) => (),\n+                    (true) => (),\n+                }\n+            }\n+        \";\n+\n+        // Match arms with the incorrect type are filtered out.\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_not_in_scope() {\n+        let content = r\"\n+            fn test_fn() {\n+                match Foo::Bar {\n+                    Foo::Baz => (),\n+                }\n+            }\n+        \";\n+\n+        // The enum is not in scope so we don't perform exhaustiveness\n+        // checking, but we want to be sure we don't panic here (and\n+        // we don't create a diagnostic).\n+        check_no_diagnostic(content);\n+    }\n+}\n+\n+#[cfg(test)]\n+mod false_negatives {\n+    //! The implementation of match checking here is a work in progress. As we roll this out, we\n+    //! prefer false negatives to false positives (ideally there would be no false positives). This\n+    //! test module should document known false negatives. Eventually we will have a complete\n+    //! implementation of match checking and this module will be empty.\n+    //!\n+    //! The reasons for documenting known false negatives:\n+    //!\n+    //!   1. It acts as a backlog of work that can be done to improve the behavior of the system.\n+    //!   2. It ensures the code doesn't panic when handling these cases.\n+\n+    use super::tests::*;\n+\n+    #[test]\n+    fn integers() {\n+        let content = r\"\n+            fn test_fn() {\n+                match 5 {\n+                    10 => (),\n+                    11..20 => (),\n+                }\n+            }\n+        \";\n+\n+        // This is a false negative.\n+        // We don't currently check integer exhaustiveness.\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_record() {\n+        let content = r\"\n+            enum Either {\n+                A { foo: u32 },\n+                B,\n+            }\n+            fn test_fn() {\n+                match Either::B {\n+                    Either::A { foo: 5 } => (),\n+                }\n+            }\n+        \";\n+\n+        // This is a false negative.\n+        // We don't currently handle enum record types.\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn internal_or() {\n+        let content = r\"\n+            fn test_fn() {\n+                enum Either {\n+                    A(bool),\n+                    B,\n+                }\n+                match Either::B {\n+                    Either::A(true | false) => (),\n+                }\n+            }\n+        \";\n+\n+        // This is a false negative.\n+        // We do not currently handle patterns with internal `or`s.\n+        check_no_diagnostic(content);\n+    }\n+}"}, {"sha": "8cbce11686c1baebb3ddef9eaa03abb6e9b21067", "filename": "crates/ra_hir_ty/src/diagnostics.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/97b963b44b9da1fca4229da4c8744fa88c25780b/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97b963b44b9da1fca4229da4c8744fa88c25780b/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs?ref=97b963b44b9da1fca4229da4c8744fa88c25780b", "patch": "@@ -6,7 +6,7 @@ use hir_expand::{db::AstDatabase, name::Name, HirFileId, InFile};\n use ra_syntax::{ast, AstNode, AstPtr, SyntaxNodePtr};\n use stdx::format_to;\n \n-pub use hir_def::diagnostics::UnresolvedModule;\n+pub use hir_def::{diagnostics::UnresolvedModule, expr::MatchArm};\n pub use hir_expand::diagnostics::{AstDiagnostic, Diagnostic, DiagnosticSink};\n \n #[derive(Debug)]\n@@ -62,6 +62,25 @@ impl AstDiagnostic for MissingFields {\n     }\n }\n \n+#[derive(Debug)]\n+pub struct MissingMatchArms {\n+    pub file: HirFileId,\n+    pub match_expr: AstPtr<ast::Expr>,\n+    pub arms: AstPtr<ast::MatchArmList>,\n+}\n+\n+impl Diagnostic for MissingMatchArms {\n+    fn message(&self) -> String {\n+        String::from(\"Missing match arm\")\n+    }\n+    fn source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile { file_id: self.file, value: self.match_expr.into() }\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+}\n+\n #[derive(Debug)]\n pub struct MissingOkInTailExpr {\n     pub file: HirFileId,"}, {"sha": "1e7395b16480c5a79f149e6a7ad9056161ddc4f6", "filename": "crates/ra_hir_ty/src/expr.rs", "status": "modified", "additions": 87, "deletions": 2, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/97b963b44b9da1fca4229da4c8744fa88c25780b/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97b963b44b9da1fca4229da4c8744fa88c25780b/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs?ref=97b963b44b9da1fca4229da4c8744fa88c25780b", "patch": "@@ -14,9 +14,10 @@ use rustc_hash::FxHashSet;\n \n use crate::{\n     db::HirDatabase,\n-    diagnostics::{MissingFields, MissingOkInTailExpr},\n+    diagnostics::{MissingFields, MissingMatchArms, MissingOkInTailExpr},\n     utils::variant_data,\n     ApplicationTy, InferenceResult, Ty, TypeCtor,\n+    _match::{is_useful, MatchCheckCtx, Matrix, PatStack, Usefulness},\n };\n \n pub use hir_def::{\n@@ -52,15 +53,99 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         for e in body.exprs.iter() {\n             if let (id, Expr::RecordLit { path, fields, spread }) = e {\n                 self.validate_record_literal(id, path, fields, *spread, db);\n+            } else if let (id, Expr::Match { expr, arms }) = e {\n+                self.validate_match(id, *expr, arms, db, self.infer.clone());\n             }\n         }\n \n         let body_expr = &body[body.body_expr];\n-        if let Expr::Block { statements: _, tail: Some(t) } = body_expr {\n+        if let Expr::Block { tail: Some(t), .. } = body_expr {\n             self.validate_results_in_tail_expr(body.body_expr, *t, db);\n         }\n     }\n \n+    fn validate_match(\n+        &mut self,\n+        id: ExprId,\n+        match_expr: ExprId,\n+        arms: &[MatchArm],\n+        db: &dyn HirDatabase,\n+        infer: Arc<InferenceResult>,\n+    ) {\n+        let (body, source_map): (Arc<Body>, Arc<BodySourceMap>) =\n+            db.body_with_source_map(self.func.into());\n+\n+        let match_expr_ty = match infer.type_of_expr.get(match_expr) {\n+            Some(ty) => ty,\n+            // If we can't resolve the type of the match expression\n+            // we cannot perform exhaustiveness checks.\n+            None => return,\n+        };\n+\n+        let cx = MatchCheckCtx { body, infer: infer.clone(), db };\n+        let pats = arms.iter().map(|arm| arm.pat);\n+\n+        let mut seen = Matrix::empty();\n+        for pat in pats {\n+            // We skip any patterns whose type we cannot resolve.\n+            //\n+            // This could lead to false positives in this diagnostic, so\n+            // it might be better to skip the entire diagnostic if we either\n+            // cannot resolve a match arm or determine that the match arm has\n+            // the wrong type.\n+            if let Some(pat_ty) = infer.type_of_pat.get(pat) {\n+                // We only include patterns whose type matches the type\n+                // of the match expression. If we had a InvalidMatchArmPattern\n+                // diagnostic or similar we could raise that in an else\n+                // block here.\n+                //\n+                // When comparing the types, we also have to consider that rustc\n+                // will automatically de-reference the match expression type if\n+                // necessary.\n+                //\n+                // FIXME we should use the type checker for this.\n+                if pat_ty == match_expr_ty\n+                    || match_expr_ty\n+                        .as_reference()\n+                        .map(|(match_expr_ty, _)| match_expr_ty == pat_ty)\n+                        .unwrap_or(false)\n+                {\n+                    // If we had a NotUsefulMatchArm diagnostic, we could\n+                    // check the usefulness of each pattern as we added it\n+                    // to the matrix here.\n+                    let v = PatStack::from_pattern(pat);\n+                    seen.push(&cx, v);\n+                }\n+            }\n+        }\n+\n+        match is_useful(&cx, &seen, &PatStack::from_wild()) {\n+            Ok(Usefulness::Useful) => (),\n+            // if a wildcard pattern is not useful, then all patterns are covered\n+            Ok(Usefulness::NotUseful) => return,\n+            // this path is for unimplemented checks, so we err on the side of not\n+            // reporting any errors\n+            _ => return,\n+        }\n+\n+        if let Ok(source_ptr) = source_map.expr_syntax(id) {\n+            if let Some(expr) = source_ptr.value.left() {\n+                let root = source_ptr.file_syntax(db.upcast());\n+                if let ast::Expr::MatchExpr(match_expr) = expr.to_node(&root) {\n+                    if let (Some(match_expr), Some(arms)) =\n+                        (match_expr.expr(), match_expr.match_arm_list())\n+                    {\n+                        self.sink.push(MissingMatchArms {\n+                            file: source_ptr.file_id,\n+                            match_expr: AstPtr::new(&match_expr),\n+                            arms: AstPtr::new(&arms),\n+                        })\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     fn validate_record_literal(\n         &mut self,\n         id: ExprId,"}, {"sha": "69bbb4307f59c11544f7ea388c1e1e8034fbfe39", "filename": "crates/ra_hir_ty/src/infer/pat.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/97b963b44b9da1fca4229da4c8744fa88c25780b/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97b963b44b9da1fca4229da4c8744fa88c25780b/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=97b963b44b9da1fca4229da4c8744fa88c25780b", "patch": "@@ -21,9 +21,13 @@ impl<'a> InferenceContext<'a> {\n         subpats: &[PatId],\n         expected: &Ty,\n         default_bm: BindingMode,\n+        id: PatId,\n     ) -> Ty {\n         let (ty, def) = self.resolve_variant(path);\n         let var_data = def.map(|it| variant_data(self.db.upcast(), it));\n+        if let Some(variant) = def {\n+            self.write_variant_resolution(id.into(), variant);\n+        }\n         self.unify(&ty, expected);\n \n         let substs = ty.substs().unwrap_or_else(Substs::empty);\n@@ -152,7 +156,7 @@ impl<'a> InferenceContext<'a> {\n                 Ty::apply_one(TypeCtor::Ref(*mutability), subty)\n             }\n             Pat::TupleStruct { path: p, args: subpats } => {\n-                self.infer_tuple_struct_pat(p.as_ref(), subpats, expected, default_bm)\n+                self.infer_tuple_struct_pat(p.as_ref(), subpats, expected, default_bm, pat)\n             }\n             Pat::Record { path: p, args: fields } => {\n                 self.infer_record_pat(p.as_ref(), fields, expected, default_bm, pat)"}, {"sha": "2b6bc0f798f79752ff3e871c40a97d377870c332", "filename": "crates/ra_hir_ty/src/infer/path.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/97b963b44b9da1fca4229da4c8744fa88c25780b/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97b963b44b9da1fca4229da4c8744fa88c25780b/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=97b963b44b9da1fca4229da4c8744fa88c25780b", "patch": "@@ -67,8 +67,16 @@ impl<'a> InferenceContext<'a> {\n             ValueNs::FunctionId(it) => it.into(),\n             ValueNs::ConstId(it) => it.into(),\n             ValueNs::StaticId(it) => it.into(),\n-            ValueNs::StructId(it) => it.into(),\n-            ValueNs::EnumVariantId(it) => it.into(),\n+            ValueNs::StructId(it) => {\n+                self.write_variant_resolution(id, it.into());\n+\n+                it.into()\n+            }\n+            ValueNs::EnumVariantId(it) => {\n+                self.write_variant_resolution(id, it.into());\n+\n+                it.into()\n+            }\n         };\n \n         let ty = self.db.value_ty(typable);"}, {"sha": "18f74d3b12bd47c2145ef72cfc12b47cbfb01927", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/97b963b44b9da1fca4229da4c8744fa88c25780b/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97b963b44b9da1fca4229da4c8744fa88c25780b/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=97b963b44b9da1fca4229da4c8744fa88c25780b", "patch": "@@ -43,6 +43,7 @@ mod tests;\n #[cfg(test)]\n mod test_db;\n mod marks;\n+mod _match;\n \n use std::ops::Deref;\n use std::sync::Arc;"}, {"sha": "3a4d58bf9c4ffae26eb29326a6a346558a929b0c", "filename": "crates/ra_hir_ty/src/test_db.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/97b963b44b9da1fca4229da4c8744fa88c25780b/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97b963b44b9da1fca4229da4c8744fa88c25780b/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs?ref=97b963b44b9da1fca4229da4c8744fa88c25780b", "patch": "@@ -105,8 +105,9 @@ impl TestDB {\n     }\n \n     // FIXME: don't duplicate this\n-    pub fn diagnostics(&self) -> String {\n+    pub fn diagnostics(&self) -> (String, u32) {\n         let mut buf = String::new();\n+        let mut count = 0;\n         let crate_graph = self.crate_graph();\n         for krate in crate_graph.iter() {\n             let crate_def_map = self.crate_def_map(krate);\n@@ -133,13 +134,14 @@ impl TestDB {\n                 let infer = self.infer(f.into());\n                 let mut sink = DiagnosticSink::new(|d| {\n                     format_to!(buf, \"{:?}: {}\\n\", d.syntax_node(self).text(), d.message());\n+                    count += 1;\n                 });\n                 infer.add_diagnostics(self, f, &mut sink);\n                 let mut validator = ExprValidator::new(f, infer, &mut sink);\n                 validator.validate_body(self);\n             }\n         }\n-        buf\n+        (buf, count)\n     }\n }\n "}, {"sha": "e4a103d1be100d328b587ee16be555ca297fb53b", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/97b963b44b9da1fca4229da4c8744fa88c25780b/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97b963b44b9da1fca4229da4c8744fa88c25780b/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=97b963b44b9da1fca4229da4c8744fa88c25780b", "patch": "@@ -309,7 +309,8 @@ fn no_such_field_diagnostics() {\n         }\n         \",\n     )\n-    .diagnostics();\n+    .diagnostics()\n+    .0;\n \n     assert_snapshot!(diagnostics, @r###\"\n     \"baz: 62\": no such field"}, {"sha": "901ad104c10f24d4bd0725b02a38c00f9b4bbaca", "filename": "crates/ra_ide/src/diagnostics.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/97b963b44b9da1fca4229da4c8744fa88c25780b/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97b963b44b9da1fca4229da4c8744fa88c25780b/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs?ref=97b963b44b9da1fca4229da4c8744fa88c25780b", "patch": "@@ -101,6 +101,14 @@ pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic>\n             fix,\n         })\n     })\n+    .on::<hir::diagnostics::MissingMatchArms, _>(|d| {\n+        res.borrow_mut().push(Diagnostic {\n+            range: d.highlight_range(),\n+            message: d.message(),\n+            severity: Severity::Error,\n+            fix: None,\n+        })\n+    })\n     .on::<hir::diagnostics::MissingOkInTailExpr, _>(|d| {\n         let node = d.ast(db);\n         let replacement = format!(\"Ok({})\", node.syntax());\n@@ -291,7 +299,7 @@ mod tests {\n     fn check_no_diagnostic(content: &str) {\n         let (analysis, file_id) = single_file(content);\n         let diagnostics = analysis.diagnostics(file_id).unwrap();\n-        assert_eq!(diagnostics.len(), 0);\n+        assert_eq!(diagnostics.len(), 0, \"expected no diagnostic, found one\");\n     }\n \n     #[test]"}]}