{"sha": "759bd01e039452a1a357d347aea51348f9ffc443", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1OWJkMDFlMDM5NDUyYTFhMzU3ZDM0N2FlYTUxMzQ4ZjlmZmM0NDM=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-01-30T05:30:39Z"}, "committer": {"name": "flip1995", "email": "uwdkn@student.kit.edu", "date": "2018-05-02T09:32:34Z"}, "message": "Allow Path for name of MetaItem", "tree": {"sha": "899d72c77c451e784e48534c2502c8b49643deaf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/899d72c77c451e784e48534c2502c8b49643deaf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/759bd01e039452a1a357d347aea51348f9ffc443", "comment_count": 0, "verification": {"verified": false, "reason": "unverified_email", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEz66kzxK9mXB0K2lyZ1erJvcvAIQFAlrphbIACgkQZ1erJvcv\nAIQHARAAoQ9X9CA2Q7/WuAQL9JgNLU08asYerv1vs33uyj0ZM6aKxC5iy9CiKd08\nCGk7vesl2/Y6DZu0NkfQ3HX8oUMd9BBd2B3MnZlFKX2YyLFuWTEywClYnXizMAxY\njYsR/XpuFG+6gAJpl+FjghMotRX9mvbRaXvvKgktG3KmMTNQ19co3JiJmtxACvM5\nXGXV9U7Cr55OqZV4HqLoa2N1Tud4fWiF7F/BKnTDUKZv/aPdTcMYoLDY5xKJ5Uur\nE6EkgbHdHfhhCAJJIm15zeXfNa2lKUnnJnKk9I8p4qfSO9amGwYSKPTvc6RqHX9h\nrbRfivgV5puHZHHwcF7kOpfzq8fopa/39+uj22/0wvBqc3/EyVW7SPR7N0lnkmUv\nZg/tz+302Vy6jc5sw+tQsarLbscyeYyMWXUcqEDPN6gX6O+YWGkuJBH7bFRotYRU\nrw2zxum+yghNV1TsVbsyU6DGmadC4jTIW/a7A1c90bmDNwQOXwf1UX1fHirTIk8V\nTi6WMFSxFv5eP/eKi4RBdA/jJoRNkYua4nuQgRvndJDZCYIYpx6Kp4uA1t0l7HTV\nuldmA5+cb8RkxCCv9m805h/cS7zT76c9rtUmAfUXcetL/zn1jdlMa1aNFzPixL0p\nM7zPJa07/L/RGxeDq//apZUuGj/FOmcivpcu2n9NNc6dyLyCLFg=\n=zuAc\n-----END PGP SIGNATURE-----", "payload": "tree 899d72c77c451e784e48534c2502c8b49643deaf\nparent e27d20a7ba01a67d7b46ff0edef2fa53f5421035\nauthor Seiichi Uchida <seuchida@gmail.com> 1517290239 +0900\ncommitter flip1995 <uwdkn@student.kit.edu> 1525253554 +0200\n\nAllow Path for name of MetaItem\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/759bd01e039452a1a357d347aea51348f9ffc443", "html_url": "https://github.com/rust-lang/rust/commit/759bd01e039452a1a357d347aea51348f9ffc443", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/759bd01e039452a1a357d347aea51348f9ffc443/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e27d20a7ba01a67d7b46ff0edef2fa53f5421035", "url": "https://api.github.com/repos/rust-lang/rust/commits/e27d20a7ba01a67d7b46ff0edef2fa53f5421035", "html_url": "https://github.com/rust-lang/rust/commit/e27d20a7ba01a67d7b46ff0edef2fa53f5421035"}], "stats": {"total": 211, "additions": 141, "deletions": 70}, "files": [{"sha": "ed7b79b392d89f5153cb997378fd3b9fafa65f3e", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/759bd01e039452a1a357d347aea51348f9ffc443/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/759bd01e039452a1a357d347aea51348f9ffc443/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=759bd01e039452a1a357d347aea51348f9ffc443", "patch": "@@ -211,6 +211,17 @@ impl<'a> HashStable<StableHashingContext<'a>> for [ast::Attribute] {\n     }\n }\n \n+impl<'a> HashStable<StableHashingContext<'a>> for ast::Path {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.segments.len().hash_stable(hcx, hasher);\n+        for segment in &self.segments {\n+            segment.identifier.name.hash_stable(hcx, hasher);\n+        }\n+    }\n+}\n+\n impl<'a> HashStable<StableHashingContext<'a>> for ast::Attribute {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n@@ -229,10 +240,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for ast::Attribute {\n         } = *self;\n \n         style.hash_stable(hcx, hasher);\n-        path.segments.len().hash_stable(hcx, hasher);\n-        for segment in &path.segments {\n-            segment.ident.name.hash_stable(hcx, hasher);\n-        }\n+        path.hash_stable(hcx, hasher);\n         for tt in tokens.trees() {\n             tt.hash_stable(hcx, hasher);\n         }"}, {"sha": "67ba55a6aabd2e66c83f3651777cbcbcd41b13a1", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/759bd01e039452a1a357d347aea51348f9ffc443/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/759bd01e039452a1a357d347aea51348f9ffc443/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=759bd01e039452a1a357d347aea51348f9ffc443", "patch": "@@ -1060,7 +1060,7 @@ impl RustcDefaultCalls {\n                     let mut cfgs = Vec::new();\n                     for &(name, ref value) in sess.parse_sess.config.iter() {\n                         let gated_cfg = GatedCfg::gate(&ast::MetaItem {\n-                            ident: ast::Ident::with_empty_ctxt(name),\n+                            name: ast::Path::from_ident(DUMMY_SP, name.to_ident()),\n                             node: ast::MetaItemKind::Word,\n                             span: DUMMY_SP,\n                         });"}, {"sha": "35228748f06627a3892bc059a535eb62258db072", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/759bd01e039452a1a357d347aea51348f9ffc443/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/759bd01e039452a1a357d347aea51348f9ffc443/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=759bd01e039452a1a357d347aea51348f9ffc443", "patch": "@@ -235,7 +235,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n             if name == \"derive\" {\n                 let result = attrs[i].parse_list(&self.session.parse_sess, |parser| {\n-                    parser.parse_path_allowing_meta(PathStyle::Mod)\n+                    parser.parse_path(PathStyle::Mod)\n                 });\n \n                 let mut traits = match result {"}, {"sha": "bc457f49fcffda325941eeae5760eb4f77818114", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/759bd01e039452a1a357d347aea51348f9ffc443/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/759bd01e039452a1a357d347aea51348f9ffc443/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=759bd01e039452a1a357d347aea51348f9ffc443", "patch": "@@ -474,10 +474,10 @@ pub enum NestedMetaItemKind {\n \n /// A spanned compile-time attribute item.\n ///\n-/// E.g. `#[test]`, `#[derive(..)]` or `#[feature = \"foo\"]`\n+/// E.g. `#[test]`, `#[derive(..)]`, `#[rustfmt::skip]` or `#[feature = \"foo\"]`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct MetaItem {\n-    pub ident: Ident,\n+    pub name: Path,\n     pub node: MetaItemKind,\n     pub span: Span,\n }"}, {"sha": "7a0231dc3f44773a8968d1443d94812c5d274cec", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 99, "deletions": 40, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/759bd01e039452a1a357d347aea51348f9ffc443/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/759bd01e039452a1a357d347aea51348f9ffc443/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=759bd01e039452a1a357d347aea51348f9ffc443", "patch": "@@ -137,7 +137,7 @@ impl NestedMetaItem {\n     /// Returns the name of the meta item, e.g. `foo` in `#[foo]`,\n     /// `#[foo=\"bar\"]` and `#[foo(bar)]`, if self is a MetaItem\n     pub fn name(&self) -> Option<Name> {\n-        self.meta_item().and_then(|meta_item| Some(meta_item.ident.name))\n+        self.meta_item().and_then(|meta_item| Some(meta_item.name()))\n     }\n \n     /// Gets the string value if self is a MetaItem and the MetaItem is a\n@@ -154,7 +154,7 @@ impl NestedMetaItem {\n                     if meta_item_list.len() == 1 {\n                         let nested_item = &meta_item_list[0];\n                         if nested_item.is_literal() {\n-                            Some((meta_item.ident.name, nested_item.literal().unwrap()))\n+                            Some((meta_item.name(), nested_item.literal().unwrap()))\n                         } else {\n                             None\n                         }\n@@ -204,6 +204,10 @@ impl NestedMetaItem {\n     }\n }\n \n+fn name_from_path(path: &ast::Path) -> Name {\n+    path.segments.iter().next().unwrap().identifier.name\n+}\n+\n impl Attribute {\n     pub fn check_name(&self, name: &str) -> bool {\n         let matches = self.path == name;\n@@ -215,7 +219,7 @@ impl Attribute {\n \n     pub fn name(&self) -> Option<Name> {\n         match self.path.segments.len() {\n-            1 => Some(self.path.segments[0].ident.name),\n+            1 => Some(self.path.segments[0].identifier.name),\n             _ => None,\n         }\n     }\n@@ -250,6 +254,10 @@ impl Attribute {\n }\n \n impl MetaItem {\n+    pub fn name(&self) -> Name {\n+        name_from_path(&self.name)\n+    }\n+\n     pub fn value_str(&self) -> Option<Symbol> {\n         match self.node {\n             MetaItemKind::NameValue(ref v) => {\n@@ -279,7 +287,7 @@ impl MetaItem {\n     pub fn span(&self) -> Span { self.span }\n \n     pub fn check_name(&self, name: &str) -> bool {\n-        self.ident.name == name\n+        self.name() == name\n     }\n \n     pub fn is_value_str(&self) -> bool {\n@@ -296,10 +304,7 @@ impl Attribute {\n     pub fn meta(&self) -> Option<MetaItem> {\n         let mut tokens = self.tokens.trees().peekable();\n         Some(MetaItem {\n-            ident: match self.path.segments.len() {\n-                1 => self.path.segments[0].ident,\n-                _ => return None,\n-            },\n+            name: self.path.clone(),\n             node: if let Some(node) = MetaItemKind::from_tokens(&mut tokens) {\n                 if tokens.peek().is_some() {\n                     return None;\n@@ -344,12 +349,8 @@ impl Attribute {\n     }\n \n     pub fn parse_meta<'a>(&self, sess: &'a ParseSess) -> PResult<'a, MetaItem> {\n-        if self.path.segments.len() > 1 {\n-            sess.span_diagnostic.span_err(self.path.span, \"expected ident, found path\");\n-        }\n-\n         Ok(MetaItem {\n-            ident: self.path.segments.last().unwrap().ident,\n+            name: self.path.clone(),\n             node: self.parse(sess, |parser| parser.parse_meta_item_kind())?,\n             span: self.span,\n         })\n@@ -397,8 +398,31 @@ pub fn mk_list_item(span: Span, ident: Ident, items: Vec<NestedMetaItem>) -> Met\n pub fn mk_word_item(ident: Ident) -> MetaItem {\n     MetaItem { ident, span: ident.span, node: MetaItemKind::Word }\n }\n-pub fn mk_nested_word_item(ident: Ident) -> NestedMetaItem {\n-    respan(ident.span, NestedMetaItemKind::MetaItem(mk_word_item(ident)))\n+\n+pub fn mk_word_item(name: Name) -> MetaItem {\n+    mk_spanned_word_item(DUMMY_SP, name)\n+}\n+\n+macro_rules! mk_spanned_meta_item {\n+    ($sp:ident, $name:ident, $node:expr) => {\n+        MetaItem {\n+            span: $sp,\n+            name: ast::Path::from_ident($sp, ast::Ident::with_empty_ctxt($name)),\n+            node: $node,\n+        }\n+    }\n+}\n+\n+pub fn mk_spanned_name_value_item(sp: Span, name: Name, value: ast::Lit) -> MetaItem {\n+    mk_spanned_meta_item!(sp, name, MetaItemKind::NameValue(value))\n+}\n+\n+pub fn mk_spanned_list_item(sp: Span, name: Name, items: Vec<NestedMetaItem>) -> MetaItem {\n+    mk_spanned_meta_item!(sp, name, MetaItemKind::List(items))\n+}\n+\n+pub fn mk_spanned_word_item(sp: Span, name: Name) -> MetaItem {\n+    mk_spanned_meta_item!(sp, name, MetaItemKind::Word)\n }\n \n pub fn mk_attr_id() -> AttrId {\n@@ -422,7 +446,7 @@ pub fn mk_spanned_attr_inner(sp: Span, id: AttrId, item: MetaItem) -> Attribute\n     Attribute {\n         id,\n         style: ast::AttrStyle::Inner,\n-        path: ast::Path::from_ident(item.ident),\n+        path: item.name,\n         tokens: item.node.tokens(item.span),\n         is_sugared_doc: false,\n         span: sp,\n@@ -440,7 +464,7 @@ pub fn mk_spanned_attr_outer(sp: Span, id: AttrId, item: MetaItem) -> Attribute\n     Attribute {\n         id,\n         style: ast::AttrStyle::Outer,\n-        path: ast::Path::from_ident(item.ident),\n+        path: item.name,\n         tokens: item.node.tokens(item.span),\n         is_sugared_doc: false,\n         span: sp,\n@@ -489,7 +513,7 @@ pub fn contains_feature_attr(attrs: &[Attribute], feature_name: &str) -> bool {\n         item.check_name(\"feature\") &&\n         item.meta_item_list().map(|list| {\n             list.iter().any(|mi| {\n-                mi.word().map(|w| w.ident.name == feature_name)\n+                mi.word().map(|w| w.name() == feature_name)\n                          .unwrap_or(false)\n             })\n         }).unwrap_or(false)\n@@ -562,7 +586,7 @@ pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Feat\n         if let (Some(feats), Some(gated_cfg)) = (features, GatedCfg::gate(cfg)) {\n             gated_cfg.check_and_emit(sess, feats);\n         }\n-        sess.config.contains(&(cfg.ident.name, cfg.value_str()))\n+        sess.config.contains(&(cfg.name(), cfg.value_str()))\n     })\n }\n \n@@ -583,7 +607,7 @@ pub fn eval_condition<F>(cfg: &ast::MetaItem, sess: &ParseSess, eval: &mut F)\n \n             // The unwraps below may look dangerous, but we've already asserted\n             // that they won't fail with the loop above.\n-            match &*cfg.ident.name.as_str() {\n+            match &*cfg.name().as_str() {\n                 \"any\" => mis.iter().any(|mi| {\n                     eval_condition(mi.meta_item().unwrap(), sess, eval)\n                 }),\n@@ -676,7 +700,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n             let meta = meta.as_ref().unwrap();\n             let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n                 if item.is_some() {\n-                    handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.ident.name));\n+                    handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.name()));\n                     return false\n                 }\n                 if let Some(v) = meta.value_str() {\n@@ -695,14 +719,14 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                     )+\n                     for meta in metas {\n                         if let Some(mi) = meta.meta_item() {\n-                            match &*mi.ident.name.as_str() {\n+                            match &*mi.name().as_str() {\n                                 $(\n                                     stringify!($name)\n                                         => if !get(mi, &mut $name) { continue 'outer },\n                                 )+\n                                 _ => {\n                                     handle_errors(diagnostic, mi.span,\n-                                                  AttrError::UnknownMetaItem(mi.ident.name));\n+                                                  AttrError::UnknownMetaItem(mi.name()));\n                                     continue 'outer\n                                 }\n                             }\n@@ -714,7 +738,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                 }\n             }\n \n-            match &*meta.ident.name.as_str() {\n+            match &*meta.name().as_str() {\n                 \"rustc_deprecated\" => {\n                     if rustc_depr.is_some() {\n                         span_err!(diagnostic, item_sp, E0540,\n@@ -769,13 +793,13 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                     let mut issue = None;\n                     for meta in metas {\n                         if let Some(mi) = meta.meta_item() {\n-                            match &*mi.ident.name.as_str() {\n+                            match &*mi.name().as_str() {\n                                 \"feature\" => if !get(mi, &mut feature) { continue 'outer },\n                                 \"reason\" => if !get(mi, &mut reason) { continue 'outer },\n                                 \"issue\" => if !get(mi, &mut issue) { continue 'outer },\n                                 _ => {\n                                     handle_errors(diagnostic, meta.span,\n-                                                  AttrError::UnknownMetaItem(mi.ident.name));\n+                                                  AttrError::UnknownMetaItem(mi.name()));\n                                     continue 'outer\n                                 }\n                             }\n@@ -825,12 +849,12 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                     let mut since = None;\n                     for meta in metas {\n                         if let NestedMetaItemKind::MetaItem(ref mi) = meta.node {\n-                            match &*mi.ident.name.as_str() {\n+                            match &*mi.name().as_str() {\n                                 \"feature\" => if !get(mi, &mut feature) { continue 'outer },\n                                 \"since\" => if !get(mi, &mut since) { continue 'outer },\n                                 _ => {\n                                     handle_errors(diagnostic, meta.span,\n-                                                  AttrError::UnknownMetaItem(mi.ident.name));\n+                                                  AttrError::UnknownMetaItem(mi.name()));\n                                     continue 'outer\n                                 }\n                             }\n@@ -917,7 +941,7 @@ fn find_deprecation_generic<'a, I>(diagnostic: &Handler,\n         depr = if let Some(metas) = attr.meta_item_list() {\n             let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n                 if item.is_some() {\n-                    handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.ident.name));\n+                    handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.name()));\n                     return false\n                 }\n                 if let Some(v) = meta.value_str() {\n@@ -933,12 +957,12 @@ fn find_deprecation_generic<'a, I>(diagnostic: &Handler,\n             let mut note = None;\n             for meta in metas {\n                 if let NestedMetaItemKind::MetaItem(ref mi) = meta.node {\n-                    match &*mi.ident.name.as_str() {\n+                    match &*mi.name().as_str() {\n                         \"since\" => if !get(mi, &mut since) { continue 'outer },\n                         \"note\" => if !get(mi, &mut note) { continue 'outer },\n                         _ => {\n                             handle_errors(diagnostic, meta.span,\n-                                          AttrError::UnknownMetaItem(mi.ident.name));\n+                                          AttrError::UnknownMetaItem(mi.name()));\n                             continue 'outer\n                         }\n                     }\n@@ -990,7 +1014,7 @@ pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr>\n \n                 let mut recognised = false;\n                 if let Some(mi) = item.word() {\n-                    let word = &*mi.ident.name.as_str();\n+                    let word = &*mi.name().as_str();\n                     let hint = match word {\n                         \"C\" => Some(ReprC),\n                         \"packed\" => Some(ReprPacked(1)),\n@@ -1127,18 +1151,52 @@ impl IntType {\n \n impl MetaItem {\n     fn tokens(&self) -> TokenStream {\n-        let ident = TokenTree::Token(self.span, Token::from_ast_ident(self.ident));\n-        TokenStream::concat(vec![ident.into(), self.node.tokens(self.span)])\n+        let mut idents = vec![];\n+        let mut last_pos = BytePos(0 as u32);\n+        for (i, segment) in self.name.segments.iter().enumerate() {\n+            let is_first = i == 0;\n+            if !is_first {\n+                let mod_sep_span = Span::new(last_pos, segment.span.lo(), segment.span.ctxt());\n+                idents.push(TokenTree::Token(mod_sep_span, Token::ModSep).into());\n+            }\n+            idents.push(TokenTree::Token(segment.span, Token::Ident(segment.identifier)).into());\n+            last_pos = segment.span.hi();\n+        }\n+        idents.push(self.node.tokens(self.span));\n+        TokenStream::concat(idents)\n     }\n \n     fn from_tokens<I>(tokens: &mut iter::Peekable<I>) -> Option<MetaItem>\n         where I: Iterator<Item = TokenTree>,\n     {\n-        let (span, ident) = match tokens.next() {\n-            Some(TokenTree::Token(span, Token::Ident(ident, _))) => (span, ident),\n+        let name = match tokens.next() {\n+            Some(TokenTree::Token(span, Token::Ident(ident))) => {\n+                if let Some(TokenTree::Token(_, Token::ModSep)) = tokens.peek() {\n+                    tokens.next();\n+                    let mut segments = vec![];\n+                    loop {\n+                        if let Some(TokenTree::Token(span, Token::Ident(ident))) = tokens.next() {\n+                            segments.push(ast::PathSegment::from_ident(ident, span));\n+                        } else {\n+                            return None;\n+                        }\n+                        if let Some(TokenTree::Token(_, Token::ModSep)) = tokens.peek() {\n+                            tokens.next();\n+                        } else {\n+                            break;\n+                        }\n+                    }\n+                    ast::Path { span, segments }\n+                } else {\n+                    ast::Path::from_ident(span, ident)\n+                }\n+            }\n             Some(TokenTree::Token(_, Token::Interpolated(ref nt))) => match nt.0 {\n-                token::Nonterminal::NtIdent(ident, _) => (ident.span, ident),\n+                token::Nonterminal::NtIdent(ident) => {\n+                    ast::Path::from_ident(ident.span, ident.node)\n+                }\n                 token::Nonterminal::NtMeta(ref meta) => return Some(meta.clone()),\n+                token::Nonterminal::NtPath(ref path) => path.clone(),\n                 _ => return None,\n             },\n             _ => return None,\n@@ -1147,10 +1205,11 @@ impl MetaItem {\n         let node = MetaItemKind::from_tokens(tokens)?;\n         let hi = match node {\n             MetaItemKind::NameValue(ref lit) => lit.span.hi(),\n-            MetaItemKind::List(..) => list_closing_paren_pos.unwrap_or(span.hi()),\n-            _ => span.hi(),\n+            MetaItemKind::List(..) => list_closing_paren_pos.unwrap_or(name.span.hi()),\n+            _ => name.span.hi(),\n         };\n-        Some(MetaItem { ident, node, span: span.with_hi(hi) })\n+        let span = name.span.with_hi(hi);\n+        Some(MetaItem { name, node, span })\n     }\n }\n "}, {"sha": "afb233533bad667e793f85dceafdd63c42a8fe2d", "filename": "src/libsyntax/ext/derive.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/759bd01e039452a1a357d347aea51348f9ffc443/src%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/759bd01e039452a1a357d347aea51348f9ffc443/src%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderive.rs?ref=759bd01e039452a1a357d347aea51348f9ffc443", "patch": "@@ -26,8 +26,7 @@ pub fn collect_derives(cx: &mut ExtCtxt, attrs: &mut Vec<ast::Attribute>) -> Vec\n             return true;\n         }\n \n-        match attr.parse_list(cx.parse_sess,\n-                              |parser| parser.parse_path_allowing_meta(PathStyle::Mod)) {\n+        match attr.parse_list(cx.parse_sess, |parser| parser.parse_path(PathStyle::Mod)) {\n             Ok(ref traits) if traits.is_empty() => {\n                 cx.span_warn(attr.span, \"empty trait list in `derive`\");\n                 false"}, {"sha": "1d16a7eb0914594a6ee606fabd4454c618fccdd6", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/759bd01e039452a1a357d347aea51348f9ffc443/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/759bd01e039452a1a357d347aea51348f9ffc443/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=759bd01e039452a1a357d347aea51348f9ffc443", "patch": "@@ -810,7 +810,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 invoc.expansion_data.mark.set_expn_info(expn_info);\n                 let span = span.with_ctxt(self.cx.backtrace());\n                 let dummy = ast::MetaItem { // FIXME(jseyfried) avoid this\n-                    ident: keywords::Invalid.ident(),\n+                    name: Path::from_ident(DUMMY_SP, keywords::Invalid.ident()),\n                     span: DUMMY_SP,\n                     node: ast::MetaItemKind::Word,\n                 };"}, {"sha": "0671f29648f918c8db4df47c71a15cd96325ab54", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/759bd01e039452a1a357d347aea51348f9ffc443/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/759bd01e039452a1a357d347aea51348f9ffc443/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=759bd01e039452a1a357d347aea51348f9ffc443", "patch": "@@ -149,7 +149,7 @@ impl<'a> Parser<'a> {\n         };\n         Ok(if let Some(meta) = meta {\n             self.bump();\n-            (ast::Path::from_ident(meta.ident), meta.node.tokens(meta.span))\n+            (meta.name, meta.node.tokens(meta.span))\n         } else {\n             (self.parse_path(PathStyle::Mod)?, self.parse_tokens())\n         })\n@@ -225,9 +225,10 @@ impl<'a> Parser<'a> {\n         }\n \n         let lo = self.span;\n-        let ident = self.parse_ident()?;\n+        let name = self.parse_path(PathStyle::Mod)?;\n         let node = self.parse_meta_item_kind()?;\n-        Ok(ast::MetaItem { ident, node: node, span: lo.to(self.prev_span) })\n+        let span = lo.to(self.prev_span);\n+        Ok(ast::MetaItem { name, node, span })\n     }\n \n     pub fn parse_meta_item_kind(&mut self) -> PResult<'a, ast::MetaItemKind> {"}, {"sha": "e8beb7e442c0b7af72db7a4789c1ffefdff4750d", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/759bd01e039452a1a357d347aea51348f9ffc443/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/759bd01e039452a1a357d347aea51348f9ffc443/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=759bd01e039452a1a357d347aea51348f9ffc443", "patch": "@@ -714,6 +714,22 @@ pub trait PrintState<'a> {\n         Ok(())\n     }\n \n+    fn print_attribute_path(&mut self, path: &ast::Path) -> io::Result<()> {\n+        for (i, segment) in path.segments.iter().enumerate() {\n+            if i > 0 {\n+                self.writer().word(\"::\")?\n+            }\n+            if segment.identifier.name != keywords::CrateRoot.name() &&\n+               segment.identifier.name != keywords::DollarCrate.name()\n+            {\n+                self.writer().word(&segment.identifier.name.as_str())?;\n+            } else if segment.identifier.name == keywords::DollarCrate.name() {\n+                self.print_dollar_crate(segment.identifier.ctxt)?;\n+            }\n+        }\n+        Ok(())\n+    }\n+\n     fn print_attribute(&mut self, attr: &ast::Attribute) -> io::Result<()> {\n         self.print_attribute_inline(attr, false)\n     }\n@@ -735,17 +751,7 @@ pub trait PrintState<'a> {\n             if let Some(mi) = attr.meta() {\n                 self.print_meta_item(&mi)?\n             } else {\n-                for (i, segment) in attr.path.segments.iter().enumerate() {\n-                    if i > 0 {\n-                        self.writer().word(\"::\")?\n-                    }\n-                    if segment.ident.name != keywords::CrateRoot.name() &&\n-                       segment.ident.name != keywords::DollarCrate.name() {\n-                        self.writer().word(&segment.ident.name.as_str())?;\n-                    } else if segment.ident.name == keywords::DollarCrate.name() {\n-                        self.print_dollar_crate(segment.ident.span.ctxt())?;\n-                    }\n-                }\n+                self.print_attribute_path(&attr.path)?;\n                 self.writer().space()?;\n                 self.print_tts(attr.tokens.clone())?;\n             }\n@@ -767,16 +773,14 @@ pub trait PrintState<'a> {\n     fn print_meta_item(&mut self, item: &ast::MetaItem) -> io::Result<()> {\n         self.ibox(INDENT_UNIT)?;\n         match item.node {\n-            ast::MetaItemKind::Word => {\n-                self.writer().word(&item.ident.name.as_str())?;\n-            }\n+            ast::MetaItemKind::Word => self.print_attribute_path(&item.name)?,\n             ast::MetaItemKind::NameValue(ref value) => {\n-                self.word_space(&item.ident.name.as_str())?;\n+                self.print_attribute_path(&item.name)?;\n                 self.word_space(\"=\")?;\n                 self.print_literal(value)?;\n             }\n             ast::MetaItemKind::List(ref items) => {\n-                self.writer().word(&item.ident.name.as_str())?;\n+                self.print_attribute_path(&item.name)?;\n                 self.popen()?;\n                 self.commasep(Consistent,\n                               &items[..],"}]}