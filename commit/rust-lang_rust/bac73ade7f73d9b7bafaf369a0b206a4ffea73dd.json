{"sha": "bac73ade7f73d9b7bafaf369a0b206a4ffea73dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhYzczYWRlN2Y3M2Q5YjdiYWZhZjM2OWEwYjIwNmE0ZmZlYTczZGQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-09-03T12:17:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-03T12:17:58Z"}, "message": "Merge #1757\n\n1757: Assoc type bindings r=flodiebold a=flodiebold\n\nThis adds support for type bindings (bounds like `where T: Iterator<Item = u32>`).\r\n\r\nIt doesn't yet work in as many situations as I'd like because of some [Chalk problems](https://github.com/rust-lang/chalk/issues/234). But it works in some situations, and will at least not bitrot this way ;)\r\n\r\n(part of the problem is that we use `Normalize` to normalize associated types, but produce `ProjectionEq` goals from where clauses, so Chalk can't normalize using the environment; this would be fixed by using `ProjectionEq` for normalization, which I think is the 'proper' way, but then we'd run into those ambiguity problems everywhere...)\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "ddd1737a8e3f46fb8757bad1d8024469d3bf0a89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ddd1737a8e3f46fb8757bad1d8024469d3bf0a89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bac73ade7f73d9b7bafaf369a0b206a4ffea73dd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdbln2CRBK7hj4Ov3rIwAAdHIIAD1lg0AZf1U4e3ivKZN0Dj5c\nrzl2TL0yaZk37d/D6kb/CTjyaE38gQBQqkRg50U5jRg4dva8n6sQC8g/lXsfeKCJ\nnBZ+/1u5J+J9HJtOKTH/+43ktS4qDGxntYpR5uCWASZzEeSDXODmLsQ6eCO8mopV\nGUB3YL8KMVzUr1WPmOZWEUepJ5m1rAXC1SDCztsdwWTStSavneHsVlPypXW+hx3h\nIhWtnl4zaAlnCQHg6T8Jr8DrqQgP6biN//s0Vi2aecUYe00/KWH+6MvLG7z99EfT\ndSKBiBcjiTXczqSTpq+jkxiCiuodpZbzy1AApKFTaPC0ATLwuYYk14LYOzu0H0Y=\n=r2g1\n-----END PGP SIGNATURE-----\n", "payload": "tree ddd1737a8e3f46fb8757bad1d8024469d3bf0a89\nparent 1c0672b7f802c7e7814ba9a1b3b21ecf866343d6\nparent b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1567513078 +0000\ncommitter GitHub <noreply@github.com> 1567513078 +0000\n\nMerge #1757\n\n1757: Assoc type bindings r=flodiebold a=flodiebold\n\nThis adds support for type bindings (bounds like `where T: Iterator<Item = u32>`).\r\n\r\nIt doesn't yet work in as many situations as I'd like because of some [Chalk problems](https://github.com/rust-lang/chalk/issues/234). But it works in some situations, and will at least not bitrot this way ;)\r\n\r\n(part of the problem is that we use `Normalize` to normalize associated types, but produce `ProjectionEq` goals from where clauses, so Chalk can't normalize using the environment; this would be fixed by using `ProjectionEq` for normalization, which I think is the 'proper' way, but then we'd run into those ambiguity problems everywhere...)\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bac73ade7f73d9b7bafaf369a0b206a4ffea73dd", "html_url": "https://github.com/rust-lang/rust/commit/bac73ade7f73d9b7bafaf369a0b206a4ffea73dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bac73ade7f73d9b7bafaf369a0b206a4ffea73dd/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c0672b7f802c7e7814ba9a1b3b21ecf866343d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c0672b7f802c7e7814ba9a1b3b21ecf866343d6", "html_url": "https://github.com/rust-lang/rust/commit/1c0672b7f802c7e7814ba9a1b3b21ecf866343d6"}, {"sha": "b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d", "html_url": "https://github.com/rust-lang/rust/commit/b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d"}], "stats": {"total": 585, "additions": 427, "deletions": 158}, "files": [{"sha": "1fad5b23393f810723f942186fd299fbf007a887", "filename": "crates/ra_cli/src/analysis_stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac73ade7f73d9b7bafaf369a0b206a4ffea73dd/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac73ade7f73d9b7bafaf369a0b206a4ffea73dd/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs?ref=bac73ade7f73d9b7bafaf369a0b206a4ffea73dd", "patch": "@@ -1,7 +1,7 @@\n use std::{collections::HashSet, fmt::Write, path::Path, time::Instant};\n \n use ra_db::SourceDatabase;\n-use ra_hir::{Crate, HasBodySource, HasSource, HirDisplay, ImplItem, ModuleDef, Ty};\n+use ra_hir::{Crate, HasBodySource, HasSource, HirDisplay, ImplItem, ModuleDef, Ty, TypeWalk};\n use ra_syntax::AstNode;\n \n use crate::Result;"}, {"sha": "c3e5899216fce23213d731a46f5a57806cbb3f0d", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bac73ade7f73d9b7bafaf369a0b206a4ffea73dd/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac73ade7f73d9b7bafaf369a0b206a4ffea73dd/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=bac73ade7f73d9b7bafaf369a0b206a4ffea73dd", "patch": "@@ -69,7 +69,9 @@ pub use self::{\n     resolve::Resolution,\n     source_binder::{PathResolution, ScopeEntryWithSyntax, SourceAnalyzer},\n     source_id::{AstIdMap, ErasedFileAstId},\n-    ty::{display::HirDisplay, ApplicationTy, CallableDef, Substs, TraitRef, Ty, TypeCtor},\n+    ty::{\n+        display::HirDisplay, ApplicationTy, CallableDef, Substs, TraitRef, Ty, TypeCtor, TypeWalk,\n+    },\n     type_ref::Mutability,\n };\n "}, {"sha": "24316fc911b2d980c1c077e79f78b124d21a0dc4", "filename": "crates/ra_hir/src/path.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bac73ade7f73d9b7bafaf369a0b206a4ffea73dd/crates%2Fra_hir%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac73ade7f73d9b7bafaf369a0b206a4ffea73dd/crates%2Fra_hir%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fpath.rs?ref=bac73ade7f73d9b7bafaf369a0b206a4ffea73dd", "patch": "@@ -31,7 +31,8 @@ pub struct GenericArgs {\n     /// Self type. Otherwise, when we have a path `Trait<X, Y>`, the Self type\n     /// is left out.\n     pub has_self_type: bool,\n-    // someday also bindings\n+    /// Associated type bindings like in `Iterator<Item = T>`.\n+    pub bindings: Vec<(Name, TypeRef)>,\n }\n \n /// A single generic argument.\n@@ -170,16 +171,24 @@ impl GenericArgs {\n             let type_ref = TypeRef::from_ast_opt(type_arg.type_ref());\n             args.push(GenericArg::Type(type_ref));\n         }\n-        // lifetimes and assoc type args ignored for now\n-        if !args.is_empty() {\n-            Some(GenericArgs { args, has_self_type: false })\n-        } else {\n+        // lifetimes ignored for now\n+        let mut bindings = Vec::new();\n+        for assoc_type_arg in node.assoc_type_args() {\n+            if let Some(name_ref) = assoc_type_arg.name_ref() {\n+                let name = name_ref.as_name();\n+                let type_ref = TypeRef::from_ast_opt(assoc_type_arg.type_ref());\n+                bindings.push((name, type_ref));\n+            }\n+        }\n+        if args.is_empty() && bindings.is_empty() {\n             None\n+        } else {\n+            Some(GenericArgs { args, has_self_type: false, bindings })\n         }\n     }\n \n     pub(crate) fn empty() -> GenericArgs {\n-        GenericArgs { args: Vec::new(), has_self_type: false }\n+        GenericArgs { args: Vec::new(), has_self_type: false, bindings: Vec::new() }\n     }\n }\n "}, {"sha": "a3df0882783653533416c1fe0d0613c31599dd04", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 231, "deletions": 117, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/bac73ade7f73d9b7bafaf369a0b206a4ffea73dd/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac73ade7f73d9b7bafaf369a0b206a4ffea73dd/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=bac73ade7f73d9b7bafaf369a0b206a4ffea73dd", "patch": "@@ -120,12 +120,44 @@ pub struct ProjectionTy {\n     pub parameters: Substs,\n }\n \n+impl ProjectionTy {\n+    pub fn trait_ref(&self, db: &impl HirDatabase) -> TraitRef {\n+        TraitRef {\n+            trait_: self\n+                .associated_ty\n+                .parent_trait(db)\n+                .expect(\"projection ty without parent trait\"),\n+            substs: self.parameters.clone(),\n+        }\n+    }\n+}\n+\n+impl TypeWalk for ProjectionTy {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        self.parameters.walk(f);\n+    }\n+\n+    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n+        self.parameters.walk_mut(f);\n+    }\n+}\n+\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct UnselectedProjectionTy {\n     pub type_name: Name,\n     pub parameters: Substs,\n }\n \n+impl TypeWalk for UnselectedProjectionTy {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        self.parameters.walk(f);\n+    }\n+\n+    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n+        self.parameters.walk_mut(f);\n+    }\n+}\n+\n /// A type.\n ///\n /// See also the `TyKind` enum in rustc (librustc/ty/sty.rs), which represents\n@@ -282,20 +314,14 @@ impl TraitRef {\n     pub fn self_ty(&self) -> &Ty {\n         &self.substs[0]\n     }\n+}\n \n-    pub fn subst(mut self, substs: &Substs) -> TraitRef {\n-        self.substs.walk_mut(&mut |ty_mut| {\n-            let ty = mem::replace(ty_mut, Ty::Unknown);\n-            *ty_mut = ty.subst(substs);\n-        });\n-        self\n-    }\n-\n-    pub fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+impl TypeWalk for TraitRef {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n         self.substs.walk(f);\n     }\n \n-    pub fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n+    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n         self.substs.walk_mut(f);\n     }\n }\n@@ -306,6 +332,8 @@ impl TraitRef {\n pub enum GenericPredicate {\n     /// The given trait needs to be implemented for its type parameters.\n     Implemented(TraitRef),\n+    /// An associated type bindings like in `Iterator<Item = T>`.\n+    Projection(ProjectionPredicate),\n     /// We couldn't resolve the trait reference. (If some type parameters can't\n     /// be resolved, they will just be Unknown).\n     Error,\n@@ -319,25 +347,35 @@ impl GenericPredicate {\n         }\n     }\n \n-    pub fn subst(self, substs: &Substs) -> GenericPredicate {\n+    pub fn is_implemented(&self) -> bool {\n         match self {\n-            GenericPredicate::Implemented(trait_ref) => {\n-                GenericPredicate::Implemented(trait_ref.subst(substs))\n-            }\n-            GenericPredicate::Error => self,\n+            GenericPredicate::Implemented(_) => true,\n+            _ => false,\n         }\n     }\n \n-    pub fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+    pub fn trait_ref(&self, db: &impl HirDatabase) -> Option<TraitRef> {\n+        match self {\n+            GenericPredicate::Implemented(tr) => Some(tr.clone()),\n+            GenericPredicate::Projection(proj) => Some(proj.projection_ty.trait_ref(db)),\n+            GenericPredicate::Error => None,\n+        }\n+    }\n+}\n+\n+impl TypeWalk for GenericPredicate {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n         match self {\n             GenericPredicate::Implemented(trait_ref) => trait_ref.walk(f),\n+            GenericPredicate::Projection(projection_pred) => projection_pred.walk(f),\n             GenericPredicate::Error => {}\n         }\n     }\n \n-    pub fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n+    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n         match self {\n             GenericPredicate::Implemented(trait_ref) => trait_ref.walk_mut(f),\n+            GenericPredicate::Projection(projection_pred) => projection_pred.walk_mut(f),\n             GenericPredicate::Error => {}\n         }\n     }\n@@ -378,16 +416,16 @@ impl FnSig {\n     pub fn ret(&self) -> &Ty {\n         &self.params_and_return[self.params_and_return.len() - 1]\n     }\n+}\n \n-    /// Applies the given substitutions to all types in this signature and\n-    /// returns the result.\n-    pub fn subst(&self, substs: &Substs) -> FnSig {\n-        let result: Vec<_> =\n-            self.params_and_return.iter().map(|ty| ty.clone().subst(substs)).collect();\n-        FnSig { params_and_return: result.into() }\n+impl TypeWalk for FnSig {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        for t in self.params_and_return.iter() {\n+            t.walk(f);\n+        }\n     }\n \n-    pub fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n+    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n         // Without an Arc::make_mut_slice, we can't avoid the clone here:\n         let mut v: Vec<_> = self.params_and_return.iter().cloned().collect();\n         for t in &mut v {\n@@ -411,64 +449,6 @@ impl Ty {\n         Ty::apply(TypeCtor::Tuple { cardinality: 0 }, Substs::empty())\n     }\n \n-    pub fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        match self {\n-            Ty::Apply(a_ty) => {\n-                for t in a_ty.parameters.iter() {\n-                    t.walk(f);\n-                }\n-            }\n-            Ty::Projection(p_ty) => {\n-                for t in p_ty.parameters.iter() {\n-                    t.walk(f);\n-                }\n-            }\n-            Ty::UnselectedProjection(p_ty) => {\n-                for t in p_ty.parameters.iter() {\n-                    t.walk(f);\n-                }\n-            }\n-            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n-                for p in predicates.iter() {\n-                    p.walk(f);\n-                }\n-            }\n-            Ty::Param { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n-        }\n-        f(self);\n-    }\n-\n-    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n-        match self {\n-            Ty::Apply(a_ty) => {\n-                a_ty.parameters.walk_mut(f);\n-            }\n-            Ty::Projection(p_ty) => {\n-                p_ty.parameters.walk_mut(f);\n-            }\n-            Ty::UnselectedProjection(p_ty) => {\n-                p_ty.parameters.walk_mut(f);\n-            }\n-            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n-                let mut v: Vec<_> = predicates.iter().cloned().collect();\n-                for p in &mut v {\n-                    p.walk_mut(f);\n-                }\n-                *predicates = v.into();\n-            }\n-            Ty::Param { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n-        }\n-        f(self);\n-    }\n-\n-    fn fold(mut self, f: &mut impl FnMut(Ty) -> Ty) -> Ty {\n-        self.walk_mut(&mut |ty_mut| {\n-            let ty = mem::replace(ty_mut, Ty::Unknown);\n-            *ty_mut = f(ty);\n-        });\n-        self\n-    }\n-\n     pub fn as_reference(&self) -> Option<(&Ty, Mutability)> {\n         match self {\n             Ty::Apply(ApplicationTy { ctor: TypeCtor::Ref(mutability), parameters }) => {\n@@ -544,10 +524,53 @@ impl Ty {\n         }\n     }\n \n+    /// Returns the type parameters of this type if it has some (i.e. is an ADT\n+    /// or function); so if `self` is `Option<u32>`, this returns the `u32`.\n+    pub fn substs(&self) -> Option<Substs> {\n+        match self {\n+            Ty::Apply(ApplicationTy { parameters, .. }) => Some(parameters.clone()),\n+            _ => None,\n+        }\n+    }\n+\n+    /// If this is an `impl Trait` or `dyn Trait`, returns that trait.\n+    pub fn inherent_trait(&self) -> Option<Trait> {\n+        match self {\n+            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n+                predicates.iter().find_map(|pred| match pred {\n+                    GenericPredicate::Implemented(tr) => Some(tr.trait_),\n+                    _ => None,\n+                })\n+            }\n+            _ => None,\n+        }\n+    }\n+}\n+\n+/// This allows walking structures that contain types to do something with those\n+/// types, similar to Chalk's `Fold` trait.\n+pub trait TypeWalk {\n+    fn walk(&self, f: &mut impl FnMut(&Ty));\n+    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty));\n+\n+    fn fold(mut self, f: &mut impl FnMut(Ty) -> Ty) -> Self\n+    where\n+        Self: Sized,\n+    {\n+        self.walk_mut(&mut |ty_mut| {\n+            let ty = mem::replace(ty_mut, Ty::Unknown);\n+            *ty_mut = f(ty);\n+        });\n+        self\n+    }\n+\n     /// Replaces type parameters in this type using the given `Substs`. (So e.g.\n     /// if `self` is `&[T]`, where type parameter T has index 0, and the\n     /// `Substs` contain `u32` at index 0, we'll have `&[u32]` afterwards.)\n-    pub fn subst(self, substs: &Substs) -> Ty {\n+    fn subst(self, substs: &Substs) -> Self\n+    where\n+        Self: Sized,\n+    {\n         self.fold(&mut |ty| match ty {\n             Ty::Param { idx, name } => {\n                 substs.get(idx as usize).cloned().unwrap_or(Ty::Param { idx, name })\n@@ -557,24 +580,21 @@ impl Ty {\n     }\n \n     /// Substitutes `Ty::Bound` vars (as opposed to type parameters).\n-    pub fn subst_bound_vars(self, substs: &Substs) -> Ty {\n+    fn subst_bound_vars(self, substs: &Substs) -> Self\n+    where\n+        Self: Sized,\n+    {\n         self.fold(&mut |ty| match ty {\n             Ty::Bound(idx) => substs.get(idx as usize).cloned().unwrap_or_else(|| Ty::Bound(idx)),\n             ty => ty,\n         })\n     }\n \n-    /// Returns the type parameters of this type if it has some (i.e. is an ADT\n-    /// or function); so if `self` is `Option<u32>`, this returns the `u32`.\n-    pub fn substs(&self) -> Option<Substs> {\n-        match self {\n-            Ty::Apply(ApplicationTy { parameters, .. }) => Some(parameters.clone()),\n-            _ => None,\n-        }\n-    }\n-\n     /// Shifts up `Ty::Bound` vars by `n`.\n-    pub fn shift_bound_vars(self, n: i32) -> Ty {\n+    fn shift_bound_vars(self, n: i32) -> Self\n+    where\n+        Self: Sized,\n+    {\n         self.fold(&mut |ty| match ty {\n             Ty::Bound(idx) => {\n                 assert!(idx as i32 >= -n);\n@@ -583,18 +603,57 @@ impl Ty {\n             ty => ty,\n         })\n     }\n+}\n \n-    /// If this is an `impl Trait` or `dyn Trait`, returns that trait.\n-    pub fn inherent_trait(&self) -> Option<Trait> {\n+impl TypeWalk for Ty {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        match self {\n+            Ty::Apply(a_ty) => {\n+                for t in a_ty.parameters.iter() {\n+                    t.walk(f);\n+                }\n+            }\n+            Ty::Projection(p_ty) => {\n+                for t in p_ty.parameters.iter() {\n+                    t.walk(f);\n+                }\n+            }\n+            Ty::UnselectedProjection(p_ty) => {\n+                for t in p_ty.parameters.iter() {\n+                    t.walk(f);\n+                }\n+            }\n+            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n+                for p in predicates.iter() {\n+                    p.walk(f);\n+                }\n+            }\n+            Ty::Param { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n+        }\n+        f(self);\n+    }\n+\n+    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n         match self {\n+            Ty::Apply(a_ty) => {\n+                a_ty.parameters.walk_mut(f);\n+            }\n+            Ty::Projection(p_ty) => {\n+                p_ty.parameters.walk_mut(f);\n+            }\n+            Ty::UnselectedProjection(p_ty) => {\n+                p_ty.parameters.walk_mut(f);\n+            }\n             Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n-                predicates.iter().find_map(|pred| match pred {\n-                    GenericPredicate::Implemented(tr) => Some(tr.trait_),\n-                    _ => None,\n-                })\n+                let mut v: Vec<_> = predicates.iter().cloned().collect();\n+                for p in &mut v {\n+                    p.walk_mut(f);\n+                }\n+                *predicates = v.into();\n             }\n-            _ => None,\n+            Ty::Param { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n         }\n+        f(self);\n     }\n }\n \n@@ -742,20 +801,66 @@ impl HirDisplay for Ty {\n                     Ty::Opaque(_) => write!(f, \"impl \")?,\n                     _ => unreachable!(),\n                 };\n-                // looping by hand here just to format the bounds in a slightly nicer way\n+                // Note: This code is written to produce nice results (i.e.\n+                // corresponding to surface Rust) for types that can occur in\n+                // actual Rust. It will have weird results if the predicates\n+                // aren't as expected (i.e. self types = $0, projection\n+                // predicates for a certain trait come after the Implemented\n+                // predicate for that trait).\n                 let mut first = true;\n+                let mut angle_open = false;\n                 for p in predicates.iter() {\n-                    if !first {\n-                        write!(f, \" + \")?;\n-                    }\n-                    first = false;\n                     match p {\n-                        // don't show the $0 self type\n                         GenericPredicate::Implemented(trait_ref) => {\n-                            trait_ref.hir_fmt_ext(f, false)?\n+                            if angle_open {\n+                                write!(f, \">\")?;\n+                            }\n+                            if !first {\n+                                write!(f, \" + \")?;\n+                            }\n+                            // We assume that the self type is $0 (i.e. the\n+                            // existential) here, which is the only thing that's\n+                            // possible in actual Rust, and hence don't print it\n+                            write!(\n+                                f,\n+                                \"{}\",\n+                                trait_ref.trait_.name(f.db).unwrap_or_else(Name::missing)\n+                            )?;\n+                            if trait_ref.substs.len() > 1 {\n+                                write!(f, \"<\")?;\n+                                f.write_joined(&trait_ref.substs[1..], \", \")?;\n+                                // there might be assoc type bindings, so we leave the angle brackets open\n+                                angle_open = true;\n+                            }\n+                        }\n+                        GenericPredicate::Projection(projection_pred) => {\n+                            // in types in actual Rust, these will always come\n+                            // after the corresponding Implemented predicate\n+                            if angle_open {\n+                                write!(f, \", \")?;\n+                            } else {\n+                                write!(f, \"<\")?;\n+                                angle_open = true;\n+                            }\n+                            let name = projection_pred.projection_ty.associated_ty.name(f.db);\n+                            write!(f, \"{} = \", name)?;\n+                            projection_pred.ty.hir_fmt(f)?;\n+                        }\n+                        GenericPredicate::Error => {\n+                            if angle_open {\n+                                // impl Trait<X, {error}>\n+                                write!(f, \", \")?;\n+                            } else if !first {\n+                                // impl Trait + {error}\n+                                write!(f, \" + \")?;\n+                            }\n+                            p.hir_fmt(f)?;\n                         }\n-                        GenericPredicate::Error => p.hir_fmt(f)?,\n                     }\n+                    first = false;\n+                }\n+                if angle_open {\n+                    write!(f, \">\")?;\n                 }\n             }\n             Ty::Unknown => write!(f, \"{{unknown}}\")?,\n@@ -766,13 +871,12 @@ impl HirDisplay for Ty {\n }\n \n impl TraitRef {\n-    fn hir_fmt_ext(\n-        &self,\n-        f: &mut HirFormatter<impl HirDatabase>,\n-        with_self_ty: bool,\n-    ) -> fmt::Result {\n-        if with_self_ty {\n-            write!(f, \"{}: \", self.substs[0].display(f.db),)?;\n+    fn hir_fmt_ext(&self, f: &mut HirFormatter<impl HirDatabase>, use_as: bool) -> fmt::Result {\n+        self.substs[0].hir_fmt(f)?;\n+        if use_as {\n+            write!(f, \" as \")?;\n+        } else {\n+            write!(f, \": \")?;\n         }\n         write!(f, \"{}\", self.trait_.name(f.db).unwrap_or_else(Name::missing))?;\n         if self.substs.len() > 1 {\n@@ -786,7 +890,7 @@ impl TraitRef {\n \n impl HirDisplay for TraitRef {\n     fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n-        self.hir_fmt_ext(f, true)\n+        self.hir_fmt_ext(f, false)\n     }\n }\n \n@@ -800,6 +904,16 @@ impl HirDisplay for GenericPredicate {\n     fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n         match self {\n             GenericPredicate::Implemented(trait_ref) => trait_ref.hir_fmt(f)?,\n+            GenericPredicate::Projection(projection_pred) => {\n+                write!(f, \"<\")?;\n+                projection_pred.projection_ty.trait_ref(f.db).hir_fmt_ext(f, true)?;\n+                write!(\n+                    f,\n+                    \">::{} = {}\",\n+                    projection_pred.projection_ty.associated_ty.name(f.db),\n+                    projection_pred.ty.display(f.db)\n+                )?;\n+            }\n             GenericPredicate::Error => write!(f, \"{{error}}\")?,\n         }\n         Ok(())"}, {"sha": "08f52a53bc0627f3298de2be009116cd2c4d467c", "filename": "crates/ra_hir/src/ty/autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac73ade7f73d9b7bafaf369a0b206a4ffea73dd/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac73ade7f73d9b7bafaf369a0b206a4ffea73dd/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs?ref=bac73ade7f73d9b7bafaf369a0b206a4ffea73dd", "patch": "@@ -7,7 +7,7 @@ use std::iter::successors;\n \n use log::{info, warn};\n \n-use super::{traits::Solution, Canonical, Ty};\n+use super::{traits::Solution, Canonical, Ty, TypeWalk};\n use crate::{HasGenericParams, HirDatabase, Name, Resolver};\n \n const AUTODEREF_RECURSION_LIMIT: usize = 10;"}, {"sha": "ec3b7ffefff79fb2978c53b11d0df1286cc07c6c", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac73ade7f73d9b7bafaf369a0b206a4ffea73dd/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac73ade7f73d9b7bafaf369a0b206a4ffea73dd/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=bac73ade7f73d9b7bafaf369a0b206a4ffea73dd", "patch": "@@ -30,7 +30,7 @@ use super::{\n     autoderef, lower, method_resolution, op, primitive,\n     traits::{Guidance, Obligation, ProjectionPredicate, Solution},\n     ApplicationTy, CallableDef, InEnvironment, ProjectionTy, Substs, TraitEnvironment, TraitRef,\n-    Ty, TypableDef, TypeCtor,\n+    Ty, TypableDef, TypeCtor, TypeWalk,\n };\n use crate::{\n     adt::VariantDef,"}, {"sha": "9a0d2d8f9ca50626fc91001b79169351f79e941a", "filename": "crates/ra_hir/src/ty/infer/unify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac73ade7f73d9b7bafaf369a0b206a4ffea73dd/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac73ade7f73d9b7bafaf369a0b206a4ffea73dd/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs?ref=bac73ade7f73d9b7bafaf369a0b206a4ffea73dd", "patch": "@@ -3,7 +3,7 @@\n use super::{InferenceContext, Obligation};\n use crate::db::HirDatabase;\n use crate::ty::{\n-    Canonical, InEnvironment, InferTy, ProjectionPredicate, ProjectionTy, TraitRef, Ty,\n+    Canonical, InEnvironment, InferTy, ProjectionPredicate, ProjectionTy, TraitRef, Ty, TypeWalk,\n };\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {"}, {"sha": "f6f0137cffa3bf1747a25aed5e84be00368d6a84", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 58, "deletions": 28, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/bac73ade7f73d9b7bafaf369a0b206a4ffea73dd/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac73ade7f73d9b7bafaf369a0b206a4ffea73dd/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=bac73ade7f73d9b7bafaf369a0b206a4ffea73dd", "patch": "@@ -8,7 +8,10 @@\n use std::iter;\n use std::sync::Arc;\n \n-use super::{FnSig, GenericPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor};\n+use super::{\n+    FnSig, GenericPredicate, ProjectionPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n+    TypeWalk,\n+};\n use crate::{\n     adt::VariantDef,\n     generics::HasGenericParams,\n@@ -62,15 +65,19 @@ impl Ty {\n                 let self_ty = Ty::Bound(0);\n                 let predicates = bounds\n                     .iter()\n-                    .map(|b| GenericPredicate::from_type_bound(db, resolver, b, self_ty.clone()))\n+                    .flat_map(|b| {\n+                        GenericPredicate::from_type_bound(db, resolver, b, self_ty.clone())\n+                    })\n                     .collect::<Vec<_>>();\n                 Ty::Dyn(predicates.into())\n             }\n             TypeRef::ImplTrait(bounds) => {\n                 let self_ty = Ty::Bound(0);\n                 let predicates = bounds\n                     .iter()\n-                    .map(|b| GenericPredicate::from_type_bound(db, resolver, b, self_ty.clone()))\n+                    .flat_map(|b| {\n+                        GenericPredicate::from_type_bound(db, resolver, b, self_ty.clone())\n+                    })\n                     .collect::<Vec<_>>();\n                 Ty::Opaque(predicates.into())\n             }\n@@ -326,15 +333,6 @@ impl TraitRef {\n         TraitRef { trait_, substs }\n     }\n \n-    pub(crate) fn from_where_predicate(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n-        pred: &WherePredicate,\n-    ) -> Option<TraitRef> {\n-        let self_ty = Ty::from_hir(db, resolver, &pred.type_ref);\n-        TraitRef::from_type_bound(db, resolver, &pred.bound, self_ty)\n-    }\n-\n     pub(crate) fn from_type_bound(\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n@@ -349,26 +347,58 @@ impl TraitRef {\n }\n \n impl GenericPredicate {\n-    pub(crate) fn from_where_predicate(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n-        where_predicate: &WherePredicate,\n-    ) -> GenericPredicate {\n-        TraitRef::from_where_predicate(db, &resolver, where_predicate)\n-            .map_or(GenericPredicate::Error, GenericPredicate::Implemented)\n+    pub(crate) fn from_where_predicate<'a>(\n+        db: &'a impl HirDatabase,\n+        resolver: &'a Resolver,\n+        where_predicate: &'a WherePredicate,\n+    ) -> impl Iterator<Item = GenericPredicate> + 'a {\n+        let self_ty = Ty::from_hir(db, resolver, &where_predicate.type_ref);\n+        GenericPredicate::from_type_bound(db, resolver, &where_predicate.bound, self_ty)\n     }\n \n-    pub(crate) fn from_type_bound(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n-        bound: &TypeBound,\n+    pub(crate) fn from_type_bound<'a>(\n+        db: &'a impl HirDatabase,\n+        resolver: &'a Resolver,\n+        bound: &'a TypeBound,\n         self_ty: Ty,\n-    ) -> GenericPredicate {\n-        TraitRef::from_type_bound(db, &resolver, bound, self_ty)\n-            .map_or(GenericPredicate::Error, GenericPredicate::Implemented)\n+    ) -> impl Iterator<Item = GenericPredicate> + 'a {\n+        let trait_ref = TraitRef::from_type_bound(db, &resolver, bound, self_ty);\n+        iter::once(trait_ref.clone().map_or(GenericPredicate::Error, GenericPredicate::Implemented))\n+            .chain(\n+                trait_ref.into_iter().flat_map(move |tr| {\n+                    assoc_type_bindings_from_type_bound(db, resolver, bound, tr)\n+                }),\n+            )\n     }\n }\n \n+fn assoc_type_bindings_from_type_bound<'a>(\n+    db: &'a impl HirDatabase,\n+    resolver: &'a Resolver,\n+    bound: &'a TypeBound,\n+    trait_ref: TraitRef,\n+) -> impl Iterator<Item = GenericPredicate> + 'a {\n+    let last_segment = match bound {\n+        TypeBound::Path(path) => path.segments.last(),\n+        TypeBound::Error => None,\n+    };\n+    last_segment\n+        .into_iter()\n+        .flat_map(|segment| segment.args_and_bindings.iter())\n+        .flat_map(|args_and_bindings| args_and_bindings.bindings.iter())\n+        .map(move |(name, type_ref)| {\n+            let associated_ty = match trait_ref.trait_.associated_type_by_name(db, name.clone()) {\n+                None => return GenericPredicate::Error,\n+                Some(t) => t,\n+            };\n+            let projection_ty =\n+                ProjectionTy { associated_ty, parameters: trait_ref.substs.clone() };\n+            let ty = Ty::from_hir(db, resolver, type_ref);\n+            let projection_predicate = ProjectionPredicate { projection_ty, ty };\n+            GenericPredicate::Projection(projection_predicate)\n+        })\n+}\n+\n /// Build the declared type of an item. This depends on the namespace; e.g. for\n /// `struct Foo(usize)`, we have two types: The type of the struct itself, and\n /// the constructor function `(usize) -> Foo` which lives in the values\n@@ -425,7 +455,7 @@ pub(crate) fn trait_env(\n ) -> Arc<super::TraitEnvironment> {\n     let predicates = resolver\n         .where_predicates_in_scope()\n-        .map(|pred| GenericPredicate::from_where_predicate(db, &resolver, pred))\n+        .flat_map(|pred| GenericPredicate::from_where_predicate(db, &resolver, pred))\n         .collect::<Vec<_>>();\n \n     Arc::new(super::TraitEnvironment { predicates })\n@@ -439,7 +469,7 @@ pub(crate) fn generic_predicates_query(\n     let resolver = def.resolver(db);\n     let predicates = resolver\n         .where_predicates_in_scope()\n-        .map(|pred| GenericPredicate::from_where_predicate(db, &resolver, pred))\n+        .flat_map(|pred| GenericPredicate::from_where_predicate(db, &resolver, pred))\n         .collect::<Vec<_>>();\n     predicates.into()\n }"}, {"sha": "d92d4659b253856d3b2a28cfdda059f729491a14", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/bac73ade7f73d9b7bafaf369a0b206a4ffea73dd/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac73ade7f73d9b7bafaf369a0b206a4ffea73dd/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=bac73ade7f73d9b7bafaf369a0b206a4ffea73dd", "patch": "@@ -3552,6 +3552,97 @@ fn test() {\n     );\n }\n \n+#[test]\n+fn assoc_type_bindings() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait {\n+    type Type;\n+}\n+\n+fn get<T: Trait>(t: T) -> <T as Trait>::Type {}\n+fn get2<U, T: Trait<Type = U>>(t: T) -> U {}\n+fn set<T: Trait<Type = u64>>(t: T) -> T {t}\n+\n+struct S<T>;\n+impl<T> Trait for S<T> { type Type = T; }\n+\n+fn test<T: Trait<Type = u32>>(x: T, y: impl Trait<Type = i64>) {\n+    get(x);\n+    get2(x);\n+    get(y);\n+    get2(y);\n+    get(set(S));\n+    get2(set(S));\n+    get2(S::<str>);\n+}\n+\"#),\n+        @r###\"\n+    [50; 51) 't': T\n+    [78; 80) '{}': ()\n+    [112; 113) 't': T\n+    [123; 125) '{}': ()\n+    [155; 156) 't': T\n+    [166; 169) '{t}': T\n+    [167; 168) 't': T\n+    [257; 258) 'x': T\n+    [263; 264) 'y': impl Trait<Type = i64>\n+    [290; 398) '{     ...r>); }': ()\n+    [296; 299) 'get': fn get<T>(T) -> <T as Trait>::Type\n+    [296; 302) 'get(x)': {unknown}\n+    [300; 301) 'x': T\n+    [308; 312) 'get2': fn get2<{unknown}, S<{unknown}>>(T) -> U\n+    [308; 315) 'get2(x)': {unknown}\n+    [313; 314) 'x': T\n+    [321; 324) 'get': fn get<impl Trait<Type = i64>>(T) -> <T as Trait>::Type\n+    [321; 327) 'get(y)': {unknown}\n+    [325; 326) 'y': impl Trait<Type = i64>\n+    [333; 337) 'get2': fn get2<{unknown}, S<{unknown}>>(T) -> U\n+    [333; 340) 'get2(y)': {unknown}\n+    [338; 339) 'y': impl Trait<Type = i64>\n+    [346; 349) 'get': fn get<S<u64>>(T) -> <T as Trait>::Type\n+    [346; 357) 'get(set(S))': u64\n+    [350; 353) 'set': fn set<S<u64>>(T) -> T\n+    [350; 356) 'set(S)': S<u64>\n+    [354; 355) 'S': S<u64>\n+    [363; 367) 'get2': fn get2<u64, S<u64>>(T) -> U\n+    [363; 375) 'get2(set(S))': u64\n+    [368; 371) 'set': fn set<S<u64>>(T) -> T\n+    [368; 374) 'set(S)': S<u64>\n+    [372; 373) 'S': S<u64>\n+    [381; 385) 'get2': fn get2<str, S<str>>(T) -> U\n+    [381; 395) 'get2(S::<str>)': str\n+    [386; 394) 'S::<str>': S<str>\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn projection_eq_within_chalk() {\n+    // std::env::set_var(\"CHALK_DEBUG\", \"1\");\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait1 {\n+    type Type;\n+}\n+trait Trait2<T> {\n+    fn foo(self) -> T;\n+}\n+impl<T, U> Trait2<T> for U where U: Trait1<Type = T> {}\n+\n+fn test<T: Trait1<Type = u32>>(x: T) {\n+    x.foo();\n+}\n+\"#),\n+        @r###\"\n+    [62; 66) 'self': Self\n+    [164; 165) 'x': T\n+    [170; 186) '{     ...o(); }': ()\n+    [176; 177) 'x': T\n+    [176; 183) 'x.foo()': {unknown}\n+    \"###\n+    );\n+}\n fn type_at_pos(db: &MockDatabase, pos: FilePosition) -> String {\n     let file = db.parse(pos.file_id).ok().unwrap();\n     let expr = algo::find_node_at_offset::<ast::Expr>(file.syntax(), pos.offset).unwrap();"}, {"sha": "6e0271a9666c03821742299f29ddda89217c6682", "filename": "crates/ra_hir/src/ty/traits.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bac73ade7f73d9b7bafaf369a0b206a4ffea73dd/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac73ade7f73d9b7bafaf369a0b206a4ffea73dd/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs?ref=bac73ade7f73d9b7bafaf369a0b206a4ffea73dd", "patch": "@@ -8,7 +8,7 @@ use ra_db::salsa;\n use ra_prof::profile;\n use rustc_hash::FxHashSet;\n \n-use super::{Canonical, GenericPredicate, HirDisplay, ProjectionTy, TraitRef, Ty};\n+use super::{Canonical, GenericPredicate, HirDisplay, ProjectionTy, TraitRef, Ty, TypeWalk};\n use crate::{db::HirDatabase, Crate, ImplBlock, Trait};\n \n use self::chalk::{from_chalk, ToChalk};\n@@ -124,6 +124,9 @@ impl Obligation {\n     pub fn from_predicate(predicate: GenericPredicate) -> Option<Obligation> {\n         match predicate {\n             GenericPredicate::Implemented(trait_ref) => Some(Obligation::Trait(trait_ref)),\n+            GenericPredicate::Projection(projection_pred) => {\n+                Some(Obligation::Projection(projection_pred))\n+            }\n             GenericPredicate::Error => None,\n         }\n     }\n@@ -135,6 +138,18 @@ pub struct ProjectionPredicate {\n     pub ty: Ty,\n }\n \n+impl TypeWalk for ProjectionPredicate {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        self.projection_ty.walk(f);\n+        self.ty.walk(f);\n+    }\n+\n+    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n+        self.projection_ty.walk_mut(f);\n+        self.ty.walk_mut(f);\n+    }\n+}\n+\n /// Solve a trait goal using Chalk.\n pub(crate) fn trait_solve_query(\n     db: &impl HirDatabase,"}, {"sha": "c201c5e50e751cb15a5026c75096ae53a92b21c7", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bac73ade7f73d9b7bafaf369a0b206a4ffea73dd/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac73ade7f73d9b7bafaf369a0b206a4ffea73dd/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=bac73ade7f73d9b7bafaf369a0b206a4ffea73dd", "patch": "@@ -19,6 +19,7 @@ use crate::{\n     ty::display::HirDisplay,\n     ty::{\n         ApplicationTy, CallableDef, GenericPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n+        TypeWalk,\n     },\n     Crate, HasGenericParams, ImplBlock, ImplItem, Trait, TypeAlias,\n };\n@@ -211,6 +212,13 @@ impl ToChalk for GenericPredicate {\n             GenericPredicate::Implemented(trait_ref) => {\n                 make_binders(chalk_ir::WhereClause::Implemented(trait_ref.to_chalk(db)), 0)\n             }\n+            GenericPredicate::Projection(projection_pred) => make_binders(\n+                chalk_ir::WhereClause::ProjectionEq(chalk_ir::ProjectionEq {\n+                    projection: projection_pred.projection_ty.to_chalk(db),\n+                    ty: projection_pred.ty.to_chalk(db),\n+                }),\n+                0,\n+            ),\n             GenericPredicate::Error => {\n                 let impossible_trait_ref = chalk_ir::TraitRef {\n                     trait_id: UNKNOWN_TRAIT,"}, {"sha": "db7e8348e1e1a4edb0cd26e600abe169ae8c06e3", "filename": "crates/ra_ide_api/src/completion/presentation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac73ade7f73d9b7bafaf369a0b206a4ffea73dd/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac73ade7f73d9b7bafaf369a0b206a4ffea73dd/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fpresentation.rs?ref=bac73ade7f73d9b7bafaf369a0b206a4ffea73dd", "patch": "@@ -1,5 +1,5 @@\n //! This modules takes care of rendering various defenitions as completion items.\n-use hir::{Docs, HasSource, HirDisplay, PerNs, Resolution, Ty};\n+use hir::{Docs, HasSource, HirDisplay, PerNs, Resolution, Ty, TypeWalk};\n use join_to_string::join;\n use ra_syntax::ast::NameOwner;\n use test_utils::tested_by;"}]}