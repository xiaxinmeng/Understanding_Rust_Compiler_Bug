{"sha": "62b834fb9f3e18d54e56d12824a9fa1780a5fc9d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyYjgzNGZiOWYzZTE4ZDU0ZTU2ZDEyODI0YTlmYTE3ODBhNWZjOWQ=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2021-05-15T15:56:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-15T15:56:47Z"}, "message": "Rollup merge of #84751 - Soveu:is_char_boundary_opt, r=Amanieu\n\nstr::is_char_boundary - slight optimization\n\nCurrent `str::is_char_boundary` implementation emits slightly more instructions, because it includes an additional branch for `index == s.len()`\n```rust\npub fn is_char_boundary(s: &str, index: usize) -> bool {\n    if index == 0 || index == s.len() {\n        return true;\n    }\n    match s.as_bytes().get(index) {\n        None => false,\n        Some(&b) => (b as i8) >= -0x40,\n    }\n}\n```\nJust changing the place of `index == s.len()` merges it with `index < s.len()` from `s.as_bytes().get(index)`\n```rust\npub fn is_char_boundary2(s: &str, index: usize) -> bool {\n    if index == 0 {\n        return true;\n    }\n\n    match s.as_bytes().get(index) {\n        // For some reason, LLVM likes this comparison here more\n        None => index == s.len(),\n        // This is bit magic equivalent to: b < 128 || b >= 192\n        Some(&b) => (b as i8) >= -0x40,\n    }\n}\n```\nThis one has better codegen on every platform, except powerpc\n<details><summary>x86 codegen</summary>\n<p>\n\n```nasm\nexample::is_char_boundary:\n        mov     al, 1\n        test    rdx, rdx\n        je      .LBB0_5\n        cmp     rsi, rdx\n        je      .LBB0_5\n        cmp     rsi, rdx\n        jbe     .LBB0_3\n        cmp     byte ptr [rdi + rdx], -65\n        setg    al\n.LBB0_5:\n        ret\n.LBB0_3:\n        xor     eax, eax\n        ret\n\nexample::is_char_boundary2:\n        test    rdx, rdx\n        je      .LBB1_1\n        cmp     rsi, rdx\n        jbe     .LBB1_4\n        cmp     byte ptr [rdi + rdx], -65\n        setg    al\n        ret\n.LBB1_1:  ; technically this branch is the same as LBB1_4\n        mov     al, 1\n        ret\n.LBB1_4:\n        sete    al\n        ret\n ```\n</p>\n</details>\n\n<details><summary>aarch64 codegen</summary>\n<p>\n\n```as\nexample::is_char_boundary:\n        mov     x8, x0\n        mov     w0, #1\n        cbz     x2, .LBB0_4\n        cmp     x1, x2\n        b.eq    .LBB0_4\n        b.ls    .LBB0_5\n        ldrsb   w8, [x8, x2]\n        cmn     w8, #65\n        cset    w0, gt\n.LBB0_4:\n        ret\n.LBB0_5:\n        mov     w0, wzr\n        ret\n\nexample::is_char_boundary2:\n        cbz     x2, .LBB1_3\n        cmp     x1, x2\n        b.ls    .LBB1_4\n        ldrsb   w8, [x0, x2]\n        cmn     w8, #65\n        cset    w0, gt\n        ret\n.LBB1_3:\n        mov     w0, #1\n        ret\n.LBB1_4:\n        cset    w0, eq\n        ret\n```\n\n</p>\n</details>\n\n<details><summary>riscv64gc codegen</summary>\n<p>\n\nexample::is_char_boundary:\n        seqz    a3, a2\n        xor     a4, a1, a2\n        seqz    a4, a4\n        or      a4, a4, a3\n        addi    a3, zero, 1\n        bnez    a4, .LBB0_3\n        bgeu    a2, a1, .LBB0_4\n        add     a0, a0, a2\n        lb      a0, 0(a0)\n        addi    a1, zero, -65\n        slt     a3, a1, a0\n.LBB0_3:\n        mv      a0, a3\n        ret\n.LBB0_4:\n        mv      a0, zero\n        ret\n\nexample::is_char_boundary2:\n        beqz    a2, .LBB1_3\n        bgeu    a2, a1, .LBB1_4\n        add     a0, a0, a2\n        lb      a0, 0(a0)\n        addi    a1, zero, -65\n        slt     a0, a1, a0\n        ret\n.LBB1_3:\n        addi    a0, zero, 1\n        ret\n.LBB1_4:\n        xor     a0, a1, a2\n        seqz    a0, a0\n        ret\n\n</p>\n</details>\n\n[Link to godbolt](https://godbolt.org/z/K8avEz8Gr)\n\n`@rustbot` label: A-codegen", "tree": {"sha": "392b3ca5ba66d8f6b0fd125185f8c454306ed411", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/392b3ca5ba66d8f6b0fd125185f8c454306ed411"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62b834fb9f3e18d54e56d12824a9fa1780a5fc9d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgn+9ACRBK7hj4Ov3rIwAA7LQIAHFLVlfb4qDWPx7rJrX71Wy3\nGqYMAmSq5leCjxY8nrqkFDBlaeVQruxChRWQvvG53Zg5vYY1nAidWBK9lSq8HqP5\ngoioPwiEG+n6JzabeyV3wrJDaiOGV98Lu8uC8y036E19RMR+r4EfAjs2QDprV/ig\nuZPKIdXQyD27e9/hdgpH/dC9zPN2XLVJmaJ9BESTRFTz66oS7rOuQSfwJvF/SEoB\nsJm2OpxUtTy6VmsX5VRNRs9q5B8XBiMZsm2J04ChwfYYJbY6wKMNMDp22iFEquDA\n23VViIPBjKONzkx2C61YnHafsrn+dsZNIDoxbf/Vi13v3nrwA5TE0RH5F8YAhE0=\n=zvXZ\n-----END PGP SIGNATURE-----\n", "payload": "tree 392b3ca5ba66d8f6b0fd125185f8c454306ed411\nparent 2a245f40a19c9a60b3be33c959eb5cfb0ad163c6\nparent 7bd9d9f1e995272494854c78dd60fcd8e06487f8\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1621094207 +0200\ncommitter GitHub <noreply@github.com> 1621094207 +0200\n\nRollup merge of #84751 - Soveu:is_char_boundary_opt, r=Amanieu\n\nstr::is_char_boundary - slight optimization\n\nCurrent `str::is_char_boundary` implementation emits slightly more instructions, because it includes an additional branch for `index == s.len()`\n```rust\npub fn is_char_boundary(s: &str, index: usize) -> bool {\n    if index == 0 || index == s.len() {\n        return true;\n    }\n    match s.as_bytes().get(index) {\n        None => false,\n        Some(&b) => (b as i8) >= -0x40,\n    }\n}\n```\nJust changing the place of `index == s.len()` merges it with `index < s.len()` from `s.as_bytes().get(index)`\n```rust\npub fn is_char_boundary2(s: &str, index: usize) -> bool {\n    if index == 0 {\n        return true;\n    }\n\n    match s.as_bytes().get(index) {\n        // For some reason, LLVM likes this comparison here more\n        None => index == s.len(),\n        // This is bit magic equivalent to: b < 128 || b >= 192\n        Some(&b) => (b as i8) >= -0x40,\n    }\n}\n```\nThis one has better codegen on every platform, except powerpc\n<details><summary>x86 codegen</summary>\n<p>\n\n```nasm\nexample::is_char_boundary:\n        mov     al, 1\n        test    rdx, rdx\n        je      .LBB0_5\n        cmp     rsi, rdx\n        je      .LBB0_5\n        cmp     rsi, rdx\n        jbe     .LBB0_3\n        cmp     byte ptr [rdi + rdx], -65\n        setg    al\n.LBB0_5:\n        ret\n.LBB0_3:\n        xor     eax, eax\n        ret\n\nexample::is_char_boundary2:\n        test    rdx, rdx\n        je      .LBB1_1\n        cmp     rsi, rdx\n        jbe     .LBB1_4\n        cmp     byte ptr [rdi + rdx], -65\n        setg    al\n        ret\n.LBB1_1:  ; technically this branch is the same as LBB1_4\n        mov     al, 1\n        ret\n.LBB1_4:\n        sete    al\n        ret\n ```\n</p>\n</details>\n\n<details><summary>aarch64 codegen</summary>\n<p>\n\n```as\nexample::is_char_boundary:\n        mov     x8, x0\n        mov     w0, #1\n        cbz     x2, .LBB0_4\n        cmp     x1, x2\n        b.eq    .LBB0_4\n        b.ls    .LBB0_5\n        ldrsb   w8, [x8, x2]\n        cmn     w8, #65\n        cset    w0, gt\n.LBB0_4:\n        ret\n.LBB0_5:\n        mov     w0, wzr\n        ret\n\nexample::is_char_boundary2:\n        cbz     x2, .LBB1_3\n        cmp     x1, x2\n        b.ls    .LBB1_4\n        ldrsb   w8, [x0, x2]\n        cmn     w8, #65\n        cset    w0, gt\n        ret\n.LBB1_3:\n        mov     w0, #1\n        ret\n.LBB1_4:\n        cset    w0, eq\n        ret\n```\n\n</p>\n</details>\n\n<details><summary>riscv64gc codegen</summary>\n<p>\n\nexample::is_char_boundary:\n        seqz    a3, a2\n        xor     a4, a1, a2\n        seqz    a4, a4\n        or      a4, a4, a3\n        addi    a3, zero, 1\n        bnez    a4, .LBB0_3\n        bgeu    a2, a1, .LBB0_4\n        add     a0, a0, a2\n        lb      a0, 0(a0)\n        addi    a1, zero, -65\n        slt     a3, a1, a0\n.LBB0_3:\n        mv      a0, a3\n        ret\n.LBB0_4:\n        mv      a0, zero\n        ret\n\nexample::is_char_boundary2:\n        beqz    a2, .LBB1_3\n        bgeu    a2, a1, .LBB1_4\n        add     a0, a0, a2\n        lb      a0, 0(a0)\n        addi    a1, zero, -65\n        slt     a0, a1, a0\n        ret\n.LBB1_3:\n        addi    a0, zero, 1\n        ret\n.LBB1_4:\n        xor     a0, a1, a2\n        seqz    a0, a0\n        ret\n\n</p>\n</details>\n\n[Link to godbolt](https://godbolt.org/z/K8avEz8Gr)\n\n`@rustbot` label: A-codegen\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62b834fb9f3e18d54e56d12824a9fa1780a5fc9d", "html_url": "https://github.com/rust-lang/rust/commit/62b834fb9f3e18d54e56d12824a9fa1780a5fc9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62b834fb9f3e18d54e56d12824a9fa1780a5fc9d/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6", "html_url": "https://github.com/rust-lang/rust/commit/2a245f40a19c9a60b3be33c959eb5cfb0ad163c6"}, {"sha": "7bd9d9f1e995272494854c78dd60fcd8e06487f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bd9d9f1e995272494854c78dd60fcd8e06487f8", "html_url": "https://github.com/rust-lang/rust/commit/7bd9d9f1e995272494854c78dd60fcd8e06487f8"}], "stats": {"total": 18, "additions": 15, "deletions": 3}, "files": [{"sha": "065acd3f38bb21ad37c3fd337a8536ae160708f5", "filename": "library/core/src/str/mod.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/62b834fb9f3e18d54e56d12824a9fa1780a5fc9d/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62b834fb9f3e18d54e56d12824a9fa1780a5fc9d/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs?ref=62b834fb9f3e18d54e56d12824a9fa1780a5fc9d", "patch": "@@ -192,14 +192,26 @@ impl str {\n     #[stable(feature = \"is_char_boundary\", since = \"1.9.0\")]\n     #[inline]\n     pub fn is_char_boundary(&self, index: usize) -> bool {\n-        // 0 and len are always ok.\n+        // 0 is always ok.\n         // Test for 0 explicitly so that it can optimize out the check\n         // easily and skip reading string data for that case.\n-        if index == 0 || index == self.len() {\n+        // Note that optimizing `self.get(..index)` relies on this.\n+        if index == 0 {\n             return true;\n         }\n+\n         match self.as_bytes().get(index) {\n-            None => false,\n+            // For `None` we have two options:\n+            //\n+            // - index == self.len()\n+            //   Empty strings are valid, so return true\n+            // - index > self.len()\n+            //   In this case return false\n+            //\n+            // The check is placed exactly here, because it improves generated\n+            // code on higher opt-levels. See PR #84751 for more details.\n+            None => index == self.len(),\n+\n             // This is bit magic equivalent to: b < 128 || b >= 192\n             Some(&b) => (b as i8) >= -0x40,\n         }"}]}