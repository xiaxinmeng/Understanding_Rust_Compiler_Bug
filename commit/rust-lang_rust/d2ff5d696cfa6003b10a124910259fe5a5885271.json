{"sha": "d2ff5d696cfa6003b10a124910259fe5a5885271", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyZmY1ZDY5NmNmYTYwMDNiMTBhMTI0OTEwMjU5ZmU1YTU4ODUyNzE=", "commit": {"author": {"name": "Diogo Sousa", "email": "diogogsousa@gmail.com", "date": "2018-08-10T17:13:43Z"}, "committer": {"name": "Diogo Sousa", "email": "diogogsousa@gmail.com", "date": "2018-09-30T19:01:28Z"}, "message": "Typos and style fixes.", "tree": {"sha": "94878c206fdf83518a559c2338cb5d8e0aa25566", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94878c206fdf83518a559c2338cb5d8e0aa25566"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2ff5d696cfa6003b10a124910259fe5a5885271", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2ff5d696cfa6003b10a124910259fe5a5885271", "html_url": "https://github.com/rust-lang/rust/commit/d2ff5d696cfa6003b10a124910259fe5a5885271", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2ff5d696cfa6003b10a124910259fe5a5885271/comments", "author": {"login": "orium", "id": 4107683, "node_id": "MDQ6VXNlcjQxMDc2ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4107683?v=4", "gravatar_id": "", "url": "https://api.github.com/users/orium", "html_url": "https://github.com/orium", "followers_url": "https://api.github.com/users/orium/followers", "following_url": "https://api.github.com/users/orium/following{/other_user}", "gists_url": "https://api.github.com/users/orium/gists{/gist_id}", "starred_url": "https://api.github.com/users/orium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/orium/subscriptions", "organizations_url": "https://api.github.com/users/orium/orgs", "repos_url": "https://api.github.com/users/orium/repos", "events_url": "https://api.github.com/users/orium/events{/privacy}", "received_events_url": "https://api.github.com/users/orium/received_events", "type": "User", "site_admin": false}, "committer": {"login": "orium", "id": 4107683, "node_id": "MDQ6VXNlcjQxMDc2ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4107683?v=4", "gravatar_id": "", "url": "https://api.github.com/users/orium", "html_url": "https://github.com/orium", "followers_url": "https://api.github.com/users/orium/followers", "following_url": "https://api.github.com/users/orium/following{/other_user}", "gists_url": "https://api.github.com/users/orium/gists{/gist_id}", "starred_url": "https://api.github.com/users/orium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/orium/subscriptions", "organizations_url": "https://api.github.com/users/orium/orgs", "repos_url": "https://api.github.com/users/orium/repos", "events_url": "https://api.github.com/users/orium/events{/privacy}", "received_events_url": "https://api.github.com/users/orium/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb50e75729bce449272ffb3bfbca2f7234f2ae13", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb50e75729bce449272ffb3bfbca2f7234f2ae13", "html_url": "https://github.com/rust-lang/rust/commit/eb50e75729bce449272ffb3bfbca2f7234f2ae13"}], "stats": {"total": 47, "additions": 23, "deletions": 24}, "files": [{"sha": "79fc9b449238db0e2b16731ed56000ef65ca553c", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2ff5d696cfa6003b10a124910259fe5a5885271/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ff5d696cfa6003b10a124910259fe5a5885271/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=d2ff5d696cfa6003b10a124910259fe5a5885271", "patch": "@@ -73,16 +73,16 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     /// ```\n     /// struct Foo<T> { data: Box<T> }\n     /// ```\n-\n+    ///\n     /// then this might return that Foo<T>: Send if T: Send (encoded in the AutoTraitResult type).\n     /// The analysis attempts to account for custom impls as well as other complex cases. This\n     /// result is intended for use by rustdoc and other such consumers.\n-\n+    ///\n     /// (Note that due to the coinductive nature of Send, the full and correct result is actually\n     /// quite simple to generate. That is, when a type has no custom impl, it is Send iff its field\n     /// types are all Send. So, in our example, we might have that Foo<T>: Send if Box<T>: Send.\n     /// But this is often not the best way to present to the user.)\n-\n+    ///\n     /// Warning: The API should be considered highly unstable, and it may be refactored or removed\n     /// in the future.\n     pub fn find_auto_trait_generics<A>(\n@@ -288,7 +288,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     // hold.\n     //\n     // One additional consideration is supertrait bounds. Normally, a ParamEnv is only ever\n-    // consutrcted once for a given type. As part of the construction process, the ParamEnv will\n+    // constructed once for a given type. As part of the construction process, the ParamEnv will\n     // have any supertrait bounds normalized - e.g. if we have a type 'struct Foo<T: Copy>', the\n     // ParamEnv will contain 'T: Copy' and 'T: Clone', since 'Copy: Clone'. When we construct our\n     // own ParamEnv, we need to do this ourselves, through traits::elaborate_predicates, or else"}, {"sha": "0f330504334a6a38e4bf0e443af53b028c2a48b4", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2ff5d696cfa6003b10a124910259fe5a5885271/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ff5d696cfa6003b10a124910259fe5a5885271/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=d2ff5d696cfa6003b10a124910259fe5a5885271", "patch": "@@ -45,7 +45,6 @@ impl<'tcx> ForestObligation for PendingPredicateObligation<'tcx> {\n /// along. Once all type inference constraints have been generated, the\n /// method `select_all_or_error` can be used to report any remaining\n /// ambiguous cases as errors.\n-\n pub struct FulfillmentContext<'tcx> {\n     // A list of all obligations that have been registered with this\n     // fulfillment context.\n@@ -89,7 +88,7 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n \n     /// Attempts to select obligations using `selcx`.\n     fn select(&mut self, selcx: &mut SelectionContext<'a, 'gcx, 'tcx>)\n-              -> Result<(),Vec<FulfillmentError<'tcx>>> {\n+              -> Result<(), Vec<FulfillmentError<'tcx>>> {\n         debug!(\"select(obligation-forest-size={})\", self.predicates.len());\n \n         let mut errors = Vec::new();"}, {"sha": "f394fbd9c7b4cd7b902dc8fe5d87052c45725e26", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2ff5d696cfa6003b10a124910259fe5a5885271/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ff5d696cfa6003b10a124910259fe5a5885271/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=d2ff5d696cfa6003b10a124910259fe5a5885271", "patch": "@@ -644,7 +644,7 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // have the errors get reported at a defined place (e.g.,\n     // during typeck). Instead I have all parameter\n     // environments, in effect, going through this function\n-    // and hence potentially reporting errors. This ensurse of\n+    // and hence potentially reporting errors. This ensures of\n     // course that we never forget to normalize (the\n     // alternative seemed like it would involve a lot of\n     // manual invocations of this fn -- and then we'd have to"}, {"sha": "7e504094ad86f7d91db056c04ca7cca8089ff792", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d2ff5d696cfa6003b10a124910259fe5a5885271/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ff5d696cfa6003b10a124910259fe5a5885271/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=d2ff5d696cfa6003b10a124910259fe5a5885271", "patch": "@@ -582,7 +582,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         match self.confirm_candidate(obligation, candidate) {\n             Err(SelectionError::Overflow) => {\n                 assert!(self.query_mode == TraitQueryMode::Canonical);\n-                return Err(SelectionError::Overflow);\n+                Err(SelectionError::Overflow)\n             },\n             Err(e) => Err(e),\n             Ok(candidate) => Ok(Some(candidate))\n@@ -879,7 +879,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // must be met of course). One obvious case this comes up is\n         // marker traits like `Send`. Think of a linked list:\n         //\n-        //    struct List<T> { data: T, next: Option<Box<List<T>>> {\n+        //    struct List<T> { data: T, next: Option<Box<List<T>>> }\n         //\n         // `Box<List<T>>` will be `Send` if `T` is `Send` and\n         // `Option<Box<List<T>>>` is `Send`, and in turn\n@@ -1407,7 +1407,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                stack: &TraitObligationStack<'o, 'tcx>)\n                                -> Result<SelectionCandidateSet<'tcx>, SelectionError<'tcx>>\n     {\n-        let TraitObligationStack { obligation, .. } = *stack;\n+        let obligation = stack.obligation;\n         let ref obligation = Obligation {\n             param_env: obligation.param_env,\n             cause: obligation.cause.clone(),\n@@ -1788,9 +1788,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     }\n \n     fn assemble_candidates_from_auto_impls(&mut self,\n-                                              obligation: &TraitObligation<'tcx>,\n-                                              candidates: &mut SelectionCandidateSet<'tcx>)\n-                                              -> Result<(), SelectionError<'tcx>>\n+                                           obligation: &TraitObligation<'tcx>,\n+                                           candidates: &mut SelectionCandidateSet<'tcx>)\n+                                           -> Result<(), SelectionError<'tcx>>\n     {\n         // OK to skip binder here because the tests we do below do not involve bound regions\n         let self_ty = *obligation.self_ty().skip_binder();\n@@ -2433,7 +2433,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn confirm_candidate(&mut self,\n                          obligation: &TraitObligation<'tcx>,\n                          candidate: SelectionCandidate<'tcx>)\n-                         -> Result<Selection<'tcx>,SelectionError<'tcx>>\n+                         -> Result<Selection<'tcx>, SelectionError<'tcx>>\n     {\n         debug!(\"confirm_candidate({:?}, {:?})\",\n                obligation,\n@@ -2612,11 +2612,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let mut obligations = self.collect_predicates_for_types(\n             obligation.param_env,\n             cause,\n-            obligation.recursion_depth+1,\n+            obligation.recursion_depth + 1,\n             trait_def_id,\n             nested);\n \n-        let trait_obligations = self.in_snapshot(|this, snapshot| {\n+        let trait_obligations: Vec<PredicateObligation<'_>> = self.in_snapshot(|this, snapshot| {\n             let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n             let (trait_ref, skol_map) =\n                 this.infcx().skolemize_late_bound_regions(&poly_trait_ref);\n@@ -2630,6 +2630,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                            snapshot)\n         });\n \n+        // Adds the predicates from the trait.  Note that this contains a `Self: Trait`\n+        // predicate as usual.  It won't have any effect since auto traits are coinductive.\n         obligations.extend(trait_obligations);\n \n         debug!(\"vtable_auto_impl: obligations={:?}\", obligations);"}, {"sha": "094c1cec31acce8847cc221139642c525e8d88b2", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2ff5d696cfa6003b10a124910259fe5a5885271/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ff5d696cfa6003b10a124910259fe5a5885271/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=d2ff5d696cfa6003b10a124910259fe5a5885271", "patch": "@@ -187,7 +187,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                               -> Result<(), ()>\n     {\n         if self.done_cache.contains(obligation.as_predicate()) {\n-            return Ok(())\n+            return Ok(());\n         }\n \n         match self.waiting_cache.entry(obligation.as_predicate().clone()) {\n@@ -269,8 +269,8 @@ impl<O: ForestObligation> ObligationForest<O> {\n                    self.nodes[index]);\n \n             let result = match self.nodes[index] {\n-                Node { state: ref _state, ref mut obligation, .. }\n-                    if _state.get() == NodeState::Pending =>\n+                Node { ref state, ref mut obligation, .. }\n+                    if state.get() == NodeState::Pending =>\n                 {\n                     processor.process_obligation(obligation)\n                 }"}, {"sha": "c27a65e34310ff19e774a6d0029366d5ffeaa8f2", "filename": "src/librustc_data_structures/obligation_forest/test.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2ff5d696cfa6003b10a124910259fe5a5885271/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2ff5d696cfa6003b10a124910259fe5a5885271/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs?ref=d2ff5d696cfa6003b10a124910259fe5a5885271", "patch": "@@ -59,8 +59,9 @@ impl<OF, BF, O, E> ObligationProcessor for ClosureObligationProcessor<OF, BF, O,\n \n     fn process_backedge<'c, I>(&mut self, _cycle: I,\n                                _marker: PhantomData<&'c Self::Obligation>)\n-        where I: Clone + Iterator<Item=&'c Self::Obligation> {\n-        }\n+        where I: Clone + Iterator<Item=&'c Self::Obligation>\n+    {\n+    }\n }\n \n \n@@ -350,11 +351,8 @@ fn done_dependency() {\n         }, |_|{}));\n     assert_eq!(ok, vec![\"(A,B,C): Sized\"]);\n     assert_eq!(err.len(), 0);\n-\n-\n }\n \n-\n #[test]\n fn orphan() {\n     // check that orphaned nodes are handled correctly"}]}