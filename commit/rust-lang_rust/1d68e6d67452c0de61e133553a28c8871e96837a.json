{"sha": "1d68e6d67452c0de61e133553a28c8871e96837a", "node_id": "C_kwDOAAsO6NoAKDFkNjhlNmQ2NzQ1MmMwZGU2MWUxMzM1NTNhMjhjODg3MWU5NjgzN2E", "commit": {"author": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2022-05-07T18:12:01Z"}, "committer": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2022-05-09T17:53:16Z"}, "message": "Properly fix issue 96638", "tree": {"sha": "f9bfcabbac28305b982bd759ae99ec358f3169ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9bfcabbac28305b982bd759ae99ec358f3169ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d68e6d67452c0de61e133553a28c8871e96837a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d68e6d67452c0de61e133553a28c8871e96837a", "html_url": "https://github.com/rust-lang/rust/commit/1d68e6d67452c0de61e133553a28c8871e96837a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d68e6d67452c0de61e133553a28c8871e96837a/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e345b76a5550d82caff5540649ee0ba6e3b4f3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e345b76a5550d82caff5540649ee0ba6e3b4f3f", "html_url": "https://github.com/rust-lang/rust/commit/0e345b76a5550d82caff5540649ee0ba6e3b4f3f"}], "stats": {"total": 175, "additions": 89, "deletions": 86}, "files": [{"sha": "b7ba9d978784627a3752e6c374b067dc05d26538", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/arg_matrix.rs", "status": "modified", "additions": 51, "deletions": 43, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/1d68e6d67452c0de61e133553a28c8871e96837a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Farg_matrix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d68e6d67452c0de61e133553a28c8871e96837a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Farg_matrix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Farg_matrix.rs?ref=1d68e6d67452c0de61e133553a28c8871e96837a", "patch": "@@ -3,6 +3,7 @@ use std::cmp;\n use rustc_middle::ty::error::TypeError;\n \n // An issue that might be found in the compatibility matrix\n+#[derive(Debug)]\n enum Issue {\n     /// The given argument is the invalid type for the input\n     Invalid(usize),\n@@ -23,9 +24,10 @@ pub(crate) enum Compatibility<'tcx> {\n }\n \n /// Similar to `Issue`, but contains some extra information\n+#[derive(Debug)]\n pub(crate) enum Error<'tcx> {\n-    /// The given argument is the invalid type for the input\n-    Invalid(usize, Compatibility<'tcx>),\n+    /// The provided argument is the invalid type for the expected input\n+    Invalid(usize, usize, Compatibility<'tcx>), // provided, expected\n     /// There is a missing input\n     Missing(usize),\n     /// There's a superfluous argument\n@@ -37,8 +39,15 @@ pub(crate) enum Error<'tcx> {\n }\n \n pub(crate) struct ArgMatrix<'tcx> {\n+    /// Maps the indices in the `compatibility_matrix` rows to the indices of\n+    /// the *user provided* inputs\n     input_indexes: Vec<usize>,\n+    /// Maps the indices in the `compatibility_matrix` columns to the indices\n+    /// of the *expected* args\n     arg_indexes: Vec<usize>,\n+    /// The first dimension (rows) are the remaining user provided inputs to\n+    /// match and the second dimension (cols) are the remaining expected args\n+    /// to match\n     compatibility_matrix: Vec<Vec<Compatibility<'tcx>>>,\n }\n \n@@ -52,24 +61,24 @@ impl<'tcx> ArgMatrix<'tcx> {\n             .map(|i| (0..minimum_input_count).map(|j| is_compatible(i, j)).collect())\n             .collect();\n         ArgMatrix {\n-            input_indexes: (0..minimum_input_count).collect(),\n-            arg_indexes: (0..provided_arg_count).collect(),\n+            input_indexes: (0..provided_arg_count).collect(),\n+            arg_indexes: (0..minimum_input_count).collect(),\n             compatibility_matrix,\n         }\n     }\n \n     /// Remove a given input from consideration\n     fn eliminate_input(&mut self, idx: usize) {\n         self.input_indexes.remove(idx);\n-        for row in &mut self.compatibility_matrix {\n-            row.remove(idx);\n-        }\n+        self.compatibility_matrix.remove(idx);\n     }\n \n     /// Remove a given argument from consideration\n     fn eliminate_arg(&mut self, idx: usize) {\n         self.arg_indexes.remove(idx);\n-        self.compatibility_matrix.remove(idx);\n+        for row in &mut self.compatibility_matrix {\n+            row.remove(idx);\n+        }\n     }\n \n     /// \"satisfy\" an input with a given arg, removing both from consideration\n@@ -78,21 +87,23 @@ impl<'tcx> ArgMatrix<'tcx> {\n         self.eliminate_arg(arg_idx);\n     }\n \n+    // Returns a `Vec` of (user input, expected arg) of matched arguments. These\n+    // are inputs on the remaining diagonal that match.\n     fn eliminate_satisfied(&mut self) -> Vec<(usize, usize)> {\n         let mut i = cmp::min(self.input_indexes.len(), self.arg_indexes.len());\n         let mut eliminated = vec![];\n         while i > 0 {\n             let idx = i - 1;\n             if matches!(self.compatibility_matrix[idx][idx], Compatibility::Compatible) {\n-                eliminated.push((self.arg_indexes[idx], self.input_indexes[idx]));\n+                eliminated.push((self.input_indexes[idx], self.arg_indexes[idx]));\n                 self.satisfy_input(idx, idx);\n             }\n             i -= 1;\n         }\n         return eliminated;\n     }\n \n-    // Check for the above mismatch cases\n+    // Find some issue in the compatibility matrix\n     fn find_issue(&self) -> Option<Issue> {\n         let mat = &self.compatibility_matrix;\n         let ai = &self.arg_indexes;\n@@ -121,26 +132,26 @@ impl<'tcx> ArgMatrix<'tcx> {\n             if is_arg {\n                 for j in 0..ii.len() {\n                     // If we find at least one input this argument could satisfy\n-                    // this argument isn't completely useless\n-                    if matches!(mat[i][j], Compatibility::Compatible) {\n-                        useless = false;\n+                    // this argument isn't unsatisfiable\n+                    if matches!(mat[j][i], Compatibility::Compatible) {\n+                        unsatisfiable = false;\n                         break;\n                     }\n                 }\n             }\n             if is_input {\n                 for j in 0..ai.len() {\n                     // If we find at least one argument that could satisfy this input\n-                    // this argument isn't unsatisfiable\n-                    if matches!(mat[j][i], Compatibility::Compatible) {\n-                        unsatisfiable = false;\n+                    // this argument isn't useless\n+                    if matches!(mat[i][j], Compatibility::Compatible) {\n+                        useless = false;\n                         break;\n                     }\n                 }\n             }\n \n-            match (is_arg, is_input, useless, unsatisfiable) {\n-                // If an input is unsatisfied, and the argument in its position is useless\n+            match (is_input, is_arg, useless, unsatisfiable) {\n+                // If an argument is unsatisfied, and the input in its position is useless\n                 // then the most likely explanation is that we just got the types wrong\n                 (true, true, true, true) => return Some(Issue::Invalid(i)),\n                 // Otherwise, if an input is useless, then indicate that this is an extra argument\n@@ -167,7 +178,7 @@ impl<'tcx> ArgMatrix<'tcx> {\n                 _ => {\n                     continue;\n                 }\n-            };\n+            }\n         }\n \n         // We didn't find any of the individual issues above, but\n@@ -254,11 +265,11 @@ impl<'tcx> ArgMatrix<'tcx> {\n     // We'll want to know which arguments and inputs these rows and columns correspond to\n     // even after we delete them.\n     pub(crate) fn find_errors(mut self) -> (Vec<Error<'tcx>>, Vec<Option<usize>>) {\n-        let provided_arg_count = self.arg_indexes.len();\n+        let provided_arg_count = self.input_indexes.len();\n \n         let mut errors: Vec<Error<'tcx>> = vec![];\n         // For each expected argument, the matched *actual* input\n-        let mut matched_inputs: Vec<Option<usize>> = vec![None; self.input_indexes.len()];\n+        let mut matched_inputs: Vec<Option<usize>> = vec![None; self.arg_indexes.len()];\n \n         // Before we start looking for issues, eliminate any arguments that are already satisfied,\n         // so that an argument which is already spoken for by the input it's in doesn't\n@@ -269,28 +280,28 @@ impl<'tcx> ArgMatrix<'tcx> {\n         // Without this elimination, the first argument causes the second argument\n         // to show up as both a missing input and extra argument, rather than\n         // just an invalid type.\n-        for (arg, inp) in self.eliminate_satisfied() {\n-            matched_inputs[inp] = Some(arg);\n+        for (inp, arg) in self.eliminate_satisfied() {\n+            matched_inputs[arg] = Some(inp);\n         }\n \n         while self.input_indexes.len() > 0 || self.arg_indexes.len() > 0 {\n-            // Check for the first relevant issue\n             match self.find_issue() {\n                 Some(Issue::Invalid(idx)) => {\n                     let compatibility = self.compatibility_matrix[idx][idx].clone();\n                     let input_idx = self.input_indexes[idx];\n+                    let arg_idx = self.arg_indexes[idx];\n                     self.satisfy_input(idx, idx);\n-                    errors.push(Error::Invalid(input_idx, compatibility));\n+                    errors.push(Error::Invalid(input_idx, arg_idx, compatibility));\n                 }\n                 Some(Issue::Extra(idx)) => {\n-                    let arg_idx = self.arg_indexes[idx];\n-                    self.eliminate_arg(idx);\n-                    errors.push(Error::Extra(arg_idx));\n-                }\n-                Some(Issue::Missing(idx)) => {\n                     let input_idx = self.input_indexes[idx];\n                     self.eliminate_input(idx);\n-                    errors.push(Error::Missing(input_idx));\n+                    errors.push(Error::Extra(input_idx));\n+                }\n+                Some(Issue::Missing(idx)) => {\n+                    let arg_idx = self.arg_indexes[idx];\n+                    self.eliminate_arg(idx);\n+                    errors.push(Error::Missing(arg_idx));\n                 }\n                 Some(Issue::Swap(idx, other)) => {\n                     let input_idx = self.input_indexes[idx];\n@@ -302,24 +313,21 @@ impl<'tcx> ArgMatrix<'tcx> {\n                     // Subtract 1 because we already removed the \"min\" row\n                     self.satisfy_input(max - 1, min);\n                     errors.push(Error::Swap(input_idx, other_input_idx, arg_idx, other_arg_idx));\n-                    matched_inputs[input_idx] = Some(other_arg_idx);\n-                    matched_inputs[other_input_idx] = Some(arg_idx);\n+                    matched_inputs[other_arg_idx] = Some(input_idx);\n+                    matched_inputs[arg_idx] = Some(other_input_idx);\n                 }\n                 Some(Issue::Permutation(args)) => {\n-                    // FIXME: If satisfy_input ever did anything non-trivial (emit obligations to help type checking, for example)\n-                    // we'd want to call this function with the correct arg/input pairs, but for now, we just throw them in a bucket.\n-                    // This works because they force a cycle, so each row is guaranteed to also be a column\n                     let mut idxs: Vec<usize> = args.iter().filter_map(|&a| a).collect();\n \n                     let mut real_idxs = vec![None; provided_arg_count];\n                     for (src, dst) in\n                         args.iter().enumerate().filter_map(|(src, dst)| dst.map(|dst| (src, dst)))\n                     {\n-                        let src_arg = self.arg_indexes[src];\n-                        let dst_arg = self.arg_indexes[dst];\n-                        let dest_input = self.input_indexes[dst];\n-                        real_idxs[src_arg] = Some((dst_arg, dest_input));\n-                        matched_inputs[dest_input] = Some(src_arg);\n+                        let src_input_idx = self.input_indexes[src];\n+                        let dst_input_idx = self.input_indexes[dst];\n+                        let dest_arg_idx = self.arg_indexes[dst];\n+                        real_idxs[src_input_idx] = Some((dest_arg_idx, dst_input_idx));\n+                        matched_inputs[dest_arg_idx] = Some(src_input_idx);\n                     }\n                     idxs.sort();\n                     idxs.reverse();\n@@ -331,8 +339,8 @@ impl<'tcx> ArgMatrix<'tcx> {\n                 None => {\n                     // We didn't find any issues, so we need to push the algorithm forward\n                     // First, eliminate any arguments that currently satisfy their inputs\n-                    for (arg, inp) in self.eliminate_satisfied() {\n-                        matched_inputs[inp] = Some(arg);\n+                    for (inp, arg) in self.eliminate_satisfied() {\n+                        matched_inputs[arg] = Some(inp);\n                     }\n                 }\n             };"}, {"sha": "847c2c32dba293f6487091932015837559d34954", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 38, "deletions": 43, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/1d68e6d67452c0de61e133553a28c8871e96837a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d68e6d67452c0de61e133553a28c8871e96837a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=1d68e6d67452c0de61e133553a28c8871e96837a", "patch": "@@ -274,9 +274,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // A \"softer\" version of the helper above, which checks types without persisting them,\n         // and treats error types differently\n         // This will allow us to \"probe\" for other argument orders that would likely have been correct\n-        let check_compatible = |arg_idx, input_idx| {\n-            let formal_input_ty: Ty<'tcx> = formal_input_tys[input_idx];\n-            let expected_input_ty: Ty<'tcx> = expected_input_tys[input_idx];\n+        let check_compatible = |input_idx, arg_idx| {\n+            let formal_input_ty: Ty<'tcx> = formal_input_tys[arg_idx];\n+            let expected_input_ty: Ty<'tcx> = expected_input_tys[arg_idx];\n \n             // If either is an error type, we defy the usual convention and consider them to *not* be\n             // coercible.  This prevents our error message heuristic from trying to pass errors into\n@@ -285,7 +285,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 return Compatibility::Incompatible(None);\n             }\n \n-            let provided_arg: &hir::Expr<'tcx> = &provided_args[arg_idx];\n+            let provided_arg: &hir::Expr<'tcx> = &provided_args[input_idx];\n             let expectation = Expectation::rvalue_hint(self, expected_input_ty);\n             // FIXME: check that this is safe; I don't believe this commits any of the obligations, but I can't be sure.\n             //\n@@ -429,11 +429,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let found_errors = !errors.is_empty();\n \n             errors.drain_filter(|error| {\n-                let Error::Invalid(input_idx, Compatibility::Incompatible(error)) = error else { return false };\n-                let expected_ty = expected_input_tys[*input_idx];\n-                let Some(Some((provided_ty, _))) = final_arg_types.get(*input_idx) else { return false };\n+                let Error::Invalid(input_idx, arg_idx, Compatibility::Incompatible(error)) = error else { return false };\n+                let expected_ty = expected_input_tys[*arg_idx];\n+                let provided_ty = final_arg_types[*input_idx].map(|ty| ty.0).unwrap();\n                 let cause = &self.misc(provided_args[*input_idx].span);\n-                let trace = TypeTrace::types(cause, true, expected_ty, *provided_ty);\n+                let trace = TypeTrace::types(cause, true, expected_ty, provided_ty);\n                 if let Some(e) = error {\n                     if !matches!(trace.cause.as_failure_code(e), FailureCode::Error0308(_)) {\n                         self.report_and_explain_type_error(trace, e).emit();\n@@ -562,11 +562,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // Next special case: if there is only one \"Incompatible\" error, just emit that\n             if errors.len() == 1 {\n-                if let Some(Error::Invalid(input_idx, Compatibility::Incompatible(Some(error)))) =\n-                    errors.iter().next()\n+                if let Some(Error::Invalid(\n+                    input_idx,\n+                    arg_idx,\n+                    Compatibility::Incompatible(Some(error)),\n+                )) = errors.iter().next()\n                 {\n-                    let expected_ty = expected_input_tys[*input_idx];\n-                    let provided_ty = final_arg_types[*input_idx].map(|ty| ty.0).unwrap();\n+                    let expected_ty = expected_input_tys[*arg_idx];\n+                    let provided_ty = final_arg_types[*arg_idx].map(|ty| ty.0).unwrap();\n                     let expected_ty = self.resolve_vars_if_possible(expected_ty);\n                     let provided_ty = self.resolve_vars_if_possible(provided_ty);\n                     let cause = &self.misc(provided_args[*input_idx].span);\n@@ -631,19 +634,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let mut errors = errors.into_iter().peekable();\n             while let Some(error) = errors.next() {\n                 match error {\n-                    Error::Invalid(input_idx, compatibility) => {\n-                        let expected_ty = expected_input_tys[input_idx];\n-                        let provided_ty = final_arg_types\n-                            .get(input_idx)\n-                            .and_then(|x| x.as_ref())\n-                            .map(|ty| ty.0)\n-                            .unwrap_or(tcx.ty_error());\n+                    Error::Invalid(input_idx, arg_idx, compatibility) => {\n+                        let expected_ty = expected_input_tys[arg_idx];\n+                        let provided_ty = final_arg_types[input_idx].map(|ty| ty.0).unwrap();\n                         let expected_ty = self.resolve_vars_if_possible(expected_ty);\n                         let provided_ty = self.resolve_vars_if_possible(provided_ty);\n                         if let Compatibility::Incompatible(error) = &compatibility {\n-                            let cause = &self.misc(\n-                                provided_args.get(input_idx).map(|i| i.span).unwrap_or(call_span),\n-                            );\n+                            let cause = &self.misc(provided_args[input_idx].span);\n                             let trace = TypeTrace::types(cause, true, expected_ty, provided_ty);\n                             if let Some(e) = error {\n                                 self.note_type_err(\n@@ -658,16 +655,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             }\n                         }\n \n-                        if let Some(expr) = provided_args.get(input_idx) {\n-                            self.emit_coerce_suggestions(\n-                                &mut err,\n-                                &expr,\n-                                final_arg_types[input_idx].map(|ty| ty.0).unwrap(),\n-                                final_arg_types[input_idx].map(|ty| ty.1).unwrap(),\n-                                None,\n-                                None,\n-                            );\n-                        }\n+                        self.emit_coerce_suggestions(\n+                            &mut err,\n+                            &provided_args[input_idx],\n+                            final_arg_types[input_idx].map(|ty| ty.0).unwrap(),\n+                            final_arg_types[input_idx].map(|ty| ty.1).unwrap(),\n+                            None,\n+                            None,\n+                        );\n                     }\n                     Error::Extra(arg_idx) => {\n                         let arg_type = if let Some((_, ty)) = final_arg_types[arg_idx] {\n@@ -843,12 +838,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n                     }\n                     Error::Swap(input_idx, other_input_idx, arg_idx, other_arg_idx) => {\n-                        let first_span = provided_args[arg_idx].span;\n-                        let second_span = provided_args[other_arg_idx].span;\n+                        let first_span = provided_args[input_idx].span;\n+                        let second_span = provided_args[other_input_idx].span;\n \n                         let first_expected_ty =\n-                            self.resolve_vars_if_possible(expected_input_tys[input_idx]);\n-                        let first_provided_ty = if let Some((ty, _)) = final_arg_types[arg_idx] {\n+                            self.resolve_vars_if_possible(expected_input_tys[arg_idx]);\n+                        let first_provided_ty = if let Some((ty, _)) = final_arg_types[input_idx] {\n                             format!(\",found `{}`\", ty)\n                         } else {\n                             \"\".into()\n@@ -858,9 +853,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             format!(\"expected `{}`{}\", first_expected_ty, first_provided_ty),\n                         ));\n                         let other_expected_ty =\n-                            self.resolve_vars_if_possible(expected_input_tys[other_input_idx]);\n+                            self.resolve_vars_if_possible(expected_input_tys[other_arg_idx]);\n                         let other_provided_ty =\n-                            if let Some((ty, _)) = final_arg_types[other_arg_idx] {\n+                            if let Some((ty, _)) = final_arg_types[other_input_idx] {\n                                 format!(\",found `{}`\", ty)\n                             } else {\n                                 \"\".into()\n@@ -926,14 +921,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     \"{}(\",\n                     source_map.span_to_snippet(full_call_span).unwrap_or_else(|_| String::new())\n                 );\n-                for (idx, arg) in matched_inputs.iter().enumerate() {\n-                    let suggestion_text = if let Some(arg) = arg {\n-                        let arg_span = provided_args[*arg].span.source_callsite();\n+                for (arg_index, input_idx) in matched_inputs.iter().enumerate() {\n+                    let suggestion_text = if let Some(input_idx) = input_idx {\n+                        let arg_span = provided_args[*input_idx].span.source_callsite();\n                         let arg_text = source_map.span_to_snippet(arg_span).unwrap();\n                         arg_text\n                     } else {\n                         // Propose a placeholder of the correct type\n-                        let expected_ty = expected_input_tys[idx];\n+                        let expected_ty = expected_input_tys[arg_index];\n                         let input_ty = self.resolve_vars_if_possible(expected_ty);\n                         if input_ty.is_unit() {\n                             \"()\".to_string()\n@@ -942,7 +937,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n                     };\n                     suggestion += &suggestion_text;\n-                    if idx < minimum_input_count - 1 {\n+                    if arg_index < minimum_input_count - 1 {\n                         suggestion += \", \";\n                     }\n                 }"}]}