{"sha": "06755d90ce3bf9694060e579439ee4e8345e4512", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2NzU1ZDkwY2UzYmY5Njk0MDYwZTU3OTQzOWVlNGU4MzQ1ZTQ1MTI=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-02-15T21:40:38Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-02-15T21:40:38Z"}, "message": "Split PatKind::Enum into PatKind::TupleStruct and PatKind::Path", "tree": {"sha": "325bb8ae969f1b147a0e725b570fba0b0b7a8098", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/325bb8ae969f1b147a0e725b570fba0b0b7a8098"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06755d90ce3bf9694060e579439ee4e8345e4512", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06755d90ce3bf9694060e579439ee4e8345e4512", "html_url": "https://github.com/rust-lang/rust/commit/06755d90ce3bf9694060e579439ee4e8345e4512", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06755d90ce3bf9694060e579439ee4e8345e4512/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b40e1e5b3d75c101b1ad78a1e2160962e955174", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b40e1e5b3d75c101b1ad78a1e2160962e955174", "html_url": "https://github.com/rust-lang/rust/commit/9b40e1e5b3d75c101b1ad78a1e2160962e955174"}], "stats": {"total": 279, "additions": 137, "deletions": 142}, "files": [{"sha": "701a459690889388847e0e9a23a592496f05891f", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=06755d90ce3bf9694060e579439ee4e8345e4512", "patch": "@@ -100,7 +100,8 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn pat(&mut self, pat: &hir::Pat, pred: CFGIndex) -> CFGIndex {\n         match pat.node {\n             PatKind::Ident(_, _, None) |\n-            PatKind::Enum(_, None) |\n+            PatKind::TupleStruct(_, None) |\n+            PatKind::Path(..) |\n             PatKind::QPath(..) |\n             PatKind::Lit(..) |\n             PatKind::Range(..) |\n@@ -115,7 +116,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.add_ast_node(pat.id, &[subpat_exit])\n             }\n \n-            PatKind::Enum(_, Some(ref subpats)) |\n+            PatKind::TupleStruct(_, Some(ref subpats)) |\n             PatKind::Tup(ref subpats) => {\n                 let pats_exit = self.pats_all(subpats.iter(), pred);\n                 self.add_ast_node(pat.id, &[pats_exit])"}, {"sha": "246a4e9f28f6b31082005d87666e1232e64d76be", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 42, "deletions": 51, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=06755d90ce3bf9694060e579439ee4e8345e4512", "patch": "@@ -377,7 +377,7 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix, source: hir:\n                 hir::MatchSource::ForLoopDesugar => {\n                     // `witnesses[0]` has the form `Some(<head>)`, peel off the `Some`\n                     let witness = match witnesses[0].node {\n-                        PatKind::Enum(_, Some(ref pats)) => match &pats[..] {\n+                        PatKind::TupleStruct(_, Some(ref pats)) => match &pats[..] {\n                             [ref pat] => &**pat,\n                             _ => unreachable!(),\n                         },\n@@ -466,7 +466,7 @@ impl<'map> ast_util::IdVisitingOperation for RenamingRecorder<'map> {\n impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n     fn fold_pat(&mut self, pat: P<Pat>) -> P<Pat> {\n         return match pat.node {\n-            PatKind::Ident(..) | PatKind::Enum(..) | PatKind::QPath(..) => {\n+            PatKind::Ident(..) | PatKind::Path(..) | PatKind::QPath(..) => {\n                 let def = self.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def());\n                 match def {\n                     Some(Def::AssociatedConst(did)) |\n@@ -534,22 +534,28 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n \n         ty::TyEnum(adt, _) | ty::TyStruct(adt, _)  => {\n             let v = adt.variant_of_ctor(ctor);\n-            if let VariantKind::Struct = v.kind() {\n-                let field_pats: hir::HirVec<_> = v.fields.iter()\n-                    .zip(pats)\n-                    .filter(|&(_, ref pat)| pat.node != PatKind::Wild)\n-                    .map(|(field, pat)| Spanned {\n-                        span: DUMMY_SP,\n-                        node: hir::FieldPat {\n-                            name: field.name,\n-                            pat: pat,\n-                            is_shorthand: false,\n-                        }\n-                    }).collect();\n-                let has_more_fields = field_pats.len() < pats_len;\n-                PatKind::Struct(def_to_path(cx.tcx, v.did), field_pats, has_more_fields)\n-            } else {\n-                PatKind::Enum(def_to_path(cx.tcx, v.did), Some(pats.collect()))\n+            match v.kind() {\n+                VariantKind::Struct => {\n+                    let field_pats: hir::HirVec<_> = v.fields.iter()\n+                        .zip(pats)\n+                        .filter(|&(_, ref pat)| pat.node != PatKind::Wild)\n+                        .map(|(field, pat)| Spanned {\n+                            span: DUMMY_SP,\n+                            node: hir::FieldPat {\n+                                name: field.name,\n+                                pat: pat,\n+                                is_shorthand: false,\n+                            }\n+                        }).collect();\n+                    let has_more_fields = field_pats.len() < pats_len;\n+                    PatKind::Struct(def_to_path(cx.tcx, v.did), field_pats, has_more_fields)\n+                }\n+                VariantKind::Tuple => {\n+                    PatKind::TupleStruct(def_to_path(cx.tcx, v.did), Some(pats.collect()))\n+                }\n+                VariantKind::Unit => {\n+                    PatKind::Path(def_to_path(cx.tcx, v.did))\n+                }\n             }\n         }\n \n@@ -769,34 +775,20 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n                     left_ty: Ty, max_slice_length: usize) -> Vec<Constructor> {\n     let pat = raw_pat(p);\n     match pat.node {\n-        PatKind::Ident(..) =>\n-            match cx.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n-                Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) =>\n-                    cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n-                                                    been rewritten\"),\n-                Some(Def::Struct(..)) => vec!(Single),\n-                Some(Def::Variant(_, id)) => vec!(Variant(id)),\n-                _ => vec!()\n-            },\n-        PatKind::Enum(..) =>\n-            match cx.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n-                Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) =>\n+        PatKind::Struct(..) | PatKind::TupleStruct(..) | PatKind::Path(..) | PatKind::Ident(..) =>\n+            match cx.tcx.def_map.borrow().get(&pat.id).unwrap().full_def() {\n+                Def::Const(..) | Def::AssociatedConst(..) =>\n                     cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                                     been rewritten\"),\n-                Some(Def::Variant(_, id)) => vec!(Variant(id)),\n-                _ => vec!(Single)\n+                Def::Struct(..) | Def::TyAlias(..) => vec![Single],\n+                Def::Variant(_, id) => vec![Variant(id)],\n+                Def::Local(..) => vec![],\n+                def => cx.tcx.sess.span_bug(pat.span, &format!(\"pat_constructors: unexpected \\\n+                                                                definition {:?}\", def)),\n             },\n         PatKind::QPath(..) =>\n             cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                             been rewritten\"),\n-        PatKind::Struct(..) =>\n-            match cx.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n-                Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) =>\n-                    cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n-                                                    been rewritten\"),\n-                Some(Def::Variant(_, id)) => vec!(Variant(id)),\n-                _ => vec!(Single)\n-            },\n         PatKind::Lit(ref expr) =>\n             vec!(ConstantValue(eval_const_expr(cx.tcx, &expr))),\n         PatKind::Range(ref lo, ref hi) =>\n@@ -880,22 +872,21 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         PatKind::Wild =>\n             Some(vec![DUMMY_WILD_PAT; arity]),\n \n-        PatKind::Ident(_, _, _) => {\n-            let opt_def = cx.tcx.def_map.borrow().get(&pat_id).map(|d| d.full_def());\n-            match opt_def {\n-                Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) =>\n+        PatKind::Path(..) | PatKind::Ident(..) => {\n+            let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n+            match def {\n+                Def::Const(..) | Def::AssociatedConst(..) =>\n                     cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n                                                     been rewritten\"),\n-                Some(Def::Variant(_, id)) => if *constructor == Variant(id) {\n-                    Some(vec!())\n-                } else {\n-                    None\n-                },\n-                _ => Some(vec![DUMMY_WILD_PAT; arity])\n+                Def::Variant(_, id) if *constructor != Variant(id) => None,\n+                Def::Variant(..) | Def::Struct(..) => Some(Vec::new()),\n+                Def::Local(..) => Some(vec![DUMMY_WILD_PAT; arity]),\n+                _ => cx.tcx.sess.span_bug(pat_span, &format!(\"specialize: unexpected \\\n+                                                              definition {:?}\", def)),\n             }\n         }\n \n-        PatKind::Enum(_, ref args) => {\n+        PatKind::TupleStruct(_, ref args) => {\n             let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n             match def {\n                 Def::Const(..) | Def::AssociatedConst(..) =>"}, {"sha": "9ec79c84afb30b6d61ee132fceaec0060321af0d", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=06755d90ce3bf9694060e579439ee4e8345e4512", "patch": "@@ -343,7 +343,7 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<hir::Pat>\n                 _ => unreachable!()\n             };\n             let pats = args.iter().map(|expr| const_expr_to_pat(tcx, &expr, span)).collect();\n-            PatKind::Enum(path, Some(pats))\n+            PatKind::TupleStruct(path, Some(pats))\n         }\n \n         hir::ExprStruct(ref path, ref fields, None) => {\n@@ -366,10 +366,8 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<hir::Pat>\n         hir::ExprPath(_, ref path) => {\n             let opt_def = tcx.def_map.borrow().get(&expr.id).map(|d| d.full_def());\n             match opt_def {\n-                Some(Def::Struct(..)) =>\n-                    PatKind::Struct(path.clone(), hir::HirVec::new(), false),\n-                Some(Def::Variant(..)) =>\n-                    PatKind::Enum(path.clone(), None),\n+                Some(Def::Struct(..)) | Some(Def::Variant(..)) =>\n+                    PatKind::Path(path.clone()),\n                 Some(Def::Const(def_id)) |\n                 Some(Def::AssociatedConst(def_id)) => {\n                     let expr = lookup_const_by_id(tcx, def_id, Some(expr.id), None).unwrap();"}, {"sha": "9b315aa46e5d372d9ab250a0be6c71f5d2fa8bea", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=06755d90ce3bf9694060e579439ee4e8345e4512", "patch": "@@ -1070,7 +1070,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n             let tcx = typer.tcx;\n \n             match pat.node {\n-                PatKind::Enum(_, _) | PatKind::QPath(..) |\n+                PatKind::TupleStruct(..) | PatKind::Path(..) | PatKind::QPath(..) |\n                 PatKind::Ident(_, _, None) | PatKind::Struct(..) => {\n                     match def_map.get(&pat.id).map(|d| d.full_def()) {\n                         None => {"}, {"sha": "c16997157bd9fb9268eeaf9a2f42e6c2ba018ca9", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=06755d90ce3bf9694060e579439ee4e8345e4512", "patch": "@@ -1209,7 +1209,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n             None\n         };\n \n-        // Note: This goes up here (rather than within the PatKind::Enum arm\n+        // Note: This goes up here (rather than within the PatKind::TupleStruct arm\n         // alone) because struct patterns can refer to struct types or\n         // to struct variants within enums.\n         let cmt = match opt_def {\n@@ -1226,10 +1226,10 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n             // _\n           }\n \n-          PatKind::Enum(_, None) => {\n+          PatKind::TupleStruct(_, None) => {\n             // variant(..)\n           }\n-          PatKind::Enum(_, Some(ref subpats)) => {\n+          PatKind::TupleStruct(_, Some(ref subpats)) => {\n             match opt_def {\n                 Some(Def::Variant(..)) => {\n                     // variant(x, y, z)\n@@ -1267,18 +1267,14 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n             }\n           }\n \n-          PatKind::QPath(..) => {\n-              // Lone constant: ignore\n+          PatKind::Path(..) | PatKind::QPath(..) | PatKind::Ident(_, _, None) => {\n+              // Lone constant, or unit variant or identifier: ignore\n           }\n \n           PatKind::Ident(_, _, Some(ref subpat)) => {\n               try!(self.cat_pattern_(cmt, &subpat, op));\n           }\n \n-          PatKind::Ident(_, _, None) => {\n-              // nullary variant or identifier: ignore\n-          }\n-\n           PatKind::Struct(_, ref field_pats, _) => {\n             // {f1: p1, ..., fN: pN}\n             for fp in field_pats {"}, {"sha": "a1a3c194efe078d20b82b5885daa2d2027cea60c", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=06755d90ce3bf9694060e579439ee4e8345e4512", "patch": "@@ -35,7 +35,8 @@ pub fn pat_id_map(dm: &RefCell<DefMap>, pat: &hir::Pat) -> PatIdMap {\n pub fn pat_is_refutable(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n         PatKind::Lit(_) | PatKind::Range(_, _) | PatKind::QPath(..) => true,\n-        PatKind::Enum(_, _) |\n+        PatKind::TupleStruct(..) |\n+        PatKind::Path(..) |\n         PatKind::Ident(_, _, None) |\n         PatKind::Struct(..) => {\n             match dm.get(&pat.id).map(|d| d.full_def()) {\n@@ -50,11 +51,12 @@ pub fn pat_is_refutable(dm: &DefMap, pat: &hir::Pat) -> bool {\n \n pub fn pat_is_variant_or_struct(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n-        PatKind::Enum(_, _) |\n+        PatKind::TupleStruct(..) |\n+        PatKind::Path(..) |\n         PatKind::Ident(_, _, None) |\n         PatKind::Struct(..) => {\n             match dm.get(&pat.id).map(|d| d.full_def()) {\n-                Some(Def::Variant(..)) | Some(Def::Struct(..)) => true,\n+                Some(Def::Variant(..)) | Some(Def::Struct(..)) | Some(Def::TyAlias(..)) => true,\n                 _ => false\n             }\n         }\n@@ -64,7 +66,7 @@ pub fn pat_is_variant_or_struct(dm: &DefMap, pat: &hir::Pat) -> bool {\n \n pub fn pat_is_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n-        PatKind::Ident(_, _, None) | PatKind::Enum(..) | PatKind::QPath(..) => {\n+        PatKind::Ident(_, _, None) | PatKind::Path(..) | PatKind::QPath(..) => {\n             match dm.get(&pat.id).map(|d| d.full_def()) {\n                 Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => true,\n                 _ => false\n@@ -78,7 +80,7 @@ pub fn pat_is_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n // returned instead of a panic.\n pub fn pat_is_resolved_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n-        PatKind::Ident(_, _, None) | PatKind::Enum(..) | PatKind::QPath(..) => {\n+        PatKind::Ident(_, _, None) | PatKind::Path(..) | PatKind::QPath(..) => {\n             match dm.get(&pat.id)\n                     .and_then(|d| if d.depth == 0 { Some(d.base_def) }\n                                   else { None } ) {\n@@ -224,7 +226,8 @@ pub fn necessary_variants(dm: &DefMap, pat: &hir::Pat) -> Vec<DefId> {\n     let mut variants = vec![];\n     walk_pat(pat, |p| {\n         match p.node {\n-            PatKind::Enum(_, _) |\n+            PatKind::TupleStruct(..) |\n+            PatKind::Path(..) |\n             PatKind::Ident(_, _, None) |\n             PatKind::Struct(..) => {\n                 match dm.get(&p.id) {"}, {"sha": "b39964e2861e33a60bef8c985da8efe405de0bd5", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=06755d90ce3bf9694060e579439ee4e8345e4512", "patch": "@@ -970,7 +970,7 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &hir::Local) {\n                 pats3.iter().any(|p| is_binding_pat(&p))\n             }\n \n-            PatKind::Enum(_, Some(ref subpats)) |\n+            PatKind::TupleStruct(_, Some(ref subpats)) |\n             PatKind::Tup(ref subpats) => {\n                 subpats.iter().any(|p| is_binding_pat(&p))\n             }"}, {"sha": "fbb84c3cd7ec8858c2a2dcf0842836a11812d03b", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=06755d90ce3bf9694060e579439ee4e8345e4512", "patch": "@@ -598,8 +598,8 @@ pub fn check_pat(tcx: &ty::ctxt, pat: &hir::Pat,\n     };\n     match pat.node {\n         // Foo(a, b, c)\n-        // A Variant(..) pattern `PatKind::Enum(_, None)` doesn't have to be recursed into.\n-        PatKind::Enum(_, Some(ref pat_fields)) => {\n+        // A Variant(..) pattern `PatKind::TupleStruct(_, None)` doesn't have to be recursed into.\n+        PatKind::TupleStruct(_, Some(ref pat_fields)) => {\n             for (field, struct_field) in pat_fields.iter().zip(&v.fields) {\n                 maybe_do_stability_check(tcx, struct_field.did, field.span, cb)\n             }"}, {"sha": "b5e56edb6e47c1e3be06da70f8a393d90b846f18", "filename": "src/librustc_front/fold.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc_front%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc_front%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Ffold.rs?ref=06755d90ce3bf9694060e579439ee4e8345e4512", "patch": "@@ -972,10 +972,13 @@ pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n                              sub.map(|x| folder.fold_pat(x)))\n                 }\n                 PatKind::Lit(e) => PatKind::Lit(folder.fold_expr(e)),\n-                PatKind::Enum(pth, pats) => {\n-                    PatKind::Enum(folder.fold_path(pth),\n+                PatKind::TupleStruct(pth, pats) => {\n+                    PatKind::TupleStruct(folder.fold_path(pth),\n                             pats.map(|pats| pats.move_map(|x| folder.fold_pat(x))))\n                 }\n+                PatKind::Path(pth) => {\n+                    PatKind::Path(folder.fold_path(pth))\n+                }\n                 PatKind::QPath(qself, pth) => {\n                     let qself = QSelf { ty: folder.fold_ty(qself.ty), ..qself };\n                     PatKind::QPath(qself, folder.fold_path(pth))"}, {"sha": "dbc1d71517b75b45c4de90abd2dedd2669fd31c4", "filename": "src/librustc_front/hir.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc_front%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc_front%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fhir.rs?ref=06755d90ce3bf9694060e579439ee4e8345e4512", "patch": "@@ -509,28 +509,34 @@ pub enum PatKind {\n     /// Represents a wildcard pattern (`_`)\n     Wild,\n \n-    /// A PatKind::Ident may either be a new bound variable,\n-    /// or a nullary enum (in which case the third field\n-    /// is None).\n+    /// A `PatKind::Ident` may either be a new bound variable,\n+    /// or a unit struct/variant pattern, or a const pattern (in the last two cases\n+    /// the third field must be `None`).\n     ///\n-    /// In the nullary enum case, the parser can't determine\n+    /// In the unit or const pattern case, the parser can't determine\n     /// which it is. The resolver determines this, and\n-    /// records this pattern's NodeId in an auxiliary\n-    /// set (of \"PatIdents that refer to nullary enums\")\n+    /// records this pattern's `NodeId` in an auxiliary\n+    /// set (of \"PatIdents that refer to unit patterns or constants\").\n     Ident(BindingMode, Spanned<Ident>, Option<P<Pat>>),\n \n+    /// A struct or struct variant pattern, e.g. `Variant {x, y, ..}`.\n+    /// The `bool` is `true` in the presence of a `..`.\n+    Struct(Path, HirVec<Spanned<FieldPat>>, bool),\n+\n+    /// A tuple struct/variant pattern `Variant(x, y, z)`.\n     /// \"None\" means a `Variant(..)` pattern where we don't bind the fields to names.\n-    Enum(Path, Option<HirVec<P<Pat>>>),\n+    TupleStruct(Path, Option<HirVec<P<Pat>>>),\n+\n+    /// A path pattern.\n+    /// Such pattern can be resolved to a unit struct/variant or a constant.\n+    Path(Path),\n \n     /// An associated const named using the qualified path `<T>::CONST` or\n     /// `<T as Trait>::CONST`. Associated consts from inherent impls can be\n     /// referred to as simply `T::CONST`, in which case they will end up as\n-    /// PatKind::Enum, and the resolver will have to sort that out.\n+    /// PatKind::Path, and the resolver will have to sort that out.\n     QPath(QSelf, Path),\n \n-    /// Destructuring of a struct, e.g. `Foo {x, y, ..}`\n-    /// The `bool` is `true` in the presence of a `..`\n-    Struct(Path, HirVec<Spanned<FieldPat>>, bool),\n     /// A tuple pattern `(a, b)`\n     Tup(HirVec<P<Pat>>),\n     /// A `box` pattern"}, {"sha": "c1bcaab9d6819721914099417aadeb974dc180ec", "filename": "src/librustc_front/intravisit.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc_front%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc_front%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fintravisit.rs?ref=06755d90ce3bf9694060e579439ee4e8345e4512", "patch": "@@ -468,12 +468,15 @@ pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(visitor: &mut V,\n \n pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n     match pattern.node {\n-        PatKind::Enum(ref path, ref opt_children) => {\n+        PatKind::TupleStruct(ref path, ref opt_children) => {\n             visitor.visit_path(path, pattern.id);\n             if let Some(ref children) = *opt_children {\n                 walk_list!(visitor, visit_pat, children);\n             }\n         }\n+        PatKind::Path(ref path) => {\n+            visitor.visit_path(path, pattern.id);\n+        }\n         PatKind::QPath(ref qself, ref path) => {\n             visitor.visit_ty(&qself.ty);\n             visitor.visit_path(path, pattern.id)"}, {"sha": "0e7d9db37fdb8fd663b76ccd62bf1302cfda77cf", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=06755d90ce3bf9694060e579439ee4e8345e4512", "patch": "@@ -921,12 +921,12 @@ pub fn lower_pat(lctx: &LoweringContext, p: &Pat) -> P<hir::Pat> {\n             }\n             PatKind::Lit(ref e) => hir::PatKind::Lit(lower_expr(lctx, e)),\n             PatKind::TupleStruct(ref pth, ref pats) => {\n-                hir::PatKind::Enum(lower_path(lctx, pth),\n+                hir::PatKind::TupleStruct(lower_path(lctx, pth),\n                              pats.as_ref()\n                                  .map(|pats| pats.iter().map(|x| lower_pat(lctx, x)).collect()))\n             }\n             PatKind::Path(ref pth) => {\n-                hir::PatKind::Enum(lower_path(lctx, pth), Some(hir::HirVec::new()))\n+                hir::PatKind::Path(lower_path(lctx, pth))\n             }\n             PatKind::QPath(ref qself, ref pth) => {\n                 let qself = hir::QSelf {\n@@ -1750,7 +1750,11 @@ fn pat_enum(lctx: &LoweringContext,\n             path: hir::Path,\n             subpats: hir::HirVec<P<hir::Pat>>)\n             -> P<hir::Pat> {\n-    let pt = hir::PatKind::Enum(path, Some(subpats));\n+    let pt = if subpats.is_empty() {\n+        hir::PatKind::Path(path)\n+    } else {\n+        hir::PatKind::TupleStruct(path, Some(subpats))\n+    };\n     pat(lctx, span, pt)\n }\n "}, {"sha": "d837ab0f8f6cbb89a73123381b09c3daa54ba04a", "filename": "src/librustc_front/print/pprust.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fprint%2Fpprust.rs?ref=06755d90ce3bf9694060e579439ee4e8345e4512", "patch": "@@ -1748,19 +1748,20 @@ impl<'a> State<'a> {\n                     None => (),\n                 }\n             }\n-            PatKind::Enum(ref path, ref args_) => {\n+            PatKind::TupleStruct(ref path, ref args_) => {\n                 try!(self.print_path(path, true, 0));\n                 match *args_ {\n                     None => try!(word(&mut self.s, \"(..)\")),\n                     Some(ref args) => {\n-                        if !args.is_empty() {\n-                            try!(self.popen());\n-                            try!(self.commasep(Inconsistent, &args[..], |s, p| s.print_pat(&p)));\n-                            try!(self.pclose());\n-                        }\n+                        try!(self.popen());\n+                        try!(self.commasep(Inconsistent, &args[..], |s, p| s.print_pat(&p)));\n+                        try!(self.pclose());\n                     }\n                 }\n             }\n+            PatKind::Path(ref path) => {\n+                try!(self.print_path(path, true, 0));\n+            }\n             PatKind::QPath(ref qself, ref path) => {\n                 try!(self.print_qpath(path, qself, false));\n             }"}, {"sha": "8140ea1f167d851d0782c5977cdc65f315daa6bc", "filename": "src/librustc_front/util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc_front%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc_front%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Futil.rs?ref=06755d90ce3bf9694060e579439ee4e8345e4512", "patch": "@@ -32,7 +32,7 @@ pub fn walk_pat<F>(pat: &Pat, mut it: F) -> bool\n             PatKind::Struct(_, ref fields, _) => {\n                 fields.iter().all(|field| walk_pat_(&field.node.pat, it))\n             }\n-            PatKind::Enum(_, Some(ref s)) | PatKind::Tup(ref s) => {\n+            PatKind::TupleStruct(_, Some(ref s)) | PatKind::Tup(ref s) => {\n                 s.iter().all(|p| walk_pat_(&p, it))\n             }\n             PatKind::Box(ref s) | PatKind::Ref(ref s, _) => {\n@@ -47,7 +47,8 @@ pub fn walk_pat<F>(pat: &Pat, mut it: F) -> bool\n             PatKind::Lit(_) |\n             PatKind::Range(_, _) |\n             PatKind::Ident(_, _, _) |\n-            PatKind::Enum(_, _) |\n+            PatKind::TupleStruct(..) |\n+            PatKind::Path(..) |\n             PatKind::QPath(_, _) => {\n                 true\n             }"}, {"sha": "c5b34d9246694a3ac30e0a321e4d2f6a313bdbbd", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=06755d90ce3bf9694060e579439ee4e8345e4512", "patch": "@@ -79,7 +79,7 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                 PatternKind::Range { lo: lo, hi: hi }\n             },\n \n-            PatKind::Enum(..) | PatKind::Ident(..) | PatKind::QPath(..)\n+            PatKind::Path(..) | PatKind::Ident(..) | PatKind::QPath(..)\n                 if pat_is_resolved_const(&self.cx.tcx.def_map.borrow(), pat) =>\n             {\n                 let def = self.cx.tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n@@ -179,11 +179,11 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                 }\n             }\n \n-            PatKind::Ident(..) => {\n+            PatKind::Ident(..) | PatKind::Path(..) => {\n                 self.variant_or_leaf(pat, vec![])\n             }\n \n-            PatKind::Enum(_, ref opt_subpatterns) => {\n+            PatKind::TupleStruct(_, ref opt_subpatterns) => {\n                 let subpatterns =\n                     opt_subpatterns.iter()\n                                    .flat_map(|v| v.iter())"}, {"sha": "1424616e792f64ddaa732d7bd09696e938967d10", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=06755d90ce3bf9694060e579439ee4e8345e4512", "patch": "@@ -932,7 +932,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n \n             // Patterns which bind no fields are allowable (the path is check\n             // elsewhere).\n-            PatKind::Enum(_, Some(ref fields)) => {\n+            PatKind::TupleStruct(_, Some(ref fields)) => {\n                 match self.tcx.pat_ty(pattern).sty {\n                     ty::TyStruct(def, _) => {\n                         for (i, field) in fields.iter().enumerate() {"}, {"sha": "22b28865effd8f7b1e4b85cae576fcb43239a785", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=06755d90ce3bf9694060e579439ee4e8345e4512", "patch": "@@ -2473,7 +2473,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 }\n \n-                PatKind::Enum(ref path, _) => {\n+                PatKind::TupleStruct(ref path, _) | PatKind::Path(ref path) => {\n                     // This must be an enum variant, struct or const.\n                     let resolution = match self.resolve_possibly_assoc_item(pat_id,\n                                                                             None,\n@@ -2484,13 +2484,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         // qualified paths should be in PatKind::QPath.\n                         TypecheckRequired =>\n                             self.session.span_bug(path.span,\n-                                                  \"resolve_possibly_assoc_item claimed\n-                                     \\\n-                                                   that a path in PatKind::Enum requires typecheck\n-                                     \\\n-                                                   to resolve, but qualified paths should be\n-                                     \\\n-                                                   PatKind::QPath\"),\n+                                                  \"resolve_possibly_assoc_item claimed that a path \\\n+                                                   in PatKind::Path or PatKind::TupleStruct \\\n+                                                   requires typecheck to resolve, but qualified \\\n+                                                   paths should be PatKind::QPath\"),\n                         ResolveAttempt(resolution) => resolution,\n                     };\n                     if let Some(path_res) = resolution {"}, {"sha": "c5efc9b7e228646dde4dcfbc9a1e24af451f5810", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=06755d90ce3bf9694060e579439ee4e8345e4512", "patch": "@@ -665,7 +665,8 @@ fn get_branches<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             PatKind::Lit(ref l) => {\n                 ConstantValue(ConstantExpr(&l), debug_loc)\n             }\n-            PatKind::Ident(..) | PatKind::Enum(..) | PatKind::Struct(..) => {\n+            PatKind::Ident(..) | PatKind::Path(..) |\n+            PatKind::TupleStruct(..) | PatKind::Struct(..) => {\n                 // This is either an enum variant or a variable binding.\n                 let opt_def = tcx.def_map.borrow().get(&cur.id).map(|d| d.full_def());\n                 match opt_def {\n@@ -798,16 +799,11 @@ fn any_irrefutable_adt_pat(tcx: &ty::ctxt, m: &[Match], col: usize) -> bool {\n         let pat = br.pats[col];\n         match pat.node {\n             PatKind::Tup(_) => true,\n-            PatKind::Struct(..) => {\n-                match tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n-                    Some(Def::Variant(..)) => false,\n-                    _ => true,\n-                }\n-            }\n-            PatKind::Enum(..) | PatKind::Ident(_, _, None) => {\n-                match tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n-                    Some(Def::Struct(..)) => true,\n-                    _ => false\n+            PatKind::Struct(..) | PatKind::TupleStruct(..) |\n+            PatKind::Path(..) | PatKind::Ident(_, _, None) => {\n+                match tcx.def_map.borrow().get(&pat.id).unwrap().full_def() {\n+                    Def::Struct(..) | Def::TyAlias(..) => true,\n+                    _ => false,\n                 }\n             }\n             _ => false\n@@ -1849,7 +1845,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 bcx = bind_irrefutable_pat(bcx, &inner_pat, val, cleanup_scope);\n             }\n         }\n-        PatKind::Enum(_, ref sub_pats) => {\n+        PatKind::TupleStruct(_, ref sub_pats) => {\n             let opt_def = bcx.tcx().def_map.borrow().get(&pat.id).map(|d| d.full_def());\n             match opt_def {\n                 Some(Def::Variant(enum_id, var_id)) => {\n@@ -2013,7 +2009,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                         cleanup_scope)\n                 });\n         }\n-        PatKind::QPath(..) | PatKind::Wild | PatKind::Lit(_) |\n+        PatKind::Path(..) | PatKind::QPath(..) | PatKind::Wild | PatKind::Lit(_) |\n         PatKind::Range(_, _) => ()\n     }\n     return bcx;"}, {"sha": "73fdbd54b29d086b7c36eb7b5678e9910a24dbac", "filename": "src/librustc_trans/trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=06755d90ce3bf9694060e579439ee4e8345e4512", "patch": "@@ -239,7 +239,7 @@ fn walk_pattern(cx: &CrateContext,\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n         }\n \n-        PatKind::Enum(_, ref sub_pats_opt) => {\n+        PatKind::TupleStruct(_, ref sub_pats_opt) => {\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n             if let Some(ref sub_pats) = *sub_pats_opt {\n@@ -249,7 +249,7 @@ fn walk_pattern(cx: &CrateContext,\n             }\n         }\n \n-        PatKind::QPath(..) => {\n+        PatKind::Path(..) | PatKind::QPath(..) => {\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n         }\n "}, {"sha": "bd2c7b3915363130009cab6580e037081a992ff7", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=06755d90ce3bf9694060e579439ee4e8345e4512", "patch": "@@ -135,14 +135,8 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             // subtyping doesn't matter here, as the value is some kind of scalar\n             demand::eqtype(fcx, pat.span, expected, lhs_ty);\n         }\n-        PatKind::Enum(..) | PatKind::Ident(..)\n+        PatKind::Path(..) | PatKind::Ident(..)\n                 if pat_is_resolved_const(&tcx.def_map.borrow(), pat) => {\n-            if let PatKind::Enum(ref path, ref subpats) = pat.node {\n-                if !(subpats.is_some() && subpats.as_ref().unwrap().is_empty()) {\n-                    bad_struct_kind_err(tcx.sess, pat, path, false);\n-                    return;\n-                }\n-            }\n             if let Some(pat_def) = tcx.def_map.borrow().get(&pat.id) {\n                 let const_did = pat_def.def_id();\n                 let const_scheme = tcx.lookup_item_type(const_did);\n@@ -206,10 +200,11 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             let path = hir_util::ident_to_path(path.span, path.node);\n             check_pat_enum(pcx, pat, &path, Some(&[]), expected, false);\n         }\n-        PatKind::Enum(ref path, ref subpats) => {\n-            let subpats = subpats.as_ref().map(|v| &v[..]);\n-            let is_tuple_struct_pat = !(subpats.is_some() && subpats.unwrap().is_empty());\n-            check_pat_enum(pcx, pat, path, subpats, expected, is_tuple_struct_pat);\n+        PatKind::TupleStruct(ref path, ref subpats) => {\n+            check_pat_enum(pcx, pat, path, subpats.as_ref().map(|v| &v[..]), expected, true);\n+        }\n+        PatKind::Path(ref path) => {\n+            check_pat_enum(pcx, pat, path, None, expected, false);\n         }\n         PatKind::QPath(ref qself, ref path) => {\n             let self_ty = fcx.to_ty(&qself.ty);"}, {"sha": "7072f1b498bb91f6bee167e2bb17035f4a9c34d3", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=06755d90ce3bf9694060e579439ee4e8345e4512", "patch": "@@ -2554,7 +2554,7 @@ fn name_from_pat(p: &hir::Pat) -> String {\n     match p.node {\n         PatKind::Wild => \"_\".to_string(),\n         PatKind::Ident(_, ref p, _) => p.node.to_string(),\n-        PatKind::Enum(ref p, _) => path_to_string(p),\n+        PatKind::TupleStruct(ref p, _) | PatKind::Path(ref p) => path_to_string(p),\n         PatKind::QPath(..) => panic!(\"tried to get argument name from PatKind::QPath, \\\n                                 which is not allowed in function arguments\"),\n         PatKind::Struct(ref name, ref fields, etc) => {"}, {"sha": "23bb6fd141a4ed22112dafd8655e705cc50ded19", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06755d90ce3bf9694060e579439ee4e8345e4512/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=06755d90ce3bf9694060e579439ee4e8345e4512", "patch": "@@ -580,7 +580,7 @@ pub enum PatKind {\n     /// An associated const named using the qualified path `<T>::CONST` or\n     /// `<T as Trait>::CONST`. Associated consts from inherent impls can be\n     /// referred to as simply `T::CONST`, in which case they will end up as\n-    /// PatKind::Enum, and the resolver will have to sort that out.\n+    /// PatKind::Path, and the resolver will have to sort that out.\n     QPath(QSelf, Path),\n \n     /// A tuple pattern `(a, b)`"}]}