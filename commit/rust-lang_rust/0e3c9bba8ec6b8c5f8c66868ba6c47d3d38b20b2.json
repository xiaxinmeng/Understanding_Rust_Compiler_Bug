{"sha": "0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlM2M5YmJhOGVjNmI4YzVmOGM2Njg2OGJhNmM0N2QzZDM4YjIwYjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-28T23:10:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-28T23:10:14Z"}, "message": "Auto merge of #48615 - Manishearth:rollup, r=Manishearth\n\nRollup of 10 pull requests\n\n- Successful merges: #48355, #48359, #48380, #48419, #48420, #48461, #48522, #48570, #48572, #48603\n- Failed merges:", "tree": {"sha": "deea138e5eaca89ac78992162eae1c37a5cee807", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/deea138e5eaca89ac78992162eae1c37a5cee807"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "html_url": "https://github.com/rust-lang/rust/commit/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ff9872b2280009f094af0df3dcdc542cc46a5fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ff9872b2280009f094af0df3dcdc542cc46a5fd", "html_url": "https://github.com/rust-lang/rust/commit/0ff9872b2280009f094af0df3dcdc542cc46a5fd"}, {"sha": "b2b970769635d2aefcb6fa75d885c541d3a8a132", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2b970769635d2aefcb6fa75d885c541d3a8a132", "html_url": "https://github.com/rust-lang/rust/commit/b2b970769635d2aefcb6fa75d885c541d3a8a132"}], "stats": {"total": 825, "additions": 677, "deletions": 148}, "files": [{"sha": "39d105399594535a5f0885e67369a796f918e696", "filename": "src/doc/man/rustc.1", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Fdoc%2Fman%2Frustc.1", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Fdoc%2Fman%2Frustc.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fman%2Frustc.1?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -125,6 +125,16 @@ Print version info and exit.\n \\fB\\-v\\fR, \\fB\\-\\-verbose\\fR\n Use verbose output.\n .TP\n+\\fB\\-\\-remap\\-path\\-prefix\\fR \\fIfrom\\fR=\\fIto\\fR\n+Remap source path prefixes in all output, including compiler diagnostics, debug information,\n+macro expansions, etc. The \\fIfrom\\fR=\\fIto\\fR parameter is scanned from right to left, so \\fIfrom\\fR\n+may contain '=', but \\fIto\\fR may not.\n+\n+This is useful for normalizing build products, for example by removing the current directory out of\n+pathnames emitted into the object files. The replacement is purely textual, with no consideration of\n+the current system's pathname syntax. For example \\fI\\-\\-remap\\-path\\-prefix foo=bar\\fR will\n+match \\fBfoo/lib.rs\\fR but not \\fB./foo/lib.rs\\fR.\n+.TP\n \\fB\\-\\-extern\\fR \\fINAME\\fR=\\fIPATH\\fR\n Specify where an external rust library is located. These should match\n \\fIextern\\fR declarations in the crate's source code."}, {"sha": "8ca04d253259258af86b8e2546cc28f943d8734d", "filename": "src/doc/unstable-book/src/compiler-flags/remap-path-prefix.md", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fremap-path-prefix.md", "raw_url": "https://github.com/rust-lang/rust/raw/0ff9872b2280009f094af0df3dcdc542cc46a5fd/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fremap-path-prefix.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fremap-path-prefix.md?ref=0ff9872b2280009f094af0df3dcdc542cc46a5fd", "patch": "@@ -1,37 +0,0 @@\n-# `remap-path-prefix`\n-\n-The tracking issue for this feature is: [#41555](https://github.com/rust-lang/rust/issues/41555)\n-\n-------------------------\n-\n-The `-Z remap-path-prefix-from`, `-Z remap-path-prefix-to` commandline option\n-pair allows to replace prefixes of any file paths the compiler emits in various\n-places. This is useful for bringing debuginfo paths into a well-known form and\n-for achieving reproducible builds independent of the directory the compiler was\n-executed in. All paths emitted by the compiler are affected, including those in\n-error messages.\n-\n-In order to map all paths starting with `/home/foo/my-project/src` to\n-`/sources/my-project`, one would invoke the compiler as follows:\n-\n-```text\n-rustc -Zremap-path-prefix-from=\"/home/foo/my-project/src\" -Zremap-path-prefix-to=\"/sources/my-project\"\n-```\n-\n-Debuginfo for code from the file `/home/foo/my-project/src/foo/mod.rs`,\n-for example, would then point debuggers to `/sources/my-project/foo/mod.rs`\n-instead of the original file.\n-\n-The options can be specified multiple times when multiple prefixes should be\n-mapped:\n-\n-```text\n-rustc -Zremap-path-prefix-from=\"/home/foo/my-project/src\" \\\n-      -Zremap-path-prefix-to=\"/sources/my-project\" \\\n-      -Zremap-path-prefix-from=\"/home/foo/my-project/build-dir\" \\\n-      -Zremap-path-prefix-to=\"/stable-build-dir\"\n-```\n-\n-When the options are given multiple times, the nth `-from` will be matched up\n-with the nth `-to` and they can appear anywhere on the commandline. Mappings\n-specified later on the line will take precedence over earlier ones."}, {"sha": "b06534c9c1ec9c29ed9051ce118d91826fff1ed9", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -1062,8 +1062,8 @@ pub trait Iterator {\n     /// assert_eq!(merged, \"alphabetagamma\");\n     /// ```\n     ///\n-    /// You can also rewrite this in terms of [`flat_map()`] which is preferable\n-    /// in this case since that conveys intent clearer:\n+    /// You can also rewrite this in terms of [`flat_map()`], which is preferable\n+    /// in this case since it conveys intent more clearly:\n     ///\n     /// ```\n     /// let words = [\"alpha\", \"beta\", \"gamma\"];"}, {"sha": "94db0baa3f95f883f9eb73855ce0c0ff24b939fa", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -64,7 +64,8 @@ pub fn panic_fmt(fmt: fmt::Arguments, file_line_col: &(&'static str, u32, u32))\n     #[allow(improper_ctypes)]\n     extern {\n         #[lang = \"panic_fmt\"]\n-        #[unwind]\n+        #[cfg_attr(stage0, unwind)]\n+        #[cfg_attr(not(stage0), unwind(allowed))]\n         fn panic_impl(fmt: fmt::Arguments, file: &'static str, line: u32, col: u32) -> !;\n     }\n     let (file, line, col) = *file_line_col;"}, {"sha": "ca2fd561cadcfcc75d9bb719cc5937fee4227b31", "filename": "src/libpanic_unwind/gcc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibpanic_unwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibpanic_unwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fgcc.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -286,7 +286,8 @@ unsafe fn find_eh_action(context: *mut uw::_Unwind_Context)\n // See docs in the `unwind` module.\n #[cfg(all(target_os=\"windows\", target_arch = \"x86\", target_env=\"gnu\"))]\n #[lang = \"eh_unwind_resume\"]\n-#[unwind]\n+#[cfg_attr(stage0, unwind)]\n+#[cfg_attr(not(stage0), unwind(allowed))]\n unsafe extern \"C\" fn rust_eh_unwind_resume(panic_ctx: *mut u8) -> ! {\n     uw::_Unwind_Resume(panic_ctx as *mut uw::_Unwind_Exception);\n }"}, {"sha": "a5cebc3e4d04b6eee6b74854f82d1146508878d9", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -112,7 +112,8 @@ pub unsafe extern \"C\" fn __rust_maybe_catch_panic(f: fn(*mut u8),\n // Entry point for raising an exception, just delegates to the platform-specific\n // implementation.\n #[no_mangle]\n-#[unwind]\n+#[cfg_attr(stage0, unwind)]\n+#[cfg_attr(not(stage0), unwind(allowed))]\n pub unsafe extern \"C\" fn __rust_start_panic(data: usize, vtable: usize) -> u32 {\n     imp::panic(mem::transmute(raw::TraitObject {\n         data: data as *mut (),"}, {"sha": "090cd095380ee8dfcaffdaeb3600e664130105b3", "filename": "src/libpanic_unwind/seh64_gnu.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh64_gnu.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -108,7 +108,8 @@ unsafe extern \"C\" fn rust_eh_personality(exceptionRecord: *mut c::EXCEPTION_RECO\n }\n \n #[lang = \"eh_unwind_resume\"]\n-#[unwind]\n+#[cfg_attr(stage0, unwind)]\n+#[cfg_attr(not(stage0), unwind(allowed))]\n unsafe extern \"C\" fn rust_eh_unwind_resume(panic_ctx: c::LPVOID) -> ! {\n     let params = [panic_ctx as c::ULONG_PTR];\n     c::RaiseException(RUST_PANIC,"}, {"sha": "50fba5faee747facb0f1309ebd900411f912982e", "filename": "src/libpanic_unwind/windows.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibpanic_unwind%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibpanic_unwind%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fwindows.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -79,18 +79,21 @@ pub enum EXCEPTION_DISPOSITION {\n pub use self::EXCEPTION_DISPOSITION::*;\n \n extern \"system\" {\n-    #[unwind]\n+    #[cfg_attr(stage0, unwind)]\n+    #[cfg_attr(not(stage0), unwind(allowed))]\n     pub fn RaiseException(dwExceptionCode: DWORD,\n                           dwExceptionFlags: DWORD,\n                           nNumberOfArguments: DWORD,\n                           lpArguments: *const ULONG_PTR);\n-    #[unwind]\n+    #[cfg_attr(stage0, unwind)]\n+    #[cfg_attr(not(stage0), unwind(allowed))]\n     pub fn RtlUnwindEx(TargetFrame: LPVOID,\n                        TargetIp: LPVOID,\n                        ExceptionRecord: *const EXCEPTION_RECORD,\n                        ReturnValue: LPVOID,\n                        OriginalContext: *const CONTEXT,\n                        HistoryTable: *const UNWIND_HISTORY_TABLE);\n-    #[unwind]\n+    #[cfg_attr(stage0, unwind)]\n+    #[cfg_attr(not(stage0), unwind(allowed))]\n     pub fn _CxxThrowException(pExceptionObject: *mut c_void, pThrowInfo: *mut u8);\n }"}, {"sha": "b18bb5a24b695dce2a29686ca243bbd141a78e6f", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -316,7 +316,7 @@ impl SourceFile {\n     /// If the code span associated with this `SourceFile` was generated by an external macro, this\n     /// may not be an actual path on the filesystem. Use [`is_real`] to check.\n     ///\n-    /// Also note that even if `is_real` returns `true`, if `-Z remap-path-prefix-*` was passed on\n+    /// Also note that even if `is_real` returns `true`, if `--remap-path-prefix` was passed on\n     /// the command line, the path as given may not actually be valid.\n     ///\n     /// [`is_real`]: #method.is_real"}, {"sha": "b15ee53e22571511049dc4a465d8aa98243650a5", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -46,7 +46,7 @@ use hir::HirVec;\n use hir::map::{Definitions, DefKey, DefPathData};\n use hir::def_id::{DefIndex, DefId, CRATE_DEF_INDEX, DefIndexAddressSpace};\n use hir::def::{Def, PathResolution};\n-use lint::builtin::PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES;\n+use lint::builtin::{self, PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES};\n use middle::cstore::CrateStore;\n use rustc_data_structures::indexed_vec::IndexVec;\n use session::Session;\n@@ -912,7 +912,11 @@ impl<'a> LoweringContext<'a> {\n             TyKind::Path(ref qself, ref path) => {\n                 let id = self.lower_node_id(t.id);\n                 let qpath = self.lower_qpath(t.id, qself, path, ParamMode::Explicit, itctx);\n-                return self.ty_path(id, t.span, qpath);\n+                let ty = self.ty_path(id, t.span, qpath);\n+                if let hir::TyTraitObject(..) = ty.node {\n+                    self.maybe_lint_bare_trait(t.span, t.id, qself.is_none() && path.is_global());\n+                }\n+                return ty;\n             }\n             TyKind::ImplicitSelf => {\n                 hir::TyPath(hir::QPath::Resolved(None, P(hir::Path {\n@@ -931,7 +935,7 @@ impl<'a> LoweringContext<'a> {\n                 let expr = self.lower_body(None, |this| this.lower_expr(expr));\n                 hir::TyTypeof(expr)\n             }\n-            TyKind::TraitObject(ref bounds, ..) => {\n+            TyKind::TraitObject(ref bounds, kind) => {\n                 let mut lifetime_bound = None;\n                 let bounds = bounds.iter().filter_map(|bound| {\n                     match *bound {\n@@ -950,6 +954,9 @@ impl<'a> LoweringContext<'a> {\n                 let lifetime_bound = lifetime_bound.unwrap_or_else(|| {\n                     self.elided_lifetime(t.span)\n                 });\n+                if kind != TraitObjectSyntax::Dyn {\n+                    self.maybe_lint_bare_trait(t.span, t.id, false);\n+                }\n                 hir::TyTraitObject(bounds, lifetime_bound)\n             }\n             TyKind::ImplTrait(ref bounds) => {\n@@ -3685,7 +3692,6 @@ impl<'a> LoweringContext<'a> {\n                     // The original ID is taken by the `PolyTraitRef`,\n                     // so the `Ty` itself needs a different one.\n                     id = self.next_id();\n-\n                     hir::TyTraitObject(hir_vec![principal], self.elided_lifetime(span))\n                 } else {\n                     hir::TyPath(hir::QPath::Resolved(None, path))\n@@ -3703,6 +3709,16 @@ impl<'a> LoweringContext<'a> {\n             name: hir::LifetimeName::Implicit,\n         }\n     }\n+\n+    fn maybe_lint_bare_trait(&self, span: Span, id: NodeId, is_global: bool) {\n+        if self.sess.features.borrow().dyn_trait {\n+            self.sess.buffer_lint_with_diagnostic(\n+                builtin::BARE_TRAIT_OBJECT, id, span,\n+                \"trait objects without an explicit `dyn` are deprecated\",\n+                builtin::BuiltinLintDiagnostics::BareTraitObject(span, is_global)\n+            )\n+        }\n+    }\n }\n \n fn body_ids(bodies: &BTreeMap<hir::BodyId, hir::Body>) -> Vec<hir::BodyId> {"}, {"sha": "f05ed0a460d87cc18bbd278feea4085889df7b73", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -41,6 +41,8 @@\n        html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![deny(warnings)]\n \n+#![cfg_attr(not(stage0), allow(bare_trait_object))]\n+\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(conservative_impl_trait)]"}, {"sha": "b68b7dc6c067256d1fea467c43f8749517006ce2", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -14,7 +14,11 @@\n //! compiler code, rather than using their own custom pass. Those\n //! lints are all available in `rustc_lint::builtin`.\n \n+use errors::DiagnosticBuilder;\n use lint::{LintPass, LateLintPass, LintArray};\n+use session::Session;\n+use session::config::Epoch;\n+use syntax::codemap::Span;\n \n declare_lint! {\n     pub CONST_ERR,\n@@ -252,6 +256,13 @@ declare_lint! {\n     \"hidden lifetime parameters are deprecated, try `Foo<'_>`\"\n }\n \n+declare_lint! {\n+    pub BARE_TRAIT_OBJECT,\n+    Warn,\n+    \"suggest using `dyn Trait` for trait objects\",\n+    Epoch::Epoch2018\n+}\n+\n /// Does nothing as a lint pass, but registers some `Lint`s\n /// which are used by other parts of the compiler.\n #[derive(Copy, Clone)]\n@@ -298,10 +309,34 @@ impl LintPass for HardwiredLints {\n             COERCE_NEVER,\n             SINGLE_USE_LIFETIME,\n             TYVAR_BEHIND_RAW_POINTER,\n-            ELIDED_LIFETIME_IN_PATH\n-\n+            ELIDED_LIFETIME_IN_PATH,\n+            BARE_TRAIT_OBJECT\n         )\n     }\n }\n \n+// this could be a closure, but then implementing derive traits\n+// becomes hacky (and it gets allocated)\n+#[derive(PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+pub enum BuiltinLintDiagnostics {\n+    Normal,\n+    BareTraitObject(Span, /* is_global */ bool)\n+}\n+\n+impl BuiltinLintDiagnostics {\n+    pub fn run(self, sess: &Session, db: &mut DiagnosticBuilder) {\n+        match self {\n+            BuiltinLintDiagnostics::Normal => (),\n+            BuiltinLintDiagnostics::BareTraitObject(span, is_global) => {\n+                let sugg = match sess.codemap().span_to_snippet(span) {\n+                    Ok(ref s) if is_global => format!(\"dyn ({})\", s),\n+                    Ok(s) => format!(\"dyn {}\", s),\n+                    Err(_) => format!(\"dyn <type>\")\n+                };\n+                db.span_suggestion(span, \"use `dyn`\", sugg);\n+            }\n+        }\n+    }\n+}\n+\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for HardwiredLints {}"}, {"sha": "bfd2034dd6cfe4e577089a0d8cf3b9ddd763731c", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 39, "deletions": 9, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -29,6 +29,7 @@ use self::TargetLint::*;\n use std::slice;\n use lint::{EarlyLintPassObject, LateLintPassObject};\n use lint::{Level, Lint, LintId, LintPass, LintBuffer};\n+use lint::builtin::BuiltinLintDiagnostics;\n use lint::levels::{LintLevelSets, LintLevelsBuilder};\n use middle::privacy::AccessLevels;\n use rustc_serialize::{Decoder, Decodable, Encoder, Encodable};\n@@ -92,14 +93,19 @@ pub struct BufferedEarlyLint {\n     pub ast_id: ast::NodeId,\n     pub span: MultiSpan,\n     pub msg: String,\n+    pub diagnostic: BuiltinLintDiagnostics,\n }\n \n /// Extra information for a future incompatibility lint. See the call\n /// to `register_future_incompatible` in `librustc_lint/lib.rs` for\n /// guidelines.\n pub struct FutureIncompatibleInfo {\n     pub id: LintId,\n-    pub reference: &'static str // e.g., a URL for an issue/PR/RFC or error code\n+    /// e.g., a URL for an issue/PR/RFC or error code\n+    pub reference: &'static str,\n+    /// If this is an epoch fixing lint, the epoch in which\n+    /// this lint becomes obsolete\n+    pub epoch: Option<config::Epoch>,\n }\n \n /// The target of the `by_name` map, which accounts for renaming/deprecation.\n@@ -194,11 +200,24 @@ impl LintStore {\n     pub fn register_future_incompatible(&mut self,\n                                         sess: Option<&Session>,\n                                         lints: Vec<FutureIncompatibleInfo>) {\n-        let ids = lints.iter().map(|f| f.id).collect();\n-        self.register_group(sess, false, \"future_incompatible\", ids);\n-        for info in lints {\n-            self.future_incompatible.insert(info.id, info);\n+\n+        for epoch in config::ALL_EPOCHS {\n+            let lints = lints.iter().filter(|f| f.epoch == Some(*epoch)).map(|f| f.id)\n+                             .collect::<Vec<_>>();\n+            if !lints.is_empty() {\n+                self.register_group(sess, false, epoch.lint_name(), lints)\n+            }\n         }\n+\n+        let mut future_incompatible = vec![];\n+        for lint in lints {\n+            future_incompatible.push(lint.id);\n+            self.future_incompatible.insert(lint.id, lint);\n+        }\n+\n+        self.register_group(sess, false, \"future_incompatible\", future_incompatible);\n+\n+\n     }\n \n     pub fn future_incompatible(&self, id: LintId) -> Option<&FutureIncompatibleInfo> {\n@@ -429,6 +448,16 @@ pub trait LintContext<'tcx>: Sized {\n         self.lookup(lint, span, msg).emit();\n     }\n \n+    fn lookup_and_emit_with_diagnostics<S: Into<MultiSpan>>(&self,\n+                                                            lint: &'static Lint,\n+                                                            span: Option<S>,\n+                                                            msg: &str,\n+                                                            diagnostic: BuiltinLintDiagnostics) {\n+        let mut db = self.lookup(lint, span, msg);\n+        diagnostic.run(self.sess(), &mut db);\n+        db.emit();\n+    }\n+\n     fn lookup<S: Into<MultiSpan>>(&self,\n                                   lint: &'static Lint,\n                                   span: Option<S>,\n@@ -499,9 +528,10 @@ impl<'a> EarlyContext<'a> {\n \n     fn check_id(&mut self, id: ast::NodeId) {\n         for early_lint in self.buffered.take(id) {\n-            self.lookup_and_emit(early_lint.lint_id.lint,\n-                                 Some(early_lint.span.clone()),\n-                                 &early_lint.msg);\n+            self.lookup_and_emit_with_diagnostics(early_lint.lint_id.lint,\n+                                                  Some(early_lint.span.clone()),\n+                                                  &early_lint.msg,\n+                                                  early_lint.diagnostic);\n         }\n     }\n }\n@@ -1054,7 +1084,7 @@ pub fn check_ast_crate(sess: &Session, krate: &ast::Crate) {\n     if !sess.opts.actually_rustdoc {\n         for (_id, lints) in cx.buffered.map {\n             for early_lint in lints {\n-                span_bug!(early_lint.span, \"failed to process buffered lint here\");\n+                sess.delay_span_bug(early_lint.span, \"failed to process buffered lint here\");\n             }\n         }\n     }"}, {"sha": "909904b4fc36cd9d16838ca91b21ba6deaf2e70f", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -89,14 +89,15 @@ impl LintLevelSets {\n     fn get_lint_level(&self,\n                       lint: &'static Lint,\n                       idx: u32,\n-                      aux: Option<&FxHashMap<LintId, (Level, LintSource)>>)\n+                      aux: Option<&FxHashMap<LintId, (Level, LintSource)>>,\n+                      sess: &Session)\n         -> (Level, LintSource)\n     {\n         let (level, mut src) = self.get_lint_id_level(LintId::of(lint), idx, aux);\n \n         // If `level` is none then we actually assume the default level for this\n         // lint.\n-        let mut level = level.unwrap_or(lint.default_level);\n+        let mut level = level.unwrap_or(lint.default_level(sess));\n \n         // If we're about to issue a warning, check at the last minute for any\n         // directives against the warnings \"lint\". If, for example, there's an\n@@ -235,7 +236,8 @@ impl<'a> LintLevelsBuilder<'a> {\n                         let lint = builtin::RENAMED_AND_REMOVED_LINTS;\n                         let (level, src) = self.sets.get_lint_level(lint,\n                                                                     self.cur,\n-                                                                    Some(&specs));\n+                                                                    Some(&specs),\n+                                                                    &sess);\n                         lint::struct_lint_level(self.sess,\n                                                 lint,\n                                                 level,\n@@ -248,7 +250,8 @@ impl<'a> LintLevelsBuilder<'a> {\n                         let lint = builtin::UNKNOWN_LINTS;\n                         let (level, src) = self.sets.get_lint_level(lint,\n                                                                     self.cur,\n-                                                                    Some(&specs));\n+                                                                    Some(&specs),\n+                                                                    self.sess);\n                         let msg = format!(\"unknown lint: `{}`\", name);\n                         let mut db = lint::struct_lint_level(self.sess,\n                                                 lint,\n@@ -342,7 +345,7 @@ impl<'a> LintLevelsBuilder<'a> {\n                        msg: &str)\n         -> DiagnosticBuilder<'a>\n     {\n-        let (level, src) = self.sets.get_lint_level(lint, self.cur, None);\n+        let (level, src) = self.sets.get_lint_level(lint, self.cur, None, self.sess);\n         lint::struct_lint_level(self.sess, lint, level, src, span, msg)\n     }\n \n@@ -377,11 +380,11 @@ impl LintLevelMap {\n     /// If the `id` was not previously registered, returns `None`. If `None` is\n     /// returned then the parent of `id` should be acquired and this function\n     /// should be called again.\n-    pub fn level_and_source(&self, lint: &'static Lint, id: HirId)\n+    pub fn level_and_source(&self, lint: &'static Lint, id: HirId, session: &Session)\n         -> Option<(Level, LintSource)>\n     {\n         self.id_to_set.get(&id).map(|idx| {\n-            self.sets.get_lint_level(lint, *idx, None)\n+            self.sets.get_lint_level(lint, *idx, None, session)\n         })\n     }\n "}, {"sha": "a51d06c06edd3a1ebb1a7fd9b5ac8cbe09669555", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -37,7 +37,8 @@ use errors::{DiagnosticBuilder, DiagnosticId};\n use hir::def_id::{CrateNum, LOCAL_CRATE};\n use hir::intravisit::{self, FnKind};\n use hir;\n-use session::{Session, DiagnosticMessageId};\n+use lint::builtin::BuiltinLintDiagnostics;\n+use session::{config, Session, DiagnosticMessageId};\n use std::hash;\n use syntax::ast;\n use syntax::codemap::MultiSpan;\n@@ -74,25 +75,46 @@ pub struct Lint {\n     ///\n     /// e.g. \"imports that are never used\"\n     pub desc: &'static str,\n+\n+    /// Deny lint after this epoch\n+    pub epoch_deny: Option<config::Epoch>,\n }\n \n impl Lint {\n     /// Get the lint's name, with ASCII letters converted to lowercase.\n     pub fn name_lower(&self) -> String {\n         self.name.to_ascii_lowercase()\n     }\n+\n+    pub fn default_level(&self, session: &Session) -> Level {\n+        if let Some(epoch_deny) = self.epoch_deny {\n+            if session.epoch() >= epoch_deny {\n+                return Level::Deny\n+            }\n+        }\n+        self.default_level\n+    }\n }\n \n /// Declare a static item of type `&'static Lint`.\n #[macro_export]\n macro_rules! declare_lint {\n+    ($vis: vis $NAME: ident, $Level: ident, $desc: expr, $epoch: expr) => (\n+        $vis static $NAME: &$crate::lint::Lint = &$crate::lint::Lint {\n+            name: stringify!($NAME),\n+            default_level: $crate::lint::$Level,\n+            desc: $desc,\n+            epoch_deny: Some($epoch)\n+        };\n+    );\n     ($vis: vis $NAME: ident, $Level: ident, $desc: expr) => (\n         $vis static $NAME: &$crate::lint::Lint = &$crate::lint::Lint {\n             name: stringify!($NAME),\n             default_level: $crate::lint::$Level,\n-            desc: $desc\n+            desc: $desc,\n+            epoch_deny: None,\n         };\n-    )\n+    );\n }\n \n /// Declare a static `LintArray` and return it as an expression.\n@@ -304,7 +326,7 @@ impl LintId {\n /// Setting for how to handle a lint.\n #[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]\n pub enum Level {\n-    Allow, Warn, Deny, Forbid\n+    Allow, Warn, Deny, Forbid,\n }\n \n impl_stable_hash_for!(enum self::Level {\n@@ -378,12 +400,14 @@ impl LintBuffer {\n                     lint: &'static Lint,\n                     id: ast::NodeId,\n                     sp: MultiSpan,\n-                    msg: &str) {\n+                    msg: &str,\n+                    diagnostic: BuiltinLintDiagnostics) {\n         let early_lint = BufferedEarlyLint {\n             lint_id: LintId::of(lint),\n             ast_id: id,\n             span: sp,\n             msg: msg.to_string(),\n+            diagnostic\n         };\n         let arr = self.map.entry(id).or_insert(Vec::new());\n         if !arr.contains(&early_lint) {"}, {"sha": "b69f5d6c8bdd79fe98870e314d5e955d0bca4ca5", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 64, "deletions": 32, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -41,7 +41,7 @@ use std::collections::btree_map::Iter as BTreeMapIter;\n use std::collections::btree_map::Keys as BTreeMapKeysIter;\n use std::collections::btree_map::Values as BTreeMapValuesIter;\n \n-use std::fmt;\n+use std::{fmt, str};\n use std::hash::Hasher;\n use std::collections::hash_map::DefaultHasher;\n use std::collections::HashSet;\n@@ -113,7 +113,7 @@ pub enum OutputType {\n }\n \n /// The epoch of the compiler (RFC 2052)\n-#[derive(Clone, Copy, Hash, PartialOrd, Ord, Eq, PartialEq)]\n+#[derive(Clone, Copy, Hash, PartialOrd, Ord, Eq, PartialEq, Debug)]\n #[non_exhaustive]\n pub enum Epoch {\n     // epochs must be kept in order, newest to oldest\n@@ -137,6 +137,37 @@ pub enum Epoch {\n     // as well as changing the default Cargo template.\n }\n \n+pub const ALL_EPOCHS: &[Epoch] = &[Epoch::Epoch2015, Epoch::Epoch2018];\n+\n+impl ToString for Epoch {\n+    fn to_string(&self) -> String {\n+        match *self {\n+            Epoch::Epoch2015 => \"2015\".into(),\n+            Epoch::Epoch2018 => \"2018\".into(),\n+        }\n+    }\n+}\n+\n+impl Epoch {\n+    pub fn lint_name(&self) -> &'static str {\n+        match *self {\n+            Epoch::Epoch2015 => \"epoch_2015\",\n+            Epoch::Epoch2018 => \"epoch_2018\",\n+        }\n+    }\n+}\n+\n+impl str::FromStr for Epoch {\n+    type Err = ();\n+    fn from_str(s: &str) -> Result<Self, ()> {\n+        match s {\n+            \"2015\" => Ok(Epoch::Epoch2015),\n+            \"2018\" => Ok(Epoch::Epoch2018),\n+            _ => Err(())\n+        }\n+    }\n+}\n+\n impl_stable_hash_for!(enum self::OutputType {\n     Bitcode,\n     Assembly,\n@@ -435,6 +466,9 @@ top_level_options!(\n         // if we otherwise use the defaults of rustc.\n         cli_forced_codegen_units: Option<usize> [UNTRACKED],\n         cli_forced_thinlto_off: bool [UNTRACKED],\n+\n+        // Remap source path prefixes in all output (messages, object files, debug, etc)\n+        remap_path_prefix: Vec<(PathBuf, PathBuf)> [UNTRACKED],\n     }\n );\n \n@@ -617,6 +651,7 @@ pub fn basic_options() -> Options {\n         actually_rustdoc: false,\n         cli_forced_codegen_units: None,\n         cli_forced_thinlto_off: false,\n+        remap_path_prefix: Vec::new(),\n     }\n }\n \n@@ -635,11 +670,7 @@ impl Options {\n     }\n \n     pub fn file_path_mapping(&self) -> FilePathMapping {\n-        FilePathMapping::new(\n-            self.debugging_opts.remap_path_prefix_from.iter().zip(\n-                self.debugging_opts.remap_path_prefix_to.iter()\n-            ).map(|(src, dst)| (src.clone(), dst.clone())).collect()\n-        )\n+        FilePathMapping::new(self.remap_path_prefix.clone())\n     }\n \n     /// True if there will be an output file generated\n@@ -1021,11 +1052,17 @@ macro_rules! options {\n \n         fn parse_epoch(slot: &mut Epoch, v: Option<&str>) -> bool {\n             match v {\n-                Some(\"2015\") => *slot = Epoch::Epoch2015,\n-                Some(\"2018\") => *slot = Epoch::Epoch2018,\n-                _ => return false,\n+                Some(s) => {\n+                    let epoch = s.parse();\n+                    if let Ok(parsed) = epoch {\n+                        *slot = parsed;\n+                        true\n+                    } else {\n+                        false\n+                    }\n+                }\n+                _ => false,\n             }\n-            true\n         }\n     }\n ) }\n@@ -1269,10 +1306,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"set the optimization fuel quota for a crate\"),\n     print_fuel: Option<String> = (None, parse_opt_string, [TRACKED],\n         \"make Rustc print the total optimization fuel used by a crate\"),\n-    remap_path_prefix_from: Vec<PathBuf> = (vec![], parse_pathbuf_push, [UNTRACKED],\n-        \"add a source pattern to the file path remapping config\"),\n-    remap_path_prefix_to: Vec<PathBuf> = (vec![], parse_pathbuf_push, [UNTRACKED],\n-        \"add a mapping target to the file path remapping config\"),\n     force_unstable_if_unmarked: bool = (false, parse_bool, [TRACKED],\n         \"force all crates to be `rustc_private` unstable\"),\n     pre_link_arg: Vec<String> = (vec![], parse_string_push, [UNTRACKED],\n@@ -1597,6 +1630,7 @@ pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n                   `expanded` (crates expanded), or\n                   `expanded,identified` (fully parenthesized, AST nodes with IDs).\",\n                  \"TYPE\"),\n+        opt::multi_s(\"\", \"remap-path-prefix\", \"remap source names in output\", \"FROM=TO\"),\n     ]);\n     opts\n }\n@@ -1720,23 +1754,6 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n         output_types.insert(OutputType::Exe, None);\n     }\n \n-    let remap_path_prefix_sources = debugging_opts.remap_path_prefix_from.len();\n-    let remap_path_prefix_targets = debugging_opts.remap_path_prefix_to.len();\n-\n-    if remap_path_prefix_targets < remap_path_prefix_sources {\n-        for source in &debugging_opts.remap_path_prefix_from[remap_path_prefix_targets..] {\n-            early_error(error_format,\n-                &format!(\"option `-Zremap-path-prefix-from='{}'` does not have \\\n-                         a corresponding `-Zremap-path-prefix-to`\", source.display()))\n-        }\n-    } else if remap_path_prefix_targets > remap_path_prefix_sources {\n-        for target in &debugging_opts.remap_path_prefix_to[remap_path_prefix_sources..] {\n-            early_error(error_format,\n-                &format!(\"option `-Zremap-path-prefix-to='{}'` does not have \\\n-                          a corresponding `-Zremap-path-prefix-from`\", target.display()))\n-        }\n-    }\n-\n     let mut cg = build_codegen_options(matches, error_format);\n     let mut codegen_units = cg.codegen_units;\n     let mut disable_thinlto = false;\n@@ -1970,6 +1987,20 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n \n     let crate_name = matches.opt_str(\"crate-name\");\n \n+    let remap_path_prefix = matches.opt_strs(\"remap-path-prefix\")\n+        .into_iter()\n+        .map(|remap| {\n+            let mut parts = remap.rsplitn(2, '='); // reverse iterator\n+            let to = parts.next();\n+            let from = parts.next();\n+            match (from, to) {\n+                (Some(from), Some(to)) => (PathBuf::from(from), PathBuf::from(to)),\n+                _ => early_error(error_format,\n+                        \"--remap-path-prefix must contain '=' between FROM and TO\"),\n+            }\n+        })\n+        .collect();\n+\n     (Options {\n         crate_types,\n         optimize: opt_level,\n@@ -1997,6 +2028,7 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n         actually_rustdoc: false,\n         cli_forced_codegen_units: codegen_units,\n         cli_forced_thinlto_off: disable_thinlto,\n+        remap_path_prefix,\n     },\n     cfg)\n }"}, {"sha": "2437eaadc6d480381598dd24a43fe4fd8d1fc2f3", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -16,6 +16,7 @@ use ich::Fingerprint;\n \n use ich;\n use lint;\n+use lint::builtin::BuiltinLintDiagnostics;\n use middle::allocator::AllocatorKind;\n use middle::dependency_format;\n use session::search_paths::PathKind;\n@@ -341,7 +342,18 @@ impl Session {\n                                            sp: S,\n                                            msg: &str) {\n         match *self.buffered_lints.borrow_mut() {\n-            Some(ref mut buffer) => buffer.add_lint(lint, id, sp.into(), msg),\n+            Some(ref mut buffer) => buffer.add_lint(lint, id, sp.into(),\n+                                                    msg, BuiltinLintDiagnostics::Normal),\n+            None => bug!(\"can't buffer lints after HIR lowering\"),\n+        }\n+    }\n+\n+    pub fn buffer_lint_with_diagnostic<S: Into<MultiSpan>>(&self,\n+        lint: &'static lint::Lint, id: ast::NodeId, sp: S,\n+        msg: &str, diagnostic: BuiltinLintDiagnostics) {\n+        match *self.buffered_lints.borrow_mut() {\n+            Some(ref mut buffer) => buffer.add_lint(lint, id, sp.into(),\n+                                                    msg, diagnostic),\n             None => bug!(\"can't buffer lints after HIR lowering\"),\n         }\n     }\n@@ -869,6 +881,10 @@ impl Session {\n     pub fn rust_2018(&self) -> bool {\n         self.opts.debugging_opts.epoch >= Epoch::Epoch2018\n     }\n+\n+    pub fn epoch(&self) -> Epoch {\n+        self.opts.debugging_opts.epoch\n+    }\n }\n \n pub fn build_session(sopts: config::Options,"}, {"sha": "a39d63d05eeafdf93bcf578db76b68de8edd5136", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -2234,7 +2234,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             let sets = self.lint_levels(LOCAL_CRATE);\n             loop {\n                 let hir_id = self.hir.definitions().node_to_hir_id(id);\n-                if let Some(pair) = sets.level_and_source(lint, hir_id) {\n+                if let Some(pair) = sets.level_and_source(lint, hir_id, self.sess) {\n                     return pair\n                 }\n                 let next = self.hir.get_parent_node(id);"}, {"sha": "2ae800e8cdc96ebc0fe5664d8e5ab89d07facb61", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -737,7 +737,7 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n \n     // Lint plugins are registered; now we can process command line flags.\n     if sess.opts.describe_lints {\n-        super::describe_lints(&sess.lint_store.borrow(), true);\n+        super::describe_lints(&sess, &sess.lint_store.borrow(), true);\n         return Err(CompileIncomplete::Stopped);\n     }\n "}, {"sha": "22c26b0643050546ca85a90e255c0254e25537b1", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -787,15 +787,15 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                 -> Option<(Input, Option<PathBuf>)> {\n         match matches.free.len() {\n             0 => {\n+                let mut sess = build_session(sopts.clone(),\n+                    None,\n+                    descriptions.clone());\n                 if sopts.describe_lints {\n                     let mut ls = lint::LintStore::new();\n-                    rustc_lint::register_builtins(&mut ls, None);\n-                    describe_lints(&ls, false);\n+                    rustc_lint::register_builtins(&mut ls, Some(&sess));\n+                    describe_lints(&sess, &ls, false);\n                     return None;\n                 }\n-                let mut sess = build_session(sopts.clone(),\n-                    None,\n-                    descriptions.clone());\n                 rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n                 let mut cfg = config::build_configuration(&sess, cfg.clone());\n                 let trans = get_trans(&sess);\n@@ -1134,7 +1134,7 @@ fn usage(verbose: bool, include_unstable_options: bool) {\n              verbose_help);\n }\n \n-fn describe_lints(lint_store: &lint::LintStore, loaded_plugins: bool) {\n+fn describe_lints(sess: &Session, lint_store: &lint::LintStore, loaded_plugins: bool) {\n     println!(\"\n Available lint options:\n     -W <foo>           Warn about <foo>\n@@ -1146,10 +1146,10 @@ Available lint options:\n \n \");\n \n-    fn sort_lints(lints: Vec<(&'static Lint, bool)>) -> Vec<&'static Lint> {\n+    fn sort_lints(sess: &Session, lints: Vec<(&'static Lint, bool)>) -> Vec<&'static Lint> {\n         let mut lints: Vec<_> = lints.into_iter().map(|(x, _)| x).collect();\n         lints.sort_by(|x: &&Lint, y: &&Lint| {\n-            match x.default_level.cmp(&y.default_level) {\n+            match x.default_level(sess).cmp(&y.default_level(sess)) {\n                 // The sort doesn't case-fold but it's doubtful we care.\n                 Equal => x.name.cmp(y.name),\n                 r => r,\n@@ -1172,8 +1172,8 @@ Available lint options:\n                                                    .iter()\n                                                    .cloned()\n                                                    .partition(|&(_, p)| p);\n-    let plugin = sort_lints(plugin);\n-    let builtin = sort_lints(builtin);\n+    let plugin = sort_lints(sess, plugin);\n+    let builtin = sort_lints(sess, builtin);\n \n     let (plugin_groups, builtin_groups): (Vec<_>, _) = lint_store.get_lint_groups()\n                                                                  .iter()"}, {"sha": "9dc6d977851b147d9c28ab04982e140ce1dacdd6", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -191,75 +191,98 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n         FutureIncompatibleInfo {\n             id: LintId::of(PRIVATE_IN_PUBLIC),\n             reference: \"issue #34537 <https://github.com/rust-lang/rust/issues/34537>\",\n+            epoch: None,\n         },\n         FutureIncompatibleInfo {\n             id: LintId::of(PUB_USE_OF_PRIVATE_EXTERN_CRATE),\n             reference: \"issue #34537 <https://github.com/rust-lang/rust/issues/34537>\",\n+            epoch: None,\n         },\n         FutureIncompatibleInfo {\n             id: LintId::of(PATTERNS_IN_FNS_WITHOUT_BODY),\n             reference: \"issue #35203 <https://github.com/rust-lang/rust/issues/35203>\",\n+            epoch: None,\n         },\n         FutureIncompatibleInfo {\n             id: LintId::of(SAFE_EXTERN_STATICS),\n             reference: \"issue #36247 <https://github.com/rust-lang/rust/issues/36247>\",\n+            epoch: None,\n         },\n         FutureIncompatibleInfo {\n             id: LintId::of(INVALID_TYPE_PARAM_DEFAULT),\n             reference: \"issue #36887 <https://github.com/rust-lang/rust/issues/36887>\",\n+            epoch: None,\n         },\n         FutureIncompatibleInfo {\n             id: LintId::of(LEGACY_DIRECTORY_OWNERSHIP),\n             reference: \"issue #37872 <https://github.com/rust-lang/rust/issues/37872>\",\n+            epoch: None,\n         },\n         FutureIncompatibleInfo {\n             id: LintId::of(LEGACY_IMPORTS),\n             reference: \"issue #38260 <https://github.com/rust-lang/rust/issues/38260>\",\n+            epoch: None,\n         },\n         FutureIncompatibleInfo {\n             id: LintId::of(LEGACY_CONSTRUCTOR_VISIBILITY),\n             reference: \"issue #39207 <https://github.com/rust-lang/rust/issues/39207>\",\n+            epoch: None,\n         },\n         FutureIncompatibleInfo {\n             id: LintId::of(RESOLVE_TRAIT_ON_DEFAULTED_UNIT),\n             reference: \"issue #39216 <https://github.com/rust-lang/rust/issues/39216>\",\n+            epoch: None,\n         },\n         FutureIncompatibleInfo {\n             id: LintId::of(MISSING_FRAGMENT_SPECIFIER),\n             reference: \"issue #40107 <https://github.com/rust-lang/rust/issues/40107>\",\n+            epoch: None,\n         },\n         FutureIncompatibleInfo {\n             id: LintId::of(ILLEGAL_FLOATING_POINT_LITERAL_PATTERN),\n             reference: \"issue #41620 <https://github.com/rust-lang/rust/issues/41620>\",\n+            epoch: None,\n         },\n         FutureIncompatibleInfo {\n             id: LintId::of(ANONYMOUS_PARAMETERS),\n             reference: \"issue #41686 <https://github.com/rust-lang/rust/issues/41686>\",\n+            epoch: None,\n         },\n         FutureIncompatibleInfo {\n             id: LintId::of(PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES),\n             reference: \"issue #42238 <https://github.com/rust-lang/rust/issues/42238>\",\n+            epoch: None,\n         },\n         FutureIncompatibleInfo {\n             id: LintId::of(LATE_BOUND_LIFETIME_ARGUMENTS),\n             reference: \"issue #42868 <https://github.com/rust-lang/rust/issues/42868>\",\n+            epoch: None,\n         },\n         FutureIncompatibleInfo {\n             id: LintId::of(SAFE_PACKED_BORROWS),\n             reference: \"issue #46043 <https://github.com/rust-lang/rust/issues/46043>\",\n+            epoch: None,\n         },\n         FutureIncompatibleInfo {\n             id: LintId::of(INCOHERENT_FUNDAMENTAL_IMPLS),\n             reference: \"issue #46205 <https://github.com/rust-lang/rust/issues/46205>\",\n+            epoch: None,\n         },\n         FutureIncompatibleInfo {\n             id: LintId::of(COERCE_NEVER),\n             reference: \"issue #46325 <https://github.com/rust-lang/rust/issues/46325>\",\n+            epoch: None,\n         },\n         FutureIncompatibleInfo {\n             id: LintId::of(TYVAR_BEHIND_RAW_POINTER),\n             reference: \"issue #46906 <https://github.com/rust-lang/rust/issues/46906>\",\n+            epoch: None,\n         },\n+         FutureIncompatibleInfo {\n+             id: LintId::of(lint::builtin::BARE_TRAIT_OBJECT),\n+             reference: \"issue #48457 <https://github.com/rust-lang/rust/issues/48457>\",\n+             epoch: Some(session::config::Epoch::Epoch2018),\n+         }\n         ]);\n \n     // Register renamed and removed lints"}, {"sha": "d140b135416c9c7148bf66c6911d97fa4f33f4f6", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -323,7 +323,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 // paths because any relative paths are potentially relative to\n                 // a wrong directory.\n                 // However, if a path has been modified via\n-                // `-Zremap-path-prefix` we assume the user has already set\n+                // `--remap-path-prefix` we assume the user has already set\n                 // things up the way they want and don't touch the path values\n                 // anymore.\n                 match filemap.name {"}, {"sha": "a325cfe3eaae33cab4a84971cc58eadcab21502b", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -28,6 +28,7 @@ use std::mem;\n use std::u32;\n use syntax::abi::Abi;\n use syntax::ast;\n+use syntax::attr::{self, UnwindAttr};\n use syntax::symbol::keywords;\n use syntax_pos::Span;\n use transform::MirSource;\n@@ -355,10 +356,9 @@ macro_rules! unpack {\n }\n \n fn should_abort_on_panic<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                         fn_id: ast::NodeId,\n+                                         fn_def_id: DefId,\n                                          abi: Abi)\n                                          -> bool {\n-\n     // Not callable from C, so we can safely unwind through these\n     if abi == Abi::Rust || abi == Abi::RustCall { return false; }\n \n@@ -370,9 +370,17 @@ fn should_abort_on_panic<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n \n     // This is a special case: some functions have a C abi but are meant to\n     // unwind anyway. Don't stop them.\n-    if tcx.has_attr(tcx.hir.local_def_id(fn_id), \"unwind\") { return false; }\n+    let attrs = &tcx.get_attrs(fn_def_id);\n+    match attr::find_unwind_attr(Some(tcx.sess.diagnostic()), attrs) {\n+        None => {\n+            // FIXME(rust-lang/rust#48251) -- Had to disable\n+            // abort-on-panic for backwards compatibility reasons.\n+            false\n+        }\n \n-    return true;\n+        Some(UnwindAttr::Allowed) => false,\n+        Some(UnwindAttr::Aborts) => true,\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -399,13 +407,14 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n         safety,\n         return_ty);\n \n+    let fn_def_id = tcx.hir.local_def_id(fn_id);\n     let call_site_scope = region::Scope::CallSite(body.value.hir_id.local_id);\n     let arg_scope = region::Scope::Arguments(body.value.hir_id.local_id);\n     let mut block = START_BLOCK;\n     let source_info = builder.source_info(span);\n     let call_site_s = (call_site_scope, source_info);\n     unpack!(block = builder.in_scope(call_site_s, LintLevel::Inherited, block, |builder| {\n-        if should_abort_on_panic(tcx, fn_id, abi) {\n+        if should_abort_on_panic(tcx, fn_def_id, abi) {\n             builder.schedule_abort();\n         }\n "}, {"sha": "9887ac82a2ea66079f5c5af3483a27a3bec6dcfa", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -15,6 +15,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n */\n \n #![deny(warnings)]\n+#![cfg_attr(not(stage0), allow(bare_trait_object))]\n \n #![feature(box_patterns)]\n #![feature(box_syntax)]"}, {"sha": "54a7a0eafe0af6019ef249b259f56039f427bf13", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -257,6 +257,7 @@ fn optimized_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx\n \n \n         // Optimizations begin.\n+        uniform_array_move_out::RestoreSubsliceArrayMoveOut,\n         inline::Inline,\n \n         // Lowering generator control-flow and variables"}, {"sha": "e46de170479861dc07e47b1bfe137dc40e8bb627", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "modified", "additions": 187, "deletions": 11, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -34,15 +34,15 @@\n //  and mir statement _11 = move _2[-1 of 1]; replaced by:\n //  _11 = move _2[2 of 3];\n //\n-// FIXME: convert to Subslice back for performance reason\n // FIXME: integrate this transformation to the mir build\n \n use rustc::ty;\n use rustc::ty::TyCtxt;\n use rustc::mir::*;\n-use rustc::mir::visit::Visitor;\n+use rustc::mir::visit::{Visitor, PlaceContext};\n use transform::{MirPass, MirSource};\n use util::patch::MirPatch;\n+use rustc_data_structures::indexed_vec::{IndexVec};\n \n pub struct UniformArrayMoveOut;\n \n@@ -67,12 +67,12 @@ struct UniformArrayMoveOutVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for UniformArrayMoveOutVisitor<'a, 'tcx> {\n-    fn visit_statement(&mut self,\n-                       block: BasicBlock,\n-                       statement: &Statement<'tcx>,\n-                       location: Location) {\n-        if let StatementKind::Assign(ref dst_place,\n-                                     Rvalue::Use(Operand::Move(ref src_place))) = statement.kind {\n+    fn visit_assign(&mut self,\n+                    block: BasicBlock,\n+                    dst_place: &Place<'tcx>,\n+                    rvalue: &Rvalue<'tcx>,\n+                    location: Location) {\n+        if let Rvalue::Use(Operand::Move(ref src_place)) = rvalue {\n             if let Place::Projection(ref proj) = *src_place {\n                 if let ProjectionElem::ConstantIndex{offset: _,\n                                                      min_length: _,\n@@ -92,7 +92,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UniformArrayMoveOutVisitor<'a, 'tcx> {\n                 }\n             }\n         }\n-        return self.super_statement(block, statement, location);\n+        self.super_assign(block, dst_place, rvalue, location)\n     }\n }\n \n@@ -104,7 +104,7 @@ impl<'a, 'tcx> UniformArrayMoveOutVisitor<'a, 'tcx> {\n                item_ty: &'tcx ty::TyS<'tcx>,\n                size: u32) {\n         match proj.elem {\n-            // uniform _10 = move _2[:-1];\n+            // uniforms statements like_10 = move _2[:-1];\n             ProjectionElem::Subslice{from, to} => {\n                 self.patch.make_nop(location);\n                 let temps : Vec<_> = (from..(size-to)).map(|i| {\n@@ -133,7 +133,7 @@ impl<'a, 'tcx> UniformArrayMoveOutVisitor<'a, 'tcx> {\n                     self.patch.add_statement(location, StatementKind::StorageDead(temp));\n                 }\n             }\n-            // _11 = move _2[-1 of 1];\n+            // uniforms statements like _11 = move _2[-1 of 1];\n             ProjectionElem::ConstantIndex{offset, min_length: _, from_end: true} => {\n                 self.patch.make_nop(location);\n                 self.patch.add_assign(location,\n@@ -151,3 +151,179 @@ impl<'a, 'tcx> UniformArrayMoveOutVisitor<'a, 'tcx> {\n         }\n     }\n }\n+\n+// Restore Subslice move out after analysis\n+// Example:\n+//\n+//  next statements:\n+//   StorageLive(_12);\n+//   _12 = move _2[0 of 3];\n+//   StorageLive(_13);\n+//   _13 = move _2[1 of 3];\n+//   _10 = [move _12, move _13]\n+//   StorageDead(_12);\n+//   StorageDead(_13);\n+//\n+// replaced by _10 = move _2[:-1];\n+\n+pub struct RestoreSubsliceArrayMoveOut;\n+\n+impl MirPass for RestoreSubsliceArrayMoveOut {\n+    fn run_pass<'a, 'tcx>(&self,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          _src: MirSource,\n+                          mir: &mut Mir<'tcx>) {\n+        let mut patch = MirPatch::new(mir);\n+        {\n+            let mut visitor = RestoreDataCollector {\n+                locals_use: IndexVec::from_elem(LocalUse::new(), &mir.local_decls),\n+                candidates: vec![],\n+            };\n+            visitor.visit_mir(mir);\n+\n+            for candidate in &visitor.candidates {\n+                let statement = &mir[candidate.block].statements[candidate.statement_index];\n+                if let StatementKind::Assign(ref dst_place, ref rval) = statement.kind {\n+                    if let Rvalue::Aggregate(box AggregateKind::Array(_), ref items) = *rval {\n+                        let items : Vec<_> = items.iter().map(|item| {\n+                            if let Operand::Move(Place::Local(local)) = item {\n+                                let local_use = &visitor.locals_use[*local];\n+                                let opt_index_and_place = Self::try_get_item_source(local_use, mir);\n+                                // each local should be used twice:\n+                                //  in assign and in aggregate statments\n+                                if local_use.use_count == 2 && opt_index_and_place.is_some() {\n+                                    let (index, src_place) = opt_index_and_place.unwrap();\n+                                    return Some((local_use, index, src_place));\n+                                }\n+                            }\n+                            None\n+                        }).collect();\n+\n+                        let opt_src_place = items.first().and_then(|x| *x).map(|x| x.2);\n+                        let opt_size = opt_src_place.and_then(|src_place| {\n+                            let src_ty = src_place.ty(mir, tcx).to_ty(tcx);\n+                            if let ty::TyArray(_, ref size_o) = src_ty.sty {\n+                                size_o.val.to_const_int().and_then(|v| v.to_u64())\n+                            } else {\n+                                None\n+                            }\n+                        });\n+                        Self::check_and_patch(*candidate, &items, opt_size, &mut patch, dst_place);\n+                    }\n+                }\n+            }\n+        }\n+        patch.apply(mir);\n+    }\n+}\n+\n+impl RestoreSubsliceArrayMoveOut {\n+    // Checks that source has size, all locals are inited from same source place and\n+    // indices is an integer interval. If all checks pass do the replacent.\n+    // items are Vec<Option<LocalUse, index in source array, source place for init local>>\n+    fn check_and_patch<'tcx>(candidate: Location,\n+                             items: &Vec<Option<(&LocalUse, u32, &Place<'tcx>)>>,\n+                             opt_size: Option<u64>,\n+                             patch: &mut MirPatch<'tcx>,\n+                             dst_place: &Place<'tcx>) {\n+        let opt_src_place = items.first().and_then(|x| *x).map(|x| x.2);\n+\n+        if opt_size.is_some() && items.iter().all(\n+            |l| l.is_some() && l.unwrap().2 == opt_src_place.unwrap()) {\n+\n+            let indicies: Vec<_> = items.iter().map(|x| x.unwrap().1).collect();\n+            for i in 1..indicies.len() {\n+                if indicies[i - 1] + 1 != indicies[i] {\n+                    return;\n+                }\n+            }\n+\n+            let min = *indicies.first().unwrap();\n+            let max = *indicies.last().unwrap();\n+\n+            for item in items {\n+                let locals_use = item.unwrap().0;\n+                patch.make_nop(locals_use.alive.unwrap());\n+                patch.make_nop(locals_use.dead.unwrap());\n+                patch.make_nop(locals_use.first_use.unwrap());\n+            }\n+            patch.make_nop(candidate);\n+            let size = opt_size.unwrap() as u32;\n+            patch.add_assign(candidate,\n+                             dst_place.clone(),\n+                             Rvalue::Use(\n+                                 Operand::Move(\n+                                     Place::Projection(box PlaceProjection{\n+                                         base: opt_src_place.unwrap().clone(),\n+                                         elem: ProjectionElem::Subslice{\n+                                             from: min, to: size - max - 1}}))));\n+        }\n+    }\n+\n+    fn try_get_item_source<'a, 'tcx>(local_use: &LocalUse,\n+                                     mir: &'a Mir<'tcx>) -> Option<(u32, &'a Place<'tcx>)> {\n+        if let Some(location) = local_use.first_use {\n+            let block = &mir[location.block];\n+            if block.statements.len() > location.statement_index {\n+                let statement = &block.statements[location.statement_index];\n+                if let StatementKind::Assign(\n+                    Place::Local(_),\n+                    Rvalue::Use(Operand::Move(Place::Projection(box PlaceProjection{\n+                        ref base, elem: ProjectionElem::ConstantIndex{\n+                            offset, min_length: _, from_end: false}})))) = statement.kind {\n+                    return Some((offset, base))\n+                }\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+struct LocalUse {\n+    alive: Option<Location>,\n+    dead: Option<Location>,\n+    use_count: u32,\n+    first_use: Option<Location>,\n+}\n+\n+impl LocalUse {\n+    pub fn new() -> Self {\n+        LocalUse{alive: None, dead: None, use_count: 0, first_use: None}\n+    }\n+}\n+\n+struct RestoreDataCollector {\n+    locals_use: IndexVec<Local, LocalUse>,\n+    candidates: Vec<Location>,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for RestoreDataCollector {\n+    fn visit_assign(&mut self,\n+                    block: BasicBlock,\n+                    place: &Place<'tcx>,\n+                    rvalue: &Rvalue<'tcx>,\n+                    location: Location) {\n+        if let Rvalue::Aggregate(box AggregateKind::Array(_), _) = *rvalue {\n+            self.candidates.push(location);\n+        }\n+        self.super_assign(block, place, rvalue, location)\n+    }\n+\n+    fn visit_local(&mut self,\n+                   local: &Local,\n+                   context: PlaceContext<'tcx>,\n+                   location: Location) {\n+        let local_use = &mut self.locals_use[*local];\n+        match context {\n+            PlaceContext::StorageLive => local_use.alive = Some(location),\n+            PlaceContext::StorageDead => local_use.dead = Some(location),\n+            _ => {\n+                local_use.use_count += 1;\n+                if local_use.first_use.is_none() {\n+                    local_use.first_use = Some(location);\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "454ac64735c67900e37f40cf5212da99e247d7fe", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -55,7 +55,8 @@ extern {\n                                 data: *mut u8,\n                                 data_ptr: *mut usize,\n                                 vtable_ptr: *mut usize) -> u32;\n-    #[unwind]\n+    #[cfg_attr(stage0, unwind)]\n+    #[cfg_attr(not(stage0), unwind(allowed))]\n     fn __rust_start_panic(data: usize, vtable: usize) -> u32;\n }\n \n@@ -315,7 +316,8 @@ pub fn panicking() -> bool {\n /// Entry point of panic from the libcore crate.\n #[cfg(not(test))]\n #[lang = \"panic_fmt\"]\n-#[unwind]\n+#[cfg_attr(stage0, unwind)]\n+#[cfg_attr(not(stage0), unwind(allowed))]\n pub extern fn rust_begin_panic(msg: fmt::Arguments,\n                                file: &'static str,\n                                line: u32,"}, {"sha": "1608a752a463fdac287f7d309d9068fd10a659d8", "filename": "src/libstd/path.rs", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -1035,6 +1035,50 @@ impl<'a> cmp::Ord for Components<'a> {\n     }\n }\n \n+/// An iterator over [`Path`] and its ancestors.\n+///\n+/// This `struct` is created by the [`ancestors`] method on [`Path`].\n+/// See its documentation for more.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(path_ancestors)]\n+///\n+/// use std::path::Path;\n+///\n+/// let path = Path::new(\"/foo/bar\");\n+///\n+/// for ancestor in path.ancestors() {\n+///     println!(\"{}\", ancestor.display());\n+/// }\n+/// ```\n+///\n+/// [`ancestors`]: struct.Path.html#method.ancestors\n+/// [`Path`]: struct.Path.html\n+#[derive(Copy, Clone, Debug)]\n+#[unstable(feature = \"path_ancestors\", issue = \"48581\")]\n+pub struct Ancestors<'a> {\n+    next: Option<&'a Path>,\n+}\n+\n+#[unstable(feature = \"path_ancestors\", issue = \"48581\")]\n+impl<'a> Iterator for Ancestors<'a> {\n+    type Item = &'a Path;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let next = self.next;\n+        self.next = match next {\n+            Some(path) => path.parent(),\n+            None => None,\n+        };\n+        next\n+    }\n+}\n+\n+#[unstable(feature = \"fused\", issue = \"35602\")]\n+impl<'a> FusedIterator for Ancestors<'a> {}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Basic types and traits\n ////////////////////////////////////////////////////////////////////////////////\n@@ -1820,6 +1864,37 @@ impl Path {\n         })\n     }\n \n+    /// Produces an iterator over `Path` and its ancestors.\n+    ///\n+    /// The iterator will yield the `Path` that is returned if the [`parent`] method is used zero\n+    /// or more times. That means, the iterator will yield `&self`, `&self.parent().unwrap()`,\n+    /// `&self.parent().unwrap().parent().unwrap()` and so on. If the [`parent`] method returns\n+    /// [`None`], the iterator will do likewise. The iterator will always yield at least one value,\n+    /// namely `&self`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(path_ancestors)]\n+    ///\n+    /// use std::path::Path;\n+    ///\n+    /// let mut ancestors = Path::new(\"/foo/bar\").ancestors();\n+    /// assert_eq!(ancestors.next(), Some(Path::new(\"/foo/bar\")));\n+    /// assert_eq!(ancestors.next(), Some(Path::new(\"/foo\")));\n+    /// assert_eq!(ancestors.next(), Some(Path::new(\"/\")));\n+    /// assert_eq!(ancestors.next(), None);\n+    /// ```\n+    ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`parent`]: struct.Path.html#method.parent\n+    #[unstable(feature = \"path_ancestors\", issue = \"48581\")]\n+    pub fn ancestors(&self) -> Ancestors {\n+        Ancestors {\n+            next: Some(&self),\n+        }\n+    }\n+\n     /// Returns the final component of the `Path`, if there is one.\n     ///\n     /// If the path is a normal file, this is the file name. If it's the path of a directory, this"}, {"sha": "d0822b69aa692d079bc926331595db5ed2f2cc67", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -565,6 +565,51 @@ pub fn find_inline_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> In\n     })\n }\n \n+#[derive(Copy, Clone, PartialEq)]\n+pub enum UnwindAttr {\n+    Allowed,\n+    Aborts,\n+}\n+\n+/// Determine what `#[unwind]` attribute is present in `attrs`, if any.\n+pub fn find_unwind_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> Option<UnwindAttr> {\n+    let syntax_error = |attr: &Attribute| {\n+        mark_used(attr);\n+        diagnostic.map(|d| {\n+            span_err!(d, attr.span, E0633, \"malformed `#[unwind]` attribute\");\n+        });\n+        None\n+    };\n+\n+    attrs.iter().fold(None, |ia, attr| {\n+        if attr.path != \"unwind\" {\n+            return ia;\n+        }\n+        let meta = match attr.meta() {\n+            Some(meta) => meta.node,\n+            None => return ia,\n+        };\n+        match meta {\n+            MetaItemKind::Word => {\n+                syntax_error(attr)\n+            }\n+            MetaItemKind::List(ref items) => {\n+                mark_used(attr);\n+                if items.len() != 1 {\n+                    syntax_error(attr)\n+                } else if list_contains_name(&items[..], \"allowed\") {\n+                    Some(UnwindAttr::Allowed)\n+                } else if list_contains_name(&items[..], \"aborts\") {\n+                    Some(UnwindAttr::Aborts)\n+                } else {\n+                    syntax_error(attr)\n+                }\n+            }\n+            _ => ia,\n+        }\n+    })\n+}\n+\n /// True if `#[inline]` or `#[inline(always)]` is present in `attrs`.\n pub fn requests_inline(attrs: &[Attribute]) -> bool {\n     match find_inline_attr(None, attrs) {"}, {"sha": "926548b60318be167473d8235af3e7d41771b4b4", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -129,7 +129,7 @@ pub struct CodeMap {\n     pub(super) files: RefCell<Vec<Rc<FileMap>>>,\n     file_loader: Box<FileLoader>,\n     // This is used to apply the file path remapping as specified via\n-    // -Zremap-path-prefix to all FileMaps allocated within this CodeMap.\n+    // --remap-path-prefix to all FileMaps allocated within this CodeMap.\n     path_mapping: FilePathMapping,\n     stable_id_to_filemap: RefCell<FxHashMap<StableFilemapId, Rc<FileMap>>>,\n     /// In case we are in a doctest, replace all file names with the PathBuf,"}, {"sha": "84ab0336f1671ceb5ac88a31008ad3be9eb2f9bc", "filename": "src/libsyntax/diagnostic_list.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibsyntax%2Fdiagnostic_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibsyntax%2Fdiagnostic_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic_list.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -342,6 +342,33 @@ fn main() {\n ```\n \"##,\n \n+E0633: r##\"\n+The `unwind` attribute was malformed.\n+\n+Erroneous code example:\n+\n+```ignore (compile_fail not working here; see Issue #43707)\n+#[unwind()] // error: expected one argument\n+pub extern fn something() {}\n+\n+fn main() {}\n+```\n+\n+The `#[unwind]` attribute should be used as follows:\n+\n+- `#[unwind(aborts)]` -- specifies that if a non-Rust ABI function\n+  should abort the process if it attempts to unwind. This is the safer\n+  and preferred option.\n+\n+- `#[unwind(allowed)]` -- specifies that a non-Rust ABI function\n+  should be allowed to unwind. This can easily result in Undefined\n+  Behavior (UB), so be careful.\n+\n+NB. The default behavior here is \"allowed\", but this is unspecified\n+and likely to change in the future.\n+\n+\"##,\n+\n }\n \n register_diagnostics! {"}, {"sha": "6444c846a8b2ed1107f1cd98a2eef26f1c7aa8ab", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -233,7 +233,7 @@ declare_features! (\n     // allow `extern \"platform-intrinsic\" { ... }`\n     (active, platform_intrinsics, \"1.4.0\", Some(27731)),\n \n-    // allow `#[unwind]`\n+    // allow `#[unwind(..)]`\n     // rust runtime internal\n     (active, unwind_attributes, \"1.4.0\", None),\n "}, {"sha": "e2c6b1b0c928f793240d697259d0d5dd9c31c5c1", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -670,7 +670,7 @@ pub struct FileMap {\n     /// originate from files has names between angle brackets by convention,\n     /// e.g. `<anon>`\n     pub name: FileName,\n-    /// True if the `name` field above has been modified by -Zremap-path-prefix\n+    /// True if the `name` field above has been modified by --remap-path-prefix\n     pub name_was_remapped: bool,\n     /// The unmapped path of the file that the source came from.\n     /// Set to `None` if the FileMap was imported from an external crate."}, {"sha": "aa73b11fb3813683534bc7286c502c13d36bfd54", "filename": "src/libunwind/libunwind.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibunwind%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Flibunwind%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Flibunwind.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -83,7 +83,8 @@ pub enum _Unwind_Context {}\n pub type _Unwind_Exception_Cleanup_Fn = extern \"C\" fn(unwind_code: _Unwind_Reason_Code,\n                                                       exception: *mut _Unwind_Exception);\n extern \"C\" {\n-    #[unwind]\n+    #[cfg_attr(stage0, unwind)]\n+    #[cfg_attr(not(stage0), unwind(allowed))]\n     pub fn _Unwind_Resume(exception: *mut _Unwind_Exception) -> !;\n     pub fn _Unwind_DeleteException(exception: *mut _Unwind_Exception);\n     pub fn _Unwind_GetLanguageSpecificData(ctx: *mut _Unwind_Context) -> *mut c_void;\n@@ -220,7 +221,8 @@ if #[cfg(all(any(target_os = \"ios\", not(target_arch = \"arm\"))))] {\n if #[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))] {\n     // Not 32-bit iOS\n     extern \"C\" {\n-        #[unwind]\n+        #[cfg_attr(stage0, unwind)]\n+        #[cfg_attr(not(stage0), unwind(allowed))]\n         pub fn _Unwind_RaiseException(exception: *mut _Unwind_Exception) -> _Unwind_Reason_Code;\n         pub fn _Unwind_Backtrace(trace: _Unwind_Trace_Fn,\n                                  trace_argument: *mut c_void)\n@@ -229,7 +231,8 @@ if #[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))] {\n } else {\n     // 32-bit iOS uses SjLj and does not provide _Unwind_Backtrace()\n     extern \"C\" {\n-        #[unwind]\n+        #[cfg_attr(stage0, unwind)]\n+        #[cfg_attr(not(stage0), unwind(allowed))]\n         pub fn _Unwind_SjLj_RaiseException(e: *mut _Unwind_Exception) -> _Unwind_Reason_Code;\n     }\n "}, {"sha": "90ee0c75680dce81eea4e1b04ec8eb8271199f7b", "filename": "src/test/codegen/extern-functions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Ftest%2Fcodegen%2Fextern-functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Ftest%2Fcodegen%2Fextern-functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fextern-functions.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -19,7 +19,7 @@ extern {\n     fn extern_fn();\n // CHECK-NOT: Function Attrs: nounwind\n // CHECK: declare void @unwinding_extern_fn\n-    #[unwind]\n+    #[unwind(allowed)]\n     fn unwinding_extern_fn();\n }\n "}, {"sha": "3ef0ff9ef0687164b71b33c5a1a1006eef2ebf41", "filename": "src/test/codegen/remap_path_prefix/auxiliary/remap_path_prefix_aux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fauxiliary%2Fremap_path_prefix_aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fauxiliary%2Fremap_path_prefix_aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fauxiliary%2Fremap_path_prefix_aux.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -10,7 +10,7 @@\n \n // ignore-tidy-linelength\n \n-// compile-flags: -g  -Zremap-path-prefix-from={{cwd}} -Zremap-path-prefix-to=/the/aux-cwd -Zremap-path-prefix-from={{src-base}}/remap_path_prefix/auxiliary -Zremap-path-prefix-to=/the/aux-src\n+// compile-flags: -g  --remap-path-prefix={{cwd}}=/the/aux-cwd --remap-path-prefix={{src-base}}/remap_path_prefix/auxiliary=/the/aux-src\n \n #[inline]\n pub fn some_aux_function() -> i32 {"}, {"sha": "2f46b6c5d48da28412ce3e08d00f337afb4a4c34", "filename": "src/test/codegen/remap_path_prefix/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fmain.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -11,7 +11,7 @@\n // ignore-windows\n // ignore-tidy-linelength\n \n-// compile-flags: -g  -C no-prepopulate-passes -Zremap-path-prefix-from={{cwd}} -Zremap-path-prefix-to=/the/cwd -Zremap-path-prefix-from={{src-base}} -Zremap-path-prefix-to=/the/src\n+// compile-flags: -g  -C no-prepopulate-passes --remap-path-prefix={{cwd}}=/the/cwd --remap-path-prefix={{src-base}}=/the/src\n // aux-build:remap_path_prefix_aux.rs\n \n extern crate remap_path_prefix_aux;"}, {"sha": "0dd1a4e7d73358401a55e57094b95f959414ec07", "filename": "src/test/compile-fail/trait-bounds-not-on-struct.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-struct.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![feature(dyn_trait)]\n+#![allow(bare_trait_object)]\n \n struct Foo;\n "}, {"sha": "c80b334623b43f0112523c34a14907e12180ca95", "filename": "src/test/incremental/remapped_paths_cc/auxiliary/extern_crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Ftest%2Fincremental%2Fremapped_paths_cc%2Fauxiliary%2Fextern_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Ftest%2Fincremental%2Fremapped_paths_cc%2Fauxiliary%2Fextern_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fremapped_paths_cc%2Fauxiliary%2Fextern_crate.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -12,7 +12,7 @@\n \n //[rpass1] compile-flags: -g\n //[rpass2] compile-flags: -g\n-//[rpass3] compile-flags: -g -Zremap-path-prefix-from={{src-base}} -Zremap-path-prefix-to=/the/src\n+//[rpass3] compile-flags: -g --remap-path-prefix={{src-base}}=/the/src\n \n #![feature(rustc_attrs)]\n #![crate_type=\"rlib\"]"}, {"sha": "482b69a59ddbc1bcdd34a065f669194081758001", "filename": "src/test/mir-opt/uniform_array_move_out.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -57,3 +57,28 @@ fn main() {\n //     nop;\n //     _0 = ();\n // END rustc.move_out_by_subslice.UniformArrayMoveOut.after.mir\n+\n+// START rustc.move_out_by_subslice.RestoreSubsliceArrayMoveOut.before.mir\n+//     StorageLive(_6);\n+//     StorageLive(_7);\n+//     _7 = move _1[0 of 2];\n+//     StorageLive(_8);\n+//     _8 = move _1[1 of 2];\n+//     _6 = [move _7, move _8];\n+//     StorageDead(_7);\n+//     StorageDead(_8);\n+//     _0 = ();\n+// END rustc.move_out_by_subslice.RestoreSubsliceArrayMoveOut.before.mir\n+\n+// START rustc.move_out_by_subslice.RestoreSubsliceArrayMoveOut.after.mir\n+//     StorageLive(_6);\n+//     nop;\n+//     nop;\n+//     nop;\n+//     nop;\n+//     _6 = move _1[0:];\n+//     nop;\n+//     nop;\n+//     nop;\n+//     _0 = ();\n+// END rustc.move_out_by_subslice.RestoreSubsliceArrayMoveOut.after.mir"}, {"sha": "ef368ed604bea810890c7df702b1336b9c4e7214", "filename": "src/test/run-pass/abort-on-c-abi.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Ftest%2Frun-pass%2Fabort-on-c-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2/src%2Ftest%2Frun-pass%2Fabort-on-c-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fabort-on-c-abi.rs?ref=0e3c9bba8ec6b8c5f8c66868ba6c47d3d38b20b2", "patch": "@@ -14,11 +14,14 @@\n // ignore-cloudabi no env and process\n // ignore-emscripten no processes\n \n+#![feature(unwind_attributes)]\n+\n use std::{env, panic};\n use std::io::prelude::*;\n use std::io;\n use std::process::{Command, Stdio};\n \n+#[unwind(aborts)]\n extern \"C\" fn panic_in_ffi() {\n     panic!(\"Test\");\n }"}]}