{"sha": "ec53c379ccb79257f4802a883b42789daec00c50", "node_id": "C_kwDOAAsO6NoAKGVjNTNjMzc5Y2NiNzkyNTdmNDgwMmE4ODNiNDI3ODlkYWVjMDBjNTA", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-05-10T06:24:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-05-10T06:24:05Z"}, "message": "Rollup merge of #96872 - RalfJung:layout-sanity, r=eddyb\n\nmake sure ScalarPair enums have ScalarPair variants; add some layout sanity checks\n\n`@eddyb` suggested that it might be reasonable for `ScalarPair` enums to simply adjust the ABI of their variants accordingly, such that the layout invariant Miri expects actually holds. This PR implements that. I should note though that I don't know much about this layout computation code and what non-Miri consumers expect from it, so tread with caution!\n\nI also added a function to sanity-check that computed layouts are internally consistent. This helped a lot in figuring out the final shape of this PR, though I am also not 100% sure that these sanity checks are the right ones.\n\nCc `@oli-obk`\nFixes https://github.com/rust-lang/rust/issues/96221", "tree": {"sha": "998d97785d1b9c97bc4e253d0fb1e46f55a1ee13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/998d97785d1b9c97bc4e253d0fb1e46f55a1ee13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec53c379ccb79257f4802a883b42789daec00c50", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiegUFCRBK7hj4Ov3rIwAA3E8IAFBnr/Z+Kcj0SSC40afM8U2B\ng/dtzYcYmFEo+YgMafLPJaMIivey8ZeQ2ErvJqXA/bESSPHAIgC/9oNV3QXdAq1i\nhoDuWji70fTE2S2k6N+t3nHc2GhzDVS2w6FPgT2yyiXVBWVEpfNB67SSz/cGjR4E\nbSwen7H04tW8SconubR1uVYDXvs4HOCCz84XRG37EAnYawvT2vcIHdHFPkDZ11cm\n1JkhQ39dHyd1ubc+MzLpvO8NtIQMjZQRVQ0BoWkngVW2UfVAN+FuISxQ2L5mHpaX\nrc+E7Xs2+fciXS0DI7CbZSmyL3uZGMd/lrBSGomjbP8stwabyf2kXp0zWLNZWGg=\n=UMsa\n-----END PGP SIGNATURE-----\n", "payload": "tree 998d97785d1b9c97bc4e253d0fb1e46f55a1ee13\nparent 9a3f17b34d59329a931c10086d5e98b3dea26ee7\nparent 02eca34534c2f69cda539aade9fff230aae70af3\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1652163845 +0200\ncommitter GitHub <noreply@github.com> 1652163845 +0200\n\nRollup merge of #96872 - RalfJung:layout-sanity, r=eddyb\n\nmake sure ScalarPair enums have ScalarPair variants; add some layout sanity checks\n\n`@eddyb` suggested that it might be reasonable for `ScalarPair` enums to simply adjust the ABI of their variants accordingly, such that the layout invariant Miri expects actually holds. This PR implements that. I should note though that I don't know much about this layout computation code and what non-Miri consumers expect from it, so tread with caution!\n\nI also added a function to sanity-check that computed layouts are internally consistent. This helped a lot in figuring out the final shape of this PR, though I am also not 100% sure that these sanity checks are the right ones.\n\nCc `@oli-obk`\nFixes https://github.com/rust-lang/rust/issues/96221\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec53c379ccb79257f4802a883b42789daec00c50", "html_url": "https://github.com/rust-lang/rust/commit/ec53c379ccb79257f4802a883b42789daec00c50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec53c379ccb79257f4802a883b42789daec00c50/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a3f17b34d59329a931c10086d5e98b3dea26ee7", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a3f17b34d59329a931c10086d5e98b3dea26ee7", "html_url": "https://github.com/rust-lang/rust/commit/9a3f17b34d59329a931c10086d5e98b3dea26ee7"}, {"sha": "02eca34534c2f69cda539aade9fff230aae70af3", "url": "https://api.github.com/repos/rust-lang/rust/commits/02eca34534c2f69cda539aade9fff230aae70af3", "html_url": "https://github.com/rust-lang/rust/commit/02eca34534c2f69cda539aade9fff230aae70af3"}], "stats": {"total": 268, "additions": 237, "deletions": 31}, "files": [{"sha": "c8055100d30968a5c1c9f0df09fa9d5400b72f38", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 127, "deletions": 9, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/ec53c379ccb79257f4802a883b42789daec00c50/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec53c379ccb79257f4802a883b42789daec00c50/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=ec53c379ccb79257f4802a883b42789daec00c50", "patch": "@@ -221,6 +221,111 @@ impl<'tcx> fmt::Display for LayoutError<'tcx> {\n     }\n }\n \n+/// Enforce some basic invariants on layouts.\n+fn sanity_check_layout<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    layout: &TyAndLayout<'tcx>,\n+) {\n+    // Type-level uninhabitedness should always imply ABI uninhabitedness.\n+    if tcx.conservative_is_privately_uninhabited(param_env.and(layout.ty)) {\n+        assert!(layout.abi.is_uninhabited());\n+    }\n+\n+    if cfg!(debug_assertions) {\n+        fn check_layout_abi<'tcx>(tcx: TyCtxt<'tcx>, layout: Layout<'tcx>) {\n+            match layout.abi() {\n+                Abi::Scalar(_scalar) => {\n+                    // No padding in scalars.\n+                    /* FIXME(#96185):\n+                    assert_eq!(\n+                        layout.align().abi,\n+                        scalar.align(&tcx).abi,\n+                        \"alignment mismatch between ABI and layout in {layout:#?}\"\n+                    );\n+                    assert_eq!(\n+                        layout.size(),\n+                        scalar.size(&tcx),\n+                        \"size mismatch between ABI and layout in {layout:#?}\"\n+                    );*/\n+                }\n+                Abi::Vector { count, element } => {\n+                    // No padding in vectors. Alignment can be strengthened, though.\n+                    assert!(\n+                        layout.align().abi >= element.align(&tcx).abi,\n+                        \"alignment mismatch between ABI and layout in {layout:#?}\"\n+                    );\n+                    let size = element.size(&tcx) * count;\n+                    assert_eq!(\n+                        layout.size(),\n+                        size.align_to(tcx.data_layout().vector_align(size).abi),\n+                        \"size mismatch between ABI and layout in {layout:#?}\"\n+                    );\n+                }\n+                Abi::ScalarPair(scalar1, scalar2) => {\n+                    // Sanity-check scalar pairs. These are a bit more flexible and support\n+                    // padding, but we can at least ensure both fields actually fit into the layout\n+                    // and the alignment requirement has not been weakened.\n+                    let align1 = scalar1.align(&tcx).abi;\n+                    let align2 = scalar2.align(&tcx).abi;\n+                    assert!(\n+                        layout.align().abi >= cmp::max(align1, align2),\n+                        \"alignment mismatch between ABI and layout in {layout:#?}\",\n+                    );\n+                    let field2_offset = scalar1.size(&tcx).align_to(align2);\n+                    assert!(\n+                        layout.size() >= field2_offset + scalar2.size(&tcx),\n+                        \"size mismatch between ABI and layout in {layout:#?}\"\n+                    );\n+                }\n+                Abi::Uninhabited | Abi::Aggregate { .. } => {} // Nothing to check.\n+            }\n+        }\n+\n+        check_layout_abi(tcx, layout.layout);\n+\n+        if let Variants::Multiple { variants, .. } = &layout.variants {\n+            for variant in variants {\n+                check_layout_abi(tcx, *variant);\n+                // No nested \"multiple\".\n+                assert!(matches!(variant.variants(), Variants::Single { .. }));\n+                // Skip empty variants.\n+                if variant.size() == Size::ZERO\n+                    || variant.fields().count() == 0\n+                    || variant.abi().is_uninhabited()\n+                {\n+                    // These are never actually accessed anyway, so we can skip them. (Note that\n+                    // sometimes, variants with fields have size 0, and sometimes, variants without\n+                    // fields have non-0 size.)\n+                    continue;\n+                }\n+                // Variants should have the same or a smaller size as the full thing.\n+                if variant.size() > layout.size {\n+                    bug!(\n+                        \"Type with size {} bytes has variant with size {} bytes: {layout:#?}\",\n+                        layout.size.bytes(),\n+                        variant.size().bytes(),\n+                    )\n+                }\n+                // The top-level ABI and the ABI of the variants should be coherent.\n+                let abi_coherent = match (layout.abi, variant.abi()) {\n+                    (Abi::Scalar(..), Abi::Scalar(..)) => true,\n+                    (Abi::ScalarPair(..), Abi::ScalarPair(..)) => true,\n+                    (Abi::Uninhabited, _) => true,\n+                    (Abi::Aggregate { .. }, _) => true,\n+                    _ => false,\n+                };\n+                if !abi_coherent {\n+                    bug!(\n+                        \"Variant ABI is incompatible with top-level ABI:\\nvariant={:#?}\\nTop-level: {layout:#?}\",\n+                        variant\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n #[instrument(skip(tcx, query), level = \"debug\")]\n fn layout_of<'tcx>(\n     tcx: TyCtxt<'tcx>,\n@@ -264,10 +369,7 @@ fn layout_of<'tcx>(\n \n             cx.record_layout_for_printing(layout);\n \n-            // Type-level uninhabitedness should always imply ABI uninhabitedness.\n-            if tcx.conservative_is_privately_uninhabited(param_env.and(ty)) {\n-                assert!(layout.abi.is_uninhabited());\n-            }\n+            sanity_check_layout(tcx, param_env, &layout);\n \n             Ok(layout)\n         })\n@@ -1314,9 +1416,11 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 };\n                 let mut abi = Abi::Aggregate { sized: true };\n \n-                // Without latter check aligned enums with custom discriminant values\n-                // Would result in ICE see the issue #92464 for more info\n-                if tag.size(dl) == size || variants.iter().all(|layout| layout.is_empty()) {\n+                if layout_variants.iter().all(|v| v.abi.is_uninhabited()) {\n+                    abi = Abi::Uninhabited;\n+                } else if tag.size(dl) == size || variants.iter().all(|layout| layout.is_empty()) {\n+                    // Without latter check aligned enums with custom discriminant values\n+                    // Would result in ICE see the issue #92464 for more info\n                     abi = Abi::Scalar(tag);\n                 } else {\n                     // Try to use a ScalarPair for all tagged enums.\n@@ -1390,8 +1494,22 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     }\n                 }\n \n-                if layout_variants.iter().all(|v| v.abi.is_uninhabited()) {\n-                    abi = Abi::Uninhabited;\n+                // If we pick a \"clever\" (by-value) ABI, we might have to adjust the ABI of the\n+                // variants to ensure they are consistent. This is because a downcast is\n+                // semantically a NOP, and thus should not affect layout.\n+                if matches!(abi, Abi::Scalar(..) | Abi::ScalarPair(..)) {\n+                    for variant in &mut layout_variants {\n+                        // We only do this for variants with fields; the others are not accessed anyway.\n+                        // Also do not overwrite any already existing \"clever\" ABIs.\n+                        if variant.fields.count() > 0\n+                            && matches!(variant.abi, Abi::Aggregate { .. })\n+                        {\n+                            variant.abi = abi;\n+                            // Also need to bump up the size and alignment, so that the entire value fits in here.\n+                            variant.size = cmp::max(variant.size, size);\n+                            variant.align.abi = cmp::max(variant.align.abi, align.abi);\n+                        }\n+                    }\n                 }\n \n                 let largest_niche = Niche::from_scalar(dl, Size::ZERO, tag);"}, {"sha": "f129f073e98ded94b27ff273a5c1b15721f6a1a7", "filename": "src/test/codegen/align-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec53c379ccb79257f4802a883b42789daec00c50/src%2Ftest%2Fcodegen%2Falign-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec53c379ccb79257f4802a883b42789daec00c50/src%2Ftest%2Fcodegen%2Falign-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Falign-struct.rs?ref=ec53c379ccb79257f4802a883b42789daec00c50", "patch": "@@ -19,7 +19,7 @@ pub enum Enum4 {\n     A(i32),\n     B(i32),\n }\n-// CHECK: %\"Enum4::A\" = type { [1 x i32], i32 }\n+// No Aggregate type, and hence nothing in LLVM IR.\n \n pub enum Enum64 {\n     A(Align64),"}, {"sha": "7dbcc151855016fa5ab0545924ccb3693ee6385d", "filename": "src/test/ui/layout/debug.stderr", "status": "modified", "additions": 32, "deletions": 6, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ec53c379ccb79257f4802a883b42789daec00c50/src%2Ftest%2Fui%2Flayout%2Fdebug.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec53c379ccb79257f4802a883b42789daec00c50/src%2Ftest%2Fui%2Flayout%2Fdebug.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fdebug.stderr?ref=ec53c379ccb79257f4802a883b42789daec00c50", "patch": "@@ -184,9 +184,22 @@ error: layout_of(std::result::Result<i32, i32>) = Layout {\n                        variants: Single {\n                            index: 0,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n+                       abi: ScalarPair(\n+                           Initialized {\n+                               value: Int(\n+                                   I32,\n+                                   false,\n+                               ),\n+                               valid_range: 0..=1,\n+                           },\n+                           Initialized {\n+                               value: Int(\n+                                   I32,\n+                                   true,\n+                               ),\n+                               valid_range: 0..=4294967295,\n+                           },\n+                       ),\n                        largest_niche: None,\n                        align: AbiAndPrefAlign {\n                            abi: Align(4 bytes),\n@@ -206,9 +219,22 @@ error: layout_of(std::result::Result<i32, i32>) = Layout {\n                        variants: Single {\n                            index: 1,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n+                       abi: ScalarPair(\n+                           Initialized {\n+                               value: Int(\n+                                   I32,\n+                                   false,\n+                               ),\n+                               valid_range: 0..=1,\n+                           },\n+                           Initialized {\n+                               value: Int(\n+                                   I32,\n+                                   true,\n+                               ),\n+                               valid_range: 0..=4294967295,\n+                           },\n+                       ),\n                        largest_niche: None,\n                        align: AbiAndPrefAlign {\n                            abi: Align(4 bytes),"}, {"sha": "33dfa307c1d271a9ac819e53ebf5cd2967f60a4c", "filename": "src/test/ui/layout/issue-96158-scalarpair-payload-might-be-uninit.stderr", "status": "modified", "additions": 77, "deletions": 15, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/ec53c379ccb79257f4802a883b42789daec00c50/src%2Ftest%2Fui%2Flayout%2Fissue-96158-scalarpair-payload-might-be-uninit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec53c379ccb79257f4802a883b42789daec00c50/src%2Ftest%2Fui%2Flayout%2Fissue-96158-scalarpair-payload-might-be-uninit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fissue-96158-scalarpair-payload-might-be-uninit.stderr?ref=ec53c379ccb79257f4802a883b42789daec00c50", "patch": "@@ -30,9 +30,21 @@ error: layout_of(MissingPayloadField) = Layout {\n                        variants: Single {\n                            index: 0,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n+                       abi: ScalarPair(\n+                           Initialized {\n+                               value: Int(\n+                                   I8,\n+                                   false,\n+                               ),\n+                               valid_range: 0..=1,\n+                           },\n+                           Union {\n+                               value: Int(\n+                                   I8,\n+                                   false,\n+                               ),\n+                           },\n+                       ),\n                        largest_niche: None,\n                        align: AbiAndPrefAlign {\n                            abi: Align(1 bytes),\n@@ -131,9 +143,22 @@ error: layout_of(CommonPayloadField) = Layout {\n                        variants: Single {\n                            index: 0,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n+                       abi: ScalarPair(\n+                           Initialized {\n+                               value: Int(\n+                                   I8,\n+                                   false,\n+                               ),\n+                               valid_range: 0..=1,\n+                           },\n+                           Initialized {\n+                               value: Int(\n+                                   I8,\n+                                   false,\n+                               ),\n+                               valid_range: 0..=255,\n+                           },\n+                       ),\n                        largest_niche: None,\n                        align: AbiAndPrefAlign {\n                            abi: Align(1 bytes),\n@@ -153,9 +178,22 @@ error: layout_of(CommonPayloadField) = Layout {\n                        variants: Single {\n                            index: 1,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n+                       abi: ScalarPair(\n+                           Initialized {\n+                               value: Int(\n+                                   I8,\n+                                   false,\n+                               ),\n+                               valid_range: 0..=1,\n+                           },\n+                           Initialized {\n+                               value: Int(\n+                                   I8,\n+                                   false,\n+                               ),\n+                               valid_range: 0..=255,\n+                           },\n+                       ),\n                        largest_niche: None,\n                        align: AbiAndPrefAlign {\n                            abi: Align(1 bytes),\n@@ -237,9 +275,21 @@ error: layout_of(CommonPayloadFieldIsMaybeUninit) = Layout {\n                        variants: Single {\n                            index: 0,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n+                       abi: ScalarPair(\n+                           Initialized {\n+                               value: Int(\n+                                   I8,\n+                                   false,\n+                               ),\n+                               valid_range: 0..=1,\n+                           },\n+                           Union {\n+                               value: Int(\n+                                   I8,\n+                                   false,\n+                               ),\n+                           },\n+                       ),\n                        largest_niche: None,\n                        align: AbiAndPrefAlign {\n                            abi: Align(1 bytes),\n@@ -259,9 +309,21 @@ error: layout_of(CommonPayloadFieldIsMaybeUninit) = Layout {\n                        variants: Single {\n                            index: 1,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n+                       abi: ScalarPair(\n+                           Initialized {\n+                               value: Int(\n+                                   I8,\n+                                   false,\n+                               ),\n+                               valid_range: 0..=1,\n+                           },\n+                           Union {\n+                               value: Int(\n+                                   I8,\n+                                   false,\n+                               ),\n+                           },\n+                       ),\n                        largest_niche: None,\n                        align: AbiAndPrefAlign {\n                            abi: Align(1 bytes),"}]}