{"sha": "4c0c0f6158b464ee5070b32bb37f2863d0eff012", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjMGMwZjYxNThiNDY0ZWU1MDcwYjMyYmIzN2YyODYzZDBlZmYwMTI=", "commit": {"author": {"name": "Baoshan Pang", "email": "baoshan.pang@windriver.com", "date": "2019-07-16T06:57:53Z"}, "committer": {"name": "Baoshan Pang", "email": "baoshan.pang@windriver.com", "date": "2019-07-16T07:13:07Z"}, "message": "Add supporting for vxWorks\n\nr? @alexcrichton", "tree": {"sha": "3306eadf9f3bb9023cfca1fc16b44e18132916e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3306eadf9f3bb9023cfca1fc16b44e18132916e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c0c0f6158b464ee5070b32bb37f2863d0eff012", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c0c0f6158b464ee5070b32bb37f2863d0eff012", "html_url": "https://github.com/rust-lang/rust/commit/4c0c0f6158b464ee5070b32bb37f2863d0eff012", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c0c0f6158b464ee5070b32bb37f2863d0eff012/comments", "author": {"login": "bpangWR", "id": 53950092, "node_id": "MDQ6VXNlcjUzOTUwMDky", "avatar_url": "https://avatars.githubusercontent.com/u/53950092?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bpangWR", "html_url": "https://github.com/bpangWR", "followers_url": "https://api.github.com/users/bpangWR/followers", "following_url": "https://api.github.com/users/bpangWR/following{/other_user}", "gists_url": "https://api.github.com/users/bpangWR/gists{/gist_id}", "starred_url": "https://api.github.com/users/bpangWR/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bpangWR/subscriptions", "organizations_url": "https://api.github.com/users/bpangWR/orgs", "repos_url": "https://api.github.com/users/bpangWR/repos", "events_url": "https://api.github.com/users/bpangWR/events{/privacy}", "received_events_url": "https://api.github.com/users/bpangWR/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bpangWR", "id": 53950092, "node_id": "MDQ6VXNlcjUzOTUwMDky", "avatar_url": "https://avatars.githubusercontent.com/u/53950092?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bpangWR", "html_url": "https://github.com/bpangWR", "followers_url": "https://api.github.com/users/bpangWR/followers", "following_url": "https://api.github.com/users/bpangWR/following{/other_user}", "gists_url": "https://api.github.com/users/bpangWR/gists{/gist_id}", "starred_url": "https://api.github.com/users/bpangWR/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bpangWR/subscriptions", "organizations_url": "https://api.github.com/users/bpangWR/orgs", "repos_url": "https://api.github.com/users/bpangWR/repos", "events_url": "https://api.github.com/users/bpangWR/events{/privacy}", "received_events_url": "https://api.github.com/users/bpangWR/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a95e9704de0eeaecba55df102c1129e79a3a929", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a95e9704de0eeaecba55df102c1129e79a3a929", "html_url": "https://github.com/rust-lang/rust/commit/4a95e9704de0eeaecba55df102c1129e79a3a929"}], "stats": {"total": 8794, "additions": 8791, "deletions": 3}, "files": [{"sha": "c58a98bac36783dccffe786a65c76f1d8a2b14f0", "filename": "src/bootstrap/cc_detect.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Fbootstrap%2Fcc_detect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Fbootstrap%2Fcc_detect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcc_detect.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -45,6 +45,8 @@ fn cc2ar(cc: &Path, target: &str) -> Option<PathBuf> {\n         Some(PathBuf::from(\"ar\"))\n     } else if target.contains(\"openbsd\") {\n         Some(PathBuf::from(\"ar\"))\n+    } else if target.contains(\"vxworks\") {\n+        Some(PathBuf::from(\"vx-ar\"))\n     } else {\n         let parent = cc.parent().unwrap();\n         let file = cc.file_name().unwrap().to_str().unwrap();"}, {"sha": "6ad6632341ce3b3f37c57c082d855f783fe94203", "filename": "src/librustc_target/spec/aarch64_wrs_vxworks.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibrustc_target%2Fspec%2Faarch64_wrs_vxworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibrustc_target%2Fspec%2Faarch64_wrs_vxworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Faarch64_wrs_vxworks.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,24 @@\n+use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::vxworks_base::opts();\n+    base.max_atomic_width = Some(128);\n+\n+    Ok(Target {\n+        llvm_target: \"aarch64-unknown-linux-gnu\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        target_env: \"gnu\".to_string(),\n+        data_layout: \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\".to_string(),\n+        arch: \"aarch64\".to_string(),\n+        target_os: \"vxworks\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: TargetOptions {\n+            abi_blacklist: super::arm_base::abi_blacklist(),\n+            target_mcount: \"\\u{1}_mcount\".to_string(),\n+            .. base\n+        },\n+    })\n+}"}, {"sha": "7db587d9b35d4755815238a68b9b044f2a082e27", "filename": "src/librustc_target/spec/arm_wrs_vxworks.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibrustc_target%2Fspec%2Farm_wrs_vxworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibrustc_target%2Fspec%2Farm_wrs_vxworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Farm_wrs_vxworks.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,32 @@\n+use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+\n+// This target is for glibc Linux on ARMv7 without NEON or\n+// thumb-mode. See the thumbv7neon variant for enabling both.\n+\n+pub fn target() -> TargetResult {\n+    let base = super::vxworks_base::opts();\n+    Ok(Target {\n+        llvm_target: \"armv7-unknown-linux-gnueabihf\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"e-m:e-p:32:32-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n+        arch: \"arm\".to_string(),\n+        target_os: \"vxworks\".to_string(),\n+        target_env: \"gnu\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+\n+        options: TargetOptions {\n+            // Info about features at https://wiki.debian.org/ArmHardFloatPort\n+            features: \"+v7,+vfp3,+d16,+thumb2,-neon\".to_string(),\n+            cpu: \"generic\".to_string(),\n+            max_atomic_width: Some(64),\n+            abi_blacklist: super::arm_base::abi_blacklist(),\n+            target_mcount: \"\\u{1}__gnu_mcount_nc\".to_string(),\n+//          tls_model: \"local-exec\".to_string(),\n+            position_independent_executables: false,\n+            .. base\n+        }\n+    })\n+}"}, {"sha": "bde903de102212370bff818009362b10a427688c", "filename": "src/librustc_target/spec/arm_wrs_vxworks_sf.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibrustc_target%2Fspec%2Farm_wrs_vxworks_sf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibrustc_target%2Fspec%2Farm_wrs_vxworks_sf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Farm_wrs_vxworks_sf.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,25 @@\n+use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::vxworks_base::opts();\n+    base.max_atomic_width = Some(64);\n+    Ok(Target {\n+        llvm_target: \"arm-unknown-linux-gnueabi\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"e-m:e-p:32:32-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n+        arch: \"arm\".to_string(),\n+        target_os: \"vxworks\".to_string(),\n+        target_env: \"gnu\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+\n+        options: TargetOptions {\n+            features: \"+strict-align,+v6\".to_string(),\n+            abi_blacklist: super::arm_base::abi_blacklist(),\n+            target_mcount: \"\\u{1}__gnu_mcount_nc\".to_string(),\n+            .. base\n+        },\n+    })\n+}"}, {"sha": "7db587d9b35d4755815238a68b9b044f2a082e27", "filename": "src/librustc_target/spec/armv7_wrs_vxworks.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibrustc_target%2Fspec%2Farmv7_wrs_vxworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibrustc_target%2Fspec%2Farmv7_wrs_vxworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Farmv7_wrs_vxworks.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,32 @@\n+use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+\n+// This target is for glibc Linux on ARMv7 without NEON or\n+// thumb-mode. See the thumbv7neon variant for enabling both.\n+\n+pub fn target() -> TargetResult {\n+    let base = super::vxworks_base::opts();\n+    Ok(Target {\n+        llvm_target: \"armv7-unknown-linux-gnueabihf\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"e-m:e-p:32:32-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n+        arch: \"arm\".to_string(),\n+        target_os: \"vxworks\".to_string(),\n+        target_env: \"gnu\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+\n+        options: TargetOptions {\n+            // Info about features at https://wiki.debian.org/ArmHardFloatPort\n+            features: \"+v7,+vfp3,+d16,+thumb2,-neon\".to_string(),\n+            cpu: \"generic\".to_string(),\n+            max_atomic_width: Some(64),\n+            abi_blacklist: super::arm_base::abi_blacklist(),\n+            target_mcount: \"\\u{1}__gnu_mcount_nc\".to_string(),\n+//          tls_model: \"local-exec\".to_string(),\n+            position_independent_executables: false,\n+            .. base\n+        }\n+    })\n+}"}, {"sha": "355250e6eca7f152fe03701c8dc8dd277cf9bf2c", "filename": "src/librustc_target/spec/i586_wrs_vxworks.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibrustc_target%2Fspec%2Fi586_wrs_vxworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibrustc_target%2Fspec%2Fi586_wrs_vxworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fi586_wrs_vxworks.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,8 @@\n+use crate::spec::TargetResult;\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::i686_wrs_vxworks::target()?;\n+    base.options.cpu = \"pentium\".to_string();\n+    base.llvm_target = \"i586-unknown-linux-gnu\".to_string();\n+    Ok(base)\n+}"}, {"sha": "4b1ff5ccbe8aa238d4cdbab86ea4cbc6e666779b", "filename": "src/librustc_target/spec/i686_wrs_vxworks.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibrustc_target%2Fspec%2Fi686_wrs_vxworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibrustc_target%2Fspec%2Fi686_wrs_vxworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fi686_wrs_vxworks.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,23 @@\n+use crate::spec::{LinkerFlavor, Target, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::vxworks_base::opts();\n+    base.cpu = \"pentium4\".to_string();\n+    base.max_atomic_width = Some(64);\n+    base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m32\".to_string());\n+    base.stack_probes = true;\n+\n+    Ok(Target {\n+        llvm_target: \"i686-unknown-linux-gnu\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"e-m:e-p:32:32-f64:32:64-f80:32-n8:16:32-S128\".to_string(),\n+        arch: \"x86\".to_string(),\n+        target_os: \"vxworks\".to_string(),\n+        target_env: \"gnu\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: base,\n+    })\n+}"}, {"sha": "4b1ff5ccbe8aa238d4cdbab86ea4cbc6e666779b", "filename": "src/librustc_target/spec/i686_wrs_vxworks_gnu.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibrustc_target%2Fspec%2Fi686_wrs_vxworks_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibrustc_target%2Fspec%2Fi686_wrs_vxworks_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fi686_wrs_vxworks_gnu.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,23 @@\n+use crate::spec::{LinkerFlavor, Target, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::vxworks_base::opts();\n+    base.cpu = \"pentium4\".to_string();\n+    base.max_atomic_width = Some(64);\n+    base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m32\".to_string());\n+    base.stack_probes = true;\n+\n+    Ok(Target {\n+        llvm_target: \"i686-unknown-linux-gnu\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"e-m:e-p:32:32-f64:32:64-f80:32-n8:16:32-S128\".to_string(),\n+        arch: \"x86\".to_string(),\n+        target_os: \"vxworks\".to_string(),\n+        target_env: \"gnu\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: base,\n+    })\n+}"}, {"sha": "1fdc9b015ba395e4ed93c5439c8cd32bdfc0a798", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -66,6 +66,7 @@ mod fuchsia_base;\n mod redox_base;\n mod riscv_base;\n mod wasm32_base;\n+mod vxworks_base;\n \n #[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd, Hash,\n          RustcEncodable, RustcDecodable)]\n@@ -361,7 +362,6 @@ supported_targets! {\n     (\"thumbv7neon-unknown-linux-gnueabihf\", thumbv7neon_unknown_linux_gnueabihf),\n     (\"armv7-unknown-linux-musleabihf\", armv7_unknown_linux_musleabihf),\n     (\"aarch64-unknown-linux-gnu\", aarch64_unknown_linux_gnu),\n-\n     (\"aarch64-unknown-linux-musl\", aarch64_unknown_linux_musl),\n     (\"x86_64-unknown-linux-musl\", x86_64_unknown_linux_musl),\n     (\"i686-unknown-linux-musl\", i686_unknown_linux_musl),\n@@ -476,6 +476,15 @@ supported_targets! {\n     (\"x86_64-unknown-uefi\", x86_64_unknown_uefi),\n \n     (\"nvptx64-nvidia-cuda\", nvptx64_nvidia_cuda),\n+\n+    (\"x86_64-wrs-vxworks\", x86_64_wrs_vxworks),\n+    (\"i686-wrs-vxworks\", i686_wrs_vxworks),\n+    (\"i586-wrs-vxworks\", i586_wrs_vxworks),\n+    (\"armv7-wrs-vxworks\", armv7_wrs_vxworks),\n+    (\"aarch64-wrs-vxworks\", aarch64_wrs_vxworks),\n+    (\"powerpc-wrs-vxworks\", powerpc_wrs_vxworks),\n+    (\"powerpc-wrs-vxworks-spe\", powerpc_wrs_vxworks_spe),\n+    (\"powerpc64-wrs-vxworks\", powerpc64_wrs_vxworks),\n }\n \n /// Everything `rustc` knows about how to compile for a specific target."}, {"sha": "a9520709e66569d955f0a6a5311662e2488e9b9c", "filename": "src/librustc_target/spec/powerpc64_wrs_vxworks.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibrustc_target%2Fspec%2Fpowerpc64_wrs_vxworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibrustc_target%2Fspec%2Fpowerpc64_wrs_vxworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fpowerpc64_wrs_vxworks.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,25 @@\n+use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::vxworks_base::opts();\n+    base.cpu = \"ppc64\".to_string();\n+    base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m64\".to_string());\n+    base.max_atomic_width = Some(64);\n+\n+    Ok(Target {\n+        llvm_target: \"powerpc64-unknown-linux-gnu\".to_string(),\n+        target_endian: \"big\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"E-m:e-i64:64-n32:64\".to_string(),\n+        arch: \"powerpc64\".to_string(),\n+        target_os: \"vxworks\".to_string(),\n+        target_env: \"gnu\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: TargetOptions {\n+            target_mcount: \"_mcount\".to_string(),\n+            .. base\n+        },\n+    })\n+}"}, {"sha": "c2dae8535a2870b2fb58b624e0a4d6a348872136", "filename": "src/librustc_target/spec/powerpc64_wrs_vxworks_gnusf.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibrustc_target%2Fspec%2Fpowerpc64_wrs_vxworks_gnusf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibrustc_target%2Fspec%2Fpowerpc64_wrs_vxworks_gnusf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fpowerpc64_wrs_vxworks_gnusf.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,26 @@\n+use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::vxworks_base::opts();\n+    base.cpu = \"ppc64\".to_string();\n+    base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m64\".to_string());\n+    base.max_atomic_width = Some(64);\n+\n+    Ok(Target {\n+        llvm_target: \"powerpc64-unknown-linux-gnu\".to_string(),\n+        target_endian: \"big\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"E-m:e-i64:64-n32:64\".to_string(),\n+        arch: \"powerpc64\".to_string(),\n+        target_os: \"vxworks\".to_string(),\n+        target_env: \"gnu\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: TargetOptions {\n+            features: \"-hard-float\".to_string(),\n+            target_mcount: \"_mcount\".to_string(),\n+            .. base\n+        },\n+    })\n+}"}, {"sha": "2e833ee1d487b3d31b8fc0fe2d00b693b2fe85cc", "filename": "src/librustc_target/spec/powerpc_wrs_vxworks.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibrustc_target%2Fspec%2Fpowerpc_wrs_vxworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibrustc_target%2Fspec%2Fpowerpc_wrs_vxworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fpowerpc_wrs_vxworks.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,26 @@\n+use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::vxworks_base::opts();\n+    base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m32\".to_string());\n+    base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"--secure-plt\".to_string());\n+    base.max_atomic_width = Some(32);\n+\n+    Ok(Target {\n+        llvm_target: \"powerpc-unknown-linux-gnu\".to_string(),\n+        target_endian: \"big\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"E-m:e-p:32:32-i64:64-n32\".to_string(),\n+        arch: \"powerpc\".to_string(),\n+        target_os: \"vxworks\".to_string(),\n+        target_env: \"gnu\".to_string(),\n+        target_vendor: \"wrs\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: TargetOptions {\n+            features: \"+secure-plt\".to_string(),\n+            target_mcount: \"_mcount\".to_string(),\n+            .. base\n+        },\n+    })\n+}"}, {"sha": "43723ea7c0cc8404c0a3a93fe89d97c24a270c32", "filename": "src/librustc_target/spec/powerpc_wrs_vxworks_gnusf.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibrustc_target%2Fspec%2Fpowerpc_wrs_vxworks_gnusf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibrustc_target%2Fspec%2Fpowerpc_wrs_vxworks_gnusf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fpowerpc_wrs_vxworks_gnusf.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,26 @@\n+use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::vxworks_base::opts();\n+    base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m32\".to_string());\n+    base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"--secure-plt\".to_string());\n+    base.max_atomic_width = Some(32);\n+\n+    Ok(Target {\n+        llvm_target: \"powerpc-unknown-linux-gnu\".to_string(),\n+        target_endian: \"big\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"E-m:e-p:32:32-i64:64-n32\".to_string(),\n+        arch: \"powerpc\".to_string(),\n+        target_os: \"vxworks\".to_string(),\n+        target_env: \"gnu\".to_string(),\n+        target_vendor: \"wrs\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: TargetOptions {\n+            features: \"+secure-plt,-hard-float\".to_string(),\n+            target_mcount: \"_mcount\".to_string(),\n+            .. base\n+        },\n+    })\n+}"}, {"sha": "8f236235867e57bba34a2ed93c893d541065ee80", "filename": "src/librustc_target/spec/powerpc_wrs_vxworks_gnuspesf.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibrustc_target%2Fspec%2Fpowerpc_wrs_vxworks_gnuspesf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibrustc_target%2Fspec%2Fpowerpc_wrs_vxworks_gnuspesf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fpowerpc_wrs_vxworks_gnuspesf.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,27 @@\n+use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::vxworks_base::opts();\n+    base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-mspe\".to_string());\n+    base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"--secure-plt\".to_string());\n+    base.max_atomic_width = Some(32);\n+\n+    Ok(Target {\n+        llvm_target: \"powerpc-unknown-linux-gnuspe\".to_string(),\n+        target_endian: \"big\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"E-m:e-p:32:32-i64:64-n32\".to_string(),\n+        arch: \"powerpc\".to_string(),\n+        target_os: \"vxworks\".to_string(),\n+        target_env: \"gnu\".to_string(),\n+        target_vendor: \"wrs\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: TargetOptions {\n+            // feature msync would disable instruction 'fsync' which is not supported by fsl_p1p2\n+            features: \"+secure-plt,+msync,-hard-float\".to_string(),\n+            target_mcount: \"_mcount\".to_string(),\n+            .. base\n+        },\n+    })\n+}"}, {"sha": "2305b4b7ab84cc001676d78c74ca93deaa15dd27", "filename": "src/librustc_target/spec/powerpc_wrs_vxworks_spe.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibrustc_target%2Fspec%2Fpowerpc_wrs_vxworks_spe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibrustc_target%2Fspec%2Fpowerpc_wrs_vxworks_spe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fpowerpc_wrs_vxworks_spe.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,27 @@\n+use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::vxworks_base::opts();\n+    base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-mspe\".to_string());\n+    base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"--secure-plt\".to_string());\n+    base.max_atomic_width = Some(32);\n+\n+    Ok(Target {\n+        llvm_target: \"powerpc-unknown-linux-gnuspe\".to_string(),\n+        target_endian: \"big\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"E-m:e-p:32:32-i64:64-n32\".to_string(),\n+        arch: \"powerpc\".to_string(),\n+        target_os: \"vxworks\".to_string(),\n+        target_env: \"gnu\".to_string(),\n+        target_vendor: \"wrs\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: TargetOptions {\n+            // feature msync would disable instruction 'fsync' which is not supported by fsl_p1p2\n+            features: \"+secure-plt,+msync\".to_string(),\n+            target_mcount: \"_mcount\".to_string(),\n+            .. base\n+        },\n+    })\n+}"}, {"sha": "6db56c553a9d81df930822dd8c1062b25cea7611", "filename": "src/librustc_target/spec/vxworks_base.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibrustc_target%2Fspec%2Fvxworks_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibrustc_target%2Fspec%2Fvxworks_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fvxworks_base.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,41 @@\n+use crate::spec::{LinkArgs, LinkerFlavor, TargetOptions, RelroLevel};\n+use std::default::Default;\n+\n+pub fn opts() -> TargetOptions {\n+    let mut args = LinkArgs::new();\n+    args.insert(LinkerFlavor::Gcc, vec![\n+        // We want to be able to strip as much executable code as possible\n+        // from the linker command line, and this flag indicates to the\n+        // linker that it can avoid linking in dynamic libraries that don't\n+        // actually satisfy any symbols up to that point (as with many other\n+        // resolutions the linker does). This option only applies to all\n+        // following libraries so we're sure to pass it as one of the first\n+        // arguments.\n+        \"-Wl,--as-needed\".to_string(),\n+\n+        // Always enable NX protection when it is available\n+        \"-Wl,-z,noexecstack\".to_string(),\n+    ]);\n+\n+    let mut late_lk_args = LinkArgs::new();\n+    late_lk_args.insert(LinkerFlavor::Gcc, vec![\n+        \"-lnet\".to_string(),\n+        \"-lunix\".to_string(),\n+    ]);\n+\n+    TargetOptions {\n+        linker: Some(\"vx-cxx\".to_string()),\n+        exe_suffix: \".vxe\".to_string(),\n+        late_link_args: late_lk_args,\n+        dynamic_linking: true,\n+        executables: true,\n+        target_family: Some(\"unix\".to_string()),\n+        linker_is_gnu: true,\n+        has_rpath: true,\n+        pre_link_args: args,\n+        position_independent_executables: true,\n+        relro_level: RelroLevel::Full,\n+        has_elf_tls: true,\n+        .. Default::default()\n+    }\n+}"}, {"sha": "eac7cd7502d462e50b3329268df287790b9799cd", "filename": "src/librustc_target/spec/x86_64_wrs_vxworks.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibrustc_target%2Fspec%2Fx86_64_wrs_vxworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibrustc_target%2Fspec%2Fx86_64_wrs_vxworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fx86_64_wrs_vxworks.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,23 @@\n+use crate::spec::{LinkerFlavor, Target, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::vxworks_base::opts();\n+    base.cpu = \"x86-64\".to_string();\n+    base.max_atomic_width = Some(64);\n+    base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m64\".to_string());\n+    base.stack_probes = true;\n+\n+    Ok(Target {\n+        llvm_target: \"x86_64-unknown-linux-gnu\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\".to_string(),\n+        arch: \"x86_64\".to_string(),\n+        target_os: \"vxworks\".to_string(),\n+        target_env: \"gnu\".to_string(),\n+        target_vendor: \"wrs\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: base,\n+    })\n+}"}, {"sha": "c9aa5f4de95531b921b59232dee744298b797cba", "filename": "src/libstd/os/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fmod.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -24,7 +24,7 @@ cfg_if::cfg_if! {\n         // If we're not documenting libstd then we just expose the main modules\n         // as we otherwise would.\n \n-        #[cfg(any(target_os = \"redox\", unix))]\n+        #[cfg(any(target_os = \"redox\", unix, target_os = \"vxworks\"))]\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         pub use crate::sys::ext as unix;\n \n@@ -51,6 +51,7 @@ cfg_if::cfg_if! {\n #[cfg(target_os = \"fuchsia\")]    pub mod fuchsia;\n #[cfg(target_os = \"hermit\")]     pub mod hermit;\n #[cfg(target_os = \"wasi\")]       pub mod wasi;\n+#[cfg(target_os = \"vxworks\")]    pub mod vxworks;\n #[cfg(all(target_vendor = \"fortanix\", target_env = \"sgx\"))] pub mod fortanix_sgx;\n \n pub mod raw;"}, {"sha": "c0b0b6d40d891a742ff08dfa8841843ec96ce4da", "filename": "src/libstd/os/raw/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fos%2Fraw%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fos%2Fraw%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fraw%2Fmod.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -25,6 +25,10 @@\n                                         target_arch = \"arm\",\n                                         target_arch = \"powerpc\")),\n           all(target_os = \"openbsd\", target_arch = \"aarch64\"),\n+          all(target_os = \"vxworks\", any(target_arch = \"aarch64\",\n+                                         target_arch = \"arm\",\n+                                         target_arch = \"powerpc64\",\n+                                         target_arch = \"powerpc\")),\n           all(target_os = \"fuchsia\", target_arch = \"aarch64\")))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_char = u8;\n #[doc(include = \"os/raw/char.md\")]\n@@ -44,6 +48,10 @@\n                                             target_arch = \"arm\",\n                                             target_arch = \"powerpc\")),\n               all(target_os = \"openbsd\", target_arch = \"aarch64\"),\n+              all(target_os = \"vxworks\", any(target_arch = \"aarch64\",\n+                                             target_arch = \"arm\",\n+                                             target_arch = \"powerpc64\",\n+                                             target_arch = \"powerpc\")),\n               all(target_os = \"fuchsia\", target_arch = \"aarch64\"))))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_char = i8;\n #[doc(include = \"os/raw/schar.md\")]"}, {"sha": "57ab4fb943e43ac9fc0688e0c66d4ab6521e24fb", "filename": "src/libstd/os/vxworks/fs.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fos%2Fvxworks%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fos%2Fvxworks%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fvxworks%2Ffs.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,84 @@\n+#![stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+\n+use crate::fs::Metadata;\n+use crate::sys_common::AsInner;\n+\n+///\n+/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n+#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+pub trait MetadataExt {\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_dev(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_ino(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_mode(&self) -> u32;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_nlink(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_uid(&self) -> u32;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_gid(&self) -> u32;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_rdev(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_size(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_atime(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_mtime(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_ctime(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_blksize(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_blocks(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_attrib(&self) -> u8;\n+}\n+\n+#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+impl MetadataExt for Metadata {\n+    fn st_dev(&self) -> u64 {\n+        self.as_inner().as_inner().st_dev as u64\n+    }\n+    fn st_ino(&self) -> u64 {\n+        self.as_inner().as_inner().st_ino as u64\n+    }\n+    fn st_mode(&self) -> u32 {\n+        self.as_inner().as_inner().st_mode as u32\n+    }\n+    fn st_nlink(&self) -> u64 {\n+        self.as_inner().as_inner().st_nlink as u64\n+    }\n+    fn st_uid(&self) -> u32 {\n+        self.as_inner().as_inner().st_uid as u32\n+    }\n+    fn st_gid(&self) -> u32 {\n+        self.as_inner().as_inner().st_gid as u32\n+    }\n+    fn st_rdev(&self) -> u64 {\n+        self.as_inner().as_inner().st_rdev as u64\n+    }\n+    fn st_size(&self) -> u64 {\n+        self.as_inner().as_inner().st_size as u64\n+    }\n+    fn st_atime(&self) -> i64 {\n+        self.as_inner().as_inner().st_atime as i64\n+    }\n+    fn st_mtime(&self) -> i64 {\n+        self.as_inner().as_inner().st_mtime as i64\n+    }\n+    fn st_ctime(&self) -> i64 {\n+        self.as_inner().as_inner().st_ctime as i64\n+    }\n+    fn st_blksize(&self) -> u64 {\n+        self.as_inner().as_inner().st_blksize as u64\n+    }\n+    fn st_blocks(&self) -> u64 {\n+        self.as_inner().as_inner().st_blocks as u64\n+    }\n+    fn st_attrib(&self) -> u8 {\n+        self.as_inner().as_inner().st_attrib as u8\n+    }\n+}"}, {"sha": "2255a103d353d6d2e78ca8547edc14ceae289f5e", "filename": "src/libstd/os/vxworks/mod.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fos%2Fvxworks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fos%2Fvxworks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fvxworks%2Fmod.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,6 @@\n+//! VxWorks-specific definitions\n+\n+#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+\n+pub mod raw;\n+pub mod fs;"}, {"sha": "ae0560a5a92ac25689a2ba7eceff0190858373d4", "filename": "src/libstd/os/vxworks/raw.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fos%2Fvxworks%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fos%2Fvxworks%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fvxworks%2Fraw.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,7 @@\n+//! VxWorks-specific raw type definitions\n+#![stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+\n+use crate::os::raw::{c_ulong};\n+\n+#[stable(feature = \"pthread_t\", since = \"1.8.0\")]\n+pub type pthread_t = c_ulong;"}, {"sha": "35972b54e39d253a8d38b53367c6a67dc8bde99c", "filename": "src/libstd/sys/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fmod.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -23,7 +23,10 @@\n #![allow(missing_debug_implementations)]\n \n cfg_if::cfg_if! {\n-    if #[cfg(unix)] {\n+    if #[cfg(target_os = \"vxworks\")] {\n+        mod vxworks;\n+        pub use self::vxworks::*;\n+    } else if #[cfg(unix)] {\n         mod unix;\n         pub use self::unix::*;\n     } else if #[cfg(windows)] {"}, {"sha": "c60d1b8dab898200e679cc8d893d4134589350f9", "filename": "src/libstd/sys/vxworks/alloc.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Falloc.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,83 @@\n+use crate::ptr;\n+use crate::sys_common::alloc::{MIN_ALIGN, realloc_fallback};\n+use crate::alloc::{GlobalAlloc, Layout, System};\n+\n+#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n+unsafe impl GlobalAlloc for System {\n+    #[inline]\n+    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+        if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n+            libc::malloc(layout.size()) as *mut u8\n+        } else {\n+            aligned_malloc(&layout)\n+        }\n+    }\n+\n+    #[inline]\n+    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n+        if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n+            libc::calloc(layout.size(), 1) as *mut u8\n+        } else {\n+            let ptr = self.alloc(layout.clone());\n+            if !ptr.is_null() {\n+                ptr::write_bytes(ptr, 0, layout.size());\n+            }\n+            ptr\n+        }\n+    }\n+\n+    #[inline]\n+    unsafe fn dealloc(&self, ptr: *mut u8, _layout: Layout) {\n+        libc::free(ptr as *mut libc::c_void)\n+    }\n+\n+    #[inline]\n+    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n+        if layout.align() <= MIN_ALIGN && layout.align() <= new_size {\n+            libc::realloc(ptr as *mut libc::c_void, new_size) as *mut u8\n+        } else {\n+            realloc_fallback(self, ptr, layout, new_size)\n+        }\n+    }\n+}\n+\n+#[cfg(any(target_os = \"android\",\n+          target_os = \"hermit\",\n+          target_os = \"redox\",\n+          target_os = \"solaris\"))]\n+#[inline]\n+unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n+    // On android we currently target API level 9 which unfortunately\n+    // doesn't have the `posix_memalign` API used below. Instead we use\n+    // `memalign`, but this unfortunately has the property on some systems\n+    // where the memory returned cannot be deallocated by `free`!\n+    //\n+    // Upon closer inspection, however, this appears to work just fine with\n+    // Android, so for this platform we should be fine to call `memalign`\n+    // (which is present in API level 9). Some helpful references could\n+    // possibly be chromium using memalign [1], attempts at documenting that\n+    // memalign + free is ok [2] [3], or the current source of chromium\n+    // which still uses memalign on android [4].\n+    //\n+    // [1]: https://codereview.chromium.org/10796020/\n+    // [2]: https://code.google.com/p/android/issues/detail?id=35391\n+    // [3]: https://bugs.chromium.org/p/chromium/issues/detail?id=138579\n+    // [4]: https://chromium.googlesource.com/chromium/src/base/+/master/\n+    //                                       /memory/aligned_memory.cc\n+    libc::memalign(layout.align(), layout.size()) as *mut u8\n+}\n+\n+#[cfg(not(any(target_os = \"android\",\n+              target_os = \"hermit\",\n+              target_os = \"redox\",\n+              target_os = \"solaris\")))]\n+#[inline]\n+unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n+    let mut out = ptr::null_mut();\n+    let ret = libc::posix_memalign(&mut out, layout.align(), layout.size());\n+    if ret != 0 {\n+        ptr::null_mut()\n+    } else {\n+        out as *mut u8\n+    }\n+}"}, {"sha": "6774160bb2561596117de3b16800bd8e7ff31fcf", "filename": "src/libstd/sys/vxworks/android.rs", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fandroid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fandroid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fandroid.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,160 @@\n+//! Android ABI-compatibility module\n+//!\n+//! The ABI of Android has changed quite a bit over time, and libstd attempts to\n+//! be both forwards and backwards compatible as much as possible. We want to\n+//! always work with the most recent version of Android, but we also want to\n+//! work with older versions of Android for whenever projects need to.\n+//!\n+//! Our current minimum supported Android version is `android-9`, e.g., Android\n+//! with API level 9. We then in theory want to work on that and all future\n+//! versions of Android!\n+//!\n+//! Some of the detection here is done at runtime via `dlopen` and\n+//! introspection. Other times no detection is performed at all and we just\n+//! provide a fallback implementation as some versions of Android we support\n+//! don't have the function.\n+//!\n+//! You'll find more details below about why each compatibility shim is needed.\n+\n+#![cfg(target_os = \"android\")]\n+\n+use libc::{c_int, c_void, sighandler_t, size_t, ssize_t};\n+use libc::{ftruncate, pread, pwrite};\n+\n+use crate::io;\n+use super::{cvt, cvt_r};\n+\n+// The `log2` and `log2f` functions apparently appeared in android-18, or at\n+// least you can see they're not present in the android-17 header [1] and they\n+// are present in android-18 [2].\n+//\n+// [1]: https://chromium.googlesource.com/android_tools/+/20ee6d20/ndk/platforms\n+//                                       /android-17/arch-arm/usr/include/math.h\n+// [2]: https://chromium.googlesource.com/android_tools/+/20ee6d20/ndk/platforms\n+//                                       /android-18/arch-arm/usr/include/math.h\n+//\n+// Note that these shims are likely less precise than directly calling `log2`,\n+// but hopefully that should be enough for now...\n+//\n+// Note that mathematically, for any arbitrary `y`:\n+//\n+//      log_2(x) = log_y(x) / log_y(2)\n+//               = log_y(x) / (1 / log_2(y))\n+//               = log_y(x) * log_2(y)\n+//\n+// Hence because `ln` (log_e) is available on all Android we just choose `y = e`\n+// and get:\n+//\n+//      log_2(x) = ln(x) * log_2(e)\n+\n+#[cfg(not(test))]\n+pub fn log2f32(f: f32) -> f32 {\n+    f.ln() * crate::f32::consts::LOG2_E\n+}\n+\n+#[cfg(not(test))]\n+pub fn log2f64(f: f64) -> f64 {\n+    f.ln() * crate::f64::consts::LOG2_E\n+}\n+\n+// Back in the day [1] the `signal` function was just an inline wrapper\n+// around `bsd_signal`, but starting in API level android-20 the `signal`\n+// symbols was introduced [2]. Finally, in android-21 the API `bsd_signal` was\n+// removed [3].\n+//\n+// Basically this means that if we want to be binary compatible with multiple\n+// Android releases (oldest being 9 and newest being 21) then we need to check\n+// for both symbols and not actually link against either.\n+//\n+// [1]: https://chromium.googlesource.com/android_tools/+/20ee6d20/ndk/platforms\n+//                                       /android-18/arch-arm/usr/include/signal.h\n+// [2]: https://chromium.googlesource.com/android_tools/+/fbd420/ndk_experimental\n+//                                       /platforms/android-20/arch-arm\n+//                                       /usr/include/signal.h\n+// [3]: https://chromium.googlesource.com/android_tools/+/20ee6d/ndk/platforms\n+//                                       /android-21/arch-arm/usr/include/signal.h\n+pub unsafe fn signal(signum: c_int, handler: sighandler_t) -> sighandler_t {\n+    weak!(fn signal(c_int, sighandler_t) -> sighandler_t);\n+    weak!(fn bsd_signal(c_int, sighandler_t) -> sighandler_t);\n+\n+    let f = signal.get().or_else(|| bsd_signal.get());\n+    let f = f.expect(\"neither `signal` nor `bsd_signal` symbols found\");\n+    f(signum, handler)\n+}\n+\n+// The `ftruncate64` symbol apparently appeared in android-12, so we do some\n+// dynamic detection to see if we can figure out whether `ftruncate64` exists.\n+//\n+// If it doesn't we just fall back to `ftruncate`, generating an error for\n+// too-large values.\n+#[cfg(target_pointer_width = \"32\")]\n+pub fn ftruncate64(fd: c_int, size: u64) -> io::Result<()> {\n+    weak!(fn ftruncate64(c_int, i64) -> c_int);\n+\n+    unsafe {\n+        match ftruncate64.get() {\n+            Some(f) => cvt_r(|| f(fd, size as i64)).map(|_| ()),\n+            None => {\n+                if size > i32::max_value() as u64 {\n+                    Err(io::Error::new(io::ErrorKind::InvalidInput,\n+                                       \"cannot truncate >2GB\"))\n+                } else {\n+                    cvt_r(|| ftruncate(fd, size as i32)).map(|_| ())\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(target_pointer_width = \"64\")]\n+pub fn ftruncate64(fd: c_int, size: u64) -> io::Result<()> {\n+    unsafe {\n+        cvt_r(|| ftruncate(fd, size as i64)).map(|_| ())\n+    }\n+}\n+\n+#[cfg(target_pointer_width = \"32\")]\n+pub unsafe fn cvt_pread64(fd: c_int, buf: *mut c_void, count: size_t, offset: i64)\n+    -> io::Result<ssize_t>\n+{\n+    use crate::convert::TryInto;\n+    weak!(fn pread64(c_int, *mut c_void, size_t, i64) -> ssize_t);\n+    pread64.get().map(|f| cvt(f(fd, buf, count, offset))).unwrap_or_else(|| {\n+        if let Ok(o) = offset.try_into() {\n+            cvt(pread(fd, buf, count, o))\n+        } else {\n+            Err(io::Error::new(io::ErrorKind::InvalidInput,\n+                               \"cannot pread >2GB\"))\n+        }\n+    })\n+}\n+\n+#[cfg(target_pointer_width = \"32\")]\n+pub unsafe fn cvt_pwrite64(fd: c_int, buf: *const c_void, count: size_t, offset: i64)\n+    -> io::Result<ssize_t>\n+{\n+    use crate::convert::TryInto;\n+    weak!(fn pwrite64(c_int, *const c_void, size_t, i64) -> ssize_t);\n+    pwrite64.get().map(|f| cvt(f(fd, buf, count, offset))).unwrap_or_else(|| {\n+        if let Ok(o) = offset.try_into() {\n+            cvt(pwrite(fd, buf, count, o))\n+        } else {\n+            Err(io::Error::new(io::ErrorKind::InvalidInput,\n+                               \"cannot pwrite >2GB\"))\n+        }\n+    })\n+}\n+\n+#[cfg(target_pointer_width = \"64\")]\n+pub unsafe fn cvt_pread64(fd: c_int, buf: *mut c_void, count: size_t, offset: i64)\n+    -> io::Result<ssize_t>\n+{\n+    cvt(pread(fd, buf, count, offset))\n+}\n+\n+#[cfg(target_pointer_width = \"64\")]\n+pub unsafe fn cvt_pwrite64(fd: c_int, buf: *const c_void, count: size_t, offset: i64)\n+    -> io::Result<ssize_t>\n+{\n+    cvt(pwrite(fd, buf, count, offset))\n+}"}, {"sha": "11c3cb7881950bb5eb5daf253b9d6f1987007cbc", "filename": "src/libstd/sys/vxworks/args.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fargs.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,85 @@\n+#![allow(dead_code)] // runtime init functions not used during testing\n+use crate::ffi::OsString;\n+use crate::marker::PhantomData;\n+use crate::vec;\n+\n+/// One-time global initialization.\n+pub unsafe fn init(argc: isize, argv: *const *const u8) { imp::init(argc, argv) }\n+\n+/// One-time global cleanup.\n+pub unsafe fn cleanup() { imp::cleanup() }\n+\n+/// Returns the command line arguments\n+pub fn args() -> Args {\n+    imp::args()\n+}\n+\n+pub struct Args {\n+    iter: vec::IntoIter<OsString>,\n+    _dont_send_or_sync_me: PhantomData<*mut ()>,\n+}\n+\n+impl Args {\n+    pub fn inner_debug(&self) -> &[OsString] {\n+        self.iter.as_slice()\n+    }\n+}\n+\n+impl Iterator for Args {\n+    type Item = OsString;\n+    fn next(&mut self) -> Option<OsString> { self.iter.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+}\n+\n+impl ExactSizeIterator for Args {\n+    fn len(&self) -> usize { self.iter.len() }\n+}\n+\n+impl DoubleEndedIterator for Args {\n+    fn next_back(&mut self) -> Option<OsString> { self.iter.next_back() }\n+}\n+\n+mod imp {\n+    use crate::ptr;\n+    use crate::ffi::{CStr, OsString};\n+    use crate::marker::PhantomData;\n+    use libc;\n+    use super::Args;\n+\n+    use crate::sys_common::mutex::Mutex;\n+\n+    static mut ARGC: isize = 0;\n+    static mut ARGV: *const *const u8 = ptr::null();\n+    static LOCK: Mutex = Mutex::new();\n+\n+    pub unsafe fn init(argc: isize, argv: *const *const u8) {\n+        let _guard = LOCK.lock();\n+        ARGC = argc;\n+        ARGV = argv;\n+    }\n+\n+    pub unsafe fn cleanup() {\n+        let _guard = LOCK.lock();\n+        ARGC = 0;\n+        ARGV = ptr::null();\n+    }\n+\n+    pub fn args() -> Args {\n+        Args {\n+            iter: clone().into_iter(),\n+            _dont_send_or_sync_me: PhantomData\n+        }\n+    }\n+\n+    fn clone() -> Vec<OsString> {\n+        unsafe {\n+            let _guard = LOCK.lock();\n+            let ret = (0..ARGC).map(|i| {\n+                let cstr = CStr::from_ptr(*ARGV.offset(i) as *const libc::c_char);\n+                use crate::sys::vxworks::ext::ffi::OsStringExt;\n+                OsStringExt::from_vec(cstr.to_bytes().to_vec())\n+            }).collect();\n+            return ret\n+        }\n+    }\n+}"}, {"sha": "0887e5a4df937ed97486ceb77367defe4ab1f833", "filename": "src/libstd/sys/vxworks/backtrace/mod.rs", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Fmod.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,110 @@\n+/// Backtrace support built on libgcc with some extra OS-specific support\n+///\n+/// Some methods of getting a backtrace:\n+///\n+/// * The backtrace() functions on unix. It turns out this doesn't work very\n+///   well for green threads on macOS, and the address to symbol portion of it\n+///   suffers problems that are described below.\n+///\n+/// * Using libunwind. This is more difficult than it sounds because libunwind\n+///   isn't installed everywhere by default. It's also a bit of a hefty library,\n+///   so possibly not the best option. When testing, libunwind was excellent at\n+///   getting both accurate backtraces and accurate symbols across platforms.\n+///   This route was not chosen in favor of the next option, however.\n+///\n+/// * We're already using libgcc_s for exceptions in rust (triggering thread\n+///   unwinding and running destructors on the stack), and it turns out that it\n+///   conveniently comes with a function that also gives us a backtrace. All of\n+///   these functions look like _Unwind_*, but it's not quite the full\n+///   repertoire of the libunwind API. Due to it already being in use, this was\n+///   the chosen route of getting a backtrace.\n+///\n+/// After choosing libgcc_s for backtraces, the sad part is that it will only\n+/// give us a stack trace of instruction pointers. Thankfully these instruction\n+/// pointers are accurate (they work for green and native threads), but it's\n+/// then up to us again to figure out how to translate these addresses to\n+/// symbols. As with before, we have a few options. Before, that, a little bit\n+/// of an interlude about symbols. This is my very limited knowledge about\n+/// symbol tables, and this information is likely slightly wrong, but the\n+/// general idea should be correct.\n+///\n+/// When talking about symbols, it's helpful to know a few things about where\n+/// symbols are located. Some symbols are located in the dynamic symbol table\n+/// of the executable which in theory means that they're available for dynamic\n+/// linking and lookup. Other symbols end up only in the local symbol table of\n+/// the file. This loosely corresponds to pub and priv functions in Rust.\n+///\n+/// Armed with this knowledge, we know that our solution for address to symbol\n+/// translation will need to consult both the local and dynamic symbol tables.\n+/// With that in mind, here's our options of translating an address to\n+/// a symbol.\n+///\n+/// * Use dladdr(). The original backtrace()-based idea actually uses dladdr()\n+///   behind the scenes to translate, and this is why backtrace() was not used.\n+///   Conveniently, this method works fantastically on macOS. It appears dladdr()\n+///   uses magic to consult the local symbol table, or we're putting everything\n+///   in the dynamic symbol table anyway. Regardless, for macOS, this is the\n+///   method used for translation. It's provided by the system and easy to do.o\n+///\n+///   Sadly, all other systems have a dladdr() implementation that does not\n+///   consult the local symbol table. This means that most functions are blank\n+///   because they don't have symbols. This means that we need another solution.\n+///\n+/// * Use unw_get_proc_name(). This is part of the libunwind api (not the\n+///   libgcc_s version of the libunwind api), but involves taking a dependency\n+///   to libunwind. We may pursue this route in the future if we bundle\n+///   libunwind, but libunwind was unwieldy enough that it was not chosen at\n+///   this time to provide this functionality.\n+///\n+/// * Shell out to a utility like `readelf`. Crazy though it may sound, it's a\n+///   semi-reasonable solution. The stdlib already knows how to spawn processes,\n+///   so in theory it could invoke readelf, parse the output, and consult the\n+///   local/dynamic symbol tables from there. This ended up not getting chosen\n+///   due to the craziness of the idea plus the advent of the next option.\n+///\n+/// * Use `libbacktrace`. It turns out that this is a small library bundled in\n+///   the gcc repository which provides backtrace and symbol translation\n+///   functionality. All we really need from it is the backtrace functionality,\n+///   and we only really need this on everything that's not macOS, so this is the\n+///   chosen route for now.\n+///\n+/// In summary, the current situation uses libgcc_s to get a trace of stack\n+/// pointers, and we use dladdr() or libbacktrace to translate these addresses\n+/// to symbols. This is a bit of a hokey implementation as-is, but it works for\n+/// all unix platforms we support right now, so it at least gets the job done.\n+\n+pub use self::tracing::unwind_backtrace;\n+pub use self::printing::{foreach_symbol_fileline, resolve_symname};\n+\n+// tracing impls:\n+mod tracing;\n+// symbol resolvers:\n+mod printing;\n+\n+#[cfg(not(target_os = \"emscripten\"))]\n+pub mod gnu {\n+    use crate::io;\n+    use crate::fs;\n+\n+    use libc::c_char;\n+\n+    #[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n+    pub fn get_executable_filename() -> io::Result<(Vec<c_char>, fs::File)> {\n+        Err(io::Error::new(io::ErrorKind::Other, \"Not implemented\"))\n+    }\n+\n+    #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+    pub fn get_executable_filename() -> io::Result<(Vec<c_char>, fs::File)> {\n+        use crate::env;\n+        use crate::os::unix::ffi::OsStrExt;\n+\n+        let filename = env::current_exe()?;\n+        let file = fs::File::open(&filename)?;\n+        let mut filename_cstr: Vec<_> = filename.as_os_str().as_bytes().iter()\n+            .map(|&x| x as c_char).collect();\n+        filename_cstr.push(0); // Null terminate\n+        Ok((filename_cstr, file))\n+    }\n+}\n+\n+pub struct BacktraceContext;"}, {"sha": "202164dd3c4d7655c0239ffee22891984b4cd18d", "filename": "src/libstd/sys/vxworks/backtrace/printing/dladdr.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Fprinting%2Fdladdr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Fprinting%2Fdladdr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Fprinting%2Fdladdr.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,35 @@\n+use crate::io;\n+use crate::intrinsics;\n+use crate::ffi::CStr;\n+use crate::sys::backtrace::BacktraceContext;\n+use crate::sys_common::backtrace::Frame;\n+\n+pub fn resolve_symname<F>(frame: Frame,\n+                          callback: F,\n+                          _: &BacktraceContext) -> io::Result<()>\n+    where F: FnOnce(Option<&str>) -> io::Result<()>\n+{\n+    unsafe {\n+        let mut info: Dl_info = intrinsics::init();\n+        let symname = if dladdr(frame.exact_position as *mut _, &mut info) == 0 ||\n+                         info.dli_sname.is_null() {\n+            None\n+        } else {\n+            CStr::from_ptr(info.dli_sname).to_str().ok()\n+        };\n+        callback(symname)\n+    }\n+}\n+\n+#[repr(C)]\n+struct Dl_info {\n+    dli_fname: *const libc::c_char,\n+    dli_fbase: *mut libc::c_void,\n+    dli_sname: *const libc::c_char,\n+    dli_saddr: *mut libc::c_void,\n+}\n+\n+extern {\n+    #[ link_name = \"_rtld_dladdr\" ]\n+    fn dladdr(addr: *const libc::c_void, info: *mut Dl_info) -> libc::c_int;\n+}"}, {"sha": "d090caede437abc25749831a46fe2d99896a7300", "filename": "src/libstd/sys/vxworks/backtrace/printing/mod.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Fprinting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Fprinting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Fprinting%2Fmod.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,33 @@\n+mod dladdr;\n+\n+use crate::sys::backtrace::BacktraceContext;\n+use crate::sys_common::backtrace::Frame;\n+use crate::io;\n+\n+#[cfg(target_os = \"emscripten\")]\n+pub use self::dladdr::resolve_symname;\n+\n+#[cfg(target_os = \"emscripten\")]\n+pub fn foreach_symbol_fileline<F>(_: Frame, _: F, _: &BacktraceContext) -> io::Result<bool>\n+where\n+    F: FnMut(&[u8], u32) -> io::Result<()>\n+{\n+    Ok(false)\n+}\n+\n+#[cfg(not(target_os = \"emscripten\"))]\n+pub use crate::sys_common::gnu::libbacktrace::foreach_symbol_fileline;\n+\n+#[cfg(not(target_os = \"emscripten\"))]\n+pub fn resolve_symname<F>(frame: Frame, callback: F, bc: &BacktraceContext) -> io::Result<()>\n+where\n+    F: FnOnce(Option<&str>) -> io::Result<()>\n+{\n+    crate::sys_common::gnu::libbacktrace::resolve_symname(frame, |symname| {\n+        if symname.is_some() {\n+            callback(symname)\n+        } else {\n+            dladdr::resolve_symname(frame, callback, bc)\n+        }\n+    }, bc)\n+}"}, {"sha": "a628d107ad6fbd94f523f7c49a951cdea4c941c6", "filename": "src/libstd/sys/vxworks/backtrace/tracing/backtrace_fn.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Ftracing%2Fbacktrace_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Ftracing%2Fbacktrace_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Ftracing%2Fbacktrace_fn.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,39 @@\n+/// As always - iOS on arm uses SjLj exceptions and\n+/// _Unwind_Backtrace is even not available there. Still,\n+/// backtraces could be extracted using a backtrace function,\n+/// which thanks god is public\n+///\n+/// As mentioned in a huge comment block in `super::super`, backtrace\n+/// doesn't play well with green threads, so while it is extremely nice and\n+/// simple to use it should be used only on iOS devices as the only viable\n+/// option.\n+\n+use crate::io;\n+use crate::ptr;\n+use crate::sys::backtrace::BacktraceContext;\n+use crate::sys_common::backtrace::Frame;\n+\n+#[inline(never)] // if we know this is a function call, we can skip it when\n+                 // tracing\n+pub fn unwind_backtrace(frames: &mut [Frame])\n+    -> io::Result<(usize, BacktraceContext)>\n+{\n+    const FRAME_LEN: usize = 100;\n+    assert!(FRAME_LEN >= frames.len());\n+    let mut raw_frames = [ptr::null_mut(); FRAME_LEN];\n+    let nb_frames = unsafe {\n+        backtrace(raw_frames.as_mut_ptr(), raw_frames.len() as libc::c_int)\n+    } as usize;\n+    for (from, to) in raw_frames.iter().zip(frames.iter_mut()).take(nb_frames) {\n+        *to = Frame {\n+            exact_position: *from as *mut u8,\n+            symbol_addr: *from as *mut u8,\n+            inline_context: 0,\n+        };\n+    }\n+    Ok((nb_frames as usize, BacktraceContext))\n+}\n+\n+extern {\n+    fn backtrace(buf: *mut *mut libc::c_void, sz: libc::c_int) -> libc::c_int;\n+}"}, {"sha": "e6379132bafbe35552adac17dd543aaef39accf4", "filename": "src/libstd/sys/vxworks/backtrace/tracing/gcc_s.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Ftracing%2Fgcc_s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Ftracing%2Fgcc_s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Ftracing%2Fgcc_s.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,99 @@\n+use crate::error::Error;\n+use crate::fmt;\n+use crate::io;\n+use crate::sys::backtrace::BacktraceContext;\n+use crate::sys_common::backtrace::Frame;\n+\n+use unwind as uw;\n+\n+struct Context<'a> {\n+    idx: usize,\n+    frames: &'a mut [Frame],\n+}\n+\n+#[derive(Debug)]\n+struct UnwindError(uw::_Unwind_Reason_Code);\n+\n+impl Error for UnwindError {\n+    fn description(&self) -> &'static str {\n+        \"unexpected return value while unwinding\"\n+    }\n+}\n+\n+impl fmt::Display for UnwindError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}: {:?}\", self.description(), self.0)\n+    }\n+}\n+\n+#[inline(never)] // if we know this is a function call, we can skip it when\n+                 // tracing\n+pub fn unwind_backtrace(frames: &mut [Frame])\n+    -> io::Result<(usize, BacktraceContext)>\n+{\n+    let mut cx = Context {\n+        idx: 0,\n+        frames,\n+    };\n+    let result_unwind = unsafe {\n+        uw::_Unwind_Backtrace(trace_fn,\n+                              &mut cx as *mut Context<'_>\n+                              as *mut libc::c_void)\n+    };\n+    // See libunwind:src/unwind/Backtrace.c for the return values.\n+    // No, there is no doc.\n+    match result_unwind {\n+        // These return codes seem to be benign and need to be ignored for backtraces\n+        // to show up properly on all tested platforms.\n+        uw::_URC_END_OF_STACK | uw::_URC_FATAL_PHASE1_ERROR | uw::_URC_FAILURE => {\n+            Ok((cx.idx, BacktraceContext))\n+        }\n+        _ => {\n+            Err(io::Error::new(io::ErrorKind::Other,\n+                               UnwindError(result_unwind)))\n+        }\n+    }\n+}\n+\n+extern fn trace_fn(ctx: *mut uw::_Unwind_Context,\n+                   arg: *mut libc::c_void) -> uw::_Unwind_Reason_Code {\n+    let cx = unsafe { &mut *(arg as *mut Context<'_>) };\n+    if cx.idx >= cx.frames.len() {\n+        return uw::_URC_NORMAL_STOP;\n+    }\n+\n+    let mut ip_before_insn = 0;\n+    let mut ip = unsafe {\n+        uw::_Unwind_GetIPInfo(ctx, &mut ip_before_insn) as *mut libc::c_void\n+    };\n+    if !ip.is_null() && ip_before_insn == 0 {\n+        // this is a non-signaling frame, so `ip` refers to the address\n+        // after the calling instruction. account for that.\n+        ip = (ip as usize - 1) as *mut _;\n+    }\n+\n+    // dladdr() on osx gets whiny when we use FindEnclosingFunction, and\n+    // it appears to work fine without it, so we only use\n+    // FindEnclosingFunction on non-osx platforms. In doing so, we get a\n+    // slightly more accurate stack trace in the process.\n+    //\n+    // This is often because panic involves the last instruction of a\n+    // function being \"call std::rt::begin_unwind\", with no ret\n+    // instructions after it. This means that the return instruction\n+    // pointer points *outside* of the calling function, and by\n+    // unwinding it we go back to the original function.\n+    let symaddr = if cfg!(target_os = \"macos\") || cfg!(target_os = \"ios\") {\n+        ip\n+    } else {\n+        unsafe { uw::_Unwind_FindEnclosingFunction(ip) }\n+    };\n+\n+    cx.frames[cx.idx] = Frame {\n+        symbol_addr: symaddr as *mut u8,\n+        exact_position: ip as *mut u8,\n+        inline_context: 0,\n+    };\n+    cx.idx += 1;\n+\n+    uw::_URC_NO_REASON\n+}"}, {"sha": "11863e6454525b2c955b2103ac33dca3799a92ea", "filename": "src/libstd/sys/vxworks/backtrace/tracing/mod.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Ftracing%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Ftracing%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fbacktrace%2Ftracing%2Fmod.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,8 @@\n+pub use self::imp::*;\n+\n+#[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))]\n+#[path = \"gcc_s.rs\"]\n+mod imp;\n+#[cfg(all(target_os = \"ios\", target_arch = \"arm\"))]\n+#[path = \"backtrace_fn.rs\"]\n+mod imp;"}, {"sha": "f6bb58934fc050727800194bb82f89cf1020433d", "filename": "src/libstd/sys/vxworks/cmath.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fcmath.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,33 @@\n+#![cfg(not(test))]\n+\n+use libc::{c_float, c_double};\n+\n+#[link_name = \"m\"]\n+extern {\n+    pub fn acos(n: c_double) -> c_double;\n+    pub fn acosf(n: c_float) -> c_float;\n+    pub fn asin(n: c_double) -> c_double;\n+    pub fn asinf(n: c_float) -> c_float;\n+    pub fn atan(n: c_double) -> c_double;\n+    pub fn atan2(a: c_double, b: c_double) -> c_double;\n+    pub fn atan2f(a: c_float, b: c_float) -> c_float;\n+    pub fn atanf(n: c_float) -> c_float;\n+    pub fn cbrt(n: c_double) -> c_double;\n+    pub fn cbrtf(n: c_float) -> c_float;\n+    pub fn cosh(n: c_double) -> c_double;\n+    pub fn coshf(n: c_float) -> c_float;\n+    pub fn expm1(n: c_double) -> c_double;\n+    pub fn expm1f(n: c_float) -> c_float;\n+    pub fn fdim(a: c_double, b: c_double) -> c_double;\n+    pub fn fdimf(a: c_float, b: c_float) -> c_float;\n+    pub fn hypot(x: c_double, y: c_double) -> c_double;\n+    pub fn hypotf(x: c_float, y: c_float) -> c_float;\n+    pub fn log1p(n: c_double) -> c_double;\n+    pub fn log1pf(n: c_float) -> c_float;\n+    pub fn sinh(n: c_double) -> c_double;\n+    pub fn sinhf(n: c_float) -> c_float;\n+    pub fn tan(n: c_double) -> c_double;\n+    pub fn tanf(n: c_float) -> c_float;\n+    pub fn tanh(n: c_double) -> c_double;\n+    pub fn tanhf(n: c_float) -> c_float;\n+}"}, {"sha": "4d221264f232f8cf921f36f65c978d374d47aa13", "filename": "src/libstd/sys/vxworks/condvar.rs", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fcondvar.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,169 @@\n+use crate::cell::UnsafeCell;\n+use crate::sys::mutex::{self, Mutex};\n+use crate::time::Duration;\n+\n+pub struct Condvar { inner: UnsafeCell<libc::pthread_cond_t> }\n+\n+unsafe impl Send for Condvar {}\n+unsafe impl Sync for Condvar {}\n+\n+const TIMESPEC_MAX: libc::timespec = libc::timespec {\n+    tv_sec: <libc::time_t>::max_value(),\n+    tv_nsec: 1_000_000_000 - 1,\n+};\n+\n+fn saturating_cast_to_time_t(value: u64) -> libc::time_t {\n+    if value > <libc::time_t>::max_value() as u64 {\n+        <libc::time_t>::max_value()\n+    } else {\n+        value as libc::time_t\n+    }\n+}\n+\n+impl Condvar {\n+    pub const fn new() -> Condvar {\n+        // Might be moved and address is changing it is better to avoid\n+        // initialization of potentially opaque OS data before it landed\n+        Condvar { inner: UnsafeCell::new(libc::PTHREAD_COND_INITIALIZER) }\n+    }\n+\n+    pub unsafe fn init(&mut self) {\n+        use crate::mem::MaybeUninit;\n+        let mut attr = MaybeUninit::<libc::pthread_condattr_t>::uninit();\n+        let r = libc::pthread_condattr_init(attr.as_mut_ptr());\n+        assert_eq!(r, 0);\n+        let r = libc::pthread_condattr_setclock(attr.as_mut_ptr(), libc::CLOCK_MONOTONIC);\n+        assert_eq!(r, 0);\n+        let r = libc::pthread_cond_init(self.inner.get(), attr.as_ptr());\n+        assert_eq!(r, 0);\n+        let r = libc::pthread_condattr_destroy(attr.as_mut_ptr());\n+        assert_eq!(r, 0);\n+    }\n+\n+    #[inline]\n+    pub unsafe fn notify_one(&self) {\n+        let r = libc::pthread_cond_signal(self.inner.get());\n+        debug_assert_eq!(r, 0);\n+    }\n+\n+    #[inline]\n+    pub unsafe fn notify_all(&self) {\n+        let r = libc::pthread_cond_broadcast(self.inner.get());\n+        debug_assert_eq!(r, 0);\n+    }\n+\n+    #[inline]\n+    pub unsafe fn wait(&self, mutex: &Mutex) {\n+        let r = libc::pthread_cond_wait(self.inner.get(), mutex::raw(mutex));\n+        debug_assert_eq!(r, 0);\n+    }\n+\n+    // This implementation is used on systems that support pthread_condattr_setclock\n+    // where we configure condition variable to use monotonic clock (instead of\n+    // default system clock). This approach avoids all problems that result\n+    // from changes made to the system time.\n+    #[cfg(not(any(target_os = \"macos\",\n+                  target_os = \"ios\",\n+                  target_os = \"android\",\n+                  target_os = \"hermit\")))]\n+    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n+        use crate::mem;\n+\n+        let mut now: libc::timespec = mem::zeroed();\n+        let r = libc::clock_gettime(libc::CLOCK_MONOTONIC, &mut now);\n+        assert_eq!(r, 0);\n+\n+        // Nanosecond calculations can't overflow because both values are below 1e9.\n+        let nsec = dur.subsec_nanos() + now.tv_nsec as u32;\n+\n+        let sec = saturating_cast_to_time_t(dur.as_secs())\n+            .checked_add((nsec / 1_000_000_000) as libc::time_t)\n+            .and_then(|s| s.checked_add(now.tv_sec));\n+        let nsec = nsec % 1_000_000_000;\n+\n+        let timeout = sec.map(|s| {\n+            libc::timespec { tv_sec: s, tv_nsec: nsec as _}\n+        }).unwrap_or(TIMESPEC_MAX);\n+\n+        let r = libc::pthread_cond_timedwait(self.inner.get(), mutex::raw(mutex),\n+                                            &timeout);\n+        assert!(r == libc::ETIMEDOUT || r == 0);\n+        r == 0\n+    }\n+\n+\n+    // This implementation is modeled after libcxx's condition_variable\n+    // https://github.com/llvm-mirror/libcxx/blob/release_35/src/condition_variable.cpp#L46\n+    // https://github.com/llvm-mirror/libcxx/blob/release_35/include/__mutex_base#L367\n+    #[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"android\", target_os = \"hermit\"))]\n+    pub unsafe fn wait_timeout(&self, mutex: &Mutex, mut dur: Duration) -> bool {\n+        use crate::ptr;\n+        use crate::time::Instant;\n+\n+        // 1000 years\n+        let max_dur = Duration::from_secs(1000 * 365 * 86400);\n+\n+        if dur > max_dur {\n+            // OSX implementation of `pthread_cond_timedwait` is buggy\n+            // with super long durations. When duration is greater than\n+            // 0x100_0000_0000_0000 seconds, `pthread_cond_timedwait`\n+            // in macOS Sierra return error 316.\n+            //\n+            // This program demonstrates the issue:\n+            // https://gist.github.com/stepancheg/198db4623a20aad2ad7cddb8fda4a63c\n+            //\n+            // To work around this issue, and possible bugs of other OSes, timeout\n+            // is clamped to 1000 years, which is allowable per the API of `wait_timeout`\n+            // because of spurious wakeups.\n+\n+            dur = max_dur;\n+        }\n+\n+        // First, figure out what time it currently is, in both system and\n+        // stable time.  pthread_cond_timedwait uses system time, but we want to\n+        // report timeout based on stable time.\n+        let mut sys_now = libc::timeval { tv_sec: 0, tv_usec: 0 };\n+        let stable_now = Instant::now();\n+        let r = libc::gettimeofday(&mut sys_now, ptr::null_mut());\n+        debug_assert_eq!(r, 0);\n+\n+        let nsec = dur.subsec_nanos() as libc::c_long +\n+                   (sys_now.tv_usec * 1000) as libc::c_long;\n+        let extra = (nsec / 1_000_000_000) as libc::time_t;\n+        let nsec = nsec % 1_000_000_000;\n+        let seconds = saturating_cast_to_time_t(dur.as_secs());\n+\n+        let timeout = sys_now.tv_sec.checked_add(extra).and_then(|s| {\n+            s.checked_add(seconds)\n+        }).map(|s| {\n+            libc::timespec { tv_sec: s, tv_nsec: nsec }\n+        }).unwrap_or(TIMESPEC_MAX);\n+\n+        // And wait!\n+        let r = libc::pthread_cond_timedwait(self.inner.get(), mutex::raw(mutex),\n+                                            &timeout);\n+        debug_assert!(r == libc::ETIMEDOUT || r == 0);\n+\n+        // ETIMEDOUT is not a totally reliable method of determining timeout due\n+        // to clock shifts, so do the check ourselves\n+        stable_now.elapsed() < dur\n+    }\n+\n+    #[inline]\n+    #[cfg(not(target_os = \"dragonfly\"))]\n+    pub unsafe fn destroy(&self) {\n+        let r = libc::pthread_cond_destroy(self.inner.get());\n+        debug_assert_eq!(r, 0);\n+    }\n+\n+    #[inline]\n+    #[cfg(target_os = \"dragonfly\")]\n+    pub unsafe fn destroy(&self) {\n+        let r = libc::pthread_cond_destroy(self.inner.get());\n+        // On DragonFly pthread_cond_destroy() returns EINVAL if called on\n+        // a condvar that was just initialized with\n+        // libc::PTHREAD_COND_INITIALIZER. Once it is used or\n+        // pthread_cond_init() is called, this behaviour no longer occurs.\n+        debug_assert!(r == 0 || r == libc::EINVAL);\n+    }\n+}"}, {"sha": "fe1aedd58590bb4acdff4456213b9855d7c8cfc1", "filename": "src/libstd/sys/vxworks/env.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fenv.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,9 @@\n+pub mod os {\n+    pub const FAMILY: &str = \"vxworks\";\n+    pub const OS: &str = \"vxworks\";\n+    pub const DLL_PREFIX: &str = \"lib\";\n+    pub const DLL_SUFFIX: &str = \".so\";\n+    pub const DLL_EXTENSION: &str = \"so\";\n+    pub const EXE_SUFFIX: &str = \"\";\n+    pub const EXE_EXTENSION: &str = \"\";\n+}"}, {"sha": "76b34a6b5d84aa64a0a9a429e56218fc59931752", "filename": "src/libstd/sys/vxworks/ext/ffi.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fffi.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,38 @@\n+//! Unix-specific extension to the primitives in the `std::ffi` module\n+//!\n+//! # Examples\n+//!\n+//! ```\n+//! use std::ffi::OsString;\n+//! use std::os::unix::ffi::OsStringExt;\n+//!\n+//! let bytes = b\"foo\".to_vec();\n+//!\n+//! // OsStringExt::from_vec\n+//! let os_string = OsString::from_vec(bytes);\n+//! assert_eq!(os_string.to_str(), Some(\"foo\"));\n+//!\n+//! // OsStringExt::into_vec\n+//! let bytes = os_string.into_vec();\n+//! assert_eq!(bytes, b\"foo\");\n+//! ```\n+//!\n+//! ```\n+//! use std::ffi::OsStr;\n+//! use std::os::unix::ffi::OsStrExt;\n+//!\n+//! let bytes = b\"foo\";\n+//!\n+//! // OsStrExt::from_bytes\n+//! let os_str = OsStr::from_bytes(bytes);\n+//! assert_eq!(os_str.to_str(), Some(\"foo\"));\n+//!\n+//! // OsStrExt::as_bytes\n+//! let bytes = os_str.as_bytes();\n+//! assert_eq!(bytes, b\"foo\");\n+//! ```\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use crate::sys_common::os_str_bytes::*;"}, {"sha": "7ab7f2a1a26459a27ff928c4f65268dbe0ce1592", "filename": "src/libstd/sys/vxworks/ext/fs.rs", "status": "added", "additions": 801, "deletions": 0, "changes": 801, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Ffs.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,801 @@\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+use crate::fs::{self, Permissions};\n+use crate::io;\n+use libc;\n+use crate::path::Path;\n+use crate::sys;\n+use crate::sys_common::{FromInner, AsInner, AsInnerMut};\n+use crate::sys::platform::fs::MetadataExt as UnixMetadataExt;\n+\n+/// Unix-specific extensions to [`File`].\n+///\n+/// [`File`]: ../../../../std/fs/struct.File.html\n+#[stable(feature = \"file_offset\", since = \"1.15.0\")]\n+pub trait FileExt {\n+    /// Reads a number of bytes starting from a given offset.\n+    ///\n+    /// Returns the number of bytes read.\n+    ///\n+    /// The offset is relative to the start of the file and thus independent\n+    /// from the current cursor.\n+    ///\n+    /// The current file cursor is not affected by this function.\n+    ///\n+    /// Note that similar to [`File::read`], it is not an error to return with a\n+    /// short read.\n+    ///\n+    /// [`File::read`]: ../../../../std/fs/struct.File.html#method.read\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::fs::File;\n+    /// use std::os::unix::prelude::FileExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let mut buf = [0u8; 8];\n+    ///     let file = File::open(\"foo.txt\")?;\n+    ///\n+    ///     // We now read 8 bytes from the offset 10.\n+    ///     let num_bytes_read = file.read_at(&mut buf, 10)?;\n+    ///     println!(\"read {} bytes: {:?}\", num_bytes_read, buf);\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"file_offset\", since = \"1.15.0\")]\n+    fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize>;\n+\n+    /// Reads the exact number of byte required to fill `buf` from the given offset.\n+    ///\n+    /// The offset is relative to the start of the file and thus independent\n+    /// from the current cursor.\n+    ///\n+    /// The current file cursor is not affected by this function.\n+    ///\n+    /// Similar to [`Read::read_exact`] but uses [`read_at`] instead of `read`.\n+    ///\n+    /// [`Read::read_exact`]: ../../../../std/io/trait.Read.html#method.read_exact\n+    /// [`read_at`]: #tymethod.read_at\n+    ///\n+    /// # Errors\n+    ///\n+    /// If this function encounters an error of the kind\n+    /// [`ErrorKind::Interrupted`] then the error is ignored and the operation\n+    /// will continue.\n+    ///\n+    /// If this function encounters an \"end of file\" before completely filling\n+    /// the buffer, it returns an error of the kind [`ErrorKind::UnexpectedEof`].\n+    /// The contents of `buf` are unspecified in this case.\n+    ///\n+    /// If any other read error is encountered then this function immediately\n+    /// returns. The contents of `buf` are unspecified in this case.\n+    ///\n+    /// If this function returns an error, it is unspecified how many bytes it\n+    /// has read, but it will never read more than would be necessary to\n+    /// completely fill the buffer.\n+    ///\n+    /// [`ErrorKind::Interrupted`]: ../../../../std/io/enum.ErrorKind.html#variant.Interrupted\n+    /// [`ErrorKind::UnexpectedEof`]: ../../../../std/io/enum.ErrorKind.html#variant.UnexpectedEof\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(rw_exact_all_at)]\n+    /// use std::io;\n+    /// use std::fs::File;\n+    /// use std::os::unix::prelude::FileExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let mut buf = [0u8; 8];\n+    ///     let file = File::open(\"foo.txt\")?;\n+    ///\n+    ///     // We now read exactly 8 bytes from the offset 10.\n+    ///     file.read_exact_at(&mut buf, 10)?;\n+    ///     println!(\"read {} bytes: {:?}\", buf.len(), buf);\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rw_exact_all_at\", since = \"1.33.0\")]\n+    fn read_exact_at(&self, mut buf: &mut [u8], mut offset: u64) -> io::Result<()> {\n+        while !buf.is_empty() {\n+            match self.read_at(buf, offset) {\n+                Ok(0) => break,\n+                Ok(n) => {\n+                    let tmp = buf;\n+                    buf = &mut tmp[n..];\n+                    offset += n as u64;\n+                }\n+                Err(ref e) if e.kind() == io::ErrorKind::Interrupted => {}\n+                Err(e) => return Err(e),\n+            }\n+        }\n+        if !buf.is_empty() {\n+            Err(io::Error::new(io::ErrorKind::UnexpectedEof,\n+                               \"failed to fill whole buffer\"))\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n+    /// Writes a number of bytes starting from a given offset.\n+    ///\n+    /// Returns the number of bytes written.\n+    ///\n+    /// The offset is relative to the start of the file and thus independent\n+    /// from the current cursor.\n+    ///\n+    /// The current file cursor is not affected by this function.\n+    ///\n+    /// When writing beyond the end of the file, the file is appropriately\n+    /// extended and the intermediate bytes are initialized with the value 0.\n+    ///\n+    /// Note that similar to [`File::write`], it is not an error to return a\n+    /// short write.\n+    ///\n+    /// [`File::write`]: ../../../../std/fs/struct.File.html#write.v\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs::File;\n+    /// use std::io;\n+    /// use std::os::unix::prelude::FileExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let file = File::open(\"foo.txt\")?;\n+    ///\n+    ///     // We now write at the offset 10.\n+    ///     file.write_at(b\"sushi\", 10)?;\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"file_offset\", since = \"1.15.0\")]\n+    fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize>;\n+\n+    /// Attempts to write an entire buffer starting from a given offset.\n+    ///\n+    /// The offset is relative to the start of the file and thus independent\n+    /// from the current cursor.\n+    ///\n+    /// The current file cursor is not affected by this function.\n+    ///\n+    /// This method will continuously call [`write_at`] until there is no more data\n+    /// to be written or an error of non-[`ErrorKind::Interrupted`] kind is\n+    /// returned. This method will not return until the entire buffer has been\n+    /// successfully written or such an error occurs. The first error that is\n+    /// not of [`ErrorKind::Interrupted`] kind generated from this method will be\n+    /// returned.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function will return the first error of\n+    /// non-[`ErrorKind::Interrupted`] kind that [`write_at`] returns.\n+    ///\n+    /// [`ErrorKind::Interrupted`]: ../../../../std/io/enum.ErrorKind.html#variant.Interrupted\n+    /// [`write_at`]: #tymethod.write_at\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(rw_exact_all_at)]\n+    /// use std::fs::File;\n+    /// use std::io;\n+    /// use std::os::unix::prelude::FileExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let file = File::open(\"foo.txt\")?;\n+    ///\n+    ///     // We now write at the offset 10.\n+    ///     file.write_all_at(b\"sushi\", 10)?;\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rw_exact_all_at\", since = \"1.33.0\")]\n+    fn write_all_at(&self, mut buf: &[u8], mut offset: u64) -> io::Result<()> {\n+        while !buf.is_empty() {\n+            match self.write_at(buf, offset) {\n+                Ok(0) => return Err(io::Error::new(io::ErrorKind::WriteZero,\n+                                                   \"failed to write whole buffer\")),\n+                Ok(n) => {\n+                    buf = &buf[n..];\n+                    offset += n as u64\n+                }\n+                Err(ref e) if e.kind() == io::ErrorKind::Interrupted => {}\n+                Err(e) => return Err(e),\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+#[stable(feature = \"file_offset\", since = \"1.15.0\")]\n+impl FileExt for fs::File {\n+    fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {\n+        self.as_inner().read_at(buf, offset)\n+    }\n+    fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {\n+        self.as_inner().write_at(buf, offset)\n+    }\n+}\n+\n+/// Unix-specific extensions to [`fs::Permissions`].\n+///\n+/// [`fs::Permissions`]: ../../../../std/fs/struct.Permissions.html\n+#[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n+pub trait PermissionsExt {\n+    /// Returns the underlying raw `st_mode` bits that contain the standard\n+    /// Unix permissions for this file.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs::File;\n+    /// use std::os::unix::fs::PermissionsExt;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let f = File::create(\"foo.txt\")?;\n+    ///     let metadata = f.metadata()?;\n+    ///     let permissions = metadata.permissions();\n+    ///\n+    ///     println!(\"permissions: {}\", permissions.mode());\n+    ///     Ok(()) }\n+    /// ```\n+    #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n+    fn mode(&self) -> u32;\n+\n+    /// Sets the underlying raw bits for this set of permissions.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs::File;\n+    /// use std::os::unix::fs::PermissionsExt;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let f = File::create(\"foo.txt\")?;\n+    ///     let metadata = f.metadata()?;\n+    ///     let mut permissions = metadata.permissions();\n+    ///\n+    ///     permissions.set_mode(0o644); // Read/write for owner and read for others.\n+    ///     assert_eq!(permissions.mode(), 0o644);\n+    ///     Ok(()) }\n+    /// ```\n+    #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n+    fn set_mode(&mut self, mode: u32);\n+\n+    /// Creates a new instance of `Permissions` from the given set of Unix\n+    /// permission bits.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fs::Permissions;\n+    /// use std::os::unix::fs::PermissionsExt;\n+    ///\n+    /// // Read/write for owner and read for others.\n+    /// let permissions = Permissions::from_mode(0o644);\n+    /// assert_eq!(permissions.mode(), 0o644);\n+    /// ```\n+    #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n+    fn from_mode(mode: u32) -> Self;\n+}\n+\n+#[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n+impl PermissionsExt for Permissions {\n+    fn mode(&self) -> u32 {\n+        self.as_inner().mode()\n+    }\n+\n+    fn set_mode(&mut self, mode: u32) {\n+        *self = Permissions::from_inner(FromInner::from_inner(mode));\n+    }\n+\n+    fn from_mode(mode: u32) -> Permissions {\n+        Permissions::from_inner(FromInner::from_inner(mode))\n+    }\n+}\n+\n+/// Unix-specific extensions to [`fs::OpenOptions`].\n+///\n+/// [`fs::OpenOptions`]: ../../../../std/fs/struct.OpenOptions.html\n+#[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n+pub trait OpenOptionsExt {\n+    /// Sets the mode bits that a new file will be created with.\n+    ///\n+    /// If a new file is created as part of a `File::open_opts` call then this\n+    /// specified `mode` will be used as the permission bits for the new file.\n+    /// If no `mode` is set, the default of `0o666` will be used.\n+    /// The operating system masks out bits with the systems `umask`, to produce\n+    /// the final permissions.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs::OpenOptions;\n+    /// use std::os::unix::fs::OpenOptionsExt;\n+    ///\n+    /// # fn main() {\n+    /// let mut options = OpenOptions::new();\n+    /// options.mode(0o644); // Give read/write for owner and read for others.\n+    /// let file = options.open(\"foo.txt\");\n+    /// # }\n+    /// ```\n+    #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n+    fn mode(&mut self, mode: u32) -> &mut Self;\n+\n+    /// Pass custom flags to the `flags` argument of `open`.\n+    ///\n+    /// The bits that define the access mode are masked out with `O_ACCMODE`, to\n+    /// ensure they do not interfere with the access mode set by Rusts options.\n+    ///\n+    /// Custom flags can only set flags, not remove flags set by Rusts options.\n+    /// This options overwrites any previously set custom flags.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// # #![feature(libc)]\n+    /// extern crate libc;\n+    /// use std::fs::OpenOptions;\n+    /// use std::os::unix::fs::OpenOptionsExt;\n+    ///\n+    /// # fn main() {\n+    /// let mut options = OpenOptions::new();\n+    /// options.write(true);\n+    /// if cfg!(unix) {\n+    ///     options.custom_flags(libc::O_NOFOLLOW);\n+    /// }\n+    /// let file = options.open(\"foo.txt\");\n+    /// # }\n+    /// ```\n+    #[stable(feature = \"open_options_ext\", since = \"1.10.0\")]\n+    fn custom_flags(&mut self, flags: i32) -> &mut Self;\n+}\n+\n+/*#[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n+impl OpenOptionsExt for OpenOptions {\n+    fn mode(&mut self, mode: u32) -> &mut OpenOptions {\n+        self.as_inner_mut().mode(mode); self\n+    }\n+\n+    fn custom_flags(&mut self, flags: i32) -> &mut OpenOptions {\n+        self.as_inner_mut().custom_flags(flags); self\n+    }\n+}\n+*/\n+\n+/// Unix-specific extensions to [`fs::Metadata`].\n+///\n+/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n+#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+pub trait MetadataExt {\n+    /// Returns the ID of the device containing the file.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::fs;\n+    /// use std::os::unix::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     let dev_id = meta.dev();\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn dev(&self) -> u64;\n+    /// Returns the inode number.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::os::unix::fs::MetadataExt;\n+    /// use std::io;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     let inode = meta.ino();\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn ino(&self) -> u64;\n+    /// Returns the rights applied to this file.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::os::unix::fs::MetadataExt;\n+    /// use std::io;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     let mode = meta.mode();\n+    ///     let user_has_write_access      = mode & 0o200;\n+    ///     let user_has_read_write_access = mode & 0o600;\n+    ///     let group_has_read_access      = mode & 0o040;\n+    ///     let others_have_exec_access    = mode & 0o001;\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn mode(&self) -> u32;\n+    /// Returns the number of hard links pointing to this file.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::os::unix::fs::MetadataExt;\n+    ///  use std::io;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     let nb_hard_links = meta.nlink();\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn nlink(&self) -> u64;\n+    /// Returns the user ID of the owner of this file.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::os::unix::fs::MetadataExt;\n+    /// use std::io;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     let user_id = meta.uid();\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn uid(&self) -> u32;\n+    /// Returns the group ID of the owner of this file.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::os::unix::fs::MetadataExt;\n+    /// use std::io;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     let group_id = meta.gid();\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn gid(&self) -> u32;\n+    /// Returns the device ID of this file (if it is a special one).\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::os::unix::fs::MetadataExt;\n+    /// use std::io;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     let device_id = meta.rdev();\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn rdev(&self) -> u64;\n+    /// Returns the total size of this file in bytes.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::os::unix::fs::MetadataExt;\n+    /// use std::io;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     let file_size = meta.size();\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn size(&self) -> u64;\n+    /// Returns the time of the last access to the file.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::os::unix::fs::MetadataExt;\n+    /// use std::io;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     let last_access_time = meta.atime();\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn atime(&self) -> i64;\n+    /// Returns the time of the last access to the file in nanoseconds.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::os::unix::fs::MetadataExt;\n+    /// use std::io;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     let nano_last_access_time = meta.atime_nsec();\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn mtime(&self) -> i64;\n+    /// Returns the time of the last modification of the file in nanoseconds.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::os::unix::fs::MetadataExt;\n+    /// use std::io;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     let nano_last_modification_time = meta.mtime_nsec();\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn ctime(&self) -> i64;\n+    /// Returns the time of the last status change of the file in nanoseconds.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::os::unix::fs::MetadataExt;\n+    /// use std::io;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     let nano_last_status_change_time = meta.ctime_nsec();\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn blksize(&self) -> u64;\n+    /// Returns the number of blocks allocated to the file, in 512-byte units.\n+    ///\n+    /// Please note that this may be smaller than `st_size / 512` when the file has holes.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::os::unix::fs::MetadataExt;\n+    /// use std::io;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     let blocks = meta.blocks();\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn blocks(&self) -> u64;\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn attrib(&self) -> u8;\n+}\n+\n+#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+impl MetadataExt for fs::Metadata {\n+    fn dev(&self) -> u64 { self.st_dev() }\n+    fn ino(&self) -> u64 { self.st_ino() }\n+    fn mode(&self) -> u32 { self.st_mode() }\n+    fn nlink(&self) -> u64 { self.st_nlink() }\n+    fn uid(&self) -> u32 { self.st_uid() }\n+    fn gid(&self) -> u32 { self.st_gid() }\n+    fn rdev(&self) -> u64 { self.st_rdev() }\n+    fn size(&self) -> u64 { self.st_size() }\n+    fn atime(&self) -> i64 { self.st_atime() }\n+    fn mtime(&self) -> i64 { self.st_mtime() }\n+    fn ctime(&self) -> i64 { self.st_ctime() }\n+    fn blksize(&self) -> u64 { self.st_blksize() }\n+    fn blocks(&self) -> u64 { self.st_blocks() }\n+    fn attrib(&self) -> u8 {self.st_attrib() }\n+}\n+\n+/// Unix-specific extensions for [`FileType`].\n+///\n+/// Adds support for special Unix file types such as block/character devices,\n+/// pipes, and sockets.\n+///\n+/// [`FileType`]: ../../../../std/fs/struct.FileType.html\n+#[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n+pub trait FileTypeExt {\n+    /// Returns whether this file type is a block device.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::os::unix::fs::FileTypeExt;\n+    /// use std::io;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"block_device_file\")?;\n+    ///     let file_type = meta.file_type();\n+    ///     assert!(file_type.is_block_device());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n+    fn is_block_device(&self) -> bool;\n+    /// Returns whether this file type is a char device.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::os::unix::fs::FileTypeExt;\n+    /// use std::io;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"char_device_file\")?;\n+    ///     let file_type = meta.file_type();\n+    ///     assert!(file_type.is_char_device());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n+    fn is_char_device(&self) -> bool;\n+    /// Returns whether this file type is a fifo.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::os::unix::fs::FileTypeExt;\n+    /// use std::io;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"fifo_file\")?;\n+    ///     let file_type = meta.file_type();\n+    ///     assert!(file_type.is_fifo());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n+    fn is_fifo(&self) -> bool;\n+    /// Returns whether this file type is a socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::os::unix::fs::FileTypeExt;\n+    /// use std::io;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"unix.socket\")?;\n+    ///     let file_type = meta.file_type();\n+    ///     assert!(file_type.is_socket());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n+    fn is_socket(&self) -> bool;\n+}\n+\n+#[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n+impl FileTypeExt for fs::FileType {\n+    fn is_block_device(&self) -> bool { self.as_inner().is(libc::S_IFBLK) }\n+    fn is_char_device(&self) -> bool { self.as_inner().is(libc::S_IFCHR) }\n+    fn is_fifo(&self) -> bool { self.as_inner().is(libc::S_IFIFO) }\n+    fn is_socket(&self) -> bool { self.as_inner().is(libc::S_IFSOCK) }\n+}\n+\n+/// Unix-specific extension methods for [`fs::DirEntry`].\n+///\n+/// [`fs::DirEntry`]: ../../../../std/fs/struct.DirEntry.html\n+#[stable(feature = \"dir_entry_ext\", since = \"1.1.0\")]\n+pub trait DirEntryExt {\n+    /// Returns the underlying `d_ino` field in the contained `dirent`\n+    /// structure.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fs;\n+    /// use std::os::unix::fs::DirEntryExt;\n+    ///\n+    /// if let Ok(entries) = fs::read_dir(\".\") {\n+    ///     for entry in entries {\n+    ///         if let Ok(entry) = entry {\n+    ///             // Here, `entry` is a `DirEntry`.\n+    ///             println!(\"{:?}: {}\", entry.file_name(), entry.ino());\n+    ///         }\n+    ///     }\n+    /// }\n+    /// ```\n+    #[stable(feature = \"dir_entry_ext\", since = \"1.1.0\")]\n+    fn ino(&self) -> u64;\n+}\n+\n+#[stable(feature = \"dir_entry_ext\", since = \"1.1.0\")]\n+impl DirEntryExt for fs::DirEntry {\n+    fn ino(&self) -> u64 { self.as_inner().ino() }\n+}\n+\n+/// Creates a new symbolic link on the filesystem.\n+///\n+/// The `dst` path will be a symbolic link pointing to the `src` path.\n+///\n+/// # Note\n+///\n+/// On Windows, you must specify whether a symbolic link points to a file\n+/// or directory.  Use `os::windows::fs::symlink_file` to create a\n+/// symbolic link to a file, or `os::windows::fs::symlink_dir` to create a\n+/// symbolic link to a directory.  Additionally, the process must have\n+/// `SeCreateSymbolicLinkPrivilege` in order to be able to create a\n+/// symbolic link.\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// use std::os::unix::fs;\n+///\n+/// fn main() -> std::io::Result<()> {\n+///     fs::symlink(\"a.txt\", \"b.txt\")?;\n+///     Ok(())\n+/// }\n+/// ```\n+#[stable(feature = \"symlink\", since = \"1.1.0\")]\n+pub fn symlink<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()>\n+{\n+    sys::fs::symlink(src.as_ref(), dst.as_ref())\n+}\n+\n+/// Unix-specific extensions to [`fs::DirBuilder`].\n+///\n+/// [`fs::DirBuilder`]: ../../../../std/fs/struct.DirBuilder.html\n+#[stable(feature = \"dir_builder\", since = \"1.6.0\")]\n+pub trait DirBuilderExt {\n+    /// Sets the mode to create new directories with. This option defaults to\n+    /// 0o777.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs::DirBuilder;\n+    /// use std::os::unix::fs::DirBuilderExt;\n+    ///\n+    /// let mut builder = DirBuilder::new();\n+    /// builder.mode(0o755);\n+    /// ```\n+    #[stable(feature = \"dir_builder\", since = \"1.6.0\")]\n+    fn mode(&mut self, mode: u32) -> &mut Self;\n+}\n+\n+#[stable(feature = \"dir_builder\", since = \"1.6.0\")]\n+impl DirBuilderExt for fs::DirBuilder {\n+    fn mode(&mut self, mode: u32) -> &mut fs::DirBuilder {\n+        self.as_inner_mut().set_mode(mode);\n+        self\n+    }\n+}"}, {"sha": "6bcc59495e3635511bd7d63bbf807d8ec44e8a33", "filename": "src/libstd/sys/vxworks/ext/io.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fio.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,112 @@\n+//! Unix-specific extensions to general I/O primitives\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+use crate::fs;\n+use crate::os::raw;\n+use crate::sys;\n+use crate::io;\n+use crate::sys_common::{AsInner, FromInner, IntoInner};\n+\n+/// Raw file descriptors.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub type RawFd = raw::c_int;\n+\n+/// A trait to extract the raw unix file descriptor from an underlying\n+/// object.\n+///\n+/// This is only available on unix platforms and must be imported in order\n+/// to call the method. Windows platforms have a corresponding `AsRawHandle`\n+/// and `AsRawSocket` set of traits.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait AsRawFd {\n+    /// Extracts the raw file descriptor.\n+    ///\n+    /// This method does **not** pass ownership of the raw file descriptor\n+    /// to the caller. The descriptor is only guaranteed to be valid while\n+    /// the original object has not yet been destroyed.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn as_raw_fd(&self) -> RawFd;\n+}\n+\n+/// A trait to express the ability to construct an object from a raw file\n+/// descriptor.\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+pub trait FromRawFd {\n+    /// Constructs a new instance of `Self` from the given raw file\n+    /// descriptor.\n+    ///\n+    /// This function **consumes ownership** of the specified file\n+    /// descriptor. The returned object will take responsibility for closing\n+    /// it when the object goes out of scope.\n+    ///\n+    /// This function is also unsafe as the primitives currently returned\n+    /// have the contract that they are the sole owner of the file\n+    /// descriptor they are wrapping. Usage of this function could\n+    /// accidentally allow violating this contract which can cause memory\n+    /// unsafety in code that relies on it being true.\n+    #[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+    unsafe fn from_raw_fd(fd: RawFd) -> Self;\n+}\n+\n+/// A trait to express the ability to consume an object and acquire ownership of\n+/// its raw file descriptor.\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+pub trait IntoRawFd {\n+    /// Consumes this object, returning the raw underlying file descriptor.\n+    ///\n+    /// This function **transfers ownership** of the underlying file descriptor\n+    /// to the caller. Callers are then the unique owners of the file descriptor\n+    /// and must close the descriptor once it's no longer needed.\n+    #[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+    fn into_raw_fd(self) -> RawFd;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawFd for fs::File {\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.as_inner().fd().raw()\n+    }\n+}\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+impl FromRawFd for fs::File {\n+    unsafe fn from_raw_fd(fd: RawFd) -> fs::File {\n+        fs::File::from_inner(sys::fs::File::from_inner(fd))\n+    }\n+}\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl IntoRawFd for fs::File {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.into_inner().into_fd().into_raw()\n+    }\n+}\n+\n+#[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n+impl AsRawFd for io::Stdin {\n+    fn as_raw_fd(&self) -> RawFd { libc::STDIN_FILENO }\n+}\n+\n+#[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n+impl AsRawFd for io::Stdout {\n+    fn as_raw_fd(&self) -> RawFd { libc::STDOUT_FILENO }\n+}\n+\n+#[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n+impl AsRawFd for io::Stderr {\n+    fn as_raw_fd(&self) -> RawFd { libc::STDERR_FILENO }\n+}\n+\n+#[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n+impl<'a> AsRawFd for io::StdinLock<'a> {\n+    fn as_raw_fd(&self) -> RawFd { libc::STDIN_FILENO }\n+}\n+\n+#[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n+impl<'a> AsRawFd for io::StdoutLock<'a> {\n+    fn as_raw_fd(&self) -> RawFd { libc::STDOUT_FILENO }\n+}\n+\n+#[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n+impl<'a> AsRawFd for io::StderrLock<'a> {\n+    fn as_raw_fd(&self) -> RawFd { libc::STDERR_FILENO }\n+}"}, {"sha": "c2ebc38c30039583c6264ec4296a56e50c3b3056", "filename": "src/libstd/sys/vxworks/ext/mod.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fmod.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,20 @@\n+// Uhhh\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+#![allow(missing_docs)]\n+\n+pub mod io;\n+pub mod ffi;\n+pub mod fs;\n+pub mod raw;\n+pub mod process;\n+pub mod net;\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub mod prelude {\n+    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use super::io::{RawFd, AsRawFd, FromRawFd, IntoRawFd};\n+    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use super::ffi::{OsStrExt, OsStringExt};\n+    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use super::fs::{PermissionsExt, OpenOptionsExt, MetadataExt, FileTypeExt};\n+}"}, {"sha": "41090caee8459fea5e08e6ad9054379d9da08da3", "filename": "src/libstd/sys/vxworks/ext/net.rs", "status": "added", "additions": 1850, "deletions": 0, "changes": 1850, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fnet.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,1850 @@\n+#![stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+\n+//! Unix-specific networking functionality\n+\n+#[cfg(unix)]\n+use libc;\n+\n+// FIXME(#43348): Make libc adapt #[doc(cfg(...))] so we don't need these fake definitions here?\n+#[cfg(not(unix))]\n+mod libc {\n+    pub use libc::c_int;\n+    pub type socklen_t = u32;\n+    pub struct sockaddr;\n+    #[derive(Clone)]\n+    pub struct sockaddr_un;\n+}\n+\n+use crate::ascii;\n+use crate::ffi::OsStr;\n+use crate::fmt;\n+use crate::io::{self, Initializer, IoSlice, IoSliceMut};\n+use crate::mem;\n+use crate::net::{self, Shutdown};\n+use crate::os::unix::ffi::OsStrExt;\n+use crate::os::unix::io::{RawFd, AsRawFd, FromRawFd, IntoRawFd};\n+use crate::path::Path;\n+use crate::time::Duration;\n+use crate::sys::{self, cvt};\n+use crate::sys::net::Socket;\n+use crate::sys_common::{self, AsInner, FromInner, IntoInner};\n+\n+#[cfg(any(target_os = \"linux\", target_os = \"android\",\n+          target_os = \"dragonfly\", target_os = \"freebsd\",\n+          target_os = \"openbsd\", target_os = \"netbsd\",\n+          target_os = \"haiku\"))]\n+use libc::MSG_NOSIGNAL;\n+#[cfg(not(any(target_os = \"linux\", target_os = \"android\",\n+              target_os = \"dragonfly\", target_os = \"freebsd\",\n+              target_os = \"openbsd\", target_os = \"netbsd\",\n+              target_os = \"haiku\")))]\n+const MSG_NOSIGNAL: libc::c_int = 0x0;\n+\n+fn sun_path_offset(addr: &libc::sockaddr_un) -> usize {\n+    // Work with an actual instance of the type since using a null pointer is UB\n+    let base = addr as *const _ as usize;\n+    let path = &addr.sun_path as *const _ as usize;\n+    path - base\n+}\n+\n+unsafe fn sockaddr_un(path: &Path) -> io::Result<(libc::sockaddr_un, libc::socklen_t)> {\n+    let mut addr: libc::sockaddr_un = mem::zeroed();\n+    addr.sun_family = libc::AF_UNIX as libc::sa_family_t;\n+\n+    let bytes = path.as_os_str().as_bytes();\n+\n+    if bytes.contains(&0) {\n+        return Err(io::Error::new(io::ErrorKind::InvalidInput,\n+                                  \"paths may not contain interior null bytes\"));\n+    }\n+\n+    if bytes.len() >= addr.sun_path.len() {\n+        return Err(io::Error::new(io::ErrorKind::InvalidInput,\n+                                  \"path must be shorter than SUN_LEN\"));\n+    }\n+    for (dst, src) in addr.sun_path.iter_mut().zip(bytes.iter()) {\n+        *dst = *src as libc::c_char;\n+    }\n+    // null byte for pathname addresses is already there because we zeroed the\n+    // struct\n+\n+    let mut len = sun_path_offset(&addr) + bytes.len();\n+    match bytes.get(0) {\n+        Some(&0) | None => {}\n+        Some(_) => len += 1,\n+    }\n+    Ok((addr, len as libc::socklen_t))\n+}\n+\n+enum AddressKind<'a> {\n+    Unnamed,\n+    Pathname(&'a Path),\n+    Abstract(&'a [u8]),\n+}\n+\n+/// An address associated with a Unix socket.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::os::unix::net::UnixListener;\n+///\n+/// let socket = match UnixListener::bind(\"/tmp/sock\") {\n+///     Ok(sock) => sock,\n+///     Err(e) => {\n+///         println!(\"Couldn't bind: {:?}\", e);\n+///         return\n+///     }\n+/// };\n+/// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+/// ```\n+#[derive(Clone)]\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+pub struct SocketAddr {\n+    addr: libc::sockaddr_un,\n+    len: libc::socklen_t,\n+}\n+\n+impl SocketAddr {\n+    fn new<F>(f: F) -> io::Result<SocketAddr>\n+        where F: FnOnce(*mut libc::sockaddr, *mut libc::socklen_t) -> libc::c_int\n+    {\n+        unsafe {\n+            let mut addr: libc::sockaddr_un = mem::zeroed();\n+            let mut len = mem::size_of::<libc::sockaddr_un>() as libc::socklen_t;\n+            cvt(f(&mut addr as *mut _ as *mut _, &mut len))?;\n+            SocketAddr::from_parts(addr, len)\n+        }\n+    }\n+\n+    fn from_parts(addr: libc::sockaddr_un, mut len: libc::socklen_t) -> io::Result<SocketAddr> {\n+        if len == 0 {\n+            // When there is a datagram from unnamed unix socket\n+            // linux returns zero bytes of address\n+            len = sun_path_offset(&addr) as libc::socklen_t;  // i.e., zero-length address\n+        } else if addr.sun_family != libc::AF_UNIX as libc::sa_family_t {\n+            return Err(io::Error::new(io::ErrorKind::InvalidInput,\n+                                      \"file descriptor did not correspond to a Unix socket\"));\n+        }\n+\n+        Ok(SocketAddr {\n+            addr,\n+            len,\n+        })\n+    }\n+\n+    /// Returns `true` if the address is unnamed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// A named address:\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let socket = UnixListener::bind(\"/tmp/sock\").unwrap();\n+    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    /// assert_eq!(addr.is_unnamed(), false);\n+    /// ```\n+    ///\n+    /// An unnamed address:\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let socket = UnixDatagram::unbound().unwrap();\n+    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    /// assert_eq!(addr.is_unnamed(), true);\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn is_unnamed(&self) -> bool {\n+        if let AddressKind::Unnamed = self.address() {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    /// Returns the contents of this address if it is a `pathname` address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// With a pathname:\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    /// use std::path::Path;\n+    ///\n+    /// let socket = UnixListener::bind(\"/tmp/sock\").unwrap();\n+    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    /// assert_eq!(addr.as_pathname(), Some(Path::new(\"/tmp/sock\")));\n+    /// ```\n+    ///\n+    /// Without a pathname:\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let socket = UnixDatagram::unbound().unwrap();\n+    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    /// assert_eq!(addr.as_pathname(), None);\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn as_pathname(&self) -> Option<&Path> {\n+        if let AddressKind::Pathname(path) = self.address() {\n+            Some(path)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn address<'a>(&'a self) -> AddressKind<'a> {\n+        let len = self.len as usize - sun_path_offset(&self.addr);\n+        let path = unsafe { mem::transmute::<&[libc::c_char], &[u8]>(&self.addr.sun_path) };\n+\n+        // macOS seems to return a len of 16 and a zeroed sun_path for unnamed addresses\n+        if len == 0\n+            || (cfg!(not(any(target_os = \"linux\", target_os = \"android\")))\n+                && self.addr.sun_path[0] == 0)\n+        {\n+            AddressKind::Unnamed\n+        } else if self.addr.sun_path[0] == 0 {\n+            AddressKind::Abstract(&path[1..len])\n+        } else {\n+            AddressKind::Pathname(OsStr::from_bytes(&path[..len - 1]).as_ref())\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl fmt::Debug for SocketAddr {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.address() {\n+            AddressKind::Unnamed => write!(fmt, \"(unnamed)\"),\n+            AddressKind::Abstract(name) => write!(fmt, \"{} (abstract)\", AsciiEscaped(name)),\n+            AddressKind::Pathname(path) => write!(fmt, \"{:?} (pathname)\", path),\n+        }\n+    }\n+}\n+\n+struct AsciiEscaped<'a>(&'a [u8]);\n+\n+impl<'a> fmt::Display for AsciiEscaped<'a> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(fmt, \"\\\"\")?;\n+        for byte in self.0.iter().cloned().flat_map(ascii::escape_default) {\n+            write!(fmt, \"{}\", byte as char)?;\n+        }\n+        write!(fmt, \"\\\"\")\n+    }\n+}\n+\n+/// A Unix stream socket.\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// use std::os::unix::net::UnixStream;\n+/// use std::io::prelude::*;\n+///\n+/// let mut stream = UnixStream::connect(\"/path/to/my/socket\").unwrap();\n+/// stream.write_all(b\"hello world\").unwrap();\n+/// let mut response = String::new();\n+/// stream.read_to_string(&mut response).unwrap();\n+/// println!(\"{}\", response);\n+/// ```\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+pub struct UnixStream(Socket);\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl fmt::Debug for UnixStream {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let mut builder = fmt.debug_struct(\"UnixStream\");\n+        builder.field(\"fd\", self.0.as_inner());\n+        if let Ok(addr) = self.local_addr() {\n+            builder.field(\"local\", &addr);\n+        }\n+        if let Ok(addr) = self.peer_addr() {\n+            builder.field(\"peer\", &addr);\n+        }\n+        builder.finish()\n+    }\n+}\n+\n+impl UnixStream {\n+    /// Connects to the socket named by `path`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let socket = match UnixStream::connect(\"/tmp/sock\") {\n+    ///     Ok(sock) => sock,\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't connect: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn connect<P: AsRef<Path>>(path: P) -> io::Result<UnixStream> {\n+        fn inner(path: &Path) -> io::Result<UnixStream> {\n+            unsafe {\n+                let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM)?;\n+                let (addr, len) = sockaddr_un(path)?;\n+\n+                cvt(libc::connect(*inner.as_inner(), &addr as *const _ as *const _, len))?;\n+                Ok(UnixStream(inner))\n+            }\n+        }\n+        inner(path.as_ref())\n+    }\n+\n+    /// Creates an unnamed pair of connected sockets.\n+    ///\n+    /// Returns two `UnixStream`s which are connected to each other.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let (sock1, sock2) = match UnixStream::pair() {\n+    ///     Ok((sock1, sock2)) => (sock1, sock2),\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't create a pair of sockets: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn pair() -> io::Result<(UnixStream, UnixStream)> {\n+        let (i1, i2) = Socket::new_pair(libc::AF_UNIX, libc::SOCK_STREAM)?;\n+        Ok((UnixStream(i1), UnixStream(i2)))\n+    }\n+\n+    /// Creates a new independently owned handle to the underlying socket.\n+    ///\n+    /// The returned `UnixStream` is a reference to the same stream that this\n+    /// object references. Both handles will read and write the same stream of\n+    /// data, and options set on one stream will be propagated to the other\n+    /// stream.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// let sock_copy = socket.try_clone().expect(\"Couldn't clone socket\");\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn try_clone(&self) -> io::Result<UnixStream> {\n+        self.0.duplicate().map(UnixStream)\n+    }\n+\n+    /// Returns the socket address of the local half of this connection.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n+        SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n+    }\n+\n+    /// Returns the socket address of the remote half of this connection.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// let addr = socket.peer_addr().expect(\"Couldn't get peer address\");\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n+        SocketAddr::new(|addr, len| unsafe { libc::getpeername(*self.0.as_inner(), addr, len) })\n+    }\n+\n+    /// Sets the read timeout for the socket.\n+    ///\n+    /// If the provided value is [`None`], then [`read`] calls will block\n+    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method.\n+    ///\n+    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n+    /// [`Err`]: ../../../../std/result/enum.Result.html#variant.Err\n+    /// [`read`]: ../../../../std/io/trait.Read.html#tymethod.read\n+    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n+    /// ```\n+    ///\n+    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method:\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// let result = socket.set_read_timeout(Some(Duration::new(0, 0)));\n+    /// let err = result.unwrap_err();\n+    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n+        self.0.set_timeout(timeout, libc::SO_RCVTIMEO)\n+    }\n+\n+    /// Sets the write timeout for the socket.\n+    ///\n+    /// If the provided value is [`None`], then [`write`] calls will block\n+    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is\n+    /// passed to this method.\n+    ///\n+    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n+    /// [`Err`]: ../../../../std/result/enum.Result.html#variant.Err\n+    /// [`write`]: ../../../../std/io/trait.Write.html#tymethod.write\n+    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// socket.set_write_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set write timeout\");\n+    /// ```\n+    ///\n+    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method:\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::net::UdpSocket;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").unwrap();\n+    /// let result = socket.set_write_timeout(Some(Duration::new(0, 0)));\n+    /// let err = result.unwrap_err();\n+    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n+        self.0.set_timeout(timeout, libc::SO_SNDTIMEO)\n+    }\n+\n+    /// Returns the read timeout of this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n+    /// assert_eq!(socket.read_timeout().unwrap(), Some(Duration::new(1, 0)));\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n+        self.0.timeout(libc::SO_RCVTIMEO)\n+    }\n+\n+    /// Returns the write timeout of this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// socket.set_write_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set write timeout\");\n+    /// assert_eq!(socket.write_timeout().unwrap(), Some(Duration::new(1, 0)));\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n+        self.0.timeout(libc::SO_SNDTIMEO)\n+    }\n+\n+    /// Moves the socket into or out of nonblocking mode.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// socket.set_nonblocking(true).expect(\"Couldn't set nonblocking\");\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        self.0.set_nonblocking(nonblocking)\n+    }\n+\n+    /// Returns the value of the `SO_ERROR` option.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// if let Ok(Some(err)) = socket.take_error() {\n+    ///     println!(\"Got error: {:?}\", err);\n+    /// }\n+    /// ```\n+    ///\n+    /// # Platform specific\n+    /// On Redox this always returns `None`.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        self.0.take_error()\n+    }\n+\n+    /// Shuts down the read, write, or both halves of this connection.\n+    ///\n+    /// This function will cause all pending and future I/O calls on the\n+    /// specified portions to immediately return with an appropriate value\n+    /// (see the documentation of [`Shutdown`]).\n+    ///\n+    /// [`Shutdown`]: ../../../../std/net/enum.Shutdown.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::net::Shutdown;\n+    ///\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// socket.shutdown(Shutdown::Both).expect(\"shutdown function failed\");\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n+        self.0.shutdown(how)\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl io::Read for UnixStream {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        io::Read::read(&mut &*self, buf)\n+    }\n+\n+    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n+        io::Read::read_vectored(&mut &*self, bufs)\n+    }\n+\n+    #[inline]\n+    unsafe fn initializer(&self) -> Initializer {\n+        Initializer::nop()\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl<'a> io::Read for &'a UnixStream {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.read(buf)\n+    }\n+\n+    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n+        self.0.read_vectored(bufs)\n+    }\n+\n+    #[inline]\n+    unsafe fn initializer(&self) -> Initializer {\n+        Initializer::nop()\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl io::Write for UnixStream {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        io::Write::write(&mut &*self, buf)\n+    }\n+\n+    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        io::Write::write_vectored(&mut &*self, bufs)\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        io::Write::flush(&mut &*self)\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl<'a> io::Write for &'a UnixStream {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.0.write(buf)\n+    }\n+\n+    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        self.0.write_vectored(bufs)\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl AsRawFd for UnixStream {\n+    fn as_raw_fd(&self) -> RawFd {\n+        *self.0.as_inner()\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl FromRawFd for UnixStream {\n+    unsafe fn from_raw_fd(fd: RawFd) -> UnixStream {\n+        UnixStream(Socket::from_inner(fd))\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl IntoRawFd for UnixStream {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.0.into_inner()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawFd for net::TcpStream {\n+    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawFd for net::TcpListener {\n+    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawFd for net::UdpSocket {\n+    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n+}\n+\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+impl FromRawFd for net::TcpStream {\n+    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpStream {\n+        let socket = sys::net::Socket::from_inner(fd);\n+        net::TcpStream::from_inner(sys_common::net::TcpStream::from_inner(socket))\n+    }\n+}\n+\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+impl FromRawFd for net::TcpListener {\n+    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpListener {\n+        let socket = sys::net::Socket::from_inner(fd);\n+        net::TcpListener::from_inner(sys_common::net::TcpListener::from_inner(socket))\n+    }\n+}\n+\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+impl FromRawFd for net::UdpSocket {\n+    unsafe fn from_raw_fd(fd: RawFd) -> net::UdpSocket {\n+        let socket = sys::net::Socket::from_inner(fd);\n+        net::UdpSocket::from_inner(sys_common::net::UdpSocket::from_inner(socket))\n+    }\n+}\n+\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl IntoRawFd for net::TcpStream {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.into_inner().into_socket().into_inner()\n+    }\n+}\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl IntoRawFd for net::TcpListener {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.into_inner().into_socket().into_inner()\n+    }\n+}\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl IntoRawFd for net::UdpSocket {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.into_inner().into_socket().into_inner()\n+    }\n+}\n+\n+/// A structure representing a Unix domain socket server.\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// use std::thread;\n+/// use std::os::unix::net::{UnixStream, UnixListener};\n+///\n+/// fn handle_client(stream: UnixStream) {\n+///     // ...\n+/// }\n+///\n+/// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+///\n+/// // accept connections and process them, spawning a new thread for each one\n+/// for stream in listener.incoming() {\n+///     match stream {\n+///         Ok(stream) => {\n+///             /* connection succeeded */\n+///             thread::spawn(|| handle_client(stream));\n+///         }\n+///         Err(err) => {\n+///             /* connection failed */\n+///             break;\n+///         }\n+///     }\n+/// }\n+/// ```\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+pub struct UnixListener(Socket);\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl fmt::Debug for UnixListener {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let mut builder = fmt.debug_struct(\"UnixListener\");\n+        builder.field(\"fd\", self.0.as_inner());\n+        if let Ok(addr) = self.local_addr() {\n+            builder.field(\"local\", &addr);\n+        }\n+        builder.finish()\n+    }\n+}\n+\n+impl UnixListener {\n+    /// Creates a new `UnixListener` bound to the specified socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let listener = match UnixListener::bind(\"/path/to/the/socket\") {\n+    ///     Ok(sock) => sock,\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't connect: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixListener> {\n+        fn inner(path: &Path) -> io::Result<UnixListener> {\n+            unsafe {\n+                let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM)?;\n+                let (addr, len) = sockaddr_un(path)?;\n+\n+                cvt(libc::bind(*inner.as_inner(), &addr as *const _ as *const _, len as _))?;\n+                cvt(libc::listen(*inner.as_inner(), 128))?;\n+\n+                Ok(UnixListener(inner))\n+            }\n+        }\n+        inner(path.as_ref())\n+    }\n+\n+    /// Accepts a new incoming connection to this listener.\n+    ///\n+    /// This function will block the calling thread until a new Unix connection\n+    /// is established. When established, the corresponding [`UnixStream`] and\n+    /// the remote peer's address will be returned.\n+    ///\n+    /// [`UnixStream`]: ../../../../std/os/unix/net/struct.UnixStream.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// match listener.accept() {\n+    ///     Ok((socket, addr)) => println!(\"Got a client: {:?}\", addr),\n+    ///     Err(e) => println!(\"accept function failed: {:?}\", e),\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn accept(&self) -> io::Result<(UnixStream, SocketAddr)> {\n+        let mut storage: libc::sockaddr_un = unsafe { mem::zeroed() };\n+        let mut len = mem::size_of_val(&storage) as libc::socklen_t;\n+        let sock = self.0.accept(&mut storage as *mut _ as *mut _, &mut len)?;\n+        let addr = SocketAddr::from_parts(storage, len)?;\n+        Ok((UnixStream(sock), addr))\n+    }\n+\n+    /// Creates a new independently owned handle to the underlying socket.\n+    ///\n+    /// The returned `UnixListener` is a reference to the same socket that this\n+    /// object references. Both handles can be used to accept incoming\n+    /// connections and options set on one listener will affect the other.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// let listener_copy = listener.try_clone().expect(\"try_clone failed\");\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn try_clone(&self) -> io::Result<UnixListener> {\n+        self.0.duplicate().map(UnixListener)\n+    }\n+\n+    /// Returns the local socket address of this listener.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// let addr = listener.local_addr().expect(\"Couldn't get local address\");\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n+        SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n+    }\n+\n+    /// Moves the socket into or out of nonblocking mode.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// listener.set_nonblocking(true).expect(\"Couldn't set non blocking\");\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        self.0.set_nonblocking(nonblocking)\n+    }\n+\n+    /// Returns the value of the `SO_ERROR` option.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let listener = UnixListener::bind(\"/tmp/sock\").unwrap();\n+    ///\n+    /// if let Ok(Some(err)) = listener.take_error() {\n+    ///     println!(\"Got error: {:?}\", err);\n+    /// }\n+    /// ```\n+    ///\n+    /// # Platform specific\n+    /// On Redox this always returns `None`.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        self.0.take_error()\n+    }\n+\n+    /// Returns an iterator over incoming connections.\n+    ///\n+    /// The iterator will never return [`None`] and will also not yield the\n+    /// peer's [`SocketAddr`] structure.\n+    ///\n+    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n+    /// [`SocketAddr`]: struct.SocketAddr.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::thread;\n+    /// use std::os::unix::net::{UnixStream, UnixListener};\n+    ///\n+    /// fn handle_client(stream: UnixStream) {\n+    ///     // ...\n+    /// }\n+    ///\n+    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// for stream in listener.incoming() {\n+    ///     match stream {\n+    ///         Ok(stream) => {\n+    ///             thread::spawn(|| handle_client(stream));\n+    ///         }\n+    ///         Err(err) => {\n+    ///             break;\n+    ///         }\n+    ///     }\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn incoming<'a>(&'a self) -> Incoming<'a> {\n+        Incoming { listener: self }\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl AsRawFd for UnixListener {\n+    fn as_raw_fd(&self) -> RawFd {\n+        *self.0.as_inner()\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl FromRawFd for UnixListener {\n+    unsafe fn from_raw_fd(fd: RawFd) -> UnixListener {\n+        UnixListener(Socket::from_inner(fd))\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl IntoRawFd for UnixListener {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.0.into_inner()\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl<'a> IntoIterator for &'a UnixListener {\n+    type Item = io::Result<UnixStream>;\n+    type IntoIter = Incoming<'a>;\n+\n+    fn into_iter(self) -> Incoming<'a> {\n+        self.incoming()\n+    }\n+}\n+\n+/// An iterator over incoming connections to a [`UnixListener`].\n+///\n+/// It will never return [`None`].\n+///\n+/// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n+/// [`UnixListener`]: struct.UnixListener.html\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// use std::thread;\n+/// use std::os::unix::net::{UnixStream, UnixListener};\n+///\n+/// fn handle_client(stream: UnixStream) {\n+///     // ...\n+/// }\n+///\n+/// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+///\n+/// for stream in listener.incoming() {\n+///     match stream {\n+///         Ok(stream) => {\n+///             thread::spawn(|| handle_client(stream));\n+///         }\n+///         Err(err) => {\n+///             break;\n+///         }\n+///     }\n+/// }\n+/// ```\n+#[derive(Debug)]\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+pub struct Incoming<'a> {\n+    listener: &'a UnixListener,\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl<'a> Iterator for Incoming<'a> {\n+    type Item = io::Result<UnixStream>;\n+\n+    fn next(&mut self) -> Option<io::Result<UnixStream>> {\n+        Some(self.listener.accept().map(|s| s.0))\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (usize::max_value(), None)\n+    }\n+}\n+\n+/// A Unix datagram socket.\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// use std::os::unix::net::UnixDatagram;\n+///\n+/// let socket = UnixDatagram::bind(\"/path/to/my/socket\").unwrap();\n+/// socket.send_to(b\"hello world\", \"/path/to/other/socket\").unwrap();\n+/// let mut buf = [0; 100];\n+/// let (count, address) = socket.recv_from(&mut buf).unwrap();\n+/// println!(\"socket {:?} sent {:?}\", address, &buf[..count]);\n+/// ```\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+pub struct UnixDatagram(Socket);\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl fmt::Debug for UnixDatagram {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let mut builder = fmt.debug_struct(\"UnixDatagram\");\n+        builder.field(\"fd\", self.0.as_inner());\n+        if let Ok(addr) = self.local_addr() {\n+            builder.field(\"local\", &addr);\n+        }\n+        if let Ok(addr) = self.peer_addr() {\n+            builder.field(\"peer\", &addr);\n+        }\n+        builder.finish()\n+    }\n+}\n+\n+impl UnixDatagram {\n+    /// Creates a Unix datagram socket bound to the given path.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = match UnixDatagram::bind(\"/path/to/the/socket\") {\n+    ///     Ok(sock) => sock,\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't bind: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixDatagram> {\n+        fn inner(path: &Path) -> io::Result<UnixDatagram> {\n+            unsafe {\n+                let socket = UnixDatagram::unbound()?;\n+                let (addr, len) = sockaddr_un(path)?;\n+\n+                cvt(libc::bind(*socket.0.as_inner(), &addr as *const _ as *const _, len as _))?;\n+\n+                Ok(socket)\n+            }\n+        }\n+        inner(path.as_ref())\n+    }\n+\n+    /// Creates a Unix Datagram socket which is not bound to any address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = match UnixDatagram::unbound() {\n+    ///     Ok(sock) => sock,\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't unbound: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn unbound() -> io::Result<UnixDatagram> {\n+        let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_DGRAM)?;\n+        Ok(UnixDatagram(inner))\n+    }\n+\n+    /// Creates an unnamed pair of connected sockets.\n+    ///\n+    /// Returns two `UnixDatagrams`s which are connected to each other.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let (sock1, sock2) = match UnixDatagram::pair() {\n+    ///     Ok((sock1, sock2)) => (sock1, sock2),\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't unbound: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn pair() -> io::Result<(UnixDatagram, UnixDatagram)> {\n+        let (i1, i2) = Socket::new_pair(libc::AF_UNIX, libc::SOCK_DGRAM)?;\n+        Ok((UnixDatagram(i1), UnixDatagram(i2)))\n+    }\n+\n+    /// Connects the socket to the specified address.\n+    ///\n+    /// The [`send`] method may be used to send data to the specified address.\n+    /// [`recv`] and [`recv_from`] will only receive data from that address.\n+    ///\n+    /// [`send`]: #method.send\n+    /// [`recv`]: #method.recv\n+    /// [`recv_from`]: #method.recv_from\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// match sock.connect(\"/path/to/the/socket\") {\n+    ///     Ok(sock) => sock,\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't connect: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn connect<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {\n+        fn inner(d: &UnixDatagram, path: &Path) -> io::Result<()> {\n+            unsafe {\n+                let (addr, len) = sockaddr_un(path)?;\n+\n+                cvt(libc::connect(*d.0.as_inner(), &addr as *const _ as *const _, len))?;\n+\n+                Ok(())\n+            }\n+        }\n+        inner(self, path.as_ref())\n+    }\n+\n+    /// Creates a new independently owned handle to the underlying socket.\n+    ///\n+    /// The returned `UnixDatagram` is a reference to the same socket that this\n+    /// object references. Both handles can be used to accept incoming\n+    /// connections and options set on one side will affect the other.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// let sock_copy = sock.try_clone().expect(\"try_clone failed\");\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn try_clone(&self) -> io::Result<UnixDatagram> {\n+        self.0.duplicate().map(UnixDatagram)\n+    }\n+\n+    /// Returns the address of this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// let addr = sock.local_addr().expect(\"Couldn't get local address\");\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n+        SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n+    }\n+\n+    /// Returns the address of this socket's peer.\n+    ///\n+    /// The [`connect`] method will connect the socket to a peer.\n+    ///\n+    /// [`connect`]: #method.connect\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// sock.connect(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// let addr = sock.peer_addr().expect(\"Couldn't get peer address\");\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n+        SocketAddr::new(|addr, len| unsafe { libc::getpeername(*self.0.as_inner(), addr, len) })\n+    }\n+\n+    /// Receives data from the socket.\n+    ///\n+    /// On success, returns the number of bytes read and the address from\n+    /// whence the data came.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// let mut buf = vec![0; 10];\n+    /// match sock.recv_from(buf.as_mut_slice()) {\n+    ///     Ok((size, sender)) => println!(\"received {} bytes from {:?}\", size, sender),\n+    ///     Err(e) => println!(\"recv_from function failed: {:?}\", e),\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        let mut count = 0;\n+        let addr = SocketAddr::new(|addr, len| {\n+            unsafe {\n+                count = libc::recvfrom(*self.0.as_inner(),\n+                                       buf.as_mut_ptr() as *mut _,\n+                                       buf.len(),\n+                                       0,\n+                                       addr,\n+                                       len);\n+                if count > 0 {\n+                    1\n+                } else if count == 0 {\n+                    0\n+                } else {\n+                    -1\n+                }\n+            }\n+        })?;\n+\n+        Ok((count as usize, addr))\n+    }\n+\n+    /// Receives data from the socket.\n+    ///\n+    /// On success, returns the number of bytes read.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::bind(\"/path/to/the/socket\").unwrap();\n+    /// let mut buf = vec![0; 10];\n+    /// sock.recv(buf.as_mut_slice()).expect(\"recv function failed\");\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn recv(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.read(buf)\n+    }\n+\n+    /// Sends data on the socket to the specified address.\n+    ///\n+    /// On success, returns the number of bytes written.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// sock.send_to(b\"omelette au fromage\", \"/some/sock\").expect(\"send_to function failed\");\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn send_to<P: AsRef<Path>>(&self, buf: &[u8], path: P) -> io::Result<usize> {\n+        fn inner(d: &UnixDatagram, buf: &[u8], path: &Path) -> io::Result<usize> {\n+            unsafe {\n+                let (addr, len) = sockaddr_un(path)?;\n+\n+                let count = cvt(libc::sendto(*d.0.as_inner(),\n+                                             buf.as_ptr() as *const _,\n+                                             buf.len(),\n+                                             MSG_NOSIGNAL,\n+                                             &addr as *const _ as *const _,\n+                                             len))?;\n+                Ok(count as usize)\n+            }\n+        }\n+        inner(self, buf, path.as_ref())\n+    }\n+\n+    /// Sends data on the socket to the socket's peer.\n+    ///\n+    /// The peer address may be set by the `connect` method, and this method\n+    /// will return an error if the socket has not already been connected.\n+    ///\n+    /// On success, returns the number of bytes written.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// sock.connect(\"/some/sock\").expect(\"Couldn't connect\");\n+    /// sock.send(b\"omelette au fromage\").expect(\"send_to function failed\");\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn send(&self, buf: &[u8]) -> io::Result<usize> {\n+        self.0.write(buf)\n+    }\n+\n+    /// Sets the read timeout for the socket.\n+    ///\n+    /// If the provided value is [`None`], then [`recv`] and [`recv_from`] calls will\n+    /// block indefinitely. An [`Err`] is returned if the zero [`Duration`]\n+    /// is passed to this method.\n+    ///\n+    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n+    /// [`Err`]: ../../../../std/result/enum.Result.html#variant.Err\n+    /// [`recv`]: #method.recv\n+    /// [`recv_from`]: #method.recv_from\n+    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::time::Duration;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// sock.set_read_timeout(Some(Duration::new(1, 0))).expect(\"set_read_timeout function failed\");\n+    /// ```\n+    ///\n+    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method:\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UnixDatagram::unbound().unwrap();\n+    /// let result = socket.set_read_timeout(Some(Duration::new(0, 0)));\n+    /// let err = result.unwrap_err();\n+    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n+        self.0.set_timeout(timeout, libc::SO_RCVTIMEO)\n+    }\n+\n+    /// Sets the write timeout for the socket.\n+    ///\n+    /// If the provided value is [`None`], then [`send`] and [`send_to`] calls will\n+    /// block indefinitely. An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method.\n+    ///\n+    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n+    /// [`send`]: #method.send\n+    /// [`send_to`]: #method.send_to\n+    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::time::Duration;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// sock.set_write_timeout(Some(Duration::new(1, 0)))\n+    ///     .expect(\"set_write_timeout function failed\");\n+    /// ```\n+    ///\n+    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method:\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::time::Duration;\n+    ///\n+    /// let socket = UnixDatagram::unbound().unwrap();\n+    /// let result = socket.set_write_timeout(Some(Duration::new(0, 0)));\n+    /// let err = result.unwrap_err();\n+    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n+        self.0.set_timeout(timeout, libc::SO_SNDTIMEO)\n+    }\n+\n+    /// Returns the read timeout of this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::time::Duration;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// sock.set_read_timeout(Some(Duration::new(1, 0))).expect(\"set_read_timeout function failed\");\n+    /// assert_eq!(sock.read_timeout().unwrap(), Some(Duration::new(1, 0)));\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n+        self.0.timeout(libc::SO_RCVTIMEO)\n+    }\n+\n+    /// Returns the write timeout of this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::time::Duration;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// sock.set_write_timeout(Some(Duration::new(1, 0)))\n+    ///     .expect(\"set_write_timeout function failed\");\n+    /// assert_eq!(sock.write_timeout().unwrap(), Some(Duration::new(1, 0)));\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n+        self.0.timeout(libc::SO_SNDTIMEO)\n+    }\n+\n+    /// Moves the socket into or out of nonblocking mode.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// sock.set_nonblocking(true).expect(\"set_nonblocking function failed\");\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        self.0.set_nonblocking(nonblocking)\n+    }\n+\n+    /// Returns the value of the `SO_ERROR` option.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// if let Ok(Some(err)) = sock.take_error() {\n+    ///     println!(\"Got error: {:?}\", err);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        self.0.take_error()\n+    }\n+\n+    /// Shut down the read, write, or both halves of this connection.\n+    ///\n+    /// This function will cause all pending and future I/O calls on the\n+    /// specified portions to immediately return with an appropriate value\n+    /// (see the documentation of [`Shutdown`]).\n+    ///\n+    /// [`Shutdown`]: ../../../../std/net/enum.Shutdown.html\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::net::Shutdown;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// sock.shutdown(Shutdown::Both).expect(\"shutdown function failed\");\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n+        self.0.shutdown(how)\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl AsRawFd for UnixDatagram {\n+    fn as_raw_fd(&self) -> RawFd {\n+        *self.0.as_inner()\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl FromRawFd for UnixDatagram {\n+    unsafe fn from_raw_fd(fd: RawFd) -> UnixDatagram {\n+        UnixDatagram(Socket::from_inner(fd))\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl IntoRawFd for UnixDatagram {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.0.into_inner()\n+    }\n+}\n+\n+#[cfg(all(test, not(target_os = \"emscripten\")))]\n+mod test {\n+    use crate::thread;\n+    use crate::io::{self, ErrorKind};\n+    use crate::io::prelude::*;\n+    use crate::time::Duration;\n+    use crate::sys_common::io::test::tmpdir;\n+\n+    use super::*;\n+\n+    macro_rules! or_panic {\n+        ($e:expr) => {\n+            match $e {\n+                Ok(e) => e,\n+                Err(e) => panic!(\"{}\", e),\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn basic() {\n+        let dir = tmpdir();\n+        let socket_path = dir.path().join(\"sock\");\n+        let msg1 = b\"hello\";\n+        let msg2 = b\"world!\";\n+\n+        let listener = or_panic!(UnixListener::bind(&socket_path));\n+        let thread = thread::spawn(move || {\n+            let mut stream = or_panic!(listener.accept()).0;\n+            let mut buf = [0; 5];\n+            or_panic!(stream.read(&mut buf));\n+            assert_eq!(&msg1[..], &buf[..]);\n+            or_panic!(stream.write_all(msg2));\n+        });\n+\n+        let mut stream = or_panic!(UnixStream::connect(&socket_path));\n+        assert_eq!(Some(&*socket_path),\n+                   stream.peer_addr().unwrap().as_pathname());\n+        or_panic!(stream.write_all(msg1));\n+        let mut buf = vec![];\n+        or_panic!(stream.read_to_end(&mut buf));\n+        assert_eq!(&msg2[..], &buf[..]);\n+        drop(stream);\n+\n+        thread.join().unwrap();\n+    }\n+\n+    #[test]\n+    fn vectored() {\n+        let (mut s1, mut s2) = or_panic!(UnixStream::pair());\n+\n+        let len = or_panic!(s1.write_vectored(\n+            &[IoSlice::new(b\"hello\"), IoSlice::new(b\" \"), IoSlice::new(b\"world!\")],\n+        ));\n+        assert_eq!(len, 12);\n+\n+        let mut buf1 = [0; 6];\n+        let mut buf2 = [0; 7];\n+        let len = or_panic!(s2.read_vectored(\n+            &mut [IoSliceMut::new(&mut buf1), IoSliceMut::new(&mut buf2)],\n+        ));\n+        assert_eq!(len, 12);\n+        assert_eq!(&buf1, b\"hello \");\n+        assert_eq!(&buf2, b\"world!\\0\");\n+    }\n+\n+    #[test]\n+    fn pair() {\n+        let msg1 = b\"hello\";\n+        let msg2 = b\"world!\";\n+\n+        let (mut s1, mut s2) = or_panic!(UnixStream::pair());\n+        let thread = thread::spawn(move || {\n+            // s1 must be moved in or the test will hang!\n+            let mut buf = [0; 5];\n+            or_panic!(s1.read(&mut buf));\n+            assert_eq!(&msg1[..], &buf[..]);\n+            or_panic!(s1.write_all(msg2));\n+        });\n+\n+        or_panic!(s2.write_all(msg1));\n+        let mut buf = vec![];\n+        or_panic!(s2.read_to_end(&mut buf));\n+        assert_eq!(&msg2[..], &buf[..]);\n+        drop(s2);\n+\n+        thread.join().unwrap();\n+    }\n+\n+    #[test]\n+    fn try_clone() {\n+        let dir = tmpdir();\n+        let socket_path = dir.path().join(\"sock\");\n+        let msg1 = b\"hello\";\n+        let msg2 = b\"world\";\n+\n+        let listener = or_panic!(UnixListener::bind(&socket_path));\n+        let thread = thread::spawn(move || {\n+            let mut stream = or_panic!(listener.accept()).0;\n+            or_panic!(stream.write_all(msg1));\n+            or_panic!(stream.write_all(msg2));\n+        });\n+\n+        let mut stream = or_panic!(UnixStream::connect(&socket_path));\n+        let mut stream2 = or_panic!(stream.try_clone());\n+\n+        let mut buf = [0; 5];\n+        or_panic!(stream.read(&mut buf));\n+        assert_eq!(&msg1[..], &buf[..]);\n+        or_panic!(stream2.read(&mut buf));\n+        assert_eq!(&msg2[..], &buf[..]);\n+\n+        thread.join().unwrap();\n+    }\n+\n+    #[test]\n+    fn iter() {\n+        let dir = tmpdir();\n+        let socket_path = dir.path().join(\"sock\");\n+\n+        let listener = or_panic!(UnixListener::bind(&socket_path));\n+        let thread = thread::spawn(move || {\n+            for stream in listener.incoming().take(2) {\n+                let mut stream = or_panic!(stream);\n+                let mut buf = [0];\n+                or_panic!(stream.read(&mut buf));\n+            }\n+        });\n+\n+        for _ in 0..2 {\n+            let mut stream = or_panic!(UnixStream::connect(&socket_path));\n+            or_panic!(stream.write_all(&[0]));\n+        }\n+\n+        thread.join().unwrap();\n+    }\n+\n+    #[test]\n+    fn long_path() {\n+        let dir = tmpdir();\n+        let socket_path = dir.path()\n+                             .join(\"asdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfa\\\n+                                    sasdfasdfasdasdfasdfasdfadfasdfasdfasdfasdfasdf\");\n+        match UnixStream::connect(&socket_path) {\n+            Err(ref e) if e.kind() == io::ErrorKind::InvalidInput => {}\n+            Err(e) => panic!(\"unexpected error {}\", e),\n+            Ok(_) => panic!(\"unexpected success\"),\n+        }\n+\n+        match UnixListener::bind(&socket_path) {\n+            Err(ref e) if e.kind() == io::ErrorKind::InvalidInput => {}\n+            Err(e) => panic!(\"unexpected error {}\", e),\n+            Ok(_) => panic!(\"unexpected success\"),\n+        }\n+\n+        match UnixDatagram::bind(&socket_path) {\n+            Err(ref e) if e.kind() == io::ErrorKind::InvalidInput => {}\n+            Err(e) => panic!(\"unexpected error {}\", e),\n+            Ok(_) => panic!(\"unexpected success\"),\n+        }\n+    }\n+\n+    #[test]\n+    fn timeouts() {\n+        let dir = tmpdir();\n+        let socket_path = dir.path().join(\"sock\");\n+\n+        let _listener = or_panic!(UnixListener::bind(&socket_path));\n+\n+        let stream = or_panic!(UnixStream::connect(&socket_path));\n+        let dur = Duration::new(15410, 0);\n+\n+        assert_eq!(None, or_panic!(stream.read_timeout()));\n+\n+        or_panic!(stream.set_read_timeout(Some(dur)));\n+        assert_eq!(Some(dur), or_panic!(stream.read_timeout()));\n+\n+        assert_eq!(None, or_panic!(stream.write_timeout()));\n+\n+        or_panic!(stream.set_write_timeout(Some(dur)));\n+        assert_eq!(Some(dur), or_panic!(stream.write_timeout()));\n+\n+        or_panic!(stream.set_read_timeout(None));\n+        assert_eq!(None, or_panic!(stream.read_timeout()));\n+\n+        or_panic!(stream.set_write_timeout(None));\n+        assert_eq!(None, or_panic!(stream.write_timeout()));\n+    }\n+\n+    #[test]\n+    fn test_read_timeout() {\n+        let dir = tmpdir();\n+        let socket_path = dir.path().join(\"sock\");\n+\n+        let _listener = or_panic!(UnixListener::bind(&socket_path));\n+\n+        let mut stream = or_panic!(UnixStream::connect(&socket_path));\n+        or_panic!(stream.set_read_timeout(Some(Duration::from_millis(1000))));\n+\n+        let mut buf = [0; 10];\n+        let kind = stream.read_exact(&mut buf).err().expect(\"expected error\").kind();\n+        assert!(kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut,\n+                \"unexpected_error: {:?}\", kind);\n+    }\n+\n+    #[test]\n+    fn test_read_with_timeout() {\n+        let dir = tmpdir();\n+        let socket_path = dir.path().join(\"sock\");\n+\n+        let listener = or_panic!(UnixListener::bind(&socket_path));\n+\n+        let mut stream = or_panic!(UnixStream::connect(&socket_path));\n+        or_panic!(stream.set_read_timeout(Some(Duration::from_millis(1000))));\n+\n+        let mut other_end = or_panic!(listener.accept()).0;\n+        or_panic!(other_end.write_all(b\"hello world\"));\n+\n+        let mut buf = [0; 11];\n+        or_panic!(stream.read(&mut buf));\n+        assert_eq!(b\"hello world\", &buf[..]);\n+\n+        let kind = stream.read_exact(&mut buf).err().expect(\"expected error\").kind();\n+        assert!(kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut,\n+                \"unexpected_error: {:?}\", kind);\n+    }\n+\n+    // Ensure the `set_read_timeout` and `set_write_timeout` calls return errors\n+    // when passed zero Durations\n+    #[test]\n+    fn test_unix_stream_timeout_zero_duration() {\n+        let dir = tmpdir();\n+        let socket_path = dir.path().join(\"sock\");\n+\n+        let listener = or_panic!(UnixListener::bind(&socket_path));\n+        let stream = or_panic!(UnixStream::connect(&socket_path));\n+\n+        let result = stream.set_write_timeout(Some(Duration::new(0, 0)));\n+        let err = result.unwrap_err();\n+        assert_eq!(err.kind(), ErrorKind::InvalidInput);\n+\n+        let result = stream.set_read_timeout(Some(Duration::new(0, 0)));\n+        let err = result.unwrap_err();\n+        assert_eq!(err.kind(), ErrorKind::InvalidInput);\n+\n+        drop(listener);\n+    }\n+\n+    #[test]\n+    fn test_unix_datagram() {\n+        let dir = tmpdir();\n+        let path1 = dir.path().join(\"sock1\");\n+        let path2 = dir.path().join(\"sock2\");\n+\n+        let sock1 = or_panic!(UnixDatagram::bind(&path1));\n+        let sock2 = or_panic!(UnixDatagram::bind(&path2));\n+\n+        let msg = b\"hello world\";\n+        or_panic!(sock1.send_to(msg, &path2));\n+        let mut buf = [0; 11];\n+        or_panic!(sock2.recv_from(&mut buf));\n+        assert_eq!(msg, &buf[..]);\n+    }\n+\n+    #[test]\n+    fn test_unnamed_unix_datagram() {\n+        let dir = tmpdir();\n+        let path1 = dir.path().join(\"sock1\");\n+\n+        let sock1 = or_panic!(UnixDatagram::bind(&path1));\n+        let sock2 = or_panic!(UnixDatagram::unbound());\n+\n+        let msg = b\"hello world\";\n+        or_panic!(sock2.send_to(msg, &path1));\n+        let mut buf = [0; 11];\n+        let (usize, addr) = or_panic!(sock1.recv_from(&mut buf));\n+        assert_eq!(usize, 11);\n+        assert!(addr.is_unnamed());\n+        assert_eq!(msg, &buf[..]);\n+    }\n+\n+    #[test]\n+    fn test_connect_unix_datagram() {\n+        let dir = tmpdir();\n+        let path1 = dir.path().join(\"sock1\");\n+        let path2 = dir.path().join(\"sock2\");\n+\n+        let bsock1 = or_panic!(UnixDatagram::bind(&path1));\n+        let bsock2 = or_panic!(UnixDatagram::bind(&path2));\n+        let sock = or_panic!(UnixDatagram::unbound());\n+        or_panic!(sock.connect(&path1));\n+\n+        // Check send()\n+        let msg = b\"hello there\";\n+        or_panic!(sock.send(msg));\n+        let mut buf = [0; 11];\n+        let (usize, addr) = or_panic!(bsock1.recv_from(&mut buf));\n+        assert_eq!(usize, 11);\n+        assert!(addr.is_unnamed());\n+        assert_eq!(msg, &buf[..]);\n+\n+        // Changing default socket works too\n+        or_panic!(sock.connect(&path2));\n+        or_panic!(sock.send(msg));\n+        or_panic!(bsock2.recv_from(&mut buf));\n+    }\n+\n+    #[test]\n+    fn test_unix_datagram_recv() {\n+        let dir = tmpdir();\n+        let path1 = dir.path().join(\"sock1\");\n+\n+        let sock1 = or_panic!(UnixDatagram::bind(&path1));\n+        let sock2 = or_panic!(UnixDatagram::unbound());\n+        or_panic!(sock2.connect(&path1));\n+\n+        let msg = b\"hello world\";\n+        or_panic!(sock2.send(msg));\n+        let mut buf = [0; 11];\n+        let size = or_panic!(sock1.recv(&mut buf));\n+        assert_eq!(size, 11);\n+        assert_eq!(msg, &buf[..]);\n+    }\n+\n+    #[test]\n+    fn datagram_pair() {\n+        let msg1 = b\"hello\";\n+        let msg2 = b\"world!\";\n+\n+        let (s1, s2) = or_panic!(UnixDatagram::pair());\n+        let thread = thread::spawn(move || {\n+            // s1 must be moved in or the test will hang!\n+            let mut buf = [0; 5];\n+            or_panic!(s1.recv(&mut buf));\n+            assert_eq!(&msg1[..], &buf[..]);\n+            or_panic!(s1.send(msg2));\n+        });\n+\n+        or_panic!(s2.send(msg1));\n+        let mut buf = [0; 6];\n+        or_panic!(s2.recv(&mut buf));\n+        assert_eq!(&msg2[..], &buf[..]);\n+        drop(s2);\n+\n+        thread.join().unwrap();\n+    }\n+\n+    // Ensure the `set_read_timeout` and `set_write_timeout` calls return errors\n+    // when passed zero Durations\n+    #[test]\n+    fn test_unix_datagram_timeout_zero_duration() {\n+        let dir = tmpdir();\n+        let path = dir.path().join(\"sock\");\n+\n+        let datagram = or_panic!(UnixDatagram::bind(&path));\n+\n+        let result = datagram.set_write_timeout(Some(Duration::new(0, 0)));\n+        let err = result.unwrap_err();\n+        assert_eq!(err.kind(), ErrorKind::InvalidInput);\n+\n+        let result = datagram.set_read_timeout(Some(Duration::new(0, 0)));\n+        let err = result.unwrap_err();\n+        assert_eq!(err.kind(), ErrorKind::InvalidInput);\n+    }\n+\n+    #[test]\n+    fn abstract_namespace_not_allowed() {\n+        assert!(UnixStream::connect(\"\\0asdf\").is_err());\n+    }\n+}"}, {"sha": "4de72fa18167e8c95fe8d2e3e3ed30ced3a6c03c", "filename": "src/libstd/sys/vxworks/ext/process.rs", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fprocess.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,213 @@\n+//! Unix-specific extensions to primitives in the `std::process` module.\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+use crate::io;\n+use crate::sys::vxworks::ext::io::{FromRawFd, RawFd, AsRawFd, IntoRawFd};\n+use crate::process;\n+use crate::sys;\n+use crate::sys_common::{AsInnerMut, AsInner, FromInner, IntoInner};\n+\n+/// Unix-specific extensions to the [`process::Command`] builder.\n+///\n+/// [`process::Command`]: ../../../../std/process/struct.Command.html\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait CommandExt {\n+    /// Sets the child process's user ID. This translates to a\n+    /// `setuid` call in the child process. Failure in the `setuid`\n+    /// call will cause the spawn to fail.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn uid(&mut self, id: u16) -> &mut process::Command;\n+\n+    /// Similar to `uid`, but sets the group ID of the child process. This has\n+    /// the same semantics as the `uid` field.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn gid(&mut self, id: u16) -> &mut process::Command;\n+\n+    /// Schedules a closure to be run just before the `exec` function is\n+    /// invoked.\n+    ///\n+    /// The closure is allowed to return an I/O error whose OS error code will\n+    /// be communicated back to the parent and returned as an error from when\n+    /// the spawn was requested.\n+    ///\n+    /// Multiple closures can be registered and they will be called in order of\n+    /// their registration. If a closure returns `Err` then no further closures\n+    /// will be called and the spawn operation will immediately return with a\n+    /// failure.\n+    ///\n+    /// # Notes and Safety\n+    ///\n+    /// This closure will be run in the context of the child process after a\n+    /// `fork`. This primarily means that any modifications made to memory on\n+    /// behalf of this closure will **not** be visible to the parent process.\n+    /// This is often a very constrained environment where normal operations\n+    /// like `malloc` or acquiring a mutex are not guaranteed to work (due to\n+    /// other threads perhaps still running when the `fork` was run).\n+    ///\n+    /// This also means that all resources such as file descriptors and\n+    /// memory-mapped regions got duplicated. It is your responsibility to make\n+    /// sure that the closure does not violate library invariants by making\n+    /// invalid use of these duplicates.\n+    ///\n+    /// When this closure is run, aspects such as the stdio file descriptors and\n+    /// working directory have successfully been changed, so output to these\n+    /// locations may not appear where intended.\n+    #[stable(feature = \"process_pre_exec\", since = \"1.34.0\")]\n+    unsafe fn pre_exec<F>(&mut self, f: F) -> &mut process::Command\n+        where F: FnMut() -> io::Result<()> + Send + Sync + 'static;\n+\n+    /// Schedules a closure to be run just before the `exec` function is\n+    /// invoked.\n+    ///\n+    /// This method is stable and usable, but it should be unsafe. To fix\n+    /// that, it got deprecated in favor of the unsafe [`pre_exec`].\n+    ///\n+    /// [`pre_exec`]: #tymethod.pre_exec\n+    #[stable(feature = \"process_exec\", since = \"1.15.0\")]\n+    #[rustc_deprecated(since = \"1.37.0\", reason = \"should be unsafe, use `pre_exec` instead\")]\n+    fn before_exec<F>(&mut self, f: F) -> &mut process::Command\n+        where F: FnMut() -> io::Result<()> + Send + Sync + 'static\n+    {\n+        unsafe { self.pre_exec(f) }\n+    }\n+\n+    /// Performs all the required setup by this `Command`, followed by calling\n+    /// the `execvp` syscall.\n+    ///\n+    /// On success this function will not return, and otherwise it will return\n+    /// an error indicating why the exec (or another part of the setup of the\n+    /// `Command`) failed.\n+    ///\n+    /// `exec` not returning has the same implications as calling\n+    /// [`process::exit`] \u2013 no destructors on the current stack or any other\n+    /// thread\u2019s stack will be run. Therefore, it is recommended to only call\n+    /// `exec` at a point where it is fine to not run any destructors. Note,\n+    /// that the `execvp` syscall independently guarantees that all memory is\n+    /// freed and all file descriptors with the `CLOEXEC` option (set by default\n+    /// on all file descriptors opened by the standard library) are closed.\n+    ///\n+    /// This function, unlike `spawn`, will **not** `fork` the process to create\n+    /// a new child. Like spawn, however, the default behavior for the stdio\n+    /// descriptors will be to inherited from the current process.\n+    ///\n+    /// [`process::exit`]: ../../../process/fn.exit.html\n+    ///\n+    /// # Notes\n+    ///\n+    /// The process may be in a \"broken state\" if this function returns in\n+    /// error. For example the working directory, environment variables, signal\n+    /// handling settings, various user/group information, or aspects of stdio\n+    /// file descriptors may have changed. If a \"transactional spawn\" is\n+    /// required to gracefully handle errors it is recommended to use the\n+    /// cross-platform `spawn` instead.\n+    #[stable(feature = \"process_exec2\", since = \"1.9.0\")]\n+    fn exec(&mut self) -> io::Error;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl CommandExt for process::Command {\n+    fn uid(&mut self, id: u16) -> &mut process::Command {\n+        self.as_inner_mut().uid(id);\n+        self\n+    }\n+\n+    fn gid(&mut self, id: u16) -> &mut process::Command {\n+        self.as_inner_mut().gid(id);\n+        self\n+    }\n+\n+    unsafe fn pre_exec<F>(&mut self, f: F) -> &mut process::Command\n+        where F: FnMut() -> io::Result<()> + Send + Sync + 'static\n+    {\n+        self.as_inner_mut().pre_exec(Box::new(f));\n+        self\n+    }\n+\n+    fn exec(&mut self) -> io::Error {\n+        self.as_inner_mut().exec(sys::process::Stdio::Inherit)\n+    }\n+}\n+\n+/// Unix-specific extensions to [`process::ExitStatus`].\n+///\n+/// [`process::ExitStatus`]: ../../../../std/process/struct.ExitStatus.html\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait ExitStatusExt {\n+    /// Creates a new `ExitStatus` from the raw underlying `i32` return value of\n+    /// a process.\n+    #[stable(feature = \"exit_status_from\", since = \"1.12.0\")]\n+    fn from_raw(raw: i32) -> Self;\n+\n+    /// If the process was terminated by a signal, returns that signal.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn signal(&self) -> Option<i32>;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl ExitStatusExt for process::ExitStatus {\n+    fn from_raw(raw: i32) -> Self {\n+        process::ExitStatus::from_inner(From::from(raw))\n+    }\n+\n+    fn signal(&self) -> Option<i32> {\n+        self.as_inner().signal()\n+    }\n+}\n+\n+#[stable(feature = \"process_extensions\", since = \"1.2.0\")]\n+impl FromRawFd for process::Stdio {\n+    unsafe fn from_raw_fd(fd: RawFd) -> process::Stdio {\n+        let fd = sys::fd::FileDesc::new(fd);\n+        let io = sys::process::Stdio::Fd(fd);\n+        process::Stdio::from_inner(io)\n+    }\n+}\n+\n+#[stable(feature = \"process_extensions\", since = \"1.2.0\")]\n+impl AsRawFd for process::ChildStdin {\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.as_inner().fd().raw()\n+    }\n+}\n+\n+#[stable(feature = \"process_extensions\", since = \"1.2.0\")]\n+impl AsRawFd for process::ChildStdout {\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.as_inner().fd().raw()\n+    }\n+}\n+\n+#[stable(feature = \"process_extensions\", since = \"1.2.0\")]\n+impl AsRawFd for process::ChildStderr {\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.as_inner().fd().raw()\n+    }\n+}\n+\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl IntoRawFd for process::ChildStdin {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.into_inner().into_fd().into_raw()\n+    }\n+}\n+\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl IntoRawFd for process::ChildStdout {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.into_inner().into_fd().into_raw()\n+    }\n+}\n+\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl IntoRawFd for process::ChildStderr {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.into_inner().into_fd().into_raw()\n+    }\n+}\n+\n+/// Returns the OS-assigned process identifier associated with this process's parent.\n+#[stable(feature = \"unix_ppid\", since = \"1.27.0\")]\n+pub fn parent_id() -> u32 {\n+    crate::sys::os::getppid()\n+}"}, {"sha": "1f134f4e2d1bddd7bc427099fbf562b158a0717a", "filename": "src/libstd/sys/vxworks/ext/raw.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fext%2Fraw.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,5 @@\n+#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+\n+#[doc(inline)]\n+#[stable(feature = \"pthread_t\", since = \"1.8.0\")]\n+pub use crate::sys::platform::raw::pthread_t;"}, {"sha": "f5a2e263d25e7c6612696fc01c9bb197b7040dcf", "filename": "src/libstd/sys/vxworks/fast_thread_local.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Ffast_thread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Ffast_thread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Ffast_thread_local.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,36 @@\n+#![cfg(target_thread_local)]\n+#![unstable(feature = \"thread_local_internals\", issue = \"0\")]\n+\n+// Since what appears to be glibc 2.18 this symbol has been shipped which\n+// GCC and clang both use to invoke destructors in thread_local globals, so\n+// let's do the same!\n+//\n+// Note, however, that we run on lots older linuxes, as well as cross\n+// compiling from a newer linux to an older linux, so we also have a\n+// fallback implementation to use as well.\n+//\n+// Due to rust-lang/rust#18804, make sure this is not generic!\n+pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n+    use crate::mem;\n+    use crate::sys_common::thread_local::register_dtor_fallback;\n+\n+    extern {\n+        #[linkage = \"extern_weak\"]\n+        static __dso_handle: *mut u8;\n+        #[linkage = \"extern_weak\"]\n+        static __cxa_thread_atexit_impl: *const libc::c_void;\n+    }\n+    if !__cxa_thread_atexit_impl.is_null() {\n+        type F = unsafe extern fn(dtor: unsafe extern fn(*mut u8),\n+                                  arg: *mut u8,\n+                                  dso_handle: *mut u8) -> libc::c_int;\n+        mem::transmute::<*const libc::c_void, F>(__cxa_thread_atexit_impl)\n+            (dtor, t, &__dso_handle as *const _ as *mut _);\n+        return\n+    }\n+    register_dtor_fallback(t, dtor);\n+}\n+\n+pub fn requires_move_before_drop() -> bool {\n+    false\n+}"}, {"sha": "db2865d25292c1908ba495bfc47d34312ee3c64f", "filename": "src/libstd/sys/vxworks/fd.rs", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Ffd.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,188 @@\n+#![unstable(reason = \"not public\", issue = \"0\", feature = \"fd\")]\n+\n+use crate::cmp;\n+use crate::io::{self, Read, Initializer, IoSlice, IoSliceMut};\n+use crate::mem;\n+use crate::sys::cvt;\n+use crate::sys_common::AsInner;\n+\n+use libc::{self, c_int, c_void, ssize_t};\n+\n+#[derive(Debug)]\n+pub struct FileDesc {\n+    fd: c_int,\n+}\n+\n+fn max_len() -> usize {\n+    // The maximum read limit on most posix-like systems is `SSIZE_MAX`,\n+    // with the man page quoting that if the count of bytes to read is\n+    // greater than `SSIZE_MAX` the result is \"unspecified\".\n+    <ssize_t>::max_value() as usize\n+}\n+\n+impl FileDesc {\n+    pub fn new(fd: c_int) -> FileDesc {\n+        FileDesc { fd: fd }\n+    }\n+\n+    pub fn raw(&self) -> c_int { self.fd }\n+\n+    /// Extracts the actual filedescriptor without closing it.\n+    pub fn into_raw(self) -> c_int {\n+        let fd = self.fd;\n+        mem::forget(self);\n+        fd\n+    }\n+\n+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        let ret = cvt(unsafe {\n+            libc::read(self.fd,\n+                       buf.as_mut_ptr() as *mut c_void,\n+                       cmp::min(buf.len(), max_len()))\n+        })?;\n+        Ok(ret as usize)\n+    }\n+\n+    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n+        let ret = cvt(unsafe {\n+            libc::readv(self.fd,\n+                        bufs.as_ptr() as *const libc::iovec,\n+                        cmp::min(bufs.len(), c_int::max_value() as usize) as c_int)\n+        })?;\n+        Ok(ret as usize)\n+    }\n+\n+    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        let mut me = self;\n+        (&mut me).read_to_end(buf)\n+    }\n+\n+    pub fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {\n+        unsafe fn cvt_pread(fd: c_int, buf: *mut c_void, count: usize, offset: i64)\n+            -> io::Result<isize>\n+        {\n+            use libc::pread;\n+            cvt(pread(fd, buf, count, offset))\n+        }\n+\n+        unsafe {\n+            cvt_pread(self.fd,\n+                buf.as_mut_ptr() as *mut c_void,\n+                cmp::min(buf.len(), max_len()),\n+                offset as i64)\n+            .map(|n| n as usize)\n+        }\n+    }\n+\n+    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n+        let ret = cvt(unsafe {\n+            libc::write(self.fd,\n+            buf.as_ptr() as *const c_void,\n+            cmp::min(buf.len(), max_len()))\n+        })?;\n+        Ok(ret as usize)\n+    }\n+\n+    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        let ret = cvt(unsafe {\n+            libc::writev(self.fd,\n+                         bufs.as_ptr() as *const libc::iovec,\n+                         cmp::min(bufs.len(), c_int::max_value() as usize) as c_int)\n+        })?;\n+        Ok(ret as usize)\n+    }\n+\n+    pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {\n+        unsafe fn cvt_pwrite(fd: c_int, buf: *const c_void, count: usize, offset: i64)\n+            -> io::Result<isize>\n+        {\n+            use libc::pwrite;\n+            cvt(pwrite(fd, buf, count, offset))\n+        }\n+\n+        unsafe {\n+            cvt_pwrite(self.fd,\n+                buf.as_ptr() as *const c_void,\n+                cmp::min(buf.len(), max_len()),\n+                offset as i64)\n+                .map(|n| n as usize)\n+        }\n+    }\n+\n+    pub fn get_cloexec(&self) -> io::Result<bool> {\n+        unsafe {\n+            Ok((cvt(libc::fcntl(self.fd, libc::F_GETFD))? & libc::FD_CLOEXEC) != 0)\n+        }\n+    }\n+\n+    pub fn set_cloexec(&self) -> io::Result<()> {\n+        unsafe {\n+            let previous = cvt(libc::fcntl(self.fd, libc::F_GETFD))?;\n+            let new = previous | libc::FD_CLOEXEC;\n+            if new != previous {\n+                cvt(libc::fcntl(self.fd, libc::F_SETFD, new))?;\n+            }\n+            Ok(())\n+        }\n+    }\n+\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        unsafe {\n+            let v = nonblocking as c_int;\n+            cvt(libc::ioctl(self.fd, libc::FIONBIO, &v))?;\n+            Ok(())\n+        }\n+    }\n+\n+    // refer to pxPipeDrv library documentation.\n+    // VxWorks uses fcntl to set O_NONBLOCK to the pipes\n+    pub fn set_nonblocking_pipe(&self, nonblocking: bool) -> io::Result<()> {\n+        unsafe {\n+            let mut flags = cvt(libc::fcntl(self.fd, libc::F_GETFL, 0))?;\n+            flags = if nonblocking {\n+                flags | libc::O_NONBLOCK\n+            } else {\n+                flags & !libc::O_NONBLOCK\n+            };\n+            cvt(libc::fcntl(self.fd, libc::F_SETFL, flags))?;\n+            Ok(())\n+        }\n+    }\n+\n+\n+    pub fn duplicate(&self) -> io::Result<FileDesc> {\n+        let fd = self.raw();\n+        match cvt(unsafe { libc::fcntl(fd, libc::F_DUPFD_CLOEXEC, 0) }) {\n+            Ok(newfd) => {\n+                Ok(FileDesc::new(newfd))\n+            }\n+            Err(e) => return Err(e),\n+        }\n+    }\n+}\n+\n+impl<'a> Read for &'a FileDesc {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        (**self).read(buf)\n+    }\n+\n+    #[inline]\n+    unsafe fn initializer(&self) -> Initializer {\n+        Initializer::nop()\n+    }\n+}\n+\n+impl AsInner<c_int> for FileDesc {\n+    fn as_inner(&self) -> &c_int { &self.fd }\n+}\n+\n+impl Drop for FileDesc {\n+    fn drop(&mut self) {\n+        // Note that errors are ignored when closing a file descriptor. The\n+        // reason for this is that if an error occurs we don't actually know if\n+        // the file descriptor was closed or not, and if we retried (for\n+        // something like EINTR), we might close another valid file descriptor\n+        // (opened after we closed ours.\n+        let _ = unsafe { libc::close(self.fd) };\n+    }\n+}"}, {"sha": "4eb185c4d57ac439a8c3b90c7ce55448700e91a1", "filename": "src/libstd/sys/vxworks/fs.rs", "status": "added", "additions": 590, "deletions": 0, "changes": 590, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Ffs.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,590 @@\n+// copies from linuxx\n+use crate::ffi::{CString, CStr, OsString, OsStr};\n+use crate::sys::vxworks::ext::ffi::OsStrExt;\n+use crate::fmt;\n+use crate::io::{self, Error, ErrorKind, SeekFrom, IoSlice, IoSliceMut};\n+use crate::mem;\n+use crate::path::{Path, PathBuf};\n+use crate::ptr;\n+use crate::sync::Arc;\n+use crate::sys::fd::FileDesc;\n+use crate::sys::time::SystemTime;\n+use crate::sys::{cvt, cvt_r};\n+use crate::sys_common::{AsInner, FromInner};\n+use libc::{self, c_int, mode_t, stat64, off_t};\n+use libc::{ftruncate, lseek, dirent, readdir_r as readdir64_r, open};\n+use crate::sys::vxworks::ext::ffi::OsStringExt;\n+pub struct File(FileDesc);\n+\n+#[derive(Clone)]\n+pub struct FileAttr {\n+    stat: stat64,\n+}\n+\n+// all DirEntry's will have a reference to this struct\n+struct InnerReadDir {\n+    dirp: Dir,\n+    root: PathBuf,\n+}\n+\n+#[derive(Clone)]\n+pub struct ReadDir {\n+    inner: Arc<InnerReadDir>,\n+    end_of_stream: bool,\n+}\n+\n+struct Dir(*mut libc::DIR);\n+\n+unsafe impl Send for Dir {}\n+unsafe impl Sync for Dir {}\n+\n+pub struct DirEntry {\n+    entry: dirent,\n+    dir: ReadDir,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct OpenOptions {\n+    // generic\n+    read: bool,\n+    write: bool,\n+    append: bool,\n+    truncate: bool,\n+    create: bool,\n+    create_new: bool,\n+    // system-specific\n+    custom_flags: i32,\n+    mode: mode_t,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct FilePermissions { mode: mode_t }\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct FileType { mode: mode_t }\n+\n+#[derive(Debug)]\n+pub struct DirBuilder { mode: mode_t }\n+\n+impl FileAttr {\n+    pub fn size(&self) -> u64 { self.stat.st_size as u64 }\n+    pub fn perm(&self) -> FilePermissions {\n+        FilePermissions { mode: (self.stat.st_mode as mode_t) }\n+    }\n+\n+    pub fn file_type(&self) -> FileType {\n+        FileType { mode: self.stat.st_mode as mode_t }\n+    }\n+\n+    pub fn modified(&self) -> io::Result<SystemTime> {\n+        Ok(SystemTime::from(libc::timespec {\n+            tv_sec: self.stat.st_mtime as libc::time_t,\n+            tv_nsec: 0, // hack 2.0;\n+        }))\n+    }\n+\n+    pub fn accessed(&self) -> io::Result<SystemTime> {\n+        Ok(SystemTime::from(libc::timespec {\n+        tv_sec: self.stat.st_atime as libc::time_t,\n+        tv_nsec: 0, // hack - a proper fix would be better\n+        }))\n+    }\n+\n+    pub fn created(&self) -> io::Result<SystemTime> {\n+        Err(io::Error::new(io::ErrorKind::Other,\n+                           \"creation time is not available on this platform currently\"))\n+    }\n+\n+}\n+\n+impl AsInner<stat64> for FileAttr {\n+    fn as_inner(&self) -> &stat64 { &self.stat }\n+}\n+\n+impl FilePermissions {\n+    pub fn readonly(&self) -> bool {\n+        // check if any class (owner, group, others) has write permission\n+        self.mode & 0o222 == 0\n+    }\n+\n+    pub fn set_readonly(&mut self, readonly: bool) {\n+        if readonly {\n+            // remove write permission for all classes; equivalent to `chmod a-w <file>`\n+            self.mode &= !0o222;\n+        } else {\n+            // add write permission for all classes; equivalent to `chmod a+w <file>`\n+            self.mode |= 0o222;\n+        }\n+    }\n+    pub fn mode(&self) -> u32 { self.mode as u32 }\n+}\n+\n+impl FileType {\n+    pub fn is_dir(&self) -> bool { self.is(libc::S_IFDIR) }\n+    pub fn is_file(&self) -> bool { self.is(libc::S_IFREG) }\n+    pub fn is_symlink(&self) -> bool { self.is(libc::S_IFLNK) }\n+\n+    pub fn is(&self, mode: mode_t) -> bool { self.mode & libc::S_IFMT == mode }\n+}\n+\n+impl FromInner<u32> for FilePermissions {\n+    fn from_inner(mode: u32) -> FilePermissions {\n+        FilePermissions { mode: mode as mode_t }\n+    }\n+}\n+\n+impl fmt::Debug for ReadDir {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // This will only be called from std::fs::ReadDir, which will add a \"ReadDir()\" frame.\n+        // Thus the result will be e g 'ReadDir(\"/home\")'\n+        fmt::Debug::fmt(&*self.inner.root, f)\n+    }\n+}\n+\n+impl Iterator for ReadDir {\n+    type Item = io::Result<DirEntry>;\n+    fn next(&mut self) -> Option<io::Result<DirEntry>> {\n+        if self.end_of_stream {\n+            return None;\n+        }\n+\n+        unsafe {\n+            let mut ret = DirEntry {\n+                entry: mem::zeroed(),\n+                dir: self.clone(),\n+            };\n+            let mut entry_ptr = ptr::null_mut();\n+            loop {\n+                if readdir64_r(self.inner.dirp.0, &mut ret.entry, &mut entry_ptr) != 0 {\n+                    if entry_ptr.is_null() {\n+                        // We encountered an error (which will be returned in this iteration), but\n+                        // we also reached the end of the directory stream. The `end_of_stream`\n+                        // flag is enabled to make sure that we return `None` in the next iteration\n+                        // (instead of looping forever)\n+                        self.end_of_stream = true;\n+                    }\n+                    return Some(Err(Error::last_os_error()))\n+                }\n+                if entry_ptr.is_null() {\n+                    return None\n+                }\n+                if ret.name_bytes() != b\".\" && ret.name_bytes() != b\"..\" {\n+                    return Some(Ok(ret))\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl Drop for Dir {\n+    fn drop(&mut self) {\n+        let r = unsafe { libc::closedir(self.0) };\n+        debug_assert_eq!(r, 0);\n+    }\n+}\n+\n+impl DirEntry {\n+    pub fn path(&self) -> PathBuf {\n+            use crate::sys::vxworks::ext::ffi::OsStrExt;\n+            self.dir.inner.root.join(OsStr::from_bytes(self.name_bytes()))\n+    }\n+\n+    pub fn file_name(&self) -> OsString {\n+        OsStr::from_bytes(self.name_bytes()).to_os_string()\n+    }\n+\n+\n+    pub fn metadata(&self) -> io::Result<FileAttr> {\n+        lstat(&self.path())\n+    }\n+\n+    pub fn file_type(&self) -> io::Result<FileType> {\n+        lstat(&self.path()).map(|m| m.file_type())\n+\n+    }\n+\n+    pub fn ino(&self) -> u64 {\n+        self.entry.d_ino as u64\n+    }\n+\n+    fn name_bytes(&self) -> &[u8] {\n+        unsafe {\n+            //&*self.name\n+            CStr::from_ptr(self.entry.d_name.as_ptr()).to_bytes()\n+        }\n+    }\n+}\n+\n+impl OpenOptions {\n+    pub fn new() -> OpenOptions {\n+        OpenOptions {\n+            // generic\n+            read: false,\n+            write: false,\n+            append: false,\n+            truncate: false,\n+            create: false,\n+            create_new: false,\n+            // system-specific\n+            custom_flags: 0,\n+            mode: 0o666,\n+        }\n+    }\n+\n+    pub fn read(&mut self, read: bool) { self.read = read; }\n+    pub fn write(&mut self, write: bool) { self.write = write; }\n+    pub fn append(&mut self, append: bool) { self.append = append; }\n+    pub fn truncate(&mut self, truncate: bool) { self.truncate = truncate; }\n+    pub fn create(&mut self, create: bool) { self.create = create; }\n+    pub fn create_new(&mut self, create_new: bool) { self.create_new = create_new; }\n+    pub fn mode(&mut self, mode: u32) { self.mode = mode as mode_t; }\n+\n+    fn get_access_mode(&self) -> io::Result<c_int> {\n+        match (self.read, self.write, self.append) {\n+            (true,  false, false) => Ok(libc::O_RDONLY),\n+            (false, true,  false) => Ok(libc::O_WRONLY),\n+            (true,  true,  false) => Ok(libc::O_RDWR),\n+            (false, _,     true)  => Ok(libc::O_WRONLY | libc::O_APPEND),\n+            (true,  _,     true)  => Ok(libc::O_RDWR | libc::O_APPEND),\n+            (false, false, false) => Err(Error::from_raw_os_error(libc::EINVAL)),\n+        }\n+    }\n+\n+    fn get_creation_mode(&self) -> io::Result<c_int> {\n+        match (self.write, self.append) {\n+            (true, false) => {}\n+            (false, false) =>\n+                if self.truncate || self.create || self.create_new {\n+                    return Err(Error::from_raw_os_error(libc::EINVAL));\n+                },\n+            (_, true) =>\n+                if self.truncate && !self.create_new {\n+                    return Err(Error::from_raw_os_error(libc::EINVAL));\n+                },\n+        }\n+\n+        Ok(match (self.create, self.truncate, self.create_new) {\n+                (false, false, false) => 0,\n+                (true,  false, false) => libc::O_CREAT,\n+                (false, true,  false) => libc::O_TRUNC,\n+                (true,  true,  false) => libc::O_CREAT | libc::O_TRUNC,\n+                (_,      _,    true)  => libc::O_CREAT | libc::O_EXCL,\n+           })\n+    }\n+}\n+\n+impl File {\n+    pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n+        let path = cstr(path)?;\n+        File::open_c(&path, opts)\n+    }\n+\n+    pub fn open_c(path: &CStr, opts: &OpenOptions) -> io::Result<File> {\n+        let flags = libc::O_CLOEXEC |\n+                opts.get_access_mode()? |\n+                opts.get_creation_mode()? |\n+                (opts.custom_flags as c_int & !libc::O_ACCMODE);\n+        let fd = cvt_r(|| unsafe {\n+            open(path.as_ptr(), flags, opts.mode as c_int)\n+        })?;\n+        let fd = FileDesc::new(fd);\n+        // Currently the standard library supports Linux 2.6.18 which did not\n+        // have the O_CLOEXEC flag (passed above). If we're running on an older\n+        // Linux kernel then the flag is just ignored by the OS. After we open\n+        // the first file, we check whether it has CLOEXEC set. If it doesn't,\n+        // we will explicitly ask for a CLOEXEC fd for every further file we\n+        // open, if it does, we will skip that step.\n+        //\n+        // The CLOEXEC flag, however, is supported on versions of macOS/BSD/etc\n+        // that we support, so we only do this on Linux currently.\n+        fn ensure_cloexec(_: &FileDesc) -> io::Result<()> {\n+            Ok(())\n+        }\n+\n+        ensure_cloexec(&fd)?;\n+        Ok(File(fd))\n+    }\n+\n+    pub fn file_attr(&self) -> io::Result<FileAttr> {\n+        let mut stat: stat64 = unsafe { mem::zeroed() };\n+        cvt(unsafe {\n+            ::libc::fstat(self.0.raw(), &mut stat)\n+        })?;\n+        Ok(FileAttr { stat: stat })\n+    }\n+\n+    pub fn fsync(&self) -> io::Result<()> {\n+        cvt_r(|| unsafe { libc::fsync(self.0.raw()) })?;\n+        Ok(())\n+    }\n+\n+    pub fn datasync(&self) -> io::Result<()> {\n+        cvt_r(|| unsafe { os_datasync(self.0.raw()) })?;\n+        return Ok(());\n+        unsafe fn os_datasync(fd: c_int) -> c_int { libc::fsync(fd) } //not supported\n+    }\n+\n+    pub fn truncate(&self, size: u64) -> io::Result<()> {\n+        return cvt_r(|| unsafe {\n+            ftruncate(self.0.raw(), size as off_t)\n+        }).map(|_| ());\n+    }\n+\n+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.read(buf)\n+    }\n+\n+    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n+        self.0.read_vectored(bufs)\n+    }\n+\n+    pub fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {\n+        self.0.read_at(buf, offset)\n+    }\n+\n+    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n+        self.0.write(buf)\n+    }\n+\n+    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        self.0.write_vectored(bufs)\n+    }\n+\n+    pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {\n+        self.0.write_at(buf, offset)\n+    }\n+\n+    pub fn flush(&self) -> io::Result<()> { Ok(()) }\n+\n+    pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> {\n+        let (whence, pos) = match pos {\n+            // Casting to `i64` is fine, too large values will end up as\n+            // negative which will cause an error in `\"lseek64\"`.\n+            SeekFrom::Start(off) => (libc::SEEK_SET, off as i64),\n+            SeekFrom::End(off) => (libc::SEEK_END, off),\n+            SeekFrom::Current(off) => (libc::SEEK_CUR, off),\n+        };\n+        let n = cvt(unsafe { lseek(self.0.raw(), pos, whence) })?;\n+        Ok(n as u64)\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<File> {\n+        self.0.duplicate().map(File)\n+    }\n+\n+    pub fn fd(&self) -> &FileDesc { &self.0 }\n+\n+    pub fn into_fd(self) -> FileDesc { self.0 }\n+\n+    pub fn set_permissions(&self, perm: FilePermissions) -> io::Result<()> {\n+        cvt_r(|| unsafe { libc::fchmod(self.0.raw(), perm.mode) })?;\n+        Ok(())\n+    }\n+\n+    pub fn diverge(&self) -> ! {\n+        panic!()\n+    }\n+}\n+\n+impl DirBuilder {\n+    pub fn new() -> DirBuilder {\n+        DirBuilder { mode: 0o777 }\n+    }\n+\n+    pub fn mkdir(&self, p: &Path) -> io::Result<()> {\n+        let p = cstr(p)?;\n+        cvt(unsafe { libc::mkdir(p.as_ptr(), self.mode) })?;\n+        Ok(())\n+    }\n+\n+    pub fn set_mode(&mut self, mode: u32) {\n+        self.mode = mode as mode_t;\n+    }\n+}\n+\n+fn cstr(path: &Path) -> io::Result<CString> {\n+    use crate::sys::vxworks::ext::ffi::OsStrExt;\n+    Ok(CString::new(path.as_os_str().as_bytes())?)\n+}\n+\n+impl FromInner<c_int> for File {\n+    fn from_inner(fd: c_int) -> File {\n+        File(FileDesc::new(fd))\n+    }\n+}\n+\n+impl fmt::Debug for File {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fn get_path(_fd: c_int) -> Option<PathBuf> {\n+            // FIXME(#:(): implement this for VxWorks\n+            None\n+        }\n+        fn get_mode(_fd: c_int) -> Option<(bool, bool)> {\n+            // FIXME(#:(): implement this for VxWorks\n+            None\n+        }\n+\n+        let fd = self.0.raw();\n+        let mut b = f.debug_struct(\"File\");\n+        b.field(\"fd\", &fd);\n+        if let Some(path) = get_path(fd) {\n+            b.field(\"path\", &path);\n+        }\n+        if let Some((read, write)) = get_mode(fd) {\n+            b.field(\"read\", &read).field(\"write\", &write);\n+        }\n+        b.finish()\n+    }\n+}\n+\n+pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n+    let root = p.to_path_buf();\n+    let p = cstr(p)?;\n+    unsafe {\n+        let ptr = libc::opendir(p.as_ptr());\n+        if ptr.is_null() {\n+            Err(Error::last_os_error())\n+        } else {\n+            let inner = InnerReadDir { dirp: Dir(ptr), root };\n+            Ok(ReadDir{\n+                inner: Arc::new(inner),\n+                end_of_stream: false,\n+            })\n+        }\n+    }\n+}\n+\n+pub fn unlink(p: &Path) -> io::Result<()> {\n+    let p = cstr(p)?;\n+    cvt(unsafe { libc::unlink(p.as_ptr()) })?;\n+    Ok(())\n+}\n+\n+pub fn rename(old: &Path, new: &Path) -> io::Result<()> {\n+    let old = cstr(old)?;\n+    let new = cstr(new)?;\n+    cvt(unsafe { libc::rename(old.as_ptr(), new.as_ptr()) })?;\n+    Ok(())\n+}\n+\n+pub fn set_perm(p: &Path, perm: FilePermissions) -> io::Result<()> {\n+    let p = cstr(p)?;\n+    cvt_r(|| unsafe { libc::chmod(p.as_ptr(), perm.mode) })?;\n+    Ok(())\n+}\n+\n+pub fn rmdir(p: &Path) -> io::Result<()> {\n+    let p = cstr(p)?;\n+    cvt(unsafe { libc::rmdir(p.as_ptr()) })?;\n+    Ok(())\n+}\n+\n+pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n+    let filetype = lstat(path)?.file_type();\n+    if filetype.is_symlink() {\n+        unlink(path)\n+    } else {\n+        remove_dir_all_recursive(path)\n+    }\n+}\n+\n+fn remove_dir_all_recursive(path: &Path) -> io::Result<()> {\n+    for child in readdir(path)? {\n+        let child = child?;\n+        if child.file_type()?.is_dir() {\n+            remove_dir_all_recursive(&child.path())?;\n+        } else {\n+            unlink(&child.path())?;\n+        }\n+    }\n+    rmdir(path)\n+}\n+\n+pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n+    let c_path = cstr(p)?;\n+    let p = c_path.as_ptr();\n+\n+    let mut buf = Vec::with_capacity(256);\n+\n+    loop {\n+        let buf_read = cvt(unsafe {\n+            libc::readlink(p, buf.as_mut_ptr() as *mut _, buf.capacity())\n+        })? as usize;\n+\n+        unsafe { buf.set_len(buf_read); }\n+\n+        if buf_read != buf.capacity() {\n+            buf.shrink_to_fit();\n+\n+            return Ok(PathBuf::from(OsString::from_vec(buf)));\n+        }\n+\n+        // Trigger the internal buffer resizing logic of `Vec` by requiring\n+        // more space than the current capacity. The length is guaranteed to be\n+        // the same as the capacity due to the if statement above.\n+        buf.reserve(1);\n+    }\n+}\n+\n+pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> {\n+    let src = cstr(src)?;\n+    let dst = cstr(dst)?;\n+    cvt(unsafe { libc::symlink(src.as_ptr(), dst.as_ptr()) })?;\n+    Ok(())\n+}\n+\n+pub fn link(src: &Path, dst: &Path) -> io::Result<()> {\n+    let src = cstr(src)?;\n+    let dst = cstr(dst)?;\n+    cvt(unsafe { libc::link(src.as_ptr(), dst.as_ptr()) })?;\n+    Ok(())\n+}\n+\n+pub fn stat(p: &Path) -> io::Result<FileAttr> {\n+    let p = cstr(p)?;\n+    let mut stat: stat64 = unsafe { mem::zeroed() };\n+    cvt(unsafe {\n+        libc::lstat(p.as_ptr(), &mut stat as *mut _ as *mut _)\n+    })?;\n+    Ok(FileAttr { stat })\n+}\n+\n+pub fn lstat(p: &Path) -> io::Result<FileAttr> {\n+    let p = cstr(p)?;\n+    let mut stat: stat64 = unsafe { mem::zeroed() };\n+    cvt(unsafe {\n+        ::libc::lstat(p.as_ptr(), &mut stat as *mut _ as *mut _)\n+    })?;\n+    Ok(FileAttr { stat })\n+}\n+\n+pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n+    use crate::sys::vxworks::ext::ffi::OsStrExt;\n+    let path = CString::new(p.as_os_str().as_bytes())?;\n+    let buf;\n+    unsafe {\n+        let r = libc::realpath(path.as_ptr(), ptr::null_mut());\n+        if r.is_null() {\n+            return Err(io::Error::last_os_error())\n+        }\n+        buf = CStr::from_ptr(r).to_bytes().to_vec();\n+        libc::free(r as *mut _);\n+    }\n+    Ok(PathBuf::from(OsString::from_vec(buf)))\n+}\n+\n+pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n+    use crate::fs::File;\n+    if !from.is_file() {\n+        return Err(Error::new(ErrorKind::InvalidInput,\n+                              \"the source path is not an existing regular file\"))\n+    }\n+\n+    let mut reader = File::open(from)?;\n+    let mut writer = File::create(to)?;\n+    let perm = reader.metadata()?.permissions();\n+\n+    let ret = io::copy(&mut reader, &mut writer)?;\n+    writer.set_permissions(perm)?;\n+    Ok(ret)\n+}"}, {"sha": "72954ff20ef95a230d162547de74d62c41c63957", "filename": "src/libstd/sys/vxworks/io.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fio.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,62 @@\n+use crate::marker::PhantomData;\n+use crate::slice;\n+\n+use libc::{iovec, c_void};\n+\n+#[repr(transparent)]\n+pub struct IoSlice<'a> {\n+    vec: iovec,\n+    _p: PhantomData<&'a [u8]>,\n+}\n+\n+impl<'a> IoSlice<'a> {\n+    #[inline]\n+    pub fn new(buf: &'a [u8]) -> IoSlice<'a> {\n+        IoSlice {\n+            vec: iovec {\n+                iov_base: buf.as_ptr() as *mut u8 as *mut c_void,\n+                iov_len: buf.len()\n+            },\n+            _p: PhantomData,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &[u8] {\n+        unsafe {\n+            slice::from_raw_parts(self.vec.iov_base as *mut u8, self.vec.iov_len)\n+        }\n+    }\n+}\n+\n+pub struct IoSliceMut<'a> {\n+    vec: iovec,\n+    _p: PhantomData<&'a mut [u8]>,\n+}\n+\n+impl<'a> IoSliceMut<'a> {\n+    #[inline]\n+    pub fn new(buf: &'a mut [u8]) -> IoSliceMut<'a> {\n+        IoSliceMut {\n+            vec: iovec {\n+                iov_base: buf.as_mut_ptr() as *mut c_void,\n+                iov_len: buf.len()\n+            },\n+            _p: PhantomData,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &[u8] {\n+        unsafe {\n+            slice::from_raw_parts(self.vec.iov_base as *mut u8, self.vec.iov_len)\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn as_mut_slice(&mut self) -> &mut [u8] {\n+        unsafe {\n+            slice::from_raw_parts_mut(self.vec.iov_base as *mut u8, self.vec.iov_len)\n+        }\n+    }\n+}"}, {"sha": "b3dd1cf6aaac7b8620ba75c26155810e1929adf7", "filename": "src/libstd/sys/vxworks/l4re.rs", "status": "added", "additions": 469, "deletions": 0, "changes": 469, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fl4re.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fl4re.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fl4re.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,469 @@\n+macro_rules! unimpl {\n+    () => (return Err(io::Error::new(io::ErrorKind::Other, \"No networking available on L4Re.\"));)\n+}\n+\n+pub mod net {\n+    #![allow(warnings)]\n+    use crate::fmt;\n+    use crate::io::{self, IoVec, IoVecMut};\n+    use crate::net::{SocketAddr, Shutdown, Ipv4Addr, Ipv6Addr};\n+    use crate::sys_common::{AsInner, FromInner, IntoInner};\n+    use crate::sys::fd::FileDesc;\n+    use crate::time::Duration;\n+    use crate::convert::TryFrom;\n+\n+    #[allow(unused_extern_crates)]\n+    pub extern crate libc as netc;\n+\n+    pub struct Socket(FileDesc);\n+    impl Socket {\n+        pub fn new(_: &SocketAddr, _: libc::c_int) -> io::Result<Socket> {\n+            unimpl!();\n+        }\n+\n+        pub fn new_raw(_: libc::c_int, _: libc::c_int) -> io::Result<Socket> {\n+            unimpl!();\n+        }\n+\n+        pub fn new_pair(_: libc::c_int, _: libc::c_int) -> io::Result<(Socket, Socket)> {\n+            unimpl!();\n+        }\n+\n+        pub fn connect_timeout(&self, _: &SocketAddr, _: Duration) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn accept(&self, _: *mut libc::sockaddr, _: *mut libc::socklen_t)\n+                  -> io::Result<Socket> {\n+            unimpl!();\n+        }\n+\n+        pub fn duplicate(&self) -> io::Result<Socket> {\n+            unimpl!();\n+        }\n+\n+        pub fn read(&self, _: &mut [u8]) -> io::Result<usize> {\n+            unimpl!();\n+        }\n+\n+        pub fn read_vectored(&self, _: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+            unimpl!();\n+        }\n+\n+        pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n+            unimpl!();\n+        }\n+\n+        pub fn recv_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+            unimpl!();\n+        }\n+\n+        pub fn peek_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+            unimpl!();\n+        }\n+\n+        pub fn write(&self, _: &[u8]) -> io::Result<usize> {\n+            unimpl!();\n+        }\n+\n+        pub fn write_vectored(&self, _: &[IoVec<'_>]) -> io::Result<usize> {\n+            unimpl!();\n+        }\n+\n+        pub fn set_timeout(&self, _: Option<Duration>, _: libc::c_int) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn timeout(&self, _: libc::c_int) -> io::Result<Option<Duration>> {\n+            unimpl!();\n+        }\n+\n+        pub fn shutdown(&self, _: Shutdown) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn set_nodelay(&self, _: bool) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn nodelay(&self) -> io::Result<bool> {\n+            unimpl!();\n+        }\n+\n+        pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+            unimpl!();\n+        }\n+    }\n+\n+    impl AsInner<libc::c_int> for Socket {\n+        fn as_inner(&self) -> &libc::c_int { self.0.as_inner() }\n+    }\n+\n+    impl FromInner<libc::c_int> for Socket {\n+        fn from_inner(fd: libc::c_int) -> Socket { Socket(FileDesc::new(fd)) }\n+    }\n+\n+    impl IntoInner<libc::c_int> for Socket {\n+        fn into_inner(self) -> libc::c_int { self.0.into_raw() }\n+    }\n+\n+    pub struct TcpStream {\n+        inner: Socket,\n+    }\n+\n+    impl TcpStream {\n+        pub fn connect(_: io::Result<&SocketAddr>) -> io::Result<TcpStream> {\n+            unimpl!();\n+        }\n+\n+        pub fn connect_timeout(_: &SocketAddr, _: Duration) -> io::Result<TcpStream> {\n+            unimpl!();\n+        }\n+\n+        pub fn socket(&self) -> &Socket { &self.inner }\n+\n+        pub fn into_socket(self) -> Socket { self.inner }\n+\n+        pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n+            unimpl!();\n+        }\n+\n+        pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n+            unimpl!();\n+        }\n+\n+        pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n+            unimpl!();\n+        }\n+\n+        pub fn read(&self, _: &mut [u8]) -> io::Result<usize> {\n+            unimpl!();\n+        }\n+\n+        pub fn read_vectored(&self, _: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+            unimpl!();\n+        }\n+\n+        pub fn write(&self, _: &[u8]) -> io::Result<usize> {\n+            unimpl!();\n+        }\n+\n+        pub fn write_vectored(&self, _: &[IoVec<'_>]) -> io::Result<usize> {\n+            unimpl!();\n+        }\n+\n+        pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n+            unimpl!();\n+        }\n+\n+        pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+            unimpl!();\n+        }\n+\n+        pub fn shutdown(&self, _: Shutdown) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn duplicate(&self) -> io::Result<TcpStream> {\n+            unimpl!();\n+        }\n+\n+        pub fn set_nodelay(&self, _: bool) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn nodelay(&self) -> io::Result<bool> {\n+            unimpl!();\n+        }\n+\n+        pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn ttl(&self) -> io::Result<u32> {\n+            unimpl!();\n+        }\n+\n+        pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+            unimpl!();\n+        }\n+\n+        pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n+            unimpl!();\n+        }\n+    }\n+\n+    impl FromInner<Socket> for TcpStream {\n+        fn from_inner(socket: Socket) -> TcpStream {\n+            TcpStream { inner: socket }\n+        }\n+    }\n+\n+    impl fmt::Debug for TcpStream {\n+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+            write!(f, \"No networking support available on L4Re\")\n+        }\n+    }\n+\n+    pub struct TcpListener {\n+        inner: Socket,\n+    }\n+\n+    impl TcpListener {\n+        pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<TcpListener> {\n+            unimpl!();\n+        }\n+\n+        pub fn socket(&self) -> &Socket { &self.inner }\n+\n+        pub fn into_socket(self) -> Socket { self.inner }\n+\n+        pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+            unimpl!();\n+        }\n+\n+        pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n+            unimpl!();\n+        }\n+\n+        pub fn duplicate(&self) -> io::Result<TcpListener> {\n+            unimpl!();\n+        }\n+\n+        pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn ttl(&self) -> io::Result<u32> {\n+            unimpl!();\n+        }\n+\n+        pub fn set_only_v6(&self, _: bool) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn only_v6(&self) -> io::Result<bool> {\n+            unimpl!();\n+        }\n+\n+        pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+            unimpl!();\n+        }\n+\n+        pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n+            unimpl!();\n+        }\n+    }\n+\n+    impl FromInner<Socket> for TcpListener {\n+        fn from_inner(socket: Socket) -> TcpListener {\n+            TcpListener { inner: socket }\n+        }\n+    }\n+\n+    impl fmt::Debug for TcpListener {\n+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+            write!(f, \"No networking support available on L4Re.\")\n+        }\n+    }\n+\n+    pub struct UdpSocket {\n+        inner: Socket,\n+    }\n+\n+    impl UdpSocket {\n+        pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<UdpSocket> {\n+            unimpl!();\n+        }\n+\n+        pub fn socket(&self) -> &Socket { &self.inner }\n+\n+        pub fn into_socket(self) -> Socket { self.inner }\n+\n+        pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n+            unimpl!();\n+        }\n+\n+        pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+            unimpl!();\n+        }\n+\n+        pub fn recv_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+            unimpl!();\n+        }\n+\n+        pub fn peek_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+            unimpl!();\n+        }\n+\n+        pub fn send_to(&self, _: &[u8], _: &SocketAddr) -> io::Result<usize> {\n+            unimpl!();\n+        }\n+\n+        pub fn duplicate(&self) -> io::Result<UdpSocket> {\n+            unimpl!();\n+        }\n+\n+        pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n+            unimpl!();\n+        }\n+\n+        pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n+            unimpl!();\n+        }\n+\n+        pub fn set_broadcast(&self, _: bool) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn broadcast(&self) -> io::Result<bool> {\n+            unimpl!();\n+        }\n+\n+        pub fn set_multicast_loop_v4(&self, _: bool) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n+            unimpl!();\n+        }\n+\n+        pub fn set_multicast_ttl_v4(&self, _: u32) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n+            unimpl!();\n+        }\n+\n+        pub fn set_multicast_loop_v6(&self, _: bool) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn multicast_loop_v6(&self) -> io::Result<bool> {\n+            unimpl!();\n+        }\n+\n+        pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr)\n+                             -> io::Result<()> {\n+                                 unimpl!();\n+        }\n+\n+        pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32)\n+                             -> io::Result<()> {\n+                                 unimpl!();\n+        }\n+\n+        pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr)\n+                              -> io::Result<()> {\n+                                  unimpl!();\n+        }\n+\n+        pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32)\n+                              -> io::Result<()> {\n+                                  unimpl!();\n+        }\n+\n+        pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn ttl(&self) -> io::Result<u32> {\n+            unimpl!();\n+        }\n+\n+        pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+            unimpl!();\n+        }\n+\n+        pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn recv(&self, _: &mut [u8]) -> io::Result<usize> {\n+            unimpl!();\n+        }\n+\n+        pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n+            unimpl!();\n+        }\n+\n+        pub fn send(&self, _: &[u8]) -> io::Result<usize> {\n+            unimpl!();\n+        }\n+\n+        pub fn connect(&self, _: io::Result<&SocketAddr>) -> io::Result<()> {\n+            unimpl!();\n+        }\n+    }\n+\n+    impl FromInner<Socket> for UdpSocket {\n+        fn from_inner(socket: Socket) -> UdpSocket {\n+            UdpSocket { inner: socket }\n+        }\n+    }\n+\n+    impl fmt::Debug for UdpSocket {\n+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+            write!(f, \"No networking support on L4Re available.\")\n+        }\n+    }\n+\n+    pub struct LookupHost {\n+        original: *mut libc::addrinfo,\n+        cur: *mut libc::addrinfo,\n+    }\n+\n+    impl Iterator for LookupHost {\n+        type Item = SocketAddr;\n+        fn next(&mut self) -> Option<SocketAddr> {\n+            None\n+        }\n+    }\n+\n+    impl LookupHost {\n+        pub fn port(&self) -> u16 {\n+            unimpl!();\n+        }\n+    }\n+\n+    unsafe impl Sync for LookupHost {}\n+    unsafe impl Send for LookupHost {}\n+\n+\n+    impl TryFrom<&str> for LookupHost {\n+        type Error = io::Error;\n+\n+        fn try_from(_v: &str) -> io::Result<LookupHost> {\n+            unimpl!();\n+        }\n+    }\n+\n+    impl<'a> TryFrom<(&'a str, u16)> for LookupHost {\n+        type Error = io::Error;\n+\n+        fn try_from(_v: (&'a str, u16)) -> io::Result<LookupHost> {\n+            unimpl!();\n+        }\n+    }\n+}"}, {"sha": "1984678bdde4e5d27c14db1db6a7bfd05a9e582b", "filename": "src/libstd/sys/vxworks/memchr.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fmemchr.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,43 @@\n+// Original implementation taken from rust-memchr.\n+// Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n+\n+pub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n+    let p = unsafe {\n+        libc::memchr(\n+            haystack.as_ptr() as *const libc::c_void,\n+            needle as libc::c_int,\n+            haystack.len())\n+    };\n+    if p.is_null() {\n+        None\n+    } else {\n+        Some(p as usize - (haystack.as_ptr() as usize))\n+    }\n+}\n+\n+pub fn memrchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n+\n+    #[cfg(target_os = \"linux\")]\n+    fn memrchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n+        // GNU's memrchr() will - unlike memchr() - error if haystack is empty.\n+        if haystack.is_empty() {return None}\n+        let p = unsafe {\n+            libc::memrchr(\n+                haystack.as_ptr() as *const libc::c_void,\n+                needle as libc::c_int,\n+                haystack.len())\n+        };\n+        if p.is_null() {\n+            None\n+        } else {\n+            Some(p as usize - (haystack.as_ptr() as usize))\n+        }\n+    }\n+\n+    #[cfg(not(target_os = \"linux\"))]\n+    fn memrchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n+        core::slice::memchr::memrchr(needle, haystack)\n+    }\n+\n+    memrchr_specific(needle, haystack)\n+}"}, {"sha": "b01bea03c1b529f689daad79e675304fc3ec5904", "filename": "src/libstd/sys/vxworks/mod.rs", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fmod.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,139 @@\n+#![allow(dead_code)]\n+#![allow(missing_docs, nonstandard_style)]\n+\n+use crate::io::ErrorKind;\n+\n+pub use crate::os::vxworks as platform;\n+pub use self::rand::hashmap_random_keys;\n+pub use libc::strlen;\n+\n+#[macro_use]\n+pub mod weak;\n+\n+pub mod alloc;\n+pub mod args;\n+pub mod android;\n+//#[cfg(feature = \"backtrace\")]\n+//pub mod backtrace;\n+pub mod cmath;\n+pub mod condvar;\n+pub mod env;\n+pub mod ext;\n+pub mod fast_thread_local;\n+pub mod fd;\n+pub mod fs;\n+pub mod memchr;\n+pub mod io;\n+pub mod mutex;\n+#[cfg(not(target_os = \"l4re\"))]\n+pub mod net;\n+#[cfg(target_os = \"l4re\")]\n+mod l4re;\n+#[cfg(target_os = \"l4re\")]\n+pub use self::l4re::net;\n+pub mod os;\n+pub mod path;\n+pub mod pipe;\n+pub mod process;\n+pub mod rand;\n+pub mod rwlock;\n+pub mod stack_overflow;\n+pub mod thread;\n+pub mod thread_local;\n+pub mod time;\n+pub mod stdio;\n+\n+pub use crate::sys_common::os_str_bytes as os_str;\n+\n+#[cfg(not(test))]\n+pub fn init() {\n+    // By default, some platforms will send a *signal* when an EPIPE error\n+    // would otherwise be delivered. This runtime doesn't install a SIGPIPE\n+    // handler, causing it to kill the program, which isn't exactly what we\n+    // want!\n+    //\n+    // Hence, we set SIGPIPE to ignore when the program starts up in order\n+    // to prevent this problem.\n+    unsafe {\n+        reset_sigpipe();\n+    }\n+\n+    unsafe fn reset_sigpipe() { }\n+}\n+\n+#[cfg(target_os = \"android\")]\n+pub use crate::sys::android::signal;\n+#[cfg(not(target_os = \"android\"))]\n+pub use libc::signal;\n+\n+pub fn decode_error_kind(errno: i32) -> ErrorKind {\n+    match errno as libc::c_int {\n+        libc::ECONNREFUSED => ErrorKind::ConnectionRefused,\n+        libc::ECONNRESET => ErrorKind::ConnectionReset,\n+        libc::EPERM | libc::EACCES => ErrorKind::PermissionDenied,\n+        libc::EPIPE => ErrorKind::BrokenPipe,\n+        libc::ENOTCONN => ErrorKind::NotConnected,\n+        libc::ECONNABORTED => ErrorKind::ConnectionAborted,\n+        libc::EADDRNOTAVAIL => ErrorKind::AddrNotAvailable,\n+        libc::EADDRINUSE => ErrorKind::AddrInUse,\n+        libc::ENOENT => ErrorKind::NotFound,\n+        libc::EINTR => ErrorKind::Interrupted,\n+        libc::EINVAL => ErrorKind::InvalidInput,\n+        libc::ETIMEDOUT => ErrorKind::TimedOut,\n+        libc::EEXIST => ErrorKind::AlreadyExists,\n+\n+        // These two constants can have the same value on some systems,\n+        // but different values on others, so we can't use a match\n+        // clause\n+        x if x == libc::EAGAIN || x == libc::EWOULDBLOCK =>\n+            ErrorKind::WouldBlock,\n+\n+        _ => ErrorKind::Other,\n+    }\n+}\n+\n+#[doc(hidden)]\n+pub trait IsMinusOne {\n+    fn is_minus_one(&self) -> bool;\n+}\n+\n+macro_rules! impl_is_minus_one {\n+    ($($t:ident)*) => ($(impl IsMinusOne for $t {\n+        fn is_minus_one(&self) -> bool {\n+            *self == -1\n+        }\n+    })*)\n+}\n+\n+impl_is_minus_one! { i8 i16 i32 i64 isize }\n+\n+pub fn cvt<T: IsMinusOne>(t: T) -> crate::io::Result<T> {\n+    if t.is_minus_one() {\n+        Err(crate::io::Error::last_os_error())\n+    } else {\n+        Ok(t)\n+    }\n+}\n+\n+pub fn cvt_r<T, F>(mut f: F) -> crate::io::Result<T>\n+    where T: IsMinusOne,\n+          F: FnMut() -> T\n+{\n+    loop {\n+        match cvt(f()) {\n+            Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n+            other => return other,\n+        }\n+    }\n+}\n+\n+// On Unix-like platforms, libc::abort will unregister signal handlers\n+// including the SIGABRT handler, preventing the abort from being blocked, and\n+// fclose streams, with the side effect of flushing them so libc bufferred\n+// output will be printed.  Additionally the shell will generally print a more\n+// understandable error message like \"Abort trap\" rather than \"Illegal\n+// instruction\" that intrinsics::abort would cause, as intrinsics::abort is\n+// implemented as an illegal instruction.\n+pub unsafe fn abort_internal() -> ! {\n+    libc::abort()\n+}"}, {"sha": "b43af8fdcaaa12ed392c2b3679464772a53104e6", "filename": "src/libstd/sys/vxworks/mutex.rs", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fmutex.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,127 @@\n+use crate::cell::UnsafeCell;\n+use crate::mem::MaybeUninit;\n+\n+pub struct Mutex { inner: UnsafeCell<libc::pthread_mutex_t> }\n+\n+#[inline]\n+pub unsafe fn raw(m: &Mutex) -> *mut libc::pthread_mutex_t {\n+    m.inner.get()\n+}\n+\n+unsafe impl Send for Mutex {}\n+unsafe impl Sync for Mutex {}\n+\n+#[allow(dead_code)] // sys isn't exported yet\n+impl Mutex {\n+    pub const fn new() -> Mutex {\n+        // Might be moved to a different address, so it is better to avoid\n+        // initialization of potentially opaque OS data before it landed.\n+        // Be very careful using this newly constructed `Mutex`, reentrant\n+        // locking is undefined behavior until `init` is called!\n+        Mutex { inner: UnsafeCell::new(libc::PTHREAD_MUTEX_INITIALIZER) }\n+    }\n+    #[inline]\n+    pub unsafe fn init(&mut self) {\n+        // Issue #33770\n+        //\n+        // A pthread mutex initialized with PTHREAD_MUTEX_INITIALIZER will have\n+        // a type of PTHREAD_MUTEX_DEFAULT, which has undefined behavior if you\n+        // try to re-lock it from the same thread when you already hold a lock.\n+        //\n+        // In practice, glibc takes advantage of this undefined behavior to\n+        // implement hardware lock elision, which uses hardware transactional\n+        // memory to avoid acquiring the lock. While a transaction is in\n+        // progress, the lock appears to be unlocked. This isn't a problem for\n+        // other threads since the transactional memory will abort if a conflict\n+        // is detected, however no abort is generated if re-locking from the\n+        // same thread.\n+        //\n+        // Since locking the same mutex twice will result in two aliasing &mut\n+        // references, we instead create the mutex with type\n+        // PTHREAD_MUTEX_NORMAL which is guaranteed to deadlock if we try to\n+        // re-lock it from the same thread, thus avoiding undefined behavior.\n+        let mut attr = MaybeUninit::<libc::pthread_mutexattr_t>::uninit();\n+        let r = libc::pthread_mutexattr_init(attr.as_mut_ptr());\n+        debug_assert_eq!(r, 0);\n+        let r = libc::pthread_mutexattr_settype(attr.as_mut_ptr(), libc::PTHREAD_MUTEX_NORMAL);\n+        debug_assert_eq!(r, 0);\n+        let r = libc::pthread_mutex_init(self.inner.get(), attr.as_ptr());\n+        debug_assert_eq!(r, 0);\n+        let r = libc::pthread_mutexattr_destroy(attr.as_mut_ptr());\n+        debug_assert_eq!(r, 0);\n+    }\n+    #[inline]\n+    pub unsafe fn lock(&self) {\n+        let r = libc::pthread_mutex_lock(self.inner.get());\n+        debug_assert_eq!(r, 0);\n+    }\n+    #[inline]\n+    pub unsafe fn unlock(&self) {\n+        let r = libc::pthread_mutex_unlock(self.inner.get());\n+        debug_assert_eq!(r, 0);\n+    }\n+    #[inline]\n+    pub unsafe fn try_lock(&self) -> bool {\n+        libc::pthread_mutex_trylock(self.inner.get()) == 0\n+    }\n+    #[inline]\n+    #[cfg(not(target_os = \"dragonfly\"))]\n+    pub unsafe fn destroy(&self) {\n+        let r = libc::pthread_mutex_destroy(self.inner.get());\n+        debug_assert_eq!(r, 0);\n+    }\n+    #[inline]\n+    #[cfg(target_os = \"dragonfly\")]\n+    pub unsafe fn destroy(&self) {\n+        let r = libc::pthread_mutex_destroy(self.inner.get());\n+        // On DragonFly pthread_mutex_destroy() returns EINVAL if called on a\n+        // mutex that was just initialized with libc::PTHREAD_MUTEX_INITIALIZER.\n+        // Once it is used (locked/unlocked) or pthread_mutex_init() is called,\n+        // this behaviour no longer occurs.\n+        debug_assert!(r == 0 || r == libc::EINVAL);\n+    }\n+}\n+\n+pub struct ReentrantMutex { inner: UnsafeCell<libc::pthread_mutex_t> }\n+\n+unsafe impl Send for ReentrantMutex {}\n+unsafe impl Sync for ReentrantMutex {}\n+\n+impl ReentrantMutex {\n+    pub unsafe fn uninitialized() -> ReentrantMutex {\n+        ReentrantMutex { inner: UnsafeCell::new(libc::PTHREAD_MUTEX_INITIALIZER) }\n+    }\n+\n+    pub unsafe fn init(&mut self) {\n+        let mut attr = MaybeUninit::<libc::pthread_mutexattr_t>::uninit();\n+        let result = libc::pthread_mutexattr_init(attr.as_mut_ptr());\n+        debug_assert_eq!(result, 0);\n+        let result = libc::pthread_mutexattr_settype(attr.as_mut_ptr(),\n+                                                    libc::PTHREAD_MUTEX_RECURSIVE);\n+        debug_assert_eq!(result, 0);\n+        let result = libc::pthread_mutex_init(self.inner.get(), attr.as_ptr());\n+        debug_assert_eq!(result, 0);\n+        let result = libc::pthread_mutexattr_destroy(attr.as_mut_ptr());\n+        debug_assert_eq!(result, 0);\n+    }\n+\n+    pub unsafe fn lock(&self) {\n+        let result = libc::pthread_mutex_lock(self.inner.get());\n+        debug_assert_eq!(result, 0);\n+    }\n+\n+    #[inline]\n+    pub unsafe fn try_lock(&self) -> bool {\n+        libc::pthread_mutex_trylock(self.inner.get()) == 0\n+    }\n+\n+    pub unsafe fn unlock(&self) {\n+        let result = libc::pthread_mutex_unlock(self.inner.get());\n+        debug_assert_eq!(result, 0);\n+    }\n+\n+    pub unsafe fn destroy(&self) {\n+        let result = libc::pthread_mutex_destroy(self.inner.get());\n+        debug_assert_eq!(result, 0);\n+    }\n+}"}, {"sha": "686cea49a6ea8066089a438e17e1b7253f3d3e97", "filename": "src/libstd/sys/vxworks/net.rs", "status": "added", "additions": 374, "deletions": 0, "changes": 374, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fnet.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,374 @@\n+use crate::ffi::CStr;\n+use crate::io;\n+use crate::io::{IoSlice, IoSliceMut};\n+use libc::{self, c_int, c_void, size_t, sockaddr, socklen_t, EAI_SYSTEM, MSG_PEEK};\n+use crate::mem;\n+use crate::net::{SocketAddr, Shutdown};\n+use crate::str;\n+use crate::sys::fd::FileDesc;\n+use crate::sys_common::{AsInner, FromInner, IntoInner};\n+use crate::sys_common::net::{getsockopt, setsockopt, sockaddr_to_addr};\n+use crate::time::{Duration, Instant};\n+use crate::cmp;\n+\n+pub use crate::sys::{cvt, cvt_r};\n+\n+#[allow(unused_extern_crates)]\n+pub extern crate libc as netc;\n+\n+pub type wrlen_t = size_t;\n+\n+\n+const SOCK_CLOEXEC: c_int = 0;\n+const SO_NOSIGPIPE: c_int = 0;\n+\n+pub struct Socket(FileDesc);\n+\n+pub fn init() {}\n+\n+pub fn cvt_gai(err: c_int) -> io::Result<()> {\n+    if err == 0 {\n+        return Ok(())\n+    }\n+\n+    // We may need to trigger a glibc workaround. See on_resolver_failure() for details.\n+    on_resolver_failure();\n+\n+    if err == EAI_SYSTEM {\n+        return Err(io::Error::last_os_error())\n+    }\n+\n+    let detail = unsafe {\n+        str::from_utf8(CStr::from_ptr(libc::gai_strerror(err)).to_bytes()).unwrap()\n+            .to_owned()\n+    };\n+    Err(io::Error::new(io::ErrorKind::Other,\n+                       &format!(\"failed to lookup address information: {}\",\n+                                detail)[..]))\n+}\n+\n+impl Socket {\n+    pub fn new(addr: &SocketAddr, ty: c_int) -> io::Result<Socket> {\n+        let fam = match *addr {\n+            SocketAddr::V4(..) => libc::AF_INET,\n+            SocketAddr::V6(..) => libc::AF_INET6,\n+        };\n+        Socket::new_raw(fam, ty)\n+    }\n+\n+    pub fn new_raw(fam: c_int, ty: c_int) -> io::Result<Socket> {\n+        unsafe {\n+            // On linux we first attempt to pass the SOCK_CLOEXEC flag to\n+            // atomically create the socket and set it as CLOEXEC. Support for\n+            // this option, however, was added in 2.6.27, and we still support\n+            // 2.6.18 as a kernel, so if the returned error is EINVAL we\n+            // fallthrough to the fallback.\n+            if cfg!(target_os = \"linux\") {\n+                match cvt(libc::socket(fam, ty | SOCK_CLOEXEC, 0)) {\n+                    Ok(fd) => return Ok(Socket(FileDesc::new(fd))),\n+                    Err(ref e) if e.raw_os_error() == Some(libc::EINVAL) => {}\n+                    Err(e) => return Err(e),\n+                }\n+            }\n+\n+            let fd = cvt(libc::socket(fam, ty, 0))?;\n+            let fd = FileDesc::new(fd);\n+            fd.set_cloexec()?;\n+            let socket = Socket(fd);\n+            Ok(socket)\n+        }\n+    }\n+\n+    pub fn new_pair(_fam: c_int, _ty: c_int) -> io::Result<(Socket, Socket)> {\n+            unimplemented!();\n+    }\n+\n+    pub fn connect_timeout(&self, addr: &SocketAddr, timeout: Duration) -> io::Result<()> {\n+        self.set_nonblocking(true)?;\n+        let r = unsafe {\n+            let (addrp, len) = addr.into_inner();\n+            cvt(libc::connect(self.0.raw(), addrp, len))\n+        };\n+        self.set_nonblocking(false)?;\n+\n+        match r {\n+            Ok(_) => return Ok(()),\n+            // there's no ErrorKind for EINPROGRESS :(\n+            Err(ref e) if e.raw_os_error() == Some(libc::EINPROGRESS) => {}\n+            Err(e) => return Err(e),\n+        }\n+\n+        let mut pollfd = libc::pollfd {\n+            fd: self.0.raw(),\n+            events: libc::POLLOUT,\n+            revents: 0,\n+        };\n+\n+        if timeout.as_secs() == 0 && timeout.subsec_nanos() == 0 {\n+            return Err(io::Error::new(io::ErrorKind::InvalidInput,\n+                                      \"cannot set a 0 duration timeout\"));\n+        }\n+\n+        let start = Instant::now();\n+\n+        loop {\n+            let elapsed = start.elapsed();\n+            if elapsed >= timeout {\n+                return Err(io::Error::new(io::ErrorKind::TimedOut, \"connection timed out\"));\n+            }\n+\n+            let timeout = timeout - elapsed;\n+            let mut timeout = timeout.as_secs()\n+                .saturating_mul(1_000)\n+                .saturating_add(timeout.subsec_nanos() as u64 / 1_000_000);\n+            if timeout == 0 {\n+                timeout = 1;\n+            }\n+\n+            let timeout = cmp::min(timeout, c_int::max_value() as u64) as c_int;\n+\n+            match unsafe { libc::poll(&mut pollfd, 1, timeout) } {\n+                -1 => {\n+                    let err = io::Error::last_os_error();\n+                    if err.kind() != io::ErrorKind::Interrupted {\n+                        return Err(err);\n+                    }\n+                }\n+                0 => {}\n+                _ => {\n+                    // linux returns POLLOUT|POLLERR|POLLHUP for refused connections (!), so look\n+                    // for POLLHUP rather than read readiness\n+                    if pollfd.revents & libc::POLLHUP != 0 {\n+                        let e = self.take_error()?\n+                            .unwrap_or_else(|| {\n+                                io::Error::new(io::ErrorKind::Other, \"no error set after POLLHUP\")\n+                            });\n+                        return Err(e);\n+                    }\n+\n+                    return Ok(());\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn accept(&self, storage: *mut sockaddr, len: *mut socklen_t)\n+                  -> io::Result<Socket> {\n+        // Unfortunately the only known way right now to accept a socket and\n+        // atomically set the CLOEXEC flag is to use the `accept4` syscall on\n+        // Linux. This was added in 2.6.28, however, and because we support\n+        // 2.6.18 we must detect this support dynamically.\n+        let fd = cvt_r(|| unsafe {\n+            libc::accept(self.0.raw(), storage, len)\n+        })?;\n+        let fd = FileDesc::new(fd);\n+        fd.set_cloexec()?;\n+        Ok(Socket(fd))\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<Socket> {\n+        self.0.duplicate().map(Socket)\n+    }\n+\n+    fn recv_with_flags(&self, buf: &mut [u8], flags: c_int) -> io::Result<usize> {\n+        let ret = cvt(unsafe {\n+            libc::recv(self.0.raw(),\n+                       buf.as_mut_ptr() as *mut c_void,\n+                       buf.len(),\n+                       flags)\n+        })?;\n+        Ok(ret as usize)\n+    }\n+\n+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.recv_with_flags(buf, 0)\n+    }\n+\n+    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.recv_with_flags(buf, MSG_PEEK)\n+    }\n+\n+    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n+        self.0.read_vectored(bufs)\n+    }\n+\n+    fn recv_from_with_flags(&self, buf: &mut [u8], flags: c_int)\n+                            -> io::Result<(usize, SocketAddr)> {\n+        let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n+        let mut addrlen = mem::size_of_val(&storage) as libc::socklen_t;\n+\n+        let n = cvt(unsafe {\n+            libc::recvfrom(self.0.raw(),\n+                        buf.as_mut_ptr() as *mut c_void,\n+                        buf.len(),\n+                        flags,\n+                        &mut storage as *mut _ as *mut _,\n+                        &mut addrlen)\n+        })?;\n+        Ok((n as usize, sockaddr_to_addr(&storage, addrlen as usize)?))\n+    }\n+\n+    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        self.recv_from_with_flags(buf, 0)\n+    }\n+\n+    pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        self.recv_from_with_flags(buf, MSG_PEEK)\n+    }\n+\n+    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n+        self.0.write(buf)\n+    }\n+\n+    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        self.0.write_vectored(bufs)\n+    }\n+\n+    pub fn set_timeout(&self, dur: Option<Duration>, kind: libc::c_int) -> io::Result<()> {\n+        let timeout = match dur {\n+            Some(dur) => {\n+                if dur.as_secs() == 0 && dur.subsec_nanos() == 0 {\n+                    return Err(io::Error::new(io::ErrorKind::InvalidInput,\n+                                              \"cannot set a 0 duration timeout\"));\n+                }\n+\n+                let secs = if dur.as_secs() > libc::time_t::max_value() as u64 {\n+                    libc::time_t::max_value()\n+                } else {\n+                    dur.as_secs() as libc::time_t\n+                };\n+                let mut timeout = libc::timeval {\n+                    tv_sec: secs,\n+                    tv_usec: (dur.subsec_nanos() / 1000) as libc::suseconds_t,\n+                };\n+                if timeout.tv_sec == 0 && timeout.tv_usec == 0 {\n+                    timeout.tv_usec = 1;\n+                }\n+                timeout\n+            }\n+            None => {\n+                libc::timeval {\n+                    tv_sec: 0,\n+                    tv_usec: 0,\n+                }\n+            }\n+        };\n+        setsockopt(self, libc::SOL_SOCKET, kind, timeout)\n+    }\n+\n+    pub fn timeout(&self, kind: libc::c_int) -> io::Result<Option<Duration>> {\n+        let raw: libc::timeval = getsockopt(self, libc::SOL_SOCKET, kind)?;\n+        if raw.tv_sec == 0 && raw.tv_usec == 0 {\n+            Ok(None)\n+        } else {\n+            let sec = raw.tv_sec as u64;\n+            let nsec = (raw.tv_usec as u32) * 1000;\n+            Ok(Some(Duration::new(sec, nsec)))\n+        }\n+    }\n+\n+    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n+        let how = match how {\n+            Shutdown::Write => libc::SHUT_WR,\n+            Shutdown::Read => libc::SHUT_RD,\n+            Shutdown::Both => libc::SHUT_RDWR,\n+        };\n+        cvt(unsafe { libc::shutdown(self.0.raw(), how) })?;\n+        Ok(())\n+    }\n+\n+    pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {\n+        setsockopt(self, libc::IPPROTO_TCP, libc::TCP_NODELAY, nodelay as c_int)\n+    }\n+\n+    pub fn nodelay(&self) -> io::Result<bool> {\n+        let raw: c_int = getsockopt(self, libc::IPPROTO_TCP, libc::TCP_NODELAY)?;\n+        Ok(raw != 0)\n+    }\n+\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        let mut nonblocking = nonblocking as libc::c_int;\n+        cvt(unsafe { libc::ioctl(*self.as_inner(), libc::FIONBIO, &mut nonblocking) }).map(|_| ())\n+    }\n+\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        let raw: c_int = getsockopt(self, libc::SOL_SOCKET, libc::SO_ERROR)?;\n+        if raw == 0 {\n+            Ok(None)\n+        } else {\n+            Ok(Some(io::Error::from_raw_os_error(raw as i32)))\n+        }\n+    }\n+}\n+\n+impl AsInner<c_int> for Socket {\n+    fn as_inner(&self) -> &c_int { self.0.as_inner() }\n+}\n+\n+impl FromInner<c_int> for Socket {\n+    fn from_inner(fd: c_int) -> Socket { Socket(FileDesc::new(fd)) }\n+}\n+\n+impl IntoInner<c_int> for Socket {\n+    fn into_inner(self) -> c_int { self.0.into_raw() }\n+}\n+\n+// In versions of glibc prior to 2.26, there's a bug where the DNS resolver\n+// will cache the contents of /etc/resolv.conf, so changes to that file on disk\n+// can be ignored by a long-running program. That can break DNS lookups on e.g.\n+// laptops where the network comes and goes. See\n+// https://sourceware.org/bugzilla/show_bug.cgi?id=984. Note however that some\n+// distros including Debian have patched glibc to fix this for a long time.\n+//\n+// A workaround for this bug is to call the res_init libc function, to clear\n+// the cached configs. Unfortunately, while we believe glibc's implementation\n+// of res_init is thread-safe, we know that other implementations are not\n+// (https://github.com/rust-lang/rust/issues/43592). Code here in libstd could\n+// try to synchronize its res_init calls with a Mutex, but that wouldn't\n+// protect programs that call into libc in other ways. So instead of calling\n+// res_init unconditionally, we call it only when we detect we're linking\n+// against glibc version < 2.26. (That is, when we both know its needed and\n+// believe it's thread-safe).\n+#[cfg(target_env = \"gnu\")]\n+fn on_resolver_failure() {\n+/*\n+    use crate::sys;\n+\n+    // If the version fails to parse, we treat it the same as \"not glibc\".\n+    if let Some(version) = sys::os::glibc_version() {\n+        if version < (2, 26) {\n+            unsafe { libc::res_init() };\n+        }\n+    }\n+    */\n+}\n+\n+#[cfg(not(target_env = \"gnu\"))]\n+fn on_resolver_failure() {}\n+\n+#[cfg(all(test, taget_env = \"gnu\"))]\n+mod test {\n+    use super::*;\n+\n+    #[test]\n+    fn test_res_init() {\n+        // This mostly just tests that the weak linkage doesn't panic wildly...\n+        res_init_if_glibc_before_2_26().unwrap();\n+    }\n+\n+    #[test]\n+    fn test_parse_glibc_version() {\n+        let cases = [\n+            (\"0.0\", Some((0, 0))),\n+            (\"01.+2\", Some((1, 2))),\n+            (\"3.4.5.six\", Some((3, 4))),\n+            (\"1\", None),\n+            (\"1.-2\", None),\n+            (\"1.foo\", None),\n+            (\"foo.1\", None),\n+        ];\n+        for &(version_str, parsed) in cases.iter() {\n+            assert_eq!(parsed, parse_glibc_version(version_str));\n+        }\n+    }\n+}"}, {"sha": "5dc35a6176bce7c27493f90cbba52575c63171f2", "filename": "src/libstd/sys/vxworks/os.rs", "status": "added", "additions": 324, "deletions": 0, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fos.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,324 @@\n+use crate::error::Error as StdError;\n+use crate::ffi::{CString, CStr, OsString, OsStr};\n+use crate::fmt;\n+use crate::io;\n+use crate::iter;\n+use libc::{self, c_int, c_char /*,c_void */};\n+use crate::marker::PhantomData;\n+use crate::mem;\n+use crate::memchr;\n+use crate::path::{self, PathBuf, Path};\n+use crate::ptr;\n+use crate::slice;\n+use crate::str;\n+use crate::sys_common::mutex::Mutex;\n+use crate::sys::cvt;\n+/*use sys::fd; this one is probably important */\n+use crate::vec;\n+\n+const TMPBUF_SZ: usize = 128;\n+static ENV_LOCK: Mutex = Mutex::new();\n+\n+\n+// This is a terrible fix\n+use crate::sys::os_str::Buf;\n+use crate::sys_common::{FromInner, IntoInner, AsInner};\n+\n+pub trait OsStringExt {\n+    fn from_vec(vec: Vec<u8>) -> Self;\n+    fn into_vec(self) -> Vec<u8>;\n+}\n+\n+impl OsStringExt for OsString {\n+    fn from_vec(vec: Vec<u8>) -> OsString {\n+        FromInner::from_inner(Buf { inner: vec })\n+    }\n+    fn into_vec(self) -> Vec<u8> {\n+        self.into_inner().inner\n+    }\n+}\n+\n+pub trait OsStrExt {\n+    fn from_bytes(slice: &[u8]) -> &Self;\n+    fn as_bytes(&self) -> &[u8];\n+}\n+\n+impl OsStrExt for OsStr {\n+    fn from_bytes(slice: &[u8]) -> &OsStr {\n+        unsafe { mem::transmute(slice) }\n+    }\n+    fn as_bytes(&self) -> &[u8] {\n+        &self.as_inner().inner\n+    }\n+}\n+\n+pub fn errno() -> i32 {\n+    unsafe { libc::errnoGet() }\n+}\n+\n+pub fn set_errno(e: i32) {\n+    unsafe { libc::errnoSet(e as c_int); }\n+}\n+\n+/// Gets a detailed string description for the given error number.\n+pub fn error_string(errno: i32) -> String {\n+    let mut buf = [0 as c_char; TMPBUF_SZ];\n+    extern {\n+        fn strerror_r(\n+            errnum: c_int,\n+            buf: *mut c_char,\n+            buflen: libc::size_t\n+        ) -> c_int;\n+    }\n+\n+    let p = buf.as_mut_ptr();\n+    unsafe {\n+        if strerror_r(errno as c_int, p, buf.len()) < 0 {\n+            panic!(\"strerror_r failure\");\n+        }\n+        let p = p as *const _;\n+        str::from_utf8(CStr::from_ptr(p).to_bytes()).unwrap().to_owned()\n+    }\n+}\n+\n+pub fn getcwd() -> io::Result<PathBuf> {\n+    let mut buf = Vec::with_capacity(512);\n+    loop {\n+        unsafe {\n+            let ptr = buf.as_mut_ptr() as *mut libc::c_char;\n+            if !libc::getcwd(ptr, buf.capacity() as libc::size_t).is_null() {\n+                let len = CStr::from_ptr(buf.as_ptr() as *const libc::c_char).to_bytes().len();\n+                buf.set_len(len);\n+                buf.shrink_to_fit();\n+                return Ok(PathBuf::from(OsString::from_vec(buf)));\n+            } else {\n+                let error = io::Error::last_os_error();\n+                if error.raw_os_error() != Some(libc::ERANGE) {\n+                    return Err(error);\n+                }\n+            }\n+            // Trigger the internal buffer resizing logic of `Vec` by requiring\n+            // more space than the current capacity.\n+            let cap = buf.capacity();\n+            buf.set_len(cap);\n+            buf.reserve(1);\n+        }\n+    }\n+}\n+\n+pub fn chdir(p: &path::Path) -> io::Result<()> {\n+    let p: &OsStr = p.as_ref();\n+    let p = CString::new(p.as_bytes())?;\n+    unsafe {\n+        match libc::chdir(p.as_ptr()) == (0 as c_int) {\n+            true => Ok(()),\n+            false => Err(io::Error::last_os_error()),\n+        }\n+    }\n+}\n+\n+pub struct SplitPaths<'a> {\n+    iter: iter::Map<slice::Split<'a, u8, fn(&u8) -> bool>,\n+            fn(&'a [u8]) -> PathBuf>,\n+}\n+\n+pub fn split_paths(unparsed: &OsStr) -> SplitPaths<'_> {\n+    fn bytes_to_path(b: &[u8]) -> PathBuf {\n+        PathBuf::from(<OsStr as OsStrExt>::from_bytes(b))\n+    }\n+    fn is_colon(b: &u8) -> bool { *b == b':' }\n+    let unparsed = unparsed.as_bytes();\n+    SplitPaths {\n+        iter: unparsed.split(is_colon as fn(&u8) -> bool)\n+                        .map(bytes_to_path as fn(&[u8]) -> PathBuf)\n+    }\n+}\n+\n+impl<'a> Iterator for SplitPaths<'a> {\n+    type Item = PathBuf;\n+    fn next(&mut self) -> Option<PathBuf> { self.iter.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+}\n+\n+#[derive(Debug)]\n+pub struct JoinPathsError;\n+\n+pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>\n+    where I: Iterator<Item=T>, T: AsRef<OsStr>\n+{\n+    let mut joined = Vec::new();\n+    let sep = b':';\n+\n+    for (i, path) in paths.enumerate() {\n+        let path = path.as_ref().as_bytes();\n+        if i > 0 {\n+            joined.push(sep)\n+        }\n+        if path.contains(&sep) {\n+            return Err(JoinPathsError)\n+        }\n+        joined.extend_from_slice(path);\n+    }\n+    Ok(OsStringExt::from_vec(joined))\n+}\n+\n+impl fmt::Display for JoinPathsError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        \"path segment contains separator `:`\".fmt(f)\n+    }\n+}\n+\n+impl StdError for JoinPathsError {\n+    fn description(&self) -> &str { \"failed to join paths\" }\n+}\n+\n+pub fn current_exe() -> io::Result<PathBuf> {\n+    #[cfg(test)]\n+    use realstd::env;\n+\n+    #[cfg(not(test))]\n+    use crate::env;\n+\n+    let exe_path = env::args().next().unwrap();\n+    let path = Path::new(&exe_path);\n+    path.canonicalize()\n+}\n+\n+pub struct Env {\n+    iter: vec::IntoIter<(OsString, OsString)>,\n+    _dont_send_or_sync_me: PhantomData<*mut ()>,\n+}\n+\n+impl Iterator for Env {\n+    type Item = (OsString, OsString);\n+    fn next(&mut self) -> Option<(OsString, OsString)> { self.iter.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+}\n+\n+pub unsafe fn environ() -> *mut *const *const c_char {\n+    extern { static mut environ: *const *const c_char; }\n+    &mut environ\n+}\n+\n+/// Returns a vector of (variable, value) byte-vector pairs for all the\n+/// environment variables of the current process.\n+pub fn env() -> Env {\n+    unsafe {\n+        let _guard = ENV_LOCK.lock();\n+        let mut environ = *environ();\n+        if environ == ptr::null() {\n+            panic!(\"os::env() failure getting env string from OS: {}\",\n+                io::Error::last_os_error());\n+        }\n+        let mut result = Vec::new();\n+        while *environ != ptr::null() {\n+            if let Some(key_value) = parse(CStr::from_ptr(*environ).to_bytes()) {\n+                result.push(key_value);\n+            }\n+            environ = environ.offset(1);\n+        }\n+        return Env {\n+            iter: result.into_iter(),\n+            _dont_send_or_sync_me: PhantomData,\n+        }\n+    }\n+\n+    fn parse(input: &[u8]) -> Option<(OsString, OsString)> {\n+        // Strategy (copied from glibc): Variable name and value are separated\n+        // by an ASCII equals sign '='. Since a variable name must not be\n+        // empty, allow variable names starting with an equals sign. Skip all\n+        // malformed lines.\n+        if input.is_empty() {\n+            return None;\n+        }\n+        let pos = memchr::memchr(b'=', &input[1..]).map(|p| p + 1);\n+        pos.map(|p| (\n+            OsStringExt::from_vec(input[..p].to_vec()),\n+            OsStringExt::from_vec(input[p+1..].to_vec()),\n+        ))\n+    }\n+}\n+\n+pub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n+    // environment variables with a nul byte can't be set, so their value is\n+    // always None as well\n+    let k = CString::new(k.as_bytes())?;\n+    unsafe {\n+        let _guard = ENV_LOCK.lock();\n+        let s = libc::getenv(k.as_ptr()) as *const libc::c_char;\n+        let ret = if s.is_null() {\n+            None\n+        } else {\n+            Some(OsStringExt::from_vec(CStr::from_ptr(s).to_bytes().to_vec()))\n+        };\n+        Ok(ret)\n+    }\n+}\n+\n+pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n+    let k = CString::new(k.as_bytes())?;\n+    let v = CString::new(v.as_bytes())?;\n+\n+    unsafe {\n+        let _guard = ENV_LOCK.lock();\n+        cvt(libc::setenv(k.as_ptr(), v.as_ptr(), 1)).map(|_| ())\n+    }\n+}\n+\n+pub fn unsetenv(n: &OsStr) -> io::Result<()> {\n+    let nbuf = CString::new(n.as_bytes())?;\n+\n+    unsafe {\n+        let _guard = ENV_LOCK.lock();\n+        cvt(libc::unsetenv(nbuf.as_ptr())).map(|_| ())\n+    }\n+}\n+\n+pub fn page_size() -> usize {\n+    unsafe {\n+        libc::sysconf(libc::_SC_PAGESIZE) as usize\n+    }\n+}\n+\n+pub fn temp_dir() -> PathBuf {\n+    crate::env::var_os(\"TMPDIR\").map(PathBuf::from).unwrap_or_else(|| {\n+        PathBuf::from(\"/tmp\")\n+    })\n+}\n+\n+pub fn home_dir() -> Option<PathBuf> {\n+    return crate::env::var_os(\"HOME\").or_else(|| unsafe {\n+        fallback()\n+    }).map(PathBuf::from);\n+\n+    unsafe fn fallback() -> Option<OsString> {\n+        let amt = match libc::sysconf(libc::_SC_GETPW_R_SIZE_MAX) {\n+            n if n < 0 => 512 as usize,\n+            n => n as usize,\n+        };\n+        let mut buf = Vec::with_capacity(amt);\n+        let mut passwd: libc::passwd = mem::zeroed();\n+        let mut result = ptr::null_mut();\n+        match libc::getpwuid_r(libc::getuid(), &mut passwd, buf.as_mut_ptr(),\n+                                buf.capacity(), &mut result) {\n+            0 if !result.is_null() => {\n+                let ptr = passwd.pw_dir as *const _;\n+                let bytes = CStr::from_ptr(ptr).to_bytes().to_vec();\n+                Some(OsStringExt::from_vec(bytes))\n+            },\n+            _ => None,\n+        }\n+    }\n+}\n+\n+pub fn exit(code: i32) -> ! {\n+    unsafe { libc::exit(code as c_int) }\n+}\n+\n+pub fn getpid() -> u32 {\n+    unsafe { libc::getpid() as u32 }\n+}\n+\n+pub fn getppid() -> u32 {\n+    unsafe { libc::getppid() as u32 }\n+}"}, {"sha": "7a1839561078575c74850ce343f81b0989767916", "filename": "src/libstd/sys/vxworks/path.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fpath.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,19 @@\n+use crate::path::Prefix;\n+use crate::ffi::OsStr;\n+\n+#[inline]\n+pub fn is_sep_byte(b: u8) -> bool {\n+    b == b'/'\n+}\n+\n+#[inline]\n+pub fn is_verbatim_sep(b: u8) -> bool {\n+    b == b'/'\n+}\n+\n+pub fn parse_prefix(_: &OsStr) -> Option<Prefix<'_>> {\n+    None\n+}\n+\n+pub const MAIN_SEP_STR: &str = \"/\";\n+pub const MAIN_SEP: char = '/';"}, {"sha": "83637832ff32719bcdce090bfb4dc3f5e40a7848", "filename": "src/libstd/sys/vxworks/pipe.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fpipe.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,100 @@\n+use crate::io::{self, IoSlice, IoSliceMut};\n+use libc::{self /*, c_int apparently not used? */};\n+use crate::mem;\n+use crate::sync::atomic::{AtomicBool};\n+use crate::sys::fd::FileDesc;\n+use crate::sys::{cvt, cvt_r};\n+\n+pub struct AnonPipe(FileDesc);\n+\n+pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n+    static INVALID: AtomicBool = AtomicBool::new(false);\n+\n+    let mut fds = [0; 2];\n+\n+    // Unfortunately the only known way right now to create atomically set the\n+    // CLOEXEC flag is to use the `pipe2` syscall on Linux. This was added in\n+    // 2.6.27, however, and because we support 2.6.18 we must detect this\n+    // support dynamically.\n+    cvt(unsafe { libc::pipe(fds.as_mut_ptr()) })?;\n+\n+    let fd0 = FileDesc::new(fds[0]);\n+    let fd1 = FileDesc::new(fds[1]);\n+    fd0.set_cloexec()?;\n+    fd1.set_cloexec()?;\n+    Ok((AnonPipe(fd0), AnonPipe(fd1)))\n+}\n+\n+impl AnonPipe {\n+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.read(buf)\n+    }\n+    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n+                self.0.read_vectored(bufs)\n+        }\n+\n+    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n+        self.0.write(buf)\n+    }\n+\n+        pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+                self.0.write_vectored(bufs)\n+        }\n+\n+    pub fn fd(&self) -> &FileDesc { &self.0 }\n+    pub fn into_fd(self) -> FileDesc { self.0 }\n+    pub fn diverge(&self) -> ! {\n+        panic!()\n+     }\n+}\n+\n+pub fn read2(p1: AnonPipe,\n+             v1: &mut Vec<u8>,\n+             p2: AnonPipe,\n+             v2: &mut Vec<u8>) -> io::Result<()> {\n+\n+    // Set both pipes into nonblocking mode as we're gonna be reading from both\n+    // in the `select` loop below, and we wouldn't want one to block the other!\n+    let p1 = p1.into_fd();\n+    let p2 = p2.into_fd();\n+    p1.set_nonblocking_pipe(true)?;\n+    p2.set_nonblocking_pipe(true)?;\n+\n+    let mut fds: [libc::pollfd; 2] = unsafe { mem::zeroed() };\n+    fds[0].fd = p1.raw();\n+    fds[0].events = libc::POLLIN;\n+    fds[1].fd = p2.raw();\n+    fds[1].events = libc::POLLIN;\n+    loop {\n+        // wait for either pipe to become readable using `poll`\n+        cvt_r(|| unsafe { libc::poll(fds.as_mut_ptr(), 2, -1) })?;\n+\n+        if fds[0].revents != 0 && read(&p1, v1)? {\n+            p2.set_nonblocking_pipe(false)?;\n+            return p2.read_to_end(v2).map(|_| ());\n+        }\n+        if fds[1].revents != 0 && read(&p2, v2)? {\n+            p1.set_nonblocking_pipe(false)?;\n+            return p1.read_to_end(v1).map(|_| ());\n+        }\n+    }\n+\n+    // Read as much as we can from each pipe, ignoring EWOULDBLOCK or\n+    // EAGAIN. If we hit EOF, then this will happen because the underlying\n+    // reader will return Ok(0), in which case we'll see `Ok` ourselves. In\n+    // this case we flip the other fd back into blocking mode and read\n+    // whatever's leftover on that file descriptor.\n+    fn read(fd: &FileDesc, dst: &mut Vec<u8>) -> Result<bool, io::Error> {\n+        match fd.read_to_end(dst) {\n+            Ok(_) => Ok(true),\n+            Err(e) => {\n+                if e.raw_os_error() == Some(libc::EWOULDBLOCK) ||\n+                   e.raw_os_error() == Some(libc::EAGAIN) {\n+                    Ok(false)\n+                } else {\n+                    Err(e)\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "4dc706006f4ce859469648a4b8187aa3172f9ef7", "filename": "src/libstd/sys/vxworks/process/mod.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fmod.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,7 @@\n+pub use self::process_common::{Command, ExitStatus, ExitCode, Stdio, StdioPipes};\n+pub use self::process_inner::Process;\n+\n+mod process_common;\n+#[path = \"process_vxworks.rs\"]\n+mod process_inner;\n+mod rtp;"}, {"sha": "db4e80c216c12828b133b55e006016efa94250f1", "filename": "src/libstd/sys/vxworks/process/process_common.rs", "status": "added", "additions": 503, "deletions": 0, "changes": 503, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,503 @@\n+use crate::os::unix::prelude::*;\n+\n+use crate::ffi::{OsString, OsStr, CString, CStr};\n+use crate::fmt;\n+use crate::io;\n+use crate::ptr;\n+use crate::sys::fd::FileDesc;\n+use crate::sys::fs::{File, OpenOptions};\n+use crate::sys::pipe::{self, AnonPipe};\n+use crate::sys_common::process::{CommandEnv, DefaultEnvKey};\n+use crate::collections::BTreeMap;\n+\n+use libc::{c_int, gid_t, uid_t, c_char, EXIT_SUCCESS, EXIT_FAILURE};\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Command\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct Command {\n+    // Currently we try hard to ensure that the call to `.exec()` doesn't\n+    // actually allocate any memory. While many platforms try to ensure that\n+    // memory allocation works after a fork in a multithreaded process, it's\n+    // been observed to be buggy and somewhat unreliable, so we do our best to\n+    // just not do it at all!\n+    //\n+    // Along those lines, the `argv` and `envp` raw pointers here are exactly\n+    // what's gonna get passed to `execvp`. The `argv` array starts with the\n+    // `program` and ends with a NULL, and the `envp` pointer, if present, is\n+    // also null-terminated.\n+    //\n+    // Right now we don't support removing arguments, so there's no much fancy\n+    // support there, but we support adding and removing environment variables,\n+    // so a side table is used to track where in the `envp` array each key is\n+    // located. Whenever we add a key we update it in place if it's already\n+    // present, and whenever we remove a key we update the locations of all\n+    // other keys.\n+    program: CString,\n+    args: Vec<CString>,\n+    argv: Argv,\n+    env: CommandEnv<DefaultEnvKey>,\n+\n+    cwd: Option<CString>,\n+    uid: Option<uid_t>,\n+    gid: Option<gid_t>,\n+    saw_nul: bool,\n+    closures: Vec<Box<dyn FnMut() -> io::Result<()> + Send + Sync>>,\n+    stdin: Option<Stdio>,\n+    stdout: Option<Stdio>,\n+    stderr: Option<Stdio>,\n+}\n+\n+// Create a new type for argv, so that we can make it `Send`\n+struct Argv(Vec<*const c_char>);\n+\n+// It is safe to make Argv Send, because it contains pointers to memory owned by `Command.args`\n+unsafe impl Send for Argv {}\n+\n+// passed back to std::process with the pipes connected to the child, if any\n+// were requested\n+pub struct StdioPipes {\n+    pub stdin: Option<AnonPipe>,\n+    pub stdout: Option<AnonPipe>,\n+    pub stderr: Option<AnonPipe>,\n+}\n+\n+// passed to do_exec() with configuration of what the child stdio should look\n+// like\n+pub struct ChildPipes {\n+    pub stdin: ChildStdio,\n+    pub stdout: ChildStdio,\n+    pub stderr: ChildStdio,\n+}\n+\n+pub enum ChildStdio {\n+    Inherit,\n+    Explicit(c_int),\n+    Owned(FileDesc),\n+}\n+\n+pub enum Stdio {\n+    Inherit,\n+    Null,\n+    MakePipe,\n+    Fd(FileDesc),\n+}\n+\n+impl Command {\n+    pub fn new(program: &OsStr) -> Command {\n+        let mut saw_nul = false;\n+        let program = os2c(program, &mut saw_nul);\n+        Command {\n+            argv: Argv(vec![program.as_ptr(), ptr::null()]),\n+            program,\n+            args: Vec::new(),\n+            env: Default::default(),\n+            cwd: None,\n+            uid: None,\n+            gid: None,\n+            saw_nul,\n+            closures: Vec::new(),\n+            stdin: None,\n+            stdout: None,\n+            stderr: None,\n+        }\n+    }\n+\n+    pub fn arg(&mut self, arg: &OsStr) {\n+        // Overwrite the trailing NULL pointer in `argv` and then add a new null\n+        // pointer.\n+        let arg = os2c(arg, &mut self.saw_nul);\n+        self.argv.0[self.args.len() + 1] = arg.as_ptr();\n+        self.argv.0.push(ptr::null());\n+\n+        // Also make sure we keep track of the owned value to schedule a\n+        // destructor for this memory.\n+        self.args.push(arg);\n+    }\n+\n+    pub fn cwd(&mut self, dir: &OsStr) {\n+        self.cwd = Some(os2c(dir, &mut self.saw_nul));\n+    }\n+    pub fn uid(&mut self, id: uid_t) {\n+        self.uid = Some(id);\n+    }\n+    pub fn gid(&mut self, id: gid_t) {\n+        self.gid = Some(id);\n+    }\n+\n+    pub fn saw_nul(&self) -> bool {\n+        self.saw_nul\n+    }\n+    pub fn get_argv(&self) -> &Vec<*const c_char> {\n+        &self.argv.0\n+    }\n+\n+    #[allow(dead_code)]\n+    pub fn get_cwd(&self) -> &Option<CString> {\n+        &self.cwd\n+    }\n+    #[allow(dead_code)]\n+    pub fn get_uid(&self) -> Option<uid_t> {\n+        self.uid\n+    }\n+    #[allow(dead_code)]\n+    pub fn get_gid(&self) -> Option<gid_t> {\n+        self.gid\n+    }\n+\n+    pub fn get_closures(&mut self) -> &mut Vec<Box<dyn FnMut() -> io::Result<()> + Send + Sync>> {\n+        &mut self.closures\n+    }\n+\n+    pub unsafe fn pre_exec(\n+        &mut self,\n+        _f: Box<dyn FnMut() -> io::Result<()> + Send + Sync>,\n+    ) {\n+        // Fork() is not supported in vxWorks so no way to run the closure in the new procecss.\n+        unimplemented!();;\n+    }\n+\n+    pub fn stdin(&mut self, stdin: Stdio) {\n+        self.stdin = Some(stdin);\n+    }\n+\n+    pub fn stdout(&mut self, stdout: Stdio) {\n+        self.stdout = Some(stdout);\n+    }\n+\n+    pub fn stderr(&mut self, stderr: Stdio) {\n+        self.stderr = Some(stderr);\n+    }\n+\n+    pub fn env_mut(&mut self) -> &mut CommandEnv<DefaultEnvKey> {\n+        &mut self.env\n+    }\n+\n+    pub fn capture_env(&mut self) -> Option<CStringArray> {\n+        let maybe_env = self.env.capture_if_changed();\n+        maybe_env.map(|env| construct_envp(env, &mut self.saw_nul))\n+    }\n+    #[allow(dead_code)]\n+    pub fn env_saw_path(&self) -> bool {\n+        self.env.have_changed_path()\n+    }\n+\n+    pub fn setup_io(&self, default: Stdio, needs_stdin: bool)\n+                -> io::Result<(StdioPipes, ChildPipes)> {\n+        let null = Stdio::Null;\n+        let default_stdin = if needs_stdin {&default} else {&null};\n+        let stdin = self.stdin.as_ref().unwrap_or(default_stdin);\n+        let stdout = self.stdout.as_ref().unwrap_or(&default);\n+        let stderr = self.stderr.as_ref().unwrap_or(&default);\n+        let (their_stdin, our_stdin) = stdin.to_child_stdio(true)?;\n+        let (their_stdout, our_stdout) = stdout.to_child_stdio(false)?;\n+        let (their_stderr, our_stderr) = stderr.to_child_stdio(false)?;\n+        let ours = StdioPipes {\n+            stdin: our_stdin,\n+            stdout: our_stdout,\n+            stderr: our_stderr,\n+        };\n+        let theirs = ChildPipes {\n+            stdin: their_stdin,\n+            stdout: their_stdout,\n+            stderr: their_stderr,\n+        };\n+        Ok((ours, theirs))\n+    }\n+}\n+\n+fn os2c(s: &OsStr, saw_nul: &mut bool) -> CString {\n+    CString::new(s.as_bytes()).unwrap_or_else(|_e| {\n+        *saw_nul = true;\n+        CString::new(\"<string-with-nul>\").unwrap()\n+    })\n+}\n+\n+// Helper type to manage ownership of the strings within a C-style array.\n+pub struct CStringArray {\n+    items: Vec<CString>,\n+    ptrs: Vec<*const c_char>\n+}\n+\n+impl CStringArray {\n+    pub fn with_capacity(capacity: usize) -> Self {\n+        let mut result = CStringArray {\n+            items: Vec::with_capacity(capacity),\n+            ptrs: Vec::with_capacity(capacity+1)\n+        };\n+        result.ptrs.push(ptr::null());\n+        result\n+    }\n+    pub fn push(&mut self, item: CString) {\n+        let l = self.ptrs.len();\n+        self.ptrs[l-1] = item.as_ptr();\n+        self.ptrs.push(ptr::null());\n+        self.items.push(item);\n+    }\n+    pub fn as_ptr(&self) -> *const *const c_char {\n+        self.ptrs.as_ptr()\n+    }\n+}\n+\n+fn construct_envp(env: BTreeMap<DefaultEnvKey, OsString>, saw_nul: &mut bool) -> CStringArray {\n+    let mut result = CStringArray::with_capacity(env.len());\n+    for (k, v) in env {\n+        let mut k: OsString = k.into();\n+\n+        // Reserve additional space for '=' and null terminator\n+        k.reserve_exact(v.len() + 2);\n+        k.push(\"=\");\n+        k.push(&v);\n+\n+        // Add the new entry into the array\n+        if let Ok(item) = CString::new(k.into_vec()) {\n+            result.push(item);\n+        } else {\n+            *saw_nul = true;\n+        }\n+    }\n+\n+    result\n+}\n+\n+impl Stdio {\n+    pub fn to_child_stdio(&self, readable: bool)\n+                      -> io::Result<(ChildStdio, Option<AnonPipe>)> {\n+        match *self {\n+            Stdio::Inherit => {\n+                Ok((ChildStdio::Inherit, None))\n+            },\n+\n+            // Make sure that the source descriptors are not an stdio\n+            // descriptor, otherwise the order which we set the child's\n+            // descriptors may blow away a descriptor which we are hoping to\n+            // save. For example, suppose we want the child's stderr to be the\n+            // parent's stdout, and the child's stdout to be the parent's\n+            // stderr. No matter which we dup first, the second will get\n+            // overwritten prematurely.\n+            Stdio::Fd(ref fd) => {\n+                if fd.raw() >= 0 && fd.raw() <= libc::STDERR_FILENO {\n+                    Ok((ChildStdio::Owned(fd.duplicate()?), None))\n+                } else {\n+                    Ok((ChildStdio::Explicit(fd.raw()), None))\n+                }\n+            }\n+\n+            Stdio::MakePipe => {\n+                let (reader, writer) = pipe::anon_pipe()?;\n+                let (ours, theirs) = if readable {\n+                    (writer, reader)\n+                } else {\n+                    (reader, writer)\n+                };\n+                Ok((ChildStdio::Owned(theirs.into_fd()), Some(ours)))\n+            }\n+\n+            Stdio::Null => {\n+                let mut opts = OpenOptions::new();\n+                opts.read(readable);\n+                opts.write(!readable);\n+                let path = unsafe {\n+                    CStr::from_ptr(\"/null\\0\".as_ptr() as *const _)\n+                };\n+                let fd = File::open_c(&path, &opts)?;\n+                Ok((ChildStdio::Owned(fd.into_fd()), None))\n+            }\n+        }\n+    }\n+}\n+\n+impl From<AnonPipe> for Stdio {\n+    fn from(pipe: AnonPipe) -> Stdio {\n+        Stdio::Fd(pipe.into_fd())\n+    }\n+}\n+\n+impl From<File> for Stdio {\n+    fn from(file: File) -> Stdio {\n+        Stdio::Fd(file.into_fd())\n+    }\n+}\n+\n+impl ChildStdio {\n+    pub fn fd(&self) -> Option<c_int> {\n+        match *self {\n+            ChildStdio::Inherit => None,\n+            ChildStdio::Explicit(fd) => Some(fd),\n+            ChildStdio::Owned(ref fd) => Some(fd.raw()),\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for Command {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{:?}\", self.program)?;\n+        for arg in &self.args {\n+            write!(f, \" {:?}\", arg)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+/// Unix exit statuses\n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+pub struct ExitStatus(c_int);\n+\n+impl ExitStatus {\n+    pub fn new(status: c_int) -> ExitStatus {\n+        ExitStatus(status)\n+    }\n+\n+    fn exited(&self) -> bool {\n+        /*unsafe*/ { libc::WIFEXITED(self.0) }\n+    }\n+\n+    pub fn success(&self) -> bool {\n+        self.code() == Some(0)\n+    }\n+\n+    pub fn code(&self) -> Option<i32> {\n+        if self.exited() {\n+            Some(/*unsafe*/ { libc::WEXITSTATUS(self.0) })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn signal(&self) -> Option<i32> {\n+        if !self.exited() {\n+            Some(/*unsafe*/ { libc::WTERMSIG(self.0) })\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl From<c_int> for ExitStatus {\n+    fn from(a: c_int) -> ExitStatus {\n+        ExitStatus(a)\n+    }\n+}\n+\n+impl fmt::Display for ExitStatus {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if let Some(code) = self.code() {\n+            write!(f, \"exit code: {}\", code)\n+        } else {\n+            let signal = self.signal().unwrap();\n+            write!(f, \"signal: {}\", signal)\n+        }\n+    }\n+}\n+\n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+pub struct ExitCode(u8);\n+\n+impl ExitCode {\n+    pub const SUCCESS: ExitCode = ExitCode(EXIT_SUCCESS as _);\n+    pub const FAILURE: ExitCode = ExitCode(EXIT_FAILURE as _);\n+\n+    #[inline]\n+    pub fn as_i32(&self) -> i32 {\n+        self.0 as i32\n+    }\n+}\n+\n+#[cfg(all(test, not(target_os = \"emscripten\")))]\n+mod tests {\n+    use super::*;\n+\n+    use crate::ffi::OsStr;\n+    use crate::mem;\n+    use crate::ptr;\n+    use crate::sys::cvt;\n+\n+    macro_rules! t {\n+        ($e:expr) => {\n+            match $e {\n+                Ok(t) => t,\n+                Err(e) => panic!(\"received error for `{}`: {}\", stringify!($e), e),\n+            }\n+        }\n+    }\n+\n+    // Android with api less than 21 define sig* functions inline, so it is not\n+    // available for dynamic link. Implementing sigemptyset and sigaddset allow us\n+    // to support older Android version (independent of libc version).\n+    // The following implementations are based on https://git.io/vSkNf\n+\n+    #[cfg(not(target_os = \"android\"))]\n+    extern {\n+        #[cfg_attr(target_os = \"netbsd\", link_name = \"__sigemptyset14\")]\n+        fn sigemptyset(set: *mut libc::sigset_t) -> libc::c_int;\n+\n+        #[cfg_attr(target_os = \"netbsd\", link_name = \"__sigaddset14\")]\n+        fn sigaddset(set: *mut libc::sigset_t, signum: libc::c_int) -> libc::c_int;\n+    }\n+\n+    #[cfg(target_os = \"android\")]\n+    unsafe fn sigemptyset(set: *mut libc::sigset_t) -> libc::c_int {\n+        libc::memset(set as *mut _, 0, mem::size_of::<libc::sigset_t>());\n+        return 0;\n+    }\n+\n+    #[cfg(target_os = \"android\")]\n+    unsafe fn sigaddset(set: *mut libc::sigset_t, signum: libc::c_int) -> libc::c_int {\n+        use crate::slice;\n+\n+        let raw = slice::from_raw_parts_mut(set as *mut u8, mem::size_of::<libc::sigset_t>());\n+        let bit = (signum - 1) as usize;\n+        raw[bit / 8] |= 1 << (bit % 8);\n+        return 0;\n+    }\n+\n+    // See #14232 for more information, but it appears that signal delivery to a\n+    // newly spawned process may just be raced in the macOS, so to prevent this\n+    // test from being flaky we ignore it on macOS.\n+    #[test]\n+    #[cfg_attr(target_os = \"macos\", ignore)]\n+    // When run under our current QEMU emulation test suite this test fails,\n+    // although the reason isn't very clear as to why. For now this test is\n+    // ignored there.\n+    #[cfg_attr(target_arch = \"arm\", ignore)]\n+    #[cfg_attr(target_arch = \"aarch64\", ignore)]\n+    fn test_process_mask() {\n+        unsafe {\n+            // Test to make sure that a signal mask does not get inherited.\n+            let mut cmd = Command::new(OsStr::new(\"cat\"));\n+\n+            let mut set: libc::sigset_t = mem::uninitialized();\n+            let mut old_set: libc::sigset_t = mem::uninitialized();\n+            t!(cvt(sigemptyset(&mut set)));\n+            t!(cvt(sigaddset(&mut set, libc::SIGINT)));\n+            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &set, &mut old_set)));\n+\n+            cmd.stdin(Stdio::MakePipe);\n+            cmd.stdout(Stdio::MakePipe);\n+\n+            let (mut cat, mut pipes) = t!(cmd.spawn(Stdio::Null, true));\n+            let stdin_write = pipes.stdin.take().unwrap();\n+            let stdout_read = pipes.stdout.take().unwrap();\n+\n+            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &old_set,\n+                                         ptr::null_mut())));\n+\n+            t!(cvt(libc::kill(cat.id() as libc::pid_t, libc::SIGINT)));\n+            // We need to wait until SIGINT is definitely delivered. The\n+            // easiest way is to write something to cat, and try to read it\n+            // back: if SIGINT is unmasked, it'll get delivered when cat is\n+            // next scheduled.\n+            let _ = stdin_write.write(b\"Hello\");\n+            drop(stdin_write);\n+\n+            // Either EOF or failure (EPIPE) is okay.\n+            let mut buf = [0; 5];\n+            if let Ok(ret) = stdout_read.read(&mut buf) {\n+                assert_eq!(ret, 0);\n+            }\n+\n+            t!(cat.wait());\n+        }\n+    }\n+}"}, {"sha": "d06d63bb43de55b5613cb67314c5d51e4c9ba522", "filename": "src/libstd/sys/vxworks/process/process_vxworks.rs", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_vxworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_vxworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_vxworks.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,167 @@\n+use crate::io::{self, Error, ErrorKind};\n+use libc::{self, c_int};\n+use libc::{RTP_ID};\n+\n+use crate::sys::cvt;\n+use crate::sys::process::rtp;\n+use crate::sys::process::process_common::*;\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Command\n+////////////////////////////////////////////////////////////////////////////////\n+\n+impl Command {\n+    pub fn spawn(&mut self, default: Stdio, needs_stdin: bool)\n+                 -> io::Result<(Process, StdioPipes)> {\n+        use crate::sys::{cvt_r};\n+        const CLOEXEC_MSG_FOOTER: &'static [u8] = b\"NOEX\";\n+\n+        let envp = self.capture_env();\n+\n+        if self.saw_nul() {\n+            return Err(io::Error::new(ErrorKind::InvalidInput,\n+                                      \"nul byte found in provided data\"));\n+        }\n+        let (ours, theirs) = self.setup_io(default, needs_stdin)?;\n+        let mut p = Process { pid: 0, status: None };\n+\n+        unsafe {\n+            macro_rules! t {\n+                ($e:expr) => (match $e {\n+                    Ok(e) => e,\n+                    Err(e) => return Err(e.into()),\n+                })\n+            }\n+\n+            let mut orig_stdin = libc::STDIN_FILENO;\n+            let mut orig_stdout = libc::STDOUT_FILENO;\n+            let mut orig_stderr = libc::STDERR_FILENO;\n+\n+            if let Some(fd) = theirs.stdin.fd() {\n+                orig_stdin = t!(cvt_r(|| libc::dup(libc::STDIN_FILENO)));\n+                t!(cvt_r(|| libc::dup2(fd, libc::STDIN_FILENO)));\n+            }\n+            if let Some(fd) = theirs.stdout.fd() {\n+                orig_stdout = t!(cvt_r(|| libc::dup(libc::STDOUT_FILENO)));\n+                t!(cvt_r(|| libc::dup2(fd, libc::STDOUT_FILENO)));\n+            }\n+            if let Some(fd) = theirs.stderr.fd() {\n+                orig_stderr = t!(cvt_r(|| libc::dup(libc::STDERR_FILENO)));\n+                t!(cvt_r(|| libc::dup2(fd, libc::STDERR_FILENO)));\n+            }\n+\n+            if let Some(ref cwd) = *self.get_cwd() {\n+                t!(cvt(libc::chdir(cwd.as_ptr())));\n+            }\n+\n+            //            let envp = envp.map(|c| c.as_ptr())\n+            //                .unwrap_or(*sys::os::environ() as *const _);\n+            // FIXME: https://github.com/rust-lang/rust/issues/61993\n+            let envp_empty = CStringArray::with_capacity(0);\n+            let envp = match envp {\n+                Some(x) => x,\n+                None => envp_empty,\n+            };\n+            let envp = envp.as_ptr();\n+            let ret = rtp::rtpSpawn(\n+                self.get_argv()[0],                   // executing program\n+                self.get_argv().as_ptr() as *const _, // argv\n+                envp as *const _,                     // environment variable pointers\n+                100 as c_int,                         // initial priority\n+                0x16000,                                    // initial stack size. 0 defaults\n+                                                      // to 0x4000 in 32 bit and 0x8000 in 64 bit\n+                0,                                    // options\n+                0                                     // task options\n+            );\n+\n+            // Because FileDesc was not used, each duplicated file descriptor\n+            // needs to be closed manually\n+            if orig_stdin != libc::STDIN_FILENO {\n+                t!(cvt_r(|| libc::dup2(orig_stdin, libc::STDIN_FILENO)));\n+                libc::close(orig_stdin);\n+            }\n+            if orig_stdout != libc::STDOUT_FILENO {\n+                t!(cvt_r(|| libc::dup2(orig_stdout, libc::STDOUT_FILENO)));\n+                libc::close(orig_stdout);\n+            }\n+            if orig_stderr != libc::STDERR_FILENO {\n+                t!(cvt_r(|| libc::dup2(orig_stderr, libc::STDERR_FILENO)));\n+                libc::close(orig_stderr);\n+            }\n+\n+            if ret != rtp::RTP_ID_ERROR {\n+                p.pid = ret;\n+                Ok((p, ours))\n+            } else {\n+                Err(io::Error::last_os_error())\n+            }\n+        }\n+    }\n+\n+    pub fn exec(&mut self, default: Stdio) -> io::Error {\n+        let ret = Command::spawn(self, default, false);\n+        match ret {\n+            Ok(t) => unsafe {\n+                let mut status = 0 as c_int;\n+                libc::waitpid(t.0.pid, &mut status, 0);\n+                libc::exit(0);\n+            },\n+            Err(e) => e,\n+        }\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Processes\n+////////////////////////////////////////////////////////////////////////////////\n+\n+/// The unique id of the process (this should never be negative).\n+pub struct Process {\n+    pid: RTP_ID,\n+    status: Option<ExitStatus>,\n+}\n+\n+impl Process {\n+    pub fn id(&self) -> u32 {\n+        self.pid as u32\n+    }\n+\n+    pub fn kill(&mut self) -> io::Result<()> {\n+        // If we've already waited on this process then the pid can be recycled\n+        // and used for another process, and we probably shouldn't be killing\n+        // random processes, so just return an error.\n+        if self.status.is_some() {\n+            Err(Error::new(ErrorKind::InvalidInput,\n+                           \"invalid argument: can't kill an exited process\"))\n+        } else {\n+            cvt(unsafe { libc::kill(self.pid, libc::SIGKILL) }).map(|_| ())\n+        }\n+    }\n+\n+    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n+        use crate::sys::cvt_r;\n+        if let Some(status) = self.status {\n+            return Ok(status)\n+        }\n+        let mut status = 0 as c_int;\n+        cvt_r(|| unsafe { libc::waitpid(self.pid, &mut status, 0) })?;\n+        self.status = Some(ExitStatus::new(status));\n+        Ok(ExitStatus::new(status))\n+    }\n+\n+    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {\n+        if let Some(status) = self.status {\n+            return Ok(Some(status))\n+        }\n+        let mut status = 0 as c_int;\n+        let pid = cvt(unsafe {\n+            libc::waitpid(self.pid, &mut status, libc::WNOHANG)\n+        })?;\n+        if pid == 0 {\n+            Ok(None)\n+        } else {\n+            self.status = Some(ExitStatus::new(status));\n+            Ok(Some(ExitStatus::new(status)))\n+        }\n+    }\n+}"}, {"sha": "3e6e0017abcb582e31772cb2f3f0bf6b370b5c26", "filename": "src/libstd/sys/vxworks/process/rtp.rs", "status": "added", "additions": 298, "deletions": 0, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Frtp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Frtp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Frtp.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,298 @@\n+#![allow(non_camel_case_types, unused)]\n+\n+use libc::{self, c_int, size_t, c_char, BOOL, RTP_DESC, RTP_ID, TASK_ID};\n+\n+\n+// Copied directly from rtpLibCommon.h, rtpLib.h, signal.h and taskLibCommon.h (for task options)\n+\n+// ****     definitions for rtpLibCommon.h    ****\n+\n+pub const RTP_GLOBAL_SYMBOLS     : c_int = 0x01; // register global symbols for RTP\n+pub const RTP_LOCAL_SYMBOLS      : c_int = 0x02; // idem for local symbols\n+pub const RTP_ALL_SYMBOLS        : c_int = (RTP_GLOBAL_SYMBOLS | RTP_LOCAL_SYMBOLS);\n+pub const RTP_DEBUG              : c_int = 0x10; // set RTP in debug mode when created\n+pub const RTP_BUFFER_VAL_OFF     : c_int = 0x20; // disable buffer validation for all\n+                                                 // system calls issued from the RTP\n+pub const RTP_LOADED_WAIT        : c_int = 0x40; // Wait until the RTP is loaded\n+pub const RTP_CPU_AFFINITY_NONE  : c_int = 0x80; // Remove any CPU affinity (SMP)\n+\n+// Error Status codes\n+\n+pub const M_rtpLib : c_int = 178 << 16;\n+\n+pub const S_rtpLib_INVALID_FILE                   : c_int = (M_rtpLib | 1);\n+pub const S_rtpLib_INVALID_OPTION                 : c_int = (M_rtpLib | 2);\n+pub const S_rtpLib_ACCESS_DENIED                  : c_int = (M_rtpLib | 3);\n+pub const S_rtpLib_INVALID_RTP_ID                 : c_int = (M_rtpLib | 4);\n+pub const S_rtpLib_NO_SYMBOL_TABLE                : c_int = (M_rtpLib | 5);\n+pub const S_rtpLib_INVALID_SEGMENT_START_ADDRESS  : c_int = (M_rtpLib | 6);\n+pub const S_rtpLib_INVALID_SYMBOL_REGISTR_POLICY  : c_int = (M_rtpLib | 7);\n+pub const S_rtpLib_INSTANTIATE_FAILED             : c_int = (M_rtpLib | 8);\n+pub const S_rtpLib_INVALID_TASK_OPTION            : c_int = (M_rtpLib | 9);\n+pub const S_rtpLib_RTP_NAME_LENGTH_EXCEEDED       : c_int = (M_rtpLib | 10);    // rtpInfoGet\n+\n+pub const VX_RTP_NAME_LENGTH                      : c_int  = 255;    // max name length for diplay\n+\n+\n+// The 'status' field (32 bit integer) of a RTP holds the RTP state and status.\n+//\n+// NOTE: RTP_STATE_GET()    : read the RTP state(s)\n+//       RTP_STATE_PUT()    : write the RTP state(s)\n+//       RTP_STATE_SET()    : set a RTP state\n+//       RTP_STATE_UNSET()  : unset a RTP state\n+//\n+//       RTP_STATUS_GET()   : read the RTP status\n+//       RTP_STATUS_PUT()   : write the RTP status\n+//       RTP_STATUS_SET()   : set a RTP status\n+//       RTP_STATUS_UNSET() : unset a RTP status\n+//\n+// The PUT/SET/UNSET macros are available only in the kernel headers.\n+\n+\n+// RTP states\n+\n+pub const RTP_STATE_CREATE           : c_int  = 0x0001; // RrtpStructTP is under construction\n+pub const RTP_STATE_NORMAL           : c_int  = 0x0002; // RrtpStructTP is ready\n+pub const RTP_STATE_DELETE           : c_int  = 0x0004; // RrtpStructTP is being deleted\n+\n+pub const RTP_STATUS_STOP            : c_int  = 0x0100; // RTP hrtpStructas recieved stopped signal\n+pub const RTP_STATUS_ELECTED_DELETER : c_int  = 0x0200; // RTP drtpStructelete has started\n+\n+pub const RTP_STATE_MASK             : c_int  = (RTP_STATE_CREATE | RTP_STATE_NORMAL |\n+                                                 RTP_STATE_DELETE);\n+pub const RTP_STATUS_MASK            : c_int  = (RTP_STATUS_STOP | RTP_STATUS_ELECTED_DELETER);\n+\n+pub fn RTP_STATE_GET  (value : c_int) -> c_int {\n+    value & RTP_STATE_MASK\n+}\n+pub fn RTP_STATUS_GET (value : c_int) -> c_int {\n+    value & RTP_STATUS_MASK\n+}\n+\n+// Indicates that the RTP_ID returned is not valid.\n+\n+// RTP_ID_ERROR is supposed to be set to -1, but you can't set\n+// an unsigned value to a negative without casting, and you\n+// can't cast unless the size of the integer types are the same,\n+// but the size of RTP_ID may differ between kernel and user space.\n+// Bitwise or-ing min and max should get the same result.\n+pub const RTP_ID_ERROR : RTP_ID = RTP_ID::min_value() | RTP_ID::max_value();\n+\n+// IS_RTP_ C macros\n+\n+pub fn IS_RTP_STATE_NORMAL           (value : c_int) -> bool {\n+    (RTP_STATE_GET(value)  & RTP_STATE_NORMAL) == RTP_STATE_NORMAL\n+}\n+pub fn IS_RTP_STATE_CREATE           (value : c_int) -> bool {\n+    (RTP_STATE_GET(value)  & RTP_STATE_CREATE) == RTP_STATE_CREATE\n+}\n+pub fn IS_RTP_STATE_DELETE           (value : c_int) -> bool {\n+    (RTP_STATE_GET(value)  & RTP_STATE_DELETE) == RTP_STATE_DELETE\n+}\n+pub fn IS_RTP_STATUS_STOP            (value : c_int) -> bool {\n+    (RTP_STATUS_GET(value) & RTP_STATUS_STOP ) == RTP_STATUS_STOP\n+}\n+pub fn IS_RTP_STATUS_ELECTED_DELETER (value : c_int) -> bool {\n+    (RTP_STATUS_GET(value) &  RTP_STATUS_ELECTED_DELETER) == RTP_STATUS_ELECTED_DELETER\n+}\n+\n+// **** end of definitions for rtpLibCommon.h ****\n+\n+\n+\n+\n+// ****    definitions for rtpLib.h     ****\n+\n+pub fn rtpExit(exitCode : c_int) -> ! {\n+    unsafe{ libc::exit (exitCode) }\n+}\n+\n+/* rtpLib.h in the kernel\n+pub const RTP_DEL_VIA_TASK_DELETE : c_int  = 0x1;          // rtpDelete() via taskDestroy()\n+pub const RTP_DEL_FORCE           : c_int  = 0x2;          // Forceful  rtpDelete()\n+pub const RTP_ID_ANY              : RTP_ID = 0;            // used for when a kernel task\n+                                                           // wants to wait for the next\n+                                                           // RTP to finish\n+\n+\n+// Function pointers\n+\n+pub type RTP_PRE_CREATE_HOOK    = size_t;\n+pub type RTP_POST_CREATE_HOOK   = size_t;\n+pub type RTP_INIT_COMPLETE_HOOK = size_t;\n+pub type RTP_DELETE_HOOK        = size_t;\n+*/\n+\n+// **** end of definitions for rtpLib.h ****\n+\n+\n+\n+\n+\n+// ****     definitions for signal.h    ****\n+pub fn rtpKill(rtpId : RTP_ID, signo : c_int) -> c_int {\n+    unsafe{ libc::kill(rtpId as c_int, signo) }\n+}\n+\n+pub fn rtpSigqueue(rtpId : RTP_ID, signo : c_int, value : size_t) -> c_int {\n+    unsafe{ libc::sigqueue(rtpId as c_int, signo, value) }\n+}\n+\n+pub fn _rtpSigqueue(rtpId : RTP_ID, signo : c_int, value : *mut size_t, code : c_int) -> c_int {\n+    unsafe{ libc::_sigqueue(rtpId, signo, value, code) }\n+}\n+\n+pub fn taskRaise(signo : c_int) -> c_int {\n+    unsafe{ libc::taskKill(libc::taskIdSelf(), signo) }\n+}\n+pub fn rtpRaise(signo : c_int) -> c_int {\n+    unsafe{ libc::raise(signo) }\n+}\n+\n+// **** end of definitions for signal.h ****\n+\n+\n+\n+// ****     definitions for taskLibCommon.h    ****\n+pub const VX_PRIVATE_ENV      : c_int = 0x0080;  // 1 = private environment variables\n+pub const VX_NO_STACK_FILL    : c_int = 0x0100;  // 1 = avoid stack fill of 0xee\n+pub const VX_PRIVATE_UMASK    : c_int = 0x0400;  // 1 = private file creation mode mask\n+pub const VX_TASK_NOACTIVATE  : c_int = 0x2000;  // taskOpen() does not taskActivate()\n+pub const VX_NO_STACK_PROTECT : c_int = 0x4000;  // no over/underflow stack protection,\n+                                                 // stack space remains executable\n+\n+// define for all valid user task options\n+\n+pub const VX_USR_TASK_OPTIONS_BASE: c_int = (VX_PRIVATE_ENV      |\n+                                             VX_NO_STACK_FILL    |\n+                                             VX_TASK_NOACTIVATE  |\n+                                             VX_NO_STACK_PROTECT |\n+                                             VX_PRIVATE_UMASK);\n+\n+// **** end of definitions for taskLibCommon.h ****\n+\n+\n+\n+extern \"C\" {\n+// functions in rtpLibCommon.h\n+\n+// forward declarations\n+    pub fn rtpSpawn (\n+        pubrtpFileName : *const c_char,\n+        argv           : *const *const c_char,\n+        envp           : *const *const c_char,\n+        priority       : c_int,\n+        uStackSize     : size_t,\n+        options        : c_int,\n+        taskOptions    : c_int,\n+    ) -> RTP_ID;\n+\n+    pub fn rtpInfoGet (\n+        rtpId     : RTP_ID,\n+        rtpStruct : *mut RTP_DESC,\n+    ) -> c_int;\n+\n+/* functions in rtpLib.h for kernel\n+\n+\n+    // function declarations\n+\n+    pub fn rtpDelete (\n+        id      : RTP_ID,\n+        options : c_int,\n+        status  : c_int,\n+    ) -> c_int;\n+\n+    pub fn rtpDeleteForce (\n+        rtpId : RTP_ID\n+    ) -> c_int;\n+\n+    pub fn rtpShow (\n+        rtpNameOrId : *mut c_char,\n+        level       : c_int,\n+    ) -> BOOL;\n+\n+    // RTP signals are always present when RTPs are included.  The public RTP\n+    // signal APIs are declared here.\n+\n+\n+    pub fn rtpKill (\n+        rtpId : RTP_ID,\n+        signo : c_int,\n+    ) -> c_int;\n+\n+    pub fn rtpSigqueue (\n+        rtpId : RTP_ID,\n+        signo : c_int,\n+        value : size_t, // Actual type is const union sigval value,\n+                        // which is a union of int and void *\n+    ) -> c_int;\n+\n+    pub fn rtpTaskKill (\n+        tid   : TASK_ID,\n+        signo : c_int,\n+    ) -> c_int;\n+\n+    pub fn rtpTaskSigqueue (\n+        tid   : TASK_ID,\n+        signo : c_int,\n+        value : const size_t, // Actual type is const union sigval,\n+                        // which is a union of int and void *\n+    ) -> c_int;\n+\n+    pub fn rtpWait (\n+        rtpWaitId : RTP_ID,\n+        timeout   : libc::alloc_jemalloc_Vx_ticks_t,\n+        pRtpId    : *mut RTP_ID,\n+        pStatus   : *mut c_int,\n+    ) -> c_int;\n+\n+                             // Other public functions\n+\n+\n+    pub fn rtpPreCreateHookAdd     (\n+        hook      : RTP_PRE_CREATE_HOOK,\n+        addToHead : BOOL,\n+    ) -> c_int;\n+\n+    pub fn rtpPreCreateHookDelete  (\n+        hook      : RTP_POST_CREATE_HOOK,\n+    ) -> c_int;\n+\n+    pub fn rtpPostCreateHookAdd    (\n+        hook      : RTP_POST_CREATE_HOOK,\n+        addToHead : BOOL,\n+    ) -> c_int;\n+\n+    pub fn rtpPostCreateHookDelete (\n+        hook      : RTP_POST_CREATE_HOOK,\n+    ) -> c_int;\n+\n+    pub fn rtpInitCompleteHookAdd  (\n+        hook      : RTP_INIT_COMPLETE_HOOK,\n+        addToHead : BOOL,\n+    ) -> c_int;\n+\n+    pub fn rtpInitCompleteHookDelete (\n+        hook      : RTP_INIT_COMPLETE_HOOK,\n+    ) -> c_int;\n+\n+    pub fn rtpDeleteHookAdd        (\n+        hook      : RTP_DELETE_HOOK,\n+        addToHead : BOOL,\n+    ) -> c_int;\n+\n+    pub fn rtpDeleteHookDelete     (\n+        hook      : RTP_DELETE_HOOK,\n+    ) -> c_int;\n+\n+    pub fn rtpMemShow              (\n+        rtpNameOrId : *mut c_char,\n+        level       : c_int,\n+    ) -> c_int;\n+\n+    pub fn rtpHookShow             (\n+\n+    );\n+*/\n+}"}, {"sha": "1ec0cbe4dcf5bfe797700fa5f52ed0bd18f1bd4d", "filename": "src/libstd/sys/vxworks/rand.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Frand.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,31 @@\n+use crate::mem;\n+use crate::slice;\n+\n+pub fn hashmap_random_keys() -> (u64, u64) {\n+    let mut v = (0, 0);\n+    unsafe {\n+        let view = slice::from_raw_parts_mut(&mut v as *mut _ as *mut u8,\n+                                             mem::size_of_val(&v));\n+        imp::fill_bytes(view);\n+    }\n+    return v\n+}\n+\n+mod imp {\n+    use libc;\n+    use crate::io;\n+\n+    extern \"C\" {\n+        fn randBytes (randBuf: *mut libc::c_uchar,\n+                      numOfBytes: libc::c_int) -> libc::c_int;\n+    }\n+\n+    pub fn fill_bytes(v: &mut [u8]) {\n+        let ret = unsafe {\n+            randBytes(v.as_mut_ptr() as *mut libc::c_uchar, v.len() as libc::c_int)\n+        };\n+        if ret == -1 {\n+            panic!(\"couldn't generate random bytes: {}\", io::Error::last_os_error());\n+        }\n+    }\n+}"}, {"sha": "718f422ed11e635b7fdc5d47b51ee9b11691e79d", "filename": "src/libstd/sys/vxworks/rwlock.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Frwlock.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,113 @@\n+use libc;\n+use crate::cell::UnsafeCell;\n+use crate::sync::atomic::{AtomicUsize, Ordering};\n+\n+pub struct RWLock {\n+    inner: UnsafeCell<libc::pthread_rwlock_t>,\n+    write_locked: UnsafeCell<bool>,\n+    num_readers: AtomicUsize,\n+}\n+\n+unsafe impl Send for RWLock {}\n+unsafe impl Sync for RWLock {}\n+\n+impl RWLock {\n+    pub const fn new() -> RWLock {\n+        RWLock {\n+            inner: UnsafeCell::new(libc::PTHREAD_RWLOCK_INITIALIZER),\n+            write_locked: UnsafeCell::new(false),\n+            num_readers: AtomicUsize::new(0),\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn read(&self) {\n+        let r = libc::pthread_rwlock_rdlock(self.inner.get());\n+        if r == libc::EAGAIN {\n+            panic!(\"rwlock maximum reader count exceeded\");\n+        } else if r == libc::EDEADLK || *self.write_locked.get() {\n+            if r == 0 {\n+                self.raw_unlock();\n+            }\n+        panic!(\"rwlock read lock would result in deadlock\");\n+        } else {\n+            debug_assert_eq!(r, 0);\n+            self.num_readers.fetch_add(1, Ordering::Relaxed);\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn try_read(&self) -> bool {\n+        let r = libc::pthread_rwlock_tryrdlock(self.inner.get());\n+        if r == 0 {\n+            if *self.write_locked.get() {\n+                self.raw_unlock();\n+                false\n+            } else {\n+                self.num_readers.fetch_add(1, Ordering::Relaxed);\n+                true\n+            }\n+        } else {\n+            false\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn write(&self) {\n+        let r = libc::pthread_rwlock_wrlock(self.inner.get());\n+        // See comments above for why we check for EDEADLK and write_locked. We\n+        // also need to check that num_readers is 0.\n+        if r == libc::EDEADLK || *self.write_locked.get() ||\n+            self.num_readers.load(Ordering::Relaxed) != 0 {\n+            if r == 0 {\n+                self.raw_unlock();\n+            }\n+        panic!(\"rwlock write lock would result in deadlock\");\n+        } else {\n+            debug_assert_eq!(r, 0);\n+        }\n+        *self.write_locked.get() = true;\n+    }\n+\n+    #[inline]\n+    pub unsafe fn try_write(&self) -> bool {\n+        let r = libc::pthread_rwlock_trywrlock(self.inner.get());\n+        if r == 0 {\n+            if *self.write_locked.get() || self.num_readers.load(Ordering::Relaxed) != 0 {\n+                self.raw_unlock();\n+                false\n+            } else {\n+                *self.write_locked.get() = true;\n+                true\n+            }\n+            } else {\n+                false\n+        }\n+    }\n+\n+    #[inline]\n+    unsafe fn raw_unlock(&self) {\n+        let r = libc::pthread_rwlock_unlock(self.inner.get());\n+        debug_assert_eq!(r, 0);\n+    }\n+\n+    #[inline]\n+    pub unsafe fn read_unlock(&self) {\n+        debug_assert!(!*self.write_locked.get());\n+        self.num_readers.fetch_sub(1, Ordering::Relaxed);\n+        self.raw_unlock();\n+    }\n+\n+     #[inline]\n+    pub unsafe fn write_unlock(&self) {\n+        debug_assert_eq!(self.num_readers.load(Ordering::Relaxed), 0);\n+        debug_assert!(*self.write_locked.get());\n+        *self.write_locked.get() = false;\n+        self.raw_unlock();\n+    }\n+    #[inline]\n+    pub unsafe fn destroy(&self) {\n+        let r = libc::pthread_rwlock_destroy(self.inner.get());\n+        debug_assert_eq!(r, 0);\n+    }\n+}"}, {"sha": "561279e82785c317429a7cb0ce075581f93d5d0b", "filename": "src/libstd/sys/vxworks/stack_overflow.rs", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fstack_overflow.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,209 @@\n+#![cfg_attr(test, allow(dead_code))]\n+\n+use self::imp::{make_handler, drop_handler};\n+\n+pub use self::imp::cleanup;\n+pub use self::imp::init;\n+\n+pub struct Handler {\n+    _data: *mut libc::c_void\n+}\n+\n+impl Handler {\n+    pub unsafe fn new() -> Handler {\n+        make_handler()\n+    }\n+}\n+\n+impl Drop for Handler {\n+    fn drop(&mut self) {\n+        unsafe {\n+            drop_handler(self);\n+        }\n+    }\n+}\n+\n+#[cfg(any(target_os = \"linux\",\n+          target_os = \"macos\",\n+          target_os = \"bitrig\",\n+          target_os = \"dragonfly\",\n+          target_os = \"freebsd\",\n+          target_os = \"solaris\",\n+          all(target_os = \"netbsd\", not(target_vendor = \"rumprun\")),\n+          target_os = \"openbsd\"))]\n+mod imp {\n+    use super::Handler;\n+    use crate::mem;\n+    use crate::ptr;\n+\n+    use libc::{sigaltstack, SIGSTKSZ, SS_DISABLE};\n+    use libc::{sigaction, SIGBUS, SIG_DFL,\n+               SA_SIGINFO, SA_ONSTACK, sighandler_t};\n+    use libc::{mmap, munmap};\n+    use libc::{SIGSEGV, PROT_READ, PROT_WRITE, MAP_PRIVATE, MAP_ANON};\n+    use libc::MAP_FAILED;\n+\n+    use crate::sys_common::thread_info;\n+\n+\n+    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+    unsafe fn siginfo_si_addr(info: *mut libc::siginfo_t) -> usize {\n+        #[repr(C)]\n+        struct siginfo_t {\n+            a: [libc::c_int; 3], // si_signo, si_errno, si_code\n+            si_addr: *mut libc::c_void,\n+        }\n+\n+        (*(info as *const siginfo_t)).si_addr as usize\n+    }\n+\n+    #[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n+    unsafe fn siginfo_si_addr(info: *mut libc::siginfo_t) -> usize {\n+        (*info).si_addr as usize\n+    }\n+\n+    // Signal handler for the SIGSEGV and SIGBUS handlers. We've got guard pages\n+    // (unmapped pages) at the end of every thread's stack, so if a thread ends\n+    // up running into the guard page it'll trigger this handler. We want to\n+    // detect these cases and print out a helpful error saying that the stack\n+    // has overflowed. All other signals, however, should go back to what they\n+    // were originally supposed to do.\n+    //\n+    // This handler currently exists purely to print an informative message\n+    // whenever a thread overflows its stack. We then abort to exit and\n+    // indicate a crash, but to avoid a misleading SIGSEGV that might lead\n+    // users to believe that unsafe code has accessed an invalid pointer; the\n+    // SIGSEGV encountered when overflowing the stack is expected and\n+    // well-defined.\n+    //\n+    // If this is not a stack overflow, the handler un-registers itself and\n+    // then returns (to allow the original signal to be delivered again).\n+    // Returning from this kind of signal handler is technically not defined\n+    // to work when reading the POSIX spec strictly, but in practice it turns\n+    // out many large systems and all implementations allow returning from a\n+    // signal handler to work. For a more detailed explanation see the\n+    // comments on #26458.\n+    unsafe extern fn signal_handler(signum: libc::c_int,\n+                                    info: *mut libc::siginfo_t,\n+                                    _data: *mut libc::c_void) {\n+        use crate::sys_common::util::report_overflow;\n+\n+        let guard = thread_info::stack_guard().unwrap_or(0..0);\n+        let addr = siginfo_si_addr(info);\n+\n+        // If the faulting address is within the guard page, then we print a\n+        // message saying so and abort.\n+        if guard.start <= addr && addr < guard.end {\n+            report_overflow();\n+            rtabort!(\"stack overflow\");\n+        } else {\n+            // Unregister ourselves by reverting back to the default behavior.\n+            let mut action: sigaction = mem::zeroed();\n+            action.sa_sigaction = SIG_DFL;\n+            sigaction(signum, &action, ptr::null_mut());\n+\n+            // See comment above for why this function returns.\n+        }\n+    }\n+\n+    static mut MAIN_ALTSTACK: *mut libc::c_void = ptr::null_mut();\n+\n+    pub unsafe fn init() {\n+        let mut action: sigaction = mem::zeroed();\n+        action.sa_flags = SA_SIGINFO | SA_ONSTACK;\n+        action.sa_sigaction = signal_handler as sighandler_t;\n+        sigaction(SIGSEGV, &action, ptr::null_mut());\n+        sigaction(SIGBUS, &action, ptr::null_mut());\n+\n+        let handler = make_handler();\n+        MAIN_ALTSTACK = handler._data;\n+        mem::forget(handler);\n+    }\n+\n+    pub unsafe fn cleanup() {\n+        Handler { _data: MAIN_ALTSTACK };\n+    }\n+\n+    unsafe fn get_stackp() -> *mut libc::c_void {\n+        let stackp = mmap(ptr::null_mut(),\n+                          SIGSTKSZ,\n+                          PROT_READ | PROT_WRITE,\n+                          MAP_PRIVATE | MAP_ANON,\n+                          -1,\n+                          0);\n+        if stackp == MAP_FAILED {\n+            panic!(\"failed to allocate an alternative stack\");\n+        }\n+        stackp\n+    }\n+\n+    #[cfg(any(target_os = \"linux\",\n+              target_os = \"macos\",\n+              target_os = \"bitrig\",\n+              target_os = \"freebsd\",\n+              target_os = \"netbsd\",\n+              target_os = \"openbsd\",\n+              target_os = \"solaris\"))]\n+    unsafe fn get_stack() -> libc::stack_t {\n+        libc::stack_t { ss_sp: get_stackp(), ss_flags: 0, ss_size: SIGSTKSZ }\n+    }\n+\n+    #[cfg(target_os = \"dragonfly\")]\n+    unsafe fn get_stack() -> libc::stack_t {\n+        libc::stack_t { ss_sp: get_stackp() as *mut i8, ss_flags: 0, ss_size: SIGSTKSZ }\n+    }\n+\n+    pub unsafe fn make_handler() -> Handler {\n+        let mut stack = mem::zeroed();\n+        sigaltstack(ptr::null(), &mut stack);\n+        // Configure alternate signal stack, if one is not already set.\n+        if stack.ss_flags & SS_DISABLE != 0 {\n+            stack = get_stack();\n+            sigaltstack(&stack, ptr::null_mut());\n+            Handler { _data: stack.ss_sp as *mut libc::c_void }\n+        } else {\n+            Handler { _data: ptr::null_mut() }\n+        }\n+    }\n+\n+    pub unsafe fn drop_handler(handler: &mut Handler) {\n+        if !handler._data.is_null() {\n+            let stack =  libc::stack_t {\n+                ss_sp: ptr::null_mut(),\n+                ss_flags: SS_DISABLE,\n+                // Workaround for bug in macOS implementation of sigaltstack\n+                // UNIX2003 which returns ENOMEM when disabling a stack while\n+                // passing ss_size smaller than MINSIGSTKSZ. According to POSIX\n+                // both ss_sp and ss_size should be ignored in this case.\n+                ss_size: SIGSTKSZ,\n+            };\n+            sigaltstack(&stack, ptr::null_mut());\n+            munmap(handler._data, SIGSTKSZ);\n+        }\n+    }\n+}\n+\n+#[cfg(not(any(target_os = \"linux\",\n+              target_os = \"macos\",\n+              target_os = \"bitrig\",\n+              target_os = \"dragonfly\",\n+              target_os = \"freebsd\",\n+              target_os = \"solaris\",\n+              all(target_os = \"netbsd\", not(target_vendor = \"rumprun\")),\n+              target_os = \"openbsd\")))]\n+mod imp {\n+    use crate::ptr;\n+\n+    pub unsafe fn init() {\n+    }\n+\n+    pub unsafe fn cleanup() {\n+    }\n+\n+    pub unsafe fn make_handler() -> super::Handler {\n+        super::Handler { _data: ptr::null_mut() }\n+    }\n+\n+    pub unsafe fn drop_handler(_handler: &mut super::Handler) {\n+    }\n+}"}, {"sha": "35f163bbdb10fd7db3c2ebbd2b80450743e1256e", "filename": "src/libstd/sys/vxworks/stdio.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fstdio.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,63 @@\n+use crate::io;\n+use crate::sys::fd::FileDesc;\n+\n+pub struct Stdin(());\n+pub struct Stdout(());\n+pub struct Stderr(());\n+\n+impl Stdin {\n+    pub fn new() -> io::Result<Stdin> { Ok(Stdin(())) }\n+}\n+\n+impl io::Read for Stdin {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        let fd = FileDesc::new(libc::STDIN_FILENO);\n+        let ret = fd.read(buf);\n+        fd.into_raw(); // do not close this FD\n+        ret\n+    }\n+}\n+\n+impl Stdout {\n+    pub fn new() -> io::Result<Stdout> { Ok(Stdout(())) }\n+}\n+\n+impl io::Write for Stdout {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        let fd = FileDesc::new(libc::STDOUT_FILENO);\n+        let ret = fd.write(buf);\n+        fd.into_raw(); // do not close this FD\n+        ret\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+impl Stderr {\n+    pub fn new() -> io::Result<Stderr> { Ok(Stderr(())) }\n+}\n+\n+impl io::Write for Stderr {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        let fd = FileDesc::new(libc::STDERR_FILENO);\n+        let ret = fd.write(buf);\n+        fd.into_raw(); // do not close this FD\n+        ret\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+pub fn is_ebadf(err: &io::Error) -> bool {\n+    err.raw_os_error() == Some(libc::EBADF as i32)\n+}\n+\n+pub const STDIN_BUF_SIZE: usize = crate::sys_common::io::DEFAULT_BUF_SIZE;\n+\n+pub fn panic_output() -> Option<impl io::Write> {\n+    Stderr::new().ok()\n+}"}, {"sha": "810dbad7284e3b1492668214f2fc3f628f01e105", "filename": "src/libstd/sys/vxworks/thread.rs", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fthread.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,179 @@\n+//use crate::boxed::FnBox;\n+use crate::cmp;\n+use crate::ffi::CStr;\n+use crate::io;\n+use crate::mem;\n+use crate::ptr;\n+use crate::sys::os;\n+use crate::time::Duration;\n+\n+use crate::sys_common::thread::*;\n+\n+#[cfg(not(target_os = \"l4re\"))]\n+pub const DEFAULT_MIN_STACK_SIZE: usize = 2 * 1024 * 1024;\n+#[cfg(target_os = \"l4re\")]\n+pub const DEFAULT_MIN_STACK_SIZE: usize = 1024 * 1024;\n+\n+pub struct Thread {\n+    id: libc::pthread_t,\n+}\n+\n+// Some platforms may have pthread_t as a pointer in which case we still want\n+// a thread to be Send/Sync\n+unsafe impl Send for Thread {}\n+unsafe impl Sync for Thread {}\n+\n+// The pthread_attr_setstacksize symbol doesn't exist in the emscripten libc,\n+// so we have to not link to it to satisfy emcc's ERROR_ON_UNDEFINED_SYMBOLS.\n+#[cfg(not(target_os = \"emscripten\"))]\n+unsafe fn pthread_attr_setstacksize(attr: *mut libc::pthread_attr_t,\n+                                    stack_size: libc::size_t) -> libc::c_int {\n+    libc::pthread_attr_setstacksize(attr, stack_size)\n+}\n+\n+#[cfg(target_os = \"emscripten\")]\n+unsafe fn pthread_attr_setstacksize(_attr: *mut libc::pthread_attr_t,\n+                                    _stack_size: libc::size_t) -> libc::c_int {\n+    panic!()\n+}\n+\n+impl Thread {\n+    // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n+    pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>)\n+                          -> io::Result<Thread> {\n+        let p = box p;\n+        let mut native: libc::pthread_t = mem::zeroed();\n+        let mut attr: libc::pthread_attr_t = mem::zeroed();\n+        assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n+\n+        let stack_size = cmp::max(stack, min_stack_size(&attr));\n+\n+        match pthread_attr_setstacksize(&mut attr,\n+                                        stack_size) {\n+            0 => {}\n+            n => {\n+                assert_eq!(n, libc::EINVAL);\n+                // EINVAL means |stack_size| is either too small or not a\n+                // multiple of the system page size.  Because it's definitely\n+                // >= PTHREAD_STACK_MIN, it must be an alignment issue.\n+                // Round up to the nearest page and try again.\n+                let page_size = os::page_size();\n+                let stack_size = (stack_size + page_size - 1) &\n+                                 (-(page_size as isize - 1) as usize - 1);\n+                assert_eq!(libc::pthread_attr_setstacksize(&mut attr,\n+                                                           stack_size), 0);\n+            }\n+        };\n+\n+        let ret = libc::pthread_create(&mut native, &attr, thread_start,\n+                                       &*p as *const _ as *mut _);\n+        assert_eq!(libc::pthread_attr_destroy(&mut attr), 0);\n+\n+        return if ret != 0 {\n+            Err(io::Error::from_raw_os_error(ret))\n+        } else {\n+            mem::forget(p); // ownership passed to pthread_create\n+            Ok(Thread { id: native })\n+        };\n+\n+        extern fn thread_start(main: *mut libc::c_void) -> *mut libc::c_void {\n+            unsafe { start_thread(main as *mut u8); }\n+            ptr::null_mut()\n+        }\n+    }\n+\n+    pub fn yield_now() {\n+        let ret = unsafe { libc::sched_yield() };\n+        debug_assert_eq!(ret, 0);\n+    }\n+\n+    pub fn set_name(_name: &CStr) {\n+        assert!(false, \"FIXME: set_name\");\n+    }\n+\n+    pub fn sleep(dur: Duration) {\n+        let mut secs = dur.as_secs();\n+        let mut nsecs = dur.subsec_nanos() as _;\n+\n+        // If we're awoken with a signal then the return value will be -1 and\n+        // nanosleep will fill in `ts` with the remaining time.\n+        unsafe {\n+            while secs > 0 || nsecs > 0 {\n+                let mut ts = libc::timespec {\n+                    tv_sec: cmp::min(libc::time_t::max_value() as u64, secs) as libc::time_t,\n+                    tv_nsec: nsecs,\n+                };\n+                secs -= ts.tv_sec as u64;\n+                if libc::nanosleep(&ts, &mut ts) == -1 {\n+                    assert_eq!(os::errno(), libc::EINTR);\n+                    secs += ts.tv_sec as u64;\n+                    nsecs = ts.tv_nsec;\n+                } else {\n+                    nsecs = 0;\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn join(self) {\n+        unsafe {\n+            let ret = libc::pthread_join(self.id, ptr::null_mut());\n+            mem::forget(self);\n+            assert!(ret == 0,\n+                    \"failed to join thread: {}\", io::Error::from_raw_os_error(ret));\n+        }\n+    }\n+\n+    pub fn id(&self) -> libc::pthread_t { self.id }\n+\n+    pub fn into_id(self) -> libc::pthread_t {\n+        let id = self.id;\n+        mem::forget(self);\n+        id\n+    }\n+}\n+\n+impl Drop for Thread {\n+    fn drop(&mut self) {\n+        let ret = unsafe { libc::pthread_detach(self.id) };\n+        debug_assert_eq!(ret, 0);\n+    }\n+}\n+\n+#[cfg_attr(test, allow(dead_code))]\n+pub mod guard {\n+    use crate::ops::Range;\n+    pub type Guard = Range<usize>;\n+    pub unsafe fn current() -> Option<Guard> { None }\n+    pub unsafe fn init() -> Option<Guard> { None }\n+    pub unsafe fn deinit() {}\n+}\n+\n+// glibc >= 2.15 has a __pthread_get_minstack() function that returns\n+// PTHREAD_STACK_MIN plus however many bytes are needed for thread-local\n+// storage.  We need that information to avoid blowing up when a small stack\n+// is created in an application with big thread-local storage requirements.\n+// See #6233 for rationale and details.\n+#[cfg(target_os = \"linux\")]\n+#[allow(deprecated)]\n+fn min_stack_size(attr: *const libc::pthread_attr_t) -> usize {\n+    weak!(fn __pthread_get_minstack(*const libc::pthread_attr_t) -> libc::size_t);\n+\n+    match __pthread_get_minstack.get() {\n+        None => libc::PTHREAD_STACK_MIN,\n+        Some(f) => unsafe { f(attr) },\n+    }\n+}\n+\n+// No point in looking up __pthread_get_minstack() on non-glibc\n+// platforms.\n+#[cfg(all(not(target_os = \"linux\"),\n+          not(target_os = \"netbsd\")))]\n+fn min_stack_size(_: *const libc::pthread_attr_t) -> usize {\n+    libc::PTHREAD_STACK_MIN\n+}\n+\n+#[cfg(target_os = \"netbsd\")]\n+fn min_stack_size(_: *const libc::pthread_attr_t) -> usize {\n+    2048 // just a guess\n+}"}, {"sha": "ac615b76b36245650492eb3d883557f5b9ed2ae3", "filename": "src/libstd/sys/vxworks/thread_local.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fthread_local.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,34 @@\n+#![allow(dead_code)] // not used on all platforms\n+\n+use crate::mem;\n+\n+pub type Key = libc::pthread_key_t;\n+\n+#[inline]\n+pub unsafe fn create(dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n+    let mut key = 0;\n+    assert_eq!(libc::pthread_key_create(&mut key, mem::transmute(dtor)), 0);\n+    key\n+}\n+\n+#[inline]\n+pub unsafe fn set(key: Key, value: *mut u8) {\n+    let r = libc::pthread_setspecific(key, value as *mut _);\n+    debug_assert_eq!(r, 0);\n+}\n+\n+#[inline]\n+pub unsafe fn get(key: Key) -> *mut u8 {\n+    libc::pthread_getspecific(key) as *mut u8\n+}\n+\n+#[inline]\n+pub unsafe fn destroy(key: Key) {\n+    let r = libc::pthread_key_delete(key);\n+    debug_assert_eq!(r, 0);\n+}\n+\n+#[inline]\n+pub fn requires_synchronized_create() -> bool {\n+    false\n+}"}, {"sha": "cb3a4241ea601e1f1bc9a15a7f1570a6fb15ea40", "filename": "src/libstd/sys/vxworks/time.rs", "status": "added", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Ftime.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,224 @@\n+use crate::cmp::Ordering;\n+use libc;\n+use crate::time::Duration;\n+use ::core::hash::{Hash, Hasher};\n+\n+pub use self::inner::{Instant, SystemTime, UNIX_EPOCH};\n+use crate::convert::TryInto;\n+\n+const NSEC_PER_SEC: u64 = 1_000_000_000;\n+\n+#[derive(Copy, Clone)]\n+struct Timespec {\n+    t: libc::timespec,\n+}\n+\n+impl Timespec {\n+    const fn zero() -> Timespec {\n+        Timespec {\n+            t: libc::timespec { tv_sec: 0, tv_nsec: 0 },\n+        }\n+    }\n+    fn sub_timespec(&self, other: &Timespec) -> Result<Duration, Duration> {\n+        if self >= other {\n+            Ok(if self.t.tv_nsec >= other.t.tv_nsec {\n+                Duration::new((self.t.tv_sec - other.t.tv_sec) as u64,\n+                                (self.t.tv_nsec - other.t.tv_nsec) as u32)\n+                } else {\n+                    Duration::new((self.t.tv_sec - 1 - other.t.tv_sec) as u64,\n+                        self.t.tv_nsec as u32 + (NSEC_PER_SEC as u32) -\n+                        other.t.tv_nsec as u32)\n+                })\n+        } else {\n+            match other.sub_timespec(self) {\n+                Ok(d) => Err(d),\n+                Err(d) => Ok(d),\n+            }\n+        }\n+    }\n+\n+    fn checked_add_duration(&self, other: &Duration) -> Option<Timespec> {\n+        let mut secs = other\n+            .as_secs()\n+            .try_into() // <- target type would be `libc::time_t`\n+            .ok()\n+            .and_then(|secs| self.t.tv_sec.checked_add(secs))?;\n+\n+        // Nano calculations can't overflow because nanos are <1B which fit\n+        // in a u32.\n+        let mut nsec = other.subsec_nanos() + self.t.tv_nsec as u32;\n+        if nsec >= NSEC_PER_SEC as u32 {\n+            nsec -= NSEC_PER_SEC as u32;\n+            secs = secs.checked_add(1)?;\n+        }\n+        Some(Timespec {\n+            t: libc::timespec {\n+                tv_sec: secs,\n+                tv_nsec: nsec as _,\n+            },\n+        })\n+    }\n+\n+    fn checked_sub_duration(&self, other: &Duration) -> Option<Timespec> {\n+        let mut secs = other\n+            .as_secs()\n+            .try_into() // <- target type would be `libc::time_t`\n+            .ok()\n+            .and_then(|secs| self.t.tv_sec.checked_sub(secs))?;\n+\n+        // Similar to above, nanos can't overflow.\n+        let mut nsec = self.t.tv_nsec as i32 - other.subsec_nanos() as i32;\n+        if nsec < 0 {\n+            nsec += NSEC_PER_SEC as i32;\n+            secs = secs.checked_sub(1)?;\n+        }\n+        Some(Timespec {\n+            t: libc::timespec {\n+                tv_sec: secs,\n+                tv_nsec: nsec as _,\n+            },\n+        })\n+    }\n+}\n+\n+impl PartialEq for Timespec {\n+    fn eq(&self, other: &Timespec) -> bool {\n+        self.t.tv_sec == other.t.tv_sec && self.t.tv_nsec == other.t.tv_nsec\n+    }\n+}\n+\n+impl Eq for Timespec {}\n+\n+impl PartialOrd for Timespec {\n+    fn partial_cmp(&self, other: &Timespec) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+impl Ord for Timespec {\n+    fn cmp(&self, other: &Timespec) -> Ordering {\n+        let me = (self.t.tv_sec, self.t.tv_nsec);\n+        let other = (other.t.tv_sec, other.t.tv_nsec);\n+        me.cmp(&other)\n+    }\n+}\n+\n+impl Hash for Timespec {\n+    fn hash<H : Hasher>(&self, state: &mut H) {\n+        self.t.tv_sec.hash(state);\n+        self.t.tv_nsec.hash(state);\n+    }\n+}\n+mod inner {\n+    use crate::fmt;\n+    use libc;\n+    use crate::sys::cvt;\n+    use crate::time::Duration;\n+\n+    use super::Timespec;\n+\n+    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+    pub struct Instant {\n+        t: Timespec,\n+    }\n+\n+    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+    pub struct SystemTime {\n+        t: Timespec,\n+    }\n+\n+    pub const UNIX_EPOCH: SystemTime = SystemTime {\n+        t: Timespec {\n+            t: libc::timespec {\n+                tv_sec: 0,\n+                tv_nsec: 0,\n+            },\n+        },\n+    };\n+\n+    impl Instant {\n+        pub fn now() -> Instant {\n+            Instant { t: now(libc::CLOCK_MONOTONIC) }\n+        }\n+\n+        pub const fn zero() -> Instant {\n+            Instant {\n+                t: Timespec::zero(),\n+            }\n+        }\n+\n+        pub fn actually_monotonic() -> bool {\n+            true\n+        }\n+\n+        pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n+            self.t.sub_timespec(&other.t).ok()\n+        }\n+\n+        pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {\n+            Some(Instant { t: self.t.checked_add_duration(other)? })\n+        }\n+\n+        pub fn checked_sub_duration(&self, other: &Duration) -> Option<Instant> {\n+            Some(Instant { t: self.t.checked_sub_duration(other)? })\n+        }\n+    }\n+\n+    impl fmt::Debug for Instant {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            f.debug_struct(\"Instant\")\n+             .field(\"tv_sec\", &self.t.t.tv_sec)\n+             .field(\"tv_nsec\", &self.t.t.tv_nsec)\n+             .finish()\n+        }\n+    }\n+\n+    impl SystemTime {\n+        pub fn now() -> SystemTime {\n+            SystemTime { t: now(libc::CLOCK_REALTIME) }\n+        }\n+\n+        pub fn sub_time(&self, other: &SystemTime)\n+                        -> Result<Duration, Duration> {\n+            self.t.sub_timespec(&other.t)\n+        }\n+\n+        pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {\n+            Some(SystemTime { t: self.t.checked_add_duration(other)? })\n+        }\n+\n+        pub fn checked_sub_duration(&self, other: &Duration) -> Option<SystemTime> {\n+            Some(SystemTime { t: self.t.checked_sub_duration(other)? })\n+        }\n+    }\n+\n+    impl From<libc::timespec> for SystemTime {\n+        fn from(t: libc::timespec) -> SystemTime {\n+            SystemTime { t: Timespec { t: t } }\n+        }\n+    }\n+\n+    impl fmt::Debug for SystemTime {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            f.debug_struct(\"SystemTime\")\n+             .field(\"tv_sec\", &self.t.t.tv_sec)\n+             .field(\"tv_nsec\", &self.t.t.tv_nsec)\n+             .finish()\n+        }\n+    }\n+\n+    pub type clock_t = libc::c_int;\n+\n+    fn now(clock: clock_t) -> Timespec {\n+        let mut t = Timespec {\n+            t: libc::timespec {\n+                tv_sec: 0,\n+                tv_nsec: 0,\n+            }\n+        };\n+        cvt(unsafe {\n+            libc::clock_gettime(clock, &mut t.t)\n+        }).unwrap();\n+        t\n+    }\n+}"}, {"sha": "284f21164239a4fbc9e7c036f1cf4aca9eec77bc", "filename": "src/libstd/sys/vxworks/weak.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fweak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibstd%2Fsys%2Fvxworks%2Fweak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fweak.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -0,0 +1,60 @@\n+//! Support for \"weak linkage\" to symbols on Unix\n+//!\n+//! Some I/O operations we do in libstd require newer versions of OSes but we\n+//! need to maintain binary compatibility with older releases for now. In order\n+//! to use the new functionality when available we use this module for\n+//! detection.\n+//!\n+//! One option to use here is weak linkage, but that is unfortunately only\n+//! really workable on Linux. Hence, use dlsym to get the symbol value at\n+//! runtime. This is also done for compatibility with older versions of glibc,\n+//! and to avoid creating dependencies on GLIBC_PRIVATE symbols. It assumes that\n+//! we've been dynamically linked to the library the symbol comes from, but that\n+//! is currently always the case for things like libpthread/libc.\n+//!\n+//! A long time ago this used weak linkage for the __pthread_get_minstack\n+//! symbol, but that caused Debian to detect an unnecessarily strict versioned\n+//! dependency on libc6 (#23628).\n+\n+use crate::ffi::CStr;\n+use crate::marker;\n+use crate::mem;\n+use crate::sync::atomic::{AtomicUsize, Ordering};\n+\n+pub struct Weak<F> {\n+    name: &'static str,\n+    addr: AtomicUsize,\n+    _marker: marker::PhantomData<F>,\n+}\n+\n+impl<F> Weak<F> {\n+    pub const fn new(name: &'static str) -> Weak<F> {\n+        Weak {\n+            name,\n+            addr: AtomicUsize::new(1),\n+            _marker: marker::PhantomData,\n+        }\n+    }\n+\n+    pub fn get(&self) -> Option<F> {\n+        assert_eq!(mem::size_of::<F>(), mem::size_of::<usize>());\n+        unsafe {\n+            if self.addr.load(Ordering::SeqCst) == 1 {\n+                self.addr.store(fetch(self.name), Ordering::SeqCst);\n+            }\n+            match self.addr.load(Ordering::SeqCst) {\n+                0 => None,\n+                addr => Some(mem::transmute_copy::<usize, F>(&addr)),\n+            }\n+        }\n+    }\n+}\n+\n+unsafe fn fetch(name: &str) -> usize {\n+    let name = match CStr::from_bytes_with_nul(name.as_bytes()) {\n+        Ok(cstr) => cstr,\n+        Err(..) => return 0,\n+    };\n+    assert!(false, \"FIXME: fetch\");\n+   libc::dlsym(libc::RTLD_DEFAULT, name.as_ptr()) as usize\n+}"}, {"sha": "fa45c9d7d9d796a81369a1d1f3ea7c482fc52909", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -1263,6 +1263,12 @@ fn get_concurrency() -> usize {\n         1\n     }\n \n+    #[cfg(target_os = \"vxworks\")]\n+    fn num_cpus() -> usize {\n+        // FIXME: Implement num_cpus on vxWorks\n+        1\n+    }\n+\n     #[cfg(any(\n         all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n         all(target_vendor = \"fortanix\", target_env = \"sgx\")"}, {"sha": "66fbe3c7037a7ee8834ea258185d0f30f94dc509", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -1653,6 +1653,18 @@ impl<'test> TestCx<'test> {\n                     None,\n                 )\n             }\n+            _ if self.config.target.contains(\"vxworks\") => {\n+                let aux_dir = self.aux_output_dir_name();\n+                let ProcArgs { prog, args } = self.make_run_args();\n+                let mut vx_run = Command::new(\"vx-run\");\n+                vx_run.args(&[&prog]).args(args).envs(env.clone());\n+                self.compose_and_run(\n+                    vx_run,\n+                    self.config.run_lib_path.to_str().unwrap(),\n+                    Some(aux_dir.to_str().unwrap()),\n+                    None,\n+                )\n+            }\n             _ => {\n                 let aux_dir = self.aux_output_dir_name();\n                 let ProcArgs { prog, args } = self.make_run_args();"}, {"sha": "76099b950b0b08d77d0a27f0ce9e55769b9ffa9d", "filename": "src/tools/compiletest/src/util.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0c0f6158b464ee5070b32bb37f2863d0eff012/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs?ref=4c0c0f6158b464ee5070b32bb37f2863d0eff012", "patch": "@@ -30,6 +30,7 @@ const OS_TABLE: &'static [(&'static str, &'static str)] = &[\n     (\"solaris\", \"solaris\"),\n     (\"win32\", \"windows\"),\n     (\"windows\", \"windows\"),\n+    (\"vxworks\", \"vxworks\"),\n ];\n \n const ARCH_TABLE: &'static [(&'static str, &'static str)] = &["}]}