{"sha": "c2ff8ad035deebde575235db310eb27afb3af7a8", "node_id": "C_kwDOAAsO6NoAKGMyZmY4YWQwMzVkZWViZGU1NzUyMzVkYjMxMGViMjdhZmIzYWY3YTg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-23T16:57:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-23T16:57:21Z"}, "message": "Auto merge of #105550 - gimbles:master, r=Nilstrieb\n\nUse `DepKind` instead of `&'static str` in `QueryStackFrame`\n\n`@rustbot` author\n\nFixes #105168", "tree": {"sha": "7746afdd5c0547b27dcd519556fedf4e5a917127", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7746afdd5c0547b27dcd519556fedf4e5a917127"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2ff8ad035deebde575235db310eb27afb3af7a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2ff8ad035deebde575235db310eb27afb3af7a8", "html_url": "https://github.com/rust-lang/rust/commit/c2ff8ad035deebde575235db310eb27afb3af7a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2ff8ad035deebde575235db310eb27afb3af7a8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62cc86924520f23091976655dab93b54a4c5ba21", "url": "https://api.github.com/repos/rust-lang/rust/commits/62cc86924520f23091976655dab93b54a4c5ba21", "html_url": "https://github.com/rust-lang/rust/commit/62cc86924520f23091976655dab93b54a4c5ba21"}, {"sha": "f8b30084ac5ae2845175a89fa66f174d6eb871b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8b30084ac5ae2845175a89fa66f174d6eb871b2", "html_url": "https://github.com/rust-lang/rust/commit/f8b30084ac5ae2845175a89fa66f174d6eb871b2"}], "stats": {"total": 255, "additions": 141, "deletions": 114}, "files": [{"sha": "c242be570312354d780529f5df3449d0e6d64ffe", "filename": "compiler/rustc_middle/src/values.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c2ff8ad035deebde575235db310eb27afb3af7a8/compiler%2Frustc_middle%2Fsrc%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2ff8ad035deebde575235db310eb27afb3af7a8/compiler%2Frustc_middle%2Fsrc%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fvalues.rs?ref=c2ff8ad035deebde575235db310eb27afb3af7a8", "patch": "@@ -1,3 +1,4 @@\n+use crate::dep_graph::DepKind;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{pluralize, struct_span_err, Applicability, MultiSpan};\n use rustc_hir as hir;\n@@ -11,16 +12,16 @@ use rustc_span::Span;\n \n use std::fmt::Write;\n \n-impl<'tcx> Value<TyCtxt<'tcx>> for Ty<'_> {\n-    fn from_cycle_error(tcx: TyCtxt<'tcx>, _: &[QueryInfo]) -> Self {\n+impl<'tcx> Value<TyCtxt<'tcx>, DepKind> for Ty<'_> {\n+    fn from_cycle_error(tcx: TyCtxt<'tcx>, _: &[QueryInfo<DepKind>]) -> Self {\n         // SAFETY: This is never called when `Self` is not `Ty<'tcx>`.\n         // FIXME: Represent the above fact in the trait system somehow.\n         unsafe { std::mem::transmute::<Ty<'tcx>, Ty<'_>>(tcx.ty_error()) }\n     }\n }\n \n-impl<'tcx> Value<TyCtxt<'tcx>> for ty::SymbolName<'_> {\n-    fn from_cycle_error(tcx: TyCtxt<'tcx>, _: &[QueryInfo]) -> Self {\n+impl<'tcx> Value<TyCtxt<'tcx>, DepKind> for ty::SymbolName<'_> {\n+    fn from_cycle_error(tcx: TyCtxt<'tcx>, _: &[QueryInfo<DepKind>]) -> Self {\n         // SAFETY: This is never called when `Self` is not `SymbolName<'tcx>`.\n         // FIXME: Represent the above fact in the trait system somehow.\n         unsafe {\n@@ -31,12 +32,12 @@ impl<'tcx> Value<TyCtxt<'tcx>> for ty::SymbolName<'_> {\n     }\n }\n \n-impl<'tcx> Value<TyCtxt<'tcx>> for ty::Binder<'_, ty::FnSig<'_>> {\n-    fn from_cycle_error(tcx: TyCtxt<'tcx>, stack: &[QueryInfo]) -> Self {\n+impl<'tcx> Value<TyCtxt<'tcx>, DepKind> for ty::Binder<'_, ty::FnSig<'_>> {\n+    fn from_cycle_error(tcx: TyCtxt<'tcx>, stack: &[QueryInfo<DepKind>]) -> Self {\n         let err = tcx.ty_error();\n \n         let arity = if let Some(frame) = stack.get(0)\n-            && frame.query.name == \"fn_sig\"\n+            && frame.query.dep_kind == DepKind::fn_sig\n             && let Some(def_id) = frame.query.def_id\n             && let Some(node) = tcx.hir().get_if_local(def_id)\n             && let Some(sig) = node.fn_sig()\n@@ -61,12 +62,12 @@ impl<'tcx> Value<TyCtxt<'tcx>> for ty::Binder<'_, ty::FnSig<'_>> {\n     }\n }\n \n-impl<'tcx> Value<TyCtxt<'tcx>> for Representability {\n-    fn from_cycle_error(tcx: TyCtxt<'tcx>, cycle: &[QueryInfo]) -> Self {\n+impl<'tcx> Value<TyCtxt<'tcx>, DepKind> for Representability {\n+    fn from_cycle_error(tcx: TyCtxt<'tcx>, cycle: &[QueryInfo<DepKind>]) -> Self {\n         let mut item_and_field_ids = Vec::new();\n         let mut representable_ids = FxHashSet::default();\n         for info in cycle {\n-            if info.query.name == \"representability\"\n+            if info.query.dep_kind == DepKind::representability\n                 && let Some(field_id) = info.query.def_id\n                 && let Some(field_id) = field_id.as_local()\n                 && let Some(DefKind::Field) = info.query.def_kind\n@@ -80,7 +81,7 @@ impl<'tcx> Value<TyCtxt<'tcx>> for Representability {\n             }\n         }\n         for info in cycle {\n-            if info.query.name == \"representability_adt_ty\"\n+            if info.query.dep_kind == DepKind::representability_adt_ty\n                 && let Some(def_id) = info.query.ty_adt_id\n                 && let Some(def_id) = def_id.as_local()\n                 && !item_and_field_ids.iter().any(|&(id, _)| id == def_id)"}, {"sha": "9ffcc5672cc33676c2b37077603f21eeff3cb402", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c2ff8ad035deebde575235db310eb27afb3af7a8/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2ff8ad035deebde575235db310eb27afb3af7a8/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=c2ff8ad035deebde575235db310eb27afb3af7a8", "patch": "@@ -66,7 +66,7 @@ impl QueryContext for QueryCtxt<'_> {\n         tls::with_related_context(**self, |icx| icx.query)\n     }\n \n-    fn try_collect_active_jobs(&self) -> Option<QueryMap> {\n+    fn try_collect_active_jobs(&self) -> Option<QueryMap<DepKind>> {\n         self.queries.try_collect_active_jobs(**self)\n     }\n \n@@ -195,7 +195,7 @@ impl<'tcx> QueryCtxt<'tcx> {\n \n #[derive(Clone, Copy)]\n pub(crate) struct QueryStruct<'tcx> {\n-    pub try_collect_active_jobs: fn(QueryCtxt<'tcx>, &mut QueryMap) -> Option<()>,\n+    pub try_collect_active_jobs: fn(QueryCtxt<'tcx>, &mut QueryMap<DepKind>) -> Option<()>,\n     pub alloc_self_profile_query_strings: fn(TyCtxt<'tcx>, &mut QueryKeyStringCache),\n     pub encode_query_results:\n         Option<fn(QueryCtxt<'tcx>, &mut CacheEncoder<'_, 'tcx>, &mut EncodedDepNodeIndex)>,\n@@ -313,7 +313,7 @@ pub(crate) fn create_query_frame<\n     key: K,\n     kind: DepKind,\n     name: &'static str,\n-) -> QueryStackFrame {\n+) -> QueryStackFrame<DepKind> {\n     // Disable visible paths printing for performance reasons.\n     // Showing visible path instead of any path is not that important in production.\n     let description = ty::print::with_no_visible_paths!(\n@@ -346,7 +346,7 @@ pub(crate) fn create_query_frame<\n     };\n     let ty_adt_id = key.ty_adt_id();\n \n-    QueryStackFrame::new(name, description, span, def_id, def_kind, ty_adt_id, hash)\n+    QueryStackFrame::new(description, span, def_id, def_kind, kind, ty_adt_id, hash)\n }\n \n fn try_load_from_on_disk_cache<'tcx, Q>(tcx: TyCtxt<'tcx>, dep_node: DepNode)\n@@ -378,7 +378,7 @@ fn force_from_dep_node<'tcx, Q>(tcx: TyCtxt<'tcx>, dep_node: DepNode) -> bool\n where\n     Q: QueryConfig<QueryCtxt<'tcx>>,\n     Q::Key: DepNodeParams<TyCtxt<'tcx>>,\n-    Q::Value: Value<TyCtxt<'tcx>>,\n+    Q::Value: Value<TyCtxt<'tcx>, DepKind>,\n {\n     // We must avoid ever having to call `force_from_dep_node()` for a\n     // `DepNode::codegen_unit`:\n@@ -402,7 +402,7 @@ where\n         #[cfg(debug_assertions)]\n         let _guard = tracing::span!(tracing::Level::TRACE, stringify!($name), ?key).entered();\n         let tcx = QueryCtxt::from_tcx(tcx);\n-        force_query::<Q, _>(tcx, key, dep_node);\n+        force_query::<Q, _, DepKind>(tcx, key, dep_node);\n         true\n     } else {\n         false\n@@ -480,7 +480,7 @@ macro_rules! define_queries {\n             type Cache = query_storage::$name<'tcx>;\n \n             #[inline(always)]\n-            fn query_state<'a>(tcx: QueryCtxt<'tcx>) -> &'a QueryState<Self::Key>\n+            fn query_state<'a>(tcx: QueryCtxt<'tcx>) -> &'a QueryState<Self::Key, crate::dep_graph::DepKind>\n                 where QueryCtxt<'tcx>: 'a\n             {\n                 &tcx.queries.$name\n@@ -587,9 +587,10 @@ macro_rules! define_queries {\n             use $crate::plumbing::{QueryStruct, QueryCtxt};\n             use $crate::profiling_support::QueryKeyStringCache;\n             use rustc_query_system::query::QueryMap;\n+            use rustc_middle::dep_graph::DepKind;\n \n             pub(super) const fn dummy_query_struct<'tcx>() -> QueryStruct<'tcx> {\n-                fn noop_try_collect_active_jobs(_: QueryCtxt<'_>, _: &mut QueryMap) -> Option<()> {\n+                fn noop_try_collect_active_jobs(_: QueryCtxt<'_>, _: &mut QueryMap<DepKind>) -> Option<()> {\n                     None\n                 }\n                 fn noop_alloc_self_profile_query_strings(_: TyCtxt<'_>, _: &mut QueryKeyStringCache) {}\n@@ -675,7 +676,8 @@ macro_rules! define_queries_struct {\n             $(\n                 $(#[$attr])*\n                 $name: QueryState<\n-                    <queries::$name<'tcx> as QueryConfig<QueryCtxt<'tcx>>>::Key\n+                    <queries::$name<'tcx> as QueryConfig<QueryCtxt<'tcx>>>::Key,\n+                    rustc_middle::dep_graph::DepKind,\n                 >,\n             )*\n         }\n@@ -684,7 +686,7 @@ macro_rules! define_queries_struct {\n             pub(crate) fn try_collect_active_jobs(\n                 &'tcx self,\n                 tcx: TyCtxt<'tcx>,\n-            ) -> Option<QueryMap> {\n+            ) -> Option<QueryMap<rustc_middle::dep_graph::DepKind>> {\n                 let tcx = QueryCtxt { tcx, queries: self };\n                 let mut jobs = QueryMap::default();\n \n@@ -718,7 +720,7 @@ macro_rules! define_queries_struct {\n                 mode: QueryMode,\n             ) -> Option<query_stored::$name<'tcx>> {\n                 let qcx = QueryCtxt { tcx, queries: self };\n-                get_query::<queries::$name<'tcx>, _>(qcx, span, key, mode)\n+                get_query::<queries::$name<'tcx>, _, rustc_middle::dep_graph::DepKind>(qcx, span, key, mode)\n             })*\n         }\n     };"}, {"sha": "24c960765df8a387b8a177d3a8b4741d13204f3f", "filename": "compiler/rustc_query_system/src/query/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2ff8ad035deebde575235db310eb27afb3af7a8/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2ff8ad035deebde575235db310eb27afb3af7a8/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs?ref=c2ff8ad035deebde575235db310eb27afb3af7a8", "patch": "@@ -21,7 +21,7 @@ pub trait QueryConfig<Qcx: QueryContext> {\n     type Cache: QueryCache<Key = Self::Key, Stored = Self::Stored, Value = Self::Value>;\n \n     // Don't use this method to access query results, instead use the methods on TyCtxt\n-    fn query_state<'a>(tcx: Qcx) -> &'a QueryState<Self::Key>\n+    fn query_state<'a>(tcx: Qcx) -> &'a QueryState<Self::Key, Qcx::DepKind>\n     where\n         Qcx: 'a;\n "}, {"sha": "a5a2f0093ce6b97bff16dbf438d6915ef9ea5241", "filename": "compiler/rustc_query_system/src/query/job.rs", "status": "modified", "additions": 61, "deletions": 43, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/c2ff8ad035deebde575235db310eb27afb3af7a8/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2ff8ad035deebde575235db310eb27afb3af7a8/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs?ref=c2ff8ad035deebde575235db310eb27afb3af7a8", "patch": "@@ -1,6 +1,8 @@\n+use crate::dep_graph::DepKind;\n use crate::error::CycleStack;\n use crate::query::plumbing::CycleError;\n use crate::query::{QueryContext, QueryStackFrame};\n+use core::marker::PhantomData;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{\n@@ -28,48 +30,48 @@ use {\n \n /// Represents a span and a query key.\n #[derive(Clone, Debug)]\n-pub struct QueryInfo {\n+pub struct QueryInfo<D: DepKind> {\n     /// The span corresponding to the reason for which this query was required.\n     pub span: Span,\n-    pub query: QueryStackFrame,\n+    pub query: QueryStackFrame<D>,\n }\n \n-pub type QueryMap = FxHashMap<QueryJobId, QueryJobInfo>;\n+pub type QueryMap<D> = FxHashMap<QueryJobId, QueryJobInfo<D>>;\n \n /// A value uniquely identifying an active query job.\n #[derive(Copy, Clone, Eq, PartialEq, Hash)]\n pub struct QueryJobId(pub NonZeroU64);\n \n impl QueryJobId {\n-    fn query(self, map: &QueryMap) -> QueryStackFrame {\n+    fn query<D: DepKind>(self, map: &QueryMap<D>) -> QueryStackFrame<D> {\n         map.get(&self).unwrap().query.clone()\n     }\n \n     #[cfg(parallel_compiler)]\n-    fn span(self, map: &QueryMap) -> Span {\n+    fn span<D: DepKind>(self, map: &QueryMap<D>) -> Span {\n         map.get(&self).unwrap().job.span\n     }\n \n     #[cfg(parallel_compiler)]\n-    fn parent(self, map: &QueryMap) -> Option<QueryJobId> {\n+    fn parent<D: DepKind>(self, map: &QueryMap<D>) -> Option<QueryJobId> {\n         map.get(&self).unwrap().job.parent\n     }\n \n     #[cfg(parallel_compiler)]\n-    fn latch<'a>(self, map: &'a QueryMap) -> Option<&'a QueryLatch> {\n+    fn latch<D: DepKind>(self, map: &QueryMap<D>) -> Option<&QueryLatch<D>> {\n         map.get(&self).unwrap().job.latch.as_ref()\n     }\n }\n \n #[derive(Clone)]\n-pub struct QueryJobInfo {\n-    pub query: QueryStackFrame,\n-    pub job: QueryJob,\n+pub struct QueryJobInfo<D: DepKind> {\n+    pub query: QueryStackFrame<D>,\n+    pub job: QueryJob<D>,\n }\n \n /// Represents an active query job.\n #[derive(Clone)]\n-pub struct QueryJob {\n+pub struct QueryJob<D: DepKind> {\n     pub id: QueryJobId,\n \n     /// The span corresponding to the reason for which this query was required.\n@@ -80,10 +82,11 @@ pub struct QueryJob {\n \n     /// The latch that is used to wait on this job.\n     #[cfg(parallel_compiler)]\n-    latch: Option<QueryLatch>,\n+    latch: Option<QueryLatch<D>>,\n+    spooky: core::marker::PhantomData<D>,\n }\n \n-impl QueryJob {\n+impl<D: DepKind> QueryJob<D> {\n     /// Creates a new query job.\n     #[inline]\n     pub fn new(id: QueryJobId, span: Span, parent: Option<QueryJobId>) -> Self {\n@@ -93,11 +96,12 @@ impl QueryJob {\n             parent,\n             #[cfg(parallel_compiler)]\n             latch: None,\n+            spooky: PhantomData,\n         }\n     }\n \n     #[cfg(parallel_compiler)]\n-    pub(super) fn latch(&mut self) -> QueryLatch {\n+    pub(super) fn latch(&mut self) -> QueryLatch<D> {\n         if self.latch.is_none() {\n             self.latch = Some(QueryLatch::new());\n         }\n@@ -123,12 +127,12 @@ impl QueryJobId {\n     #[cold]\n     #[inline(never)]\n     #[cfg(not(parallel_compiler))]\n-    pub(super) fn find_cycle_in_stack(\n+    pub(super) fn find_cycle_in_stack<D: DepKind>(\n         &self,\n-        query_map: QueryMap,\n+        query_map: QueryMap<D>,\n         current_job: &Option<QueryJobId>,\n         span: Span,\n-    ) -> CycleError {\n+    ) -> CycleError<D> {\n         // Find the waitee amongst `current_job` parents\n         let mut cycle = Vec::new();\n         let mut current_job = Option::clone(current_job);\n@@ -162,14 +166,18 @@ impl QueryJobId {\n \n     #[cold]\n     #[inline(never)]\n-    pub fn try_find_layout_root(&self, query_map: QueryMap) -> Option<(QueryJobInfo, usize)> {\n+    pub fn try_find_layout_root<D: DepKind>(\n+        &self,\n+        query_map: QueryMap<D>,\n+    ) -> Option<(QueryJobInfo<D>, usize)> {\n         let mut last_layout = None;\n         let mut current_id = Some(*self);\n         let mut depth = 0;\n \n         while let Some(id) = current_id {\n             let info = query_map.get(&id).unwrap();\n-            if info.query.name == \"layout_of\" {\n+            // FIXME: This string comparison should probably not be done.\n+            if format!(\"{:?}\", info.query.dep_kind) == \"layout_of\" {\n                 depth += 1;\n                 last_layout = Some((info.clone(), depth));\n             }\n@@ -180,43 +188,47 @@ impl QueryJobId {\n }\n \n #[cfg(parallel_compiler)]\n-struct QueryWaiter {\n+struct QueryWaiter<D: DepKind> {\n     query: Option<QueryJobId>,\n     condvar: Condvar,\n     span: Span,\n-    cycle: Lock<Option<CycleError>>,\n+    cycle: Lock<Option<CycleError<D>>>,\n }\n \n #[cfg(parallel_compiler)]\n-impl QueryWaiter {\n+impl<D: DepKind> QueryWaiter<D> {\n     fn notify(&self, registry: &rayon_core::Registry) {\n         rayon_core::mark_unblocked(registry);\n         self.condvar.notify_one();\n     }\n }\n \n #[cfg(parallel_compiler)]\n-struct QueryLatchInfo {\n+struct QueryLatchInfo<D: DepKind> {\n     complete: bool,\n-    waiters: Vec<Lrc<QueryWaiter>>,\n+    waiters: Vec<Lrc<QueryWaiter<D>>>,\n }\n \n #[cfg(parallel_compiler)]\n #[derive(Clone)]\n-pub(super) struct QueryLatch {\n-    info: Lrc<Mutex<QueryLatchInfo>>,\n+pub(super) struct QueryLatch<D: DepKind> {\n+    info: Lrc<Mutex<QueryLatchInfo<D>>>,\n }\n \n #[cfg(parallel_compiler)]\n-impl QueryLatch {\n+impl<D: DepKind> QueryLatch<D> {\n     fn new() -> Self {\n         QueryLatch {\n             info: Lrc::new(Mutex::new(QueryLatchInfo { complete: false, waiters: Vec::new() })),\n         }\n     }\n \n     /// Awaits for the query job to complete.\n-    pub(super) fn wait_on(&self, query: Option<QueryJobId>, span: Span) -> Result<(), CycleError> {\n+    pub(super) fn wait_on(\n+        &self,\n+        query: Option<QueryJobId>,\n+        span: Span,\n+    ) -> Result<(), CycleError<D>> {\n         let waiter =\n             Lrc::new(QueryWaiter { query, span, cycle: Lock::new(None), condvar: Condvar::new() });\n         self.wait_on_inner(&waiter);\n@@ -231,7 +243,7 @@ impl QueryLatch {\n     }\n \n     /// Awaits the caller on this latch by blocking the current thread.\n-    fn wait_on_inner(&self, waiter: &Lrc<QueryWaiter>) {\n+    fn wait_on_inner(&self, waiter: &Lrc<QueryWaiter<D>>) {\n         let mut info = self.info.lock();\n         if !info.complete {\n             // We push the waiter on to the `waiters` list. It can be accessed inside\n@@ -265,7 +277,7 @@ impl QueryLatch {\n \n     /// Removes a single waiter from the list of waiters.\n     /// This is used to break query cycles.\n-    fn extract_waiter(&self, waiter: usize) -> Lrc<QueryWaiter> {\n+    fn extract_waiter(&self, waiter: usize) -> Lrc<QueryWaiter<D>> {\n         let mut info = self.info.lock();\n         debug_assert!(!info.complete);\n         // Remove the waiter from the list of waiters\n@@ -287,9 +299,14 @@ type Waiter = (QueryJobId, usize);\n /// required information to resume the waiter.\n /// If all `visit` calls returns None, this function also returns None.\n #[cfg(parallel_compiler)]\n-fn visit_waiters<F>(query_map: &QueryMap, query: QueryJobId, mut visit: F) -> Option<Option<Waiter>>\n+fn visit_waiters<F, D>(\n+    query_map: &QueryMap<D>,\n+    query: QueryJobId,\n+    mut visit: F,\n+) -> Option<Option<Waiter>>\n where\n     F: FnMut(Span, QueryJobId) -> Option<Option<Waiter>>,\n+    D: DepKind,\n {\n     // Visit the parent query which is a non-resumable waiter since it's on the same stack\n     if let Some(parent) = query.parent(query_map) {\n@@ -318,8 +335,8 @@ where\n /// If a cycle is detected, this initial value is replaced with the span causing\n /// the cycle.\n #[cfg(parallel_compiler)]\n-fn cycle_check(\n-    query_map: &QueryMap,\n+fn cycle_check<D: DepKind>(\n+    query_map: &QueryMap<D>,\n     query: QueryJobId,\n     span: Span,\n     stack: &mut Vec<(Span, QueryJobId)>,\n@@ -359,8 +376,8 @@ fn cycle_check(\n /// from `query` without going through any of the queries in `visited`.\n /// This is achieved with a depth first search.\n #[cfg(parallel_compiler)]\n-fn connected_to_root(\n-    query_map: &QueryMap,\n+fn connected_to_root<D: DepKind>(\n+    query_map: &QueryMap<D>,\n     query: QueryJobId,\n     visited: &mut FxHashSet<QueryJobId>,\n ) -> bool {\n@@ -382,9 +399,10 @@ fn connected_to_root(\n \n // Deterministically pick an query from a list\n #[cfg(parallel_compiler)]\n-fn pick_query<'a, T, F>(query_map: &QueryMap, queries: &'a [T], f: F) -> &'a T\n+fn pick_query<'a, T, F, D>(query_map: &QueryMap<D>, queries: &'a [T], f: F) -> &'a T\n where\n     F: Fn(&T) -> (Span, QueryJobId),\n+    D: DepKind,\n {\n     // Deterministically pick an entry point\n     // FIXME: Sort this instead\n@@ -408,10 +426,10 @@ where\n /// If a cycle was not found, the starting query is removed from `jobs` and\n /// the function returns false.\n #[cfg(parallel_compiler)]\n-fn remove_cycle(\n-    query_map: &QueryMap,\n+fn remove_cycle<D: DepKind>(\n+    query_map: &QueryMap<D>,\n     jobs: &mut Vec<QueryJobId>,\n-    wakelist: &mut Vec<Lrc<QueryWaiter>>,\n+    wakelist: &mut Vec<Lrc<QueryWaiter<D>>>,\n ) -> bool {\n     let mut visited = FxHashSet::default();\n     let mut stack = Vec::new();\n@@ -513,7 +531,7 @@ fn remove_cycle(\n /// There may be multiple cycles involved in a deadlock, so this searches\n /// all active queries for cycles before finally resuming all the waiters at once.\n #[cfg(parallel_compiler)]\n-pub fn deadlock(query_map: QueryMap, registry: &rayon_core::Registry) {\n+pub fn deadlock<D: DepKind>(query_map: QueryMap<D>, registry: &rayon_core::Registry) {\n     let on_panic = OnDrop(|| {\n         eprintln!(\"deadlock handler panicked, aborting process\");\n         process::abort();\n@@ -549,9 +567,9 @@ pub fn deadlock(query_map: QueryMap, registry: &rayon_core::Registry) {\n \n #[inline(never)]\n #[cold]\n-pub(crate) fn report_cycle<'a>(\n+pub(crate) fn report_cycle<'a, D: DepKind>(\n     sess: &'a Session,\n-    CycleError { usage, cycle: stack }: &CycleError,\n+    CycleError { usage, cycle: stack }: &CycleError<D>,\n ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n     assert!(!stack.is_empty());\n \n@@ -617,7 +635,7 @@ pub fn print_query_stack<Qcx: QueryContext>(\n         };\n         let mut diag = Diagnostic::new(\n             Level::FailureNote,\n-            &format!(\"#{} [{}] {}\", i, query_info.query.name, query_info.query.description),\n+            &format!(\"#{} [{:?}] {}\", i, query_info.query.dep_kind, query_info.query.description),\n         );\n         diag.span = query_info.job.span.into();\n         handler.force_print_diagnostic(diag);"}, {"sha": "ce9179ea832e75e8fbc6e61ff2f00b108ae8f1f5", "filename": "compiler/rustc_query_system/src/query/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c2ff8ad035deebde575235db310eb27afb3af7a8/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2ff8ad035deebde575235db310eb27afb3af7a8/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs?ref=c2ff8ad035deebde575235db310eb27afb3af7a8", "patch": "@@ -14,6 +14,7 @@ pub use self::caches::{\n mod config;\n pub use self::config::{QueryConfig, QueryVTable};\n \n+use crate::dep_graph::DepKind;\n use crate::dep_graph::{DepNodeIndex, HasDepContext, SerializedDepNodeIndex};\n use rustc_data_structures::sync::Lock;\n use rustc_errors::Diagnostic;\n@@ -26,37 +27,37 @@ use thin_vec::ThinVec;\n ///\n /// This is mostly used in case of cycles for error reporting.\n #[derive(Clone, Debug)]\n-pub struct QueryStackFrame {\n-    pub name: &'static str,\n+pub struct QueryStackFrame<D: DepKind> {\n     pub description: String,\n     span: Option<Span>,\n     pub def_id: Option<DefId>,\n     pub def_kind: Option<DefKind>,\n     pub ty_adt_id: Option<DefId>,\n+    pub dep_kind: D,\n     /// This hash is used to deterministically pick\n     /// a query to remove cycles in the parallel compiler.\n     #[cfg(parallel_compiler)]\n     hash: u64,\n }\n \n-impl QueryStackFrame {\n+impl<D: DepKind> QueryStackFrame<D> {\n     #[inline]\n     pub fn new(\n-        name: &'static str,\n         description: String,\n         span: Option<Span>,\n         def_id: Option<DefId>,\n         def_kind: Option<DefKind>,\n+        dep_kind: D,\n         ty_adt_id: Option<DefId>,\n         _hash: impl FnOnce() -> u64,\n     ) -> Self {\n         Self {\n-            name,\n             description,\n             span,\n             def_id,\n             def_kind,\n             ty_adt_id,\n+            dep_kind,\n             #[cfg(parallel_compiler)]\n             hash: _hash(),\n         }\n@@ -104,7 +105,7 @@ pub trait QueryContext: HasDepContext {\n     /// Get the query information from the TLS context.\n     fn current_query_job(&self) -> Option<QueryJobId>;\n \n-    fn try_collect_active_jobs(&self) -> Option<QueryMap>;\n+    fn try_collect_active_jobs(&self) -> Option<QueryMap<Self::DepKind>>;\n \n     /// Load side effects associated to the node in the previous session.\n     fn load_side_effects(&self, prev_dep_node_index: SerializedDepNodeIndex) -> QuerySideEffects;"}, {"sha": "c3a2410dacaa7931ecfe665e78d91b2f3df276a2", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 42, "deletions": 37, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/c2ff8ad035deebde575235db310eb27afb3af7a8/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2ff8ad035deebde575235db310eb27afb3af7a8/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=c2ff8ad035deebde575235db310eb27afb3af7a8", "patch": "@@ -2,7 +2,7 @@\n //! generate the actual methods on tcx which find and execute the provider,\n //! manage the caches, and so forth.\n \n-use crate::dep_graph::{DepContext, DepNode, DepNodeIndex, DepNodeParams};\n+use crate::dep_graph::{DepContext, DepKind, DepNode, DepNodeIndex, DepNodeParams};\n use crate::ich::StableHashingContext;\n use crate::query::caches::QueryCache;\n use crate::query::config::QueryVTable;\n@@ -31,26 +31,27 @@ use thin_vec::ThinVec;\n \n use super::QueryConfig;\n \n-pub struct QueryState<K> {\n+pub struct QueryState<K, D: DepKind> {\n     #[cfg(parallel_compiler)]\n-    active: Sharded<FxHashMap<K, QueryResult>>,\n+    active: Sharded<FxHashMap<K, QueryResult<D>>>,\n     #[cfg(not(parallel_compiler))]\n-    active: Lock<FxHashMap<K, QueryResult>>,\n+    active: Lock<FxHashMap<K, QueryResult<D>>>,\n }\n \n /// Indicates the state of a query for a given key in a query map.\n-enum QueryResult {\n+enum QueryResult<D: DepKind> {\n     /// An already executing query. The query job can be used to await for its completion.\n-    Started(QueryJob),\n+    Started(QueryJob<D>),\n \n     /// The query panicked. Queries trying to wait on this will raise a fatal error which will\n     /// silently panic.\n     Poisoned,\n }\n \n-impl<K> QueryState<K>\n+impl<K, D> QueryState<K, D>\n where\n     K: Eq + Hash + Clone + Debug,\n+    D: DepKind,\n {\n     pub fn all_inactive(&self) -> bool {\n         #[cfg(parallel_compiler)]\n@@ -67,8 +68,8 @@ where\n     pub fn try_collect_active_jobs<Qcx: Copy>(\n         &self,\n         qcx: Qcx,\n-        make_query: fn(Qcx, K) -> QueryStackFrame,\n-        jobs: &mut QueryMap,\n+        make_query: fn(Qcx, K) -> QueryStackFrame<D>,\n+        jobs: &mut QueryMap<D>,\n     ) -> Option<()> {\n         #[cfg(parallel_compiler)]\n         {\n@@ -102,34 +103,34 @@ where\n     }\n }\n \n-impl<K> Default for QueryState<K> {\n-    fn default() -> QueryState<K> {\n+impl<K, D: DepKind> Default for QueryState<K, D> {\n+    fn default() -> QueryState<K, D> {\n         QueryState { active: Default::default() }\n     }\n }\n \n /// A type representing the responsibility to execute the job in the `job` field.\n /// This will poison the relevant query if dropped.\n-struct JobOwner<'tcx, K>\n+struct JobOwner<'tcx, K, D: DepKind>\n where\n     K: Eq + Hash + Clone,\n {\n-    state: &'tcx QueryState<K>,\n+    state: &'tcx QueryState<K, D>,\n     key: K,\n     id: QueryJobId,\n }\n \n #[cold]\n #[inline(never)]\n-fn mk_cycle<Qcx, V, R>(\n+fn mk_cycle<Qcx, V, R, D: DepKind>(\n     qcx: Qcx,\n-    cycle_error: CycleError,\n+    cycle_error: CycleError<D>,\n     handler: HandleCycleError,\n     cache: &dyn crate::query::QueryStorage<Value = V, Stored = R>,\n ) -> R\n where\n-    Qcx: QueryContext,\n-    V: std::fmt::Debug + Value<Qcx::DepContext>,\n+    Qcx: QueryContext + crate::query::HasDepContext<DepKind = D>,\n+    V: std::fmt::Debug + Value<Qcx::DepContext, Qcx::DepKind>,\n     R: Clone,\n {\n     let error = report_cycle(qcx.dep_context().sess(), &cycle_error);\n@@ -139,13 +140,13 @@ where\n \n fn handle_cycle_error<Tcx, V>(\n     tcx: Tcx,\n-    cycle_error: &CycleError,\n+    cycle_error: &CycleError<Tcx::DepKind>,\n     mut error: DiagnosticBuilder<'_, ErrorGuaranteed>,\n     handler: HandleCycleError,\n ) -> V\n where\n     Tcx: DepContext,\n-    V: Value<Tcx>,\n+    V: Value<Tcx, Tcx::DepKind>,\n {\n     use HandleCycleError::*;\n     match handler {\n@@ -165,7 +166,7 @@ where\n     }\n }\n \n-impl<'tcx, K> JobOwner<'tcx, K>\n+impl<'tcx, K, D: DepKind> JobOwner<'tcx, K, D>\n where\n     K: Eq + Hash + Clone,\n {\n@@ -180,12 +181,12 @@ where\n     #[inline(always)]\n     fn try_start<'b, Qcx>(\n         qcx: &'b Qcx,\n-        state: &'b QueryState<K>,\n+        state: &'b QueryState<K, Qcx::DepKind>,\n         span: Span,\n         key: K,\n-    ) -> TryGetJob<'b, K>\n+    ) -> TryGetJob<'b, K, D>\n     where\n-        Qcx: QueryContext,\n+        Qcx: QueryContext + crate::query::HasDepContext<DepKind = D>,\n     {\n         #[cfg(parallel_compiler)]\n         let mut state_lock = state.active.get_shard_by_value(&key).lock();\n@@ -280,9 +281,10 @@ where\n     }\n }\n \n-impl<'tcx, K> Drop for JobOwner<'tcx, K>\n+impl<'tcx, K, D> Drop for JobOwner<'tcx, K, D>\n where\n     K: Eq + Hash + Clone,\n+    D: DepKind,\n {\n     #[inline(never)]\n     #[cold]\n@@ -308,19 +310,20 @@ where\n }\n \n #[derive(Clone)]\n-pub(crate) struct CycleError {\n+pub(crate) struct CycleError<D: DepKind> {\n     /// The query and related span that uses the cycle.\n-    pub usage: Option<(Span, QueryStackFrame)>,\n-    pub cycle: Vec<QueryInfo>,\n+    pub usage: Option<(Span, QueryStackFrame<D>)>,\n+    pub cycle: Vec<QueryInfo<D>>,\n }\n \n /// The result of `try_start`.\n-enum TryGetJob<'tcx, K>\n+enum TryGetJob<'tcx, K, D>\n where\n     K: Eq + Hash + Clone,\n+    D: DepKind,\n {\n     /// The query is not yet started. Contains a guard to the cache eventually used to start it.\n-    NotYetStarted(JobOwner<'tcx, K>),\n+    NotYetStarted(JobOwner<'tcx, K, D>),\n \n     /// The query was already completed.\n     /// Returns the result of the query and its dep-node index\n@@ -329,7 +332,7 @@ where\n     JobCompleted(TimingGuard<'tcx>),\n \n     /// Trying to execute the query resulted in a cycle.\n-    Cycle(CycleError),\n+    Cycle(CycleError<D>),\n }\n \n /// Checks if the query is already computed and in the cache.\n@@ -360,7 +363,7 @@ where\n \n fn try_execute_query<Qcx, C>(\n     qcx: Qcx,\n-    state: &QueryState<C::Key>,\n+    state: &QueryState<C::Key, Qcx::DepKind>,\n     cache: &C,\n     span: Span,\n     key: C::Key,\n@@ -370,11 +373,11 @@ fn try_execute_query<Qcx, C>(\n where\n     C: QueryCache,\n     C::Key: Clone + DepNodeParams<Qcx::DepContext>,\n-    C::Value: Value<Qcx::DepContext>,\n+    C::Value: Value<Qcx::DepContext, Qcx::DepKind>,\n     C::Stored: Debug + std::borrow::Borrow<C::Value>,\n     Qcx: QueryContext,\n {\n-    match JobOwner::<'_, C::Key>::try_start(&qcx, state, span, key.clone()) {\n+    match JobOwner::<'_, C::Key, Qcx::DepKind>::try_start(&qcx, state, span, key.clone()) {\n         TryGetJob::NotYetStarted(job) => {\n             let (result, dep_node_index) = execute_job(qcx, key.clone(), dep_node, query, job.id);\n             if query.feedable {\n@@ -739,11 +742,12 @@ pub enum QueryMode {\n     Ensure,\n }\n \n-pub fn get_query<Q, Qcx>(qcx: Qcx, span: Span, key: Q::Key, mode: QueryMode) -> Option<Q::Stored>\n+pub fn get_query<Q, Qcx, D>(qcx: Qcx, span: Span, key: Q::Key, mode: QueryMode) -> Option<Q::Stored>\n where\n+    D: DepKind,\n     Q: QueryConfig<Qcx>,\n     Q::Key: DepNodeParams<Qcx::DepContext>,\n-    Q::Value: Value<Qcx::DepContext>,\n+    Q::Value: Value<Qcx::DepContext, D>,\n     Qcx: QueryContext,\n {\n     let query = Q::make_vtable(qcx, &key);\n@@ -772,11 +776,12 @@ where\n     Some(result)\n }\n \n-pub fn force_query<Q, Qcx>(qcx: Qcx, key: Q::Key, dep_node: DepNode<Qcx::DepKind>)\n+pub fn force_query<Q, Qcx, D>(qcx: Qcx, key: Q::Key, dep_node: DepNode<Qcx::DepKind>)\n where\n+    D: DepKind,\n     Q: QueryConfig<Qcx>,\n     Q::Key: DepNodeParams<Qcx::DepContext>,\n-    Q::Value: Value<Qcx::DepContext>,\n+    Q::Value: Value<Qcx::DepContext, D>,\n     Qcx: QueryContext,\n {\n     // We may be concurrently trying both execute and force a query."}, {"sha": "b6e2cfa3dca5e3c33ab02040cea3b2f55b9e75f5", "filename": "compiler/rustc_query_system/src/values.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c2ff8ad035deebde575235db310eb27afb3af7a8/compiler%2Frustc_query_system%2Fsrc%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2ff8ad035deebde575235db310eb27afb3af7a8/compiler%2Frustc_query_system%2Fsrc%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fvalues.rs?ref=c2ff8ad035deebde575235db310eb27afb3af7a8", "patch": "@@ -1,12 +1,12 @@\n-use crate::dep_graph::DepContext;\n+use crate::dep_graph::{DepContext, DepKind};\n use crate::query::QueryInfo;\n \n-pub trait Value<Tcx: DepContext>: Sized {\n-    fn from_cycle_error(tcx: Tcx, cycle: &[QueryInfo]) -> Self;\n+pub trait Value<Tcx: DepContext, D: DepKind>: Sized {\n+    fn from_cycle_error(tcx: Tcx, cycle: &[QueryInfo<D>]) -> Self;\n }\n \n-impl<Tcx: DepContext, T> Value<Tcx> for T {\n-    default fn from_cycle_error(tcx: Tcx, _: &[QueryInfo]) -> T {\n+impl<Tcx: DepContext, T, D: DepKind> Value<Tcx, D> for T {\n+    default fn from_cycle_error(tcx: Tcx, _: &[QueryInfo<D>]) -> T {\n         tcx.sess().abort_if_errors();\n         // Ideally we would use `bug!` here. But bug! is only defined in rustc_middle, and it's\n         // non-trivial to define it earlier."}]}