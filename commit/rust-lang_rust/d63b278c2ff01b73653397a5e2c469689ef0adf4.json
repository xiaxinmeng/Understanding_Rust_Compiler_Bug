{"sha": "d63b278c2ff01b73653397a5e2c469689ef0adf4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2M2IyNzhjMmZmMDFiNzM2NTMzOTdhNWUyYzQ2OTY4OWVmMGFkZjQ=", "commit": {"author": {"name": "D\u00e1niel Buga", "email": "bugadani@gmail.com", "date": "2021-01-22T17:15:55Z"}, "committer": {"name": "D\u00e1niel Buga", "email": "bugadani@gmail.com", "date": "2021-01-22T17:36:30Z"}, "message": "Only scan through assoc items once in check_impl_items_against_trait", "tree": {"sha": "c06852fd439fe4ca4132bd7898e3133ae1c94682", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c06852fd439fe4ca4132bd7898e3133ae1c94682"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d63b278c2ff01b73653397a5e2c469689ef0adf4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d63b278c2ff01b73653397a5e2c469689ef0adf4", "html_url": "https://github.com/rust-lang/rust/commit/d63b278c2ff01b73653397a5e2c469689ef0adf4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d63b278c2ff01b73653397a5e2c469689ef0adf4/comments", "author": {"login": "bugadani", "id": 977627, "node_id": "MDQ6VXNlcjk3NzYyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/977627?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bugadani", "html_url": "https://github.com/bugadani", "followers_url": "https://api.github.com/users/bugadani/followers", "following_url": "https://api.github.com/users/bugadani/following{/other_user}", "gists_url": "https://api.github.com/users/bugadani/gists{/gist_id}", "starred_url": "https://api.github.com/users/bugadani/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bugadani/subscriptions", "organizations_url": "https://api.github.com/users/bugadani/orgs", "repos_url": "https://api.github.com/users/bugadani/repos", "events_url": "https://api.github.com/users/bugadani/events{/privacy}", "received_events_url": "https://api.github.com/users/bugadani/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bugadani", "id": 977627, "node_id": "MDQ6VXNlcjk3NzYyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/977627?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bugadani", "html_url": "https://github.com/bugadani", "followers_url": "https://api.github.com/users/bugadani/followers", "following_url": "https://api.github.com/users/bugadani/following{/other_user}", "gists_url": "https://api.github.com/users/bugadani/gists{/gist_id}", "starred_url": "https://api.github.com/users/bugadani/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bugadani/subscriptions", "organizations_url": "https://api.github.com/users/bugadani/orgs", "repos_url": "https://api.github.com/users/bugadani/repos", "events_url": "https://api.github.com/users/bugadani/events{/privacy}", "received_events_url": "https://api.github.com/users/bugadani/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9988821a04073360c27bd95b9535a8dceca67d9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/9988821a04073360c27bd95b9535a8dceca67d9c", "html_url": "https://github.com/rust-lang/rust/commit/9988821a04073360c27bd95b9535a8dceca67d9c"}], "stats": {"total": 215, "additions": 117, "deletions": 98}, "files": [{"sha": "eda5a27e97e3a376c8294df9f73751b0c20f6412", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 117, "deletions": 98, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/d63b278c2ff01b73653397a5e2c469689ef0adf4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d63b278c2ff01b73653397a5e2c469689ef0adf4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=d63b278c2ff01b73653397a5e2c469689ef0adf4", "patch": "@@ -846,15 +846,13 @@ pub(super) fn check_specialization_validity<'tcx>(\n         Ok(ancestors) => ancestors,\n         Err(_) => return,\n     };\n-    let mut ancestor_impls = ancestors\n-        .skip(1)\n-        .filter_map(|parent| {\n-            if parent.is_from_trait() {\n-                None\n-            } else {\n-                Some((parent, parent.item(tcx, trait_item.ident, kind, trait_def.def_id)))\n-            }\n-        });\n+    let mut ancestor_impls = ancestors.skip(1).filter_map(|parent| {\n+        if parent.is_from_trait() {\n+            None\n+        } else {\n+            Some((parent, parent.item(tcx, trait_item.ident, kind, trait_def.def_id)))\n+        }\n+    });\n \n     let opt_result = ancestor_impls.find_map(|(parent_impl, parent_item)| {\n         match parent_item {\n@@ -931,105 +929,72 @@ pub(super) fn check_impl_items_against_trait<'tcx>(\n     // Check existing impl methods to see if they are both present in trait\n     // and compatible with trait signature\n     for impl_item in impl_items {\n-        let namespace = impl_item.kind.namespace();\n         let ty_impl_item = tcx.associated_item(tcx.hir().local_def_id(impl_item.hir_id));\n-        let ty_trait_item = tcx\n-            .associated_items(impl_trait_ref.def_id)\n-            .find_by_name_and_namespace(tcx, ty_impl_item.ident, namespace, impl_trait_ref.def_id)\n-            .or_else(|| {\n-                // Not compatible, but needed for the error message\n-                tcx.associated_items(impl_trait_ref.def_id)\n-                    .filter_by_name(tcx, ty_impl_item.ident, impl_trait_ref.def_id)\n-                    .next()\n-            });\n-\n-        // Check that impl definition matches trait definition\n-        if let Some(ty_trait_item) = ty_trait_item {\n+        let associated_items = tcx.associated_items(impl_trait_ref.def_id);\n+\n+        let mut items = associated_items.filter_by_name(tcx, ty_impl_item.ident, impl_trait_ref.def_id);\n+\n+        let (compatible_kind, ty_trait_item) = if let Some(ty_trait_item) = items.next() {\n+\n+            let is_compatible = |ty: &&ty::AssocItem| {\n+                match (ty.kind, &impl_item.kind) {\n+                    (ty::AssocKind::Const, hir::ImplItemKind::Const(..)) => true,\n+                    (ty::AssocKind::Fn, hir::ImplItemKind::Fn(..)) => true,\n+                    (ty::AssocKind::Type, hir::ImplItemKind::TyAlias(..)) => true,\n+                    _ => false\n+                }\n+            };\n+\n+            // If we don't have a compatible item, we'll use the first one whose name matches\n+            // to report an error.\n+            let mut compatible_kind = is_compatible(&ty_trait_item);\n+            let mut trait_item = ty_trait_item;\n+\n+            if  !compatible_kind {\n+                if let Some(ty_trait_item) = items.find(is_compatible) {\n+                    compatible_kind = true;\n+                    trait_item = ty_trait_item;\n+                }\n+            }\n+\n+            (compatible_kind, trait_item)\n+        } else {\n+            continue;\n+        };\n+\n+        if compatible_kind {\n             match impl_item.kind {\n                 hir::ImplItemKind::Const(..) => {\n                     // Find associated const definition.\n-                    if ty_trait_item.kind == ty::AssocKind::Const {\n-                        compare_const_impl(\n-                            tcx,\n-                            &ty_impl_item,\n-                            impl_item.span,\n-                            &ty_trait_item,\n-                            impl_trait_ref,\n-                        );\n-                    } else {\n-                        let mut err = struct_span_err!(\n-                            tcx.sess,\n-                            impl_item.span,\n-                            E0323,\n-                            \"item `{}` is an associated const, \\\n-                             which doesn't match its trait `{}`\",\n-                            ty_impl_item.ident,\n-                            impl_trait_ref.print_only_trait_path()\n-                        );\n-                        err.span_label(impl_item.span, \"does not match trait\");\n-                        // We can only get the spans from local trait definition\n-                        // Same for E0324 and E0325\n-                        if let Some(trait_span) = tcx.hir().span_if_local(ty_trait_item.def_id) {\n-                            err.span_label(trait_span, \"item in trait\");\n-                        }\n-                        err.emit()\n-                    }\n+                    compare_const_impl(\n+                        tcx,\n+                        &ty_impl_item,\n+                        impl_item.span,\n+                        &ty_trait_item,\n+                        impl_trait_ref,\n+                    );\n                 }\n                 hir::ImplItemKind::Fn(..) => {\n                     let opt_trait_span = tcx.hir().span_if_local(ty_trait_item.def_id);\n-                    if ty_trait_item.kind == ty::AssocKind::Fn {\n-                        compare_impl_method(\n-                            tcx,\n-                            &ty_impl_item,\n-                            impl_item.span,\n-                            &ty_trait_item,\n-                            impl_trait_ref,\n-                            opt_trait_span,\n-                        );\n-                    } else {\n-                        let mut err = struct_span_err!(\n-                            tcx.sess,\n-                            impl_item.span,\n-                            E0324,\n-                            \"item `{}` is an associated method, \\\n-                             which doesn't match its trait `{}`\",\n-                            ty_impl_item.ident,\n-                            impl_trait_ref.print_only_trait_path()\n-                        );\n-                        err.span_label(impl_item.span, \"does not match trait\");\n-                        if let Some(trait_span) = opt_trait_span {\n-                            err.span_label(trait_span, \"item in trait\");\n-                        }\n-                        err.emit()\n-                    }\n+                    compare_impl_method(\n+                        tcx,\n+                        &ty_impl_item,\n+                        impl_item.span,\n+                        &ty_trait_item,\n+                        impl_trait_ref,\n+                        opt_trait_span,\n+                    );\n                 }\n                 hir::ImplItemKind::TyAlias(_) => {\n                     let opt_trait_span = tcx.hir().span_if_local(ty_trait_item.def_id);\n-                    if ty_trait_item.kind == ty::AssocKind::Type {\n-                        compare_ty_impl(\n-                            tcx,\n-                            &ty_impl_item,\n-                            impl_item.span,\n-                            &ty_trait_item,\n-                            impl_trait_ref,\n-                            opt_trait_span,\n-                        );\n-                    } else {\n-                        let mut err = struct_span_err!(\n-                            tcx.sess,\n-                            impl_item.span,\n-                            E0325,\n-                            \"item `{}` is an associated type, \\\n-                             which doesn't match its trait `{}`\",\n-                            ty_impl_item.ident,\n-                            impl_trait_ref.print_only_trait_path()\n-                        );\n-                        err.span_label(impl_item.span, \"does not match trait\");\n-                        if let Some(trait_span) = opt_trait_span {\n-                            err.span_label(trait_span, \"item in trait\");\n-                        }\n-                        err.emit()\n-                    }\n+                    compare_ty_impl(\n+                        tcx,\n+                        &ty_impl_item,\n+                        impl_item.span,\n+                        &ty_trait_item,\n+                        impl_trait_ref,\n+                        opt_trait_span,\n+                    );\n                 }\n             }\n \n@@ -1040,6 +1005,8 @@ pub(super) fn check_impl_items_against_trait<'tcx>(\n                 impl_id.to_def_id(),\n                 impl_item,\n             );\n+        } else {\n+            report_mismatch_error(tcx, ty_trait_item.def_id, impl_trait_ref, impl_item, &ty_impl_item);\n         }\n     }\n \n@@ -1065,6 +1032,58 @@ pub(super) fn check_impl_items_against_trait<'tcx>(\n     }\n }\n \n+#[inline(never)]\n+#[cold]\n+fn report_mismatch_error<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_item_def_id: DefId,\n+    impl_trait_ref: ty::TraitRef<'tcx>,\n+    impl_item: &hir::ImplItem<'_>,\n+    ty_impl_item: &ty::AssocItem,\n+) {\n+    let mut err = match impl_item.kind {\n+        hir::ImplItemKind::Const(..) => {\n+            // Find associated const definition.\n+            struct_span_err!(\n+                tcx.sess,\n+                impl_item.span,\n+                E0323,\n+                \"item `{}` is an associated const, which doesn't match its trait `{}`\",\n+                ty_impl_item.ident,\n+                impl_trait_ref.print_only_trait_path()\n+            )\n+        }\n+\n+        hir::ImplItemKind::Fn(..) => {\n+            struct_span_err!(\n+                tcx.sess,\n+                impl_item.span,\n+                E0324,\n+                \"item `{}` is an associated method, which doesn't match its trait `{}`\",\n+                ty_impl_item.ident,\n+                impl_trait_ref.print_only_trait_path()\n+            )\n+        }\n+\n+        hir::ImplItemKind::TyAlias(_) => {\n+            struct_span_err!(\n+                tcx.sess,\n+                impl_item.span,\n+                E0325,\n+                \"item `{}` is an associated type, which doesn't match its trait `{}`\",\n+                ty_impl_item.ident,\n+                impl_trait_ref.print_only_trait_path()\n+            )\n+        }\n+    };\n+\n+    err.span_label(impl_item.span, \"does not match trait\");\n+    if let Some(trait_span) = tcx.hir().span_if_local(trait_item_def_id) {\n+        err.span_label(trait_span, \"item in trait\");\n+    }\n+    err.emit();\n+}\n+\n /// Checks whether a type can be represented in memory. In particular, it\n /// identifies types that contain themselves without indirection through a\n /// pointer, which would mean their size is unbounded."}]}