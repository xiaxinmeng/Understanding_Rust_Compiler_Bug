{"sha": "acd38f656ad20166f25f527530ddc32a523c9e97", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjZDM4ZjY1NmFkMjAxNjZmMjVmNTI3NTMwZGRjMzJhNTIzYzllOTc=", "commit": {"author": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-07-25T11:20:53Z"}, "committer": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-07-26T19:48:38Z"}, "message": "Improve a few vectors - calculate capacity or build from iterators", "tree": {"sha": "0f678bab0bdf3b891af9f2b899b884cb3fdd99d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f678bab0bdf3b891af9f2b899b884cb3fdd99d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/acd38f656ad20166f25f527530ddc32a523c9e97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/acd38f656ad20166f25f527530ddc32a523c9e97", "html_url": "https://github.com/rust-lang/rust/commit/acd38f656ad20166f25f527530ddc32a523c9e97", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/acd38f656ad20166f25f527530ddc32a523c9e97/comments", "author": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13985724033467ab86da9136c43fe242092b294e", "url": "https://api.github.com/repos/rust-lang/rust/commits/13985724033467ab86da9136c43fe242092b294e", "html_url": "https://github.com/rust-lang/rust/commit/13985724033467ab86da9136c43fe242092b294e"}], "stats": {"total": 35, "additions": 14, "deletions": 21}, "files": [{"sha": "a17c160c4d03e5340051d6597dd69ab1a7ed59cf", "filename": "src/librustc/hir/map/hir_id_validator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acd38f656ad20166f25f527530ddc32a523c9e97/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd38f656ad20166f25f527530ddc32a523c9e97/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs?ref=acd38f656ad20166f25f527530ddc32a523c9e97", "patch": "@@ -105,7 +105,7 @@ impl<'a, 'hir: 'a> HirIdValidator<'a, 'hir> {\n               .collect();\n \n             // Try to map those to something more useful\n-            let mut missing_items = vec![];\n+            let mut missing_items = Vec::with_capacity(missing.len());\n \n             for local_id in missing {\n                 let hir_id = HirId {"}, {"sha": "b8991a0366a61d0672e3ff214bcfa682a8b24b72", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/acd38f656ad20166f25f527530ddc32a523c9e97/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd38f656ad20166f25f527530ddc32a523c9e97/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=acd38f656ad20166f25f527530ddc32a523c9e97", "patch": "@@ -505,11 +505,7 @@ where\n     }\n \n     fn recursive_type_bound(&self, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n-        let mut bounds = vec![];\n-\n-        for subty in ty.walk_shallow() {\n-            bounds.push(self.type_bound(subty));\n-        }\n+        let mut bounds = ty.walk_shallow().map(|subty| self.type_bound(subty)).collect::<Vec<_>>();\n \n         let mut regions = ty.regions();\n         regions.retain(|r| !r.is_late_bound()); // ignore late-bound regions"}, {"sha": "14cfaa8153377d76f1adbdcc6c5acac35ffc2a66", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acd38f656ad20166f25f527530ddc32a523c9e97/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd38f656ad20166f25f527530ddc32a523c9e97/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=acd38f656ad20166f25f527530ddc32a523c9e97", "patch": "@@ -219,7 +219,7 @@ impl LintStore {\n             }\n         }\n \n-        let mut future_incompatible = vec![];\n+        let mut future_incompatible = Vec::with_capacity(lints.len());\n         for lint in lints {\n             future_incompatible.push(lint.id);\n             self.future_incompatible.insert(lint.id, lint);"}, {"sha": "aa4f63675d7341dbab16834fc61ecf64c88fc3f5", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/acd38f656ad20166f25f527530ddc32a523c9e97/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd38f656ad20166f25f527530ddc32a523c9e97/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=acd38f656ad20166f25f527530ddc32a523c9e97", "patch": "@@ -98,13 +98,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn astconv_object_safety_violations(self, trait_def_id: DefId)\n                                             -> Vec<ObjectSafetyViolation>\n     {\n-        let mut violations = vec![];\n-\n-        for def_id in traits::supertrait_def_ids(self, trait_def_id) {\n-            if self.predicates_reference_self(def_id, true) {\n-                violations.push(ObjectSafetyViolation::SupertraitSelf);\n-            }\n-        }\n+        let violations = traits::supertrait_def_ids(self, trait_def_id)\n+            .filter(|&def_id| self.predicates_reference_self(def_id, true))\n+            .map(|_| ObjectSafetyViolation::SupertraitSelf)\n+            .collect();\n \n         debug!(\"astconv_object_safety_violations(trait_def_id={:?}) = {:?}\",\n                trait_def_id,"}, {"sha": "13f0c90e8855e7efd5d20c5e8a4a27da47af6433", "filename": "src/librustc_codegen_llvm/back/link.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/acd38f656ad20166f25f527530ddc32a523c9e97/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd38f656ad20166f25f527530ddc32a523c9e97/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs?ref=acd38f656ad20166f25f527530ddc32a523c9e97", "patch": "@@ -40,6 +40,7 @@ use std::env;\n use std::fmt;\n use std::fs;\n use std::io;\n+use std::iter;\n use std::path::{Path, PathBuf};\n use std::process::{Output, Stdio};\n use std::str;\n@@ -885,9 +886,9 @@ fn exec_linker(sess: &Session, cmd: &mut Command, out_filename: &Path, tmpdir: &\n     }\n     let file = tmpdir.join(\"linker-arguments\");\n     let bytes = if sess.target.target.options.is_like_msvc {\n-        let mut out = vec![];\n+        let mut out = Vec::with_capacity((1 + args.len()) * 2);\n         // start the stream with a UTF-16 BOM\n-        for c in vec![0xFEFF].into_iter().chain(args.encode_utf16()) {\n+        for c in iter::once(0xFEFF).chain(args.encode_utf16()) {\n             // encode in little endian\n             out.push(c as u8);\n             out.push((c >> 8) as u8);"}, {"sha": "dfa38e874a7a55c346415b523ffcf31efce85740", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/acd38f656ad20166f25f527530ddc32a523c9e97/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd38f656ad20166f25f527530ddc32a523c9e97/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=acd38f656ad20166f25f527530ddc32a523c9e97", "patch": "@@ -634,15 +634,14 @@ impl MultiSpan {\n     /// `SpanLabel` instances with empty labels.\n     pub fn span_labels(&self) -> Vec<SpanLabel> {\n         let is_primary = |span| self.primary_spans.contains(&span);\n-        let mut span_labels = vec![];\n \n-        for &(span, ref label) in &self.span_labels {\n-            span_labels.push(SpanLabel {\n+        let mut span_labels = self.span_labels.iter().map(|&(span, ref label)|\n+            SpanLabel {\n                 span,\n                 is_primary: is_primary(span),\n                 label: Some(label.clone())\n-            });\n-        }\n+            }\n+        ).collect::<Vec<_>>();\n \n         for &span in &self.primary_spans {\n             if !span_labels.iter().any(|sl| sl.span == span) {"}]}