{"sha": "aeda178011775f4a8e16446341fe4774e02d8f5f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlZGExNzgwMTE3NzVmNGE4ZTE2NDQ2MzQxZmU0Nzc0ZTAyZDhmNWY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-05-24T02:12:16Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-05-30T02:04:50Z"}, "message": "librustc: Redo the unsafe checker and make unsafe methods not callable from safe code", "tree": {"sha": "6e96ca95949ebee511eea69ebe1a854cc31dee0a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e96ca95949ebee511eea69ebe1a854cc31dee0a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aeda178011775f4a8e16446341fe4774e02d8f5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aeda178011775f4a8e16446341fe4774e02d8f5f", "html_url": "https://github.com/rust-lang/rust/commit/aeda178011775f4a8e16446341fe4774e02d8f5f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aeda178011775f4a8e16446341fe4774e02d8f5f/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5da389d36ec9108f82bb7025eabb7ce4f26b103", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5da389d36ec9108f82bb7025eabb7ce4f26b103", "html_url": "https://github.com/rust-lang/rust/commit/b5da389d36ec9108f82bb7025eabb7ce4f26b103"}], "stats": {"total": 424, "additions": 288, "deletions": 136}, "files": [{"sha": "e120f3dd033c67c5c2627b0989277ba24a7ab22d", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/aeda178011775f4a8e16446341fe4774e02d8f5f/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeda178011775f4a8e16446341fe4774e02d8f5f/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=aeda178011775f4a8e16446341fe4774e02d8f5f", "patch": "@@ -198,13 +198,15 @@ pub impl<T:Owned> MutexARC<T> {\n      */\n     #[inline(always)]\n     unsafe fn access<U>(&self, blk: &fn(x: &mut T) -> U) -> U {\n-        let state = self.x.get();\n-        // Borrowck would complain about this if the function were\n-        // not already unsafe. See borrow_rwlock, far below.\n-        do (&(*state).lock).lock {\n-            check_poison(true, (*state).failed);\n-            let _z = PoisonOnFail(&mut (*state).failed);\n-            blk(&mut (*state).data)\n+        unsafe {\n+            let state = self.x.get();\n+            // Borrowck would complain about this if the function were\n+            // not already unsafe. See borrow_rwlock, far below.\n+            do (&(*state).lock).lock {\n+                check_poison(true, (*state).failed);\n+                let _z = PoisonOnFail(&mut (*state).failed);\n+                blk(&mut (*state).data)\n+            }\n         }\n     }\n \n@@ -356,8 +358,8 @@ pub impl<T:Const + Owned> RWARC<T> {\n      * access modes, this will not poison the ARC.\n      */\n     fn read<U>(&self, blk: &fn(x: &T) -> U) -> U {\n-        let state = self.x.get();\n         unsafe {\n+            let state = self.x.get();\n             do (*state).lock.read {\n                 check_poison(false, (*state).failed);\n                 blk(&(*state).data)"}, {"sha": "beea3b6f52b4d0c8ef19b4b65ee9ab7a93ed49d1", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 51, "deletions": 43, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/aeda178011775f4a8e16446341fe4774e02d8f5f/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeda178011775f4a8e16446341fe4774e02d8f5f/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=aeda178011775f4a8e16446341fe4774e02d8f5f", "patch": "@@ -100,30 +100,34 @@ fn new_sem_and_signal(count: int, num_condvars: uint)\n #[doc(hidden)]\n pub impl<Q:Owned> Sem<Q> {\n     fn acquire(&self) {\n-        let mut waiter_nobe = None;\n-        do (**self).with |state| {\n-            state.count -= 1;\n-            if state.count < 0 {\n-                // Create waiter nobe.\n-                let (WaitEnd, SignalEnd) = comm::oneshot();\n-                // Tell outer scope we need to block.\n-                waiter_nobe = Some(WaitEnd);\n-                // Enqueue ourself.\n-                state.waiters.tail.send(SignalEnd);\n+        unsafe {\n+            let mut waiter_nobe = None;\n+            do (**self).with |state| {\n+                state.count -= 1;\n+                if state.count < 0 {\n+                    // Create waiter nobe.\n+                    let (WaitEnd, SignalEnd) = comm::oneshot();\n+                    // Tell outer scope we need to block.\n+                    waiter_nobe = Some(WaitEnd);\n+                    // Enqueue ourself.\n+                    state.waiters.tail.send(SignalEnd);\n+                }\n+            }\n+            // Uncomment if you wish to test for sem races. Not valgrind-friendly.\n+            /* for 1000.times { task::yield(); } */\n+            // Need to wait outside the exclusive.\n+            if waiter_nobe.is_some() {\n+                let _ = comm::recv_one(waiter_nobe.unwrap());\n             }\n-        }\n-        // Uncomment if you wish to test for sem races. Not valgrind-friendly.\n-        /* for 1000.times { task::yield(); } */\n-        // Need to wait outside the exclusive.\n-        if waiter_nobe.is_some() {\n-            let _ = comm::recv_one(waiter_nobe.unwrap());\n         }\n     }\n     fn release(&self) {\n-        do (**self).with |state| {\n-            state.count += 1;\n-            if state.count <= 0 {\n-                signal_waitqueue(&state.waiters);\n+        unsafe {\n+            do (**self).with |state| {\n+                state.count += 1;\n+                if state.count <= 0 {\n+                    signal_waitqueue(&state.waiters);\n+                }\n             }\n         }\n     }\n@@ -283,17 +287,19 @@ pub impl<'self> Condvar<'self> {\n \n     /// As signal, but with a specified condvar_id. See wait_on.\n     fn signal_on(&self, condvar_id: uint) -> bool {\n-        let mut out_of_bounds = None;\n-        let mut result = false;\n-        do (**self.sem).with |state| {\n-            if condvar_id < state.blocked.len() {\n-                result = signal_waitqueue(&state.blocked[condvar_id]);\n-            } else {\n-                out_of_bounds = Some(state.blocked.len());\n+        unsafe {\n+            let mut out_of_bounds = None;\n+            let mut result = false;\n+            do (**self.sem).with |state| {\n+                if condvar_id < state.blocked.len() {\n+                    result = signal_waitqueue(&state.blocked[condvar_id]);\n+                } else {\n+                    out_of_bounds = Some(state.blocked.len());\n+                }\n+            }\n+            do check_cvar_bounds(out_of_bounds, condvar_id, \"cond.signal_on()\") {\n+                result\n             }\n-        }\n-        do check_cvar_bounds(out_of_bounds, condvar_id, \"cond.signal_on()\") {\n-            result\n         }\n     }\n \n@@ -304,20 +310,22 @@ pub impl<'self> Condvar<'self> {\n     fn broadcast_on(&self, condvar_id: uint) -> uint {\n         let mut out_of_bounds = None;\n         let mut queue = None;\n-        do (**self.sem).with |state| {\n-            if condvar_id < state.blocked.len() {\n-                // To avoid :broadcast_heavy, we make a new waitqueue,\n-                // swap it out with the old one, and broadcast on the\n-                // old one outside of the little-lock.\n-                queue = Some(util::replace(&mut state.blocked[condvar_id],\n-                                           new_waitqueue()));\n-            } else {\n-                out_of_bounds = Some(state.blocked.len());\n+        unsafe {\n+            do (**self.sem).with |state| {\n+                if condvar_id < state.blocked.len() {\n+                    // To avoid :broadcast_heavy, we make a new waitqueue,\n+                    // swap it out with the old one, and broadcast on the\n+                    // old one outside of the little-lock.\n+                    queue = Some(util::replace(&mut state.blocked[condvar_id],\n+                                               new_waitqueue()));\n+                } else {\n+                    out_of_bounds = Some(state.blocked.len());\n+                }\n+            }\n+            do check_cvar_bounds(out_of_bounds, condvar_id, \"cond.signal_on()\") {\n+                let queue = queue.swap_unwrap();\n+                broadcast_waitqueue(&queue)\n             }\n-        }\n-        do check_cvar_bounds(out_of_bounds, condvar_id, \"cond.signal_on()\") {\n-            let queue = queue.swap_unwrap();\n-            broadcast_waitqueue(&queue)\n         }\n     }\n }"}, {"sha": "b56699927e4ec7d5146b4e578fb7605b5feec187", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aeda178011775f4a8e16446341fe4774e02d8f5f/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeda178011775f4a8e16446341fe4774e02d8f5f/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=aeda178011775f4a8e16446341fe4774e02d8f5f", "patch": "@@ -262,6 +262,9 @@ pub fn compile_rest(sess: Session,\n         time(time_passes, ~\"privacy checking\", ||\n              middle::privacy::check_crate(ty_cx, &method_map, crate));\n \n+        time(time_passes, ~\"effect checking\", ||\n+             middle::effect::check_crate(ty_cx, method_map, crate));\n+\n         time(time_passes, ~\"loop checking\", ||\n              middle::check_loop::check_crate(ty_cx, crate));\n "}, {"sha": "d2f0a5580ef6eaf282eada9c77a789aeb4214a12", "filename": "src/librustc/middle/effect.rs", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/aeda178011775f4a8e16446341fe4774e02d8f5f/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeda178011775f4a8e16446341fe4774e02d8f5f/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=aeda178011775f4a8e16446341fe4774e02d8f5f", "patch": "@@ -0,0 +1,154 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Enforces the Rust effect system. Currently there is just one effect,\n+/// `unsafe`.\n+\n+use middle::ty::{ty_bare_fn, ty_closure, ty_ptr};\n+use middle::ty;\n+use middle::typeck::method_map;\n+use util::ppaux;\n+\n+use syntax::ast::{deref, expr_call, expr_inline_asm, expr_method_call};\n+use syntax::ast::{expr_unary, node_id, unsafe_blk, unsafe_fn};\n+use syntax::ast;\n+use syntax::codemap::span;\n+use syntax::visit::{fk_item_fn, fk_method};\n+use syntax::visit;\n+\n+#[deriving(Eq)]\n+enum UnsafeContext {\n+    SafeContext,\n+    UnsafeFn,\n+    UnsafeBlock(node_id),\n+}\n+\n+struct Context {\n+    /// The method map.\n+    method_map: method_map,\n+    /// Whether we're in an unsafe context.\n+    unsafe_context: UnsafeContext,\n+}\n+\n+fn type_is_unsafe_function(ty: ty::t) -> bool {\n+    match ty::get(ty).sty {\n+        ty_bare_fn(ref f) => f.purity == unsafe_fn,\n+        ty_closure(ref f) => f.purity == unsafe_fn,\n+        _ => false,\n+    }\n+}\n+\n+pub fn check_crate(tcx: ty::ctxt,\n+                   method_map: method_map,\n+                   crate: @ast::crate) {\n+    let context = @mut Context {\n+        method_map: method_map,\n+        unsafe_context: SafeContext,\n+    };\n+\n+    let require_unsafe: @fn(span: span,\n+                            description: &str) = |span, description| {\n+        match context.unsafe_context {\n+            SafeContext => {\n+                // Report an error.\n+                tcx.sess.span_err(span,\n+                                  fmt!(\"%s requires unsafe function or block\",\n+                                       description))\n+            }\n+            UnsafeBlock(block_id) => {\n+                // OK, but record this.\n+                debug!(\"effect: recording unsafe block as used: %?\", block_id);\n+                let _ = tcx.used_unsafe.insert(block_id);\n+            }\n+            UnsafeFn => {}\n+        }\n+    };\n+\n+    let visitor = visit::mk_vt(@visit::Visitor {\n+        visit_fn: |fn_kind, fn_decl, block, span, node_id, _, visitor| {\n+            let is_unsafe_fn = match *fn_kind {\n+                fk_item_fn(_, _, purity, _) => purity == unsafe_fn,\n+                fk_method(_, _, method) => method.purity == unsafe_fn,\n+                _ => false,\n+            };\n+\n+            let old_unsafe_context = context.unsafe_context;\n+            if is_unsafe_fn {\n+                context.unsafe_context = UnsafeFn\n+            }\n+\n+            visit::visit_fn(fn_kind,\n+                            fn_decl,\n+                            block,\n+                            span,\n+                            node_id,\n+                            (),\n+                            visitor);\n+\n+            context.unsafe_context = old_unsafe_context\n+        },\n+\n+        visit_block: |block, _, visitor| {\n+            let old_unsafe_context = context.unsafe_context;\n+            if block.node.rules == unsafe_blk {\n+                context.unsafe_context = UnsafeBlock(block.node.id)\n+            }\n+\n+            visit::visit_block(block, (), visitor);\n+\n+            context.unsafe_context = old_unsafe_context\n+        },\n+\n+        visit_expr: |expr, _, visitor| {\n+            match expr.node {\n+                expr_method_call(*) => {\n+                    let base_type = ty::node_id_to_type(tcx, expr.callee_id);\n+                    debug!(\"effect: method call case, base type is %s\",\n+                           ppaux::ty_to_str(tcx, base_type));\n+                    if type_is_unsafe_function(base_type) {\n+                        require_unsafe(expr.span,\n+                                       \"invocation of unsafe method\")\n+                    }\n+                }\n+                expr_call(base, _, _) => {\n+                    let base_type = ty::node_id_to_type(tcx, base.id);\n+                    debug!(\"effect: call case, base type is %s\",\n+                           ppaux::ty_to_str(tcx, base_type));\n+                    if type_is_unsafe_function(base_type) {\n+                        require_unsafe(expr.span, \"call to unsafe function\")\n+                    }\n+                }\n+                expr_unary(deref, base) => {\n+                    let base_type = ty::node_id_to_type(tcx, base.id);\n+                    debug!(\"effect: unary case, base type is %s\",\n+                           ppaux::ty_to_str(tcx, base_type));\n+                    match ty::get(base_type).sty {\n+                        ty_ptr(_) => {\n+                            require_unsafe(expr.span,\n+                                           \"dereference of unsafe pointer\")\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+                expr_inline_asm(*) => {\n+                    require_unsafe(expr.span, \"use of inline assembly\")\n+                }\n+                _ => {}\n+            }\n+\n+            visit::visit_expr(expr, (), visitor)\n+        },\n+\n+        .. *visit::default_visitor()\n+    });\n+\n+    visit::visit_crate(crate, (), visitor)\n+}\n+"}, {"sha": "f25d451363bd3d12c8d9b8b3c43186173e83f523", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/aeda178011775f4a8e16446341fe4774e02d8f5f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeda178011775f4a8e16446341fe4774e02d8f5f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=aeda178011775f4a8e16446341fe4774e02d8f5f", "patch": "@@ -891,21 +891,6 @@ pub impl FnCtxt {\n         infer::mk_subr(self.infcx(), a_is_expected, span, sub, sup)\n     }\n \n-    fn require_unsafe(&self, sp: span, op: ~str) {\n-        match self.ps.purity {\n-          ast::unsafe_fn => {\n-            // ok, but flag that we used the source of unsafeness\n-            debug!(\"flagging %? as a used unsafe source\", self.ps);\n-            self.tcx().used_unsafe.insert(self.ps.def);\n-          }\n-          _ => {\n-            self.ccx.tcx.sess.span_err(\n-                sp,\n-                fmt!(\"%s requires unsafe function or block\", op));\n-          }\n-        }\n-    }\n-\n     fn with_region_lb<R>(@mut self, lb: ast::node_id, f: &fn() -> R) -> R {\n         let old_region_lb = self.region_lb;\n         self.region_lb = lb;\n@@ -2285,16 +2270,6 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 }\n                 ast::deref => {\n                     let sty = structure_of(fcx, expr.span, oprnd_t);\n-                    match sty {\n-                        // deref'ing an unsafe pointer requires that we be in\n-                        // an unsafe context\n-                        ty::ty_ptr(*) => {\n-                            fcx.require_unsafe(\n-                                expr.span,\n-                                ~\"dereference of unsafe pointer\");\n-                        }\n-                        _ => { /*ok*/ }\n-                    }\n                     let operand_ty = ty::deref_sty(tcx, &sty, true);\n                     match operand_ty {\n                         Some(mt) => {\n@@ -2392,8 +2367,6 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         fcx.write_ty(id, ty_param_bounds_and_ty.ty);\n       }\n       ast::expr_inline_asm(ref ia) => {\n-          fcx.require_unsafe(expr.span, ~\"use of inline assembly\");\n-\n           for ia.inputs.each |&(_, in)| {\n               check_expr(fcx, in);\n           }\n@@ -3223,13 +3196,6 @@ pub fn ty_param_bounds_and_ty_for_def(fcx: @mut FnCtxt,\n         };\n       }\n \n-      ast::def_fn(id, ast::unsafe_fn) |\n-      ast::def_static_method(id, _, ast::unsafe_fn) => {\n-        // Unsafe functions can only be touched in an unsafe context\n-        fcx.require_unsafe(sp, ~\"access to unsafe function\");\n-        return ty::lookup_item_type(fcx.ccx.tcx, id);\n-      }\n-\n       ast::def_fn(id, _) | ast::def_static_method(id, _, _) |\n       ast::def_const(id) | ast::def_variant(_, id) |\n       ast::def_struct(id) => {"}, {"sha": "019ca2a0ed51934a3ebc760175cdcd5a03b9dda2", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aeda178011775f4a8e16446341fe4774e02d8f5f/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/aeda178011775f4a8e16446341fe4774e02d8f5f/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=aeda178011775f4a8e16446341fe4774e02d8f5f", "patch": "@@ -109,6 +109,7 @@ pub mod middle {\n     pub mod privacy;\n     pub mod moves;\n     pub mod entry;\n+    pub mod effect;\n }\n \n pub mod front {"}, {"sha": "adc2c21580b0222cd869d7d5111f5ce45c36f88e", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/aeda178011775f4a8e16446341fe4774e02d8f5f/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeda178011775f4a8e16446341fe4774e02d8f5f/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=aeda178011775f4a8e16446341fe4774e02d8f5f", "patch": "@@ -236,20 +236,24 @@ impl<T: Owned> SharedChan<T> {\n \n impl<T: Owned> GenericChan<T> for SharedChan<T> {\n     fn send(&self, x: T) {\n-        let mut xx = Some(x);\n-        do self.ch.with_imm |chan| {\n-            let x = replace(&mut xx, None);\n-            chan.send(x.unwrap())\n+        unsafe {\n+            let mut xx = Some(x);\n+            do self.ch.with_imm |chan| {\n+                let x = replace(&mut xx, None);\n+                chan.send(x.unwrap())\n+            }\n         }\n     }\n }\n \n impl<T: Owned> GenericSmartChan<T> for SharedChan<T> {\n     fn try_send(&self, x: T) -> bool {\n-        let mut xx = Some(x);\n-        do self.ch.with_imm |chan| {\n-            let x = replace(&mut xx, None);\n-            chan.try_send(x.unwrap())\n+        unsafe {\n+            let mut xx = Some(x);\n+            do self.ch.with_imm |chan| {\n+                let x = replace(&mut xx, None);\n+                chan.try_send(x.unwrap())\n+            }\n         }\n     }\n }"}, {"sha": "9c8c2dbe4d71c56aeda9697e6e55758f9b1fe306", "filename": "src/libstd/os.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/aeda178011775f4a8e16446341fe4774e02d8f5f/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeda178011775f4a8e16446341fe4774e02d8f5f/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=aeda178011775f4a8e16446341fe4774e02d8f5f", "patch": "@@ -861,20 +861,18 @@ pub fn change_dir_locked(p: &Path, action: &fn()) -> bool {\n \n     fn key(_: Exclusive<()>) { }\n \n-    let result = unsafe {\n-        global_data_clone_create(key, || {\n-            ~exclusive(())\n-        })\n-    };\n+    unsafe {\n+        let result = global_data_clone_create(key, || { ~exclusive(()) });\n \n-    do result.with_imm() |_| {\n-        let old_dir = os::getcwd();\n-        if change_dir(p) {\n-            action();\n-            change_dir(&old_dir)\n-        }\n-        else {\n-            false\n+        do result.with_imm() |_| {\n+            let old_dir = os::getcwd();\n+            if change_dir(p) {\n+                action();\n+                change_dir(&old_dir)\n+            }\n+            else {\n+                false\n+            }\n         }\n     }\n }"}, {"sha": "fb1a533464669ac696a4e84569408f7d105622f1", "filename": "src/libstd/rt/message_queue.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/aeda178011775f4a8e16446341fe4774e02d8f5f/src%2Flibstd%2Frt%2Fmessage_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeda178011775f4a8e16446341fe4774e02d8f5f/src%2Flibstd%2Frt%2Fmessage_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmessage_queue.rs?ref=aeda178011775f4a8e16446341fe4774e02d8f5f", "patch": "@@ -29,16 +29,20 @@ impl<T: Owned> MessageQueue<T> {\n     }\n \n     pub fn push(&mut self, value: T) {\n-        let value = Cell(value);\n-        self.queue.with(|q| q.push(value.take()) );\n+        unsafe {\n+            let value = Cell(value);\n+            self.queue.with(|q| q.push(value.take()) );\n+        }\n     }\n \n     pub fn pop(&mut self) -> Option<T> {\n-        do self.queue.with |q| {\n-            if !q.is_empty() {\n-                Some(q.shift())\n-            } else {\n-                None\n+        unsafe {\n+            do self.queue.with |q| {\n+                if !q.is_empty() {\n+                    Some(q.shift())\n+                } else {\n+                    None\n+                }\n             }\n         }\n     }"}, {"sha": "4671a45aaea3af8c3e78264f380917a4b40da15d", "filename": "src/libstd/rt/work_queue.rs", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/aeda178011775f4a8e16446341fe4774e02d8f5f/src%2Flibstd%2Frt%2Fwork_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeda178011775f4a8e16446341fe4774e02d8f5f/src%2Flibstd%2Frt%2Fwork_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fwork_queue.rs?ref=aeda178011775f4a8e16446341fe4774e02d8f5f", "patch": "@@ -29,32 +29,40 @@ pub impl<T: Owned> WorkQueue<T> {\n     }\n \n     fn push(&mut self, value: T) {\n-        let value = Cell(value);\n-        self.queue.with(|q| q.unshift(value.take()) );\n+        unsafe {\n+            let value = Cell(value);\n+            self.queue.with(|q| q.unshift(value.take()) );\n+        }\n     }\n \n     fn pop(&mut self) -> Option<T> {\n-        do self.queue.with |q| {\n-            if !q.is_empty() {\n-                Some(q.shift())\n-            } else {\n-                None\n+        unsafe {\n+            do self.queue.with |q| {\n+                if !q.is_empty() {\n+                    Some(q.shift())\n+                } else {\n+                    None\n+                }\n             }\n         }\n     }\n \n     fn steal(&mut self) -> Option<T> {\n-        do self.queue.with |q| {\n-            if !q.is_empty() {\n-                Some(q.pop())\n-            } else {\n-                None\n+        unsafe {\n+            do self.queue.with |q| {\n+                if !q.is_empty() {\n+                    Some(q.pop())\n+                } else {\n+                    None\n+                }\n             }\n         }\n     }\n \n     fn is_empty(&self) -> bool {\n-        self.queue.with_imm(|q| q.is_empty() )\n+        unsafe {\n+            self.queue.with_imm(|q| q.is_empty() )\n+        }\n     }\n }\n "}, {"sha": "56b1fb43ff1c07ee2d2e893e768f3e273f2b0a4e", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aeda178011775f4a8e16446341fe4774e02d8f5f/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeda178011775f4a8e16446341fe4774e02d8f5f/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=aeda178011775f4a8e16446341fe4774e02d8f5f", "patch": "@@ -159,13 +159,17 @@ struct AncestorList(Option<Exclusive<AncestorNode>>);\n // Accessors for taskgroup arcs and ancestor arcs that wrap the unsafety.\n #[inline(always)]\n fn access_group<U>(x: &TaskGroupArc, blk: &fn(TaskGroupInner) -> U) -> U {\n-    x.with(blk)\n+    unsafe {\n+        x.with(blk)\n+    }\n }\n \n #[inline(always)]\n fn access_ancestors<U>(x: &Exclusive<AncestorNode>,\n                        blk: &fn(x: &mut AncestorNode) -> U) -> U {\n-    x.with(blk)\n+    unsafe {\n+        x.with(blk)\n+    }\n }\n \n // Iterates over an ancestor list."}, {"sha": "2f5258aa7f23e4022381d68861a6a7d9be149edf", "filename": "src/test/compile-fail/foreign-unsafe-fn-called.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aeda178011775f4a8e16446341fe4774e02d8f5f/src%2Ftest%2Fcompile-fail%2Fforeign-unsafe-fn-called.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeda178011775f4a8e16446341fe4774e02d8f5f/src%2Ftest%2Fcompile-fail%2Fforeign-unsafe-fn-called.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fforeign-unsafe-fn-called.rs?ref=aeda178011775f4a8e16446341fe4774e02d8f5f", "patch": "@@ -19,5 +19,5 @@ mod test {\n \n fn main() {\n     test::free();\n-    //~^ ERROR access to unsafe function requires unsafe function or block\n+    //~^ ERROR call to unsafe function requires unsafe function or block\n }"}, {"sha": "fce269ab5174e1b8447d32439ad0690bdf8629c7", "filename": "src/test/compile-fail/foreign-unsafe-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aeda178011775f4a8e16446341fe4774e02d8f5f/src%2Ftest%2Fcompile-fail%2Fforeign-unsafe-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeda178011775f4a8e16446341fe4774e02d8f5f/src%2Ftest%2Fcompile-fail%2Fforeign-unsafe-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fforeign-unsafe-fn.rs?ref=aeda178011775f4a8e16446341fe4774e02d8f5f", "patch": "@@ -19,5 +19,5 @@ mod test {\n \n fn main() {\n     let x = test::free;\n-    //~^ ERROR access to unsafe function requires unsafe function or block\n+    //~^ ERROR call to unsafe function requires unsafe function or block\n }"}, {"sha": "9ad7a178fb188ae84d205b72bc25d03780775331", "filename": "src/test/compile-fail/forget-init-unsafe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aeda178011775f4a8e16446341fe4774e02d8f5f/src%2Ftest%2Fcompile-fail%2Fforget-init-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeda178011775f4a8e16446341fe4774e02d8f5f/src%2Ftest%2Fcompile-fail%2Fforget-init-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fforget-init-unsafe.rs?ref=aeda178011775f4a8e16446341fe4774e02d8f5f", "patch": "@@ -12,6 +12,6 @@ use std::unstable::intrinsics::{init, forget};\n \n // Test that the `forget` and `init` intrinsics are really unsafe\n pub fn main() {\n-    let stuff = init::<int>(); //~ ERROR access to unsafe function requires unsafe\n-    forget(stuff);             //~ ERROR access to unsafe function requires unsafe\n-}\n\\ No newline at end of file\n+    let stuff = init::<int>(); //~ ERROR call to unsafe function requires unsafe\n+    forget(stuff);             //~ ERROR call to unsafe function requires unsafe\n+}"}, {"sha": "2ea0f5a4ec91d3dd68b87832e3afaf19c6f8ff09", "filename": "src/test/compile-fail/unsafe-fn-called-from-safe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aeda178011775f4a8e16446341fe4774e02d8f5f/src%2Ftest%2Fcompile-fail%2Funsafe-fn-called-from-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeda178011775f4a8e16446341fe4774e02d8f5f/src%2Ftest%2Fcompile-fail%2Funsafe-fn-called-from-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-fn-called-from-safe.rs?ref=aeda178011775f4a8e16446341fe4774e02d8f5f", "patch": "@@ -13,5 +13,5 @@\n unsafe fn f() { return; }\n \n fn main() {\n-    f(); //~ ERROR access to unsafe function requires unsafe function or block\n+    f(); //~ ERROR call to unsafe function requires unsafe function or block\n }"}, {"sha": "b5565b4821b36a2c6552db9806a69f20ab9efb28", "filename": "src/test/compile-fail/unsafe-fn-used-as-value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aeda178011775f4a8e16446341fe4774e02d8f5f/src%2Ftest%2Fcompile-fail%2Funsafe-fn-used-as-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeda178011775f4a8e16446341fe4774e02d8f5f/src%2Ftest%2Fcompile-fail%2Funsafe-fn-used-as-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-fn-used-as-value.rs?ref=aeda178011775f4a8e16446341fe4774e02d8f5f", "patch": "@@ -13,6 +13,6 @@\n unsafe fn f() { return; }\n \n fn main() {\n-    let x = f; //~ ERROR access to unsafe function requires unsafe function or block\n-    x();\n+    let x = f;\n+    x();    //~ ERROR call to unsafe function requires unsafe function or block\n }"}]}