{"sha": "193a1c8af6a0ceef734fff9acc07231c67896bb1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5M2ExYzhhZjZhMGNlZWY3MzRmZmY5YWNjMDcyMzFjNjc4OTZiYjE=", "commit": {"author": {"name": "Gareth Smith", "email": "garethdanielsmith@gmail.com", "date": "2013-08-01T22:48:22Z"}, "committer": {"name": "Gareth Smith", "email": "garethdanielsmith@gmail.com", "date": "2013-09-05T20:19:47Z"}, "message": "Replace os::glob with extra::glob, which is written in rust,\nfixing issue #6100.", "tree": {"sha": "cb9247ef6186a9e884c7981e7b06ca00bad07e12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb9247ef6186a9e884c7981e7b06ca00bad07e12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/193a1c8af6a0ceef734fff9acc07231c67896bb1", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/193a1c8af6a0ceef734fff9acc07231c67896bb1", "html_url": "https://github.com/rust-lang/rust/commit/193a1c8af6a0ceef734fff9acc07231c67896bb1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/193a1c8af6a0ceef734fff9acc07231c67896bb1/comments", "author": {"login": "Dretch", "id": 1428731, "node_id": "MDQ6VXNlcjE0Mjg3MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1428731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dretch", "html_url": "https://github.com/Dretch", "followers_url": "https://api.github.com/users/Dretch/followers", "following_url": "https://api.github.com/users/Dretch/following{/other_user}", "gists_url": "https://api.github.com/users/Dretch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dretch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dretch/subscriptions", "organizations_url": "https://api.github.com/users/Dretch/orgs", "repos_url": "https://api.github.com/users/Dretch/repos", "events_url": "https://api.github.com/users/Dretch/events{/privacy}", "received_events_url": "https://api.github.com/users/Dretch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Dretch", "id": 1428731, "node_id": "MDQ6VXNlcjE0Mjg3MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1428731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dretch", "html_url": "https://github.com/Dretch", "followers_url": "https://api.github.com/users/Dretch/followers", "following_url": "https://api.github.com/users/Dretch/following{/other_user}", "gists_url": "https://api.github.com/users/Dretch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dretch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dretch/subscriptions", "organizations_url": "https://api.github.com/users/Dretch/orgs", "repos_url": "https://api.github.com/users/Dretch/repos", "events_url": "https://api.github.com/users/Dretch/events{/privacy}", "received_events_url": "https://api.github.com/users/Dretch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d84a7b5ae3b3a820fb0a26292632856ceb959b3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d84a7b5ae3b3a820fb0a26292632856ceb959b3e", "html_url": "https://github.com/rust-lang/rust/commit/d84a7b5ae3b3a820fb0a26292632856ceb959b3e"}], "stats": {"total": 905, "additions": 821, "deletions": 84}, "files": [{"sha": "9c3c8636d8907e741e3b4a7aa5e0ecbc1b8f18c7", "filename": "src/libextra/extra.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/193a1c8af6a0ceef734fff9acc07231c67896bb1/src%2Flibextra%2Fextra.rs", "raw_url": "https://github.com/rust-lang/rust/raw/193a1c8af6a0ceef734fff9acc07231c67896bb1/src%2Flibextra%2Fextra.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fextra.rs?ref=193a1c8af6a0ceef734fff9acc07231c67896bb1", "patch": "@@ -85,6 +85,7 @@ pub mod getopts;\n pub mod json;\n pub mod md4;\n pub mod tempfile;\n+pub mod glob;\n pub mod term;\n pub mod time;\n pub mod arena;"}, {"sha": "7598049737454ece58de8a07a6f51bdb6fc85206", "filename": "src/libextra/glob.rs", "status": "added", "additions": 820, "deletions": 0, "changes": 820, "blob_url": "https://github.com/rust-lang/rust/blob/193a1c8af6a0ceef734fff9acc07231c67896bb1/src%2Flibextra%2Fglob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/193a1c8af6a0ceef734fff9acc07231c67896bb1/src%2Flibextra%2Fglob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fglob.rs?ref=193a1c8af6a0ceef734fff9acc07231c67896bb1", "patch": "@@ -0,0 +1,820 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * Support for matching file paths against Unix shell style patterns.\n+ *\n+ * The `glob` and `glob_with` functions, in concert with the `GlobIterator`\n+ * type, allow querying the filesystem for all files that match a particular\n+ * pattern - just like the libc `glob` function (for an example see the `glob`\n+ * documentation). The methods on the `Pattern` type provide functionality\n+ * for checking if individual paths match a particular pattern - in a similar\n+ * manner to the libc `fnmatch` function\n+ *\n+ * For consistency across platforms, and for Windows support, this module\n+ * is implemented entirely in Rust rather than deferring to the libc\n+ * `glob`/`fnmatch` functions.\n+ */\n+\n+use std::{os, path, util};\n+\n+use sort;\n+\n+/**\n+ * An iterator that yields Paths from the filesystem that match a particular\n+ * pattern - see the `glob` function for more details.\n+ */\n+pub struct GlobIterator {\n+    priv root: Path,\n+    priv dir_patterns: ~[Pattern],\n+    priv options: MatchOptions,\n+    priv todo: ~[Path]\n+}\n+\n+/**\n+ * Return an iterator that produces all the Paths that match the given pattern,\n+ * which may be absolute or relative to the current working directory.\n+ *\n+ * This method uses the default match options and is equivalent to calling\n+ * `glob_with(pattern, MatchOptions::new())`. Use `glob_with` directly if you\n+ * want to use non-default match options.\n+ *\n+ * # Example\n+ *\n+ * Consider a directory `/media/pictures` containing only the files `kittens.jpg`,\n+ * `puppies.jpg` and `hamsters.gif`:\n+ *\n+ * ~~~ {.rust}\n+ * for path in glob(\"/media/pictures/*.jpg\") {\n+ *     println(path.to_str());\n+ * }\n+ * ~~~\n+ *\n+ * The above code will print:\n+ *\n+ * ~~~\n+ * /media/pictures/kittens.jpg\n+ * /media/pictures/puppies.jpg\n+ * ~~~\n+ */\n+pub fn glob(pattern: &str) -> GlobIterator {\n+    glob_with(pattern, MatchOptions::new())\n+}\n+\n+/**\n+ * Return an iterator that produces all the Paths that match the given pattern,\n+ * which may be absolute or relative to the current working directory.\n+ *\n+ * This function accepts Unix shell style patterns as described by `Pattern::new(..)`.\n+ * The options given are passed through unchanged to `Pattern::matches_with(..)` with\n+ * the exception that `require_literal_separator` is always set to `true` regardless of the\n+ * value passed to this function.\n+ *\n+ * Paths are yielded in alphabetical order, as absolute paths.\n+ */\n+pub fn glob_with(pattern: &str, options: MatchOptions) -> GlobIterator {\n+\n+    // note that this relies on the glob meta characters not\n+    // having any special meaning in actual pathnames\n+    let path = Path(pattern);\n+    let dir_patterns = path.components.map(|s| Pattern::new(*s));\n+\n+    let root = if path.is_absolute() {\n+        Path {components: ~[], .. path} // preserve windows path host/device\n+    } else {\n+        os::getcwd()\n+    };\n+    let todo = list_dir_sorted(&root);\n+\n+    GlobIterator {\n+        root: root,\n+        dir_patterns: dir_patterns,\n+        options: options,\n+        todo: todo,\n+    }\n+}\n+\n+impl Iterator<Path> for GlobIterator {\n+\n+    fn next(&mut self) -> Option<Path> {\n+        loop {\n+            if self.dir_patterns.is_empty() || self.todo.is_empty() {\n+                return None;\n+            }\n+\n+            let path = self.todo.pop();\n+            let pattern_index = path.components.len() - self.root.components.len() - 1;\n+            let ref pattern = self.dir_patterns[pattern_index];\n+\n+            if pattern.matches_with(*path.components.last(), self.options) {\n+\n+                if pattern_index == self.dir_patterns.len() - 1 {\n+                    // it is not possible for a pattern to match a directory *AND* its children\n+                    // so we don't need to check the children\n+                    return Some(path);\n+                } else {\n+                    self.todo.push_all(list_dir_sorted(&path));\n+                }\n+            }\n+        }\n+    }\n+\n+}\n+\n+fn list_dir_sorted(path: &Path) -> ~[Path] {\n+    let mut children = os::list_dir_path(path);\n+    sort::quick_sort(children, |p1, p2| p2.components.last() <= p1.components.last());\n+    children\n+}\n+\n+/**\n+ * A compiled Unix shell style pattern.\n+ */\n+#[deriving(Clone, Eq, TotalEq, Ord, TotalOrd, IterBytes, Zero)]\n+pub struct Pattern {\n+    priv tokens: ~[PatternToken]\n+}\n+\n+#[deriving(Clone, Eq, TotalEq, Ord, TotalOrd, IterBytes)]\n+enum PatternToken {\n+    Char(char),\n+    AnyChar,\n+    AnySequence,\n+    AnyWithin(~[char]),\n+    AnyExcept(~[char])\n+}\n+\n+#[deriving(Eq)]\n+enum MatchResult {\n+    Match,\n+    SubPatternDoesntMatch,\n+    EntirePatternDoesntMatch\n+}\n+\n+impl Pattern {\n+\n+    /**\n+     * This function compiles Unix shell style patterns: `?` matches any single character,\n+     * `*` matches any (possibly empty) sequence of characters and `[...]` matches any character\n+     * inside the brackets, unless the first character is `!` in which case it matches any\n+     * character except those between the `!` and the `]`.\n+     *\n+     * The metacharacters `?`, `*`, `[`, `]` can be matched by using brackets (e.g. `[?]`).\n+     * When a `]` occurs immediately following `[` or `[!` then it is interpreted as\n+     * being part of, rather then ending, the character set, so `]` and NOT `]` can be\n+     * matched by `[]]` and `[!]]` respectively.\n+     *\n+     * When a `[` does not have a closing `]` before the end of the string then the `[` will\n+     * be treated literally.\n+     */\n+    pub fn new(pattern: &str) -> Pattern {\n+\n+        let chars = pattern.iter().to_owned_vec();\n+        let mut tokens = ~[];\n+        let mut i = 0;\n+\n+        while i < chars.len() {\n+            match chars[i] {\n+                '?' => {\n+                    tokens.push(AnyChar);\n+                    i += 1;\n+                }\n+                '*' => {\n+                    // *, **, ***, ****, ... are all equivalent\n+                    while i < chars.len() && chars[i] == '*' {\n+                        i += 1;\n+                    }\n+                    tokens.push(AnySequence);\n+                }\n+                '[' => {\n+\n+                    if i <= chars.len() - 4 && chars[i + 1] == '!' {\n+                        match chars.slice_from(i + 3).position_elem(&']') {\n+                            None => (),\n+                            Some(j) => {\n+                                tokens.push(AnyExcept(chars.slice(i + 2, i + 3 + j).to_owned()));\n+                                i += j + 4;\n+                                loop;\n+                            }\n+                        }\n+                    }\n+                    else if i <= chars.len() - 3 && chars[i + 1] != '!' {\n+                        match chars.slice_from(i + 2).position_elem(&']') {\n+                            None => (),\n+                            Some(j) => {\n+                                tokens.push(AnyWithin(chars.slice(i + 1, i + 2 + j).to_owned()));\n+                                i += j + 3;\n+                                loop;\n+                            }\n+                        }\n+                    }\n+\n+                    // if we get here then this is not a valid range pattern\n+                    tokens.push(Char('['));\n+                    i += 1;\n+                }\n+                c => {\n+                    tokens.push(Char(c));\n+                    i += 1;\n+                }\n+            }\n+        }\n+\n+        Pattern { tokens: tokens }\n+    }\n+\n+    /**\n+     * Escape metacharacters within the given string by surrounding them in\n+     * brackets. The resulting string will, when compiled into a `Pattern`,\n+     * match the input string and nothing else.\n+     */\n+    pub fn escape(s: &str) -> ~str {\n+        let mut escaped = ~\"\";\n+        for c in s.iter() {\n+            match c {\n+                // note that ! does not need escaping because it is only special inside brackets\n+                '?' | '*' | '[' | ']' => {\n+                    escaped.push_char('[');\n+                    escaped.push_char(c);\n+                    escaped.push_char(']');\n+                }\n+                c => {\n+                    escaped.push_char(c);\n+                }\n+            }\n+        }\n+        escaped\n+    }\n+\n+    /**\n+     * Return if the given `str` matches this `Pattern` using the default\n+     * match options (i.e. `MatchOptions::new()`).\n+     *\n+     * # Example\n+     *\n+     * ~~~ {.rust}\n+     * assert!(Pattern::new(\"c?t\").matches(\"cat\"));\n+     * assert!(Pattern::new(\"k[!e]tteh\").matches(\"kitteh\"));\n+     * assert!(Pattern::new(\"d*g\").matches(\"doog\"));\n+     * ~~~\n+     */\n+    pub fn matches(&self, str: &str) -> bool {\n+        self.matches_with(str, MatchOptions::new())\n+    }\n+\n+    /**\n+     * Return if the given `Path`, when converted to a `str`, matches this `Pattern`\n+     * using the default match options (i.e. `MatchOptions::new()`).\n+     */\n+    pub fn matches_path(&self, path: &Path) -> bool {\n+        self.matches(path.to_str())\n+    }\n+\n+    /**\n+     * Return if the given `str` matches this `Pattern` using the specified match options.\n+     */\n+    pub fn matches_with(&self, str: &str, options: MatchOptions) -> bool {\n+        self.matches_from(None, str, 0, options) == Match\n+    }\n+\n+    /**\n+     * Return if the given `Path`, when converted to a `str`, matches this `Pattern`\n+     * using the specified match options.\n+     */\n+    pub fn matches_path_with(&self, path: &Path, options: MatchOptions) -> bool {\n+        self.matches_with(path.to_str(), options)\n+    }\n+\n+    fn matches_from(&self,\n+                    mut prev_char: Option<char>,\n+                    mut file: &str,\n+                    i: uint,\n+                    options: MatchOptions) -> MatchResult {\n+\n+        let require_literal = |c| {\n+            (options.require_literal_separator && is_sep(c)) ||\n+            (options.require_literal_leading_dot && c == '.'\n+             && is_sep(prev_char.unwrap_or_default('/')))\n+        };\n+\n+        for ti in range(i, self.tokens.len()) {\n+            match self.tokens[ti] {\n+                AnySequence => {\n+                    loop {\n+                        match self.matches_from(prev_char, file, ti + 1, options) {\n+                            SubPatternDoesntMatch => (), // keep trying\n+                            m => return m,\n+                        }\n+\n+                        if file.is_empty() {\n+                            return EntirePatternDoesntMatch;\n+                        }\n+\n+                        let (c, next) = file.slice_shift_char();\n+                        if require_literal(c) {\n+                            return SubPatternDoesntMatch;\n+                        }\n+                        prev_char = Some(c);\n+                        file = next;\n+                    }\n+                }\n+                _ => {\n+                    if file.is_empty() {\n+                        return EntirePatternDoesntMatch;\n+                    }\n+\n+                    let (c, next) = file.slice_shift_char();\n+                    let matches = match self.tokens[ti] {\n+                        AnyChar => {\n+                            !require_literal(c)\n+                        }\n+                        AnyWithin(ref chars) => {\n+                            !require_literal(c) &&\n+                            chars.iter()\n+                                .rposition(|&e| chars_eq(e, c, options.case_sensitive)).is_some()\n+                        }\n+                        AnyExcept(ref chars) => {\n+                            !require_literal(c) &&\n+                            chars.iter()\n+                                .rposition(|&e| chars_eq(e, c, options.case_sensitive)).is_none()\n+                        }\n+                        Char(c2) => {\n+                            chars_eq(c, c2, options.case_sensitive)\n+                        }\n+                        AnySequence => {\n+                            util::unreachable()\n+                        }\n+                    };\n+                    if !matches {\n+                        return SubPatternDoesntMatch;\n+                    }\n+                    prev_char = Some(c);\n+                    file = next;\n+                }\n+            }\n+        }\n+\n+        if file.is_empty() {\n+            Match\n+        } else {\n+            SubPatternDoesntMatch\n+        }\n+    }\n+\n+}\n+\n+/// A helper function to determine if two chars are (possibly case-insensitively) equal.\n+fn chars_eq(a: char, b: char, case_sensitive: bool) -> bool {\n+    if cfg!(windows) && path::windows::is_sep(a) && path::windows::is_sep(b) {\n+        true\n+    } else if !case_sensitive && a.is_ascii() && b.is_ascii() {\n+        // FIXME: work with non-ascii chars properly (issue #1347)\n+        a.to_ascii().eq_ignore_case(b.to_ascii())\n+    } else {\n+        a == b\n+    }\n+}\n+\n+/// A helper function to determine if a char is a path separator on the current platform.\n+fn is_sep(c: char) -> bool {\n+    if cfg!(windows) {\n+        path::windows::is_sep(c)\n+    } else {\n+        path::posix::is_sep(c)\n+    }\n+}\n+\n+/**\n+ * Configuration options to modify the behaviour of `Pattern::matches_with(..)`\n+ */\n+#[deriving(Clone, Eq, TotalEq, Ord, TotalOrd, IterBytes, Zero)]\n+pub struct MatchOptions {\n+\n+    /**\n+     * Whether or not patterns should be matched in a case-sensitive manner. This\n+     * currently only considers upper/lower case relationships between ASCII characters,\n+     * but in future this might be extended to work with Unicode.\n+     */\n+    case_sensitive: bool,\n+\n+    /**\n+     * If this is true then path-component separator characters (e.g. `/` on Posix)\n+     * must be matched by a literal `/`, rather than by `*` or `?` or `[...]`\n+     */\n+    require_literal_separator: bool,\n+\n+    /**\n+     * If this is true then paths that contain components that start with a `.` will\n+     * not match unless the `.` appears literally in the pattern: `*`, `?` or `[...]`\n+     * will not match. This is useful because such files are conventionally considered\n+     * hidden on Unix systems and it might be desirable to skip them when listing files.\n+     */\n+    require_literal_leading_dot: bool\n+}\n+\n+impl MatchOptions {\n+\n+    /**\n+     * Constructs a new `MatchOptions` with default field values. This is used\n+     * when calling functions that do not take an explicit `MatchOptions` parameter.\n+     *\n+     * This function always returns this value:\n+     *\n+     * ~~~ {.rust}\n+     * MatchOptions {\n+     *     case_sensitive: true,\n+     *     require_literal_separator: false.\n+     *     require_literal_leading_dot: false\n+     * }\n+     * ~~~\n+     */\n+    pub fn new() -> MatchOptions {\n+        MatchOptions {\n+            case_sensitive: true,\n+            require_literal_separator: false,\n+            require_literal_leading_dot: false\n+        }\n+    }\n+\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use std::{io, os, unstable};\n+    use super::*;\n+\n+    #[test]\n+    fn test_relative_pattern() {\n+\n+        fn mk_file(path: &str, directory: bool) {\n+            if directory {\n+                os::make_dir(&Path(path), 0xFFFF);\n+            } else {\n+                io::mk_file_writer(&Path(path), [io::Create]);\n+            }\n+        }\n+\n+        fn abs_path(path: &str) -> Path {\n+            os::getcwd().push_many(Path(path).components)\n+        }\n+\n+        fn glob_vec(pattern: &str) -> ~[Path] {\n+            glob(pattern).collect()\n+        }\n+\n+        mk_file(\"tmp\", true);\n+        mk_file(\"tmp/glob-tests\", true);\n+\n+        do unstable::change_dir_locked(&Path(\"tmp/glob-tests\")) {\n+\n+            mk_file(\"aaa\", true);\n+            mk_file(\"aaa/apple\", true);\n+            mk_file(\"aaa/orange\", true);\n+            mk_file(\"aaa/tomato\", true);\n+            mk_file(\"aaa/tomato/tomato.txt\", false);\n+            mk_file(\"aaa/tomato/tomoto.txt\", false);\n+            mk_file(\"bbb\", true);\n+            mk_file(\"bbb/specials\", true);\n+            mk_file(\"bbb/specials/!\", false);\n+\n+            // windows does not allow `*` or `?` characters to exist in filenames\n+            if os::consts::FAMILY != os::consts::windows::FAMILY {\n+                mk_file(\"bbb/specials/*\", false);\n+                mk_file(\"bbb/specials/?\", false);\n+            }\n+\n+            mk_file(\"bbb/specials/[\", false);\n+            mk_file(\"bbb/specials/]\", false);\n+            mk_file(\"ccc\", true);\n+            mk_file(\"xyz\", true);\n+            mk_file(\"xyz/x\", false);\n+            mk_file(\"xyz/y\", false);\n+            mk_file(\"xyz/z\", false);\n+\n+            assert_eq!(glob_vec(\"\"), ~[]);\n+            assert_eq!(glob_vec(\".\"), ~[]);\n+            assert_eq!(glob_vec(\"..\"), ~[]);\n+\n+            assert_eq!(glob_vec(\"aaa\"), ~[abs_path(\"aaa\")]);\n+            assert_eq!(glob_vec(\"aaa/\"), ~[abs_path(\"aaa\")]);\n+            assert_eq!(glob_vec(\"a\"), ~[]);\n+            assert_eq!(glob_vec(\"aa\"), ~[]);\n+            assert_eq!(glob_vec(\"aaaa\"), ~[]);\n+\n+            assert_eq!(glob_vec(\"aaa/apple\"), ~[abs_path(\"aaa/apple\")]);\n+            assert_eq!(glob_vec(\"aaa/apple/nope\"), ~[]);\n+\n+            // windows should support both / and \\ as directory separators\n+            if os::consts::FAMILY == os::consts::windows::FAMILY {\n+                assert_eq!(glob_vec(\"aaa\\\\apple\"), ~[abs_path(\"aaa/apple\")]);\n+            }\n+\n+            assert_eq!(glob_vec(\"???/\"), ~[\n+                abs_path(\"aaa\"),\n+                abs_path(\"bbb\"),\n+                abs_path(\"ccc\"),\n+                abs_path(\"xyz\")]);\n+\n+            assert_eq!(glob_vec(\"aaa/tomato/tom?to.txt\"), ~[\n+                abs_path(\"aaa/tomato/tomato.txt\"),\n+                abs_path(\"aaa/tomato/tomoto.txt\")]);\n+\n+            assert_eq!(glob_vec(\"xyz/?\"), ~[\n+                abs_path(\"xyz/x\"),\n+                abs_path(\"xyz/y\"),\n+                abs_path(\"xyz/z\")]);\n+\n+            assert_eq!(glob_vec(\"a*\"), ~[abs_path(\"aaa\")]);\n+            assert_eq!(glob_vec(\"*a*\"), ~[abs_path(\"aaa\")]);\n+            assert_eq!(glob_vec(\"a*a\"), ~[abs_path(\"aaa\")]);\n+            assert_eq!(glob_vec(\"aaa*\"), ~[abs_path(\"aaa\")]);\n+            assert_eq!(glob_vec(\"*aaa\"), ~[abs_path(\"aaa\")]);\n+            assert_eq!(glob_vec(\"*aaa*\"), ~[abs_path(\"aaa\")]);\n+            assert_eq!(glob_vec(\"*a*a*a*\"), ~[abs_path(\"aaa\")]);\n+            assert_eq!(glob_vec(\"aaa*/\"), ~[abs_path(\"aaa\")]);\n+\n+            assert_eq!(glob_vec(\"aaa/*\"), ~[\n+                abs_path(\"aaa/apple\"),\n+                abs_path(\"aaa/orange\"),\n+                abs_path(\"aaa/tomato\")]);\n+\n+            assert_eq!(glob_vec(\"aaa/*a*\"), ~[\n+                abs_path(\"aaa/apple\"),\n+                abs_path(\"aaa/orange\"),\n+                abs_path(\"aaa/tomato\")]);\n+\n+            assert_eq!(glob_vec(\"*/*/*.txt\"), ~[\n+                abs_path(\"aaa/tomato/tomato.txt\"),\n+                abs_path(\"aaa/tomato/tomoto.txt\")]);\n+\n+            assert_eq!(glob_vec(\"*/*/t[aob]m?to[.]t[!y]t\"), ~[\n+                abs_path(\"aaa/tomato/tomato.txt\"),\n+                abs_path(\"aaa/tomato/tomoto.txt\")]);\n+\n+            assert_eq!(glob_vec(\"aa[a]\"), ~[abs_path(\"aaa\")]);\n+            assert_eq!(glob_vec(\"aa[abc]\"), ~[abs_path(\"aaa\")]);\n+            assert_eq!(glob_vec(\"a[bca]a\"), ~[abs_path(\"aaa\")]);\n+            assert_eq!(glob_vec(\"aa[b]\"), ~[]);\n+            assert_eq!(glob_vec(\"aa[xyz]\"), ~[]);\n+            assert_eq!(glob_vec(\"aa[]]\"), ~[]);\n+\n+            assert_eq!(glob_vec(\"aa[!b]\"), ~[abs_path(\"aaa\")]);\n+            assert_eq!(glob_vec(\"aa[!bcd]\"), ~[abs_path(\"aaa\")]);\n+            assert_eq!(glob_vec(\"a[!bcd]a\"), ~[abs_path(\"aaa\")]);\n+            assert_eq!(glob_vec(\"aa[!a]\"), ~[]);\n+            assert_eq!(glob_vec(\"aa[!abc]\"), ~[]);\n+\n+            assert_eq!(glob_vec(\"bbb/specials/[[]\"), ~[abs_path(\"bbb/specials/[\")]);\n+            assert_eq!(glob_vec(\"bbb/specials/!\"), ~[abs_path(\"bbb/specials/!\")]);\n+            assert_eq!(glob_vec(\"bbb/specials/[]]\"), ~[abs_path(\"bbb/specials/]\")]);\n+\n+            if os::consts::FAMILY != os::consts::windows::FAMILY {\n+                assert_eq!(glob_vec(\"bbb/specials/[*]\"), ~[abs_path(\"bbb/specials/*\")]);\n+                assert_eq!(glob_vec(\"bbb/specials/[?]\"), ~[abs_path(\"bbb/specials/?\")]);\n+            }\n+\n+            if os::consts::FAMILY == os::consts::windows::FAMILY {\n+\n+                assert_eq!(glob_vec(\"bbb/specials/[![]\"), ~[\n+                    abs_path(\"bbb/specials/!\"),\n+                    abs_path(\"bbb/specials/]\")]);\n+\n+                assert_eq!(glob_vec(\"bbb/specials/[!]]\"), ~[\n+                    abs_path(\"bbb/specials/!\"),\n+                    abs_path(\"bbb/specials/[\")]);\n+\n+                assert_eq!(glob_vec(\"bbb/specials/[!!]\"), ~[\n+                    abs_path(\"bbb/specials/[\"),\n+                    abs_path(\"bbb/specials/]\")]);\n+\n+            } else {\n+\n+                assert_eq!(glob_vec(\"bbb/specials/[![]\"), ~[\n+                    abs_path(\"bbb/specials/!\"),\n+                    abs_path(\"bbb/specials/*\"),\n+                    abs_path(\"bbb/specials/?\"),\n+                    abs_path(\"bbb/specials/]\")]);\n+\n+                assert_eq!(glob_vec(\"bbb/specials/[!]]\"), ~[\n+                    abs_path(\"bbb/specials/!\"),\n+                    abs_path(\"bbb/specials/*\"),\n+                    abs_path(\"bbb/specials/?\"),\n+                    abs_path(\"bbb/specials/[\")]);\n+\n+                assert_eq!(glob_vec(\"bbb/specials/[!!]\"), ~[\n+                    abs_path(\"bbb/specials/*\"),\n+                    abs_path(\"bbb/specials/?\"),\n+                    abs_path(\"bbb/specials/[\"),\n+                    abs_path(\"bbb/specials/]\")]);\n+\n+                assert_eq!(glob_vec(\"bbb/specials/[!*]\"), ~[\n+                    abs_path(\"bbb/specials/!\"),\n+                    abs_path(\"bbb/specials/?\"),\n+                    abs_path(\"bbb/specials/[\"),\n+                    abs_path(\"bbb/specials/]\")]);\n+\n+                assert_eq!(glob_vec(\"bbb/specials/[!?]\"), ~[\n+                    abs_path(\"bbb/specials/!\"),\n+                    abs_path(\"bbb/specials/*\"),\n+                    abs_path(\"bbb/specials/[\"),\n+                    abs_path(\"bbb/specials/]\")]);\n+\n+            }\n+        };\n+    }\n+\n+    #[test]\n+    fn test_absolute_pattern() {\n+        // assume that the filesystem is not empty!\n+        assert!(glob(\"/*\").next().is_some());\n+        assert!(glob(\"//\").next().is_none());\n+\n+        // check windows absolute paths with host/device components\n+        let root_with_device = (Path {components: ~[], .. os::getcwd()}).to_str() + \"*\";\n+        assert!(glob(root_with_device).next().is_some());\n+    }\n+\n+    #[test]\n+    fn test_wildcard_optimizations() {\n+        assert!(Pattern::new(\"a*b\").matches(\"a___b\"));\n+        assert!(Pattern::new(\"a**b\").matches(\"a___b\"));\n+        assert!(Pattern::new(\"a***b\").matches(\"a___b\"));\n+        assert!(Pattern::new(\"a*b*c\").matches(\"abc\"));\n+        assert!(!Pattern::new(\"a*b*c\").matches(\"abcd\"));\n+        assert!(Pattern::new(\"a*b*c\").matches(\"a_b_c\"));\n+        assert!(Pattern::new(\"a*b*c\").matches(\"a___b___c\"));\n+        assert!(Pattern::new(\"abc*abc*abc\").matches(\"abcabcabcabcabcabcabc\"));\n+        assert!(!Pattern::new(\"abc*abc*abc\").matches(\"abcabcabcabcabcabcabca\"));\n+        assert!(Pattern::new(\"a*a*a*a*a*a*a*a*a\").matches(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n+        assert!(Pattern::new(\"a*b[xyz]c*d\").matches(\"abxcdbxcddd\"));\n+    }\n+\n+    #[test]\n+    fn test_lots_of_files() {\n+        // this is a good test because it touches lots of differently named files\n+        glob(\"/*/*/*/*\").skip(10000).next();\n+    }\n+\n+    #[test]\n+    fn test_unclosed_bracket() {\n+        // unclosed `[` should be treated literally\n+        assert!(Pattern::new(\"abc[def\").matches(\"abc[def\"));\n+        assert!(Pattern::new(\"abc[!def\").matches(\"abc[!def\"));\n+        assert!(Pattern::new(\"abc[\").matches(\"abc[\"));\n+        assert!(Pattern::new(\"abc[!\").matches(\"abc[!\"));\n+        assert!(Pattern::new(\"abc[d\").matches(\"abc[d\"));\n+        assert!(Pattern::new(\"abc[!d\").matches(\"abc[!d\"));\n+        assert!(Pattern::new(\"abc[]\").matches(\"abc[]\"));\n+        assert!(Pattern::new(\"abc[!]\").matches(\"abc[!]\"));\n+    }\n+\n+    #[test]\n+    fn test_pattern_matches() {\n+        let txt_pat = Pattern::new(\"*hello.txt\");\n+        assert!(txt_pat.matches(\"hello.txt\"));\n+        assert!(txt_pat.matches(\"gareth_says_hello.txt\"));\n+        assert!(txt_pat.matches(\"some/path/to/hello.txt\"));\n+        assert!(txt_pat.matches(\"some\\\\path\\\\to\\\\hello.txt\"));\n+        assert!(txt_pat.matches(\"/an/absolute/path/to/hello.txt\"));\n+        assert!(!txt_pat.matches(\"hello.txt-and-then-some\"));\n+        assert!(!txt_pat.matches(\"goodbye.txt\"));\n+\n+        let dir_pat = Pattern::new(\"*some/path/to/hello.txt\");\n+        assert!(dir_pat.matches(\"some/path/to/hello.txt\"));\n+        assert!(dir_pat.matches(\"a/bigger/some/path/to/hello.txt\"));\n+        assert!(!dir_pat.matches(\"some/path/to/hello.txt-and-then-some\"));\n+        assert!(!dir_pat.matches(\"some/other/path/to/hello.txt\"));\n+    }\n+\n+    #[test]\n+    fn test_pattern_escape() {\n+        let s = \"_[_]_?_*_!_\";\n+        assert_eq!(Pattern::escape(s), ~\"_[[]_[]]_[?]_[*]_!_\");\n+        assert!(Pattern::new(Pattern::escape(s)).matches(s));\n+    }\n+\n+    #[test]\n+    fn test_pattern_matches_case_insensitive() {\n+\n+        let pat = Pattern::new(\"aBcDeFg\");\n+        let options = MatchOptions {\n+            case_sensitive: false,\n+            require_literal_separator: false,\n+            require_literal_leading_dot: false\n+        };\n+\n+        assert!(pat.matches_with(\"aBcDeFg\", options));\n+        assert!(pat.matches_with(\"abcdefg\", options));\n+        assert!(pat.matches_with(\"ABCDEFG\", options));\n+        assert!(pat.matches_with(\"AbCdEfG\", options));\n+    }\n+\n+    #[test]\n+    fn test_pattern_matches_case_insensitive_range() {\n+\n+        let pat_within = Pattern::new(\"[a]\");\n+        let pat_except = Pattern::new(\"[!a]\");\n+\n+        let options_case_insensitive = MatchOptions {\n+            case_sensitive: false,\n+            require_literal_separator: false,\n+            require_literal_leading_dot: false\n+        };\n+        let options_case_sensitive = MatchOptions {\n+            case_sensitive: true,\n+            require_literal_separator: false,\n+            require_literal_leading_dot: false\n+        };\n+\n+        assert!(pat_within.matches_with(\"a\", options_case_insensitive));\n+        assert!(pat_within.matches_with(\"A\", options_case_insensitive));\n+        assert!(!pat_within.matches_with(\"A\", options_case_sensitive));\n+\n+        assert!(!pat_except.matches_with(\"a\", options_case_insensitive));\n+        assert!(!pat_except.matches_with(\"A\", options_case_insensitive));\n+        assert!(pat_except.matches_with(\"A\", options_case_sensitive));\n+    }\n+\n+    #[test]\n+    fn test_pattern_matches_require_literal_separator() {\n+\n+        let options_require_literal = MatchOptions {\n+            case_sensitive: true,\n+            require_literal_separator: true,\n+            require_literal_leading_dot: false\n+        };\n+        let options_not_require_literal = MatchOptions {\n+            case_sensitive: true,\n+            require_literal_separator: false,\n+            require_literal_leading_dot: false\n+        };\n+\n+        assert!(Pattern::new(\"abc/def\").matches_with(\"abc/def\", options_require_literal));\n+        assert!(!Pattern::new(\"abc?def\").matches_with(\"abc/def\", options_require_literal));\n+        assert!(!Pattern::new(\"abc*def\").matches_with(\"abc/def\", options_require_literal));\n+        assert!(!Pattern::new(\"abc[/]def\").matches_with(\"abc/def\", options_require_literal));\n+\n+        assert!(Pattern::new(\"abc/def\").matches_with(\"abc/def\", options_not_require_literal));\n+        assert!(Pattern::new(\"abc?def\").matches_with(\"abc/def\", options_not_require_literal));\n+        assert!(Pattern::new(\"abc*def\").matches_with(\"abc/def\", options_not_require_literal));\n+        assert!(Pattern::new(\"abc[/]def\").matches_with(\"abc/def\", options_not_require_literal));\n+    }\n+\n+    #[test]\n+    fn test_pattern_matches_require_literal_leading_dot() {\n+\n+        let options_require_literal_leading_dot = MatchOptions {\n+            case_sensitive: true,\n+            require_literal_separator: false,\n+            require_literal_leading_dot: true\n+        };\n+        let options_not_require_literal_leading_dot = MatchOptions {\n+            case_sensitive: true,\n+            require_literal_separator: false,\n+            require_literal_leading_dot: false\n+        };\n+\n+        let f = |options| Pattern::new(\"*.txt\").matches_with(\".hello.txt\", options);\n+        assert!(f(options_not_require_literal_leading_dot));\n+        assert!(!f(options_require_literal_leading_dot));\n+\n+        let f = |options| Pattern::new(\".*.*\").matches_with(\".hello.txt\", options);\n+        assert!(f(options_not_require_literal_leading_dot));\n+        assert!(f(options_require_literal_leading_dot));\n+\n+        let f = |options| Pattern::new(\"aaa/bbb/*\").matches_with(\"aaa/bbb/.ccc\", options);\n+        assert!(f(options_not_require_literal_leading_dot));\n+        assert!(!f(options_require_literal_leading_dot));\n+\n+        let f = |options| Pattern::new(\"aaa/bbb/*\").matches_with(\"aaa/bbb/c.c.c.\", options);\n+        assert!(f(options_not_require_literal_leading_dot));\n+        assert!(f(options_require_literal_leading_dot));\n+\n+        let f = |options| Pattern::new(\"aaa/bbb/.*\").matches_with(\"aaa/bbb/.ccc\", options);\n+        assert!(f(options_not_require_literal_leading_dot));\n+        assert!(f(options_require_literal_leading_dot));\n+\n+        let f = |options| Pattern::new(\"aaa/?bbb\").matches_with(\"aaa/.bbb\", options);\n+        assert!(f(options_not_require_literal_leading_dot));\n+        assert!(!f(options_require_literal_leading_dot));\n+\n+        let f = |options| Pattern::new(\"aaa/[.]bbb\").matches_with(\"aaa/.bbb\", options);\n+        assert!(f(options_not_require_literal_leading_dot));\n+        assert!(!f(options_require_literal_leading_dot));\n+    }\n+\n+    #[test]\n+    fn test_matches_path() {\n+        // on windows, (Path(\"a/b\").to_str() == \"a\\\\b\"), so this\n+        // tests that / and \\ are considered equivalent on windows\n+        assert!(Pattern::new(\"a/b\").matches_path(&Path(\"a/b\")));\n+    }\n+}\n+"}, {"sha": "ffd99fc9f75ca7dd44c34685acac95033acaa537", "filename": "src/libstd/os.rs", "status": "modified", "additions": 0, "deletions": 84, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/193a1c8af6a0ceef734fff9acc07231c67896bb1/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/193a1c8af6a0ceef734fff9acc07231c67896bb1/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=193a1c8af6a0ceef734fff9acc07231c67896bb1", "patch": "@@ -1318,90 +1318,6 @@ pub fn args() -> ~[~str] {\n     real_args()\n }\n \n-// FIXME #6100 we should really use an internal implementation of this - using\n-// the POSIX glob functions isn't portable to windows, probably has slight\n-// inconsistencies even where it is implemented, and makes extending\n-// functionality a lot more difficult\n-// FIXME #6101 also provide a non-allocating version - each_glob or so?\n-/// Returns a vector of Path objects that match the given glob pattern\n-#[cfg(target_os = \"linux\")]\n-#[cfg(target_os = \"android\")]\n-#[cfg(target_os = \"freebsd\")]\n-#[cfg(target_os = \"macos\")]\n-pub fn glob(pattern: &str) -> ~[Path] {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    #[cfg(target_os = \"linux\")]\n-    #[cfg(target_os = \"android\")]\n-    fn default_glob_t () -> libc::glob_t {\n-        libc::glob_t {\n-            gl_pathc: 0,\n-            gl_pathv: ptr::null(),\n-            gl_offs: 0,\n-            __unused1: ptr::null(),\n-            __unused2: ptr::null(),\n-            __unused3: ptr::null(),\n-            __unused4: ptr::null(),\n-            __unused5: ptr::null(),\n-        }\n-    }\n-\n-    #[cfg(target_os = \"freebsd\")]\n-    fn default_glob_t () -> libc::glob_t {\n-        libc::glob_t {\n-            gl_pathc: 0,\n-            __unused1: 0,\n-            gl_offs: 0,\n-            __unused2: 0,\n-            gl_pathv: ptr::null(),\n-            __unused3: ptr::null(),\n-            __unused4: ptr::null(),\n-            __unused5: ptr::null(),\n-            __unused6: ptr::null(),\n-            __unused7: ptr::null(),\n-            __unused8: ptr::null(),\n-        }\n-    }\n-\n-    #[cfg(target_os = \"macos\")]\n-    fn default_glob_t () -> libc::glob_t {\n-        libc::glob_t {\n-            gl_pathc: 0,\n-            __unused1: 0,\n-            gl_offs: 0,\n-            __unused2: 0,\n-            gl_pathv: ptr::null(),\n-            __unused3: ptr::null(),\n-            __unused4: ptr::null(),\n-            __unused5: ptr::null(),\n-            __unused6: ptr::null(),\n-            __unused7: ptr::null(),\n-            __unused8: ptr::null(),\n-        }\n-    }\n-\n-    let mut g = default_glob_t();\n-    do pattern.with_c_str |c_pattern| {\n-        unsafe { libc::glob(c_pattern, 0, ptr::null(), &mut g) }\n-    };\n-    do(|| {\n-        let paths = unsafe {\n-            vec::raw::from_buf_raw(g.gl_pathv, g.gl_pathc as uint)\n-        };\n-        do paths.map |&c_str| {\n-            Path(unsafe { str::raw::from_c_str(c_str) })\n-        }\n-    }).finally {\n-        unsafe { libc::globfree(&mut g) };\n-    }\n-}\n-\n-/// Returns a vector of Path objects that match the given glob pattern\n-#[cfg(target_os = \"win32\")]\n-pub fn glob(_pattern: &str) -> ~[Path] {\n-    fail!(\"glob() is unimplemented on Windows\")\n-}\n-\n #[cfg(target_os = \"macos\")]\n extern {\n     // These functions are in crt_externs.h."}]}