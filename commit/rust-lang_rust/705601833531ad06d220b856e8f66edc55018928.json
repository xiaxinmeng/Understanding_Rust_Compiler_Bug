{"sha": "705601833531ad06d220b856e8f66edc55018928", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwNTYwMTgzMzUzMWFkMDZkMjIwYjg1NmU4ZjY2ZWRjNTUwMTg5Mjg=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-06-13T09:30:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-06-13T09:30:52Z"}, "message": "Merge pull request #1501 from scott-linder/types-borrow-box\n\nTypes borrow box", "tree": {"sha": "dec8b9d8b6196fd9b664b45e66f123e52b365d29", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dec8b9d8b6196fd9b664b45e66f123e52b365d29"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/705601833531ad06d220b856e8f66edc55018928", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/705601833531ad06d220b856e8f66edc55018928", "html_url": "https://github.com/rust-lang/rust/commit/705601833531ad06d220b856e8f66edc55018928", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/705601833531ad06d220b856e8f66edc55018928/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92fac4ac1aa9f14e327d8959955517c0fd431cab", "url": "https://api.github.com/repos/rust-lang/rust/commits/92fac4ac1aa9f14e327d8959955517c0fd431cab", "html_url": "https://github.com/rust-lang/rust/commit/92fac4ac1aa9f14e327d8959955517c0fd431cab"}, {"sha": "5db8647c5e32bc93255d1edea279eec9b1c29c62", "url": "https://api.github.com/repos/rust-lang/rust/commits/5db8647c5e32bc93255d1edea279eec9b1c29c62", "html_url": "https://github.com/rust-lang/rust/commit/5db8647c5e32bc93255d1edea279eec9b1c29c62"}], "stats": {"total": 179, "additions": 163, "deletions": 16}, "files": [{"sha": "d2b5f6f2fe7c3dbe7c2dd2e4f33be82ef70e2e43", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/705601833531ad06d220b856e8f66edc55018928/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/705601833531ad06d220b856e8f66edc55018928/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=705601833531ad06d220b856e8f66edc55018928", "patch": "@@ -364,6 +364,7 @@ All notable changes to this project will be documented in this file.\n [`block_in_if_condition_expr`]: https://github.com/Manishearth/rust-clippy/wiki#block_in_if_condition_expr\n [`block_in_if_condition_stmt`]: https://github.com/Manishearth/rust-clippy/wiki#block_in_if_condition_stmt\n [`bool_comparison`]: https://github.com/Manishearth/rust-clippy/wiki#bool_comparison\n+[`borrowed_box`]: https://github.com/Manishearth/rust-clippy/wiki#borrowed_box\n [`box_vec`]: https://github.com/Manishearth/rust-clippy/wiki#box_vec\n [`boxed_local`]: https://github.com/Manishearth/rust-clippy/wiki#boxed_local\n [`builtin_type_shadow`]: https://github.com/Manishearth/rust-clippy/wiki#builtin_type_shadow"}, {"sha": "28dffcbea9411a00be6e0bd95ec27a16849f23ae", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/705601833531ad06d220b856e8f66edc55018928/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/705601833531ad06d220b856e8f66edc55018928/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=705601833531ad06d220b856e8f66edc55018928", "patch": "@@ -194,6 +194,7 @@ name\n [block_in_if_condition_expr](https://github.com/Manishearth/rust-clippy/wiki#block_in_if_condition_expr)               | warn    | braces that can be eliminated in conditions, e.g. `if { true } ...`\n [block_in_if_condition_stmt](https://github.com/Manishearth/rust-clippy/wiki#block_in_if_condition_stmt)               | warn    | complex blocks in conditions, e.g. `if { let x = true; x } ...`\n [bool_comparison](https://github.com/Manishearth/rust-clippy/wiki#bool_comparison)                                     | warn    | comparing a variable to a boolean, e.g. `if x == true`\n+[borrowed_box](https://github.com/Manishearth/rust-clippy/wiki#borrowed_box)                                           | warn    | a borrow of a boxed type\n [box_vec](https://github.com/Manishearth/rust-clippy/wiki#box_vec)                                                     | warn    | usage of `Box<Vec<T>>`, vector elements are already on the heap\n [boxed_local](https://github.com/Manishearth/rust-clippy/wiki#boxed_local)                                             | warn    | using `Box<T>` where unnecessary\n [builtin_type_shadow](https://github.com/Manishearth/rust-clippy/wiki#builtin_type_shadow)                             | warn    | shadowing a builtin type"}, {"sha": "c91492c4c4b276ecfe3bd47311ddcf26e263cef8", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/705601833531ad06d220b856e8f66edc55018928/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705601833531ad06d220b856e8f66edc55018928/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=705601833531ad06d220b856e8f66edc55018928", "patch": "@@ -506,6 +506,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         transmute::USELESS_TRANSMUTE,\n         transmute::WRONG_TRANSMUTE,\n         types::ABSURD_EXTREME_COMPARISONS,\n+        types::BORROWED_BOX,\n         types::BOX_VEC,\n         types::CHAR_LIT_AS_U8,\n         types::LET_UNIT_VALUE,"}, {"sha": "0204bfff0d4362928339244b2193ab86cc05d992", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 81, "deletions": 16, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/705601833531ad06d220b856e8f66edc55018928/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705601833531ad06d220b856e8f66edc55018928/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=705601833531ad06d220b856e8f66edc55018928", "patch": "@@ -8,7 +8,7 @@ use std::cmp::Ordering;\n use syntax::ast::{IntTy, UintTy, FloatTy};\n use syntax::attr::IntType;\n use syntax::codemap::Span;\n-use utils::{comparisons, higher, in_external_macro, in_macro, match_def_path, snippet, span_help_and_lint, span_lint,\n+use utils::{comparisons, higher, in_external_macro, in_macro, match_def_path, snippet, span_help_and_lint, span_lint, span_lint_and_then,\n             opt_def_id, last_path_segment, type_size};\n use utils::paths;\n \n@@ -65,9 +65,25 @@ declare_lint! {\n      structure like a VecDeque\"\n }\n \n+/// **What it does:** Checks for use of `&Box<T>` anywhere in the code.\n+///\n+/// **Why is this bad?** Any `&Box<T>` can also be a `&T`, which is more general.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// fn foo(bar: &Box<T>) { ... }\n+/// ```\n+declare_lint! {\n+    pub BORROWED_BOX,\n+    Warn,\n+    \"a borrow of a boxed type\"\n+}\n+\n impl LintPass for TypePass {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(BOX_VEC, LINKEDLIST)\n+        lint_array!(BOX_VEC, LINKEDLIST, BORROWED_BOX)\n     }\n }\n \n@@ -84,35 +100,46 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypePass {\n     }\n \n     fn check_struct_field(&mut self, cx: &LateContext, field: &StructField) {\n-        check_ty(cx, &field.ty);\n+        check_ty(cx, &field.ty, false);\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext, item: &TraitItem) {\n         match item.node {\n             TraitItemKind::Const(ref ty, _) |\n-            TraitItemKind::Type(_, Some(ref ty)) => check_ty(cx, ty),\n+            TraitItemKind::Type(_, Some(ref ty)) => check_ty(cx, ty, false),\n             TraitItemKind::Method(ref sig, _) => check_fn_decl(cx, &sig.decl),\n             _ => (),\n         }\n     }\n+\n+    fn check_local(&mut self, cx: &LateContext, local: &Local) {\n+        if let Some(ref ty) = local.ty {\n+            check_ty(cx, ty, true);\n+        }\n+    }\n }\n \n fn check_fn_decl(cx: &LateContext, decl: &FnDecl) {\n     for input in &decl.inputs {\n-        check_ty(cx, input);\n+        check_ty(cx, input, false);\n     }\n \n     if let FunctionRetTy::Return(ref ty) = decl.output {\n-        check_ty(cx, ty);\n+        check_ty(cx, ty, false);\n     }\n }\n \n-fn check_ty(cx: &LateContext, ast_ty: &hir::Ty) {\n+/// Recursively check for `TypePass` lints in the given type. Stop at the first\n+/// lint found.\n+///\n+/// The parameter `is_local` distinguishes the context of the type; types from\n+/// local bindings should only be checked for the `BORROWED_BOX` lint.\n+fn check_ty(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool) {\n     if in_macro(ast_ty.span) {\n         return;\n     }\n     match ast_ty.node {\n-        TyPath(ref qpath) => {\n+        TyPath(ref qpath) if !is_local => {\n             let def = cx.tables.qpath_def(qpath, ast_ty.id);\n             if let Some(def_id) = opt_def_id(def) {\n                 if Some(def_id) == cx.tcx.lang_items.owned_box() {\n@@ -143,32 +170,70 @@ fn check_ty(cx: &LateContext, ast_ty: &hir::Ty) {\n             }\n             match *qpath {\n                 QPath::Resolved(Some(ref ty), ref p) => {\n-                    check_ty(cx, ty);\n+                    check_ty(cx, ty, is_local);\n                     for ty in p.segments.iter().flat_map(|seg| seg.parameters.types()) {\n-                        check_ty(cx, ty);\n+                        check_ty(cx, ty, is_local);\n                     }\n                 },\n                 QPath::Resolved(None, ref p) => {\n                     for ty in p.segments.iter().flat_map(|seg| seg.parameters.types()) {\n-                        check_ty(cx, ty);\n+                        check_ty(cx, ty, is_local);\n                     }\n                 },\n                 QPath::TypeRelative(ref ty, ref seg) => {\n-                    check_ty(cx, ty);\n+                    check_ty(cx, ty, is_local);\n                     for ty in seg.parameters.types() {\n-                        check_ty(cx, ty);\n+                        check_ty(cx, ty, is_local);\n                     }\n                 },\n             }\n         },\n+        TyRptr(ref lt, MutTy { ref ty, ref mutbl }) => {\n+            match ty.node {\n+                TyPath(ref qpath) => {\n+                    let def = cx.tables.qpath_def(qpath, ast_ty.id);\n+                    if_let_chain! {[\n+                        let Some(def_id) = opt_def_id(def),\n+                        Some(def_id) == cx.tcx.lang_items.owned_box(),\n+                        let QPath::Resolved(None, ref path) = *qpath,\n+                        let [ref bx] = *path.segments,\n+                        let PathParameters::AngleBracketedParameters(ref ab_data) = bx.parameters,\n+                        let [ref inner] = *ab_data.types\n+                    ], {\n+                        let ltopt = if lt.is_elided() {\n+                            \"\".to_owned()\n+                        } else {\n+                            format!(\"{} \", lt.name.as_str())\n+                        };\n+                        let mutopt = if *mutbl == Mutability::MutMutable {\n+                            \"mut \"\n+                        } else {\n+                            \"\"\n+                        };\n+                        span_lint_and_then(cx,\n+                            BORROWED_BOX,\n+                            ast_ty.span,\n+                            \"you seem to be trying to use `&Box<T>`. Consider using just `&T`\",\n+                            |db| {\n+                                db.span_suggestion(ast_ty.span,\n+                                    \"try\",\n+                                    format!(\"&{}{}{}\", ltopt, mutopt, &snippet(cx, inner.span, \"..\")));\n+                            }\n+                        );\n+                        return; // don't recurse into the type\n+                    }};\n+                    check_ty(cx, ty, is_local);\n+                },\n+                _ => check_ty(cx, ty, is_local),\n+            }\n+        },\n         // recurse\n         TySlice(ref ty) |\n         TyArray(ref ty, _) |\n-        TyPtr(MutTy { ref ty, .. }) |\n-        TyRptr(_, MutTy { ref ty, .. }) => check_ty(cx, ty),\n+        TyPtr(MutTy { ref ty, .. }) => check_ty(cx, ty, is_local),\n         TyTup(ref tys) => {\n             for ty in tys {\n-                check_ty(cx, ty);\n+                check_ty(cx, ty, is_local);\n             }\n         },\n         _ => {},"}, {"sha": "ef569ab037ffd0b06433be81a70a4b3d4c4880b9", "filename": "clippy_tests/examples/borrow_box.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/705601833531ad06d220b856e8f66edc55018928/clippy_tests%2Fexamples%2Fborrow_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705601833531ad06d220b856e8f66edc55018928/clippy_tests%2Fexamples%2Fborrow_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_tests%2Fexamples%2Fborrow_box.rs?ref=705601833531ad06d220b856e8f66edc55018928", "patch": "@@ -0,0 +1,34 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+\n+#![deny(borrowed_box)]\n+#![allow(blacklisted_name)]\n+#![allow(unused_variables)]\n+#![allow(dead_code)]\n+\n+pub fn test1(foo: &mut Box<bool>) {\n+    println!(\"{:?}\", foo)\n+}\n+\n+pub fn test2() {\n+    let foo: &Box<bool>;\n+}\n+\n+struct Test3<'a> {\n+    foo: &'a Box<bool>\n+}\n+\n+trait Test4 {\n+    fn test4(a: &Box<bool>);\n+}\n+\n+impl<'a> Test4 for Test3<'a> {\n+    fn test4(a: &Box<bool>) {\n+        unimplemented!();\n+    }\n+}\n+\n+fn main(){\n+    test1(&mut Box::new(false));\n+    test2();\n+}"}, {"sha": "6670a8c40835c4a330b8b9c890dc9c71eeb3495a", "filename": "clippy_tests/examples/borrow_box.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/705601833531ad06d220b856e8f66edc55018928/clippy_tests%2Fexamples%2Fborrow_box.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/705601833531ad06d220b856e8f66edc55018928/clippy_tests%2Fexamples%2Fborrow_box.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_tests%2Fexamples%2Fborrow_box.stderr?ref=705601833531ad06d220b856e8f66edc55018928", "patch": "@@ -0,0 +1,35 @@\n+error: you seem to be trying to use `&Box<T>`. Consider using just `&T`\n+ --> borrow_box.rs:9:19\n+  |\n+9 | pub fn test1(foo: &mut Box<bool>) {\n+  |                   ^^^^^^^^^^^^^^ help: try `&mut bool`\n+  |\n+note: lint level defined here\n+ --> borrow_box.rs:4:9\n+  |\n+4 | #![deny(borrowed_box)]\n+  |         ^^^^^^^^^^^^\n+\n+error: you seem to be trying to use `&Box<T>`. Consider using just `&T`\n+  --> borrow_box.rs:14:14\n+   |\n+14 |     let foo: &Box<bool>;\n+   |              ^^^^^^^^^^ help: try `&bool`\n+\n+error: you seem to be trying to use `&Box<T>`. Consider using just `&T`\n+  --> borrow_box.rs:18:10\n+   |\n+18 |     foo: &'a Box<bool>\n+   |          ^^^^^^^^^^^^^ help: try `&'a bool`\n+\n+error: you seem to be trying to use `&Box<T>`. Consider using just `&T`\n+  --> borrow_box.rs:22:17\n+   |\n+22 |     fn test4(a: &Box<bool>);\n+   |                 ^^^^^^^^^^ help: try `&bool`\n+\n+error: aborting due to previous error(s)\n+\n+error: Could not compile `clippy_tests`.\n+\n+To learn more, run the command again with --verbose."}, {"sha": "f8c5a80c59dec3be92348ddbe4f727ddaaa02550", "filename": "clippy_tests/examples/box_vec.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/705601833531ad06d220b856e8f66edc55018928/clippy_tests%2Fexamples%2Fbox_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705601833531ad06d220b856e8f66edc55018928/clippy_tests%2Fexamples%2Fbox_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_tests%2Fexamples%2Fbox_vec.rs?ref=705601833531ad06d220b856e8f66edc55018928", "patch": "@@ -22,8 +22,13 @@ pub fn test2(foo: Box<Fn(Vec<u32>)>) { // pass if #31 is fixed\n     foo(vec![1, 2, 3])\n }\n \n+pub fn test_local_not_linted() {\n+    let _: Box<Vec<bool>>;\n+}\n+\n fn main(){\n     test(Box::new(Vec::new()));\n     test2(Box::new(|v| println!(\"{:?}\", v)));\n     test_macro();\n+    test_local_not_linted();\n }"}, {"sha": "b23aeb70a63376dbbae181d6c7ae27fd4dc75f67", "filename": "clippy_tests/examples/dlist.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/705601833531ad06d220b856e8f66edc55018928/clippy_tests%2Fexamples%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705601833531ad06d220b856e8f66edc55018928/clippy_tests%2Fexamples%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_tests%2Fexamples%2Fdlist.rs?ref=705601833531ad06d220b856e8f66edc55018928", "patch": "@@ -34,6 +34,11 @@ pub fn test_ret() -> Option<LinkedList<u8>> {\n     unimplemented!();\n }\n \n+pub fn test_local_not_linted() {\n+    let _: LinkedList<u8>;\n+}\n+\n fn main(){\n     test(LinkedList::new());\n+    test_local_not_linted();\n }"}]}