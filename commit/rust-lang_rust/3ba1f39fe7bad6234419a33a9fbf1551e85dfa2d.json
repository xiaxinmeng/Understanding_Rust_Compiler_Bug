{"sha": "3ba1f39fe7bad6234419a33a9fbf1551e85dfa2d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiYTFmMzlmZTdiYWQ2MjM0NDE5YTMzYTlmYmYxNTUxZTg1ZGZhMmQ=", "commit": {"author": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2019-06-26T22:03:15Z"}, "committer": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2019-06-26T22:03:15Z"}, "message": "Avoid mem::uninitialized() in std::sys::unix\n\nFor `libc` types that will be initialized in FFI calls, we can just use\n`MaybeUninit` and then pass around raw pointers.\n\nFor `sun_path_offset()`, which really wants `offset_of`, all callers\nhave a real `sockaddr_un` available, so we can use that reference.", "tree": {"sha": "23f38acff08ac7fe85e7e61b84ea7c01f0e7c79a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23f38acff08ac7fe85e7e61b84ea7c01f0e7c79a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ba1f39fe7bad6234419a33a9fbf1551e85dfa2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ba1f39fe7bad6234419a33a9fbf1551e85dfa2d", "html_url": "https://github.com/rust-lang/rust/commit/3ba1f39fe7bad6234419a33a9fbf1551e85dfa2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ba1f39fe7bad6234419a33a9fbf1551e85dfa2d/comments", "author": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "html_url": "https://github.com/rust-lang/rust/commit/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf"}], "stats": {"total": 115, "additions": 57, "deletions": 58}, "files": [{"sha": "4201de794b70835406a05713122b0816d5e584ea", "filename": "src/libstd/sys/unix/condvar.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3ba1f39fe7bad6234419a33a9fbf1551e85dfa2d/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ba1f39fe7bad6234419a33a9fbf1551e85dfa2d/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs?ref=3ba1f39fe7bad6234419a33a9fbf1551e85dfa2d", "patch": "@@ -40,15 +40,15 @@ impl Condvar {\n                   target_os = \"android\",\n                   target_os = \"hermit\")))]\n     pub unsafe fn init(&mut self) {\n-        use crate::mem;\n-        let mut attr: libc::pthread_condattr_t = mem::uninitialized();\n-        let r = libc::pthread_condattr_init(&mut attr);\n+        use crate::mem::MaybeUninit;\n+        let mut attr = MaybeUninit::<libc::pthread_condattr_t>::uninit();\n+        let r = libc::pthread_condattr_init(attr.as_mut_ptr());\n         assert_eq!(r, 0);\n-        let r = libc::pthread_condattr_setclock(&mut attr, libc::CLOCK_MONOTONIC);\n+        let r = libc::pthread_condattr_setclock(attr.as_mut_ptr(), libc::CLOCK_MONOTONIC);\n         assert_eq!(r, 0);\n-        let r = libc::pthread_cond_init(self.inner.get(), &attr);\n+        let r = libc::pthread_cond_init(self.inner.get(), attr.as_ptr());\n         assert_eq!(r, 0);\n-        let r = libc::pthread_condattr_destroy(&mut attr);\n+        let r = libc::pthread_condattr_destroy(attr.as_mut_ptr());\n         assert_eq!(r, 0);\n     }\n "}, {"sha": "41090caee8459fea5e08e6ad9054379d9da08da3", "filename": "src/libstd/sys/unix/ext/net.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3ba1f39fe7bad6234419a33a9fbf1551e85dfa2d/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ba1f39fe7bad6234419a33a9fbf1551e85dfa2d/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs?ref=3ba1f39fe7bad6234419a33a9fbf1551e85dfa2d", "patch": "@@ -40,10 +40,9 @@ use libc::MSG_NOSIGNAL;\n               target_os = \"haiku\")))]\n const MSG_NOSIGNAL: libc::c_int = 0x0;\n \n-fn sun_path_offset() -> usize {\n+fn sun_path_offset(addr: &libc::sockaddr_un) -> usize {\n     // Work with an actual instance of the type since using a null pointer is UB\n-    let addr: libc::sockaddr_un = unsafe { mem::uninitialized() };\n-    let base = &addr as *const _ as usize;\n+    let base = addr as *const _ as usize;\n     let path = &addr.sun_path as *const _ as usize;\n     path - base\n }\n@@ -69,7 +68,7 @@ unsafe fn sockaddr_un(path: &Path) -> io::Result<(libc::sockaddr_un, libc::sockl\n     // null byte for pathname addresses is already there because we zeroed the\n     // struct\n \n-    let mut len = sun_path_offset() + bytes.len();\n+    let mut len = sun_path_offset(&addr) + bytes.len();\n     match bytes.get(0) {\n         Some(&0) | None => {}\n         Some(_) => len += 1,\n@@ -122,7 +121,7 @@ impl SocketAddr {\n         if len == 0 {\n             // When there is a datagram from unnamed unix socket\n             // linux returns zero bytes of address\n-            len = sun_path_offset() as libc::socklen_t;  // i.e., zero-length address\n+            len = sun_path_offset(&addr) as libc::socklen_t;  // i.e., zero-length address\n         } else if addr.sun_family != libc::AF_UNIX as libc::sa_family_t {\n             return Err(io::Error::new(io::ErrorKind::InvalidInput,\n                                       \"file descriptor did not correspond to a Unix socket\"));\n@@ -200,7 +199,7 @@ impl SocketAddr {\n     }\n \n     fn address<'a>(&'a self) -> AddressKind<'a> {\n-        let len = self.len as usize - sun_path_offset();\n+        let len = self.len as usize - sun_path_offset(&self.addr);\n         let path = unsafe { mem::transmute::<&[libc::c_char], &[u8]>(&self.addr.sun_path) };\n \n         // macOS seems to return a len of 16 and a zeroed sun_path for unnamed addresses"}, {"sha": "b43af8fdcaaa12ed392c2b3679464772a53104e6", "filename": "src/libstd/sys/unix/mutex.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3ba1f39fe7bad6234419a33a9fbf1551e85dfa2d/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ba1f39fe7bad6234419a33a9fbf1551e85dfa2d/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs?ref=3ba1f39fe7bad6234419a33a9fbf1551e85dfa2d", "patch": "@@ -1,5 +1,5 @@\n use crate::cell::UnsafeCell;\n-use crate::mem;\n+use crate::mem::MaybeUninit;\n \n pub struct Mutex { inner: UnsafeCell<libc::pthread_mutex_t> }\n \n@@ -40,14 +40,14 @@ impl Mutex {\n         // references, we instead create the mutex with type\n         // PTHREAD_MUTEX_NORMAL which is guaranteed to deadlock if we try to\n         // re-lock it from the same thread, thus avoiding undefined behavior.\n-        let mut attr: libc::pthread_mutexattr_t = mem::uninitialized();\n-        let r = libc::pthread_mutexattr_init(&mut attr);\n+        let mut attr = MaybeUninit::<libc::pthread_mutexattr_t>::uninit();\n+        let r = libc::pthread_mutexattr_init(attr.as_mut_ptr());\n         debug_assert_eq!(r, 0);\n-        let r = libc::pthread_mutexattr_settype(&mut attr, libc::PTHREAD_MUTEX_NORMAL);\n+        let r = libc::pthread_mutexattr_settype(attr.as_mut_ptr(), libc::PTHREAD_MUTEX_NORMAL);\n         debug_assert_eq!(r, 0);\n-        let r = libc::pthread_mutex_init(self.inner.get(), &attr);\n+        let r = libc::pthread_mutex_init(self.inner.get(), attr.as_ptr());\n         debug_assert_eq!(r, 0);\n-        let r = libc::pthread_mutexattr_destroy(&mut attr);\n+        let r = libc::pthread_mutexattr_destroy(attr.as_mut_ptr());\n         debug_assert_eq!(r, 0);\n     }\n     #[inline]\n@@ -89,19 +89,19 @@ unsafe impl Sync for ReentrantMutex {}\n \n impl ReentrantMutex {\n     pub unsafe fn uninitialized() -> ReentrantMutex {\n-        ReentrantMutex { inner: mem::uninitialized() }\n+        ReentrantMutex { inner: UnsafeCell::new(libc::PTHREAD_MUTEX_INITIALIZER) }\n     }\n \n     pub unsafe fn init(&mut self) {\n-        let mut attr: libc::pthread_mutexattr_t = mem::uninitialized();\n-        let result = libc::pthread_mutexattr_init(&mut attr as *mut _);\n+        let mut attr = MaybeUninit::<libc::pthread_mutexattr_t>::uninit();\n+        let result = libc::pthread_mutexattr_init(attr.as_mut_ptr());\n         debug_assert_eq!(result, 0);\n-        let result = libc::pthread_mutexattr_settype(&mut attr as *mut _,\n+        let result = libc::pthread_mutexattr_settype(attr.as_mut_ptr(),\n                                                     libc::PTHREAD_MUTEX_RECURSIVE);\n         debug_assert_eq!(result, 0);\n-        let result = libc::pthread_mutex_init(self.inner.get(), &attr as *const _);\n+        let result = libc::pthread_mutex_init(self.inner.get(), attr.as_ptr());\n         debug_assert_eq!(result, 0);\n-        let result = libc::pthread_mutexattr_destroy(&mut attr as *mut _);\n+        let result = libc::pthread_mutexattr_destroy(attr.as_mut_ptr());\n         debug_assert_eq!(result, 0);\n     }\n "}, {"sha": "7127386def4a51cd3b5bd296e92784548344b9c1", "filename": "src/libstd/sys/unix/process/process_common.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3ba1f39fe7bad6234419a33a9fbf1551e85dfa2d/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ba1f39fe7bad6234419a33a9fbf1551e85dfa2d/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs?ref=3ba1f39fe7bad6234419a33a9fbf1551e85dfa2d", "patch": "@@ -466,11 +466,11 @@ mod tests {\n             // Test to make sure that a signal mask does not get inherited.\n             let mut cmd = Command::new(OsStr::new(\"cat\"));\n \n-            let mut set: libc::sigset_t = mem::uninitialized();\n-            let mut old_set: libc::sigset_t = mem::uninitialized();\n-            t!(cvt(sigemptyset(&mut set)));\n-            t!(cvt(sigaddset(&mut set, libc::SIGINT)));\n-            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &set, &mut old_set)));\n+            let mut set = mem::MaybeUninit::<libc::sigset_t>::uninit();\n+            let mut old_set = mem::MaybeUninit::<libc::sigset_t>::uninit();\n+            t!(cvt(sigemptyset(set.as_mut_ptr())));\n+            t!(cvt(sigaddset(set.as_mut_ptr(), libc::SIGINT)));\n+            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, set.as_ptr(), old_set.as_mut_ptr())));\n \n             cmd.stdin(Stdio::MakePipe);\n             cmd.stdout(Stdio::MakePipe);\n@@ -479,7 +479,7 @@ mod tests {\n             let stdin_write = pipes.stdin.take().unwrap();\n             let stdout_read = pipes.stdout.take().unwrap();\n \n-            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &old_set,\n+            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, old_set.as_ptr(),\n                                          ptr::null_mut())));\n \n             t!(cvt(libc::kill(cat.id() as libc::pid_t, libc::SIGINT)));"}, {"sha": "28c1d214a8d0d8bc66272703f5855cd5623b3f23", "filename": "src/libstd/sys/unix/process/process_unix.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3ba1f39fe7bad6234419a33a9fbf1551e85dfa2d/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ba1f39fe7bad6234419a33a9fbf1551e85dfa2d/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=3ba1f39fe7bad6234419a33a9fbf1551e85dfa2d", "patch": "@@ -202,26 +202,26 @@ impl Command {\n         // emscripten has no signal support.\n         #[cfg(not(any(target_os = \"emscripten\")))]\n         {\n-            use crate::mem;\n+            use crate::mem::{self, MaybeUninit};\n             // Reset signal handling so the child process starts in a\n             // standardized state. libstd ignores SIGPIPE, and signal-handling\n             // libraries often set a mask. Child processes inherit ignored\n             // signals and the signal mask from their parent, but most\n             // UNIX programs do not reset these things on their own, so we\n             // need to clean things up now to avoid confusing the program\n             // we're about to run.\n-            let mut set: libc::sigset_t = mem::uninitialized();\n+            let mut set = MaybeUninit::<libc::sigset_t>::uninit();\n             if cfg!(target_os = \"android\") {\n                 // Implementing sigemptyset allow us to support older Android\n                 // versions. See the comment about Android and sig* functions in\n                 // process_common.rs\n-                libc::memset(&mut set as *mut _ as *mut _,\n+                libc::memset(set.as_mut_ptr() as *mut _,\n                              0,\n                              mem::size_of::<libc::sigset_t>());\n             } else {\n-                cvt(libc::sigemptyset(&mut set))?;\n+                cvt(libc::sigemptyset(set.as_mut_ptr()))?;\n             }\n-            cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &set,\n+            cvt(libc::pthread_sigmask(libc::SIG_SETMASK, set.as_ptr(),\n                                          ptr::null_mut()))?;\n             let ret = sys::signal(libc::SIGPIPE, libc::SIG_DFL);\n             if ret == libc::SIG_ERR {\n@@ -273,7 +273,7 @@ impl Command {\n     fn posix_spawn(&mut self, stdio: &ChildPipes, envp: Option<&CStringArray>)\n         -> io::Result<Option<Process>>\n     {\n-        use crate::mem;\n+        use crate::mem::MaybeUninit;\n         use crate::sys;\n \n         if self.get_gid().is_some() ||\n@@ -315,63 +315,63 @@ impl Command {\n \n         let mut p = Process { pid: 0, status: None };\n \n-        struct PosixSpawnFileActions(libc::posix_spawn_file_actions_t);\n+        struct PosixSpawnFileActions(MaybeUninit<libc::posix_spawn_file_actions_t>);\n \n         impl Drop for PosixSpawnFileActions {\n             fn drop(&mut self) {\n                 unsafe {\n-                    libc::posix_spawn_file_actions_destroy(&mut self.0);\n+                    libc::posix_spawn_file_actions_destroy(self.0.as_mut_ptr());\n                 }\n             }\n         }\n \n-        struct PosixSpawnattr(libc::posix_spawnattr_t);\n+        struct PosixSpawnattr(MaybeUninit<libc::posix_spawnattr_t>);\n \n         impl Drop for PosixSpawnattr {\n             fn drop(&mut self) {\n                 unsafe {\n-                    libc::posix_spawnattr_destroy(&mut self.0);\n+                    libc::posix_spawnattr_destroy(self.0.as_mut_ptr());\n                 }\n             }\n         }\n \n         unsafe {\n-            let mut file_actions = PosixSpawnFileActions(mem::uninitialized());\n-            let mut attrs = PosixSpawnattr(mem::uninitialized());\n+            let mut file_actions = PosixSpawnFileActions(MaybeUninit::uninit());\n+            let mut attrs = PosixSpawnattr(MaybeUninit::uninit());\n \n-            libc::posix_spawnattr_init(&mut attrs.0);\n-            libc::posix_spawn_file_actions_init(&mut file_actions.0);\n+            libc::posix_spawnattr_init(attrs.0.as_mut_ptr());\n+            libc::posix_spawn_file_actions_init(file_actions.0.as_mut_ptr());\n \n             if let Some(fd) = stdio.stdin.fd() {\n-                cvt(libc::posix_spawn_file_actions_adddup2(&mut file_actions.0,\n+                cvt(libc::posix_spawn_file_actions_adddup2(file_actions.0.as_mut_ptr(),\n                                                            fd,\n                                                            libc::STDIN_FILENO))?;\n             }\n             if let Some(fd) = stdio.stdout.fd() {\n-                cvt(libc::posix_spawn_file_actions_adddup2(&mut file_actions.0,\n+                cvt(libc::posix_spawn_file_actions_adddup2(file_actions.0.as_mut_ptr(),\n                                                            fd,\n                                                            libc::STDOUT_FILENO))?;\n             }\n             if let Some(fd) = stdio.stderr.fd() {\n-                cvt(libc::posix_spawn_file_actions_adddup2(&mut file_actions.0,\n+                cvt(libc::posix_spawn_file_actions_adddup2(file_actions.0.as_mut_ptr(),\n                                                            fd,\n                                                            libc::STDERR_FILENO))?;\n             }\n             if let Some((f, cwd)) = addchdir {\n-                cvt(f(&mut file_actions.0, cwd.as_ptr()))?;\n+                cvt(f(file_actions.0.as_mut_ptr(), cwd.as_ptr()))?;\n             }\n \n-            let mut set: libc::sigset_t = mem::uninitialized();\n-            cvt(libc::sigemptyset(&mut set))?;\n-            cvt(libc::posix_spawnattr_setsigmask(&mut attrs.0,\n-                                                 &set))?;\n-            cvt(libc::sigaddset(&mut set, libc::SIGPIPE))?;\n-            cvt(libc::posix_spawnattr_setsigdefault(&mut attrs.0,\n-                                                    &set))?;\n+            let mut set = MaybeUninit::<libc::sigset_t>::uninit();\n+            cvt(libc::sigemptyset(set.as_mut_ptr()))?;\n+            cvt(libc::posix_spawnattr_setsigmask(attrs.0.as_mut_ptr(),\n+                                                 set.as_ptr()))?;\n+            cvt(libc::sigaddset(set.as_mut_ptr(), libc::SIGPIPE))?;\n+            cvt(libc::posix_spawnattr_setsigdefault(attrs.0.as_mut_ptr(),\n+                                                    set.as_ptr()))?;\n \n             let flags = libc::POSIX_SPAWN_SETSIGDEF |\n                 libc::POSIX_SPAWN_SETSIGMASK;\n-            cvt(libc::posix_spawnattr_setflags(&mut attrs.0, flags as _))?;\n+            cvt(libc::posix_spawnattr_setflags(attrs.0.as_mut_ptr(), flags as _))?;\n \n             // Make sure we synchronize access to the global `environ` resource\n             let _env_lock = sys::os::env_lock();\n@@ -380,8 +380,8 @@ impl Command {\n             let ret = libc::posix_spawnp(\n                 &mut p.pid,\n                 self.get_argv()[0],\n-                &file_actions.0,\n-                &attrs.0,\n+                file_actions.0.as_ptr(),\n+                attrs.0.as_ptr(),\n                 self.get_argv().as_ptr() as *const _,\n                 envp as *const _,\n             );"}]}