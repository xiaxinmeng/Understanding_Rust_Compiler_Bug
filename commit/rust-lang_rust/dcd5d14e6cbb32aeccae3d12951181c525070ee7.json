{"sha": "dcd5d14e6cbb32aeccae3d12951181c525070ee7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjZDVkMTRlNmNiYjMyYWVjY2FlM2QxMjk1MTE4MWM1MjUwNzBlZTc=", "commit": {"author": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2013-07-13T01:25:46Z"}, "committer": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2013-07-13T11:33:48Z"}, "message": "Avoid return blocks that have only a single predecessor\n\nCurrently, we always create a dedicated \"return\" basic block, but when\nthere's only a single predecessor for that block, it can be merged with\nthat predecessor. We can achieve that merge by only creating the return\nblock on demand, avoiding its creation when its not required.\n\nReduces the pre-optimization size of librustc.ll created with --passes \"\"\nby about 90k lines which equals about 4%.", "tree": {"sha": "2402786bf610bff99ee0f7af4ad110812f7c3d19", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2402786bf610bff99ee0f7af4ad110812f7c3d19"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dcd5d14e6cbb32aeccae3d12951181c525070ee7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dcd5d14e6cbb32aeccae3d12951181c525070ee7", "html_url": "https://github.com/rust-lang/rust/commit/dcd5d14e6cbb32aeccae3d12951181c525070ee7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dcd5d14e6cbb32aeccae3d12951181c525070ee7/comments", "author": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9eb86823049c2eff98e74fcac8ae75cc8760f33", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9eb86823049c2eff98e74fcac8ae75cc8760f33", "html_url": "https://github.com/rust-lang/rust/commit/a9eb86823049c2eff98e74fcac8ae75cc8760f33"}], "stats": {"total": 181, "additions": 113, "deletions": 68}, "files": [{"sha": "bbd676c87b498b0dc2ae3acb96ec770f69ab0349", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 68, "deletions": 21, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/dcd5d14e6cbb32aeccae3d12951181c525070ee7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd5d14e6cbb32aeccae3d12951181c525070ee7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=dcd5d14e6cbb32aeccae3d12951181c525070ee7", "patch": "@@ -1102,11 +1102,6 @@ pub fn trans_trace(bcx: block, sp_opt: Option<span>, trace_str: @str) {\n     Call(bcx, ccx.upcalls.trace, args);\n }\n \n-pub fn build_return(bcx: block) {\n-    let _icx = push_ctxt(\"build_return\");\n-    Br(bcx, bcx.fcx.llreturn);\n-}\n-\n pub fn ignore_lhs(_bcx: block, local: &ast::local) -> bool {\n     match local.node.pat.node {\n         ast::pat_wild => true, _ => false\n@@ -1364,6 +1359,42 @@ pub fn cleanup_and_leave(bcx: block,\n     }\n }\n \n+pub fn cleanup_block(bcx: block, upto: Option<BasicBlockRef>) -> block{\n+    let _icx = push_ctxt(\"cleanup_block\");\n+    let mut cur = bcx;\n+    let mut bcx = bcx;\n+    loop {\n+        debug!(\"cleanup_block: %s\", cur.to_str());\n+\n+        if bcx.sess().trace() {\n+            trans_trace(\n+                bcx, None,\n+                (fmt!(\"cleanup_block(%s)\", cur.to_str())).to_managed());\n+        }\n+\n+        let mut cur_scope = cur.scope;\n+        loop {\n+            cur_scope = match cur_scope {\n+                Some (inf) => {\n+                    bcx = trans_block_cleanups_(bcx, inf.cleanups.to_owned(), false);\n+                    inf.parent\n+                }\n+                None => break\n+            }\n+        }\n+\n+        match upto {\n+          Some(bb) => { if cur.llbb == bb { break; } }\n+          _ => ()\n+        }\n+        cur = match cur.parent {\n+          Some(next) => next,\n+          None => { assert!(upto.is_none()); break; }\n+        };\n+    }\n+    bcx\n+}\n+\n pub fn cleanup_and_Br(bcx: block, upto: block, target: BasicBlockRef) {\n     let _icx = push_ctxt(\"cleanup_and_Br\");\n     cleanup_and_leave(bcx, Some(upto.llbb), Some(target));\n@@ -1544,7 +1575,6 @@ pub fn arrayalloca(cx: block, ty: Type, v: ValueRef) -> ValueRef {\n \n pub struct BasicBlocks {\n     sa: BasicBlockRef,\n-    rt: BasicBlockRef\n }\n \n // Creates the standard set of basic blocks for a function\n@@ -1554,12 +1584,18 @@ pub fn mk_standard_basic_blocks(llfn: ValueRef) -> BasicBlocks {\n         BasicBlocks {\n             sa: str::as_c_str(\"static_allocas\",\n                            |buf| llvm::LLVMAppendBasicBlockInContext(cx, llfn, buf)),\n-            rt: str::as_c_str(\"return\",\n-                           |buf| llvm::LLVMAppendBasicBlockInContext(cx, llfn, buf))\n         }\n     }\n }\n \n+pub fn mk_return_basic_block(llfn: ValueRef) -> BasicBlockRef {\n+    unsafe {\n+        let cx = task_llcx();\n+        str::as_c_str(\"return\",\n+                      |buf| llvm::LLVMAppendBasicBlockInContext(cx, llfn, buf))\n+    }\n+}\n+\n // Creates and returns space for, or returns the argument representing, the\n // slot where the return value of the function must go.\n pub fn make_return_pointer(fcx: fn_ctxt, output_type: ty::t) -> ValueRef {\n@@ -1613,7 +1649,7 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n           llretptr: None,\n           llstaticallocas: llbbs.sa,\n           llloadenv: None,\n-          llreturn: llbbs.rt,\n+          llreturn: None,\n           llself: None,\n           personality: None,\n           loop_ret: None,\n@@ -1757,16 +1793,24 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n \n // Ties up the llstaticallocas -> llloadenv -> lltop edges,\n // and builds the return block.\n-pub fn finish_fn(fcx: fn_ctxt, lltop: BasicBlockRef) {\n+pub fn finish_fn(fcx: fn_ctxt, lltop: BasicBlockRef, last_bcx: block) {\n     let _icx = push_ctxt(\"finish_fn\");\n     tie_up_header_blocks(fcx, lltop);\n-    build_return_block(fcx);\n+\n+    let ret_cx = match fcx.llreturn {\n+        Some(llreturn) => {\n+            if !last_bcx.terminated {\n+                Br(last_bcx, llreturn);\n+            }\n+            raw_block(fcx, false, llreturn)\n+        }\n+        None => last_bcx\n+    };\n+    build_return_block(fcx, ret_cx);\n }\n \n // Builds the return block for a function.\n-pub fn build_return_block(fcx: fn_ctxt) {\n-    let ret_cx = raw_block(fcx, false, fcx.llreturn);\n-\n+pub fn build_return_block(fcx: fn_ctxt, ret_cx: block) {\n     // Return the value if this function immediate; otherwise, return void.\n     if fcx.llretptr.is_some() && fcx.has_immediate_return_value {\n         Ret(ret_cx, Load(ret_cx, fcx.llretptr.get()))\n@@ -1854,16 +1898,21 @@ pub fn trans_closure(ccx: @mut CrateContext,\n     }\n \n     finish(bcx);\n-    cleanup_and_Br(bcx, bcx_top, fcx.llreturn);\n+    match fcx.llreturn {\n+        Some(llreturn) => cleanup_and_Br(bcx, bcx_top, llreturn),\n+        None => bcx = cleanup_block(bcx, Some(bcx_top.llbb))\n+    };\n \n     // Put return block after all other blocks.\n     // This somewhat improves single-stepping experience in debugger.\n     unsafe {\n-        llvm::LLVMMoveBasicBlockAfter(fcx.llreturn, bcx.llbb);\n+        for fcx.llreturn.iter().advance |&llreturn| {\n+            llvm::LLVMMoveBasicBlockAfter(llreturn, bcx.llbb);\n+        }\n     }\n \n     // Insert the mandatory first few basic blocks before lltop.\n-    finish_fn(fcx, lltop);\n+    finish_fn(fcx, lltop, bcx);\n }\n \n // trans_fn: creates an LLVM function corresponding to a source language\n@@ -2046,8 +2095,7 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n         let arg_ty = arg_tys[i];\n         memcpy_ty(bcx, lldestptr, llarg, arg_ty);\n     }\n-    build_return(bcx);\n-    finish_fn(fcx, lltop);\n+    finish_fn(fcx, lltop, bcx);\n }\n \n pub fn trans_enum_def(ccx: @mut CrateContext, enum_definition: &ast::enum_def,\n@@ -2288,8 +2336,7 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n         let args = ~[llenvarg];\n         Call(bcx, main_llfn, args);\n \n-        build_return(bcx);\n-        finish_fn(fcx, lltop);\n+        finish_fn(fcx, lltop, bcx);\n         return llfdecl;\n     }\n "}, {"sha": "7b7989879a639a4758e2db95bbe2dc46a3f9cc41", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dcd5d14e6cbb32aeccae3d12951181c525070ee7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd5d14e6cbb32aeccae3d12951181c525070ee7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=dcd5d14e6cbb32aeccae3d12951181c525070ee7", "patch": "@@ -704,7 +704,7 @@ pub fn trans_call_inner(in_cx: block,\n                         Store(bcx, C_bool(false), bcx.fcx.llretptr.get());\n                     }\n                 }\n-                base::cleanup_and_leave(bcx, None, Some(bcx.fcx.llreturn));\n+                base::cleanup_and_leave(bcx, None, Some(bcx.fcx.get_llreturn()));\n                 Unreachable(bcx);\n                 bcx\n             }"}, {"sha": "2e016377e75c4013207f4ee70777dfbc5c3896de", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dcd5d14e6cbb32aeccae3d12951181c525070ee7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd5d14e6cbb32aeccae3d12951181c525070ee7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=dcd5d14e6cbb32aeccae3d12951181c525070ee7", "patch": "@@ -184,7 +184,7 @@ pub struct fn_ctxt_ {\n     // (LLVM requires that arguments be copied to local allocas before\n     // allowing most any operation to be performed on them.)\n     llloadenv: Option<BasicBlockRef>,\n-    llreturn: BasicBlockRef,\n+    llreturn: Option<BasicBlockRef>,\n     // The 'self' value currently in use in this function, if there\n     // is one.\n     //\n@@ -251,6 +251,13 @@ impl fn_ctxt_ {\n         }\n     }\n \n+    pub fn get_llreturn(&mut self) -> BasicBlockRef {\n+        if self.llreturn.is_none() {\n+            self.llreturn = Some(base::mk_return_basic_block(self.llfn));\n+        }\n+\n+        self.llreturn.get()\n+    }\n }\n \n pub type fn_ctxt = @mut fn_ctxt_;"}, {"sha": "e9eb7ff086dde7038b5c76a77390967238b0b1d8", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dcd5d14e6cbb32aeccae3d12951181c525070ee7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd5d14e6cbb32aeccae3d12951181c525070ee7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=dcd5d14e6cbb32aeccae3d12951181c525070ee7", "patch": "@@ -279,7 +279,7 @@ pub fn trans_break_cont(bcx: block,\n                         // This is a return from a loop body block\n                         None => {\n                             Store(bcx, C_bool(!to_end), bcx.fcx.llretptr.get());\n-                            cleanup_and_leave(bcx, None, Some(bcx.fcx.llreturn));\n+                            cleanup_and_leave(bcx, None, Some(bcx.fcx.get_llreturn()));\n                             Unreachable(bcx);\n                             return bcx;\n                         }\n@@ -328,7 +328,7 @@ pub fn trans_ret(bcx: block, e: Option<@ast::expr>) -> block {\n       }\n       _ => ()\n     }\n-    cleanup_and_leave(bcx, None, Some(bcx.fcx.llreturn));\n+    cleanup_and_leave(bcx, None, Some(bcx.fcx.get_llreturn()));\n     Unreachable(bcx);\n     return bcx;\n }"}, {"sha": "1ad5a543e66103d05a29a3d6918359f29d6cfe1f", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/dcd5d14e6cbb32aeccae3d12951181c525070ee7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd5d14e6cbb32aeccae3d12951181c525070ee7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=dcd5d14e6cbb32aeccae3d12951181c525070ee7", "patch": "@@ -164,7 +164,10 @@ fn build_shim_fn_(ccx: @mut CrateContext,\n     // follow the normal Rust calling conventions.\n     tie_up_header_blocks(fcx, lltop);\n \n-    let ret_cx = raw_block(fcx, false, fcx.llreturn);\n+    let ret_cx = match fcx.llreturn {\n+        Some(llreturn) => raw_block(fcx, false, llreturn),\n+        None => bcx\n+    };\n     RetVoid(ret_cx);\n \n     return llshimfn;\n@@ -217,7 +220,10 @@ fn build_wrap_fn_(ccx: @mut CrateContext,\n     tie_up_header_blocks(fcx, lltop);\n \n     // Then return according to the C ABI.\n-    let return_context = raw_block(fcx, false, fcx.llreturn);\n+    let return_context = match fcx.llreturn {\n+        Some(llreturn) => raw_block(fcx, false, llreturn),\n+        None => bcx\n+    };\n \n     let llfunctiontype = val_ty(llwrapfn);\n     let llfunctiontype = llfunctiontype.element_type();\n@@ -388,7 +394,6 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n                                      tys.ret_def,\n                                      llargbundle,\n                                      llretval);\n-            build_return(bcx);\n         }\n \n         let lname = link_name(ccx, foreign_item);\n@@ -438,8 +443,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n         if !ty::type_is_nil(ret_ty) && !ty::type_is_bot(ret_ty) {\n             Store(bcx, retval, fcx.llretptr.get());\n         }\n-        build_return(bcx);\n-        finish_fn(fcx, lltop);\n+        finish_fn(fcx, lltop, bcx);\n     }\n \n     // FIXME (#2535): this is very shaky and probably gets ABIs wrong all\n@@ -467,8 +471,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n         if !ty::type_is_nil(ret_ty) && !ty::type_is_bot(ret_ty) {\n             Store(bcx, retval, fcx.llretptr.get());\n         }\n-        build_return(bcx);\n-        finish_fn(fcx, lltop);\n+        finish_fn(fcx, lltop, bcx);\n     }\n \n     fn build_wrap_fn(ccx: @mut CrateContext,\n@@ -534,7 +537,6 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n                 let llretptr = load_inbounds(bcx, llargbundle, [0, arg_count]);\n                 Store(bcx, Load(bcx, llretptr), retptr);\n             }\n-            build_return(bcx);\n         }\n     }\n }\n@@ -629,8 +631,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             }\n         }\n \n-        build_return(bcx);\n-        finish_fn(fcx, lltop);\n+        finish_fn(fcx, lltop, bcx);\n \n         return;\n     }\n@@ -1124,8 +1125,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             ccx.sess.span_bug(item.span, \"unknown intrinsic\");\n         }\n     }\n-    build_return(bcx);\n-    finish_fn(fcx, lltop);\n+    finish_fn(fcx, lltop, bcx);\n }\n \n /**\n@@ -1257,8 +1257,6 @@ pub fn trans_foreign_fn(ccx: @mut CrateContext,\n                 // NB: The return pointer in the Rust ABI function is wired\n                 // directly into the return slot in the shim struct.\n             }\n-\n-            build_return(bcx);\n         }\n \n         let shim_name = link::mangle_internal_name_by_path(\n@@ -1314,7 +1312,6 @@ pub fn trans_foreign_fn(ccx: @mut CrateContext,\n         fn build_ret(bcx: block, tys: &ShimTypes, llargbundle: ValueRef) {\n             let _icx = push_ctxt(\"foreign::foreign::wrap::build_ret\");\n             tys.fn_ty.build_wrap_ret(bcx, tys.llsig.llarg_tys, llargbundle);\n-            build_return(bcx);\n         }\n     }\n "}, {"sha": "418c89e603d07a5db35d1a2fcc8b9e6c0123357a", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/dcd5d14e6cbb32aeccae3d12951181c525070ee7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd5d14e6cbb32aeccae3d12951181c525070ee7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=dcd5d14e6cbb32aeccae3d12951181c525070ee7", "patch": "@@ -348,24 +348,23 @@ pub fn call_tydesc_glue(cx: block, v: ValueRef, t: ty::t, field: uint)\n     return cx;\n }\n \n-pub fn make_visit_glue(bcx: block, v: ValueRef, t: ty::t) {\n+pub fn make_visit_glue(bcx: block, v: ValueRef, t: ty::t) -> block {\n     let _icx = push_ctxt(\"make_visit_glue\");\n-    let bcx = do with_scope(bcx, None, \"visitor cleanup\") |bcx| {\n+    do with_scope(bcx, None, \"visitor cleanup\") |bcx| {\n         let mut bcx = bcx;\n         let (visitor_trait, object_ty) = ty::visitor_object_ty(bcx.tcx());\n         let v = PointerCast(bcx, v, type_of::type_of(bcx.ccx(), object_ty).ptr_to());\n         bcx = reflect::emit_calls_to_trait_visit_ty(bcx, t, v, visitor_trait.def_id);\n         // The visitor is a boxed object and needs to be dropped\n         add_clean(bcx, v, object_ty);\n         bcx\n-    };\n-    build_return(bcx);\n+    }\n }\n \n-pub fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n+pub fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) -> block {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"make_free_glue\");\n-    let bcx = match ty::get(t).sty {\n+    match ty::get(t).sty {\n       ty::ty_box(body_mt) => {\n         let v = Load(bcx, v);\n         let body = GEPi(bcx, v, [0u, abi::box_field_body]);\n@@ -389,9 +388,7 @@ pub fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n         tvec::make_uniq_free_glue(bcx, v, t)\n       }\n       ty::ty_evec(_, ty::vstore_box) | ty::ty_estr(ty::vstore_box) => {\n-        make_free_glue(bcx, v,\n-                       tvec::expand_boxed_vec_ty(bcx.tcx(), t));\n-        return;\n+        make_free_glue(bcx, v, tvec::expand_boxed_vec_ty(bcx.tcx(), t))\n       }\n       ty::ty_closure(_) => {\n         closure::make_closure_glue(bcx, v, t, free_ty)\n@@ -400,8 +397,7 @@ pub fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n         closure::make_opaque_cbox_free_glue(bcx, ck, v)\n       }\n       _ => bcx\n-    };\n-    build_return(bcx);\n+    }\n }\n \n pub fn trans_struct_drop_flag(bcx: block, t: ty::t, v0: ValueRef, dtor_did: ast::def_id,\n@@ -475,11 +471,11 @@ pub fn trans_struct_drop(mut bcx: block, t: ty::t, v0: ValueRef, dtor_did: ast::\n     bcx\n }\n \n-pub fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n+pub fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) -> block {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"make_drop_glue\");\n     let ccx = bcx.ccx();\n-    let bcx = match ty::get(t).sty {\n+    match ty::get(t).sty {\n       ty::ty_box(_) | ty::ty_opaque_box |\n       ty::ty_estr(ty::vstore_box) | ty::ty_evec(_, ty::vstore_box) => {\n         decr_refcnt_maybe_free(bcx, Load(bcx, v0), Some(v0), t)\n@@ -542,8 +538,7 @@ pub fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n             iter_structural_ty(bcx, v0, t, drop_ty)\n         } else { bcx }\n       }\n-    };\n-    build_return(bcx);\n+    }\n }\n \n // box_ptr_ptr is optional, it is constructed if not supplied.\n@@ -569,10 +564,10 @@ pub fn decr_refcnt_maybe_free(bcx: block, box_ptr: ValueRef,\n }\n \n \n-pub fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) {\n+pub fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) -> block {\n     let _icx = push_ctxt(\"make_take_glue\");\n     // NB: v is a *pointer* to type t here, not a direct value.\n-    let bcx = match ty::get(t).sty {\n+    match ty::get(t).sty {\n       ty::ty_box(_) | ty::ty_opaque_box |\n       ty::ty_evec(_, ty::vstore_box) | ty::ty_estr(ty::vstore_box) => {\n         incr_refcnt_of_boxed(bcx, Load(bcx, v)); bcx\n@@ -638,9 +633,7 @@ pub fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) {\n         iter_structural_ty(bcx, v, t, take_ty)\n       }\n       _ => bcx\n-    };\n-\n-    build_return(bcx);\n+    }\n }\n \n pub fn incr_refcnt_of_boxed(cx: block, box_ptr: ValueRef) {\n@@ -690,7 +683,7 @@ pub fn declare_tydesc(ccx: &mut CrateContext, t: ty::t) -> @mut tydesc_info {\n     return inf;\n }\n \n-pub type glue_helper<'self> = &'self fn(block, ValueRef, ty::t);\n+pub type glue_helper<'self> = &'self fn(block, ValueRef, ty::t) -> block;\n \n pub fn declare_generic_glue(ccx: &mut CrateContext, t: ty::t, llfnty: Type,\n                             name: &str) -> ValueRef {\n@@ -723,11 +716,9 @@ pub fn make_generic_glue_inner(ccx: @mut CrateContext,\n     let llrawptr0 = unsafe { llvm::LLVMGetParam(llfn, rawptr0_arg as c_uint) };\n     let llty = type_of(ccx, t);\n     let llrawptr0 = PointerCast(bcx, llrawptr0, llty.ptr_to());\n-    helper(bcx, llrawptr0, t);\n+    let bcx = helper(bcx, llrawptr0, t);\n \n-    // This is from the general finish fn, but that emits a ret {} that we don't want\n-    Br(raw_block(fcx, false, fcx.llstaticallocas), lltop);\n-    RetVoid(raw_block(fcx, false, fcx.llreturn));\n+    finish_fn(fcx, lltop, bcx);\n \n     return llfn;\n }"}, {"sha": "dee40f32169eedfb5eb424dcc27b50db50d541b1", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dcd5d14e6cbb32aeccae3d12951181c525070ee7/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd5d14e6cbb32aeccae3d12951181c525070ee7/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=dcd5d14e6cbb32aeccae3d12951181c525070ee7", "patch": "@@ -299,12 +299,15 @@ impl Reflector {\n                     //\n                     llvm::LLVMGetParam(llfdecl, fcx.arg_pos(0u) as c_uint)\n                 };\n-                let bcx = top_scope_block(fcx, None);\n+                let mut bcx = top_scope_block(fcx, None);\n                 let arg = BitCast(bcx, arg, llptrty);\n                 let ret = adt::trans_get_discr(bcx, repr, arg);\n                 Store(bcx, ret, fcx.llretptr.get());\n-                cleanup_and_Br(bcx, bcx, fcx.llreturn);\n-                finish_fn(fcx, bcx.llbb);\n+                match fcx.llreturn {\n+                    Some(llreturn) => cleanup_and_Br(bcx, bcx, llreturn),\n+                    None => bcx = cleanup_block(bcx, Some(bcx.llbb))\n+                };\n+                finish_fn(fcx, bcx.llbb, bcx);\n                 llfdecl\n             };\n "}]}