{"sha": "9395f0af789dc007e23dbae5d961c0751ab2dbe7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzOTVmMGFmNzg5ZGMwMDdlMjNkYmFlNWQ5NjFjMDc1MWFiMmRiZTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-02T21:24:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-02T21:24:18Z"}, "message": "Auto merge of #53725 - tbu-:pr_getrandom_syscalls, r=alexcrichton\n\nReduce number of syscalls in `rand`\n\nThis skips the initial zero-length `getrandom` call and\ndirectly hands the user buffer to the operating system, saving one\n`getrandom` syscall.", "tree": {"sha": "2d4489df2ba82e8b982e6bf900fb83b0b9641223", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d4489df2ba82e8b982e6bf900fb83b0b9641223"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9395f0af789dc007e23dbae5d961c0751ab2dbe7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9395f0af789dc007e23dbae5d961c0751ab2dbe7", "html_url": "https://github.com/rust-lang/rust/commit/9395f0af789dc007e23dbae5d961c0751ab2dbe7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9395f0af789dc007e23dbae5d961c0751ab2dbe7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "763d91aa124a4278a68207b644df8c48b39fab45", "url": "https://api.github.com/repos/rust-lang/rust/commits/763d91aa124a4278a68207b644df8c48b39fab45", "html_url": "https://github.com/rust-lang/rust/commit/763d91aa124a4278a68207b644df8c48b39fab45"}, {"sha": "b95c491dfc77c17161ac858f8e466f6024f8bb4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b95c491dfc77c17161ac858f8e466f6024f8bb4b", "html_url": "https://github.com/rust-lang/rust/commit/b95c491dfc77c17161ac858f8e466f6024f8bb4b"}], "stats": {"total": 66, "additions": 26, "deletions": 40}, "files": [{"sha": "371e58a20c40dd65a2b182e8aece96079ecfd19e", "filename": "src/libstd/sys/unix/rand.rs", "status": "modified", "additions": 26, "deletions": 40, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/9395f0af789dc007e23dbae5d961c0751ab2dbe7/src%2Flibstd%2Fsys%2Funix%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9395f0af789dc007e23dbae5d961c0751ab2dbe7/src%2Flibstd%2Fsys%2Funix%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Frand.rs?ref=9395f0af789dc007e23dbae5d961c0751ab2dbe7", "patch": "@@ -29,8 +29,8 @@ pub fn hashmap_random_keys() -> (u64, u64) {\n mod imp {\n     use fs::File;\n     use io::Read;\n+    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n     use libc;\n-    use sys::os::errno;\n \n     #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n     fn getrandom(buf: &mut [u8]) -> libc::c_long {\n@@ -40,71 +40,57 @@ mod imp {\n     }\n \n     #[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n-    fn getrandom(_buf: &mut [u8]) -> libc::c_long { -1 }\n+    fn getrandom_fill_bytes(_buf: &mut [u8]) -> bool { false }\n \n+    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n     fn getrandom_fill_bytes(v: &mut [u8]) -> bool {\n+        use sync::atomic::{AtomicBool, Ordering};\n+        use sys::os::errno;\n+\n+        static GETRANDOM_UNAVAILABLE: AtomicBool = AtomicBool::new(false);\n+        if GETRANDOM_UNAVAILABLE.load(Ordering::Relaxed) {\n+            return false;\n+        }\n+\n         let mut read = 0;\n         while read < v.len() {\n             let result = getrandom(&mut v[read..]);\n             if result == -1 {\n                 let err = errno() as libc::c_int;\n                 if err == libc::EINTR {\n                     continue;\n+                } else if err == libc::ENOSYS {\n+                    GETRANDOM_UNAVAILABLE.store(true, Ordering::Relaxed);\n+                    return false;\n                 } else if err == libc::EAGAIN {\n-                    return false\n+                    return false;\n                 } else {\n                     panic!(\"unexpected getrandom error: {}\", err);\n                 }\n             } else {\n                 read += result as usize;\n             }\n         }\n-\n-        return true\n+        true\n     }\n \n-    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-    fn is_getrandom_available() -> bool {\n-        use io;\n-        use sync::atomic::{AtomicBool, Ordering};\n-        use sync::Once;\n-\n-        static CHECKER: Once = Once::new();\n-        static AVAILABLE: AtomicBool = AtomicBool::new(false);\n-\n-        CHECKER.call_once(|| {\n-            let mut buf: [u8; 0] = [];\n-            let result = getrandom(&mut buf);\n-            let available = if result == -1 {\n-                let err = io::Error::last_os_error().raw_os_error();\n-                err != Some(libc::ENOSYS)\n-            } else {\n-                true\n-            };\n-            AVAILABLE.store(available, Ordering::Relaxed);\n-        });\n-\n-        AVAILABLE.load(Ordering::Relaxed)\n-    }\n-\n-    #[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n-    fn is_getrandom_available() -> bool { false }\n-\n     pub fn fill_bytes(v: &mut [u8]) {\n         // getrandom_fill_bytes here can fail if getrandom() returns EAGAIN,\n         // meaning it would have blocked because the non-blocking pool (urandom)\n-        // has not initialized in the kernel yet due to a lack of entropy the\n+        // has not initialized in the kernel yet due to a lack of entropy. The\n         // fallback we do here is to avoid blocking applications which could\n         // depend on this call without ever knowing they do and don't have a\n-        // work around.  The PRNG of /dev/urandom will still be used but not\n-        // over a completely full entropy pool\n-        if is_getrandom_available() && getrandom_fill_bytes(v) {\n-            return\n+        // work around. The PRNG of /dev/urandom will still be used but over a\n+        // possibly predictable entropy pool.\n+        if getrandom_fill_bytes(v) {\n+            return;\n         }\n \n-        let mut file = File::open(\"/dev/urandom\")\n-            .expect(\"failed to open /dev/urandom\");\n-        file.read_exact(v).expect(\"failed to read /dev/urandom\");\n+        // getrandom failed because it is permanently or temporarily (because\n+        // of missing entropy) unavailable. Open /dev/urandom, read from it,\n+        // and close it again.\n+        let mut file = File::open(\"/dev/urandom\").expect(\"failed to open /dev/urandom\");\n+        file.read_exact(v).expect(\"failed to read /dev/urandom\")\n     }\n }\n "}]}