{"sha": "14f1fe0e29d5f4d832ef622b7a1a49e5c591e1c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0ZjFmZTBlMjlkNWY0ZDgzMmVmNjIyYjdhMWE0OWU1YzU5MWUxYzA=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-05-11T14:30:48Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-05-11T15:11:44Z"}, "message": "Remove mod indices from the AST\n\nThey are now created by the resolve pass, which is the only pass that\nneeds them, and kept internal to that pass.", "tree": {"sha": "838f21d4c374f114571e0c895eabcf8676566252", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/838f21d4c374f114571e0c895eabcf8676566252"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14f1fe0e29d5f4d832ef622b7a1a49e5c591e1c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14f1fe0e29d5f4d832ef622b7a1a49e5c591e1c0", "html_url": "https://github.com/rust-lang/rust/commit/14f1fe0e29d5f4d832ef622b7a1a49e5c591e1c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14f1fe0e29d5f4d832ef622b7a1a49e5c591e1c0/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5bea22d75c5427db76978f4f1e644b4ba37c3dc8", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bea22d75c5427db76978f4f1e644b4ba37c3dc8", "html_url": "https://github.com/rust-lang/rust/commit/5bea22d75c5427db76978f4f1e644b4ba37c3dc8"}], "stats": {"total": 367, "additions": 165, "deletions": 202}, "files": [{"sha": "8cfffc3948e2fad015980b6318cf602ee190cdb4", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 2, "deletions": 89, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/14f1fe0e29d5f4d832ef622b7a1a49e5c591e1c0/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f1fe0e29d5f4d832ef622b7a1a49e5c591e1c0/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=14f1fe0e29d5f4d832ef622b7a1a49e5c591e1c0", "patch": "@@ -360,21 +360,8 @@ type _obj = rec(vec[obj_field] fields,\n                 vec[@method] methods,\n                 Option.t[@method] dtor);\n \n-tag mod_index_entry {\n-    mie_view_item(@view_item);\n-    mie_item(@item);\n-    mie_tag_variant(@item /* tag item */, uint /* variant index */);\n-}\n-\n-tag native_mod_index_entry {\n-    nmie_view_item(@view_item);\n-    nmie_item(@native_item);\n-}\n-\n-type mod_index = hashmap[ident,mod_index_entry];\n type _mod = rec(vec[@view_item] view_items,\n-                vec[@item] items,\n-                mod_index index);\n+                vec[@item] items);\n \n tag native_abi {\n     native_abi_rust;\n@@ -386,9 +373,7 @@ tag native_abi {\n type native_mod = rec(str native_name,\n                       native_abi abi,\n                       vec[@view_item] view_items,\n-                      vec[@native_item] items,\n-                      native_mod_index index);\n-type native_mod_index = hashmap[ident,native_mod_index_entry];\n+                      vec[@native_item] items);\n \n type variant_arg = rec(@ty ty, def_id id);\n type variant_ = rec(str name, vec[variant_arg] args, def_id id, ann ann);\n@@ -433,78 +418,6 @@ tag native_item_ {\n                    fn_decl, vec[ty_param], def_id, ann);\n }\n \n-fn index_view_item(mod_index index, @view_item it) {\n-    alt (it.node) {\n-        case(ast.view_item_use(?id, _, _, _)) {\n-            index.insert(id, ast.mie_view_item(it));\n-        }\n-        case(ast.view_item_import(?def_ident,_,_)) {\n-            index.insert(def_ident, ast.mie_view_item(it));\n-        }\n-        case(ast.view_item_export(_)) {\n-            // NB: don't index these, they might collide with\n-            // the import or use that they're exporting. Have\n-            // to do linear search for exports.\n-        }\n-    }\n-}\n-\n-fn index_item(mod_index index, @item it) {\n-    alt (it.node) {\n-        case (ast.item_const(?id, _, _, _, _)) {\n-            index.insert(id, ast.mie_item(it));\n-        }\n-        case (ast.item_fn(?id, _, _, _, _)) {\n-            index.insert(id, ast.mie_item(it));\n-        }\n-        case (ast.item_mod(?id, _, _)) {\n-            index.insert(id, ast.mie_item(it));\n-        }\n-        case (ast.item_native_mod(?id, _, _)) {\n-            index.insert(id, ast.mie_item(it));\n-        }\n-        case (ast.item_ty(?id, _, _, _, _)) {\n-            index.insert(id, ast.mie_item(it));\n-        }\n-        case (ast.item_tag(?id, ?variants, _, _, _)) {\n-            index.insert(id, ast.mie_item(it));\n-            let uint variant_idx = 0u;\n-            for (ast.variant v in variants) {\n-                index.insert(v.node.name,\n-                             ast.mie_tag_variant(it, variant_idx));\n-                variant_idx += 1u;\n-            }\n-        }\n-        case (ast.item_obj(?id, _, _, _, _)) {\n-            index.insert(id, ast.mie_item(it));\n-        }\n-    }\n-}\n-\n-fn index_native_item(native_mod_index index, @native_item it) {\n-    alt (it.node) {\n-        case (ast.native_item_ty(?id, _)) {\n-            index.insert(id, ast.nmie_item(it));\n-        }\n-        case (ast.native_item_fn(?id, _, _, _, _, _)) {\n-            index.insert(id, ast.nmie_item(it));\n-        }\n-    }\n-}\n-\n-fn index_native_view_item(native_mod_index index, @view_item it) {\n-    alt (it.node) {\n-        case(ast.view_item_import(?def_ident,_,_)) {\n-            index.insert(def_ident, ast.nmie_view_item(it));\n-        }\n-        case(ast.view_item_export(_)) {\n-            // NB: don't index these, they might collide with\n-            // the import or use that they're exporting. Have\n-            // to do linear search for exports.\n-        }\n-    }\n-}\n-\n fn is_exported(ident i, _mod m) -> bool {\n     auto count = 0;\n     for (@ast.view_item vi in m.view_items) {"}, {"sha": "1d708f170043c74b8f0ceb1bf9f7b13dfbb77c8d", "filename": "src/comp/front/eval.rs", "status": "modified", "additions": 15, "deletions": 31, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/14f1fe0e29d5f4d832ef622b7a1a49e5c591e1c0/src%2Fcomp%2Ffront%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f1fe0e29d5f4d832ef622b7a1a49e5c591e1c0/src%2Fcomp%2Ffront%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Feval.rs?ref=14f1fe0e29d5f4d832ef622b7a1a49e5c591e1c0", "patch": "@@ -236,13 +236,11 @@ fn eval_crate_directives(ctx cx,\n                                 vec[@ast.crate_directive] cdirs,\n                                 str prefix,\n                                 &mutable vec[@ast.view_item] view_items,\n-                                &mutable vec[@ast.item] items,\n-                                hashmap[ast.ident,\n-                                        ast.mod_index_entry] index) {\n+                                &mutable vec[@ast.item] items) {\n \n     for (@ast.crate_directive sub_cdir in cdirs) {\n         eval_crate_directive(cx, e, sub_cdir, prefix,\n-                             view_items, items, index);\n+                             view_items, items);\n     }\n }\n \n@@ -252,12 +250,11 @@ fn eval_crate_directives_to_mod(ctx cx, env e,\n                                        str prefix) -> ast._mod {\n     let vec[@ast.view_item] view_items = vec();\n     let vec[@ast.item] items = vec();\n-    auto index = new_str_hash[ast.mod_index_entry]();\n \n     eval_crate_directives(cx, e, cdirs, prefix,\n-                          view_items, items, index);\n+                          view_items, items);\n \n-    ret rec(view_items=view_items, items=items, index=index);\n+    ret rec(view_items=view_items, items=items);\n }\n \n \n@@ -266,15 +263,13 @@ fn eval_crate_directive_block(ctx cx,\n                                      &ast.block blk,\n                                      str prefix,\n                                      &mutable vec[@ast.view_item] view_items,\n-                                     &mutable vec[@ast.item] items,\n-                                     hashmap[ast.ident,\n-                                             ast.mod_index_entry] index) {\n+                                     &mutable vec[@ast.item] items) {\n \n     for (@ast.stmt s in blk.node.stmts) {\n         alt (s.node) {\n             case (ast.stmt_crate_directive(?cdir)) {\n                 eval_crate_directive(cx, e, cdir, prefix,\n-                                     view_items, items, index);\n+                                     view_items, items);\n             }\n             case (_) {\n                 cx.sess.span_err(s.span,\n@@ -289,9 +284,7 @@ fn eval_crate_directive_expr(ctx cx,\n                                     @ast.expr x,\n                                     str prefix,\n                                     &mutable vec[@ast.view_item] view_items,\n-                                    &mutable vec[@ast.item] items,\n-                                    hashmap[ast.ident,\n-                                            ast.mod_index_entry] index) {\n+                                    &mutable vec[@ast.item] items) {\n     alt (x.node) {\n \n         case (ast.expr_if(?cond, ?thn, ?elopt, _)) {\n@@ -302,15 +295,13 @@ fn eval_crate_directive_expr(ctx cx,\n \n             if (val_as_bool(cv)) {\n                 ret eval_crate_directive_block(cx, e, thn, prefix,\n-                                               view_items, items,\n-                                               index);\n+                                               view_items, items);\n             }\n \n             alt (elopt) {\n                 case (some[@ast.expr](?els)) {\n                     ret eval_crate_directive_expr(cx, e, els, prefix,\n-                                                  view_items, items,\n-                                                  index);\n+                                                  view_items, items);\n                 }\n                 case (_) {\n                     // Absent-else is ok.\n@@ -326,14 +317,13 @@ fn eval_crate_directive_expr(ctx cx,\n                         auto pv = eval_lit(cx, arm.pat.span, lit);\n                         if (val_eq(cx.sess, arm.pat.span, vv, pv)) {\n                             ret eval_crate_directive_block\n-                                (cx, e, arm.block, prefix,\n-                                 view_items, items, index);\n+                                (cx, e, arm.block, prefix, view_items, items);\n                         }\n                     }\n                     case (ast.pat_wild(_)) {\n                         ret eval_crate_directive_block\n                             (cx, e, arm.block, prefix,\n-                             view_items, items, index);\n+                             view_items, items);\n                     }\n                     case (_) {\n                         cx.sess.span_err(arm.pat.span,\n@@ -346,8 +336,7 @@ fn eval_crate_directive_expr(ctx cx,\n \n         case (ast.expr_block(?block, _)) {\n             ret eval_crate_directive_block(cx, e, block, prefix,\n-                                           view_items, items,\n-                                           index);\n+                                           view_items, items);\n         }\n \n         case (_) {\n@@ -361,21 +350,19 @@ fn eval_crate_directive(ctx cx,\n                                @ast.crate_directive cdir,\n                                str prefix,\n                                &mutable vec[@ast.view_item] view_items,\n-                               &mutable vec[@ast.item] items,\n-                               hashmap[ast.ident,\n-                                       ast.mod_index_entry] index) {\n+                               &mutable vec[@ast.item] items) {\n     alt (cdir.node) {\n \n         case (ast.cdir_let(?id, ?x, ?cdirs)) {\n             auto v = eval_expr(cx, e, x);\n             auto e0 = vec(tup(id, v)) + e;\n             eval_crate_directives(cx, e0, cdirs, prefix,\n-                                  view_items, items, index);\n+                                  view_items, items);\n         }\n \n         case (ast.cdir_expr(?x)) {\n             eval_crate_directive_expr(cx, e, x, prefix,\n-                                      view_items, items, index);\n+                                      view_items, items);\n         }\n \n         case (ast.cdir_src_mod(?id, ?file_opt)) {\n@@ -404,7 +391,6 @@ fn eval_crate_directive(ctx cx,\n             cx.chpos = p0.get_chpos();\n             auto im = ast.item_mod(id, m0, next_id);\n             auto i = @spanned(cdir.span.lo, cdir.span.hi, im);\n-            ast.index_item(index, i);\n             Vec.push[@ast.item](items, i);\n         }\n \n@@ -422,13 +408,11 @@ fn eval_crate_directive(ctx cx,\n             auto m0 = eval_crate_directives_to_mod(cx, e, cdirs, full_path);\n             auto im = ast.item_mod(id, m0, cx.p.next_def_id());\n             auto i = @spanned(cdir.span.lo, cdir.span.hi, im);\n-            ast.index_item(index, i);\n             Vec.push[@ast.item](items, i);\n         }\n \n         case (ast.cdir_view_item(?vi)) {\n             Vec.push[@ast.view_item](view_items, vi);\n-            ast.index_view_item(index, vi);\n         }\n \n         case (ast.cdir_meta(?mi)) {"}, {"sha": "33b74d8d982db7af056a7de9e25c08a1bde062e1", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 10, "deletions": 28, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/14f1fe0e29d5f4d832ef622b7a1a49e5c591e1c0/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f1fe0e29d5f4d832ef622b7a1a49e5c591e1c0/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=14f1fe0e29d5f4d832ef622b7a1a49e5c591e1c0", "patch": "@@ -1889,17 +1889,12 @@ fn parse_item_obj(parser p, ast.layer lyr) -> @ast.item {\n }\n \n fn parse_mod_items(parser p, token.token term) -> ast._mod {\n-    auto index = new_str_hash[ast.mod_index_entry]();\n-    auto view_items = parse_view(p, index);\n+    auto view_items = parse_view(p);\n     let vec[@ast.item] items = vec();\n     while (p.peek() != term) {\n-        auto item = parse_item(p);\n-        items += vec(item);\n-\n-        // Index the item.\n-        ast.index_item(index, item);\n+        items += vec(parse_item(p));\n     }\n-    ret rec(view_items=view_items, items=items, index=index);\n+    ret rec(view_items=view_items, items=items);\n }\n \n fn parse_item_const(parser p) -> @ast.item {\n@@ -1972,22 +1967,16 @@ fn parse_native_item(parser p) -> @ast.native_item {\n fn parse_native_mod_items(parser p,\n                                  str native_name,\n                                  ast.native_abi abi) -> ast.native_mod {\n-    auto index = new_str_hash[ast.native_mod_index_entry]();\n     let vec[@ast.native_item] items = vec();\n \n-    auto view_items = parse_native_view(p, index);\n+    auto view_items = parse_native_view(p);\n \n     while (p.peek() != token.RBRACE) {\n-        auto item = parse_native_item(p);\n-        items += vec(item);\n-\n-        // Index the item.\n-        ast.index_native_item(index, item);\n+        items += vec(parse_native_item(p));\n     }\n     ret rec(native_name=native_name, abi=abi,\n             view_items=view_items,\n-            items=items,\n-            index=index);\n+            items=items);\n }\n \n fn default_native_name(session.session sess, str id) -> str {\n@@ -2353,25 +2342,18 @@ fn is_view_item(token.token t) -> bool {\n     ret false;\n }\n \n-fn parse_view(parser p, ast.mod_index index) -> vec[@ast.view_item] {\n+fn parse_view(parser p) -> vec[@ast.view_item] {\n     let vec[@ast.view_item] items = vec();\n     while (is_view_item(p.peek())) {\n-        auto item = parse_view_item(p);\n-        items += vec(item);\n-\n-        ast.index_view_item(index, item);\n+        items += vec(parse_view_item(p));\n     }\n     ret items;\n }\n \n-fn parse_native_view(parser p, ast.native_mod_index index)\n-    -> vec[@ast.view_item] {\n+fn parse_native_view(parser p) -> vec[@ast.view_item] {\n     let vec[@ast.view_item] items = vec();\n     while (is_view_item(p.peek())) {\n-        auto item = parse_view_item(p);\n-        items += vec(item);\n-\n-        ast.index_native_view_item(index, item);\n+        items += vec(parse_view_item(p));\n     }\n     ret items;\n }"}, {"sha": "06f4bfe5fb49e5ff56d8eeca6fdf8a8e801d34c0", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/14f1fe0e29d5f4d832ef622b7a1a49e5c591e1c0/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f1fe0e29d5f4d832ef622b7a1a49e5c591e1c0/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=14f1fe0e29d5f4d832ef622b7a1a49e5c591e1c0", "patch": "@@ -1057,21 +1057,18 @@ fn fold_mod[ENV](&ENV e, &ast_fold[ENV] fld, &ast._mod m) -> ast._mod {\n \n     let vec[@view_item] view_items = vec();\n     let vec[@item] items = vec();\n-    auto index = new_str_hash[ast.mod_index_entry]();\n \n     for (@view_item vi in m.view_items) {\n         auto new_vi = fold_view_item[ENV](e, fld, vi);\n         Vec.push[@view_item](view_items, new_vi);\n-        ast.index_view_item(index, new_vi);\n     }\n \n     for (@item i in m.items) {\n         auto new_item = fold_item[ENV](e, fld, i);\n         Vec.push[@item](items, new_item);\n-        ast.index_item(index, new_item);\n     }\n \n-    ret fld.fold_mod(e, rec(view_items=view_items, items=items, index=index));\n+    ret fld.fold_mod(e, rec(view_items=view_items, items=items));\n }\n \n fn fold_native_item[ENV](&ENV env, &ast_fold[ENV] fld,\n@@ -1098,7 +1095,6 @@ fn fold_native_mod[ENV](&ENV e, &ast_fold[ENV] fld,\n                         &ast.native_mod m) -> ast.native_mod {\n     let vec[@view_item] view_items = vec();\n     let vec[@native_item] items = vec();\n-    auto index = new_str_hash[ast.native_mod_index_entry]();\n \n     for (@view_item vi in m.view_items) {\n         auto new_vi = fold_view_item[ENV](e, fld, vi);\n@@ -1108,14 +1104,12 @@ fn fold_native_mod[ENV](&ENV e, &ast_fold[ENV] fld,\n     for (@native_item i in m.items) {\n         auto new_item = fold_native_item[ENV](e, fld, i);\n         Vec.push[@native_item](items, new_item);\n-        ast.index_native_item(index, new_item);\n     }\n \n     ret fld.fold_native_mod(e, rec(native_name=m.native_name,\n                                    abi=m.abi,\n                                    view_items=view_items,\n-                                   items=items,\n-                                   index=index));\n+                                   items=items));\n }\n \n fn fold_crate[ENV](&ENV env, &ast_fold[ENV] fld,"}, {"sha": "22c674595f3916eb15fef93ae043de0a22e6e595", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 134, "deletions": 37, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/14f1fe0e29d5f4d832ef622b7a1a49e5c591e1c0/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f1fe0e29d5f4d832ef622b7a1a49e5c591e1c0/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=14f1fe0e29d5f4d832ef622b7a1a49e5c591e1c0", "patch": "@@ -7,6 +7,7 @@ import front.creader;\n import driver.session.session;\n import util.common.new_def_hash;\n import util.common.new_int_hash;\n+import util.common.new_str_hash;\n import util.common.span;\n import util.typestate_ann.ts_ann;\n import std.Map.hashmap;\n@@ -26,6 +27,11 @@ import std.Vec;\n // locates all names (in expressions, types, and alt patterns) and resolves\n // them, storing the resulting def in the AST nodes.\n \n+// This module internally uses -1 as a def_id for the top_level module in a\n+// crate. The parser doesn't assign a def_id to this module.\n+// (FIXME See https://github.com/graydon/rust/issues/358 for the reason this\n+//  isn't a const.)\n+\n tag scope {\n     scope_crate(@ast.crate);\n     scope_item(@ast.item);\n@@ -35,10 +41,6 @@ tag scope {\n     scope_arm(ast.arm);\n }\n \n-tag wrap_mod {\n-    wmod(ast._mod);\n-    wnmod(ast.native_mod);\n-}\n tag import_state {\n     todo(@ast.view_item, list[scope]);\n     resolving(span);\n@@ -57,8 +59,24 @@ fn new_ext_hash() -> ext_hash {\n     ret std.Map.mk_hashmap[tup(def_id,str),def](hash, eq);\n }\n \n+tag mod_index_entry {\n+    mie_view_item(@ast.view_item);\n+    mie_item(@ast.item);\n+    mie_tag_variant(@ast.item /* tag item */, uint /* variant index */);\n+}\n+type mod_index = hashmap[ident,mod_index_entry];\n+type indexed_mod = rec(ast._mod m, mod_index index);\n+\n+tag native_mod_index_entry {\n+    nmie_view_item(@ast.view_item);\n+    nmie_item(@ast.native_item);\n+}\n+type nmod_index = hashmap[ident,native_mod_index_entry];\n+type indexed_nmod = rec(ast.native_mod m, nmod_index index);\n+\n type env = rec(hashmap[ast.def_num,import_state] imports,\n-               hashmap[ast.def_num,@wrap_mod] mod_map,\n+               hashmap[ast.def_num,@indexed_mod] mod_map,\n+               hashmap[ast.def_num,@indexed_nmod] nmod_map,\n                hashmap[def_id,vec[ident]] ext_map,\n                ext_hash ext_cache,\n                session sess);\n@@ -74,7 +92,8 @@ tag namespace {\n \n fn resolve_crate(session sess, @ast.crate crate) -> @ast.crate {\n     auto e = @rec(imports = new_int_hash[import_state](),\n-                  mod_map = new_int_hash[@wrap_mod](),\n+                  mod_map = new_int_hash[@indexed_mod](),\n+                  nmod_map = new_int_hash[@indexed_nmod](),\n                   ext_map = new_def_hash[vec[ident]](),\n                   ext_cache = new_ext_hash(),\n                   sess = sess);\n@@ -94,6 +113,9 @@ fn map_crate(&@env e, &ast.crate c) {\n                  visit_item_pre = bind push_env_for_item_map_mod(e, cell, _),\n                  visit_item_post = bind pop_env_for_item(cell, _)\n                  with walk.default_visitor());\n+    // Register the top-level mod\n+    e.mod_map.insert(-1, @rec(m=c.node.module,\n+                              index=index_mod(c.node.module)));\n     walk.walk_crate(v, c);\n \n     // Helpers for this pass.\n@@ -108,10 +130,12 @@ fn map_crate(&@env e, &ast.crate c) {\n         *sc = cons[scope](scope_item(i), @*sc);\n         alt (i.node) {\n             case (ast.item_mod(_, ?md, ?defid)) {\n-                e.mod_map.insert(defid._1, @wmod(md));\n+                auto index = index_mod(md);\n+                e.mod_map.insert(defid._1, @rec(m=md, index=index));\n             }\n             case (ast.item_native_mod(_, ?nmd, ?defid)) {\n-                e.mod_map.insert(defid._1, @wnmod(nmd));\n+                auto index = index_nmod(nmd);\n+                e.nmod_map.insert(defid._1, @rec(m=nmd, index=index));\n             }\n             case (_) {}\n         }\n@@ -375,7 +399,8 @@ fn lookup_in_scope(&env e, list[scope] sc, ident id, namespace ns)\n         -> Option.t[def] {\n         alt (s) {\n             case (scope_crate(?c)) {\n-                ret lookup_in_regular_mod(e, c.node.module, id, ns, inside);\n+                auto defid = tup(ast.local_crate, -1);\n+                ret lookup_in_regular_mod(e, defid, id, ns, inside);\n             }\n             case (scope_item(?it)) {\n                 alt (it.node) {\n@@ -390,11 +415,11 @@ fn lookup_in_scope(&env e, list[scope] sc, ident id, namespace ns)\n                             ret lookup_in_ty_params(id, ty_params);\n                         }\n                     }\n-                    case (ast.item_mod(_, ?m, _)) {\n-                        ret lookup_in_regular_mod(e, m, id, ns, inside);\n+                    case (ast.item_mod(_, _, ?defid)) {\n+                        ret lookup_in_regular_mod(e, defid, id, ns, inside);\n                     }\n-                    case (ast.item_native_mod(_, ?m, _)) {\n-                        ret lookup_in_native_mod(e, m, id, ns);\n+                    case (ast.item_native_mod(_, ?m, ?defid)) {\n+                        ret lookup_in_native_mod(e, defid, id, ns);\n                     }\n                     case (ast.item_ty(_, _, ?ty_params, _, _)) {\n                         if (ns == ns_type) {\n@@ -606,8 +631,6 @@ fn lookup_in_mod(&env e, def m, ident id, namespace ns, dir dr)\n             ret cached;\n         }\n         auto path = vec(id);\n-        // def_num=-1 is a kludge to overload def_mod for external crates,\n-        // since those don't get a def num\n         if (defid._1 != -1) {\n             path = e.ext_map.get(defid) + path;\n         }\n@@ -619,18 +642,10 @@ fn lookup_in_mod(&env e, def m, ident id, namespace ns, dir dr)\n     }\n     alt (m) {\n         case (ast.def_mod(?defid)) {\n-            alt (*e.mod_map.get(defid._1)) {\n-                case (wmod(?m)) {\n-                    ret lookup_in_regular_mod(e, m, id, ns, dr);\n-                }\n-            }\n+            ret lookup_in_regular_mod(e, defid, id, ns, dr);\n         }\n         case (ast.def_native_mod(?defid)) {\n-            alt (*e.mod_map.get(defid._1)) {\n-                case (wnmod(?m)) {\n-                    ret lookup_in_native_mod(e, m, id, ns);\n-                }\n-            }\n+            ret lookup_in_native_mod(e, defid, id, ns);\n         }\n     }\n }\n@@ -646,21 +661,22 @@ fn found_view_item(&env e, @ast.view_item vi, namespace ns) -> Option.t[def] {\n     }\n }\n \n-fn lookup_in_regular_mod(&env e, &ast._mod md, ident id, namespace ns, dir dr)\n+fn lookup_in_regular_mod(&env e, def_id defid, ident id, namespace ns, dir dr)\n     -> Option.t[def] {\n-    auto found = md.index.find(id);\n-    if (found == none[ast.mod_index_entry] || \n-        (dr == outside && !ast.is_exported(id, md))) {\n+    auto info = e.mod_map.get(defid._1);\n+    auto found = info.index.find(id);\n+    if (found == none[mod_index_entry] || \n+        (dr == outside && !ast.is_exported(id, info.m))) {\n         ret none[def];\n     }\n     alt (Option.get(found)) {\n-        case (ast.mie_view_item(?view_item)) {\n+        case (mie_view_item(?view_item)) {\n             ret found_view_item(e, view_item, ns);\n         }\n-        case (ast.mie_item(?item)) {\n+        case (mie_item(?item)) {\n             ret found_def_item(item, ns);\n         }\n-        case (ast.mie_tag_variant(?item, ?variant_idx)) {\n+        case (mie_tag_variant(?item, ?variant_idx)) {\n             alt (item.node) {\n                 case (ast.item_tag(_, ?variants, _, ?tid, _)) {\n                     if (ns == ns_value) {\n@@ -675,17 +691,18 @@ fn lookup_in_regular_mod(&env e, &ast._mod md, ident id, namespace ns, dir dr)\n     }\n }\n \n-fn lookup_in_native_mod(&env e, &ast.native_mod md, ident id, namespace ns)\n+fn lookup_in_native_mod(&env e, def_id defid, ident id, namespace ns)\n     -> Option.t[def] {\n-    auto found = md.index.find(id);\n-    if (found == none[ast.native_mod_index_entry]) {\n+    auto info = e.nmod_map.get(defid._1);\n+    auto found = info.index.find(id);\n+    if (found == none[native_mod_index_entry]) {\n         ret none[def];\n     }\n     alt (Option.get(found)) {\n-        case (ast.nmie_view_item(?view_item)) {\n+        case (nmie_view_item(?view_item)) {\n             ret found_view_item(e, view_item, ns);\n         }\n-        case (ast.nmie_item(?item)) {\n+        case (nmie_item(?item)) {\n             alt (item.node) {\n                 case (ast.native_item_ty(_, ?id)) {\n                     if (ns == ns_type) {\n@@ -704,6 +721,86 @@ fn lookup_in_native_mod(&env e, &ast.native_mod md, ident id, namespace ns)\n     ret none[def];\n }\n \n+// Module indexing\n+\n+fn index_mod(&ast._mod md) -> mod_index {\n+    auto index = new_str_hash[mod_index_entry]();\n+\n+    for (@ast.view_item it in md.view_items) {\n+        alt (it.node) {\n+            case(ast.view_item_use(?id, _, _, _)) {\n+                index.insert(id, mie_view_item(it));\n+            }\n+            case(ast.view_item_import(?def_ident,_,_)) {\n+                index.insert(def_ident, mie_view_item(it));\n+            }\n+            case(ast.view_item_export(_)) {}\n+        }\n+    }\n+\n+    for (@ast.item it in md.items) {\n+        alt (it.node) {\n+            case (ast.item_const(?id, _, _, _, _)) {\n+                index.insert(id, mie_item(it));\n+            }\n+            case (ast.item_fn(?id, _, _, _, _)) {\n+                index.insert(id, mie_item(it));\n+            }\n+            case (ast.item_mod(?id, _, _)) {\n+                index.insert(id, mie_item(it));\n+            }\n+            case (ast.item_native_mod(?id, _, _)) {\n+                index.insert(id, mie_item(it));\n+            }\n+            case (ast.item_ty(?id, _, _, _, _)) {\n+                index.insert(id, mie_item(it));\n+            }\n+            case (ast.item_tag(?id, ?variants, _, _, _)) {\n+                index.insert(id, mie_item(it));\n+                let uint variant_idx = 0u;\n+                for (ast.variant v in variants) {\n+                    index.insert(v.node.name,\n+                                 mie_tag_variant(it, variant_idx));\n+                    variant_idx += 1u;\n+                }\n+            }\n+            case (ast.item_obj(?id, _, _, _, _)) {\n+                index.insert(id, mie_item(it));\n+            }\n+        }\n+    }\n+\n+    ret index;\n+}\n+\n+fn index_nmod(&ast.native_mod md) -> nmod_index {\n+    auto index = new_str_hash[native_mod_index_entry]();\n+\n+    for (@ast.view_item it in md.view_items) {\n+        alt (it.node) {\n+            case(ast.view_item_import(?def_ident,_,_)) {\n+                index.insert(def_ident, nmie_view_item(it));\n+            }\n+            case(ast.view_item_export(_)) {}\n+        }\n+    }\n+\n+    for (@ast.native_item it in md.items) {\n+        alt (it.node) {\n+            case (ast.native_item_ty(?id, _)) {\n+                index.insert(id, nmie_item(it));\n+            }\n+            case (ast.native_item_fn(?id, _, _, _, _, _)) {\n+                index.insert(id, nmie_item(it));\n+            }\n+        }\n+    }\n+\n+    ret index;\n+}\n+\n+// External lookups\n+\n // FIXME creader should handle multiple namespaces\n fn check_def_by_ns(def d, namespace ns) -> bool {\n     ret alt (d) {"}, {"sha": "687b2e16614527082a227f431a9890505515e157", "filename": "src/comp/middle/typestate_check.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/14f1fe0e29d5f4d832ef622b7a1a49e5c591e1c0/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f1fe0e29d5f4d832ef622b7a1a49e5c591e1c0/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs?ref=14f1fe0e29d5f4d832ef622b7a1a49e5c591e1c0", "patch": "@@ -6,7 +6,6 @@ import front.ast.mutability;\n import front.ast.item;\n import front.ast.block;\n import front.ast.block_;\n-import front.ast.mod_index_entry;\n import front.ast.obj_field;\n import front.ast.decl;\n import front.ast.arm;\n@@ -83,8 +82,6 @@ import front.ast.ann_type;\n import front.ast._obj;\n import front.ast._mod;\n import front.ast.crate;\n-import front.ast.mod_index_entry;\n-import front.ast.mie_item;\n import front.ast.item_fn;\n import front.ast.item_obj;\n import front.ast.def_local;\n@@ -2357,14 +2354,12 @@ fn annotate_fn(&fn_info_map fm, &ast._fn f) -> ast._fn {\n }\n fn annotate_mod(&fn_info_map fm, &ast._mod m) -> ast._mod {\n     let vec[@item] new_items = vec();\n-    auto new_index = new_str_hash[mod_index_entry]();\n \n     for (@item i in m.items) {\n         auto new_i = annotate_item(fm, i);\n         Vec.push[@item](new_items, new_i);\n-        ast.index_item(new_index, new_i);\n     }\n-    ret rec(items=new_items, index=new_index with m);\n+    ret rec(items=new_items with m);\n }\n fn annotate_method(&fn_info_map fm, &@method m) -> @method {\n     auto f_info = get_fn_info(fm, m.node.id);\n@@ -2471,15 +2466,13 @@ fn annotate_item(&fn_info_map fm, &@ast.item item) -> @ast.item {\n \n fn annotate_module(&fn_info_map fm, &ast._mod module) -> ast._mod {\n     let vec[@item] new_items = vec();\n-    auto new_index = new_str_hash[ast.mod_index_entry]();\n \n     for (@item i in module.items) {\n         auto new_item = annotate_item(fm, i);\n         Vec.push[@item](new_items, new_item);\n-        ast.index_item(new_index, new_item);\n     }\n \n-    ret rec(items = new_items, index = new_index with module);\n+    ret rec(items = new_items with module);\n }\n \n fn annotate_crate(&fn_info_map fm, &@ast.crate crate) -> @ast.crate {"}]}