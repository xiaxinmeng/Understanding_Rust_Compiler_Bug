{"sha": "f808877bbf8643cb9ea54a59cb5a61a631f545dd", "node_id": "C_kwDOAAsO6NoAKGY4MDg4NzdiYmY4NjQzY2I5ZWE1NGE1OWNiNWE2MWE2MzFmNTQ1ZGQ", "commit": {"author": {"name": "yukang", "email": "moorekang@gmail.com", "date": "2023-02-22T10:30:35Z"}, "committer": {"name": "yukang", "email": "moorekang@gmail.com", "date": "2023-02-28T07:57:17Z"}, "message": "refactor parse_token_trees to not return unmatched_delims", "tree": {"sha": "fffca94dbf24ff5cbcd2752bb7b76cb363e0bae4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fffca94dbf24ff5cbcd2752bb7b76cb363e0bae4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f808877bbf8643cb9ea54a59cb5a61a631f545dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f808877bbf8643cb9ea54a59cb5a61a631f545dd", "html_url": "https://github.com/rust-lang/rust/commit/f808877bbf8643cb9ea54a59cb5a61a631f545dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f808877bbf8643cb9ea54a59cb5a61a631f545dd/comments", "author": {"login": "chenyukang", "id": 230646, "node_id": "MDQ6VXNlcjIzMDY0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/230646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chenyukang", "html_url": "https://github.com/chenyukang", "followers_url": "https://api.github.com/users/chenyukang/followers", "following_url": "https://api.github.com/users/chenyukang/following{/other_user}", "gists_url": "https://api.github.com/users/chenyukang/gists{/gist_id}", "starred_url": "https://api.github.com/users/chenyukang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chenyukang/subscriptions", "organizations_url": "https://api.github.com/users/chenyukang/orgs", "repos_url": "https://api.github.com/users/chenyukang/repos", "events_url": "https://api.github.com/users/chenyukang/events{/privacy}", "received_events_url": "https://api.github.com/users/chenyukang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "chenyukang", "id": 230646, "node_id": "MDQ6VXNlcjIzMDY0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/230646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chenyukang", "html_url": "https://github.com/chenyukang", "followers_url": "https://api.github.com/users/chenyukang/followers", "following_url": "https://api.github.com/users/chenyukang/following{/other_user}", "gists_url": "https://api.github.com/users/chenyukang/gists{/gist_id}", "starred_url": "https://api.github.com/users/chenyukang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chenyukang/subscriptions", "organizations_url": "https://api.github.com/users/chenyukang/orgs", "repos_url": "https://api.github.com/users/chenyukang/repos", "events_url": "https://api.github.com/users/chenyukang/events{/privacy}", "received_events_url": "https://api.github.com/users/chenyukang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88de2e111504439f76315548dd3e442999b46e95", "url": "https://api.github.com/repos/rust-lang/rust/commits/88de2e111504439f76315548dd3e442999b46e95", "html_url": "https://github.com/rust-lang/rust/commit/88de2e111504439f76315548dd3e442999b46e95"}], "stats": {"total": 59, "additions": 29, "deletions": 30}, "files": [{"sha": "9dbddee5a56f0ddc0c45831b8ab3ee881391ed30", "filename": "compiler/rustc_parse/src/lexer/mod.rs", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f808877bbf8643cb9ea54a59cb5a61a631f545dd/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f808877bbf8643cb9ea54a59cb5a61a631f545dd/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs?ref=f808877bbf8643cb9ea54a59cb5a61a631f545dd", "patch": "@@ -1,10 +1,11 @@\n use crate::errors;\n use crate::lexer::unicode_chars::UNICODE_ARRAY;\n+use crate::make_unclosed_delims_error;\n use rustc_ast::ast::{self, AttrStyle};\n use rustc_ast::token::{self, CommentKind, Delimiter, Token, TokenKind};\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::util::unicode::contains_text_flow_control_chars;\n-use rustc_errors::{error_code, Applicability, DiagnosticBuilder, PResult, StashKey};\n+use rustc_errors::{error_code, Applicability, Diagnostic, DiagnosticBuilder, StashKey};\n use rustc_lexer::unescape::{self, Mode};\n use rustc_lexer::Cursor;\n use rustc_lexer::{Base, DocStyle, RawStrError};\n@@ -44,7 +45,7 @@ pub(crate) fn parse_token_trees<'a>(\n     mut src: &'a str,\n     mut start_pos: BytePos,\n     override_span: Option<Span>,\n-) -> (PResult<'a, TokenStream>, Vec<UnmatchedDelim>) {\n+) -> Result<TokenStream, Vec<Diagnostic>> {\n     // Skip `#!`, if present.\n     if let Some(shebang_len) = rustc_lexer::strip_shebang(src) {\n         src = &src[shebang_len..];\n@@ -61,7 +62,29 @@ pub(crate) fn parse_token_trees<'a>(\n         override_span,\n         nbsp_is_whitespace: false,\n     };\n-    tokentrees::TokenTreesReader::parse_all_token_trees(string_reader)\n+    let (token_trees, unmatched_delims) =\n+        tokentrees::TokenTreesReader::parse_all_token_trees(string_reader);\n+    match token_trees {\n+        Ok(stream) if unmatched_delims.is_empty() => Ok(stream),\n+        _ => {\n+            // Return error if there are unmatched delimiters or unclosng delimiters.\n+            // We emit delimiter mismatch errors first, then emit the unclosing delimiter mismatch\n+            // because the delimiter mismatch is more likely to be the root cause of error\n+\n+            let mut buffer = Vec::with_capacity(1);\n+            // Not using `emit_unclosed_delims` to use `db.buffer`\n+            for unmatched in unmatched_delims {\n+                if let Some(err) = make_unclosed_delims_error(unmatched, &sess) {\n+                    err.buffer(&mut buffer);\n+                }\n+            }\n+            if let Err(err) = token_trees {\n+                // Add unclosing delimiter error\n+                err.buffer(&mut buffer);\n+            }\n+            Err(buffer)\n+        }\n+    }\n }\n \n struct StringReader<'a> {"}, {"sha": "36fd1e37d651ebbd08388bb67f8d028bd7c5b630", "filename": "compiler/rustc_parse/src/lexer/tokentrees.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f808877bbf8643cb9ea54a59cb5a61a631f545dd/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f808877bbf8643cb9ea54a59cb5a61a631f545dd/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs?ref=f808877bbf8643cb9ea54a59cb5a61a631f545dd", "patch": "@@ -161,7 +161,6 @@ impl<'a> TokenTreesReader<'a> {\n                         }\n                     }\n                     let (tok, _) = self.diag_info.open_braces.pop().unwrap();\n-                    debug!(\"anan now: open {:#?} close {:#?}\", open_delim, close_delim);\n                     self.diag_info.unmatched_delims.push(UnmatchedDelim {\n                         expected_delim: tok,\n                         found_delim: Some(close_delim),"}, {"sha": "d1c3fd0cd0f8f7559e412a799bfe6e7bce2d2448", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 1, "deletions": 24, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f808877bbf8643cb9ea54a59cb5a61a631f545dd/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f808877bbf8643cb9ea54a59cb5a61a631f545dd/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=f808877bbf8643cb9ea54a59cb5a61a631f545dd", "patch": "@@ -196,30 +196,7 @@ pub fn maybe_file_to_stream(\n         ));\n     });\n \n-    let (token_trees, unmatched_delims) =\n-        lexer::parse_token_trees(sess, src.as_str(), source_file.start_pos, override_span);\n-\n-    match token_trees {\n-        Ok(stream) if unmatched_delims.is_empty() => Ok(stream),\n-        _ => {\n-            // Return error if there are unmatched delimiters or unclosng delimiters.\n-            // We emit delimiter mismatch errors first, then emit the unclosing delimiter mismatch\n-            // because the delimiter mismatch is more likely to be the root cause of the\n-\n-            let mut buffer = Vec::with_capacity(1);\n-            // Not using `emit_unclosed_delims` to use `db.buffer`\n-            for unmatched in unmatched_delims {\n-                if let Some(err) = make_unclosed_delims_error(unmatched, &sess) {\n-                    err.buffer(&mut buffer);\n-                }\n-            }\n-            if let Err(err) = token_trees {\n-                // Add unclosing delimiter error\n-                err.buffer(&mut buffer);\n-            }\n-            Err(buffer)\n-        }\n-    }\n+    lexer::parse_token_trees(sess, src.as_str(), source_file.start_pos, override_span)\n }\n \n /// Given a stream and the `ParseSess`, produces a parser."}, {"sha": "f7a2a6d929174bb89bc270ce547b72a6fc49ac91", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f808877bbf8643cb9ea54a59cb5a61a631f545dd/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f808877bbf8643cb9ea54a59cb5a61a631f545dd/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=f808877bbf8643cb9ea54a59cb5a61a631f545dd", "patch": "@@ -19,9 +19,9 @@ use crate::errors::{\n };\n \n use crate::fluent_generated as fluent;\n-use rustc_ast as ast;\n-use crate::parser;\n use crate::lexer::UnmatchedDelim;\n+use crate::parser;\n+use rustc_ast as ast;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter, Lit, LitKind, TokenKind};\n use rustc_ast::util::parser::AssocOp;"}]}