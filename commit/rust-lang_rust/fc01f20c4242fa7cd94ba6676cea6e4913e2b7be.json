{"sha": "fc01f20c4242fa7cd94ba6676cea6e4913e2b7be", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjMDFmMjBjNDI0MmZhN2NkOTRiYTY2NzZjZWE2ZTQ5MTNlMmI3YmU=", "commit": {"author": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2013-11-11T10:06:26Z"}, "committer": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2013-11-11T12:22:30Z"}, "message": "Implement `size_hint` for Range\n\nCloses #8606", "tree": {"sha": "e5701475d3fa1ce039c35d944ee5d1c2f46c5c9d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5701475d3fa1ce039c35d944ee5d1c2f46c5c9d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc01f20c4242fa7cd94ba6676cea6e4913e2b7be", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc01f20c4242fa7cd94ba6676cea6e4913e2b7be", "html_url": "https://github.com/rust-lang/rust/commit/fc01f20c4242fa7cd94ba6676cea6e4913e2b7be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc01f20c4242fa7cd94ba6676cea6e4913e2b7be/comments", "author": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "committer": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c18983ea59e44762cb4d9f4cb95733009ce2002", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c18983ea59e44762cb4d9f4cb95733009ce2002", "html_url": "https://github.com/rust-lang/rust/commit/2c18983ea59e44762cb4d9f4cb95733009ce2002"}], "stats": {"total": 88, "additions": 80, "deletions": 8}, "files": [{"sha": "90195efeae9e01a6a5a347e0a6fc5fc47dc8defb", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 80, "deletions": 8, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/fc01f20c4242fa7cd94ba6676cea6e4913e2b7be/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc01f20c4242fa7cd94ba6676cea6e4913e2b7be/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=fc01f20c4242fa7cd94ba6676cea6e4913e2b7be", "patch": "@@ -65,7 +65,7 @@ the rest of the rust manuals.\n */\n \n use cmp;\n-use num::{Zero, One, Integer, CheckedAdd, CheckedSub, Saturating};\n+use num::{Zero, One, Integer, CheckedAdd, CheckedSub, Saturating, ToPrimitive};\n use option::{Option, Some, None};\n use ops::{Add, Mul, Sub};\n use cmp::{Eq, Ord};\n@@ -1829,7 +1829,8 @@ pub fn range<A: Add<A, A> + Ord + Clone + One>(start: A, stop: A) -> Range<A> {\n     Range{state: start, stop: stop, one: One::one()}\n }\n \n-impl<A: Add<A, A> + Ord + Clone> Iterator<A> for Range<A> {\n+// FIXME: #10414: Unfortunate type bound\n+impl<A: Add<A, A> + Ord + Clone + ToPrimitive> Iterator<A> for Range<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         if self.state < self.stop {\n@@ -1841,13 +1842,42 @@ impl<A: Add<A, A> + Ord + Clone> Iterator<A> for Range<A> {\n         }\n     }\n \n-    // FIXME: #8606 Implement size_hint() on Range\n-    // Blocked on #8605 Need numeric trait for converting to `Option<uint>`\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        // This first checks if the elements are representable as i64. If they aren't, try u64 (to\n+        // handle cases like range(huge, huger)). We don't use uint/int because the difference of\n+        // the i64/u64 might lie within their range.\n+        let bound = match self.state.to_i64() {\n+            Some(a) => {\n+                let sz = self.stop.to_i64().map(|b| b.checked_sub(&a));\n+                match sz {\n+                    Some(Some(bound)) => bound.to_uint(),\n+                    _ => None,\n+                }\n+            },\n+            None => match self.state.to_u64() {\n+                Some(a) => {\n+                    let sz = self.stop.to_u64().map(|b| b.checked_sub(&a));\n+                    match sz {\n+                        Some(Some(bound)) => bound.to_uint(),\n+                        _ => None\n+                    }\n+                },\n+                None => None\n+            }\n+        };\n+\n+        match bound {\n+            Some(b) => (b, Some(b)),\n+            // Standard fallback for unbounded/unrepresentable bounds\n+            None => (0, None)\n+        }\n+    }\n }\n \n /// `Integer` is required to ensure the range will be the same regardless of\n /// the direction it is consumed.\n-impl<A: Integer + Ord + Clone> DoubleEndedIterator<A> for Range<A> {\n+impl<A: Integer + Ord + Clone + ToPrimitive> DoubleEndedIterator<A> for Range<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n         if self.stop > self.state {\n@@ -1868,11 +1898,12 @@ pub struct RangeInclusive<A> {\n \n /// Return an iterator over the range [start, stop]\n #[inline]\n-pub fn range_inclusive<A: Add<A, A> + Ord + Clone + One>(start: A, stop: A) -> RangeInclusive<A> {\n+pub fn range_inclusive<A: Add<A, A> + Ord + Clone + One + ToPrimitive>(start: A, stop: A)\n+    -> RangeInclusive<A> {\n     RangeInclusive{range: range(start, stop), done: false}\n }\n \n-impl<A: Add<A, A> + Eq + Ord + Clone> Iterator<A> for RangeInclusive<A> {\n+impl<A: Add<A, A> + Eq + Ord + Clone + ToPrimitive> Iterator<A> for RangeInclusive<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         match self.range.next() {\n@@ -1904,7 +1935,8 @@ impl<A: Add<A, A> + Eq + Ord + Clone> Iterator<A> for RangeInclusive<A> {\n     }\n }\n \n-impl<A: Sub<A, A> + Integer + Ord + Clone> DoubleEndedIterator<A> for RangeInclusive<A> {\n+impl<A: Sub<A, A> + Integer + Ord + Clone + ToPrimitive> DoubleEndedIterator<A>\n+    for RangeInclusive<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n         if self.range.stop > self.range.state {\n@@ -2184,6 +2216,7 @@ mod tests {\n \n     use cmp;\n     use uint;\n+    use num;\n \n     #[test]\n     fn test_counter_from_iter() {\n@@ -2801,12 +2834,51 @@ mod tests {\n \n     #[test]\n     fn test_range() {\n+        /// A mock type to check Range when ToPrimitive returns None\n+        struct Foo;\n+\n+        impl ToPrimitive for Foo {\n+            fn to_i64(&self) -> Option<i64> { None }\n+            fn to_u64(&self) -> Option<u64> { None }\n+        }\n+\n+        impl Add<Foo, Foo> for Foo {\n+            fn add(&self, _: &Foo) -> Foo {\n+                Foo\n+            }\n+        }\n+\n+        impl Ord for Foo {\n+            fn lt(&self, _: &Foo) -> bool {\n+                false\n+            }\n+        }\n+\n+        impl Clone for Foo {\n+            fn clone(&self) -> Foo {\n+                Foo\n+            }\n+        }\n+\n+        impl num::One for Foo {\n+            fn one() -> Foo {\n+                Foo\n+            }\n+        }\n+\n         assert_eq!(range(0i, 5).collect::<~[int]>(), ~[0i, 1, 2, 3, 4]);\n+        assert_eq!(range(-10i, -1).collect::<~[int]>(), ~[-10, -9, -8, -7, -6, -5, -4, -3, -2]);\n         assert_eq!(range(0i, 5).invert().collect::<~[int]>(), ~[4, 3, 2, 1, 0]);\n         assert_eq!(range(200, -5).collect::<~[int]>(), ~[]);\n         assert_eq!(range(200, -5).invert().collect::<~[int]>(), ~[]);\n         assert_eq!(range(200, 200).collect::<~[int]>(), ~[]);\n         assert_eq!(range(200, 200).invert().collect::<~[int]>(), ~[]);\n+\n+        assert_eq!(range(0i, 100).size_hint(), (100, Some(100)));\n+        // this test is only meaningful when sizeof uint < sizeof u64\n+        assert_eq!(range(uint::max_value - 1, uint::max_value).size_hint(), (1, Some(1)));\n+        assert_eq!(range(-10i, -1).size_hint(), (9, Some(9)));\n+        assert_eq!(range(Foo, Foo).size_hint(), (0, None));\n     }\n \n     #[test]"}]}