{"sha": "b968c8e6cd362567bf0047a96d261691dfca43e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5NjhjOGU2Y2QzNjI1NjdiZjAwNDdhOTZkMjYxNjkxZGZjYTQzZTg=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-13T21:39:28Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-13T22:14:17Z"}, "message": "Name types after their modules instead of 't'", "tree": {"sha": "9cec3e42976bef8815df2a5710083d2bb518b651", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9cec3e42976bef8815df2a5710083d2bb518b651"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b968c8e6cd362567bf0047a96d261691dfca43e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b968c8e6cd362567bf0047a96d261691dfca43e8", "html_url": "https://github.com/rust-lang/rust/commit/b968c8e6cd362567bf0047a96d261691dfca43e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b968c8e6cd362567bf0047a96d261691dfca43e8/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a38ccf12547b1bdb37dce3c7edca5b95a898326a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a38ccf12547b1bdb37dce3c7edca5b95a898326a", "html_url": "https://github.com/rust-lang/rust/commit/a38ccf12547b1bdb37dce3c7edca5b95a898326a"}], "stats": {"total": 379, "additions": 190, "deletions": 189}, "files": [{"sha": "a61021237116c29963d69b4d224779f7a6b87faf", "filename": "doc/tutorial.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b968c8e6cd362567bf0047a96d261691dfca43e8/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/b968c8e6cd362567bf0047a96d261691dfca43e8/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=b968c8e6cd362567bf0047a96d261691dfca43e8", "patch": "@@ -1540,11 +1540,11 @@ You can then declare a function to take a `circular_buf<u8>` or return\n an `option<str>`, or even an `option<T>` if the function itself is\n generic.\n \n-The `option` type given above exists in the core library as\n-`option::t`, and is the way Rust programs express the thing that in C\n-would be a nullable pointer. The nice part is that you have to\n-explicitly unpack an `option` type, so accidental null pointer\n-dereferences become impossible.\n+The `option` type given above exists in the core library and is the\n+way Rust programs express the thing that in C would be a nullable\n+pointer. The nice part is that you have to explicitly unpack an\n+`option` type, so accidental null pointer dereferences become\n+impossible.\n \n ## Type-inference and generics\n \n@@ -1562,7 +1562,7 @@ you really want to have such a statement, you'll have to write it like\n this:\n \n ~~~~\n-let n2: option::t<int> = option::none;\n+let n2: option<int> = option::none;\n // or\n let n = option::none::<int>;\n ~~~~"}, {"sha": "1572972ffdf6acb44b6c690d61bb46d4b0a8e3c1", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=b968c8e6cd362567bf0047a96d261691dfca43e8", "patch": "@@ -167,7 +167,7 @@ fn recv_<T: send>(p: *rust_port) -> T {\n #[doc = \"Receive on one of two ports\"]\n fn select2<A: send, B: send>(\n     p_a: port<A>, p_b: port<B>\n-) -> either::t<A, B> unsafe {\n+) -> either<A, B> unsafe {\n \n     fn select(dptr: **rust_port, ports: **rust_port,\n               n_ports: libc::size_t, yield: *libc::uintptr_t) {"}, {"sha": "5dfb2522f08ead7d50600171872058065f7a6533", "filename": "src/libcore/core.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Flibcore%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Flibcore%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rs?ref=b968c8e6cd362567bf0047a96d261691dfca43e8", "patch": "@@ -3,7 +3,9 @@\n // Export various ubiquitous types, constructors, methods.\n \n import option::{some, none};\n-import option = option::t;\n+import option = option::option;\n+import either = either::either;\n+import result = result::result;\n import path = path::path;\n import vec::vec_len;\n export path, option, some, none, vec_len, unreachable;"}, {"sha": "a77f19af4e1e73b1405d35bb700bd5d60c035eb6", "filename": "src/libcore/either.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=b968c8e6cd362567bf0047a96d261691dfca43e8", "patch": "@@ -1,13 +1,13 @@\n #[doc = \"A type that represents one of two alternatives\"];\n \n #[doc = \"The either type\"]\n-enum t<T, U> {\n+enum either<T, U> {\n     left(T),\n     right(U)\n }\n \n fn either<T, U, V>(f_left: fn(T) -> V,\n-                   f_right: fn(U) -> V, value: t<T, U>) -> V {\n+                   f_right: fn(U) -> V, value: either<T, U>) -> V {\n     #[doc = \"\n     Applies a function based on the given either value\n \n@@ -19,27 +19,27 @@ fn either<T, U, V>(f_left: fn(T) -> V,\n     alt value { left(l) { f_left(l) } right(r) { f_right(r) } }\n }\n \n-fn lefts<T: copy, U>(eithers: [t<T, U>]) -> [T] {\n+fn lefts<T: copy, U>(eithers: [either<T, U>]) -> [T] {\n     #[doc = \"Extracts from a vector of either all the left values\"];\n \n     let mut result: [T] = [];\n-    for elt: t<T, U> in eithers {\n+    for elt: either<T, U> in eithers {\n         alt elt { left(l) { result += [l]; } _ {/* fallthrough */ } }\n     }\n     ret result;\n }\n \n-fn rights<T, U: copy>(eithers: [t<T, U>]) -> [U] {\n+fn rights<T, U: copy>(eithers: [either<T, U>]) -> [U] {\n     #[doc = \"Extracts from a vector of either all the right values\"];\n \n     let mut result: [U] = [];\n-    for elt: t<T, U> in eithers {\n+    for elt: either<T, U> in eithers {\n         alt elt { right(r) { result += [r]; } _ {/* fallthrough */ } }\n     }\n     ret result;\n }\n \n-fn partition<T: copy, U: copy>(eithers: [t<T, U>])\n+fn partition<T: copy, U: copy>(eithers: [either<T, U>])\n     -> {lefts: [T], rights: [U]} {\n     #[doc = \"\n     Extracts from a vector of either all the left values and right values\n@@ -50,13 +50,13 @@ fn partition<T: copy, U: copy>(eithers: [t<T, U>])\n \n     let mut lefts: [T] = [];\n     let mut rights: [U] = [];\n-    for elt: t<T, U> in eithers {\n+    for elt: either<T, U> in eithers {\n         alt elt { left(l) { lefts += [l]; } right(r) { rights += [r]; } }\n     }\n     ret {lefts: lefts, rights: rights};\n }\n \n-pure fn flip<T: copy, U: copy>(eith: t<T, U>) -> t<U, T> {\n+pure fn flip<T: copy, U: copy>(eith: either<T, U>) -> either<U, T> {\n     #[doc = \"Flips between left and right of a given either\"];\n \n     alt eith {\n@@ -65,7 +65,8 @@ pure fn flip<T: copy, U: copy>(eith: t<T, U>) -> t<U, T> {\n     }\n }\n \n-pure fn to_result<T: copy, U: copy>(eith: t<T, U>) -> result::t<U, T> {\n+pure fn to_result<T: copy, U: copy>(\n+    eith: either<T, U>) -> result<U, T> {\n     #[doc = \"\n     Converts either::t to a result::t\n \n@@ -79,13 +80,13 @@ pure fn to_result<T: copy, U: copy>(eith: t<T, U>) -> result::t<U, T> {\n     }\n }\n \n-pure fn is_left<T, U>(eith: t<T, U>) -> bool {\n+pure fn is_left<T, U>(eith: either<T, U>) -> bool {\n     #[doc = \"Checks whether the given value is a left\"];\n \n     alt eith { left(_) { true } _ { false } }\n }\n \n-pure fn is_right<T, U>(eith: t<T, U>) -> bool {\n+pure fn is_right<T, U>(eith: either<T, U>) -> bool {\n     #[doc = \"Checks whether the given value is a right\"];\n \n     alt eith { right(_) { true } _ { false } }\n@@ -116,14 +117,14 @@ fn test_lefts() {\n \n #[test]\n fn test_lefts_none() {\n-    let input: [t<int, int>] = [right(10), right(10)];\n+    let input: [either<int, int>] = [right(10), right(10)];\n     let result = lefts(input);\n     assert (vec::len(result) == 0u);\n }\n \n #[test]\n fn test_lefts_empty() {\n-    let input: [t<int, int>] = [];\n+    let input: [either<int, int>] = [];\n     let result = lefts(input);\n     assert (vec::len(result) == 0u);\n }\n@@ -137,14 +138,14 @@ fn test_rights() {\n \n #[test]\n fn test_rights_none() {\n-    let input: [t<int, int>] = [left(10), left(10)];\n+    let input: [either<int, int>] = [left(10), left(10)];\n     let result = rights(input);\n     assert (vec::len(result) == 0u);\n }\n \n #[test]\n fn test_rights_empty() {\n-    let input: [t<int, int>] = [];\n+    let input: [either<int, int>] = [];\n     let result = rights(input);\n     assert (vec::len(result) == 0u);\n }\n@@ -162,23 +163,23 @@ fn test_partition() {\n \n #[test]\n fn test_partition_no_lefts() {\n-    let input: [t<int, int>] = [right(10), right(11)];\n+    let input: [either<int, int>] = [right(10), right(11)];\n     let result = partition(input);\n     assert (vec::len(result.lefts) == 0u);\n     assert (vec::len(result.rights) == 2u);\n }\n \n #[test]\n fn test_partition_no_rights() {\n-    let input: [t<int, int>] = [left(10), left(11)];\n+    let input: [either<int, int>] = [left(10), left(11)];\n     let result = partition(input);\n     assert (vec::len(result.lefts) == 2u);\n     assert (vec::len(result.rights) == 0u);\n }\n \n #[test]\n fn test_partition_empty() {\n-    let input: [t<int, int>] = [];\n+    let input: [either<int, int>] = [];\n     let result = partition(input);\n     assert (vec::len(result.lefts) == 0u);\n     assert (vec::len(result.rights) == 0u);"}, {"sha": "5b9d090db4f5692ef3eca7f11a0100cd4674d803", "filename": "src/libcore/f32.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Flibcore%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Flibcore%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ff32.rs?ref=b968c8e6cd362567bf0047a96d261691dfca43e8", "patch": "@@ -20,8 +20,6 @@ export lgamma, ln, log_radix, ln1p, log10, log2, ilog_radix;\n export modf, pow, round, sin, sinh, sqrt, tan, tanh, tgamma, trunc;\n export signbit;\n \n-type t = f32;\n-\n // These are not defined inside consts:: for consistency with\n // the integer types\n "}, {"sha": "7cc2846a4212c64d73921eed63be6ea632bbd64b", "filename": "src/libcore/f64.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Flibcore%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Flibcore%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ff64.rs?ref=b968c8e6cd362567bf0047a96d261691dfca43e8", "patch": "@@ -21,8 +21,6 @@ export modf, pow, round, sin, sinh, sqrt, tan, tanh, tgamma, trunc;\n export signbit;\n export epsilon;\n \n-type t = f64;\n-\n // These are not defined inside consts:: for consistency with\n // the integer types\n "}, {"sha": "e9aa803e1371e6ac3ef257db5ebf9651f3ac2ad7", "filename": "src/libcore/float.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=b968c8e6cd362567bf0047a96d261691dfca43e8", "patch": "@@ -26,8 +26,6 @@ export j0, j1, jn, y0, y1, yn;\n import m_float = f64;\n import f64::*;\n \n-type t = float;\n-\n /**\n  * Section: String Conversions\n  */"}, {"sha": "7d2ce8ef44da1915e194cb7fa52dd4b533b12edb", "filename": "src/libcore/future.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Flibcore%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Flibcore%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture.rs?ref=b968c8e6cd362567bf0047a96d261691dfca43e8", "patch": "@@ -20,8 +20,6 @@ export get;\n export with;\n export spawn;\n \n-import either = either::t;\n-\n #[doc = \"The future type\"]\n enum future<A> = {\n     mutable v: either<@A, fn@() -> A>"}, {"sha": "e28876f2134e3e8706b8d4bd699deee0c73f4e33", "filename": "src/libcore/io.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=b968c8e6cd362567bf0047a96d261691dfca43e8", "patch": "@@ -218,7 +218,7 @@ fn FILE_reader(f: *libc::FILE, cleanup: bool) -> reader {\n \n fn stdin() -> reader { rustrt::rust_get_stdin() as reader }\n \n-fn file_reader(path: str) -> result::t<reader, str> {\n+fn file_reader(path: str) -> result<reader, str> {\n     let f = os::as_c_charp(path, {|pathbuf|\n         os::as_c_charp(\"r\", {|modebuf|\n             libc::fopen(pathbuf, modebuf)\n@@ -374,7 +374,7 @@ fn fd_writer(fd: fd_t, cleanup: bool) -> writer {\n \n \n fn mk_file_writer(path: str, flags: [fileflag])\n-    -> result::t<writer, str> {\n+    -> result<writer, str> {\n \n     #[cfg(target_os = \"win32\")]\n     fn wb() -> c_int { (O_WRONLY | O_BINARY) as c_int }\n@@ -487,13 +487,13 @@ impl writer_util for writer {\n     fn write_u8(n: u8) { self.write([n]) }\n }\n \n-fn file_writer(path: str, flags: [fileflag]) -> result::t<writer, str> {\n+fn file_writer(path: str, flags: [fileflag]) -> result<writer, str> {\n     result::chain(mk_file_writer(path, flags), { |w| result::ok(w)})\n }\n \n \n // FIXME: fileflags\n-fn buffered_file_writer(path: str) -> result::t<writer, str> {\n+fn buffered_file_writer(path: str) -> result<writer, str> {\n     let f = os::as_c_charp(path) {|pathbuf|\n         os::as_c_charp(\"w\") {|modebuf|\n             libc::fopen(pathbuf, modebuf)\n@@ -581,15 +581,15 @@ fn seek_in_buf(offset: int, pos: uint, len: uint, whence: seek_style) ->\n     ret bpos as uint;\n }\n \n-fn read_whole_file_str(file: str) -> result::t<str, str> {\n+fn read_whole_file_str(file: str) -> result<str, str> {\n     result::chain(read_whole_file(file), { |bytes|\n         result::ok(str::from_bytes(bytes))\n     })\n }\n \n // FIXME implement this in a low-level way. Going through the abstractions is\n // pointless.\n-fn read_whole_file(file: str) -> result::t<[u8], str> {\n+fn read_whole_file(file: str) -> result<[u8], str> {\n     result::chain(file_reader(file), { |rdr|\n         result::ok(rdr.read_whole_stream())\n     })"}, {"sha": "02957cc9f3bc5e079bbef0ddf7bd2b34c79a8aec", "filename": "src/libcore/option.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=b968c8e6cd362567bf0047a96d261691dfca43e8", "patch": "@@ -8,12 +8,12 @@ languages you might use a nullable type, in Rust you would use an option type.\n \"];\n \n #[doc = \"The option type\"]\n-enum t<T> {\n+enum option<T> {\n     none,\n     some(T),\n }\n \n-pure fn get<T: copy>(opt: t<T>) -> T {\n+pure fn get<T: copy>(opt: option<T>) -> T {\n     #[doc = \"\n     Gets the value out of an option\n \n@@ -25,13 +25,13 @@ pure fn get<T: copy>(opt: t<T>) -> T {\n     alt opt { some(x) { ret x; } none { fail \"option none\"; } }\n }\n \n-fn map<T, U: copy>(opt: t<T>, f: fn(T) -> U) -> t<U> {\n+fn map<T, U: copy>(opt: option<T>, f: fn(T) -> U) -> option<U> {\n     #[doc = \"Maps a `some` value from one type to another\"];\n \n     alt opt { some(x) { some(f(x)) } none { none } }\n }\n \n-fn chain<T, U>(opt: t<T>, f: fn(T) -> t<U>) -> t<U> {\n+fn chain<T, U>(opt: option<T>, f: fn(T) -> option<U>) -> option<U> {\n     #[doc = \"\n     Update an optional value by optionally running its content through a\n     function that returns an option.\n@@ -40,37 +40,37 @@ fn chain<T, U>(opt: t<T>, f: fn(T) -> t<U>) -> t<U> {\n     alt opt { some(x) { f(x) } none { none } }\n }\n \n-pure fn is_none<T>(opt: t<T>) -> bool {\n+pure fn is_none<T>(opt: option<T>) -> bool {\n     #[doc = \"Returns true if the option equals `none`\"];\n \n     alt opt { none { true } some(_) { false } }\n }\n \n-pure fn is_some<T>(opt: t<T>) -> bool {\n+pure fn is_some<T>(opt: option<T>) -> bool {\n     #[doc = \"Returns true if the option contains some value\"];\n \n     !is_none(opt)\n }\n \n-pure fn from_maybe<T: copy>(def: T, opt: t<T>) -> T {\n+pure fn from_maybe<T: copy>(def: T, opt: option<T>) -> T {\n     #[doc = \"Returns the contained value or a default\"];\n \n     alt opt { some(x) { x } none { def } }\n }\n \n-fn maybe<T, U: copy>(def: U, opt: t<T>, f: fn(T) -> U) -> U {\n+fn maybe<T, U: copy>(def: U, opt: option<T>, f: fn(T) -> U) -> U {\n     #[doc = \"Applies a function to the contained value or returns a default\"];\n \n     alt opt { none { def } some(t) { f(t) } }\n }\n \n-fn may<T>(opt: t<T>, f: fn(T)) {\n+fn may<T>(opt: option<T>, f: fn(T)) {\n     #[doc = \"Performs an operation on the contained value or does nothing\"];\n \n     alt opt { none { } some(t) { f(t); } }\n }\n \n-fn unwrap<T>(-opt: t<T>) -> T unsafe {\n+fn unwrap<T>(-opt: option<T>) -> T unsafe {\n     #[doc = \"\n     Moves a value out of an option type and returns it.\n "}, {"sha": "1b1474d23fd2008cab80e174f67b8df7141c67ba", "filename": "src/libcore/os.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=b968c8e6cd362567bf0047a96d261691dfca43e8", "patch": "@@ -21,7 +21,6 @@ import libc::{c_char, c_void, c_int, c_uint, size_t, ssize_t,\n import libc::{close, fclose};\n \n import option::{some, none};\n-import option = option::t;\n \n import getcwd = rustrt::rust_getcwd;\n import consts::*;"}, {"sha": "a8ba34b2f3a2067c2fed48e9a453497754d9a388", "filename": "src/libcore/result.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=b968c8e6cd362567bf0047a96d261691dfca43e8", "patch": "@@ -1,7 +1,7 @@\n #[doc = \"A type representing either success or failure\"];\n \n #[doc = \"The result type\"]\n-enum t<T, U> {\n+enum result<T, U> {\n     #[doc = \"Contains the successful result value\"]\n     ok(T),\n     #[doc = \"Contains the error value\"]\n@@ -15,7 +15,7 @@ Get the value out of a successful result\n \n If the result is an error\n \"]\n-fn get<T: copy, U>(res: t<T, U>) -> T {\n+fn get<T: copy, U>(res: result<T, U>) -> T {\n     alt res {\n       ok(t) { t }\n       err(_) {\n@@ -33,7 +33,7 @@ Get the value out of an error result\n \n If the result is not an error\n \"]\n-fn get_err<T, U: copy>(res: t<T, U>) -> U {\n+fn get_err<T, U: copy>(res: result<T, U>) -> U {\n     alt res {\n       err(u) { u }\n       ok(_) {\n@@ -43,15 +43,15 @@ fn get_err<T, U: copy>(res: t<T, U>) -> U {\n }\n \n #[doc = \"Returns true if the result is `ok`\"]\n-pure fn success<T, U>(res: t<T, U>) -> bool {\n+pure fn success<T, U>(res: result<T, U>) -> bool {\n     alt res {\n       ok(_) { true }\n       err(_) { false }\n     }\n }\n \n #[doc = \"Returns true if the result is `error`\"]\n-pure fn failure<T, U>(res: t<T, U>) -> bool {\n+pure fn failure<T, U>(res: result<T, U>) -> bool {\n     !success(res)\n }\n \n@@ -61,7 +61,7 @@ Convert to the `either` type\n `ok` result variants are converted to `either::right` variants, `err`\n result variants are converted to `either::left`.\n \"]\n-pure fn to_either<T: copy, U: copy>(res: t<U, T>) -> either::t<T, U> {\n+pure fn to_either<T: copy, U: copy>(res: result<U, T>) -> either<T, U> {\n     alt res {\n       ok(res) { either::right(res) }\n       err(fail_) { either::left(fail_) }\n@@ -81,8 +81,8 @@ Example:\n         ok(parse_buf(buf))\n     }\n \"]\n-fn chain<T, U: copy, V: copy>(res: t<T, V>, op: fn(T) -> t<U, V>)\n-    -> t<U, V> {\n+fn chain<T, U: copy, V: copy>(res: result<T, V>, op: fn(T) -> result<U, V>)\n+    -> result<U, V> {\n     alt res {\n       ok(t) { op(t) }\n       err(e) { err(e) }\n@@ -91,11 +91,13 @@ fn chain<T, U: copy, V: copy>(res: t<T, V>, op: fn(T) -> t<U, V>)\n \n #[cfg(test)]\n mod tests {\n-    fn op1() -> result::t<int, str> { result::ok(666) }\n+    fn op1() -> result::result<int, str> { result::ok(666) }\n \n-    fn op2(&&i: int) -> result::t<uint, str> { result::ok(i as uint + 1u) }\n+    fn op2(&&i: int) -> result::result<uint, str> {\n+        result::ok(i as uint + 1u)\n+    }\n \n-    fn op3() -> result::t<int, str> { result::err(\"sadface\") }\n+    fn op3() -> result::result<int, str> { result::err(\"sadface\") }\n \n     #[test]\n     fn chain_success() {"}, {"sha": "c673fbf9b84222c441e424c493e7e6ea9f875565", "filename": "src/libcore/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=b968c8e6cd362567bf0047a96d261691dfca43e8", "patch": "@@ -406,7 +406,7 @@ fn spawn_sched(mode: sched_mode, +f: fn~()) {\n     run(builder, f);\n }\n \n-fn try<T:send>(+f: fn~() -> T) -> result::t<T,()> {\n+fn try<T:send>(+f: fn~() -> T) -> result<T,()> {\n     #[doc = \"\n     Execute a function in another task and return either the return value\n     of the function or result::err."}, {"sha": "28ee44690eed764d2b95cdb03ee6722d3bfe688f", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=b968c8e6cd362567bf0047a96d261691dfca43e8", "patch": "@@ -25,7 +25,7 @@ form -- for instance, to pass memory back into C -- but great care must be\n taken to ensure that a reference to the c_vec::t is still held if needed.\n \"];\n \n-export t;\n+export c_vec;\n export c_vec, c_vec_with_dtor;\n export get, set;\n export len;\n@@ -37,8 +37,8 @@ The type representing a native chunk of memory\n Wrapped in a enum for opacity; FIXME #818 when it is possible to have\n truly opaque types, this should be revisited.\n \"]\n-enum t<T> {\n-    t({ base: *mutable T, len: uint, rsrc: @dtor_res})\n+enum c_vec<T> {\n+    c_vec_({ base: *mutable T, len: uint, rsrc: @dtor_res})\n }\n \n resource dtor_res(dtor: option<fn@()>) {\n@@ -53,22 +53,23 @@ resource dtor_res(dtor: option<fn@()>) {\n  */\n \n #[doc = \"\n-Create a c_vec::t from a native buffer with a given length.\n+Create a `c_vec` from a native buffer with a given length.\n \n # Arguments\n \n * base - A native pointer to a buffer\n * len - The number of elements in the buffer\n \"]\n-unsafe fn c_vec<T>(base: *mutable T, len: uint) -> t<T> {\n-    ret t({base: base,\n-           len: len,\n-           rsrc: @dtor_res(option::none)\n-          });\n+unsafe fn c_vec<T>(base: *mutable T, len: uint) -> c_vec<T> {\n+    ret c_vec_({\n+        base: base,\n+        len: len,\n+        rsrc: @dtor_res(option::none)\n+    });\n }\n \n #[doc = \"\n-Create a c_vec::t from a native buffer, with a given length,\n+Create a `c_vec` from a native buffer, with a given length,\n and a function to run upon destruction.\n \n # Arguments\n@@ -79,11 +80,12 @@ and a function to run upon destruction.\n          for freeing the buffer, etc.\n \"]\n unsafe fn c_vec_with_dtor<T>(base: *mutable T, len: uint, dtor: fn@())\n-  -> t<T> {\n-    ret t({base: base,\n-           len: len,\n-           rsrc: @dtor_res(option::some(dtor))\n-          });\n+  -> c_vec<T> {\n+    ret c_vec_({\n+        base: base,\n+        len: len,\n+        rsrc: @dtor_res(option::some(dtor))\n+    });\n }\n \n /*\n@@ -95,7 +97,7 @@ Retrieves an element at a given index\n \n Fails if `ofs` is greater or equal to the length of the vector\n \"]\n-fn get<T: copy>(t: t<T>, ofs: uint) -> T {\n+fn get<T: copy>(t: c_vec<T>, ofs: uint) -> T {\n     assert ofs < len(t);\n     ret unsafe { *ptr::mut_offset((*t).base, ofs) };\n }\n@@ -105,7 +107,7 @@ Sets the value of an element at a given index\n \n Fails if `ofs` is greater or equal to the length of the vector\n \"]\n-fn set<T: copy>(t: t<T>, ofs: uint, v: T) {\n+fn set<T: copy>(t: c_vec<T>, ofs: uint, v: T) {\n     assert ofs < len(t);\n     unsafe { *ptr::mut_offset((*t).base, ofs) = v };\n }\n@@ -115,20 +117,20 @@ fn set<T: copy>(t: t<T>, ofs: uint, v: T) {\n  */\n \n #[doc = \"Returns the length of the vector\"]\n-fn len<T>(t: t<T>) -> uint {\n+fn len<T>(t: c_vec<T>) -> uint {\n     ret (*t).len;\n }\n \n #[doc = \"Returns a pointer to the first element of the vector\"]\n-unsafe fn ptr<T>(t: t<T>) -> *mutable T {\n+unsafe fn ptr<T>(t: c_vec<T>) -> *mutable T {\n     ret (*t).base;\n }\n \n #[cfg(test)]\n mod tests {\n     import libc::*;\n \n-    fn malloc(n: size_t) -> t<u8> {\n+    fn malloc(n: size_t) -> c_vec<u8> {\n         let mem = libc::malloc(n);\n \n         assert mem as int != 0;"}, {"sha": "e2565d673068ee2bcf85c1c3cab0190abdee19e8", "filename": "src/libstd/four.rs", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Flibstd%2Ffour.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Flibstd%2Ffour.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffour.rs?ref=b968c8e6cd362567bf0047a96d261691dfca43e8", "patch": "@@ -12,7 +12,7 @@ on current cpus.\n \n import tri;\n \n-export t, none, true, false, both;\n+export four, none, true, false, both;\n export not, and, or, xor, implies, implies_materially;\n export eq, ne, is_true, is_false;\n export from_str, to_str, all_values, to_trit, to_bit;\n@@ -22,89 +22,91 @@ The type of fourrternary logic values\n \n It may be thought of as  tuple `(y, x)` of two bools\n \"]\n-type t = u8;\n+type four = u8;\n \n const b0: u8  = 1u8;\n const b1: u8  = 2u8;\n const b01: u8 = 3u8;\n \n #[doc = \"Logic value `(0, 0)` for bottom (neither true or false)\"]\n-const none: t  = 0u8;\n+const none: four  = 0u8;\n \n #[doc = \"Logic value `(0, 1)` for truth\"]\n-const true: t  = 1u8;\n+const true: four  = 1u8;\n \n #[doc = \"Logic value `(1, 0)` for falsehood\"]\n-const false: t = 2u8;\n+const false: four = 2u8;\n \n #[doc = \"Logic value `(1, 1)` for top (both true and false)\"]\n-const both: t  = 3u8;\n+const both: four = 3u8;\n \n #[doc = \"\n Negation/Inverse\n \n Returns `'(v.y, v.x)`\n \"]\n-pure fn not(v: t) -> t { ((v << 1u8) | (v >> 1u8)) & b01 }\n+pure fn not(v: four) -> four { ((v << 1u8) | (v >> 1u8)) & b01 }\n \n #[doc = \"\n Conjunction\n \n Returns `(a.x | b.x, a.y & b.y)`\n \"]\n-pure fn and(a: t, b: t) -> t { ((a & b) & b0) | ((a | b) & b1) }\n+pure fn and(a: four, b: four) -> four { ((a & b) & b0) | ((a | b) & b1) }\n \n #[doc = \"\n Disjunction\n \n Returns `(a.x & b.x, a.y | b.y)`\n \"]\n-pure fn or(a: t, b: t) -> t { ((a | b) & b0) | ((a & b) & b1) }\n+pure fn or(a: four, b: four) -> four { ((a | b) & b0) | ((a & b) & b1) }\n \n #[doc = \"\n Classic exclusive or\n \n Returns `or(and(a, not(b)), and(not(a), b))`\n \"]\n-pure fn xor(a: t, b: t) -> t { or(and(a, not(b)), and(not(a), b)) }\n+pure fn xor(a: four, b: four) -> four { or(and(a, not(b)), and(not(a), b)) }\n \n #[doc = \"\n Strong implication (from `a` strongly follows `b`)\n \n Returns `( x1 & y2, !x1 | x2)`\n \"]\n-pure fn implies(a: t, b: t) -> t { ((a << 1u8) & b & b1) | (((!a) | b) & b0) }\n+pure fn implies(a: four, b: four) -> four {\n+    ((a << 1u8) & b & b1) | (((!a) | b) & b0)\n+}\n \n #[doc = \"\n Classic (material) implication in the logic\n (from `a` materially follows `b`)\n \n Returns `or(not(a), b)`\n \"]\n-pure fn implies_materially(a: t, b: t) -> t { or(not(a), b) }\n+pure fn implies_materially(a: four, b: four) -> four { or(not(a), b) }\n \n #[doc = \"\n Returns true if truth values `a` and `b` are indistinguishable in the logic\n \"]\n-pure fn eq(a: t, b: t) -> bool { a == b }\n+pure fn eq(a: four, b: four) -> bool { a == b }\n \n #[doc = \"\n Returns true if truth values `a` and `b` are distinguishable in the logic\n \"]\n-pure fn ne(a: t, b: t) -> bool { a != b }\n+pure fn ne(a: four, b: four) -> bool { a != b }\n \n #[doc = \"\n Returns true if `v` represents truth in the logic (is `true` or `both`)\n \"]\n-pure fn is_true(v: t) -> bool { (v & b0) != 0u8 }\n+pure fn is_true(v: four) -> bool { (v & b0) != 0u8 }\n \n #[doc = \"\n Returns true if `v` represents falsehood in the logic (is `false` or `none`)\n \"]\n-pure fn is_false(v: t) -> bool { (v & b0) == 0u8 }\n+pure fn is_false(v: four) -> bool { (v & b0) == 0u8 }\n \n #[doc = \"Parse logic value from `s`\"]\n-pure fn from_str(s: str) -> t {\n+pure fn from_str(s: str) -> four {\n     alt check s {\n       \"none\" { none }\n       \"false\" { four::false }\n@@ -114,7 +116,7 @@ pure fn from_str(s: str) -> t {\n }\n \n #[doc = \"Convert `v` into a string\"]\n-pure fn to_str(v: t) -> str {\n+pure fn to_str(v: four) -> str {\n     // FIXME replace with consts as soon as that works\n     alt check v {\n       0u8 { \"none\" }\n@@ -128,7 +130,7 @@ pure fn to_str(v: t) -> str {\n Iterates over all truth values by passing them to `blk` in an unspecified\n order\n \"]\n-fn all_values(blk: fn(v: t)) {\n+fn all_values(blk: fn(v: four)) {\n     blk(both);\n     blk(four::true);\n     blk(four::false);\n@@ -138,21 +140,21 @@ fn all_values(blk: fn(v: t)) {\n #[doc = \"\n Returns an `u8` whose first bit is set if `if_true(v)` holds\n \"]\n-fn to_bit(v: t) -> u8 { v & b0 }\n+fn to_bit(v: four) -> u8 { v & b0 }\n \n #[doc = \"\n Returns a trit of `v` (`both` and `none` are both coalesced into\n `trit::unknown`)\n \"]\n-fn to_trit(v: t) -> tri::t { v & (v ^ not(v)) }\n+fn to_trit(v: four) -> tri::tri { v & (v ^ not(v)) }\n \n #[cfg(test)]\n mod tests {\n \n-    fn eq1(a: four::t, b: four::t) -> bool { four::eq(a , b) }\n-    fn ne1(a: four::t, b: four::t) -> bool { four::ne(a , b) }\n+    fn eq1(a: four, b: four) -> bool { four::eq(a , b) }\n+    fn ne1(a: four, b: four) -> bool { four::ne(a , b) }\n \n-    fn eq2(a: four::t, b: four::t) -> bool { eq1( a, b ) && eq1( b, a ) }\n+    fn eq2(a: four, b: four) -> bool { eq1( a, b ) && eq1( b, a ) }\n \n     #[test]\n     fn test_four_req_eq() {\n@@ -190,7 +192,7 @@ mod tests {\n         }\n     }\n \n-    fn to_tup(v: four::t) -> (bool, bool) {\n+    fn to_tup(v: four) -> (bool, bool) {\n         alt check v {\n           0u8 { (false, false) }\n           1u8 { (false, true) }"}, {"sha": "8d6aade9fade9e4349bfdbdd70240d5f579a0ade", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=b968c8e6cd362567bf0047a96d261691dfca43e8", "patch": "@@ -45,7 +45,6 @@ name following -o, and accepts both -h and --help as optional flags.\n \n \"];\n \n-import core::result;\n import core::result::{err, ok};\n import core::option;\n import core::option::{some, none};\n@@ -159,7 +158,7 @@ fn fail_str(f: fail_) -> str {\n The result of parsing a command line with a set of options\n (result::t<match, fail_>)\n \"]\n-type result = result::t<match, fail_>;\n+type result = result::result<match, fail_>;\n \n #[doc = \"\n Parse command line arguments according to the provided options"}, {"sha": "4e197d30c95310dadfd721d52abbb3102e4d0ee6", "filename": "src/libstd/json.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=b968c8e6cd362567bf0047a96d261691dfca43e8", "patch": "@@ -133,11 +133,11 @@ impl parser for parser {\n         self.ch\n     }\n \n-    fn error<T>(msg: str) -> result::t<T, error> {\n+    fn error<T>(msg: str) -> result<T, error> {\n         err({ line: self.line, col: self.col, msg: msg })\n     }\n \n-    fn parse() -> result::t<json, error> {\n+    fn parse() -> result<json, error> {\n         alt self.parse_value() {\n           ok(value) {\n             // Skip trailing whitespaces.\n@@ -153,7 +153,7 @@ impl parser for parser {\n         }\n     }\n \n-    fn parse_value() -> result::t<json, error> {\n+    fn parse_value() -> result<json, error> {\n         self.parse_whitespace();\n \n         if self.eof() { ret self.error(\"EOF while parsing value\"); }\n@@ -179,7 +179,7 @@ impl parser for parser {\n         while char::is_whitespace(self.ch) { self.bump(); }\n     }\n \n-    fn parse_ident(ident: str, value: json) -> result::t<json, error> {\n+    fn parse_ident(ident: str, value: json) -> result<json, error> {\n         if str::all(ident, { |c| c == self.next_char() }) {\n             self.bump();\n             ok(value)\n@@ -188,7 +188,7 @@ impl parser for parser {\n         }\n     }\n \n-    fn parse_number() -> result::t<json, error> {\n+    fn parse_number() -> result<json, error> {\n         let neg = 1f;\n \n         if self.ch == '-' {\n@@ -218,7 +218,7 @@ impl parser for parser {\n         ok(num(neg * res))\n     }\n \n-    fn parse_integer() -> result::t<float, error> {\n+    fn parse_integer() -> result<float, error> {\n         let res = 0f;\n \n         alt self.ch {\n@@ -250,7 +250,7 @@ impl parser for parser {\n         ok(res)\n     }\n \n-    fn parse_decimal(res: float) -> result::t<float, error> {\n+    fn parse_decimal(res: float) -> result<float, error> {\n         self.bump();\n \n         // Make sure a digit follows the decimal place.\n@@ -276,7 +276,7 @@ impl parser for parser {\n         ok(res)\n     }\n \n-    fn parse_exponent(res: float) -> result::t<float, error> {\n+    fn parse_exponent(res: float) -> result<float, error> {\n         self.bump();\n \n         let res = res;\n@@ -317,7 +317,7 @@ impl parser for parser {\n         ok(res)\n     }\n \n-    fn parse_str() -> result::t<str, error> {\n+    fn parse_str() -> result<str, error> {\n         let escape = false;\n         let res = \"\";\n \n@@ -372,7 +372,7 @@ impl parser for parser {\n         self.error(\"EOF while parsing string\")\n     }\n \n-    fn parse_list() -> result::t<json, error> {\n+    fn parse_list() -> result<json, error> {\n         self.bump();\n         self.parse_whitespace();\n \n@@ -402,7 +402,7 @@ impl parser for parser {\n         };\n     }\n \n-    fn parse_object() -> result::t<json, error> {\n+    fn parse_object() -> result<json, error> {\n         self.bump();\n         self.parse_whitespace();\n \n@@ -454,7 +454,7 @@ impl parser for parser {\n }\n \n #[doc = \"Deserializes a json value from an io::reader\"]\n-fn from_reader(rdr: io::reader) -> result::t<json, error> {\n+fn from_reader(rdr: io::reader) -> result<json, error> {\n     let parser = {\n         rdr: rdr,\n         mutable ch: rdr.read_char(),\n@@ -466,7 +466,7 @@ fn from_reader(rdr: io::reader) -> result::t<json, error> {\n }\n \n #[doc = \"Deserializes a json value from a string\"]\n-fn from_str(s: str) -> result::t<json, error> {\n+fn from_str(s: str) -> result<json, error> {\n     io::with_str_reader(s, from_reader)\n }\n "}, {"sha": "d28912bae125a712cf58be26a5169e6fb843856a", "filename": "src/libstd/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=b968c8e6cd362567bf0047a96d261691dfca43e8", "patch": "@@ -58,7 +58,7 @@ fn test_main(args: [str], tests: [test_desc]) {\n \n type test_opts = {filter: option<str>, run_ignored: bool};\n \n-type opt_res = either::t<test_opts, str>;\n+type opt_res = either<test_opts, str>;\n \n // Parses command line arguments into test options\n fn parse_opts(args: [str]) -> opt_res {"}, {"sha": "95eea29dc7e336a5ccc28be4568f666b7e5a2f86", "filename": "src/libstd/tri.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Flibstd%2Ftri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Flibstd%2Ftri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftri.rs?ref=b968c8e6cd362567bf0047a96d261691dfca43e8", "patch": "@@ -10,44 +10,44 @@ all operations are done using bit operations which is fast\n on current cpus.\n \"];\n \n-export t, true, false, unknown;\n+export tri, true, false, unknown;\n export not, and, or, xor, implies, eq, ne, is_true, is_false;\n export from_str, to_str, all_values, to_bit;\n \n #[doc = \"The type of ternary logic values\"]\n-type t = u8;\n+type tri = u8;\n \n const b0: u8  = 1u8;\n const b1: u8  = 2u8;\n const b01: u8 = 3u8;\n \n #[doc = \"Logic value for unknown (maybe true xor maybe false)\"]\n-const unknown: t = 0u8;\n+const unknown: tri = 0u8;\n \n #[doc = \"Logic value for truth\"]\n-const true: t = 1u8;\n+const true: tri = 1u8;\n \n #[doc = \"Logic value for falsehood\"]\n-const false: t = 2u8;\n+const false: tri = 2u8;\n \n #[doc = \"Negation/Inverse\"]\n-pure fn not(v: t) -> t { ((v << 1u8) | (v >> 1u8)) & b01 }\n+pure fn not(v: tri) -> tri { ((v << 1u8) | (v >> 1u8)) & b01 }\n \n #[doc = \"Conjunction\"]\n-pure fn and(a: t, b: t) -> t { ((a | b) & b1) | ((a & b) & b0) }\n+pure fn and(a: tri, b: tri) -> tri { ((a | b) & b1) | ((a & b) & b0) }\n \n #[doc = \"Disjunction\"]\n-pure fn or(a: t, b: t) -> t { ((a & b) & b1) | ((a | b) & b0) }\n+pure fn or(a: tri, b: tri) -> tri { ((a & b) & b1) | ((a | b) & b0) }\n \n #[doc = \"Exclusive or\"]\n-pure fn xor(a: t, b: t) -> t {\n+pure fn xor(a: tri, b: tri) -> tri {\n     let anb = a & b;\n     let aob = a & not(b);\n     ret ((anb & b1) | (anb << 1u8) | (aob >> 1u8) | (aob & b0)) & b01;\n }\n \n #[doc = \"Classic implication, i.e. from `a` follows `b`\"]\n-pure fn implies(a: t, b: t) -> t {\n+pure fn implies(a: tri, b: tri) -> tri {\n     ret ((a & b1) >> 1u8) | (b & b0) | ((a << 1u8) & b & b1);\n }\n \n@@ -56,38 +56,38 @@ pure fn implies(a: t, b: t) -> t {\n \n true if truth values `a` and `b` are indistinguishable in the logic\n \"]\n-pure fn eq(a: t, b: t) -> bool {  a == b }\n+pure fn eq(a: tri, b: tri) -> bool {  a == b }\n \n #[doc = \"\n # Return value\n \n true if truth values `a` and `b` are distinguishable in the logic\n \"]\n-pure fn ne(a: t, b: t) -> bool { a != b }\n+pure fn ne(a: tri, b: tri) -> bool { a != b }\n \n #[doc = \"\n # Return value\n \n true if `v` represents truth in the logic\n \"]\n-pure fn is_true(v: t) -> bool { v == tri::true }\n+pure fn is_true(v: tri) -> bool { v == tri::true }\n \n #[doc = \"\n # Return value\n \n true if `v` represents false in the logic\n \"]\n-pure fn is_false(v: t) -> bool { v == tri::false }\n+pure fn is_false(v: tri) -> bool { v == tri::false }\n \n #[doc = \"\n # Return value\n \n true if `v` represents the unknown state in the logic\n \"]\n-pure fn is_unknown(v: t) -> bool { v == unknown }\n+pure fn is_unknown(v: tri) -> bool { v == unknown }\n \n #[doc = \"Parse logic value from `s`\"]\n-pure fn from_str(s: str) -> t {\n+pure fn from_str(s: str) -> tri {\n     alt check s {\n       \"unknown\" { unknown }\n       \"true\" { tri::true }\n@@ -96,7 +96,7 @@ pure fn from_str(s: str) -> t {\n }\n \n #[doc = \"Convert `v` into a string\"]\n-pure fn to_str(v: t) -> str {\n+pure fn to_str(v: tri) -> str {\n     // FIXME replace with consts as soon as that works\n     alt check v {\n       0u8 { \"unknown\" }\n@@ -109,7 +109,7 @@ pure fn to_str(v: t) -> str {\n Iterates over all truth values by passing them to `blk`\n in an unspecified order\n \"]\n-fn all_values(blk: fn(v: t)) {\n+fn all_values(blk: fn(v: tri)) {\n     blk(tri::false);\n     blk(unknown);\n     blk(tri::true);\n@@ -120,15 +120,17 @@ fn all_values(blk: fn(v: t)) {\n \n An u8 whose first bit is set if `if_true(v)` holds\n \"]\n-fn to_bit(v: t) -> u8 { v & b0 }\n+fn to_bit(v: tri) -> u8 { v & b0 }\n \n #[cfg(test)]\n mod tests {\n \n-    pure fn eq1(a: tri::t, b: tri::t) -> bool { tri::eq(a , b) }\n-    pure fn ne1(a: tri::t, b: tri::t) -> bool { tri::ne(a , b) }\n+    pure fn eq1(a: tri::tri, b: tri::tri) -> bool { tri::eq(a , b) }\n+    pure fn ne1(a: tri::tri, b: tri::tri) -> bool { tri::ne(a , b) }\n \n-    pure fn eq2(a: tri::t, b: tri::t) -> bool { eq1( a, b ) && eq1( b, a ) }\n+    pure fn eq2(a: tri::tri, b: tri::tri) -> bool {\n+        eq1( a, b ) && eq1( b, a )\n+    }\n \n     #[test]\n     fn test_eq2() {"}, {"sha": "9bd817fb36a9c0c42a3c6f5d46a4a18da3a1d2d0", "filename": "src/rustc/front/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Frustc%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Frustc%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fattr.rs?ref=b968c8e6cd362567bf0047a96d261691dfca43e8", "patch": "@@ -231,7 +231,7 @@ fn require_unique_names(sess: session, metas: [@ast::meta_item]) {\n     }\n }\n \n-fn native_abi(attrs: [ast::attribute]) -> either::t<str, ast::native_abi> {\n+fn native_abi(attrs: [ast::attribute]) -> either<str, ast::native_abi> {\n     ret alt attr::get_meta_item_value_str_by_name(attrs, \"abi\") {\n       option::none {\n         either::right(ast::native_abi_cdecl)"}, {"sha": "9292490ff6bedb1d3760e18202b73d23fc909726", "filename": "src/rustc/metadata/astencode_gen.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Frustc%2Fmetadata%2Fastencode_gen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Frustc%2Fmetadata%2Fastencode_gen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fastencode_gen.rs?ref=b968c8e6cd362567bf0047a96d261691dfca43e8", "patch": "@@ -261,7 +261,7 @@ fn serialize_20<S: std::serialization::serializer>(s: S, v: uint) {\n /*core::option::t<syntax::codemap::span>*/\n fn serialize_26<S: std::serialization::serializer>(s: S,\n                                                    v:\n-                                                       core::option::t<syntax::codemap::span>) {\n+                                                       core::option<syntax::codemap::span>) {\n     s.emit_enum(\"core::option::t\",\n \n                 /*syntax::codemap::span*/\n@@ -291,7 +291,7 @@ fn serialize_25<S: std::serialization::serializer>(s: S,\n                                                    v:\n                                                        {name: str,\n                                                         span:\n-                                                            core::option::t<syntax::codemap::span>,}) {\n+                                                            core::option<syntax::codemap::span>,}) {\n     s.emit_rec(/*str*//*core::option::t<syntax::codemap::span>*/\n                {||\n                    {\n@@ -311,7 +311,7 @@ fn serialize_24<S: std::serialization::serializer>(s: S,\n                                                         callie:\n                                                             {name: str,\n                                                              span:\n-                                                                 core::option::t<syntax::codemap::span>,},}) {\n+                                                                 core::option<syntax::codemap::span>,},}) {\n     s.emit_rec(/*syntax::codemap::span*/\n                /*{name: str,span: core::option::t<syntax::codemap::span>}*/\n                {||\n@@ -1269,7 +1269,7 @@ fn serialize_76<S: std::serialization::serializer>(s: S,\n /*core::option::t<@syntax::ast::expr>*/\n fn serialize_79<S: std::serialization::serializer>(s: S,\n                                                    v:\n-                                                       core::option::t<@syntax::ast::expr>) {\n+                                                       core::option<@syntax::ast::expr>) {\n     s.emit_enum(\"core::option::t\",\n \n                 /*@syntax::ast::expr*/\n@@ -1297,7 +1297,7 @@ fn serialize_79<S: std::serialization::serializer>(s: S,\n /*[core::option::t<@syntax::ast::expr>]*/\n fn serialize_80<S: std::serialization::serializer>(s: S,\n                                                    v:\n-                                                       [core::option::t<@syntax::ast::expr>]) {\n+                                                       [core::option<@syntax::ast::expr>]) {\n     s.emit_vec(vec::len(v), /*core::option::t<@syntax::ast::expr>*/\n                {||\n                    vec::iteri(v,\n@@ -1712,7 +1712,7 @@ fn serialize_85<S: std::serialization::serializer>(s: S,\n /*core::option::t<@syntax::ast::pat>*/\n fn serialize_112<S: std::serialization::serializer>(s: S,\n                                                     v:\n-                                                        core::option::t<@syntax::ast::pat>) {\n+                                                        core::option<@syntax::ast::pat>) {\n     s.emit_enum(\"core::option::t\",\n \n                 /*@syntax::ast::pat*/\n@@ -1973,7 +1973,7 @@ fn serialize_117<S: std::serialization::serializer>(s: S,\n /*core::option::t<syntax::ast::initializer>*/\n fn serialize_116<S: std::serialization::serializer>(s: S,\n                                                     v:\n-                                                        core::option::t<syntax::ast::initializer>) {\n+                                                        core::option<syntax::ast::initializer>) {\n     s.emit_enum(\"core::option::t\",\n \n                 /*syntax::ast::initializer*/\n@@ -3950,7 +3950,7 @@ fn serialize_159<S: std::serialization::serializer>(s: S,\n /*core::option::t<@syntax::ast::ty>*/\n fn serialize_161<S: std::serialization::serializer>(s: S,\n                                                     v:\n-                                                        core::option::t<@syntax::ast::ty>) {\n+                                                        core::option<@syntax::ast::ty>) {\n     s.emit_enum(\"core::option::t\",\n \n                 /*@syntax::ast::ty*/\n@@ -4471,7 +4471,7 @@ fn deserialize_20<S: std::serialization::deserializer>(s: S) -> uint {\n }\n /*core::option::t<syntax::codemap::span>*/\n fn deserialize_26<S: std::serialization::deserializer>(s: S) ->\n-   core::option::t<syntax::codemap::span> {\n+   core::option<syntax::codemap::span> {\n     s.read_enum(\"core::option::t\",\n \n \n@@ -4492,7 +4492,7 @@ fn deserialize_26<S: std::serialization::deserializer>(s: S) ->\n }\n /*{name: str,span: core::option::t<syntax::codemap::span>}*/\n fn deserialize_25<S: std::serialization::deserializer>(s: S) ->\n-   {name: str, span: core::option::t<syntax::codemap::span>,} {\n+   {name: str, span: core::option<syntax::codemap::span>,} {\n \n     s.read_rec(\n \n@@ -4513,7 +4513,7 @@ fn deserialize_25<S: std::serialization::deserializer>(s: S) ->\n /*{call_site: syntax::codemap::span,callie: {name: str,span: core::option::t<syntax::codemap::span>}}*/\n fn deserialize_24<S: std::serialization::deserializer>(s: S) ->\n    {call_site: syntax::codemap::span,\n-    callie: {name: str, span: core::option::t<syntax::codemap::span>,},} {\n+    callie: {name: str, span: core::option<syntax::codemap::span>,},} {\n \n     s.read_rec(\n \n@@ -5501,7 +5501,7 @@ fn deserialize_76<S: std::serialization::deserializer>(s: S) ->\n }\n /*core::option::t<@syntax::ast::expr>*/\n fn deserialize_79<S: std::serialization::deserializer>(s: S) ->\n-   core::option::t<@syntax::ast::expr> {\n+   core::option<@syntax::ast::expr> {\n     s.read_enum(\"core::option::t\",\n \n \n@@ -5522,7 +5522,7 @@ fn deserialize_79<S: std::serialization::deserializer>(s: S) ->\n }\n /*[core::option::t<@syntax::ast::expr>]*/\n fn deserialize_80<S: std::serialization::deserializer>(s: S) ->\n-   [core::option::t<@syntax::ast::expr>] {\n+   [core::option<@syntax::ast::expr>] {\n     s.read_vec(\n \n                /*core::option::t<@syntax::ast::expr>*/\n@@ -5886,7 +5886,7 @@ fn deserialize_85<S: std::serialization::deserializer>(s: S) ->\n }\n /*core::option::t<@syntax::ast::pat>*/\n fn deserialize_112<S: std::serialization::deserializer>(s: S) ->\n-   core::option::t<@syntax::ast::pat> {\n+   core::option<@syntax::ast::pat> {\n     s.read_enum(\"core::option::t\",\n \n \n@@ -6114,7 +6114,7 @@ fn deserialize_117<S: std::serialization::deserializer>(s: S) ->\n }\n /*core::option::t<syntax::ast::initializer>*/\n fn deserialize_116<S: std::serialization::deserializer>(s: S) ->\n-   core::option::t<syntax::ast::initializer> {\n+   core::option<syntax::ast::initializer> {\n     s.read_enum(\"core::option::t\",\n \n \n@@ -7890,7 +7890,7 @@ fn deserialize_159<S: std::serialization::deserializer>(s: S) ->\n }\n /*core::option::t<@syntax::ast::ty>*/\n fn deserialize_161<S: std::serialization::deserializer>(s: S) ->\n-   core::option::t<@syntax::ast::ty> {\n+   core::option<@syntax::ast::ty> {\n     s.read_enum(\"core::option::t\",\n \n "}, {"sha": "a6bc7cbb732b4dd3cdde42b207369cb563584f67", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=b968c8e6cd362567bf0047a96d261691dfca43e8", "patch": "@@ -183,7 +183,7 @@ fn allocate_cbox(bcx: block,\n     fn store_uniq_tydesc(bcx: block,\n                          cdata_ty: ty::t,\n                          box: ValueRef,\n-                         &ti: option::t<@tydesc_info>) -> block {\n+                         &ti: option<@tydesc_info>) -> block {\n         let ccx = bcx.ccx();\n         let bound_tydesc = GEPi(bcx, box, [0, abi::box_field_tydesc]);\n         let {bcx, val: td} = base::get_tydesc(bcx, cdata_ty, true, ti);"}, {"sha": "5f5ac939a228032477fbe170b907d29aec02cf8c", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=b968c8e6cd362567bf0047a96d261691dfca43e8", "patch": "@@ -1509,7 +1509,7 @@ fn arg_mode(cx: ctxt, a: arg) -> ast::rmode { resolved_mode(cx, a.mode) }\n \n // Unifies `m1` and `m2`.  Returns unified value or failure code.\n fn unify_mode(cx: ctxt, m1: ast::mode, m2: ast::mode)\n-    -> result::t<ast::mode, type_err> {\n+    -> result<ast::mode, type_err> {\n     alt (canon_mode(cx, m1), canon_mode(cx, m2)) {\n       (m1, m2) if (m1 == m2) {\n         result::ok(m1)\n@@ -1758,7 +1758,7 @@ mod unify {\n         };\n     }\n     fn unify_args(cx: @uctxt, e_args: [arg], a_args: [arg],\n-                  variance: variance) -> either::t<result, [arg]> {\n+                  variance: variance) -> either<result, [arg]> {\n         if !vec::same_length(e_args, a_args) {\n             ret either::left(ures_err(terr_arg_count));\n         }"}, {"sha": "e8d478866651cdec85e81a1115fd2aafc6380a52", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=b968c8e6cd362567bf0047a96d261691dfca43e8", "patch": "@@ -1701,7 +1701,7 @@ fn impl_self_ty(tcx: ty::ctxt, did: ast::def_id) -> {n_tps: uint, ty: ty::t} {\n \n fn lookup_method(fcx: @fn_ctxt, expr: @ast::expr, node_id: ast::node_id,\n                  name: ast::ident, ty: ty::t, tps: [ty::t])\n-    -> option::t<method_origin> {\n+    -> option<method_origin> {\n     alt lookup_method_inner(fcx, expr, name, ty) {\n       some({method_ty: fty, n_tps: method_n_tps, substs, origin, self_sub}) {\n         let tcx = fcx.ccx.tcx;\n@@ -1743,9 +1743,9 @@ fn lookup_method(fcx: @fn_ctxt, expr: @ast::expr, node_id: ast::node_id,\n \n fn lookup_method_inner(fcx: @fn_ctxt, expr: @ast::expr,\n                        name: ast::ident, ty: ty::t)\n-    -> option::t<{method_ty: ty::t, n_tps: uint, substs: [ty::t],\n+    -> option<{method_ty: ty::t, n_tps: uint, substs: [ty::t],\n                   origin: method_origin,\n-                  self_sub: option::t<self_subst>}> {\n+                  self_sub: option<self_subst>}> {\n     let tcx = fcx.ccx.tcx;\n     // First, see whether this is an interface-bounded parameter\n     alt ty::get(ty).struct {\n@@ -2120,8 +2120,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         }\n     }\n     fn lookup_op_method(fcx: @fn_ctxt, op_ex: @ast::expr, self_t: ty::t,\n-                        opname: str, args: [option::t<@ast::expr>])\n-        -> option::t<ty::t> {\n+                        opname: str, args: [option<@ast::expr>])\n+        -> option<ty::t> {\n         let callee_id = ast_util::op_expr_callee_id(op_ex);\n         alt lookup_method(fcx, op_ex, callee_id, opname, self_t, []) {\n           some(origin) {"}, {"sha": "91a884ce57ce19e436b60c7bcb7e135bbb48ea09", "filename": "src/rustc/syntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Frustc%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Frustc%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fast.rs?ref=b968c8e6cd362567bf0047a96d261691dfca43e8", "patch": "@@ -291,10 +291,10 @@ enum blk_sort {\n \n type mac = spanned<mac_>;\n \n-type mac_arg = option::t<@expr>;\n+type mac_arg = option<@expr>;\n \n type mac_body_ = {span: span};\n-type mac_body = option::t<mac_body_>;\n+type mac_body = option<mac_body_>;\n \n enum mac_ {\n     mac_invoc(@path, mac_arg, mac_body),"}, {"sha": "4beefe216326c64391e82c57786674207451452d", "filename": "src/rustc/syntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Frustc%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Frustc%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fparse%2Fparser.rs?ref=b968c8e6cd362567bf0047a96d261691dfca43e8", "patch": "@@ -643,7 +643,7 @@ fn parse_seq<T: copy>(bra: token::token, ket: token::token,\n     ret spanned(lo, hi, result);\n }\n \n-fn have_dollar(p: parser) -> option::t<ast::mac_> {\n+fn have_dollar(p: parser) -> option<ast::mac_> {\n     alt p.token {\n       token::DOLLAR_NUM(num) {\n         p.bump();\n@@ -2384,7 +2384,7 @@ else { ret none; }\n \n // A type to distingush between the parsing of item attributes or syntax\n // extensions, which both begin with token.POUND\n-type attr_or_ext = option<either::t<[ast::attribute], @ast::expr>>;\n+type attr_or_ext = option<either<[ast::attribute], @ast::expr>>;\n \n fn parse_outer_attrs_or_ext(\n     p: parser,"}, {"sha": "c37bb519702ddf989fc7eaacd8e6ed8ddad031ef", "filename": "src/rustc/util/filesearch.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Frustc%2Futil%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Frustc%2Futil%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Ffilesearch.rs?ref=b968c8e6cd362567bf0047a96d261691dfca43e8", "patch": "@@ -109,12 +109,12 @@ fn get_sysroot(maybe_sysroot: option<path>) -> path {\n     }\n }\n \n-fn get_cargo_sysroot() -> result::t<path, str> {\n+fn get_cargo_sysroot() -> result<path, str> {\n     let path = [get_default_sysroot(), libdir(), \"cargo\"];\n     result::ok(path::connect_many(path))\n }\n \n-fn get_cargo_root() -> result::t<path, str> {\n+fn get_cargo_root() -> result<path, str> {\n     alt os::getenv(\"CARGO_ROOT\") {\n         some(_p) { result::ok(_p) }\n         none {\n@@ -126,7 +126,7 @@ fn get_cargo_root() -> result::t<path, str> {\n     }\n }\n \n-fn get_cargo_root_nearest() -> result::t<path, str> {\n+fn get_cargo_root_nearest() -> result<path, str> {\n     result::chain(get_cargo_root()) { |p|\n         let cwd = os::getcwd();\n         let dirname = path::dirname(cwd);\n@@ -151,13 +151,13 @@ fn get_cargo_root_nearest() -> result::t<path, str> {\n     }\n }\n \n-fn get_cargo_lib_path() -> result::t<path, str> {\n+fn get_cargo_lib_path() -> result<path, str> {\n     result::chain(get_cargo_root()) { |p|\n         result::ok(path::connect(p, libdir()))\n     }\n }\n \n-fn get_cargo_lib_path_nearest() -> result::t<path, str> {\n+fn get_cargo_lib_path_nearest() -> result<path, str> {\n     result::chain(get_cargo_root_nearest()) { |p|\n         result::ok(path::connect(p, libdir()))\n     }"}, {"sha": "3ffbe70c6a0c1ebba9a0f3ff29261b9702b6a4c4", "filename": "src/rustdoc/config.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Frustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Frustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fconfig.rs?ref=b968c8e6cd362567bf0047a96d261691dfca43e8", "patch": "@@ -86,14 +86,14 @@ fn mock_program_output(_prog: str, _args: [str]) -> {\n     }\n }\n \n-fn parse_config(args: [str]) -> result::t<config, str> {\n+fn parse_config(args: [str]) -> result<config, str> {\n     parse_config_(args, run::program_output)\n }\n \n fn parse_config_(\n     args: [str],\n     program_output: program_output\n-) -> result::t<config, str> {\n+) -> result<config, str> {\n     let args = vec::tail(args);\n     let opts = tuple::first(vec::unzip(opts()));\n     alt getopts::getopts(args, opts) {\n@@ -117,7 +117,7 @@ fn config_from_opts(\n     input_crate: str,\n     match: getopts::match,\n     program_output: program_output\n-) -> result::t<config, str> {\n+) -> result<config, str> {\n \n     let config = default_config(input_crate);\n     let result = result::ok(config);\n@@ -165,15 +165,15 @@ fn config_from_opts(\n     ret result;\n }\n \n-fn parse_output_format(output_format: str) -> result::t<output_format, str> {\n+fn parse_output_format(output_format: str) -> result<output_format, str> {\n     alt output_format {\n       \"markdown\" { result::ok(markdown) }\n       \"html\" { result::ok(pandoc_html) }\n       _ { result::err(#fmt(\"unknown output format '%s'\", output_format)) }\n     }\n }\n \n-fn parse_output_style(output_style: str) -> result::t<output_style, str> {\n+fn parse_output_style(output_style: str) -> result<output_style, str> {\n     alt output_style {\n       \"doc-per-crate\" { result::ok(doc_per_crate) }\n       \"doc-per-mod\" { result::ok(doc_per_mod) }\n@@ -185,7 +185,7 @@ fn maybe_find_pandoc(\n     config: config,\n     maybe_pandoc_cmd: option<str>,\n     program_output: program_output\n-) -> result::t<option<str>, str> {\n+) -> result<option<str>, str> {\n     if config.output_format != pandoc_html {\n         ret result::ok(maybe_pandoc_cmd);\n     }\n@@ -251,7 +251,7 @@ fn should_error_with_no_pandoc() {\n \n #[cfg(test)]\n mod test {\n-    fn parse_config(args: [str]) -> result::t<config, str> {\n+    fn parse_config(args: [str]) -> result<config, str> {\n         parse_config_(args, mock_program_output)\n     }\n }"}, {"sha": "db574f6f2bc165e16a90772a2510cc45fda58b68", "filename": "src/test/compile-fail/fully-qualified-type-name1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Ftest%2Fcompile-fail%2Ffully-qualified-type-name1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b968c8e6cd362567bf0047a96d261691dfca43e8/src%2Ftest%2Fcompile-fail%2Ffully-qualified-type-name1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffully-qualified-type-name1.rs?ref=b968c8e6cd362567bf0047a96d261691dfca43e8", "patch": "@@ -3,5 +3,5 @@\n fn main() {\n     let x: option<uint>;\n     x = 5;\n-    //!^ ERROR mismatched types: expected `core::option::t<uint>`\n+    //!^ ERROR mismatched types: expected `core::option::option<uint>`\n }"}]}