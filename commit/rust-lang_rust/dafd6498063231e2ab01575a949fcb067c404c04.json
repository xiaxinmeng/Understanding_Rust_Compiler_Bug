{"sha": "dafd6498063231e2ab01575a949fcb067c404c04", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhZmQ2NDk4MDYzMjMxZTJhYjAxNTc1YTk0OWZjYjA2N2M0MDRjMDQ=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-03-03T01:20:00Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-03-03T02:46:13Z"}, "message": "First cut at consolidated core::os module built on core::libc.", "tree": {"sha": "c2b76c86c135605d5463c3588a7bb0e3b6bb1b23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2b76c86c135605d5463c3588a7bb0e3b6bb1b23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dafd6498063231e2ab01575a949fcb067c404c04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dafd6498063231e2ab01575a949fcb067c404c04", "html_url": "https://github.com/rust-lang/rust/commit/dafd6498063231e2ab01575a949fcb067c404c04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dafd6498063231e2ab01575a949fcb067c404c04/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87c14f1e3d85751bffffda0b1920be5e726172c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/87c14f1e3d85751bffffda0b1920be5e726172c4", "html_url": "https://github.com/rust-lang/rust/commit/87c14f1e3d85751bffffda0b1920be5e726172c4"}], "stats": {"total": 1283, "additions": 1270, "deletions": 13}, "files": [{"sha": "a91c445208888047612beef1fc2e1a919014ca55", "filename": "src/etc/libc.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dafd6498063231e2ab01575a949fcb067c404c04/src%2Fetc%2Flibc.c", "raw_url": "https://github.com/rust-lang/rust/raw/dafd6498063231e2ab01575a949fcb067c404c04/src%2Fetc%2Flibc.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flibc.c?ref=dafd6498063231e2ab01575a949fcb067c404c04", "patch": "@@ -10,6 +10,7 @@\n #include <stdio.h>\n #include <stdlib.h>\n #include <limits.h>\n+#include <wchar.h>\n \n /* c99 */\n #include <inttypes.h>\n@@ -53,6 +54,8 @@ void c95_types() {\n   put_type(\"clock_t\", clock_t);\n   put_type(\"time_t\", time_t);\n \n+  put_type(\"wchar_t\", wchar_t);\n+\n   printf(\"    }\\n\");\n }\n "}, {"sha": "ee3f90a33330faacdac117ae43c3cff50abac91c", "filename": "src/libcore/core.rc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dafd6498063231e2ab01575a949fcb067c404c04/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/dafd6498063231e2ab01575a949fcb067c404c04/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=dafd6498063231e2ab01575a949fcb067c404c04", "patch": "@@ -82,6 +82,12 @@ mod to_str;\n // Runtime and language-primitive support\n \n mod libc;\n+\n+// Rename when transition done.\n+#[path = \"os.rs\"]\n+mod new_os;\n+mod path;\n+\n mod ctypes;\n mod math;\n mod cmath;"}, {"sha": "96bff1250fc77214cc9c7f4cdb85484e2f669e29", "filename": "src/libcore/core.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dafd6498063231e2ab01575a949fcb067c404c04/src%2Flibcore%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dafd6498063231e2ab01575a949fcb067c404c04/src%2Flibcore%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rs?ref=dafd6498063231e2ab01575a949fcb067c404c04", "patch": "@@ -1,12 +1,12 @@\n // Top-level, visible-everywhere definitions.\n \n-// Export type option as a synonym for option and export the some and none\n-// enum constructors.\n+// Export various ubiquitous types, constructors, methods.\n \n import option::{some, none};\n import option = option::t;\n+import path = path::path;\n import vec::vec_len;\n-export option, some, none, vec_len;\n+export path, option, some, none, vec_len;\n \n // Export the log levels as global constants. Higher levels mean\n // more-verbosity. Error is the bottom level, default logging level is"}, {"sha": "0c16a378c25f963cd9a9af8c2f0e0de1ac2aab39", "filename": "src/libcore/libc.rs", "status": "modified", "additions": 219, "deletions": 9, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/dafd6498063231e2ab01575a949fcb067c404c04/src%2Flibcore%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dafd6498063231e2ab01575a949fcb067c404c04/src%2Flibcore%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flibc.rs?ref=dafd6498063231e2ab01575a949fcb067c404c04", "patch": "@@ -5,7 +5,8 @@\n //   - ISO 9899:1990 ('C95', 'ANSI C', 'Standard C'), NA1, 1995.\n //   - ISO 9899:1999 ('C99' or 'C9x').\n //   - ISO 9945:1988 / IEEE 1003.1-1988 ('POSIX.1').\n-//   - ISO 9945:2008 / IEEE 1003.1-2008 ('POSIX:2008').\n+//   - ISO 9945:2001 / IEEE 1003.1-2001 ('POSIX:2001', 'SUSv3').\n+//   - ISO 9945:2008 / IEEE 1003.1-2008 ('POSIX:2008', 'SUSv4').\n //\n // Despite having several names each, these are *reasonably* coherent\n // point-in-time, list-of-definition sorts of specs. You can get each under a\n@@ -17,9 +18,18 @@\n // platforms.\n //\n // We therefore wind up dividing our module-space up (mostly for the sake of\n-// sanity while editing) into definitions common-to-all (held in modules named\n-// c95, c99, posix88, and posix08) and definitions that appear only on *some*\n-// platforms (named 'extra').\n+// sanity while editing, filling-in-details and eliminating duplication) into\n+// definitions common-to-all (held in modules named c95, c99, posix88, posix01\n+// and posix08) and definitions that appear only on *some* platforms (named\n+// 'extra'). This would be things like significant OSX foundation kit, or\n+// win32 library kernel32.dll, or various fancy glibc, linux or BSD\n+// extensions.\n+//\n+// In addition to the per-platform 'extra' modules, we define a module of\n+// \"common BSD\" libc routines that never quite made it into POSIX but show up\n+// in multiple derived systems. This is the 4.4BSD r2 / 1995 release, the\n+// final one from Berkeley after the lawsuits died down and the CSRG\n+// dissolved.\n //\n \n // Initial glob-exports mean that all the contents of all the modules\n@@ -28,14 +38,25 @@\n // FIXME: change these to glob-exports when sufficiently supported.\n \n import types::common::c95::*;\n+import types::common::c99::*;\n import types::common::posix88::*;\n+import types::common::posix01::*;\n+import types::common::posix08::*;\n+import types::common::bsd44::*;\n import types::os::arch::c95::*;\n import types::os::arch::c99::*;\n import types::os::arch::posix88::*;\n+import types::os::arch::posix01::*;\n+import types::os::arch::posix08::*;\n+import types::os::arch::bsd44::*;\n import types::os::arch::extra::*;\n \n import consts::os::c95::*;\n+import consts::os::c99::*;\n import consts::os::posix88::*;\n+import consts::os::posix01::*;\n+import consts::os::posix08::*;\n+import consts::os::bsd44::*;\n import consts::os::extra::*;\n \n import funcs::c95::ctype::*;\n@@ -49,6 +70,18 @@ import funcs::posix88::fcntl::*;\n import funcs::posix88::dirent::*;\n import funcs::posix88::unistd::*;\n \n+import funcs::posix01::unistd::*;\n+import funcs::posix08::unistd::*;\n+\n+import funcs::bsd44::*;\n+import funcs::extra::*;\n+\n+// FIXME: remove these 3 exports (and their uses next door in os::) when\n+// export globs work. They provide access (for now) for os:: to dig around in\n+// the rest of the platform-specific definitions.\n+\n+export types, funcs, consts;\n+\n // Explicit export lists for the intersection (provided here) mean that\n // you can write more-platform-agnostic code if you stick to just these\n // symbols.\n@@ -76,7 +109,7 @@ export strcpy, strncpy, strcat, strncat, strcmp, strncmp, strcoll, strchr,\n        strxfrm, memcpy, memmove, memcmp, memchr, memset;\n \n export chmod, mkdir;\n-export popen, pclose;\n+export popen, pclose, fdopen;\n export open, creat;\n export access, chdir, close, dup, dup2, execv, execve, execvp, getcwd,\n        getpid, isatty, lseek, pipe, read, rmdir, unlink, write;\n@@ -95,11 +128,14 @@ mod types {\n             enum FILE {}\n             enum fpos_t {}\n         }\n-\n+        mod c99 { }\n         mod posix88 {\n             enum DIR {}\n             enum dirent {}\n         }\n+        mod posix01 { }\n+        mod posix08 { }\n+        mod bsd44 { }\n     }\n \n     // Standard types that are scalar but vary by OS and arch.\n@@ -122,6 +158,7 @@ mod types {\n                 type ptrdiff_t = i32;\n                 type clock_t = i32;\n                 type time_t = i32;\n+                type wchar_t = i32;\n             }\n             mod c99 {\n                 type c_longlong = i64;\n@@ -140,6 +177,9 @@ mod types {\n                 type mode_t = u32;\n                 type ssize_t = i32;\n             }\n+            mod posix01 { }\n+            mod posix08 { }\n+            mod bsd44 { }\n             mod extra {\n             }\n         }\n@@ -160,6 +200,7 @@ mod types {\n                 type ptrdiff_t = i64;\n                 type clock_t = i64;\n                 type time_t = i64;\n+                type wchar_t = i32;\n             }\n             mod c99 {\n                 type c_longlong = i64;\n@@ -178,6 +219,9 @@ mod types {\n                 type mode_t = u32;\n                 type ssize_t = i64;\n             }\n+            mod posix01 { }\n+            mod posix08 { }\n+            mod bsd44 { }\n             mod extra {\n             }\n         }\n@@ -201,6 +245,7 @@ mod types {\n                 type ptrdiff_t = i64;\n                 type clock_t = i32;\n                 type time_t = i64;\n+                type wchar_t = i32;\n             }\n             mod c99 {\n                 type c_longlong = i64;\n@@ -219,6 +264,9 @@ mod types {\n                 type mode_t = u16;\n                 type ssize_t = i64;\n             }\n+            mod posix01 { }\n+            mod posix08 { }\n+            mod bsd44 { }\n             mod extra {\n             }\n         }\n@@ -242,6 +290,7 @@ mod types {\n                 type ptrdiff_t = i32;\n                 type clock_t = i32;\n                 type time_t = i32;\n+                type wchar_t = u16;\n             }\n             mod c99 {\n                 type c_longlong = i64;\n@@ -258,7 +307,39 @@ mod types {\n                 type mode_t = u16;\n                 type ssize_t = i32;\n             }\n+            mod posix01 { }\n+            mod posix08 { }\n+            mod bsd44 { }\n             mod extra {\n+                type BOOL = c_int;\n+                type BYTE = u8;\n+                type CCHAR = c_char;\n+                type CHAR = c_char;\n+\n+                type DWORD = c_ulong;\n+                type DWORDLONG = c_ulonglong;\n+\n+                type HANDLE = LPVOID;\n+                type HMODULE = c_uint;\n+\n+                type LONG_PTR = c_long;\n+\n+                type LPCWSTR = *WCHAR;\n+                type LPCSTR = *CHAR;\n+\n+                type LPWSTR = *mutable WCHAR;\n+                type LPSTR = *mutable CHAR;\n+\n+                // Not really, but opaque to us.\n+                type LPSECURITY_ATTRIBUTES = LPVOID;\n+\n+                type LPVOID = *mutable c_void;\n+                type LPWORD = *mutable WORD;\n+\n+                type LRESULT = LONG_PTR;\n+                type PBOOL = *mutable BOOL;\n+                type WCHAR = wchar_t;\n+                type WORD = u16;\n             }\n         }\n     }\n@@ -281,6 +362,7 @@ mod types {\n                 type ptrdiff_t = i32;\n                 type clock_t = u32;\n                 type time_t = i32;\n+                type wchar_t = i32;\n             }\n             mod c99 {\n                 type c_longlong = i64;\n@@ -299,6 +381,9 @@ mod types {\n                 type mode_t = u16;\n                 type ssize_t = i32;\n             }\n+            mod posix01 { }\n+            mod posix08 { }\n+            mod bsd44 { }\n             mod extra {\n             }\n         }\n@@ -319,6 +404,7 @@ mod types {\n                 type ptrdiff_t = i64;\n                 type clock_t = u64;\n                 type time_t = i64;\n+                type wchar_t = i32;\n             }\n             mod c99 {\n                 type c_longlong = i64;\n@@ -337,6 +423,9 @@ mod types {\n                 type mode_t = u16;\n                 type ssize_t = i64;\n             }\n+            mod posix01 { }\n+            mod posix08 { }\n+            mod bsd44 { }\n             mod extra {\n             }\n         }\n@@ -367,6 +456,7 @@ mod consts {\n             const L_tmpnam : uint = 16_u;\n             const TMP_MAX : uint = 32767_u;\n         }\n+        mod c99 { }\n         mod posix88 {\n             const O_RDONLY : int = 0;\n             const O_WRONLY : int = 1;\n@@ -396,9 +486,13 @@ mod consts {\n             const STDIN_FILENO : int = 0;\n             const STDOUT_FILENO : int = 1;\n         }\n+        mod posix01 { }\n+        mod posix08 { }\n+        mod bsd44 { }\n         mod extra {\n             const O_TEXT : int = 16384;\n             const O_BINARY : int = 32768;\n+            const O_NOINHERIT: int = 128;\n         }\n     }\n \n@@ -422,6 +516,7 @@ mod consts {\n             const L_tmpnam : uint = 20_u;\n             const TMP_MAX : uint = 238328_u;\n         }\n+        mod c99 { }\n         mod posix88 {\n             const O_RDONLY : int = 0;\n             const O_WRONLY : int = 1;\n@@ -452,6 +547,9 @@ mod consts {\n             const F_TLOCK : int = 2;\n             const F_ULOCK : int = 0;\n         }\n+        mod posix01 { }\n+        mod posix08 { }\n+        mod bsd44 { }\n         mod extra {\n             const O_RSYNC : int = 1052672;\n             const O_DSYNC : int = 4096;\n@@ -478,6 +576,7 @@ mod consts {\n             const L_tmpnam : uint = 1024_u;\n             const TMP_MAX : uint = 308915776_u;\n         }\n+        mod c99 { }\n         mod posix88 {\n             const O_RDONLY : int = 0;\n             const O_WRONLY : int = 1;\n@@ -511,8 +610,14 @@ mod consts {\n             const F_TLOCK : int = 2;\n             const F_ULOCK : int = 0;\n         }\n+        mod posix01 { }\n+        mod posix08 { }\n+        mod bsd44 { }\n         mod extra {\n             const O_SYNC : int = 128;\n+            const CTL_KERN: int = 1;\n+            const KERN_PROC: int = 14;\n+            const KERN_PROC_PATHNAME: int = 12;\n         }\n     }\n \n@@ -535,6 +640,7 @@ mod consts {\n             const L_tmpnam : uint = 1024_u;\n             const TMP_MAX : uint = 308915776_u;\n         }\n+        mod c99 { }\n         mod posix88 {\n             const O_RDONLY : int = 0;\n             const O_WRONLY : int = 1;\n@@ -568,9 +674,13 @@ mod consts {\n             const F_TLOCK : int = 2;\n             const F_ULOCK : int = 0;\n         }\n+        mod posix01 { }\n+        mod posix08 { }\n+        mod bsd44 { }\n         mod extra {\n             const O_DSYNC : int = 4194304;\n             const O_SYNC : int = 128;\n+            const F_FULLFSYNC : int = 51;\n         }\n     }\n }\n@@ -725,6 +835,9 @@ mod funcs {\n \n             #[link_name = \"_pclose\"]\n             fn pclose(stream: *FILE) -> c_int;\n+\n+            #[link_name = \"_fdopen\"]\n+            fn fdopen(fd: c_int, mode: *c_char) -> *FILE;\n         }\n \n         #[nolink]\n@@ -765,7 +878,8 @@ mod funcs {\n             fn execv(prog: *c_char, argv: **c_char) -> intptr_t;\n \n             #[link_name = \"_execve\"]\n-            fn execve(prog: *c_char, argv: **c_char, envp: **c_char) -> c_int;\n+            fn execve(prog: *c_char, argv: **c_char,\n+                      envp: **c_char) -> c_int;\n \n             #[link_name = \"_execvp\"]\n             fn execvp(c: *c_char, argv: **c_char) -> c_int;\n@@ -786,7 +900,8 @@ mod funcs {\n             fn lseek(fd: c_int, offset: c_long, origin: c_int) -> c_long;\n \n             #[link_name = \"_pipe\"]\n-            fn pipe(fds: *c_int, psize: c_uint, textmode: c_int) -> c_int;\n+            fn pipe(fds: *mutable c_int, psize: c_uint,\n+                    textmode: c_int) -> c_int;\n \n             #[link_name = \"_read\"]\n             fn read(fd: c_int, buf: *c_void, count: c_uint) -> c_int;\n@@ -823,6 +938,7 @@ mod funcs {\n         native mod stdio {\n             fn popen(command: *c_char, mode: *c_char) -> *FILE;\n             fn pclose(stream: *FILE) -> c_int;\n+            fn fdopen(fd: c_int, mode: *c_char) -> *FILE;\n         }\n \n         #[nolink]\n@@ -875,7 +991,7 @@ mod funcs {\n             fn lseek(fd: c_int, offset: off_t, whence: c_int) -> off_t;\n             fn pathconf(path: *c_char, name: c_int) -> c_long;\n             fn pause() -> c_int;\n-            fn pipe(fds: *c_int) -> c_int;\n+            fn pipe(fds: *mutable c_int) -> c_int;\n             fn read(fd: c_int, buf: *c_void, count: size_t) -> ssize_t;\n             fn rmdir(path: *c_char) -> c_int;\n             fn setgid(gid: gid_t) -> c_int;\n@@ -890,7 +1006,101 @@ mod funcs {\n             fn write(fd: c_int, buf: *c_void, count: size_t) -> ssize_t;\n         }\n     }\n+\n+    #[cfg(target_os = \"linux\")]\n+    #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"freebsd\")]\n+    mod posix01 {\n+\n+        #[nolink]\n+        #[abi = \"cdecl\"]\n+        native mod unistd {\n+            fn readlink(path: *c_char, buf: *mutable c_char,\n+                        bufsz: size_t) -> ssize_t;\n+\n+            fn setenv(name: *c_char, val: *c_char,\n+                      overwrite: c_int) -> c_int;\n+            fn unsetenv(name: *c_char) -> c_int;\n+            fn putenv(string: *c_char) -> c_int;\n+        }\n+    }\n+\n+    #[cfg(target_os = \"win32\")]\n+    mod posix01 {\n+        #[nolink]\n+        native mod unistd { }\n+    }\n+\n+\n+    #[cfg(target_os = \"win32\")]\n+    #[cfg(target_os = \"linux\")]\n+    #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"freebsd\")]\n+    mod posix08 {\n+        #[nolink]\n+        native mod unistd { }\n+    }\n+\n+\n+    #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"freebsd\")]\n+    #[nolink]\n+    #[abi = \"cdecl\"]\n+    native mod bsd44 {\n+\n+        fn sysctl(name: *c_int, namelen: c_uint,\n+                  oldp: *mutable c_void, oldlenp: *mutable size_t,\n+                  newp: *c_void, newlen: size_t) -> c_int;\n+\n+        fn sysctlbyname(name: *c_char,\n+                        oldp: *mutable c_void, oldlenp: *mutable size_t,\n+                        newp: *c_void, newlen: size_t) -> c_int;\n+\n+        fn sysctlnametomib(name: *c_char, mibp: *mutable c_int,\n+                           sizep: *mutable size_t) -> c_int;\n+    }\n+\n+\n+    #[cfg(target_os = \"linux\")]\n+    #[cfg(target_os = \"win32\")]\n+    mod bsd44 {\n+    }\n+\n+\n+    #[cfg(target_os = \"macos\")]\n+    #[nolink]\n+    #[abi = \"cdecl\"]\n+    native mod extra {\n+        fn _NSGetExecutablePath(buf: *mutable c_char,\n+                                bufsize: *mutable u32) -> c_int;\n+    }\n+\n+    #[cfg(target_os = \"freebsd\")]\n+    mod extra { }\n+\n+    #[cfg(target_os = \"linux\")]\n+    mod extra { }\n+\n+\n+    #[cfg(target_os = \"win32\")]\n     mod extra {\n+        import types::os::arch::extra::*;\n+\n+        #[abi = \"stdcall\"]\n+        native mod kernel32 {\n+            fn GetEnvironmentVariableA(n: LPCSTR,\n+                                       v: LPSTR,\n+                                       nsize: DWORD) -> DWORD;\n+            fn SetEnvironmentVariableA(n: LPCSTR, v: LPCSTR) -> BOOL;\n+            fn GetModuleFileNameA(hModule: HMODULE,\n+                                  lpFilename: LPSTR,\n+                                  nSize: DWORD) -> DWORD;\n+            fn CreateDirectoryA(lpPathName: LPCSTR,\n+                                lpSecurityAttributes:\n+                                LPSECURITY_ATTRIBUTES) -> BOOL;\n+            fn RemoveDirectoryA(lpPathName: LPCSTR) -> BOOL;\n+            fn SetCurrentDirectoryA(lpPathName: LPCSTR) -> BOOL;\n+        }\n     }\n }\n "}, {"sha": "a458fe49a3096a830f25915eb9ba9d3228bbcef2", "filename": "src/libcore/os.rs", "status": "added", "additions": 529, "deletions": 0, "changes": 529, "blob_url": "https://github.com/rust-lang/rust/blob/dafd6498063231e2ab01575a949fcb067c404c04/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dafd6498063231e2ab01575a949fcb067c404c04/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=dafd6498063231e2ab01575a949fcb067c404c04", "patch": "@@ -0,0 +1,529 @@\n+// Higher-level interfaces to libc::* functions and operating system services.\n+//\n+// In general these take and return rust types, use rust idioms (enums,\n+// closures, vectors) rather than C idioms, and do more extensive safety\n+// checks.\n+//\n+// This module is not meant to only contain 1:1 mappings to libc entries; any\n+// os-interface code that is reasonably useful and broadly applicable can go\n+// here. Including utility routines that merely build on other os code.\n+//\n+// We assume the general case is that users do not care, and do not want to\n+// be made to care, which operating system they are on. While they may want\n+// to special case various special cases -- and so we will not _hide_ the\n+// facts of which OS the user is on -- they should be given the opportunity\n+// to write OS-ignorant code by default.\n+\n+import libc::{c_char, c_void, c_int, c_uint, size_t, mode_t, FILE};\n+import libc::{close, fclose};\n+\n+import getcwd = rustrt::rust_getcwd;\n+import consts::*;\n+\n+export close, fclose;\n+export env, getenv, setenv, fdopen, pipe;\n+export getcwd, dll_filename, self_exe_path;\n+export exe_suffix, dll_suffix, sysname;\n+export homedir, list_dir, path_is_dir, path_exists;\n+\n+native mod rustrt {\n+    fn rust_env_pairs() -> [str];\n+    fn rust_getcwd() -> str;\n+    fn rust_path_is_dir(path: str::sbuf) -> c_int;\n+    fn rust_path_exists(path: str::sbuf) -> c_int;\n+    fn rust_list_files(path: str) -> [str];\n+}\n+\n+\n+fn env() -> [(str,str)] {\n+    let pairs = [];\n+    for p in rustrt::rust_env_pairs() {\n+        let vs = str::splitn_char(p, '=', 1u);\n+        assert vec::len(vs) == 2u;\n+        pairs += [(vs[0], vs[1])];\n+    }\n+    ret pairs;\n+}\n+\n+fn as_c_charp<T>(s: str, f: fn(*c_char) -> T) -> T {\n+    str::as_buf(s) {|b| f(b as *c_char) }\n+}\n+\n+// FIXME: UTF-16-ify this and revive win32 Unicode variant.\n+fn getenv(n: str) -> option<str> unsafe {\n+    let s = as_c_charp(n, libc::getenv);\n+    ret if unsafe::reinterpret_cast(s) == 0 {\n+            option::none::<str>\n+        } else {\n+            let s = unsafe::reinterpret_cast(s);\n+            option::some::<str>(str::from_cstr(s))\n+        };\n+}\n+\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n+fn setenv(n: str, v: str) {\n+\n+    // FIXME: remove this when export globs work properly.\n+    import libc::funcs::posix01::unistd::setenv;\n+\n+    as_c_charp(n) {|nbuf|\n+        as_c_charp(v) {|vbuf|\n+            setenv(nbuf, vbuf, 1i32);\n+        }\n+    }\n+}\n+\n+\n+#[cfg(target_os = \"win32\")]\n+// FIXME: UTF-16-ify this and switch to the W version.\n+fn setenv(n: str, v: str) {\n+    // FIXME: remove imports when export globs work properly.\n+    import libc::funcs::extra::kernel32;\n+    as_c_charp(n) {|nbuf|\n+        as_c_charp(v) {|vbuf|\n+            kernel32::SetEnvironmentVariableA(nbuf, vbuf);\n+        }\n+    }\n+}\n+\n+\n+fn fdopen(fd: c_int) -> *FILE {\n+    ret as_c_charp(\"r\") {|modebuf|\n+        libc::fdopen(fd, modebuf)\n+    };\n+}\n+\n+\n+\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"freebsd\")]\n+#[cfg(target_os = \"macos\")]\n+fn pipe() -> {in: c_int, out: c_int} {\n+    let fds = {mutable in: 0 as c_int,\n+               mutable out: 0 as c_int };\n+    assert (libc::pipe(ptr::mut_addr_of(fds.in)) == (0 as c_int));\n+    ret {in: fds.in, out: fds.out};\n+}\n+\n+\n+\n+#[cfg(target_os = \"win32\")]\n+fn pipe() -> {in: c_int, out: c_int} {\n+    // FIXME: remove this when export globs work properly.\n+    import libc::consts::os::extra::*;\n+    // Windows pipes work subtly differently than unix pipes, and their\n+    // inheritance has to be handled in a different way that I do not fully\n+    // understand. Here we explicitly make the pipe non-inheritable, which\n+    // means to pass it to a subprocess they need to be duplicated first, as\n+    // in rust_run_program.\n+    let fds = { mutable in: 0 as c_int,\n+               mutable out: 0 as c_int };\n+    let res = libc::pipe(ptr::mut_addr_of(fds.in),\n+                         1024 as c_uint,\n+                         (O_BINARY | O_NOINHERIT) as c_int);\n+    assert (res == 0 as c_int);\n+    assert (fds.in != -1 as c_int && fds.in != 0 as c_int);\n+    assert (fds.out != -1 as c_int && fds.in != 0 as c_int);\n+    ret {in: fds.in, out: fds.out};\n+}\n+\n+\n+fn dll_filename(base: str) -> str {\n+    ret pre() + base + dll_suffix();\n+\n+    #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"linux\")]\n+    #[cfg(target_os = \"freebsd\")]\n+    fn pre() -> str { \"lib\" }\n+\n+    #[cfg(target_os = \"win32\")]\n+    fn pre() -> str { \"\" }\n+}\n+\n+fn self_exe_path() -> option<path> unsafe {\n+    let bufsize = 1023u;\n+    let buf = vec::init_elt_mut(bufsize, 0u8 as c_char);\n+    // FIXME: This does not handle the case where the buffer is too small\n+    ret vec::as_mut_buf(buf) {|pbuf|\n+        if load_self(pbuf as *mutable c_char, bufsize as c_uint) {\n+            let path = str::from_cstr(pbuf as str::sbuf);\n+            option::some(path::dirname(path) + path::path_sep())\n+        } else {\n+            option::none\n+        }\n+    };\n+\n+    #[cfg(target_os = \"freebsd\")]\n+    unsafe fn load_self(pth: *mutable c_char, plen: c_uint) -> bool {\n+        // FIXME: remove imports when export globs work properly.\n+        import libc::funcs::bsd44::*;\n+        import libc::consts::os::extra::*;\n+        let mib = [CTL_KERN as c_int,\n+                   KERN_PROC as c_int,\n+                   KERN_PROC_PATHNAME as c_int, -1 as c_int];\n+        ret sysctl(vec::unsafe::to_ptr(mib), vec::len(mib) as c_uint,\n+                   pth as *mutable c_void, ptr::mut_addr_of(plen),\n+                   ptr::null(), 0u as size_t)\n+            == (0 as c_int);\n+    }\n+\n+    #[cfg(target_os = \"linux\")]\n+    unsafe fn load_self(pth: *mutable c_char, plen: c_uint) -> bool {\n+        // FIXME: remove imports when export globs work properly.\n+        import libc::funcs::posix01::unistd::readlink;\n+        as_c_charp(\"/proc/self/exe\") { |proc_self_buf|\n+            ret readlink(proc_self_buf, pth, plen as size_t) != -1;\n+        }\n+    }\n+\n+    #[cfg(target_os = \"win32\")]\n+    unsafe fn load_self(pth: *mutable c_char, plen: c_uint) -> bool {\n+        // FIXME: remove imports when export globs work properly.\n+        import libc::types::os::arch::extra::*;\n+        import libc::funcs::extra::kernel32;\n+        ret kernel32::GetModuleFileNameA(0u, pth, plen) != (0 as DWORD);\n+    }\n+\n+    #[cfg(target_os = \"macos\")]\n+    unsafe fn load_self(pth: *mutable c_char, plen: c_uint) -> bool {\n+        // FIXME: remove imports when export globs work properly.\n+        import libc::funcs::extra::*;\n+        let mplen = plen;\n+        ret _NSGetExecutablePath(pth, ptr::mut_addr_of(mplen))\n+            == (0 as c_int);\n+    }\n+\n+}\n+\n+\n+/*\n+Function: homedir\n+\n+Returns the path to the user's home directory, if known.\n+\n+On Unix, returns the value of the \"HOME\" environment variable if it is set and\n+not equal to the empty string.\n+\n+On Windows, returns the value of the \"HOME\" environment variable if it is set\n+and not equal to the empty string. Otherwise, returns the value of the\n+\"USERPROFILE\" environment variable if it is set and not equal to the empty\n+string.\n+\n+Otherwise, homedir returns option::none.\n+*/\n+fn homedir() -> option<path> {\n+    ret alt getenv(\"HOME\") {\n+        some(p) {\n+            if !str::is_empty(p) {\n+                some(p)\n+            } else {\n+                secondary()\n+            }\n+        }\n+        none {\n+            secondary()\n+        }\n+    };\n+\n+    #[cfg(target_os = \"linux\")]\n+    #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"freebsd\")]\n+    fn secondary() -> option<path> {\n+        none\n+    }\n+\n+    #[cfg(target_os = \"win32\")]\n+    fn secondary() -> option<path> {\n+        option::maybe(none, getenv(\"USERPROFILE\")) {|p|\n+            if !str::is_empty(p) {\n+                some(p)\n+            } else {\n+                none\n+            }\n+        }\n+    }\n+}\n+\n+\n+\n+/*\n+Function: path_is_dir\n+\n+Indicates whether a path represents a directory.\n+*/\n+fn path_is_dir(p: path) -> bool {\n+    ret str::as_buf(p, {|buf|\n+        rustrt::rust_path_is_dir(buf) != 0 as c_int\n+    });\n+}\n+\n+/*\n+Function: path_exists\n+\n+Indicates whether a path exists.\n+*/\n+fn path_exists(p: path) -> bool {\n+    ret str::as_buf(p, {|buf|\n+        rustrt::rust_path_exists(buf) != 0 as c_int\n+    });\n+}\n+\n+// FIXME: under Windows, we should prepend the current drive letter to paths\n+// that start with a slash.\n+/*\n+Function: make_absolute\n+\n+Convert a relative path to an absolute path\n+\n+If the given path is relative, return it prepended with the current working\n+directory. If the given path is already an absolute path, return it\n+as is.\n+*/\n+// NB: this is here rather than in path because it is a form of environment\n+// querying; what it does depends on the process working directory, not just\n+// the input paths.\n+fn make_absolute(p: path) -> path {\n+    if path::path_is_absolute(p) {\n+        p\n+    } else {\n+        path::connect(getcwd(), p)\n+    }\n+}\n+\n+\n+/*\n+Function: make_dir\n+\n+Creates a directory at the specified path.\n+*/\n+fn make_dir(p: path, mode: c_int) -> bool {\n+    ret mkdir(p, mode);\n+\n+    #[cfg(target_os = \"win32\")]\n+    fn mkdir(_p: path, _mode: c_int) -> bool unsafe {\n+        // FIXME: turn mode into something useful?\n+        ret as_c_charp(_p, {|buf|\n+            // FIXME: remove imports when export globs work properly.\n+            import libc::types::os::arch::extra::*;\n+            import libc::funcs::extra::kernel32;\n+            kernel32::CreateDirectoryA(\n+                buf, unsafe::reinterpret_cast(0)) != (0 as BOOL)\n+        });\n+    }\n+\n+    #[cfg(target_os = \"linux\")]\n+    #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"freebsd\")]\n+    fn mkdir(p: path, mode: c_int) -> bool {\n+        ret as_c_charp(p) {|c|\n+            libc::mkdir(c, mode as mode_t) == (0 as c_int)\n+        };\n+    }\n+}\n+\n+/*\n+Function: list_dir\n+\n+Lists the contents of a directory.\n+*/\n+fn list_dir(p: path) -> [str] {\n+\n+    #[cfg(target_os = \"linux\")]\n+    #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"freebsd\")]\n+    fn star() -> str { \"\" }\n+\n+    #[cfg(target_os = \"win32\")]\n+    fn star() -> str { \"*\" }\n+\n+    let p = p;\n+    let pl = str::len(p);\n+    if pl == 0u || (p[pl - 1u] as char != path::consts::path_sep\n+                    && p[pl - 1u] as char != path::consts::alt_path_sep) {\n+        p += path::path_sep();\n+    }\n+    let full_paths: [str] = [];\n+    for filename: str in rustrt::rust_list_files(p + star()) {\n+        if !str::eq(filename, \".\") {\n+            if !str::eq(filename, \"..\") {\n+                full_paths += [p + filename];\n+            }\n+        }\n+    }\n+    ret full_paths;\n+}\n+\n+/*\n+Function: remove_dir\n+\n+Removes a directory at the specified path.\n+*/\n+fn remove_dir(p: path) -> bool {\n+   ret rmdir(p);\n+\n+    #[cfg(target_os = \"win32\")]\n+    fn rmdir(p: path) -> bool {\n+        // FIXME: remove imports when export globs work properly.\n+        import libc::funcs::extra::kernel32;\n+        import libc::types::os::arch::extra::*;\n+        ret as_c_charp(p) {|buf|\n+            kernel32::RemoveDirectoryA(buf) != (0 as BOOL)\n+        };\n+    }\n+\n+    #[cfg(target_os = \"linux\")]\n+    #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"freebsd\")]\n+    fn rmdir(p: path) -> bool {\n+        ret as_c_charp(p) {|buf|\n+            libc::rmdir(buf) == (0 as c_int)\n+        };\n+    }\n+}\n+\n+fn change_dir(p: path) -> bool {\n+    ret chdir(p);\n+\n+    #[cfg(target_os = \"win32\")]\n+    fn chdir(p: path) -> bool {\n+        // FIXME: remove imports when export globs work properly.\n+        import libc::funcs::extra::kernel32;\n+        import libc::types::os::arch::extra::*;\n+        ret as_c_charp(p) {|buf|\n+            kernel32::SetCurrentDirectoryA(buf) != (0 as BOOL)\n+        };\n+    }\n+\n+    #[cfg(target_os = \"linux\")]\n+    #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"freebsd\")]\n+    fn chdir(p: path) -> bool {\n+        ret as_c_charp(p) {|buf|\n+            libc::chdir(buf) == (0 as c_int)\n+        };\n+    }\n+}\n+\n+\n+\n+#[cfg(target_os = \"macos\")]\n+mod consts {\n+    fn sysname() -> str { \"macos\" }\n+    fn exe_suffix() -> str { \"\" }\n+    fn dll_suffix() -> str { \".dylib\" }\n+}\n+\n+#[cfg(target_os = \"freebsd\")]\n+mod consts {\n+    fn sysname() -> str { \"freebsd\" }\n+    fn exe_suffix() -> str { \"\" }\n+    fn dll_suffix() -> str { \".so\" }\n+}\n+\n+#[cfg(target_os = \"linux\")]\n+mod consts {\n+    fn sysname() -> str { \"linux\" }\n+    fn exe_suffix() -> str { \"\" }\n+    fn dll_suffix() -> str { \".so\" }\n+}\n+\n+#[cfg(target_os = \"win32\")]\n+mod consts {\n+    fn sysname() -> str { \"win32\" }\n+    fn exe_suffix() -> str { \".exe\" }\n+    fn dll_suffix() -> str { \".dll\" }\n+}\n+\n+\n+\n+\n+#[cfg(test)]\n+mod tests {\n+\n+    import os = new_os;\n+\n+    #[test]\n+    fn test() {\n+        assert (!path::path_is_absolute(\"test-path\"));\n+\n+        log(debug, \"Current working directory: \" + getcwd());\n+\n+        log(debug, make_absolute(\"test-path\"));\n+        log(debug, make_absolute(\"/usr/bin\"));\n+    }\n+\n+    #[test]\n+    #[cfg(target_os = \"linux\")]\n+    #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"freebsd\")]\n+    fn homedir() {\n+        let oldhome = getenv(\"HOME\");\n+\n+        setenv(\"HOME\", \"/home/MountainView\");\n+        assert os::homedir() == some(\"/home/MountainView\");\n+\n+        setenv(\"HOME\", \"\");\n+        assert os::homedir() == none;\n+\n+        option::may(oldhome, {|s| setenv(\"HOME\", s)});\n+    }\n+\n+    #[test]\n+    #[cfg(target_os = \"win32\")]\n+    fn homedir() {\n+\n+        let oldhome = getenv(\"HOME\");\n+        let olduserprofile = getenv(\"USERPROFILE\");\n+\n+        setenv(\"HOME\", \"\");\n+        setenv(\"USERPROFILE\", \"\");\n+\n+        assert os::homedir() == none;\n+\n+        setenv(\"HOME\", \"/home/MountainView\");\n+        assert os::homedir() == some(\"/home/MountainView\");\n+\n+        setenv(\"HOME\", \"\");\n+\n+        setenv(\"USERPROFILE\", \"/home/MountainView\");\n+        assert os::homedir() == some(\"/home/MountainView\");\n+\n+        setenv(\"USERPROFILE\", \"/home/MountainView\");\n+        assert os::homedir() == some(\"/home/MountainView\");\n+\n+        setenv(\"HOME\", \"/home/MountainView\");\n+        setenv(\"USERPROFILE\", \"/home/PaloAlto\");\n+        assert os::homedir() == some(\"/home/MountainView\");\n+\n+        option::may(oldhome, {|s| setenv(\"HOME\", s)});\n+        option::may(olduserprofile, {|s| setenv(\"USERPROFILE\", s)});\n+    }\n+\n+    // Issue #712\n+    #[test]\n+    fn test_list_dir_no_invalid_memory_access() { os::list_dir(\".\"); }\n+\n+    #[test]\n+    fn list_dir() {\n+        let dirs = os::list_dir(\".\");\n+        // Just assuming that we've got some contents in the current directory\n+        assert (vec::len(dirs) > 0u);\n+\n+        for dir in dirs { log(debug, dir); }\n+    }\n+\n+    #[test]\n+    fn path_is_dir() {\n+        assert (os::path_is_dir(\".\"));\n+        assert (!os::path_is_dir(\"test/stdtest/fs.rs\"));\n+    }\n+\n+    #[test]\n+    fn path_exists() {\n+        assert (os::path_exists(\".\"));\n+        assert (!os::path_exists(\"test/nonexistent-bogus-path\"));\n+    }\n+\n+}\n\\ No newline at end of file"}, {"sha": "d5a80c39c7f2fb954725e2a042edbc0bfe63951b", "filename": "src/libcore/path.rs", "status": "added", "additions": 505, "deletions": 0, "changes": 505, "blob_url": "https://github.com/rust-lang/rust/blob/dafd6498063231e2ab01575a949fcb067c404c04/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dafd6498063231e2ab01575a949fcb067c404c04/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=dafd6498063231e2ab01575a949fcb067c404c04", "patch": "@@ -0,0 +1,505 @@\n+/*\n+Module: path\n+\n+Path data type and helper functions.\n+*/\n+\n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n+#[cfg(target_os = \"linux\")]\n+mod consts {\n+    const path_sep: char = '/';\n+    const alt_path_sep: char = '/';\n+}\n+\n+#[cfg(target_os = \"win32\")]\n+mod consts {\n+    const path_sep: char = '/';\n+    const alt_path_sep: char = '\\\\';\n+}\n+\n+/*\n+Function: path_is_absolute\n+\n+Indicates whether a path is absolute.\n+\n+A path is considered absolute if it begins at the filesystem root (\"/\") or,\n+on Windows, begins with a drive letter.\n+*/\n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n+#[cfg(target_os = \"linux\")]\n+fn path_is_absolute(p: path) -> bool {\n+    str::char_at(p, 0u) == '/'\n+}\n+\n+#[cfg(target_os = \"win32\")]\n+fn path_is_absolute(p: str) -> bool {\n+    ret str::char_at(p, 0u) == '/' ||\n+        str::char_at(p, 1u) == ':'\n+        && (str::char_at(p, 2u) == consts::path_sep\n+            || str::char_at(p, 2u) == consts::alt_path_sep);\n+}\n+\n+\n+\n+/*\n+Function: path_sep\n+\n+Get the default path separator for the host platform\n+*/\n+fn path_sep() -> str { ret str::from_char(consts::path_sep); }\n+\n+// FIXME: This type should probably be constrained\n+/*\n+Type: path\n+\n+A path or fragment of a filesystem path\n+*/\n+type path = str;\n+\n+fn split_dirname_basename (pp: path) -> {dirname: str, basename: str} {\n+    alt str::rfind(pp, {|ch|\n+        ch == consts::path_sep || ch == consts::alt_path_sep\n+    }) {\n+      some(i) {\n+        {dirname: str::slice(pp, 0u, i),\n+         basename: str::slice(pp, i + 1u, str::len(pp))}\n+      }\n+      none { {dirname: \".\", basename: pp} }\n+    }\n+}\n+\n+/*\n+Function: dirname\n+\n+Get the directory portion of a path\n+\n+Returns all of the path up to, but excluding, the final path separator.\n+The dirname of \"/usr/share\" will be \"/usr\", but the dirname of\n+\"/usr/share/\" is \"/usr/share\".\n+\n+If the path is not prefixed with a directory, then \".\" is returned.\n+*/\n+fn dirname(pp: path) -> path {\n+    ret split_dirname_basename(pp).dirname;\n+}\n+\n+/*\n+Function: basename\n+\n+Get the file name portion of a path\n+\n+Returns the portion of the path after the final path separator.\n+The basename of \"/usr/share\" will be \"share\". If there are no\n+path separators in the path then the returned path is identical to\n+the provided path. If an empty path is provided or the path ends\n+with a path separator then an empty path is returned.\n+*/\n+fn basename(pp: path) -> path {\n+    ret split_dirname_basename(pp).basename;\n+}\n+\n+// FIXME: Need some typestate to avoid bounds check when len(pre) == 0\n+/*\n+Function: connect\n+\n+Connects to path segments\n+\n+Given paths `pre` and `post, removes any trailing path separator on `pre` and\n+any leading path separator on `post`, and returns the concatenation of the two\n+with a single path separator between them.\n+*/\n+\n+fn connect(pre: path, post: path) -> path unsafe {\n+    let pre_ = pre;\n+    let post_ = post;\n+    let sep = consts::path_sep as u8;\n+    let pre_len  = str::len(pre);\n+    let post_len = str::len(post);\n+    if pre_len > 1u && pre[pre_len-1u] == sep { str::unsafe::pop_byte(pre_); }\n+    if post_len > 1u && post[0] == sep { str::unsafe::shift_byte(post_); }\n+    ret pre_ + path_sep() + post_;\n+}\n+\n+/*\n+Function: connect_many\n+\n+Connects a vector of path segments into a single path.\n+\n+Inserts path separators as needed.\n+*/\n+fn connect_many(paths: [path]) -> path {\n+    ret if vec::len(paths) == 1u {\n+        paths[0]\n+    } else {\n+        let rest = vec::slice(paths, 1u, vec::len(paths));\n+        connect(paths[0], connect_many(rest))\n+    }\n+}\n+\n+/*\n+Function: split\n+\n+Split a path into it's individual components\n+\n+Splits a given path by path separators and returns a vector containing\n+each piece of the path. On Windows, if the path is absolute then\n+the first element of the returned vector will be the drive letter\n+followed by a colon.\n+*/\n+fn split(p: path) -> [path] {\n+    str::split_nonempty(p, {|c|\n+        c == consts::path_sep || c == consts::alt_path_sep\n+    })\n+}\n+\n+/*\n+Function: splitext\n+\n+Split a path into a pair of strings with the first element being the filename\n+without the extension and the second being either empty or the file extension\n+including the period. Leading periods in the basename are ignored.  If the\n+path includes directory components then they are included in the filename part\n+of the result pair.\n+*/\n+fn splitext(p: path) -> (str, str) {\n+    if str::is_empty(p) { (\"\", \"\") }\n+    else {\n+        let parts = str::split_char(p, '.');\n+        if vec::len(parts) > 1u {\n+            let base = str::connect(vec::init(parts), \".\");\n+            let ext = \".\" + vec::last_total(parts);\n+\n+            fn is_dotfile(base: str) -> bool {\n+                str::is_empty(base)\n+                    || str::ends_with(\n+                        base, str::from_char(consts::path_sep))\n+                    || str::ends_with(\n+                        base, str::from_char(consts::alt_path_sep))\n+            }\n+\n+            fn ext_contains_sep(ext: str) -> bool {\n+                vec::len(split(ext)) > 1u\n+            }\n+\n+            fn no_basename(ext: str) -> bool {\n+                str::ends_with(\n+                    ext, str::from_char(consts::path_sep))\n+                    || str::ends_with(\n+                        ext, str::from_char(consts::alt_path_sep))\n+            }\n+\n+            if is_dotfile(base)\n+                || ext_contains_sep(ext)\n+                || no_basename(ext) {\n+                (p, \"\")\n+            } else {\n+                (base, ext)\n+            }\n+        } else {\n+            (p, \"\")\n+        }\n+    }\n+}\n+\n+/*\n+Function: normalize\n+\n+Removes extra \".\" and \"..\" entries from paths.\n+\n+Does not follow symbolic links.\n+*/\n+fn normalize(p: path) -> path {\n+    let s = split(p);\n+    let s = strip_dots(s);\n+    let s = rollup_doubledots(s);\n+\n+    let s = if check vec::is_not_empty(s) {\n+        connect_many(s)\n+    } else {\n+        \"\"\n+    };\n+    let s = reabsolute(p, s);\n+    let s = reterminate(p, s);\n+\n+    let s = if str::len(s) == 0u {\n+        \".\"\n+    } else {\n+        s\n+    };\n+\n+    ret s;\n+\n+    fn strip_dots(s: [path]) -> [path] {\n+        vec::filter_map(s, { |elem|\n+            if elem == \".\" {\n+                option::none\n+            } else {\n+                option::some(elem)\n+            }\n+        })\n+    }\n+\n+    fn rollup_doubledots(s: [path]) -> [path] {\n+        if vec::is_empty(s) {\n+            ret [];\n+        }\n+\n+        let t = [];\n+        let i = vec::len(s);\n+        let skip = 0;\n+        do {\n+            i -= 1u;\n+            if s[i] == \"..\" {\n+                skip += 1;\n+            } else {\n+                if skip == 0 {\n+                    t += [s[i]];\n+                } else {\n+                    skip -= 1;\n+                }\n+            }\n+        } while i != 0u;\n+        let t = vec::reversed(t);\n+        while skip > 0 {\n+            t += [\"..\"];\n+            skip -= 1;\n+        }\n+        ret t;\n+    }\n+\n+    #[cfg(target_os = \"linux\")]\n+    #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"freebsd\")]\n+    fn reabsolute(orig: path, new: path) -> path {\n+        if path_is_absolute(orig) {\n+            path_sep() + new\n+        } else {\n+            new\n+        }\n+    }\n+\n+    #[cfg(target_os = \"win32\")]\n+    fn reabsolute(orig: path, new: path) -> path {\n+       if path_is_absolute(orig) && orig[0] == consts::path_sep as u8 {\n+           str::from_char(consts::path_sep) + new\n+       } else {\n+           new\n+       }\n+    }\n+\n+    fn reterminate(orig: path, new: path) -> path {\n+        let last = orig[str::len(orig) - 1u];\n+        if last == consts::path_sep as u8\n+            || last == consts::path_sep as u8 {\n+            ret new + path_sep();\n+        } else {\n+            ret new;\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    fn test_connect() {\n+        let slash = path_sep();\n+        log(error, connect(\"a\", \"b\"));\n+        assert (connect(\"a\", \"b\") == \"a\" + slash + \"b\");\n+        assert (connect(\"a\" + slash, \"b\") == \"a\" + slash + \"b\");\n+    }\n+\n+    fn ps() -> str {\n+        path_sep()\n+    }\n+\n+    fn aps() -> str {\n+        \"/\"\n+    }\n+\n+    #[test]\n+    fn split1() {\n+        let actual = split(\"a\" + ps() + \"b\");\n+        let expected = [\"a\", \"b\"];\n+        assert actual == expected;\n+    }\n+\n+    #[test]\n+    fn split2() {\n+        let actual = split(\"a\" + aps() + \"b\");\n+        let expected = [\"a\", \"b\"];\n+        assert actual == expected;\n+    }\n+\n+    #[test]\n+    fn split3() {\n+        let actual = split(ps() + \"a\" + ps() + \"b\");\n+        let expected = [\"a\", \"b\"];\n+        assert actual == expected;\n+    }\n+\n+    #[test]\n+    fn split4() {\n+        let actual = split(\"a\" + ps() + \"b\" + aps() + \"c\");\n+        let expected = [\"a\", \"b\", \"c\"];\n+        assert actual == expected;\n+    }\n+\n+    #[test]\n+    fn normalize1() {\n+        let actual = normalize(\"a/b/..\");\n+        let expected = \"a\";\n+        assert actual == expected;\n+    }\n+\n+    #[test]\n+    fn normalize2() {\n+        let actual = normalize(\"/a/b/..\");\n+        let expected = \"/a\";\n+        assert actual == expected;\n+    }\n+\n+    #[test]\n+    fn normalize3() {\n+        let actual = normalize(\"a/../b\");\n+        let expected = \"b\";\n+        assert actual == expected;\n+    }\n+\n+    #[test]\n+    fn normalize4() {\n+        let actual = normalize(\"/a/../b\");\n+        let expected = \"/b\";\n+        assert actual == expected;\n+    }\n+\n+    #[test]\n+    fn normalize5() {\n+        let actual = normalize(\"a/.\");\n+        let expected = \"a\";\n+        assert actual == expected;\n+    }\n+\n+    #[test]\n+    fn normalize6() {\n+        let actual = normalize(\"a/./b/\");\n+        let expected = \"a/b/\";\n+        assert actual == expected;\n+    }\n+\n+    #[test]\n+    fn normalize7() {\n+        let actual = normalize(\"a/..\");\n+        let expected = \".\";\n+        assert actual == expected;\n+    }\n+\n+    #[test]\n+    fn normalize8() {\n+        let actual = normalize(\"../../..\");\n+        let expected = \"../../..\";\n+        assert actual == expected;\n+    }\n+\n+    #[test]\n+    fn normalize9() {\n+        let actual = normalize(\"a/b/../../..\");\n+        let expected = \"..\";\n+        assert actual == expected;\n+    }\n+\n+    #[test]\n+    fn normalize10() {\n+        let actual = normalize(\"/a/b/c/../d/./../../e/\");\n+        let expected = \"/a/e/\";\n+        log(error, actual);\n+        assert actual == expected;\n+    }\n+\n+    #[test]\n+    fn normalize11() {\n+        let actual = normalize(\"/a/..\");\n+        let expected = \"/\";\n+        assert actual == expected;\n+    }\n+\n+    #[test]\n+    #[cfg(target_os = \"win32\")]\n+    fn normalize12() {\n+        let actual = normalize(\"C:/whatever\");\n+        let expected = \"C:/whatever\";\n+        log(error, actual);\n+        assert actual == expected;\n+    }\n+\n+    #[test]\n+    #[cfg(target_os = \"win32\")]\n+    fn path_is_absolute_win32() {\n+        assert path_is_absolute(\"C:/whatever\");\n+    }\n+\n+    #[test]\n+    fn splitext_empty() {\n+        let (base, ext) = splitext(\"\");\n+        assert base == \"\";\n+        assert ext == \"\";\n+    }\n+\n+    #[test]\n+    fn splitext_ext() {\n+        let (base, ext) = splitext(\"grum.exe\");\n+        assert base == \"grum\";\n+        assert ext == \".exe\";\n+    }\n+\n+    #[test]\n+    fn splitext_noext() {\n+        let (base, ext) = splitext(\"grum\");\n+        assert base == \"grum\";\n+        assert ext == \"\";\n+    }\n+\n+    #[test]\n+    fn splitext_dotfile() {\n+        let (base, ext) = splitext(\".grum\");\n+        assert base == \".grum\";\n+        assert ext == \"\";\n+    }\n+\n+    #[test]\n+    fn splitext_path_ext() {\n+        let (base, ext) = splitext(\"oh/grum.exe\");\n+        assert base == \"oh/grum\";\n+        assert ext == \".exe\";\n+    }\n+\n+    #[test]\n+    fn splitext_path_noext() {\n+        let (base, ext) = splitext(\"oh/grum\");\n+        assert base == \"oh/grum\";\n+        assert ext == \"\";\n+    }\n+\n+    #[test]\n+    fn splitext_dot_in_path() {\n+        let (base, ext) = splitext(\"oh.my/grum\");\n+        assert base == \"oh.my/grum\";\n+        assert ext == \"\";\n+    }\n+\n+    #[test]\n+    fn splitext_nobasename() {\n+        let (base, ext) = splitext(\"oh.my/\");\n+        assert base == \"oh.my/\";\n+        assert ext == \"\";\n+    }\n+}\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:"}, {"sha": "5be3cb64037046b6bc6c0932b364434954ce6b81", "filename": "src/libcore/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dafd6498063231e2ab01575a949fcb067c404c04/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dafd6498063231e2ab01575a949fcb067c404c04/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=dafd6498063231e2ab01575a949fcb067c404c04", "patch": "@@ -1390,7 +1390,7 @@ fn as_buf<T>(s: str, f: fn(sbuf) -> T) -> T unsafe {\n /*\n Type: sbuf\n \n-An unsafe buffer of bytes. Corresponds to a C char pointer.\n+An unsafe buffer of bytes.\n */\n type sbuf = *u8;\n "}, {"sha": "27163e9f1907c24d143bec6c54b24b3f313ccfde", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dafd6498063231e2ab01575a949fcb067c404c04/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dafd6498063231e2ab01575a949fcb067c404c04/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=dafd6498063231e2ab01575a949fcb067c404c04", "patch": "@@ -996,6 +996,10 @@ fn as_buf<E,T>(v: [const E], f: fn(*E) -> T) -> T unsafe {\n     let buf = unsafe::to_ptr(v); f(buf)\n }\n \n+fn as_mut_buf<E,T>(v: [mutable E], f: fn(*mutable E) -> T) -> T unsafe {\n+    let buf = unsafe::to_ptr(v) as *mutable E; f(buf)\n+}\n+\n impl vec_len<T> for [T] {\n     fn len() -> uint { len(self) }\n }"}]}