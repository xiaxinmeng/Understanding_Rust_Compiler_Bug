{"sha": "a4cafe46c2f82d8c465dce0276197a630cb91127", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0Y2FmZTQ2YzJmODJkOGM0NjVkY2UwMjc2MTk3YTYzMGNiOTExMjc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-06T11:06:04Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-06T11:20:58Z"}, "message": "runtest: rustfmt", "tree": {"sha": "5cde155ed1551127bbf6b4c0fe1094d7179c53f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5cde155ed1551127bbf6b4c0fe1094d7179c53f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4cafe46c2f82d8c465dce0276197a630cb91127", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4cafe46c2f82d8c465dce0276197a630cb91127", "html_url": "https://github.com/rust-lang/rust/commit/a4cafe46c2f82d8c465dce0276197a630cb91127", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4cafe46c2f82d8c465dce0276197a630cb91127/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a62910baca04512daa08d0f3867e47a65ab0fdcd", "url": "https://api.github.com/repos/rust-lang/rust/commits/a62910baca04512daa08d0f3867e47a65ab0fdcd", "html_url": "https://github.com/rust-lang/rust/commit/a62910baca04512daa08d0f3867e47a65ab0fdcd"}], "stats": {"total": 1890, "additions": 1136, "deletions": 754}, "files": [{"sha": "d8ccb285cc513b54d4c7af562997982a017207d1", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 312, "deletions": 143, "changes": 455, "blob_url": "https://github.com/rust-lang/rust/blob/a4cafe46c2f82d8c465dce0276197a630cb91127/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4cafe46c2f82d8c465dce0276197a630cb91127/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=a4cafe46c2f82d8c465dce0276197a630cb91127", "patch": "@@ -9,22 +9,20 @@\n // except according to those terms.\n \n #![crate_name = \"compiletest\"]\n-\n #![feature(test)]\n #![feature(slice_rotate)]\n-\n #![deny(warnings)]\n \n+extern crate diff;\n+extern crate env_logger;\n+extern crate filetime;\n+extern crate getopts;\n #[cfg(unix)]\n extern crate libc;\n-extern crate test;\n-extern crate getopts;\n-extern crate rustc_serialize;\n #[macro_use]\n extern crate log;\n-extern crate env_logger;\n-extern crate filetime;\n-extern crate diff;\n+extern crate rustc_serialize;\n+extern crate test;\n \n use std::env;\n use std::ffi::OsString;\n@@ -35,8 +33,8 @@ use std::process::Command;\n use filetime::FileTime;\n use getopts::Options;\n use common::Config;\n-use common::{Pretty, DebugInfoGdb, DebugInfoLldb, Mode};\n-use test::{TestPaths, ColorConfig};\n+use common::{DebugInfoGdb, DebugInfoLldb, Mode, Pretty};\n+use test::{ColorConfig, TestPaths};\n use util::logv;\n \n use self::header::EarlyProps;\n@@ -63,53 +61,168 @@ fn main() {\n     run_tests(&config);\n }\n \n-pub fn parse_config(args: Vec<String> ) -> Config {\n-\n+pub fn parse_config(args: Vec<String>) -> Config {\n     let mut opts = Options::new();\n-    opts.reqopt(\"\", \"compile-lib-path\", \"path to host shared libraries\", \"PATH\")\n-        .reqopt(\"\", \"run-lib-path\", \"path to target shared libraries\", \"PATH\")\n-        .reqopt(\"\", \"rustc-path\", \"path to rustc to use for compiling\", \"PATH\")\n-        .optopt(\"\", \"rustdoc-path\", \"path to rustdoc to use for compiling\", \"PATH\")\n-        .reqopt(\"\", \"lldb-python\", \"path to python to use for doc tests\", \"PATH\")\n-        .reqopt(\"\", \"docck-python\", \"path to python to use for doc tests\", \"PATH\")\n-        .optopt(\"\", \"valgrind-path\", \"path to Valgrind executable for Valgrind tests\", \"PROGRAM\")\n-        .optflag(\"\", \"force-valgrind\", \"fail if Valgrind tests cannot be run under Valgrind\")\n-        .optopt(\"\", \"llvm-filecheck\", \"path to LLVM's FileCheck binary\", \"DIR\")\n+    opts.reqopt(\n+        \"\",\n+        \"compile-lib-path\",\n+        \"path to host shared libraries\",\n+        \"PATH\",\n+    ).reqopt(\n+            \"\",\n+            \"run-lib-path\",\n+            \"path to target shared libraries\",\n+            \"PATH\",\n+        )\n+        .reqopt(\n+            \"\",\n+            \"rustc-path\",\n+            \"path to rustc to use for compiling\",\n+            \"PATH\",\n+        )\n+        .optopt(\n+            \"\",\n+            \"rustdoc-path\",\n+            \"path to rustdoc to use for compiling\",\n+            \"PATH\",\n+        )\n+        .reqopt(\n+            \"\",\n+            \"lldb-python\",\n+            \"path to python to use for doc tests\",\n+            \"PATH\",\n+        )\n+        .reqopt(\n+            \"\",\n+            \"docck-python\",\n+            \"path to python to use for doc tests\",\n+            \"PATH\",\n+        )\n+        .optopt(\n+            \"\",\n+            \"valgrind-path\",\n+            \"path to Valgrind executable for Valgrind tests\",\n+            \"PROGRAM\",\n+        )\n+        .optflag(\n+            \"\",\n+            \"force-valgrind\",\n+            \"fail if Valgrind tests cannot be run under Valgrind\",\n+        )\n+        .optopt(\n+            \"\",\n+            \"llvm-filecheck\",\n+            \"path to LLVM's FileCheck binary\",\n+            \"DIR\",\n+        )\n         .reqopt(\"\", \"src-base\", \"directory to scan for test files\", \"PATH\")\n-        .reqopt(\"\", \"build-base\", \"directory to deposit test outputs\", \"PATH\")\n-        .reqopt(\"\", \"stage-id\", \"the target-stage identifier\", \"stageN-TARGET\")\n-        .reqopt(\"\", \"mode\", \"which sort of compile tests to run\",\n-                \"(compile-fail|parse-fail|run-fail|run-pass|\\\n-                 run-pass-valgrind|pretty|debug-info|incremental|mir-opt)\")\n+        .reqopt(\n+            \"\",\n+            \"build-base\",\n+            \"directory to deposit test outputs\",\n+            \"PATH\",\n+        )\n+        .reqopt(\n+            \"\",\n+            \"stage-id\",\n+            \"the target-stage identifier\",\n+            \"stageN-TARGET\",\n+        )\n+        .reqopt(\n+            \"\",\n+            \"mode\",\n+            \"which sort of compile tests to run\",\n+            \"(compile-fail|parse-fail|run-fail|run-pass|\\\n+             run-pass-valgrind|pretty|debug-info|incremental|mir-opt)\",\n+        )\n         .optflag(\"\", \"ignored\", \"run tests marked as ignored\")\n         .optflag(\"\", \"exact\", \"filters match exactly\")\n-        .optopt(\"\", \"runtool\", \"supervisor program to run tests under \\\n-                                (eg. emulator, valgrind)\", \"PROGRAM\")\n-        .optopt(\"\", \"host-rustcflags\", \"flags to pass to rustc for host\", \"FLAGS\")\n-        .optopt(\"\", \"target-rustcflags\", \"flags to pass to rustc for target\", \"FLAGS\")\n+        .optopt(\n+            \"\",\n+            \"runtool\",\n+            \"supervisor program to run tests under \\\n+             (eg. emulator, valgrind)\",\n+            \"PROGRAM\",\n+        )\n+        .optopt(\n+            \"\",\n+            \"host-rustcflags\",\n+            \"flags to pass to rustc for host\",\n+            \"FLAGS\",\n+        )\n+        .optopt(\n+            \"\",\n+            \"target-rustcflags\",\n+            \"flags to pass to rustc for target\",\n+            \"FLAGS\",\n+        )\n         .optflag(\"\", \"verbose\", \"run tests verbosely, showing all output\")\n-        .optflag(\"\", \"quiet\", \"print one character per test instead of one line\")\n+        .optflag(\n+            \"\",\n+            \"quiet\",\n+            \"print one character per test instead of one line\",\n+        )\n         .optopt(\"\", \"color\", \"coloring: auto, always, never\", \"WHEN\")\n         .optopt(\"\", \"logfile\", \"file to log test execution to\", \"FILE\")\n         .optopt(\"\", \"target\", \"the target to build for\", \"TARGET\")\n         .optopt(\"\", \"host\", \"the host to build for\", \"HOST\")\n-        .optopt(\"\", \"gdb\", \"path to GDB to use for GDB debuginfo tests\", \"PATH\")\n-        .optopt(\"\", \"lldb-version\", \"the version of LLDB used\", \"VERSION STRING\")\n-        .optopt(\"\", \"llvm-version\", \"the version of LLVM used\", \"VERSION STRING\")\n+        .optopt(\n+            \"\",\n+            \"gdb\",\n+            \"path to GDB to use for GDB debuginfo tests\",\n+            \"PATH\",\n+        )\n+        .optopt(\n+            \"\",\n+            \"lldb-version\",\n+            \"the version of LLDB used\",\n+            \"VERSION STRING\",\n+        )\n+        .optopt(\n+            \"\",\n+            \"llvm-version\",\n+            \"the version of LLVM used\",\n+            \"VERSION STRING\",\n+        )\n         .optflag(\"\", \"system-llvm\", \"is LLVM the system LLVM\")\n-        .optopt(\"\", \"android-cross-path\", \"Android NDK standalone path\", \"PATH\")\n+        .optopt(\n+            \"\",\n+            \"android-cross-path\",\n+            \"Android NDK standalone path\",\n+            \"PATH\",\n+        )\n         .optopt(\"\", \"adb-path\", \"path to the android debugger\", \"PATH\")\n-        .optopt(\"\", \"adb-test-dir\", \"path to tests for the android debugger\", \"PATH\")\n-        .optopt(\"\", \"lldb-python-dir\", \"directory containing LLDB's python module\", \"PATH\")\n+        .optopt(\n+            \"\",\n+            \"adb-test-dir\",\n+            \"path to tests for the android debugger\",\n+            \"PATH\",\n+        )\n+        .optopt(\n+            \"\",\n+            \"lldb-python-dir\",\n+            \"directory containing LLDB's python module\",\n+            \"PATH\",\n+        )\n         .reqopt(\"\", \"cc\", \"path to a C compiler\", \"PATH\")\n         .reqopt(\"\", \"cxx\", \"path to a C++ compiler\", \"PATH\")\n         .reqopt(\"\", \"cflags\", \"flags for the C compiler\", \"FLAGS\")\n         .optopt(\"\", \"ar\", \"path to an archiver\", \"PATH\")\n         .optopt(\"\", \"linker\", \"path to a linker\", \"PATH\")\n-        .reqopt(\"\", \"llvm-components\", \"list of LLVM components built in\", \"LIST\")\n+        .reqopt(\n+            \"\",\n+            \"llvm-components\",\n+            \"list of LLVM components built in\",\n+            \"LIST\",\n+        )\n         .reqopt(\"\", \"llvm-cxxflags\", \"C++ flags for LLVM\", \"FLAGS\")\n         .optopt(\"\", \"nodejs\", \"the name of nodejs\", \"PATH\")\n-        .optopt(\"\", \"remote-test-client\", \"path to the remote test client\", \"PATH\")\n+        .optopt(\n+            \"\",\n+            \"remote-test-client\",\n+            \"path to the remote test client\",\n+            \"PATH\",\n+        )\n         .optflag(\"h\", \"help\", \"show this message\");\n \n     let (argv0, args_) = args.split_first().unwrap();\n@@ -120,11 +233,10 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n         panic!()\n     }\n \n-    let matches =\n-        &match opts.parse(args_) {\n-          Ok(m) => m,\n-          Err(f) => panic!(\"{:?}\", f)\n-        };\n+    let matches = &match opts.parse(args_) {\n+        Ok(m) => m,\n+        Err(f) => panic!(\"{:?}\", f),\n+    };\n \n     if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n         let message = format!(\"Usage: {} [OPTIONS]  [TESTNAME...]\", argv0);\n@@ -154,7 +266,10 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n         Some(\"auto\") | None => ColorConfig::AutoColor,\n         Some(\"always\") => ColorConfig::AlwaysColor,\n         Some(\"never\") => ColorConfig::NeverColor,\n-        Some(x) => panic!(\"argument for --color must be auto, always, or never, but found `{}`\", x),\n+        Some(x) => panic!(\n+            \"argument for --color must be auto, always, or never, but found `{}`\",\n+            x\n+        ),\n     };\n \n     Config {\n@@ -170,7 +285,11 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n         src_base: opt_path(matches, \"src-base\"),\n         build_base: opt_path(matches, \"build-base\"),\n         stage_id: matches.opt_str(\"stage-id\").unwrap(),\n-        mode: matches.opt_str(\"mode\").unwrap().parse().expect(\"invalid mode\"),\n+        mode: matches\n+            .opt_str(\"mode\")\n+            .unwrap()\n+            .parse()\n+            .expect(\"invalid mode\"),\n         run_ignored: matches.opt_present(\"ignored\"),\n         filter: matches.free.first().cloned(),\n         filter_exact: matches.opt_present(\"exact\"),\n@@ -189,10 +308,9 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n         android_cross_path: opt_path(matches, \"android-cross-path\"),\n         adb_path: opt_str2(matches.opt_str(\"adb-path\")),\n         adb_test_dir: opt_str2(matches.opt_str(\"adb-test-dir\")),\n-        adb_device_status:\n-            opt_str2(matches.opt_str(\"target\")).contains(\"android\") &&\n-            \"(none)\" != opt_str2(matches.opt_str(\"adb-test-dir\")) &&\n-            !opt_str2(matches.opt_str(\"adb-test-dir\")).is_empty(),\n+        adb_device_status: opt_str2(matches.opt_str(\"target\")).contains(\"android\")\n+            && \"(none)\" != opt_str2(matches.opt_str(\"adb-test-dir\"))\n+            && !opt_str2(matches.opt_str(\"adb-test-dir\")).is_empty(),\n         lldb_python_dir: matches.opt_str(\"lldb-python-dir\"),\n         verbose: matches.opt_present(\"verbose\"),\n         quiet: matches.opt_present(\"quiet\"),\n@@ -213,7 +331,10 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n pub fn log_config(config: &Config) {\n     let c = config;\n     logv(c, \"configuration:\".to_string());\n-    logv(c, format!(\"compile_lib_path: {:?}\", config.compile_lib_path));\n+    logv(\n+        c,\n+        format!(\"compile_lib_path: {:?}\", config.compile_lib_path),\n+    );\n     logv(c, format!(\"run_lib_path: {:?}\", config.run_lib_path));\n     logv(c, format!(\"rustc_path: {:?}\", config.rustc_path.display()));\n     logv(c, format!(\"rustdoc_path: {:?}\", config.rustdoc_path));\n@@ -222,24 +343,38 @@ pub fn log_config(config: &Config) {\n     logv(c, format!(\"stage_id: {}\", config.stage_id));\n     logv(c, format!(\"mode: {}\", config.mode));\n     logv(c, format!(\"run_ignored: {}\", config.run_ignored));\n-    logv(c, format!(\"filter: {}\",\n-                    opt_str(&config.filter\n-                                   .as_ref()\n-                                   .map(|re| re.to_owned()))));\n+    logv(\n+        c,\n+        format!(\n+            \"filter: {}\",\n+            opt_str(&config.filter.as_ref().map(|re| re.to_owned()))\n+        ),\n+    );\n     logv(c, format!(\"filter_exact: {}\", config.filter_exact));\n     logv(c, format!(\"runtool: {}\", opt_str(&config.runtool)));\n-    logv(c, format!(\"host-rustcflags: {}\",\n-                    opt_str(&config.host_rustcflags)));\n-    logv(c, format!(\"target-rustcflags: {}\",\n-                    opt_str(&config.target_rustcflags)));\n+    logv(\n+        c,\n+        format!(\"host-rustcflags: {}\", opt_str(&config.host_rustcflags)),\n+    );\n+    logv(\n+        c,\n+        format!(\"target-rustcflags: {}\", opt_str(&config.target_rustcflags)),\n+    );\n     logv(c, format!(\"target: {}\", config.target));\n     logv(c, format!(\"host: {}\", config.host));\n-    logv(c, format!(\"android-cross-path: {:?}\",\n-                    config.android_cross_path.display()));\n+    logv(\n+        c,\n+        format!(\n+            \"android-cross-path: {:?}\",\n+            config.android_cross_path.display()\n+        ),\n+    );\n     logv(c, format!(\"adb_path: {:?}\", config.adb_path));\n     logv(c, format!(\"adb_test_dir: {:?}\", config.adb_test_dir));\n-    logv(c, format!(\"adb_device_status: {}\",\n-                    config.adb_device_status));\n+    logv(\n+        c,\n+        format!(\"adb_device_status: {}\", config.adb_device_status),\n+    );\n     logv(c, format!(\"ar: {}\", config.ar));\n     logv(c, format!(\"linker: {:?}\", config.linker));\n     logv(c, format!(\"verbose: {}\", config.verbose));\n@@ -264,8 +399,11 @@ pub fn opt_str2(maybestr: Option<String>) -> String {\n pub fn run_tests(config: &Config) {\n     if config.target.contains(\"android\") {\n         if let DebugInfoGdb = config.mode {\n-            println!(\"{} debug-info test uses tcp 5039 port.\\\n-                     please reserve it\", config.target);\n+            println!(\n+                \"{} debug-info test uses tcp 5039 port.\\\n+                 please reserve it\",\n+                config.target\n+            );\n \n             // android debug-info test uses remote debugger so, we test 1 thread\n             // at once as they're all sharing the same TCP port to communicate\n@@ -281,12 +419,14 @@ pub fn run_tests(config: &Config) {\n         DebugInfoLldb => {\n             if let Some(lldb_version) = config.lldb_version.as_ref() {\n                 if is_blacklisted_lldb_version(&lldb_version[..]) {\n-                    println!(\"WARNING: The used version of LLDB ({}) has a \\\n-                              known issue that breaks debuginfo tests. See \\\n-                              issue #32520 for more information. Skipping all \\\n-                              LLDB-based tests!\",\n-                             lldb_version);\n-                    return\n+                    println!(\n+                        \"WARNING: The used version of LLDB ({}) has a \\\n+                         known issue that breaks debuginfo tests. See \\\n+                         issue #32520 for more information. Skipping all \\\n+                         LLDB-based tests!\",\n+                        lldb_version\n+                    );\n+                    return;\n                 }\n             }\n \n@@ -297,11 +437,12 @@ pub fn run_tests(config: &Config) {\n         }\n \n         DebugInfoGdb => {\n-            if config.remote_test_client.is_some() &&\n-               !config.target.contains(\"android\"){\n-                println!(\"WARNING: debuginfo tests are not available when \\\n-                          testing with remote\");\n-                return\n+            if config.remote_test_client.is_some() && !config.target.contains(\"android\") {\n+                println!(\n+                    \"WARNING: debuginfo tests are not available when \\\n+                     testing with remote\"\n+                );\n+                return;\n             }\n         }\n         _ => { /* proceed */ }\n@@ -317,7 +458,9 @@ pub fn run_tests(config: &Config) {\n     // sadly osx needs some file descriptor limits raised for running tests in\n     // parallel (especially when we have lots and lots of child processes).\n     // For context, see #8904\n-    unsafe { raise_fd_limit::raise_fd_limit(); }\n+    unsafe {\n+        raise_fd_limit::raise_fd_limit();\n+    }\n     // Prevent issue #21352 UAC blocking .exe containing 'patch' etc. on Windows\n     // If #11207 is resolved (adding manifest to .exe) this becomes unnecessary\n     env::set_var(\"__COMPAT_LAYER\", \"RunAsInvoker\");\n@@ -346,7 +489,7 @@ pub fn test_opts(config: &Config) -> test::TestOpts {\n         bench_benchmarks: true,\n         nocapture: match env::var(\"RUST_TEST_NOCAPTURE\") {\n             Ok(val) => &val != \"0\",\n-            Err(_) => false\n+            Err(_) => false,\n         },\n         color: config.color,\n         test_threads: None,\n@@ -357,24 +500,25 @@ pub fn test_opts(config: &Config) -> test::TestOpts {\n }\n \n pub fn make_tests(config: &Config) -> Vec<test::TestDescAndFn> {\n-    debug!(\"making tests from {:?}\",\n-           config.src_base.display());\n+    debug!(\"making tests from {:?}\", config.src_base.display());\n     let mut tests = Vec::new();\n-    collect_tests_from_dir(config,\n-                           &config.src_base,\n-                           &config.src_base,\n-                           &PathBuf::new(),\n-                           &mut tests)\n-        .unwrap();\n+    collect_tests_from_dir(\n+        config,\n+        &config.src_base,\n+        &config.src_base,\n+        &PathBuf::new(),\n+        &mut tests,\n+    ).unwrap();\n     tests\n }\n \n-fn collect_tests_from_dir(config: &Config,\n-                          base: &Path,\n-                          dir: &Path,\n-                          relative_dir_path: &Path,\n-                          tests: &mut Vec<test::TestDescAndFn>)\n-                          -> io::Result<()> {\n+fn collect_tests_from_dir(\n+    config: &Config,\n+    base: &Path,\n+    dir: &Path,\n+    relative_dir_path: &Path,\n+    tests: &mut Vec<test::TestDescAndFn>,\n+) -> io::Result<()> {\n     // Ignore directories that contain a file\n     // `compiletest-ignore-dir`.\n     for file in fs::read_dir(dir)? {\n@@ -390,7 +534,7 @@ fn collect_tests_from_dir(config: &Config,\n                 relative_dir: relative_dir_path.parent().unwrap().to_path_buf(),\n             };\n             tests.push(make_test(config, &paths));\n-            return Ok(())\n+            return Ok(());\n         }\n     }\n \n@@ -430,11 +574,7 @@ fn collect_tests_from_dir(config: &Config,\n                 fs::create_dir_all(&build_dir).unwrap();\n             } else {\n                 debug!(\"found directory: {:?}\", file_path.display());\n-                collect_tests_from_dir(config,\n-                                       base,\n-                                       &file_path,\n-                                       &relative_file_path,\n-                                       tests)?;\n+                collect_tests_from_dir(config, base, &file_path, &relative_file_path, tests)?;\n             }\n         } else {\n             debug!(\"found other file/directory: {:?}\", file_path.display());\n@@ -467,13 +607,13 @@ pub fn make_test(config: &Config, testpaths: &TestPaths) -> test::TestDescAndFn\n             test::ShouldPanic::Yes\n         } else {\n             test::ShouldPanic::No\n-        }\n+        },\n     };\n \n     // Debugging emscripten code doesn't make sense today\n-    let ignore = early_props.ignore || !up_to_date(config, testpaths, &early_props) ||\n-                 (config.mode == DebugInfoGdb || config.mode == DebugInfoLldb) &&\n-                  config.target.contains(\"emscripten\");\n+    let ignore = early_props.ignore || !up_to_date(config, testpaths, &early_props)\n+        || (config.mode == DebugInfoGdb || config.mode == DebugInfoLldb)\n+            && config.target.contains(\"emscripten\");\n \n     test::TestDescAndFn {\n         desc: test::TestDesc {\n@@ -487,28 +627,32 @@ pub fn make_test(config: &Config, testpaths: &TestPaths) -> test::TestDescAndFn\n }\n \n fn stamp(config: &Config, testpaths: &TestPaths) -> PathBuf {\n-    let stamp_name = format!(\"{}-{}.stamp\",\n-                             testpaths.file.file_name().unwrap()\n-                                           .to_str().unwrap(),\n-                             config.stage_id);\n-    config.build_base.canonicalize()\n-          .unwrap_or_else(|_| config.build_base.clone())\n-          .join(&testpaths.relative_dir)\n-          .join(stamp_name)\n+    let stamp_name = format!(\n+        \"{}-{}.stamp\",\n+        testpaths.file.file_name().unwrap().to_str().unwrap(),\n+        config.stage_id\n+    );\n+    config\n+        .build_base\n+        .canonicalize()\n+        .unwrap_or_else(|_| config.build_base.clone())\n+        .join(&testpaths.relative_dir)\n+        .join(stamp_name)\n }\n \n fn up_to_date(config: &Config, testpaths: &TestPaths, props: &EarlyProps) -> bool {\n-    let rust_src_dir = config.find_rust_src_root().expect(\n-        \"Could not find Rust source root\",\n-    );\n+    let rust_src_dir = config\n+        .find_rust_src_root()\n+        .expect(\"Could not find Rust source root\");\n     let stamp = mtime(&stamp(config, testpaths));\n     let mut inputs = vec![mtime(&testpaths.file), mtime(&config.rustc_path)];\n     for aux in props.aux.iter() {\n-        inputs.push(mtime(\n-            &testpaths.file.parent().unwrap().join(\"auxiliary\").join(\n-                aux,\n-            ),\n-        ));\n+        inputs.push(mtime(&testpaths\n+            .file\n+            .parent()\n+            .unwrap()\n+            .join(\"auxiliary\")\n+            .join(aux)));\n     }\n     // Relevant pretty printer files\n     let pretty_printer_files = [\n@@ -533,17 +677,16 @@ fn up_to_date(config: &Config, testpaths: &TestPaths, props: &EarlyProps) -> boo\n }\n \n fn mtime(path: &Path) -> FileTime {\n-    fs::metadata(path).map(|f| {\n-        FileTime::from_last_modification_time(&f)\n-    }).unwrap_or_else(|_| FileTime::zero())\n+    fs::metadata(path)\n+        .map(|f| FileTime::from_last_modification_time(&f))\n+        .unwrap_or_else(|_| FileTime::zero())\n }\n \n pub fn make_test_name(config: &Config, testpaths: &TestPaths) -> test::TestName {\n     // Convert a complete path to something like\n     //\n     //    run-pass/foo/bar/baz.rs\n-    let path =\n-        PathBuf::from(config.src_base.file_name().unwrap())\n+    let path = PathBuf::from(config.src_base.file_name().unwrap())\n         .join(&testpaths.relative_dir)\n         .join(&testpaths.file.file_name().unwrap());\n     test::DynTestName(format!(\"[{}] {}\", config.mode, path.display()))\n@@ -552,9 +695,7 @@ pub fn make_test_name(config: &Config, testpaths: &TestPaths) -> test::TestName\n pub fn make_test_closure(config: &Config, testpaths: &TestPaths) -> test::TestFn {\n     let config = config.clone();\n     let testpaths = testpaths.clone();\n-    test::DynTestFn(Box::new(move |()| {\n-        runtest::run(config, &testpaths)\n-    }))\n+    test::DynTestFn(Box::new(move |()| runtest::run(config, &testpaths)))\n }\n \n /// Returns (Path to GDB, GDB Version, GDB has Rust Support)\n@@ -572,9 +713,17 @@ fn analyze_gdb(gdb: Option<String>) -> (Option<String>, Option<u32>, bool) {\n         Some(ref s) => s,\n     };\n \n-    let version_line = Command::new(gdb).arg(\"--version\").output().map(|output| {\n-        String::from_utf8_lossy(&output.stdout).lines().next().unwrap().to_string()\n-    }).ok();\n+    let version_line = Command::new(gdb)\n+        .arg(\"--version\")\n+        .output()\n+        .map(|output| {\n+            String::from_utf8_lossy(&output.stdout)\n+                .lines()\n+                .next()\n+                .unwrap()\n+                .to_string()\n+        })\n+        .ok();\n \n     let version = match version_line {\n         Some(line) => extract_gdb_version(&line),\n@@ -600,7 +749,7 @@ fn extract_gdb_version(full_version_line: &str) -> Option<u32> {\n     for (pos, c) in full_version_line.char_indices() {\n         if prev_was_digit || !c.is_digit(10) {\n             prev_was_digit = c.is_digit(10);\n-            continue\n+            continue;\n         }\n \n         prev_was_digit = true;\n@@ -623,10 +772,15 @@ fn extract_gdb_version(full_version_line: &str) -> Option<u32> {\n             Some(idx) => if line.as_bytes()[idx] == b'.' {\n                 let patch = &line[idx + 1..];\n \n-                let patch_len = patch.find(|c: char| !c.is_digit(10))\n-                                                       .unwrap_or_else(|| patch.len());\n+                let patch_len = patch\n+                    .find(|c: char| !c.is_digit(10))\n+                    .unwrap_or_else(|| patch.len());\n                 let patch = &patch[..patch_len];\n-                let patch = if patch_len > 3 || patch_len == 0 { None } else { Some(patch) };\n+                let patch = if patch_len > 3 || patch_len == 0 {\n+                    None\n+                } else {\n+                    Some(patch)\n+                };\n \n                 (&line[..idx], patch)\n             } else {\n@@ -666,21 +820,36 @@ fn extract_lldb_version(full_version_line: Option<String>) -> Option<String> {\n             let full_version_line = full_version_line.trim();\n \n             for (pos, l) in full_version_line.char_indices() {\n-                if l != 'l' && l != 'L' { continue }\n-                if pos + 5 >= full_version_line.len() { continue }\n+                if l != 'l' && l != 'L' {\n+                    continue;\n+                }\n+                if pos + 5 >= full_version_line.len() {\n+                    continue;\n+                }\n                 let l = full_version_line[pos + 1..].chars().next().unwrap();\n-                if l != 'l' && l != 'L' { continue }\n+                if l != 'l' && l != 'L' {\n+                    continue;\n+                }\n                 let d = full_version_line[pos + 2..].chars().next().unwrap();\n-                if d != 'd' && d != 'D' { continue }\n+                if d != 'd' && d != 'D' {\n+                    continue;\n+                }\n                 let b = full_version_line[pos + 3..].chars().next().unwrap();\n-                if b != 'b' && b != 'B' { continue }\n+                if b != 'b' && b != 'B' {\n+                    continue;\n+                }\n                 let dash = full_version_line[pos + 4..].chars().next().unwrap();\n-                if dash != '-' { continue }\n+                if dash != '-' {\n+                    continue;\n+                }\n \n-                let vers = full_version_line[pos + 5..].chars().take_while(|c| {\n-                    c.is_digit(10)\n-                }).collect::<String>();\n-                if !vers.is_empty() { return Some(vers) }\n+                let vers = full_version_line[pos + 5..]\n+                    .chars()\n+                    .take_while(|c| c.is_digit(10))\n+                    .collect::<String>();\n+                if !vers.is_empty() {\n+                    return Some(vers);\n+                }\n             }\n         }\n     }"}, {"sha": "d89dc855cb03c7623264954fbb6f2c1b87b80bc6", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 824, "deletions": 611, "changes": 1435, "blob_url": "https://github.com/rust-lang/rust/blob/a4cafe46c2f82d8c465dce0276197a630cb91127/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4cafe46c2f82d8c465dce0276197a630cb91127/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=a4cafe46c2f82d8c465dce0276197a630cb91127", "patch": "@@ -10,10 +10,10 @@\n \n use common::Config;\n use common::{CompileFail, ParseFail, Pretty, RunFail, RunPass, RunPassValgrind};\n-use common::{Codegen, DebugInfoLldb, DebugInfoGdb, Rustdoc, CodegenUnits};\n-use common::{Incremental, RunMake, Ui, MirOpt};\n+use common::{Codegen, CodegenUnits, DebugInfoGdb, DebugInfoLldb, Rustdoc};\n+use common::{Incremental, MirOpt, RunMake, Ui};\n use diff;\n-use errors::{self, ErrorKind, Error};\n+use errors::{self, Error, ErrorKind};\n use filetime::FileTime;\n use json;\n use header::TestProps;\n@@ -24,12 +24,12 @@ use std::collections::HashMap;\n use std::collections::HashSet;\n use std::env;\n use std::ffi::OsString;\n-use std::fs::{self, File, create_dir_all};\n+use std::fs::{self, create_dir_all, File};\n use std::fmt;\n use std::io::prelude::*;\n use std::io::{self, BufReader};\n use std::path::{Path, PathBuf};\n-use std::process::{Command, Output, ExitStatus, Stdio, Child};\n+use std::process::{Child, Command, ExitStatus, Output, Stdio};\n use std::str;\n \n use extract_gdb_version;\n@@ -49,7 +49,6 @@ pub fn dylib_env_var() -> &'static str {\n \n pub fn run(config: Config, testpaths: &TestPaths) {\n     match &*config.target {\n-\n         \"arm-linux-androideabi\" | \"armv7-linux-androideabi\" | \"aarch64-linux-android\" => {\n             if !config.adb_device_status {\n                 panic!(\"android device not available\");\n@@ -71,24 +70,24 @@ pub fn run(config: Config, testpaths: &TestPaths) {\n     debug!(\"running {:?}\", testpaths.file.display());\n     let base_props = TestProps::from_file(&testpaths.file, None, &config);\n \n-    let base_cx = TestCx { config: &config,\n-                           props: &base_props,\n-                           testpaths,\n-                           revision: None };\n+    let base_cx = TestCx {\n+        config: &config,\n+        props: &base_props,\n+        testpaths,\n+        revision: None,\n+    };\n     base_cx.init_all();\n \n     if base_props.revisions.is_empty() {\n         base_cx.run_revision()\n     } else {\n         for revision in &base_props.revisions {\n-            let revision_props = TestProps::from_file(&testpaths.file,\n-                                                      Some(revision),\n-                                                      &config);\n+            let revision_props = TestProps::from_file(&testpaths.file, Some(revision), &config);\n             let rev_cx = TestCx {\n                 config: &config,\n                 props: &revision_props,\n                 testpaths,\n-                revision: Some(revision)\n+                revision: Some(revision),\n             };\n             rev_cx.run_revision();\n         }\n@@ -103,7 +102,7 @@ struct TestCx<'test> {\n     config: &'test Config,\n     props: &'test TestProps,\n     testpaths: &'test TestPaths,\n-    revision: Option<&'test str>\n+    revision: Option<&'test str>,\n }\n \n struct DebuggerCommands {\n@@ -125,8 +124,7 @@ impl<'test> TestCx<'test> {\n     /// revisions, exactly once, with revision == None).\n     fn run_revision(&self) {\n         match self.config.mode {\n-            CompileFail |\n-            ParseFail => self.run_cfail_test(),\n+            CompileFail | ParseFail => self.run_cfail_test(),\n             RunFail => self.run_rfail_test(),\n             RunPass => self.run_rpass_test(),\n             RunPassValgrind => self.run_valgrind_test(),\n@@ -153,15 +151,14 @@ impl<'test> TestCx<'test> {\n \n         if self.props.must_compile_successfully {\n             if !proc_res.status.success() {\n-                self.fatal_proc_rec(\n-                    \"test compilation failed although it shouldn't!\",\n-                    &proc_res);\n+                self.fatal_proc_rec(\"test compilation failed although it shouldn't!\", &proc_res);\n             }\n         } else {\n             if proc_res.status.success() {\n                 self.fatal_proc_rec(\n                     &format!(\"{} test compiled successfully!\", self.config.mode)[..],\n-                    &proc_res);\n+                    &proc_res,\n+                );\n             }\n \n             self.check_correct_failure_status(&proc_res);\n@@ -215,9 +212,9 @@ impl<'test> TestCx<'test> {\n         const RUST_ERR: i32 = 101;\n         if proc_res.status.code() != Some(RUST_ERR) {\n             self.fatal_proc_rec(\n-                &format!(\"failure produced the wrong error: {}\",\n-                         proc_res.status),\n-                proc_res);\n+                &format!(\"failure produced the wrong error: {}\", proc_res.status),\n+                proc_res,\n+            );\n         }\n     }\n \n@@ -230,8 +227,10 @@ impl<'test> TestCx<'test> {\n \n         // FIXME(#41968): Move this check to tidy?\n         let expected_errors = errors::load_errors(&self.testpaths.file, self.revision);\n-        assert!(expected_errors.is_empty(),\n-                \"run-pass tests with expected warnings should be moved to ui/\");\n+        assert!(\n+            expected_errors.is_empty(),\n+            \"run-pass tests with expected warnings should be moved to ui/\"\n+        );\n \n         let proc_res = self.exec_compiled_test();\n \n@@ -256,7 +255,10 @@ impl<'test> TestCx<'test> {\n \n         let mut new_config = self.config.clone();\n         new_config.runtool = new_config.valgrind_path.clone();\n-        let new_cx = TestCx { config: &new_config, ..*self };\n+        let new_cx = TestCx {\n+            config: &new_config,\n+            ..*self\n+        };\n         proc_res = new_cx.exec_compiled_test();\n \n         if !proc_res.status.success() {\n@@ -268,28 +270,48 @@ impl<'test> TestCx<'test> {\n         if self.props.pp_exact.is_some() {\n             logv(self.config, \"testing for exact pretty-printing\".to_owned());\n         } else {\n-            logv(self.config, \"testing for converging pretty-printing\".to_owned());\n+            logv(\n+                self.config,\n+                \"testing for converging pretty-printing\".to_owned(),\n+            );\n         }\n \n-        let rounds = match self.props.pp_exact { Some(_) => 1, None => 2 };\n+        let rounds = match self.props.pp_exact {\n+            Some(_) => 1,\n+            None => 2,\n+        };\n \n         let mut src = String::new();\n-        File::open(&self.testpaths.file).unwrap().read_to_string(&mut src).unwrap();\n+        File::open(&self.testpaths.file)\n+            .unwrap()\n+            .read_to_string(&mut src)\n+            .unwrap();\n         let mut srcs = vec![src];\n \n         let mut round = 0;\n         while round < rounds {\n-            logv(self.config, format!(\"pretty-printing round {} revision {:?}\",\n-                                      round, self.revision));\n+            logv(\n+                self.config,\n+                format!(\n+                    \"pretty-printing round {} revision {:?}\",\n+                    round,\n+                    self.revision\n+                ),\n+            );\n             let proc_res = self.print_source(srcs[round].to_owned(), &self.props.pretty_mode);\n \n             if !proc_res.status.success() {\n-                self.fatal_proc_rec(&format!(\"pretty-printing failed in round {} revision {:?}\",\n-                                             round, self.revision),\n-                                    &proc_res);\n+                self.fatal_proc_rec(\n+                    &format!(\n+                        \"pretty-printing failed in round {} revision {:?}\",\n+                        round,\n+                        self.revision\n+                    ),\n+                    &proc_res,\n+                );\n             }\n \n-            let ProcRes{ stdout, .. } = proc_res;\n+            let ProcRes { stdout, .. } = proc_res;\n             srcs.push(stdout);\n             round += 1;\n         }\n@@ -298,10 +320,13 @@ impl<'test> TestCx<'test> {\n             Some(ref file) => {\n                 let filepath = self.testpaths.file.parent().unwrap().join(file);\n                 let mut s = String::new();\n-                File::open(&filepath).unwrap().read_to_string(&mut s).unwrap();\n+                File::open(&filepath)\n+                    .unwrap()\n+                    .read_to_string(&mut s)\n+                    .unwrap();\n                 s\n             }\n-            None => { srcs[srcs.len() - 2].clone() }\n+            None => srcs[srcs.len() - 2].clone(),\n         };\n         let mut actual = srcs[srcs.len() - 1].clone();\n \n@@ -315,66 +340,79 @@ impl<'test> TestCx<'test> {\n         self.compare_source(&expected, &actual);\n \n         // If we're only making sure that the output matches then just stop here\n-        if self.props.pretty_compare_only { return; }\n+        if self.props.pretty_compare_only {\n+            return;\n+        }\n \n         // Finally, let's make sure it actually appears to remain valid code\n         let proc_res = self.typecheck_source(actual);\n         if !proc_res.status.success() {\n             self.fatal_proc_rec(\"pretty-printed source does not typecheck\", &proc_res);\n         }\n \n-        if !self.props.pretty_expanded { return }\n+        if !self.props.pretty_expanded {\n+            return;\n+        }\n \n         // additionally, run `--pretty expanded` and try to build it.\n         let proc_res = self.print_source(srcs[round].clone(), \"expanded\");\n         if !proc_res.status.success() {\n             self.fatal_proc_rec(\"pretty-printing (expanded) failed\", &proc_res);\n         }\n \n-        let ProcRes{ stdout: expanded_src, .. } = proc_res;\n+        let ProcRes {\n+            stdout: expanded_src,\n+            ..\n+        } = proc_res;\n         let proc_res = self.typecheck_source(expanded_src);\n         if !proc_res.status.success() {\n             self.fatal_proc_rec(\n                 \"pretty-printed source (expanded) does not typecheck\",\n-                &proc_res);\n+                &proc_res,\n+            );\n         }\n     }\n \n     fn print_source(&self, src: String, pretty_type: &str) -> ProcRes {\n         let aux_dir = self.aux_output_dir_name();\n \n         let mut rustc = Command::new(&self.config.rustc_path);\n-        rustc.arg(\"-\")\n+        rustc\n+            .arg(\"-\")\n             .arg(\"-Zunstable-options\")\n             .args(&[\"--unpretty\", &pretty_type])\n             .args(&[\"--target\", &self.config.target])\n-            .arg(\"-L\").arg(&aux_dir)\n+            .arg(\"-L\")\n+            .arg(&aux_dir)\n             .args(self.split_maybe_args(&self.config.target_rustcflags))\n             .args(&self.props.compile_flags)\n             .envs(self.props.exec_env.clone());\n \n-        self.compose_and_run(rustc,\n-                             self.config.compile_lib_path.to_str().unwrap(),\n-                             Some(aux_dir.to_str().unwrap()),\n-                             Some(src))\n+        self.compose_and_run(\n+            rustc,\n+            self.config.compile_lib_path.to_str().unwrap(),\n+            Some(aux_dir.to_str().unwrap()),\n+            Some(src),\n+        )\n     }\n \n-    fn compare_source(&self,\n-                      expected: &str,\n-                      actual: &str) {\n+    fn compare_source(&self, expected: &str, actual: &str) {\n         if expected != actual {\n             self.error(\"pretty-printed source does not match expected source\");\n-            println!(\"\\n\\\n-expected:\\n\\\n-------------------------------------------\\n\\\n-{}\\n\\\n-------------------------------------------\\n\\\n-actual:\\n\\\n-------------------------------------------\\n\\\n-{}\\n\\\n-------------------------------------------\\n\\\n-\\n\",\n-                     expected, actual);\n+            println!(\n+                \"\\n\\\n+                 expected:\\n\\\n+                 ------------------------------------------\\n\\\n+                 {}\\n\\\n+                 ------------------------------------------\\n\\\n+                 actual:\\n\\\n+                 ------------------------------------------\\n\\\n+                 {}\\n\\\n+                 ------------------------------------------\\n\\\n+                 \\n\",\n+                expected,\n+                actual\n+            );\n             panic!();\n         }\n     }\n@@ -394,12 +432,16 @@ actual:\\n\\\n \n         let aux_dir = self.aux_output_dir_name();\n \n-        rustc.arg(\"-\")\n+        rustc\n+            .arg(\"-\")\n             .arg(\"-Zno-trans\")\n-            .arg(\"--out-dir\").arg(&out_dir)\n+            .arg(\"--out-dir\")\n+            .arg(&out_dir)\n             .arg(&format!(\"--target={}\", target))\n-            .arg(\"-L\").arg(&self.config.build_base)\n-            .arg(\"-L\").arg(aux_dir);\n+            .arg(\"-L\")\n+            .arg(&self.config.build_base)\n+            .arg(\"-L\")\n+            .arg(aux_dir);\n \n         if let Some(revision) = self.revision {\n             rustc.args(&[\"--cfg\", revision]);\n@@ -417,7 +459,7 @@ actual:\\n\\\n         let config = Config {\n             target_rustcflags: self.cleanup_debug_info_options(&self.config.target_rustcflags),\n             host_rustcflags: self.cleanup_debug_info_options(&self.config.host_rustcflags),\n-            .. self.config.clone()\n+            ..self.config.clone()\n         };\n \n         let test_cx = TestCx {\n@@ -444,7 +486,7 @@ actual:\\n\\\n         let DebuggerCommands {\n             commands,\n             check_lines,\n-            breakpoint_lines\n+            breakpoint_lines,\n         } = self.parse_debugger_commands(prefixes);\n         let mut cmds = commands.join(\"\\n\");\n \n@@ -458,15 +500,12 @@ actual:\\n\\\n \n         let debugger_run_result;\n         match &*self.config.target {\n-            \"arm-linux-androideabi\" |\n-            \"armv7-linux-androideabi\" |\n-            \"aarch64-linux-android\" => {\n-\n+            \"arm-linux-androideabi\" | \"armv7-linux-androideabi\" | \"aarch64-linux-android\" => {\n                 cmds = cmds.replace(\"run\", \"continue\");\n \n                 let tool_path = match self.config.android_cross_path.to_str() {\n                     Some(x) => x.to_owned(),\n-                    None => self.fatal(\"cannot find android cross path\")\n+                    None => self.fatal(\"cannot find android cross path\"),\n                 };\n \n                 // write debugger script\n@@ -475,15 +514,20 @@ actual:\\n\\\n                 script_str.push_str(&format!(\"set sysroot {}\\n\", tool_path));\n                 script_str.push_str(&format!(\"file {}\\n\", exe_file.to_str().unwrap()));\n                 script_str.push_str(\"target remote :5039\\n\");\n-                script_str.push_str(&format!(\"set solib-search-path \\\n-                                              ./{}/stage2/lib/rustlib/{}/lib/\\n\",\n-                                             self.config.host, self.config.target));\n+                script_str.push_str(&format!(\n+                    \"set solib-search-path \\\n+                     ./{}/stage2/lib/rustlib/{}/lib/\\n\",\n+                    self.config.host,\n+                    self.config.target\n+                ));\n                 for line in &breakpoint_lines {\n-                    script_str.push_str(&format!(\"break {:?}:{}\\n\",\n-                                                 self.testpaths.file.file_name()\n-                                                 .unwrap()\n-                                                 .to_string_lossy(),\n-                                                 *line)[..]);\n+                    script_str.push_str(\n+                        &format!(\n+                            \"break {:?}:{}\\n\",\n+                            self.testpaths.file.file_name().unwrap().to_string_lossy(),\n+                            *line\n+                        )[..],\n+                    );\n                 }\n                 script_str.push_str(&cmds);\n                 script_str.push_str(\"\\nquit\\n\");\n@@ -505,14 +549,18 @@ actual:\\n\\\n                     .status()\n                     .expect(&format!(\"failed to exec `{:?}`\", adb_path));\n \n-                let adb_arg = format!(\"export LD_LIBRARY_PATH={}; \\\n-                                       gdbserver{} :5039 {}/{}\",\n-                                      self.config.adb_test_dir.clone(),\n-                                      if self.config.target.contains(\"aarch64\")\n-                                      {\"64\"} else {\"\"},\n-                                      self.config.adb_test_dir.clone(),\n-                                      exe_file.file_name().unwrap().to_str()\n-                                      .unwrap());\n+                let adb_arg = format!(\n+                    \"export LD_LIBRARY_PATH={}; \\\n+                     gdbserver{} :5039 {}/{}\",\n+                    self.config.adb_test_dir.clone(),\n+                    if self.config.target.contains(\"aarch64\") {\n+                        \"64\"\n+                    } else {\n+                        \"\"\n+                    },\n+                    self.config.adb_test_dir.clone(),\n+                    exe_file.file_name().unwrap().to_str().unwrap()\n+                );\n \n                 debug!(\"adb arg: {}\", adb_arg);\n                 let mut adb = Command::new(adb_path)\n@@ -531,25 +579,26 @@ actual:\\n\\\n                     line.truncate(0);\n                     stdout.read_line(&mut line).unwrap();\n                     if line.starts_with(\"Listening on port 5039\") {\n-                        break\n+                        break;\n                     }\n                 }\n                 drop(stdout);\n \n                 let debugger_script = self.make_out_name(\"debugger.script\");\n                 // FIXME (#9639): This needs to handle non-utf8 paths\n-                let debugger_opts =\n-                    vec![\"-quiet\".to_owned(),\n-                         \"-batch\".to_owned(),\n-                         \"-nx\".to_owned(),\n-                         format!(\"-command={}\", debugger_script.to_str().unwrap())];\n+                let debugger_opts = vec![\n+                    \"-quiet\".to_owned(),\n+                    \"-batch\".to_owned(),\n+                    \"-nx\".to_owned(),\n+                    format!(\"-command={}\", debugger_script.to_str().unwrap()),\n+                ];\n \n                 let mut gdb_path = tool_path;\n                 gdb_path.push_str(\"/bin/gdb\");\n                 let Output {\n                     status,\n                     stdout,\n-                    stderr\n+                    stderr,\n                 } = Command::new(&gdb_path)\n                     .args(&debugger_opts)\n                     .output()\n@@ -574,36 +623,41 @@ actual:\\n\\\n             }\n \n             _ => {\n-                let rust_src_root = self.config.find_rust_src_root().expect(\n-                    \"Could not find Rust source root\",\n-                );\n+                let rust_src_root = self.config\n+                    .find_rust_src_root()\n+                    .expect(\"Could not find Rust source root\");\n                 let rust_pp_module_rel_path = Path::new(\"./src/etc\");\n-                let rust_pp_module_abs_path = rust_src_root.join(rust_pp_module_rel_path)\n-                                                           .to_str()\n-                                                           .unwrap()\n-                                                           .to_owned();\n+                let rust_pp_module_abs_path = rust_src_root\n+                    .join(rust_pp_module_rel_path)\n+                    .to_str()\n+                    .unwrap()\n+                    .to_owned();\n                 // write debugger script\n                 let mut script_str = String::with_capacity(2048);\n                 script_str.push_str(&format!(\"set charset {}\\n\", Self::charset()));\n                 script_str.push_str(\"show version\\n\");\n \n                 match self.config.gdb_version {\n                     Some(version) => {\n-                        println!(\"NOTE: compiletest thinks it is using GDB version {}\",\n-                                 version);\n+                        println!(\n+                            \"NOTE: compiletest thinks it is using GDB version {}\",\n+                            version\n+                        );\n \n                         if version > extract_gdb_version(\"7.4\").unwrap() {\n                             // Add the directory containing the pretty printers to\n                             // GDB's script auto loading safe path\n-                            script_str.push_str(\n-                                &format!(\"add-auto-load-safe-path {}\\n\",\n-                                         rust_pp_module_abs_path.replace(r\"\\\", r\"\\\\\"))\n-                            );\n+                            script_str.push_str(&format!(\n+                                \"add-auto-load-safe-path {}\\n\",\n+                                rust_pp_module_abs_path.replace(r\"\\\", r\"\\\\\")\n+                            ));\n                         }\n                     }\n                     _ => {\n-                        println!(\"NOTE: compiletest does not know which version of \\\n-                                  GDB it is using\");\n+                        println!(\n+                            \"NOTE: compiletest does not know which version of \\\n+                             GDB it is using\"\n+                        );\n                     }\n                 }\n \n@@ -612,13 +666,13 @@ actual:\\n\\\n                 script_str.push_str(\"set print pretty off\\n\");\n \n                 // Add the pretty printer directory to GDB's source-file search path\n-                script_str.push_str(&format!(\"directory {}\\n\",\n-                                             rust_pp_module_abs_path));\n+                script_str.push_str(&format!(\"directory {}\\n\", rust_pp_module_abs_path));\n \n                 // Load the target executable\n-                script_str.push_str(&format!(\"file {}\\n\",\n-                                             exe_file.to_str().unwrap()\n-                                             .replace(r\"\\\", r\"\\\\\")));\n+                script_str.push_str(&format!(\n+                    \"file {}\\n\",\n+                    exe_file.to_str().unwrap().replace(r\"\\\", r\"\\\\\")\n+                ));\n \n                 // Force GDB to print values in the Rust format.\n                 if self.config.gdb_native_rust {\n@@ -627,10 +681,11 @@ actual:\\n\\\n \n                 // Add line breakpoints\n                 for line in &breakpoint_lines {\n-                    script_str.push_str(&format!(\"break '{}':{}\\n\",\n-                                                 self.testpaths.file.file_name().unwrap()\n-                                                 .to_string_lossy(),\n-                                                 *line));\n+                    script_str.push_str(&format!(\n+                        \"break '{}':{}\\n\",\n+                        self.testpaths.file.file_name().unwrap().to_string_lossy(),\n+                        *line\n+                    ));\n                 }\n \n                 script_str.push_str(&cmds);\n@@ -642,21 +697,23 @@ actual:\\n\\\n                 let debugger_script = self.make_out_name(\"debugger.script\");\n \n                 // FIXME (#9639): This needs to handle non-utf8 paths\n-                let debugger_opts =\n-                    vec![\"-quiet\".to_owned(),\n-                         \"-batch\".to_owned(),\n-                         \"-nx\".to_owned(),\n-                         format!(\"-command={}\", debugger_script.to_str().unwrap())];\n+                let debugger_opts = vec![\n+                    \"-quiet\".to_owned(),\n+                    \"-batch\".to_owned(),\n+                    \"-nx\".to_owned(),\n+                    format!(\"-command={}\", debugger_script.to_str().unwrap()),\n+                ];\n \n                 let mut gdb = Command::new(self.config.gdb.as_ref().unwrap());\n                 gdb.args(&debugger_opts)\n                     .env(\"PYTHONPATH\", rust_pp_module_abs_path);\n \n-                debugger_run_result =\n-                    self.compose_and_run(gdb,\n-                                         self.config.run_lib_path.to_str().unwrap(),\n-                                         None,\n-                                         None);\n+                debugger_run_result = self.compose_and_run(\n+                    gdb,\n+                    self.config.run_lib_path.to_str().unwrap(),\n+                    None,\n+                    None,\n+                );\n             }\n         }\n \n@@ -677,7 +734,7 @@ actual:\\n\\\n         let config = Config {\n             target_rustcflags: self.cleanup_debug_info_options(&self.config.target_rustcflags),\n             host_rustcflags: self.cleanup_debug_info_options(&self.config.host_rustcflags),\n-            .. self.config.clone()\n+            ..self.config.clone()\n         };\n \n \n@@ -700,12 +757,16 @@ actual:\\n\\\n \n         match self.config.lldb_version {\n             Some(ref version) => {\n-                println!(\"NOTE: compiletest thinks it is using LLDB version {}\",\n-                         version);\n+                println!(\n+                    \"NOTE: compiletest thinks it is using LLDB version {}\",\n+                    version\n+                );\n             }\n             _ => {\n-                println!(\"NOTE: compiletest does not know which version of \\\n-                          LLDB it is using\");\n+                println!(\n+                    \"NOTE: compiletest does not know which version of \\\n+                     LLDB it is using\"\n+                );\n             }\n         }\n \n@@ -725,17 +786,18 @@ actual:\\n\\\n         script_str.push_str(\"version\\n\");\n \n         // Switch LLDB into \"Rust mode\"\n-        let rust_src_root = self.config.find_rust_src_root().expect(\n-            \"Could not find Rust source root\",\n-        );\n+        let rust_src_root = self.config\n+            .find_rust_src_root()\n+            .expect(\"Could not find Rust source root\");\n         let rust_pp_module_rel_path = Path::new(\"./src/etc/lldb_rust_formatters.py\");\n-        let rust_pp_module_abs_path = rust_src_root.join(rust_pp_module_rel_path)\n-                                                   .to_str()\n-                                                   .unwrap()\n-                                                   .to_owned();\n-\n-        script_str.push_str(&format!(\"command script import {}\\n\",\n-                                     &rust_pp_module_abs_path[..])[..]);\n+        let rust_pp_module_abs_path = rust_src_root\n+            .join(rust_pp_module_rel_path)\n+            .to_str()\n+            .unwrap()\n+            .to_owned();\n+\n+        script_str\n+            .push_str(&format!(\"command script import {}\\n\", &rust_pp_module_abs_path[..])[..]);\n         script_str.push_str(\"type summary add --no-value \");\n         script_str.push_str(\"--python-function lldb_rust_formatters.print_val \");\n         script_str.push_str(\"-x \\\".*\\\" --category Rust\\n\");\n@@ -744,9 +806,11 @@ actual:\\n\\\n         // Set breakpoints on every line that contains the string \"#break\"\n         let source_file_name = self.testpaths.file.file_name().unwrap().to_string_lossy();\n         for line in &breakpoint_lines {\n-            script_str.push_str(&format!(\"breakpoint set --file '{}' --line {}\\n\",\n-                                         source_file_name,\n-                                         line));\n+            script_str.push_str(&format!(\n+                \"breakpoint set --file '{}' --line {}\\n\",\n+                source_file_name,\n+                line\n+            ));\n         }\n \n         // Append the other commands\n@@ -764,9 +828,7 @@ actual:\\n\\\n         let debugger_script = self.make_out_name(\"debugger.script\");\n \n         // Let LLDB execute the script via lldb_batchmode.py\n-        let debugger_run_result = self.run_lldb(&exe_file,\n-                                                &debugger_script,\n-                                                &rust_src_root);\n+        let debugger_run_result = self.run_lldb(&exe_file, &debugger_script, &rust_src_root);\n \n         if !debugger_run_result.status.success() {\n             self.fatal_proc_rec(\"Error while running LLDB\", &debugger_run_result);\n@@ -775,48 +837,57 @@ actual:\\n\\\n         self.check_debugger_output(&debugger_run_result, &check_lines);\n     }\n \n-    fn run_lldb(&self,\n-                test_executable: &Path,\n-                debugger_script: &Path,\n-                rust_src_root: &Path)\n-                -> ProcRes {\n+    fn run_lldb(\n+        &self,\n+        test_executable: &Path,\n+        debugger_script: &Path,\n+        rust_src_root: &Path,\n+    ) -> ProcRes {\n         // Prepare the lldb_batchmode which executes the debugger script\n         let lldb_script_path = rust_src_root.join(\"src/etc/lldb_batchmode.py\");\n-        self.cmd2procres(Command::new(&self.config.lldb_python)\n-                         .arg(&lldb_script_path)\n-                         .arg(test_executable)\n-                         .arg(debugger_script)\n-                         .env(\"PYTHONPATH\",\n-                              self.config.lldb_python_dir.as_ref().unwrap()))\n+        self.cmd2procres(\n+            Command::new(&self.config.lldb_python)\n+                .arg(&lldb_script_path)\n+                .arg(test_executable)\n+                .arg(debugger_script)\n+                .env(\"PYTHONPATH\", self.config.lldb_python_dir.as_ref().unwrap()),\n+        )\n     }\n \n     fn cmd2procres(&self, cmd: &mut Command) -> ProcRes {\n         let (status, out, err) = match cmd.output() {\n-            Ok(Output { status, stdout, stderr }) => {\n-                (status,\n-                 String::from_utf8(stdout).unwrap(),\n-                 String::from_utf8(stderr).unwrap())\n-            },\n-            Err(e) => {\n-                self.fatal(&format!(\"Failed to setup Python process for \\\n-                                      LLDB script: {}\", e))\n-            }\n+            Ok(Output {\n+                status,\n+                stdout,\n+                stderr,\n+            }) => (\n+                status,\n+                String::from_utf8(stdout).unwrap(),\n+                String::from_utf8(stderr).unwrap(),\n+            ),\n+            Err(e) => self.fatal(&format!(\n+                \"Failed to setup Python process for \\\n+                 LLDB script: {}\",\n+                e\n+            )),\n         };\n \n         self.dump_output(&out, &err);\n         ProcRes {\n             status,\n             stdout: out,\n             stderr: err,\n-            cmdline: format!(\"{:?}\", cmd)\n+            cmdline: format!(\"{:?}\", cmd),\n         }\n     }\n \n     fn parse_debugger_commands(&self, debugger_prefixes: &[&str]) -> DebuggerCommands {\n-        let directives = debugger_prefixes.iter().map(|prefix| (\n-            format!(\"{}-command\", prefix),\n-            format!(\"{}-check\", prefix),\n-        )).collect::<Vec<_>>();\n+        let directives = debugger_prefixes\n+            .iter()\n+            .map(|prefix| {\n+                (format!(\"{}-command\", prefix), format!(\"{}-check\", prefix))\n+            })\n+            .collect::<Vec<_>>();\n \n         let mut breakpoint_lines = vec![];\n         let mut commands = vec![];\n@@ -831,22 +902,16 @@ actual:\\n\\\n                     }\n \n                     for &(ref command_directive, ref check_directive) in &directives {\n-                        self.config.parse_name_value_directive(\n-                            &line,\n-                            command_directive).map(|cmd| {\n-                                commands.push(cmd)\n-                            });\n-\n-                        self.config.parse_name_value_directive(\n-                            &line,\n-                            check_directive).map(|cmd| {\n-                                check_lines.push(cmd)\n-                            });\n+                        self.config\n+                            .parse_name_value_directive(&line, command_directive)\n+                            .map(|cmd| commands.push(cmd));\n+\n+                        self.config\n+                            .parse_name_value_directive(&line, check_directive)\n+                            .map(|cmd| check_lines.push(cmd));\n                     }\n                 }\n-                Err(e) => {\n-                    self.fatal(&format!(\"Error while parsing debugger commands: {}\", e))\n-                }\n+                Err(e) => self.fatal(&format!(\"Error while parsing debugger commands: {}\", e)),\n             }\n             counter += 1;\n         }\n@@ -864,15 +929,11 @@ actual:\\n\\\n         }\n \n         // Remove options that are either unwanted (-O) or may lead to duplicates due to RUSTFLAGS.\n-        let options_to_remove = [\n-            \"-O\".to_owned(),\n-            \"-g\".to_owned(),\n-            \"--debuginfo\".to_owned()\n-        ];\n-        let new_options =\n-            self.split_maybe_args(options).into_iter()\n-                                          .filter(|x| !options_to_remove.contains(x))\n-                                          .collect::<Vec<String>>();\n+        let options_to_remove = [\"-O\".to_owned(), \"-g\".to_owned(), \"--debuginfo\".to_owned()];\n+        let new_options = self.split_maybe_args(options)\n+            .into_iter()\n+            .filter(|x| !options_to_remove.contains(x))\n+            .collect::<Vec<String>>();\n \n         Some(new_options.join(\" \"))\n     }\n@@ -891,9 +952,13 @@ actual:\\n\\\n             }\n         }\n         if check_line_index != num_check_lines && num_check_lines > 0 {\n-            self.fatal_proc_rec(&format!(\"line not found in debugger output: {}\",\n-                                         check_lines[check_line_index]),\n-                                debugger_run_result);\n+            self.fatal_proc_rec(\n+                &format!(\n+                    \"line not found in debugger output: {}\",\n+                    check_lines[check_line_index]\n+                ),\n+                debugger_run_result,\n+            );\n         }\n \n         fn check_single_line(line: &str, check_line: &str) -> bool {\n@@ -904,17 +969,18 @@ actual:\\n\\\n             let can_start_anywhere = check_line.starts_with(\"[...]\");\n             let can_end_anywhere = check_line.ends_with(\"[...]\");\n \n-            let check_fragments: Vec<&str> = check_line.split(\"[...]\")\n-                                                       .filter(|frag| !frag.is_empty())\n-                                                       .collect();\n+            let check_fragments: Vec<&str> = check_line\n+                .split(\"[...]\")\n+                .filter(|frag| !frag.is_empty())\n+                .collect();\n             if check_fragments.is_empty() {\n                 return true;\n             }\n \n             let (mut rest, first_fragment) = if can_start_anywhere {\n                 match line.find(check_fragments[0]) {\n-                    Some(pos) => (&line[pos + check_fragments[0].len() ..], 1),\n-                    None => return false\n+                    Some(pos) => (&line[pos + check_fragments[0].len()..], 1),\n+                    None => return false,\n                 }\n             } else {\n                 (line, 0)\n@@ -923,9 +989,9 @@ actual:\\n\\\n             for current_fragment in &check_fragments[first_fragment..] {\n                 match rest.find(current_fragment) {\n                     Some(pos) => {\n-                        rest = &rest[pos + current_fragment.len() .. ];\n+                        rest = &rest[pos + current_fragment.len()..];\n                     }\n-                    None => return false\n+                    None => return false,\n                 }\n             }\n \n@@ -937,15 +1003,15 @@ actual:\\n\\\n         }\n     }\n \n-    fn check_error_patterns(&self,\n-                            output_to_check: &str,\n-                            proc_res: &ProcRes) {\n+    fn check_error_patterns(&self, output_to_check: &str, proc_res: &ProcRes) {\n         if self.props.error_patterns.is_empty() {\n             if self.props.must_compile_successfully {\n-                return\n+                return;\n             } else {\n-                self.fatal(&format!(\"no error pattern specified in {:?}\",\n-                                    self.testpaths.file.display()));\n+                self.fatal(&format!(\n+                    \"no error pattern specified in {:?}\",\n+                    self.testpaths.file.display()\n+                ));\n             }\n         }\n         let mut next_err_idx = 0;\n@@ -963,13 +1029,16 @@ actual:\\n\\\n                 next_err_pat = self.props.error_patterns[next_err_idx].trim();\n             }\n         }\n-        if done { return; }\n+        if done {\n+            return;\n+        }\n \n         let missing_patterns = &self.props.error_patterns[next_err_idx..];\n         if missing_patterns.len() == 1 {\n             self.fatal_proc_rec(\n                 &format!(\"error pattern '{}' not found!\", missing_patterns[0]),\n-                proc_res);\n+                proc_res,\n+            );\n         } else {\n             for pattern in missing_patterns {\n                 self.error(&format!(\"error pattern '{}' not found!\", *pattern));\n@@ -986,51 +1055,49 @@ actual:\\n\\\n         }\n     }\n \n-    fn check_forbid_output(&self,\n-                           output_to_check: &str,\n-                           proc_res: &ProcRes) {\n+    fn check_forbid_output(&self, output_to_check: &str, proc_res: &ProcRes) {\n         for pat in &self.props.forbid_output {\n             if output_to_check.contains(pat) {\n                 self.fatal_proc_rec(\"forbidden pattern found in compiler output\", proc_res);\n             }\n         }\n     }\n \n-    fn check_expected_errors(&self,\n-                             expected_errors: Vec<errors::Error>,\n-                             proc_res: &ProcRes) {\n-        if proc_res.status.success() &&\n-            expected_errors.iter().any(|x| x.kind == Some(ErrorKind::Error)) {\n+    fn check_expected_errors(&self, expected_errors: Vec<errors::Error>, proc_res: &ProcRes) {\n+        if proc_res.status.success()\n+            && expected_errors\n+                .iter()\n+                .any(|x| x.kind == Some(ErrorKind::Error))\n+        {\n             self.fatal_proc_rec(\"process did not return an error status\", proc_res);\n         }\n \n-        let file_name =\n-            format!(\"{}\", self.testpaths.file.display())\n-            .replace(r\"\\\", \"/\"); // on windows, translate all '\\' path separators to '/'\n+        let file_name = format!(\"{}\", self.testpaths.file.display()).replace(r\"\\\", \"/\"); // on windows, translate all '\\' path separators to '/'\n \n         // If the testcase being checked contains at least one expected \"help\"\n         // message, then we'll ensure that all \"help\" messages are expected.\n         // Otherwise, all \"help\" messages reported by the compiler will be ignored.\n         // This logic also applies to \"note\" messages.\n-        let expect_help = expected_errors.iter().any(|ee| ee.kind == Some(ErrorKind::Help));\n-        let expect_note = expected_errors.iter().any(|ee| ee.kind == Some(ErrorKind::Note));\n+        let expect_help = expected_errors\n+            .iter()\n+            .any(|ee| ee.kind == Some(ErrorKind::Help));\n+        let expect_note = expected_errors\n+            .iter()\n+            .any(|ee| ee.kind == Some(ErrorKind::Note));\n \n         // Parse the JSON output from the compiler and extract out the messages.\n         let actual_errors = json::parse_output(&file_name, &proc_res.stderr, proc_res);\n         let mut unexpected = Vec::new();\n         let mut found = vec![false; expected_errors.len()];\n         for actual_error in &actual_errors {\n-            let opt_index =\n-                expected_errors\n-                .iter()\n-                .enumerate()\n-                .position(|(index, expected_error)| {\n-                    !found[index] &&\n-                        actual_error.line_num == expected_error.line_num &&\n-                        (expected_error.kind.is_none() ||\n-                         actual_error.kind == expected_error.kind) &&\n-                        actual_error.msg.contains(&expected_error.msg)\n-                });\n+            let opt_index = expected_errors.iter().enumerate().position(\n+                |(index, expected_error)| {\n+                    !found[index] && actual_error.line_num == expected_error.line_num\n+                        && (expected_error.kind.is_none()\n+                            || actual_error.kind == expected_error.kind)\n+                        && actual_error.msg.contains(&expected_error.msg)\n+                },\n+            );\n \n             match opt_index {\n                 Some(index) => {\n@@ -1041,14 +1108,16 @@ actual:\\n\\\n \n                 None => {\n                     if self.is_unexpected_compiler_message(actual_error, expect_help, expect_note) {\n-                        self.error(\n-                            &format!(\"{}:{}: unexpected {}: '{}'\",\n-                                     file_name,\n-                                     actual_error.line_num,\n-                                     actual_error.kind.as_ref()\n-                                     .map_or(String::from(\"message\"),\n-                                             |k| k.to_string()),\n-                                     actual_error.msg));\n+                        self.error(&format!(\n+                            \"{}:{}: unexpected {}: '{}'\",\n+                            file_name,\n+                            actual_error.line_num,\n+                            actual_error\n+                                .kind\n+                                .as_ref()\n+                                .map_or(String::from(\"message\"), |k| k.to_string()),\n+                            actual_error.msg\n+                        ));\n                         unexpected.push(actual_error);\n                     }\n                 }\n@@ -1059,24 +1128,27 @@ actual:\\n\\\n         // anything not yet found is a problem\n         for (index, expected_error) in expected_errors.iter().enumerate() {\n             if !found[index] {\n-                self.error(\n-                    &format!(\"{}:{}: expected {} not found: {}\",\n-                             file_name,\n-                             expected_error.line_num,\n-                             expected_error.kind.as_ref()\n-                             .map_or(\"message\".into(),\n-                                     |k| k.to_string()),\n-                             expected_error.msg));\n+                self.error(&format!(\n+                    \"{}:{}: expected {} not found: {}\",\n+                    file_name,\n+                    expected_error.line_num,\n+                    expected_error\n+                        .kind\n+                        .as_ref()\n+                        .map_or(\"message\".into(), |k| k.to_string()),\n+                    expected_error.msg\n+                ));\n                 not_found.push(expected_error);\n             }\n         }\n \n         if !unexpected.is_empty() || !not_found.is_empty() {\n-            self.error(\n-                &format!(\"{} unexpected errors found, {} expected errors not found\",\n-                         unexpected.len(), not_found.len()));\n-            println!(\"status: {}\\ncommand: {}\",\n-                   proc_res.status, proc_res.cmdline);\n+            self.error(&format!(\n+                \"{} unexpected errors found, {} expected errors not found\",\n+                unexpected.len(),\n+                not_found.len()\n+            ));\n+            println!(\"status: {}\\ncommand: {}\", proc_res.status, proc_res.cmdline);\n             if !unexpected.is_empty() {\n                 println!(\"unexpected errors (from JSON output): {:#?}\\n\", unexpected);\n             }\n@@ -1091,24 +1163,25 @@ actual:\\n\\\n     /// which did not match any of the expected error. We always require\n     /// errors/warnings to be explicitly listed, but only require\n     /// helps/notes if there are explicit helps/notes given.\n-    fn is_unexpected_compiler_message(&self,\n-                                      actual_error: &Error,\n-                                      expect_help: bool,\n-                                      expect_note: bool)\n-                                      -> bool {\n+    fn is_unexpected_compiler_message(\n+        &self,\n+        actual_error: &Error,\n+        expect_help: bool,\n+        expect_note: bool,\n+    ) -> bool {\n         match actual_error.kind {\n             Some(ErrorKind::Help) => expect_help,\n             Some(ErrorKind::Note) => expect_note,\n-            Some(ErrorKind::Error) |\n-            Some(ErrorKind::Warning) => true,\n-            Some(ErrorKind::Suggestion) |\n-            None => false\n+            Some(ErrorKind::Error) | Some(ErrorKind::Warning) => true,\n+            Some(ErrorKind::Suggestion) | None => false,\n         }\n     }\n \n     fn compile_test(&self) -> ProcRes {\n         let mut rustc = self.make_compile_args(\n-            &self.testpaths.file, TargetLocation::ThisFile(self.make_exe_name()));\n+            &self.testpaths.file,\n+            TargetLocation::ThisFile(self.make_exe_name()),\n+        );\n \n         rustc.arg(\"-L\").arg(&self.aux_output_dir_name());\n \n@@ -1131,14 +1204,14 @@ actual:\\n\\\n         if self.props.build_aux_docs {\n             for rel_ab in &self.props.aux_builds {\n                 let aux_testpaths = self.compute_aux_test_paths(rel_ab);\n-                let aux_props = self.props.from_aux_file(&aux_testpaths.file,\n-                                                         self.revision,\n-                                                         self.config);\n+                let aux_props =\n+                    self.props\n+                        .from_aux_file(&aux_testpaths.file, self.revision, self.config);\n                 let aux_cx = TestCx {\n                     config: self.config,\n                     props: &aux_props,\n                     testpaths: &aux_testpaths,\n-                    revision: self.revision\n+                    revision: self.revision,\n                 };\n                 let auxres = aux_cx.document(out_dir);\n                 if !auxres.status.success() {\n@@ -1149,15 +1222,25 @@ actual:\\n\\\n \n         let aux_dir = self.aux_output_dir_name();\n \n-        let rustdoc_path = self.config.rustdoc_path.as_ref().expect(\"--rustdoc-path passed\");\n+        let rustdoc_path = self.config\n+            .rustdoc_path\n+            .as_ref()\n+            .expect(\"--rustdoc-path passed\");\n         let mut rustdoc = Command::new(rustdoc_path);\n \n-        rustdoc.arg(\"-L\").arg(aux_dir)\n-            .arg(\"-o\").arg(out_dir)\n+        rustdoc\n+            .arg(\"-L\")\n+            .arg(aux_dir)\n+            .arg(\"-o\")\n+            .arg(out_dir)\n             .arg(&self.testpaths.file)\n             .args(&self.props.compile_flags);\n         if let Some(ref linker) = self.config.linker {\n-            rustdoc.arg(\"--linker\").arg(linker).arg(\"-Z\").arg(\"unstable-options\");\n+            rustdoc\n+                .arg(\"--linker\")\n+                .arg(linker)\n+                .arg(\"-Z\")\n+                .arg(\"unstable-options\");\n         }\n \n         self.compose_and_run_compiler(rustdoc, None)\n@@ -1187,59 +1270,69 @@ actual:\\n\\\n                     for entry in entries {\n                         let entry = entry.unwrap();\n                         if !entry.path().is_file() {\n-                            continue\n+                            continue;\n                         }\n                         prog.push_str(\":\");\n                         prog.push_str(entry.path().to_str().unwrap());\n                     }\n                 }\n-                let mut test_client = Command::new(\n-                    self.config.remote_test_client.as_ref().unwrap());\n+                let mut test_client =\n+                    Command::new(self.config.remote_test_client.as_ref().unwrap());\n                 test_client\n                     .args(&[\"run\", &prog])\n                     .args(args)\n                     .envs(env.clone());\n-                self.compose_and_run(test_client,\n-                                     self.config.run_lib_path.to_str().unwrap(),\n-                                     Some(aux_dir.to_str().unwrap()),\n-                                     None)\n+                self.compose_and_run(\n+                    test_client,\n+                    self.config.run_lib_path.to_str().unwrap(),\n+                    Some(aux_dir.to_str().unwrap()),\n+                    None,\n+                )\n             }\n             _ => {\n                 let aux_dir = self.aux_output_dir_name();\n                 let ProcArgs { prog, args } = self.make_run_args();\n                 let mut program = Command::new(&prog);\n-                program.args(args)\n+                program\n+                    .args(args)\n                     .current_dir(&self.output_base_name().parent().unwrap())\n                     .envs(env.clone());\n-                self.compose_and_run(program,\n-                                     self.config.run_lib_path.to_str().unwrap(),\n-                                     Some(aux_dir.to_str().unwrap()),\n-                                     None)\n+                self.compose_and_run(\n+                    program,\n+                    self.config.run_lib_path.to_str().unwrap(),\n+                    Some(aux_dir.to_str().unwrap()),\n+                    None,\n+                )\n             }\n         }\n     }\n \n     /// For each `aux-build: foo/bar` annotation, we check to find the\n     /// file in a `aux` directory relative to the test itself.\n     fn compute_aux_test_paths(&self, rel_ab: &str) -> TestPaths {\n-        let test_ab = self.testpaths.file\n-                                    .parent()\n-                                    .expect(\"test file path has no parent\")\n-                                    .join(\"auxiliary\")\n-                                    .join(rel_ab);\n+        let test_ab = self.testpaths\n+            .file\n+            .parent()\n+            .expect(\"test file path has no parent\")\n+            .join(\"auxiliary\")\n+            .join(rel_ab);\n         if !test_ab.exists() {\n-            self.fatal(&format!(\"aux-build `{}` source not found\", test_ab.display()))\n+            self.fatal(&format!(\n+                \"aux-build `{}` source not found\",\n+                test_ab.display()\n+            ))\n         }\n \n         TestPaths {\n             file: test_ab,\n             base: self.testpaths.base.clone(),\n-            relative_dir: self.testpaths.relative_dir\n-                                        .join(\"auxiliary\")\n-                                        .join(rel_ab)\n-                                        .parent()\n-                                        .expect(\"aux-build path has no parent\")\n-                                        .to_path_buf()\n+            relative_dir: self.testpaths\n+                .relative_dir\n+                .join(\"auxiliary\")\n+                .join(rel_ab)\n+                .parent()\n+                .expect(\"aux-build path has no parent\")\n+                .to_path_buf(),\n         }\n     }\n \n@@ -1252,9 +1345,9 @@ actual:\\n\\\n \n         for rel_ab in &self.props.aux_builds {\n             let aux_testpaths = self.compute_aux_test_paths(rel_ab);\n-            let aux_props = self.props.from_aux_file(&aux_testpaths.file,\n-                                                     self.revision,\n-                                                     self.config);\n+            let aux_props =\n+                self.props\n+                    .from_aux_file(&aux_testpaths.file, self.revision, self.config);\n             let aux_output = {\n                 let f = self.make_lib_name(&self.testpaths.file);\n                 let parent = f.parent().unwrap();\n@@ -1264,15 +1357,16 @@ actual:\\n\\\n                 config: self.config,\n                 props: &aux_props,\n                 testpaths: &aux_testpaths,\n-                revision: self.revision\n+                revision: self.revision,\n             };\n             let mut aux_rustc = aux_cx.make_compile_args(&aux_testpaths.file, aux_output);\n \n             let crate_type = if aux_props.no_prefer_dynamic {\n                 None\n-            } else if (self.config.target.contains(\"musl\") && !aux_props.force_host) ||\n-                      self.config.target.contains(\"wasm32\") ||\n-                      self.config.target.contains(\"emscripten\") {\n+            } else if (self.config.target.contains(\"musl\") && !aux_props.force_host)\n+                || self.config.target.contains(\"wasm32\")\n+                || self.config.target.contains(\"emscripten\")\n+            {\n                 // We primarily compile all auxiliary libraries as dynamic libraries\n                 // to avoid code size bloat and large binaries as much as possible\n                 // for the test suite (otherwise including libstd statically in all\n@@ -1293,32 +1387,40 @@ actual:\\n\\\n \n             aux_rustc.arg(\"-L\").arg(&aux_dir);\n \n-            let auxres = aux_cx.compose_and_run(aux_rustc,\n-                                                aux_cx.config.compile_lib_path.to_str().unwrap(),\n-                                                Some(aux_dir.to_str().unwrap()),\n-                                                None);\n+            let auxres = aux_cx.compose_and_run(\n+                aux_rustc,\n+                aux_cx.config.compile_lib_path.to_str().unwrap(),\n+                Some(aux_dir.to_str().unwrap()),\n+                None,\n+            );\n             if !auxres.status.success() {\n                 self.fatal_proc_rec(\n-                    &format!(\"auxiliary build of {:?} failed to compile: \",\n-                             aux_testpaths.file.display()),\n-                    &auxres);\n+                    &format!(\n+                        \"auxiliary build of {:?} failed to compile: \",\n+                        aux_testpaths.file.display()\n+                    ),\n+                    &auxres,\n+                );\n             }\n         }\n \n         rustc.envs(self.props.rustc_env.clone());\n-        self.compose_and_run(rustc,\n-                             self.config.compile_lib_path.to_str().unwrap(),\n-                             Some(aux_dir.to_str().unwrap()),\n-                             input)\n-    }\n-\n-    fn compose_and_run(&self,\n-                       mut command: Command,\n-                       lib_path: &str,\n-                       aux_path: Option<&str>,\n-                       input: Option<String>) -> ProcRes {\n-        let cmdline =\n-        {\n+        self.compose_and_run(\n+            rustc,\n+            self.config.compile_lib_path.to_str().unwrap(),\n+            Some(aux_dir.to_str().unwrap()),\n+            input,\n+        )\n+    }\n+\n+    fn compose_and_run(\n+        &self,\n+        mut command: Command,\n+        lib_path: &str,\n+        aux_path: Option<&str>,\n+        input: Option<String>,\n+    ) -> ProcRes {\n+        let cmdline = {\n             let cmdline = self.make_cmdline(&command, lib_path);\n             logv(self.config, format!(\"executing {}\", cmdline));\n             cmdline\n@@ -1342,13 +1444,23 @@ actual:\\n\\\n         let newpath = env::join_paths(&path).unwrap();\n         command.env(dylib_env_var(), newpath);\n \n-        let mut child = command.spawn().expect(&format!(\"failed to exec `{:?}`\", &command));\n+        let mut child = command\n+            .spawn()\n+            .expect(&format!(\"failed to exec `{:?}`\", &command));\n         if let Some(input) = input {\n-            child.stdin.as_mut().unwrap().write_all(input.as_bytes()).unwrap();\n+            child\n+                .stdin\n+                .as_mut()\n+                .unwrap()\n+                .write_all(input.as_bytes())\n+                .unwrap();\n         }\n \n-        let Output { status, stdout, stderr } = read2_abbreviated(child)\n-            .expect(\"failed to read output\");\n+        let Output {\n+            status,\n+            stdout,\n+            stderr,\n+        } = read2_abbreviated(child).expect(\"failed to read output\");\n \n         let result = ProcRes {\n             status,\n@@ -1364,11 +1476,11 @@ actual:\\n\\\n \n     fn make_compile_args(&self, input_file: &Path, output_file: TargetLocation) -> Command {\n         let mut rustc = Command::new(&self.config.rustc_path);\n-        rustc.arg(input_file)\n-            .arg(\"-L\").arg(&self.config.build_base);\n+        rustc.arg(input_file).arg(\"-L\").arg(&self.config.build_base);\n \n         // Optionally prevent default --target if specified in test compile-flags.\n-        let custom_target = self.props.compile_flags\n+        let custom_target = self.props\n+            .compile_flags\n             .iter()\n             .any(|x| x.starts_with(\"--target\"));\n \n@@ -1387,32 +1499,36 @@ actual:\\n\\\n         }\n \n         if let Some(ref incremental_dir) = self.props.incremental_dir {\n-            rustc.args(&[\"-Z\", &format!(\"incremental={}\", incremental_dir.display())]);\n+            rustc.args(&[\n+                \"-Z\",\n+                &format!(\"incremental={}\", incremental_dir.display()),\n+            ]);\n             rustc.args(&[\"-Z\", \"incremental-verify-ich\"]);\n             rustc.args(&[\"-Z\", \"incremental-queries\"]);\n         }\n \n         match self.config.mode {\n-            CompileFail |\n-            ParseFail |\n-            Incremental => {\n+            CompileFail | ParseFail | Incremental => {\n                 // If we are extracting and matching errors in the new\n                 // fashion, then you want JSON mode. Old-skool error\n                 // patterns still match the raw compiler output.\n                 if self.props.error_patterns.is_empty() {\n                     rustc.args(&[\"--error-format\", \"json\"]);\n                 }\n             }\n-            Ui => {\n-                if !self.props.compile_flags.iter().any(|s| s.starts_with(\"--error-format\")) {\n-                    rustc.args(&[\"--error-format\", \"json\"]);\n-                }\n-            }\n+            Ui => if !self.props\n+                .compile_flags\n+                .iter()\n+                .any(|s| s.starts_with(\"--error-format\"))\n+            {\n+                rustc.args(&[\"--error-format\", \"json\"]);\n+            },\n             MirOpt => {\n                 rustc.args(&[\n                     \"-Zdump-mir=all\",\n                     \"-Zmir-opt-level=3\",\n-                    \"-Zdump-mir-exclude-pass-number\"]);\n+                    \"-Zdump-mir-exclude-pass-number\",\n+                ]);\n \n                 let mir_dump_dir = self.get_mir_dump_dir();\n                 let _ = fs::remove_dir_all(&mir_dump_dir);\n@@ -1532,26 +1648,21 @@ actual:\\n\\\n         args.extend(self.split_maybe_args(&self.props.run_flags));\n \n         let prog = args.remove(0);\n-         ProcArgs {\n-            prog,\n-            args,\n-        }\n+        ProcArgs { prog, args }\n     }\n \n     fn split_maybe_args(&self, argstr: &Option<String>) -> Vec<String> {\n         match *argstr {\n-            Some(ref s) => {\n-                s\n-                    .split(' ')\n-                    .filter_map(|s| {\n-                        if s.chars().all(|c| c.is_whitespace()) {\n-                            None\n-                        } else {\n-                            Some(s.to_owned())\n-                        }\n-                    }).collect()\n-            }\n-            None => Vec::new()\n+            Some(ref s) => s.split(' ')\n+                .filter_map(|s| {\n+                    if s.chars().all(|c| c.is_whitespace()) {\n+                        None\n+                    } else {\n+                        Some(s.to_owned())\n+                    }\n+                })\n+                .collect(),\n+            None => Vec::new(),\n         }\n     }\n \n@@ -1565,7 +1676,11 @@ actual:\\n\\\n             // Build the LD_LIBRARY_PATH variable as it would be seen on the command line\n             // for diagnostic purposes\n             fn lib_path_cmd_prefix(path: &str) -> String {\n-                format!(\"{}=\\\"{}\\\"\", util::lib_path_env_var(), util::make_new_path(path))\n+                format!(\n+                    \"{}=\\\"{}\\\"\",\n+                    util::lib_path_env_var(),\n+                    util::make_new_path(path)\n+                )\n             }\n \n             format!(\"{} {:?}\", lib_path_cmd_prefix(libpath), command)\n@@ -1584,11 +1699,12 @@ actual:\\n\\\n         self.maybe_dump_to_stdout(out, err);\n     }\n \n-    fn dump_output_file(&self,\n-                        out: &str,\n-                        extension: &str) {\n+    fn dump_output_file(&self, out: &str, extension: &str) {\n         let outfile = self.make_out_name(extension);\n-        File::create(&outfile).unwrap().write_all(out.as_bytes()).unwrap();\n+        File::create(&outfile)\n+            .unwrap()\n+            .write_all(out.as_bytes())\n+            .unwrap();\n     }\n \n     fn make_out_name(&self, extension: &str) -> PathBuf {\n@@ -1613,8 +1729,7 @@ actual:\\n\\\n         let dir = self.config.build_base.join(&self.testpaths.relative_dir);\n \n         // Note: The directory `dir` is created during `collect_tests_from_dir`\n-        dir\n-            .join(&self.output_testname(&self.testpaths.file))\n+        dir.join(&self.output_testname(&self.testpaths.file))\n             .with_extension(&self.config.stage_id)\n     }\n \n@@ -1631,12 +1746,13 @@ actual:\\n\\\n     fn error(&self, err: &str) {\n         match self.revision {\n             Some(rev) => println!(\"\\nerror in revision `{}`: {}\", rev, err),\n-            None => println!(\"\\nerror: {}\", err)\n+            None => println!(\"\\nerror: {}\", err),\n         }\n     }\n \n     fn fatal(&self, err: &str) -> ! {\n-        self.error(err); panic!();\n+        self.error(err);\n+        panic!();\n     }\n \n     fn fatal_proc_rec(&self, err: &str, proc_res: &ProcRes) -> ! {\n@@ -1652,10 +1768,10 @@ actual:\\n\\\n     // errors here.\n     fn try_print_open_handles(&self) {\n         if !cfg!(windows) {\n-            return\n+            return;\n         }\n         if self.config.mode != Incremental {\n-            return\n+            return;\n         }\n \n         let filename = match self.testpaths.file.file_stem() {\n@@ -1689,19 +1805,20 @@ actual:\\n\\\n     fn compile_test_and_save_ir(&self) -> ProcRes {\n         let aux_dir = self.aux_output_dir_name();\n \n-        let output_file = TargetLocation::ThisDirectory(\n-            self.output_base_name().parent().unwrap().to_path_buf());\n+        let output_file =\n+            TargetLocation::ThisDirectory(self.output_base_name().parent().unwrap().to_path_buf());\n         let mut rustc = self.make_compile_args(&self.testpaths.file, output_file);\n-        rustc.arg(\"-L\").arg(aux_dir)\n-            .arg(\"--emit=llvm-ir\");\n+        rustc.arg(\"-L\").arg(aux_dir).arg(\"--emit=llvm-ir\");\n \n         self.compose_and_run_compiler(rustc, None)\n     }\n \n     fn check_ir_with_filecheck(&self) -> ProcRes {\n         let irfile = self.output_base_name().with_extension(\"ll\");\n         let mut filecheck = Command::new(self.config.llvm_filecheck.as_ref().unwrap());\n-        filecheck.arg(\"--input-file\").arg(irfile)\n+        filecheck\n+            .arg(\"--input-file\")\n+            .arg(irfile)\n             .arg(&self.testpaths.file);\n         self.compose_and_run(filecheck, \"\", None, None)\n     }\n@@ -1763,105 +1880,119 @@ actual:\\n\\\n         }\n     }\n \n-    fn get_lines<P: AsRef<Path>>(&self, path: &P,\n-                                 mut other_files: Option<&mut Vec<String>>) -> Vec<usize> {\n-        let mut file = fs::File::open(path)\n-                                .expect(\"markdown_test_output_check_entry File::open failed\");\n+    fn get_lines<P: AsRef<Path>>(\n+        &self,\n+        path: &P,\n+        mut other_files: Option<&mut Vec<String>>,\n+    ) -> Vec<usize> {\n+        let mut file =\n+            fs::File::open(path).expect(\"markdown_test_output_check_entry File::open failed\");\n         let mut content = String::new();\n         file.read_to_string(&mut content)\n             .expect(\"markdown_test_output_check_entry read_to_string failed\");\n         let mut ignore = false;\n-        content.lines()\n-               .enumerate()\n-               .filter_map(|(line_nb, line)| {\n-                   if (line.trim_left().starts_with(\"pub mod \") ||\n-                       line.trim_left().starts_with(\"mod \")) &&\n-                      line.ends_with(';') {\n-                       if let Some(ref mut other_files) = other_files {\n-                           other_files.push(line.rsplit(\"mod \")\n-                                      .next()\n-                                      .unwrap()\n-                                      .replace(\";\", \"\"));\n-                       }\n-                       None\n-                   } else {\n-                       let sline = line.split(\"///\").last().unwrap_or(\"\");\n-                       let line = sline.trim_left();\n-                       if line.starts_with(\"```\") {\n-                           if ignore {\n-                               ignore = false;\n-                               None\n-                           } else {\n-                               ignore = true;\n-                               Some(line_nb + 1)\n-                           }\n-                       } else {\n-                           None\n-                       }\n-                   }\n-               })\n-               .collect()\n+        content\n+            .lines()\n+            .enumerate()\n+            .filter_map(|(line_nb, line)| {\n+                if (line.trim_left().starts_with(\"pub mod \")\n+                    || line.trim_left().starts_with(\"mod \"))\n+                    && line.ends_with(';')\n+                {\n+                    if let Some(ref mut other_files) = other_files {\n+                        other_files.push(line.rsplit(\"mod \").next().unwrap().replace(\";\", \"\"));\n+                    }\n+                    None\n+                } else {\n+                    let sline = line.split(\"///\").last().unwrap_or(\"\");\n+                    let line = sline.trim_left();\n+                    if line.starts_with(\"```\") {\n+                        if ignore {\n+                            ignore = false;\n+                            None\n+                        } else {\n+                            ignore = true;\n+                            Some(line_nb + 1)\n+                        }\n+                    } else {\n+                        None\n+                    }\n+                }\n+            })\n+            .collect()\n     }\n \n     fn check_rustdoc_test_option(&self, res: ProcRes) {\n         let mut other_files = Vec::new();\n         let mut files: HashMap<String, Vec<usize>> = HashMap::new();\n         let cwd = env::current_dir().unwrap();\n-        files.insert(self.testpaths.file.strip_prefix(&cwd)\n-                                        .unwrap_or(&self.testpaths.file)\n-                                        .to_str()\n-                                        .unwrap()\n-                                        .replace('\\\\', \"/\"),\n-                     self.get_lines(&self.testpaths.file, Some(&mut other_files)));\n+        files.insert(\n+            self.testpaths\n+                .file\n+                .strip_prefix(&cwd)\n+                .unwrap_or(&self.testpaths.file)\n+                .to_str()\n+                .unwrap()\n+                .replace('\\\\', \"/\"),\n+            self.get_lines(&self.testpaths.file, Some(&mut other_files)),\n+        );\n         for other_file in other_files {\n             let mut path = self.testpaths.file.clone();\n             path.set_file_name(&format!(\"{}.rs\", other_file));\n-            files.insert(path.strip_prefix(&cwd)\n-                             .unwrap_or(&path)\n-                             .to_str()\n-                             .unwrap()\n-                             .replace('\\\\', \"/\"),\n-                         self.get_lines(&path, None));\n+            files.insert(\n+                path.strip_prefix(&cwd)\n+                    .unwrap_or(&path)\n+                    .to_str()\n+                    .unwrap()\n+                    .replace('\\\\', \"/\"),\n+                self.get_lines(&path, None),\n+            );\n         }\n \n         let mut tested = 0;\n-        for _ in res.stdout.split('\\n')\n-                           .filter(|s| s.starts_with(\"test \"))\n-                           .inspect(|s| {\n-                               let tmp: Vec<&str> = s.split(\" - \").collect();\n-                               if tmp.len() == 2 {\n-                                   let path = tmp[0].rsplit(\"test \").next().unwrap();\n-                                   if let Some(ref mut v) = files.get_mut(\n-                                                                &path.replace('\\\\', \"/\")) {\n-                                       tested += 1;\n-                                       let mut iter = tmp[1].split(\"(line \");\n-                                       iter.next();\n-                                       let line = iter.next()\n-                                                      .unwrap_or(\")\")\n-                                                      .split(')')\n-                                                      .next()\n-                                                      .unwrap_or(\"0\")\n-                                                      .parse()\n-                                                      .unwrap_or(0);\n-                                       if let Ok(pos) = v.binary_search(&line) {\n-                                           v.remove(pos);\n-                                       } else {\n-                                           self.fatal_proc_rec(\n-                                               &format!(\"Not found doc test: \\\"{}\\\" in \\\"{}\\\":{:?}\",\n-                                                        s, path, v),\n-                                               &res);\n-                                       }\n-                                   }\n-                               }\n-                           }) {}\n+        for _ in res.stdout\n+            .split('\\n')\n+            .filter(|s| s.starts_with(\"test \"))\n+            .inspect(|s| {\n+                let tmp: Vec<&str> = s.split(\" - \").collect();\n+                if tmp.len() == 2 {\n+                    let path = tmp[0].rsplit(\"test \").next().unwrap();\n+                    if let Some(ref mut v) = files.get_mut(&path.replace('\\\\', \"/\")) {\n+                        tested += 1;\n+                        let mut iter = tmp[1].split(\"(line \");\n+                        iter.next();\n+                        let line = iter.next()\n+                            .unwrap_or(\")\")\n+                            .split(')')\n+                            .next()\n+                            .unwrap_or(\"0\")\n+                            .parse()\n+                            .unwrap_or(0);\n+                        if let Ok(pos) = v.binary_search(&line) {\n+                            v.remove(pos);\n+                        } else {\n+                            self.fatal_proc_rec(\n+                                &format!(\"Not found doc test: \\\"{}\\\" in \\\"{}\\\":{:?}\", s, path, v),\n+                                &res,\n+                            );\n+                        }\n+                    }\n+                }\n+            }) {}\n         if tested == 0 {\n             self.fatal_proc_rec(&format!(\"No test has been found... {:?}\", files), &res);\n         } else {\n             for (entry, v) in &files {\n                 if !v.is_empty() {\n-                    self.fatal_proc_rec(&format!(\"Not found test at line{} \\\"{}\\\":{:?}\",\n-                                                 if v.len() > 1 { \"s\" } else { \"\" }, entry, v),\n-                                        &res);\n+                    self.fatal_proc_rec(\n+                        &format!(\n+                            \"Not found test at line{} \\\"{}\\\":{:?}\",\n+                            if v.len() > 1 { \"s\" } else { \"\" },\n+                            entry,\n+                            v\n+                        ),\n+                        &res,\n+                    );\n                 }\n             }\n         }\n@@ -1897,25 +2028,25 @@ actual:\\n\\\n         let mut wrong_cgus = Vec::new();\n \n         for expected_item in &expected {\n-            let actual_item_with_same_name = actual.iter()\n-                                                   .find(|ti| ti.name == expected_item.name);\n+            let actual_item_with_same_name = actual.iter().find(|ti| ti.name == expected_item.name);\n \n             if let Some(actual_item) = actual_item_with_same_name {\n                 if !expected_item.codegen_units.is_empty() &&\n                    // Also check for codegen units\n-                   expected_item.codegen_units != actual_item.codegen_units {\n+                   expected_item.codegen_units != actual_item.codegen_units\n+                {\n                     wrong_cgus.push((expected_item.clone(), actual_item.clone()));\n                 }\n             } else {\n                 missing.push(expected_item.string.clone());\n             }\n         }\n \n-        let unexpected: Vec<_> =\n-            actual.iter()\n-                  .filter(|acgu| !expected.iter().any(|ecgu| acgu.name == ecgu.name))\n-                  .map(|acgu| acgu.string.clone())\n-                  .collect();\n+        let unexpected: Vec<_> = actual\n+            .iter()\n+            .filter(|acgu| !expected.iter().any(|ecgu| acgu.name == ecgu.name))\n+            .map(|acgu| acgu.string.clone())\n+            .collect();\n \n         if !missing.is_empty() {\n             missing.sort();\n@@ -1951,14 +2082,19 @@ actual:\\n\\\n \n             for &(ref expected_item, ref actual_item) in &wrong_cgus {\n                 println!(\"{}\", expected_item.name);\n-                println!(\"  expected: {}\", codegen_units_to_str(&expected_item.codegen_units));\n-                println!(\"  actual:   {}\", codegen_units_to_str(&actual_item.codegen_units));\n+                println!(\n+                    \"  expected: {}\",\n+                    codegen_units_to_str(&expected_item.codegen_units)\n+                );\n+                println!(\n+                    \"  actual:   {}\",\n+                    codegen_units_to_str(&actual_item.codegen_units)\n+                );\n                 println!(\"\");\n             }\n         }\n \n-        if !(missing.is_empty() && unexpected.is_empty() && wrong_cgus.is_empty())\n-        {\n+        if !(missing.is_empty() && unexpected.is_empty() && wrong_cgus.is_empty()) {\n             panic!();\n         }\n \n@@ -1980,22 +2116,22 @@ actual:\\n\\\n             let full_string = format!(\"{}{}\", PREFIX, s.trim().to_owned());\n \n             let parts: Vec<&str> = s.split(CGU_MARKER)\n-                                    .map(str::trim)\n-                                    .filter(|s| !s.is_empty())\n-                                    .collect();\n+                .map(str::trim)\n+                .filter(|s| !s.is_empty())\n+                .collect();\n \n             let name = parts[0].trim();\n \n             let cgus = if parts.len() > 1 {\n                 let cgus_str = parts[1];\n \n-                cgus_str.split(' ')\n-                        .map(str::trim)\n-                        .filter(|s| !s.is_empty())\n-                        .map(str::to_owned)\n-                        .collect()\n-            }\n-            else {\n+                cgus_str\n+                    .split(' ')\n+                    .map(str::trim)\n+                    .filter(|s| !s.is_empty())\n+                    .map(str::to_owned)\n+                    .collect()\n+            } else {\n                 HashSet::new()\n             };\n \n@@ -2006,8 +2142,7 @@ actual:\\n\\\n             }\n         }\n \n-        fn codegen_units_to_str(cgus: &HashSet<String>) -> String\n-        {\n+        fn codegen_units_to_str(cgus: &HashSet<String>) -> String {\n             let mut cgus: Vec<_> = cgus.iter().collect();\n             cgus.sort();\n \n@@ -2038,7 +2173,10 @@ actual:\\n\\\n         fs::create_dir_all(&incremental_dir).unwrap();\n \n         if self.config.verbose {\n-            print!(\"init_incremental_test: incremental_dir={}\", incremental_dir.display());\n+            print!(\n+                \"init_incremental_test: incremental_dir={}\",\n+                incremental_dir.display()\n+            );\n         }\n     }\n \n@@ -2062,11 +2200,15 @@ actual:\\n\\\n         // FIXME -- use non-incremental mode as an oracle? That doesn't apply\n         // to #[rustc_dirty] and clean tests I guess\n \n-        let revision = self.revision.expect(\"incremental tests require a list of revisions\");\n+        let revision = self.revision\n+            .expect(\"incremental tests require a list of revisions\");\n \n         // Incremental workproduct directory should have already been created.\n         let incremental_dir = self.incremental_dir();\n-        assert!(incremental_dir.exists(), \"init_incremental_test failed to create incremental dir\");\n+        assert!(\n+            incremental_dir.exists(),\n+            \"init_incremental_test failed to create incremental dir\"\n+        );\n \n         // Add an extra flag pointing at the incremental directory.\n         let mut revision_props = self.props.clone();\n@@ -2080,7 +2222,11 @@ actual:\\n\\\n         };\n \n         if self.config.verbose {\n-            print!(\"revision={:?} revision_props={:#?}\", revision, revision_props);\n+            print!(\n+                \"revision={:?} revision_props={:#?}\",\n+                revision,\n+                revision_props\n+            );\n         }\n \n         if revision.starts_with(\"rpass\") {\n@@ -2090,8 +2236,7 @@ actual:\\n\\\n         } else if revision.starts_with(\"cfail\") {\n             revision_cx.run_cfail_test();\n         } else {\n-            revision_cx.fatal(\n-                \"revision name must begin with rpass, rfail, or cfail\");\n+            revision_cx.fatal(\"revision name must begin with rpass, rfail, or cfail\");\n         }\n     }\n \n@@ -2103,13 +2248,18 @@ actual:\\n\\\n     fn run_rmake_test(&self) {\n         // FIXME(#11094): we should fix these tests\n         if self.config.host != self.config.target {\n-            return\n+            return;\n         }\n \n         let cwd = env::current_dir().unwrap();\n-        let src_root = self.config.src_base.parent().unwrap()\n-                                           .parent().unwrap()\n-                                           .parent().unwrap();\n+        let src_root = self.config\n+            .src_base\n+            .parent()\n+            .unwrap()\n+            .parent()\n+            .unwrap()\n+            .parent()\n+            .unwrap();\n         let src_root = cwd.join(&src_root);\n \n         let tmpdir = cwd.join(self.output_base_name());\n@@ -2119,31 +2269,37 @@ actual:\\n\\\n         create_dir_all(&tmpdir).unwrap();\n \n         let host = &self.config.host;\n-        let make = if host.contains(\"bitrig\") || host.contains(\"dragonfly\") ||\n-            host.contains(\"freebsd\") || host.contains(\"netbsd\") ||\n-            host.contains(\"openbsd\") {\n+        let make = if host.contains(\"bitrig\") || host.contains(\"dragonfly\")\n+            || host.contains(\"freebsd\") || host.contains(\"netbsd\")\n+            || host.contains(\"openbsd\")\n+        {\n             \"gmake\"\n         } else {\n             \"make\"\n         };\n \n         let mut cmd = Command::new(make);\n         cmd.current_dir(&self.testpaths.file)\n-           .stdout(Stdio::piped())\n-           .stderr(Stdio::piped())\n-           .env(\"TARGET\", &self.config.target)\n-           .env(\"PYTHON\", &self.config.docck_python)\n-           .env(\"S\", src_root)\n-           .env(\"RUST_BUILD_STAGE\", &self.config.stage_id)\n-           .env(\"RUSTC\", cwd.join(&self.config.rustc_path))\n-           .env(\"RUSTDOC\",\n-               cwd.join(&self.config.rustdoc_path.as_ref().expect(\"--rustdoc-path passed\")))\n-           .env(\"TMPDIR\", &tmpdir)\n-           .env(\"LD_LIB_PATH_ENVVAR\", dylib_env_var())\n-           .env(\"HOST_RPATH_DIR\", cwd.join(&self.config.compile_lib_path))\n-           .env(\"TARGET_RPATH_DIR\", cwd.join(&self.config.run_lib_path))\n-           .env(\"LLVM_COMPONENTS\", &self.config.llvm_components)\n-           .env(\"LLVM_CXXFLAGS\", &self.config.llvm_cxxflags);\n+            .stdout(Stdio::piped())\n+            .stderr(Stdio::piped())\n+            .env(\"TARGET\", &self.config.target)\n+            .env(\"PYTHON\", &self.config.docck_python)\n+            .env(\"S\", src_root)\n+            .env(\"RUST_BUILD_STAGE\", &self.config.stage_id)\n+            .env(\"RUSTC\", cwd.join(&self.config.rustc_path))\n+            .env(\n+                \"RUSTDOC\",\n+                cwd.join(&self.config\n+                    .rustdoc_path\n+                    .as_ref()\n+                    .expect(\"--rustdoc-path passed\")),\n+            )\n+            .env(\"TMPDIR\", &tmpdir)\n+            .env(\"LD_LIB_PATH_ENVVAR\", dylib_env_var())\n+            .env(\"HOST_RPATH_DIR\", cwd.join(&self.config.compile_lib_path))\n+            .env(\"TARGET_RPATH_DIR\", cwd.join(&self.config.run_lib_path))\n+            .env(\"LLVM_COMPONENTS\", &self.config.llvm_components)\n+            .env(\"LLVM_CXXFLAGS\", &self.config.llvm_cxxflags);\n \n         if let Some(ref linker) = self.config.linker {\n             cmd.env(\"RUSTC_LINKER\", linker);\n@@ -2161,25 +2317,31 @@ actual:\\n\\\n             // MSYS doesn't like passing flags of the form `/foo` as it thinks it's\n             // a path and instead passes `C:\\msys64\\foo`, so convert all\n             // `/`-arguments to MSVC here to `-` arguments.\n-            let cflags = self.config.cflags.split(' ').map(|s| s.replace(\"/\", \"-\"))\n-                                                 .collect::<Vec<_>>().join(\" \");\n+            let cflags = self.config\n+                .cflags\n+                .split(' ')\n+                .map(|s| s.replace(\"/\", \"-\"))\n+                .collect::<Vec<_>>()\n+                .join(\" \");\n \n             cmd.env(\"IS_MSVC\", \"1\")\n-               .env(\"IS_WINDOWS\", \"1\")\n-               .env(\"MSVC_LIB\", format!(\"'{}' -nologo\", lib.display()))\n-               .env(\"CC\", format!(\"'{}' {}\", self.config.cc, cflags))\n-               .env(\"CXX\", &self.config.cxx);\n+                .env(\"IS_WINDOWS\", \"1\")\n+                .env(\"MSVC_LIB\", format!(\"'{}' -nologo\", lib.display()))\n+                .env(\"CC\", format!(\"'{}' {}\", self.config.cc, cflags))\n+                .env(\"CXX\", &self.config.cxx);\n         } else {\n             cmd.env(\"CC\", format!(\"{} {}\", self.config.cc, self.config.cflags))\n-               .env(\"CXX\", format!(\"{} {}\", self.config.cxx, self.config.cflags))\n-               .env(\"AR\", &self.config.ar);\n+                .env(\"CXX\", format!(\"{} {}\", self.config.cxx, self.config.cflags))\n+                .env(\"AR\", &self.config.ar);\n \n             if self.config.target.contains(\"windows\") {\n                 cmd.env(\"IS_WINDOWS\", \"1\");\n             }\n         }\n \n-        let output = cmd.spawn().and_then(read2_abbreviated).expect(\"failed to spawn `make`\");\n+        let output = cmd.spawn()\n+            .and_then(read2_abbreviated)\n+            .expect(\"failed to spawn `make`\");\n         if !output.status.success() {\n             let res = ProcRes {\n                 status: output.status,\n@@ -2218,7 +2380,10 @@ actual:\\n\\\n         // if the user specified a format in the ui test\n         // print the output to the stderr file, otherwise extract\n         // the rendered error messages from json and print them\n-        let explicit = self.props.compile_flags.iter().any(|s| s.contains(\"--error-format\"));\n+        let explicit = self.props\n+            .compile_flags\n+            .iter()\n+            .any(|s| s.contains(\"--error-format\"));\n \n         let proc_res = self.compile_test();\n \n@@ -2237,24 +2402,27 @@ actual:\\n\\\n             json::extract_rendered(&proc_res.stderr, &proc_res)\n         };\n \n-        let normalized_stderr =\n-            self.normalize_output(&stderr, &self.props.normalize_stderr);\n+        let normalized_stderr = self.normalize_output(&stderr, &self.props.normalize_stderr);\n \n         let mut errors = 0;\n         errors += self.compare_output(\"stdout\", &normalized_stdout, &expected_stdout);\n         errors += self.compare_output(\"stderr\", &normalized_stderr, &expected_stderr);\n \n         if errors > 0 {\n             println!(\"To update references, run this command from build directory:\");\n-            let relative_path_to_file =\n-                self.testpaths.relative_dir\n-                              .join(self.testpaths.file.file_name().unwrap());\n-            println!(\"{}/update-references.sh '{}' '{}'\",\n-                     self.config.src_base.display(),\n-                     self.config.build_base.display(),\n-                     relative_path_to_file.display());\n-            self.fatal_proc_rec(&format!(\"{} errors occurred comparing output.\", errors),\n-                                &proc_res);\n+            let relative_path_to_file = self.testpaths\n+                .relative_dir\n+                .join(self.testpaths.file.file_name().unwrap());\n+            println!(\n+                \"{}/update-references.sh '{}' '{}'\",\n+                self.config.src_base.display(),\n+                self.config.build_base.display(),\n+                relative_path_to_file.display()\n+            );\n+            self.fatal_proc_rec(\n+                &format!(\"{} errors occurred comparing output.\", errors),\n+                &proc_res,\n+            );\n         }\n \n         let expected_errors = errors::load_errors(&self.testpaths.file, self.revision);\n@@ -2294,13 +2462,14 @@ actual:\\n\\\n \n     fn check_mir_dump(&self) {\n         let mut test_file_contents = String::new();\n-        fs::File::open(self.testpaths.file.clone()).unwrap()\n-                                                   .read_to_string(&mut test_file_contents)\n-                                                   .unwrap();\n-        if let Some(idx) =  test_file_contents.find(\"// END RUST SOURCE\") {\n+        fs::File::open(self.testpaths.file.clone())\n+            .unwrap()\n+            .read_to_string(&mut test_file_contents)\n+            .unwrap();\n+        if let Some(idx) = test_file_contents.find(\"// END RUST SOURCE\") {\n             let (_, tests_text) = test_file_contents.split_at(idx + \"// END_RUST SOURCE\".len());\n             let tests_text_str = String::from(tests_text);\n-            let mut curr_test : Option<&str> = None;\n+            let mut curr_test: Option<&str> = None;\n             let mut curr_test_contents = vec![ExpectedLine::Elision];\n             for l in tests_text_str.lines() {\n                 debug!(\"line: {:?}\", l);\n@@ -2334,9 +2503,16 @@ actual:\\n\\\n         let output_time = t(output_file);\n         let source_time = t(source_file);\n         if source_time > output_time {\n-            debug!(\"source file time: {:?} output file time: {:?}\", source_time, output_time);\n-            panic!(\"test source file `{}` is newer than potentially stale output file `{}`.\",\n-                   source_file.display(), test_name);\n+            debug!(\n+                \"source file time: {:?} output file time: {:?}\",\n+                source_time,\n+                output_time\n+            );\n+            panic!(\n+                \"test source file `{}` is newer than potentially stale output file `{}`.\",\n+                source_file.display(),\n+                test_name\n+            );\n         }\n     }\n \n@@ -2347,22 +2523,27 @@ actual:\\n\\\n         debug!(\"comparing the contests of: {:?}\", output_file);\n         debug!(\"with: {:?}\", expected_content);\n         if !output_file.exists() {\n-            panic!(\"Output file `{}` from test does not exist\",\n-                   output_file.into_os_string().to_string_lossy());\n+            panic!(\n+                \"Output file `{}` from test does not exist\",\n+                output_file.into_os_string().to_string_lossy()\n+            );\n         }\n         self.check_mir_test_timestamp(test_name, &output_file);\n \n         let mut dumped_file = fs::File::open(output_file.clone()).unwrap();\n         let mut dumped_string = String::new();\n         dumped_file.read_to_string(&mut dumped_string).unwrap();\n         let mut dumped_lines = dumped_string.lines().filter(|l| !l.is_empty());\n-        let mut expected_lines = expected_content.iter().filter(|&l| {\n-            if let &ExpectedLine::Text(l) = l {\n-                !l.is_empty()\n-            } else {\n-                true\n-            }\n-        }).peekable();\n+        let mut expected_lines = expected_content\n+            .iter()\n+            .filter(|&l| {\n+                if let &ExpectedLine::Text(l) = l {\n+                    !l.is_empty()\n+                } else {\n+                    true\n+                }\n+            })\n+            .peekable();\n \n         let compare = |expected_line, dumped_line| {\n             let e_norm = normalize_mir_line(expected_line);\n@@ -2373,27 +2554,31 @@ actual:\\n\\\n         };\n \n         let error = |expected_line, extra_msg| {\n-            let normalize_all = dumped_string.lines()\n-                                             .map(nocomment_mir_line)\n-                                             .filter(|l| !l.is_empty())\n-                                             .collect::<Vec<_>>()\n-                                             .join(\"\\n\");\n+            let normalize_all = dumped_string\n+                .lines()\n+                .map(nocomment_mir_line)\n+                .filter(|l| !l.is_empty())\n+                .collect::<Vec<_>>()\n+                .join(\"\\n\");\n             let f = |l: &ExpectedLine<_>| match l {\n                 &ExpectedLine::Elision => \"... (elided)\".into(),\n-                &ExpectedLine::Text(t) => t\n+                &ExpectedLine::Text(t) => t,\n             };\n-            let expected_content = expected_content.iter()\n-                                                   .map(|l| f(l))\n-                                                   .collect::<Vec<_>>()\n-                                                   .join(\"\\n\");\n-            panic!(\"Did not find expected line, error: {}\\n\\\n-                   Actual Line: {:?}\\n\\\n-                   Expected:\\n{}\\n\\\n-                   Actual:\\n{}\",\n-                   extra_msg,\n-                   expected_line,\n-                   expected_content,\n-                   normalize_all);\n+            let expected_content = expected_content\n+                .iter()\n+                .map(|l| f(l))\n+                .collect::<Vec<_>>()\n+                .join(\"\\n\");\n+            panic!(\n+                \"Did not find expected line, error: {}\\n\\\n+                 Actual Line: {:?}\\n\\\n+                 Expected:\\n{}\\n\\\n+                 Actual:\\n{}\",\n+                extra_msg,\n+                expected_line,\n+                expected_content,\n+                normalize_all\n+            );\n         };\n \n         // We expect each non-empty line to appear consecutively, non-consecutive lines\n@@ -2409,11 +2594,16 @@ actual:\\n\\\n \n                     if !compare(expected_line, dumped_line) {\n                         error!(\"{:?}\", start_block_line);\n-                        error(expected_line,\n-                              format!(\"Mismatch in lines\\nCurrnt block: {}\\nExpected Line: {:?}\",\n-                                      start_block_line.unwrap_or(\"None\"), dumped_line));\n+                        error(\n+                            expected_line,\n+                            format!(\n+                                \"Mismatch in lines\\nCurrnt block: {}\\nExpected Line: {:?}\",\n+                                start_block_line.unwrap_or(\"None\"),\n+                                dumped_line\n+                            ),\n+                        );\n                     }\n-                },\n+                }\n                 Some(&ExpectedLine::Elision) => {\n                     // skip any number of elisions in a row.\n                     while let Some(&&ExpectedLine::Elision) = expected_lines.peek() {\n@@ -2434,8 +2624,8 @@ actual:\\n\\\n                             error(expected_line, \"ran out of mir dump to match against\".into());\n                         }\n                     }\n-                },\n-                None => {},\n+                }\n+                None => {}\n             }\n         }\n     }\n@@ -2451,10 +2641,10 @@ actual:\\n\\\n     fn normalize_output(&self, output: &str, custom_rules: &[(String, String)]) -> String {\n         let parent_dir = self.testpaths.file.parent().unwrap();\n         let cflags = self.props.compile_flags.join(\" \");\n-        let json = cflags.contains(\"--error-format json\") ||\n-                   cflags.contains(\"--error-format pretty-json\") ||\n-                   cflags.contains(\"--error-format=json\") ||\n-                   cflags.contains(\"--error-format=pretty-json\");\n+        let json = cflags.contains(\"--error-format json\")\n+            || cflags.contains(\"--error-format pretty-json\")\n+            || cflags.contains(\"--error-format=json\")\n+            || cflags.contains(\"--error-format=pretty-json\");\n         let parent_dir_str = if json {\n             parent_dir.display().to_string().replace(\"\\\\\", \"\\\\\\\\\")\n         } else {\n@@ -2497,10 +2687,11 @@ actual:\\n\\\n         let mut result = String::new();\n         match File::open(path).and_then(|mut f| f.read_to_string(&mut result)) {\n             Ok(_) => result,\n-            Err(e) => {\n-                self.fatal(&format!(\"failed to load expected output from `{}`: {}\",\n-                                    path.display(), e))\n-            }\n+            Err(e) => self.fatal(&format!(\n+                \"failed to load expected output from `{}`: {}\",\n+                path.display(),\n+                e\n+            )),\n         }\n     }\n \n@@ -2515,19 +2706,21 @@ actual:\\n\\\n \n         for diff in diff::lines(expected, actual) {\n             match diff {\n-                diff::Result::Left(l)    => println!(\"-{}\", l),\n+                diff::Result::Left(l) => println!(\"-{}\", l),\n                 diff::Result::Both(l, _) => println!(\" {}\", l),\n-                diff::Result::Right(r)   => println!(\"+{}\", r),\n+                diff::Result::Right(r) => println!(\"+{}\", r),\n             }\n         }\n \n         let output_file = self.output_base_name().with_extension(kind);\n         match File::create(&output_file).and_then(|mut f| f.write_all(actual.as_bytes())) {\n-            Ok(()) => { }\n-            Err(e) => {\n-                self.fatal(&format!(\"failed to write {} to `{}`: {}\",\n-                                    kind, output_file.display(), e))\n-            }\n+            Ok(()) => {}\n+            Err(e) => self.fatal(&format!(\n+                \"failed to write {} to `{}`: {}\",\n+                kind,\n+                output_file.display(),\n+                e\n+            )),\n         }\n \n         println!(\"\\nThe actual {0} differed from the expected {0}.\", kind);\n@@ -2553,20 +2746,24 @@ impl ProcRes {\n         if let Some(e) = err {\n             println!(\"\\nerror: {}\", e);\n         }\n-        print!(\"\\\n-            status: {}\\n\\\n-            command: {}\\n\\\n-            stdout:\\n\\\n-            ------------------------------------------\\n\\\n-            {}\\n\\\n-            ------------------------------------------\\n\\\n-            stderr:\\n\\\n-            ------------------------------------------\\n\\\n-            {}\\n\\\n-            ------------------------------------------\\n\\\n-            \\n\",\n-               self.status, self.cmdline, self.stdout,\n-               self.stderr);\n+        print!(\n+            \"\\\n+             status: {}\\n\\\n+             command: {}\\n\\\n+             stdout:\\n\\\n+             ------------------------------------------\\n\\\n+             {}\\n\\\n+             ------------------------------------------\\n\\\n+             stderr:\\n\\\n+             ------------------------------------------\\n\\\n+             {}\\n\\\n+             ------------------------------------------\\n\\\n+             \\n\",\n+            self.status,\n+            self.cmdline,\n+            self.stdout,\n+            self.stderr\n+        );\n         panic!();\n     }\n }\n@@ -2579,12 +2776,12 @@ enum TargetLocation {\n #[derive(Clone, PartialEq, Eq)]\n enum ExpectedLine<T: AsRef<str>> {\n     Elision,\n-    Text(T)\n+    Text(T),\n }\n \n impl<T> fmt::Debug for ExpectedLine<T>\n where\n-    T: AsRef<str> + fmt::Debug\n+    T: AsRef<str> + fmt::Debug,\n {\n     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n         if let &ExpectedLine::Text(ref t) = self {\n@@ -2621,7 +2818,7 @@ fn read2_abbreviated(mut child: Child) -> io::Result<Output> {\n             head: Vec<u8>,\n             skipped: usize,\n             tail: Box<[u8]>,\n-        }\n+        },\n     }\n \n     impl ProcOutput {\n@@ -2636,9 +2833,17 @@ fn read2_abbreviated(mut child: Child) -> io::Result<Output> {\n                     let tail = bytes.split_off(new_len - TAIL_LEN).into_boxed_slice();\n                     let head = replace(bytes, Vec::new());\n                     let skipped = new_len - HEAD_LEN - TAIL_LEN;\n-                    ProcOutput::Abbreviated { head, skipped, tail }\n+                    ProcOutput::Abbreviated {\n+                        head,\n+                        skipped,\n+                        tail,\n+                    }\n                 }\n-                ProcOutput::Abbreviated { ref mut skipped, ref mut tail, .. } => {\n+                ProcOutput::Abbreviated {\n+                    ref mut skipped,\n+                    ref mut tail,\n+                    ..\n+                } => {\n                     *skipped += data.len();\n                     if data.len() <= TAIL_LEN {\n                         tail[..data.len()].copy_from_slice(data);\n@@ -2655,7 +2860,11 @@ fn read2_abbreviated(mut child: Child) -> io::Result<Output> {\n         fn into_bytes(self) -> Vec<u8> {\n             match self {\n                 ProcOutput::Full(bytes) => bytes,\n-                ProcOutput::Abbreviated { mut head, skipped, tail } => {\n+                ProcOutput::Abbreviated {\n+                    mut head,\n+                    skipped,\n+                    tail,\n+                } => {\n                     write!(&mut head, \"\\n\\n<<<<<< SKIPPED {} BYTES >>>>>>\\n\\n\", skipped).unwrap();\n                     head.extend_from_slice(&tail);\n                     head\n@@ -2668,10 +2877,14 @@ fn read2_abbreviated(mut child: Child) -> io::Result<Output> {\n     let mut stderr = ProcOutput::Full(Vec::new());\n \n     drop(child.stdin.take());\n-    read2(child.stdout.take().unwrap(), child.stderr.take().unwrap(), &mut |is_stdout, data, _| {\n-        if is_stdout { &mut stdout } else { &mut stderr }.extend(data);\n-        data.clear();\n-    })?;\n+    read2(\n+        child.stdout.take().unwrap(),\n+        child.stderr.take().unwrap(),\n+        &mut |is_stdout, data, _| {\n+            if is_stdout { &mut stdout } else { &mut stderr }.extend(data);\n+            data.clear();\n+        },\n+    )?;\n     let status = child.wait()?;\n \n     Ok(Output {"}]}