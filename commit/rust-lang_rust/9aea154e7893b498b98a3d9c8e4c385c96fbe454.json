{"sha": "9aea154e7893b498b98a3d9c8e4c385c96fbe454", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhZWExNTRlNzg5M2I0OThiOThhM2Q5YzhlNGMzODVjOTZmYmU0NTQ=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2020-02-11T23:36:29Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2020-02-12T00:32:57Z"}, "message": "Improve `u8to64_le`.\n\nThis makes it faster and also changes it to a safe function. (Thanks to\nMichael Woerister for the suggestion.) `load_int_le!` is also no longer\nnecessary.", "tree": {"sha": "81a515b6f23e099a62f4f07c8999a27cfa5076e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81a515b6f23e099a62f4f07c8999a27cfa5076e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9aea154e7893b498b98a3d9c8e4c385c96fbe454", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9aea154e7893b498b98a3d9c8e4c385c96fbe454", "html_url": "https://github.com/rust-lang/rust/commit/9aea154e7893b498b98a3d9c8e4c385c96fbe454", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9aea154e7893b498b98a3d9c8e4c385c96fbe454/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8a02864afa2faecc3cb9cb8f81905a61a638ade", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8a02864afa2faecc3cb9cb8f81905a61a638ade", "html_url": "https://github.com/rust-lang/rust/commit/f8a02864afa2faecc3cb9cb8f81905a61a638ade"}], "stats": {"total": 53, "additions": 12, "deletions": 41}, "files": [{"sha": "430f2f40caa9b7c889f5d5813ded32b923feffa8", "filename": "src/librustc_data_structures/sip128.rs", "status": "modified", "additions": 12, "deletions": 41, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/9aea154e7893b498b98a3d9c8e4c385c96fbe454/src%2Flibrustc_data_structures%2Fsip128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aea154e7893b498b98a3d9c8e4c385c96fbe454/src%2Flibrustc_data_structures%2Fsip128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsip128.rs?ref=9aea154e7893b498b98a3d9c8e4c385c96fbe454", "patch": "@@ -51,46 +51,17 @@ macro_rules! compress {\n     }};\n }\n \n-/// Loads an integer of the desired type from a byte stream, in LE order. Uses\n-/// `copy_nonoverlapping` to let the compiler generate the most efficient way\n-/// to load it from a possibly unaligned address.\n-///\n-/// Unsafe because: unchecked indexing at i..i+size_of(int_ty)\n-macro_rules! load_int_le {\n-    ($buf:expr, $i:expr, $int_ty:ident) => {{\n-        debug_assert!($i + mem::size_of::<$int_ty>() <= $buf.len());\n-        let mut data = 0 as $int_ty;\n-        ptr::copy_nonoverlapping(\n-            $buf.get_unchecked($i),\n-            &mut data as *mut _ as *mut u8,\n-            mem::size_of::<$int_ty>(),\n-        );\n-        data.to_le()\n-    }};\n-}\n-\n-/// Loads an u64 using up to 7 bytes of a byte slice.\n-///\n-/// Unsafe because: unchecked indexing at start..start+len\n+/// Loads up to 8 bytes from a byte-slice into a little-endian u64.\n #[inline]\n-unsafe fn u8to64_le(buf: &[u8], start: usize, len: usize) -> u64 {\n-    debug_assert!(len < 8);\n-    let mut i = 0; // current byte index (from LSB) in the output u64\n-    let mut out = 0;\n-    if i + 3 < len {\n-        out = u64::from(load_int_le!(buf, start + i, u32));\n-        i += 4;\n-    }\n-    if i + 1 < len {\n-        out |= u64::from(load_int_le!(buf, start + i, u16)) << (i * 8);\n-        i += 2\n-    }\n-    if i < len {\n-        out |= u64::from(*buf.get_unchecked(start + i)) << (i * 8);\n-        i += 1;\n+fn u8to64_le(buf: &[u8], start: usize, len: usize) -> u64 {\n+    assert!(len <= 8 && start + len <= buf.len());\n+\n+    let mut out = 0u64;\n+    unsafe {\n+        let out_ptr = &mut out as *mut _ as *mut u8;\n+        ptr::copy_nonoverlapping(buf.as_ptr().offset(start as isize), out_ptr, len);\n     }\n-    debug_assert_eq!(i, len);\n-    out\n+    out.to_le()\n }\n \n impl SipHasher128 {\n@@ -272,7 +243,7 @@ impl Hasher for SipHasher128 {\n \n         if self.ntail != 0 {\n             needed = 8 - self.ntail;\n-            self.tail |= unsafe { u8to64_le(msg, 0, cmp::min(length, needed)) } << (8 * self.ntail);\n+            self.tail |= u8to64_le(msg, 0, cmp::min(length, needed)) << (8 * self.ntail);\n             if length < needed {\n                 self.ntail += length;\n                 return;\n@@ -290,7 +261,7 @@ impl Hasher for SipHasher128 {\n \n         let mut i = needed;\n         while i < len - left {\n-            let mi = unsafe { load_int_le!(msg, i, u64) };\n+            let mi = u8to64_le(msg, i, 8);\n \n             self.state.v3 ^= mi;\n             Sip24Rounds::c_rounds(&mut self.state);\n@@ -299,7 +270,7 @@ impl Hasher for SipHasher128 {\n             i += 8;\n         }\n \n-        self.tail = unsafe { u8to64_le(msg, i, left) };\n+        self.tail = u8to64_le(msg, i, left);\n         self.ntail = left;\n     }\n "}]}