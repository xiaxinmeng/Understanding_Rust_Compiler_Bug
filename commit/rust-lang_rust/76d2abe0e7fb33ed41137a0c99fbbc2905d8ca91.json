{"sha": "76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2ZDJhYmUwZTdmYjMzZWQ0MTEzN2EwYzk5ZmJiYzI5MDVkOGNhOTE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-11-06T21:31:18Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-11-06T21:31:18Z"}, "message": "rollup merge of #18630 : nikomatsakis/purge-the-bars", "tree": {"sha": "1ea979f4b18b619db872eded0bbdb7971e6cc379", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ea979f4b18b619db872eded0bbdb7971e6cc379"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "html_url": "https://github.com/rust-lang/rust/commit/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "08ddfc10e4170ac5f4522a71c0d1aea8cf799f29", "url": "https://api.github.com/repos/rust-lang/rust/commits/08ddfc10e4170ac5f4522a71c0d1aea8cf799f29", "html_url": "https://github.com/rust-lang/rust/commit/08ddfc10e4170ac5f4522a71c0d1aea8cf799f29"}, {"sha": "d0fa4c6239accc08aae11d9db3e13d4153add432", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0fa4c6239accc08aae11d9db3e13d4153add432", "html_url": "https://github.com/rust-lang/rust/commit/d0fa4c6239accc08aae11d9db3e13d4153add432"}], "stats": {"total": 1582, "additions": 953, "deletions": 629}, "files": [{"sha": "d5e9c1ef99f111f160310b936b5713de02a886d0", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -57,7 +57,6 @@ register_diagnostics!(\n     E0044,\n     E0045,\n     E0046,\n-    E0047,\n     E0049,\n     E0050,\n     E0051,\n@@ -111,7 +110,6 @@ register_diagnostics!(\n     E0108,\n     E0109,\n     E0110,\n-    E0113,\n     E0116,\n     E0117,\n     E0118,\n@@ -145,5 +143,6 @@ register_diagnostics!(\n     E0163,\n     E0164,\n     E0165,\n-    E0166\n+    E0166,\n+    E0167\n )"}, {"sha": "7a97589b9facb46ebd09c0a52175220b92051c06", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -138,7 +138,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr) -> bool {\n             // to handle on-demand instantiation of functions via\n             // foo::<bar> in a const. Currently that is only done on\n             // a path in trans::callee that only works in block contexts.\n-            if !pth.segments.iter().all(|segment| segment.types.is_empty()) {\n+            if !pth.segments.iter().all(|segment| segment.parameters.is_empty()) {\n                 span_err!(v.tcx.sess, e.span, E0013,\n                           \"paths in constants may only refer to items without \\\n                            type parameters\");"}, {"sha": "e320f47075e8625ebddb219f9d9b192f7fd49286", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -16,7 +16,6 @@ use std::collections::HashMap;\n use syntax::ast::*;\n use syntax::ast_util::{walk_pat};\n use syntax::codemap::{Span, DUMMY_SP};\n-use syntax::owned_slice::OwnedSlice;\n \n pub type PatIdMap = HashMap<Ident, NodeId>;\n \n@@ -133,8 +132,7 @@ pub fn def_to_path(tcx: &ty::ctxt, id: DefId) -> Path {\n         global: false,\n         segments: path.last().map(|elem| PathSegment {\n             identifier: Ident::new(elem.name()),\n-            lifetimes: vec!(),\n-            types: OwnedSlice::empty()\n+            parameters: PathParameters::none(),\n         }).into_iter().collect(),\n         span: DUMMY_SP,\n     })"}, {"sha": "21b94babcb6a4b50eda09a0cbb8fd4b754e3c65b", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -27,7 +27,6 @@ use syntax::ast_map;\n use syntax::ast_util::{is_local, local_def, PostExpansionMethod};\n use syntax::codemap::Span;\n use syntax::parse::token;\n-use syntax::owned_slice::OwnedSlice;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n@@ -945,8 +944,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                                     debug!(\"privacy - ident item {}\", id);\n                                     let seg = ast::PathSegment {\n                                         identifier: name,\n-                                        lifetimes: Vec::new(),\n-                                        types: OwnedSlice::empty(),\n+                                        parameters: ast::PathParameters::none(),\n                                     };\n                                     let segs = vec![seg];\n                                     let path = ast::Path {"}, {"sha": "a1a8cccf55a4bdc52cafd5d2a7c681a4a0eeeb41", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 5, "deletions": 40, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -40,7 +40,7 @@ use syntax::ast::{TupleVariantKind, Ty, TyBool, TyChar, TyClosure, TyF32};\n use syntax::ast::{TyF64, TyFloat, TyI, TyI8, TyI16, TyI32, TyI64, TyInt};\n use syntax::ast::{TyParam, TyParamBound, TyPath, TyPtr, TyProc, TyQPath};\n use syntax::ast::{TyRptr, TyStr, TyU, TyU8, TyU16, TyU32, TyU64, TyUint};\n-use syntax::ast::{TypeImplItem, UnboxedFnTyParamBound, UnnamedField};\n+use syntax::ast::{TypeImplItem, UnnamedField};\n use syntax::ast::{Variant, ViewItem, ViewItemExternCrate};\n use syntax::ast::{ViewItemUse, ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::ast::{Visibility};\n@@ -4523,41 +4523,6 @@ impl<'a> Resolver<'a> {\n             TraitTyParamBound(ref tref) => {\n                 self.resolve_trait_reference(id, tref, reference_type)\n             }\n-            UnboxedFnTyParamBound(ref unboxed_function) => {\n-                match self.resolve_path(unboxed_function.ref_id,\n-                                        &unboxed_function.path,\n-                                        TypeNS,\n-                                        true) {\n-                    None => {\n-                        let path_str = self.path_names_to_string(\n-                            &unboxed_function.path);\n-                        self.resolve_error(unboxed_function.path.span,\n-                                           format!(\"unresolved trait `{}`\",\n-                                                   path_str).as_slice())\n-                    }\n-                    Some(def) => {\n-                        match def {\n-                            (DefTrait(_), _) => {\n-                                self.record_def(unboxed_function.ref_id, def);\n-                            }\n-                            _ => {\n-                                let msg =\n-                                    format!(\"`{}` is not a trait\",\n-                                            self.path_names_to_string(\n-                                                &unboxed_function.path));\n-                                self.resolve_error(unboxed_function.path.span,\n-                                                   msg.as_slice());\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                for argument in unboxed_function.decl.inputs.iter() {\n-                    self.resolve_type(&*argument.ty);\n-                }\n-\n-                self.resolve_type(&*unboxed_function.decl.output);\n-            }\n             RegionTyParamBound(..) => {}\n         }\n     }\n@@ -4951,12 +4916,12 @@ impl<'a> Resolver<'a> {\n \n                             if path.segments\n                                    .iter()\n-                                   .any(|s| !s.lifetimes.is_empty()) {\n+                                   .any(|s| s.parameters.has_lifetimes()) {\n                                 span_err!(self.session, path.span, E0157,\n                                     \"lifetime parameters are not allowed on this type\");\n                             } else if path.segments\n                                           .iter()\n-                                          .any(|s| s.types.len() > 0) {\n+                                          .any(|s| !s.parameters.is_empty()) {\n                                 span_err!(self.session, path.span, E0153,\n                                     \"type parameters are not allowed on this type\");\n                             }\n@@ -5234,7 +5199,7 @@ impl<'a> Resolver<'a> {\n                     // Check the types in the path pattern.\n                     for ty in path.segments\n                                   .iter()\n-                                  .flat_map(|s| s.types.iter()) {\n+                                  .flat_map(|s| s.parameters.types().into_iter()) {\n                         self.resolve_type(&**ty);\n                     }\n                 }\n@@ -5340,7 +5305,7 @@ impl<'a> Resolver<'a> {\n                     namespace: Namespace,\n                     check_ribs: bool) -> Option<(Def, LastPrivate)> {\n         // First, resolve the types.\n-        for ty in path.segments.iter().flat_map(|s| s.types.iter()) {\n+        for ty in path.segments.iter().flat_map(|s| s.parameters.types().into_iter()) {\n             self.resolve_type(&**ty);\n         }\n "}, {"sha": "8246970c24ad7695ad37943603cbbdb42ed2930a", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -204,9 +204,6 @@ impl<'a> LifetimeContext<'a> {\n                 ast::TraitTyParamBound(ref trait_ref) => {\n                     self.visit_trait_ref(trait_ref);\n                 }\n-                ast::UnboxedFnTyParamBound(ref fn_decl) => {\n-                    self.visit_unboxed_fn_ty_param_bound(&**fn_decl);\n-                }\n                 ast::RegionTyParamBound(ref lifetime) => {\n                     self.visit_lifetime_ref(lifetime);\n                 }\n@@ -226,18 +223,6 @@ impl<'a> LifetimeContext<'a> {\n         })\n     }\n \n-    fn visit_unboxed_fn_ty_param_bound(&mut self,\n-                                       bound: &ast::UnboxedFnBound) {\n-        self.with(|scope, f| {\n-            f(LateScope(bound.ref_id, &bound.lifetimes, scope))\n-        }, |v| {\n-            for argument in bound.decl.inputs.iter() {\n-                v.visit_ty(&*argument.ty);\n-            }\n-            v.visit_ty(&*bound.decl.output);\n-        })\n-    }\n-\n     /// Visits self by adding a scope and handling recursive walk over the contents with `walk`.\n     fn visit_fn_decl(&mut self,\n                      n: ast::NodeId,"}, {"sha": "b64a160ab1f28c915aab829310be1bf3fa21d981", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -705,7 +705,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                 ast::TraitTyParamBound(ref trait_ref) => {\n                     trait_ref\n                 }\n-                ast::UnboxedFnTyParamBound(..) | ast::RegionTyParamBound(..) => {\n+                ast::RegionTyParamBound(..) => {\n                     continue;\n                 }\n             };"}, {"sha": "0d8ef560c7d57c3f8fad5617eebf4b71224a340d", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -1836,11 +1836,7 @@ pub fn trans_closure(ccx: &CrateContext,\n         NotUnboxedClosure => monomorphized_arg_types,\n \n         // Tuple up closure argument types for the \"rust-call\" ABI.\n-        IsUnboxedClosure => vec![if monomorphized_arg_types.is_empty() {\n-            ty::mk_nil()\n-        } else {\n-            ty::mk_tup(ccx.tcx(), monomorphized_arg_types)\n-        }]\n+        IsUnboxedClosure => vec![ty::mk_tup_or_nil(ccx.tcx(), monomorphized_arg_types)]\n     };\n     for monomorphized_arg_type in monomorphized_arg_types.iter() {\n         debug!(\"trans_closure: monomorphized_arg_type: {}\","}, {"sha": "409809e0cb33b006324e2ec9683c7b385c822ff3", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -625,7 +625,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n           }\n           ast::ExprPath(ref pth) => {\n             // Assert that there are no type parameters in this path.\n-            assert!(pth.segments.iter().all(|seg| seg.types.is_empty()));\n+            assert!(pth.segments.iter().all(|seg| !seg.parameters.has_types()));\n \n             let opt_def = cx.tcx().def_map.borrow().find_copy(&e.id);\n             match opt_def {"}, {"sha": "d1baeac81ab3a89b38466a228c1ff362b9cff13d", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -1838,6 +1838,14 @@ pub fn mk_slice(cx: &ctxt, r: Region, tm: mt) -> t {\n \n pub fn mk_tup(cx: &ctxt, ts: Vec<t>) -> t { mk_t(cx, ty_tup(ts)) }\n \n+pub fn mk_tup_or_nil(cx: &ctxt, ts: Vec<t>) -> t {\n+    if ts.len() == 0 {\n+        ty::mk_nil()\n+    } else {\n+        mk_t(cx, ty_tup(ts))\n+    }\n+}\n+\n pub fn mk_closure(cx: &ctxt, fty: ClosureTy) -> t {\n     mk_t(cx, ty_closure(box fty))\n }"}, {"sha": "ae0bbd617e23343f2d8cb22a70377c8efc03ac4e", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 140, "deletions": 145, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -59,7 +59,7 @@ use middle::subst::{VecPerParamSpace};\n use middle::ty;\n use middle::typeck::lookup_def_tcx;\n use middle::typeck::infer;\n-use middle::typeck::rscope::{UnelidableRscope, RegionScope, SpecificRscope};\n+use middle::typeck::rscope::{UnelidableRscope, RegionScope, SpecificRscope, BindingRscope};\n use middle::typeck::rscope;\n use middle::typeck::TypeAndSubsts;\n use middle::typeck;\n@@ -207,15 +207,16 @@ pub fn opt_ast_region_to_region<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n }\n \n fn ast_path_substs<'tcx,AC,RS>(\n-                   this: &AC,\n-                   rscope: &RS,\n-                   decl_def_id: ast::DefId,\n-                   decl_generics: &ty::Generics,\n-                   self_ty: Option<ty::t>,\n-                   associated_ty: Option<ty::t>,\n-                   path: &ast::Path)\n-                   -> Substs\n-                   where AC: AstConv<'tcx>, RS: RegionScope\n+    this: &AC,\n+    rscope: &RS,\n+    decl_def_id: ast::DefId,\n+    decl_generics: &ty::Generics,\n+    self_ty: Option<ty::t>,\n+    associated_ty: Option<ty::t>,\n+    path: &ast::Path,\n+    binder_id: ast::NodeId)\n+    -> Substs\n+    where AC: AstConv<'tcx>, RS: RegionScope\n {\n     /*!\n      * Given a path `path` that refers to an item `I` with the\n@@ -236,67 +237,73 @@ fn ast_path_substs<'tcx,AC,RS>(\n     assert!(decl_generics.regions.all(|d| d.space == TypeSpace));\n     assert!(decl_generics.types.all(|d| d.space != FnSpace));\n \n+    let (regions, types) = match path.segments.last().unwrap().parameters {\n+        ast::AngleBracketedParameters(ref data) =>\n+            angle_bracketed_parameters(this, rscope, data),\n+        ast::ParenthesizedParameters(ref data) =>\n+            parenthesized_parameters(this, binder_id, data),\n+    };\n+\n     // If the type is parameterized by the this region, then replace this\n     // region with the current anon region binding (in other words,\n     // whatever & would get replaced with).\n     let expected_num_region_params = decl_generics.regions.len(TypeSpace);\n-    let supplied_num_region_params = path.segments.last().unwrap().lifetimes.len();\n+    let supplied_num_region_params = regions.len();\n     let regions = if expected_num_region_params == supplied_num_region_params {\n-        path.segments.last().unwrap().lifetimes.iter().map(\n-            |l| ast_region_to_region(this.tcx(), l)).collect::<Vec<_>>()\n+        regions\n     } else {\n         let anon_regions =\n             rscope.anon_regions(path.span, expected_num_region_params);\n \n         if supplied_num_region_params != 0 || anon_regions.is_err() {\n             span_err!(tcx.sess, path.span, E0107,\n-                \"wrong number of lifetime parameters: expected {}, found {}\",\n-                expected_num_region_params, supplied_num_region_params);\n+                      \"wrong number of lifetime parameters: expected {}, found {}\",\n+                      expected_num_region_params, supplied_num_region_params);\n         }\n \n         match anon_regions {\n             Ok(v) => v.into_iter().collect(),\n             Err(_) => Vec::from_fn(expected_num_region_params,\n-                                    |_| ty::ReStatic) // hokey\n+                                   |_| ty::ReStatic) // hokey\n         }\n     };\n \n     // Convert the type parameters supplied by the user.\n     let ty_param_defs = decl_generics.types.get_slice(TypeSpace);\n-    let supplied_ty_param_count = path.segments.iter().flat_map(|s| s.types.iter()).count();\n+    let supplied_ty_param_count = types.len();\n     let formal_ty_param_count =\n         ty_param_defs.iter()\n-                     .take_while(|x| !ty::is_associated_type(tcx, x.def_id))\n-                     .count();\n+        .take_while(|x| !ty::is_associated_type(tcx, x.def_id))\n+        .count();\n     let required_ty_param_count =\n         ty_param_defs.iter()\n-                     .take_while(|x| {\n-                        x.default.is_none() &&\n-                        !ty::is_associated_type(tcx, x.def_id)\n-                     })\n-                     .count();\n+        .take_while(|x| {\n+            x.default.is_none() &&\n+                !ty::is_associated_type(tcx, x.def_id)\n+        })\n+        .count();\n     if supplied_ty_param_count < required_ty_param_count {\n         let expected = if required_ty_param_count < formal_ty_param_count {\n             \"expected at least\"\n         } else {\n             \"expected\"\n         };\n         this.tcx().sess.span_fatal(path.span,\n-            format!(\"wrong number of type arguments: {} {}, found {}\",\n-                    expected,\n-                    required_ty_param_count,\n-                    supplied_ty_param_count).as_slice());\n+                                   format!(\"wrong number of type arguments: {} {}, found {}\",\n+                                           expected,\n+                                           required_ty_param_count,\n+                                           supplied_ty_param_count).as_slice());\n     } else if supplied_ty_param_count > formal_ty_param_count {\n         let expected = if required_ty_param_count < formal_ty_param_count {\n             \"expected at most\"\n         } else {\n             \"expected\"\n         };\n         this.tcx().sess.span_fatal(path.span,\n-            format!(\"wrong number of type arguments: {} {}, found {}\",\n-                    expected,\n-                    formal_ty_param_count,\n-                    supplied_ty_param_count).as_slice());\n+                                   format!(\"wrong number of type arguments: {} {}, found {}\",\n+                                           expected,\n+                                           formal_ty_param_count,\n+                                           supplied_ty_param_count).as_slice());\n     }\n \n     if supplied_ty_param_count > required_ty_param_count\n@@ -307,13 +314,7 @@ fn ast_path_substs<'tcx,AC,RS>(\n             \"add #![feature(default_type_params)] to the crate attributes to enable\");\n     }\n \n-    let tps = path.segments\n-                  .iter()\n-                  .flat_map(|s| s.types.iter())\n-                  .map(|a_t| ast_ty_to_ty(this, rscope, &**a_t))\n-                  .collect();\n-\n-    let mut substs = Substs::new_type(tps, regions);\n+    let mut substs = Substs::new_type(types, regions);\n \n     match self_ty {\n         None => {\n@@ -354,15 +355,56 @@ fn ast_path_substs<'tcx,AC,RS>(\n                                          param.def_id))\n     }\n \n-    substs\n+    return substs;\n+\n+    fn angle_bracketed_parameters<'tcx, AC, RS>(this: &AC,\n+                                                rscope: &RS,\n+                                                data: &ast::AngleBracketedParameterData)\n+                                                -> (Vec<ty::Region>, Vec<ty::t>)\n+        where AC: AstConv<'tcx>, RS: RegionScope\n+    {\n+        let regions: Vec<_> =\n+            data.lifetimes.iter()\n+            .map(|l| ast_region_to_region(this.tcx(), l))\n+            .collect();\n+\n+        let types: Vec<_> =\n+            data.types.iter()\n+            .map(|t| ast_ty_to_ty(this, rscope, &**t))\n+            .collect();\n+\n+        (regions, types)\n+    }\n+\n+    fn parenthesized_parameters<'tcx,AC>(this: &AC,\n+                                         binder_id: ast::NodeId,\n+                                         data: &ast::ParenthesizedParameterData)\n+                                         -> (Vec<ty::Region>, Vec<ty::t>)\n+        where AC: AstConv<'tcx>\n+    {\n+        let binding_rscope = BindingRscope::new(binder_id);\n+\n+        let inputs = data.inputs.iter()\n+                                .map(|a_t| ast_ty_to_ty(this, &binding_rscope, &**a_t))\n+                                .collect();\n+        let input_ty = ty::mk_tup_or_nil(this.tcx(), inputs);\n+\n+        let output = match data.output {\n+            Some(ref output_ty) => ast_ty_to_ty(this, &binding_rscope, &**output_ty),\n+            None => ty::mk_nil()\n+        };\n+\n+        (Vec::new(), vec![input_ty, output])\n+    }\n }\n \n pub fn ast_path_to_trait_ref<'tcx,AC,RS>(this: &AC,\n                                          rscope: &RS,\n                                          trait_def_id: ast::DefId,\n                                          self_ty: Option<ty::t>,\n                                          associated_type: Option<ty::t>,\n-                                         path: &ast::Path)\n+                                         path: &ast::Path,\n+                                         binder_id: ast::NodeId)\n                                          -> Rc<ty::TraitRef>\n                                          where AC: AstConv<'tcx>,\n                                                RS: RegionScope {\n@@ -375,16 +417,19 @@ pub fn ast_path_to_trait_ref<'tcx,AC,RS>(this: &AC,\n                                 &trait_def.generics,\n                                 self_ty,\n                                 associated_type,\n-                                path)\n+                                path,\n+                                binder_id)\n     })\n }\n \n pub fn ast_path_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n     this: &AC,\n     rscope: &RS,\n     did: ast::DefId,\n-    path: &ast::Path)\n-    -> TypeAndSubsts {\n+    path: &ast::Path,\n+    binder_id: ast::NodeId)\n+    -> TypeAndSubsts\n+{\n     let tcx = this.tcx();\n     let ty::Polytype {\n         generics,\n@@ -397,7 +442,8 @@ pub fn ast_path_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                  &generics,\n                                  None,\n                                  None,\n-                                 path);\n+                                 path,\n+                                 binder_id);\n     let ty = decl_ty.subst(tcx, &substs);\n     TypeAndSubsts { substs: substs, ty: ty }\n }\n@@ -407,24 +453,29 @@ pub fn ast_path_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n /// and/or region variables are substituted.\n ///\n /// This is used when checking the constructor in struct literals.\n-pub fn ast_path_to_ty_relaxed<'tcx, AC: AstConv<'tcx>,\n-                              RS:RegionScope>(\n-                              this: &AC,\n-                              rscope: &RS,\n-                              did: ast::DefId,\n-                              path: &ast::Path)\n-                              -> TypeAndSubsts {\n+pub fn ast_path_to_ty_relaxed<'tcx,AC,RS>(\n+    this: &AC,\n+    rscope: &RS,\n+    did: ast::DefId,\n+    path: &ast::Path,\n+    binder_id: ast::NodeId)\n+    -> TypeAndSubsts\n+    where AC : AstConv<'tcx>, RS : RegionScope\n+{\n     let tcx = this.tcx();\n     let ty::Polytype {\n         generics,\n         ty: decl_ty\n     } = this.get_item_ty(did);\n \n-    let substs = if (generics.has_type_params(TypeSpace) ||\n-        generics.has_region_params(TypeSpace)) &&\n-            path.segments.iter().all(|s| {\n-                s.lifetimes.len() == 0 && s.types.len() == 0\n-            }) {\n+    let wants_params =\n+        generics.has_type_params(TypeSpace) || generics.has_region_params(TypeSpace);\n+\n+    let needs_defaults =\n+        wants_params &&\n+        path.segments.iter().all(|s| s.parameters.is_empty());\n+\n+    let substs = if needs_defaults {\n         let type_params = Vec::from_fn(generics.types.len(TypeSpace),\n                                        |_| this.ty_infer(path.span));\n         let region_params =\n@@ -433,7 +484,7 @@ pub fn ast_path_to_ty_relaxed<'tcx, AC: AstConv<'tcx>,\n         Substs::new(VecPerParamSpace::params_from_type(type_params),\n                     VecPerParamSpace::params_from_type(region_params))\n     } else {\n-        ast_path_substs(this, rscope, did, &generics, None, None, path)\n+        ast_path_substs(this, rscope, did, &generics, None, None, path, binder_id)\n     };\n \n     let ty = decl_ty.subst(tcx, &substs);\n@@ -450,14 +501,14 @@ fn check_path_args(tcx: &ty::ctxt,\n                    path: &ast::Path,\n                    flags: uint) {\n     if (flags & NO_TPS) != 0u {\n-        if !path.segments.iter().all(|s| s.types.is_empty()) {\n+        if path.segments.iter().any(|s| s.parameters.has_types()) {\n             span_err!(tcx.sess, path.span, E0109,\n                 \"type parameters are not allowed on this type\");\n         }\n     }\n \n     if (flags & NO_REGIONS) != 0u {\n-        if !path.segments.last().unwrap().lifetimes.is_empty() {\n+        if path.segments.iter().any(|s| s.parameters.has_lifetimes()) {\n             span_err!(tcx.sess, path.span, E0110,\n                 \"region parameters are not allowed on this type\");\n         }\n@@ -538,29 +589,23 @@ pub fn ast_ty_to_builtin_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n             // FIXME(#12938): This is a hack until we have full support for\n             // DST.\n             match a_def {\n-                def::DefTy(did, _) | def::DefStruct(did)\n-                        if Some(did) == this.tcx().lang_items.owned_box() => {\n-                    if path.segments\n-                           .iter()\n-                           .flat_map(|s| s.types.iter())\n-                           .count() > 1 {\n-                        span_err!(this.tcx().sess, path.span, E0047,\n-                                  \"`Box` has only one type parameter\");\n-                    }\n-\n-                    for inner_ast_type in path.segments\n-                                              .iter()\n-                                              .flat_map(|s| s.types.iter()) {\n-                        return Some(mk_pointer(this,\n-                                               rscope,\n-                                               ast::MutImmutable,\n-                                               &**inner_ast_type,\n-                                               Uniq,\n-                                               |typ| ty::mk_uniq(this.tcx(), typ)));\n+                def::DefTy(did, _) |\n+                def::DefStruct(did) if Some(did) == this.tcx().lang_items.owned_box() => {\n+                    let ty = ast_path_to_ty(this, rscope, did, path, id).ty;\n+                    match ty::get(ty).sty {\n+                        ty::ty_struct(struct_def_id, ref substs) => {\n+                            assert_eq!(struct_def_id, did);\n+                            assert_eq!(substs.types.len(TypeSpace), 1);\n+                            let referent_ty = *substs.types.get(TypeSpace, 0);\n+                            Some(ty::mk_uniq(this.tcx(), referent_ty))\n+                        }\n+                        _ => {\n+                            this.tcx().sess.span_bug(\n+                                path.span,\n+                                format!(\"converting `Box` to `{}`\",\n+                                        ty.repr(this.tcx()))[]);\n+                        }\n                     }\n-                    span_err!(this.tcx().sess, path.span, E0113,\n-                              \"not enough type parameters supplied to `Box<T>`\");\n-                    Some(ty::mk_err())\n                 }\n                 _ => None\n             }\n@@ -575,15 +620,6 @@ enum PointerTy {\n     Uniq\n }\n \n-impl PointerTy {\n-    fn default_region(&self) -> ty::Region {\n-        match *self {\n-            Uniq => ty::ReStatic,\n-            RPtr(r) => r,\n-        }\n-    }\n-}\n-\n pub fn trait_ref_for_unboxed_function<'tcx, AC: AstConv<'tcx>,\n                                       RS:RegionScope>(\n                                       this: &AC,\n@@ -603,11 +639,7 @@ pub fn trait_ref_for_unboxed_function<'tcx, AC: AstConv<'tcx>,\n                           .map(|input| {\n                             ast_ty_to_ty(this, rscope, &*input.ty)\n                           }).collect::<Vec<_>>();\n-    let input_tuple = if input_types.len() == 0 {\n-        ty::mk_nil()\n-    } else {\n-        ty::mk_tup(this.tcx(), input_types)\n-    };\n+    let input_tuple = ty::mk_tup_or_nil(this.tcx(), input_types);\n     let output_type = ast_ty_to_ty(this, rscope, &*decl.output);\n     let mut substs = Substs::new_type(vec!(input_tuple, output_type),\n                                       Vec::new());\n@@ -646,31 +678,6 @@ fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n             let ty = ast_ty_to_ty(this, rscope, &**ty);\n             return constr(ty::mk_vec(tcx, ty, None));\n         }\n-        ast::TyUnboxedFn(ref unboxed_function) => {\n-            let ty::TraitRef {\n-                def_id,\n-                substs\n-            } = trait_ref_for_unboxed_function(this,\n-                                               rscope,\n-                                               unboxed_function.kind,\n-                                               &*unboxed_function.decl,\n-                                               None);\n-            let r = ptr_ty.default_region();\n-            let tr = ty::mk_trait(this.tcx(),\n-                                  def_id,\n-                                  substs,\n-                                  ty::region_existential_bound(r));\n-            match ptr_ty {\n-                Uniq => {\n-                    return ty::mk_uniq(this.tcx(), tr);\n-                }\n-                RPtr(r) => {\n-                    return ty::mk_rptr(this.tcx(),\n-                                       r,\n-                                       ty::mt {mutbl: a_seq_mutbl, ty: tr});\n-                }\n-            }\n-        }\n         ast::TyPath(ref path, ref opt_bounds, id) => {\n             // Note that the \"bounds must be empty if path is not a trait\"\n             // restriction is enforced in the below case for ty_path, which\n@@ -693,7 +700,8 @@ fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                                        trait_def_id,\n                                                        None,\n                                                        None,\n-                                                       path);\n+                                                       path,\n+                                                       id);\n                     let bounds = match *opt_bounds {\n                         None => {\n                             conv_existential_bounds(this,\n@@ -771,7 +779,12 @@ fn associated_ty_to_ty<'tcx,AC,RS>(this: &AC,\n                                           trait_did,\n                                           None,\n                                           Some(for_type),\n-                                          trait_path);\n+                                          trait_path,\n+                                          ast::DUMMY_NODE_ID); // *see below\n+\n+    // * The trait in a qualified path cannot be \"higher-ranked\" and\n+    // hence cannot use the parenthetical sugar, so the binder-id is\n+    // irrelevant.\n \n     debug!(\"associated_ty_to_ty(trait_ref={})\",\n            trait_ref.repr(this.tcx()));\n@@ -894,11 +907,6 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n \n                 ty::mk_closure(tcx, fn_decl)\n             }\n-            ast::TyUnboxedFn(..) => {\n-                tcx.sess.span_err(ast_ty.span,\n-                                  \"cannot use unboxed functions here\");\n-                ty::mk_err()\n-            }\n             ast::TyPath(ref path, ref bounds, id) => {\n                 let a_def = match tcx.def_map.borrow().get(&id) {\n                     None => {\n@@ -925,7 +933,8 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                                            trait_def_id,\n                                                            None,\n                                                            None,\n-                                                           path);\n+                                                           path,\n+                                                           id);\n                         let empty_bounds: &[ast::TyParamBound] = &[];\n                         let ast_bounds = match *bounds {\n                             Some(ref b) => b.as_slice(),\n@@ -942,7 +951,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                      bounds)\n                     }\n                     def::DefTy(did, _) | def::DefStruct(did) => {\n-                        ast_path_to_ty(this, rscope, did, path).ty\n+                        ast_path_to_ty(this, rscope, did, path, id).ty\n                     }\n                     def::DefTyParam(space, id, n) => {\n                         check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n@@ -1377,8 +1386,7 @@ pub fn conv_existential_bounds<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n \n     let PartitionedBounds { builtin_bounds,\n                             trait_bounds,\n-                            region_bounds,\n-                            unboxed_fn_ty_bounds } =\n+                            region_bounds } =\n         partition_bounds(this.tcx(), span, ast_bound_refs.as_slice());\n \n     if !trait_bounds.is_empty() {\n@@ -1389,13 +1397,6 @@ pub fn conv_existential_bounds<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n                      as closure or object bounds\").as_slice());\n     }\n \n-    if !unboxed_fn_ty_bounds.is_empty() {\n-        this.tcx().sess.span_err(\n-            span,\n-            format!(\"only the builtin traits can be used \\\n-                     as closure or object bounds\").as_slice());\n-    }\n-\n     // The \"main trait refs\", rather annoyingly, have no type\n     // specified for the `Self` parameter of the trait. The reason for\n     // this is that they are, after all, *existential* types, and\n@@ -1524,7 +1525,6 @@ fn compute_region_bound<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n pub struct PartitionedBounds<'a> {\n     pub builtin_bounds: ty::BuiltinBounds,\n     pub trait_bounds: Vec<&'a ast::TraitRef>,\n-    pub unboxed_fn_ty_bounds: Vec<&'a ast::UnboxedFnBound>,\n     pub region_bounds: Vec<&'a ast::Lifetime>,\n }\n \n@@ -1542,7 +1542,6 @@ pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n     let mut builtin_bounds = ty::empty_builtin_bounds();\n     let mut region_bounds = Vec::new();\n     let mut trait_bounds = Vec::new();\n-    let mut unboxed_fn_ty_bounds = Vec::new();\n     let mut trait_def_ids = HashMap::new();\n     for &ast_bound in ast_bounds.iter() {\n         match *ast_bound {\n@@ -1587,17 +1586,13 @@ pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n             ast::RegionTyParamBound(ref l) => {\n                 region_bounds.push(l);\n             }\n-            ast::UnboxedFnTyParamBound(ref unboxed_function) => {\n-                unboxed_fn_ty_bounds.push(&**unboxed_function);\n-            }\n         }\n     }\n \n     PartitionedBounds {\n         builtin_bounds: builtin_bounds,\n         trait_bounds: trait_bounds,\n         region_bounds: region_bounds,\n-        unboxed_fn_ty_bounds: unboxed_fn_ty_bounds\n     }\n }\n "}, {"sha": "ccd6a8103b9b46aa5210d7499b320e8b67577f57", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 78, "deletions": 12, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -3481,11 +3481,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n         // Tuple up the arguments and insert the resulting function type into\n         // the `unboxed_closures` table.\n-        fn_ty.sig.inputs = if fn_ty.sig.inputs.len() == 0 {\n-            vec![ty::mk_nil()]\n-        } else {\n-            vec![ty::mk_tup(fcx.tcx(), fn_ty.sig.inputs)]\n-        };\n+        fn_ty.sig.inputs = vec![ty::mk_tup_or_nil(fcx.tcx(), fn_ty.sig.inputs)];\n \n         let kind = match kind {\n             ast::FnUnboxedClosureKind => ty::FnUnboxedClosureKind,\n@@ -4478,7 +4474,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             let type_and_substs = astconv::ast_path_to_ty_relaxed(fcx,\n                                                                   fcx.infcx(),\n                                                                   struct_id,\n-                                                                  path);\n+                                                                  path,\n+                                                                  expr.id);\n             match fcx.mk_subty(false,\n                                infer::Misc(path.span),\n                                actual_structure_type,\n@@ -5339,6 +5336,7 @@ pub fn instantiate_path(fcx: &FnCtxt,\n             Some(space) => {\n                 push_explicit_parameters_from_segment_to_substs(fcx,\n                                                                 space,\n+                                                                path.span,\n                                                                 type_defs,\n                                                                 region_defs,\n                                                                 segment,\n@@ -5374,13 +5372,13 @@ pub fn instantiate_path(fcx: &FnCtxt,\n         fcx: &FnCtxt,\n         segment: &ast::PathSegment)\n     {\n-        for typ in segment.types.iter() {\n+        for typ in segment.parameters.types().iter() {\n             span_err!(fcx.tcx().sess, typ.span, E0085,\n                 \"type parameters may not appear here\");\n             break;\n         }\n \n-        for lifetime in segment.lifetimes.iter() {\n+        for lifetime in segment.parameters.lifetimes().iter() {\n             span_err!(fcx.tcx().sess, lifetime.span, E0086,\n                 \"lifetime parameters may not appear here\");\n             break;\n@@ -5390,6 +5388,7 @@ pub fn instantiate_path(fcx: &FnCtxt,\n     fn push_explicit_parameters_from_segment_to_substs(\n         fcx: &FnCtxt,\n         space: subst::ParamSpace,\n+        span: Span,\n         type_defs: &VecPerParamSpace<ty::TypeParameterDef>,\n         region_defs: &VecPerParamSpace<ty::RegionParameterDef>,\n         segment: &ast::PathSegment,\n@@ -5412,10 +5411,31 @@ pub fn instantiate_path(fcx: &FnCtxt,\n          * span of the N+1'th parameter.\n          */\n \n+        match segment.parameters {\n+            ast::AngleBracketedParameters(ref data) => {\n+                push_explicit_angle_bracketed_parameters_from_segment_to_substs(\n+                    fcx, space, type_defs, region_defs, data, substs);\n+            }\n+\n+            ast::ParenthesizedParameters(ref data) => {\n+                push_explicit_parenthesized_parameters_from_segment_to_substs(\n+                    fcx, space, span, type_defs, data, substs);\n+            }\n+        }\n+    }\n+\n+    fn push_explicit_angle_bracketed_parameters_from_segment_to_substs(\n+        fcx: &FnCtxt,\n+        space: subst::ParamSpace,\n+        type_defs: &VecPerParamSpace<ty::TypeParameterDef>,\n+        region_defs: &VecPerParamSpace<ty::RegionParameterDef>,\n+        data: &ast::AngleBracketedParameterData,\n+        substs: &mut Substs)\n+    {\n         {\n             let type_count = type_defs.len(space);\n             assert_eq!(substs.types.len(space), 0);\n-            for (i, typ) in segment.types.iter().enumerate() {\n+            for (i, typ) in data.types.iter().enumerate() {\n                 let t = fcx.to_ty(&**typ);\n                 if i < type_count {\n                     substs.types.push(space, t);\n@@ -5424,7 +5444,7 @@ pub fn instantiate_path(fcx: &FnCtxt,\n                         \"too many type parameters provided: \\\n                          expected at most {} parameter(s), \\\n                          found {} parameter(s)\",\n-                         type_count, segment.types.len());\n+                         type_count, data.types.len());\n                     substs.types.truncate(space, 0);\n                 }\n             }\n@@ -5433,7 +5453,7 @@ pub fn instantiate_path(fcx: &FnCtxt,\n         {\n             let region_count = region_defs.len(space);\n             assert_eq!(substs.regions().len(space), 0);\n-            for (i, lifetime) in segment.lifetimes.iter().enumerate() {\n+            for (i, lifetime) in data.lifetimes.iter().enumerate() {\n                 let r = ast_region_to_region(fcx.tcx(), lifetime);\n                 if i < region_count {\n                     substs.mut_regions().push(space, r);\n@@ -5442,13 +5462,59 @@ pub fn instantiate_path(fcx: &FnCtxt,\n                         \"too many lifetime parameters provided: \\\n                          expected {} parameter(s), found {} parameter(s)\",\n                         region_count,\n-                        segment.lifetimes.len());\n+                        data.lifetimes.len());\n                     substs.mut_regions().truncate(space, 0);\n                 }\n             }\n         }\n     }\n \n+    fn push_explicit_parenthesized_parameters_from_segment_to_substs(\n+        fcx: &FnCtxt,\n+        space: subst::ParamSpace,\n+        span: Span,\n+        type_defs: &VecPerParamSpace<ty::TypeParameterDef>,\n+        data: &ast::ParenthesizedParameterData,\n+        substs: &mut Substs)\n+    {\n+        /*!\n+         * As with\n+         * `push_explicit_angle_bracketed_parameters_from_segment_to_substs`,\n+         * but intended for `Foo(A,B) -> C` form. This expands to\n+         * roughly the same thing as `Foo<(A,B),C>`. One important\n+         * difference has to do with the treatment of anonymous\n+         * regions, which are translated into bound regions (NYI).\n+         */\n+\n+        let type_count = type_defs.len(space);\n+        if type_count < 2 {\n+            span_err!(fcx.tcx().sess, span, E0167,\n+                      \"parenthesized form always supplies 2 type parameters, \\\n+                      but only {} parameter(s) were expected\",\n+                      type_count);\n+        }\n+\n+        let input_tys: Vec<ty::t> =\n+            data.inputs.iter().map(|ty| fcx.to_ty(&**ty)).collect();\n+\n+        let tuple_ty =\n+            ty::mk_tup_or_nil(fcx.tcx(), input_tys);\n+\n+        if type_count >= 1 {\n+            substs.types.push(space, tuple_ty);\n+        }\n+\n+        let output_ty: Option<ty::t> =\n+            data.output.as_ref().map(|ty| fcx.to_ty(&**ty));\n+\n+        let output_ty =\n+            output_ty.unwrap_or(ty::mk_nil());\n+\n+        if type_count >= 2 {\n+            substs.types.push(space, output_ty);\n+        }\n+    }\n+\n     fn adjust_type_parameters(\n         fcx: &FnCtxt,\n         span: Span,"}, {"sha": "ae2073f6316ea969d5275290f076ad39b81b724b", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 56, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -638,7 +638,7 @@ pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n         let mut bounds = bounds.chain(ty_param.unbound.iter());\n         for bound in bounds {\n             match *bound {\n-                ast::TraitTyParamBound(..) | ast::UnboxedFnTyParamBound(..) => {\n+                ast::TraitTyParamBound(..) => {\n                     // According to accepted RFC #XXX, we should\n                     // eventually accept these, but it will not be\n                     // part of this PR. Still, convert to warning to\n@@ -1340,7 +1340,8 @@ pub fn instantiate_trait_ref<'tcx,AC>(this: &AC,\n                                                trait_did,\n                                                Some(self_ty),\n                                                associated_type,\n-                                               &ast_trait_ref.path);\n+                                               &ast_trait_ref.path,\n+                                               ast_trait_ref.ref_id);\n \n             this.tcx().trait_refs.borrow_mut().insert(ast_trait_ref.ref_id,\n                                                       trait_ref.clone());\n@@ -1355,20 +1356,6 @@ pub fn instantiate_trait_ref<'tcx,AC>(this: &AC,\n     }\n }\n \n-pub fn instantiate_unboxed_fn_ty<'tcx,AC>(this: &AC,\n-                                          unboxed_function: &ast::UnboxedFnTy,\n-                                          param_ty: ty::ParamTy)\n-                                          -> Rc<ty::TraitRef>\n-                                          where AC: AstConv<'tcx> {\n-    let rscope = ExplicitRscope;\n-    let param_ty = param_ty.to_ty(this.tcx());\n-    Rc::new(astconv::trait_ref_for_unboxed_function(this,\n-                                                    &rscope,\n-                                                    unboxed_function.kind,\n-                                                    &*unboxed_function.decl,\n-                                                    Some(param_ty)))\n-}\n-\n fn get_trait_def(ccx: &CrateCtxt, trait_id: ast::DefId) -> Rc<ty::TraitDef> {\n     if trait_id.krate != ast::LOCAL_CRATE {\n         return ty::lookup_trait_def(ccx.tcx, trait_id)\n@@ -1878,7 +1865,6 @@ fn ty_generics<'tcx,AC>(this: &AC,\n                 // In the above example, `ast_trait_ref` is `Iterator`.\n                 let ast_trait_ref = match *bound {\n                     ast::TraitTyParamBound(ref r) => r,\n-                    ast::UnboxedFnTyParamBound(..) => { continue; }\n                     ast::RegionTyParamBound(..) => { continue; }\n                 };\n \n@@ -2056,45 +2042,8 @@ fn conv_param_bounds<'tcx,AC>(this: &AC,\n         merge_param_bounds(this.tcx(), param_ty, ast_bounds, where_clause);\n     let astconv::PartitionedBounds { builtin_bounds,\n                                      trait_bounds,\n-                                     region_bounds,\n-                                     unboxed_fn_ty_bounds } =\n+                                     region_bounds } =\n         astconv::partition_bounds(this.tcx(), span, all_bounds.as_slice());\n-\n-    let unboxed_fn_ty_bounds = unboxed_fn_ty_bounds.into_iter().map(|b| {\n-        let trait_id = (*this.tcx().def_map.borrow())[b.ref_id].def_id();\n-        let mut kind = None;\n-        for &(lang_item, this_kind) in [\n-            (this.tcx().lang_items.fn_trait(), ast::FnUnboxedClosureKind),\n-            (this.tcx().lang_items.fn_mut_trait(),\n-             ast::FnMutUnboxedClosureKind),\n-            (this.tcx().lang_items.fn_once_trait(),\n-             ast::FnOnceUnboxedClosureKind)\n-        ].iter() {\n-            if Some(trait_id) == lang_item {\n-                kind = Some(this_kind);\n-                break\n-            }\n-        }\n-\n-        let kind = match kind {\n-            Some(kind) => kind,\n-            None => {\n-                this.tcx().sess.span_err(b.path.span,\n-                                         \"unboxed function trait must be one \\\n-                                          of `Fn`, `FnMut`, or `FnOnce`\");\n-                ast::FnMutUnboxedClosureKind\n-            }\n-        };\n-\n-        let rscope = ExplicitRscope;\n-        let param_ty = param_ty.to_ty(this.tcx());\n-        Rc::new(astconv::trait_ref_for_unboxed_function(this,\n-                                                        &rscope,\n-                                                        kind,\n-                                                        &*b.decl,\n-                                                        Some(param_ty)))\n-    });\n-\n     let trait_bounds: Vec<Rc<ty::TraitRef>> =\n         trait_bounds.into_iter()\n         .map(|b| {\n@@ -2103,7 +2052,6 @@ fn conv_param_bounds<'tcx,AC>(this: &AC,\n                                   param_ty.to_ty(this.tcx()),\n                                   Some(param_ty.to_ty(this.tcx())))\n         })\n-        .chain(unboxed_fn_ty_bounds)\n         .collect();\n     let region_bounds: Vec<ty::Region> =\n         region_bounds.into_iter()"}, {"sha": "4ca62253467917ec5dbed668492b926f691e37be", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 42, "deletions": 32, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -1102,21 +1102,19 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                     // be passing down a map.\n                     ast::RegionTyParamBound(lt)\n                 }\n-                &ast::UnboxedFnTyParamBound(ref unboxed_function_type) => {\n-                    ast::UnboxedFnTyParamBound((*unboxed_function_type).clone())\n-                }\n                 &ast::TraitTyParamBound(ref tr) => {\n                     let last_seg = tr.path.segments.last().unwrap();\n                     let mut insert = Vec::new();\n-                    for (i, lt) in last_seg.lifetimes.iter().enumerate() {\n+                    let lifetimes = last_seg.parameters.lifetimes();\n+                    for (i, lt) in lifetimes.iter().enumerate() {\n                         if region_names.contains(&lt.name) {\n                             insert.push(i);\n                         }\n                     }\n                     let rebuild_info = RebuildPathInfo {\n                         path: &tr.path,\n                         indexes: insert,\n-                        expected: last_seg.lifetimes.len(),\n+                        expected: lifetimes.len(),\n                         anon_nums: &HashSet::new(),\n                         region_names: region_names\n                     };\n@@ -1257,7 +1255,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                             let expected =\n                                 generics.regions.len(subst::TypeSpace);\n                             let lifetimes =\n-                                &path.segments.last().unwrap().lifetimes;\n+                                path.segments.last().unwrap().parameters.lifetimes();\n                             let mut insert = Vec::new();\n                             if lifetimes.len() == 0 {\n                                 let anon = self.cur_anon.get();\n@@ -1357,7 +1355,8 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n     fn rebuild_path(&self,\n                     rebuild_info: RebuildPathInfo,\n                     lifetime: ast::Lifetime)\n-                    -> ast::Path {\n+                    -> ast::Path\n+    {\n         let RebuildPathInfo {\n             path,\n             indexes,\n@@ -1367,37 +1366,48 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n         } = rebuild_info;\n \n         let last_seg = path.segments.last().unwrap();\n-        let mut new_lts = Vec::new();\n-        if last_seg.lifetimes.len() == 0 {\n-            // traverse once to see if there's a need to insert lifetime\n-            let need_insert = range(0, expected).any(|i| {\n-                indexes.contains(&i)\n-            });\n-            if need_insert {\n-                for i in range(0, expected) {\n-                    if indexes.contains(&i) {\n-                        new_lts.push(lifetime);\n-                    } else {\n-                        new_lts.push(self.life_giver.give_lifetime());\n+        let new_parameters = match last_seg.parameters {\n+            ast::ParenthesizedParameters(..) => {\n+                last_seg.parameters.clone()\n+            }\n+\n+            ast::AngleBracketedParameters(ref data) => {\n+                let mut new_lts = Vec::new();\n+                if data.lifetimes.len() == 0 {\n+                    // traverse once to see if there's a need to insert lifetime\n+                    let need_insert = range(0, expected).any(|i| {\n+                        indexes.contains(&i)\n+                    });\n+                    if need_insert {\n+                        for i in range(0, expected) {\n+                            if indexes.contains(&i) {\n+                                new_lts.push(lifetime);\n+                            } else {\n+                                new_lts.push(self.life_giver.give_lifetime());\n+                            }\n+                        }\n                     }\n-                }\n-            }\n-        } else {\n-            for (i, lt) in last_seg.lifetimes.iter().enumerate() {\n-                if indexes.contains(&i) {\n-                    new_lts.push(lifetime);\n                 } else {\n-                    new_lts.push(*lt);\n+                    for (i, lt) in data.lifetimes.iter().enumerate() {\n+                        if indexes.contains(&i) {\n+                            new_lts.push(lifetime);\n+                        } else {\n+                            new_lts.push(*lt);\n+                        }\n+                    }\n                 }\n+                let new_types = data.types.map(|t| {\n+                    self.rebuild_arg_ty_or_output(&**t, lifetime, anon_nums, region_names)\n+                });\n+                ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n+                    lifetimes: new_lts,\n+                    types: new_types\n+                })\n             }\n-        }\n-        let new_types = last_seg.types.map(|t| {\n-            self.rebuild_arg_ty_or_output(&**t, lifetime, anon_nums, region_names)\n-        });\n+        };\n         let new_seg = ast::PathSegment {\n             identifier: last_seg.identifier,\n-            lifetimes: new_lts,\n-            types: new_types,\n+            parameters: new_parameters\n         };\n         let mut new_segs = Vec::new();\n         new_segs.push_all(path.segments.init());"}, {"sha": "bcbd09d7b119e190fe3200ff7d836d1067ab0a50", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -323,7 +323,6 @@ fn build_impl(cx: &DocContext, tcx: &ty::ctxt,\n             trait_: associated_trait.clean(cx).map(|bound| {\n                 match bound {\n                     clean::TraitBound(ty) => ty,\n-                    clean::UnboxedFnBound(..) |\n                     clean::RegionBound(..) => unreachable!(),\n                 }\n             }),"}, {"sha": "4478c29f66a48f2668eaf072ab7c9cb44647352b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -476,15 +476,13 @@ impl Clean<TyParam> for ty::TypeParameterDef {\n #[deriving(Clone, Encodable, Decodable, PartialEq)]\n pub enum TyParamBound {\n     RegionBound(Lifetime),\n-    UnboxedFnBound(UnboxedFnType),\n     TraitBound(Type)\n }\n \n impl Clean<TyParamBound> for ast::TyParamBound {\n     fn clean(&self, cx: &DocContext) -> TyParamBound {\n         match *self {\n             ast::RegionTyParamBound(lt) => RegionBound(lt.clean(cx)),\n-            ast::UnboxedFnTyParamBound(ref ty) => { UnboxedFnBound(ty.clean(cx)) },\n             ast::TraitTyParamBound(ref t) => TraitBound(t.clean(cx)),\n         }\n     }\n@@ -599,21 +597,6 @@ impl Clean<Option<Vec<TyParamBound>>> for subst::Substs {\n     }\n }\n \n-#[deriving(Clone, Encodable, Decodable, PartialEq)]\n-pub struct UnboxedFnType {\n-    pub path: Path,\n-    pub decl: FnDecl\n-}\n-\n-impl Clean<UnboxedFnType> for ast::UnboxedFnBound {\n-    fn clean(&self, cx: &DocContext) -> UnboxedFnType {\n-        UnboxedFnType {\n-            path: self.path.clean(cx),\n-            decl: self.decl.clean(cx)\n-        }\n-    }\n-}\n-\n #[deriving(Clone, Encodable, Decodable, PartialEq)]\n pub struct Lifetime(String);\n \n@@ -1641,10 +1624,23 @@ pub struct PathSegment {\n \n impl Clean<PathSegment> for ast::PathSegment {\n     fn clean(&self, cx: &DocContext) -> PathSegment {\n+        let (lifetimes, types) = match self.parameters {\n+            ast::AngleBracketedParameters(ref data) => {\n+                (data.lifetimes.clean(cx), data.types.clean(cx))\n+            }\n+\n+            ast::ParenthesizedParameters(ref data) => {\n+                // FIXME -- rustdoc should be taught about Foo() notation\n+                let inputs = Tuple(data.inputs.clean(cx));\n+                let output = data.output.as_ref().map(|t| t.clean(cx)).unwrap_or(Tuple(Vec::new()));\n+                (Vec::new(), vec![inputs, output])\n+            }\n+        };\n+\n         PathSegment {\n             name: self.identifier.clean(cx),\n-            lifetimes: self.lifetimes.clean(cx),\n-            types: self.types.clean(cx),\n+            lifetimes: lifetimes,\n+            types: types,\n         }\n     }\n }"}, {"sha": "fe96c9b3a9f6a07b090d20a97d20fd0851c9d60b", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -143,9 +143,6 @@ impl fmt::Show for clean::TyParamBound {\n             clean::RegionBound(ref lt) => {\n                 write!(f, \"{}\", *lt)\n             }\n-            clean::UnboxedFnBound(ref ty) => {\n-                write!(f, \"{}{}\", ty.path, ty.decl)\n-            }\n             clean::TraitBound(ref ty) => {\n                 write!(f, \"{}\", *ty)\n             }\n@@ -404,8 +401,7 @@ impl fmt::Show for clean::Type {\n                            let mut ret = String::new();\n                            for bound in decl.bounds.iter() {\n                                 match *bound {\n-                                    clean::RegionBound(..) |\n-                                    clean::UnboxedFnBound(..) => {}\n+                                    clean::RegionBound(..) => {}\n                                     clean::TraitBound(ref t) => {\n                                         if ret.len() == 0 {\n                                             ret.push_str(\": \");"}, {"sha": "6a354fa20e1b40bbb88b48d0ea5ee6cac1f11fcb", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 96, "deletions": 17, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -171,7 +171,7 @@ pub struct Path {\n     /// module (like paths in an import).\n     pub global: bool,\n     /// The segments in the path: the things separated by `::`.\n-    pub segments: Vec<PathSegment> ,\n+    pub segments: Vec<PathSegment>,\n }\n \n /// A segment of a path: an identifier, an optional lifetime, and a set of\n@@ -180,12 +180,107 @@ pub struct Path {\n pub struct PathSegment {\n     /// The identifier portion of this path segment.\n     pub identifier: Ident,\n+\n+    /// Type/lifetime parameters attached to this path. They come in\n+    /// two flavors: `Path<A,B,C>` and `Path(A,B) -> C`. Note that\n+    /// this is more than just simple syntactic sugar; the use of\n+    /// parens affects the region binding rules, so we preserve the\n+    /// distinction.\n+    pub parameters: PathParameters,\n+}\n+\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+pub enum PathParameters {\n+    AngleBracketedParameters(AngleBracketedParameterData),\n+    ParenthesizedParameters(ParenthesizedParameterData),\n+}\n+\n+impl PathParameters {\n+    pub fn none() -> PathParameters {\n+        AngleBracketedParameters(AngleBracketedParameterData {\n+            lifetimes: Vec::new(),\n+            types: OwnedSlice::empty(),\n+        })\n+    }\n+\n+    pub fn is_empty(&self) -> bool {\n+        match *self {\n+            AngleBracketedParameters(ref data) => data.is_empty(),\n+\n+            // Even if the user supplied no types, something like\n+            // `X()` is equivalent to `X<(),()>`.\n+            ParenthesizedParameters(..) => false,\n+        }\n+    }\n+\n+    pub fn has_lifetimes(&self) -> bool {\n+        match *self {\n+            AngleBracketedParameters(ref data) => !data.lifetimes.is_empty(),\n+            ParenthesizedParameters(_) => false,\n+        }\n+    }\n+\n+    pub fn has_types(&self) -> bool {\n+        match *self {\n+            AngleBracketedParameters(ref data) => !data.types.is_empty(),\n+            ParenthesizedParameters(..) => true,\n+        }\n+    }\n+\n+    pub fn types(&self) -> Vec<&P<Ty>> {\n+        /*!\n+         * Returns the types that the user wrote. Note that these do not\n+         * necessarily map to the type parameters in the parenthesized case.\n+         */\n+        match *self {\n+            AngleBracketedParameters(ref data) => {\n+                data.types.iter().collect()\n+            }\n+            ParenthesizedParameters(ref data) => {\n+                data.inputs.iter()\n+                    .chain(data.output.iter())\n+                    .collect()\n+            }\n+        }\n+    }\n+\n+    pub fn lifetimes(&self) -> Vec<&Lifetime> {\n+        match *self {\n+            AngleBracketedParameters(ref data) => {\n+                data.lifetimes.iter().collect()\n+            }\n+            ParenthesizedParameters(_) => {\n+                Vec::new()\n+            }\n+        }\n+    }\n+}\n+\n+/// A path like `Foo<'a, T>`\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+pub struct AngleBracketedParameterData {\n     /// The lifetime parameters for this path segment.\n     pub lifetimes: Vec<Lifetime>,\n     /// The type parameters for this path segment, if present.\n     pub types: OwnedSlice<P<Ty>>,\n }\n \n+impl AngleBracketedParameterData {\n+    fn is_empty(&self) -> bool {\n+        self.lifetimes.is_empty() && self.types.is_empty()\n+    }\n+}\n+\n+/// A path like `Foo(A,B) -> C`\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+pub struct ParenthesizedParameterData {\n+    /// `(A,B)`\n+    pub inputs: Vec<P<Ty>>,\n+\n+    /// `C`\n+    pub output: Option<P<Ty>>,\n+}\n+\n pub type CrateNum = u32;\n \n pub type NodeId = u32;\n@@ -213,20 +308,11 @@ pub const DUMMY_NODE_ID: NodeId = -1;\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum TyParamBound {\n     TraitTyParamBound(TraitRef),\n-    UnboxedFnTyParamBound(P<UnboxedFnBound>),\n     RegionTyParamBound(Lifetime)\n }\n \n pub type TyParamBounds = OwnedSlice<TyParamBound>;\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n-pub struct UnboxedFnBound {\n-    pub path: Path,\n-    pub decl: P<FnDecl>,\n-    pub lifetimes: Vec<LifetimeDef>,\n-    pub ref_id: NodeId,\n-}\n-\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct TyParam {\n     pub ident: Ident,\n@@ -994,12 +1080,6 @@ pub struct BareFnTy {\n     pub decl: P<FnDecl>\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n-pub struct UnboxedFnTy {\n-    pub kind: UnboxedClosureKind,\n-    pub decl: P<FnDecl>,\n-}\n-\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Ty_ {\n     TyNil,\n@@ -1012,7 +1092,6 @@ pub enum Ty_ {\n     TyClosure(P<ClosureTy>),\n     TyProc(P<ClosureTy>),\n     TyBareFn(P<BareFnTy>),\n-    TyUnboxedFn(P<UnboxedFnTy>),\n     TyTup(Vec<P<Ty>> ),\n     TyPath(Path, Option<TyParamBounds>, NodeId), // for #7264; see above\n     /// A \"qualified path\", e.g. `<Vec<T> as SomeTrait>::SomeType`"}, {"sha": "3adb062864e1e128ffe207dac5be3702ba254c72", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -848,9 +848,6 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n             TyBareFn(ref fd) => {\n                 self.visit_fn_decl(&*fd.decl);\n             }\n-            TyUnboxedFn(ref fd) => {\n-                self.visit_fn_decl(&*fd.decl);\n-            }\n             _ => {}\n         }\n         visit::walk_ty(self, ty);"}, {"sha": "2e3a15bfd4b4b1826a8cdb654718d04faf380779", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -171,8 +171,10 @@ pub fn ident_to_path(s: Span, identifier: Ident) -> Path {\n         segments: vec!(\n             ast::PathSegment {\n                 identifier: identifier,\n-                lifetimes: Vec::new(),\n-                types: OwnedSlice::empty(),\n+                parameters: ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n+                    lifetimes: Vec::new(),\n+                    types: OwnedSlice::empty(),\n+                })\n             }\n         ),\n     }\n@@ -681,11 +683,11 @@ pub fn segments_name_eq(a : &[ast::PathSegment], b : &[ast::PathSegment]) -> boo\n         false\n     } else {\n         for (idx,seg) in a.iter().enumerate() {\n-            if (seg.identifier.name != b[idx].identifier.name)\n+            if seg.identifier.name != b[idx].identifier.name\n                 // FIXME #7743: ident -> name problems in lifetime comparison?\n-                || (seg.lifetimes != b[idx].lifetimes)\n                 // can types contain idents?\n-                || (seg.types != b[idx].types) {\n+                || seg.parameters != b[idx].parameters\n+            {\n                 return false;\n             }\n         }\n@@ -747,12 +749,10 @@ impl PostExpansionMethod for Method {\n mod test {\n     use ast::*;\n     use super::*;\n-    use owned_slice::OwnedSlice;\n \n     fn ident_to_segment(id : &Ident) -> PathSegment {\n-        PathSegment {identifier:id.clone(),\n-                     lifetimes: Vec::new(),\n-                     types: OwnedSlice::empty()}\n+        PathSegment {identifier: id.clone(),\n+                     parameters: PathParameters::none()}\n     }\n \n     #[test] fn idents_name_eq_test() {"}, {"sha": "5921d630b8979c6a44e9f850c6b1bbb2878aa3ce", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -313,14 +313,15 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                                                       .map(|ident| {\n             ast::PathSegment {\n                 identifier: ident,\n-                lifetimes: Vec::new(),\n-                types: OwnedSlice::empty(),\n+                parameters: ast::PathParameters::none(),\n             }\n         }).collect();\n         segments.push(ast::PathSegment {\n             identifier: last_identifier,\n-            lifetimes: lifetimes,\n-            types: OwnedSlice::from_vec(types),\n+            parameters: ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n+                lifetimes: lifetimes,\n+                types: OwnedSlice::from_vec(types),\n+            })\n         });\n         ast::Path {\n             span: sp,"}, {"sha": "aa18b1be31acc46e9b6615e509e43704efbaa9fd", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -12,7 +12,6 @@ use ast;\n use codemap::Span;\n use ext::base::*;\n use ext::base;\n-use owned_slice::OwnedSlice;\n use parse::token;\n use parse::token::{str_to_ident};\n use ptr::P;\n@@ -52,8 +51,7 @@ pub fn expand_syntax_ext<'cx>(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]\n                  segments: vec!(\n                     ast::PathSegment {\n                         identifier: res,\n-                        lifetimes: Vec::new(),\n-                        types: OwnedSlice::empty(),\n+                        parameters: ast::PathParameters::none(),\n                     }\n                 )\n             }"}, {"sha": "80b158a54d36cf90dd8d20fc473044134e3c89fd", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -313,11 +313,6 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n                                    experimental and likely to be removed\");\n \n             },\n-            ast::TyUnboxedFn(..) => {\n-                self.gate_feature(\"unboxed_closure_sugar\",\n-                                  t.span,\n-                                  \"unboxed closure trait sugar is experimental\");\n-            }\n             _ => {}\n         }\n "}, {"sha": "cd4a3d10c48825749105d304305b494adcbc94d5", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 47, "deletions": 26, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -166,6 +166,22 @@ pub trait Folder {\n         noop_fold_path(p, self)\n     }\n \n+    fn fold_path_parameters(&mut self, p: PathParameters) -> PathParameters {\n+        noop_fold_path_parameters(p, self)\n+    }\n+\n+    fn fold_angle_bracketed_parameter_data(&mut self, p: AngleBracketedParameterData)\n+                                           -> AngleBracketedParameterData\n+    {\n+        noop_fold_angle_bracketed_parameter_data(p, self)\n+    }\n+\n+    fn fold_parenthesized_parameter_data(&mut self, p: ParenthesizedParameterData)\n+                                         -> ParenthesizedParameterData\n+    {\n+        noop_fold_parenthesized_parameter_data(p, self)\n+    }\n+\n     fn fold_local(&mut self, l: P<Local>) -> P<Local> {\n         noop_fold_local(l, self)\n     }\n@@ -408,12 +424,6 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n                     decl: fld.fold_fn_decl(decl)\n                 }))\n             }\n-            TyUnboxedFn(f) => {\n-                TyUnboxedFn(f.map(|UnboxedFnTy {decl, kind}| UnboxedFnTy {\n-                    decl: fld.fold_fn_decl(decl),\n-                    kind: kind,\n-                }))\n-            }\n             TyTup(tys) => TyTup(tys.move_map(|ty| fld.fold_ty(ty))),\n             TyParen(ty) => TyParen(fld.fold_ty(ty)),\n             TyPath(path, bounds, id) => {\n@@ -480,15 +490,43 @@ pub fn noop_fold_uint<T: Folder>(i: uint, _: &mut T) -> uint {\n pub fn noop_fold_path<T: Folder>(Path {global, segments, span}: Path, fld: &mut T) -> Path {\n     Path {\n         global: global,\n-        segments: segments.move_map(|PathSegment {identifier, lifetimes, types}| PathSegment {\n+        segments: segments.move_map(|PathSegment {identifier, parameters}| PathSegment {\n             identifier: fld.fold_ident(identifier),\n-            lifetimes: fld.fold_lifetimes(lifetimes),\n-            types: types.move_map(|typ| fld.fold_ty(typ)),\n+            parameters: fld.fold_path_parameters(parameters),\n         }),\n         span: fld.new_span(span)\n     }\n }\n \n+pub fn noop_fold_path_parameters<T: Folder>(path_parameters: PathParameters, fld: &mut T)\n+                                            -> PathParameters\n+{\n+    match path_parameters {\n+        AngleBracketedParameters(data) =>\n+            AngleBracketedParameters(fld.fold_angle_bracketed_parameter_data(data)),\n+        ParenthesizedParameters(data) =>\n+            ParenthesizedParameters(fld.fold_parenthesized_parameter_data(data)),\n+    }\n+}\n+\n+pub fn noop_fold_angle_bracketed_parameter_data<T: Folder>(data: AngleBracketedParameterData,\n+                                                           fld: &mut T)\n+                                                           -> AngleBracketedParameterData\n+{\n+    let AngleBracketedParameterData { lifetimes, types } = data;\n+    AngleBracketedParameterData { lifetimes: fld.fold_lifetimes(lifetimes),\n+                                  types: types.move_map(|ty| fld.fold_ty(ty)) }\n+}\n+\n+pub fn noop_fold_parenthesized_parameter_data<T: Folder>(data: ParenthesizedParameterData,\n+                                                         fld: &mut T)\n+                                                         -> ParenthesizedParameterData\n+{\n+    let ParenthesizedParameterData { inputs, output } = data;\n+    ParenthesizedParameterData { inputs: inputs.move_map(|ty| fld.fold_ty(ty)),\n+                                 output: output.map(|ty| fld.fold_ty(ty)) }\n+}\n+\n pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> {\n     l.map(|Local {id, pat, ty, init, source, span}| Local {\n         id: fld.new_id(id),\n@@ -671,23 +709,6 @@ pub fn noop_fold_ty_param_bound<T>(tpb: TyParamBound, fld: &mut T)\n     match tpb {\n         TraitTyParamBound(ty) => TraitTyParamBound(fld.fold_trait_ref(ty)),\n         RegionTyParamBound(lifetime) => RegionTyParamBound(fld.fold_lifetime(lifetime)),\n-        UnboxedFnTyParamBound(bound) => {\n-            match *bound {\n-                UnboxedFnBound {\n-                    ref path,\n-                    ref decl,\n-                    ref lifetimes,\n-                    ref_id\n-                } => {\n-                    UnboxedFnTyParamBound(P(UnboxedFnBound {\n-                        path: fld.fold_path(path.clone()),\n-                        decl: fld.fold_fn_decl(decl.clone()),\n-                        lifetimes: fld.fold_lifetime_defs(lifetimes.clone()),\n-                        ref_id: fld.new_id(ref_id),\n-                    }))\n-                }\n-            }\n-        }\n     }\n }\n "}, {"sha": "996708b217426d186a5d7b44f39ca3c3850a9252", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -749,8 +749,7 @@ mod test {\n                         segments: vec!(\n                             ast::PathSegment {\n                                 identifier: str_to_ident(\"a\"),\n-                                lifetimes: Vec::new(),\n-                                types: OwnedSlice::empty(),\n+                                parameters: ast::PathParameters::none(),\n                             }\n                         ),\n                     }),\n@@ -768,13 +767,11 @@ mod test {\n                             segments: vec!(\n                                 ast::PathSegment {\n                                     identifier: str_to_ident(\"a\"),\n-                                    lifetimes: Vec::new(),\n-                                    types: OwnedSlice::empty(),\n+                                    parameters: ast::PathParameters::none(),\n                                 },\n                                 ast::PathSegment {\n                                     identifier: str_to_ident(\"b\"),\n-                                    lifetimes: Vec::new(),\n-                                    types: OwnedSlice::empty(),\n+                                    parameters: ast::PathParameters::none(),\n                                 }\n                             )\n                         }),\n@@ -952,8 +949,7 @@ mod test {\n                             segments: vec!(\n                                 ast::PathSegment {\n                                     identifier: str_to_ident(\"d\"),\n-                                    lifetimes: Vec::new(),\n-                                    types: OwnedSlice::empty(),\n+                                    parameters: ast::PathParameters::none(),\n                                 }\n                             ),\n                         }),\n@@ -974,8 +970,7 @@ mod test {\n                                segments: vec!(\n                                 ast::PathSegment {\n                                     identifier: str_to_ident(\"b\"),\n-                                    lifetimes: Vec::new(),\n-                                    types: OwnedSlice::empty(),\n+                                    parameters: ast::PathParameters::none(),\n                                 }\n                                ),\n                             }),\n@@ -1022,8 +1017,7 @@ mod test {\n                                             ast::PathSegment {\n                                                 identifier:\n                                                     str_to_ident(\"int\"),\n-                                                lifetimes: Vec::new(),\n-                                                types: OwnedSlice::empty(),\n+                                                parameters: ast::PathParameters::none(),\n                                             }\n                                         ),\n                                         }, None, ast::DUMMY_NODE_ID),\n@@ -1072,10 +1066,8 @@ mod test {\n                                                                 identifier:\n                                                                 str_to_ident(\n                                                                     \"b\"),\n-                                                                lifetimes:\n-                                                                Vec::new(),\n-                                                                types:\n-                                                                OwnedSlice::empty()\n+                                                                parameters:\n+                                                                ast::PathParameters::none(),\n                                                             }\n                                                         ),\n                                                       }),"}, {"sha": "18dd7074d28b32e8389d4ae3bddc9735b9d28b60", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 154, "deletions": 112, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -53,9 +53,8 @@ use ast::{TtNonterminal, TupleVariantKind, Ty, Ty_, TyBot};\n use ast::{TypeField, TyFixedLengthVec, TyClosure, TyProc, TyBareFn};\n use ast::{TyTypeof, TyInfer, TypeMethod};\n use ast::{TyNil, TyParam, TyParamBound, TyParen, TyPath, TyPtr, TyQPath};\n-use ast::{TyRptr, TyTup, TyU32, TyUnboxedFn, TyUniq, TyVec, UnUniq};\n+use ast::{TyRptr, TyTup, TyU32, TyUniq, TyVec, UnUniq};\n use ast::{TypeImplItem, TypeTraitItem, Typedef, UnboxedClosureKind};\n-use ast::{UnboxedFnBound, UnboxedFnTy, UnboxedFnTyParamBound};\n use ast::{UnnamedField, UnsafeBlock};\n use ast::{UnsafeFn, ViewItem, ViewItem_, ViewItemExternCrate, ViewItemUse};\n use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n@@ -1127,19 +1126,16 @@ impl<'a> Parser<'a> {\n             Vec::new()\n         };\n \n-        let (optional_unboxed_closure_kind, inputs) = if self.eat(&token::OrOr) {\n-            (None, Vec::new())\n+        let inputs = if self.eat(&token::OrOr) {\n+            Vec::new()\n         } else {\n             self.expect_or();\n \n-            let optional_unboxed_closure_kind =\n-                self.parse_optional_unboxed_closure_kind();\n-\n             let inputs = self.parse_seq_to_before_or(\n                 &token::Comma,\n                 |p| p.parse_arg_general(false));\n             self.expect_or();\n-            (optional_unboxed_closure_kind, inputs)\n+            inputs\n         };\n \n         let bounds = self.parse_colon_then_ty_param_bounds();\n@@ -1152,23 +1148,13 @@ impl<'a> Parser<'a> {\n             variadic: false\n         });\n \n-        match optional_unboxed_closure_kind {\n-            Some(unboxed_closure_kind) => {\n-                TyUnboxedFn(P(UnboxedFnTy {\n-                    kind: unboxed_closure_kind,\n-                    decl: decl,\n-                }))\n-            }\n-            None => {\n-                TyClosure(P(ClosureTy {\n-                    fn_style: fn_style,\n-                    onceness: onceness,\n-                    bounds: bounds,\n-                    decl: decl,\n-                    lifetimes: lifetime_defs,\n-                }))\n-            }\n-        }\n+        TyClosure(P(ClosureTy {\n+            fn_style: fn_style,\n+            onceness: onceness,\n+            bounds: bounds,\n+            decl: decl,\n+            lifetimes: lifetime_defs,\n+        }))\n     }\n \n     pub fn parse_unsafety(&mut self) -> FnStyle {\n@@ -1487,9 +1473,9 @@ impl<'a> Parser<'a> {\n                 trait_name: trait_name.path,\n                 item_name: item_name,\n             }))\n-        } else if self.token == token::ModSep\n-            || self.token.is_ident()\n-            || self.token.is_path() {\n+        } else if self.token == token::ModSep ||\n+                  self.token.is_ident() ||\n+                  self.token.is_path() {\n             // NAMED TYPE\n             let mode = if plus_allowed {\n                 LifetimeAndTypesAndBounds\n@@ -1706,50 +1692,18 @@ impl<'a> Parser<'a> {\n         // Parse any number of segments and bound sets. A segment is an\n         // identifier followed by an optional lifetime and a set of types.\n         // A bound set is a set of type parameter bounds.\n-        let mut segments = Vec::new();\n-        loop {\n-            // First, parse an identifier.\n-            let identifier = self.parse_ident();\n-\n-            // Parse the '::' before type parameters if it's required. If\n-            // it is required and wasn't present, then we're done.\n-            if mode == LifetimeAndTypesWithColons &&\n-                    !self.eat(&token::ModSep) {\n-                segments.push(ast::PathSegment {\n-                    identifier: identifier,\n-                    lifetimes: Vec::new(),\n-                    types: OwnedSlice::empty(),\n-                });\n-                break\n+        let segments = match mode {\n+            LifetimeAndTypesWithoutColons |\n+            LifetimeAndTypesAndBounds => {\n+                self.parse_path_segments_without_colons()\n             }\n-\n-            // Parse the `<` before the lifetime and types, if applicable.\n-            let (any_lifetime_or_types, lifetimes, types) = {\n-                if mode != NoTypesAllowed && self.eat_lt(false) {\n-                    let (lifetimes, types) =\n-                        self.parse_generic_values_after_lt();\n-                    (true, lifetimes, OwnedSlice::from_vec(types))\n-                } else {\n-                    (false, Vec::new(), OwnedSlice::empty())\n-                }\n-            };\n-\n-            // Assemble and push the result.\n-            segments.push(ast::PathSegment {\n-                identifier: identifier,\n-                lifetimes: lifetimes,\n-                types: types,\n-            });\n-\n-            // We're done if we don't see a '::', unless the mode required\n-            // a double colon to get here in the first place.\n-            if !(mode == LifetimeAndTypesWithColons &&\n-                    !any_lifetime_or_types) {\n-                if !self.eat(&token::ModSep) {\n-                    break\n-                }\n+            LifetimeAndTypesWithColons => {\n+                self.parse_path_segments_with_colons()\n             }\n-        }\n+            NoTypesAllowed => {\n+                self.parse_path_segments_without_types()\n+            }\n+        };\n \n         // Next, parse a plus and bounded type parameters, if\n         // applicable. We need to remember whether the separate was\n@@ -1792,6 +1746,123 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    /// Examples:\n+    /// - `a::b<T,U>::c<V,W>`\n+    /// - `a::b<T,U>::c(V) -> W`\n+    /// - `a::b<T,U>::c(V)`\n+    pub fn parse_path_segments_without_colons(&mut self) -> Vec<ast::PathSegment> {\n+        let mut segments = Vec::new();\n+        loop {\n+            // First, parse an identifier.\n+            let identifier = self.parse_ident();\n+\n+            // Parse types, optionally.\n+            let parameters = if self.eat_lt(false) {\n+                let (lifetimes, types) = self.parse_generic_values_after_lt();\n+\n+                ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n+                    lifetimes: lifetimes,\n+                    types: OwnedSlice::from_vec(types),\n+                })\n+            } else if self.eat(&token::OpenDelim(token::Paren)) {\n+                let inputs = self.parse_seq_to_end(\n+                    &token::CloseDelim(token::Paren),\n+                    seq_sep_trailing_allowed(token::Comma),\n+                    |p| p.parse_ty(true));\n+\n+                let output_ty = if self.eat(&token::RArrow) {\n+                    Some(self.parse_ty(true))\n+                } else {\n+                    None\n+                };\n+\n+                ast::ParenthesizedParameters(ast::ParenthesizedParameterData {\n+                    inputs: inputs,\n+                    output: output_ty\n+                })\n+            } else {\n+                ast::PathParameters::none()\n+            };\n+\n+            // Assemble and push the result.\n+            segments.push(ast::PathSegment { identifier: identifier,\n+                                             parameters: parameters });\n+\n+            // Continue only if we see a `::`\n+            if !self.eat(&token::ModSep) {\n+                return segments;\n+            }\n+        }\n+    }\n+\n+    /// Examples:\n+    /// - `a::b::<T,U>::c`\n+    pub fn parse_path_segments_with_colons(&mut self) -> Vec<ast::PathSegment> {\n+        let mut segments = Vec::new();\n+        loop {\n+            // First, parse an identifier.\n+            let identifier = self.parse_ident();\n+\n+            // If we do not see a `::`, stop.\n+            if !self.eat(&token::ModSep) {\n+                segments.push(ast::PathSegment {\n+                    identifier: identifier,\n+                    parameters: ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n+                        lifetimes: Vec::new(),\n+                        types: OwnedSlice::empty(),\n+                    })\n+                });\n+                return segments;\n+            }\n+\n+            // Check for a type segment.\n+            if self.eat_lt(false) {\n+                // Consumed `a::b::<`, go look for types\n+                let (lifetimes, types) = self.parse_generic_values_after_lt();\n+                segments.push(ast::PathSegment {\n+                    identifier: identifier,\n+                    parameters: ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n+                        lifetimes: lifetimes,\n+                        types: OwnedSlice::from_vec(types),\n+                    }),\n+                });\n+\n+                // Consumed `a::b::<T,U>`, check for `::` before proceeding\n+                if !self.eat(&token::ModSep) {\n+                    return segments;\n+                }\n+            } else {\n+                // Consumed `a::`, go look for `b`\n+                segments.push(ast::PathSegment {\n+                    identifier: identifier,\n+                    parameters: ast::PathParameters::none(),\n+                });\n+            }\n+        }\n+    }\n+\n+\n+    /// Examples:\n+    /// - `a::b::c`\n+    pub fn parse_path_segments_without_types(&mut self) -> Vec<ast::PathSegment> {\n+        let mut segments = Vec::new();\n+        loop {\n+            // First, parse an identifier.\n+            let identifier = self.parse_ident();\n+\n+            // Assemble and push the result.\n+            segments.push(ast::PathSegment {\n+                identifier: identifier,\n+                parameters: ast::PathParameters::none()\n+            });\n+\n+            // If we do not see a `::`, stop.\n+            if !self.eat(&token::ModSep) {\n+                return segments;\n+            }\n+        }\n+    }\n+\n     /// parses 0 or 1 lifetime\n     pub fn parse_opt_lifetime(&mut self) -> Option<ast::Lifetime> {\n         match self.token {\n@@ -3389,13 +3460,9 @@ impl<'a> Parser<'a> {\n                           },\n                           _ => {\n                               if !enum_path.global &&\n-                                    enum_path.segments.len() == 1 &&\n-                                    enum_path.segments[0]\n-                                             .lifetimes\n-                                             .len() == 0 &&\n-                                    enum_path.segments[0]\n-                                             .types\n-                                             .len() == 0 {\n+                                  enum_path.segments.len() == 1 &&\n+                                  enum_path.segments[0].parameters.is_empty()\n+                              {\n                                   // it could still be either an enum\n                                   // or an identifier pattern, resolve\n                                   // will sort it out:\n@@ -3854,31 +3921,11 @@ impl<'a> Parser<'a> {\n                 token::ModSep | token::Ident(..) => {\n                     let path =\n                         self.parse_path(LifetimeAndTypesWithoutColons).path;\n-                    if self.token == token::OpenDelim(token::Paren) {\n-                        self.bump();\n-                        let inputs = self.parse_seq_to_end(\n-                            &token::CloseDelim(token::Paren),\n-                            seq_sep_trailing_allowed(token::Comma),\n-                            |p| p.parse_arg_general(false));\n-                        let (return_style, output) = self.parse_ret_ty();\n-                        result.push(UnboxedFnTyParamBound(P(UnboxedFnBound {\n-                            path: path,\n-                            decl: P(FnDecl {\n-                                inputs: inputs,\n-                                output: output,\n-                                cf: return_style,\n-                                variadic: false,\n-                            }),\n-                            lifetimes: lifetime_defs,\n-                            ref_id: ast::DUMMY_NODE_ID,\n-                        })));\n-                    } else {\n-                        result.push(TraitTyParamBound(ast::TraitRef {\n-                            path: path,\n-                            ref_id: ast::DUMMY_NODE_ID,\n-                            lifetimes: lifetime_defs,\n-                        }))\n-                    }\n+                    result.push(TraitTyParamBound(ast::TraitRef {\n+                        path: path,\n+                        ref_id: ast::DUMMY_NODE_ID,\n+                        lifetimes: lifetime_defs,\n+                    }))\n                 }\n                 _ => break,\n             }\n@@ -3894,8 +3941,7 @@ impl<'a> Parser<'a> {\n     fn trait_ref_from_ident(ident: Ident, span: Span) -> ast::TraitRef {\n         let segment = ast::PathSegment {\n             identifier: ident,\n-            lifetimes: Vec::new(),\n-            types: OwnedSlice::empty(),\n+            parameters: ast::PathParameters::none()\n         };\n         let path = ast::Path {\n             span: span,\n@@ -5611,8 +5657,7 @@ impl<'a> Parser<'a> {\n                 segments: path.into_iter().map(|identifier| {\n                     ast::PathSegment {\n                         identifier: identifier,\n-                        lifetimes: Vec::new(),\n-                        types: OwnedSlice::empty(),\n+                        parameters: ast::PathParameters::none(),\n                     }\n                 }).collect()\n             };\n@@ -5646,8 +5691,7 @@ impl<'a> Parser<'a> {\n                         segments: path.into_iter().map(|identifier| {\n                             ast::PathSegment {\n                                 identifier: identifier,\n-                                lifetimes: Vec::new(),\n-                                types: OwnedSlice::empty(),\n+                                parameters: ast::PathParameters::none(),\n                             }\n                         }).collect()\n                     };\n@@ -5664,8 +5708,7 @@ impl<'a> Parser<'a> {\n                         segments: path.into_iter().map(|identifier| {\n                             ast::PathSegment {\n                                 identifier: identifier,\n-                                lifetimes: Vec::new(),\n-                                types: OwnedSlice::empty(),\n+                                parameters: ast::PathParameters::none(),\n                             }\n                         }).collect()\n                     };\n@@ -5686,8 +5729,7 @@ impl<'a> Parser<'a> {\n             segments: path.into_iter().map(|identifier| {\n                 ast::PathSegment {\n                     identifier: identifier,\n-                    lifetimes: Vec::new(),\n-                    types: OwnedSlice::empty(),\n+                    parameters: ast::PathParameters::none(),\n                 }\n             }).collect()\n         };"}, {"sha": "2448eacbb39986a32e5290cb729d739d9c3574b9", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 51, "deletions": 61, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -13,7 +13,7 @@ use ast::{FnUnboxedClosureKind, FnMutUnboxedClosureKind};\n use ast::{FnOnceUnboxedClosureKind};\n use ast::{MethodImplItem, RegionTyParamBound, TraitTyParamBound};\n use ast::{RequiredMethod, ProvidedMethod, TypeImplItem, TypeTraitItem};\n-use ast::{UnboxedClosureKind, UnboxedFnTyParamBound};\n+use ast::{UnboxedClosureKind};\n use ast;\n use ast_util;\n use owned_slice::OwnedSlice;\n@@ -699,7 +699,6 @@ impl<'a> State<'a> {\n                                       None,\n                                       &OwnedSlice::empty(),\n                                       Some(&generics),\n-                                      None,\n                                       None));\n             }\n             ast::TyClosure(ref f) => {\n@@ -719,7 +718,6 @@ impl<'a> State<'a> {\n                                       None,\n                                       &f.bounds,\n                                       Some(&generics),\n-                                      None,\n                                       None));\n             }\n             ast::TyProc(ref f) => {\n@@ -739,21 +737,8 @@ impl<'a> State<'a> {\n                                       None,\n                                       &f.bounds,\n                                       Some(&generics),\n-                                      None,\n                                       None));\n             }\n-            ast::TyUnboxedFn(ref f) => {\n-                try!(self.print_ty_fn(None,\n-                                      None,\n-                                      ast::NormalFn,\n-                                      ast::Many,\n-                                      &*f.decl,\n-                                      None,\n-                                      &OwnedSlice::empty(),\n-                                      None,\n-                                      None,\n-                                      Some(f.kind)));\n-            }\n             ast::TyPath(ref path, ref bounds, _) => {\n                 try!(self.print_bounded_path(path, bounds));\n             }\n@@ -1212,8 +1197,7 @@ impl<'a> State<'a> {\n                               Some(m.ident),\n                               &OwnedSlice::empty(),\n                               Some(&m.generics),\n-                              Some(&m.explicit_self.node),\n-                              None));\n+                              Some(&m.explicit_self.node)));\n         word(&mut self.s, \";\")\n     }\n \n@@ -1995,39 +1979,73 @@ impl<'a> State<'a> {\n \n             try!(self.print_ident(segment.identifier));\n \n-            if !segment.lifetimes.is_empty() || !segment.types.is_empty() {\n-                if colons_before_params {\n-                    try!(word(&mut self.s, \"::\"))\n-                }\n+            try!(self.print_path_parameters(&segment.parameters, colons_before_params));\n+        }\n+\n+        match *opt_bounds {\n+            None => Ok(()),\n+            Some(ref bounds) => self.print_bounds(\"+\", bounds)\n+        }\n+    }\n+\n+    fn print_path_parameters(&mut self,\n+                             parameters: &ast::PathParameters,\n+                             colons_before_params: bool)\n+                             -> IoResult<()>\n+    {\n+        if parameters.is_empty() {\n+            return Ok(());\n+        }\n+\n+        if colons_before_params {\n+            try!(word(&mut self.s, \"::\"))\n+        }\n+\n+        match *parameters {\n+            ast::AngleBracketedParameters(ref data) => {\n                 try!(word(&mut self.s, \"<\"));\n \n                 let mut comma = false;\n-                for lifetime in segment.lifetimes.iter() {\n+                for lifetime in data.lifetimes.iter() {\n                     if comma {\n                         try!(self.word_space(\",\"))\n                     }\n                     try!(self.print_lifetime(lifetime));\n                     comma = true;\n                 }\n \n-                if !segment.types.is_empty() {\n+                if !data.types.is_empty() {\n                     if comma {\n                         try!(self.word_space(\",\"))\n                     }\n                     try!(self.commasep(\n                         Inconsistent,\n-                        segment.types.as_slice(),\n+                        data.types.as_slice(),\n                         |s, ty| s.print_type(&**ty)));\n                 }\n \n                 try!(word(&mut self.s, \">\"))\n             }\n-        }\n \n-        match *opt_bounds {\n-            None => Ok(()),\n-            Some(ref bounds) => self.print_bounds(\"+\", bounds)\n+            ast::ParenthesizedParameters(ref data) => {\n+                try!(word(&mut self.s, \"(\"));\n+                try!(self.commasep(\n+                    Inconsistent,\n+                    data.inputs.as_slice(),\n+                    |s, ty| s.print_type(&**ty)));\n+                try!(word(&mut self.s, \")\"));\n+\n+                match data.output {\n+                    None => { }\n+                    Some(ref ty) => {\n+                        try!(self.word_space(\"->\"));\n+                        try!(self.print_type(&**ty));\n+                    }\n+                }\n+            }\n         }\n+\n+        Ok(())\n     }\n \n     fn print_path(&mut self, path: &ast::Path,\n@@ -2373,15 +2391,6 @@ impl<'a> State<'a> {\n                     RegionTyParamBound(ref lt) => {\n                         self.print_lifetime(lt)\n                     }\n-                    UnboxedFnTyParamBound(ref unboxed_function_type) => {\n-                        try!(self.print_path(&unboxed_function_type.path,\n-                                             false));\n-                        try!(self.popen());\n-                        try!(self.print_fn_args(&*unboxed_function_type.decl,\n-                                                None));\n-                        try!(self.pclose());\n-                        self.print_fn_output(&*unboxed_function_type.decl)\n-                    }\n                 })\n             }\n             Ok(())\n@@ -2641,9 +2650,7 @@ impl<'a> State<'a> {\n                        id: Option<ast::Ident>,\n                        bounds: &OwnedSlice<ast::TyParamBound>,\n                        generics: Option<&ast::Generics>,\n-                       opt_explicit_self: Option<&ast::ExplicitSelf_>,\n-                       opt_unboxed_closure_kind:\n-                        Option<ast::UnboxedClosureKind>)\n+                       opt_explicit_self: Option<&ast::ExplicitSelf_>)\n                        -> IoResult<()> {\n         try!(self.ibox(indent_unit));\n \n@@ -2660,9 +2667,7 @@ impl<'a> State<'a> {\n             try!(self.print_fn_style(fn_style));\n             try!(self.print_opt_abi_and_extern_if_nondefault(opt_abi));\n             try!(self.print_onceness(onceness));\n-            if opt_unboxed_closure_kind.is_none() {\n-                try!(word(&mut self.s, \"fn\"));\n-            }\n+            try!(word(&mut self.s, \"fn\"));\n         }\n \n         match id {\n@@ -2676,30 +2681,15 @@ impl<'a> State<'a> {\n         match generics { Some(g) => try!(self.print_generics(g)), _ => () }\n         try!(zerobreak(&mut self.s));\n \n-        if opt_unboxed_closure_kind.is_some() || opt_sigil == Some('&') {\n+        if opt_sigil == Some('&') {\n             try!(word(&mut self.s, \"|\"));\n         } else {\n             try!(self.popen());\n         }\n \n-        match opt_unboxed_closure_kind {\n-            Some(ast::FnUnboxedClosureKind) => {\n-                try!(word(&mut self.s, \"&\"));\n-                try!(self.word_space(\":\"));\n-            }\n-            Some(ast::FnMutUnboxedClosureKind) => {\n-                try!(word(&mut self.s, \"&mut\"));\n-                try!(self.word_space(\":\"));\n-            }\n-            Some(ast::FnOnceUnboxedClosureKind) => {\n-                try!(self.word_space(\":\"));\n-            }\n-            None => {}\n-        }\n-\n         try!(self.print_fn_args(decl, opt_explicit_self));\n \n-        if opt_unboxed_closure_kind.is_some() || opt_sigil == Some('&') {\n+        if opt_sigil == Some('&') {\n             try!(word(&mut self.s, \"|\"));\n         } else {\n             if decl.variadic {"}, {"sha": "6a4ab365a50b2930c9870ada96f8d23c2cfe72b3", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -14,7 +14,6 @@ use codemap::DUMMY_SP;\n use codemap;\n use fold::Folder;\n use fold;\n-use owned_slice::OwnedSlice;\n use parse::token::InternedString;\n use parse::token::special_idents;\n use parse::token;\n@@ -181,13 +180,11 @@ impl<'a> fold::Folder for PreludeInjector<'a> {\n             segments: vec!(\n                 ast::PathSegment {\n                     identifier: token::str_to_ident(\"std\"),\n-                    lifetimes: Vec::new(),\n-                    types: OwnedSlice::empty(),\n+                    parameters: ast::PathParameters::none(),\n                 },\n                 ast::PathSegment {\n                     identifier: token::str_to_ident(\"prelude\"),\n-                    lifetimes: Vec::new(),\n-                    types: OwnedSlice::empty(),\n+                    parameters: ast::PathParameters::none(),\n                 }),\n         };\n "}, {"sha": "a7db8e800a9d0e54503d2b86bc7fca21cc2b1af1", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -453,8 +453,7 @@ fn path_node(ids: Vec<ast::Ident> ) -> ast::Path {\n         global: false,\n         segments: ids.into_iter().map(|identifier| ast::PathSegment {\n             identifier: identifier,\n-            lifetimes: Vec::new(),\n-            types: OwnedSlice::empty(),\n+            parameters: ast::PathParameters::none(),\n         }).collect()\n     }\n }"}, {"sha": "9751abacbd3ff863bc42cae0f235763e72777e15", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -365,12 +365,6 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             visitor.visit_ty(&*function_declaration.decl.output);\n             walk_lifetime_decls(visitor, &function_declaration.lifetimes);\n         }\n-        TyUnboxedFn(ref function_declaration) => {\n-            for argument in function_declaration.decl.inputs.iter() {\n-                visitor.visit_ty(&*argument.ty)\n-            }\n-            visitor.visit_ty(&*function_declaration.decl.output);\n-        }\n         TyPath(ref path, ref opt_bounds, id) => {\n             visitor.visit_path(path, id);\n             match *opt_bounds {\n@@ -407,11 +401,23 @@ pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path) {\n     for segment in path.segments.iter() {\n         visitor.visit_ident(path.span, segment.identifier);\n \n-        for typ in segment.types.iter() {\n-            visitor.visit_ty(&**typ);\n-        }\n-        for lifetime in segment.lifetimes.iter() {\n-            visitor.visit_lifetime_ref(lifetime);\n+        match segment.parameters {\n+            ast::AngleBracketedParameters(ref data) => {\n+                for typ in data.types.iter() {\n+                    visitor.visit_ty(&**typ);\n+                }\n+                for lifetime in data.lifetimes.iter() {\n+                    visitor.visit_lifetime_ref(lifetime);\n+                }\n+            }\n+            ast::ParenthesizedParameters(ref data) => {\n+                for typ in data.inputs.iter() {\n+                    visitor.visit_ty(&**typ);\n+                }\n+                for typ in data.output.iter() {\n+                    visitor.visit_ty(&**typ);\n+                }\n+            }\n         }\n     }\n }\n@@ -493,13 +499,6 @@ pub fn walk_ty_param_bounds<'v, V: Visitor<'v>>(visitor: &mut V,\n             TraitTyParamBound(ref typ) => {\n                 walk_trait_ref_helper(visitor, typ)\n             }\n-            UnboxedFnTyParamBound(ref function_declaration) => {\n-                for argument in function_declaration.decl.inputs.iter() {\n-                    visitor.visit_ty(&*argument.ty)\n-                }\n-                visitor.visit_ty(&*function_declaration.decl.output);\n-                walk_lifetime_decls(visitor, &function_declaration.lifetimes);\n-            }\n             RegionTyParamBound(ref lifetime) => {\n                 visitor.visit_lifetime_ref(lifetime);\n             }"}, {"sha": "0ab37a888267f44eed1c158dc69f0ff1d3a3d038", "filename": "src/test/compile-fail/issue-14092.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Ftest%2Fcompile-fail%2Fissue-14092.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Ftest%2Fcompile-fail%2Fissue-14092.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14092.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn fn1(0: Box) {} //~ ERROR: not enough type parameters supplied to `Box<T>`\n+fn fn1(0: Box) {} //~ ERROR: wrong number of type arguments: expected 1, found 0\n \n fn main() {}\n "}, {"sha": "63b110b5579344901453bcbbbc00bf6b1e182c8d", "filename": "src/test/compile-fail/issue-18423.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Ftest%2Fcompile-fail%2Fissue-18423.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Ftest%2Fcompile-fail%2Fissue-18423.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18423.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that `Box` cannot be used with a lifetime parameter.\n+\n+struct Foo<'a> {\n+    x: Box<'a, int> //~ ERROR wrong number of lifetime parameters\n+}\n+\n+pub fn main() {\n+}"}, {"sha": "9866a20004527f0520063f680bab36af044057f7", "filename": "src/test/compile-fail/unboxed-closure-sugar-default.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-default.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test interaction between unboxed closure sugar and default type\n+// parameters (should be exactly as if angle brackets were used).\n+\n+#![feature(default_type_params)]\n+#![allow(dead_code)]\n+\n+struct Foo<T,U,V=T> {\n+    t: T, u: U\n+}\n+\n+trait Eq<X> { }\n+impl<X> Eq<X> for X { }\n+fn eq<A,B:Eq<A>>() { }\n+\n+fn test<'a,'b>() {\n+    // Parens are equivalent to omitting default in angle.\n+    eq::< Foo<(int,),()>,               Foo(int)                      >();\n+\n+    // In angle version, we supply something other than the default\n+    eq::< Foo<(int,),(),int>,           Foo(int)                      >();\n+    //~^ ERROR not implemented\n+\n+    // Supply default explicitly.\n+    eq::< Foo<(int,),(),(int,)>,        Foo(int)                      >();\n+}\n+\n+fn main() { }"}, {"sha": "c38010c1ee260a9bb5fcd610bf63d1dd2edc89b9", "filename": "src/test/compile-fail/unboxed-closure-sugar-equiv.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the unboxed closure sugar can be used with an arbitrary\n+// struct type and that it is equivalent to the same syntax using\n+// angle brackets. This test covers only simple types and in\n+// particular doesn't test bound regions.\n+\n+#![allow(dead_code)]\n+\n+struct Foo<T,U> {\n+    t: T, u: U\n+}\n+\n+trait Eq<X> { }\n+impl<X> Eq<X> for X { }\n+fn eq<A,B:Eq<A>>() { }\n+\n+fn test<'a,'b>() {\n+    // No errors expected:\n+    eq::< Foo<(),()>,                   Foo()                         >();\n+    eq::< Foo<(int,),()>,               Foo(int)                      >();\n+    eq::< Foo<(int,uint),()>,           Foo(int,uint)                 >();\n+    eq::< Foo<(int,uint),uint>,         Foo(int,uint) -> uint         >();\n+    eq::< Foo<(&'a int,&'b uint),uint>, Foo(&'a int,&'b uint) -> uint >();\n+\n+    // Errors expected:\n+    eq::< Foo<(),()>,                   Foo(char)                     >();\n+    //~^ ERROR not implemented\n+}\n+\n+fn main() { }"}, {"sha": "d89c3802508c593c653330580acb96d7635ee745", "filename": "src/test/compile-fail/unboxed-closure-sugar-nonexistent-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-nonexistent-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-nonexistent-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-nonexistent-trait.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn f<F:Nonexist(int) -> int>(x: F) {} //~ ERROR unresolved trait\n+fn f<F:Nonexist(int) -> int>(x: F) {} //~ ERROR nonexistent trait `Nonexist`\n \n type Typedef = int;\n "}, {"sha": "962e233dea696651ee56bb33753ffc3d02db6423", "filename": "src/test/compile-fail/unboxed-closure-sugar-region.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-region.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test interaction between unboxed closure sugar and region\n+// parameters (should be exactly as if angle brackets were used\n+// and regions omitted).\n+\n+#![feature(default_type_params)]\n+#![allow(dead_code)]\n+\n+use std::kinds::marker;\n+\n+struct Foo<'a,T,U> {\n+    t: T,\n+    u: U,\n+    m: marker::InvariantLifetime<'a>\n+}\n+\n+trait Eq<X> { }\n+impl<X> Eq<X> for X { }\n+fn eq<A,B:Eq<A>>() { }\n+fn same_type<A,B:Eq<A>>(a: A, b: B) { }\n+\n+fn test<'a,'b>() {\n+    // Parens are equivalent to omitting default in angle.\n+    eq::< Foo<(int,),()>,               Foo(int)                      >();\n+\n+    // Here we specify 'static explicitly in angle-bracket version.\n+    // Parenthesized winds up getting inferred.\n+    eq::< Foo<'static, (int,),()>,               Foo(int)                      >();\n+}\n+\n+fn test2(x: Foo<(int,),()>, y: Foo(int)) {\n+    // Here, the omitted lifetimes are expanded to distinct things.\n+    same_type(x, y) //~ ERROR cannot infer\n+}\n+\n+fn main() { }"}, {"sha": "e122b87b1e0f04c9b4094d6a764ecb7434b1a9ca", "filename": "src/test/compile-fail/unboxed-closure-sugar-wrong-number-number-type-parameters-1.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-1.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct One<A>;\n+\n+fn foo(_: One()) //~ ERROR wrong number of type arguments\n+{}\n+\n+fn main() { }"}, {"sha": "7a66abb39df58e1e01da72422c651e1ba6c86291", "filename": "src/test/compile-fail/unboxed-closure-sugar-wrong-number-number-type-parameters-3.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-3.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Three<A,B,C>;\n+\n+fn foo(_: Three()) //~ ERROR wrong number of type arguments\n+{}\n+\n+fn main() { }"}, {"sha": "e265a3d56b871cc56af5f340fbe1b9c7b10d8b62", "filename": "src/test/compile-fail/unboxed-closure-sugar-wrong-number-number-type-parameters.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Zero;\n+\n+fn foo(_: Zero()) //~ ERROR wrong number of type arguments\n+{}\n+\n+fn main() { }"}, {"sha": "1394f8fa65fccb9cd0d07f08b4a0de2dd824d89b", "filename": "src/test/compile-fail/unboxed-closure-sugar-wrong-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-trait.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -11,7 +11,7 @@\n trait Trait {}\n \n fn f<F:Trait(int) -> int>(x: F) {}\n-//~^ ERROR unboxed function trait must be one of `Fn`, `FnMut`, or `FnOnce`\n+//~^ ERROR wrong number of type arguments: expected 0, found 2\n \n fn main() {}\n "}, {"sha": "8f6cfe0499703ff7c7116c016bff80af6f060744", "filename": "src/test/run-pass/unboxed-closures-manual-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Ftest%2Frun-pass%2Funboxed-closures-manual-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Ftest%2Frun-pass%2Funboxed-closures-manual-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-manual-impl.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -25,7 +25,7 @@ fn call_it<F:FnMut(int)->int>(mut f: F, x: int) -> int {\n     f.call_mut((x,)) + 3\n }\n \n-fn call_box(f: &mut |&mut: int|->int, x: int) -> int {\n+fn call_box(f: &mut FnMut(int) -> int, x: int) -> int {\n     f.call_mut((x,)) + 3\n }\n "}, {"sha": "f9d2ba02123c464775abab2ca5f52acd0a3b96fa", "filename": "src/test/run-pass/unboxed-closures-prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Ftest%2Frun-pass%2Funboxed-closures-prelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Ftest%2Frun-pass%2Funboxed-closures-prelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-prelude.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -13,7 +13,7 @@\n #![feature(unboxed_closures, unboxed_closure_sugar)]\n \n fn main() {\n-    let task: Box<|: int| -> int> = box |: x| x;\n+    let task: Box<FnOnce(int) -> int> = box |: x| x;\n     task.call_once((0i, ));\n }\n "}, {"sha": "b358e7ce288339f26a6a727dadeb85ac4666d1ad", "filename": "src/test/run-pass/unboxed-closures-sugar-1.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Ftest%2Frun-pass%2Funboxed-closures-sugar-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Ftest%2Frun-pass%2Funboxed-closures-sugar-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-sugar-1.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the unboxed closure sugar can be used with an arbitrary\n+// struct type and that it is equivalent to the same syntax using\n+// angle brackets. This test covers only simple types and in\n+// particular doesn't test bound regions.\n+\n+#![allow(dead_code)]\n+\n+struct Foo<T,U> {\n+    t: T, u: U\n+}\n+\n+trait Eq<X> { }\n+impl<X> Eq<X> for X { }\n+fn eq<A,B:Eq<A>>() { }\n+\n+fn test<'a,'b>() {\n+    eq::< Foo<(),()>,                   Foo()                         >();\n+    eq::< Foo<(int,),()>,               Foo(int)                      >();\n+    eq::< Foo<(int,uint),()>,           Foo(int,uint)                 >();\n+    eq::< Foo<(int,uint),uint>,         Foo(int,uint) -> uint         >();\n+    eq::< Foo<(&'a int,&'b uint),uint>, Foo(&'a int,&'b uint) -> uint >();\n+}\n+\n+fn main() { }"}, {"sha": "3b38f72432f179c32e9a5320b2396afb5c19f2e7", "filename": "src/test/run-pass/unboxed-closures-sugar-object.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Ftest%2Frun-pass%2Funboxed-closures-sugar-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Ftest%2Frun-pass%2Funboxed-closures-sugar-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-sugar-object.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test unboxed closure sugar used in object types.\n+\n+#![allow(dead_code)]\n+\n+struct Foo<T,U> {\n+    t: T, u: U\n+}\n+\n+trait Getter<A,R> {\n+    fn get(&self, arg: A) -> R;\n+}\n+\n+struct Identity;\n+impl<X> Getter<X,X> for Identity {\n+    fn get(&self, arg: X) -> X {\n+        arg\n+    }\n+}\n+\n+fn main() {\n+    let x: &Getter(int) -> (int,) = &Identity;\n+    let (y,) = x.get((22,));\n+    assert_eq!(y, 22);\n+}"}, {"sha": "426352cadd87fbcf05e312d65a439032a07c28dc", "filename": "src/test/run-pass/unboxed-closures-unboxing-shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Ftest%2Frun-pass%2Funboxed-closures-unboxing-shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91/src%2Ftest%2Frun-pass%2Funboxed-closures-unboxing-shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-unboxing-shim.rs?ref=76d2abe0e7fb33ed41137a0c99fbbc2905d8ca91", "patch": "@@ -13,7 +13,7 @@\n use std::ops::FnOnce;\n \n fn main() {\n-    let task: Box<|: int| -> int> = box |: x| x;\n+    let task: Box<FnOnce(int) -> int> = box |: x| x;\n     assert!(task.call_once((1234i,)) == 1234i);\n }\n "}]}