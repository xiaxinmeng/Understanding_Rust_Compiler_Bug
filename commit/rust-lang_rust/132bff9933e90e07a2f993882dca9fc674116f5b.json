{"sha": "132bff9933e90e07a2f993882dca9fc674116f5b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzMmJmZjk5MzNlOTBlMDdhMmY5OTM4ODJkY2E5ZmM2NzQxMTZmNWI=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-07-25T23:04:42Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-07-27T05:17:04Z"}, "message": "If a single import resolves to an inaccessible name in some but not all namespaces,\navoid importing the name in the inaccessible namespaces.\n\nCurrently, the inaccessible namespaces are imported but cause a privacy error when used.", "tree": {"sha": "da29f99e6462890b4fe70665677a4242cab66d45", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da29f99e6462890b4fe70665677a4242cab66d45"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/132bff9933e90e07a2f993882dca9fc674116f5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/132bff9933e90e07a2f993882dca9fc674116f5b", "html_url": "https://github.com/rust-lang/rust/commit/132bff9933e90e07a2f993882dca9fc674116f5b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/132bff9933e90e07a2f993882dca9fc674116f5b/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b541f5f0cc342dc6d31d7980f75c3d3d42f7587f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b541f5f0cc342dc6d31d7980f75c3d3d42f7587f", "html_url": "https://github.com/rust-lang/rust/commit/b541f5f0cc342dc6d31d7980f75c3d3d42f7587f"}], "stats": {"total": 85, "additions": 35, "deletions": 50}, "files": [{"sha": "7a0a417d0274a8f1c7a76bcf830a124862123599", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/132bff9933e90e07a2f993882dca9fc674116f5b/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132bff9933e90e07a2f993882dca9fc674116f5b/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=132bff9933e90e07a2f993882dca9fc674116f5b", "patch": "@@ -825,8 +825,6 @@ enum NameBindingKind<'a> {\n     Import {\n         binding: &'a NameBinding<'a>,\n         directive: &'a ImportDirective<'a>,\n-        // Some(error) if using this imported name causes the import to be a privacy error\n-        privacy_error: Option<Box<PrivacyError<'a>>>,\n     },\n }\n \n@@ -1206,16 +1204,11 @@ impl<'a> Resolver<'a> {\n             self.used_crates.insert(krate);\n         }\n \n-        let (directive, privacy_error) = match binding.kind {\n-            NameBindingKind::Import { directive, ref privacy_error, .. } =>\n-                (directive, privacy_error),\n+        let directive = match binding.kind {\n+            NameBindingKind::Import { directive, .. } => directive,\n             _ => return,\n         };\n \n-        if let Some(error) = privacy_error.as_ref() {\n-            self.privacy_errors.push((**error).clone());\n-        }\n-\n         if !self.make_glob_map {\n             return;\n         }"}, {"sha": "fc5e2a48e876ccc2eaf5391dd85a4e399f7ec2ee", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 33, "deletions": 41, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/132bff9933e90e07a2f993882dca9fc674116f5b/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132bff9933e90e07a2f993882dca9fc674116f5b/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=132bff9933e90e07a2f993882dca9fc674116f5b", "patch": "@@ -73,13 +73,11 @@ pub struct ImportDirective<'a> {\n impl<'a> ImportDirective<'a> {\n     // Given the binding to which this directive resolves in a particular namespace,\n     // this returns the binding for the name this directive defines in that namespace.\n-    fn import(&'a self, binding: &'a NameBinding<'a>, privacy_error: Option<Box<PrivacyError<'a>>>)\n-              -> NameBinding<'a> {\n+    fn import(&'a self, binding: &'a NameBinding<'a>) -> NameBinding<'a> {\n         NameBinding {\n             kind: NameBindingKind::Import {\n                 binding: binding,\n                 directive: self,\n-                privacy_error: privacy_error,\n             },\n             span: self.span,\n             vis: self.vis,\n@@ -328,7 +326,7 @@ impl<'a> ::ModuleS<'a> {\n     fn define_in_glob_importers(&self, name: Name, ns: Namespace, binding: &'a NameBinding<'a>) {\n         if !binding.is_importable() || !binding.is_pseudo_public() { return }\n         for &(importer, directive) in self.glob_importers.borrow_mut().iter() {\n-            let _ = importer.try_define_child(name, ns, directive.import(binding, None));\n+            let _ = importer.try_define_child(name, ns, directive.import(binding));\n         }\n     }\n }\n@@ -409,7 +407,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 span: DUMMY_SP,\n                 vis: ty::Visibility::Public,\n             });\n-            let dummy_binding = directive.import(dummy_binding, None);\n+            let dummy_binding = directive.import(dummy_binding);\n \n             let _ = source_module.try_define_child(target, ValueNS, dummy_binding.clone());\n             let _ = source_module.try_define_child(target, TypeNS, dummy_binding);\n@@ -494,38 +492,37 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             self.resolver.resolve_name_in_module(target_module, source, TypeNS, false, true);\n \n         let module_ = self.resolver.current_module;\n+        let mut privacy_error = true;\n         for &(ns, result, determined) in &[(ValueNS, &value_result, value_determined),\n                                            (TypeNS, &type_result, type_determined)] {\n-            if determined.get() { continue }\n-            if let Indeterminate = *result { continue }\n-\n-            determined.set(true);\n-            if let Success(binding) = *result {\n-                if !binding.is_importable() {\n+            match *result {\n+                Failed(..) if !determined.get() => {\n+                    determined.set(true);\n+                    module_.update_resolution(target, ns, |resolution| {\n+                        resolution.single_imports.directive_failed()\n+                    });\n+                }\n+                Success(binding) if !binding.is_importable() => {\n                     let msg = format!(\"`{}` is not directly importable\", target);\n                     span_err!(self.resolver.session, directive.span, E0253, \"{}\", &msg);\n                     // Do not import this illegal binding. Import a dummy binding and pretend\n                     // everything is fine\n                     self.import_dummy_binding(module_, directive);\n                     return Success(());\n                 }\n-\n-                let privacy_error = if !self.resolver.is_accessible(binding.vis) {\n-                    Some(Box::new(PrivacyError(directive.span, source, binding)))\n-                } else {\n-                    None\n-                };\n-\n-                let imported_binding = directive.import(binding, privacy_error);\n-                let conflict = module_.try_define_child(target, ns, imported_binding);\n-                if let Err(old_binding) = conflict {\n-                    let binding = &directive.import(binding, None);\n-                    self.resolver.report_conflict(module_, target, ns, binding, old_binding);\n+                Success(binding) if !self.resolver.is_accessible(binding.vis) => {}\n+                Success(binding) if !determined.get() => {\n+                    determined.set(true);\n+                    let imported_binding = directive.import(binding);\n+                    let conflict = module_.try_define_child(target, ns, imported_binding);\n+                    if let Err(old_binding) = conflict {\n+                        let binding = &directive.import(binding);\n+                        self.resolver.report_conflict(module_, target, ns, binding, old_binding);\n+                    }\n+                    privacy_error = false;\n                 }\n-            } else {\n-                module_.update_resolution(target, ns, |resolution| {\n-                    resolution.single_imports.directive_failed();\n-                });\n+                Success(_) => privacy_error = false,\n+                _ => {}\n             }\n         }\n \n@@ -556,6 +553,14 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             _ => (),\n         }\n \n+        if privacy_error {\n+            for &(ns, result) in &[(ValueNS, &value_result), (TypeNS, &type_result)] {\n+                let binding = match *result { Success(binding) => binding, _ => continue };\n+                self.resolver.privacy_errors.push(PrivacyError(directive.span, source, binding));\n+                let _ = module_.try_define_child(target, ns, directive.import(binding));\n+            }\n+        }\n+\n         match (&value_result, &type_result) {\n             (&Success(binding), _) if !binding.pseudo_vis()\n                                               .is_at_least(directive.vis, self.resolver) &&\n@@ -592,19 +597,6 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             _ => {}\n         }\n \n-        // Report a privacy error here if all successful namespaces are privacy errors.\n-        let mut privacy_error = None;\n-        for &ns in &[ValueNS, TypeNS] {\n-            privacy_error = match module_.resolve_name(target, ns, true) {\n-                Success(&NameBinding {\n-                    kind: NameBindingKind::Import { ref privacy_error, .. }, ..\n-                }) => privacy_error.as_ref().map(|error| (**error).clone()),\n-                _ => continue,\n-            };\n-            if privacy_error.is_none() { break }\n-        }\n-        privacy_error.map(|error| self.resolver.privacy_errors.push(error));\n-\n         // Record what this import resolves to for later uses in documentation,\n         // this may resolve to either a value or a type, but for documentation\n         // purposes it's good enough to just favor one over the other.\n@@ -652,7 +644,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         }).collect::<Vec<_>>();\n         for ((name, ns), binding) in bindings {\n             if binding.is_importable() && binding.is_pseudo_public() {\n-                let _ = module_.try_define_child(name, ns, directive.import(binding, None));\n+                let _ = module_.try_define_child(name, ns, directive.import(binding));\n             }\n         }\n "}]}