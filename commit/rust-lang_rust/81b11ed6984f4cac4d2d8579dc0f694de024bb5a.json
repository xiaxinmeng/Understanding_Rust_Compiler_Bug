{"sha": "81b11ed6984f4cac4d2d8579dc0f694de024bb5a", "node_id": "C_kwDOAAsO6NoAKDgxYjExZWQ2OTg0ZjRjYWM0ZDJkODU3OWRjMGY2OTRkZTAyNGJiNWE", "commit": {"author": {"name": "joboet", "email": "jonasboettiger@icloud.com", "date": "2022-09-06T12:32:45Z"}, "committer": {"name": "joboet", "email": "jonasboettiger@icloud.com", "date": "2022-09-10T18:03:15Z"}, "message": "std: optimize thread parking on NetBSD", "tree": {"sha": "6dfedd9f7d5a046d1e5f2bd0004b9986edeead79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6dfedd9f7d5a046d1e5f2bd0004b9986edeead79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81b11ed6984f4cac4d2d8579dc0f694de024bb5a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEVuz3PwcqDyifNyYbcE4BSbAZSzwFAmMc0WwACgkQcE4BSbAZ\nSzwdbA//S5vxiIHPtGZIObkZwGAbUU0+jNjhQlnWTXMSK3t3Bpd5R1Zs4KMUOBxQ\njMwIhr7i8qK/mzN0I9zoF+Kl9ibLKdv+/zDYAgifxo93qn4fuFgiAztfAv2YWWn3\nFt6yxZ+3i9w9G0poLPCJh+oIMQuS4O04WemoKGRaAZfC2oFY/txvQaF/9y8HJHdr\nkJrAcTT5vmAfRxabyqgiBlyYtL1RDbRi8FXoU9bqTBimw7wdd8B9fkeulywDcgbJ\nfHjgPNlIRucyFK3fCepImhli7BI0xRN16kirKfRYQeoLHLTaMkfOfVb1kggoHlS4\n9mRJ2tvYB5hcF8IaXEjhXjkqFANQxnoPHtCpwLiT32TjVt7N7vW93qcK16QnZZkv\nyYHjh7q4ytna4PiuPN2WLuEbZGPgmweaq1ET2JfNzmFwJnPxufxeoX10z6vhciXx\nXuSc2/1zgkMQ2ib5BuqMUfX9s3LJt8bRyK8knSC2XKv88i8ZwqDIOjf+8FOfe7/z\nv0n1IzLyZp6TcIneOdSw6KNG6ETErmZTJ5YxbfEYeOl0ptEAodqlHjpwLAybkKzV\nt4PpHlKgrbHRigm0kDnFa8Fx+Szfnk0NHJ+jsMpzk05soUEgB4qYEM91bfRWdQud\nlqL7bGNKAhWXqYnABfXiuOQ62OPNnGhLQe4EoKByk8jW6docccU=\n=2rMA\n-----END PGP SIGNATURE-----", "payload": "tree 6dfedd9f7d5a046d1e5f2bd0004b9986edeead79\nparent 098cf8802271eacdc463fa66c35da377926d4c4e\nauthor joboet <jonasboettiger@icloud.com> 1662467565 +0200\ncommitter joboet <jonasboettiger@icloud.com> 1662832995 +0200\n\nstd: optimize thread parking on NetBSD\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81b11ed6984f4cac4d2d8579dc0f694de024bb5a", "html_url": "https://github.com/rust-lang/rust/commit/81b11ed6984f4cac4d2d8579dc0f694de024bb5a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81b11ed6984f4cac4d2d8579dc0f694de024bb5a/comments", "author": {"login": "joboet", "id": 25721079, "node_id": "MDQ6VXNlcjI1NzIxMDc5", "avatar_url": "https://avatars.githubusercontent.com/u/25721079?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joboet", "html_url": "https://github.com/joboet", "followers_url": "https://api.github.com/users/joboet/followers", "following_url": "https://api.github.com/users/joboet/following{/other_user}", "gists_url": "https://api.github.com/users/joboet/gists{/gist_id}", "starred_url": "https://api.github.com/users/joboet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joboet/subscriptions", "organizations_url": "https://api.github.com/users/joboet/orgs", "repos_url": "https://api.github.com/users/joboet/repos", "events_url": "https://api.github.com/users/joboet/events{/privacy}", "received_events_url": "https://api.github.com/users/joboet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "joboet", "id": 25721079, "node_id": "MDQ6VXNlcjI1NzIxMDc5", "avatar_url": "https://avatars.githubusercontent.com/u/25721079?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joboet", "html_url": "https://github.com/joboet", "followers_url": "https://api.github.com/users/joboet/followers", "following_url": "https://api.github.com/users/joboet/following{/other_user}", "gists_url": "https://api.github.com/users/joboet/gists{/gist_id}", "starred_url": "https://api.github.com/users/joboet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joboet/subscriptions", "organizations_url": "https://api.github.com/users/joboet/orgs", "repos_url": "https://api.github.com/users/joboet/repos", "events_url": "https://api.github.com/users/joboet/events{/privacy}", "received_events_url": "https://api.github.com/users/joboet/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "098cf8802271eacdc463fa66c35da377926d4c4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/098cf8802271eacdc463fa66c35da377926d4c4e", "html_url": "https://github.com/rust-lang/rust/commit/098cf8802271eacdc463fa66c35da377926d4c4e"}], "stats": {"total": 148, "additions": 136, "deletions": 12}, "files": [{"sha": "e2453580dc72a62ffa3d2c60870426969de5e487", "filename": "library/std/src/sys/unix/thread_parker/mod.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/81b11ed6984f4cac4d2d8579dc0f694de024bb5a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81b11ed6984f4cac4d2d8579dc0f694de024bb5a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fmod.rs?ref=81b11ed6984f4cac4d2d8579dc0f694de024bb5a", "patch": "@@ -0,0 +1,21 @@\n+//! Thread parking on systems without futex support.\n+\n+#![cfg(not(any(\n+    target_os = \"linux\",\n+    target_os = \"android\",\n+    all(target_os = \"emscripten\", target_feature = \"atomics\"),\n+    target_os = \"freebsd\",\n+    target_os = \"openbsd\",\n+    target_os = \"dragonfly\",\n+    target_os = \"fuchsia\",\n+)))]\n+\n+cfg_if::cfg_if! {\n+    if #[cfg(target_os = \"netbsd\")] {\n+        mod netbsd;\n+        pub use netbsd::Parker;\n+    } else {\n+        mod pthread;\n+        pub use pthread::Parker;\n+    }\n+}"}, {"sha": "7657605b52f0d99d70db8599d5cb5d5b32d86be2", "filename": "library/std/src/sys/unix/thread_parker/netbsd.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/81b11ed6984f4cac4d2d8579dc0f694de024bb5a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fnetbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81b11ed6984f4cac4d2d8579dc0f694de024bb5a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fnetbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fnetbsd.rs?ref=81b11ed6984f4cac4d2d8579dc0f694de024bb5a", "patch": "@@ -0,0 +1,113 @@\n+use crate::ffi::{c_int, c_void};\n+use crate::pin::Pin;\n+use crate::ptr::{null, null_mut};\n+use crate::sync::atomic::{\n+    AtomicU64,\n+    Ordering::{Acquire, Relaxed, Release},\n+};\n+use crate::time::Duration;\n+use libc::{_lwp_self, clockid_t, lwpid_t, time_t, timespec, CLOCK_MONOTONIC};\n+\n+extern \"C\" {\n+    fn ___lwp_park60(\n+        clock_id: clockid_t,\n+        flags: c_int,\n+        ts: *mut timespec,\n+        unpark: lwpid_t,\n+        hint: *const c_void,\n+        unparkhint: *const c_void,\n+    ) -> c_int;\n+    fn _lwp_unpark(lwp: lwpid_t, hint: *const c_void) -> c_int;\n+}\n+\n+/// The thread is not parked and the token is not available.\n+///\n+/// Zero cannot be a valid LWP id, since it is used as empty value for the unpark\n+/// argument in _lwp_park.\n+const EMPTY: u64 = 0;\n+/// The token is available. Do not park anymore.\n+const NOTIFIED: u64 = u64::MAX;\n+\n+pub struct Parker {\n+    /// The parker state. Contains either one of the two state values above or the LWP\n+    /// id of the parked thread.\n+    state: AtomicU64,\n+}\n+\n+impl Parker {\n+    pub unsafe fn new(parker: *mut Parker) {\n+        parker.write(Parker { state: AtomicU64::new(EMPTY) })\n+    }\n+\n+    // Does not actually need `unsafe` or `Pin`, but the pthread implementation does.\n+    pub unsafe fn park(self: Pin<&Self>) {\n+        // If the token has already been made available, we can skip\n+        // a bit of work, so check for it here.\n+        if self.state.load(Acquire) != NOTIFIED {\n+            let parked = _lwp_self() as u64;\n+            let hint = self.state.as_mut_ptr().cast();\n+            if self.state.compare_exchange(EMPTY, parked, Relaxed, Acquire).is_ok() {\n+                // Loop to guard against spurious wakeups.\n+                loop {\n+                    ___lwp_park60(0, 0, null_mut(), 0, hint, null());\n+                    if self.state.load(Acquire) == NOTIFIED {\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        // At this point, the change to NOTIFIED has always been observed with acquire\n+        // ordering, so we can just use a relaxed store here (instead of a swap).\n+        self.state.store(EMPTY, Relaxed);\n+    }\n+\n+    // Does not actually need `unsafe` or `Pin`, but the pthread implementation does.\n+    pub unsafe fn park_timeout(self: Pin<&Self>, dur: Duration) {\n+        if self.state.load(Acquire) != NOTIFIED {\n+            let parked = _lwp_self() as u64;\n+            let hint = self.state.as_mut_ptr().cast();\n+            let mut timeout = timespec {\n+                // Saturate so that the operation will definitely time out\n+                // (even if it is after the heat death of the universe).\n+                tv_sec: dur.as_secs().try_into().ok().unwrap_or(time_t::MAX),\n+                tv_nsec: dur.subsec_nanos().into(),\n+            };\n+\n+            if self.state.compare_exchange(EMPTY, parked, Relaxed, Acquire).is_ok() {\n+                // Timeout needs to be mutable since it is modified on NetBSD 9.0 and\n+                // above.\n+                ___lwp_park60(CLOCK_MONOTONIC, 0, &mut timeout, 0, hint, null());\n+                // Use a swap to get acquire ordering even if the token was set after\n+                // the timeout occurred.\n+                self.state.swap(EMPTY, Acquire);\n+                return;\n+            }\n+        }\n+\n+        self.state.store(EMPTY, Relaxed);\n+    }\n+\n+    // Does not actually need `Pin`, but the pthread implementation does.\n+    pub fn unpark(self: Pin<&Self>) {\n+        let state = self.state.swap(NOTIFIED, Release);\n+        if !matches!(state, EMPTY | NOTIFIED) {\n+            let lwp = state as lwpid_t;\n+            let hint = self.state.as_mut_ptr().cast();\n+\n+            // If the parking thread terminated and did not actually park, this will\n+            // probably return an error, which is OK. In the worst case, another\n+            // thread has received the same LWP id. It will then receive a spurious\n+            // wakeup, but those are allowable per the API contract. The same reasoning\n+            // applies if a timeout occurred before this call, but the state was not\n+            // yet reset.\n+\n+            // SAFETY:\n+            // The syscall has no invariants to hold. Only unsafe because it is an\n+            // extern function.\n+            unsafe {\n+                _lwp_unpark(lwp, hint);\n+            }\n+        }\n+    }\n+}"}, {"sha": "3dfc0026ed1a43a219c51c870c5d402944913789", "filename": "library/std/src/sys/unix/thread_parker/pthread.rs", "status": "renamed", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/81b11ed6984f4cac4d2d8579dc0f694de024bb5a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fpthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81b11ed6984f4cac4d2d8579dc0f694de024bb5a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fpthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fpthread.rs?ref=81b11ed6984f4cac4d2d8579dc0f694de024bb5a", "patch": "@@ -1,15 +1,5 @@\n //! Thread parking without `futex` using the `pthread` synchronization primitives.\n \n-#![cfg(not(any(\n-    target_os = \"linux\",\n-    target_os = \"android\",\n-    all(target_os = \"emscripten\", target_feature = \"atomics\"),\n-    target_os = \"freebsd\",\n-    target_os = \"openbsd\",\n-    target_os = \"dragonfly\",\n-    target_os = \"fuchsia\",\n-)))]\n-\n use crate::cell::UnsafeCell;\n use crate::marker::PhantomPinned;\n use crate::pin::Pin;\n@@ -59,8 +49,8 @@ unsafe fn wait_timeout(\n         target_os = \"espidf\"\n     ))]\n     let (now, dur) = {\n-        use super::time::SystemTime;\n         use crate::cmp::min;\n+        use crate::sys::time::SystemTime;\n \n         // OSX implementation of `pthread_cond_timedwait` is buggy\n         // with super long durations. When duration is greater than\n@@ -85,7 +75,7 @@ unsafe fn wait_timeout(\n         target_os = \"espidf\"\n     )))]\n     let (now, dur) = {\n-        use super::time::Timespec;\n+        use crate::sys::time::Timespec;\n \n         (Timespec::now(libc::CLOCK_MONOTONIC), dur)\n     };", "previous_filename": "library/std/src/sys/unix/thread_parker.rs"}]}