{"sha": "fb5f51d3ebb2c6b119a7343037cbe780f1a3bf2c", "node_id": "C_kwDOAAsO6NoAKGZiNWY1MWQzZWJiMmM2YjExOWE3MzQzMDM3Y2JlNzgwZjFhM2JmMmM", "commit": {"author": {"name": "Elliot Bobrow", "email": "elliotgreybobrow@gmail.com", "date": "2022-01-16T17:17:22Z"}, "committer": {"name": "Elliot Bobrow", "email": "elliotgreybobrow@gmail.com", "date": "2022-01-16T17:20:33Z"}, "message": "fix op_ref false positive", "tree": {"sha": "3d640aa1851c281cfdcf24561d9a6c07b78fca5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d640aa1851c281cfdcf24561d9a6c07b78fca5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb5f51d3ebb2c6b119a7343037cbe780f1a3bf2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb5f51d3ebb2c6b119a7343037cbe780f1a3bf2c", "html_url": "https://github.com/rust-lang/rust/commit/fb5f51d3ebb2c6b119a7343037cbe780f1a3bf2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb5f51d3ebb2c6b119a7343037cbe780f1a3bf2c/comments", "author": {"login": "ebobrow", "id": 77182873, "node_id": "MDQ6VXNlcjc3MTgyODcz", "avatar_url": "https://avatars.githubusercontent.com/u/77182873?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebobrow", "html_url": "https://github.com/ebobrow", "followers_url": "https://api.github.com/users/ebobrow/followers", "following_url": "https://api.github.com/users/ebobrow/following{/other_user}", "gists_url": "https://api.github.com/users/ebobrow/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebobrow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebobrow/subscriptions", "organizations_url": "https://api.github.com/users/ebobrow/orgs", "repos_url": "https://api.github.com/users/ebobrow/repos", "events_url": "https://api.github.com/users/ebobrow/events{/privacy}", "received_events_url": "https://api.github.com/users/ebobrow/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ebobrow", "id": 77182873, "node_id": "MDQ6VXNlcjc3MTgyODcz", "avatar_url": "https://avatars.githubusercontent.com/u/77182873?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebobrow", "html_url": "https://github.com/ebobrow", "followers_url": "https://api.github.com/users/ebobrow/followers", "following_url": "https://api.github.com/users/ebobrow/following{/other_user}", "gists_url": "https://api.github.com/users/ebobrow/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebobrow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebobrow/subscriptions", "organizations_url": "https://api.github.com/users/ebobrow/orgs", "repos_url": "https://api.github.com/users/ebobrow/repos", "events_url": "https://api.github.com/users/ebobrow/events{/privacy}", "received_events_url": "https://api.github.com/users/ebobrow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88f5be2041acca3da00648ffc10846dab25cfb5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/88f5be2041acca3da00648ffc10846dab25cfb5f", "html_url": "https://github.com/rust-lang/rust/commit/88f5be2041acca3da00648ffc10846dab25cfb5f"}], "stats": {"total": 126, "additions": 123, "deletions": 3}, "files": [{"sha": "24d7613e6f8ca6d2061d3d3c3c1e2c6958a9a983", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 68, "deletions": 1, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/fb5f51d3ebb2c6b119a7343037cbe780f1a3bf2c/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5f51d3ebb2c6b119a7343037cbe780f1a3bf2c/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=fb5f51d3ebb2c6b119a7343037cbe780f1a3bf2c", "patch": "@@ -1,12 +1,16 @@\n use clippy_utils::diagnostics::{multispan_sugg, span_lint, span_lint_and_then};\n+use clippy_utils::get_enclosing_block;\n use clippy_utils::macros::{find_assert_eq_args, first_node_macro_backtrace};\n use clippy_utils::source::snippet;\n use clippy_utils::ty::{implements_trait, is_copy};\n use clippy_utils::{ast_utils::is_useless_with_eq_exprs, eq_expr_value, is_in_test_function};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind};\n+use rustc_hir::{\n+    def::Res, def_id::DefId, BinOpKind, BorrowKind, Expr, ExprKind, GenericArg, ItemKind, QPath, Ty, TyKind,\n+};\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::{self, TyS};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n@@ -146,6 +150,13 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n                         let rty = cx.typeck_results().expr_ty(r);\n                         let lcpy = is_copy(cx, lty);\n                         let rcpy = is_copy(cx, rty);\n+                        if let Some((self_ty, other_ty)) = in_impl(cx, e, trait_id) {\n+                            if (are_equal(cx, rty, self_ty) && are_equal(cx, lty, other_ty))\n+                                || (are_equal(cx, rty, other_ty) && are_equal(cx, lty, self_ty))\n+                            {\n+                                return; // Don't lint\n+                            }\n+                        }\n                         // either operator autorefs or both args are copyable\n                         if (requires_ref || (lcpy && rcpy)) && implements_trait(cx, lty, trait_id, &[rty.into()]) {\n                             span_lint_and_then(\n@@ -206,6 +217,14 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n                     // &foo == bar\n                     (&ExprKind::AddrOf(BorrowKind::Ref, _, l), _) => {\n                         let lty = cx.typeck_results().expr_ty(l);\n+                        if let Some((self_ty, other_ty)) = in_impl(cx, e, trait_id) {\n+                            let rty = cx.typeck_results().expr_ty(right);\n+                            if (are_equal(cx, rty, self_ty) && are_equal(cx, lty, other_ty))\n+                                || (are_equal(cx, rty, other_ty) && are_equal(cx, lty, self_ty))\n+                            {\n+                                return; // Don't lint\n+                            }\n+                        }\n                         let lcpy = is_copy(cx, lty);\n                         if (requires_ref || lcpy)\n                             && implements_trait(cx, lty, trait_id, &[cx.typeck_results().expr_ty(right).into()])\n@@ -230,6 +249,14 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n                     // foo == &bar\n                     (_, &ExprKind::AddrOf(BorrowKind::Ref, _, r)) => {\n                         let rty = cx.typeck_results().expr_ty(r);\n+                        if let Some((self_ty, other_ty)) = in_impl(cx, e, trait_id) {\n+                            let lty = cx.typeck_results().expr_ty(left);\n+                            if (are_equal(cx, rty, self_ty) && are_equal(cx, lty, other_ty))\n+                                || (are_equal(cx, rty, other_ty) && are_equal(cx, lty, self_ty))\n+                            {\n+                                return; // Don't lint\n+                            }\n+                        }\n                         let rcpy = is_copy(cx, rty);\n                         if (requires_ref || rcpy)\n                             && implements_trait(cx, cx.typeck_results().expr_ty(left), trait_id, &[rty.into()])\n@@ -251,3 +278,43 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n         }\n     }\n }\n+\n+fn in_impl<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, bin_op: DefId) -> Option<(&'tcx Ty<'tcx>, &'tcx Ty<'tcx>)> {\n+    if_chain! {\n+        if let Some(block) = get_enclosing_block(cx, e.hir_id);\n+        if let Some(impl_def_id) = cx.tcx.impl_of_method(block.hir_id.owner.to_def_id());\n+        let item = cx.tcx.hir().expect_item(impl_def_id.expect_local());\n+        if let ItemKind::Impl(item) = &item.kind;\n+        if let Some(of_trait) = &item.of_trait;\n+        if let Some(seg) = of_trait.path.segments.last();\n+        if let Some(Res::Def(_, trait_id)) = seg.res;\n+        if trait_id == bin_op;\n+        if let Some(generic_args) = seg.args;\n+        if let Some(GenericArg::Type(other_ty)) = generic_args.args.last();\n+\n+        then {\n+            Some((item.self_ty, other_ty))\n+        }\n+        else {\n+            None\n+        }\n+    }\n+}\n+\n+fn are_equal<'tcx>(cx: &LateContext<'tcx>, middle_ty: &TyS<'_>, hir_ty: &Ty<'_>) -> bool {\n+    if_chain! {\n+        if let ty::Adt(adt_def, _) = middle_ty.kind();\n+        if let Some(local_did) = adt_def.did.as_local();\n+        let item = cx.tcx.hir().expect_item(local_did);\n+        let middle_ty_id = item.def_id.to_def_id();\n+        if let TyKind::Path(QPath::Resolved(_, path)) = hir_ty.kind;\n+        if let Res::Def(_, hir_ty_id) = path.res;\n+\n+        then {\n+            hir_ty_id == middle_ty_id\n+        }\n+        else {\n+            false\n+        }\n+    }\n+}"}, {"sha": "d8bf66603d9f5840f4878552bf4b34f4d62c5379", "filename": "tests/ui/op_ref.rs", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/fb5f51d3ebb2c6b119a7343037cbe780f1a3bf2c/tests%2Fui%2Fop_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5f51d3ebb2c6b119a7343037cbe780f1a3bf2c/tests%2Fui%2Fop_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fop_ref.rs?ref=fb5f51d3ebb2c6b119a7343037cbe780f1a3bf2c", "patch": "@@ -1,7 +1,7 @@\n #![allow(unused_variables, clippy::blacklisted_name)]\n #![warn(clippy::op_ref)]\n use std::collections::HashSet;\n-use std::ops::BitAnd;\n+use std::ops::{BitAnd, Mul};\n \n fn main() {\n     let tracked_fds: HashSet<i32> = HashSet::new();\n@@ -55,3 +55,40 @@ fn main() {\n     let y = Y(2);\n     let z = x & &y;\n }\n+\n+#[derive(Clone, Copy)]\n+struct A(i32);\n+#[derive(Clone, Copy)]\n+struct B(i32);\n+\n+impl Mul<&A> for B {\n+    type Output = i32;\n+    fn mul(self, rhs: &A) -> Self::Output {\n+        self.0 * rhs.0\n+    }\n+}\n+impl Mul<A> for B {\n+    type Output = i32;\n+    fn mul(self, rhs: A) -> Self::Output {\n+        // Should not lint because removing the reference would lead to unconditional recursion\n+        self * &rhs\n+    }\n+}\n+impl Mul<&A> for A {\n+    type Output = i32;\n+    fn mul(self, rhs: &A) -> Self::Output {\n+        self.0 * rhs.0\n+    }\n+}\n+impl Mul<A> for A {\n+    type Output = i32;\n+    fn mul(self, rhs: A) -> Self::Output {\n+        let one = B(1);\n+        let two = 2;\n+        let three = 3;\n+        let _ = one * &self;\n+        let _ = two + &three;\n+        // Removing the reference would lead to unconditional recursion\n+        self * &rhs\n+    }\n+}"}, {"sha": "fe36c01166ff714c959a9abcdae7f7a1ec6ed51d", "filename": "tests/ui/op_ref.stderr", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fb5f51d3ebb2c6b119a7343037cbe780f1a3bf2c/tests%2Fui%2Fop_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb5f51d3ebb2c6b119a7343037cbe780f1a3bf2c/tests%2Fui%2Fop_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fop_ref.stderr?ref=fb5f51d3ebb2c6b119a7343037cbe780f1a3bf2c", "patch": "@@ -18,5 +18,21 @@ LL |     let z = x & &y;\n    |                 |\n    |                 help: use the right value directly: `y`\n \n-error: aborting due to 2 previous errors\n+error: taken reference of right operand\n+  --> $DIR/op_ref.rs:89:17\n+   |\n+LL |         let _ = one * &self;\n+   |                 ^^^^^^-----\n+   |                       |\n+   |                       help: use the right value directly: `self`\n+\n+error: taken reference of right operand\n+  --> $DIR/op_ref.rs:90:17\n+   |\n+LL |         let _ = two + &three;\n+   |                 ^^^^^^------\n+   |                       |\n+   |                       help: use the right value directly: `three`\n+\n+error: aborting due to 4 previous errors\n "}]}