{"sha": "cac133c9a86a4687755aeb44908e3fbb2bb35fc2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhYzEzM2M5YTg2YTQ2ODc3NTVhZWI0NDkwOGUzZmJiMmJiMzVmYzI=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-11-25T16:52:10Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-12-19T07:31:35Z"}, "message": "Introduce std::thread\n\nAlso removes:\n\n* `std::task`\n* `std::rt::task`\n* `std::rt::thread`\n\nNotes for the new API are in a follow-up commit.\n\nCloses #18000", "tree": {"sha": "91736549f0fd24edb154fa21a54d8bfdca418ef0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91736549f0fd24edb154fa21a54d8bfdca418ef0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cac133c9a86a4687755aeb44908e3fbb2bb35fc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cac133c9a86a4687755aeb44908e3fbb2bb35fc2", "html_url": "https://github.com/rust-lang/rust/commit/cac133c9a86a4687755aeb44908e3fbb2bb35fc2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cac133c9a86a4687755aeb44908e3fbb2bb35fc2/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b03b72d7fb82f07d35e7dcda02754c6da90ae58", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b03b72d7fb82f07d35e7dcda02754c6da90ae58", "html_url": "https://github.com/rust-lang/rust/commit/9b03b72d7fb82f07d35e7dcda02754c6da90ae58"}], "stats": {"total": 1462, "additions": 742, "deletions": 720}, "files": [{"sha": "a0939999c7c19945477bbe3053095bc180f9c47e", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cac133c9a86a4687755aeb44908e3fbb2bb35fc2/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac133c9a86a4687755aeb44908e3fbb2bb35fc2/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=cac133c9a86a4687755aeb44908e3fbb2bb35fc2", "patch": "@@ -227,9 +227,9 @@ pub mod time;\n pub mod collections;\n pub mod hash;\n \n-/* Tasks and communication */\n+/* Threads and communication */\n \n-pub mod task;\n+pub mod thread;\n pub mod sync;\n pub mod comm;\n "}, {"sha": "eff80b5ab2f7bc50f5617019527d307c7cf839dd", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cac133c9a86a4687755aeb44908e3fbb2bb35fc2/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac133c9a86a4687755aeb44908e3fbb2bb35fc2/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=cac133c9a86a4687755aeb44908e3fbb2bb35fc2", "patch": "@@ -53,7 +53,9 @@ use failure;\n use os;\n use thunk::Thunk;\n use kinds::Send;\n+use thread::Thread;\n use sys_common;\n+use sys_common::thread::{mod, NewThread};\n \n // Reexport some of our utilities which are expected by other crates.\n pub use self::util::{default_sched_threads, min_stack, running_on_valgrind};\n@@ -73,8 +75,6 @@ pub mod mutex;\n pub mod thread;\n pub mod exclusive;\n pub mod util;\n-pub mod local;\n-pub mod task;\n pub mod unwind;\n \n mod args;\n@@ -98,8 +98,8 @@ pub fn init(argc: int, argv: *const *const u8) {\n     // Need to propagate the unsafety to `start`.\n     unsafe {\n         args::init(argc, argv);\n-        local_ptr::init();\n-        thread::init();\n+        sys::thread::guard::init();\n+        sys::stack_overflow::init();\n         unwind::register(failure::on_fail);\n     }\n }\n@@ -125,9 +125,6 @@ fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int {\n /// This procedure is guaranteed to run on the thread calling this function, but\n /// the stack bounds for this rust task will *not* be set. Care must be taken\n /// for this function to not overflow its stack.\n-///\n-/// This function will only return once *all* native threads in the system have\n-/// exited.\n pub fn start(argc: int, argv: *const *const u8, main: Thunk) -> int {\n     use prelude::*;\n     use rt;\n@@ -143,11 +140,9 @@ pub fn start(argc: int, argv: *const *const u8, main: Thunk) -> int {\n     // frames above our current position.\n     let my_stack_bottom = my_stack_top + 20000 - OS_DEFAULT_STACK_ESTIMATE;\n \n-    // When using libgreen, one of the first things that we do is to turn off\n-    // the SIGPIPE signal (set it to ignore). By default, some platforms will\n-    // send a *signal* when a EPIPE error would otherwise be delivered. This\n-    // runtime doesn't install a SIGPIPE handler, causing it to kill the\n-    // program, which isn't exactly what we want!\n+    // By default, some platforms will send a *signal* when a EPIPE error would\n+    // otherwise be delivered. This runtime doesn't install a SIGPIPE handler,\n+    // causing it to kill the program, which isn't exactly what we want!\n     //\n     // Hence, we set SIGPIPE to ignore when the program starts up in order to\n     // prevent this problem.\n@@ -163,17 +158,18 @@ pub fn start(argc: int, argv: *const *const u8, main: Thunk) -> int {\n \n     init(argc, argv);\n     let mut exit_code = None;\n-    let mut main = Some(main);\n-    let mut task = box Task::new(Some((my_stack_bottom, my_stack_top)),\n-                                 Some(rt::thread::main_guard_page()));\n-    task.name = Some(str::Slice(\"<main>\"));\n-    drop(task.run(|| {\n+\n+    let thread: std::Thread = NewThread::new(Some(\"<main>\".into_string()));\n+    thread_info::set((my_stack_bottom, my_stack_top),\n+                     unsafe { sys::thread::guard::main() },\n+                     thread);\n+    unwind::try(|| {\n         unsafe {\n             sys_common::stack::record_os_managed_stack_bounds(my_stack_bottom, my_stack_top);\n         }\n         (main.take().unwrap()).invoke(());\n         exit_code = Some(os::get_exit_status());\n-    }).destroy());\n+    });\n     unsafe { cleanup(); }\n     // If the exit code wasn't set, then the task block must have panicked.\n     return exit_code.unwrap_or(rt::DEFAULT_ERROR_CODE);\n@@ -207,8 +203,7 @@ pub fn at_exit(f: proc():Send) {\n /// undefined behavior.\n pub unsafe fn cleanup() {\n     args::cleanup();\n-    thread::cleanup();\n-    local_ptr::cleanup();\n+    sys::stack_overflow::cleanup();\n }\n \n // FIXME: these probably shouldn't be public..."}, {"sha": "c10338b1bceb2f406084a6a1e002467f56874c39", "filename": "src/libstd/rt/thread.rs", "status": "removed", "additions": 0, "deletions": 171, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/9b03b72d7fb82f07d35e7dcda02754c6da90ae58/src%2Flibstd%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b03b72d7fb82f07d35e7dcda02754c6da90ae58/src%2Flibstd%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread.rs?ref=9b03b72d7fb82f07d35e7dcda02754c6da90ae58", "patch": "@@ -1,171 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Native os-thread management\n-//!\n-//! This modules contains bindings necessary for managing OS-level threads.\n-//! These functions operate outside of the rust runtime, creating threads\n-//! which are not used for scheduling in any way.\n-\n-#![allow(non_camel_case_types)]\n-\n-use core::prelude::*;\n-\n-use boxed::Box;\n-use mem;\n-use sys::stack_overflow;\n-use sys::thread as imp;\n-\n-pub unsafe fn init() {\n-    imp::guard::init();\n-    stack_overflow::init();\n-}\n-\n-pub unsafe fn cleanup() {\n-    stack_overflow::cleanup();\n-}\n-\n-/// This struct represents a native thread's state. This is used to join on an\n-/// existing thread created in the join-able state.\n-pub struct Thread<T> {\n-    native: imp::rust_thread,\n-    joined: bool,\n-    packet: Box<Option<T>>,\n-}\n-\n-static DEFAULT_STACK_SIZE: uint = 1024 * 1024;\n-\n-/// Returns the last writable byte of the main thread's stack next to the guard\n-/// page. Must be called from the main thread.\n-pub fn main_guard_page() -> uint {\n-    unsafe {\n-        imp::guard::main()\n-    }\n-}\n-\n-/// Returns the last writable byte of the current thread's stack next to the\n-/// guard page. Must not be called from the main thread.\n-pub fn current_guard_page() -> uint {\n-    unsafe {\n-        imp::guard::current()\n-    }\n-}\n-\n-// There are two impl blocks b/c if T were specified at the top then it's just a\n-// pain to specify a type parameter on Thread::spawn (which doesn't need the\n-// type parameter).\n-impl Thread<()> {\n-\n-    /// Starts execution of a new OS thread.\n-    ///\n-    /// This function will not wait for the thread to join, but a handle to the\n-    /// thread will be returned.\n-    ///\n-    /// Note that the handle returned is used to acquire the return value of the\n-    /// procedure `main`. The `join` function will wait for the thread to finish\n-    /// and return the value that `main` generated.\n-    ///\n-    /// Also note that the `Thread` returned will *always* wait for the thread\n-    /// to finish executing. This means that even if `join` is not explicitly\n-    /// called, when the `Thread` falls out of scope its destructor will block\n-    /// waiting for the OS thread.\n-    pub fn start<T: Send>(main: proc():Send -> T) -> Thread<T> {\n-        Thread::start_stack(DEFAULT_STACK_SIZE, main)\n-    }\n-\n-    /// Performs the same functionality as `start`, but specifies an explicit\n-    /// stack size for the new thread.\n-    pub fn start_stack<T: Send>(stack: uint, main: proc():Send -> T) -> Thread<T> {\n-\n-        // We need the address of the packet to fill in to be stable so when\n-        // `main` fills it in it's still valid, so allocate an extra box to do\n-        // so.\n-        let packet = box None;\n-        let packet2: *mut Option<T> = unsafe {\n-            *mem::transmute::<&Box<Option<T>>, *const *mut Option<T>>(&packet)\n-        };\n-        let main = proc() unsafe { *packet2 = Some(main()); };\n-        let native = unsafe { imp::create(stack, box main) };\n-\n-        Thread {\n-            native: native,\n-            joined: false,\n-            packet: packet,\n-        }\n-    }\n-\n-    /// This will spawn a new thread, but it will not wait for the thread to\n-    /// finish, nor is it possible to wait for the thread to finish.\n-    ///\n-    /// This corresponds to creating threads in the 'detached' state on unix\n-    /// systems. Note that platforms may not keep the main program alive even if\n-    /// there are detached thread still running around.\n-    pub fn spawn(main: proc():Send) {\n-        Thread::spawn_stack(DEFAULT_STACK_SIZE, main)\n-    }\n-\n-    /// Performs the same functionality as `spawn`, but explicitly specifies a\n-    /// stack size for the new thread.\n-    pub fn spawn_stack(stack: uint, main: proc():Send) {\n-        unsafe {\n-            let handle = imp::create(stack, box main);\n-            imp::detach(handle);\n-        }\n-    }\n-\n-    /// Relinquishes the CPU slot that this OS-thread is currently using,\n-    /// allowing another thread to run for awhile.\n-    pub fn yield_now() {\n-        unsafe { imp::yield_now(); }\n-    }\n-}\n-\n-impl<T: Send> Thread<T> {\n-    /// Wait for this thread to finish, returning the result of the thread's\n-    /// calculation.\n-    pub fn join(mut self) -> T {\n-        assert!(!self.joined);\n-        unsafe { imp::join(self.native) };\n-        self.joined = true;\n-        assert!(self.packet.is_some());\n-        self.packet.take().unwrap()\n-    }\n-}\n-\n-#[unsafe_destructor]\n-impl<T: Send> Drop for Thread<T> {\n-    fn drop(&mut self) {\n-        // This is required for correctness. If this is not done then the thread\n-        // would fill in a return box which no longer exists.\n-        if !self.joined {\n-            unsafe { imp::join(self.native) };\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::Thread;\n-\n-    #[test]\n-    fn smoke() { Thread::start(proc (){}).join(); }\n-\n-    #[test]\n-    fn data() { assert_eq!(Thread::start(proc () { 1i }).join(), 1); }\n-\n-    #[test]\n-    fn detached() { Thread::spawn(proc () {}) }\n-\n-    #[test]\n-    fn small_stacks() {\n-        assert_eq!(42i, Thread::start_stack(0, proc () 42i).join());\n-        assert_eq!(42i, Thread::start_stack(1, proc () 42i).join());\n-    }\n-}"}, {"sha": "fb0231b44ba739d43f11ed3df5ee17a8e28a4aae", "filename": "src/libstd/sys/common/thread_info.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/cac133c9a86a4687755aeb44908e3fbb2bb35fc2/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac133c9a86a4687755aeb44908e3fbb2bb35fc2/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs?ref=cac133c9a86a4687755aeb44908e3fbb2bb35fc2", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct ThreadInfo {\n+    // This field holds the known bounds of the stack in (lo, hi)\n+    // form. Not all threads necessarily know their precise bounds,\n+    // hence this is optional.\n+    stack_bounds: (uint, uint),\n+    stack_guard: uint,\n+    unwinder: Unwinder,\n+    thread: Thread,\n+}\n+\n+thread_local!(static THREAD_INFO: RefCell<Option<ThreadInfo>> = RefCell::new(None));\n+\n+impl ThreadInfo {\n+    fn with<R>(f: |&ThreadInfo| -> R) -> R {\n+        THREAD_INFO.with(|c| {\n+            if c.borrow().is_none() {\n+                *c.borrow_mut() = Some(ThreadInfo {\n+                    stack_bounds: (0, 0),\n+                    stack_guard: 0,\n+                    unwinder: Unwinder::new(),\n+                    thread: Thread::new(None),\n+                })\n+            }\n+            f(c.borrow().as_ref().unwrap())\n+        })\n+    }\n+}\n+\n+pub fn current_thread() -> Thread {\n+    ThreadInfo::with(|info| info.thread.clone())\n+}\n+\n+pub fn panicking() -> bool {\n+    ThreadInfo::with(|info| info.unwinder.unwinding())\n+}\n+\n+pub fn set(stack_bounds: (uint, uint), stack_guard: uint, thread: Thread) {\n+    THREAD_INFO.with(|c| assert!(c.borrow().is_none()));\n+    THREAD_INFO.with(|c| *c.borrow_mut() = Some(ThreadInfo{\n+        stack_bounds: stack_bounds,\n+        stack_guard: stack_guard,\n+        unwinder: Unwinder::new(),\n+        thread: thread,\n+    }));\n+}\n+\n+// a hack to get around privacy restrictions; implemented by `std::thread::Thread`\n+pub trait NewThread {\n+    fn new(name: Option<String>) -> Self;\n+}"}, {"sha": "6881a1adb25fb59de8c31e05777b9584b4d8b6db", "filename": "src/libstd/task.rs", "status": "modified", "additions": 10, "deletions": 527, "changes": 537, "blob_url": "https://github.com/rust-lang/rust/blob/cac133c9a86a4687755aeb44908e3fbb2bb35fc2/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac133c9a86a4687755aeb44908e3fbb2bb35fc2/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=cac133c9a86a4687755aeb44908e3fbb2bb35fc2", "patch": "@@ -8,536 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Task creation\n-//!\n-//! An executing Rust program consists of a collection of tasks, each\n-//! with their own stack and local state.\n-//!\n-//! Tasks generally have their memory *isolated* from each other by\n-//! virtue of Rust's owned types (which of course may only be owned by\n-//! a single task at a time). Communication between tasks is primarily\n-//! done through [channels](../../std/comm/index.html), Rust's\n-//! message-passing types, though [other forms of task\n-//! synchronization](../../std/sync/index.html) are often employed to\n-//! achieve particular performance goals. In particular, types that\n-//! are guaranteed to be threadsafe are easily shared between threads\n-//! using the atomically-reference-counted container,\n-//! [`Arc`](../../std/sync/struct.Arc.html).\n-//!\n-//! Fatal logic errors in Rust cause *task panic*, during which\n-//! a task will unwind the stack, running destructors and freeing\n-//! owned resources. Task panic is unrecoverable from within\n-//! the panicking task (i.e. there is no 'try/catch' in Rust), but\n-//! panic may optionally be detected from a different task. If\n-//! the main task panics the application will exit with a non-zero\n-//! exit code.\n-//!\n-//! # Examples\n-//!\n-//! ```rust\n-//! spawn(move|| {\n-//!     println!(\"Hello, World!\");\n-//! })\n-//! ```\n+//! Deprecated in favor of `thread`.\n \n-#![unstable = \"The task spawning model will be changed as part of runtime reform, and the module \\\n-               will likely be renamed from `task` to `thread`.\"]\n+#![deprecated = \"use std::thread instead\"]\n \n-use any::Any;\n-use borrow::IntoCow;\n-use boxed::Box;\n-use comm::channel;\n-use core::ops::FnOnce;\n-use io::{Writer, stdio};\n+use thread;\n use kinds::Send;\n-use option::Option;\n-use option::Option::{None, Some};\n-use result::Result;\n-use rt::local::Local;\n-use rt::task;\n-use rt::task::Task;\n-use str::SendStr;\n-use string::{String, ToString};\n-use thunk::{Thunk};\n-use sync::Future;\n \n-/// The task builder type.\n-///\n-/// Provides detailed control over the properties and behavior of new tasks.\n+/// Deprecate: use `std::thread::Cfg` instead.\n+#[deprecated = \"use std::thread::Cfg instead\"]\n+pub type TaskBuilder = thread::Cfg;\n \n-// NB: Builders are designed to be single-use because they do stateful\n-// things that get weird when reusing - e.g. if you create a result future\n-// it only applies to a single task, so then you have to maintain Some\n-// potentially tricky state to ensure that everything behaves correctly\n-// when you try to reuse the builder to spawn a new task. We'll just\n-// sidestep that whole issue by making builders uncopyable and making\n-// the run function move them in.\n-pub struct TaskBuilder {\n-    // A name for the task-to-be, for identification in panic messages\n-    name: Option<SendStr>,\n-    // The size of the stack for the spawned task\n-    stack_size: Option<uint>,\n-    // Task-local stdout\n-    stdout: Option<Box<Writer + Send>>,\n-    // Task-local stderr\n-    stderr: Option<Box<Writer + Send>>,\n-    // Optionally wrap the eventual task body\n-    gen_body: Option<Thunk<Thunk, Thunk>>,\n-}\n-\n-impl TaskBuilder {\n-    /// Generate the base configuration for spawning a task, off of which more\n-    /// configuration methods can be chained.\n-    pub fn new() -> TaskBuilder {\n-        TaskBuilder {\n-            name: None,\n-            stack_size: None,\n-            stdout: None,\n-            stderr: None,\n-            gen_body: None,\n-        }\n-    }\n-}\n-\n-impl TaskBuilder {\n-    /// Name the task-to-be. Currently the name is used for identification\n-    /// only in panic messages.\n-    #[unstable = \"IntoMaybeOwned will probably change.\"]\n-    pub fn named<T: IntoCow<'static, String, str>>(mut self, name: T) -> TaskBuilder {\n-        self.name = Some(name.into_cow());\n-        self\n-    }\n-\n-    /// Set the size of the stack for the new task.\n-    pub fn stack_size(mut self, size: uint) -> TaskBuilder {\n-        self.stack_size = Some(size);\n-        self\n-    }\n-\n-    /// Redirect task-local stdout.\n-    #[experimental = \"May not want to make stdio overridable here.\"]\n-    pub fn stdout(mut self, stdout: Box<Writer + Send>) -> TaskBuilder {\n-        self.stdout = Some(stdout);\n-        self\n-    }\n-\n-    /// Redirect task-local stderr.\n-    #[experimental = \"May not want to make stdio overridable here.\"]\n-    pub fn stderr(mut self, stderr: Box<Writer + Send>) -> TaskBuilder {\n-        self.stderr = Some(stderr);\n-        self\n-    }\n-\n-    // Where spawning actually happens (whether yielding a future or not)\n-    fn spawn_internal(\n-        self,\n-        f: Thunk,\n-        on_exit: Option<Thunk<task::Result>>)\n-    {\n-        let TaskBuilder {\n-            name, stack_size, stdout, stderr, mut gen_body\n-        } = self;\n-\n-        let f = match gen_body.take() {\n-            Some(gen) => gen.invoke(f),\n-            None => f\n-        };\n-\n-        let opts = task::TaskOpts {\n-            on_exit: on_exit,\n-            name: name,\n-            stack_size: stack_size,\n-        };\n-        if stdout.is_some() || stderr.is_some() {\n-            Task::spawn(opts, move|:| {\n-                let _ = stdout.map(stdio::set_stdout);\n-                let _ = stderr.map(stdio::set_stderr);\n-                f.invoke(());\n-            });\n-        } else {\n-            Task::spawn(opts, move|:| f.invoke(()))\n-        }\n-    }\n-\n-    /// Creates and executes a new child task.\n-    ///\n-    /// Sets up a new task with its own call stack and schedules it to run\n-    /// the provided function. The task has the properties and behavior\n-    /// specified by the `TaskBuilder`.\n-    pub fn spawn<F:FnOnce()+Send>(self, f: F) {\n-        self.spawn_internal(Thunk::new(f), None)\n-    }\n-\n-    /// Execute a function in a newly-spawned task and return a future representing\n-    /// the task's result. The task has the properties and behavior\n-    /// specified by the `TaskBuilder`.\n-    ///\n-    /// Taking the value of the future will block until the child task\n-    /// terminates.\n-    ///\n-    /// # Return value\n-    ///\n-    /// If the child task executes successfully (without panicking) then the\n-    /// future returns `result::Result::Ok` containing the value returned by the\n-    /// function. If the child task panics then the future returns\n-    /// `result::Result::Err` containing the argument to `panic!(...)` as an\n-    /// `Any` trait object.\n-    #[experimental = \"Futures are experimental.\"]\n-    pub fn try_future<T:Send,F:FnOnce()->(T)+Send>(self, f: F)\n-                                                   -> Future<Result<T, Box<Any + Send>>> {\n-        // currently, the on_exit fn provided by librustrt only works for unit\n-        // results, so we use an additional side-channel to communicate the\n-        // result.\n-\n-        let (tx_done, rx_done) = channel(); // signal that task has exited\n-        let (tx_retv, rx_retv) = channel(); // return value from task\n-\n-        let on_exit: Thunk<task::Result> = Thunk::with_arg(move |: res: task::Result| {\n-            let _ = tx_done.send_opt(res);\n-        });\n-        self.spawn_internal(Thunk::new(move |:| { let _ = tx_retv.send_opt(f()); }),\n-                            Some(on_exit));\n-\n-        Future::from_fn(move|:| {\n-            rx_done.recv().map(|_| rx_retv.recv())\n-        })\n-    }\n-\n-    /// Execute a function in a newly-spawnedtask and block until the task\n-    /// completes or panics. Equivalent to `.try_future(f).unwrap()`.\n-    #[unstable = \"Error type may change.\"]\n-    pub fn try<T,F>(self, f: F) -> Result<T, Box<Any + Send>>\n-        where F : FnOnce() -> T, F : Send, T : Send\n-    {\n-        self.try_future(f).into_inner()\n-    }\n-}\n-\n-/* Convenience functions */\n-\n-/// Creates and executes a new child task\n-///\n-/// Sets up a new task with its own call stack and schedules it to run\n-/// the provided unique closure.\n-///\n-/// This function is equivalent to `TaskBuilder::new().spawn(f)`.\n-pub fn spawn<F:FnOnce()+Send>(f: F) {\n-    TaskBuilder::new().spawn(f)\n-}\n-\n-/// Execute a function in a newly-spawned task and return either the return\n-/// value of the function or an error if the task panicked.\n-///\n-/// This is equivalent to `TaskBuilder::new().try`.\n-#[unstable = \"Error type may change.\"]\n-pub fn try<T,F>(f: F) -> Result<T, Box<Any + Send>>\n-    where T : Send, F : FnOnce() -> T, F : Send\n-{\n-    TaskBuilder::new().try(f)\n-}\n-\n-/// Execute a function in another task and return a future representing the\n-/// task's result.\n-///\n-/// This is equivalent to `TaskBuilder::new().try_future`.\n-#[experimental = \"Futures are experimental.\"]\n-pub fn try_future<T,F>(f: F) -> Future<Result<T, Box<Any + Send>>>\n-    where T:Send, F:FnOnce()->T, F:Send\n-{\n-    TaskBuilder::new().try_future(f)\n-}\n-\n-/* Lifecycle functions */\n-\n-/// Read the name of the current task.\n-#[stable]\n-pub fn name() -> Option<String> {\n-    use rt::task::Task;\n-\n-    let task = Local::borrow(None::<Task>);\n-    match task.name {\n-        Some(ref name) => Some(name.to_string()),\n-        None => None\n-    }\n-}\n-\n-/// Yield control to the task scheduler.\n-#[unstable = \"Name will change.\"]\n-pub fn deschedule() {\n-    use rt::task::Task;\n-    Task::yield_now();\n-}\n-\n-/// True if the running task is currently panicking (e.g. will return `true` inside a\n-/// destructor that is run while unwinding the stack after a call to `panic!()`).\n-#[unstable = \"May move to a different module.\"]\n-pub fn failing() -> bool {\n-    use rt::task::Task;\n-    Local::borrow(None::<Task>).unwinder.unwinding()\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use any::{Any, AnyRefExt};\n-    use borrow::IntoCow;\n-    use boxed::BoxAny;\n-    use prelude::*;\n-    use result::Result::{Ok, Err};\n-    use result;\n-    use std::io::{ChanReader, ChanWriter};\n-    use string::String;\n-    use thunk::Thunk;\n-    use prelude::*;\n-    use super::*;\n-\n-    // !!! These tests are dangerous. If something is buggy, they will hang, !!!\n-    // !!! instead of exiting cleanly. This might wedge the buildbots.       !!!\n-\n-    #[test]\n-    fn test_unnamed_task() {\n-        try(move|| {\n-            assert!(name().is_none());\n-        }).map_err(|_| ()).unwrap();\n-    }\n-\n-    #[test]\n-    fn test_owned_named_task() {\n-        TaskBuilder::new().named(\"ada lovelace\".to_string()).try(move|| {\n-            assert!(name().unwrap() == \"ada lovelace\");\n-        }).map_err(|_| ()).unwrap();\n-    }\n-\n-    #[test]\n-    fn test_static_named_task() {\n-        TaskBuilder::new().named(\"ada lovelace\").try(move|| {\n-            assert!(name().unwrap() == \"ada lovelace\");\n-        }).map_err(|_| ()).unwrap();\n-    }\n-\n-    #[test]\n-    fn test_send_named_task() {\n-        TaskBuilder::new().named(\"ada lovelace\".into_cow()).try(move|| {\n-            assert!(name().unwrap() == \"ada lovelace\");\n-        }).map_err(|_| ()).unwrap();\n-    }\n-\n-    #[test]\n-    fn test_run_basic() {\n-        let (tx, rx) = channel();\n-        TaskBuilder::new().spawn(move|| {\n-            tx.send(());\n-        });\n-        rx.recv();\n-    }\n-\n-    #[test]\n-    fn test_try_future() {\n-        let result = TaskBuilder::new().try_future(move|| {});\n-        assert!(result.unwrap().is_ok());\n-\n-        let result = TaskBuilder::new().try_future(move|| -> () {\n-            panic!();\n-        });\n-        assert!(result.unwrap().is_err());\n-    }\n-\n-    #[test]\n-    fn test_try_success() {\n-        match try(move|| {\n-            \"Success!\".to_string()\n-        }).as_ref().map(|s| s.as_slice()) {\n-            result::Result::Ok(\"Success!\") => (),\n-            _ => panic!()\n-        }\n-    }\n-\n-    #[test]\n-    fn test_try_panic() {\n-        match try(move|| {\n-            panic!()\n-        }) {\n-            result::Result::Err(_) => (),\n-            result::Result::Ok(()) => panic!()\n-        }\n-    }\n-\n-    #[test]\n-    fn test_spawn_sched() {\n-        use clone::Clone;\n-\n-        let (tx, rx) = channel();\n-\n-        fn f(i: int, tx: Sender<()>) {\n-            let tx = tx.clone();\n-            spawn(move|| {\n-                if i == 0 {\n-                    tx.send(());\n-                } else {\n-                    f(i - 1, tx);\n-                }\n-            });\n-\n-        }\n-        f(10, tx);\n-        rx.recv();\n-    }\n-\n-    #[test]\n-    fn test_spawn_sched_childs_on_default_sched() {\n-        let (tx, rx) = channel();\n-\n-        spawn(move|| {\n-            spawn(move|| {\n-                tx.send(());\n-            });\n-        });\n-\n-        rx.recv();\n-    }\n-\n-    fn avoid_copying_the_body<F>(spawnfn: F) where\n-        F: FnOnce(Thunk),\n-    {\n-        let (tx, rx) = channel::<uint>();\n-\n-        let x = box 1;\n-        let x_in_parent = (&*x) as *const int as uint;\n-\n-        spawnfn(Thunk::new(move|| {\n-            let x_in_child = (&*x) as *const int as uint;\n-            tx.send(x_in_child);\n-        }));\n-\n-        let x_in_child = rx.recv();\n-        assert_eq!(x_in_parent, x_in_child);\n-    }\n-\n-    #[test]\n-    fn test_avoid_copying_the_body_spawn() {\n-        avoid_copying_the_body(|t| spawn(move|| t.invoke(())));\n-    }\n-\n-    #[test]\n-    fn test_avoid_copying_the_body_task_spawn() {\n-        avoid_copying_the_body(|f| {\n-            let builder = TaskBuilder::new();\n-            builder.spawn(move|| f.invoke(()));\n-        })\n-    }\n-\n-    #[test]\n-    fn test_avoid_copying_the_body_try() {\n-        avoid_copying_the_body(|f| {\n-            let _ = try(move|| f.invoke(()));\n-        })\n-    }\n-\n-    #[test]\n-    fn test_child_doesnt_ref_parent() {\n-        // If the child refcounts the parent task, this will stack overflow when\n-        // climbing the task tree to dereference each ancestor. (See #1789)\n-        // (well, it would if the constant were 8000+ - I lowered it to be more\n-        // valgrind-friendly. try this at home, instead..!)\n-        static GENERATIONS: uint = 16;\n-        fn child_no(x: uint) -> Thunk {\n-            return Thunk::new(move|| {\n-                if x < GENERATIONS {\n-                    TaskBuilder::new().spawn(move|| child_no(x+1).invoke(()));\n-                }\n-            });\n-        }\n-        TaskBuilder::new().spawn(|| child_no(0).invoke(()));\n-    }\n-\n-    #[test]\n-    fn test_simple_newsched_spawn() {\n-        spawn(move|| ())\n-    }\n-\n-    #[test]\n-    fn test_try_panic_message_static_str() {\n-        match try(move|| {\n-            panic!(\"static string\");\n-        }) {\n-            Err(e) => {\n-                type T = &'static str;\n-                assert!(e.is::<T>());\n-                assert_eq!(*e.downcast::<T>().unwrap(), \"static string\");\n-            }\n-            Ok(()) => panic!()\n-        }\n-    }\n-\n-    #[test]\n-    fn test_try_panic_message_owned_str() {\n-        match try(move|| {\n-            panic!(\"owned string\".to_string());\n-        }) {\n-            Err(e) => {\n-                type T = String;\n-                assert!(e.is::<T>());\n-                assert_eq!(*e.downcast::<T>().unwrap(), \"owned string\");\n-            }\n-            Ok(()) => panic!()\n-        }\n-    }\n-\n-    #[test]\n-    fn test_try_panic_message_any() {\n-        match try(move|| {\n-            panic!(box 413u16 as Box<Any + Send>);\n-        }) {\n-            Err(e) => {\n-                type T = Box<Any + Send>;\n-                assert!(e.is::<T>());\n-                let any = e.downcast::<T>().unwrap();\n-                assert!(any.is::<u16>());\n-                assert_eq!(*any.downcast::<u16>().unwrap(), 413u16);\n-            }\n-            Ok(()) => panic!()\n-        }\n-    }\n-\n-    #[test]\n-    fn test_try_panic_message_unit_struct() {\n-        struct Juju;\n-\n-        match try(move|| {\n-            panic!(Juju)\n-        }) {\n-            Err(ref e) if e.is::<Juju>() => {}\n-            Err(_) | Ok(()) => panic!()\n-        }\n-    }\n-\n-    #[test]\n-    fn test_stdout() {\n-        let (tx, rx) = channel();\n-        let mut reader = ChanReader::new(rx);\n-        let stdout = ChanWriter::new(tx);\n-\n-        let r = TaskBuilder::new().stdout(box stdout as Box<Writer + Send>)\n-                                  .try(move|| {\n-                print!(\"Hello, world!\");\n-            });\n-        assert!(r.is_ok());\n-\n-        let output = reader.read_to_string().unwrap();\n-        assert_eq!(output, \"Hello, world!\");\n-    }\n-\n-    // NOTE: the corresponding test for stderr is in run-pass/task-stderr, due\n-    // to the test harness apparently interfering with stderr configuration.\n-}\n-\n-#[test]\n-fn task_abort_no_kill_runtime() {\n-    use std::io::timer;\n-    use time::Duration;\n-    use mem;\n-\n-    let tb = TaskBuilder::new();\n-    let rx = tb.try_future(move|| {});\n-    mem::drop(rx);\n-    timer::sleep(Duration::milliseconds(1000));\n+/// Deprecated: use `std::thread::Thread::spawn` instead.\n+#[deprecated = \"use std::thread::Thread::spawn instead\"]\n+pub fn spawn(f: proc(): Send) {\n+    thread::Thread::spawn(f);\n }"}, {"sha": "a6e114bc2c356e52184288471c0edfd39065abc4", "filename": "src/libstd/thread.rs", "status": "added", "additions": 655, "deletions": 0, "changes": 655, "blob_url": "https://github.com/rust-lang/rust/blob/cac133c9a86a4687755aeb44908e3fbb2bb35fc2/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac133c9a86a4687755aeb44908e3fbb2bb35fc2/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=cac133c9a86a4687755aeb44908e3fbb2bb35fc2", "patch": "@@ -0,0 +1,655 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Native threads\n+//!\n+//! ## The threading model\n+//!\n+//! An executing Rust program consists of a collection of native OS threads,\n+//! each with their own stack and local state.\n+//!\n+//! Threads generally have their memory *isolated* from each other by virtue of\n+//! Rust's owned types (which of course may only be owned by a single thread at\n+//! a time). Communication between threads can be done through\n+//! [channels](../../std/comm/index.html), Rust's message-passing types, along\n+//! with [other forms of thread synchronization](../../std/sync/index.html) and\n+//! shared-memory data structures. In particular, types that are guaranteed to\n+//! be threadsafe are easily shared between threads using the\n+//! atomically-reference-counted container,\n+//! [`Arc`](../../std/sync/struct.Arc.html).\n+//!\n+//! Fatal logic errors in Rust cause *thread panic*, during which\n+//! a thread will unwind the stack, running destructors and freeing\n+//! owned resources. Thread panic is unrecoverable from within\n+//! the panicking thread (i.e. there is no 'try/catch' in Rust), but\n+//! panic may optionally be detected from a different thread. If\n+//! the main thread panics the application will exit with a non-zero\n+//! exit code.\n+//!\n+//! When the main thread of a Rust program terminates, the entire program shuts\n+//! down, even if other threads are still running. However, this module provides\n+//! convenient facilities for automatically waiting for the termination of a\n+//! child thread (i.e., join), described below.\n+//!\n+//! ## The `Thread` type\n+//!\n+//! Already-running threads are represented via the `Thread` type, which you can\n+//! get in one of two ways:\n+//!\n+//! * By spawning a new thread, e.g. using the `Thread::spawn` constructor;\n+//! * By requesting the current thread, using the `Thread::current` function.\n+//!\n+//! Threads can be named, and provide some built-in support for low-level\n+//! synchronization described below.\n+//!\n+//! The `Thread::current()` function is available even for threads not spawned\n+//! by the APIs of this module.\n+//!\n+//! ## Spawning a thread\n+//!\n+//! There are a few different ways to spawn a new thread, depending on how it\n+//! should relate to the parent thread.\n+//!\n+//! ### Simple detached threads\n+//!\n+//! The simplest case just spawns a completely independent (detached) thread,\n+//! returning a new `Thread` handle to it:\n+//!\n+//! ```rust\n+//! use std::thread::Thread;\n+//!\n+//! Thread::spawn(proc() {\n+//!     println!(\"Hello, World!\");\n+//! })\n+//! ```\n+//!\n+//! The spawned thread may outlive its parent.\n+//!\n+//! ### Joining\n+//!\n+//! Alternatively, the `with_join` constructor spawns a new thread and returns a\n+//! `JoinGuard` which can be used to wait until the child thread completes,\n+//! returning its result (or `Err` if the child thread panicked):\n+//!\n+//! ```rust\n+//! use std::thread::Thread;\n+//!\n+//! let guard = Thread::with_join(proc() { panic!() };\n+//! assert!(guard.join().is_err());\n+//! ```\n+//!\n+//! The guard works in RAII style, meaning that the child thread is\n+//! automatically joined when the guard is dropped. A handle to the thread\n+//! itself is available via the `thread` method on the guard.\n+//!\n+//! ### Configured threads\n+//!\n+//! Finally, a new thread can be configured independently of how it is\n+//! spawned. Configuration is available via the `Cfg` builder, which currently\n+//! allows you to set the name, stack size, and writers for `println!` and\n+//! `panic!` for the child thread:\n+//!\n+//! ```rust\n+//! use std::thread;\n+//!\n+//! thread::cfg().name(\"child1\").spawn(proc() { println!(\"Hello, world!\") });\n+//! ```\n+//!\n+//! ## Blocking support: park and unpark\n+//!\n+//! Every thread is equipped with some basic low-level blocking support, via the\n+//! `park` and `unpark` functions.\n+//!\n+//! Conceptually, each `Thread` handle has an associated token, which is\n+//! initially not present:\n+//!\n+//! * The `Thread::park()` function blocks the current thread unless or until\n+//!   the token is available for its thread handle, at which point It atomically\n+//!   consumes the token. It may also return *spuriously*, without consuming the\n+//!   token.\n+//!\n+//! * The `unpark()` method on a `Thread` atomically makes the token available\n+//!   if it wasn't already.\n+//!\n+//! In other words, each `Thread` acts a bit like a semaphore with initial count\n+//! 0, except that the semaphore is *saturating* (the count cannot go above 1),\n+//! and can return spuriously.\n+//!\n+//! The API is typically used by acquiring a handle to the current thread,\n+//! placing that handle in a shared data structure so that other threads can\n+//! find it, and then `park`ing. When some desired condition is met, another\n+//! thread calls `unpark` on the handle.\n+//!\n+//! The motivation for this design is twofold:\n+//!\n+//! * It avoids the need to allocate mutexes and condvars when building new\n+//!   synchronization primitives; the threads already provide basic blocking/signaling.\n+//!\n+//! * It can be implemented highly efficiently on many platforms.\n+\n+use core::prelude::*;\n+\n+use any::Any;\n+use borrow::IntoCow;\n+use boxed::Box;\n+use mem;\n+use sync::{Mutex, Condvar, Arc};\n+use string::String;\n+use rt::{mod, unwind};\n+use io::{Writer, stdio};\n+\n+use sys::thread as imp;\n+use sys_common::{stack, thread_info};\n+\n+/// Thread configuation. Provides detailed control over the properties\n+/// and behavior of new threads.\n+pub struct Cfg {\n+    // A name for the thread-to-be, for identification in panic messages\n+    name: Option<String>,\n+    // The size of the stack for the spawned thread\n+    stack_size: Option<uint>,\n+    // Thread-local stdout\n+    stdout: Option<Box<Writer + Send>>,\n+    // Thread-local stderr\n+    stderr: Option<Box<Writer + Send>>,\n+}\n+\n+impl Cfg {\n+    /// Generate the base configuration for spawning a thread, from which\n+    /// configuration methods can be chained.\n+    pub fn new() -> Cfg {\n+        Cfg {\n+            name: None,\n+            stack_size: None,\n+            stdout: None,\n+            stderr: None,\n+        }\n+    }\n+\n+    /// Name the thread-to-be. Currently the name is used for identification\n+    /// only in panic messages.\n+    pub fn name(mut self, name: String) -> Cfg {\n+        self.name = Some(name);\n+        self\n+    }\n+\n+    /// Deprecated: use `name` instead\n+    #[deprecated = \"use name instead\"]\n+    pub fn named<T: IntoCow<'static, String, str>>(self, name: T) -> Cfg {\n+        self.name(name.into_cow().into_owned())\n+    }\n+\n+    /// Set the size of the stack for the new thread.\n+    pub fn stack_size(mut self, size: uint) -> Cfg {\n+        self.stack_size = Some(size);\n+        self\n+    }\n+\n+    /// Redirect thread-local stdout.\n+    #[experimental = \"Will likely go away after proc removal\"]\n+    pub fn stdout(mut self, stdout: Box<Writer + Send>) -> Cfg {\n+        self.stdout = Some(stdout);\n+        self\n+    }\n+\n+    /// Redirect thread-local stderr.\n+    #[experimental = \"Will likely go away after proc removal\"]\n+    pub fn stderr(mut self, stderr: Box<Writer + Send>) -> Cfg {\n+        self.stderr = Some(stderr);\n+        self\n+    }\n+\n+    fn core_spawn<T: Send>(self, f: proc():Send -> T, after: proc(Result<T>):Send)\n+                           -> (imp::rust_thread, Thread)\n+    {\n+        let Cfg { name, stack_size, stdout, stderr } = self;\n+\n+        let stack_size = stack_size.unwrap_or(rt::min_stack());\n+        let my_thread = Thread::new(name);\n+        let their_thread = my_thread.clone();\n+\n+        // Spawning a new OS thread guarantees that __morestack will never get\n+        // triggered, but we must manually set up the actual stack bounds once\n+        // this function starts executing. This raises the lower limit by a bit\n+        // because by the time that this function is executing we've already\n+        // consumed at least a little bit of stack (we don't know the exact byte\n+        // address at which our stack started).\n+        let main = proc() {\n+            let something_around_the_top_of_the_stack = 1;\n+            let addr = &something_around_the_top_of_the_stack as *const int;\n+            let my_stack_top = addr as uint;\n+            let my_stack_bottom = my_stack_top - stack_size + 1024;\n+            unsafe {\n+                stack::record_os_managed_stack_bounds(my_stack_bottom, my_stack_top);\n+            }\n+            thread_info::set(\n+                (my_stack_bottom, my_stack_top),\n+                thread::current_guard_page(),\n+                their_thread\n+            );\n+\n+            // There are two primary reasons that general try/catch is\n+            // unsafe. The first is that we do not support nested try/catch. The\n+            // fact that this is happening in a newly-spawned thread\n+            // suffices. The second is that unwinding while unwinding is not\n+            // defined.  We take care of that by having an 'unwinding' flag in\n+            // the thread itself. For these reasons, this unsafety should be ok.\n+            unsafe {\n+                let mut output = None;\n+                let mut f_opt = Some( // option dance\n+                    if stdout.is_some() || stderr.is_some() {\n+                        proc() {\n+                            let _ = stdout.map(stdio::set_stdout);\n+                            let _ = stderr.map(stdio::set_stderr);\n+                            f()\n+                        }\n+                    } else {\n+                        f\n+                    });\n+                let try_result = unwind::try(|| output = Some((f_opt.take().unwrap())()));\n+                match (output, try_result) {\n+                    (Some(data), Ok(_)) => after(Ok(data)),\n+                    (None, Err(cause)) => after(Err(cause)),\n+                    _ => unreachable!()\n+                }\n+            }\n+        };\n+        (unsafe { imp::create(stack, box main) }, my_thread)\n+    }\n+\n+    /// Spawn a detached thread, and return a handle to it.\n+    ///\n+    /// The new child thread may outlive its parent.\n+    pub fn spawn(self, f: proc():Send) -> Thread {\n+        let (native, thread) = self.core_spawn(f, proc(_) {});\n+        unsafe { imp::detach(native) };\n+        thread\n+    }\n+\n+    /// Spawn a joinable thread, and return an RAII guard for it.\n+    pub fn with_join<T: Send>(self, f: proc():Send -> T) -> JoinGuard<T> {\n+        // We need the address of the packet to fill in to be stable so when\n+        // `main` fills it in it's still valid, so allocate an extra box to do\n+        // so.\n+        let my_packet = box Err(box 0); // sentinel value\n+        let their_packet: *mut Result<T> = unsafe {\n+            *mem::transmute::<&Box<Result<T>>, *const *mut Result<T>>(&my_packet)\n+        };\n+\n+        let (native, thread) = self.core_spawn(f, proc(result) {\n+            *their_packet = result;\n+        });\n+\n+        JoinGuard {\n+            native: native,\n+            joined: false,\n+            packet: my_packet,\n+            thread: thread,\n+        }\n+    }\n+}\n+\n+/// A convenience function for creating configurations.\n+pub fn cfg() -> Cfg { Cfg::new() }\n+\n+struct Inner {\n+    name: Option<String>,\n+    lock: Mutex<bool>,          // true when there is a buffered unpark\n+    cvar: Condvar,\n+}\n+\n+#[deriving(Clone)]\n+/// A handle to a thread.\n+pub struct Thread {\n+    inner: Arc<Inner>,\n+}\n+\n+impl Thread {\n+    fn new(name: Option<String>) -> Thread {\n+        Thread {\n+            inner: Arc::new(Inner {\n+                name: name,\n+                lock: Mutex::new(false),\n+                cvar: Condvar::new(),\n+            })\n+        }\n+    }\n+\n+    /// Spawn a detached thread, and return a handle to it.\n+    ///\n+    /// The new child thread may outlive its parent.\n+    pub fn spawn(f: proc():Send) -> Thread {\n+        Cfg::new().spawn(f)\n+    }\n+\n+    /// Spawn a joinable thread, and return an RAII guard for it.\n+    pub fn with_join<T: Send>(f: proc():Send -> T) -> JoinGuard<T> {\n+        Cfg::new().with_join(f)\n+    }\n+\n+    /// Gets a handle to the thread that invokes it.\n+    pub fn current() -> Thread {\n+        ThreadInfo::current_thread()\n+    }\n+\n+    /// Cooperatively give up a timeslice to the OS scheduler.\n+    pub fn yield_now() {\n+        unsafe { imp::yield_now() }\n+    }\n+\n+    /// Determines whether the current thread is panicking.\n+    pub fn panicking() -> bool {\n+        ThreadInfo::panicking()\n+    }\n+\n+    // http://cr.openjdk.java.net/~stefank/6989984.1/raw_files/new/src/os/linux/vm/os_linux.cpp\n+    /// Block unless or until the current thread's token is made available (may wake spuriously).\n+    ///\n+    /// See the module doc for more detail.\n+    pub fn park() {\n+        let thread = Thread::current();\n+        let guard = thread.inner.lock.lock();\n+        while !*guard {\n+            thread.inner.cvar.wait(guard);\n+        }\n+        *guard = false;\n+    }\n+\n+    /// Atomically makes the handle's token available if it is not already.\n+    ///\n+    /// See the module doc for more detail.\n+    pub fn unpark(&self) {\n+        let guard = self.inner.lock();\n+        if !*guard {\n+            *guard = true;\n+            self.inner.cvar.notify_one();\n+        }\n+    }\n+\n+    /// Get the thread's name.\n+    pub fn name(&self) -> Option<&str> {\n+        self.inner.name.as_ref()\n+    }\n+}\n+\n+// a hack to get around privacy restrictions\n+impl thread_info::NewThread for Thread {\n+    fn new(name: Option<String>) -> Thread { Thread::new(name) }\n+}\n+\n+/// Indicates the manner in which a thread exited.\n+///\n+/// A thread that completes without panicking is considered to exit successfully.\n+pub type Result<T> = result::Result<T, Box<Any + Send>>;\n+\n+#[must_use]\n+/// An RAII guard that will block until thread termination when dropped.\n+pub struct JoinGuard<T> {\n+    native: imp::rust_thread,\n+    thread: Thread,\n+    joined: bool,\n+    packet: Box<Result<T>>,\n+}\n+\n+impl<T: Send> JoinGuard<T> {\n+    /// Extract a handle to the thread this guard will join on.\n+    pub fn thread(&self) -> Thread {\n+        self.thread.clone()\n+    }\n+\n+    /// Wait for the associated thread to finish, returning the result of the thread's\n+    /// calculation.\n+    pub fn join(mut self) -> Result<T> {\n+        assert!(!self.joined);\n+        unsafe { imp::join(self.native) };\n+        self.joined = true;\n+        let box res =  self.packet.take().unwrap();\n+        res\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<T: Send> Drop for JoinGuard<T> {\n+    fn drop(&mut self) {\n+        // This is required for correctness. If this is not done then the thread\n+        // would fill in a return box which no longer exists.\n+        if !self.joined {\n+            unsafe { imp::join(self.native) };\n+        }\n+    }\n+}\n+\n+// TODO: fix tests\n+#[cfg(test)]\n+mod test {\n+    use any::{Any, AnyRefExt};\n+    use boxed::BoxAny;\n+    use prelude::*;\n+    use result::Result::{Ok, Err};\n+    use result;\n+    use std::io::{ChanReader, ChanWriter};\n+    use string::String;\n+    use super::{Thread, cfg};\n+\n+    // !!! These tests are dangerous. If something is buggy, they will hang, !!!\n+    // !!! instead of exiting cleanly. This might wedge the buildbots.       !!!\n+\n+    #[test]\n+    fn test_unnamed_thread() {\n+        Thread::with_join(proc() {\n+            assert!(Thread::current().name().is_none());\n+        }).join().map_err(|_| ()).unwrap();\n+    }\n+\n+    #[test]\n+    fn test_named_thread() {\n+        cfg().name(\"ada lovelace\".to_string()).with_join(proc() {\n+            assert!(Thread::current().name().unwrap() == \"ada lovelace\".to_string());\n+        }).join().map_err(|_| ()).unwrap();\n+    }\n+\n+    #[test]\n+    fn test_run_basic() {\n+        let (tx, rx) = channel();\n+        Thread::spawn(proc() {\n+            tx.send(());\n+        });\n+        rx.recv();\n+    }\n+\n+    #[test]\n+    fn test_join_success() {\n+        match Thread::with_join::<String>(proc() {\n+            \"Success!\".to_string()\n+        }).join().as_ref().map(|s| s.as_slice()) {\n+            result::Result::Ok(\"Success!\") => (),\n+            _ => panic!()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_join_panic() {\n+        match Thread::with_join(proc() {\n+            panic!()\n+        }).join() {\n+            result::Result::Err(_) => (),\n+            result::Result::Ok(()) => panic!()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_spawn_sched() {\n+        use clone::Clone;\n+\n+        let (tx, rx) = channel();\n+\n+        fn f(i: int, tx: Sender<()>) {\n+            let tx = tx.clone();\n+            Thread::spawn(proc() {\n+                if i == 0 {\n+                    tx.send(());\n+                } else {\n+                    f(i - 1, tx);\n+                }\n+            });\n+\n+        }\n+        f(10, tx);\n+        rx.recv();\n+    }\n+\n+    #[test]\n+    fn test_spawn_sched_childs_on_default_sched() {\n+        let (tx, rx) = channel();\n+\n+        Thread::spawn(proc() {\n+            Thread::spawn(proc() {\n+                tx.send(());\n+            });\n+        });\n+\n+        rx.recv();\n+    }\n+\n+    fn avoid_copying_the_body(spawnfn: |v: proc():Send|) {\n+        let (tx, rx) = channel::<uint>();\n+\n+        let x = box 1;\n+        let x_in_parent = (&*x) as *const int as uint;\n+\n+        spawnfn(proc() {\n+            let x_in_child = (&*x) as *const int as uint;\n+            tx.send(x_in_child);\n+        });\n+\n+        let x_in_child = rx.recv();\n+        assert_eq!(x_in_parent, x_in_child);\n+    }\n+\n+    #[test]\n+    fn test_avoid_copying_the_body_spawn() {\n+        avoid_copying_the_body(|v| { Thread::spawn(v); });\n+    }\n+\n+    #[test]\n+    fn test_avoid_copying_the_body_thread_spawn() {\n+        avoid_copying_the_body(|f| {\n+            let builder = cfg();\n+            builder.spawn(proc() {\n+                f();\n+            });\n+        })\n+    }\n+\n+    #[test]\n+    fn test_avoid_copying_the_body_join() {\n+        avoid_copying_the_body(|f| {\n+            let _ = Thread::with_join(proc() {\n+                f()\n+            }).join();\n+        })\n+    }\n+\n+    #[test]\n+    fn test_child_doesnt_ref_parent() {\n+        // If the child refcounts the parent task, this will stack overflow when\n+        // climbing the task tree to dereference each ancestor. (See #1789)\n+        // (well, it would if the constant were 8000+ - I lowered it to be more\n+        // valgrind-friendly. try this at home, instead..!)\n+        static GENERATIONS: uint = 16;\n+        fn child_no(x: uint) -> proc(): Send {\n+            return proc() {\n+                if x < GENERATIONS {\n+                    Thread::spawn(child_no(x+1));\n+                }\n+            }\n+        }\n+        Thread::spawn(child_no(0));\n+    }\n+\n+    #[test]\n+    fn test_simple_newsched_spawn() {\n+        Thread::spawn(proc()());\n+    }\n+\n+    #[test]\n+    fn test_try_panic_message_static_str() {\n+        match Thread::with_join(proc() {\n+            panic!(\"static string\");\n+        }).join() {\n+            Err(e) => {\n+                type T = &'static str;\n+                assert!(e.is::<T>());\n+                assert_eq!(*e.downcast::<T>().unwrap(), \"static string\");\n+            }\n+            Ok(()) => panic!()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_try_panic_message_owned_str() {\n+        match Thread::with_join(proc() {\n+            panic!(\"owned string\".to_string());\n+        }).join() {\n+            Err(e) => {\n+                type T = String;\n+                assert!(e.is::<T>());\n+                assert_eq!(*e.downcast::<T>().unwrap(), \"owned string\".to_string());\n+            }\n+            Ok(()) => panic!()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_try_panic_message_any() {\n+        match Thread::with_join(proc() {\n+            panic!(box 413u16 as Box<Any + Send>);\n+        }).join() {\n+            Err(e) => {\n+                type T = Box<Any + Send>;\n+                assert!(e.is::<T>());\n+                let any = e.downcast::<T>().unwrap();\n+                assert!(any.is::<u16>());\n+                assert_eq!(*any.downcast::<u16>().unwrap(), 413u16);\n+            }\n+            Ok(()) => panic!()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_try_panic_message_unit_struct() {\n+        struct Juju;\n+\n+        match Thread::with_join(proc() {\n+            panic!(Juju)\n+        }).join() {\n+            Err(ref e) if e.is::<Juju>() => {}\n+            Err(_) | Ok(()) => panic!()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_stdout() {\n+        let (tx, rx) = channel();\n+        let mut reader = ChanReader::new(rx);\n+        let stdout = ChanWriter::new(tx);\n+\n+        let r = cfg().stdout(box stdout as Box<Writer + Send>).with_join(proc() {\n+                print!(\"Hello, world!\");\n+            }).join();\n+        assert!(r.is_ok());\n+\n+        let output = reader.read_to_string().unwrap();\n+        assert_eq!(output, \"Hello, world!\".to_string());\n+    }\n+\n+    // NOTE: the corresponding test for stderr is in run-pass/task-stderr, due\n+    // to the test harness apparently interfering with stderr configuration.\n+}"}]}