{"sha": "af75ebdc3a4d01c62ae1af96931f6fa1b188b698", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmNzVlYmRjM2E0ZDAxYzYyYWUxYWY5NjkzMWY2ZmExYjE4OGI2OTg=", "commit": {"author": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-05-21T16:06:28Z"}, "committer": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-05-21T16:06:28Z"}, "message": "Improve the diagnostic around impl Trait <-> generic param mismatch", "tree": {"sha": "8766abb9fab6b5a44bde3e6323fc66cb64cde1b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8766abb9fab6b5a44bde3e6323fc66cb64cde1b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af75ebdc3a4d01c62ae1af96931f6fa1b188b698", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af75ebdc3a4d01c62ae1af96931f6fa1b188b698", "html_url": "https://github.com/rust-lang/rust/commit/af75ebdc3a4d01c62ae1af96931f6fa1b188b698", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af75ebdc3a4d01c62ae1af96931f6fa1b188b698/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00842d10cd703263833132867d59c85b343eb202", "url": "https://api.github.com/repos/rust-lang/rust/commits/00842d10cd703263833132867d59c85b343eb202", "html_url": "https://github.com/rust-lang/rust/commit/00842d10cd703263833132867d59c85b343eb202"}], "stats": {"total": 326, "additions": 243, "deletions": 83}, "files": [{"sha": "81b32f436c8dded59ff4cd0bffa5c182b3f7cd08", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/af75ebdc3a4d01c62ae1af96931f6fa1b188b698/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af75ebdc3a4d01c62ae1af96931f6fa1b188b698/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=af75ebdc3a4d01c62ae1af96931f6fa1b188b698", "patch": "@@ -259,6 +259,25 @@ impl Diagnostic {\n         self\n     }\n \n+    pub fn multipart_suggestion(\n+        &mut self,\n+        msg: &str,\n+        suggestion: Vec<(Span, String)>,\n+    ) -> &mut Self {\n+        self.suggestions.push(CodeSuggestion {\n+            substitutions: vec![Substitution {\n+                parts: suggestion\n+                    .into_iter()\n+                    .map(|(span, snippet)| SubstitutionPart { snippet, span })\n+                    .collect(),\n+            }],\n+            msg: msg.to_owned(),\n+            show_code_when_inline: true,\n+            applicability: Applicability::Unspecified,\n+        });\n+        self\n+    }\n+\n     /// Prints out a message with multiple suggested edits of the code.\n     pub fn span_suggestions(&mut self, sp: Span, msg: &str, suggestions: Vec<String>) -> &mut Self {\n         self.suggestions.push(CodeSuggestion {"}, {"sha": "b813edadc577e10b31c0749e86c60b6c418186bd", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af75ebdc3a4d01c62ae1af96931f6fa1b188b698/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af75ebdc3a4d01c62ae1af96931f6fa1b188b698/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=af75ebdc3a4d01c62ae1af96931f6fa1b188b698", "patch": "@@ -178,6 +178,11 @@ impl<'a> DiagnosticBuilder<'a> {\n                                           msg: &str,\n                                           suggestion: String)\n                                           -> &mut Self);\n+    forward!(pub fn multipart_suggestion(\n+        &mut self,\n+        msg: &str,\n+        suggestion: Vec<(Span, String)>\n+    ) -> &mut Self);\n     forward!(pub fn span_suggestion(&mut self,\n                                     sp: Span,\n                                     msg: &str,"}, {"sha": "bdaee97e8f632dbd7ae59416c6dfea0925f335ef", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 74, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/af75ebdc3a4d01c62ae1af96931f6fa1b188b698/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af75ebdc3a4d01c62ae1af96931f6fa1b188b698/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=af75ebdc3a4d01c62ae1af96931f6fa1b188b698", "patch": "@@ -41,7 +41,7 @@ use rustc::ty;\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet, DefIdMap};\n \n-use syntax::codemap::{BytePos, CodeMap};\n+use syntax::codemap::CodeMap;\n use syntax::ext::hygiene::{Mark, MarkKind, SyntaxContext};\n use syntax::ast::{self, Name, NodeId, Ident, FloatTy, IntTy, UintTy};\n use syntax::ext::base::SyntaxExtension;\n@@ -210,12 +210,12 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n             // Try to retrieve the span of the function signature and generate a new message with\n             // a local type parameter\n             let sugg_msg = \"try using a local type parameter instead\";\n-            if let Some((sugg_span, new_snippet)) = generate_local_type_param_snippet(cm, span) {\n+            if let Some((sugg_span, new_snippet)) = cm.generate_local_type_param_snippet(span) {\n                 // Suggest the modification to the user\n                 err.span_suggestion(sugg_span,\n                                     sugg_msg,\n                                     new_snippet);\n-            } else if let Some(sp) = generate_fn_name_span(cm, span) {\n+            } else if let Some(sp) = cm.generate_fn_name_span(span) {\n                 err.span_label(sp, \"try adding a local type parameter in this method instead\");\n             } else {\n                 err.help(\"try using a local type parameter instead\");\n@@ -412,77 +412,6 @@ fn reduce_impl_span_to_impl_keyword(cm: &CodeMap, impl_span: Span) -> Span {\n     impl_span\n }\n \n-fn generate_fn_name_span(cm: &CodeMap, span: Span) -> Option<Span> {\n-    let prev_span = cm.span_extend_to_prev_str(span, \"fn\", true);\n-    cm.span_to_snippet(prev_span).map(|snippet| {\n-        let len = snippet.find(|c: char| !c.is_alphanumeric() && c != '_')\n-            .expect(\"no label after fn\");\n-        prev_span.with_hi(BytePos(prev_span.lo().0 + len as u32))\n-    }).ok()\n-}\n-\n-/// Take the span of a type parameter in a function signature and try to generate a span for the\n-/// function name (with generics) and a new snippet for this span with the pointed type parameter as\n-/// a new local type parameter.\n-///\n-/// For instance:\n-/// ```rust,ignore (pseudo-Rust)\n-/// // Given span\n-/// fn my_function(param: T)\n-/// //                    ^ Original span\n-///\n-/// // Result\n-/// fn my_function(param: T)\n-/// // ^^^^^^^^^^^ Generated span with snippet `my_function<T>`\n-/// ```\n-///\n-/// Attention: The method used is very fragile since it essentially duplicates the work of the\n-/// parser. If you need to use this function or something similar, please consider updating the\n-/// codemap functions and this function to something more robust.\n-fn generate_local_type_param_snippet(cm: &CodeMap, span: Span) -> Option<(Span, String)> {\n-    // Try to extend the span to the previous \"fn\" keyword to retrieve the function\n-    // signature\n-    let sugg_span = cm.span_extend_to_prev_str(span, \"fn\", false);\n-    if sugg_span != span {\n-        if let Ok(snippet) = cm.span_to_snippet(sugg_span) {\n-            // Consume the function name\n-            let mut offset = snippet.find(|c: char| !c.is_alphanumeric() && c != '_')\n-                .expect(\"no label after fn\");\n-\n-            // Consume the generics part of the function signature\n-            let mut bracket_counter = 0;\n-            let mut last_char = None;\n-            for c in snippet[offset..].chars() {\n-                match c {\n-                    '<' => bracket_counter += 1,\n-                    '>' => bracket_counter -= 1,\n-                    '(' => if bracket_counter == 0 { break; }\n-                    _ => {}\n-                }\n-                offset += c.len_utf8();\n-                last_char = Some(c);\n-            }\n-\n-            // Adjust the suggestion span to encompass the function name with its generics\n-            let sugg_span = sugg_span.with_hi(BytePos(sugg_span.lo().0 + offset as u32));\n-\n-            // Prepare the new suggested snippet to append the type parameter that triggered\n-            // the error in the generics of the function signature\n-            let mut new_snippet = if last_char == Some('>') {\n-                format!(\"{}, \", &snippet[..(offset - '>'.len_utf8())])\n-            } else {\n-                format!(\"{}<\", &snippet[..offset])\n-            };\n-            new_snippet.push_str(&cm.span_to_snippet(span).unwrap_or(\"T\".to_string()));\n-            new_snippet.push('>');\n-\n-            return Some((sugg_span, new_snippet));\n-        }\n-    }\n-\n-    None\n-}\n-\n #[derive(Copy, Clone, Debug)]\n struct BindingInfo {\n     span: Span,"}, {"sha": "befe42f991fb7aa15b8fd3e79a46ae09aa00bba6", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 126, "deletions": 3, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/af75ebdc3a4d01c62ae1af96931f6fa1b188b698/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af75ebdc3a4d01c62ae1af96931f6fa1b188b698/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=af75ebdc3a4d01c62ae1af96931f6fa1b188b698", "patch": "@@ -720,7 +720,7 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         _trait_item_span: Option<Span>) // FIXME necessary?\n                                         -> Result<(), ErrorReported> {\n     // FIXME(chrisvittal) Clean up this function, list of FIXME items:\n-    //     1. Better messages for the span lables\n+    //     1. Better messages for the span labels\n     //     2. Explanation as to what is going on\n     //     3. Correct the function signature for what we actually use\n     // If we get here, we already have the same number of generics, so the zip will\n@@ -751,8 +751,131 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            E0643,\n                                            \"method `{}` has incompatible signature for trait\",\n                                            trait_m.name);\n-            err.span_label(trait_span, \"annotation in trait\");\n-            err.span_label(impl_span, \"annotation in impl\");\n+            err.span_label(trait_span, \"declaration in trait here\");\n+            match (impl_synthetic, trait_synthetic) {\n+                // The case where the impl method uses `impl Trait` but the trait method uses\n+                // explicit generics\n+                (Some(hir::SyntheticTyParamKind::ImplTrait), None) => {\n+                    err.span_label(impl_span, \"expected generic parameter, found `impl Trait`\");\n+                    (|| {\n+                        // try taking the name from the trait impl\n+                        // FIXME: this is obviously suboptimal since the name can already be used\n+                        // as another generic argument\n+                        let new_name = tcx\n+                            .sess\n+                            .codemap()\n+                            .span_to_snippet(trait_span)\n+                            .ok()?;\n+                        let trait_m = tcx.hir.as_local_node_id(trait_m.def_id)?;\n+                        let trait_m = tcx.hir.trait_item(hir::TraitItemId { node_id: trait_m });\n+\n+                        let impl_m = tcx.hir.as_local_node_id(impl_m.def_id)?;\n+                        let impl_m = tcx.hir.impl_item(hir::ImplItemId { node_id: impl_m });\n+\n+                        // in case there are no generics, take the spot between the function name\n+                        // and the opening paren of the argument list\n+                        let new_generics_span = tcx\n+                            .sess\n+                            .codemap()\n+                            .generate_fn_name_span(impl_m.span)?\n+                            .shrink_to_hi();\n+                        // in case there are generics, just replace them\n+                        let generics_span = impl_m\n+                            .generics\n+                            .span\n+                            .substitute_dummy(new_generics_span);\n+                        // replace with the generics from the trait\n+                        let new_generics = tcx\n+                            .sess\n+                            .codemap()\n+                            .span_to_snippet(trait_m.generics.span)\n+                            .ok()?;\n+\n+                        err.multipart_suggestion(\n+                            \"try changing the `impl Trait` argument to a generic parameter\",\n+                            vec![\n+                                // replace `impl Trait` with `T`\n+                                (impl_span, new_name),\n+                                // replace impl method generics with trait method generics\n+                                // This isn't quite right, as users might have changed the names\n+                                // of the generics, but it works for the common case\n+                                (generics_span, new_generics),\n+                            ],\n+                        );\n+                        Some(())\n+                    })();\n+                },\n+                // The case where the trait method uses `impl Trait`, but the impl method uses\n+                // explicit generics.\n+                (None, Some(hir::SyntheticTyParamKind::ImplTrait)) => {\n+                    err.span_label(impl_span, \"expected `impl Trait`, found generic parameter\");\n+                    (|| {\n+                        let impl_m = tcx.hir.as_local_node_id(impl_m.def_id)?;\n+                        let impl_m = tcx.hir.impl_item(hir::ImplItemId { node_id: impl_m });\n+                        let input_tys = match impl_m.node {\n+                            hir::ImplItemKind::Method(ref sig, _) => &sig.decl.inputs,\n+                            _ => unreachable!(),\n+                        };\n+                        struct Visitor(Option<Span>, hir::def_id::DefId);\n+                        impl<'v> hir::intravisit::Visitor<'v> for Visitor {\n+                            fn visit_ty(&mut self, ty: &'v hir::Ty) {\n+                                hir::intravisit::walk_ty(self, ty);\n+                                match ty.node {\n+                                    hir::TyPath(hir::QPath::Resolved(None, ref path)) => {\n+                                        if let hir::def::Def::TyParam(def_id) = path.def {\n+                                            if def_id == self.1 {\n+                                                self.0 = Some(ty.span);\n+                                            }\n+                                        }\n+                                    },\n+                                    _ => {}\n+                                }\n+                            }\n+                            fn nested_visit_map<'this>(\n+                                &'this mut self\n+                            ) -> hir::intravisit::NestedVisitorMap<'this, 'v> {\n+                                hir::intravisit::NestedVisitorMap::None\n+                            }\n+                        }\n+                        let mut visitor = Visitor(None, impl_def_id);\n+                        for ty in input_tys {\n+                            hir::intravisit::Visitor::visit_ty(&mut visitor, ty);\n+                        }\n+                        let span = visitor.0?;\n+\n+                        let param = impl_m.generics.params.iter().filter_map(|param| {\n+                            match param {\n+                                hir::GenericParam::Type(param) => {\n+                                    if param.id == impl_node_id {\n+                                        Some(param)\n+                                    } else {\n+                                        None\n+                                    }\n+                                },\n+                                hir::GenericParam::Lifetime(..) => None,\n+                            }\n+                        }).next()?;\n+                        let bounds = param.bounds.first()?.span().to(param.bounds.last()?.span());\n+                        let bounds = tcx\n+                            .sess\n+                            .codemap()\n+                            .span_to_snippet(bounds)\n+                            .ok()?;\n+\n+                        err.multipart_suggestion(\n+                            \"try removing the generic parameter and using `impl Trait` instead\",\n+                            vec![\n+                                // delete generic parameters\n+                                (impl_m.generics.span, String::new()),\n+                                // replace param usage with `impl Trait`\n+                                (span, format!(\"impl {}\", bounds)),\n+                            ],\n+                        );\n+                        Some(())\n+                    })();\n+                },\n+                _ => unreachable!(),\n+            }\n             err.emit();\n             error_found = true;\n         }"}, {"sha": "0f25c56c457fe7073c4aefef31dd52603a1721f8", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/af75ebdc3a4d01c62ae1af96931f6fa1b188b698/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af75ebdc3a4d01c62ae1af96931f6fa1b188b698/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=af75ebdc3a4d01c62ae1af96931f6fa1b188b698", "patch": "@@ -874,6 +874,78 @@ impl CodeMap {\n     pub fn count_lines(&self) -> usize {\n         self.files().iter().fold(0, |a, f| a + f.count_lines())\n     }\n+\n+\n+    pub fn generate_fn_name_span(&self, span: Span) -> Option<Span> {\n+        let prev_span = self.span_extend_to_prev_str(span, \"fn\", true);\n+        self.span_to_snippet(prev_span).map(|snippet| {\n+            let len = snippet.find(|c: char| !c.is_alphanumeric() && c != '_')\n+                .expect(\"no label after fn\");\n+            prev_span.with_hi(BytePos(prev_span.lo().0 + len as u32))\n+        }).ok()\n+    }\n+\n+    /// Take the span of a type parameter in a function signature and try to generate a span for the\n+    /// function name (with generics) and a new snippet for this span with the pointed type parameter as\n+    /// a new local type parameter.\n+    ///\n+    /// For instance:\n+    /// ```rust,ignore (pseudo-Rust)\n+    /// // Given span\n+    /// fn my_function(param: T)\n+    /// //                    ^ Original span\n+    ///\n+    /// // Result\n+    /// fn my_function(param: T)\n+    /// // ^^^^^^^^^^^ Generated span with snippet `my_function<T>`\n+    /// ```\n+    ///\n+    /// Attention: The method used is very fragile since it essentially duplicates the work of the\n+    /// parser. If you need to use this function or something similar, please consider updating the\n+    /// codemap functions and this function to something more robust.\n+    pub fn generate_local_type_param_snippet(&self, span: Span) -> Option<(Span, String)> {\n+        // Try to extend the span to the previous \"fn\" keyword to retrieve the function\n+        // signature\n+        let sugg_span = self.span_extend_to_prev_str(span, \"fn\", false);\n+        if sugg_span != span {\n+            if let Ok(snippet) = self.span_to_snippet(sugg_span) {\n+                // Consume the function name\n+                let mut offset = snippet.find(|c: char| !c.is_alphanumeric() && c != '_')\n+                    .expect(\"no label after fn\");\n+\n+                // Consume the generics part of the function signature\n+                let mut bracket_counter = 0;\n+                let mut last_char = None;\n+                for c in snippet[offset..].chars() {\n+                    match c {\n+                        '<' => bracket_counter += 1,\n+                        '>' => bracket_counter -= 1,\n+                        '(' => if bracket_counter == 0 { break; }\n+                        _ => {}\n+                    }\n+                    offset += c.len_utf8();\n+                    last_char = Some(c);\n+                }\n+\n+                // Adjust the suggestion span to encompass the function name with its generics\n+                let sugg_span = sugg_span.with_hi(BytePos(sugg_span.lo().0 + offset as u32));\n+\n+                // Prepare the new suggested snippet to append the type parameter that triggered\n+                // the error in the generics of the function signature\n+                let mut new_snippet = if last_char == Some('>') {\n+                    format!(\"{}, \", &snippet[..(offset - '>'.len_utf8())])\n+                } else {\n+                    format!(\"{}<\", &snippet[..offset])\n+                };\n+                new_snippet.push_str(&self.span_to_snippet(span).unwrap_or(\"T\".to_string()));\n+                new_snippet.push('>');\n+\n+                return Some((sugg_span, new_snippet));\n+            }\n+        }\n+\n+        None\n+    }\n }\n \n impl CodeMapper for CodeMap {"}, {"sha": "4f25a4faefe57b98f9a9ec95b495289487ee22fc", "filename": "src/test/ui/impl-trait/impl-generic-mismatch.stderr", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/af75ebdc3a4d01c62ae1af96931f6fa1b188b698/src%2Ftest%2Fui%2Fimpl-trait%2Fimpl-generic-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af75ebdc3a4d01c62ae1af96931f6fa1b188b698/src%2Ftest%2Fui%2Fimpl-trait%2Fimpl-generic-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fimpl-generic-mismatch.stderr?ref=af75ebdc3a4d01c62ae1af96931f6fa1b188b698", "patch": "@@ -2,30 +2,42 @@ error[E0643]: method `foo` has incompatible signature for trait\n   --> $DIR/impl-generic-mismatch.rs:18:12\n    |\n LL |     fn foo(&self, _: &impl Debug);\n-   |                       ---------- annotation in trait\n+   |                       ---------- declaration in trait here\n ...\n LL |     fn foo<U: Debug>(&self, _: &U) { }\n-   |            ^ annotation in impl\n+   |            ^ expected `impl Trait`, found generic parameter\n+help: try removing the generic parameter and using `impl Trait` instead\n+   |\n+LL |     fn foo(&self, _: &impl Debug) { }\n+   |\n \n error[E0643]: method `bar` has incompatible signature for trait\n   --> $DIR/impl-generic-mismatch.rs:27:23\n    |\n LL |     fn bar<U: Debug>(&self, _: &U);\n-   |            - annotation in trait\n+   |            - declaration in trait here\n ...\n LL |     fn bar(&self, _: &impl Debug) { }\n-   |                       ^^^^^^^^^^ annotation in impl\n+   |                       ^^^^^^^^^^ expected generic parameter, found `impl Trait`\n+help: try changing the `impl Trait` argument to a generic parameter\n+   |\n+LL |     fn bar<U: Debug><U: Debug>(&self, _: &U);\n+LL | }\n+LL | \n+LL | impl Bar for () {\n+LL |     fn bar(&self, _: &U) { }\n+   |\n \n error[E0643]: method `hash` has incompatible signature for trait\n   --> $DIR/impl-generic-mismatch.rs:38:33\n    |\n LL |     fn hash(&self, hasher: &mut impl Hasher) {}\n-   |                                 ^^^^^^^^^^^ annotation in impl\n+   |                                 ^^^^^^^^^^^ expected generic parameter, found `impl Trait`\n    | \n   ::: /home/oliver/Projects/rust/rust3/src/libcore/hash/mod.rs:185:13\n    |\n LL |     fn hash<H: Hasher>(&self, state: &mut H);\n-   |             - annotation in trait\n+   |             - declaration in trait here\n \n error: aborting due to 3 previous errors\n "}]}