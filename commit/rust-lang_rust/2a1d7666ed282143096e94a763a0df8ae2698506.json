{"sha": "2a1d7666ed282143096e94a763a0df8ae2698506", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhMWQ3NjY2ZWQyODIxNDMwOTZlOTRhNzYzYTBkZjhhZTI2OTg1MDY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-08-05T05:02:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-08-05T05:02:52Z"}, "message": "Merge pull request #286 from RalfJung/mir-validate\n\nUpdate MIR validation and test it", "tree": {"sha": "aa6b6b2bace3e0afa86fd84a4f4921d51632591f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa6b6b2bace3e0afa86fd84a4f4921d51632591f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a1d7666ed282143096e94a763a0df8ae2698506", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a1d7666ed282143096e94a763a0df8ae2698506", "html_url": "https://github.com/rust-lang/rust/commit/2a1d7666ed282143096e94a763a0df8ae2698506", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a1d7666ed282143096e94a763a0df8ae2698506/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b449c3eadc68b17141be801fbcddb20a105403a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b449c3eadc68b17141be801fbcddb20a105403a", "html_url": "https://github.com/rust-lang/rust/commit/8b449c3eadc68b17141be801fbcddb20a105403a"}, {"sha": "fb2ed457c6bdbe587e2ac21c2f671d3e30bab353", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb2ed457c6bdbe587e2ac21c2f671d3e30bab353", "html_url": "https://github.com/rust-lang/rust/commit/fb2ed457c6bdbe587e2ac21c2f671d3e30bab353"}], "stats": {"total": 156, "additions": 93, "deletions": 63}, "files": [{"sha": "38917ad1f2af55ef5ffb6c2ab73be9ecf01e38cd", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d7666ed282143096e94a763a0df8ae2698506/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d7666ed282143096e94a763a0df8ae2698506/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=2a1d7666ed282143096e94a763a0df8ae2698506", "patch": "@@ -37,8 +37,6 @@ pub struct EvalContext<'a, 'tcx: 'a, M: Machine<'tcx>> {\n     /// The virtual memory system.\n     pub memory: Memory<'a, 'tcx, M>,\n \n-    #[allow(dead_code)]\n-    // FIXME(@RalfJung): validation branch\n     /// Lvalues that were suspended by the validation subsystem, and will be recovered later\n     pub(crate) suspended: HashMap<DynamicLifetime, Vec<ValidationQuery<'tcx>>>,\n "}, {"sha": "b200ece4ccf9c2c6f670bcebc5e2427e9e423b53", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d7666ed282143096e94a763a0df8ae2698506/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d7666ed282143096e94a763a0df8ae2698506/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=2a1d7666ed282143096e94a763a0df8ae2698506", "patch": "@@ -35,8 +35,6 @@ mod range {\n     }\n \n     impl MemoryRange {\n-        #[allow(dead_code)]\n-        // FIXME(@RalfJung): validation branch\n         pub fn new(offset: u64, len: u64) -> MemoryRange {\n             assert!(len > 0);\n             MemoryRange {\n@@ -61,8 +59,6 @@ mod range {\n             left..right\n         }\n \n-        #[allow(dead_code)]\n-        // FIXME(@RalfJung): validation branch\n         pub fn contained_in(&self, offset: u64, len: u64) -> bool {\n             assert!(len > 0);\n             offset <= self.start && self.end <= (offset + len)\n@@ -143,8 +139,6 @@ impl<M> Allocation<M> {\n             .filter(move |&(range, _)| range.overlaps(offset, len))\n     }\n \n-    #[allow(dead_code)]\n-    // FIXME(@RalfJung): validation branch\n     fn iter_locks_mut<'a>(&'a mut self, offset: u64, len: u64) -> impl Iterator<Item=(&'a MemoryRange, &'a mut LockInfo)> + 'a {\n         self.locks.range_mut(MemoryRange::range(offset, len))\n             .filter(move |&(range, _)| range.overlaps(offset, len))\n@@ -474,8 +468,6 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             .map_err(|lock| EvalErrorKind::MemoryLockViolation { ptr, len, frame, access, lock }.into())\n     }\n \n-    #[allow(dead_code)]\n-    // FIXME(@RalfJung): validation branch\n     /// Acquire the lock for the given lifetime\n     pub(crate) fn acquire_lock(&mut self, ptr: MemoryPointer, len: u64, region: Option<CodeExtent>, kind: AccessKind) -> EvalResult<'tcx> {\n         use std::collections::btree_map::Entry::*;\n@@ -504,8 +496,6 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         Ok(())\n     }\n \n-    #[allow(dead_code)]\n-    // FIXME(@RalfJung): validation branch\n     /// Release a write lock prematurely. If there's a read lock or someone else's lock, fail.\n     pub(crate) fn release_write_lock(&mut self, ptr: MemoryPointer, len: u64) -> EvalResult<'tcx> {\n         assert!(len > 0);"}, {"sha": "56195998b9e7a0ac8e17539b508a561d6f9709f1", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d7666ed282143096e94a763a0df8ae2698506/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d7666ed282143096e94a763a0df8ae2698506/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=2a1d7666ed282143096e94a763a0df8ae2698506", "patch": "@@ -133,8 +133,15 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 self.deallocate_local(old_val)?;\n             }\n \n-            // NOPs for now.\n-            EndRegion(_ce) => {}\n+            // Validity checks.\n+            Validate(op, ref lvalues) => {\n+                for operand in lvalues {\n+                    self.validation_op(op, operand)?;\n+                }\n+            }\n+            EndRegion(ce) => {\n+                self.end_region(ce)?;\n+            }\n \n             // Defined to do nothing. These are added by optimization passes, to avoid changing the\n             // size of MIR constantly."}, {"sha": "f77c7d65ff7de66d3c8e42d747e9bd290e1b152e", "filename": "src/librustc_mir/interpret/validation.rs", "status": "modified", "additions": 32, "deletions": 47, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d7666ed282143096e94a763a0df8ae2698506/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d7666ed282143096e94a763a0df8ae2698506/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs?ref=2a1d7666ed282143096e94a763a0df8ae2698506", "patch": "@@ -1,9 +1,6 @@\n-// code for @RalfJung's validation branch is dead for now\n-#![allow(dead_code)]\n-\n use rustc::hir::Mutability;\n use rustc::hir::Mutability::*;\n-use rustc::mir;\n+use rustc::mir::{self, ValidationOp, ValidationOperand};\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::subst::Subst;\n use rustc::traits::Reveal;\n@@ -14,28 +11,11 @@ use super::{\n     EvalError, EvalResult, EvalErrorKind,\n     EvalContext, DynamicLifetime,\n     AccessKind, LockInfo,\n-    PrimVal, Value,\n+    Value,\n     Lvalue, LvalueExtra,\n     Machine,\n };\n \n-// FIXME remove this once it lands in rustc\n-#[derive(Copy, Clone, PartialEq, Eq)]\n-pub enum ValidationOp {\n-    Acquire,\n-    Release,\n-    Suspend(CodeExtent),\n-}\n-\n-#[derive(Clone, Debug)]\n-pub struct ValidationOperand<'tcx, T> {\n-    pub lval: T,\n-    pub ty: Ty<'tcx>,\n-    pub re: Option<CodeExtent>,\n-    pub mutbl: Mutability,\n-}\n-// FIXME end\n-\n pub type ValidationQuery<'tcx> = ValidationOperand<'tcx, Lvalue<'tcx>>;\n \n #[derive(Copy, Clone, Debug)]\n@@ -59,26 +39,35 @@ impl ValidationMode {\n // Validity checks\n impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     pub(crate) fn validation_op(&mut self, op: ValidationOp, operand: &ValidationOperand<'tcx, mir::Lvalue<'tcx>>) -> EvalResult<'tcx> {\n+        // If mir-emit-validate is set to 0 (i.e., disabled), we may still see validation commands\n+        // because other crates may have been compiled with mir-emit-validate > 0.  Ignore those\n+        // commands.  This makes mir-emit-validate also a flag to control whether miri will do\n+        // validation or not.\n+        if self.tcx.sess.opts.debugging_opts.mir_emit_validate == 0 {\n+            return Ok(());\n+        }\n+\n         // HACK: Determine if this method is whitelisted and hence we do not perform any validation.\n+        // We currently insta-UB on anything passing around uninitialized memory, so we have to whitelist\n+        // the places that are allowed to do that.\n+        // The second group is stuff libstd does that is forbidden even under relaxed validation.\n         {\n             // The regexp we use for filtering\n             use regex::Regex;\n             lazy_static! {\n                 static ref RE: Regex = Regex::new(\"^(\\\n-std::mem::swap::|\\\n-std::mem::uninitialized::|\\\n-std::ptr::read::|\\\n-std::panicking::try::do_call::|\\\n-std::slice::from_raw_parts_mut::|\\\n-<std::heap::Heap as std::heap::Alloc>::|\\\n-<std::mem::ManuallyDrop<T>><std::heap::AllocErr>::new$|\\\n-<std::mem::ManuallyDrop<T> as std::ops::DerefMut><std::heap::AllocErr>::deref_mut$|\\\n-std::sync::atomic::AtomicBool::get_mut$|\\\n-<std::boxed::Box<T>><[a-zA-Z0-9_\\\\[\\\\]]+>::from_raw|\\\n-<[a-zA-Z0-9_:<>]+ as std::slice::SliceIndex<[a-zA-Z0-9_\\\\[\\\\]]+>><[a-zA-Z0-9_\\\\[\\\\]]+>::get_unchecked_mut$|\\\n-<alloc::raw_vec::RawVec<T, std::heap::Heap>><[a-zA-Z0-9_\\\\[\\\\]]+>::into_box$|\\\n-<std::vec::Vec<T>><[a-zA-Z0-9_\\\\[\\\\]]+>::into_boxed_slice$\\\n-)\").unwrap();\n+                    std::mem::uninitialized::|\\\n+                    std::mem::forget::|\\\n+                    <(std|alloc)::heap::Heap as (std::heap|alloc::allocator)::Alloc>::|\\\n+                    <std::mem::ManuallyDrop<T>><.*>::new$|\\\n+                    <std::mem::ManuallyDrop<T> as std::ops::DerefMut><.*>::deref_mut$|\\\n+                    std::ptr::read::|\\\n+                    \\\n+                    <std::sync::Arc<T>><.*>::inner$|\\\n+                    <std::sync::Arc<T>><.*>::drop_slow$|\\\n+                    (std::heap|alloc::allocator)::Layout::for_value::|\\\n+                    std::mem::(size|align)_of_val::\\\n+                )\").unwrap();\n             }\n             // Now test\n             let name = self.stack[self.cur_frame()].instance.to_string();\n@@ -167,10 +156,11 @@ std::sync::atomic::AtomicBool::get_mut$|\\\n     fn validate(&mut self, query: ValidationQuery<'tcx>, mode: ValidationMode) -> EvalResult<'tcx>\n     {\n         match self.try_validate(query, mode) {\n-            // HACK: If, during releasing, we hit memory we cannot use, we just ignore that.\n-            // This can happen because releases are added before drop elaboration.\n-            // TODO: Fix the MIR so that these releases do not happen.\n-            res @ Err(EvalError{ kind: EvalErrorKind::DanglingPointerDeref, ..}) |\n+            // Releasing an uninitalized variable is a NOP.  This is needed because\n+            // we have to release the return value of a function; due to destination-passing-style\n+            // the callee may directly write there.\n+            // TODO: Ideally we would know whether the destination is already initialized, and only\n+            // release if it is.\n             res @ Err(EvalError{ kind: EvalErrorKind::ReadUndefBytes, ..}) => {\n                 if let ValidationMode::Release = mode {\n                     return Ok(());\n@@ -199,18 +189,13 @@ std::sync::atomic::AtomicBool::get_mut$|\\\n         }\n \n         // HACK: For now, bail out if we hit a dead local during recovery (can happen because sometimes we have\n-        // StorageDead before EndRegion).\n+        // StorageDead before EndRegion due to https://github.com/rust-lang/rust/issues/43481).\n         // TODO: We should rather fix the MIR.\n-        // HACK: Releasing on dead/undef local variables is a NOP.  This can happen because of releases being added\n-        // before drop elaboration.\n-        // TODO: Fix the MIR so that these releases do not happen.\n         match query.lval {\n             Lvalue::Local { frame, local } => {\n                 let res = self.stack[frame].get_local(local);\n                 match (res, mode) {\n-                    (Err(EvalError{ kind: EvalErrorKind::DeadLocal, ..}), ValidationMode::Recover(_)) |\n-                    (Err(EvalError{ kind: EvalErrorKind::DeadLocal, ..}), ValidationMode::Release) |\n-                    (Ok(Value::ByVal(PrimVal::Undef)), ValidationMode::Release) => {\n+                    (Err(EvalError{ kind: EvalErrorKind::DeadLocal, ..}), ValidationMode::Recover(_)) => {\n                         return Ok(());\n                     }\n                     _ => {},"}, {"sha": "88ffc57a8f0688df78c95d2df3b7120c62050b0f", "filename": "src/librustc_mir/interpret/value.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d7666ed282143096e94a763a0df8ae2698506/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d7666ed282143096e94a763a0df8ae2698506/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs?ref=2a1d7666ed282143096e94a763a0df8ae2698506", "patch": "@@ -197,6 +197,7 @@ impl<'a, 'tcx: 'a> Value {\n \n             ByValPair(ptr, vtable) => Ok((ptr.into(), vtable.to_ptr()?)),\n \n+            ByVal(PrimVal::Undef) => err!(ReadUndefBytes),\n             _ => bug!(\"expected ptr and vtable, got {:?}\", self),\n         }\n     }\n@@ -216,6 +217,7 @@ impl<'a, 'tcx: 'a> Value {\n                 assert_eq!(len as u64 as u128, len);\n                 Ok((ptr.into(), len as u64))\n             },\n+            ByVal(PrimVal::Undef) => err!(ReadUndefBytes),\n             ByVal(_) => bug!(\"expected ptr and length, got {:?}\", self),\n         }\n     }"}, {"sha": "912b1bd7d91f26ea2118a2eb8cabcb70ac16b1d3", "filename": "tests/compile-fail/cast_box_int_to_fn_ptr.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d7666ed282143096e94a763a0df8ae2698506/tests%2Fcompile-fail%2Fcast_box_int_to_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d7666ed282143096e94a763a0df8ae2698506/tests%2Fcompile-fail%2Fcast_box_int_to_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_box_int_to_fn_ptr.rs?ref=2a1d7666ed282143096e94a763a0df8ae2698506", "patch": "@@ -1,3 +1,6 @@\n+// Validation makes this fail in the wrong place\n+// compile-flags: -Zmir-emit-validate=0\n+\n fn main() {\n     let b = Box::new(42);\n     let g = unsafe {"}, {"sha": "23f85dbaf3ecbfd8715b50478e8d88ce63dc7e63", "filename": "tests/compile-fail/cast_int_to_fn_ptr.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d7666ed282143096e94a763a0df8ae2698506/tests%2Fcompile-fail%2Fcast_int_to_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d7666ed282143096e94a763a0df8ae2698506/tests%2Fcompile-fail%2Fcast_int_to_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_int_to_fn_ptr.rs?ref=2a1d7666ed282143096e94a763a0df8ae2698506", "patch": "@@ -1,3 +1,6 @@\n+// Validation makes this fail in the wrong place\n+// compile-flags: -Zmir-emit-validate=0\n+\n fn main() {\n     let g = unsafe {\n         std::mem::transmute::<usize, fn(i32)>(42)"}, {"sha": "87d975e1f9d486ab389b00f8ab4906145076541c", "filename": "tests/compile-fail/execute_memory.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d7666ed282143096e94a763a0df8ae2698506/tests%2Fcompile-fail%2Fexecute_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d7666ed282143096e94a763a0df8ae2698506/tests%2Fcompile-fail%2Fexecute_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fexecute_memory.rs?ref=2a1d7666ed282143096e94a763a0df8ae2698506", "patch": "@@ -1,3 +1,6 @@\n+// Validation makes this fail in the wrong place\n+// compile-flags: -Zmir-emit-validate=0\n+\n #![feature(box_syntax)]\n \n fn main() {"}, {"sha": "3e4c5d6ad391651daac0027cbe37f975ceb06d1a", "filename": "tests/compile-fail/fn_ptr_offset.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d7666ed282143096e94a763a0df8ae2698506/tests%2Fcompile-fail%2Ffn_ptr_offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d7666ed282143096e94a763a0df8ae2698506/tests%2Fcompile-fail%2Ffn_ptr_offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffn_ptr_offset.rs?ref=2a1d7666ed282143096e94a763a0df8ae2698506", "patch": "@@ -1,3 +1,6 @@\n+// Validation makes this fail in the wrong place\n+// compile-flags: -Zmir-emit-validate=0\n+\n use std::mem;\n \n fn f() {}"}, {"sha": "9ce6d44ca460ff356dc0effbf20919fb43aaf653", "filename": "tests/compile-fail/invalid_enum_discriminant.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d7666ed282143096e94a763a0df8ae2698506/tests%2Fcompile-fail%2Finvalid_enum_discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d7666ed282143096e94a763a0df8ae2698506/tests%2Fcompile-fail%2Finvalid_enum_discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Finvalid_enum_discriminant.rs?ref=2a1d7666ed282143096e94a763a0df8ae2698506", "patch": "@@ -1,3 +1,6 @@\n+// Validation makes this fail in the wrong place\n+// compile-flags: -Zmir-emit-validate=0\n+\n #[repr(C)]\n pub enum Foo {\n     A, B, C, D"}, {"sha": "ee245daa310694c3a58f45aa1ebbcdb5b5ab4fba", "filename": "tests/compile-fail/memleak_rc.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d7666ed282143096e94a763a0df8ae2698506/tests%2Fcompile-fail%2Fmemleak_rc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d7666ed282143096e94a763a0df8ae2698506/tests%2Fcompile-fail%2Fmemleak_rc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmemleak_rc.rs?ref=2a1d7666ed282143096e94a763a0df8ae2698506", "patch": "@@ -1,3 +1,6 @@\n+// FIXME: Due to https://github.com/rust-lang/rust/issues/43457 we have to disable validation\n+// compile-flags: -Zmir-emit-validate=0\n+\n //error-pattern: the evaluated program leaked memory\n \n use std::rc::Rc;"}, {"sha": "dbe80fecd00f1157ff82654647e6557ca9da220d", "filename": "tests/compile-fail/panic.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d7666ed282143096e94a763a0df8ae2698506/tests%2Fcompile-fail%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d7666ed282143096e94a763a0df8ae2698506/tests%2Fcompile-fail%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpanic.rs?ref=2a1d7666ed282143096e94a763a0df8ae2698506", "patch": "@@ -1,3 +1,6 @@\n+// FIXME: Due to https://github.com/rust-lang/rust/issues/43457 we have to disable validation\n+// compile-flags: -Zmir-emit-validate=0\n+\n //error-pattern: the evaluated program panicked\n \n fn main() {"}, {"sha": "f030a9c281de7fff0b1501b0a21fb3a81c289f62", "filename": "tests/compile-fail/static_memory_modification2.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d7666ed282143096e94a763a0df8ae2698506/tests%2Fcompile-fail%2Fstatic_memory_modification2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d7666ed282143096e94a763a0df8ae2698506/tests%2Fcompile-fail%2Fstatic_memory_modification2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstatic_memory_modification2.rs?ref=2a1d7666ed282143096e94a763a0df8ae2698506", "patch": "@@ -1,3 +1,6 @@\n+// Validation detects that we are casting & to &mut and so it changes why we fail\n+// compile-flags: -Zmir-emit-validate=0\n+\n use std::mem::transmute;\n \n #[allow(mutable_transmutes)]"}, {"sha": "0c46acb8ade40501bbcec8483f222f4a082773e2", "filename": "tests/compile-fail/zst2.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d7666ed282143096e94a763a0df8ae2698506/tests%2Fcompile-fail%2Fzst2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d7666ed282143096e94a763a0df8ae2698506/tests%2Fcompile-fail%2Fzst2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fzst2.rs?ref=2a1d7666ed282143096e94a763a0df8ae2698506", "patch": "@@ -1,3 +1,6 @@\n+// FIXME: Due to https://github.com/rust-lang/rust/issues/43457 we have to disable validation\n+// compile-flags: -Zmir-emit-validate=0\n+\n // error-pattern: the evaluated program panicked\n \n #[derive(Debug)]"}, {"sha": "a6d7fdd35521d8d9604a1680256b2fff3321cce8", "filename": "tests/compile-fail/zst3.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d7666ed282143096e94a763a0df8ae2698506/tests%2Fcompile-fail%2Fzst3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d7666ed282143096e94a763a0df8ae2698506/tests%2Fcompile-fail%2Fzst3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fzst3.rs?ref=2a1d7666ed282143096e94a763a0df8ae2698506", "patch": "@@ -1,3 +1,6 @@\n+// FIXME: Due to https://github.com/rust-lang/rust/issues/43457 we have to disable validation\n+// compile-flags: -Zmir-emit-validate=0\n+\n // error-pattern: the evaluated program panicked\n \n #[derive(Debug)]"}, {"sha": "7d1829adb5a4d31e63b474951bdfba03ea9adb76", "filename": "tests/compiletest.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d7666ed282143096e94a763a0df8ae2698506/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d7666ed282143096e94a763a0df8ae2698506/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=2a1d7666ed282143096e94a763a0df8ae2698506", "patch": "@@ -20,6 +20,7 @@ fn compile_fail(sysroot: &Path, path: &str, target: &str, host: &str, fullmir: b\n     let mut config = compiletest::default_config();\n     config.mode = \"compile-fail\".parse().expect(\"Invalid mode\");\n     config.rustc_path = MIRI_PATH.into();\n+    let mut flags = Vec::new();\n     if fullmir {\n         if host != target {\n             // skip fullmir on nonhost\n@@ -32,6 +33,8 @@ fn compile_fail(sysroot: &Path, path: &str, target: &str, host: &str, fullmir: b\n         config.target_rustcflags = Some(format!(\"--sysroot {}\", sysroot.to_str().unwrap()));\n         config.src_base = PathBuf::from(path.to_string());\n     }\n+    flags.push(\"-Zmir-emit-validate=1\".to_owned());\n+    config.target_rustcflags = Some(flags.join(\" \"));\n     config.target = target.to_owned();\n     compiletest::run_tests(&config);\n }\n@@ -72,6 +75,8 @@ fn miri_pass(path: &str, target: &str, host: &str, fullmir: bool, opt: bool) {\n         flags.push(\"-Zmir-opt-level=3\".to_owned());\n     } else {\n         flags.push(\"-Zmir-opt-level=0\".to_owned());\n+        // For now, only validate without optimizations.  Inlining breaks validation.\n+        flags.push(\"-Zmir-emit-validate=1\".to_owned());\n     }\n     config.target_rustcflags = Some(flags.join(\" \"));\n     // don't actually execute the final binary, it might be for other targets and we only care"}, {"sha": "6eeb7cd5117e928c84564d99302dbf84a6967d4a", "filename": "tests/run-pass-fullmir/regions-mock-trans.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d7666ed282143096e94a763a0df8ae2698506/tests%2Frun-pass-fullmir%2Fregions-mock-trans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d7666ed282143096e94a763a0df8ae2698506/tests%2Frun-pass-fullmir%2Fregions-mock-trans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fregions-mock-trans.rs?ref=2a1d7666ed282143096e94a763a0df8ae2698506", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// pretty-expanded FIXME #23616\n+// FIXME: We handle uninitialzied storage here, which currently makes validation fail.\n+// compile-flags: -Zmir-emit-validate=0\n \n #![feature(libc)]\n "}, {"sha": "ba1ef6d704314596dc385f29ce1cb884b272531d", "filename": "tests/run-pass/rc.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d7666ed282143096e94a763a0df8ae2698506/tests%2Frun-pass%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d7666ed282143096e94a763a0df8ae2698506/tests%2Frun-pass%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Frc.rs?ref=2a1d7666ed282143096e94a763a0df8ae2698506", "patch": "@@ -1,3 +1,6 @@\n+// FIXME: Due to https://github.com/rust-lang/rust/issues/43457 we have to disable validation\n+// compile-flags: -Zmir-emit-validate=0\n+\n use std::cell::RefCell;\n use std::rc::Rc;\n "}, {"sha": "d259ca6361c978ed3bfa54e847b7226c50943d4d", "filename": "tests/run-pass/recursive_static.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d7666ed282143096e94a763a0df8ae2698506/tests%2Frun-pass%2Frecursive_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d7666ed282143096e94a763a0df8ae2698506/tests%2Frun-pass%2Frecursive_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Frecursive_static.rs?ref=2a1d7666ed282143096e94a763a0df8ae2698506", "patch": "@@ -1,3 +1,6 @@\n+// FIXME: Disable validation until we figure out how to handle recursive statics.\n+// compile-flags: -Zmir-emit-validate=0\n+\n struct S(&'static S);\n static S1: S = S(&S2);\n static S2: S = S(&S1);"}, {"sha": "19ff4b30db1d7c96fb9c94c8d8b2d9da0eed78fb", "filename": "tests/run-pass/send-is-not-static-par-for.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d7666ed282143096e94a763a0df8ae2698506/tests%2Frun-pass%2Fsend-is-not-static-par-for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d7666ed282143096e94a763a0df8ae2698506/tests%2Frun-pass%2Fsend-is-not-static-par-for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fsend-is-not-static-par-for.rs?ref=2a1d7666ed282143096e94a763a0df8ae2698506", "patch": "@@ -10,6 +10,9 @@\n \n //ignore-windows\n \n+// FIXME: Due to https://github.com/rust-lang/rust/issues/43457 we have to disable validation\n+// compile-flags: -Zmir-emit-validate=0\n+\n use std::sync::Mutex;\n \n fn par_for<I, F>(iter: I, f: F)"}, {"sha": "b15307bb48d834b218036c06b6685182964eb301", "filename": "tests/run-pass/std.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d7666ed282143096e94a763a0df8ae2698506/tests%2Frun-pass%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d7666ed282143096e94a763a0df8ae2698506/tests%2Frun-pass%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fstd.rs?ref=2a1d7666ed282143096e94a763a0df8ae2698506", "patch": "@@ -1,3 +1,6 @@\n+// FIXME: Due to https://github.com/rust-lang/rust/issues/43457 we have to disable validation\n+// compile-flags: -Zmir-emit-validate=0\n+\n use std::cell::{Cell, RefCell};\n use std::rc::Rc;\n use std::sync::Arc;"}, {"sha": "d4b0d06024afd86afb26384c54d3559436acc579", "filename": "xargo/build.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d7666ed282143096e94a763a0df8ae2698506/xargo%2Fbuild.sh", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d7666ed282143096e94a763a0df8ae2698506/xargo%2Fbuild.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xargo%2Fbuild.sh?ref=2a1d7666ed282143096e94a763a0df8ae2698506", "patch": "@@ -1,3 +1,3 @@\n #!/bin/bash\n cd \"$(readlink -e \"$(dirname \"$0\")\")\"\n-RUSTFLAGS='-Zalways-encode-mir' xargo build\n+RUSTFLAGS='-Zalways-encode-mir -Zmir-emit-validate=1' xargo build"}]}