{"sha": "d21b0e35e7c5a74e1042a66c409d0ebe6fd9a72f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyMWIwZTM1ZTdjNWE3NGUxMDQyYTY2YzQwOWQwZWJlNmZkOWE3MmY=", "commit": {"author": {"name": "Cengiz Can", "email": "canc@thoughtworks.com", "date": "2017-02-27T19:09:13Z"}, "committer": {"name": "Cengiz Can", "email": "canc@thoughtworks.com", "date": "2017-02-27T19:09:13Z"}, "message": "Move two large error_reporting fn's to a separate file", "tree": {"sha": "0747072e56edd683ca3421b870c3a0b9a896e5b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0747072e56edd683ca3421b870c3a0b9a896e5b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d21b0e35e7c5a74e1042a66c409d0ebe6fd9a72f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d21b0e35e7c5a74e1042a66c409d0ebe6fd9a72f", "html_url": "https://github.com/rust-lang/rust/commit/d21b0e35e7c5a74e1042a66c409d0ebe6fd9a72f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d21b0e35e7c5a74e1042a66c409d0ebe6fd9a72f/comments", "author": null, "committer": null, "parents": [{"sha": "0ed75e1f47d099a17de22eb2c1d2b43ce89ea390", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ed75e1f47d099a17de22eb2c1d2b43ce89ea390", "html_url": "https://github.com/rust-lang/rust/commit/0ed75e1f47d099a17de22eb2c1d2b43ce89ea390"}], "stats": {"total": 945, "additions": 478, "deletions": 467}, "files": [{"sha": "21139c8dde2a4b34b96c22becfc1b483728c9dfb", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "renamed", "additions": 8, "deletions": 462, "changes": 470, "blob_url": "https://github.com/rust-lang/rust/blob/d21b0e35e7c5a74e1042a66c409d0ebe6fd9a72f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d21b0e35e7c5a74e1042a66c409d0ebe6fd9a72f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=d21b0e35e7c5a74e1042a66c409d0ebe6fd9a72f", "patch": "@@ -55,32 +55,25 @@\n //! ported to this system, and which relies on string concatenation at the\n //! time of error detection.\n \n-use super::InferCtxt;\n-use super::TypeTrace;\n-use super::SubregionOrigin;\n-use super::RegionVariableOrigin;\n-use super::ValuePairs;\n-use super::region_inference::RegionResolutionError;\n-use super::region_inference::ConcreteFailure;\n-use super::region_inference::SubSupConflict;\n-use super::region_inference::GenericBoundFailure;\n-use super::region_inference::GenericKind;\n+use infer;\n+use super::{InferCtxt, TypeTrace, SubregionOrigin, RegionVariableOrigin, ValuePairs};\n+use super::region_inference::{RegionResolutionError, ConcreteFailure, SubSupConflict,\n+                              GenericBoundFailure, GenericKind};\n \n-use hir::map as hir_map;\n+use std::fmt;\n use hir;\n-\n+use hir::map as hir_map;\n use hir::def_id::DefId;\n-use infer;\n use middle::region;\n use traits::{ObligationCause, ObligationCauseCode};\n use ty::{self, TyCtxt, TypeFoldable};\n use ty::{Region, Issue32330};\n use ty::error::TypeError;\n-\n-use std::fmt;\n use syntax_pos::{Pos, Span};\n use errors::DiagnosticBuilder;\n \n+mod note;\n+\n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn note_and_explain_region(self,\n                                    err: &mut DiagnosticBuilder,\n@@ -584,289 +577,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         err.emit();\n     }\n \n-    fn report_concrete_failure(&self,\n-                               origin: SubregionOrigin<'tcx>,\n-                               sub: &'tcx Region,\n-                               sup: &'tcx Region)\n-                                -> DiagnosticBuilder<'tcx> {\n-        match origin {\n-            infer::Subtype(trace) => {\n-                let terr = TypeError::RegionsDoesNotOutlive(sup, sub);\n-                self.report_and_explain_type_error(trace, &terr)\n-            }\n-            infer::Reborrow(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0312,\n-                    \"lifetime of reference outlives \\\n-                     lifetime of borrowed content...\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"...the reference is valid for \",\n-                    sub,\n-                    \"...\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"...but the borrowed content is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::ReborrowUpvar(span, ref upvar_id) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0313,\n-                    \"lifetime of borrowed pointer outlives \\\n-                            lifetime of captured variable `{}`...\",\n-                            self.tcx.local_var_name_str(upvar_id.var_id));\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"...the borrowed pointer is valid for \",\n-                    sub,\n-                    \"...\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    &format!(\"...but `{}` is only valid for \",\n-                             self.tcx.local_var_name_str(upvar_id.var_id)),\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::InfStackClosure(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0314,\n-                    \"closure outlives stack frame\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"...the closure must be valid for \",\n-                    sub,\n-                    \"...\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"...but the closure's stack frame is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::InvokeClosure(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0315,\n-                    \"cannot invoke closure outside of its lifetime\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"the closure is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::DerefPointer(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0473,\n-                          \"dereference of reference outside its lifetime\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"the reference is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::FreeVariable(span, id) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0474,\n-                          \"captured variable `{}` does not outlive the enclosing closure\",\n-                          self.tcx.local_var_name_str(id));\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"captured variable is valid for \",\n-                    sup,\n-                    \"\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"closure is valid for \",\n-                    sub,\n-                    \"\");\n-                err\n-            }\n-            infer::IndexSlice(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0475,\n-                          \"index of slice outside its lifetime\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"the slice is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::RelateObjectBound(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0476,\n-                          \"lifetime of the source pointer does not outlive \\\n-                           lifetime bound of the object type\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"object type is valid for \",\n-                    sub,\n-                    \"\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"source pointer is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::RelateParamBound(span, ty) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0477,\n-                          \"the type `{}` does not fulfill the required lifetime\",\n-                          self.ty_to_string(ty));\n-                self.tcx.note_and_explain_region(&mut err,\n-                                        \"type must outlive \",\n-                                        sub,\n-                                        \"\");\n-                err\n-            }\n-            infer::RelateRegionParamBound(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0478,\n-                          \"lifetime bound not satisfied\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"lifetime parameter instantiated with \",\n-                    sup,\n-                    \"\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"but lifetime parameter must outlive \",\n-                    sub,\n-                    \"\");\n-                err\n-            }\n-            infer::RelateDefaultParamBound(span, ty) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0479,\n-                          \"the type `{}` (provided as the value of \\\n-                           a type parameter) is not valid at this point\",\n-                          self.ty_to_string(ty));\n-                self.tcx.note_and_explain_region(&mut err,\n-                                        \"type must outlive \",\n-                                        sub,\n-                                        \"\");\n-                err\n-            }\n-            infer::CallRcvr(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0480,\n-                          \"lifetime of method receiver does not outlive \\\n-                           the method call\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"the receiver is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::CallArg(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0481,\n-                          \"lifetime of function argument does not outlive \\\n-                           the function call\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"the function argument is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::CallReturn(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0482,\n-                          \"lifetime of return value does not outlive \\\n-                           the function call\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"the return value is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::Operand(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0483,\n-                          \"lifetime of operand does not outlive \\\n-                           the operation\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"the operand is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::AddrOf(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0484,\n-                          \"reference is not valid at the time of borrow\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"the borrow is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::AutoBorrow(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0485,\n-                          \"automatically reference is not valid \\\n-                           at the time of borrow\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"the automatic borrow is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::ExprTypeIsNotInScope(t, span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0486,\n-                          \"type of expression contains references \\\n-                           that are not valid during the expression: `{}`\",\n-                          self.ty_to_string(t));\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"type is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::SafeDestructor(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0487,\n-                          \"unsafe use of destructor: destructor might be called \\\n-                           while references are dead\");\n-                // FIXME (22171): terms \"super/subregion\" are suboptimal\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"superregion: \",\n-                    sup,\n-                    \"\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"subregion: \",\n-                    sub,\n-                    \"\");\n-                err\n-            }\n-            infer::BindingTypeIsNotValidAtDecl(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0488,\n-                          \"lifetime of variable does not enclose its declaration\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"the variable is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::ParameterInScope(_, span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0489,\n-                          \"type/lifetime parameter not in scope here\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"the parameter is only valid for \",\n-                    sub,\n-                    \"\");\n-                err\n-            }\n-            infer::DataBorrowed(ty, span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0490,\n-                          \"a value of type `{}` is borrowed for too long\",\n-                          self.ty_to_string(ty));\n-                self.tcx.note_and_explain_region(&mut err, \"the type is valid for \", sub, \"\");\n-                self.tcx.note_and_explain_region(&mut err, \"but the borrow lasts for \", sup, \"\");\n-                err\n-            }\n-            infer::ReferenceOutlivesReferent(ty, span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0491,\n-                          \"in type `{}`, reference has a longer lifetime \\\n-                           than the data it references\",\n-                          self.ty_to_string(ty));\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"the pointer is valid for \",\n-                    sub,\n-                    \"\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"but the referenced data is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::CompareImplMethodObligation { span,\n-                                                 item_name,\n-                                                 impl_item_def_id,\n-                                                 trait_item_def_id,\n-                                                 lint_id } => {\n-                self.report_extra_impl_obligation(span,\n-                                                  item_name,\n-                                                  impl_item_def_id,\n-                                                  trait_item_def_id,\n-                                                  &format!(\"`{}: {}`\", sup, sub),\n-                                                  lint_id)\n-            }\n-        }\n-    }\n-\n     fn report_sub_sup_conflict(&self,\n                                var_origin: RegionVariableOrigin,\n                                sub_origin: SubregionOrigin<'tcx>,\n@@ -939,170 +649,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                    due to conflicting requirements\",\n                   var_description)\n     }\n-\n-    fn note_region_origin(&self, err: &mut DiagnosticBuilder, origin: &SubregionOrigin<'tcx>) {\n-        match *origin {\n-            infer::Subtype(ref trace) => {\n-                if let Some((expected, found)) = self.values_str(&trace.values) {\n-                    // FIXME: do we want a \"the\" here?\n-                    err.span_note(\n-                        trace.cause.span,\n-                        &format!(\"...so that {} (expected {}, found {})\",\n-                                 trace.cause.as_requirement_str(), expected, found));\n-                } else {\n-                    // FIXME: this really should be handled at some earlier stage. Our\n-                    // handling of region checking when type errors are present is\n-                    // *terrible*.\n-\n-                    err.span_note(\n-                        trace.cause.span,\n-                        &format!(\"...so that {}\",\n-                                 trace.cause.as_requirement_str()));\n-                }\n-            }\n-            infer::Reborrow(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that reference does not outlive \\\n-                    borrowed content\");\n-            }\n-            infer::ReborrowUpvar(span, ref upvar_id) => {\n-                err.span_note(\n-                    span,\n-                    &format!(\n-                        \"...so that closure can access `{}`\",\n-                        self.tcx.local_var_name_str(upvar_id.var_id)\n-                            .to_string()));\n-            }\n-            infer::InfStackClosure(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that closure does not outlive its stack frame\");\n-            }\n-            infer::InvokeClosure(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that closure is not invoked outside its lifetime\");\n-            }\n-            infer::DerefPointer(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that pointer is not dereferenced \\\n-                    outside its lifetime\");\n-            }\n-            infer::FreeVariable(span, id) => {\n-                err.span_note(\n-                    span,\n-                    &format!(\"...so that captured variable `{}` \\\n-                            does not outlive the enclosing closure\",\n-                            self.tcx.local_var_name_str(id)));\n-            }\n-            infer::IndexSlice(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that slice is not indexed outside the lifetime\");\n-            }\n-            infer::RelateObjectBound(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that it can be closed over into an object\");\n-            }\n-            infer::CallRcvr(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that method receiver is valid for the method call\");\n-            }\n-            infer::CallArg(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that argument is valid for the call\");\n-            }\n-            infer::CallReturn(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that return value is valid for the call\");\n-            }\n-            infer::Operand(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that operand is valid for operation\");\n-            }\n-            infer::AddrOf(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that reference is valid \\\n-                     at the time of borrow\");\n-            }\n-            infer::AutoBorrow(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that auto-reference is valid \\\n-                     at the time of borrow\");\n-            }\n-            infer::ExprTypeIsNotInScope(t, span) => {\n-                err.span_note(\n-                    span,\n-                    &format!(\"...so type `{}` of expression is valid during the \\\n-                             expression\",\n-                            self.ty_to_string(t)));\n-            }\n-            infer::BindingTypeIsNotValidAtDecl(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that variable is valid at time of its declaration\");\n-            }\n-            infer::ParameterInScope(_, span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that a type/lifetime parameter is in scope here\");\n-            }\n-            infer::DataBorrowed(ty, span) => {\n-                err.span_note(\n-                    span,\n-                    &format!(\"...so that the type `{}` is not borrowed for too long\",\n-                             self.ty_to_string(ty)));\n-            }\n-            infer::ReferenceOutlivesReferent(ty, span) => {\n-                err.span_note(\n-                    span,\n-                    &format!(\"...so that the reference type `{}` \\\n-                             does not outlive the data it points at\",\n-                            self.ty_to_string(ty)));\n-            }\n-            infer::RelateParamBound(span, t) => {\n-                err.span_note(\n-                    span,\n-                    &format!(\"...so that the type `{}` \\\n-                             will meet its required lifetime bounds\",\n-                            self.ty_to_string(t)));\n-            }\n-            infer::RelateDefaultParamBound(span, t) => {\n-                err.span_note(\n-                    span,\n-                    &format!(\"...so that type parameter \\\n-                             instantiated with `{}`, \\\n-                             will meet its declared lifetime bounds\",\n-                            self.ty_to_string(t)));\n-            }\n-            infer::RelateRegionParamBound(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that the declared lifetime parameter bounds \\\n-                                are satisfied\");\n-            }\n-            infer::SafeDestructor(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that references are valid when the destructor \\\n-                     runs\");\n-            }\n-            infer::CompareImplMethodObligation { span, .. } => {\n-                err.span_note(\n-                    span,\n-                    \"...so that the definition in impl matches the definition from the trait\");\n-            }\n-        }\n-    }\n }\n \n impl<'tcx> ObligationCause<'tcx> {", "previous_filename": "src/librustc/infer/error_reporting.rs"}, {"sha": "a711d031dd699eff4af400179b9dd30f2d83cbc4", "filename": "src/librustc/infer/error_reporting/note.rs", "status": "added", "additions": 465, "deletions": 0, "changes": 465, "blob_url": "https://github.com/rust-lang/rust/blob/d21b0e35e7c5a74e1042a66c409d0ebe6fd9a72f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d21b0e35e7c5a74e1042a66c409d0ebe6fd9a72f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=d21b0e35e7c5a74e1042a66c409d0ebe6fd9a72f", "patch": "@@ -0,0 +1,465 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use infer::{self, InferCtxt, SubregionOrigin};\n+use ty::Region;\n+use ty::error::TypeError;\n+use errors::DiagnosticBuilder;\n+\n+impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+    pub fn note_region_origin(&self, err: &mut DiagnosticBuilder, origin: &SubregionOrigin<'tcx>) {\n+        match *origin {\n+            infer::Subtype(ref trace) => {\n+                if let Some((expected, found)) = self.values_str(&trace.values) {\n+                    // FIXME: do we want a \"the\" here?\n+                    err.span_note(\n+                        trace.cause.span,\n+                        &format!(\"...so that {} (expected {}, found {})\",\n+                                 trace.cause.as_requirement_str(), expected, found));\n+                } else {\n+                    // FIXME: this really should be handled at some earlier stage. Our\n+                    // handling of region checking when type errors are present is\n+                    // *terrible*.\n+\n+                    err.span_note(\n+                        trace.cause.span,\n+                        &format!(\"...so that {}\",\n+                                 trace.cause.as_requirement_str()));\n+                }\n+            }\n+            infer::Reborrow(span) => {\n+                err.span_note(\n+                    span,\n+                    \"...so that reference does not outlive \\\n+                    borrowed content\");\n+            }\n+            infer::ReborrowUpvar(span, ref upvar_id) => {\n+                err.span_note(\n+                    span,\n+                    &format!(\n+                        \"...so that closure can access `{}`\",\n+                        self.tcx.local_var_name_str(upvar_id.var_id)\n+                            .to_string()));\n+            }\n+            infer::InfStackClosure(span) => {\n+                err.span_note(\n+                    span,\n+                    \"...so that closure does not outlive its stack frame\");\n+            }\n+            infer::InvokeClosure(span) => {\n+                err.span_note(\n+                    span,\n+                    \"...so that closure is not invoked outside its lifetime\");\n+            }\n+            infer::DerefPointer(span) => {\n+                err.span_note(\n+                    span,\n+                    \"...so that pointer is not dereferenced \\\n+                    outside its lifetime\");\n+            }\n+            infer::FreeVariable(span, id) => {\n+                err.span_note(\n+                    span,\n+                    &format!(\"...so that captured variable `{}` \\\n+                            does not outlive the enclosing closure\",\n+                             self.tcx.local_var_name_str(id)));\n+            }\n+            infer::IndexSlice(span) => {\n+                err.span_note(\n+                    span,\n+                    \"...so that slice is not indexed outside the lifetime\");\n+            }\n+            infer::RelateObjectBound(span) => {\n+                err.span_note(\n+                    span,\n+                    \"...so that it can be closed over into an object\");\n+            }\n+            infer::CallRcvr(span) => {\n+                err.span_note(\n+                    span,\n+                    \"...so that method receiver is valid for the method call\");\n+            }\n+            infer::CallArg(span) => {\n+                err.span_note(\n+                    span,\n+                    \"...so that argument is valid for the call\");\n+            }\n+            infer::CallReturn(span) => {\n+                err.span_note(\n+                    span,\n+                    \"...so that return value is valid for the call\");\n+            }\n+            infer::Operand(span) => {\n+                err.span_note(\n+                    span,\n+                    \"...so that operand is valid for operation\");\n+            }\n+            infer::AddrOf(span) => {\n+                err.span_note(\n+                    span,\n+                    \"...so that reference is valid \\\n+                     at the time of borrow\");\n+            }\n+            infer::AutoBorrow(span) => {\n+                err.span_note(\n+                    span,\n+                    \"...so that auto-reference is valid \\\n+                     at the time of borrow\");\n+            }\n+            infer::ExprTypeIsNotInScope(t, span) => {\n+                err.span_note(\n+                    span,\n+                    &format!(\"...so type `{}` of expression is valid during the \\\n+                             expression\",\n+                             self.ty_to_string(t)));\n+            }\n+            infer::BindingTypeIsNotValidAtDecl(span) => {\n+                err.span_note(\n+                    span,\n+                    \"...so that variable is valid at time of its declaration\");\n+            }\n+            infer::ParameterInScope(_, span) => {\n+                err.span_note(\n+                    span,\n+                    \"...so that a type/lifetime parameter is in scope here\");\n+            }\n+            infer::DataBorrowed(ty, span) => {\n+                err.span_note(\n+                    span,\n+                    &format!(\"...so that the type `{}` is not borrowed for too long\",\n+                             self.ty_to_string(ty)));\n+            }\n+            infer::ReferenceOutlivesReferent(ty, span) => {\n+                err.span_note(\n+                    span,\n+                    &format!(\"...so that the reference type `{}` \\\n+                             does not outlive the data it points at\",\n+                             self.ty_to_string(ty)));\n+            }\n+            infer::RelateParamBound(span, t) => {\n+                err.span_note(\n+                    span,\n+                    &format!(\"...so that the type `{}` \\\n+                             will meet its required lifetime bounds\",\n+                             self.ty_to_string(t)));\n+            }\n+            infer::RelateDefaultParamBound(span, t) => {\n+                err.span_note(\n+                    span,\n+                    &format!(\"...so that type parameter \\\n+                             instantiated with `{}`, \\\n+                             will meet its declared lifetime bounds\",\n+                             self.ty_to_string(t)));\n+            }\n+            infer::RelateRegionParamBound(span) => {\n+                err.span_note(\n+                    span,\n+                    \"...so that the declared lifetime parameter bounds \\\n+                                are satisfied\");\n+            }\n+            infer::SafeDestructor(span) => {\n+                err.span_note(\n+                    span,\n+                    \"...so that references are valid when the destructor \\\n+                     runs\");\n+            }\n+            infer::CompareImplMethodObligation { span, .. } => {\n+                err.span_note(\n+                    span,\n+                    \"...so that the definition in impl matches the definition from the trait\");\n+            }\n+        }\n+    }\n+\n+    pub fn report_concrete_failure(&self,\n+                               origin: SubregionOrigin<'tcx>,\n+                               sub: &'tcx Region,\n+                               sup: &'tcx Region)\n+                               -> DiagnosticBuilder<'tcx> {\n+        match origin {\n+            infer::Subtype(trace) => {\n+                let terr = TypeError::RegionsDoesNotOutlive(sup, sub);\n+                self.report_and_explain_type_error(trace, &terr)\n+            }\n+            infer::Reborrow(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0312,\n+                        \"lifetime of reference outlives \\\n+                         lifetime of borrowed content...\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"...the reference is valid for \",\n+                                                 sub,\n+                                                 \"...\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"...but the borrowed content is only valid for \",\n+                                                 sup,\n+                                                 \"\");\n+                err\n+            }\n+            infer::ReborrowUpvar(span, ref upvar_id) => {\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0313,\n+                        \"lifetime of borrowed pointer outlives \\\n+                                lifetime of captured variable `{}`...\",\n+                                self.tcx.local_var_name_str(upvar_id.var_id));\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"...the borrowed pointer is valid for \",\n+                                                 sub,\n+                                                 \"...\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 &format!(\"...but `{}` is only valid for \",\n+                                                          self.tcx.local_var_name_str(upvar_id.var_id)),\n+                                                 sup,\n+                                                 \"\");\n+                err\n+            }\n+            infer::InfStackClosure(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0314,\n+                        \"closure outlives stack frame\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"...the closure must be valid for \",\n+                                                 sub,\n+                                                 \"...\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"...but the closure's stack frame is only valid for \",\n+                                                 sup,\n+                                                 \"\");\n+                err\n+            }\n+            infer::InvokeClosure(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0315,\n+                        \"cannot invoke closure outside of its lifetime\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"the closure is only valid for \",\n+                                                 sup,\n+                                                 \"\");\n+                err\n+            }\n+            infer::DerefPointer(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0473,\n+                              \"dereference of reference outside its lifetime\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"the reference is only valid for \",\n+                                                 sup,\n+                                                 \"\");\n+                err\n+            }\n+            infer::FreeVariable(span, id) => {\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0474,\n+                              \"captured variable `{}` does not outlive the enclosing closure\",\n+                              self.tcx.local_var_name_str(id));\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"captured variable is valid for \",\n+                                                 sup,\n+                                                 \"\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"closure is valid for \",\n+                                                 sub,\n+                                                 \"\");\n+                err\n+            }\n+            infer::IndexSlice(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0475,\n+                              \"index of slice outside its lifetime\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"the slice is only valid for \",\n+                                                 sup,\n+                                                 \"\");\n+                err\n+            }\n+            infer::RelateObjectBound(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0476,\n+                              \"lifetime of the source pointer does not outlive \\\n+                               lifetime bound of the object type\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"object type is valid for \",\n+                                                 sub,\n+                                                 \"\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"source pointer is only valid for \",\n+                                                 sup,\n+                                                 \"\");\n+                err\n+            }\n+            infer::RelateParamBound(span, ty) => {\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0477,\n+                              \"the type `{}` does not fulfill the required lifetime\",\n+                              self.ty_to_string(ty));\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"type must outlive \",\n+                                                 sub,\n+                                                 \"\");\n+                err\n+            }\n+            infer::RelateRegionParamBound(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0478,\n+                              \"lifetime bound not satisfied\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"lifetime parameter instantiated with \",\n+                                                 sup,\n+                                                 \"\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"but lifetime parameter must outlive \",\n+                                                 sub,\n+                                                 \"\");\n+                err\n+            }\n+            infer::RelateDefaultParamBound(span, ty) => {\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0479,\n+                              \"the type `{}` (provided as the value of \\\n+                               a type parameter) is not valid at this point\",\n+                              self.ty_to_string(ty));\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"type must outlive \",\n+                                                 sub,\n+                                                 \"\");\n+                err\n+            }\n+            infer::CallRcvr(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0480,\n+                              \"lifetime of method receiver does not outlive \\\n+                               the method call\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"the receiver is only valid for \",\n+                                                 sup,\n+                                                 \"\");\n+                err\n+            }\n+            infer::CallArg(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0481,\n+                              \"lifetime of function argument does not outlive \\\n+                               the function call\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"the function argument is only valid for \",\n+                                                 sup,\n+                                                 \"\");\n+                err\n+            }\n+            infer::CallReturn(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0482,\n+                              \"lifetime of return value does not outlive \\\n+                               the function call\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"the return value is only valid for \",\n+                                                 sup,\n+                                                 \"\");\n+                err\n+            }\n+            infer::Operand(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0483,\n+                              \"lifetime of operand does not outlive \\\n+                               the operation\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"the operand is only valid for \",\n+                                                 sup,\n+                                                 \"\");\n+                err\n+            }\n+            infer::AddrOf(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0484,\n+                              \"reference is not valid at the time of borrow\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"the borrow is only valid for \",\n+                                                 sup,\n+                                                 \"\");\n+                err\n+            }\n+            infer::AutoBorrow(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0485,\n+                              \"automatically reference is not valid \\\n+                               at the time of borrow\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"the automatic borrow is only valid for \",\n+                                                 sup,\n+                                                 \"\");\n+                err\n+            }\n+            infer::ExprTypeIsNotInScope(t, span) => {\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0486,\n+                              \"type of expression contains references \\\n+                               that are not valid during the expression: `{}`\",\n+                              self.ty_to_string(t));\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"type is only valid for \",\n+                                                 sup,\n+                                                 \"\");\n+                err\n+            }\n+            infer::SafeDestructor(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0487,\n+                              \"unsafe use of destructor: destructor might be called \\\n+                               while references are dead\");\n+                // FIXME (22171): terms \"super/subregion\" are suboptimal\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"superregion: \",\n+                                                 sup,\n+                                                 \"\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"subregion: \",\n+                                                 sub,\n+                                                 \"\");\n+                err\n+            }\n+            infer::BindingTypeIsNotValidAtDecl(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0488,\n+                              \"lifetime of variable does not enclose its declaration\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"the variable is only valid for \",\n+                                                 sup,\n+                                                 \"\");\n+                err\n+            }\n+            infer::ParameterInScope(_, span) => {\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0489,\n+                              \"type/lifetime parameter not in scope here\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"the parameter is only valid for \",\n+                                                 sub,\n+                                                 \"\");\n+                err\n+            }\n+            infer::DataBorrowed(ty, span) => {\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0490,\n+                              \"a value of type `{}` is borrowed for too long\",\n+                              self.ty_to_string(ty));\n+                self.tcx.note_and_explain_region(&mut err, \"the type is valid for \", sub, \"\");\n+                self.tcx.note_and_explain_region(&mut err, \"but the borrow lasts for \", sup, \"\");\n+                err\n+            }\n+            infer::ReferenceOutlivesReferent(ty, span) => {\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0491,\n+                              \"in type `{}`, reference has a longer lifetime \\\n+                               than the data it references\",\n+                              self.ty_to_string(ty));\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"the pointer is valid for \",\n+                                                 sub,\n+                                                 \"\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"but the referenced data is only valid for \",\n+                                                 sup,\n+                                                 \"\");\n+                err\n+            }\n+            infer::CompareImplMethodObligation {\n+                span,\n+                item_name,\n+                impl_item_def_id,\n+                trait_item_def_id,\n+                lint_id\n+            } => {\n+                self.report_extra_impl_obligation(span,\n+                                                  item_name,\n+                                                  impl_item_def_id,\n+                                                  trait_item_def_id,\n+                                                  &format!(\"`{}: {}`\", sup, sub),\n+                                                  lint_id)\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "6fe9c1f8a34e68ef3c3c8f4ccf61646b84a0f601", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d21b0e35e7c5a74e1042a66c409d0ebe6fd9a72f/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d21b0e35e7c5a74e1042a66c409d0ebe6fd9a72f/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=d21b0e35e7c5a74e1042a66c409d0ebe6fd9a72f", "patch": "@@ -210,7 +210,7 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n /// region that each late-bound region was replaced with.\n pub type SkolemizationMap<'tcx> = FxHashMap<ty::BoundRegion, &'tcx ty::Region>;\n \n-/// See `error_reporting.rs` for more details\n+/// See `error_reporting` module for more details\n #[derive(Clone, Debug)]\n pub enum ValuePairs<'tcx> {\n     Types(ExpectedFound<Ty<'tcx>>),\n@@ -221,7 +221,7 @@ pub enum ValuePairs<'tcx> {\n /// The trace designates the path through inference that we took to\n /// encounter an error or subtyping constraint.\n ///\n-/// See `error_reporting.rs` for more details.\n+/// See `error_reporting` module for more details.\n #[derive(Clone)]\n pub struct TypeTrace<'tcx> {\n     cause: ObligationCause<'tcx>,\n@@ -230,7 +230,7 @@ pub struct TypeTrace<'tcx> {\n \n /// The origin of a `r1 <= r2` constraint.\n ///\n-/// See `error_reporting.rs` for more details\n+/// See `error_reporting` module for more details\n #[derive(Clone, Debug)]\n pub enum SubregionOrigin<'tcx> {\n     // Arose from a subtyping relation\n@@ -348,7 +348,7 @@ pub enum LateBoundRegionConversionTime {\n \n /// Reasons to create a region inference variable\n ///\n-/// See `error_reporting.rs` for more details\n+/// See `error_reporting` module for more details\n #[derive(Clone, Debug)]\n pub enum RegionVariableOrigin {\n     // Region variables created for ill-categorized reasons,\n@@ -1292,7 +1292,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             // this infcx was in use.  This is totally hokey but\n             // otherwise we have a hard time separating legit region\n             // errors from silly ones.\n-            self.report_region_errors(&errors); // see error_reporting.rs\n+            self.report_region_errors(&errors); // see error_reporting module\n         }\n     }\n "}]}