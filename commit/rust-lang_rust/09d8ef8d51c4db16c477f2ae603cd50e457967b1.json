{"sha": "09d8ef8d51c4db16c477f2ae603cd50e457967b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5ZDhlZjhkNTFjNGRiMTZjNDc3ZjJhZTYwM2NkNTBlNDU3OTY3YjE=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-05-17T18:41:41Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-05-17T18:41:41Z"}, "message": "Finally rename std::_xxx to std::xxx\n\nExcept for _task, which is still a keyword.", "tree": {"sha": "fff5a9f1551e4dc8f2a2b92291a039fc73660a29", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fff5a9f1551e4dc8f2a2b92291a039fc73660a29"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09d8ef8d51c4db16c477f2ae603cd50e457967b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09d8ef8d51c4db16c477f2ae603cd50e457967b1", "html_url": "https://github.com/rust-lang/rust/commit/09d8ef8d51c4db16c477f2ae603cd50e457967b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09d8ef8d51c4db16c477f2ae603cd50e457967b1/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60670506569a606fc874cf5cfde07b18449757ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/60670506569a606fc874cf5cfde07b18449757ea", "html_url": "https://github.com/rust-lang/rust/commit/60670506569a606fc874cf5cfde07b18449757ea"}], "stats": {"total": 2448, "additions": 1224, "deletions": 1224}, "files": [{"sha": "60256eeb435a3d7678cf791d500be1ac7a53bcbc", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,7 +1,7 @@\n import driver::session;\n import lib::llvm::llvm;\n import middle::trans;\n-import std::_str;\n+import std::str;\n import std::fs;\n \n import lib::llvm::llvm::ModuleRef;\n@@ -25,15 +25,15 @@ fn llvm_err(session::session sess, str msg) {\n     if ((buf as uint) == 0u) {\n         sess.err(msg);\n     } else {\n-        sess.err(msg + \": \" + _str::str_from_cstr(buf));\n+        sess.err(msg + \": \" + str::str_from_cstr(buf));\n     }\n     fail;\n }\n \n fn link_intrinsics(session::session sess, ModuleRef llmod) {\n     auto path = fs::connect(sess.get_opts().sysroot, \"intrinsics.bc\");\n     auto membuf =\n-        llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(_str::buf(path));\n+        llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(str::buf(path));\n     if ((membuf as uint) == 0u) {\n         llvm_err(sess, \"installation problem: couldn't open intrinstics.bc\");\n         fail;\n@@ -69,12 +69,12 @@ mod write {\n     // Decides what to call an intermediate file, given the name of the output\n     // and the extension to use.\n     fn mk_intermediate_name(str output_path, str extension) -> str {\n-        auto dot_pos = _str::index(output_path, '.' as u8);\n+        auto dot_pos = str::index(output_path, '.' as u8);\n         auto stem;\n         if (dot_pos < 0) {\n             stem = output_path;\n         } else {\n-            stem = _str::substr(output_path, 0u, dot_pos as uint);\n+            stem = str::substr(output_path, 0u, dot_pos as uint);\n         }\n         ret stem + \".\" + extension;\n     }\n@@ -105,12 +105,12 @@ mod write {\n                         auto filename = mk_intermediate_name(output,\n                                                              \"no-opt.bc\");\n                         llvm::LLVMWriteBitcodeToFile(llmod,\n-                                                    _str::buf(filename));\n+                                                    str::buf(filename));\n                     }\n                 }\n                 case (_) {\n                     auto filename = mk_intermediate_name(output, \"bc\");\n-                    llvm::LLVMWriteBitcodeToFile(llmod, _str::buf(filename));\n+                    llvm::LLVMWriteBitcodeToFile(llmod, str::buf(filename));\n                 }\n             }\n         }\n@@ -161,31 +161,31 @@ mod write {\n                 // Always output the bitcode file with --save-temps\n                 auto filename = mk_intermediate_name(output, \"opt.bc\");\n                 llvm::LLVMRunPassManager(pm.llpm, llmod);\n-                llvm::LLVMWriteBitcodeToFile(llmod, _str::buf(output));\n+                llvm::LLVMWriteBitcodeToFile(llmod, str::buf(output));\n                 pm = mk_pass_manager();\n \n                 // Save the assembly file if -S is used\n                 if (opts.output_type == output_type_assembly) {\n                         llvm::LLVMRustWriteOutputFile(pm.llpm, llmod,\n-                               _str::buf(x86::get_target_triple()),\n-                               _str::buf(output), LLVMAssemblyFile);\n+                               str::buf(x86::get_target_triple()),\n+                               str::buf(output), LLVMAssemblyFile);\n                 }\n \n                 // Save the object file for -c or --save-temps alone\n                 // This .o is needed when an exe is built\n                 if ((opts.output_type == output_type_object) ||\n                     (opts.output_type == output_type_exe)) {\n                         llvm::LLVMRustWriteOutputFile(pm.llpm, llmod,\n-                               _str::buf(x86::get_target_triple()),\n-                               _str::buf(output), LLVMObjectFile);\n+                               str::buf(x86::get_target_triple()),\n+                               str::buf(output), LLVMObjectFile);\n                }\n             } else {\n \n                 // If we aren't saving temps then just output the file\n                 // type corresponding to the '-c' or '-S' flag used\n                 llvm::LLVMRustWriteOutputFile(pm.llpm, llmod,\n-                                     _str::buf(x86::get_target_triple()),\n-                                     _str::buf(output),\n+                                     str::buf(x86::get_target_triple()),\n+                                     str::buf(output),\n                                      FileType);\n             }\n \n@@ -201,7 +201,7 @@ mod write {\n         // flag, then output it here\n         llvm::LLVMRunPassManager(pm.llpm, llmod);\n \n-        llvm::LLVMWriteBitcodeToFile(llmod, _str::buf(output));\n+        llvm::LLVMWriteBitcodeToFile(llmod, str::buf(output));\n         llvm::LLVMDisposeModule(llmod);\n \n         if (opts.time_llvm_passes) {"}, {"sha": "839851c4968c7b3b81c89ada4b83fe7894c5c21b", "filename": "src/comp/back/x86.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fx86.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,7 +1,7 @@\n import lib::llvm::llvm;\n import lib::llvm::llvm::ModuleRef;\n-import std::_str;\n-import std::_vec;\n+import std::str;\n+import std::vec;\n import std::os::target_os;\n import util::common::istr;\n \n@@ -241,7 +241,7 @@ fn native_glue(int n_args, abi::native_glue_type ngt) -> vec[str] {\n         }\n         auto m = [\"movl  \" + src_off + \"(%ebp),%eax\",\n                      \"movl  %eax,\" + dst_off + \"(%esp)\"];\n-        ret _str::connect(m, \"\\n\\t\");\n+        ret str::connect(m, \"\\n\\t\");\n     }\n \n     auto carg = bind copy_arg(pass_task, _);\n@@ -259,7 +259,7 @@ fn native_glue(int n_args, abi::native_glue_type ngt) -> vec[str] {\n         + [\"subl  $\" + wstr(n_args) + \", %esp   # esp -= args\",\n               \"andl  $~0xf, %esp    # align esp down\"]\n \n-        + _vec::init_fn[str](carg, (n_args) as uint)\n+        + vec::init_fn[str](carg, (n_args) as uint)\n \n         +  [\"movl  %edx, %edi     # save task from edx to edi\",\n                \"call  *%ecx          # call *%ecx\",\n@@ -278,7 +278,7 @@ fn decl_glue(int align, str prefix, str name, vec[str] insns) -> str {\n     ret \"\\t.globl \" + sym + \"\\n\" +\n         \"\\t.balign \" + istr(align) + \"\\n\" +\n         sym + \":\\n\" +\n-        \"\\t\" + _str::connect(insns, \"\\n\\t\");\n+        \"\\t\" + str::connect(insns, \"\\n\\t\");\n }\n \n \n@@ -291,8 +291,8 @@ fn decl_native_glue(int align, str prefix, abi::native_glue_type ngt, uint n)\n }\n \n fn get_symbol_prefix() -> str {\n-    if (_str::eq(target_os(), \"macos\") ||\n-        _str::eq(target_os(), \"win32\")) {\n+    if (str::eq(target_os(), \"macos\") ||\n+        str::eq(target_os(), \"win32\")) {\n         ret \"_\";\n     } else {\n         ret \"\";\n@@ -313,44 +313,44 @@ fn get_module_asm() -> str {\n                       abi::yield_glue_name(),\n                       rust_yield_glue())]\n \n-        + _vec::init_fn[str](bind decl_native_glue(align, prefix,\n+        + vec::init_fn[str](bind decl_native_glue(align, prefix,\n             abi::ngt_rust, _), (abi::n_native_glues + 1) as uint)\n-        + _vec::init_fn[str](bind decl_native_glue(align, prefix,\n+        + vec::init_fn[str](bind decl_native_glue(align, prefix,\n             abi::ngt_pure_rust, _), (abi::n_native_glues + 1) as uint)\n-        + _vec::init_fn[str](bind decl_native_glue(align, prefix,\n+        + vec::init_fn[str](bind decl_native_glue(align, prefix,\n             abi::ngt_cdecl, _), (abi::n_native_glues + 1) as uint);\n \n \n-    ret _str::connect(glues, \"\\n\\n\");\n+    ret str::connect(glues, \"\\n\\n\");\n }\n \n fn get_meta_sect_name() -> str {\n-    if (_str::eq(target_os(), \"macos\")) {\n+    if (str::eq(target_os(), \"macos\")) {\n         ret \"__DATA,__note.rustc\";\n     }\n-    if (_str::eq(target_os(), \"win32\")) {\n+    if (str::eq(target_os(), \"win32\")) {\n         ret \".note.rustc\";\n     }\n     ret \".note.rustc\";\n }\n \n fn get_data_layout() -> str {\n-    if (_str::eq(target_os(), \"macos\")) {\n+    if (str::eq(target_os(), \"macos\")) {\n       ret \"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64\" +\n         \"-f32:32:32-f64:32:64-v64:64:64-v128:128:128-a0:0:64-f80:128:128\" +\n         \"-n8:16:32\";\n     }\n-    if (_str::eq(target_os(), \"win32\")) {\n+    if (str::eq(target_os(), \"win32\")) {\n       ret \"e-p:32:32-f64:64:64-i64:64:64-f80:32:32-n8:16:32\";\n     }\n     ret \"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\";\n }\n \n fn get_target_triple() -> str {\n-    if (_str::eq(target_os(), \"macos\")) {\n+    if (str::eq(target_os(), \"macos\")) {\n         ret \"i686-apple-darwin\";\n     }\n-    if (_str::eq(target_os(), \"win32\")) {\n+    if (str::eq(target_os(), \"win32\")) {\n         ret \"i686-pc-mingw32\";\n     }\n     ret \"i686-unknown-linux-gnu\";"}, {"sha": "4ccc73f117a9ae65c594cde1f2daccf50f61c35b", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -19,8 +19,8 @@ import std::map::mk_hashmap;\n import std::option;\n import std::option::some;\n import std::option::none;\n-import std::_str;\n-import std::_vec;\n+import std::str;\n+import std::vec;\n import std::io;\n import std::run;\n \n@@ -59,9 +59,9 @@ fn default_environment(session::session sess,\n fn parse_input(session::session sess,\n                       parser::parser p,\n                       str input) -> @ast::crate {\n-    if (_str::ends_with(input, \".rc\")) {\n+    if (str::ends_with(input, \".rc\")) {\n         ret parser::parse_crate_from_crate_file(p);\n-    } else if (_str::ends_with(input, \".rs\")) {\n+    } else if (str::ends_with(input, \".rs\")) {\n         ret parser::parse_crate_from_source_file(p);\n     }\n     sess.err(\"unknown input file type: \" + input);\n@@ -130,7 +130,7 @@ fn pretty_print_input(session::session sess,\n fn version(str argv0) {\n     auto vers = \"unknown version\";\n     auto env_vers = #env(\"CFG_VERSION\");\n-    if (_str::byte_len(env_vers) != 0u) {\n+    if (str::byte_len(env_vers) != 0u) {\n         vers = env_vers;\n     }\n     io::stdout().write_str(#fmt(\"%s %s\\n\", argv0, vers));\n@@ -166,25 +166,25 @@ options:\n }\n \n fn get_os(str triple) -> session::os {\n-    if (_str::find(triple, \"win32\") >= 0 ||\n-        _str::find(triple, \"mingw32\") >= 0 ) {\n+    if (str::find(triple, \"win32\") >= 0 ||\n+        str::find(triple, \"mingw32\") >= 0 ) {\n         ret session::os_win32;\n-    } else if (_str::find(triple, \"darwin\") >= 0) { ret session::os_macos; }\n-    else if (_str::find(triple, \"linux\") >= 0) { ret session::os_linux; }\n+    } else if (str::find(triple, \"darwin\") >= 0) { ret session::os_macos; }\n+    else if (str::find(triple, \"linux\") >= 0) { ret session::os_linux; }\n     else { log_err \"Unknown operating system!\"; fail; }\n }\n \n fn get_arch(str triple) -> session::arch {\n-    if (_str::find(triple, \"i386\") >= 0 ||\n-        _str::find(triple, \"i486\") >= 0 ||\n-        _str::find(triple, \"i586\") >= 0 ||\n-        _str::find(triple, \"i686\") >= 0 ||\n-        _str::find(triple, \"i786\") >= 0 ) {\n+    if (str::find(triple, \"i386\") >= 0 ||\n+        str::find(triple, \"i486\") >= 0 ||\n+        str::find(triple, \"i586\") >= 0 ||\n+        str::find(triple, \"i686\") >= 0 ||\n+        str::find(triple, \"i786\") >= 0 ) {\n         ret session::arch_x86;\n-    } else if (_str::find(triple, \"x86_64\") >= 0) {\n+    } else if (str::find(triple, \"x86_64\") >= 0) {\n         ret session::arch_x64;\n-    } else if (_str::find(triple, \"arm\") >= 0 ||\n-        _str::find(triple, \"xscale\") >= 0 ) {\n+    } else if (str::find(triple, \"arm\") >= 0 ||\n+        str::find(triple, \"xscale\") >= 0 ) {\n         ret session::arch_arm;\n     }\n     else {\n@@ -195,14 +195,14 @@ fn get_arch(str triple) -> session::arch {\n \n fn get_default_sysroot(str binary) -> str {\n     auto dirname = fs::dirname(binary);\n-    if (_str::eq(dirname, binary)) { ret \".\"; }\n+    if (str::eq(dirname, binary)) { ret \".\"; }\n     ret dirname;\n }\n \n fn main(vec[str] args) {\n \n     let str triple =\n-        std::_str::rustrt::str_from_cstr(llvm::llvm::LLVMRustGetHostTriple());\n+        std::str::rustrt::str_from_cstr(llvm::llvm::LLVMRustGetHostTriple());\n \n     let @session::config target_cfg =\n         @rec(os = get_os(triple),\n@@ -221,7 +221,7 @@ fn main(vec[str] args) {\n                     optflag(\"stats\"),\n                     optflag(\"time-passes\"), optflag(\"time-llvm-passes\"),\n                     optflag(\"no-typestate\"), optflag(\"noverify\")];\n-    auto binary = _vec::shift[str](args);\n+    auto binary = vec::shift[str](args);\n     auto match;\n     alt (getopts::getopts(args, opts)) {\n         case (getopts::failure(?f)) {\n@@ -298,7 +298,7 @@ fn main(vec[str] args) {\n         session::session(target_crate_num, target_cfg, sopts,\n                         crate_cache, md, front::codemap::new_codemap());\n \n-    auto n_inputs = _vec::len[str](match.free);\n+    auto n_inputs = vec::len[str](match.free);\n \n     if (glue) {\n         if (n_inputs > 0u) {\n@@ -325,8 +325,8 @@ fn main(vec[str] args) {\n     } else {\n         alt (output_file) {\n             case (none[str]) {\n-                let vec[str] parts = _str::split(ifile, '.' as u8);\n-                _vec::pop[str](parts);\n+                let vec[str] parts = str::split(ifile, '.' as u8);\n+                vec::pop[str](parts);\n                 saved_out_filename = parts.(0);\n                 alt (output_type) {\n                     case (link::output_type_none) { parts += [\"pp\"]; }\n@@ -337,7 +337,7 @@ fn main(vec[str] args) {\n                     case (link::output_type_object) { parts += [\"o\"]; }\n                     case (link::output_type_exe) { parts += [\"o\"]; }\n                 }\n-                auto ofile = _str::connect(parts, \".\");\n+                auto ofile = str::connect(parts, \".\");\n                 compile_input(sess, env, ifile, ofile);\n             }\n             case (some[str](?ofile)) {"}, {"sha": "1b03567aec5b4dc5f817bd674aadef64bf58bd06", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -2,7 +2,7 @@ import front::ast;\n import front::codemap;\n import util::common::span;\n import util::common::ty_mach;\n-import std::_uint;\n+import std::uint;\n import std::term;\n import std::io;\n import std::map;"}, {"sha": "2b5959028d4724f8e5f8ac8245466c3638fa1b8b", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,7 +1,7 @@\n import std::map::hashmap;\n import std::option;\n-import std::_str;\n-import std::_vec;\n+import std::str;\n+import std::vec;\n import util::common::span;\n import util::common::spanned;\n import util::common::ty_mach;\n@@ -454,7 +454,7 @@ fn is_exported(ident i, _mod m) -> bool {\n     for (@ast::view_item vi in m.view_items) {\n         alt (vi.node) {\n             case (ast::view_item_export(?id)) {\n-                if (_str::eq(i, id)) {\n+                if (str::eq(i, id)) {\n                     ret true;\n                 }\n                 count += 1;"}, {"sha": "a9aacd8c6c2e26bc8ad66f71d7cddaba39f9f918", "filename": "src/comp/front/codemap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Ffront%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Ffront%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcodemap.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,4 +1,4 @@\n-import std::_vec;\n+import std::vec;\n \n /* A codemap is a thing that maps uints to file/line/column positions\n  * in a crate. This to make it possible to represent the positions\n@@ -24,18 +24,18 @@ fn new_filemap(str filename, uint start_pos) -> filemap {\n }\n \n fn next_line(filemap file, uint pos) {\n-    _vec::push[uint](file.lines, pos);\n+    vec::push[uint](file.lines, pos);\n }\n \n fn lookup_pos(codemap map, uint pos) -> loc {\n-    auto a = 0u; auto b = _vec::len[filemap](map.files);\n+    auto a = 0u; auto b = vec::len[filemap](map.files);\n     while (b - a > 1u) {\n         auto m = (a + b) / 2u;\n         if (map.files.(m).start_pos > pos) { b = m; }\n         else { a = m; }\n     }\n     auto f = map.files.(a);\n-    a = 0u; b = _vec::len[uint](f.lines);\n+    a = 0u; b = vec::len[uint](f.lines);\n     while (b - a > 1u) {\n         auto m = (a + b) / 2u;\n         if (f.lines.(m) > pos) { b = m; }"}, {"sha": "7d61afc1de9542a06f511645c5675f9f58049063", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -14,9 +14,9 @@ import back::x86;\n import util::common;\n import util::common::span;\n \n-import std::_str;\n-import std::_uint;\n-import std::_vec;\n+import std::str;\n+import std::uint;\n+import std::vec;\n import std::ebml;\n import std::fs;\n import std::io;\n@@ -117,7 +117,7 @@ fn parse_ty(@pstate st, str_def sd) -> ty::t {\n             while (peek(st) as char != ']') {\n                 auto name = \"\";\n                 while (peek(st) as char != '=') {\n-                    name += _str::unsafe_from_byte(next(st));\n+                    name += str::unsafe_from_byte(next(st));\n                 }\n                 st.pos = st.pos + 1u;\n                 fields += [rec(ident=name, mt=parse_mt(st, sd))];\n@@ -155,7 +155,7 @@ fn parse_ty(@pstate st, str_def sd) -> ty::t {\n                 }\n                 auto name = \"\";\n                 while (peek(st) as char != '[') {\n-                    name += _str::unsafe_from_byte(next(st));\n+                    name += str::unsafe_from_byte(next(st));\n                 }\n                 auto func = parse_ty_fn(st, sd);\n                 methods += [rec(proto=proto,\n@@ -205,7 +205,7 @@ fn parse_mt(@pstate st, str_def sd) -> ty::mt {\n fn parse_def(@pstate st, str_def sd) -> ast::def_id {\n     auto def = \"\";\n     while (peek(st) as char != '|') {\n-        def += _str::unsafe_from_byte(next(st));\n+        def += str::unsafe_from_byte(next(st));\n     }\n     st.pos = st.pos + 1u;\n     ret sd(def);\n@@ -260,7 +260,7 @@ fn parse_ty_fn(@pstate st, str_def sd) -> tup(vec[ty::arg], ty::t) {\n \n fn parse_def_id(vec[u8] buf) -> ast::def_id {\n     auto colon_idx = 0u;\n-    auto len = _vec::len[u8](buf);\n+    auto len = vec::len[u8](buf);\n     while (colon_idx < len && buf.(colon_idx) != (':' as u8)) {\n         colon_idx += 1u;\n     }\n@@ -269,10 +269,10 @@ fn parse_def_id(vec[u8] buf) -> ast::def_id {\n         fail;\n     }\n \n-    auto crate_part = _vec::slice[u8](buf, 0u, colon_idx);\n-    auto def_part = _vec::slice[u8](buf, colon_idx + 1u, len);\n-    auto crate_num = _uint::parse_buf(crate_part, 10u) as int;\n-    auto def_num = _uint::parse_buf(def_part, 10u) as int;\n+    auto crate_part = vec::slice[u8](buf, 0u, colon_idx);\n+    auto def_part = vec::slice[u8](buf, colon_idx + 1u, len);\n+    auto crate_num = uint::parse_buf(crate_part, 10u) as int;\n+    auto def_num = uint::parse_buf(def_part, 10u) as int;\n     ret tup(crate_num, def_num);\n }\n \n@@ -289,8 +289,8 @@ fn lookup_hash(&ebml::doc d, fn(vec[u8]) -> bool eq_fn, uint hash)\n     auto belt = metadata::tag_index_buckets_bucket_elt;\n     for each (ebml::doc elt in ebml::tagged_docs(bucket, belt)) {\n         auto pos = ebml::be_uint_from_bytes(elt.data, elt.start, 4u);\n-        if (eq_fn(_vec::slice[u8](elt.data, elt.start+4u, elt.end))) {\n-            _vec::push(result, ebml::doc_at(d.data, pos));\n+        if (eq_fn(vec::slice[u8](elt.data, elt.start+4u, elt.end))) {\n+            vec::push(result, ebml::doc_at(d.data, pos));\n         }\n     }\n     ret result;\n@@ -300,16 +300,16 @@ fn lookup_hash(&ebml::doc d, fn(vec[u8]) -> bool eq_fn, uint hash)\n // definition the path refers to.\n fn resolve_path(vec[ast::ident] path, vec[u8] data) -> vec[ast::def_id] {\n     fn eq_item(vec[u8] data, str s) -> bool {\n-        ret _str::eq(_str::unsafe_from_bytes(data), s);\n+        ret str::eq(str::unsafe_from_bytes(data), s);\n     }\n-    auto s = _str::connect(path, \"::\");\n+    auto s = str::connect(path, \"::\");\n     auto md = ebml::new_doc(data);\n     auto paths = ebml::get_doc(md, metadata::tag_paths);\n     auto eqer = bind eq_item(_, s);\n     let vec[ast::def_id] result = [];\n     for (ebml::doc doc in lookup_hash(paths, eqer, metadata::hash_path(s))) {\n         auto did_doc = ebml::get_doc(doc, metadata::tag_def_id);\n-        _vec::push(result, parse_def_id(ebml::doc_data(did_doc)));\n+        vec::push(result, parse_def_id(ebml::doc_data(did_doc)));\n     }\n     ret result;\n }\n@@ -320,7 +320,7 @@ fn maybe_find_item(int item_id, &ebml::doc items) -> option::t[ebml::doc] {\n     }\n     auto eqer = bind eq_item(_, item_id);\n     auto found = lookup_hash(items, eqer, metadata::hash_def_num(item_id));\n-    if (_vec::len(found) == 0u) {\n+    if (vec::len(found) == 0u) {\n         ret option::none[ebml::doc];\n     } else {\n         ret option::some[ebml::doc](found.(0));\n@@ -345,7 +345,7 @@ fn item_kind(&ebml::doc item) -> u8 {\n \n fn item_symbol(&ebml::doc item) -> str {\n     auto sym = ebml::get_doc(item, metadata::tag_items_data_item_symbol);\n-    ret _str::unsafe_from_bytes(ebml::doc_data(sym));\n+    ret str::unsafe_from_bytes(ebml::doc_data(sym));\n }\n \n fn variant_tag_id(&ebml::doc d) -> ast::def_id {\n@@ -359,13 +359,13 @@ fn item_type(&ebml::doc item, int this_cnum, ty::ctxt tcx) -> ty::t {\n         // that, in turn, links against another crate. We need a mapping\n         // from crate ID to crate \"meta\" attributes as part of the crate\n         // metadata:\n-        auto buf = _str::bytes(s);\n+        auto buf = str::bytes(s);\n         auto external_def_id = parse_def_id(buf);\n         ret tup(this_cnum, external_def_id._1);\n     }\n \n     auto tp = ebml::get_doc(item, metadata::tag_items_data_item_type);\n-    auto s = _str::unsafe_from_bytes(ebml::doc_data(tp));\n+    auto s = str::unsafe_from_bytes(ebml::doc_data(tp));\n     ret parse_ty_data(item.data, this_cnum, tp.start, tp.end - tp.start,\n                       bind parse_external_def_id(this_cnum, _), tcx);\n }\n@@ -384,25 +384,25 @@ fn tag_variant_ids(&ebml::doc item, int this_cnum) -> vec[ast::def_id] {\n     auto v = metadata::tag_items_data_item_variant;\n     for each (ebml::doc p in ebml::tagged_docs(item, v)) {\n         auto ext = parse_def_id(ebml::doc_data(p));\n-        _vec::push[ast::def_id](ids, tup(this_cnum, ext._1));\n+        vec::push[ast::def_id](ids, tup(this_cnum, ext._1));\n     }\n     ret ids;\n }\n \n fn get_metadata_section(str filename) -> option::t[vec[u8]] {\n     auto mb = llvm::LLVMRustCreateMemoryBufferWithContentsOfFile\n-        (_str::buf(filename));\n+        (str::buf(filename));\n     if (mb as int == 0) {ret option::none[vec[u8]];}\n     auto of = mk_object_file(mb);\n     auto si = mk_section_iter(of.llof);\n     while (llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False) {\n         auto name_buf = llvm::LLVMGetSectionName(si.llsi);\n-        auto name = _str::str_from_cstr(name_buf);\n-        if (_str::eq(name, x86::get_meta_sect_name())) {\n+        auto name = str::str_from_cstr(name_buf);\n+        if (str::eq(name, x86::get_meta_sect_name())) {\n             auto cbuf = llvm::LLVMGetSectionContents(si.llsi);\n             auto csz = llvm::LLVMGetSectionSize(si.llsi);\n-            auto cvbuf = cbuf as _vec::vbuf;\n-            ret option::some[vec[u8]](_vec::vec_from_vbuf[u8](cvbuf, csz));\n+            auto cvbuf = cbuf as vec::vbuf;\n+            ret option::some[vec[u8]](vec::vec_from_vbuf[u8](cvbuf, csz));\n         }\n         llvm::LLVMMoveToNextSection(si.llsi);\n     }\n@@ -481,7 +481,7 @@ fn lookup_defs(session::session sess, int cnum, vec[ast::ident] path)\n     -> vec[ast::def] {\n     auto data = sess.get_external_crate(cnum).data;\n \n-    ret _vec::map(bind lookup_def(cnum, data, _),\n+    ret vec::map(bind lookup_def(cnum, data, _),\n                   resolve_path(path, data));\n }\n \n@@ -580,8 +580,8 @@ fn list_file_metadata(str path, io::writer out) {\n fn read_path(&ebml::doc d) -> tup(str, uint) {\n     auto desc = ebml::doc_data(d);\n     auto pos = ebml::be_uint_from_bytes(desc, 0u, 4u);\n-    auto pathbytes = _vec::slice[u8](desc, 4u, _vec::len[u8](desc));\n-    auto path = _str::unsafe_from_bytes(pathbytes);\n+    auto pathbytes = vec::slice[u8](desc, 4u, vec::len[u8](desc));\n+    auto path = str::unsafe_from_bytes(pathbytes);\n     ret tup(path, pos);\n }\n "}, {"sha": "b66c6909e61064bf09ff2e86705090d494b6d9b9", "filename": "src/comp/front/eval.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Ffront%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Ffront%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Feval.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,5 +1,5 @@\n-import std::_vec;\n-import std::_str;\n+import std::vec;\n+import std::str;\n import std::option;\n import std::option::some;\n import std::option::none;\n@@ -92,7 +92,7 @@ fn val_as_str(val v) -> str {\n \n fn lookup(session::session sess, env e, span sp, ident i) -> val {\n     for (tup(ident, val) pair in e) {\n-        if (_str::eq(i, pair._0)) {\n+        if (str::eq(i, pair._0)) {\n             ret pair._1;\n         }\n     }\n@@ -115,8 +115,8 @@ fn eval_lit(ctx cx, span sp, @ast::lit lit) -> val {\n fn eval_expr(ctx cx, env e, @ast::expr x) -> val {\n     alt (x.node) {\n         case (ast::expr_path(?pth, _)) {\n-            if (_vec::len[ident](pth.node.idents) == 1u &&\n-                _vec::len[@ast::ty](pth.node.types) == 0u) {\n+            if (vec::len[ident](pth.node.idents) == 1u &&\n+                vec::len[@ast::ty](pth.node.types) == 0u) {\n                 ret lookup(cx.sess, e, x.span, pth.node.idents.(0));\n             }\n             cx.sess.span_err(x.span, \"evaluating structured path-name\");\n@@ -225,7 +225,7 @@ fn val_eq(session::session sess, span sp, val av, val bv) -> bool {\n         ret val_as_int(av) == val_as_int(bv);\n     }\n     if (val_is_str(av) && val_is_str(bv)) {\n-        ret _str::eq(val_as_str(av),\n+        ret str::eq(val_as_str(av),\n                     val_as_str(bv));\n     }\n     sess.span_err(sp, \"bad types in comparison\");\n@@ -394,7 +394,7 @@ fn eval_crate_directive(ctx cx,\n             cx.next_ann = p0.next_ann_num();\n             auto im = ast::item_mod(id, m0, next_id);\n             auto i = @spanned(cdir.span.lo, cdir.span.hi, im);\n-            _vec::push[@ast::item](items, i);\n+            vec::push[@ast::item](items, i);\n         }\n \n         case (ast::cdir_dir_mod(?id, ?dir_opt, ?cdirs)) {\n@@ -411,11 +411,11 @@ fn eval_crate_directive(ctx cx,\n             auto m0 = eval_crate_directives_to_mod(cx, e, cdirs, full_path);\n             auto im = ast::item_mod(id, m0, cx.p.next_def_id());\n             auto i = @spanned(cdir.span.lo, cdir.span.hi, im);\n-            _vec::push[@ast::item](items, i);\n+            vec::push[@ast::item](items, i);\n         }\n \n         case (ast::cdir_view_item(?vi)) {\n-            _vec::push[@ast::view_item](view_items, vi);\n+            vec::push[@ast::view_item](view_items, vi);\n         }\n \n         case (ast::cdir_meta(?mi)) {"}, {"sha": "f5d86dde3e71ab966b303269bc5c22aeeb5998f7", "filename": "src/comp/front/extenv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Ffront%2Fextenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Ffront%2Fextenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fextenv.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -6,8 +6,8 @@\n \n import util::common;\n \n-import std::_str;\n-import std::_vec;\n+import std::str;\n+import std::vec;\n import std::option;\n import std::generic_os;\n \n@@ -19,7 +19,7 @@ fn expand_syntax_ext(parser::parser p,\n                      vec[@ast::expr] args,\n                      option::t[str] body) -> @ast::expr {\n \n-    if (_vec::len[@ast::expr](args) != 1u) {\n+    if (vec::len[@ast::expr](args) != 1u) {\n         p.err(\"malformed #env call\");\n     }\n "}, {"sha": "8ef37b8536cac57667bb16897c8b032e17a570a1", "filename": "src/comp/front/extfmt.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Ffront%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Ffront%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fextfmt.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -7,8 +7,8 @@\n import front::parser::parser;\n import util::common;\n \n-import std::_str;\n-import std::_vec;\n+import std::str;\n+import std::vec;\n import std::option;\n import std::option::none;\n import std::option::some;\n@@ -50,7 +50,7 @@ fn expand_syntax_ext(parser p,\n                      vec[@ast::expr] args,\n                      option::t[str] body) -> @ast::expr {\n \n-    if (_vec::len[@ast::expr](args) == 0u) {\n+    if (vec::len[@ast::expr](args) == 0u) {\n         // FIXME: Handle error correctly.\n         log_err \"malformed #fmt call\";\n         fail;\n@@ -62,8 +62,8 @@ fn expand_syntax_ext(parser p,\n     // log fmt;\n \n     auto pieces = parse_fmt_string(fmt);\n-    auto args_len = _vec::len[@ast::expr](args);\n-    auto fmt_args = _vec::slice[@ast::expr](args, 1u, args_len - 1u);\n+    auto args_len = vec::len[@ast::expr](args);\n+    auto fmt_args = vec::slice[@ast::expr](args, 1u, args_len - 1u);\n     ret pieces_to_expr(p, pieces, args);\n }\n \n@@ -203,7 +203,7 @@ fn pieces_to_expr(parser p, vec[piece] pieces, vec[@ast::expr] args)\n             // FIXME: 0-length vectors can't have their type inferred\n             // through the rec that these flags are a member of, so\n             // this is a hack placeholder flag\n-            if (_vec::len[@ast::expr](flagexprs) == 0u) {\n+            if (vec::len[@ast::expr](flagexprs) == 0u) {\n                 flagexprs += [make_rt_path_expr(p, sp, \"flag_none\")];\n             }\n \n@@ -407,7 +407,7 @@ fn pieces_to_expr(parser p, vec[piece] pieces, vec[@ast::expr] args)\n     fn log_conv(conv c) {\n         alt (c.param) {\n             case (some[int](?p)) {\n-                log \"param: \" + std::_int::to_str(p, 10u);\n+                log \"param: \" + std::int::to_str(p, 10u);\n             }\n             case (_) {\n                 log \"param: none\";\n@@ -434,10 +434,10 @@ fn pieces_to_expr(parser p, vec[piece] pieces, vec[@ast::expr] args)\n         }\n         alt (c.width) {\n             case (count_is(?i)) {\n-                log \"width: count is \" + std::_int::to_str(i, 10u);\n+                log \"width: count is \" + std::int::to_str(i, 10u);\n             }\n             case (count_is_param(?i)) {\n-                log \"width: count is param \" + std::_int::to_str(i, 10u);\n+                log \"width: count is param \" + std::int::to_str(i, 10u);\n             }\n             case (count_is_next_param) {\n                 log \"width: count is next param\";\n@@ -448,10 +448,10 @@ fn pieces_to_expr(parser p, vec[piece] pieces, vec[@ast::expr] args)\n         }\n         alt (c.precision) {\n             case (count_is(?i)) {\n-                log \"prec: count is \" + std::_int::to_str(i, 10u);\n+                log \"prec: count is \" + std::int::to_str(i, 10u);\n             }\n             case (count_is_param(?i)) {\n-                log \"prec: count is param \" + std::_int::to_str(i, 10u);\n+                log \"prec: count is param \" + std::int::to_str(i, 10u);\n             }\n             case (count_is_next_param) {\n                 log \"prec: count is next param\";\n@@ -507,7 +507,7 @@ fn pieces_to_expr(parser p, vec[piece] pieces, vec[@ast::expr] args)\n                 tmp_expr = make_add_expr(p, sp, tmp_expr, s_expr);\n             }\n             case (piece_conv(?conv)) {\n-                if (n >= _vec::len[@ast::expr](args)) {\n+                if (n >= vec::len[@ast::expr](args)) {\n                     log_err \"too many conversions in #fmt string\";\n                     fail;\n                 }"}, {"sha": "d5e885c7bf0549477489e5018c929fbac6c9b63f", "filename": "src/comp/front/lexer.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Ffront%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Ffront%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Flexer.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,7 +1,7 @@\n import std::io;\n-import std::_str;\n-import std::_vec;\n-import std::_int;\n+import std::str;\n+import std::vec;\n+import std::int;\n import std::map;\n import std::map::hashmap;\n import std::option;\n@@ -54,13 +54,13 @@ fn new_reader(session sess, io::reader rdr,\n         }\n \n         fn next() -> char {\n-            if (pos < len) {ret _str::char_at(file, pos);}\n+            if (pos < len) {ret str::char_at(file, pos);}\n             else {ret -1 as char;}\n         }\n \n         fn init() {\n             if (pos < len) {\n-                auto next = _str::char_range_at(file, pos);\n+                auto next = str::char_range_at(file, pos);\n                 pos = next._1;\n                 ch = next._0;\n             }\n@@ -72,7 +72,7 @@ fn new_reader(session sess, io::reader rdr,\n                 if (ch == '\\n') {\n                     codemap::next_line(fm, chpos);\n                 }\n-                auto next = _str::char_range_at(file, pos);\n+                auto next = str::char_range_at(file, pos);\n                 pos = next._1;\n                 ch = next._0;\n             } else {\n@@ -90,9 +90,9 @@ fn new_reader(session sess, io::reader rdr,\n             sess.span_err(rec(lo=chpos, hi=chpos), m);\n         }\n     }\n-    auto file = _str::unsafe_from_bytes(rdr.read_whole_stream());\n+    auto file = str::unsafe_from_bytes(rdr.read_whole_stream());\n     let vec[str] strs = [];\n-    auto rd = reader(sess, file, _str::byte_len(file), 0u, -1 as char,\n+    auto rd = reader(sess, file, str::byte_len(file), 0u, -1 as char,\n                      filemap.start_pos, filemap.start_pos,\n                      strs, filemap, itr);\n     rd.init();\n@@ -228,15 +228,15 @@ fn scan_exponent(reader rdr) -> option::t[str] {\n     auto res = \"\";\n \n     if (c == 'e' || c == 'E') {\n-        res += _str::from_bytes([c as u8]);\n+        res += str::from_bytes([c as u8]);\n         rdr.bump();\n         c = rdr.curr();\n         if (c == '-' || c == '+') {\n-            res += _str::from_bytes([c as u8]);\n+            res += str::from_bytes([c as u8]);\n             rdr.bump();\n         }\n         auto exponent = scan_dec_digits(rdr);\n-        if (_str::byte_len(exponent) > 0u) {\n+        if (str::byte_len(exponent) > 0u) {\n             ret(some(res + exponent));\n         }\n         else {\n@@ -256,7 +256,7 @@ fn scan_dec_digits(reader rdr) -> str {\n \n     while (is_dec_digit (c) || c == '_') {\n         if (c != '_') {\n-            res += _str::from_bytes([c as u8]);\n+            res += str::from_bytes([c as u8]);\n         }\n         rdr.bump();\n         c = rdr.curr();\n@@ -458,12 +458,12 @@ fn next_token(reader rdr) -> token::token {\n \n     if (is_alpha(c) || c == '_') {\n         while (is_alnum(c) || c == '_') {\n-            _str::push_char(accum_str, c);\n+            str::push_char(accum_str, c);\n             rdr.bump();\n             c = rdr.curr();\n         }\n \n-        if (_str::eq(accum_str, \"_\")) {\n+        if (str::eq(accum_str, \"_\")) {\n             ret token::UNDERSCORE;\n         }\n \n@@ -621,37 +621,37 @@ fn next_token(reader rdr) -> token::token {\n                         alt (rdr.next()) {\n                             case ('n') {\n                                 rdr.bump();\n-                                _str::push_byte(accum_str, '\\n' as u8);\n+                                str::push_byte(accum_str, '\\n' as u8);\n                             }\n                             case ('r') {\n                                 rdr.bump();\n-                                _str::push_byte(accum_str, '\\r' as u8);\n+                                str::push_byte(accum_str, '\\r' as u8);\n                             }\n                             case ('t') {\n                                 rdr.bump();\n-                                _str::push_byte(accum_str, '\\t' as u8);\n+                                str::push_byte(accum_str, '\\t' as u8);\n                             }\n                             case ('\\\\') {\n                                 rdr.bump();\n-                                _str::push_byte(accum_str, '\\\\' as u8);\n+                                str::push_byte(accum_str, '\\\\' as u8);\n                             }\n                             case ('\"') {\n                                 rdr.bump();\n-                                _str::push_byte(accum_str, '\"' as u8);\n+                                str::push_byte(accum_str, '\"' as u8);\n                             }\n \n                             case ('x') {\n-                                _str::push_char(accum_str,\n+                                str::push_char(accum_str,\n                                                scan_numeric_escape(rdr));\n                             }\n \n                             case ('u') {\n-                                _str::push_char(accum_str,\n+                                str::push_char(accum_str,\n                                                scan_numeric_escape(rdr));\n                             }\n \n                             case ('U') {\n-                                _str::push_char(accum_str,\n+                                str::push_char(accum_str,\n                                                scan_numeric_escape(rdr));\n                             }\n \n@@ -663,7 +663,7 @@ fn next_token(reader rdr) -> token::token {\n                         }\n                     }\n                     case (_) {\n-                        _str::push_char(accum_str, rdr.curr());\n+                        str::push_char(accum_str, rdr.curr());\n                     }\n                 }\n                 rdr.bump();\n@@ -754,7 +754,7 @@ fn read_line_comment(reader rdr) -> cmnt {\n     while (rdr.curr() == ' ') {rdr.bump();}\n     auto val = \"\";\n     while (rdr.curr() != '\\n' && !rdr.is_eof()) {\n-        _str::push_char(val, rdr.curr());\n+        str::push_char(val, rdr.curr());\n         rdr.bump();\n     }\n     ret rec(val=cmnt_line(val),\n@@ -771,21 +771,21 @@ fn read_block_comment(reader rdr) -> cmnt {\n     auto level = 1;\n     while (true) {\n         if (rdr.curr() == '\\n') {\n-            _vec::push[str](lines, val);\n+            vec::push[str](lines, val);\n             val = \"\";\n             consume_whitespace(rdr);\n         } else {\n             if (rdr.curr() == '*' && rdr.next() == '/') {\n                 level -= 1;\n                 if (level == 0) {\n                     rdr.bump(); rdr.bump();\n-                    _vec::push[str](lines, val);\n+                    vec::push[str](lines, val);\n                     break;\n                 }\n             } else if (rdr.curr() == '/' && rdr.next() == '*') {\n                 level += 1;\n             }\n-            _str::push_char(val, rdr.curr());\n+            str::push_char(val, rdr.curr());\n             rdr.bump();\n         }\n         if (rdr.is_eof()) {\n@@ -800,16 +800,16 @@ fn read_block_comment(reader rdr) -> cmnt {\n \n fn gather_comments(session sess, str path) -> vec[cmnt] {\n     auto srdr = io::file_reader(path);\n-    auto itr = @interner::mk_interner[str](_str::hash, _str::eq);\n+    auto itr = @interner::mk_interner[str](str::hash, str::eq);\n     auto rdr = new_reader(sess, srdr, codemap::new_filemap(path, 0u), itr);\n     let vec[cmnt] comments = [];\n     while (!rdr.is_eof()) {\n         while (true) {\n             consume_whitespace(rdr);\n             if (rdr.curr() == '/' && rdr.next() == '/') {\n-                _vec::push[cmnt](comments, read_line_comment(rdr));\n+                vec::push[cmnt](comments, read_line_comment(rdr));\n             } else if (rdr.curr() == '/' && rdr.next() == '*') {\n-                _vec::push[cmnt](comments, read_block_comment(rdr));\n+                vec::push[cmnt](comments, read_block_comment(rdr));\n             } else { break; }\n         }\n         next_token(rdr);"}, {"sha": "c4135814175d9a5be795228c8ba3a348c66a0dab", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,6 +1,6 @@\n import std::io;\n-import std::_vec;\n-import std::_str;\n+import std::vec;\n+import std::str;\n import std::option;\n import std::option::some;\n import std::option::none;\n@@ -156,13 +156,13 @@ fn new_parser(session::session sess,\n             }\n         }\n     auto ftype = SOURCE_FILE;\n-    if (_str::ends_with(path, \".rc\")) {\n+    if (str::ends_with(path, \".rc\")) {\n         ftype = CRATE_FILE;\n     }\n     auto srdr = io::file_reader(path);\n     auto filemap = codemap::new_filemap(path, pos);\n-    _vec::push[codemap::filemap](sess.get_codemap().files, filemap);\n-    auto itr = @interner::mk_interner[str](_str::hash, _str::eq);\n+    vec::push[codemap::filemap](sess.get_codemap().files, filemap);\n+    auto itr = @interner::mk_interner[str](str::hash, str::eq);\n     auto rdr = lexer::new_reader(sess, srdr, filemap, itr);\n     // Make sure npos points at first actual token:\n     lexer::consume_any_whitespace(rdr);\n@@ -278,14 +278,14 @@ fn parse_str_lit_or_env_ident(parser p) -> ast::ident {\n \n fn is_word(&parser p, &str word) -> bool {\n     ret alt (p.peek()) {\n-        case (token::IDENT(?sid, false)) { _str::eq(word, p.get_str(sid)) }\n+        case (token::IDENT(?sid, false)) { str::eq(word, p.get_str(sid)) }\n         case (_) { false }\n     };\n }\n fn eat_word(&parser p, &str word) -> bool {\n     alt (p.peek()) {\n         case (token::IDENT(?sid, false)) {\n-            if (_str::eq(word, p.get_str(sid))) {\n+            if (str::eq(word, p.get_str(sid))) {\n                 p.bump();\n                 ret true;\n             } else { ret false; }\n@@ -433,7 +433,7 @@ fn parse_constrs(parser p) -> common::spanned[vec[@ast::constr]] {\n         while (true) {\n             auto constr = parse_ty_constr(p);\n             hi = constr.span.hi;\n-            _vec::push[@ast::constr](constrs, constr);\n+            vec::push[@ast::constr](constrs, constr);\n             if (p.peek() == token::COMMA) {\n                 p.bump();\n             } else {\n@@ -818,7 +818,7 @@ fn parse_bottom_expr(parser p) -> @ast::expr {\n             if (eat_word(p, \"with\")) {\n                 with_obj = some[ast::ident](parse_ident(p));\n             } else {\n-                _vec::push[@ast::method](meths,\n+                vec::push[@ast::method](meths,\n                                          parse_method(p));\n             }\n         }\n@@ -1004,16 +1004,16 @@ fn expand_syntax_ext(parser p, ast::span sp,\n                      &ast::path path, vec[@ast::expr] args,\n                      option::t[str] body) -> ast::expr_ {\n \n-    assert (_vec::len[ast::ident](path.node.idents) > 0u);\n+    assert (vec::len[ast::ident](path.node.idents) > 0u);\n     auto extname = path.node.idents.(0);\n-    if (_str::eq(extname, \"fmt\")) {\n+    if (str::eq(extname, \"fmt\")) {\n         auto expanded = extfmt::expand_syntax_ext(p, args, body);\n         auto newexpr = ast::expr_ext(path, args, body,\n                                     expanded,\n                                     p.get_ann());\n \n         ret newexpr;\n-    } else if (_str::eq(extname, \"env\")) {\n+    } else if (str::eq(extname, \"env\")) {\n         auto expanded = extenv::expand_syntax_ext(p, sp, args, body);\n         auto newexpr = ast::expr_ext(path, args, body,\n                                     expanded,\n@@ -1833,7 +1833,7 @@ fn parse_item_obj(parser p, ast::layer lyr) -> @ast::item {\n         if (eat_word(p, \"drop\")) {\n             dtor = some[@ast::method](parse_dtor(p));\n         } else {\n-            _vec::push[@ast::method](meths,\n+            vec::push[@ast::method](meths,\n                                      parse_method(p));\n         }\n     }\n@@ -1953,12 +1953,12 @@ fn parse_item_native_mod(parser p) -> @ast::item {\n     auto abi = ast::native_abi_cdecl;\n     if (!is_word(p, \"mod\")) {\n         auto t = parse_str_lit_or_env_ident(p);\n-        if (_str::eq(t, \"cdecl\")) {\n-        } else if (_str::eq(t, \"rust\")) {\n+        if (str::eq(t, \"cdecl\")) {\n+        } else if (str::eq(t, \"rust\")) {\n             abi = ast::native_abi_rust;\n-        } else if (_str::eq(t, \"llvm\")) {\n+        } else if (str::eq(t, \"llvm\")) {\n             abi = ast::native_abi_llvm;\n-        } else if (_str::eq(t, \"rust-intrinsic\")) {\n+        } else if (str::eq(t, \"rust-intrinsic\")) {\n             abi = ast::native_abi_rust_intrinsic;\n         } else {\n             p.err(\"unsupported abi: \" + t);\n@@ -2079,16 +2079,16 @@ fn peeking_at_item(parser p) -> bool {\n     alt (p.peek()) {\n         case (token::IDENT(?sid, false)) {\n             auto st = p.get_str(sid);\n-            ret _str::eq(st, \"state\") ||\n-                _str::eq(st, \"gc\") ||\n-                _str::eq(st, \"const\") ||\n-                _str::eq(st, \"fn\") ||\n-                _str::eq(st, \"pred\") ||\n-                _str::eq(st, \"iter\") ||\n-                _str::eq(st, \"mod\") ||\n-                _str::eq(st, \"type\") ||\n-                _str::eq(st, \"tag\") ||\n-                _str::eq(st, \"obj\");\n+            ret str::eq(st, \"state\") ||\n+                str::eq(st, \"gc\") ||\n+                str::eq(st, \"const\") ||\n+                str::eq(st, \"fn\") ||\n+                str::eq(st, \"pred\") ||\n+                str::eq(st, \"iter\") ||\n+                str::eq(st, \"mod\") ||\n+                str::eq(st, \"type\") ||\n+                str::eq(st, \"tag\") ||\n+                str::eq(st, \"obj\");\n         }\n         case (_) { ret false; }\n     }\n@@ -2193,7 +2193,7 @@ fn parse_rest_import_name(parser p, ast::ident first,\n             defined_id = i;\n         }\n         case (_) {\n-            auto len = _vec::len[ast::ident](identifiers);\n+            auto len = vec::len[ast::ident](identifiers);\n             defined_id = identifiers.(len - 1u);\n         }\n     }\n@@ -2262,8 +2262,8 @@ fn is_view_item(&parser p) -> bool {\n     alt (p.peek()) {\n         case (token::IDENT(?sid, false)) {\n             auto st = p.get_str(sid);\n-            ret _str::eq(st, \"use\") || _str::eq(st, \"import\") ||\n-                _str::eq(st, \"export\");\n+            ret str::eq(st, \"use\") || str::eq(st, \"import\") ||\n+                str::eq(st, \"export\");\n         }\n         case (_) { ret false; }\n     }\n@@ -2389,7 +2389,7 @@ fn parse_crate_directives(parser p, token::token term)\n \n     while (p.peek() != term) {\n         auto cdir = @parse_crate_directive(p);\n-        _vec::push[@ast::crate_directive](cdirs, cdir);\n+        vec::push[@ast::crate_directive](cdirs, cdir);\n     }\n \n     ret cdirs;"}, {"sha": "41b8f30d6283338c019011515445390f1651d933", "filename": "src/comp/front/token.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Ffront%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Ffront%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftoken.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -2,9 +2,9 @@ import util::common::ty_mach;\n import util::common::ty_mach_to_str;\n import util::common::new_str_hash;\n import util::interner;\n-import std::_int;\n-import std::_uint;\n-import std::_str;\n+import std::int;\n+import std::uint;\n+import std::str;\n \n type str_num = uint;\n \n@@ -133,10 +133,10 @@ fn to_str(lexer::reader r, token t) -> str {\n         case (POUND) { ret \"#\"; }\n \n         /* Literals */\n-        case (LIT_INT(?i)) { ret _int::to_str(i, 10u); }\n-        case (LIT_UINT(?u)) { ret _uint::to_str(u, 10u); }\n+        case (LIT_INT(?i)) { ret int::to_str(i, 10u); }\n+        case (LIT_UINT(?u)) { ret uint::to_str(u, 10u); }\n         case (LIT_MACH_INT(?tm, ?i)) {\n-            ret  _int::to_str(i, 10u)\n+            ret  int::to_str(i, 10u)\n                 + \"_\" + ty_mach_to_str(tm);\n         }\n         case (LIT_MACH_FLOAT(?tm, ?s)) {\n@@ -152,8 +152,8 @@ fn to_str(lexer::reader r, token t) -> str {\n         case (LIT_CHAR(?c)) {\n             // FIXME: escape.\n             auto tmp = \"'\";\n-            _str::push_char(tmp, c);\n-            _str::push_byte(tmp, '\\'' as u8);\n+            str::push_char(tmp, c);\n+            str::push_byte(tmp, '\\'' as u8);\n             ret tmp;\n         }\n \n@@ -163,7 +163,7 @@ fn to_str(lexer::reader r, token t) -> str {\n \n         /* Name components */\n         case (IDENT(?s, _)) { ret interner::get[str](*r.get_interner(), s); }\n-        case (IDX(?i)) { ret \"_\" + _int::to_str(i, 10u); }\n+        case (IDX(?i)) { ret \"_\" + int::to_str(i, 10u); }\n         case (UNDERSCORE) { ret \"_\"; }\n \n         case (BRACEQUOTE(_)) { ret \"<bracequote>\"; }"}, {"sha": "6774d224aafe315bd8a66790a81822246853c7d2", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 110, "deletions": 110, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,7 +1,7 @@\n-import std::_vec;\n-import std::_str;\n-import std::_str::rustrt::sbuf;\n-import std::_vec::rustrt::vbuf;\n+import std::vec;\n+import std::str;\n+import std::str::rustrt::sbuf;\n+import std::vec::rustrt::vbuf;\n \n import llvm::ModuleRef;\n import llvm::ContextRef;\n@@ -908,8 +908,8 @@ obj builder(BuilderRef B, @mutable bool terminated) {\n         assert (!*terminated);\n         *terminated = true;\n         ret llvm::LLVMBuildAggregateRet(B,\n-                                       _vec::buf[ValueRef](RetVals),\n-                                       _vec::len[ValueRef](RetVals));\n+                                       vec::buf[ValueRef](RetVals),\n+                                       vec::len[ValueRef](RetVals));\n     }\n \n     fn Br(BasicBlockRef Dest) -> ValueRef {\n@@ -944,10 +944,10 @@ obj builder(BuilderRef B, @mutable bool terminated) {\n         assert (!*terminated);\n         *terminated = true;\n         ret llvm::LLVMBuildInvoke(B, Fn,\n-                                 _vec::buf[ValueRef](Args),\n-                                 _vec::len[ValueRef](Args),\n+                                 vec::buf[ValueRef](Args),\n+                                 vec::len[ValueRef](Args),\n                                  Then, Catch,\n-                                 _str::buf(\"\"));\n+                                 str::buf(\"\"));\n     }\n \n     fn Unwind() -> ValueRef {\n@@ -965,176 +965,176 @@ obj builder(BuilderRef B, @mutable bool terminated) {\n     /* Arithmetic */\n     fn Add(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildAdd(B, LHS, RHS, _str::buf(\"\"));\n+        ret llvm::LLVMBuildAdd(B, LHS, RHS, str::buf(\"\"));\n     }\n \n     fn NSWAdd(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildNSWAdd(B, LHS, RHS, _str::buf(\"\"));\n+        ret llvm::LLVMBuildNSWAdd(B, LHS, RHS, str::buf(\"\"));\n     }\n \n     fn NUWAdd(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildNUWAdd(B, LHS, RHS, _str::buf(\"\"));\n+        ret llvm::LLVMBuildNUWAdd(B, LHS, RHS, str::buf(\"\"));\n     }\n \n     fn FAdd(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildFAdd(B, LHS, RHS, _str::buf(\"\"));\n+        ret llvm::LLVMBuildFAdd(B, LHS, RHS, str::buf(\"\"));\n     }\n \n     fn Sub(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildSub(B, LHS, RHS, _str::buf(\"\"));\n+        ret llvm::LLVMBuildSub(B, LHS, RHS, str::buf(\"\"));\n     }\n \n     fn NSWSub(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildNSWSub(B, LHS, RHS, _str::buf(\"\"));\n+        ret llvm::LLVMBuildNSWSub(B, LHS, RHS, str::buf(\"\"));\n     }\n \n     fn NUWSub(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildNUWSub(B, LHS, RHS, _str::buf(\"\"));\n+        ret llvm::LLVMBuildNUWSub(B, LHS, RHS, str::buf(\"\"));\n     }\n \n     fn FSub(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildFSub(B, LHS, RHS, _str::buf(\"\"));\n+        ret llvm::LLVMBuildFSub(B, LHS, RHS, str::buf(\"\"));\n     }\n \n     fn Mul(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildMul(B, LHS, RHS, _str::buf(\"\"));\n+        ret llvm::LLVMBuildMul(B, LHS, RHS, str::buf(\"\"));\n     }\n \n     fn NSWMul(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildNSWMul(B, LHS, RHS, _str::buf(\"\"));\n+        ret llvm::LLVMBuildNSWMul(B, LHS, RHS, str::buf(\"\"));\n     }\n \n     fn NUWMul(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildNUWMul(B, LHS, RHS, _str::buf(\"\"));\n+        ret llvm::LLVMBuildNUWMul(B, LHS, RHS, str::buf(\"\"));\n     }\n \n     fn FMul(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildFMul(B, LHS, RHS, _str::buf(\"\"));\n+        ret llvm::LLVMBuildFMul(B, LHS, RHS, str::buf(\"\"));\n     }\n \n     fn UDiv(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildUDiv(B, LHS, RHS, _str::buf(\"\"));\n+        ret llvm::LLVMBuildUDiv(B, LHS, RHS, str::buf(\"\"));\n     }\n \n     fn SDiv(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildSDiv(B, LHS, RHS, _str::buf(\"\"));\n+        ret llvm::LLVMBuildSDiv(B, LHS, RHS, str::buf(\"\"));\n     }\n \n     fn ExactSDiv(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildExactSDiv(B, LHS, RHS, _str::buf(\"\"));\n+        ret llvm::LLVMBuildExactSDiv(B, LHS, RHS, str::buf(\"\"));\n     }\n \n     fn FDiv(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildFDiv(B, LHS, RHS, _str::buf(\"\"));\n+        ret llvm::LLVMBuildFDiv(B, LHS, RHS, str::buf(\"\"));\n     }\n \n     fn URem(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildURem(B, LHS, RHS, _str::buf(\"\"));\n+        ret llvm::LLVMBuildURem(B, LHS, RHS, str::buf(\"\"));\n     }\n \n     fn SRem(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildSRem(B, LHS, RHS, _str::buf(\"\"));\n+        ret llvm::LLVMBuildSRem(B, LHS, RHS, str::buf(\"\"));\n     }\n \n     fn FRem(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildFRem(B, LHS, RHS, _str::buf(\"\"));\n+        ret llvm::LLVMBuildFRem(B, LHS, RHS, str::buf(\"\"));\n     }\n \n     fn Shl(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildShl(B, LHS, RHS, _str::buf(\"\"));\n+        ret llvm::LLVMBuildShl(B, LHS, RHS, str::buf(\"\"));\n     }\n \n     fn LShr(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildLShr(B, LHS, RHS, _str::buf(\"\"));\n+        ret llvm::LLVMBuildLShr(B, LHS, RHS, str::buf(\"\"));\n     }\n \n     fn AShr(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildAShr(B, LHS, RHS, _str::buf(\"\"));\n+        ret llvm::LLVMBuildAShr(B, LHS, RHS, str::buf(\"\"));\n     }\n \n     fn And(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildAnd(B, LHS, RHS, _str::buf(\"\"));\n+        ret llvm::LLVMBuildAnd(B, LHS, RHS, str::buf(\"\"));\n     }\n \n     fn Or(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildOr(B, LHS, RHS, _str::buf(\"\"));\n+        ret llvm::LLVMBuildOr(B, LHS, RHS, str::buf(\"\"));\n     }\n \n     fn Xor(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildXor(B, LHS, RHS, _str::buf(\"\"));\n+        ret llvm::LLVMBuildXor(B, LHS, RHS, str::buf(\"\"));\n     }\n \n     fn BinOp(Opcode Op, ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildBinOp(B, Op, LHS, RHS, _str::buf(\"\"));\n+        ret llvm::LLVMBuildBinOp(B, Op, LHS, RHS, str::buf(\"\"));\n     }\n \n     fn Neg(ValueRef V) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildNeg(B, V, _str::buf(\"\"));\n+        ret llvm::LLVMBuildNeg(B, V, str::buf(\"\"));\n     }\n \n     fn NSWNeg(ValueRef V) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildNSWNeg(B, V, _str::buf(\"\"));\n+        ret llvm::LLVMBuildNSWNeg(B, V, str::buf(\"\"));\n     }\n \n     fn NUWNeg(ValueRef V) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildNUWNeg(B, V, _str::buf(\"\"));\n+        ret llvm::LLVMBuildNUWNeg(B, V, str::buf(\"\"));\n     }\n     fn FNeg(ValueRef V) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildFNeg(B, V, _str::buf(\"\"));\n+        ret llvm::LLVMBuildFNeg(B, V, str::buf(\"\"));\n     }\n     fn Not(ValueRef V) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildNot(B, V, _str::buf(\"\"));\n+        ret llvm::LLVMBuildNot(B, V, str::buf(\"\"));\n     }\n \n     /* Memory */\n     fn Malloc(TypeRef Ty) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildMalloc(B, Ty, _str::buf(\"\"));\n+        ret llvm::LLVMBuildMalloc(B, Ty, str::buf(\"\"));\n     }\n \n     fn ArrayMalloc(TypeRef Ty, ValueRef Val) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildArrayMalloc(B, Ty, Val, _str::buf(\"\"));\n+        ret llvm::LLVMBuildArrayMalloc(B, Ty, Val, str::buf(\"\"));\n     }\n \n     fn Alloca(TypeRef Ty) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildAlloca(B, Ty, _str::buf(\"\"));\n+        ret llvm::LLVMBuildAlloca(B, Ty, str::buf(\"\"));\n     }\n \n     fn ArrayAlloca(TypeRef Ty, ValueRef Val) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildArrayAlloca(B, Ty, Val, _str::buf(\"\"));\n+        ret llvm::LLVMBuildArrayAlloca(B, Ty, Val, str::buf(\"\"));\n     }\n \n     fn Free(ValueRef PointerVal) -> ValueRef {\n@@ -1144,7 +1144,7 @@ obj builder(BuilderRef B, @mutable bool terminated) {\n \n     fn Load(ValueRef PointerVal) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildLoad(B, PointerVal, _str::buf(\"\"));\n+        ret llvm::LLVMBuildLoad(B, PointerVal, str::buf(\"\"));\n     }\n \n     fn Store(ValueRef Val, ValueRef Ptr) -> ValueRef {\n@@ -1155,236 +1155,236 @@ obj builder(BuilderRef B, @mutable bool terminated) {\n     fn GEP(ValueRef Pointer, vec[ValueRef] Indices) -> ValueRef {\n         assert (!*terminated);\n         ret llvm::LLVMBuildGEP(B, Pointer,\n-                              _vec::buf[ValueRef](Indices),\n-                              _vec::len[ValueRef](Indices),\n-                              _str::buf(\"\"));\n+                              vec::buf[ValueRef](Indices),\n+                              vec::len[ValueRef](Indices),\n+                              str::buf(\"\"));\n     }\n \n     fn InBoundsGEP(ValueRef Pointer, vec[ValueRef] Indices) -> ValueRef {\n         assert (!*terminated);\n         ret llvm::LLVMBuildInBoundsGEP(B, Pointer,\n-                                      _vec::buf[ValueRef](Indices),\n-                                      _vec::len[ValueRef](Indices),\n-                                      _str::buf(\"\"));\n+                                      vec::buf[ValueRef](Indices),\n+                                      vec::len[ValueRef](Indices),\n+                                      str::buf(\"\"));\n     }\n \n     fn StructGEP(ValueRef Pointer, uint Idx) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildStructGEP(B, Pointer, Idx, _str::buf(\"\"));\n+        ret llvm::LLVMBuildStructGEP(B, Pointer, Idx, str::buf(\"\"));\n     }\n \n     fn GlobalString(sbuf _Str) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildGlobalString(B, _Str, _str::buf(\"\"));\n+        ret llvm::LLVMBuildGlobalString(B, _Str, str::buf(\"\"));\n     }\n \n     fn GlobalStringPtr(sbuf _Str) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildGlobalStringPtr(B, _Str, _str::buf(\"\"));\n+        ret llvm::LLVMBuildGlobalStringPtr(B, _Str, str::buf(\"\"));\n     }\n \n     /* Casts */\n     fn Trunc(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildTrunc(B, Val, DestTy, _str::buf(\"\"));\n+        ret llvm::LLVMBuildTrunc(B, Val, DestTy, str::buf(\"\"));\n     }\n \n     fn ZExt(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildZExt(B, Val, DestTy, _str::buf(\"\"));\n+        ret llvm::LLVMBuildZExt(B, Val, DestTy, str::buf(\"\"));\n     }\n \n     fn SExt(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildSExt(B, Val, DestTy, _str::buf(\"\"));\n+        ret llvm::LLVMBuildSExt(B, Val, DestTy, str::buf(\"\"));\n     }\n \n     fn FPToUI(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildFPToUI(B, Val, DestTy, _str::buf(\"\"));\n+        ret llvm::LLVMBuildFPToUI(B, Val, DestTy, str::buf(\"\"));\n     }\n \n     fn FPToSI(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildFPToSI(B, Val, DestTy, _str::buf(\"\"));\n+        ret llvm::LLVMBuildFPToSI(B, Val, DestTy, str::buf(\"\"));\n     }\n \n     fn UIToFP(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildUIToFP(B, Val, DestTy, _str::buf(\"\"));\n+        ret llvm::LLVMBuildUIToFP(B, Val, DestTy, str::buf(\"\"));\n     }\n \n     fn SIToFP(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildSIToFP(B, Val, DestTy, _str::buf(\"\"));\n+        ret llvm::LLVMBuildSIToFP(B, Val, DestTy, str::buf(\"\"));\n     }\n \n     fn FPTrunc(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildFPTrunc(B, Val, DestTy, _str::buf(\"\"));\n+        ret llvm::LLVMBuildFPTrunc(B, Val, DestTy, str::buf(\"\"));\n     }\n \n     fn FPExt(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildFPExt(B, Val, DestTy, _str::buf(\"\"));\n+        ret llvm::LLVMBuildFPExt(B, Val, DestTy, str::buf(\"\"));\n     }\n \n     fn PtrToInt(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildPtrToInt(B, Val, DestTy, _str::buf(\"\"));\n+        ret llvm::LLVMBuildPtrToInt(B, Val, DestTy, str::buf(\"\"));\n     }\n \n     fn IntToPtr(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildIntToPtr(B, Val, DestTy, _str::buf(\"\"));\n+        ret llvm::LLVMBuildIntToPtr(B, Val, DestTy, str::buf(\"\"));\n     }\n \n     fn BitCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildBitCast(B, Val, DestTy, _str::buf(\"\"));\n+        ret llvm::LLVMBuildBitCast(B, Val, DestTy, str::buf(\"\"));\n     }\n \n     fn ZExtOrBitCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildZExtOrBitCast(B, Val, DestTy, _str::buf(\"\"));\n+        ret llvm::LLVMBuildZExtOrBitCast(B, Val, DestTy, str::buf(\"\"));\n     }\n \n     fn SExtOrBitCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildSExtOrBitCast(B, Val, DestTy, _str::buf(\"\"));\n+        ret llvm::LLVMBuildSExtOrBitCast(B, Val, DestTy, str::buf(\"\"));\n     }\n \n     fn TruncOrBitCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildTruncOrBitCast(B, Val, DestTy, _str::buf(\"\"));\n+        ret llvm::LLVMBuildTruncOrBitCast(B, Val, DestTy, str::buf(\"\"));\n     }\n \n     fn Cast(Opcode Op, ValueRef Val, TypeRef DestTy, sbuf Name) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildCast(B, Op, Val, DestTy, _str::buf(\"\"));\n+        ret llvm::LLVMBuildCast(B, Op, Val, DestTy, str::buf(\"\"));\n     }\n \n     fn PointerCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildPointerCast(B, Val, DestTy, _str::buf(\"\"));\n+        ret llvm::LLVMBuildPointerCast(B, Val, DestTy, str::buf(\"\"));\n     }\n \n     fn IntCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildIntCast(B, Val, DestTy, _str::buf(\"\"));\n+        ret llvm::LLVMBuildIntCast(B, Val, DestTy, str::buf(\"\"));\n     }\n \n     fn FPCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildFPCast(B, Val, DestTy, _str::buf(\"\"));\n+        ret llvm::LLVMBuildFPCast(B, Val, DestTy, str::buf(\"\"));\n     }\n \n \n     /* Comparisons */\n     fn ICmp(uint Op, ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildICmp(B, Op, LHS, RHS, _str::buf(\"\"));\n+        ret llvm::LLVMBuildICmp(B, Op, LHS, RHS, str::buf(\"\"));\n     }\n \n     fn FCmp(uint Op, ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildFCmp(B, Op, LHS, RHS, _str::buf(\"\"));\n+        ret llvm::LLVMBuildFCmp(B, Op, LHS, RHS, str::buf(\"\"));\n     }\n \n \n     /* Miscellaneous instructions */\n     fn Phi(TypeRef Ty, vec[ValueRef] vals,\n            vec[BasicBlockRef] bbs) -> ValueRef {\n         assert (!*terminated);\n-        auto phi = llvm::LLVMBuildPhi(B, Ty, _str::buf(\"\"));\n-        assert (_vec::len[ValueRef](vals) == _vec::len[BasicBlockRef](bbs));\n+        auto phi = llvm::LLVMBuildPhi(B, Ty, str::buf(\"\"));\n+        assert (vec::len[ValueRef](vals) == vec::len[BasicBlockRef](bbs));\n         llvm::LLVMAddIncoming(phi,\n-                             _vec::buf[ValueRef](vals),\n-                             _vec::buf[BasicBlockRef](bbs),\n-                             _vec::len[ValueRef](vals));\n+                             vec::buf[ValueRef](vals),\n+                             vec::buf[BasicBlockRef](bbs),\n+                             vec::len[ValueRef](vals));\n         ret phi;\n     }\n \n     fn AddIncomingToPhi(ValueRef phi,\n                         vec[ValueRef] vals,\n                         vec[BasicBlockRef] bbs) {\n-        assert (_vec::len[ValueRef](vals) == _vec::len[BasicBlockRef](bbs));\n+        assert (vec::len[ValueRef](vals) == vec::len[BasicBlockRef](bbs));\n         llvm::LLVMAddIncoming(phi,\n-                             _vec::buf[ValueRef](vals),\n-                             _vec::buf[BasicBlockRef](bbs),\n-                             _vec::len[ValueRef](vals));\n+                             vec::buf[ValueRef](vals),\n+                             vec::buf[BasicBlockRef](bbs),\n+                             vec::len[ValueRef](vals));\n     }\n \n     fn Call(ValueRef Fn, vec[ValueRef] Args) -> ValueRef {\n         assert (!*terminated);\n         ret llvm::LLVMBuildCall(B, Fn,\n-                               _vec::buf[ValueRef](Args),\n-                               _vec::len[ValueRef](Args),\n-                               _str::buf(\"\"));\n+                               vec::buf[ValueRef](Args),\n+                               vec::len[ValueRef](Args),\n+                               str::buf(\"\"));\n     }\n \n     fn FastCall(ValueRef Fn, vec[ValueRef] Args) -> ValueRef {\n         assert (!*terminated);\n         auto v = llvm::LLVMBuildCall(B, Fn,\n-                                    _vec::buf[ValueRef](Args),\n-                                    _vec::len[ValueRef](Args),\n-                                    _str::buf(\"\"));\n+                                    vec::buf[ValueRef](Args),\n+                                    vec::len[ValueRef](Args),\n+                                    str::buf(\"\"));\n         llvm::LLVMSetInstructionCallConv(v, LLVMFastCallConv);\n         ret v;\n     }\n \n     fn Select(ValueRef If, ValueRef Then, ValueRef Else) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildSelect(B, If, Then, Else, _str::buf(\"\"));\n+        ret llvm::LLVMBuildSelect(B, If, Then, Else, str::buf(\"\"));\n     }\n \n     fn VAArg(ValueRef list, TypeRef Ty) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildVAArg(B, list, Ty, _str::buf(\"\"));\n+        ret llvm::LLVMBuildVAArg(B, list, Ty, str::buf(\"\"));\n     }\n \n     fn ExtractElement(ValueRef VecVal, ValueRef Index) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildExtractElement(B, VecVal, Index, _str::buf(\"\"));\n+        ret llvm::LLVMBuildExtractElement(B, VecVal, Index, str::buf(\"\"));\n     }\n \n     fn InsertElement(ValueRef VecVal, ValueRef EltVal,\n                      ValueRef Index) -> ValueRef {\n         assert (!*terminated);\n         ret llvm::LLVMBuildInsertElement(B, VecVal, EltVal, Index,\n-                                        _str::buf(\"\"));\n+                                        str::buf(\"\"));\n     }\n \n     fn ShuffleVector(ValueRef V1, ValueRef V2, ValueRef Mask) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildShuffleVector(B, V1, V2, Mask, _str::buf(\"\"));\n+        ret llvm::LLVMBuildShuffleVector(B, V1, V2, Mask, str::buf(\"\"));\n     }\n \n     fn ExtractValue(ValueRef AggVal, uint Index) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildExtractValue(B, AggVal, Index, _str::buf(\"\"));\n+        ret llvm::LLVMBuildExtractValue(B, AggVal, Index, str::buf(\"\"));\n     }\n \n     fn InsertValue(ValueRef AggVal, ValueRef EltVal,\n                    uint Index) -> ValueRef {\n         assert (!*terminated);\n         ret llvm::LLVMBuildInsertValue(B, AggVal, EltVal, Index,\n-                                       _str::buf(\"\"));\n+                                       str::buf(\"\"));\n     }\n \n     fn IsNull(ValueRef Val) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildIsNull(B, Val, _str::buf(\"\"));\n+        ret llvm::LLVMBuildIsNull(B, Val, str::buf(\"\"));\n     }\n \n     fn IsNotNull(ValueRef Val) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildIsNotNull(B, Val, _str::buf(\"\"));\n+        ret llvm::LLVMBuildIsNotNull(B, Val, str::buf(\"\"));\n     }\n \n     fn PtrDiff(ValueRef LHS, ValueRef RHS) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildPtrDiff(B, LHS, RHS, _str::buf(\"\"));\n+        ret llvm::LLVMBuildPtrDiff(B, LHS, RHS, str::buf(\"\"));\n     }\n \n     fn Trap() -> ValueRef {\n@@ -1393,13 +1393,13 @@ obj builder(BuilderRef B, @mutable bool terminated) {\n         let ValueRef FN = llvm::LLVMGetBasicBlockParent(BB);\n         let ModuleRef M = llvm::LLVMGetGlobalParent(FN);\n         let ValueRef T = llvm::LLVMGetNamedFunction(M,\n-                                                    _str::buf(\"llvm.trap\"));\n+                                                    str::buf(\"llvm.trap\"));\n         assert (T as int != 0);\n         let vec[ValueRef] Args = [];\n         ret llvm::LLVMBuildCall(B, T,\n-                               _vec::buf[ValueRef](Args),\n-                               _vec::len[ValueRef](Args),\n-                               _str::buf(\"\"));\n+                               vec::buf[ValueRef](Args),\n+                               vec::len[ValueRef](Args),\n+                               str::buf(\"\"));\n     }\n \n     drop {\n@@ -1520,8 +1520,8 @@ fn type_to_str_inner(type_names names,\n             let TypeRef out_ty = llvm::LLVMGetReturnType(ty);\n             let uint n_args = llvm::LLVMCountParamTypes(ty);\n             let vec[TypeRef] args =\n-                _vec::init_elt[TypeRef](0 as TypeRef, n_args);\n-            llvm::LLVMGetParamTypes(ty, _vec::buf[TypeRef](args));\n+                vec::init_elt[TypeRef](0 as TypeRef, n_args);\n+            llvm::LLVMGetParamTypes(ty, vec::buf[TypeRef](args));\n             s += tys_str(names, outer, args);\n             s += \") -> \";\n             s += type_to_str_inner(names, outer, out_ty);\n@@ -1532,8 +1532,8 @@ fn type_to_str_inner(type_names names,\n             let str s = \"{\";\n             let uint n_elts = llvm::LLVMCountStructElementTypes(ty);\n             let vec[TypeRef] elts =\n-                _vec::init_elt[TypeRef](0 as TypeRef, n_elts);\n-            llvm::LLVMGetStructElementTypes(ty, _vec::buf[TypeRef](elts));\n+                vec::init_elt[TypeRef](0 as TypeRef, n_elts);\n+            llvm::LLVMGetStructElementTypes(ty, vec::buf[TypeRef](elts));\n             s += tys_str(names, outer, elts);\n             s += \"}\";\n             ret s;\n@@ -1546,7 +1546,7 @@ fn type_to_str_inner(type_names names,\n             for (TypeRef tout in outer0) {\n                 i += 1u;\n                 if (tout as int == ty as int) {\n-                    let uint n = _vec::len[TypeRef](outer0) - i;\n+                    let uint n = vec::len[TypeRef](outer0) - i;\n                     ret \"*\\\\\" + util::common::istr(n as int);\n                 }\n             }\n@@ -1573,7 +1573,7 @@ obj target_data_dtor(TargetDataRef TD) {\n type target_data = rec(TargetDataRef lltd, target_data_dtor dtor);\n \n fn mk_target_data(str string_rep) -> target_data {\n-    auto lltd = llvm::LLVMCreateTargetData(_str::buf(string_rep));\n+    auto lltd = llvm::LLVMCreateTargetData(str::buf(string_rep));\n     ret rec(lltd=lltd, dtor=target_data_dtor(lltd));\n }\n "}, {"sha": "f0de3c4b3cbcfcade872f3d21bc55bd257da0f2e", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -33,8 +33,8 @@ import front::ast::ann;\n import front::ast::mt;\n import front::ast::purity;\n \n-import std::_uint;\n-import std::_vec;\n+import std::uint;\n+import std::vec;\n \n type ast_fold[ENV] =\n     @rec\n@@ -362,7 +362,7 @@ type ast_fold[ENV] =\n fn fold_path[ENV](&ENV env, &ast_fold[ENV] fld, &path p) -> path {\n     let vec[@ast::ty] tys_ = [];\n     for (@ast::ty t in p.node.types) {\n-        _vec::push[@ast::ty](tys_, fold_ty(env, fld, t));\n+        vec::push[@ast::ty](tys_, fold_ty(env, fld, t));\n     }\n     let ast::path_ p_ = rec(idents=p.node.idents, types=tys_);\n     ret fld.fold_path(env, p.span, p_);\n@@ -404,7 +404,7 @@ fn fold_ty[ENV](&ENV env, &ast_fold[ENV] fld, &@ty t) -> @ty {\n             let vec[mt] elts_ = [];\n             for (mt elt in elts) {\n                 auto ty_ = fold_ty(env, fld, elt.ty);\n-                _vec::push[mt](elts_, rec(ty=ty_, mut=elt.mut));\n+                vec::push[mt](elts_, rec(ty=ty_, mut=elt.mut));\n             }\n             ret fld.fold_ty_tup(env_, t.span, elts_);\n         }\n@@ -413,7 +413,7 @@ fn fold_ty[ENV](&ENV env, &ast_fold[ENV] fld, &@ty t) -> @ty {\n             let vec[ast::ty_field] flds_ = [];\n             for (ast::ty_field f in flds) {\n                 auto ty_ = fold_ty(env, fld, f.mt.ty);\n-                _vec::push[ast::ty_field]\n+                vec::push[ast::ty_field]\n                     (flds_, rec(mt=rec(ty=ty_, mut=f.mt.mut) with f));\n             }\n             ret fld.fold_ty_rec(env_, t.span, flds_);\n@@ -426,7 +426,7 @@ fn fold_ty[ENV](&ENV env, &ast_fold[ENV] fld, &@ty t) -> @ty {\n                                       m.inputs, m.output);\n                 alt (tfn.node) {\n                     case (ast::ty_fn(?p, ?ins, ?out)) {\n-                        _vec::push[ast::ty_method]\n+                        vec::push[ast::ty_method]\n                             (meths_, rec(proto=p, inputs=ins,\n                                          output=out with m));\n                     }\n@@ -541,7 +541,7 @@ fn fold_exprs[ENV](&ENV env, &ast_fold[ENV] fld,\n                    &vec[@expr] es) -> vec[@expr] {\n     let vec[@expr] exprs = [];\n     for (@expr e in es) {\n-        _vec::push[@expr](exprs, fold_expr(env, fld, e));\n+        vec::push[@expr](exprs, fold_expr(env, fld, e));\n     }\n     ret exprs;\n }\n@@ -893,7 +893,7 @@ fn fold_block[ENV](&ENV env, &ast_fold[ENV] fld, &block blk) -> block {\n     let vec[@ast::stmt] stmts = [];\n     for (@ast::stmt s in blk.node.stmts) {\n         auto new_stmt = fold_stmt[ENV](env_, fld, s);\n-        _vec::push[@ast::stmt](stmts, new_stmt);\n+        vec::push[@ast::stmt](stmts, new_stmt);\n     }\n \n     auto expr = none[@ast::expr];\n@@ -980,7 +980,7 @@ fn fold_obj[ENV](&ENV env, &ast_fold[ENV] fld, &ast::_obj ob) -> ast::_obj {\n                                                 m.node.ann),\n                                span=m.span);\n         let ENV _env = fld.update_env_for_item(env, i);\n-        _vec::push[@ast::method](meths, fold_method(_env, fld, m));\n+        vec::push[@ast::method](meths, fold_method(_env, fld, m));\n     }\n     ret fld.fold_obj(env, fields, meths, dtor);\n }\n@@ -1023,7 +1023,7 @@ fn fold_anon_obj[ENV](&ENV env, &ast_fold[ENV] fld, &ast::anon_obj ob)\n                                                 m.node.ann),\n                                span=m.span);\n         let ENV _env = fld.update_env_for_item(env, i);\n-        _vec::push[@ast::method](meths, fold_method(_env, fld, m));\n+        vec::push[@ast::method](meths, fold_method(_env, fld, m));\n     }\n     ret fld.fold_anon_obj(env, fields, meths, with_obj);\n }\n@@ -1124,12 +1124,12 @@ fn fold_mod[ENV](&ENV e, &ast_fold[ENV] fld, &ast::_mod m) -> ast::_mod {\n \n     for (@view_item vi in m.view_items) {\n         auto new_vi = fold_view_item[ENV](e, fld, vi);\n-        _vec::push[@view_item](view_items, new_vi);\n+        vec::push[@view_item](view_items, new_vi);\n     }\n \n     for (@item i in m.items) {\n         auto new_item = fold_item[ENV](e, fld, i);\n-        _vec::push[@item](items, new_item);\n+        vec::push[@item](items, new_item);\n     }\n \n     ret fld.fold_mod(e, rec(view_items=view_items, items=items));\n@@ -1162,12 +1162,12 @@ fn fold_native_mod[ENV](&ENV e, &ast_fold[ENV] fld,\n \n     for (@view_item vi in m.view_items) {\n         auto new_vi = fold_view_item[ENV](e, fld, vi);\n-        _vec::push[@view_item](view_items, new_vi);\n+        vec::push[@view_item](view_items, new_vi);\n     }\n \n     for (@native_item i in m.items) {\n         auto new_item = fold_native_item[ENV](e, fld, i);\n-        _vec::push[@native_item](items, new_item);\n+        vec::push[@native_item](items, new_item);\n     }\n \n     ret fld.fold_native_mod(e, rec(native_name=m.native_name,"}, {"sha": "7f518506254bca08c7beff12e48a82eb12851165", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,6 +1,6 @@\n-import std::_str;\n-import std::_uint;\n-import std::_vec;\n+import std::str;\n+import std::uint;\n+import std::vec;\n import std::map::hashmap;\n import std::ebml;\n import std::io;\n@@ -120,8 +120,8 @@ mod Encode {\n                         if (abbrev_len < len) {\n                             // I.e. it's actually an abbreviation.\n                             auto s = (\"#\"\n-                                      + _uint::to_str(pos, 16u) + \":\"\n-                                      + _uint::to_str(len, 16u) + \"#\");\n+                                      + uint::to_str(pos, 16u) + \":\"\n+                                      + uint::to_str(len, 16u) + \"#\");\n                             auto a = rec(pos=pos, len=len, s=s);\n                             abbrevs.insert(t, a);\n                         }\n@@ -265,21 +265,21 @@ mod Encode {\n \n // Returns a Plain Old LLVM String:\n fn C_postr(&str s) -> ValueRef {\n-    ret llvm::LLVMConstString(_str::buf(s), _str::byte_len(s), False);\n+    ret llvm::LLVMConstString(str::buf(s), str::byte_len(s), False);\n }\n \n \n // Path table encoding\n \n fn encode_name(&ebml::writer ebml_w, &str name) {\n     ebml::start_tag(ebml_w, tag_paths_data_name);\n-    ebml_w.writer.write(_str::bytes(name));\n+    ebml_w.writer.write(str::bytes(name));\n     ebml::end_tag(ebml_w);\n }\n \n fn encode_def_id(&ebml::writer ebml_w, &ast::def_id id) {\n     ebml::start_tag(ebml_w, tag_def_id);\n-    ebml_w.writer.write(_str::bytes(def_to_str(id)));\n+    ebml_w.writer.write(str::bytes(def_to_str(id)));\n     ebml::end_tag(ebml_w);\n }\n \n@@ -301,7 +301,7 @@ fn add_to_index(&ebml::writer ebml_w,\n                 &mutable vec[tup(str, uint)] index,\n                 &str name) {\n     auto full_path = path + [name];\n-    index += [tup(_str::connect(full_path, \"::\"), ebml_w.writer.tell())];\n+    index += [tup(str::connect(full_path, \"::\"), ebml_w.writer.tell())];\n }\n \n fn encode_native_module_item_paths(&ebml::writer ebml_w,\n@@ -424,13 +424,13 @@ fn def_to_str(&ast::def_id did) -> str {\n \n fn encode_type_param_count(&ebml::writer ebml_w, &vec[ast::ty_param] tps) {\n     ebml::start_tag(ebml_w, tag_items_data_item_ty_param_count);\n-    ebml::write_vint(ebml_w.writer, _vec::len[ast::ty_param](tps));\n+    ebml::write_vint(ebml_w.writer, vec::len[ast::ty_param](tps));\n     ebml::end_tag(ebml_w);\n }\n \n fn encode_variant_id(&ebml::writer ebml_w, &ast::def_id vid) {\n     ebml::start_tag(ebml_w, tag_items_data_item_variant);\n-    ebml_w.writer.write(_str::bytes(def_to_str(vid)));\n+    ebml_w.writer.write(str::bytes(def_to_str(vid)));\n     ebml::end_tag(ebml_w);\n }\n \n@@ -447,20 +447,20 @@ fn encode_type(&@trans::crate_ctxt cx, &ebml::writer ebml_w, &ty::t typ) {\n fn encode_symbol(&@trans::crate_ctxt cx, &ebml::writer ebml_w,\n                  &ast::def_id did) {\n     ebml::start_tag(ebml_w, tag_items_data_item_symbol);\n-    ebml_w.writer.write(_str::bytes(cx.item_symbols.get(did)));\n+    ebml_w.writer.write(str::bytes(cx.item_symbols.get(did)));\n     ebml::end_tag(ebml_w);\n }\n \n fn encode_discriminant(&@trans::crate_ctxt cx, &ebml::writer ebml_w,\n                        &ast::def_id did) {\n     ebml::start_tag(ebml_w, tag_items_data_item_symbol);\n-    ebml_w.writer.write(_str::bytes(cx.discrim_symbols.get(did)));\n+    ebml_w.writer.write(str::bytes(cx.discrim_symbols.get(did)));\n     ebml::end_tag(ebml_w);\n }\n \n fn encode_tag_id(&ebml::writer ebml_w, &ast::def_id id) {\n     ebml::start_tag(ebml_w, tag_items_data_item_tag_id);\n-    ebml_w.writer.write(_str::bytes(def_to_str(id)));\n+    ebml_w.writer.write(str::bytes(def_to_str(id)));\n     ebml::end_tag(ebml_w);\n }\n \n@@ -478,7 +478,7 @@ fn encode_tag_variant_info(&@trans::crate_ctxt cx, &ebml::writer ebml_w,\n         encode_kind(ebml_w, 'v' as u8);\n         encode_tag_id(ebml_w, did);\n         encode_type(cx, ebml_w, trans::node_ann_type(cx, variant.node.ann));\n-        if (_vec::len[ast::variant_arg](variant.node.args) > 0u) {\n+        if (vec::len[ast::variant_arg](variant.node.args) > 0u) {\n             encode_symbol(cx, ebml_w, variant.node.id);\n         }\n         encode_discriminant(cx, ebml_w, variant.node.id);\n@@ -611,7 +611,7 @@ fn hash_def_num(&int def_num) -> uint {\n \n fn hash_path(&str s) -> uint {\n     auto h = 5381u;\n-    for (u8 ch in _str::bytes(s)) {\n+    for (u8 ch in str::bytes(s)) {\n         h = ((h << 5u) + h) ^ (ch as uint);\n     }\n     ret h;\n@@ -620,7 +620,7 @@ fn hash_path(&str s) -> uint {\n fn create_index[T](&vec[tup(T, uint)] index, fn(&T) -> uint hash_fn)\n         -> vec[vec[tup(T, uint)]] {\n     let vec[vec[tup(T, uint)]] buckets = [];\n-    for each (uint i in _uint::range(0u, 256u)) {\n+    for each (uint i in uint::range(0u, 256u)) {\n         let vec[tup(T, uint)] bucket = [];\n         buckets += [bucket];\n     }\n@@ -712,9 +712,9 @@ fn write_metadata(&@trans::crate_ctxt cx, &@ast::crate crate) {\n \n     auto llconst = trans::C_struct([llmeta]);\n     auto llglobal = llvm::LLVMAddGlobal(cx.llmod, trans::val_ty(llconst),\n-                                       _str::buf(\"rust_metadata\"));\n+                                       str::buf(\"rust_metadata\"));\n     llvm::LLVMSetInitializer(llglobal, llconst);\n-    llvm::LLVMSetSection(llglobal, _str::buf(x86::get_meta_sect_name()));\n+    llvm::LLVMSetSection(llglobal, str::buf(x86::get_meta_sect_name()));\n }\n \n //"}, {"sha": "28692f23928d022b33050186a8a0dbc655834d17", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -18,8 +18,8 @@ import std::list::cons;\n import std::option;\n import std::option::some;\n import std::option::none;\n-import std::_str;\n-import std::_vec;\n+import std::str;\n+import std::vec;\n \n // Resolving happens in two passes. The first pass collects defids of all\n // (internal) imports and modules, so that they can be looked up when needed,\n@@ -52,7 +52,7 @@ tag import_state {\n type ext_hash = hashmap[tup(def_id,str,namespace),def];\n fn new_ext_hash() -> ext_hash {\n     fn hash(&tup(def_id,str,namespace) v) -> uint {\n-        ret _str::hash(v._1) + util::common::hash_def(v._0) + (alt (v._2) {\n+        ret str::hash(v._1) + util::common::hash_def(v._0) + (alt (v._2) {\n             case (ns_value) { 1u }\n             case (ns_type) { 2u }\n             case (ns_module) { 3u }\n@@ -61,7 +61,7 @@ fn new_ext_hash() -> ext_hash {\n     fn eq(&tup(def_id,str,namespace) v1,\n           &tup(def_id,str,namespace) v2) -> bool {\n         ret util::common::def_eq(v1._0, v2._0) &&\n-            _str::eq(v1._1, v2._1) &&\n+            str::eq(v1._1, v2._1) &&\n             v1._2 == v2._2;\n     }\n     ret std::map::mk_hashmap[tup(def_id,str,namespace),def](hash, eq);\n@@ -223,7 +223,7 @@ fn resolve_names(&@env e, &ast::crate c) {\n                     }\n                     case (_) {\n                         e.sess.span_err(p.span, \"not a tag variant: \" +\n-                                        _str::connect(p.node.idents, \"::\"));\n+                                        str::connect(p.node.idents, \"::\"));\n                         fail;\n                     }\n                 }\n@@ -321,7 +321,7 @@ fn resolve_import(&env e, &@ast::view_item it, &list[scope] sc) {\n     }\n     e.imports.insert(defid._1, resolving(it.span));\n     \n-    auto n_idents = _vec::len(ids);\n+    auto n_idents = vec::len(ids);\n     auto end_id = ids.(n_idents - 1u);\n \n     if (n_idents == 1u) {\n@@ -377,7 +377,7 @@ fn unresolved(&env e, &span sp, &ident id, &str kind) {\n \n fn lookup_path_strict(&env e, &list[scope] sc, &span sp, vec[ident] idents,\n                       namespace ns) -> def {\n-    auto n_idents = _vec::len(idents);\n+    auto n_idents = vec::len(idents);\n     auto headns = if (n_idents == 1u) { ns } else { ns_module };\n     auto dcur = lookup_in_scope_strict(e, sc, sp, idents.(0), headns);\n     auto i = 1u;\n@@ -477,7 +477,7 @@ fn lookup_in_scope(&env e, list[scope] sc, &span sp, &ident id, namespace ns)\n                 if (ns == ns_value) {\n                     alt (d.node) {\n                         case (ast::decl_local(?local)) {\n-                            if (_str::eq(local.ident, id)) {\n+                            if (str::eq(local.ident, id)) {\n                                 ret some(ast::def_local(local.id));\n                             }\n                         }\n@@ -529,7 +529,7 @@ fn lookup_in_ty_params(&ident id, &vec[ast::ty_param] ty_params)\n     -> option::t[def] {\n     auto i = 0u;\n     for (ast::ty_param tp in ty_params) {\n-        if (_str::eq(tp, id)) {\n+        if (str::eq(tp, id)) {\n             ret some(ast::def_ty_arg(i));\n         }\n         i += 1u;\n@@ -540,7 +540,7 @@ fn lookup_in_ty_params(&ident id, &vec[ast::ty_param] ty_params)\n fn lookup_in_pat(&ident id, &ast::pat pat) -> option::t[def] {\n     alt (pat.node) {\n         case (ast::pat_bind(?name, ?defid, _)) {\n-            if (_str::eq(name, id)) { ret some(ast::def_binding(defid)); }\n+            if (str::eq(name, id)) { ret some(ast::def_binding(defid)); }\n         }\n         case (ast::pat_wild(_)) {}\n         case (ast::pat_lit(_, _)) {}\n@@ -560,7 +560,7 @@ fn lookup_in_fn(&ident id, &ast::fn_decl decl, &vec[ast::ty_param] ty_params,\n     alt (ns) {\n         case (ns_value) {\n             for (ast::arg a in decl.inputs) {\n-                if (_str::eq(a.ident, id)) {\n+                if (str::eq(a.ident, id)) {\n                     ret some(ast::def_arg(a.id));\n                 }\n             }\n@@ -578,7 +578,7 @@ fn lookup_in_obj(&ident id, &ast::_obj ob, &vec[ast::ty_param] ty_params,\n     alt (ns) {\n         case (ns_value) {\n             for (ast::obj_field f in ob.fields) {\n-                if (_str::eq(f.ident, id)) {\n+                if (str::eq(f.ident, id)) {\n                     ret some(ast::def_obj_field(f.id));\n                 }\n             }\n@@ -598,7 +598,7 @@ fn lookup_in_block(&ident id, &ast::block_ b, namespace ns)\n             case (ast::stmt_decl(?d,_)) {\n                 alt (d.node) {\n                     case (ast::decl_local(?loc)) {\n-                        if (ns == ns_value && _str::eq(id, loc.ident)) {\n+                        if (ns == ns_value && str::eq(id, loc.ident)) {\n                             ret some(ast::def_local(loc.id));\n                         }\n                     }\n@@ -607,20 +607,20 @@ fn lookup_in_block(&ident id, &ast::block_ b, namespace ns)\n                             case (ast::item_tag(?name, ?variants, _,\n                                                ?defid, _)) {\n                                 if (ns == ns_type) {\n-                                    if (_str::eq(name, id)) {\n+                                    if (str::eq(name, id)) {\n                                         ret some(ast::def_ty(defid));\n                                     }\n                                 } else if (ns == ns_value) {\n                                     for (ast::variant v in variants) {\n-                                        if (_str::eq(v.node.name, id)) {\n+                                        if (str::eq(v.node.name, id)) {\n                                             ret some(ast::def_variant(\n                                                       defid, v.node.id));\n                                         }\n                                     }\n                                 }\n                             }\n                             case (_) {\n-                                if (_str::eq(ast::item_ident(it), id)) {\n+                                if (str::eq(ast::item_ident(it), id)) {\n                                     auto found = found_def_item(it, ns);\n                                     if (!option::is_none(found)) {ret found;}\n                                 }"}, {"sha": "29f66d8b5631bb0ab4b36fd3c6f68dfb06fdc96e", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 138, "deletions": 138, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,9 +1,9 @@\n-import std::_int;\n-import std::_str;\n-import std::_uint;\n-import std::_vec;\n-import std::_str::rustrt::sbuf;\n-import std::_vec::rustrt::vbuf;\n+import std::int;\n+import std::str;\n+import std::uint;\n+import std::vec;\n+import std::str::rustrt::sbuf;\n+import std::vec::rustrt::vbuf;\n import std::map;\n import std::map::hashmap;\n import std::option;\n@@ -197,7 +197,7 @@ fn extend_path(@local_ctxt cx, &str name) -> @local_ctxt {\n }\n \n fn path_name(&vec[str] path) -> str {\n-    ret _str::connect(path, sep());\n+    ret str::connect(path, sep());\n }\n \n \n@@ -215,7 +215,7 @@ fn get_type_sha1(&@crate_ctxt ccx, &ty::t t) -> str {\n                            abbrevs=metadata::ac_no_abbrevs);\n \n             ccx.sha.input_str(metadata::Encode::ty_str(cx, t));\n-            hash = _str::substr(ccx.sha.result_str(), 0u, 16u);\n+            hash = str::substr(ccx.sha.result_str(), 0u, 16u);\n             ccx.type_sha1s.insert(t, hash);\n         }\n     }\n@@ -335,8 +335,8 @@ fn T_size_t() -> TypeRef {\n \n fn T_fn(vec[TypeRef] inputs, TypeRef output) -> TypeRef {\n     ret llvm::LLVMFunctionType(output,\n-                              _vec::buf[TypeRef](inputs),\n-                              _vec::len[TypeRef](inputs),\n+                              vec::buf[TypeRef](inputs),\n+                              vec::len[TypeRef](inputs),\n                               False);\n }\n \n@@ -350,8 +350,8 @@ fn T_ptr(TypeRef t) -> TypeRef {\n }\n \n fn T_struct(&vec[TypeRef] elts) -> TypeRef {\n-    ret llvm::LLVMStructType(_vec::buf[TypeRef](elts),\n-                            _vec::len[TypeRef](elts),\n+    ret llvm::LLVMStructType(vec::buf[TypeRef](elts),\n+                            vec::len[TypeRef](elts),\n                             False);\n }\n \n@@ -381,9 +381,9 @@ fn T_task(&type_names tn) -> TypeRef {\n fn T_tydesc_field(&type_names tn, int field) -> TypeRef {\n     // Bit of a kludge: pick the fn typeref out of the tydesc..\n     let vec[TypeRef] tydesc_elts =\n-        _vec::init_elt[TypeRef](T_nil(), abi::n_tydesc_fields as uint);\n+        vec::init_elt[TypeRef](T_nil(), abi::n_tydesc_fields as uint);\n     llvm::LLVMGetStructElementTypes(T_tydesc(tn),\n-                                   _vec::buf[TypeRef](tydesc_elts));\n+                                   vec::buf[TypeRef](tydesc_elts));\n     auto t = llvm::LLVMGetElementType(tydesc_elts.(field));\n     ret t;\n }\n@@ -401,7 +401,7 @@ fn T_glue_fn(&type_names tn) -> TypeRef {\n \n fn T_dtor(&@crate_ctxt ccx, TypeRef llself_ty) -> TypeRef {\n     ret type_of_fn_full(ccx, ast::proto_fn, some[TypeRef](llself_ty),\n-                        _vec::empty[ty::arg](), ty::mk_nil(ccx.tcx), 0u);\n+                        vec::empty[ty::arg](), ty::mk_nil(ccx.tcx), 0u);\n }\n \n fn T_cmp_glue_fn(&type_names tn) -> TypeRef {\n@@ -565,7 +565,7 @@ fn T_opaque_closure_ptr(&type_names tn) -> TypeRef {\n }\n \n fn T_tag(&type_names tn, uint size) -> TypeRef {\n-    auto s = \"tag_\" + _uint::to_str(size, 10u);\n+    auto s = \"tag_\" + uint::to_str(size, 10u);\n     if (tn.name_has_type(s)) {\n         ret tn.get_type(s);\n     }\n@@ -596,7 +596,7 @@ fn T_opaque_tag_ptr(&type_names tn) -> TypeRef {\n }\n \n fn T_captured_tydescs(&type_names tn, uint n) -> TypeRef {\n-    ret T_struct(_vec::init_elt[TypeRef](T_ptr(T_tydesc(tn)), n));\n+    ret T_struct(vec::init_elt[TypeRef](T_ptr(T_tydesc(tn)), n));\n }\n \n fn T_obj_ptr(&type_names tn, uint n_captured_tydescs) -> TypeRef {\n@@ -857,7 +857,7 @@ fn type_of_inner(&@crate_ctxt cx, &ty::t t) -> TypeRef {\n     assert (llty as int != 0);\n     if (cx.sess.get_opts().save_temps) {\n         llvm::LLVMAddTypeName(cx.llmod,\n-                             _str::buf(ty::ty_to_short_str(cx.tcx, t)),\n+                             str::buf(ty::ty_to_short_str(cx.tcx, t)),\n                              llty);\n     }\n     cx.lltypes.insert(t, llty);\n@@ -919,7 +919,7 @@ fn sanitize(&str s) -> str {\n                         c != (' ' as u8) && c != ('\\t' as u8) &&\n                         c != (';' as u8)) {\n                         auto v = [c];\n-                        result += _str::from_bytes(v);\n+                        result += str::from_bytes(v);\n                     }\n                 }\n             }\n@@ -944,11 +944,11 @@ fn C_integral(TypeRef t, uint u, Bool sign_extend) -> ValueRef {\n }\n \n fn C_float(&str s) -> ValueRef {\n-    ret llvm::LLVMConstRealOfString(T_float(), _str::buf(s));\n+    ret llvm::LLVMConstRealOfString(T_float(), str::buf(s));\n }\n \n fn C_floating(&str s, TypeRef t) -> ValueRef {\n-    ret llvm::LLVMConstRealOfString(t, _str::buf(s));\n+    ret llvm::LLVMConstRealOfString(t, str::buf(s));\n }\n \n fn C_nil() -> ValueRef {\n@@ -975,9 +975,9 @@ fn C_u8(uint i) -> ValueRef {\n // This is a 'c-like' raw string, which differs from\n // our boxed-and-length-annotated strings.\n fn C_cstr(&@crate_ctxt cx, &str s) -> ValueRef {\n-    auto sc = llvm::LLVMConstString(_str::buf(s), _str::byte_len(s), False);\n+    auto sc = llvm::LLVMConstString(str::buf(s), str::byte_len(s), False);\n     auto g = llvm::LLVMAddGlobal(cx.llmod, val_ty(sc),\n-                                _str::buf(cx.names.next(\"str\")));\n+                                str::buf(cx.names.next(\"str\")));\n     llvm::LLVMSetInitializer(g, sc);\n     llvm::LLVMSetGlobalConstant(g, True);\n     llvm::LLVMSetLinkage(g, lib::llvm::LLVMInternalLinkage\n@@ -987,15 +987,15 @@ fn C_cstr(&@crate_ctxt cx, &str s) -> ValueRef {\n \n // A rust boxed-and-length-annotated string.\n fn C_str(&@crate_ctxt cx, &str s) -> ValueRef {\n-    auto len = _str::byte_len(s);\n+    auto len = str::byte_len(s);\n     auto box = C_struct([C_int(abi::const_refcount as int),\n                             C_int(len + 1u as int), // 'alloc'\n                             C_int(len + 1u as int), // 'fill'\n                             C_int(0),               // 'pad'\n-                            llvm::LLVMConstString(_str::buf(s),\n+                            llvm::LLVMConstString(str::buf(s),\n                                                  len, False)]);\n     auto g = llvm::LLVMAddGlobal(cx.llmod, val_ty(box),\n-                                _str::buf(cx.names.next(\"str\")));\n+                                str::buf(cx.names.next(\"str\")));\n     llvm::LLVMSetInitializer(g, box);\n     llvm::LLVMSetGlobalConstant(g, True);\n     llvm::LLVMSetLinkage(g, lib::llvm::LLVMInternalLinkage\n@@ -1010,24 +1010,24 @@ fn C_zero_byte_arr(uint size) -> ValueRef {\n         elts += [C_u8(0u)];\n         i += 1u;\n     }\n-    ret llvm::LLVMConstArray(T_i8(), _vec::buf[ValueRef](elts),\n-                            _vec::len[ValueRef](elts));\n+    ret llvm::LLVMConstArray(T_i8(), vec::buf[ValueRef](elts),\n+                            vec::len[ValueRef](elts));\n }\n \n fn C_struct(&vec[ValueRef] elts) -> ValueRef {\n-    ret llvm::LLVMConstStruct(_vec::buf[ValueRef](elts),\n-                             _vec::len[ValueRef](elts),\n+    ret llvm::LLVMConstStruct(vec::buf[ValueRef](elts),\n+                             vec::len[ValueRef](elts),\n                              False);\n }\n \n fn C_array(TypeRef ty, &vec[ValueRef] elts) -> ValueRef {\n-    ret llvm::LLVMConstArray(ty, _vec::buf[ValueRef](elts),\n-                            _vec::len[ValueRef](elts));\n+    ret llvm::LLVMConstArray(ty, vec::buf[ValueRef](elts),\n+                            vec::len[ValueRef](elts));\n }\n \n fn decl_fn(ModuleRef llmod, &str name, uint cc, TypeRef llty) -> ValueRef {\n     let ValueRef llfn =\n-        llvm::LLVMAddFunction(llmod, _str::buf(name), llty);\n+        llvm::LLVMAddFunction(llmod, str::buf(name), llty);\n     llvm::LLVMSetFunctionCallConv(llfn, cc);\n     ret llfn;\n }\n@@ -1075,7 +1075,7 @@ fn decl_native_glue(ModuleRef llmod, &type_names tn,\n         args += [T_int()]; // taskptr, will not be passed\n     }\n \n-    args += _vec::init_elt[TypeRef](T_int(), n as uint);\n+    args += vec::init_elt[TypeRef](T_int(), n as uint);\n \n     ret decl_fastcall_fn(llmod, s, T_fn(args, T_int()));\n }\n@@ -1096,15 +1096,15 @@ fn get_extern_const(&hashmap[str, ValueRef] externs,\n     if (externs.contains_key(name)) {\n         ret externs.get(name);\n     }\n-    auto c = llvm::LLVMAddGlobal(llmod, ty, _str::buf(name));\n+    auto c = llvm::LLVMAddGlobal(llmod, ty, str::buf(name));\n     externs.insert(name, c);\n     ret c;\n }\n \n fn get_simple_extern_fn(&hashmap[str, ValueRef] externs,\n                         ModuleRef llmod, &str name,\n                         int n_args) -> ValueRef {\n-    auto inputs = _vec::init_elt[TypeRef](T_int(), n_args as uint);\n+    auto inputs = vec::init_elt[TypeRef](T_int(), n_args as uint);\n     auto output = T_int();\n     auto t = T_fn(inputs, output);\n     ret get_extern_fn(externs, llmod, name, lib::llvm::LLVMCCallConv, t);\n@@ -1114,7 +1114,7 @@ fn trans_native_call(&builder b, @glue_fns glues, ValueRef lltaskptr,\n                      &hashmap[str, ValueRef] externs,\n                      &type_names tn, ModuleRef llmod, &str name,\n                      bool pass_task, &vec[ValueRef] args) -> ValueRef {\n-    let int n = (_vec::len[ValueRef](args) as int);\n+    let int n = (vec::len[ValueRef](args) as int);\n     let ValueRef llnative = get_simple_extern_fn(externs, llmod, name, n);\n     llnative = llvm::LLVMConstPointerCast(llnative, T_int());\n \n@@ -1445,7 +1445,7 @@ fn GEP_tup_like(&@block_ctxt cx, &ty::t t,\n     fn split_type(&@crate_ctxt ccx, &ty::t t, &vec[int] ixs, uint n)\n         -> rec(vec[ty::t] prefix, ty::t target) {\n \n-        let uint len = _vec::len[int](ixs);\n+        let uint len = vec::len[int](ixs);\n \n         // We don't support 0-index or 1-index GEPs: The former is nonsense\n         // and the latter would only be meaningful if we supported non-0\n@@ -1467,7 +1467,7 @@ fn GEP_tup_like(&@block_ctxt cx, &ty::t t,\n         let vec[ty::t] prefix = [];\n         let int i = 0;\n         while (i < ix) {\n-            _vec::push[ty::t](prefix,\n+            vec::push[ty::t](prefix,\n                             ty::get_element_type(ccx.tcx, t, i as uint));\n             i += 1 ;\n         }\n@@ -1696,8 +1696,8 @@ fn get_derived_tydesc(&@block_ctxt cx, &ty::t t, bool escapes,\n     let uint n_params = ty::count_ty_params(bcx.fcx.lcx.ccx.tcx, t);\n     auto tys = linearize_ty_params(bcx, t);\n \n-    assert (n_params == _vec::len[uint](tys._0));\n-    assert (n_params == _vec::len[ValueRef](tys._1));\n+    assert (n_params == vec::len[uint](tys._0));\n+    assert (n_params == vec::len[ValueRef](tys._1));\n \n     auto root_ti = get_static_tydesc(bcx, t, tys._0);\n     static_ti = some[@tydesc_info](root_ti);\n@@ -1833,7 +1833,7 @@ fn declare_tydesc(&@local_ctxt cx, &ty::t t,\n     }\n \n     auto gvar = llvm::LLVMAddGlobal(ccx.llmod, T_tydesc(ccx.tn),\n-                                    _str::buf(name));\n+                                    str::buf(name));\n \n     auto info = @rec(ty = t,\n                      tydesc = gvar,\n@@ -1892,23 +1892,23 @@ fn make_generic_glue(&@local_ctxt cx,\n         llty = T_ptr(type_of(cx.ccx, t));\n     }\n \n-    auto ty_param_count = _vec::len[uint](ty_params);\n+    auto ty_param_count = vec::len[uint](ty_params);\n \n     auto lltyparams = llvm::LLVMGetParam(llfn, 3u);\n \n     auto copy_args_bcx = new_raw_block_ctxt(fcx, fcx.llcopyargs);\n \n-    auto lltydescs = _vec::empty_mut[ValueRef]();\n+    auto lltydescs = vec::empty_mut[ValueRef]();\n     auto p = 0u;\n     while (p < ty_param_count) {\n         auto llparam = copy_args_bcx.build.GEP(lltyparams,\n                                                [C_int(p as int)]);\n         llparam = copy_args_bcx.build.Load(llparam);\n-        _vec::grow_set[ValueRef](lltydescs, ty_params.(p), 0 as ValueRef,\n+        vec::grow_set[ValueRef](lltydescs, ty_params.(p), 0 as ValueRef,\n                                 llparam);\n         p += 1u;\n     }\n-    fcx.lltydescs = _vec::freeze[ValueRef](lltydescs);\n+    fcx.lltydescs = vec::freeze[ValueRef](lltydescs);\n \n     auto bcx = new_top_block_ctxt(fcx);\n     auto lltop = bcx.llbb;\n@@ -2248,7 +2248,7 @@ fn decr_refcnt_and_if_zero(&@block_ctxt cx,\n \n fn maybe_name_value(&@crate_ctxt cx, ValueRef v, &str s) {\n     if (cx.sess.get_opts().save_temps) {\n-        llvm::LLVMSetValueName(v, _str::buf(s));\n+        llvm::LLVMSetValueName(v, str::buf(s));\n     }\n }\n \n@@ -2527,7 +2527,7 @@ fn tag_variants(&@crate_ctxt cx, &ast::def_id id) -> vec[variant_info] {\n             for (ast::variant variant in variants) {\n                 auto ctor_ty = node_ann_type(cx, variant.node.ann);\n                 let vec[ty::t] arg_tys = [];\n-                if (_vec::len[ast::variant_arg](variant.node.args) > 0u) {\n+                if (vec::len[ast::variant_arg](variant.node.args) > 0u) {\n                     for (ty::arg a in ty::ty_fn_args(cx.tcx, ctor_ty)) {\n                         arg_tys += [a.ty];\n                     }\n@@ -2548,7 +2548,7 @@ fn tag_variant_with_id(&@crate_ctxt cx,\n     auto variants = tag_variants(cx, tag_id);\n \n     auto i = 0u;\n-    while (i < _vec::len[variant_info](variants)) {\n+    while (i < vec::len[variant_info](variants)) {\n         auto variant = variants.(i);\n         if (common::def_eq(variant.id, variant_id)) {\n             ret variant;\n@@ -2644,7 +2644,7 @@ fn iter_structural_ty_full(&@block_ctxt cx,\n         }\n         case (ty::ty_tag(?tid, ?tps)) {\n             auto variants = tag_variants(cx.fcx.lcx.ccx, tid);\n-            auto n_variants = _vec::len[variant_info](variants);\n+            auto n_variants = vec::len[variant_info](variants);\n \n             // Cast the tags to types we can GEP into.\n             auto lltagty = T_opaque_tag_ptr(cx.fcx.lcx.ccx.tn);\n@@ -2681,10 +2681,10 @@ fn iter_structural_ty_full(&@block_ctxt cx,\n             for (variant_info variant in variants) {\n                 auto variant_cx = new_sub_block_ctxt(bcx,\n                                                      \"tag-iter-variant-\" +\n-                                                     _uint::to_str(i, 10u));\n+                                                     uint::to_str(i, 10u));\n                 llvm::LLVMAddCase(llswitch, C_int(i as int), variant_cx.llbb);\n \n-                if (_vec::len[ty::t](variant.args) > 0u) {\n+                if (vec::len[ty::t](variant.args) > 0u) {\n                     // N-ary variant.\n                     auto fn_ty = variant.ctor_ty;\n                     alt (ty::struct(bcx.fcx.lcx.ccx.tcx, fn_ty)) {\n@@ -3670,12 +3670,12 @@ fn join_results(&@block_ctxt parent_cx,\n         }\n     }\n \n-    alt (_vec::len[result](live)) {\n+    alt (vec::len[result](live)) {\n         case (0u) {\n             // No incoming edges are live, so we're in dead-code-land.\n             // Arbitrarily pick the first dead edge, since the caller\n             // is just going to propagate it outward.\n-            assert (_vec::len[result](ins) >= 1u);\n+            assert (vec::len[result](ins) >= 1u);\n             ret ins.(0);\n         }\n \n@@ -3806,10 +3806,10 @@ fn collect_upvars(&@block_ctxt cx, &ast::block bloc,\n             case (ast::expr_path(?path, ?ann)) {\n                 alt (e.def_map.get(ast::ann_tag(ann))) {\n                     case (ast::def_arg(?did)) {\n-                        _vec::push[ast::def_id](e.refs, did);\n+                        vec::push[ast::def_id](e.refs, did);\n                     }\n                     case (ast::def_local(?did)) {\n-                        _vec::push[ast::def_id](e.refs, did);\n+                        vec::push[ast::def_id](e.refs, did);\n                     }\n                     case (_) {}\n                 }\n@@ -3892,7 +3892,7 @@ fn trans_for_each(&@block_ctxt cx,\n     }\n \n     auto upvars = collect_upvars(cx, body, decl_id);\n-    auto upvar_count = _vec::len[ast::def_id](upvars);\n+    auto upvar_count = vec::len[ast::def_id](upvars);\n \n     auto llbindingsptr;\n     if (upvar_count > 0u) {\n@@ -3931,7 +3931,7 @@ fn trans_for_each(&@block_ctxt cx,\n     }\n \n     // Create an environment and populate it with the bindings.\n-    auto tydesc_count = _vec::len[ValueRef](cx.fcx.lltydescs);\n+    auto tydesc_count = vec::len[ValueRef](cx.fcx.lltydescs);\n     auto llenvptrty = T_closure_ptr(lcx.ccx.tn, T_ptr(T_nil()),\n                                     val_ty(llbindingsptr), tydesc_count);\n     auto llenvptr = alloca(cx, llvm::LLVMGetElementType(llenvptrty));\n@@ -4149,7 +4149,7 @@ fn trans_pat_match(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n             auto ty_params = ty::ann_to_type_params(cx.fcx.lcx.ccx.node_types,\n                                                     ann);\n \n-            if (_vec::len[@ast::pat](subpats) > 0u) {\n+            if (vec::len[@ast::pat](subpats) > 0u) {\n                 auto llblobptr = matched_cx.build.GEP(lltagptr,\n                     [C_int(0), C_int(1)]);\n                 auto i = 0;\n@@ -4201,7 +4201,7 @@ fn trans_pat_binding(&@block_ctxt cx, &@ast::pat pat,\n             }\n         }\n         case (ast::pat_tag(_, ?subpats, ?ann)) {\n-            if (_vec::len[@ast::pat](subpats) == 0u) { ret res(cx, llval); }\n+            if (vec::len[@ast::pat](subpats) == 0u) { ret res(cx, llval); }\n \n             // Get the appropriate variant for this tag.\n             auto vdef = ast::variant_def_ids\n@@ -4326,7 +4326,7 @@ fn lval_generic_fn(&@block_ctxt cx,\n     auto tys = ty::ann_to_type_params(cx.fcx.lcx.ccx.node_types, ann);\n     auto monoty = ty::ann_to_type(cx.fcx.lcx.ccx.node_types, ann);\n \n-    if (_vec::len[ty::t](tys) != 0u) {\n+    if (vec::len[ty::t](tys) != 0u) {\n         auto bcx = lv.res.bcx;\n         let vec[ValueRef] tydescs = [];\n         let vec[option::t[@tydesc_info]] tis = [];\n@@ -4336,7 +4336,7 @@ fn lval_generic_fn(&@block_ctxt cx,\n             auto td = get_tydesc(bcx, t, true, ti);\n             tis += [ti];\n             bcx = td.bcx;\n-            _vec::push[ValueRef](tydescs, td.val);\n+            vec::push[ValueRef](tydescs, td.val);\n         }\n         auto gen = rec( item_type = tpt._1,\n                         static_tis = tis,\n@@ -4356,7 +4356,7 @@ fn lookup_discriminant(&@local_ctxt lcx, &ast::def_id tid, &ast::def_id vid)\n             assert (lcx.ccx.sess.get_targ_crate_num() != vid._0);\n             auto sym = creader::get_symbol(lcx.ccx.sess, vid);\n             auto gvar = llvm::LLVMAddGlobal(lcx.ccx.llmod, T_int(),\n-                                           _str::buf(sym));\n+                                           str::buf(sym));\n             llvm::LLVMSetLinkage(gvar, lib::llvm::LLVMExternalLinkage\n                                  as llvm::Linkage);\n             llvm::LLVMSetGlobalConstant(gvar, True);\n@@ -4818,7 +4818,7 @@ fn trans_bind(&@block_ctxt cx, &@ast::expr f,\n                 case (none[@ast::expr]) {\n                 }\n                 case (some[@ast::expr](?e)) {\n-                    _vec::push[@ast::expr](bound, e);\n+                    vec::push[@ast::expr](bound, e);\n                 }\n             }\n         }\n@@ -4838,9 +4838,9 @@ fn trans_bind(&@block_ctxt cx, &@ast::expr f,\n                 lltydescs = ginfo.tydescs;\n             }\n         }\n-        auto ty_param_count = _vec::len[ValueRef](lltydescs);\n+        auto ty_param_count = vec::len[ValueRef](lltydescs);\n \n-        if (_vec::len[@ast::expr](bound) == 0u && ty_param_count == 0u) {\n+        if (vec::len[@ast::expr](bound) == 0u && ty_param_count == 0u) {\n             // Trivial 'binding': just return the static pair-ptr.\n             ret f_res.res;\n         } else {\n@@ -4856,8 +4856,8 @@ fn trans_bind(&@block_ctxt cx, &@ast::expr f,\n                 auto arg = trans_expr(bcx, e);\n                 bcx = arg.bcx;\n \n-                _vec::push[ValueRef](bound_vals, arg.val);\n-                _vec::push[ty::t](bound_tys,\n+                vec::push[ValueRef](bound_vals, arg.val);\n+                vec::push[ty::t](bound_tys,\n                                  ty::expr_ty(cx.fcx.lcx.ccx.tcx,\n                                              cx.fcx.lcx.ccx.node_types, e));\n \n@@ -4874,7 +4874,7 @@ fn trans_bind(&@block_ctxt cx, &@ast::expr f,\n             let ty::t tydesc_ty = ty::mk_type(cx.fcx.lcx.ccx.tcx);\n \n             let vec[ty::t] captured_tys =\n-                _vec::init_elt[ty::t](tydesc_ty, ty_param_count);\n+                vec::init_elt[ty::t](tydesc_ty, ty_param_count);\n \n             let vec[ty::t] closure_tys =\n                 [tydesc_ty,\n@@ -5297,7 +5297,7 @@ fn trans_vec(&@block_ctxt cx, &vec[@ast::expr] args,\n     auto bcx = cx;\n     auto unit_sz = size_of(bcx, unit_ty);\n     bcx = unit_sz.bcx;\n-    auto data_sz = bcx.build.Mul(C_int(_vec::len[@ast::expr](args) as int),\n+    auto data_sz = bcx.build.Mul(C_int(vec::len[@ast::expr](args) as int),\n                                  unit_sz.val);\n \n     // FIXME: pass tydesc properly.\n@@ -5315,8 +5315,8 @@ fn trans_vec(&@block_ctxt cx, &vec[@ast::expr] args,\n \n     auto pseudo_tup_ty =\n         ty::mk_imm_tup(cx.fcx.lcx.ccx.tcx,\n-                      _vec::init_elt[ty::t](unit_ty,\n-                                           _vec::len[@ast::expr](args)));\n+                      vec::init_elt[ty::t](unit_ty,\n+                                           vec::len[@ast::expr](args)));\n     let int i = 0;\n \n     for (@ast::expr e in args) {\n@@ -5393,7 +5393,7 @@ fn trans_rec(&@block_ctxt cx, &vec[ast::field] fields,\n         auto src_res = res(bcx, C_nil());\n \n         for (ast::field f in fields) {\n-            if (_str::eq(f.ident, tf.ident)) {\n+            if (str::eq(f.ident, tf.ident)) {\n                 expr_provided = true;\n                 src_res = trans_expr(bcx, f.expr);\n             }\n@@ -5626,13 +5626,13 @@ fn load_if_immediate(&@block_ctxt cx, ValueRef v, &ty::t t) -> ValueRef {\n \n fn trans_log(int lvl, &@block_ctxt cx, &@ast::expr e) -> result {\n     auto lcx = cx.fcx.lcx;\n-    auto modname = _str::connect(lcx.module_path, \"::\");\n+    auto modname = str::connect(lcx.module_path, \"::\");\n     auto global;\n     if (lcx.ccx.module_data.contains_key(modname)) {\n         global = lcx.ccx.module_data.get(modname);\n     } else {\n         global = llvm::LLVMAddGlobal(lcx.ccx.llmod, T_int(),\n-                                    _str::buf(\"_rust_mod_log_\" + modname));\n+                                    str::buf(\"_rust_mod_log_\" + modname));\n         llvm::LLVMSetGlobalConstant(global, False);\n         llvm::LLVMSetInitializer(global, C_null(T_int()));\n         llvm::LLVMSetLinkage(global, lib::llvm::LLVMInternalLinkage\n@@ -6067,9 +6067,9 @@ fn new_block_ctxt(&@fn_ctxt cx, &block_parent parent,\n                   block_kind kind,\n                   &str name) -> @block_ctxt {\n     let vec[cleanup] cleanups = [];\n-    auto s = _str::buf(\"\");\n+    auto s = str::buf(\"\");\n     if (cx.lcx.ccx.sess.get_opts().save_temps) {\n-        s = _str::buf(cx.lcx.ccx.names.next(name));\n+        s = str::buf(cx.lcx.ccx.names.next(name));\n     }\n     let BasicBlockRef llbb = llvm::LLVMAppendBasicBlock(cx.llfn, s);\n     ret @rec(llbb=llbb,\n@@ -6114,10 +6114,10 @@ fn trans_block_cleanups(&@block_ctxt cx,\n     auto bcx = cx;\n \n     if (cleanup_cx.kind == NON_SCOPE_BLOCK) {\n-        assert (_vec::len[cleanup](cleanup_cx.cleanups) == 0u);\n+        assert (vec::len[cleanup](cleanup_cx.cleanups) == 0u);\n     }\n \n-    auto i = _vec::len[cleanup](cleanup_cx.cleanups);\n+    auto i = vec::len[cleanup](cleanup_cx.cleanups);\n     while (i > 0u) {\n         i -= 1u;\n         auto c = cleanup_cx.cleanups.(i);\n@@ -6282,9 +6282,9 @@ fn new_local_ctxt(&@crate_ctxt ccx) -> @local_ctxt {\n // tydescs.\n fn mk_standard_basic_blocks(ValueRef llfn) ->\n         tup(BasicBlockRef, BasicBlockRef, BasicBlockRef) {\n-    ret tup(llvm::LLVMAppendBasicBlock(llfn, _str::buf(\"allocas\")),\n-            llvm::LLVMAppendBasicBlock(llfn, _str::buf(\"copy_args\")),\n-            llvm::LLVMAppendBasicBlock(llfn, _str::buf(\"derived_tydescs\")));\n+    ret tup(llvm::LLVMAppendBasicBlock(llfn, str::buf(\"allocas\")),\n+            llvm::LLVMAppendBasicBlock(llfn, str::buf(\"copy_args\")),\n+            llvm::LLVMAppendBasicBlock(llfn, str::buf(\"derived_tydescs\")));\n }\n \n // NB: must keep 4 fns in sync:\n@@ -6324,7 +6324,7 @@ fn new_fn_ctxt(@local_ctxt cx,\n              llobjfields=llobjfields,\n              lllocals=lllocals,\n              llupvars=llupvars,\n-             mutable lltydescs=_vec::empty[ValueRef](),\n+             mutable lltydescs=vec::empty[ValueRef](),\n              derived_tydescs=derived_tydescs,\n              lcx=cx);\n }\n@@ -6478,7 +6478,7 @@ fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, self_vt llself) {\n     // its magic.\n     auto fields_tup_ty = ty::mk_imm_tup(fcx.lcx.ccx.tcx, field_tys);\n \n-    auto n_typarams = _vec::len[ast::ty_param](bcx.fcx.lcx.obj_typarams);\n+    auto n_typarams = vec::len[ast::ty_param](bcx.fcx.lcx.obj_typarams);\n     let TypeRef llobj_box_ty = T_obj_ptr(bcx.fcx.lcx.ccx.tn, n_typarams);\n \n     auto box_cell =\n@@ -6595,7 +6595,7 @@ fn trans_vtbl(@local_ctxt cx,\n     let vec[ValueRef] methods = [dtor];\n \n     fn meth_lteq(&@ast::method a, &@ast::method b) -> bool {\n-        ret _str::lteq(a.node.ident, b.node.ident);\n+        ret str::lteq(a.node.ident, b.node.ident);\n     }\n \n     auto meths = std::sort::merge_sort[@ast::method](bind meth_lteq(_,_),\n@@ -6609,7 +6609,7 @@ fn trans_vtbl(@local_ctxt cx,\n                 llfnty = type_of_fn_full(cx.ccx, proto,\n                                          some[TypeRef](llself_ty),\n                                          inputs, output,\n-                                         _vec::len[ast::ty_param](ty_params));\n+                                         vec::len[ast::ty_param](ty_params));\n             }\n         }\n \n@@ -6628,7 +6628,7 @@ fn trans_vtbl(@local_ctxt cx,\n     auto vtbl = C_struct(methods);\n     auto vtbl_name = mangle_name_by_seq(cx.ccx, cx.path, \"vtbl\");\n     auto gvar = llvm::LLVMAddGlobal(cx.ccx.llmod, val_ty(vtbl),\n-                                   _str::buf(vtbl_name));\n+                                   str::buf(vtbl_name));\n     llvm::LLVMSetInitializer(gvar, vtbl);\n     llvm::LLVMSetGlobalConstant(gvar, True);\n     llvm::LLVMSetLinkage(gvar, lib::llvm::LLVMInternalLinkage\n@@ -6696,22 +6696,22 @@ fn trans_obj(@local_ctxt cx, &ast::_obj ob, ast::def_id oid,\n \n     // FIXME we should probably also allocate a box for empty objs that have a\n     // dtor, since otherwise they are never dropped, and the dtor never runs\n-    if (_vec::len[ast::ty_param](ty_params) == 0u &&\n-        _vec::len[ty::arg](arg_tys) == 0u) {\n+    if (vec::len[ast::ty_param](ty_params) == 0u &&\n+        vec::len[ty::arg](arg_tys) == 0u) {\n         // Store null into pair, if no args or typarams.\n         bcx.build.Store(C_null(llbox_ty), pair_box);\n     } else {\n         // Malloc a box for the body and copy args in.\n         let vec[ty::t] obj_fields = [];\n         for (ty::arg a in arg_tys) {\n-            _vec::push[ty::t](obj_fields, a.ty);\n+            vec::push[ty::t](obj_fields, a.ty);\n         }\n \n         // Synthesize an obj body type.\n         auto tydesc_ty = ty::mk_type(ccx.tcx);\n         let vec[ty::t] tps = [];\n         for (ast::ty_param tp in ty_params) {\n-            _vec::push[ty::t](tps, tydesc_ty);\n+            vec::push[ty::t](tps, tydesc_ty);\n         }\n \n         let ty::t typarams_ty = ty::mk_imm_tup(ccx.tcx, tps);\n@@ -6797,7 +6797,7 @@ fn trans_obj(@local_ctxt cx, &ast::_obj ob, ast::def_id oid,\n fn trans_tag_variant(@local_ctxt cx, ast::def_id tag_id,\n                      &ast::variant variant, int index,\n                      &vec[ast::ty_param] ty_params) {\n-    if (_vec::len[ast::variant_arg](variant.node.args) == 0u) {\n+    if (vec::len[ast::variant_arg](variant.node.args) == 0u) {\n         ret;    // nullary constructors are just constants\n     }\n \n@@ -6807,7 +6807,7 @@ fn trans_tag_variant(@local_ctxt cx, ast::def_id tag_id,\n     for (ast::variant_arg varg in variant.node.args) {\n         fn_args += [rec(mode=ast::alias,\n                            ty=varg.ty,\n-                           ident=\"arg\" + _uint::to_str(i, 10u),\n+                           ident=\"arg\" + uint::to_str(i, 10u),\n                            id=varg.id)];\n     }\n \n@@ -6949,7 +6949,7 @@ fn get_pair_fn_ty(TypeRef llpairty) -> TypeRef {\n     // Bit of a kludge: pick the fn typeref out of the pair.\n     let vec[TypeRef] pair_tys = [T_nil(), T_nil()];\n     llvm::LLVMGetStructElementTypes(llpairty,\n-                                   _vec::buf[TypeRef](pair_tys));\n+                                   vec::buf[TypeRef](pair_tys));\n     ret llvm::LLVMGetElementType(pair_tys.(0));\n }\n \n@@ -6965,7 +6965,7 @@ fn decl_fn_and_pair(&@crate_ctxt ccx,\n     alt (ty::struct(ccx.tcx, node_ann_type(ccx, ann))) {\n         case (ty::ty_fn(?proto, ?inputs, ?output)) {\n             llfty = type_of_fn(ccx, proto, inputs, output,\n-                               _vec::len[ast::ty_param](ty_params));\n+                               vec::len[ast::ty_param](ty_params));\n             llpairty = T_fn_pair(ccx.tn, llfty);\n         }\n         case (_) {\n@@ -6987,7 +6987,7 @@ fn decl_fn_and_pair(&@crate_ctxt ccx,\n fn register_fn_pair(&@crate_ctxt cx, str ps, TypeRef llpairty, ValueRef llfn,\n                     ast::def_id id) {\n     let ValueRef gvar = llvm::LLVMAddGlobal(cx.llmod, llpairty,\n-                                           _str::buf(ps));\n+                                           str::buf(ps));\n     auto pair = C_struct([llfn,\n                              C_null(T_opaque_closure_ptr(cx.tn))]);\n \n@@ -7013,7 +7013,7 @@ fn native_fn_ty_param_count(&@crate_ctxt cx, &ast::def_id id) -> uint {\n             fail;\n         }\n         case (ast::native_item_fn(_, _, _, ?tps, _, _)) {\n-            count = _vec::len[ast::ty_param](tps);\n+            count = vec::len[ast::ty_param](tps);\n         }\n     }\n     ret count;\n@@ -7101,7 +7101,7 @@ fn decl_native_fn_and_pair(&@crate_ctxt ccx,\n     if (pass_task) { call_args += [lltaskptr]; }\n \n     auto arg_n = 3u;\n-    for each (uint i in _uint::range(0u, num_ty_param)) {\n+    for each (uint i in uint::range(0u, num_ty_param)) {\n         auto llarg = llvm::LLVMGetParam(fcx.llfn, arg_n);\n         fcx.lltydescs += [llarg];\n         assert (llarg as int != 0);\n@@ -7232,13 +7232,13 @@ fn new_walk_ctxt() -> @walk_ctxt {\n fn enter_item(@walk_ctxt cx, &@ast::item item) {\n     alt (item.node) {\n         case (ast::item_fn(?name, _, _, _, _)) {\n-            _vec::push[str](cx.path, name);\n+            vec::push[str](cx.path, name);\n         }\n         case (ast::item_obj(?name, _, _, _, _)) {\n-            _vec::push[str](cx.path, name);\n+            vec::push[str](cx.path, name);\n         }\n         case (ast::item_mod(?name, _, _)) {\n-            _vec::push[str](cx.path, name);\n+            vec::push[str](cx.path, name);\n         }\n         case (_) { }\n     }\n@@ -7247,13 +7247,13 @@ fn enter_item(@walk_ctxt cx, &@ast::item item) {\n fn leave_item(@walk_ctxt cx, &@ast::item item) {\n     alt (item.node) {\n         case (ast::item_fn(_, _, _, _, _)) {\n-            _vec::pop[str](cx.path);\n+            vec::pop[str](cx.path);\n         }\n         case (ast::item_obj(_, _, _, _, _)) {\n-            _vec::pop[str](cx.path);\n+            vec::pop[str](cx.path);\n         }\n         case (ast::item_mod(_, _, _)) {\n-            _vec::pop[str](cx.path);\n+            vec::pop[str](cx.path);\n         }\n         case (_) { }\n     }\n@@ -7281,7 +7281,7 @@ fn collect_item_1(&@crate_ctxt ccx, @walk_ctxt wcx, &@ast::item i) {\n         case (ast::item_const(?name, _, _, ?cid, ?ann)) {\n             auto typ = node_ann_type(ccx, ann);\n             auto g = llvm::LLVMAddGlobal(ccx.llmod, type_of(ccx, typ),\n-                                        _str::buf(ccx.names.next(name)));\n+                                        str::buf(ccx.names.next(name)));\n             llvm::LLVMSetLinkage(g, lib::llvm::LLVMInternalLinkage\n                                 as llvm::Linkage);\n             ccx.items.insert(cid, i);\n@@ -7345,7 +7345,7 @@ fn collect_tag_ctor(&@crate_ctxt ccx, @walk_ctxt wcx, &@ast::item i) {\n     alt (i.node) {\n         case (ast::item_tag(_, ?variants, ?tps, _, _)) {\n             for (ast::variant variant in variants) {\n-                if (_vec::len[ast::variant_arg](variant.node.args) != 0u) {\n+                if (vec::len[ast::variant_arg](variant.node.args) != 0u) {\n                     decl_fn_and_pair(ccx, wcx.path + [variant.node.name],\n                                      \"tag\", tps, variant.node.ann,\n                                      variant.node.id);\n@@ -7373,7 +7373,7 @@ fn trans_constant(&@crate_ctxt ccx, @walk_ctxt wcx, &@ast::item it) {\n     alt (it.node) {\n         case (ast::item_tag(?ident, ?variants, _, ?tag_id, _)) {\n             auto i = 0u;\n-            auto n_variants = _vec::len[ast::variant](variants);\n+            auto n_variants = vec::len[ast::variant](variants);\n             while (i < n_variants) {\n                 auto variant = variants.(i);\n \n@@ -7383,7 +7383,7 @@ fn trans_constant(&@crate_ctxt ccx, @walk_ctxt wcx, &@ast::item it) {\n                                             #fmt(\"_rust_tag_discrim_%s_%u\",\n                                                  ident, i));\n                 auto discrim_gvar = llvm::LLVMAddGlobal(ccx.llmod, T_int(),\n-                                                       _str::buf(s));\n+                                                       str::buf(s));\n \n                 llvm::LLVMSetInitializer(discrim_gvar, discrim_val);\n                 llvm::LLVMSetGlobalConstant(discrim_gvar, True);\n@@ -7443,7 +7443,7 @@ fn trans_exit_task_glue(@glue_fns glues,\n \n     auto llfn = glues.exit_task_glue;\n \n-    auto entrybb = llvm::LLVMAppendBasicBlock(llfn, _str::buf(\"entry\"));\n+    auto entrybb = llvm::LLVMAppendBasicBlock(llfn, str::buf(\"entry\"));\n     auto build = new_builder(entrybb);\n \n     let ValueRef arg1 = llvm::LLVMGetParam(llfn, 0u);\n@@ -7465,9 +7465,9 @@ fn trans_exit_task_glue(@glue_fns glues,\n }\n \n fn create_typedefs(&@crate_ctxt cx) {\n-    llvm::LLVMAddTypeName(cx.llmod, _str::buf(\"crate\"), T_crate(cx.tn));\n-    llvm::LLVMAddTypeName(cx.llmod, _str::buf(\"task\"), T_task(cx.tn));\n-    llvm::LLVMAddTypeName(cx.llmod, _str::buf(\"tydesc\"), T_tydesc(cx.tn));\n+    llvm::LLVMAddTypeName(cx.llmod, str::buf(\"crate\"), T_crate(cx.tn));\n+    llvm::LLVMAddTypeName(cx.llmod, str::buf(\"task\"), T_task(cx.tn));\n+    llvm::LLVMAddTypeName(cx.llmod, str::buf(\"tydesc\"), T_tydesc(cx.tn));\n }\n \n fn create_crate_constant(ValueRef crate_ptr, @glue_fns glues) {\n@@ -7509,7 +7509,7 @@ fn find_main_fn(&@crate_ctxt cx) -> ValueRef {\n     let ValueRef v = C_nil();\n     let uint n = 0u;\n     for each (@tup(ast::def_id, str) i in cx.item_symbols.items()) {\n-        if (_str::ends_with(i._1, e)) {\n+        if (str::ends_with(i._1, e)) {\n             n += 1u;\n             v = cx.item_ids.get(i._0);\n         }\n@@ -7533,7 +7533,7 @@ fn trans_main_fn(@local_ctxt cx, ValueRef llcrate, ValueRef crate_map) {\n     auto T_rust_start_args = [T_int(), T_int(), T_int(), T_int(), T_int()];\n \n     auto main_name;\n-    if (_str::eq(std::os::target_os(), \"win32\")) {\n+    if (str::eq(std::os::target_os(), \"win32\")) {\n         main_name = \"WinMain@16\";\n     } else {\n         main_name = \"main\";\n@@ -7558,7 +7558,7 @@ fn trans_main_fn(@local_ctxt cx, ValueRef llcrate, ValueRef crate_map) {\n     //\n \n     let BasicBlockRef llbb =\n-        llvm::LLVMAppendBasicBlock(llmain, _str::buf(\"\"));\n+        llvm::LLVMAppendBasicBlock(llmain, str::buf(\"\"));\n     auto b = new_builder(llbb);\n \n     auto start_args = [p2i(llrust_main), p2i(llcrate), llargc, llargv,\n@@ -7629,7 +7629,7 @@ fn decl_no_op_type_glue(ModuleRef llmod, type_names tn) -> ValueRef {\n }\n \n fn make_no_op_type_glue(ValueRef fun) {\n-    auto bb_name = _str::buf(\"_rust_no_op_type_glue_bb\");\n+    auto bb_name = str::buf(\"_rust_no_op_type_glue_bb\");\n     auto llbb = llvm::LLVMAppendBasicBlock(fun, bb_name);\n     new_builder(llbb).RetVoid();\n }\n@@ -7733,7 +7733,7 @@ fn trans_vec_append_glue(@local_ctxt cx) {\n                     llobjfields=new_def_hash[ValueRef](),\n                     lllocals=new_def_hash[ValueRef](),\n                     llupvars=new_def_hash[ValueRef](),\n-                    mutable lltydescs=_vec::empty[ValueRef](),\n+                    mutable lltydescs=vec::empty[ValueRef](),\n                     derived_tydescs=derived_tydescs,\n                     lcx=cx);\n \n@@ -7857,13 +7857,13 @@ fn make_glues(ModuleRef llmod, &type_names tn) -> @glue_fns {\n                                                  T_void())),\n \n              native_glues_rust =\n-                 _vec::init_fn[ValueRef](bind decl_native_glue(llmod, tn,\n+                 vec::init_fn[ValueRef](bind decl_native_glue(llmod, tn,\n                     abi::ngt_rust, _), abi::n_native_glues + 1 as uint),\n              native_glues_pure_rust =\n-                 _vec::init_fn[ValueRef](bind decl_native_glue(llmod, tn,\n+                 vec::init_fn[ValueRef](bind decl_native_glue(llmod, tn,\n                     abi::ngt_pure_rust, _), abi::n_native_glues + 1 as uint),\n              native_glues_cdecl =\n-                 _vec::init_fn[ValueRef](bind decl_native_glue(llmod, tn,\n+                 vec::init_fn[ValueRef](bind decl_native_glue(llmod, tn,\n                     abi::ngt_cdecl, _), abi::n_native_glues + 1 as uint),\n              no_op_type_glue = decl_no_op_type_glue(llmod, tn),\n              vec_append_glue = make_vec_append_glue(llmod, tn));\n@@ -7873,19 +7873,19 @@ fn make_common_glue(&session::session sess, &str output) {\n     // FIXME: part of this is repetitive and is probably a good idea\n     // to autogen it.\n     auto llmod =\n-        llvm::LLVMModuleCreateWithNameInContext(_str::buf(\"rust_out\"),\n+        llvm::LLVMModuleCreateWithNameInContext(str::buf(\"rust_out\"),\n                                                llvm::LLVMGetGlobalContext());\n \n-    llvm::LLVMSetDataLayout(llmod, _str::buf(x86::get_data_layout()));\n-    llvm::LLVMSetTarget(llmod, _str::buf(x86::get_target_triple()));\n+    llvm::LLVMSetDataLayout(llmod, str::buf(x86::get_data_layout()));\n+    llvm::LLVMSetTarget(llmod, str::buf(x86::get_target_triple()));\n     auto td = mk_target_data(x86::get_data_layout());\n     auto tn = mk_type_names();\n     let ValueRef crate_ptr =\n-        llvm::LLVMAddGlobal(llmod, T_crate(tn), _str::buf(\"rust_crate\"));\n+        llvm::LLVMAddGlobal(llmod, T_crate(tn), str::buf(\"rust_crate\"));\n \n     auto intrinsics = declare_intrinsics(llmod);\n \n-    llvm::LLVMSetModuleInlineAsm(llmod, _str::buf(x86::get_module_asm()));\n+    llvm::LLVMSetModuleInlineAsm(llmod, str::buf(x86::get_module_asm()));\n \n     auto glues = make_glues(llmod, tn);\n     create_crate_constant(crate_ptr, glues);\n@@ -7900,23 +7900,23 @@ fn create_module_map(&@crate_ctxt ccx) -> ValueRef {\n     auto elttype = T_struct([T_int(), T_int()]);\n     auto maptype = T_array(elttype, ccx.module_data.size() + 1u);\n     auto map = llvm::LLVMAddGlobal(ccx.llmod, maptype,\n-                                  _str::buf(\"_rust_mod_map\"));\n+                                  str::buf(\"_rust_mod_map\"));\n     llvm::LLVMSetLinkage(map, lib::llvm::LLVMInternalLinkage\n                          as llvm::Linkage);\n     let vec[ValueRef] elts = [];\n     for each (@tup(str, ValueRef) item in ccx.module_data.items()) {\n         auto elt = C_struct([p2i(C_cstr(ccx, item._0)), p2i(item._1)]);\n-        _vec::push[ValueRef](elts, elt);\n+        vec::push[ValueRef](elts, elt);\n     }\n     auto term = C_struct([C_int(0), C_int(0)]);\n-    _vec::push[ValueRef](elts, term);\n+    vec::push[ValueRef](elts, term);\n     llvm::LLVMSetInitializer(map, C_array(elttype, elts));\n     ret map;\n }\n \n fn crate_name(&@crate_ctxt ccx, &str deflt) -> str {\n     for (@ast::meta_item item in ccx.sess.get_metadata()) {\n-        if (_str::eq(item.node.name, \"name\")) {\n+        if (str::eq(item.node.name, \"name\")) {\n             ret item.node.value;\n         }\n     }\n@@ -7930,15 +7930,15 @@ fn create_crate_map(&@crate_ctxt ccx) -> ValueRef {\n     while (ccx.sess.has_external_crate(i)) {\n         auto name = ccx.sess.get_external_crate(i).name;\n         auto cr = llvm::LLVMAddGlobal(ccx.llmod, T_int(),\n-                                     _str::buf(\"_rust_crate_map_\" + name));\n-        _vec::push[ValueRef](subcrates, p2i(cr));\n+                                     str::buf(\"_rust_crate_map_\" + name));\n+        vec::push[ValueRef](subcrates, p2i(cr));\n         i += 1;\n     }\n-    _vec::push[ValueRef](subcrates, C_int(0));\n+    vec::push[ValueRef](subcrates, C_int(0));\n     auto sym_name = \"_rust_crate_map_\" + crate_name(ccx, \"__none__\");\n-    auto arrtype = T_array(T_int(), _vec::len[ValueRef](subcrates));\n+    auto arrtype = T_array(T_int(), vec::len[ValueRef](subcrates));\n     auto maptype = T_struct([T_int(), arrtype]);\n-    auto map = llvm::LLVMAddGlobal(ccx.llmod, maptype, _str::buf(sym_name));\n+    auto map = llvm::LLVMAddGlobal(ccx.llmod, maptype, str::buf(sym_name));\n     llvm::LLVMSetLinkage(map, lib::llvm::LLVMExternalLinkage\n                          as llvm::Linkage);\n     llvm::LLVMSetInitializer(map, C_struct([p2i(create_module_map(ccx)),\n@@ -7951,15 +7951,15 @@ fn trans_crate(&session::session sess, &@ast::crate crate, &ty::ctxt tcx,\n                &str output)\n         -> ModuleRef {\n     auto llmod =\n-        llvm::LLVMModuleCreateWithNameInContext(_str::buf(\"rust_out\"),\n+        llvm::LLVMModuleCreateWithNameInContext(str::buf(\"rust_out\"),\n                                                llvm::LLVMGetGlobalContext());\n \n-    llvm::LLVMSetDataLayout(llmod, _str::buf(x86::get_data_layout()));\n-    llvm::LLVMSetTarget(llmod, _str::buf(x86::get_target_triple()));\n+    llvm::LLVMSetDataLayout(llmod, str::buf(x86::get_data_layout()));\n+    llvm::LLVMSetTarget(llmod, str::buf(x86::get_target_triple()));\n     auto td = mk_target_data(x86::get_data_layout());\n     auto tn = mk_type_names();\n     let ValueRef crate_ptr =\n-        llvm::LLVMAddGlobal(llmod, T_crate(tn), _str::buf(\"rust_crate\"));\n+        llvm::LLVMAddGlobal(llmod, T_crate(tn), str::buf(\"rust_crate\"));\n \n     auto intrinsics = declare_intrinsics(llmod);\n "}, {"sha": "3e8c8e34a58c5ba8dac681e52353e2a0d05e2c9d", "filename": "src/comp/middle/tstate/ann.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,5 +1,5 @@\n import front::ast::ident;\n-import std::_vec;\n+import std::vec;\n import std::bitv;\n \n /* "}, {"sha": "92e6accdbec33fd216c3a1bdfe71d06d26f66c06", "filename": "src/comp/middle/tstate/annotate.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,4 +1,4 @@\n-import std::_vec;\n+import std::vec;\n import std::option;\n import std::option::some;\n import std::option::none;\n@@ -131,15 +131,15 @@ fn annotate_exprs(&fn_info_map fm, &vec[@expr] es) -> vec[@expr] {\n         ret annotate_expr(fm, e);\n     }\n     auto f = bind one(fm,_);\n-    ret _vec::map[@expr, @expr](f, es);\n+    ret vec::map[@expr, @expr](f, es);\n }\n fn annotate_elts(&fn_info_map fm, &vec[elt] es) -> vec[elt] {\n     fn one(fn_info_map fm, &elt e) -> elt {\n         ret rec(mut=e.mut,\n                 expr=annotate_expr(fm, e.expr));\n     }\n     auto f = bind one(fm,_);\n-    ret _vec::map[elt, elt](f, es);\n+    ret vec::map[elt, elt](f, es);\n }\n fn annotate_fields(&fn_info_map fm, &vec[field] fs) -> vec[field] {\n     fn one(fn_info_map fm, &field f) -> field {\n@@ -148,7 +148,7 @@ fn annotate_fields(&fn_info_map fm, &vec[field] fs) -> vec[field] {\n                  expr=annotate_expr(fm, f.expr));\n     }\n     auto f = bind one(fm,_);\n-    ret _vec::map[field, field](f, fs);\n+    ret vec::map[field, field](f, fs);\n }\n fn annotate_option_exp(&fn_info_map fm, &option::t[@expr] o)\n   -> option::t[@expr] {\n@@ -164,7 +164,7 @@ fn annotate_option_exprs(&fn_info_map fm, &vec[option::t[@expr]] es)\n         ret annotate_option_exp(fm, o);\n     }\n     auto f = bind one(fm,_);\n-    ret _vec::map[option::t[@expr], option::t[@expr]](f, es);\n+    ret vec::map[option::t[@expr], option::t[@expr]](f, es);\n }\n fn annotate_decl(&fn_info_map fm, &@decl d) -> @decl {\n     auto d1 = d.node;\n@@ -194,7 +194,7 @@ fn annotate_alts(&fn_info_map fm, &vec[arm] alts) -> vec[arm] {\n                  block=annotate_block(fm, a.block));\n     }\n     auto f = bind one(fm,_);\n-    ret _vec::map[arm, arm](f, alts);\n+    ret vec::map[arm, arm](f, alts);\n \n }\n fn annotate_expr(&fn_info_map fm, &@expr e) -> @expr {\n@@ -345,7 +345,7 @@ fn annotate_block(&fn_info_map fm, &block b) -> block {\n    \n     for (@stmt s in b.node.stmts) {\n         auto new_s = annotate_stmt(fm, s);\n-        _vec::push[@stmt](new_stmts, new_s);\n+        vec::push[@stmt](new_stmts, new_s);\n     }\n     fn ann_e(fn_info_map fm, &@expr e) -> @expr {\n         ret annotate_expr(fm, e);\n@@ -367,7 +367,7 @@ fn annotate_mod(&fn_info_map fm, &_mod m) -> _mod {\n    \n     for (@item i in m.items) {\n         auto new_i = annotate_item(fm, i);\n-        _vec::push[@item](new_items, new_i);\n+        vec::push[@item](new_items, new_i);\n     }\n     ret rec(items=new_items with m);\n }\n@@ -387,7 +387,7 @@ fn annotate_obj(&fn_info_map fm, &_obj o) -> _obj {\n         ret annotate_method(fm, m);\n     }\n     auto f = bind one(fm,_);\n-    auto new_methods = _vec::map[@method, @method](f, o.methods);\n+    auto new_methods = vec::map[@method, @method](f, o.methods);\n     auto new_dtor    = option::map[@method, @method](f, o.dtor);\n     ret rec(methods=new_methods, dtor=new_dtor with o);\n }\n@@ -479,7 +479,7 @@ fn annotate_module(&fn_info_map fm, &_mod module) -> _mod {\n    \n     for (@item i in module.items) {\n         auto new_item = annotate_item(fm, i);\n-        _vec::push[@item](new_items, new_item);\n+        vec::push[@item](new_items, new_item);\n     }\n \n     ret rec(items = new_items with module);"}, {"sha": "664327fee9d1b689408d5e10ff4c9499753e9dce", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,6 +1,6 @@\n import std::bitv;\n-import std::_vec::len;\n-import std::_vec::pop;\n+import std::vec::len;\n+import std::vec::pop;\n import std::option;\n import std::option::none;\n import std::option::some;"}, {"sha": "a0b9e5a3ece45510701708fa60b7717267a4a266", "filename": "src/comp/middle/tstate/bitvectors.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,7 +1,7 @@\n import std::bitv;\n-import std::_vec;\n-import std::_vec::len;\n-import std::_vec::slice;\n+import std::vec;\n+import std::vec::len;\n+import std::vec::slice;\n \n import front::ast;\n import front::ast::def_id;\n@@ -74,7 +74,7 @@ fn seq_preconds(fn_info enclosing, vec[pre_and_post] pps) -> precond {\n /* works on either postconds or preconds\n  should probably rethink the whole type synonym situation */\n fn union_postconds_go(&postcond first, &vec[postcond] rest) -> postcond {\n-  auto sz = _vec::len[postcond](rest);\n+  auto sz = vec::len[postcond](rest);\n \n   if (sz > 0u) {\n     auto other = rest.(0);\n@@ -96,7 +96,7 @@ fn union_postconds(uint nv, &vec[postcond] pcs) -> postcond {\n \n /* Gee, maybe we could use foldl or something */\n fn intersect_postconds_go(&postcond first, &vec[postcond] rest) -> postcond {\n-  auto sz = _vec::len[postcond](rest);\n+  auto sz = vec::len[postcond](rest);\n \n   if (sz > 0u) {\n     auto other = rest.(0);"}, {"sha": "af2455c9a6e519bec91dd87517315761d03bc67c", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -31,12 +31,12 @@ import tstate::ann::prestate;\n import tstate::ann::implies;\n import tstate::ann::ann_precond;\n import tstate::ann::ann_prestate;\n-import std::_vec::map;\n-import std::_vec;\n-import std::_vec::slice;\n-import std::_vec::unzip;\n-import std::_vec::plus_option;\n-import std::_vec::cat_options;\n+import std::vec::map;\n+import std::vec;\n+import std::vec::slice;\n+import std::vec::unzip;\n+import std::vec::plus_option;\n+import std::vec::cat_options;\n \n import std::option;\n import std::option::t;\n@@ -123,7 +123,7 @@ fn check_states_against_conditions(&fn_ctxt fcx, &_fn f, &ann a) -> () {\n \n     auto do_one = bind do_one_(fcx, _, post, nv);\n  \n-  _vec::map[@stmt, ()](do_one, f.body.node.stmts);\n+  vec::map[@stmt, ()](do_one, f.body.node.stmts);\n   fn do_inner_(fn_ctxt fcx, &@expr e, @poststate post) -> () {\n     check_states_expr(fcx, e);\n     *post = expr_poststate(e);\n@@ -187,7 +187,7 @@ fn check_obj_state(&crate_ctxt ccx, &vec[obj_field] fields,\n         ret check_method_states(ccx, m);\n     }\n     auto f = bind one(ccx,_);\n-    _vec::map[@method, ()](f, methods);\n+    vec::map[@method, ()](f, methods);\n     option::map[@method, ()](f, dtor);\n     ret rec(fields=fields, methods=methods, dtor=dtor);\n }"}, {"sha": "8ec5656cfe63645d60462e7d72486536564af13e", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,5 +1,5 @@\n-import std::_vec;\n-import std::_vec::plus_option;\n+import std::vec;\n+import std::vec::plus_option;\n \n import front::ast;\n import front::ast::crate;\n@@ -39,12 +39,12 @@ fn var_is_local(def_id v, fn_info m) -> bool {\n fn collect_local(&@vec[tup(ident, def_id)] vars, &span sp, &@local loc)\n     -> @decl {\n     log(\"collect_local: pushing \" + loc.ident);\n-    _vec::push[tup(ident, def_id)](*vars, tup(loc.ident, loc.id));\n+    vec::push[tup(ident, def_id)](*vars, tup(loc.ident, loc.id));\n     ret @respan(sp, decl_local(loc));\n }\n \n fn find_locals(_fn f) -> @vec[tup(ident,def_id)] {\n-  auto res = @_vec::alloc[tup(ident,def_id)](0u);\n+  auto res = @vec::alloc[tup(ident,def_id)](0u);\n \n   auto fld = new_identity_fold[@vec[tup(ident, def_id)]]();\n   fld = @rec(fold_decl_local = bind collect_local(_,_,_) with *fld);\n@@ -72,7 +72,7 @@ fn mk_fn_info(_fn f, def_id f_id, ident f_name) -> fn_info {\n        just collect locally declared vars */\n \n     let @vec[tup(ident,def_id)] locals = find_locals(f);\n-    // log (uistr(_vec::len[tup(ident, def_id)](locals)) + \" locals\");\n+    // log (uistr(vec::len[tup(ident, def_id)](locals)) + \" locals\");\n     for (tup(ident,def_id) p in *locals) {\n         next = add_var(p._1, p._0, next, res);\n     }\n@@ -98,7 +98,7 @@ fn mk_fn_info_item_fn(&crate_ctxt ccx, &span sp, &ident i, &_fn f,\n fn mk_fn_info_item_obj(&crate_ctxt ccx, &span sp, &ident i, &_obj o,\n                        &vec[ty_param] ty_params,\n                        &obj_def_ids odid, &ann a) -> @item {\n-    auto all_methods = _vec::clone[@method](o.methods);\n+    auto all_methods = vec::clone[@method](o.methods);\n     plus_option[@method](all_methods, o.dtor);\n     auto f_inf;\n     for (@method m in all_methods) {"}, {"sha": "c84c5e2d612e8d6c9d036a88898f90ab6cf11770", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,5 +1,5 @@\n-import std::_vec;\n-import std::_vec::plus_option;\n+import std::vec;\n+import std::vec::plus_option;\n import std::option;\n import std::option::none;\n import std::option::some;\n@@ -180,7 +180,7 @@ fn find_pre_post_obj(&crate_ctxt ccx, _obj o) -> () {\n         find_pre_post_fn(fcx, m.node.meth);\n     }\n     auto f = bind do_a_method(ccx,_);\n-    _vec::map[@method, ()](f, o.methods);\n+    vec::map[@method, ()](f, o.methods);\n     option::map[@method, ()](f, o.dtor);\n }\n \n@@ -233,19 +233,19 @@ fn find_pre_post_exprs(&fn_ctxt fcx, &vec[@expr] args, ann a) {\n     }\n     auto f = bind do_one(fcx, _);\n \n-    _vec::map[@expr, ()](f, args);\n+    vec::map[@expr, ()](f, args);\n \n     fn get_pp(&@expr e) -> pre_and_post {\n         ret expr_pp(e);\n     }\n     auto g = get_pp;\n-    auto pps = _vec::map[@expr, pre_and_post](g, args);\n+    auto pps = vec::map[@expr, pre_and_post](g, args);\n     auto h = get_post;\n \n     set_pre_and_post(a,\n        rec(precondition=seq_preconds(enclosing, pps),\n            postcondition=union_postconds\n-           (nv, (_vec::map[pre_and_post, postcond](h, pps)))));\n+           (nv, (vec::map[pre_and_post, postcond](h, pps)))));\n }\n \n fn find_pre_post_loop(&fn_ctxt fcx, &@decl d, &@expr index,\n@@ -292,13 +292,13 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n \n     alt (e.node) {\n         case (expr_call(?operator, ?operands, ?a)) {\n-            auto args = _vec::clone[@expr](operands);\n-            _vec::push[@expr](args, operator);\n+            auto args = vec::clone[@expr](operands);\n+            vec::push[@expr](args, operator);\n             find_pre_post_exprs(fcx, args, a);\n         }\n         case (expr_spawn(_, _, ?operator, ?operands, ?a)) {\n-            auto args = _vec::clone[@expr](operands);\n-            _vec::push[@expr](args, operator);\n+            auto args = vec::clone[@expr](operands);\n+            vec::push[@expr](args, operator);\n             find_pre_post_exprs(fcx, args, a);\n         }\n         case (expr_vec(?args, _, ?a)) {\n@@ -352,7 +352,7 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n         }\n         case (expr_rec(?fields,?maybe_base,?a)) {\n             auto es = field_exprs(fields);\n-            _vec::plus_option[@expr](es, maybe_base);\n+            vec::plus_option[@expr](es, maybe_base);\n             find_pre_post_exprs(fcx, es, a);\n         }\n         case (expr_assign(?lhs, ?rhs, ?a)) {\n@@ -505,7 +505,7 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n                 ret block_pp(an_alt.block);\n             }\n             auto f = bind do_an_alt(fcx, _);\n-            auto alt_pps = _vec::map[arm, pre_and_post](f, alts);\n+            auto alt_pps = vec::map[arm, pre_and_post](f, alts);\n             fn combine_pp(pre_and_post antec, \n                           fn_info enclosing, &pre_and_post pp,\n                           &pre_and_post next) -> pre_and_post {\n@@ -519,7 +519,7 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n                              postcondition=false_postcond(num_local_vars));\n             auto g = bind combine_pp(antec_pp, fcx.enclosing, _, _);\n \n-            auto alts_overall_pp = _vec::foldl[pre_and_post, pre_and_post]\n+            auto alts_overall_pp = vec::foldl[pre_and_post, pre_and_post]\n                                     (g, e_pp, alt_pps);\n \n             set_pre_and_post(a, alts_overall_pp);\n@@ -545,8 +545,8 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n             set_pre_and_post(a, expr_pp(p));\n         }\n         case(expr_bind(?operator, ?maybe_args, ?a)) {\n-            auto args = _vec::cat_options[@expr](maybe_args);\n-            _vec::push[@expr](args, operator); /* ??? order of eval? */\n+            auto args = vec::cat_options[@expr](maybe_args);\n+            vec::push[@expr](args, operator); /* ??? order of eval? */\n             find_pre_post_exprs(fcx, args, a);\n         }\n         case (expr_break(?a)) {\n@@ -643,7 +643,7 @@ fn find_pre_post_block(&fn_ctxt fcx, block b) -> () {\n     }\n     auto do_one = bind do_one_(fcx, _);\n     \n-    _vec::map[@stmt, ()](do_one, b.node.stmts);\n+    vec::map[@stmt, ()](do_one, b.node.stmts);\n     fn do_inner_(fn_ctxt fcx, &@expr e) -> () {\n         find_pre_post_expr(fcx, e);\n     }\n@@ -656,7 +656,7 @@ fn find_pre_post_block(&fn_ctxt fcx, block b) -> () {\n         ret stmt_pp(*s);\n     }\n     auto f = get_pp_stmt;\n-    pps += _vec::map[@stmt, pre_and_post](f, b.node.stmts);\n+    pps += vec::map[@stmt, pre_and_post](f, b.node.stmts);\n     fn get_pp_expr(&@expr e) -> pre_and_post {\n         ret expr_pp(e);\n     }\n@@ -666,10 +666,10 @@ fn find_pre_post_block(&fn_ctxt fcx, block b) -> () {\n \n     auto block_precond  = seq_preconds(fcx.enclosing, pps);\n     auto h = get_post;\n-    auto postconds =  _vec::map[pre_and_post, postcond](h, pps);\n+    auto postconds =  vec::map[pre_and_post, postcond](h, pps);\n     /* A block may be empty, so this next line ensures that the postconds\n        vector is non-empty. */\n-    _vec::push[postcond](postconds, block_precond);\n+    vec::push[postcond](postconds, block_precond);\n     auto block_postcond = empty_poststate(nv);\n     /* conservative approximation */\n     if (! has_nonlocal_exits(b)) {"}, {"sha": "294302cfab27569464ee1171632bf0ab13732ee4", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,7 +1,7 @@\n import std::bitv;\n-import std::_vec;\n-import std::_vec::plus_option;\n-import std::_vec::cat_options;\n+import std::vec;\n+import std::vec::plus_option;\n+import std::vec::cat_options;\n import std::option;\n import std::option::get;\n import std::option::is_none;\n@@ -538,7 +538,7 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n         changed = find_pre_post_state_expr(fcx, pres, e) || changed;\n         auto e_post = expr_poststate(e);\n         auto a_post;\n-        if (_vec::len[arm](alts) > 0u) {\n+        if (vec::len[arm](alts) > 0u) {\n             a_post = false_postcond(num_local_vars);\n             for (arm an_alt in alts) {\n                 changed = find_pre_post_state_block(fcx, e_post,\n@@ -766,8 +766,8 @@ fn find_pre_post_state_obj(crate_ctxt ccx, _obj o) -> bool {\n                                    m.node.meth);\n     }\n     auto f = bind do_a_method(ccx,_);\n-    auto flags = _vec::map[@method, bool](f, o.methods);\n-    auto changed = _vec::or(flags);\n+    auto flags = vec::map[@method, bool](f, o.methods);\n+    auto changed = vec::or(flags);\n     changed = changed || maybe[@method, bool](false, f, o.dtor);\n     ret changed;\n }"}, {"sha": "62ac2f6bd3ad454ce3eaaf97a1b74f8838f361ff", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 72, "deletions": 72, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,6 +1,6 @@\n-import std::_str;\n-import std::_uint;\n-import std::_vec;\n+import std::str;\n+import std::uint;\n+import std::vec;\n import std::box;\n import std::ufind;\n import std::map;\n@@ -194,7 +194,7 @@ fn mk_type_store() -> @type_store {\n     intern(ts, ty_type, none[str]);\n     intern(ts, ty_bot, none[str]);\n \n-    assert _vec::len(ts.vect) == idx_first_others;\n+    assert vec::len(ts.vect) == idx_first_others;\n \n     ret ts;\n }\n@@ -479,11 +479,11 @@ fn cname(&ctxt cx, &t typ) -> option::t[str] {\n // Stringification\n \n fn path_to_str(&ast::path pth) -> str {\n-    auto result = _str::connect(pth.node.idents,  \"::\");\n-    if (_vec::len[@ast::ty](pth.node.types) > 0u) {\n+    auto result = str::connect(pth.node.idents,  \"::\");\n+    if (vec::len[@ast::ty](pth.node.types) > 0u) {\n         auto f = pretty::pprust::ty_to_str;\n         result += \"[\";\n-        result += _str::connect(_vec::map(f, pth.node.types), \",\");\n+        result += str::connect(vec::map(f, pth.node.types), \",\");\n         result += \"]\";\n     }\n     ret result;\n@@ -527,7 +527,7 @@ fn ty_to_str(ctxt cx, &t typ) -> str {\n             }\n \n             s += \"(\";\n-            s += _str::connect(_vec::map[arg,str](f, inputs), \", \");\n+            s += str::connect(vec::map[arg,str](f, inputs), \", \");\n             s += \")\";\n \n             if (struct(cx, output) != ty_nil) {\n@@ -585,24 +585,24 @@ fn ty_to_str(ctxt cx, &t typ) -> str {\n \n         case (ty_tup(?elems)) {\n             auto f = bind mt_to_str(cx, _);\n-            auto strs = _vec::map[mt,str](f, elems);\n-            s += \"tup(\" + _str::connect(strs, \",\") + \")\";\n+            auto strs = vec::map[mt,str](f, elems);\n+            s += \"tup(\" + str::connect(strs, \",\") + \")\";\n         }\n \n         case (ty_rec(?elems)) {\n             auto f = bind field_to_str(cx, _);\n-            auto strs = _vec::map[field,str](f, elems);\n-            s += \"rec(\" + _str::connect(strs, \",\") + \")\";\n+            auto strs = vec::map[field,str](f, elems);\n+            s += \"rec(\" + str::connect(strs, \",\") + \")\";\n         }\n \n         case (ty_tag(?id, ?tps)) {\n             // The user should never see this if the cname is set properly!\n             s += \"<tag#\" + util::common::istr(id._0) + \":\" +\n                 util::common::istr(id._1) + \">\";\n-            if (_vec::len[t](tps) > 0u) {\n+            if (vec::len[t](tps) > 0u) {\n                 auto f = bind ty_to_str(cx, _);\n-                auto strs = _vec::map[t,str](f, tps);\n-                s += \"[\" + _str::connect(strs, \",\") + \"]\";\n+                auto strs = vec::map[t,str](f, tps);\n+                s += \"[\" + str::connect(strs, \",\") + \"]\";\n             }\n         }\n \n@@ -617,8 +617,8 @@ fn ty_to_str(ctxt cx, &t typ) -> str {\n \n         case (ty_obj(?meths)) {\n             auto f = bind method_to_str(cx, _);\n-            auto m = _vec::map[method,str](f, meths);\n-            s += \"obj {\\n\\t\" + _str::connect(m, \"\\n\\t\") + \"\\n}\";\n+            auto m = vec::map[method,str](f, meths);\n+            s += \"obj {\\n\\t\" + str::connect(m, \"\\n\\t\") + \"\\n}\";\n         }\n \n         case (ty_var(?v)) {\n@@ -631,11 +631,11 @@ fn ty_to_str(ctxt cx, &t typ) -> str {\n         }\n \n         case (ty_param(?id)) {\n-            s += \"'\" + _str::unsafe_from_bytes([('a' as u8) + (id as u8)]);\n+            s += \"'\" + str::unsafe_from_bytes([('a' as u8) + (id as u8)]);\n         }\n \n         case (ty_bound_param(?id)) {\n-            s += \"''\" + _str::unsafe_from_bytes([('a' as u8) +\n+            s += \"''\" + str::unsafe_from_bytes([('a' as u8) +\n                                                     (id as u8)]);\n         }\n \n@@ -652,7 +652,7 @@ fn ty_to_short_str(ctxt cx, t typ) -> str {\n     auto f = def_to_str;\n     auto ecx = @rec(ds=f, tcx=cx, abbrevs=metadata::ac_no_abbrevs);\n     auto s = metadata::Encode::ty_str(ecx, typ);\n-    if (_str::byte_len(s) >= 32u) { s = _str::substr(s, 0u, 32u); }\n+    if (str::byte_len(s) >= 32u) { s = str::substr(s, 0u, 32u); }\n     ret s;\n }\n \n@@ -955,14 +955,14 @@ fn type_has_dynamic_size(&ctxt cx, &t ty) -> bool {\n     alt (struct(cx, ty)) {\n         case (ty_tup(?mts)) {\n             auto i = 0u;\n-            while (i < _vec::len[mt](mts)) {\n+            while (i < vec::len[mt](mts)) {\n                 if (type_has_dynamic_size(cx, mts.(i).ty)) { ret true; }\n                 i += 1u;\n             }\n         }\n         case (ty_rec(?fields)) {\n             auto i = 0u;\n-            while (i < _vec::len[field](fields)) {\n+            while (i < vec::len[field](fields)) {\n                 if (type_has_dynamic_size(cx, fields.(i).mt.ty)) {\n                     ret true;\n                 }\n@@ -971,7 +971,7 @@ fn type_has_dynamic_size(&ctxt cx, &t ty) -> bool {\n         }\n         case (ty_tag(_, ?subtys)) {\n             auto i = 0u;\n-            while (i < _vec::len[t](subtys)) {\n+            while (i < vec::len[t](subtys)) {\n                 if (type_has_dynamic_size(cx, subtys.(i))) { ret true; }\n                 i += 1u;\n             }\n@@ -1139,7 +1139,7 @@ fn hash_type_structure(&sty st) -> uint {\n         case (ty_obj(?methods)) {\n             auto h = 27u;\n             for (method m in methods) {\n-                h += h << 5u + _str::hash(m.ident);\n+                h += h << 5u + str::hash(m.ident);\n             }\n             ret h;\n         }\n@@ -1157,7 +1157,7 @@ fn hash_type_info(&sty st, &option::t[str] cname_opt) -> uint {\n     auto h = hash_type_structure(st);\n     alt (cname_opt) {\n         case (none[str]) { /* no-op */ }\n-        case (some[str](?s)) { h += h << 5u + _str::hash(s); }\n+        case (some[str](?s)) { h += h << 5u + str::hash(s); }\n     }\n     ret h;\n }\n@@ -1178,8 +1178,8 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n                 &vec[arg] args_b, &t rty_b) -> bool {\n         if (!eq_ty(rty_a, rty_b)) { ret false; }\n \n-        auto len = _vec::len[arg](args_a);\n-        if (len != _vec::len[arg](args_b)) { ret false; }\n+        auto len = vec::len[arg](args_a);\n+        if (len != vec::len[arg](args_b)) { ret false; }\n \n         auto i = 0u;\n         while (i < len) {\n@@ -1257,8 +1257,8 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n                 case (ty_tag(?id_b, ?tys_b)) {\n                     if (!equal_def(id_a, id_b)) { ret false; }\n \n-                    auto len = _vec::len[t](tys_a);\n-                    if (len != _vec::len[t](tys_b)) { ret false; }\n+                    auto len = vec::len[t](tys_a);\n+                    if (len != vec::len[t](tys_b)) { ret false; }\n                     auto i = 0u;\n                     while (i < len) {\n                         if (!eq_ty(tys_a.(i), tys_b.(i))) { ret false; }\n@@ -1302,8 +1302,8 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n         case (ty_tup(?mts_a)) {\n             alt (b) {\n                 case (ty_tup(?mts_b)) {\n-                    auto len = _vec::len[mt](mts_a);\n-                    if (len != _vec::len[mt](mts_b)) { ret false; }\n+                    auto len = vec::len[mt](mts_a);\n+                    if (len != vec::len[mt](mts_b)) { ret false; }\n                     auto i = 0u;\n                     while (i < len) {\n                         if (!equal_mt(mts_a.(i), mts_b.(i))) { ret false; }\n@@ -1317,12 +1317,12 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n         case (ty_rec(?flds_a)) {\n             alt (b) {\n                 case (ty_rec(?flds_b)) {\n-                    auto len = _vec::len[field](flds_a);\n-                    if (len != _vec::len[field](flds_b)) { ret false; }\n+                    auto len = vec::len[field](flds_a);\n+                    if (len != vec::len[field](flds_b)) { ret false; }\n                     auto i = 0u;\n                     while (i < len) {\n                         auto fld_a = flds_a.(i); auto fld_b = flds_b.(i);\n-                        if (!_str::eq(fld_a.ident, fld_b.ident) ||\n+                        if (!str::eq(fld_a.ident, fld_b.ident) ||\n                                 !equal_mt(fld_a.mt, fld_b.mt)) {\n                             ret false;\n                         }\n@@ -1354,13 +1354,13 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n         case (ty_obj(?methods_a)) {\n             alt (b) {\n                 case (ty_obj(?methods_b)) {\n-                    auto len = _vec::len[method](methods_a);\n-                    if (len != _vec::len[method](methods_b)) { ret false; }\n+                    auto len = vec::len[method](methods_a);\n+                    if (len != vec::len[method](methods_b)) { ret false; }\n                     auto i = 0u;\n                     while (i < len) {\n                         auto m_a = methods_a.(i); auto m_b = methods_b.(i);\n                         if (m_a.proto != m_b.proto ||\n-                                !_str::eq(m_a.ident, m_b.ident) ||\n+                                !str::eq(m_a.ident, m_b.ident) ||\n                                 !equal_fn(m_a.inputs, m_a.output,\n                                           m_b.inputs, m_b.output)) {\n                             ret false;\n@@ -1432,7 +1432,7 @@ fn eq_raw_ty(&raw_t a, &raw_t b) -> bool {\n         case (some[str](?s_a)) {\n             alt (b.cname) {\n                 case (some[str](?s_b)) {\n-                    if (!_str::eq(s_a, s_b)) { ret false; }\n+                    if (!str::eq(s_a, s_b)) { ret false; }\n                 }\n                 case (_) { ret false; }\n             }\n@@ -1534,7 +1534,7 @@ fn count_ty_params(ctxt cx, t ty) -> uint {\n     let @mutable vec[uint] param_indices = @mutable v;\n     auto f = bind counter(cx, param_indices, _);\n     walk_ty(cx, f, ty);\n-    ret _vec::len[uint](*param_indices);\n+    ret vec::len[uint](*param_indices);\n }\n \n fn type_contains_vars(&ctxt cx, &t typ) -> bool {\n@@ -1605,7 +1605,7 @@ fn native_item_ty(&node_type_table ntt, &@ast::native_item it)\n     auto result_ty;\n     alt (it.node) {\n         case (ast::native_item_fn(_, _, _, ?tps, _, ?ann)) {\n-            ty_param_count = _vec::len[ast::ty_param](tps);\n+            ty_param_count = vec::len[ast::ty_param](tps);\n             result_ty = ann_to_type(ntt, ann);\n         }\n     }\n@@ -1621,22 +1621,22 @@ fn item_ty(&node_type_table ntt, &@ast::item it) -> ty_param_count_and_ty {\n             result_ty = ann_to_type(ntt, ann);\n         }\n         case (ast::item_fn(_, _, ?tps, _, ?ann)) {\n-            ty_param_count = _vec::len[ast::ty_param](tps);\n+            ty_param_count = vec::len[ast::ty_param](tps);\n             result_ty = ann_to_type(ntt, ann);\n         }\n         case (ast::item_mod(_, _, _)) {\n             fail;   // modules are typeless\n         }\n         case (ast::item_ty(_, _, ?tps, _, ?ann)) {\n-            ty_param_count = _vec::len[ast::ty_param](tps);\n+            ty_param_count = vec::len[ast::ty_param](tps);\n             result_ty = ann_to_type(ntt, ann);\n         }\n         case (ast::item_tag(_, _, ?tps, ?did, ?ann)) {\n-            ty_param_count = _vec::len[ast::ty_param](tps);\n+            ty_param_count = vec::len[ast::ty_param](tps);\n             result_ty = ann_to_type(ntt, ann);\n         }\n         case (ast::item_obj(_, _, ?tps, _, ?ann)) {\n-            ty_param_count = _vec::len[ast::ty_param](tps);\n+            ty_param_count = vec::len[ast::ty_param](tps);\n             result_ty = ann_to_type(ntt, ann);\n         }\n     }\n@@ -1781,7 +1781,7 @@ fn field_num(&session::session sess, &span sp,\n                 accum += (c as uint) - ('0' as uint);\n             } else {\n                 auto s = \"\";\n-                s += _str::unsafe_from_byte(c);\n+                s += str::unsafe_from_byte(c);\n                 sess.span_err(sp,\n                               \"bad numeric field on tuple: \"\n                               + \" non-digit character: \"\n@@ -1797,7 +1797,7 @@ fn field_idx(&session::session sess, &span sp,\n              &ast::ident id, &vec[field] fields) -> uint {\n     let uint i = 0u;\n     for (field f in fields) {\n-        if (_str::eq(f.ident, id)) {\n+        if (str::eq(f.ident, id)) {\n             ret i;\n         }\n         i += 1u;\n@@ -1810,7 +1810,7 @@ fn method_idx(&session::session sess, &span sp,\n               &ast::ident id, &vec[method] meths) -> uint {\n     let uint i = 0u;\n     for (method m in meths) {\n-        if (_str::eq(m.ident, id)) {\n+        if (str::eq(m.ident, id)) {\n             ret i;\n         }\n         i += 1u;\n@@ -1821,7 +1821,7 @@ fn method_idx(&session::session sess, &span sp,\n \n fn sort_methods(&vec[method] meths) -> vec[method] {\n     fn method_lteq(&method a, &method b) -> bool {\n-        ret _str::lteq(a.ident, b.ident);\n+        ret str::lteq(a.ident, b.ident);\n     }\n \n     ret std::sort::merge_sort[method](bind method_lteq(_,_), meths);\n@@ -1896,8 +1896,8 @@ mod unify {\n                        &vec[arg] expected_inputs, &t expected_output,\n                        &vec[arg] actual_inputs, &t actual_output)\n         -> fn_common_res {\n-        auto expected_len = _vec::len[arg](expected_inputs);\n-        auto actual_len = _vec::len[arg](actual_inputs);\n+        auto expected_len = vec::len[arg](expected_inputs);\n+        auto actual_len = vec::len[arg](actual_inputs);\n         if (expected_len != actual_len) {\n             ret fn_common_res_err(ures_err(terr_arg_count,\n                                            expected, actual));\n@@ -2012,8 +2012,8 @@ mod unify {\n                  &vec[method] actual_meths) -> result {\n       let vec[method] result_meths = [];\n       let uint i = 0u;\n-      let uint expected_len = _vec::len[method](expected_meths);\n-      let uint actual_len = _vec::len[method](actual_meths);\n+      let uint expected_len = vec::len[method](expected_meths);\n+      let uint actual_len = vec::len[method](actual_meths);\n \n       if (expected_len != actual_len) {\n         ret ures_err(terr_meth_count, expected, actual);\n@@ -2022,7 +2022,7 @@ mod unify {\n       while (i < expected_len) {\n         auto e_meth = expected_meths.(i);\n         auto a_meth = actual_meths.(i);\n-        if (! _str::eq(e_meth.ident, a_meth.ident)) {\n+        if (! str::eq(e_meth.ident, a_meth.ident)) {\n           ret ures_err(terr_obj_meths(e_meth.ident, a_meth.ident),\n                        expected, actual);\n         }\n@@ -2086,7 +2086,7 @@ mod unify {\n \n                     case (_) {\n                         // Just bind the type variable to the expected type.\n-                        auto vlen = _vec::len[vec[t]](cx.types);\n+                        auto vlen = vec::len[vec[t]](cx.types);\n                         if (actual_n < vlen) {\n                             cx.types.(actual_n) += [expected];\n                         } else {\n@@ -2154,7 +2154,7 @@ mod unify {\n                         // ty::ty_tup case\n                         let vec[t] result_tps = [];\n                         auto i = 0u;\n-                        auto expected_len = _vec::len[t](expected_tps);\n+                        auto expected_len = vec::len[t](expected_tps);\n                         while (i < expected_len) {\n                             auto expected_tp = expected_tps.(i);\n                             auto actual_tp = actual_tps.(i);\n@@ -2165,7 +2165,7 @@ mod unify {\n \n                             alt (result) {\n                                 case (ures_ok(?rty)) {\n-                                    _vec::push[t](result_tps, rty);\n+                                    vec::push[t](result_tps, rty);\n                                 }\n                                 case (_) {\n                                     ret result;\n@@ -2294,8 +2294,8 @@ mod unify {\n             case (ty::ty_tup(?expected_elems)) {\n                 alt (struct(cx.tcx, actual)) {\n                     case (ty::ty_tup(?actual_elems)) {\n-                        auto expected_len = _vec::len[ty::mt](expected_elems);\n-                        auto actual_len = _vec::len[ty::mt](actual_elems);\n+                        auto expected_len = vec::len[ty::mt](expected_elems);\n+                        auto actual_len = vec::len[ty::mt](actual_elems);\n                         if (expected_len != actual_len) {\n                             auto err = terr_tuple_size(expected_len,\n                                                        actual_len);\n@@ -2348,8 +2348,8 @@ mod unify {\n             case (ty::ty_rec(?expected_fields)) {\n                 alt (struct(cx.tcx, actual)) {\n                     case (ty::ty_rec(?actual_fields)) {\n-                        auto expected_len = _vec::len[field](expected_fields);\n-                        auto actual_len = _vec::len[field](actual_fields);\n+                        auto expected_len = vec::len[field](expected_fields);\n+                        auto actual_len = vec::len[field](actual_fields);\n                         if (expected_len != actual_len) {\n                             auto err = terr_record_size(expected_len,\n                                                         actual_len);\n@@ -2374,7 +2374,7 @@ mod unify {\n                                 case (some[ast::mutability](?m)) { mut = m; }\n                             }\n \n-                            if (!_str::eq(expected_field.ident,\n+                            if (!str::eq(expected_field.ident,\n                                          actual_field.ident)) {\n                                 auto err =\n                                     terr_record_fields(expected_field.ident,\n@@ -2388,7 +2388,7 @@ mod unify {\n                             alt (result) {\n                                 case (ures_ok(?rty)) {\n                                     auto mt = rec(ty=rty, mut=mut);\n-                                    _vec::push[field]\n+                                    vec::push[field]\n                                         (result_fields,\n                                          rec(mt=mt with expected_field));\n                                 }\n@@ -2455,7 +2455,7 @@ mod unify {\n             case (ty::ty_var(?expected_id)) {\n                 // Add a binding.\n                 auto expected_n = get_or_create_set(cx, expected_id);\n-                auto vlen = _vec::len[vec[t]](cx.types);\n+                auto vlen = vec::len[vec[t]](cx.types);\n                 if (expected_n < vlen) {\n                     cx.types.(expected_n) += [actual];\n                 } else {\n@@ -2519,23 +2519,23 @@ mod unify {\n     fn unify_sets(&@ctxt cx) -> vec[t] {\n         let vec[t] throwaway = [];\n         let vec[mutable vec[t]] set_types = [mutable throwaway];\n-        _vec::pop[vec[t]](set_types);   // FIXME: botch\n+        vec::pop[vec[t]](set_types);   // FIXME: botch\n \n         for (ufind::node node in cx.sets.nodes) {\n             let vec[t] v = [];\n             set_types += [mutable v];\n         }\n \n         auto i = 0u;\n-        while (i < _vec::len[vec[t]](set_types)) {\n+        while (i < vec::len[vec[t]](set_types)) {\n             auto root = ufind::find(cx.sets, i);\n             set_types.(root) += cx.types.(i);\n             i += 1u;\n         }\n \n         let vec[t] result = [];\n         for (vec[t] types in set_types) {\n-            if (_vec::len[t](types) > 1u) {\n+            if (vec::len[t](types) > 1u) {\n                 log_err \"unification of > 1 types in a type set is \" +\n                     \"unimplemented\";\n                 fail;\n@@ -2552,7 +2552,7 @@ mod unify {\n              &ty_ctxt tcx) -> result {\n         let vec[t] throwaway = [];\n         let vec[mutable vec[t]] types = [mutable throwaway];\n-        _vec::pop[vec[t]](types);   // FIXME: botch\n+        vec::pop[vec[t]](types);   // FIXME: botch\n \n         auto cx = @rec(sets=ufind::make(),\n                        var_ids=common::new_int_hash[uint](),\n@@ -2565,7 +2565,7 @@ mod unify {\n         case (ures_ok(?typ)) {\n             // Fast path: if there are no local variables, don't perform\n             // substitutions.\n-            if (_vec::len(cx.sets.nodes) == 0u) {\n+            if (vec::len(cx.sets.nodes) == 0u) {\n                 ret ures_ok(typ);\n             }\n \n@@ -2591,16 +2591,16 @@ fn type_err_to_str(&ty::type_err err) -> str {\n             ret \"vectors differ in mutability\";\n         }\n         case (terr_tuple_size(?e_sz, ?a_sz)) {\n-            ret \"expected a tuple with \" + _uint::to_str(e_sz, 10u) +\n-                \" elements but found one with \" + _uint::to_str(a_sz, 10u) +\n+            ret \"expected a tuple with \" + uint::to_str(e_sz, 10u) +\n+                \" elements but found one with \" + uint::to_str(a_sz, 10u) +\n                 \" elements\";\n         }\n         case (terr_tuple_mutability) {\n             ret \"tuple elements differ in mutability\";\n         }\n         case (terr_record_size(?e_sz, ?a_sz)) {\n-            ret \"expected a record with \" + _uint::to_str(e_sz, 10u) +\n-                \" fields but found one with \" + _uint::to_str(a_sz, 10u) +\n+            ret \"expected a record with \" + uint::to_str(e_sz, 10u) +\n+                \" fields but found one with \" + uint::to_str(a_sz, 10u) +\n                 \" fields\";\n         }\n         case (terr_record_mutability) {"}, {"sha": "ad100cf238971396f5b38a32b7014da964c4e1de", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 58, "deletions": 58, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -37,9 +37,9 @@ import middle::ty::ty_nil;\n import middle::ty::unify::ures_ok;\n import middle::ty::unify::ures_err;\n \n-import std::_str;\n-import std::_uint;\n-import std::_vec;\n+import std::str;\n+import std::uint;\n+import std::vec;\n import std::map;\n import std::map::hashmap;\n import std::option;\n@@ -97,12 +97,12 @@ fn substitute_ty_params(&@crate_ctxt ccx,\n         }\n     }\n \n-    auto supplied_len = _vec::len[ty::t](supplied);\n+    auto supplied_len = vec::len[ty::t](supplied);\n     if (ty_param_count != supplied_len) {\n         ccx.sess.span_err(sp, \"expected \" +\n-                          _uint::to_str(ty_param_count, 10u) +\n+                          uint::to_str(ty_param_count, 10u) +\n                           \" type parameter(s) but found \" +\n-                          _uint::to_str(supplied_len, 10u) + \" parameter(s)\");\n+                          uint::to_str(supplied_len, 10u) + \" parameter(s)\");\n         fail;\n     }\n \n@@ -187,7 +187,7 @@ fn instantiate_path(&@fn_ctxt fcx, &ast::path pth, &ty_param_count_and_ty tpt,\n     auto t = bind_params_in_type(fcx.ccx.tcx, tpt._1);\n \n     auto ty_substs_opt;\n-    auto ty_substs_len = _vec::len[@ast::ty](pth.node.types);\n+    auto ty_substs_len = vec::len[@ast::ty](pth.node.types);\n     if (ty_substs_len > 0u) {\n         let vec[ty::t] ty_substs = [];\n         auto i = 0u;\n@@ -298,22 +298,22 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n         case (ast::ty_tup(?fields)) {\n             let vec[ty::mt] flds = [];\n             for (ast::mt field in fields) {\n-                _vec::push[ty::mt](flds, ast_mt_to_mt(tcx, getter, field));\n+                vec::push[ty::mt](flds, ast_mt_to_mt(tcx, getter, field));\n             }\n             typ = ty::mk_tup(tcx, flds);\n         }\n         case (ast::ty_rec(?fields)) {\n             let vec[field] flds = [];\n             for (ast::ty_field f in fields) {\n                 auto tm = ast_mt_to_mt(tcx, getter, f.mt);\n-                _vec::push[field](flds, rec(ident=f.ident, mt=tm));\n+                vec::push[field](flds, rec(ident=f.ident, mt=tm));\n             }\n             typ = ty::mk_rec(tcx, flds);\n         }\n \n         case (ast::ty_fn(?proto, ?inputs, ?output)) {\n             auto f = bind ast_arg_to_arg(tcx, getter, _);\n-            auto i = _vec::map[ast::ty_arg, arg](f, inputs);\n+            auto i = vec::map[ast::ty_arg, arg](f, inputs);\n             auto out_ty = ast_ty_to_ty(tcx, getter, output);\n             typ = ty::mk_fn(tcx, proto, i, out_ty);\n         }\n@@ -341,9 +341,9 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n             let vec[ty::method] tmeths = [];\n             auto f = bind ast_arg_to_arg(tcx, getter, _);\n             for (ast::ty_method m in meths) {\n-                auto ins = _vec::map[ast::ty_arg, arg](f, m.inputs);\n+                auto ins = vec::map[ast::ty_arg, arg](f, m.inputs);\n                 auto out = ast_ty_to_ty(tcx, getter, m.output);\n-                _vec::push[ty::method](tmeths,\n+                vec::push[ty::method](tmeths,\n                                   rec(proto=m.proto,\n                                       ident=m.ident,\n                                       inputs=ins,\n@@ -377,7 +377,7 @@ fn ast_ty_to_ty_crate(@crate_ctxt ccx, &@ast::ty ast_ty) -> ty::t {\n // Writes a type parameter count and type pair into the node type table.\n fn write_type(&node_type_table ntt, uint node_id,\n               &ty_param_substs_opt_and_ty tpot) {\n-    _vec::grow_set[option::t[ty::ty_param_substs_opt_and_ty]]\n+    vec::grow_set[option::t[ty::ty_param_substs_opt_and_ty]]\n         (*ntt,\n          node_id,\n          none[ty_param_substs_opt_and_ty],\n@@ -425,10 +425,10 @@ mod collect {\n                      ast::proto proto,\n                      &vec[ast::ty_param] ty_params,\n                      &ast::def_id def_id) -> ty::ty_param_count_and_ty {\n-        auto input_tys = _vec::map[ast::arg,arg](ty_of_arg, decl.inputs);\n+        auto input_tys = vec::map[ast::arg,arg](ty_of_arg, decl.inputs);\n         auto output_ty = convert(decl.output);\n         auto t_fn = ty::mk_fn(cx.tcx, proto, input_tys, output_ty);\n-        auto ty_param_count = _vec::len[ast::ty_param](ty_params);\n+        auto ty_param_count = vec::len[ast::ty_param](ty_params);\n         auto tpt = tup(ty_param_count, t_fn);\n         cx.type_cache.insert(def_id, tpt);\n         ret tpt;\n@@ -441,10 +441,10 @@ mod collect {\n                             ast::native_abi abi,\n                             &vec[ast::ty_param] ty_params,\n                             &ast::def_id def_id) -> ty::ty_param_count_and_ty{\n-        auto input_tys = _vec::map[ast::arg,arg](ty_of_arg, decl.inputs);\n+        auto input_tys = vec::map[ast::arg,arg](ty_of_arg, decl.inputs);\n         auto output_ty = convert(decl.output);\n         auto t_fn = ty::mk_native_fn(cx.tcx, abi, input_tys, output_ty);\n-        auto ty_param_count = _vec::len[ast::ty_param](ty_params);\n+        auto ty_param_count = vec::len[ast::ty_param](ty_params);\n         auto tpt = tup(ty_param_count, t_fn);\n         cx.type_cache.insert(def_id, tpt);\n         ret tpt;\n@@ -479,7 +479,7 @@ mod collect {\n         auto get = bind getter(cx, _);\n         auto convert = bind ast_ty_to_ty(cx.tcx, get, _);\n         auto f = bind ty_of_arg(cx, _);\n-        auto inputs = _vec::map[ast::arg,arg](f, m.node.meth.decl.inputs);\n+        auto inputs = vec::map[ast::arg,arg](f, m.node.meth.decl.inputs);\n         auto output = convert(m.node.meth.decl.output);\n         ret rec(proto=m.node.meth.proto, ident=m.node.ident,\n                 inputs=inputs, output=output);\n@@ -492,7 +492,7 @@ mod collect {\n         auto methods = get_obj_method_types(cx, obj_info);\n         auto t_obj = ty::mk_obj(cx.tcx, ty::sort_methods(methods));\n         t_obj = ty::rename(cx.tcx, t_obj, id);\n-        auto ty_param_count = _vec::len[ast::ty_param](ty_params);\n+        auto ty_param_count = vec::len[ast::ty_param](ty_params);\n         ret tup(ty_param_count, t_obj);\n     }\n \n@@ -508,7 +508,7 @@ mod collect {\n         for (ast::obj_field f in obj_info.fields) {\n             auto g = bind getter(cx, _);\n             auto t_field = ast_ty_to_ty(cx.tcx, g, f.ty);\n-            _vec::push[arg](t_inputs, rec(mode=ty::mo_alias, ty=t_field));\n+            vec::push[arg](t_inputs, rec(mode=ty::mo_alias, ty=t_field));\n         }\n \n         auto t_fn = ty::mk_fn(cx.tcx, ast::proto_fn, t_inputs, t_obj._1);\n@@ -555,7 +555,7 @@ mod collect {\n                 // Tell ast_ty_to_ty() that we want to perform a recursive\n                 // call to resolve any named types.\n                 auto typ = convert(t);\n-                auto ty_param_count = _vec::len[ast::ty_param](tps);\n+                auto ty_param_count = vec::len[ast::ty_param](tps);\n                 auto tpt = tup(ty_param_count, typ);\n                 cx.type_cache.insert(def_id, tpt);\n                 ret tpt;\n@@ -573,7 +573,7 @@ mod collect {\n \n                 auto t = ty::mk_tag(cx.tcx, def_id, subtys);\n \n-                auto ty_param_count = _vec::len[ast::ty_param](tps);\n+                auto ty_param_count = vec::len[ast::ty_param](tps);\n                 auto tpt = tup(ty_param_count, t);\n                 cx.type_cache.insert(def_id, tpt);\n                 ret tpt;\n@@ -625,13 +625,13 @@ mod collect {\n             i += 1u;\n         }\n \n-        auto ty_param_count = _vec::len[ast::ty_param](ty_params);\n+        auto ty_param_count = vec::len[ast::ty_param](ty_params);\n \n         for (ast::variant variant in variants) {\n             // Nullary tag constructors get turned into constants; n-ary tag\n             // constructors get turned into functions.\n             auto result_ty;\n-            if (_vec::len[ast::variant_arg](variant.node.args) == 0u) {\n+            if (vec::len[ast::variant_arg](variant.node.args) == 0u) {\n                 result_ty = ty::mk_tag(cx.tcx, tag_id, ty_param_tys);\n             } else {\n                 // As above, tell ast_ty_to_ty() that trans_ty_item_to_ty()\n@@ -662,7 +662,7 @@ mod collect {\n     }\n \n     fn get_obj_method_types(&@ctxt cx, &ast::_obj object) -> vec[method] {\n-        ret _vec::map[@ast::method,method](bind ty_of_method(cx, _),\n+        ret vec::map[@ast::method,method](bind ty_of_method(cx, _),\n                                            object.methods);\n     }\n \n@@ -726,7 +726,7 @@ mod collect {\n                 // ty_of_obj().)\n                 auto method_types = get_obj_method_types(cx, object);\n                 auto i = 0u;\n-                while (i < _vec::len[@ast::method](object.methods)) {\n+                while (i < vec::len[@ast::method](object.methods)) {\n                     write_type_only(cx.node_types,\n                                     ast::ann_tag(object.methods.(i).node.ann),\n                                     ty::method_ty_to_fn_ty(cx.tcx,\n@@ -736,11 +736,11 @@ mod collect {\n \n                 // Write in the types of the object fields.\n                 //\n-                // FIXME: We want to use _uint::range() here, but that causes\n+                // FIXME: We want to use uint::range() here, but that causes\n                 // an assertion in trans.\n                 auto args = ty::ty_fn_args(cx.tcx, tpt._1);\n                 i = 0u;\n-                while (i < _vec::len[ty::arg](args)) {\n+                while (i < vec::len[ty::arg](args)) {\n                     auto fld = object.fields.(i);\n                     write_type_only(cx.node_types, ast::ann_tag(fld.ann),\n                                     args.(i).ty);\n@@ -840,7 +840,7 @@ mod unify {\n         // FIXME: horrid botch\n         let vec[mutable ty::t] param_substs =\n             [mutable ty::mk_nil(fcx.ccx.tcx)];\n-        _vec::pop(param_substs);\n+        vec::pop(param_substs);\n         ret with_params(fcx, expected, actual, param_substs);\n     }\n \n@@ -999,7 +999,7 @@ mod Demand {\n \n         let vec[mutable ty::t] ty_param_substs =\n             [mutable ty::mk_nil(fcx.ccx.tcx)];\n-        _vec::pop(ty_param_substs);   // FIXME: horrid botch\n+        vec::pop(ty_param_substs);   // FIXME: horrid botch\n         for (ty::t ty_param_subst in ty_param_substs_0) {\n             ty_param_substs += [mutable ty_param_subst];\n         }\n@@ -1042,7 +1042,7 @@ fn are_compatible(&@fn_ctxt fcx, &ty::t expected, &ty::t actual) -> bool {\n // Returns the types of the arguments to a tag variant.\n fn variant_arg_types(&@crate_ctxt ccx, &span sp, &ast::def_id vid,\n                      &vec[ty::t] tag_ty_params) -> vec[ty::t] {\n-    auto ty_param_count = _vec::len[ty::t](tag_ty_params);\n+    auto ty_param_count = vec::len[ty::t](tag_ty_params);\n \n     let vec[ty::t] result = [];\n \n@@ -1137,7 +1137,7 @@ mod Pushdown {\n                                                    pat.span,\n                                                    t1, t2);\n                     \n-                    _vec::push(tparams, res);\n+                    vec::push(tparams, res);\n                     j += 1u;\n                 }\n \n@@ -1247,7 +1247,7 @@ mod Pushdown {\n                             case (none[@ast::expr]) {\n                                 auto i = 0u;\n                                 for (ast::field field_0 in fields_0) {\n-                                    assert (_str::eq(field_0.ident,\n+                                    assert (str::eq(field_0.ident,\n                                                    field_mts.(i).ident));\n                                     auto e_1 =\n                                         pushdown_expr(fcx,\n@@ -1269,7 +1269,7 @@ mod Pushdown {\n                                 for (ast::field field_0 in fields_0) {\n \n                                     for (ty::field ft in field_mts) {\n-                                        if (_str::eq(field_0.ident,\n+                                        if (str::eq(field_0.ident,\n                                                     ft.ident)) {\n                                             auto e_1 =\n                                                 pushdown_expr(fcx, ft.mt.ty,\n@@ -1713,7 +1713,7 @@ fn check_pat(&@fn_ctxt fcx, &@ast::pat pat) {\n                 (fcx.ccx.tcx.def_map.get(ast::ann_tag(old_ann)));\n             auto t = ty::lookup_item_type(fcx.ccx.sess, fcx.ccx.tcx,\n                                          fcx.ccx.type_cache, vdef._1)._1;\n-            auto len = _vec::len[ast::ident](p.node.idents);\n+            auto len = vec::len[ast::ident](p.node.idents);\n             auto last_id = p.node.idents.(len - 1u);\n \n             auto tpt = ty::lookup_item_type(fcx.ccx.sess, fcx.ccx.tcx,\n@@ -1724,14 +1724,14 @@ fn check_pat(&@fn_ctxt fcx, &@ast::pat pat) {\n             alt (struct(fcx.ccx.tcx, t)) {\n                 // N-ary variants have function types.\n                 case (ty::ty_fn(_, ?args, ?tag_ty)) {\n-                    auto arg_len = _vec::len[arg](args);\n-                    auto subpats_len = _vec::len[@ast::pat](subpats);\n+                    auto arg_len = vec::len[arg](args);\n+                    auto subpats_len = vec::len[@ast::pat](subpats);\n                     if (arg_len != subpats_len) {\n                         // TODO: pluralize properly\n                         auto err_msg = \"tag type \" + last_id + \" has \" +\n-                                       _uint::to_str(subpats_len, 10u) +\n+                                       uint::to_str(subpats_len, 10u) +\n                                        \" field(s), but this pattern has \" +\n-                                       _uint::to_str(arg_len, 10u) +\n+                                       uint::to_str(arg_len, 10u) +\n                                        \" field(s)\";\n \n                         fcx.ccx.sess.span_err(pat.span, err_msg);\n@@ -1748,13 +1748,13 @@ fn check_pat(&@fn_ctxt fcx, &@ast::pat pat) {\n \n                 // Nullary variants have tag types.\n                 case (ty::ty_tag(?tid, _)) {\n-                    auto subpats_len = _vec::len[@ast::pat](subpats);\n+                    auto subpats_len = vec::len[@ast::pat](subpats);\n                     if (subpats_len > 0u) {\n                         // TODO: pluralize properly\n                         auto err_msg = \"tag type \" + last_id +\n                                        \" has no field(s),\" +\n                                        \" but this pattern has \" +\n-                                       _uint::to_str(subpats_len, 10u) +\n+                                       uint::to_str(subpats_len, 10u) +\n                                        \" field(s)\";\n \n                         fcx.ccx.sess.span_err(pat.span, err_msg);\n@@ -1855,13 +1855,13 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                     auto arg_ty = rec(mode=mo_either,\n                                       ty=expr_ty(fcx.ccx.tcx,\n                                                  fcx.ccx.node_types, a_0));\n-                    _vec::push[arg](arg_tys_0, arg_ty);\n+                    vec::push[arg](arg_tys_0, arg_ty);\n                 }\n                 case (none[@ast::expr]) {\n                     args_0 += [none[@ast::expr]];\n \n                     auto typ = next_ty_var(fcx.ccx);\n-                    _vec::push[arg](arg_tys_0, rec(mode=mo_either, ty=typ));\n+                    vec::push[arg](arg_tys_0, rec(mode=mo_either, ty=typ));\n                 }\n             }\n         }\n@@ -2028,7 +2028,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n \n             // The definition doesn't take type parameters. If the programmer\n             // supplied some, that's an error.\n-            if (_vec::len[@ast::ty](pth.node.types) > 0u) {\n+            if (vec::len[@ast::ty](pth.node.types) > 0u) {\n                 fcx.ccx.sess.span_err(expr.span, \"this kind of value does \" +\n                                       \"not take type parameters\");\n                 fail;\n@@ -2471,7 +2471,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                     // For each blank argument, add the type of that argument\n                     // to the resulting function type.\n                     auto i = 0u;\n-                    while (i < _vec::len[option::t[@ast::expr]](args)) {\n+                    while (i < vec::len[option::t[@ast::expr]](args)) {\n                         alt (args.(i)) {\n                             case (some[@ast::expr](_)) { /* no-op */ }\n                             case (none[@ast::expr]) {\n@@ -2623,7 +2623,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             let vec[@ast::expr] args_1 = [];\n \n             let ty::t t;\n-            if (_vec::len[@ast::expr](args) == 0u) {\n+            if (vec::len[@ast::expr](args) == 0u) {\n                 t = next_ty_var(fcx.ccx);\n             } else {\n                 auto expr_1 = check_expr(fcx, args.(0));\n@@ -2635,7 +2635,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                 auto expr_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n                                       expr_1);\n                 Demand::simple(fcx, expr.span, t, expr_t);\n-                _vec::push[@ast::expr](args_1,expr_1);\n+                vec::push[@ast::expr](args_1,expr_1);\n             }\n \n             auto typ = ty::mk_vec(fcx.ccx.tcx, rec(ty=t, mut=mut));\n@@ -2653,7 +2653,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                 auto expr_1 = check_expr(fcx, e.expr);\n                 auto expr_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n                                       expr_1);\n-                _vec::push[ast::elt](elts_1, rec(expr=expr_1 with e));\n+                vec::push[ast::elt](elts_1, rec(expr=expr_1 with e));\n                 elts_mt += [rec(ty=expr_t, mut=e.mut)];\n             }\n \n@@ -2681,10 +2681,10 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                 auto expr_1 = check_expr(fcx, f.expr);\n                 auto expr_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n                                       expr_1);\n-                _vec::push[ast::field](fields_1, rec(expr=expr_1 with f));\n+                vec::push[ast::field](fields_1, rec(expr=expr_1 with f));\n \n                 auto expr_mt = rec(ty=expr_t, mut=f.mut);\n-                _vec::push[field](fields_t, rec(ident=f.ident, mt=expr_mt));\n+                vec::push[field](fields_t, rec(ident=f.ident, mt=expr_mt));\n             }\n \n             auto ann;\n@@ -2721,7 +2721,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                     for (ty::field f in fields_t) {\n                         auto found = false;\n                         for (ty::field bf in base_fields) {\n-                            if (_str::eq(f.ident, bf.ident)) {\n+                            if (str::eq(f.ident, bf.ident)) {\n                                 Demand::simple(fcx, expr.span, f.mt.ty,\n                                               bf.mt.ty);\n                                 found = true;\n@@ -2749,7 +2749,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                 case (ty::ty_tup(?args)) {\n                     let uint ix = ty::field_num(fcx.ccx.sess,\n                                                expr.span, field);\n-                    if (ix >= _vec::len[ty::mt](args)) {\n+                    if (ix >= vec::len[ty::mt](args)) {\n                         fcx.ccx.sess.span_err(expr.span,\n                                               \"bad index on tuple\");\n                     }\n@@ -2765,7 +2765,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                 case (ty::ty_rec(?fields)) {\n                     let uint ix = ty::field_idx(fcx.ccx.sess,\n                                                expr.span, field, fields);\n-                    if (ix >= _vec::len[typeck::field](fields)) {\n+                    if (ix >= vec::len[typeck::field](fields)) {\n                         fcx.ccx.sess.span_err(expr.span,\n                                               \"bad index on record\");\n                     }\n@@ -2781,7 +2781,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                 case (ty::ty_obj(?methods)) {\n                     let uint ix = ty::method_idx(fcx.ccx.sess,\n                                                 expr.span, field, methods);\n-                    if (ix >= _vec::len[typeck::method](methods)) {\n+                    if (ix >= vec::len[typeck::method](methods)) {\n                         fcx.ccx.sess.span_err(expr.span,\n                                               \"bad index on obj\");\n                     }\n@@ -2998,7 +2998,7 @@ fn check_stmt(&@fn_ctxt fcx, &@ast::stmt stmt) -> @ast::stmt {\n fn check_block(&@fn_ctxt fcx, &ast::block block) -> ast::block {\n     let vec[@ast::stmt] stmts = [];\n     for (@ast::stmt s in block.node.stmts) {\n-        _vec::push[@ast::stmt](stmts, check_stmt(fcx, s));\n+        vec::push[@ast::stmt](stmts, check_stmt(fcx, s));\n     }\n \n     auto expr = none[@ast::expr];\n@@ -3125,7 +3125,7 @@ fn hash_unify_cache_entry(&unify_cache_entry uce) -> uint {\n     h += h << 5u + ty::hash_ty(uce._1);\n \n     auto i = 0u;\n-    auto tys_len = _vec::len(uce._2);\n+    auto tys_len = vec::len(uce._2);\n     while (i < tys_len) {\n         h += h << 5u + ty::hash_ty(uce._2.(i));\n         i += 1u;\n@@ -3138,8 +3138,8 @@ fn eq_unify_cache_entry(&unify_cache_entry a, &unify_cache_entry b) -> bool {\n     if (!ty::eq_ty(a._0, b._0) || !ty::eq_ty(a._1, b._1)) { ret false; }\n \n     auto i = 0u;\n-    auto tys_len = _vec::len(a._2);\n-    if (_vec::len(b._2) != tys_len) { ret false; }\n+    auto tys_len = vec::len(a._2);\n+    if (vec::len(b._2) != tys_len) { ret false; }\n \n     while (i < tys_len) {\n         if (!ty::eq_ty(a._2.(i), b._2.(i))) { ret false; }"}, {"sha": "e7ecb4245b0f74dbf0feac5fc55a452b3d48d393", "filename": "src/comp/middle/typestate_check.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -154,15 +154,15 @@ import pretty::pp::mkstate;\n import std::io::stdout;\n import std::io::str_writer;\n import std::io::string_writer;\n-import std::_vec::map;\n-import std::_vec;\n-import std::_vec::len;\n-import std::_vec::pop;\n-import std::_vec::push;\n-import std::_vec::slice;\n-import std::_vec::unzip;\n-import std::_vec::plus_option;\n-import std::_vec::cat_options;\n+import std::vec::map;\n+import std::vec;\n+import std::vec::len;\n+import std::vec::pop;\n+import std::vec::push;\n+import std::vec::slice;\n+import std::vec::unzip;\n+import std::vec::plus_option;\n+import std::vec::cat_options;\n import std::option;\n import std::option::t;\n import std::option::some;\n@@ -178,7 +178,7 @@ import std::list::cons;\n import std::list::nil;\n import std::list::foldl;\n import std::list::find;\n-import std::_uint;\n+import std::uint;\n import std::bitv;\n import std::util::fst;\n import std::util::snd;\n@@ -310,12 +310,12 @@ fn num_locals(fn_info m) -> uint {\n fn collect_local(&@vec[tup(ident, def_id)] vars, &span sp, &@ast::local loc)\n     -> @decl {\n     log(\"collect_local: pushing \" + loc.ident);\n-    _vec::push[tup(ident, def_id)](*vars, tup(loc.ident, loc.id));\n+    vec::push[tup(ident, def_id)](*vars, tup(loc.ident, loc.id));\n     ret @respan(sp, decl_local(loc));\n }\n \n fn find_locals(_fn f) -> @vec[tup(ident,def_id)] {\n-  auto res = @_vec::alloc[tup(ident,def_id)](0u);\n+  auto res = @vec::alloc[tup(ident,def_id)](0u);\n \n   auto fld = fold::new_identity_fold[@vec[tup(ident, def_id)]]();\n   fld = @rec(fold_decl_local = bind collect_local(_,_,_) with *fld);\n@@ -341,7 +341,7 @@ fn mk_fn_info(_fn f) -> fn_info {\n      just collect locally declared vars */\n \n   let @vec[tup(ident,def_id)] locals = find_locals(f);\n-  log(uistr(_vec::len[tup(ident, def_id)](*locals)) + \" locals\");\n+  log(uistr(vec::len[tup(ident, def_id)](*locals)) + \" locals\");\n   for (tup(ident,def_id) p in *locals) {\n     next = add_var(p._1, p._0, next, res);\n   }\n@@ -363,7 +363,7 @@ fn mk_fn_info_item_fn(&fn_info_map fi, &span sp, &ident i, &ast::_fn f,\n fn mk_fn_info_item_obj(&fn_info_map fi, &span sp, &ident i, &ast::_obj o,\n                        &vec[ast::ty_param] ty_params,\n                        &ast::obj_def_ids odid, &ann a) -> @item {\n-    auto all_methods = _vec::clone[@method](o.methods);\n+    auto all_methods = vec::clone[@method](o.methods);\n     plus_option[@method](all_methods, o.dtor);\n     for (@method m in all_methods) {\n         fi.insert(m.node.id, mk_fn_info(m.node.meth));\n@@ -651,7 +651,7 @@ fn seq_preconds(fn_info enclosing, vec[pre_and_post] pps) -> precond {\n /* works on either postconds or preconds\n  should probably rethink the whole type synonym situation */\n fn union_postconds_go(&postcond first, &vec[postcond] rest) -> postcond {\n-  auto sz = _vec::len[postcond](rest);\n+  auto sz = vec::len[postcond](rest);\n \n   if (sz > 0u) {\n     auto other = rest.(0);\n@@ -673,7 +673,7 @@ fn union_postconds(uint nv, &vec[postcond] pcs) -> postcond {\n \n /* Gee, maybe we could use foldl or something */\n fn intersect_postconds_go(&postcond first, &vec[postcond] rest) -> postcond {\n-  auto sz = _vec::len[postcond](rest);\n+  auto sz = vec::len[postcond](rest);\n \n   if (sz > 0u) {\n     auto other = rest.(0);\n@@ -719,7 +719,7 @@ fn find_pre_post_obj(&def_map dm, &fn_info_map fm, _obj o) -> () {\n         find_pre_post_fn(dm, fm, fm.get(m.node.id), m.node.meth);\n     }\n     auto f = bind do_a_method(dm, fm, _);\n-    _vec::map[@method, ()](f, o.methods);\n+    vec::map[@method, ()](f, o.methods);\n     option::map[@method, ()](f, o.dtor);\n }\n \n@@ -729,8 +729,8 @@ fn find_pre_post_state_obj(&def_map dm, &fn_info_map fm, _obj o) -> bool {\n         ret find_pre_post_state_fn(dm, fm, fm.get(m.node.id), m.node.meth);\n     }\n     auto f = bind do_a_method(dm, fm, _);\n-    auto flags = _vec::map[@method, bool](f, o.methods);\n-    auto changed = _vec::or(flags);\n+    auto flags = vec::map[@method, bool](f, o.methods);\n+    auto changed = vec::or(flags);\n     changed = changed || maybe[@method, bool](false, f, o.dtor);\n     ret changed;\n }\n@@ -777,19 +777,19 @@ fn find_pre_post_exprs(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n     }\n     auto f = bind do_one(dm, fm, enclosing, _);\n \n-    _vec::map[@expr, ()](f, args);\n+    vec::map[@expr, ()](f, args);\n \n     fn get_pp(&@expr e) -> pre_and_post {\n         ret expr_pp(e);\n     }\n     auto g = get_pp;\n-    auto pps = _vec::map[@expr, pre_and_post](g, args);\n+    auto pps = vec::map[@expr, pre_and_post](g, args);\n     auto h = get_post;\n \n     set_pre_and_post(a,\n        rec(precondition=seq_preconds(enclosing, pps),\n            postcondition=union_postconds\n-           (nv, (_vec::map[pre_and_post, postcond](h, pps)))));\n+           (nv, (vec::map[pre_and_post, postcond](h, pps)))));\n }\n \n fn find_pre_post_loop(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n@@ -816,13 +816,13 @@ fn find_pre_post_expr(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n     \n     alt (e.node) {\n         case (expr_call(?operator, ?operands, ?a)) {\n-            auto args = _vec::clone[@expr](operands);\n-            _vec::push[@expr](args, operator);\n+            auto args = vec::clone[@expr](operands);\n+            vec::push[@expr](args, operator);\n             find_pre_post_exprs(dm, fm, enclosing, args, a);\n         }\n         case (expr_spawn(_, _, ?operator, ?operands, ?a)) {\n-            auto args = _vec::clone[@expr](operands);\n-            _vec::push[@expr](args, operator);\n+            auto args = vec::clone[@expr](operands);\n+            vec::push[@expr](args, operator);\n             find_pre_post_exprs(dm, fm, enclosing, args, a);\n         }\n         case (expr_vec(?args, _, ?a)) {\n@@ -875,7 +875,7 @@ fn find_pre_post_expr(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n         }\n         case (expr_rec(?fields,?maybe_base,?a)) {\n             auto es = field_exprs(fields);\n-            _vec::plus_option[@expr](es, maybe_base);\n+            vec::plus_option[@expr](es, maybe_base);\n             find_pre_post_exprs(dm, fm, enclosing, es, a);\n         }\n         case (expr_assign(?lhs, ?rhs, ?a)) {\n@@ -1048,7 +1048,7 @@ fn find_pre_post_expr(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n                 ret block_pp(an_alt.block);\n             }\n             auto f = bind do_an_alt(dm, fm, enclosing, _);\n-            auto alt_pps = _vec::map[arm, pre_and_post](f, alts);\n+            auto alt_pps = vec::map[arm, pre_and_post](f, alts);\n             fn combine_pp(pre_and_post antec, \n                           fn_info enclosing, &pre_and_post pp,\n                           &pre_and_post next) -> pre_and_post {\n@@ -1062,7 +1062,7 @@ fn find_pre_post_expr(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n                              postcondition=false_postcond(num_local_vars));\n             auto g = bind combine_pp(antec_pp, enclosing, _, _);\n \n-            auto alts_overall_pp = _vec::foldl[pre_and_post, pre_and_post]\n+            auto alts_overall_pp = vec::foldl[pre_and_post, pre_and_post]\n                                     (g, e_pp, alt_pps);\n \n             set_pre_and_post(a, alts_overall_pp);\n@@ -1088,8 +1088,8 @@ fn find_pre_post_expr(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n             set_pre_and_post(a, expr_pp(p));\n         }\n         case(expr_bind(?operator, ?maybe_args, ?a)) {\n-            auto args = _vec::cat_options[@expr](maybe_args);\n-            _vec::push[@expr](args, operator); /* ??? order of eval? */\n+            auto args = vec::cat_options[@expr](maybe_args);\n+            vec::push[@expr](args, operator); /* ??? order of eval? */\n             find_pre_post_exprs(dm, fm, enclosing, args, a);\n         }\n         case (expr_break(?a)) {\n@@ -1207,7 +1207,7 @@ fn find_pre_post_block(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n     }\n     auto do_one = bind do_one_(dm, fm, enclosing, _);\n     \n-    _vec::map[@stmt, ()](do_one, b.node.stmts);\n+    vec::map[@stmt, ()](do_one, b.node.stmts);\n     fn do_inner_(def_map dm, fn_info_map fm, fn_info i, &@expr e) -> () {\n         find_pre_post_expr(dm, fm, i, e);\n     }\n@@ -1220,7 +1220,7 @@ fn find_pre_post_block(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n         ret stmt_pp(*s);\n     }\n     auto f = get_pp_stmt;\n-    pps += _vec::map[@stmt, pre_and_post](f, b.node.stmts);\n+    pps += vec::map[@stmt, pre_and_post](f, b.node.stmts);\n     fn get_pp_expr(&@expr e) -> pre_and_post {\n         ret expr_pp(e);\n     }\n@@ -1230,10 +1230,10 @@ fn find_pre_post_block(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n \n     auto block_precond  = seq_preconds(enclosing, pps);\n     auto h = get_post;\n-    auto postconds =  _vec::map[pre_and_post, postcond](h, pps);\n+    auto postconds =  vec::map[pre_and_post, postcond](h, pps);\n     /* A block may be empty, so this next line ensures that the postconds\n        vector is non-empty. */\n-    _vec::push[postcond](postconds, block_precond);\n+    vec::push[postcond](postconds, block_precond);\n     auto block_postcond = empty_poststate(nv);\n     /* conservative approximation */\n     if (! has_nonlocal_exits(b)) {\n@@ -1708,7 +1708,7 @@ fn find_pre_post_state_expr(&def_map dm, &fn_info_map fm, &fn_info enclosing,\n                   || changed;\n         auto e_post = expr_poststate(e);\n         auto a_post;\n-        if (_vec::len[arm](alts) > 0u) {\n+        if (vec::len[arm](alts) > 0u) {\n             a_post = false_postcond(num_local_vars);\n             for (arm an_alt in alts) {\n                 changed = find_pre_post_state_block(dm, fm, enclosing, e_post,\n@@ -1987,7 +1987,7 @@ fn check_states_against_conditions(fn_info enclosing, &ast::_fn f) -> () {\n   }\n   auto do_one = bind do_one_(enclosing, _);\n  \n-  _vec::map[@stmt, ()](do_one, f.body.node.stmts);\n+  vec::map[@stmt, ()](do_one, f.body.node.stmts);\n   fn do_inner_(fn_info i, &@expr e) -> () {\n     check_states_expr(i, e);\n   }\n@@ -2034,7 +2034,7 @@ fn check_obj_state(def_map dm, &fn_info_map f_info_map,\n         ret check_method_states(dm, fm, m);\n     }\n     auto f = bind one(dm, f_info_map,_);\n-    _vec::map[@method, ()](f, methods);\n+    vec::map[@method, ()](f, methods);\n     option::map[@method, ()](f, dtor);\n     ret rec(fields=fields, methods=methods, dtor=dtor);\n }\n@@ -2125,15 +2125,15 @@ fn annotate_exprs(&fn_info_map fm, &vec[@expr] es) -> vec[@expr] {\n         ret annotate_expr(fm, e);\n     }\n     auto f = bind one(fm,_);\n-    ret _vec::map[@expr, @expr](f, es);\n+    ret vec::map[@expr, @expr](f, es);\n }\n fn annotate_elts(&fn_info_map fm, &vec[elt] es) -> vec[elt] {\n     fn one(fn_info_map fm, &elt e) -> elt {\n         ret rec(mut=e.mut,\n                 expr=annotate_expr(fm, e.expr));\n     }\n     auto f = bind one(fm,_);\n-    ret _vec::map[elt, elt](f, es);\n+    ret vec::map[elt, elt](f, es);\n }\n fn annotate_fields(&fn_info_map fm, &vec[field] fs) -> vec[field] {\n     fn one(fn_info_map fm, &field f) -> field {\n@@ -2142,7 +2142,7 @@ fn annotate_fields(&fn_info_map fm, &vec[field] fs) -> vec[field] {\n                  expr=annotate_expr(fm, f.expr));\n     }\n     auto f = bind one(fm,_);\n-    ret _vec::map[field, field](f, fs);\n+    ret vec::map[field, field](f, fs);\n }\n fn annotate_option_exp(&fn_info_map fm, &option::t[@expr] o)\n   -> option::t[@expr] {\n@@ -2158,7 +2158,7 @@ fn annotate_option_exprs(&fn_info_map fm, &vec[option::t[@expr]] es)\n         ret annotate_option_exp(fm, o);\n     }\n     auto f = bind one(fm,_);\n-    ret _vec::map[option::t[@expr], option::t[@expr]](f, es);\n+    ret vec::map[option::t[@expr], option::t[@expr]](f, es);\n }\n fn annotate_decl(&fn_info_map fm, &@decl d) -> @decl {\n     auto d1 = d.node;\n@@ -2188,7 +2188,7 @@ fn annotate_alts(&fn_info_map fm, &vec[arm] alts) -> vec[arm] {\n                  block=annotate_block(fm, a.block));\n     }\n     auto f = bind one(fm,_);\n-    ret _vec::map[arm, arm](f, alts);\n+    ret vec::map[arm, arm](f, alts);\n \n }\n fn annotate_expr(&fn_info_map fm, &@expr e) -> @expr {\n@@ -2339,7 +2339,7 @@ fn annotate_block(&fn_info_map fm, &block b) -> block {\n \n     for (@stmt s in b.node.stmts) {\n         auto new_s = annotate_stmt(fm, s);\n-        _vec::push[@stmt](new_stmts, new_s);\n+        vec::push[@stmt](new_stmts, new_s);\n     }\n     fn ann_e(fn_info_map fm, &@expr e) -> @expr {\n         ret annotate_expr(fm, e);\n@@ -2361,7 +2361,7 @@ fn annotate_mod(&fn_info_map fm, &ast::_mod m) -> ast::_mod {\n \n     for (@item i in m.items) {\n         auto new_i = annotate_item(fm, i);\n-        _vec::push[@item](new_items, new_i);\n+        vec::push[@item](new_items, new_i);\n     }\n     ret rec(items=new_items with m);\n }\n@@ -2381,7 +2381,7 @@ fn annotate_obj(&fn_info_map fm, &ast::_obj o) -> ast::_obj {\n         ret annotate_method(fm, m);\n     }\n     auto f = bind one(fm,_);\n-    auto new_methods = _vec::map[@method, @method](f, o.methods);\n+    auto new_methods = vec::map[@method, @method](f, o.methods);\n     auto new_dtor    = option::map[@method, @method](f, o.dtor);\n     ret rec(methods=new_methods, dtor=new_dtor with o);\n }\n@@ -2474,7 +2474,7 @@ fn annotate_module(&fn_info_map fm, &ast::_mod module) -> ast::_mod {\n \n     for (@item i in module.items) {\n         auto new_item = annotate_item(fm, i);\n-        _vec::push[@item](new_items, new_item);\n+        vec::push[@item](new_items, new_item);\n     }\n \n     ret rec(items = new_items with module);"}, {"sha": "11c18edd88a3a65d68a26228118744687f932bb3", "filename": "src/comp/pretty/pp.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fpretty%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fpretty%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpp.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,6 +1,6 @@\n import std::io;\n-import std::_vec;\n-import std::_str;\n+import std::vec;\n+import std::str;\n \n tag boxtype {box_h; box_v; box_hv; box_align;}\n tag contexttype {cx_h; cx_v;}\n@@ -57,12 +57,12 @@ fn write_spaces(ps p, uint i) {\n \n fn push_context(ps p, contexttype tp, uint indent) {\n   before_print(p, false);\n-  _vec::push[context](p.context, rec(tp=tp, indent=indent));\n+  vec::push[context](p.context, rec(tp=tp, indent=indent));\n   p.start_of_box = true;\n }\n \n fn pop_context(ps p) {\n-  _vec::pop[context](p.context);\n+  vec::pop[context](p.context);\n }\n \n fn add_token(ps p, token tok) {\n@@ -89,22 +89,22 @@ fn buffer_token(ps p, token tok) {\n   } else {\n     alt (tok) {\n       case (open(?tp,_)) {\n-        _vec::push[boxtype](p.scandepth, tp);\n+        vec::push[boxtype](p.scandepth, tp);\n         if (p.scanning == scan_h) {\n           if (tp == box_h) {\n             check_potential_brk(p);\n           }\n         }\n       }\n       case (close) {\n-        _vec::pop[boxtype](p.scandepth);\n-        if (_vec::len[boxtype](p.scandepth) == 0u) {\n+        vec::pop[boxtype](p.scandepth);\n+        if (vec::len[boxtype](p.scandepth) == 0u) {\n           finish_scan(p, true);\n         }\n       }\n       case (brk(_)) {\n         if (p.scanning == scan_h) {\n-          if (p.scandepth.(_vec::len[boxtype](p.scandepth)-1u) == box_v) {\n+          if (p.scandepth.(vec::len[boxtype](p.scandepth)-1u) == box_v) {\n             finish_scan(p, true);\n           }\n         }\n@@ -123,7 +123,7 @@ fn check_potential_brk(ps p) {\n \n fn finish_scan(ps p, bool fits) {\n   auto buf = p.buffered;\n-  auto front = _vec::shift[token](buf);\n+  auto front = vec::shift[token](buf);\n   auto chosen_tp = cx_h;\n   if (!fits) {chosen_tp = cx_v;}\n   alt (front) {\n@@ -154,10 +154,10 @@ fn start_scan(ps p, token tok, scantype tp) {\n }\n \n fn cur_context(ps p) -> context {\n-  ret p.context.(_vec::len[context](p.context)-1u);\n+  ret p.context.(vec::len[context](p.context)-1u);\n }\n fn base_indent(ps p) -> uint {\n-  auto i = _vec::len[context](p.context);\n+  auto i = vec::len[context](p.context);\n   while (i > 0u) {\n     i -= 1u;\n     auto cx = p.context.(i);\n@@ -191,7 +191,7 @@ fn do_token(ps p, token tok) {\n       line_break(p);\n     }\n     case (word(?w)) {\n-      auto len = _str::char_len(w);\n+      auto len = str::char_len(w);\n       if (len + p.col + p.spaces > p.width && !start_of_box &&\n           !p.start_of_line) {\n         line_break(p);\n@@ -203,7 +203,7 @@ fn do_token(ps p, token tok) {\n     case (cword(?w)) {\n       before_print(p, true);\n       p.out.write_str(w);\n-      p.col += _str::char_len(w);\n+      p.col += str::char_len(w);\n     }\n     case (open(?tp, ?indent)) {\n       if (tp == box_v) {\n@@ -248,8 +248,8 @@ fn token_size(token tok) -> uint {\n   alt (tok) {\n     case (brk(?sz)) {ret sz;}\n     case (hardbrk) {ret 0xFFFFFFu;}\n-    case (word(?w)) {ret _str::char_len(w);}\n-    case (cword(?w)) {ret _str::char_len(w);}\n+    case (word(?w)) {ret str::char_len(w);}\n+    case (cword(?w)) {ret str::char_len(w);}\n     case (open(_, _)) {ret 0u;}\n     case (close) {ret 0u;}\n   }"}, {"sha": "db09f2785329a86f107827921709d964266fc2b3", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,5 +1,5 @@\n-import std::_vec;\n-import std::_str;\n+import std::vec;\n+import std::str;\n import std::io;\n import std::option;\n import driver::session::session;\n@@ -92,7 +92,7 @@ fn commasep[IN](ps s, vec[IN] elts, fn(ps, &IN) op) {\n }\n fn commasep_cmnt[IN](ps s, vec[IN] elts, fn(ps, &IN) op,\n                             fn(&IN) -> common::span get_span) {\n-    auto len = _vec::len[IN](elts);\n+    auto len = vec::len[IN](elts);\n     auto i = 0u;\n     for (IN elt in elts) {\n         op(s, elt);\n@@ -162,7 +162,7 @@ fn print_type(ps s, &@ast::ty ty) {\n             fn get_span(&ast::ty_field f) -> common::span {\n               // Try to reconstruct the span for this field\n               auto sp = f.mt.ty.span;\n-              auto hi = sp.hi + _str::char_len(f.ident) + 1u;\n+              auto hi = sp.hi + str::char_len(f.ident) + 1u;\n               ret rec(hi=hi with sp);\n             }\n             auto f = print_field;\n@@ -272,7 +272,7 @@ fn print_item(ps s, @ast::item item) {\n             for (ast::variant v in variants) {\n                 maybe_print_comment(s, v.span.lo);\n                 wrd(s.s, v.node.name);\n-                if (_vec::len[ast::variant_arg](v.node.args) > 0u) {\n+                if (vec::len[ast::variant_arg](v.node.args) > 0u) {\n                     popen(s);\n                     fn print_variant_arg(ps s, &ast::variant_arg arg) {\n                         print_type(s, arg.ty);\n@@ -360,7 +360,7 @@ fn print_literal(ps s, @ast::lit lit) {\n     alt (lit.node) {\n         case (ast::lit_str(?st)) {print_string(s, st);}\n         case (ast::lit_char(?ch)) {\n-            wrd(s.s, \"'\" + escape_str(_str::from_bytes([ch as u8]), '\\'')\n+            wrd(s.s, \"'\" + escape_str(str::from_bytes([ch as u8]), '\\'')\n                 + \"'\");\n         }\n         case (ast::lit_int(?val)) {\n@@ -436,7 +436,7 @@ fn print_expr(ps s, &@ast::expr expr) {\n             commasep_cmnt[ast::field](s, fields, f, gs);\n             alt (wth) {\n                 case (option::some[@ast::expr](?expr)) {\n-                    if (_vec::len[ast::field](fields) > 0u) {space(s.s);}\n+                    if (vec::len[ast::field](fields) > 0u) {space(s.s);}\n                     hbox(s);\n                     wrd1(s, \"with\");\n                     print_expr(s, expr);\n@@ -673,7 +673,7 @@ fn print_expr(ps s, &@ast::expr expr) {\n         case (ast::expr_ext(?path, ?args, ?body, _, _)) {\n             wrd(s.s, \"#\");\n             print_path(s, path);\n-            if (_vec::len[@ast::expr](args) > 0u) {\n+            if (vec::len[@ast::expr](args) > 0u) {\n                 popen(s);\n                 commasep_exprs(s, args);\n                 pclose(s);\n@@ -761,7 +761,7 @@ fn print_path(ps s, ast::path path) {\n         else {wrd(s.s, \"::\");}\n         wrd(s.s, id);\n     }\n-    if (_vec::len[@ast::ty](path.node.types) > 0u) {\n+    if (vec::len[@ast::ty](path.node.types) > 0u) {\n         wrd(s.s, \"[\");\n         auto f = print_type;\n         commasep[@ast::ty](s, path.node.types, f);\n@@ -777,7 +777,7 @@ fn print_pat(ps s, &@ast::pat pat) {\n         case (ast::pat_lit(?lit,_)) {print_literal(s, lit);}\n         case (ast::pat_tag(?path,?args,_)) {\n             print_path(s, path);\n-            if (_vec::len[@ast::pat](args) > 0u) {\n+            if (vec::len[@ast::pat](args) > 0u) {\n                 popen_h(s);\n                 auto f = print_pat;\n                 commasep[@ast::pat](s, args, f);\n@@ -822,7 +822,7 @@ fn print_fn(ps s, ast::fn_decl decl, str name,\n }\n \n fn print_type_params(ps s, vec[ast::ty_param] params) {\n-    if (_vec::len[ast::ty_param](params) > 0u) {\n+    if (vec::len[ast::ty_param](params) > 0u) {\n         wrd(s.s, \"[\");\n         fn printParam(ps s, &ast::ty_param param) {\n             wrd(s.s, param);\n@@ -840,7 +840,7 @@ fn print_view_item(ps s, @ast::view_item item) {\n         case (ast::view_item_use(?id,?mta,_,_)) {\n             wrd1(s, \"use\");\n             wrd(s.s, id);\n-            if (_vec::len[@ast::meta_item](mta) > 0u) {\n+            if (vec::len[@ast::meta_item](mta) > 0u) {\n                 popen(s);\n                 fn print_meta(ps s, &@ast::meta_item item) {\n                     hbox(s);\n@@ -856,7 +856,7 @@ fn print_view_item(ps s, @ast::view_item item) {\n         }\n         case (ast::view_item_import(?id,?ids,_)) {\n             wrd1(s, \"import\");\n-            if (!_str::eq(id, ids.(_vec::len[str](ids)-1u))) {\n+            if (!str::eq(id, ids.(vec::len[str](ids)-1u))) {\n                 wrd1(s, id);\n                 wrd1(s, \"=\");\n             }\n@@ -906,7 +906,7 @@ fn print_maybe_parens(ps s, @ast::expr expr, int outer_prec) {\n \n fn escape_str(str st, char to_escape) -> str {\n     let str out = \"\";\n-    auto len = _str::byte_len(st);\n+    auto len = str::byte_len(st);\n     auto i = 0u;\n     while (i < len) {\n         alt (st.(i) as char) {\n@@ -916,7 +916,7 @@ fn escape_str(str st, char to_escape) -> str {\n             case ('\\\\') {out += \"\\\\\\\\\";}\n             case (?cur) {\n                 if (cur == to_escape) {out += \"\\\\\";}\n-                _str::push_byte(out, cur as u8);\n+                str::push_byte(out, cur as u8);\n             }\n         }\n         i += 1u;\n@@ -966,7 +966,7 @@ fn print_ty_fn(ps s, ast::proto proto, option::t[str] id,\n fn next_comment(ps s) -> option::t[lexer::cmnt] {\n     alt (s.comments) {\n         case (option::some[vec[lexer::cmnt]](?cmnts)) {\n-            if (s.cur_cmnt < _vec::len[lexer::cmnt](cmnts)) {\n+            if (s.cur_cmnt < vec::len[lexer::cmnt](cmnts)) {\n                 ret option::some[lexer::cmnt](cmnts.(s.cur_cmnt));\n             } else {ret option::none[lexer::cmnt];}\n         }"}, {"sha": "206862c5f9b46d23a8f29eec82410424413d5313", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,8 +1,8 @@\n import std::map;\n import std::map::hashmap;\n-import std::_uint;\n-import std::_int;\n-import std::_vec;\n+import std::uint;\n+import std::int;\n+import std::vec;\n import std::option::none;\n import front::ast;\n import front::ast::ty;\n@@ -60,8 +60,8 @@ fn ty_mach_to_str(ty_mach tm) -> str {\n }\n \n fn new_str_hash[V]() -> std::map::hashmap[str,V] {\n-    let std::map::hashfn[str] hasher = std::_str::hash;\n-    let std::map::eqfn[str] eqer = std::_str::eq;\n+    let std::map::hashfn[str] hasher = std::str::hash;\n+    let std::map::eqfn[str] eqer = std::str::eq;\n     ret std::map::mk_hashmap[str,V](hasher, eqer);\n }\n \n@@ -99,25 +99,25 @@ fn new_uint_hash[V]() -> std::map::hashmap[uint,V] {\n }\n \n fn istr(int i) -> str {\n-    ret _int::to_str(i, 10u);\n+    ret int::to_str(i, 10u);\n }\n \n fn uistr(uint i) -> str {\n-    ret _uint::to_str(i, 10u);\n+    ret uint::to_str(i, 10u);\n }\n \n fn elt_expr(&ast::elt e) -> @ast::expr { ret e.expr; }\n \n fn elt_exprs(&vec[ast::elt] elts) -> vec[@ast::expr] {\n     auto f = elt_expr;\n-    ret _vec::map[ast::elt, @ast::expr](f, elts);\n+    ret vec::map[ast::elt, @ast::expr](f, elts);\n }\n \n fn field_expr(&ast::field f) -> @ast::expr { ret f.expr; }\n \n fn field_exprs(vec[ast::field] fields) -> vec [@ast::expr] {\n     auto f = field_expr;\n-    ret _vec::map[ast::field, @ast::expr](f, fields);\n+    ret vec::map[ast::field, @ast::expr](f, fields);\n }\n \n fn expr_to_str(&@ast::expr e) -> str {"}, {"sha": "60d6b3102f0eb5e40b4c03e0915c2fc1719d3984", "filename": "src/comp/util/interner.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Fcomp%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Finterner.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -2,7 +2,7 @@\n // allows bidirectional lookup; i.e. given a value, one can easily find the\n // type, and vice versa.\n \n-import std::_vec;\n+import std::vec;\n import std::map;\n import std::map::hashmap;\n import std::map::hashfn;\n@@ -28,7 +28,7 @@ fn intern[T](&interner[T] itr, &T val) -> uint {\n     alt (itr.map.find(val)) {\n         case (some[uint](?idx)) { ret idx; }\n         case (none[uint]) {\n-            auto new_idx = _vec::len[T](itr.vect);\n+            auto new_idx = vec::len[T](itr.vect);\n             itr.map.insert(val, new_idx);\n             itr.vect += [val];\n             ret new_idx;"}, {"sha": "708cc621868b0c61125338fe2b15bc14af2a95b5", "filename": "src/lib/bitv.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fbitv.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -21,19 +21,19 @@ fn create(uint nbits, bool init) -> t {\n         elt = 0u;\n     }\n \n-    auto storage = _vec::init_elt_mut[uint](elt, nbits / uint_bits() + 1u);\n+    auto storage = vec::init_elt_mut[uint](elt, nbits / uint_bits() + 1u);\n     ret rec(storage = storage, nbits = nbits);\n }\n \n fn process(&fn(uint, uint) -> uint op, &t v0, &t v1) -> bool {\n-    auto len = _vec::len(v1.storage);\n+    auto len = vec::len(v1.storage);\n \n-    assert (_vec::len(v0.storage) == len);\n+    assert (vec::len(v0.storage) == len);\n     assert (v0.nbits == v1.nbits);\n \n     auto changed = false;\n \n-    for each (uint i in _uint::range(0u, len)) {\n+    for each (uint i in uint::range(0u, len)) {\n         auto w0 = v0.storage.(i);\n         auto w1 = v1.storage.(i);\n \n@@ -75,9 +75,9 @@ fn copy(&t v0, t v1) -> bool {\n }\n \n fn clone(t v) -> t {\n-    auto storage = _vec::init_elt_mut[uint](0u, v.nbits / uint_bits() + 1u);\n-    auto len = _vec::len(v.storage);\n-    for each (uint i in _uint::range(0u, len)) {\n+    auto storage = vec::init_elt_mut[uint](0u, v.nbits / uint_bits() + 1u);\n+    auto len = vec::len(v.storage);\n+    for each (uint i in uint::range(0u, len)) {\n         storage.(i) = v.storage.(i);\n     }\n     ret rec(storage = storage, nbits = v.nbits);\n@@ -97,7 +97,7 @@ fn get(&t v, uint i) -> bool {\n fn equal(&t v0, &t v1) -> bool {\n     // FIXME: when we can break or return from inside an iterator loop,\n     //        we can eliminate this painful while-loop\n-    auto len = _vec::len(v1.storage);\n+    auto len = vec::len(v1.storage);\n     auto i = 0u;\n     while (i < len) {\n         if (v0.storage.(i) != v1.storage.(i)) {\n@@ -109,13 +109,13 @@ fn equal(&t v0, &t v1) -> bool {\n }\n \n fn clear(&t v) {\n-    for each (uint i in _uint::range(0u, _vec::len(v.storage))) {\n+    for each (uint i in uint::range(0u, vec::len(v.storage))) {\n         v.storage.(i) = 0u;\n     }\n }\n \n fn invert(&t v) {\n-    for each (uint i in _uint::range(0u, _vec::len(v.storage))) {\n+    for each (uint i in uint::range(0u, vec::len(v.storage))) {\n         v.storage.(i) = ~v.storage.(i);\n     }\n }\n@@ -176,7 +176,7 @@ fn init_to_vec(t v, uint i) -> uint {\n \n fn to_vec(&t v) -> vec[uint] {\n     auto sub = bind init_to_vec(v, _);\n-    ret _vec::init_fn[uint](sub, v.nbits);\n+    ret vec::init_fn[uint](sub, v.nbits);\n }\n \n fn to_str(&t v) -> str {\n@@ -196,7 +196,7 @@ fn to_str(&t v) -> str {\n \n // FIXME: can we just use structural equality on to_vec?\n fn eq_vec(&t v0, &vec[uint] v1) -> bool {\n-    assert (v0.nbits == _vec::len[uint](v1));\n+    assert (v0.nbits == vec::len[uint](v1));\n     auto len = v0.nbits;\n     auto i = 0u;\n     while (i < len) {"}, {"sha": "c1d719794246f7ddd5c349b531fd4cfe77139759", "filename": "src/lib/dbg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fdbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fdbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdbg.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -20,7 +20,7 @@ native \"rust\" mod rustrt {\n }\n \n fn debug_vec[T](vec[T] v) {\n-    _vec::print_debug_info[T](v);\n+    vec::print_debug_info[T](v);\n }\n \n fn debug_tydesc[T]() {"}, {"sha": "9da1651f04782dae33418a94383df8ee4eb4faa3", "filename": "src/lib/deque.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdeque.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -28,7 +28,7 @@ fn create[T]() -> t[T] {\n      * elsewhere.\n      */\n     fn grow[T](uint nelts, uint lo, vec[cell[T]] elts) -> vec[cell[T]] {\n-        assert (nelts == _vec::len[cell[T]](elts));\n+        assert (nelts == vec::len[cell[T]](elts));\n \n         fn fill[T](uint i, uint nelts, uint lo,\n                    vec[cell[T]] old) -> cell[T] {\n@@ -39,9 +39,9 @@ fn create[T]() -> t[T] {\n             }\n         }\n \n-        let uint nalloc = _uint::next_power_of_two(nelts + 1u);\n-        let _vec::init_op[cell[T]] copy_op = bind fill[T](_, nelts, lo, elts);\n-        ret _vec::init_fn[cell[T]](copy_op, nalloc);\n+        let uint nalloc = uint::next_power_of_two(nelts + 1u);\n+        let vec::init_op[cell[T]] copy_op = bind fill[T](_, nelts, lo, elts);\n+        ret vec::init_fn[cell[T]](copy_op, nalloc);\n     }\n \n     fn get[T](vec[cell[T]] elts, uint i) -> T {\n@@ -63,14 +63,14 @@ fn create[T]() -> t[T] {\n                 let uint oldlo = lo;\n \n                 if (lo == 0u) {\n-                    lo = _vec::len[cell[T]](elts) - 1u;\n+                    lo = vec::len[cell[T]](elts) - 1u;\n                 } else {\n                     lo -= 1u;\n                 }\n \n                 if (lo == hi) {\n                     elts = grow[T](nelts, oldlo, elts);\n-                    lo = _vec::len[cell[T]](elts) - 1u;\n+                    lo = vec::len[cell[T]](elts) - 1u;\n                     hi = nelts;\n                 }\n \n@@ -86,7 +86,7 @@ fn create[T]() -> t[T] {\n                 }\n \n                 elts.(hi) = option::some[T](t);\n-                hi = (hi + 1u) % _vec::len[cell[T]](elts);\n+                hi = (hi + 1u) % vec::len[cell[T]](elts);\n                 nelts += 1u;\n             }\n \n@@ -97,14 +97,14 @@ fn create[T]() -> t[T] {\n             fn pop_front() -> T {\n                 let T t = get[T](elts, lo);\n                 elts.(lo) = option::none[T];\n-                lo = (lo + 1u) % _vec::len[cell[T]](elts);\n+                lo = (lo + 1u) % vec::len[cell[T]](elts);\n                 nelts -= 1u;\n                 ret t;\n             }\n \n             fn pop_back() -> T {\n                 if (hi == 0u) {\n-                    hi = _vec::len[cell[T]](elts) - 1u;\n+                    hi = vec::len[cell[T]](elts) - 1u;\n                 } else {\n                     hi -= 1u;\n                 }\n@@ -124,12 +124,12 @@ fn create[T]() -> t[T] {\n             }\n \n             fn get(int i) -> T {\n-                let uint idx = (lo + (i as uint)) % _vec::len[cell[T]](elts);\n+                let uint idx = (lo + (i as uint)) % vec::len[cell[T]](elts);\n                 ret get[T](elts, idx);\n             }\n \n         }\n-    let vec[cell[T]] v = _vec::init_elt[cell[T]](option::none[T],\n+    let vec[cell[T]] v = vec::init_elt[cell[T]](option::none[T],\n                                                 initial_capacity);\n \n     ret deque[T](0u, 0u, 0u, v);"}, {"sha": "62f90decf932c14b7a470005145819ac9141ec10", "filename": "src/lib/ebml.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Febml.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -38,7 +38,7 @@ fn vint_at(vec[u8] data, uint start) -> tup(uint, uint) {\n }\n \n fn new_doc(vec[u8] data) -> doc {\n-    ret rec(data=data, start=0u, end=_vec::len[u8](data));\n+    ret rec(data=data, start=0u, end=vec::len[u8](data));\n }\n \n fn doc_at(vec[u8] data, uint start) -> doc {\n@@ -65,7 +65,7 @@ fn get_doc(doc d, uint tg) -> doc {\n     alt (maybe_get_doc(d, tg)) {\n         case (some[doc](?d)) {ret d;}\n         case (none[doc]) {\n-            log_err \"failed to find block with tag \" + _uint::to_str(tg, 10u);\n+            log_err \"failed to find block with tag \" + uint::to_str(tg, 10u);\n             fail;\n         }\n     }\n@@ -94,7 +94,7 @@ iter tagged_docs(doc d, uint tg) -> doc {\n }\n \n fn doc_data(doc d) -> vec[u8] {\n-    ret _vec::slice[u8](d.data, d.start, d.end);\n+    ret vec::slice[u8](d.data, d.start, d.end);\n }\n \n fn be_uint_from_bytes(vec[u8] data, uint start, uint size) -> uint {\n@@ -175,7 +175,7 @@ fn start_tag(&writer w, uint tag_id) {\n }\n \n fn end_tag(&writer w) {\n-    auto last_size_pos = _vec::pop[uint](w.size_positions);\n+    auto last_size_pos = vec::pop[uint](w.size_positions);\n     auto cur_pos = w.writer.tell();\n     w.writer.seek(last_size_pos as int, io::seek_set);\n     write_sized_vint(w.writer, cur_pos - last_size_pos - 4u, 4u);"}, {"sha": "b74d12c84d470063b37c6f918037011de33737aa", "filename": "src/lib/extfmt.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fextfmt.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -80,11 +80,11 @@ mod ct {\n \n     fn parse_fmt_string(str s) -> vec[piece] {\n         let vec[piece] pieces = [];\n-        auto lim = _str::byte_len(s);\n+        auto lim = str::byte_len(s);\n         auto buf = \"\";\n \n         fn flush_buf(str buf, &vec[piece] pieces) -> str {\n-            if (_str::byte_len(buf) > 0u) {\n+            if (str::byte_len(buf) > 0u) {\n                 auto piece = piece_string(buf);\n                 pieces += [piece];\n             }\n@@ -93,15 +93,15 @@ mod ct {\n \n         auto i = 0u;\n         while (i < lim) {\n-            auto curr = _str::substr(s, i, 1u);\n-            if (_str::eq(curr, \"%\")) {\n+            auto curr = str::substr(s, i, 1u);\n+            if (str::eq(curr, \"%\")) {\n                 i += 1u;\n                 if (i >= lim) {\n                     log_err \"unterminated conversion at end of string\";\n                     fail;\n                 }\n-                auto curr2 = _str::substr(s, i, 1u);\n-                if (_str::eq(curr2, \"%\")) {\n+                auto curr2 = str::substr(s, i, 1u);\n+                if (str::eq(curr2, \"%\")) {\n                     i += 1u;\n                 } else {\n                     buf = flush_buf(buf, pieces);\n@@ -270,27 +270,27 @@ mod ct {\n         }\n \n         auto t;\n-        auto tstr = _str::substr(s, i, 1u);\n-        if (_str::eq(tstr, \"b\")) {\n+        auto tstr = str::substr(s, i, 1u);\n+        if (str::eq(tstr, \"b\")) {\n             t = ty_bool;\n-        } else if (_str::eq(tstr, \"s\")) {\n+        } else if (str::eq(tstr, \"s\")) {\n             t = ty_str;\n-        } else if (_str::eq(tstr, \"c\")) {\n+        } else if (str::eq(tstr, \"c\")) {\n             t = ty_char;\n-        } else if (_str::eq(tstr, \"d\")\n-                   || _str::eq(tstr, \"i\")) {\n+        } else if (str::eq(tstr, \"d\")\n+                   || str::eq(tstr, \"i\")) {\n             // TODO: Do we really want two signed types here?\n             // How important is it to be printf compatible?\n             t = ty_int(signed);\n-        } else if (_str::eq(tstr, \"u\")) {\n+        } else if (str::eq(tstr, \"u\")) {\n             t = ty_int(unsigned);\n-        } else if (_str::eq(tstr, \"x\")) {\n+        } else if (str::eq(tstr, \"x\")) {\n             t = ty_hex(case_lower);\n-        } else if (_str::eq(tstr, \"X\")) {\n+        } else if (str::eq(tstr, \"X\")) {\n             t = ty_hex(case_upper);\n-        } else if (_str::eq(tstr, \"t\")) {\n+        } else if (str::eq(tstr, \"t\")) {\n             t = ty_bits;\n-        } else if (_str::eq(tstr, \"o\")) {\n+        } else if (str::eq(tstr, \"o\")) {\n             t = ty_octal;\n         } else {\n             log_err \"unknown type in conversion\";\n@@ -364,7 +364,7 @@ mod rt {\n                 res = uint_to_str_prec(u, 16u, prec);\n             }\n             case (ty_hex_upper) {\n-                res = _str::to_upper(uint_to_str_prec(u, 16u, prec));\n+                res = str::to_upper(uint_to_str_prec(u, 16u, prec));\n             }\n             case (ty_bits) {\n                 res = uint_to_str_prec(u, 2u, prec);\n@@ -389,7 +389,7 @@ mod rt {\n     }\n \n     fn conv_char(&conv cv, char c) -> str {\n-        ret pad(cv, _str::from_char(c), pad_nozero);\n+        ret pad(cv, str::from_char(c), pad_nozero);\n     }\n \n     fn conv_str(&conv cv, str s) -> str {\n@@ -399,9 +399,9 @@ mod rt {\n             }\n             case (count_is(?max)) {\n                 // For strings, precision is the maximum characters displayed\n-                if (max as uint < _str::char_len(s)) {\n+                if (max as uint < str::char_len(s)) {\n                     // FIXME: substr works on bytes, not chars!\n-                    unpadded = _str::substr(s, 0u, max as uint);\n+                    unpadded = str::substr(s, 0u, max as uint);\n                 }\n             }\n         }\n@@ -420,15 +420,15 @@ mod rt {\n \n     // Convert a uint to string with a minimum number of digits.  If precision\n     // is 0 and num is 0 then the result is the empty string. Could move this\n-    // to _uint: but it doesn't seem all that useful.\n+    // to uint: but it doesn't seem all that useful.\n     fn uint_to_str_prec(uint num, uint radix, uint prec) -> str {\n         auto s;\n \n         if (prec == 0u && num == 0u) {\n             s = \"\";\n         } else {\n-            s = _uint::to_str(num, radix);\n-            auto len = _str::char_len(s);\n+            s = uint::to_str(num, radix);\n+            auto len = str::char_len(s);\n             if (len < prec) {\n                 auto diff = prec - len;\n                 auto pad = str_init_elt('0', diff);\n@@ -450,12 +450,12 @@ mod rt {\n         }\n     }\n \n-    // FIXME: This might be useful in _str: but needs to be utf8 safe first\n+    // FIXME: This might be useful in str: but needs to be utf8 safe first\n     fn str_init_elt(char c, uint n_elts) -> str {\n-        auto svec = _vec::init_elt[u8](c as u8, n_elts);\n+        auto svec = vec::init_elt[u8](c as u8, n_elts);\n         // FIXME: Using unsafe_from_bytes because rustboot\n         // can't figure out the is_utf8 predicate on from_bytes?\n-        ret _str::unsafe_from_bytes(svec);\n+        ret str::unsafe_from_bytes(svec);\n     }\n \n     tag pad_mode {\n@@ -476,7 +476,7 @@ mod rt {\n             }\n         }\n \n-        auto strlen = _str::char_len(s);\n+        auto strlen = str::char_len(s);\n         if (uwidth <= strlen) {\n             ret s;\n         }\n@@ -532,16 +532,16 @@ mod rt {\n         // instead.\n         if (signed\n             && zero_padding\n-            && _str::byte_len(s) > 0u) {\n+            && str::byte_len(s) > 0u) {\n \n             auto head = s.(0);\n             if (head == '+' as u8\n                 || head == '-' as u8\n                 || head == ' ' as u8) {\n \n-                auto headstr = _str::unsafe_from_bytes([head]);\n-                auto bytelen = _str::byte_len(s);\n-                auto numpart = _str::substr(s, 1u, bytelen - 1u);\n+                auto headstr = str::unsafe_from_bytes([head]);\n+                auto bytelen = str::byte_len(s);\n+                auto numpart = str::substr(s, 1u, bytelen - 1u);\n                 ret headstr + padstr + numpart;\n             }\n         }"}, {"sha": "51c1ff9cdde52d8646f7ab1ad95d88b0e29ae8a9", "filename": "src/lib/fs.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ffs.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -3,24 +3,24 @@ native \"rust\" mod rustrt {\n }\n \n fn path_sep() -> str {\n-    ret _str::from_char(os_fs::path_sep);\n+    ret str::from_char(os_fs::path_sep);\n }\n \n type path = str;\n \n fn dirname(path p) -> path {\n-    let int i = _str::rindex(p, os_fs::path_sep as u8);\n+    let int i = str::rindex(p, os_fs::path_sep as u8);\n     if (i == -1) {\n-        i = _str::rindex(p, os_fs::alt_path_sep as u8);\n+        i = str::rindex(p, os_fs::alt_path_sep as u8);\n         if (i == -1) {\n             ret p;\n         }\n     }\n-    ret _str::substr(p, 0u, i as uint);\n+    ret str::substr(p, 0u, i as uint);\n }\n \n fn connect(path pre, path post) -> path {\n-    auto len = _str::byte_len(pre);\n+    auto len = str::byte_len(pre);\n     if (pre.(len - 1u) == (os_fs::path_sep as u8)) { // Trailing '/'?\n         ret pre + post;\n     }\n@@ -32,14 +32,14 @@ fn file_is_dir(path p) -> bool {\n }\n \n fn list_dir(path p) -> vec[str] {\n-  auto pl = _str::byte_len(p);\n+  auto pl = str::byte_len(p);\n   if (pl == 0u || p.(pl - 1u) as char != os_fs::path_sep) {\n     p += path_sep();\n   }\n   let vec[str] full_paths = [];\n   for (str filename in os_fs::list_dir(p)) {\n-    if (!_str::eq(filename, \".\")) {if (!_str::eq(filename, \"..\")) {\n-      _vec::push[str](full_paths, p + filename);\n+    if (!str::eq(filename, \".\")) {if (!str::eq(filename, \"..\")) {\n+      vec::push[str](full_paths, p + filename);\n     }}\n   }\n   ret full_paths;"}, {"sha": "4c8d27a5d202efd01871bfcfbfea45732c255c17", "filename": "src/lib/generic_os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fgeneric_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fgeneric_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fgeneric_os.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,9 +1,9 @@\n fn getenv(str n) -> option::t[str] {\n-  auto s = os::libc::getenv(_str::buf(n));\n+  auto s = os::libc::getenv(str::buf(n));\n   if ((s as int) == 0) {\n     ret option::none[str];\n   } else {\n-    ret option::some[str](_str::str_from_cstr(s));\n+    ret option::some[str](str::str_from_cstr(s));\n   }\n }\n "}, {"sha": "c3b485a43b06d22c2e14f7429639099b42317ec0", "filename": "src/lib/getopts.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fgetopts.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -17,7 +17,7 @@ tag occur { req; optional; multi; }\n type opt = rec(name name, hasarg hasarg, occur occur);\n \n fn mkname(str nm) -> name {\n-    if (_str::char_len(nm) == 1u) { ret short(_str::char_at(nm, 0u)); }\n+    if (str::char_len(nm) == 1u) { ret short(str::char_at(nm, 0u)); }\n     else { ret long(nm); }\n }\n fn reqopt(str name) -> opt {\n@@ -41,11 +41,11 @@ tag optval {\n type match = rec(vec[opt] opts, vec[mutable vec[optval]] vals, vec[str] free);\n \n fn is_arg(str arg) -> bool {\n-    ret _str::byte_len(arg) > 1u && arg.(0) == '-' as u8;\n+    ret str::byte_len(arg) > 1u && arg.(0) == '-' as u8;\n }\n fn name_str(name nm) -> str {\n     alt (nm) {\n-        case (short(?ch)) {ret _str::from_char(ch);}\n+        case (short(?ch)) {ret str::from_char(ch);}\n         case (long(?s)) {ret s;}\n     }\n }\n@@ -55,7 +55,7 @@ fn name_eq(name a, name b) -> bool {\n     alt (a) {\n         case (long(?a)) {\n             alt (b) {\n-                case (long(?b)) { ret _str::eq(a, b); }\n+                case (long(?b)) { ret str::eq(a, b); }\n                 case (_) { ret false; }\n             }\n         }\n@@ -64,7 +64,7 @@ fn name_eq(name a, name b) -> bool {\n }\n fn find_opt(vec[opt] opts, name nm) -> option::t[uint] {\n     auto i = 0u;\n-    auto l = _vec::len[opt](opts);\n+    auto l = vec::len[opt](opts);\n     while (i < l) {\n         if (name_eq(opts.(i).name, nm)) { ret some[uint](i); }\n         i += 1u;\n@@ -102,41 +102,41 @@ tag result {\n }\n \n fn getopts(vec[str] args, vec[opt] opts) -> result {\n-    auto n_opts = _vec::len[opt](opts);\n-    fn empty_(uint x) -> vec[optval]{ret _vec::empty[optval]();}\n+    auto n_opts = vec::len[opt](opts);\n+    fn empty_(uint x) -> vec[optval]{ret vec::empty[optval]();}\n     auto f = empty_;\n-    auto vals = _vec::init_fn_mut[vec[optval]](f, n_opts);\n+    auto vals = vec::init_fn_mut[vec[optval]](f, n_opts);\n     let vec[str] free = [];\n \n-    auto l = _vec::len[str](args);\n+    auto l = vec::len[str](args);\n     auto i = 0u;\n     while (i < l) {\n         auto cur = args.(i);\n-        auto curlen = _str::byte_len(cur);\n+        auto curlen = str::byte_len(cur);\n         if (!is_arg(cur)) {\n-            _vec::push[str](free, cur);\n-        } else if (_str::eq(cur, \"--\")) {\n-            free += _vec::slice[str](args, i + 1u, l);\n+            vec::push[str](free, cur);\n+        } else if (str::eq(cur, \"--\")) {\n+            free += vec::slice[str](args, i + 1u, l);\n             break;\n         } else {\n             auto names;\n             auto i_arg = option::none[str];\n             if (cur.(1) == '-' as u8) {\n-                auto tail = _str::slice(cur, 2u, curlen);\n-                auto eq = _str::index(tail, '=' as u8);\n+                auto tail = str::slice(cur, 2u, curlen);\n+                auto eq = str::index(tail, '=' as u8);\n                 if (eq == -1) {\n                     names = [long(tail)];\n                 } else {\n-                    names = [long(_str::slice(tail, 0u, eq as uint))];\n+                    names = [long(str::slice(tail, 0u, eq as uint))];\n                     i_arg = option::some[str]\n-                        (_str::slice(tail, (eq as uint) + 1u, curlen - 2u));\n+                        (str::slice(tail, (eq as uint) + 1u, curlen - 2u));\n                 }\n             } else {\n                 auto j = 1u;\n                 names = [];\n                 while (j < curlen) {\n-                    auto range = _str::char_range_at(cur, j);\n-                    _vec::push[name](names, short(range._0));\n+                    auto range = str::char_range_at(cur, j);\n+                    vec::push[name](names, short(range._0));\n                     j = range._1;\n                 }\n             }\n@@ -152,29 +152,29 @@ fn getopts(vec[str] args, vec[opt] opts) -> result {\n                 }\n                 alt (opts.(optid).hasarg) {\n                     case (no) {\n-                        _vec::push[optval](vals.(optid), given);\n+                        vec::push[optval](vals.(optid), given);\n                     }\n                     case (maybe) {\n                         if (!option::is_none[str](i_arg)) {\n-                            _vec::push[optval](vals.(optid),\n+                            vec::push[optval](vals.(optid),\n                                               val(option::get[str](i_arg)));\n-                        } else if (name_pos < _vec::len[name](names) ||\n+                        } else if (name_pos < vec::len[name](names) ||\n                                    i + 1u == l || is_arg(args.(i + 1u))) {\n-                            _vec::push[optval](vals.(optid), given);\n+                            vec::push[optval](vals.(optid), given);\n                         } else {\n                             i += 1u;\n-                            _vec::push[optval](vals.(optid), val(args.(i)));\n+                            vec::push[optval](vals.(optid), val(args.(i)));\n                         }\n                     }\n                     case (yes) {\n                         if (!option::is_none[str](i_arg)) {\n-                            _vec::push[optval](vals.(optid),\n+                            vec::push[optval](vals.(optid),\n                                               val(option::get[str](i_arg)));\n                         } else if (i + 1u == l) {\n                             ret failure(argument_missing(name_str(nm)));\n                         } else {\n                             i += 1u;\n-                            _vec::push[optval](vals.(optid), val(args.(i)));\n+                            vec::push[optval](vals.(optid), val(args.(i)));\n                         }\n                     }\n                 }\n@@ -185,7 +185,7 @@ fn getopts(vec[str] args, vec[opt] opts) -> result {\n \n     i = 0u;\n     while (i < n_opts) {\n-        auto n = _vec::len[optval](vals.(i));\n+        auto n = vec::len[optval](vals.(i));\n         auto occ = opts.(i).occur;\n         if (occ == req) {if (n == 0u) {\n             ret failure(option_missing(name_str(opts.(i).name)));\n@@ -212,7 +212,7 @@ fn opt_val(match m, str nm) -> optval {\n     ret opt_vals(m, nm).(0);\n }\n fn opt_present(match m, str nm) -> bool {\n-    ret _vec::len[optval](opt_vals(m, nm)) > 0u;\n+    ret vec::len[optval](opt_vals(m, nm)) > 0u;\n }\n fn opt_str(match m, str nm) -> str {\n     alt (opt_val(m, nm)) {\n@@ -224,15 +224,15 @@ fn opt_strs(match m, str nm) -> vec[str] {\n     let vec[str] acc = [];\n     for (optval v in opt_vals(m, nm)) {\n         alt (v) {\n-            case (val(?s)) { _vec::push[str](acc, s); }\n+            case (val(?s)) { vec::push[str](acc, s); }\n             case (_) {}\n         }\n     }\n     ret acc;\n }\n fn opt_maybe_str(match m, str nm) -> option::t[str] {\n     auto vals = opt_vals(m, nm);\n-    if (_vec::len[optval](vals) == 0u) { ret none[str]; }\n+    if (vec::len[optval](vals) == 0u) { ret none[str]; }\n     alt (vals.(0)) {\n         case (val(?s)) { ret some[str](s); }\n         case (_) { ret none[str]; }"}, {"sha": "1e253b3857cbe6cfcfdd1dc567f81fe7c05cb952", "filename": "src/lib/int.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fint.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -29,9 +29,9 @@ fn to_str(int n, uint radix) -> str\n {\n     assert (0u < radix && radix <= 16u);\n     if (n < 0) {\n-        ret \"-\" + _uint::to_str((-n) as uint, radix);\n+        ret \"-\" + uint::to_str((-n) as uint, radix);\n     } else {\n-        ret _uint::to_str(n as uint, radix);\n+        ret uint::to_str(n as uint, radix);\n     }\n }\n ", "previous_filename": "src/lib/_int.rs"}, {"sha": "b79c09e0ef578fc3f3b69ae93d0ac470380865fd", "filename": "src/lib/io.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fio.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -57,9 +57,9 @@ fn convert_whence(seek_style whence) -> int {\n \n state obj FILE_buf_reader(os::libc::FILE f, bool must_close) {\n     fn read(uint len) -> vec[u8] {\n-        auto buf = _vec::alloc[u8](len);\n-        auto read = os::libc::fread(_vec::buf[u8](buf), 1u, len, f);\n-        _vec::len_set[u8](buf, read);\n+        auto buf = vec::alloc[u8](len);\n+        auto read = os::libc::fread(vec::buf[u8](buf), 1u, len, f);\n+        vec::len_set[u8](buf, read);\n         ret buf;\n     }\n     fn read_byte() -> int {\n@@ -100,7 +100,7 @@ state obj new_reader(buf_reader rdr) {\n         auto c0 = rdr.read_byte();\n         if (c0 == -1) {ret -1 as char;} // FIXME will this stay valid?\n         auto b0 = c0 as u8;\n-        auto w = _str::utf8_char_width(b0);\n+        auto w = str::utf8_char_width(b0);\n         assert (w > 0u);\n         if (w == 1u) {ret b0 as char;}\n         auto val = 0u;\n@@ -112,7 +112,7 @@ state obj new_reader(buf_reader rdr) {\n             val <<= 6u;\n             val += (next & 0x3f) as uint;\n         }\n-        // See _str::char_at\n+        // See str::char_at\n         val += ((b0 << ((w + 1u) as u8)) as uint) << ((w - 1u) * 6u - w - 1u);\n         ret val as char;\n     }\n@@ -126,19 +126,19 @@ state obj new_reader(buf_reader rdr) {\n         while (go_on) {\n             auto ch = rdr.read_byte();\n             if (ch == -1 || ch == 10) {go_on = false;}\n-            else {_vec::push[u8](buf, ch as u8);}\n+            else {vec::push[u8](buf, ch as u8);}\n         }\n-        ret _str::unsafe_from_bytes(buf);\n+        ret str::unsafe_from_bytes(buf);\n     }\n     fn read_c_str() -> str {\n         let vec[u8] buf = [];\n         auto go_on = true;\n         while (go_on) {\n             auto ch = rdr.read_byte();\n             if (ch < 1) {go_on = false;}\n-            else {_vec::push[u8](buf, ch as u8);}\n+            else {vec::push[u8](buf, ch as u8);}\n         }\n-        ret _str::unsafe_from_bytes(buf);\n+        ret str::unsafe_from_bytes(buf);\n     }\n     // FIXME deal with eof?\n     fn read_le_uint(uint size) -> uint {\n@@ -191,7 +191,7 @@ fn stdin() -> reader {\n }\n \n fn file_reader(str path) -> reader {\n-    auto f = os::libc::fopen(_str::buf(path), _str::buf(\"r\"));\n+    auto f = os::libc::fopen(str::buf(path), str::buf(\"r\"));\n     if (f as uint == 0u) {\n         log_err \"error opening \" + path;\n         fail;\n@@ -212,17 +212,17 @@ type byte_buf = @rec(vec[u8] buf, mutable uint pos);\n \n state obj byte_buf_reader(byte_buf bbuf) {\n     fn read(uint len) -> vec[u8] {\n-        auto rest = _vec::len[u8](bbuf.buf) - bbuf.pos;\n+        auto rest = vec::len[u8](bbuf.buf) - bbuf.pos;\n         auto to_read = len;\n         if (rest < to_read) {\n             to_read = rest;\n         }\n-        auto range = _vec::slice[u8](bbuf.buf, bbuf.pos, bbuf.pos + to_read);\n+        auto range = vec::slice[u8](bbuf.buf, bbuf.pos, bbuf.pos + to_read);\n         bbuf.pos += to_read;\n         ret range;\n     }\n     fn read_byte() -> int {\n-        if (bbuf.pos == _vec::len[u8](bbuf.buf)) {ret -1;}\n+        if (bbuf.pos == vec::len[u8](bbuf.buf)) {ret -1;}\n         auto b = bbuf.buf.(bbuf.pos);\n         bbuf.pos += 1u;\n         ret b as int;\n@@ -234,12 +234,12 @@ state obj byte_buf_reader(byte_buf bbuf) {\n     }\n \n     fn eof() -> bool {\n-        ret bbuf.pos == _vec::len[u8](bbuf.buf);\n+        ret bbuf.pos == vec::len[u8](bbuf.buf);\n     }\n \n     fn seek(int offset, seek_style whence) {\n         auto pos = bbuf.pos;\n-        auto len = _vec::len[u8](bbuf.buf);\n+        auto len = vec::len[u8](bbuf.buf);\n         bbuf.pos = seek_in_buf(offset, pos, len, whence);\n     }\n \n@@ -270,8 +270,8 @@ type buf_writer = state obj {\n \n state obj FILE_writer(os::libc::FILE f, bool must_close) {\n     fn write(vec[u8] v) {\n-        auto len = _vec::len[u8](v);\n-        auto vbuf = _vec::buf[u8](v);\n+        auto len = vec::len[u8](v);\n+        auto vbuf = vec::buf[u8](v);\n         auto nout = os::libc::fwrite(vbuf, len, 1u, f);\n         if (nout < 1u) {\n             log_err \"error dumping buffer\";\n@@ -293,11 +293,11 @@ state obj FILE_writer(os::libc::FILE f, bool must_close) {\n \n state obj fd_buf_writer(int fd, bool must_close) {\n     fn write(vec[u8] v) {\n-        auto len = _vec::len[u8](v);\n+        auto len = vec::len[u8](v);\n         auto count = 0u;\n         auto vbuf;\n         while (count < len) {\n-            vbuf = _vec::buf_off[u8](v, count);\n+            vbuf = vec::buf_off[u8](v, count);\n             auto nout = os::libc::write(fd, vbuf, len);\n             if (nout < 0) {\n                 log_err \"error dumping buffer\";\n@@ -337,7 +337,7 @@ fn file_buf_writer(str path, vec[fileflag] flags) -> buf_writer {\n         }\n     }\n \n-    auto fd = os::libc::open(_str::buf(path),\n+    auto fd = os::libc::open(str::buf(path),\n                            fflags,\n                            os::libc_constants::S_IRUSR() |\n                            os::libc_constants::S_IWUSR());\n@@ -390,17 +390,17 @@ state obj new_writer(buf_writer out) {\n         ret out;\n     }\n     fn write_str(str s) {\n-        out.write(_str::bytes(s));\n+        out.write(str::bytes(s));\n     }\n     fn write_char(char ch) {\n         // FIXME needlessly consy\n-        out.write(_str::bytes(_str::from_char(ch)));\n+        out.write(str::bytes(str::from_char(ch)));\n     }\n     fn write_int(int n) {\n-        out.write(_str::bytes(_int::to_str(n, 10u)));\n+        out.write(str::bytes(int::to_str(n, 10u)));\n     }\n     fn write_uint(uint n) {\n-        out.write(_str::bytes(_uint::to_str(n, 10u)));\n+        out.write(str::bytes(uint::to_str(n, 10u)));\n     }\n     fn write_bytes(vec[u8] bytes) {\n         out.write(bytes);\n@@ -427,7 +427,7 @@ fn file_writer(str path, vec[fileflag] flags) -> writer {\n \n // FIXME: fileflags\n fn buffered_file_buf_writer(str path) -> buf_writer {\n-    auto f = os::libc::fopen(_str::buf(path), _str::buf(\"w\"));\n+    auto f = os::libc::fopen(str::buf(path), str::buf(\"w\"));\n     if (f as uint == 0u) {\n         log_err \"error opening \" + path;\n         fail;\n@@ -451,21 +451,21 @@ type mutable_byte_buf = @rec(mutable vec[mutable u8] buf, mutable uint pos);\n state obj byte_buf_writer(mutable_byte_buf buf) {\n     fn write(vec[u8] v) {\n         // Fast path.\n-        if (buf.pos == _vec::len(buf.buf)) {\n+        if (buf.pos == vec::len(buf.buf)) {\n             // FIXME: Fix our type system. There's no reason you shouldn't be\n             // able to add a mutable vector to an immutable one.\n-            auto mv = _vec::rustrt::unsafe_vec_to_mut[u8](v);\n+            auto mv = vec::rustrt::unsafe_vec_to_mut[u8](v);\n             buf.buf += mv;\n-            buf.pos += _vec::len[u8](v);\n+            buf.pos += vec::len[u8](v);\n             ret;\n         }\n \n         // FIXME: Optimize: These should be unique pointers.\n-        auto vlen = _vec::len[u8](v);\n+        auto vlen = vec::len[u8](v);\n         auto vpos = 0u;\n         while (vpos < vlen) {\n             auto b = v.(vpos);\n-            if (buf.pos == _vec::len(buf.buf)) {\n+            if (buf.pos == vec::len(buf.buf)) {\n                 buf.buf += [mutable b];\n             } else {\n                 buf.buf.(buf.pos) = b;\n@@ -477,7 +477,7 @@ state obj byte_buf_writer(mutable_byte_buf buf) {\n \n     fn seek(int offset, seek_style whence) {\n         auto pos = buf.pos;\n-        auto len = _vec::len(buf.buf);\n+        auto len = vec::len(buf.buf);\n         buf.pos = seek_in_buf(offset, pos, len, whence);\n     }\n \n@@ -487,12 +487,12 @@ state obj byte_buf_writer(mutable_byte_buf buf) {\n fn string_writer() -> str_writer {\n     // FIXME: yikes, this is bad. Needs fixing of mutable syntax.\n     let vec[mutable u8] b = [mutable 0u8];\n-    _vec::pop(b);\n+    vec::pop(b);\n \n     let mutable_byte_buf buf = @rec(mutable buf = b, mutable pos = 0u);\n     state obj str_writer_wrap(writer wr, mutable_byte_buf buf) {\n         fn get_writer() -> writer {ret wr;}\n-        fn get_str() -> str {ret _str::unsafe_from_bytes(buf.buf);}\n+        fn get_str() -> str {ret str::unsafe_from_bytes(buf.buf);}\n     }\n     ret str_writer_wrap(new_writer(byte_buf_writer(buf)), buf);\n }"}, {"sha": "73e4e948ffab183696b7d331dc6a9fa42a72d23a", "filename": "src/lib/linux_os.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Flinux_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Flinux_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flinux_os.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,5 +1,5 @@\n-import _str::sbuf;\n-import _vec::vbuf;\n+import str::sbuf;\n+import vec::vbuf;\n \n // FIXME Somehow merge stuff duplicated here and macosx_os.rs. Made difficult\n // by https://github.com/graydon/rust/issues#issue/268\n@@ -66,17 +66,17 @@ fn dylib_filename(str base) -> str {\n \n fn pipe() -> tup(int, int) {\n     let vec[mutable int] fds = [mutable 0, 0];\n-    assert (os::libc::pipe(_vec::buf(fds)) == 0);\n+    assert (os::libc::pipe(vec::buf(fds)) == 0);\n     ret tup(fds.(0), fds.(1));\n }\n \n fn fd_FILE(int fd) -> libc::FILE {\n-    ret libc::fdopen(fd, _str::buf(\"r\"));\n+    ret libc::fdopen(fd, str::buf(\"r\"));\n }\n \n fn waitpid(int pid) -> int {\n     let vec[mutable int] status = [mutable 0];\n-    assert (os::libc::waitpid(pid, _vec::buf(status), 0) != -1);\n+    assert (os::libc::waitpid(pid, vec::buf(status), 0) != -1);\n     ret status.(0);\n }\n "}, {"sha": "27fd762620de0697c3f56acf7ff3565557a0e2a5", "filename": "src/lib/macos_os.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fmacos_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fmacos_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmacos_os.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,5 +1,5 @@\n-import _str::sbuf;\n-import _vec::vbuf;\n+import str::sbuf;\n+import vec::vbuf;\n \n native mod libc = \"libc.dylib\" {\n \n@@ -63,17 +63,17 @@ fn dylib_filename(str base) -> str {\n \n fn pipe() -> tup(int, int) {\n     let vec[mutable int] fds = [mutable 0, 0];\n-    assert (os::libc::pipe(_vec::buf(fds)) == 0);\n+    assert (os::libc::pipe(vec::buf(fds)) == 0);\n     ret tup(fds.(0), fds.(1));\n }\n \n fn fd_FILE(int fd) -> libc::FILE {\n-    ret libc::fdopen(fd, _str::buf(\"r\"));\n+    ret libc::fdopen(fd, str::buf(\"r\"));\n }\n \n fn waitpid(int pid) -> int {\n     let vec[mutable int] status = [mutable 0];\n-    assert (os::libc::waitpid(pid, _vec::buf(status), 0) != -1);\n+    assert (os::libc::waitpid(pid, vec::buf(status), 0) != -1);\n     ret status.(0);\n }\n "}, {"sha": "8e63369cebb606db1c9e678786ceee3a08a6294c", "filename": "src/lib/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -29,7 +29,7 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n     }\n \n     fn make_buckets[K, V](uint nbkts) -> vec[mutable bucket[K, V]] {\n-        ret _vec::init_elt_mut[bucket[K, V]](nil[K, V], nbkts);\n+        ret vec::init_elt_mut[bucket[K, V]](nil[K, V], nbkts);\n     }\n \n     // Derive two hash functions from the one given by taking the upper\n@@ -148,7 +148,7 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n                 let util::rational load = rec(num=(nelts + 1u) as int,\n                                              den=nbkts as int);\n                 if (!util::rational_leq(load, lf)) {\n-                    let uint nnewbkts = _uint::next_power_of_two(nbkts + 1u);\n+                    let uint nnewbkts = uint::next_power_of_two(nbkts + 1u);\n                     let vec[mutable bucket[K, V]] newbkts =\n                         make_buckets[K, V](nnewbkts);\n                     rehash[K, V](hasher, eqer, bkts, nbkts,"}, {"sha": "4c90f02b312174ffd51be3752e7af5d88ff9aef7", "filename": "src/lib/posix_fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fposix_fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fposix_fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fposix_fs.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -4,7 +4,7 @@ native \"rust\" mod rustrt {\n \n fn list_dir(str path) -> vec[str] {\n   // TODO ensure this is always closed\n-  auto dir = os::libc::opendir(_str::buf(path));\n+  auto dir = os::libc::opendir(str::buf(path));\n   assert (dir as uint != 0u);\n   let vec[str] result = [];\n   while (true) {\n@@ -13,7 +13,7 @@ fn list_dir(str path) -> vec[str] {\n         os::libc::closedir(dir);\n         ret result;\n     }\n-    _vec::push[str](result, rustrt::rust_dirent_filename(ent));\n+    vec::push[str](result, rustrt::rust_dirent_filename(ent));\n   }\n   os::libc::closedir(dir);\n   ret result;"}, {"sha": "b4f2e5c9d1b6c4f4f088521908bd27a7f7ab5a23", "filename": "src/lib/run_program.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Frun_program.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Frun_program.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Frun_program.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,21 +1,21 @@\n-import _str::sbuf;\n-import _vec::vbuf;\n+import str::sbuf;\n+import vec::vbuf;\n \n native \"rust\" mod rustrt {\n     fn rust_run_program(vbuf argv, int in_fd, int out_fd, int err_fd) -> int;\n }\n \n fn arg_vec(str prog, vec[str] args) -> vec[sbuf] {\n-    auto argptrs = [_str::buf(prog)];\n+    auto argptrs = [str::buf(prog)];\n     for (str arg in args) {\n-        _vec::push[sbuf](argptrs, _str::buf(arg));\n+        vec::push[sbuf](argptrs, str::buf(arg));\n     }\n-    _vec::push[sbuf](argptrs, 0 as sbuf);\n+    vec::push[sbuf](argptrs, 0 as sbuf);\n     ret argptrs;\n }\n \n fn run_program(str prog, vec[str] args) -> int {\n-    auto pid = rustrt::rust_run_program(_vec::buf[sbuf](arg_vec(prog, args)),\n+    auto pid = rustrt::rust_run_program(vec::buf[sbuf](arg_vec(prog, args)),\n                                        0, 0, 0);\n     ret os::waitpid(pid);\n }\n@@ -33,7 +33,7 @@ fn start_program(str prog, vec[str] args) -> @program {\n     auto pipe_input = os::pipe();\n     auto pipe_output = os::pipe();\n     auto pid = rustrt::rust_run_program\n-        (_vec::buf[sbuf](arg_vec(prog, args)),\n+        (vec::buf[sbuf](arg_vec(prog, args)),\n          pipe_input._0, pipe_output._1, 0);\n     if (pid == -1) {fail;}\n     os::libc::close(pipe_input._0);\n@@ -80,7 +80,7 @@ fn program_output(str prog, vec[str] args)\n     auto buf = \"\";\n     while (!out.eof()) {\n         auto bytes = out.read_bytes(4096u);\n-        buf += _str::unsafe_from_bytes(bytes);\n+        buf += str::unsafe_from_bytes(bytes);\n     }\n     ret rec(status=pr.finish(), out=buf);\n }"}, {"sha": "c16b78dc69dd8032d1e0e7bd3ee959ab563a25e8", "filename": "src/lib/sha1.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsha1.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -74,8 +74,8 @@ fn mk_sha1() -> sha1 {\n     fn process_msg_block(&sha1state st) {\n \n         // FIXME: Make precondition\n-        assert (_vec::len(st.h) == digest_buf_len);\n-        assert (_vec::len(st.work_buf) == work_buf_len);\n+        assert (vec::len(st.h) == digest_buf_len);\n+        assert (vec::len(st.work_buf) == work_buf_len);\n \n         let int t; // Loop counter\n         auto w = st.work_buf;\n@@ -196,7 +196,7 @@ fn mk_sha1() -> sha1 {\n      */\n     fn pad_msg(&sha1state st) {\n         // FIXME: Should be a precondition\n-        assert (_vec::len(st.msg_block) == msg_block_len);\n+        assert (vec::len(st.msg_block) == msg_block_len);\n \n         /*\n          * Check to see if the current message block is too small to hold\n@@ -240,7 +240,7 @@ fn mk_sha1() -> sha1 {\n \n         fn reset() {\n             // FIXME: Should be typestate precondition\n-            assert (_vec::len(st.h) == digest_buf_len);\n+            assert (vec::len(st.h) == digest_buf_len);\n \n             st.len_low = 0u32;\n             st.len_high = 0u32;\n@@ -260,7 +260,7 @@ fn mk_sha1() -> sha1 {\n         }\n \n         fn input_str(&str msg) {\n-            add_input(st, _str::bytes(msg));\n+            add_input(st, str::bytes(msg));\n         }\n \n         fn result() -> vec[u8] {\n@@ -271,19 +271,19 @@ fn mk_sha1() -> sha1 {\n             auto r = mk_result(st);\n             auto s = \"\";\n             for (u8 b in r) {\n-                s += _uint::to_str(b as uint, 16u);\n+                s += uint::to_str(b as uint, 16u);\n             }\n             ret s;\n         }\n     }\n \n-    auto st = rec(h = _vec::init_elt_mut[u32](0u32, digest_buf_len),\n+    auto st = rec(h = vec::init_elt_mut[u32](0u32, digest_buf_len),\n                   mutable len_low = 0u32,\n                   mutable len_high = 0u32,\n-                  msg_block = _vec::init_elt_mut[u8](0u8, msg_block_len),\n+                  msg_block = vec::init_elt_mut[u8](0u8, msg_block_len),\n                   mutable msg_block_idx = 0u,\n                   mutable computed = false,\n-                  work_buf = _vec::init_elt_mut[u32](0u32, work_buf_len));\n+                  work_buf = vec::init_elt_mut[u32](0u32, work_buf_len));\n     auto sh = sha1(st);\n     sh.reset();\n     ret sh;"}, {"sha": "92f03903a81879525bc7a7bfe53fd3368993f97f", "filename": "src/lib/sort.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsort.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,5 +1,5 @@\n-import _vec::len;\n-import _vec::slice;\n+import vec::len;\n+import vec::slice;\n \n type lteq[T] = fn(&T a, &T b) -> bool;\n "}, {"sha": "c0839ce90980d819e8d518fcf10b969914c69034", "filename": "src/lib/std.rc", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -6,11 +6,11 @@ meta (name = \"std\",\n \n // Built-in types support modules.\n \n-mod _int;\n-mod _uint;\n-mod _u8;\n-mod _vec;\n-mod _str;\n+mod int;\n+mod uint;\n+mod u8;\n+mod vec;\n+mod str;\n \n // General io and system-services modules.\n \n@@ -29,13 +29,13 @@ auth io = unsafe;\n auth fs = unsafe;\n auth os_fs = unsafe;\n auth run = unsafe;\n-auth _str = unsafe;\n-auth _vec = unsafe;\n+auth str = unsafe;\n+auth vec = unsafe;\n auth _task = unsafe;\n \n auth dbg = unsafe;\n \n-auth _uint::next_power_of_two = unsafe;\n+auth uint::next_power_of_two = unsafe;\n auth map::mk_hashmap = unsafe;\n auth rand::mk_rng = unsafe;\n "}, {"sha": "27049c83d138b1ae274e4197e41105bf1f1979b4", "filename": "src/lib/str.rs", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstr.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,6 +1,6 @@\n import rustrt::sbuf;\n \n-import _vec::rustrt::vbuf;\n+import vec::rustrt::vbuf;\n \n native \"rust\" mod rustrt {\n     type sbuf;\n@@ -84,7 +84,7 @@ const uint tag_six_b = 0xfc_u;\n \n fn is_utf8(vec[u8] v) -> bool {\n     auto i = 0u;\n-    auto total = _vec::len[u8](v);\n+    auto total = vec::len[u8](v);\n     while (i < total) {\n         auto chsize = utf8_char_width(v.(i));\n         if (chsize == 0u) {ret false;}\n@@ -253,7 +253,7 @@ fn to_chars(str s) -> vec[char] {\n     auto len = byte_len(s);\n     while (i < len) {\n         auto cur = char_range_at(s, i);\n-        _vec::push[char](buf, cur._0);\n+        vec::push[char](buf, cur._0);\n         i = cur._1;\n     }\n     ret buf;\n@@ -311,7 +311,7 @@ fn index(str s, u8 c) -> int {\n }\n \n fn rindex(str s, u8 c) -> int {\n-    let int n = _str::byte_len(s) as int;\n+    let int n = str::byte_len(s) as int;\n     while (n >= 0) {\n         if (s.(n) == c) {\n             ret n;\n@@ -387,7 +387,7 @@ fn substr(str s, uint begin, uint len) -> str {\n fn slice(str s, uint begin, uint end) -> str {\n     // FIXME: Typestate precondition\n     assert (begin <= end);\n-    assert (end <= _str::byte_len(s));\n+    assert (end <= str::byte_len(s));\n     ret rustrt::str_slice(s, begin, end);\n }\n \n@@ -432,7 +432,7 @@ fn split(str s, u8 sep) -> vec[str] {\n             ends_with_sep = false;\n         }\n     }\n-    if (_str::byte_len(accum) != 0u ||\n+    if (str::byte_len(accum) != 0u ||\n         ends_with_sep) {\n         v += [accum];\n     }", "previous_filename": "src/lib/_str.rs"}, {"sha": "e094e5812bddb5b86663266f37fa84aec9ce65b1", "filename": "src/lib/u8.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fu8.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "previous_filename": "src/lib/_u8.rs"}, {"sha": "316bd589ee738aee1342520fd550cece80b54beb", "filename": "src/lib/ufind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fufind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fufind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fufind.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -8,12 +8,12 @@ type ufind = rec(mutable vec[mutable node] nodes);\n \n fn make() -> ufind {\n     let vec[mutable node] v = [mutable none[uint]];\n-    _vec::pop(v);  // FIXME: botch\n+    vec::pop(v);  // FIXME: botch\n     ret rec(mutable nodes=v);\n }\n \n fn make_set(&ufind ufnd) -> uint {\n-    auto idx = _vec::len(ufnd.nodes);\n+    auto idx = vec::len(ufnd.nodes);\n     ufnd.nodes += [mutable none[uint]];\n     ret idx;\n }"}, {"sha": "f4beb593cf9ff1e7355cea4a13afe3dec0965b0f", "filename": "src/lib/uint.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fuint.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -34,12 +34,12 @@ fn next_power_of_two(uint n) -> uint {\n }\n \n fn parse_buf(vec[u8] buf, uint radix) -> uint {\n-    if (_vec::len[u8](buf) == 0u) {\n+    if (vec::len[u8](buf) == 0u) {\n         log_err \"parse_buf(): buf is empty\";\n         fail;\n     }\n \n-    auto i = _vec::len[u8](buf) - 1u;\n+    auto i = vec::len[u8](buf) - 1u;\n     auto power = 1u;\n     auto n = 0u;\n     while (true) {\n@@ -83,15 +83,15 @@ fn to_str(uint num, uint radix) -> str\n \n     let str s = \"\";\n     while (n != 0u) {\n-        s += _str::unsafe_from_byte(digit(n % radix) as u8);\n+        s += str::unsafe_from_byte(digit(n % radix) as u8);\n         n /= radix;\n     }\n \n     let str s1 = \"\";\n-    let uint len = _str::byte_len(s);\n+    let uint len = str::byte_len(s);\n     while (len != 0u) {\n         len -= 1u;\n-        s1 += _str::unsafe_from_byte(s.(len));\n+        s1 += str::unsafe_from_byte(s.(len));\n     }\n     ret s1;\n ", "previous_filename": "src/lib/_uint.rs"}, {"sha": "f075b97e7f88315d0f9a2529816f0b150f293c93", "filename": "src/lib/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Futil.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -4,7 +4,7 @@ fn id[T](&T x) -> T {\n \n /* FIXME (issue #141):  See test/run-pass/constrained-type.rs.  Uncomment\n  * the constraint once fixed. */\n-type rational = rec(int num, int den); // : _int::positive(*.den);\n+type rational = rec(int num, int den); // : int::positive(*.den);\n \n fn rational_leq(&rational x, &rational y) -> bool {\n     // NB: Uses the fact that rationals have positive denominators WLOG:"}, {"sha": "f251225a3e946e062aec5e4348064803ede44f5b", "filename": "src/lib/vec.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fvec.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -199,7 +199,7 @@ fn grow[T](&array[T] v, uint n, &T initval) {\n }\n \n fn grow_set[T](&vec[mutable T] v, uint index, &T initval, &T val) {\n-    auto length = _vec::len(v);\n+    auto length = vec::len(v);\n     if (index >= length) {\n         grow(v, index - length + 1u, initval);\n     }\n@@ -270,7 +270,7 @@ fn unzip[T, U](&vec[tup(T, U)] v) -> tup(vec[T], vec[U]) {\n \n fn or(&vec[bool] v) -> bool {\n     auto f = orb;\n-    ret _vec::foldl[bool, bool](f, false, v);\n+    ret vec::foldl[bool, bool](f, false, v);\n }\n \n fn clone[T](&vec[T] v) -> vec[T] {", "previous_filename": "src/lib/_vec.rs"}, {"sha": "1540bd0ea671ef6a6aa42dfd0a1d99c29fdc21f9", "filename": "src/lib/win32_os.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fwin32_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Flib%2Fwin32_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fwin32_os.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,5 +1,5 @@\n-import _str::sbuf;\n-import _vec::vbuf;\n+import str::sbuf;\n+import vec::vbuf;\n \n native mod libc = \"msvcrt.dll\" {\n     fn open(sbuf s, int flags, uint mode) -> int = \"_open\";\n@@ -53,13 +53,13 @@ fn dylib_filename(str base) -> str {\n \n fn pipe() -> tup(int, int) {\n     let vec[mutable int] fds = [mutable 0, 0];\n-    assert (os::libc::_pipe(_vec::buf(fds), 1024u,\n+    assert (os::libc::_pipe(vec::buf(fds), 1024u,\n                         libc_constants::O_BINARY()) == 0);\n     ret tup(fds.(0), fds.(1));\n }\n \n fn fd_FILE(int fd) -> libc::FILE {\n-    ret libc::_fdopen(fd, _str::buf(\"r\"));\n+    ret libc::_fdopen(fd, str::buf(\"r\"));\n }\n \n native \"rust\" mod rustrt {"}, {"sha": "37194a39e510624f12d43c5f8a44ac8ba4b7e801", "filename": "src/test/bench/99-bottles/99bob-iter.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Fbench%2F99-bottles%2F99bob-iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Fbench%2F99-bottles%2F99bob-iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99-bottles%2F99bob-iter.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -3,8 +3,8 @@\n  * http://99-bottles-of-beer.net/\n  */\n use std;\n-import std::_int;\n-import std::_str;\n+import std::int;\n+import std::str;\n \n fn b1() -> str {\n   ret \"# of beer on the wall, # of beer.\";\n@@ -32,15 +32,15 @@ case (1) {\n     ns = \"1 bottle\";\n   }\n  case (_) {\n-    ns = _int::to_str(n, 10u) + \" bottles\";\n+    ns = int::to_str(n, 10u) + \" bottles\";\n   }\n   }\n-  while (i < _str::byte_len(t)) {\n+  while (i < str::byte_len(t)) {\n     if (t.(i) == ('#' as u8)) {\n       b += ns;\n     }\n     else {\n-      _str::push_byte(b, t.(i));\n+      str::push_byte(b, t.(i));\n     }\n     i += 1u;\n   }"}, {"sha": "96d61e8e23268e34ab37104c2def1b3004935d3e", "filename": "src/test/bench/99-bottles/99bob-pattern.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Fbench%2F99-bottles%2F99bob-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Fbench%2F99-bottles%2F99bob-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99-bottles%2F99bob-pattern.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -3,8 +3,8 @@\n  * http://99-bottles-of-beer.net/\n  */\n use std;\n-import std::_int;\n-import std::_str;\n+import std::int;\n+import std::str;\n \n tag bottle { none; dual; single; multiple(int);}\n \n@@ -25,8 +25,8 @@ fn show(bottle b) {\n       log \"Take one down and pass it around, 1 bottle of beer on the wall.\";\n     }\n     case (multiple(?n)) {\n-      let str nb =  _int::to_str(n, 10u);\n-      let str mb = _int::to_str(n - 1, 10u);\n+      let str nb =  int::to_str(n, 10u);\n+      let str mb = int::to_str(n - 1, 10u);\n       log nb + \" bottles of beer on the wall, \" + nb + \" bottles of beer,\";\n       log \"Take one down and pass it around, \" \n         + mb + \" bottles of beer on the wall.\";"}, {"sha": "6aa6d6b1e2e8e69fc9c2135359874a0de2f79cb7", "filename": "src/test/bench/99-bottles/99bob-simple.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Fbench%2F99-bottles%2F99bob-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Fbench%2F99-bottles%2F99bob-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99-bottles%2F99bob-simple.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -3,8 +3,8 @@\n  * http://99-bottles-of-beer.net/\n  */\n use std;\n-import std::_int;\n-import std::_str;\n+import std::int;\n+import std::str;\n \n fn b1() -> str {\n   ret \"# of beer on the wall, # of beer.\";\n@@ -31,15 +31,15 @@ case (1) {\n     ns = \"1 bottle\";\n   }\n  case (_) {\n-    ns = _int::to_str(n, 10u) + \" bottles\";\n+    ns = int::to_str(n, 10u) + \" bottles\";\n   }\n   }\n-  while (i < _str::byte_len(t)) {\n+  while (i < str::byte_len(t)) {\n     if (t.(i) == ('#' as u8)) {\n       b += ns;\n     }\n     else {\n-      _str::push_byte(b, t.(i));\n+      str::push_byte(b, t.(i));\n     }\n     i += 1u;\n   }"}, {"sha": "8da4a5b76b72328bbe8297d4198285022dd0a1b2", "filename": "src/test/bench/99-bottles/99bob-tail.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Fbench%2F99-bottles%2F99bob-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Fbench%2F99-bottles%2F99bob-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99-bottles%2F99bob-tail.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -3,13 +3,13 @@\n  * http://99-bottles-of-beer.net/\n  */\n use std;\n-import std::_int;\n-import std::_str;\n+import std::int;\n+import std::str;\n \n fn main() {\n   fn multiple(int n) {\n-    let str nb =  _int::to_str(n, 10u);\n-    let str mb =  _int::to_str(n - 1, 10u);\n+    let str nb =  int::to_str(n, 10u);\n+    let str mb =  int::to_str(n - 1, 10u);\n     log nb + \" bottles of beer on the wall, \" + nb + \" bottles of beer,\";\n     log \"Take one down and pass it around, \" \n       + mb + \" bottles of beer on the wall.\";"}, {"sha": "ef0de64363ce85935ca2f9aa5a0b8dbc9b11728b", "filename": "src/test/bench/shootout/binarytrees.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Fbench%2Fshootout%2Fbinarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Fbench%2Fshootout%2Fbinarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout%2Fbinarytrees.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,6 +1,6 @@\n use std;\n \n-import std::_int;\n+import std::int;\n \n tag tree {\n   nil;\n@@ -49,7 +49,7 @@ fn main() {\n \n   auto depth = min_depth;\n   while (depth <= max_depth) {\n-    auto iterations = _int::pow(2, (max_depth - depth + min_depth) as uint);\n+    auto iterations = int::pow(2, (max_depth - depth + min_depth) as uint);\n     auto chk = 0;\n \n     auto i = 1;"}, {"sha": "cca3592ce68f3e5e98ad64fa4cf4cc6f767e5dd6", "filename": "src/test/bench/shootout/fannkuchredux.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Fbench%2Fshootout%2Ffannkuchredux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Fbench%2Fshootout%2Ffannkuchredux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout%2Ffannkuchredux.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -2,8 +2,8 @@\n \n use std;\n \n-import std::_int;\n-import std::_vec;\n+import std::int;\n+import std::vec;\n \n fn fannkuch(int n) -> int {\n \n@@ -12,9 +12,9 @@ fn fannkuch(int n) -> int {\n   }\n   auto perm1init_ = perm1init; // Rustboot workaround\n \n-  auto perm = _vec::init_elt(0, n as uint);\n-  auto perm1 = _vec::init_fn(perm1init_, n as uint);\n-  auto count = _vec::init_elt(0, n as uint);\n+  auto perm = vec::init_elt(0, n as uint);\n+  auto perm1 = vec::init_fn(perm1init_, n as uint);\n+  auto count = vec::init_elt(0, n as uint);\n \n   auto f = 0;\n   auto i = 0;"}, {"sha": "1fc7ef43be3a9e306e874bc45b27b1bc5eb2d96c", "filename": "src/test/bench/shootout/fasta.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Fbench%2Fshootout%2Ffasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Fbench%2Fshootout%2Ffasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout%2Ffasta.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -7,10 +7,10 @@\n  * http://shootout.alioth.debian.org/\n  */\n use std;\n-import std::_vec;\n-import std::_str;\n-import std::_uint;\n-import std::_int;\n+import std::vec;\n+import std::str;\n+import std::uint;\n+import std::int;\n \n fn LINE_LENGTH() -> uint {\n   ret 60u;\n@@ -54,38 +54,38 @@ fn select_random(u32 r, vec[aminoacids] genelist) -> char {\n       ret v.(hi)._0;\n     }\n   }\n-  ret bisect(genelist, 0u, _vec::len[aminoacids](genelist) - 1u, r);\n+  ret bisect(genelist, 0u, vec::len[aminoacids](genelist) - 1u, r);\n }\n \n fn make_random_fasta(str id, str desc, vec[aminoacids] genelist, int n) {\n   log(\">\" + id + \" \" + desc);\n   auto rng = myrandom(std::rand::mk_rng().next());\n   let str op = \"\";\n-  for each (uint i in _uint::range(0u, n as uint)) {\n-    _str::push_byte(op, select_random(rng.next(100u32), genelist) as u8);\n-    if (_str::byte_len(op) >= LINE_LENGTH()) {\n+  for each (uint i in uint::range(0u, n as uint)) {\n+    str::push_byte(op, select_random(rng.next(100u32), genelist) as u8);\n+    if (str::byte_len(op) >= LINE_LENGTH()) {\n       log(op);\n       op = \"\";\n     }\n   }\n-  if (_str::byte_len(op) > 0u) {\n+  if (str::byte_len(op) > 0u) {\n     log(op);\n   }\n }\n \n fn make_repeat_fasta(str id, str desc, str s, int n) {\n   log(\">\" + id + \" \" + desc);\n   let str op = \"\";\n-  let uint sl = _str::byte_len(s);\n-  for each (uint i in _uint::range(0u, n as uint)) {\n+  let uint sl = str::byte_len(s);\n+  for each (uint i in uint::range(0u, n as uint)) {\n \n-    _str::push_byte(op, s.(i % sl));\n-    if (_str::byte_len(op) >= LINE_LENGTH()) {\n+    str::push_byte(op, s.(i % sl));\n+    if (str::byte_len(op) >= LINE_LENGTH()) {\n       log(op);\n       op = \"\";\n     }\n   }\n-  if (_str::byte_len(op) > 0u) {\n+  if (str::byte_len(op) > 0u) {\n     log(op);\n   }\n }"}, {"sha": "fafa0bf7a601de8ff39a4e16ef17ac1898e2faba", "filename": "src/test/run-pass/alt-pattern-drop.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,7 +1,7 @@\n // -*- rust -*-\n \n use std;\n-import std::_str;\n+import std::str;\n \n // FIXME: import std::dbg.const_refcount. Currently\n // cross-crate const references don't work.\n@@ -20,13 +20,13 @@ fn foo(str s) {\n     case (_) { log \"?\"; fail; }\n   }\n \n-  log _str::refcount(s);\n-  assert (_str::refcount(s) == const_refcount);\n+  log str::refcount(s);\n+  assert (str::refcount(s) == const_refcount);\n }\n \n fn main() {\n   let str s = \"hi\";     // ref up\n   foo(s);               // ref up then down\n-  log _str::refcount(s);\n-  assert (_str::refcount(s) == const_refcount);\n+  log str::refcount(s);\n+  assert (str::refcount(s) == const_refcount);\n }"}, {"sha": "94e709dccbce481950bddbf4d56b94bb8dfb1bd4", "filename": "src/test/run-pass/box-inside-if.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Fbox-inside-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Fbox-inside-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-inside-if.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,7 +1,7 @@\n // -*- rust -*-\n // xfail-stage0\n use std;\n-import std::_vec;\n+import std::vec;\n \n fn some_vec(int x) -> vec[int] {\n   ret [];"}, {"sha": "cf319c9056291cd18e577ca7cde9fff8968450e1", "filename": "src/test/run-pass/box-inside-if2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Fbox-inside-if2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Fbox-inside-if2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-inside-if2.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,7 +1,7 @@\n // -*- rust -*-\n // xfail-stage0\n use std;\n-import std::_vec;\n+import std::vec;\n \n fn some_vec(int x) -> vec[int] {\n   ret [];"}, {"sha": "8dddc28177587ceb3f14eb4c277f7c7277b8c8b4", "filename": "src/test/run-pass/lib-bitv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Flib-bitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Flib-bitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-bitv.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,13 +1,13 @@\n use std;\n-import std::_vec;\n+import std::vec;\n import std::bitv;\n \n fn test_0_elements() {\n   auto act;\n   auto exp;\n \n   act = bitv::create(0u, false);\n-  exp = _vec::init_elt[uint](0u, 0u);\n+  exp = vec::init_elt[uint](0u, 0u);\n   // FIXME: why can't I write vec[uint]()?\n   assert (bitv::eq_vec(act, exp));\n }"}, {"sha": "cd525f67c56ae186a37476f8d3adcda231e25466", "filename": "src/test/run-pass/lib-int.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Flib-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Flib-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-int.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,25 +1,25 @@\n use std;\n \n-import std::_int;\n-import std::_str::eq;\n+import std::int;\n+import std::str::eq;\n \n fn test_to_str() {\n-  assert (eq(_int::to_str(0, 10u), \"0\"));\n-  assert (eq(_int::to_str(1, 10u), \"1\"));\n-  assert (eq(_int::to_str(-1, 10u), \"-1\"));\n-  assert (eq(_int::to_str(255, 16u), \"ff\"));\n-  assert (eq(_int::to_str(100, 10u), \"100\"));\n+  assert (eq(int::to_str(0, 10u), \"0\"));\n+  assert (eq(int::to_str(1, 10u), \"1\"));\n+  assert (eq(int::to_str(-1, 10u), \"-1\"));\n+  assert (eq(int::to_str(255, 16u), \"ff\"));\n+  assert (eq(int::to_str(100, 10u), \"100\"));\n }\n \n fn test_pow() {\n-  assert (_int::pow(0, 0u) == 1);\n-  assert (_int::pow(0, 1u) == 0);\n-  assert (_int::pow(0, 2u) == 0);\n-  assert (_int::pow(-1, 0u) == -1);\n-  assert (_int::pow(1, 0u) == 1);\n-  assert (_int::pow(-3, 2u) == 9);\n-  assert (_int::pow(-3, 3u) == -27);\n-  assert (_int::pow(4, 9u) == 262144);\n+  assert (int::pow(0, 0u) == 1);\n+  assert (int::pow(0, 1u) == 0);\n+  assert (int::pow(0, 2u) == 0);\n+  assert (int::pow(-1, 0u) == -1);\n+  assert (int::pow(1, 0u) == 1);\n+  assert (int::pow(-3, 2u) == 9);\n+  assert (int::pow(-3, 3u) == -27);\n+  assert (int::pow(4, 9u) == 262144);\n }\n \n fn main() {"}, {"sha": "c7561ecc1534f765efbc71b6b4e117ea01f83298", "filename": "src/test/run-pass/lib-io.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Flib-io.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Flib-io.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-io.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -5,7 +5,7 @@\n \n use std;\n import std::io;\n-import std::_str;\n+import std::str;\n \n fn test_simple(str tmpfilebase) {\n   let str tmpfile = tmpfilebase + \".tmp\";\n@@ -21,7 +21,7 @@ fn test_simple(str tmpfilebase) {\n   let io::reader inp = io::file_reader(tmpfile);\n   let str frood2 = inp.read_c_str();\n   log frood2;\n-  assert (_str::eq(frood, frood2));\n+  assert (str::eq(frood, frood2));\n }\n \n fn main(vec[str] argv) {"}, {"sha": "fcded5636189d926bf90824b3627595c0fe54b4e", "filename": "src/test/run-pass/lib-map.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Flib-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Flib-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-map.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -2,8 +2,8 @@\n \n use std;\n import std::map;\n-import std::_str;\n-import std::_uint;\n+import std::str;\n+import std::uint;\n import std::util;\n \n fn test_simple() {\n@@ -19,8 +19,8 @@ fn test_simple() {\n   let map::hashfn[uint] hasher_uint = hash_uint;\n   let map::eqfn[uint] eqer_uint = eq_uint;\n \n-  let map::hashfn[str] hasher_str = _str::hash;\n-  let map::eqfn[str] eqer_str = _str::eq;\n+  let map::hashfn[str] hasher_str = str::hash;\n+  let map::eqfn[str] eqer_str = str::eq;\n \n \n   log \"uint -> uint\";\n@@ -77,15 +77,15 @@ fn test_simple() {\n   assert (hm_us.insert(11u, \"thirteen\"));\n   assert (hm_us.insert(12u, \"fourteen\"));\n \n-  assert (_str::eq(hm_us.get(11u), \"thirteen\"));\n-  assert (_str::eq(hm_us.get(12u), \"fourteen\"));\n-  assert (_str::eq(hm_us.get(10u), \"twelve\"));\n+  assert (str::eq(hm_us.get(11u), \"thirteen\"));\n+  assert (str::eq(hm_us.get(12u), \"fourteen\"));\n+  assert (str::eq(hm_us.get(10u), \"twelve\"));\n \n   assert (!hm_us.insert(12u, \"fourteen\"));\n-  assert (_str::eq(hm_us.get(12u), \"fourteen\"));\n+  assert (str::eq(hm_us.get(12u), \"fourteen\"));\n \n   assert (!hm_us.insert(12u, \"twelve\"));\n-  assert (_str::eq(hm_us.get(12u), \"twelve\"));\n+  assert (str::eq(hm_us.get(12u), \"twelve\"));\n \n \n   log \"str -> str\";\n@@ -97,15 +97,15 @@ fn test_simple() {\n   assert (hm_ss.insert(eleven, \"thirteen\"));\n   assert (hm_ss.insert(twelve, \"fourteen\"));\n \n-  assert (_str::eq(hm_ss.get(\"eleven\"), \"thirteen\"));\n-  assert (_str::eq(hm_ss.get(\"twelve\"), \"fourteen\"));\n-  assert (_str::eq(hm_ss.get(\"ten\"), \"twelve\"));\n+  assert (str::eq(hm_ss.get(\"eleven\"), \"thirteen\"));\n+  assert (str::eq(hm_ss.get(\"twelve\"), \"fourteen\"));\n+  assert (str::eq(hm_ss.get(\"ten\"), \"twelve\"));\n \n   assert (!hm_ss.insert(\"twelve\", \"fourteen\"));\n-  assert (_str::eq(hm_ss.get(\"twelve\"), \"fourteen\"));\n+  assert (str::eq(hm_ss.get(\"twelve\"), \"fourteen\"));\n \n   assert (!hm_ss.insert(\"twelve\", \"twelve\"));\n-  assert (_str::eq(hm_ss.get(\"twelve\"), \"twelve\"));\n+  assert (str::eq(hm_ss.get(\"twelve\"), \"twelve\"));\n \n   log \"*** finished test_simple\";\n }\n@@ -136,17 +136,17 @@ fn test_growth() {\n   let uint i = 0u;\n   while (i < num_to_insert) {\n     assert (hm_uu.insert(i, i * i));\n-    log \"inserting \" + _uint::to_str(i, 10u)\n-      + \" -> \" + _uint::to_str(i * i, 10u);\n+    log \"inserting \" + uint::to_str(i, 10u)\n+      + \" -> \" + uint::to_str(i * i, 10u);\n     i += 1u;\n   }\n \n   log \"-----\";\n \n   i = 0u;\n   while (i < num_to_insert) {\n-    log \"get(\" + _uint::to_str(i, 10u) + \") = \"\n-      + _uint::to_str(hm_uu.get(i), 10u);\n+    log \"get(\" + uint::to_str(i, 10u) + \") = \"\n+      + uint::to_str(hm_uu.get(i), 10u);\n     assert (hm_uu.get(i) == i * i);\n     i += 1u;\n   }\n@@ -160,25 +160,25 @@ fn test_growth() {\n \n   i = 0u;\n   while (i < num_to_insert) {\n-    log \"get(\" + _uint::to_str(i, 10u) + \") = \"\n-      + _uint::to_str(hm_uu.get(i), 10u);\n+    log \"get(\" + uint::to_str(i, 10u) + \") = \"\n+      + uint::to_str(hm_uu.get(i), 10u);\n     assert (hm_uu.get(i) == i * i);\n     i += 1u;\n   }\n \n \n   log \"str -> str\";\n \n-  let map::hashfn[str] hasher_str = _str::hash;\n-  let map::eqfn[str] eqer_str = _str::eq;\n+  let map::hashfn[str] hasher_str = str::hash;\n+  let map::eqfn[str] eqer_str = str::eq;\n   let map::hashmap[str, str] hm_ss = map::mk_hashmap[str, str](hasher_str,\n                                                              eqer_str);\n \n   i = 0u;\n   while (i < num_to_insert) {\n-    assert (hm_ss.insert(_uint::to_str(i, 2u), _uint::to_str(i * i, 2u)));\n-    log \"inserting \\\"\" + _uint::to_str(i, 2u)\n-      + \"\\\" -> \\\"\" + _uint::to_str(i * i, 2u) + \"\\\"\";\n+    assert (hm_ss.insert(uint::to_str(i, 2u), uint::to_str(i * i, 2u)));\n+    log \"inserting \\\"\" + uint::to_str(i, 2u)\n+      + \"\\\" -> \\\"\" + uint::to_str(i * i, 2u) + \"\\\"\";\n     i += 1u;\n   }\n \n@@ -187,31 +187,31 @@ fn test_growth() {\n   i = 0u;\n   while (i < num_to_insert) {\n     log \"get(\\\"\"\n-      + _uint::to_str(i, 2u)\n+      + uint::to_str(i, 2u)\n       + \"\\\") = \\\"\"\n-      + hm_ss.get(_uint::to_str(i, 2u)) + \"\\\"\";\n+      + hm_ss.get(uint::to_str(i, 2u)) + \"\\\"\";\n \n-    assert (_str::eq(hm_ss.get(_uint::to_str(i, 2u)),\n-                   _uint::to_str(i * i, 2u)));\n+    assert (str::eq(hm_ss.get(uint::to_str(i, 2u)),\n+                   uint::to_str(i * i, 2u)));\n     i += 1u;\n   }\n \n-  assert (hm_ss.insert(_uint::to_str(num_to_insert, 2u),\n-                      _uint::to_str(17u, 2u)));\n+  assert (hm_ss.insert(uint::to_str(num_to_insert, 2u),\n+                      uint::to_str(17u, 2u)));\n \n-  assert (_str::eq(hm_ss.get(_uint::to_str(num_to_insert, 2u)),\n-                 _uint::to_str(17u, 2u)));\n+  assert (str::eq(hm_ss.get(uint::to_str(num_to_insert, 2u)),\n+                 uint::to_str(17u, 2u)));\n \n   log \"-----\";\n \n   hm_ss.rehash();\n \n   i = 0u;\n   while (i < num_to_insert) {\n-    log \"get(\\\"\" + _uint::to_str(i, 2u) + \"\\\") = \\\"\"\n-      + hm_ss.get(_uint::to_str(i, 2u)) + \"\\\"\";\n-    assert (_str::eq(hm_ss.get(_uint::to_str(i, 2u)),\n-                   _uint::to_str(i * i, 2u)));\n+    log \"get(\\\"\" + uint::to_str(i, 2u) + \"\\\") = \\\"\"\n+      + hm_ss.get(uint::to_str(i, 2u)) + \"\\\"\";\n+    assert (str::eq(hm_ss.get(uint::to_str(i, 2u)),\n+                   uint::to_str(i * i, 2u)));\n     i += 1u;\n   }\n \n@@ -241,8 +241,8 @@ fn test_removal() {\n   let uint i = 0u;\n   while (i < num_to_insert) {\n     assert (hm.insert(i, i * i));\n-    log \"inserting \" + _uint::to_str(i, 10u)\n-      + \" -> \" + _uint::to_str(i * i, 10u);\n+    log \"inserting \" + uint::to_str(i, 10u)\n+      + \" -> \" + uint::to_str(i * i, 10u);\n     i += 1u;\n   }\n \n@@ -279,8 +279,8 @@ fn test_removal() {\n \n   i = 1u;\n   while (i < num_to_insert) {\n-    log \"get(\" + _uint::to_str(i, 10u) + \") = \"\n-      + _uint::to_str(hm.get(i), 10u);\n+    log \"get(\" + uint::to_str(i, 10u) + \") = \"\n+      + uint::to_str(hm.get(i), 10u);\n     assert (hm.get(i) == i * i);\n     i += 2u;\n   }\n@@ -294,8 +294,8 @@ fn test_removal() {\n \n   i = 1u;\n   while (i < num_to_insert) {\n-    log \"get(\" + _uint::to_str(i, 10u) + \") = \"\n-      + _uint::to_str(hm.get(i), 10u);\n+    log \"get(\" + uint::to_str(i, 10u) + \") = \"\n+      + uint::to_str(hm.get(i), 10u);\n     assert (hm.get(i) == i * i);\n     i += 2u;\n   }\n@@ -305,8 +305,8 @@ fn test_removal() {\n   i = 0u;\n   while (i < num_to_insert) {\n     assert (hm.insert(i, i * i));\n-    log \"inserting \" + _uint::to_str(i, 10u)\n-      + \" -> \" + _uint::to_str(i * i, 10u);\n+    log \"inserting \" + uint::to_str(i, 10u)\n+      + \" -> \" + uint::to_str(i * i, 10u);\n     i += 2u;\n   }\n \n@@ -316,8 +316,8 @@ fn test_removal() {\n \n   i = 0u;\n   while (i < num_to_insert) {\n-    log \"get(\" + _uint::to_str(i, 10u) + \") = \"\n-      + _uint::to_str(hm.get(i), 10u);\n+    log \"get(\" + uint::to_str(i, 10u) + \") = \"\n+      + uint::to_str(hm.get(i), 10u);\n     assert (hm.get(i) == i * i);\n     i += 1u;\n   }\n@@ -333,8 +333,8 @@ fn test_removal() {\n \n   i = 0u;\n   while (i < num_to_insert) {\n-    log \"get(\" + _uint::to_str(i, 10u) + \") = \"\n-      + _uint::to_str(hm.get(i), 10u);\n+    log \"get(\" + uint::to_str(i, 10u) + \") = \"\n+      + uint::to_str(hm.get(i), 10u);\n     assert (hm.get(i) == i * i);\n     i += 1u;\n   }"}, {"sha": "53afba476a9a76cb3e60ab14652e9ef8ddd743e1", "filename": "src/test/run-pass/lib-qsort.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Flib-qsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Flib-qsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-qsort.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,7 +1,7 @@\n use std;\n \n fn check_sort(vec[mutable int] v1, vec[mutable int] v2) {\n-  auto len = std::_vec::len[int](v1);\n+  auto len = std::vec::len[int](v1);\n \n   fn ltequal(&int a, &int b) -> bool {\n     ret a <= b;"}, {"sha": "1c9f843cfadbe5e43a8cfae372576e724490726d", "filename": "src/test/run-pass/lib-sha1.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Flib-sha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Flib-sha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-sha1.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -5,8 +5,8 @@\n use std;\n \n import std::sha1;\n-import std::_vec;\n-import std::_str;\n+import std::vec;\n+import std::str;\n \n fn main() {\n \n@@ -66,8 +66,8 @@ fn main() {\n     auto tests = fips_180_1_tests + wikipedia_tests;\n \n     fn check_vec_eq(vec[u8] v0, vec[u8] v1) {\n-        assert (_vec::len[u8](v0) == _vec::len[u8](v1));\n-        auto len = _vec::len[u8](v0);\n+        assert (vec::len[u8](v0) == vec::len[u8](v1));\n+        auto len = vec::len[u8](v0);\n         auto i = 0u;\n         while (i < len) {\n             auto a = v0.(i);\n@@ -88,11 +88,11 @@ fn main() {\n \n     // Test that it works when accepting the message in pieces\n     for (test t in tests) {\n-        auto len = _str::byte_len(t.input);\n+        auto len = str::byte_len(t.input);\n         auto left = len;\n         while (left > 0u) {\n             auto take = (left + 1u) / 2u;\n-            sh.input_str(_str::substr(t.input, len - left, take));\n+            sh.input_str(str::substr(t.input, len - left, take));\n             left = left - take;\n         }\n         auto out = sh.result();"}, {"sha": "b63feae4fd7b3a556d78e848838f996fe589952b", "filename": "src/test/run-pass/lib-sort.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Flib-sort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Flib-sort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-sort.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,7 +1,7 @@\n use std;\n \n fn check_sort(vec[int] v1, vec[int] v2) {\n-  auto len = std::_vec::len[int](v1);\n+  auto len = std::vec::len[int](v1);\n   fn lteq(&int a, &int b) -> bool {\n     ret a <= b;\n   }"}, {"sha": "a401838000c0c723bcb3624e37d4f08ed2d8c904", "filename": "src/test/run-pass/lib-str-buf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Flib-str-buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Flib-str-buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-str-buf.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -4,7 +4,7 @@\n // -*- rust -*-\n \n use std;\n-import std::_str;\n+import std::str;\n \n fn main() {\n     auto s = \"hello\";"}, {"sha": "a7c3cac81130aefe3b8e152c819dddc693ca3b7b", "filename": "src/test/run-pass/lib-str.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Flib-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Flib-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-str.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,38 +1,38 @@\n // xfail-stage0\n \n use std;\n-import std::_str;\n+import std::str;\n \n fn test_bytes_len() {\n-  assert (_str::byte_len(\"\") == 0u);\n-  assert (_str::byte_len(\"hello world\") == 11u);\n-  assert (_str::byte_len(\"\\x63\") == 1u);\n-  assert (_str::byte_len(\"\\xa2\") == 2u);\n-  assert (_str::byte_len(\"\\u03c0\") == 2u);\n-  assert (_str::byte_len(\"\\u2620\") == 3u);\n-  assert (_str::byte_len(\"\\U0001d11e\") == 4u);\n+  assert (str::byte_len(\"\") == 0u);\n+  assert (str::byte_len(\"hello world\") == 11u);\n+  assert (str::byte_len(\"\\x63\") == 1u);\n+  assert (str::byte_len(\"\\xa2\") == 2u);\n+  assert (str::byte_len(\"\\u03c0\") == 2u);\n+  assert (str::byte_len(\"\\u2620\") == 3u);\n+  assert (str::byte_len(\"\\U0001d11e\") == 4u);\n }\n \n fn test_index_and_rindex() {\n-  assert (_str::index(\"hello\", 'e' as u8) == 1);\n-  assert (_str::index(\"hello\", 'o' as u8) == 4);\n-  assert (_str::index(\"hello\", 'z' as u8) == -1);\n-  assert (_str::rindex(\"hello\", 'l' as u8) == 3);\n-  assert (_str::rindex(\"hello\", 'h' as u8) == 0);\n-  assert (_str::rindex(\"hello\", 'z' as u8) == -1);\n+  assert (str::index(\"hello\", 'e' as u8) == 1);\n+  assert (str::index(\"hello\", 'o' as u8) == 4);\n+  assert (str::index(\"hello\", 'z' as u8) == -1);\n+  assert (str::rindex(\"hello\", 'l' as u8) == 3);\n+  assert (str::rindex(\"hello\", 'h' as u8) == 0);\n+  assert (str::rindex(\"hello\", 'z' as u8) == -1);\n }\n \n fn test_split() {\n   fn t(&str s, char c, int i, &str k) {\n     log \"splitting: \" + s;\n     log i;\n-    auto v = _str::split(s, c as u8);\n+    auto v = str::split(s, c as u8);\n     log \"split to: \";\n     for (str z in v) {\n       log z;\n     }\n     log \"comparing: \" + v.(i) + \" vs. \" + k;\n-    assert (_str::eq(v.(i), k));\n+    assert (str::eq(v.(i), k));\n   }\n   t(\"abc.hello.there\", '.', 0, \"abc\");\n   t(\"abc.hello.there\", '.', 1, \"hello\");\n@@ -45,7 +45,7 @@ fn test_split() {\n \n fn test_find() {\n   fn t(&str haystack, &str needle, int i) {\n-    let int j = _str::find(haystack,needle);\n+    let int j = str::find(haystack,needle);\n     log \"searched for \" + needle;\n     log j;\n     assert (i == j);\n@@ -59,8 +59,8 @@ fn test_find() {\n \n fn test_substr() {\n   fn t(&str a, &str b, int start) {\n-    assert (_str::eq(_str::substr(a, start as uint,\n-                              _str::byte_len(b)), b));\n+    assert (str::eq(str::substr(a, start as uint,\n+                              str::byte_len(b)), b));\n   }\n \n   t(\"hello\", \"llo\", 2);\n@@ -70,7 +70,7 @@ fn test_substr() {\n \n fn test_concat() {\n   fn t(&vec[str] v, &str s) {\n-    assert (_str::eq(_str::concat(v), s));\n+    assert (str::eq(str::concat(v), s));\n   }\n \n   t([\"you\", \"know\", \"I'm\", \"no\", \"good\"], \"youknowI'mnogood\");\n@@ -81,7 +81,7 @@ fn test_concat() {\n \n fn test_connect() {\n   fn t(&vec[str] v, &str sep, &str s) {\n-    assert (_str::eq(_str::connect(v, sep), s));\n+    assert (str::eq(str::connect(v, sep), s));\n   }\n \n   t([\"you\", \"know\", \"I'm\", \"no\", \"good\"], \" \", \"you know I'm no good\");\n@@ -96,14 +96,14 @@ fn test_to_upper() {\n   auto unicode = \"\\u65e5\\u672c\";\n   auto input = \"abcDEF\" + unicode + \"xyz:.;\";\n   auto expected = \"ABCDEF\" + unicode + \"XYZ:.;\";\n-  auto actual = _str::to_upper(input);\n-  assert (_str::eq(expected, actual));\n+  auto actual = str::to_upper(input);\n+  assert (str::eq(expected, actual));\n }\n \n fn test_slice() {\n-  assert (_str::eq(\"ab\", _str::slice(\"abc\", 0u, 2u)));\n-  assert (_str::eq(\"bc\", _str::slice(\"abc\", 1u, 3u)));\n-  assert (_str::eq(\"\", _str::slice(\"abc\", 1u, 1u)));\n+  assert (str::eq(\"ab\", str::slice(\"abc\", 0u, 2u)));\n+  assert (str::eq(\"bc\", str::slice(\"abc\", 1u, 3u)));\n+  assert (str::eq(\"\", str::slice(\"abc\", 1u, 1u)));\n \n   fn a_million_letter_a() -> str {\n     auto i = 0;\n@@ -125,8 +125,8 @@ fn test_slice() {\n     ret res;\n   }\n \n-  assert (_str::eq(half_a_million_letter_a(),\n-                 _str::slice(a_million_letter_a(),\n+  assert (str::eq(half_a_million_letter_a(),\n+                 str::slice(a_million_letter_a(),\n                            0u,\n                            500000u)));\n }"}, {"sha": "e9618c4abb0e7df42b96a8e7a6841747caf4acd4", "filename": "src/test/run-pass/lib-uint.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Flib-uint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Flib-uint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-uint.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,47 +1,47 @@\n // -*- rust -*-\n \n use std;\n-import std::_uint;\n+import std::uint;\n \n fn main() {\n-  assert (_uint::next_power_of_two(0u) == 0u);\n-  assert (_uint::next_power_of_two(1u) == 1u);\n-  assert (_uint::next_power_of_two(2u) == 2u);\n-  assert (_uint::next_power_of_two(3u) == 4u);\n-  assert (_uint::next_power_of_two(4u) == 4u);\n-  assert (_uint::next_power_of_two(5u) == 8u);\n-  assert (_uint::next_power_of_two(6u) == 8u);\n-  assert (_uint::next_power_of_two(7u) == 8u);\n-  assert (_uint::next_power_of_two(8u) == 8u);\n-  assert (_uint::next_power_of_two(9u) == 16u);\n-  assert (_uint::next_power_of_two(10u) == 16u);\n-  assert (_uint::next_power_of_two(11u) == 16u);\n-  assert (_uint::next_power_of_two(12u) == 16u);\n-  assert (_uint::next_power_of_two(13u) == 16u);\n-  assert (_uint::next_power_of_two(14u) == 16u);\n-  assert (_uint::next_power_of_two(15u) == 16u);\n-  assert (_uint::next_power_of_two(16u) == 16u);\n-  assert (_uint::next_power_of_two(17u) == 32u);\n-  assert (_uint::next_power_of_two(18u) == 32u);\n-  assert (_uint::next_power_of_two(19u) == 32u);\n-  assert (_uint::next_power_of_two(20u) == 32u);\n-  assert (_uint::next_power_of_two(21u) == 32u);\n-  assert (_uint::next_power_of_two(22u) == 32u);\n-  assert (_uint::next_power_of_two(23u) == 32u);\n-  assert (_uint::next_power_of_two(24u) == 32u);\n-  assert (_uint::next_power_of_two(25u) == 32u);\n-  assert (_uint::next_power_of_two(26u) == 32u);\n-  assert (_uint::next_power_of_two(27u) == 32u);\n-  assert (_uint::next_power_of_two(28u) == 32u);\n-  assert (_uint::next_power_of_two(29u) == 32u);\n-  assert (_uint::next_power_of_two(30u) == 32u);\n-  assert (_uint::next_power_of_two(31u) == 32u);\n-  assert (_uint::next_power_of_two(32u) == 32u);\n-  assert (_uint::next_power_of_two(33u) == 64u);\n-  assert (_uint::next_power_of_two(34u) == 64u);\n-  assert (_uint::next_power_of_two(35u) == 64u);\n-  assert (_uint::next_power_of_two(36u) == 64u);\n-  assert (_uint::next_power_of_two(37u) == 64u);\n-  assert (_uint::next_power_of_two(38u) == 64u);\n-  assert (_uint::next_power_of_two(39u) == 64u);\n+  assert (uint::next_power_of_two(0u) == 0u);\n+  assert (uint::next_power_of_two(1u) == 1u);\n+  assert (uint::next_power_of_two(2u) == 2u);\n+  assert (uint::next_power_of_two(3u) == 4u);\n+  assert (uint::next_power_of_two(4u) == 4u);\n+  assert (uint::next_power_of_two(5u) == 8u);\n+  assert (uint::next_power_of_two(6u) == 8u);\n+  assert (uint::next_power_of_two(7u) == 8u);\n+  assert (uint::next_power_of_two(8u) == 8u);\n+  assert (uint::next_power_of_two(9u) == 16u);\n+  assert (uint::next_power_of_two(10u) == 16u);\n+  assert (uint::next_power_of_two(11u) == 16u);\n+  assert (uint::next_power_of_two(12u) == 16u);\n+  assert (uint::next_power_of_two(13u) == 16u);\n+  assert (uint::next_power_of_two(14u) == 16u);\n+  assert (uint::next_power_of_two(15u) == 16u);\n+  assert (uint::next_power_of_two(16u) == 16u);\n+  assert (uint::next_power_of_two(17u) == 32u);\n+  assert (uint::next_power_of_two(18u) == 32u);\n+  assert (uint::next_power_of_two(19u) == 32u);\n+  assert (uint::next_power_of_two(20u) == 32u);\n+  assert (uint::next_power_of_two(21u) == 32u);\n+  assert (uint::next_power_of_two(22u) == 32u);\n+  assert (uint::next_power_of_two(23u) == 32u);\n+  assert (uint::next_power_of_two(24u) == 32u);\n+  assert (uint::next_power_of_two(25u) == 32u);\n+  assert (uint::next_power_of_two(26u) == 32u);\n+  assert (uint::next_power_of_two(27u) == 32u);\n+  assert (uint::next_power_of_two(28u) == 32u);\n+  assert (uint::next_power_of_two(29u) == 32u);\n+  assert (uint::next_power_of_two(30u) == 32u);\n+  assert (uint::next_power_of_two(31u) == 32u);\n+  assert (uint::next_power_of_two(32u) == 32u);\n+  assert (uint::next_power_of_two(33u) == 64u);\n+  assert (uint::next_power_of_two(34u) == 64u);\n+  assert (uint::next_power_of_two(35u) == 64u);\n+  assert (uint::next_power_of_two(36u) == 64u);\n+  assert (uint::next_power_of_two(37u) == 64u);\n+  assert (uint::next_power_of_two(38u) == 64u);\n+  assert (uint::next_power_of_two(39u) == 64u);\n }"}, {"sha": "10783b4fb2dfd9e4e210640aba025f20c1a3c07f", "filename": "src/test/run-pass/lib-vec-str-conversions.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Flib-vec-str-conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Flib-vec-str-conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-vec-str-conversions.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,8 +1,8 @@\n // -*- rust -*-\n \n use std;\n-import std::_str;\n-import std::_vec;\n+import std::str;\n+import std::vec;\n \n fn test_simple() {\n   let str s1 = \"All mimsy were the borogoves\";\n@@ -14,12 +14,12 @@ fn test_simple() {\n    * working, but we should implement is_utf8 before that happens.\n    */\n \n-  let vec[u8] v = _str::bytes(s1);\n-  let str s2 = _str::from_bytes(v);\n+  let vec[u8] v = str::bytes(s1);\n+  let str s2 = str::from_bytes(v);\n \n   let uint i = 0u;\n-  let uint n1 = _str::byte_len(s1);\n-  let uint n2 = _vec::len[u8](v);\n+  let uint n1 = str::byte_len(s1);\n+  let uint n2 = vec::len[u8](v);\n \n   assert (n1 == n2);\n \n@@ -33,7 +33,7 @@ fn test_simple() {\n   }\n \n   log \"refcnt is\";\n-  log _str::refcount(s1);\n+  log str::refcount(s1);\n }\n \n fn main() {"}, {"sha": "af49eacf4c4ca140632896906aad88c5fc3ce2dd", "filename": "src/test/run-pass/lib-vec.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Flib-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Flib-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-vec.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,8 +1,8 @@\n use std;\n \n fn test_init_elt() {\n-  let vec[uint] v = std::_vec::init_elt[uint](5u, 3u);\n-  assert (std::_vec::len[uint](v) == 3u);\n+  let vec[uint] v = std::vec::init_elt[uint](5u, 3u);\n+  assert (std::vec::len[uint](v) == 3u);\n   assert (v.(0) == 5u);\n   assert (v.(1) == 5u);\n   assert (v.(2) == 5u);\n@@ -13,8 +13,8 @@ fn id(uint x) -> uint {\n }\n fn test_init_fn() {\n   let fn(uint)->uint op = id;\n-  let vec[uint] v = std::_vec::init_fn[uint](op, 5u);\n-  assert (std::_vec::len[uint](v) == 5u);\n+  let vec[uint] v = std::vec::init_fn[uint](op, 5u);\n+  assert (std::vec::len[uint](v) == 5u);\n   assert (v.(0) == 0u);\n   assert (v.(1) == 1u);\n   assert (v.(2) == 2u);\n@@ -24,8 +24,8 @@ fn test_init_fn() {\n \n fn test_slice() {\n   let vec[int] v = [1,2,3,4,5];\n-  auto v2 = std::_vec::slice[int](v, 2u, 4u);\n-  assert (std::_vec::len[int](v2) == 2u);\n+  auto v2 = std::vec::slice[int](v, 2u, 4u);\n+  assert (std::vec::len[int](v2) == 2u);\n   assert (v2.(0) == 3);\n   assert (v2.(1) == 4);\n }\n@@ -34,7 +34,7 @@ fn test_map() {\n   fn square(&int x) -> int { ret x * x; }\n   let std::option::operator[int, int] op = square;\n   let vec[int] v = [1, 2, 3, 4, 5];\n-  let vec[int] s = std::_vec::map[int, int](op, v);\n+  let vec[int] s = std::vec::map[int, int](op, v);\n   let int i = 0;\n   while (i < 5) {\n     assert (v.(i) * v.(i) == s.(i));\n@@ -47,7 +47,7 @@ fn test_map2() {\n   auto f = times;\n   auto v0 = [1, 2, 3, 4, 5];\n   auto v1 = [5, 4, 3, 2, 1];\n-  auto u = std::_vec::map2[int,int,int](f, v0, v1);\n+  auto u = std::vec::map2[int,int,int](f, v0, v1);\n \n   auto i = 0;\n   while (i < 5) {"}, {"sha": "2a03471db4cf6d4ea91efa402a46d3abcc6251f1", "filename": "src/test/run-pass/mutable-alias-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -11,7 +11,7 @@ fn main() {\n   grow(v);\n   grow(v);\n   grow(v);\n-  auto len = std::_vec::len[int](v);\n+  auto len = std::vec::len[int](v);\n   log len;\n   assert (len == (3 as uint));\n }"}, {"sha": "30a8e57d1b7e040b436a5769ff50b416a60d9f73", "filename": "src/test/run-pass/rt-circular-buffer.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Frt-circular-buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Frt-circular-buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frt-circular-buffer.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -6,8 +6,8 @@\n use std;\n \n import std::option;\n-import std::_uint;\n-import std::_vec;\n+import std::uint;\n+import std::vec;\n \n // A 12-byte unit to send over the channel\n type record = rec(u32 val1, u32 val2, u32 val3);\n@@ -33,7 +33,7 @@ fn test_grow() {\n \n     let record val = rec(val1=0u32, val2=0u32, val3=0u32);\n \n-    for each (uint i in _uint::range(0u, 100u)) {\n+    for each (uint i in uint::range(0u, 100u)) {\n         mychan <| val;\n     }\n }\n@@ -53,11 +53,11 @@ fn test_shrink2() {\n \n     let record val = rec(val1=0u32, val2=0u32, val3=0u32);\n \n-    for each (uint i in _uint::range(0u, 100u)) {\n+    for each (uint i in uint::range(0u, 100u)) {\n         mychan <| val;\n     }\n \n-    for each (uint i in _uint::range(0u, 100u)) {\n+    for each (uint i in uint::range(0u, 100u)) {\n         auto x <- myport;\n     }\n }\n@@ -67,7 +67,7 @@ fn test_rotate() {\n     let port[record] myport = port();\n     auto mychan = chan(myport);\n \n-    for each (uint i in _uint::range(0u, 100u)) {\n+    for each (uint i in uint::range(0u, 100u)) {\n         auto val = rec(val1=i as u32,\n                        val2=i as u32,\n                        val3=i as u32);\n@@ -86,15 +86,15 @@ fn test_rotate_grow() {\n     let port[record] myport = port();\n     auto mychan = chan(myport);\n \n-    for each (uint j in _uint::range(0u, 10u)) {\n-        for each (uint i in _uint::range(0u, 10u)) {\n+    for each (uint j in uint::range(0u, 10u)) {\n+        for each (uint i in uint::range(0u, 10u)) {\n             let record val = rec(val1=i as u32,\n                                  val2=i as u32,\n                                  val3=i as u32);\n             mychan <| val;\n         }\n \n-        for each (uint i in _uint::range(0u, 10u)) {\n+        for each (uint i in uint::range(0u, 10u)) {\n             auto x <- myport;\n             assert (x.val1 == i as u32);\n             assert (x.val2 == i as u32);"}, {"sha": "7dc17cd652fe0fc3ef9b5e19075d4e42edf4143b", "filename": "src/test/run-pass/str-append.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Fstr-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Fstr-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstr-append.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,7 +1,7 @@\n // -*- rust -*-\n \n use std;\n-import std::_str;\n+import std::str;\n \n fn test1() {\n   let str s = \"hello\";\n@@ -20,8 +20,8 @@ fn test2() {\n   log a;\n   log b;\n \n-  assert (_str::eq(a, \"abcABCabc\"));\n-  assert (_str::eq(b, \"ABCabcABC\"));\n+  assert (str::eq(a, \"abcABCabc\"));\n+  assert (str::eq(b, \"ABCabcABC\"));\n }\n \n fn main() {"}, {"sha": "27050091554668e56c848cca6ad9a5cd875c8c37", "filename": "src/test/run-pass/syntax-extension-fmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,10 +1,10 @@\n use std;\n-import std::_str;\n+import std::str;\n \n fn test(str actual, str expected) {\n   log actual;\n   log expected;\n-  assert (_str::eq(actual, expected));\n+  assert (str::eq(actual, expected));\n }\n \n fn main() {"}, {"sha": "491f192ab4f62dbabd6338e497478e69fff577f3", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -2,34 +2,34 @@\n // xfail-stage1\n // xfail-stage2\n use std;\n-import std::_str;\n-import std::_vec;\n+import std::str;\n+import std::vec;\n import std::io;\n \n fn main() {\n   // Chars of 1, 2, 3, and 4 bytes\n   let vec[char] chs = ['e', '\u00e9', '\u20ac', 0x10000 as char];\n-  let str s = _str::from_chars(chs);\n+  let str s = str::from_chars(chs);\n \n-  assert (_str::byte_len(s) == 10u);\n-  assert (_str::char_len(s) == 4u);\n-  assert (_vec::len[char](_str::to_chars(s)) == 4u);\n-  assert (_str::eq(_str::from_chars(_str::to_chars(s)), s));\n-  assert (_str::char_at(s, 0u) == 'e');\n-  assert (_str::char_at(s, 1u) == '\u00e9');\n+  assert (str::byte_len(s) == 10u);\n+  assert (str::char_len(s) == 4u);\n+  assert (vec::len[char](str::to_chars(s)) == 4u);\n+  assert (str::eq(str::from_chars(str::to_chars(s)), s));\n+  assert (str::char_at(s, 0u) == 'e');\n+  assert (str::char_at(s, 1u) == '\u00e9');\n \n-  assert (_str::is_utf8(_str::bytes(s)));\n-  assert (!_str::is_utf8([0x80_u8]));\n-  assert (!_str::is_utf8([0xc0_u8]));\n-  assert (!_str::is_utf8([0xc0_u8, 0x10_u8]));\n+  assert (str::is_utf8(str::bytes(s)));\n+  assert (!str::is_utf8([0x80_u8]));\n+  assert (!str::is_utf8([0xc0_u8]));\n+  assert (!str::is_utf8([0xc0_u8, 0x10_u8]));\n \n   auto stack = \"a\u00d7c\u20ac\";\n-  assert (_str::pop_char(stack) == '\u20ac');\n-  assert (_str::pop_char(stack) == 'c');\n-  _str::push_char(stack, 'u');\n-  assert (_str::eq(stack, \"a\u00d7u\"));\n-  assert (_str::shift_char(stack) == 'a');\n-  assert (_str::shift_char(stack) == '\u00d7');\n-  _str::unshift_char(stack, '\u00df');\n-  assert (_str::eq(stack, \"\u00dfu\"));\n+  assert (str::pop_char(stack) == '\u20ac');\n+  assert (str::pop_char(stack) == 'c');\n+  str::push_char(stack, 'u');\n+  assert (str::eq(stack, \"a\u00d7u\"));\n+  assert (str::shift_char(stack) == 'a');\n+  assert (str::shift_char(stack) == '\u00d7');\n+  str::unshift_char(stack, '\u00df');\n+  assert (str::eq(stack, \"\u00dfu\"));\n }"}, {"sha": "46b0cd6f2a1ed2d13ea5a034e48ec512e45e2bb7", "filename": "src/test/run-pass/vec-append.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Fvec-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Fvec-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-append.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -4,8 +4,8 @@\n // -*- rust -*-\n \n use std;\n-import std::_str;\n-import std::_vec;\n+import std::str;\n+import std::vec;\n \n \n // FIXME: import std::dbg::const_refcount. Currently\n@@ -53,30 +53,30 @@ fn slow_growth2_helper(str s) {   // ref up: s\n     let vec[str] v = [mumble]; // ref up: v, mumble\n     let acc a = acc(v);           // ref up: a, v\n \n-    log _vec::refcount[str](v);\n-    assert (_vec::refcount[str](v) == 2u);\n+    log vec::refcount[str](v);\n+    assert (vec::refcount[str](v) == 2u);\n \n     a.add(s);                     // ref up: mumble, s.  ref down: v\n \n-    log _vec::refcount[str](v);\n-    log _str::refcount(s);\n-    log _str::refcount(mumble);\n+    log vec::refcount[str](v);\n+    log str::refcount(s);\n+    log str::refcount(mumble);\n \n-    assert (_vec::refcount[str](v) == 1u);\n-    assert (_str::refcount(s) == const_refcount);\n-    assert (_str::refcount(mumble) == const_refcount);\n+    assert (vec::refcount[str](v) == 1u);\n+    assert (str::refcount(s) == const_refcount);\n+    assert (str::refcount(mumble) == const_refcount);\n \n     log v.(0);\n-    log _vec::len[str](v);\n-    assert (_str::eq(v.(0), mumble));\n-    assert (_vec::len[str](v) == 1u);\n+    log vec::len[str](v);\n+    assert (str::eq(v.(0), mumble));\n+    assert (vec::len[str](v) == 1u);\n   }                               // ref down: a, mumble, s, v\n \n-  log _str::refcount(s);\n-  log _str::refcount(mumble);\n+  log str::refcount(s);\n+  log str::refcount(mumble);\n \n-  assert (_str::refcount(s) == const_refcount);\n-  assert (_str::refcount(mumble) == const_refcount);\n+  assert (str::refcount(s) == const_refcount);\n+  assert (str::refcount(mumble) == const_refcount);\n \n   log mumble;\n   log ss;\n@@ -85,8 +85,8 @@ fn slow_growth2_helper(str s) {   // ref up: s\n fn slow_growth2() {\n   let str s = \"hi\";               // ref up: s\n   slow_growth2_helper(s);\n-  log _str::refcount(s);\n-  assert (_str::refcount(s) == const_refcount);\n+  log str::refcount(s);\n+  assert (str::refcount(s) == const_refcount);\n }\n \n fn main() {"}, {"sha": "c46e4d5ee18a79fa46cd15a73797a2c9ad3d53bc", "filename": "src/test/run-pass/vec-ref-count.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Fvec-ref-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d8ef8d51c4db16c477f2ae603cd50e457967b1/src%2Ftest%2Frun-pass%2Fvec-ref-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-ref-count.rs?ref=09d8ef8d51c4db16c477f2ae603cd50e457967b1", "patch": "@@ -1,12 +1,12 @@\n use std;\n-import std::_vec;\n+import std::vec;\n \n fn main() {\n     auto v = [1, 2, 3];\n-    log_err _vec::refcount[int](v);\n-    log_err _vec::refcount[int](v);\n-    log_err _vec::refcount[int](v);\n-    assert (_vec::refcount[int](v) == 1u || _vec::refcount[int](v) == 2u);\n-    assert (_vec::refcount[int](v) == 1u || _vec::refcount[int](v) == 2u);\n+    log_err vec::refcount[int](v);\n+    log_err vec::refcount[int](v);\n+    log_err vec::refcount[int](v);\n+    assert (vec::refcount[int](v) == 1u || vec::refcount[int](v) == 2u);\n+    assert (vec::refcount[int](v) == 1u || vec::refcount[int](v) == 2u);\n }\n "}]}