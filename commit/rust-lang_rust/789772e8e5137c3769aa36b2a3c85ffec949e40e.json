{"sha": "789772e8e5137c3769aa36b2a3c85ffec949e40e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4OTc3MmU4ZTUxMzdjMzc2OWFhMzZiMmEzYzg1ZmZlYzk0OWU0MGU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-18T11:34:13Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-19T12:37:25Z"}, "message": "move input module items to the lower module", "tree": {"sha": "985cd4e568e89e71e4557c5bc161ebd788256525", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/985cd4e568e89e71e4557c5bc161ebd788256525"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/789772e8e5137c3769aa36b2a3c85ffec949e40e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/789772e8e5137c3769aa36b2a3c85ffec949e40e", "html_url": "https://github.com/rust-lang/rust/commit/789772e8e5137c3769aa36b2a3c85ffec949e40e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/789772e8e5137c3769aa36b2a3c85ffec949e40e/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d7f1880650f62d7fb86dbb55562925e0be1e6ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d7f1880650f62d7fb86dbb55562925e0be1e6ec", "html_url": "https://github.com/rust-lang/rust/commit/3d7f1880650f62d7fb86dbb55562925e0be1e6ec"}], "stats": {"total": 415, "additions": 211, "deletions": 204}, "files": [{"sha": "4a3e0fed24c41138e7f1d85e67a9b18f651144b7", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/789772e8e5137c3769aa36b2a3c85ffec949e40e/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/789772e8e5137c3769aa36b2a3c85ffec949e40e/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=789772e8e5137c3769aa36b2a3c85ffec949e40e", "patch": "@@ -10,7 +10,7 @@ use crate::{\n     FnSignature, FnScopes,\n     macros::MacroExpansion,\n     module_tree::{ModuleId, ModuleTree},\n-    nameres::{ItemMap, InputModuleItems},\n+    nameres::{ItemMap, lower::InputModuleItems},\n     ty::{InferenceResult, Ty, method_resolution::CrateImplBlocks},\n     adt::{StructData, EnumData, EnumVariantData},\n     impl_block::ModuleImplBlocks,\n@@ -58,7 +58,7 @@ pub trait HirDatabase:\n     #[salsa::invoke(crate::module_tree::Submodule::submodules_query)]\n     fn submodules(&self, source: SourceItemId) -> Arc<Vec<crate::module_tree::Submodule>>;\n \n-    #[salsa::invoke(query_definitions::input_module_items)]\n+    #[salsa::invoke(crate::nameres::lower::InputModuleItems::input_module_items_query)]\n     fn input_module_items(\n         &self,\n         source_root_id: SourceRootId,"}, {"sha": "aea95e08ca5f86c4214130b30c4949a3eb22b2bf", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 6, "deletions": 147, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/789772e8e5137c3769aa36b2a3c85ffec949e40e/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/789772e8e5137c3769aa36b2a3c85ffec949e40e/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=789772e8e5137c3769aa36b2a3c85ffec949e40e", "patch": "@@ -14,23 +14,20 @@\n //! modifications (that is, typing inside a function should not change IMIs),\n //! so that the results of name resolution can be preserved unless the module\n //! structure itself is modified.\n+pub(crate) mod lower;\n+use lower::*;\n+\n use std::sync::Arc;\n \n use rustc_hash::{FxHashMap, FxHashSet};\n-use ra_syntax::{\n-    TextRange,\n-    SyntaxKind::{self, *},\n-    ast::{self, AstNode}\n-};\n-use ra_db::{SourceRootId, FileId};\n+use ra_syntax::SyntaxKind::*;\n+use ra_db::SourceRootId;\n \n use crate::{\n-    HirFileId,\n     DefId, DefLoc, DefKind,\n-    SourceItemId, SourceFileItemId, SourceFileItems,\n     Path, PathKind,\n     HirDatabase, Crate,\n-    Name, AsName,\n+    Name,\n     module_tree::{ModuleId, ModuleTree},\n };\n \n@@ -56,64 +53,6 @@ impl ModuleScope {\n     }\n }\n \n-/// A set of items and imports declared inside a module, without relation to\n-/// other modules.\n-///\n-/// This sits in-between raw syntax and name resolution and allows us to avoid\n-/// recomputing name res: if two instance of `InputModuleItems` are the same, we\n-/// can avoid redoing name resolution.\n-#[derive(Debug, Default, PartialEq, Eq)]\n-pub struct InputModuleItems {\n-    pub(crate) items: Vec<ModuleItem>,\n-    imports: Vec<Import>,\n-}\n-\n-#[derive(Debug, PartialEq, Eq)]\n-pub(crate) struct ModuleItem {\n-    pub(crate) id: SourceItemId,\n-    pub(crate) name: Name,\n-    kind: SyntaxKind,\n-    vis: Vis,\n-}\n-\n-#[derive(Debug, PartialEq, Eq)]\n-enum Vis {\n-    // Priv,\n-    Other,\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-struct Import {\n-    path: Path,\n-    kind: ImportKind,\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub struct NamedImport {\n-    pub file_item_id: SourceFileItemId,\n-    pub relative_range: TextRange,\n-}\n-\n-impl NamedImport {\n-    // FIXME: this is only here for one use-case in completion. Seems like a\n-    // pretty gross special case.\n-    pub fn range(&self, db: &impl HirDatabase, file_id: FileId) -> TextRange {\n-        let source_item_id = SourceItemId {\n-            file_id: file_id.into(),\n-            item_id: Some(self.file_item_id),\n-        };\n-        let syntax = db.file_item(source_item_id);\n-        let offset = syntax.range().start();\n-        self.relative_range + offset\n-    }\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-enum ImportKind {\n-    Glob,\n-    Named(NamedImport),\n-}\n-\n /// `Resolution` is basically `DefId` atm, but it should account for stuff like\n /// multiple namespaces, ambiguity and errors.\n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -210,86 +149,6 @@ impl<T> PerNs<T> {\n     }\n }\n \n-impl InputModuleItems {\n-    pub(crate) fn add_item(\n-        &mut self,\n-        file_id: HirFileId,\n-        file_items: &SourceFileItems,\n-        item: &ast::ModuleItem,\n-    ) -> Option<()> {\n-        match item.kind() {\n-            ast::ModuleItemKind::StructDef(it) => {\n-                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n-            }\n-            ast::ModuleItemKind::EnumDef(it) => {\n-                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n-            }\n-            ast::ModuleItemKind::FnDef(it) => {\n-                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n-            }\n-            ast::ModuleItemKind::TraitDef(it) => {\n-                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n-            }\n-            ast::ModuleItemKind::TypeDef(it) => {\n-                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n-            }\n-            ast::ModuleItemKind::ImplBlock(_) => {\n-                // impls don't define items\n-            }\n-            ast::ModuleItemKind::UseItem(it) => self.add_use_item(file_items, it),\n-            ast::ModuleItemKind::ExternCrateItem(_) => {\n-                // TODO\n-            }\n-            ast::ModuleItemKind::ConstDef(it) => {\n-                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n-            }\n-            ast::ModuleItemKind::StaticDef(it) => {\n-                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n-            }\n-            ast::ModuleItemKind::Module(it) => {\n-                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n-            }\n-        }\n-        Some(())\n-    }\n-\n-    fn add_use_item(&mut self, file_items: &SourceFileItems, item: &ast::UseItem) {\n-        let file_item_id = file_items.id_of_unchecked(item.syntax());\n-        let start_offset = item.syntax().range().start();\n-        Path::expand_use_item(item, |path, range| {\n-            let kind = match range {\n-                None => ImportKind::Glob,\n-                Some(range) => ImportKind::Named(NamedImport {\n-                    file_item_id,\n-                    relative_range: range - start_offset,\n-                }),\n-            };\n-            self.imports.push(Import { kind, path })\n-        })\n-    }\n-}\n-\n-impl ModuleItem {\n-    fn new(\n-        file_id: HirFileId,\n-        file_items: &SourceFileItems,\n-        item: &impl ast::NameOwner,\n-    ) -> Option<ModuleItem> {\n-        let name = item.name()?.as_name();\n-        let kind = item.syntax().kind();\n-        let vis = Vis::Other;\n-        let item_id = Some(file_items.id_of_unchecked(item.syntax()));\n-        let id = SourceItemId { file_id, item_id };\n-        let res = ModuleItem {\n-            id,\n-            name,\n-            kind,\n-            vis,\n-        };\n-        Some(res)\n-    }\n-}\n-\n pub(crate) struct Resolver<'a, DB> {\n     db: &'a DB,\n     input: &'a FxHashMap<ModuleId, Arc<InputModuleItems>>,"}, {"sha": "dd3bf245f0b1a63ad7ab512ed60445d035bb2382", "filename": "crates/ra_hir/src/nameres/lower.rs", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/789772e8e5137c3769aa36b2a3c85ffec949e40e/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/789772e8e5137c3769aa36b2a3c85ffec949e40e/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs?ref=789772e8e5137c3769aa36b2a3c85ffec949e40e", "patch": "@@ -0,0 +1,200 @@\n+use std::sync::Arc;\n+\n+use ra_syntax::{\n+    TextRange, SyntaxKind, AstNode,\n+    ast::{self, ModuleItemOwner},\n+};\n+use ra_db::{FileId, SourceRootId};\n+\n+use crate::{\n+    SourceItemId, SourceFileItemId, Path, ModuleSource, HirDatabase, Name, SourceFileItems,\n+    HirFileId, MacroCallLoc, AsName,\n+    module_tree::ModuleId\n+};\n+/// A set of items and imports declared inside a module, without relation to\n+/// other modules.\n+///\n+/// This sits in-between raw syntax and name resolution and allows us to avoid\n+/// recomputing name res: if two instance of `InputModuleItems` are the same, we\n+/// can avoid redoing name resolution.\n+#[derive(Debug, Default, PartialEq, Eq)]\n+pub struct InputModuleItems {\n+    pub(crate) items: Vec<ModuleItem>,\n+    pub(super) imports: Vec<Import>,\n+}\n+\n+impl InputModuleItems {\n+    pub(crate) fn input_module_items_query(\n+        db: &impl HirDatabase,\n+        source_root_id: SourceRootId,\n+        module_id: ModuleId,\n+    ) -> Arc<InputModuleItems> {\n+        let module_tree = db.module_tree(source_root_id);\n+        let source = module_id.source(&module_tree);\n+        let file_id = source.file_id;\n+        let source = ModuleSource::from_source_item_id(db, source);\n+        let file_items = db.file_items(file_id);\n+        let fill = |acc: &mut InputModuleItems, items: &mut Iterator<Item = ast::ItemOrMacro>| {\n+            for item in items {\n+                match item {\n+                    ast::ItemOrMacro::Item(it) => {\n+                        acc.add_item(file_id, &file_items, it);\n+                    }\n+                    ast::ItemOrMacro::Macro(macro_call) => {\n+                        let item_id = file_items.id_of_unchecked(macro_call.syntax());\n+                        let loc = MacroCallLoc {\n+                            source_root_id,\n+                            module_id,\n+                            source_item_id: SourceItemId {\n+                                file_id,\n+                                item_id: Some(item_id),\n+                            },\n+                        };\n+                        let id = loc.id(db);\n+                        let file_id = HirFileId::from(id);\n+                        let file_items = db.file_items(file_id);\n+                        //FIXME: expand recursively\n+                        for item in db.hir_source_file(file_id).items() {\n+                            acc.add_item(file_id, &file_items, item);\n+                        }\n+                    }\n+                }\n+            }\n+        };\n+\n+        let mut res = InputModuleItems::default();\n+        match source {\n+            ModuleSource::SourceFile(it) => fill(&mut res, &mut it.items_with_macros()),\n+            ModuleSource::Module(it) => {\n+                if let Some(item_list) = it.item_list() {\n+                    fill(&mut res, &mut item_list.items_with_macros())\n+                }\n+            }\n+        };\n+        Arc::new(res)\n+    }\n+\n+    pub(crate) fn add_item(\n+        &mut self,\n+        file_id: HirFileId,\n+        file_items: &SourceFileItems,\n+        item: &ast::ModuleItem,\n+    ) -> Option<()> {\n+        match item.kind() {\n+            ast::ModuleItemKind::StructDef(it) => {\n+                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n+            }\n+            ast::ModuleItemKind::EnumDef(it) => {\n+                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n+            }\n+            ast::ModuleItemKind::FnDef(it) => {\n+                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n+            }\n+            ast::ModuleItemKind::TraitDef(it) => {\n+                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n+            }\n+            ast::ModuleItemKind::TypeDef(it) => {\n+                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n+            }\n+            ast::ModuleItemKind::ImplBlock(_) => {\n+                // impls don't define items\n+            }\n+            ast::ModuleItemKind::UseItem(it) => self.add_use_item(file_items, it),\n+            ast::ModuleItemKind::ExternCrateItem(_) => {\n+                // TODO\n+            }\n+            ast::ModuleItemKind::ConstDef(it) => {\n+                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n+            }\n+            ast::ModuleItemKind::StaticDef(it) => {\n+                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n+            }\n+            ast::ModuleItemKind::Module(it) => {\n+                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n+            }\n+        }\n+        Some(())\n+    }\n+\n+    fn add_use_item(&mut self, file_items: &SourceFileItems, item: &ast::UseItem) {\n+        let file_item_id = file_items.id_of_unchecked(item.syntax());\n+        let start_offset = item.syntax().range().start();\n+        Path::expand_use_item(item, |path, range| {\n+            let kind = match range {\n+                None => ImportKind::Glob,\n+                Some(range) => ImportKind::Named(NamedImport {\n+                    file_item_id,\n+                    relative_range: range - start_offset,\n+                }),\n+            };\n+            self.imports.push(Import { kind, path })\n+        })\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub(super) enum Vis {\n+    // Priv,\n+    Other,\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub(crate) struct ModuleItem {\n+    pub(crate) id: SourceItemId,\n+    pub(crate) name: Name,\n+    pub(super) kind: SyntaxKind,\n+    pub(super) vis: Vis,\n+}\n+\n+impl ModuleItem {\n+    fn new(\n+        file_id: HirFileId,\n+        file_items: &SourceFileItems,\n+        item: &impl ast::NameOwner,\n+    ) -> Option<ModuleItem> {\n+        let name = item.name()?.as_name();\n+        let kind = item.syntax().kind();\n+        let vis = Vis::Other;\n+        let item_id = Some(file_items.id_of_unchecked(item.syntax()));\n+        let id = SourceItemId { file_id, item_id };\n+        let res = ModuleItem {\n+            id,\n+            name,\n+            kind,\n+            vis,\n+        };\n+        Some(res)\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub(super) struct Import {\n+    pub(super) path: Path,\n+    pub(super) kind: ImportKind,\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub struct NamedImport {\n+    pub file_item_id: SourceFileItemId,\n+    pub relative_range: TextRange,\n+}\n+\n+impl NamedImport {\n+    // FIXME: this is only here for one use-case in completion. Seems like a\n+    // pretty gross special case.\n+    pub fn range(&self, db: &impl HirDatabase, file_id: FileId) -> TextRange {\n+        let source_item_id = SourceItemId {\n+            file_id: file_id.into(),\n+            item_id: Some(self.file_item_id),\n+        };\n+        let syntax = db.file_item(source_item_id);\n+        let offset = syntax.range().start();\n+        self.relative_range + offset\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub(super) enum ImportKind {\n+    Glob,\n+    Named(NamedImport),\n+}"}, {"sha": "985a02410722789591bef7a4dbab4b5251fb7ce9", "filename": "crates/ra_hir/src/query_definitions.rs", "status": "modified", "additions": 3, "deletions": 55, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/789772e8e5137c3769aa36b2a3c85ffec949e40e/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/789772e8e5137c3769aa36b2a3c85ffec949e40e/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs?ref=789772e8e5137c3769aa36b2a3c85ffec949e40e", "patch": "@@ -6,16 +6,14 @@ use std::{\n use rustc_hash::FxHashMap;\n use ra_syntax::{\n     AstNode, SyntaxNode, TreeArc,\n-    ast::{self, ModuleItemOwner}\n };\n use ra_db::SourceRootId;\n \n use crate::{\n-    SourceFileItems, SourceItemId, DefId, HirFileId, ModuleSource,\n-    MacroCallLoc, FnScopes,\n+    SourceFileItems, SourceItemId, DefId, HirFileId,\n+    FnScopes,\n     db::HirDatabase,\n-    module_tree::ModuleId,\n-    nameres::{InputModuleItems, ItemMap, Resolver},\n+    nameres::{ItemMap, Resolver},\n };\n \n pub(super) fn fn_scopes(db: &impl HirDatabase, def_id: DefId) -> Arc<FnScopes> {\n@@ -43,56 +41,6 @@ pub(super) fn file_item(\n     }\n }\n \n-pub(super) fn input_module_items(\n-    db: &impl HirDatabase,\n-    source_root_id: SourceRootId,\n-    module_id: ModuleId,\n-) -> Arc<InputModuleItems> {\n-    let module_tree = db.module_tree(source_root_id);\n-    let source = module_id.source(&module_tree);\n-    let file_id = source.file_id;\n-    let source = ModuleSource::from_source_item_id(db, source);\n-    let file_items = db.file_items(file_id);\n-    let fill = |acc: &mut InputModuleItems, items: &mut Iterator<Item = ast::ItemOrMacro>| {\n-        for item in items {\n-            match item {\n-                ast::ItemOrMacro::Item(it) => {\n-                    acc.add_item(file_id, &file_items, it);\n-                }\n-                ast::ItemOrMacro::Macro(macro_call) => {\n-                    let item_id = file_items.id_of_unchecked(macro_call.syntax());\n-                    let loc = MacroCallLoc {\n-                        source_root_id,\n-                        module_id,\n-                        source_item_id: SourceItemId {\n-                            file_id,\n-                            item_id: Some(item_id),\n-                        },\n-                    };\n-                    let id = loc.id(db);\n-                    let file_id = HirFileId::from(id);\n-                    let file_items = db.file_items(file_id);\n-                    //FIXME: expand recursively\n-                    for item in db.hir_source_file(file_id).items() {\n-                        acc.add_item(file_id, &file_items, item);\n-                    }\n-                }\n-            }\n-        }\n-    };\n-\n-    let mut res = InputModuleItems::default();\n-    match source {\n-        ModuleSource::SourceFile(it) => fill(&mut res, &mut it.items_with_macros()),\n-        ModuleSource::Module(it) => {\n-            if let Some(item_list) = it.item_list() {\n-                fill(&mut res, &mut item_list.items_with_macros())\n-            }\n-        }\n-    };\n-    Arc::new(res)\n-}\n-\n pub(super) fn item_map(db: &impl HirDatabase, source_root: SourceRootId) -> Arc<ItemMap> {\n     let start = Instant::now();\n     let module_tree = db.module_tree(source_root);"}]}