{"sha": "fe9c64d0af379e6e48ac1e798d65e2031265aa22", "node_id": "C_kwDOAAsO6NoAKGZlOWM2NGQwYWYzNzllNmU0OGFjMWU3OThkNjVlMjAzMTI2NWFhMjI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-25T11:17:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-25T11:17:34Z"}, "message": "Auto merge of #97388 - Dylan-DPC:rollup-tfuc4tf, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #95953 (Modify MIR building to drop repeat expressions with length zero)\n - #96913 (RFC3239: Implement `cfg(target)` - Part 2)\n - #97233 ([RFC 2011] Library code)\n - #97370 (Minor improvement on else-no-if diagnostic)\n - #97384 (Fix metadata stats.)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "ad52a937e49f7e13e9eb62240670e911808b7815", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad52a937e49f7e13e9eb62240670e911808b7815"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe9c64d0af379e6e48ac1e798d65e2031265aa22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe9c64d0af379e6e48ac1e798d65e2031265aa22", "html_url": "https://github.com/rust-lang/rust/commit/fe9c64d0af379e6e48ac1e798d65e2031265aa22", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe9c64d0af379e6e48ac1e798d65e2031265aa22/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a99c5f504ab65a0fd9d60f515811e1d9cff8c0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a99c5f504ab65a0fd9d60f515811e1d9cff8c0a", "html_url": "https://github.com/rust-lang/rust/commit/4a99c5f504ab65a0fd9d60f515811e1d9cff8c0a"}, {"sha": "3c11bf3d2b345f38f920e5e7d88abead996ad775", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c11bf3d2b345f38f920e5e7d88abead996ad775", "html_url": "https://github.com/rust-lang/rust/commit/3c11bf3d2b345f38f920e5e7d88abead996ad775"}], "stats": {"total": 791, "additions": 678, "deletions": 113}, "files": [{"sha": "c8f1e1dbb01514ff3a9b20fefe93f0af834f4733", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 83, "deletions": 58, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c64d0af379e6e48ac1e798d65e2031265aa22/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c64d0af379e6e48ac1e798d65e2031265aa22/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=fe9c64d0af379e6e48ac1e798d65e2031265aa22", "patch": "@@ -454,6 +454,15 @@ pub fn find_crate_name(sess: &Session, attrs: &[Attribute]) -> Option<Symbol> {\n     sess.first_attr_value_str_by_name(attrs, sym::crate_name)\n }\n \n+#[derive(Clone, Debug)]\n+pub struct Condition {\n+    pub name: Symbol,\n+    pub name_span: Span,\n+    pub value: Option<Symbol>,\n+    pub value_span: Option<Span>,\n+    pub span: Span,\n+}\n+\n /// Tests if a cfg-pattern matches the cfg set\n pub fn cfg_matches(\n     cfg: &ast::MetaItem,\n@@ -462,70 +471,42 @@ pub fn cfg_matches(\n     features: Option<&Features>,\n ) -> bool {\n     eval_condition(cfg, sess, features, &mut |cfg| {\n-        try_gate_cfg(cfg, sess, features);\n-        let error = |span, msg| {\n-            sess.span_diagnostic.span_err(span, msg);\n-            true\n-        };\n-        if cfg.path.segments.len() != 1 {\n-            return error(cfg.path.span, \"`cfg` predicate key must be an identifier\");\n-        }\n-        match &cfg.kind {\n-            MetaItemKind::List(..) => {\n-                error(cfg.span, \"unexpected parentheses after `cfg` predicate key\")\n-            }\n-            MetaItemKind::NameValue(lit) if !lit.kind.is_str() => {\n-                handle_errors(\n-                    sess,\n-                    lit.span,\n-                    AttrError::UnsupportedLiteral(\n-                        \"literal in `cfg` predicate value must be a string\",\n-                        lit.kind.is_bytestr(),\n-                    ),\n+        try_gate_cfg(cfg.name, cfg.span, sess, features);\n+        if let Some(names_valid) = &sess.check_config.names_valid {\n+            if !names_valid.contains(&cfg.name) {\n+                sess.buffer_lint_with_diagnostic(\n+                    UNEXPECTED_CFGS,\n+                    cfg.span,\n+                    lint_node_id,\n+                    \"unexpected `cfg` condition name\",\n+                    BuiltinLintDiagnostics::UnexpectedCfg((cfg.name, cfg.name_span), None),\n                 );\n-                true\n             }\n-            MetaItemKind::NameValue(..) | MetaItemKind::Word => {\n-                let ident = cfg.ident().expect(\"multi-segment cfg predicate\");\n-                let name = ident.name;\n-                let value = cfg.value_str();\n-                if let Some(names_valid) = &sess.check_config.names_valid {\n-                    if !names_valid.contains(&name) {\n-                        sess.buffer_lint_with_diagnostic(\n-                            UNEXPECTED_CFGS,\n-                            cfg.span,\n-                            lint_node_id,\n-                            \"unexpected `cfg` condition name\",\n-                            BuiltinLintDiagnostics::UnexpectedCfg((name, ident.span), None),\n-                        );\n-                    }\n-                }\n-                if let Some(value) = value {\n-                    if let Some(values) = &sess.check_config.values_valid.get(&name) {\n-                        if !values.contains(&value) {\n-                            sess.buffer_lint_with_diagnostic(\n-                                UNEXPECTED_CFGS,\n-                                cfg.span,\n-                                lint_node_id,\n-                                \"unexpected `cfg` condition value\",\n-                                BuiltinLintDiagnostics::UnexpectedCfg(\n-                                    (name, ident.span),\n-                                    Some((value, cfg.name_value_literal_span().unwrap())),\n-                                ),\n-                            );\n-                        }\n-                    }\n+        }\n+        if let Some(value) = cfg.value {\n+            if let Some(values) = &sess.check_config.values_valid.get(&cfg.name) {\n+                if !values.contains(&value) {\n+                    sess.buffer_lint_with_diagnostic(\n+                        UNEXPECTED_CFGS,\n+                        cfg.span,\n+                        lint_node_id,\n+                        \"unexpected `cfg` condition value\",\n+                        BuiltinLintDiagnostics::UnexpectedCfg(\n+                            (cfg.name, cfg.name_span),\n+                            cfg.value_span.map(|vs| (value, vs)),\n+                        ),\n+                    );\n                 }\n-                sess.config.contains(&(name, value))\n             }\n         }\n+        sess.config.contains(&(cfg.name, cfg.value))\n     })\n }\n \n-fn try_gate_cfg(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Features>) {\n-    let gate = find_gated_cfg(|sym| cfg.has_name(sym));\n+fn try_gate_cfg(name: Symbol, span: Span, sess: &ParseSess, features: Option<&Features>) {\n+    let gate = find_gated_cfg(|sym| sym == name);\n     if let (Some(feats), Some(gated_cfg)) = (features, gate) {\n-        gate_cfg(&gated_cfg, cfg.span, sess, feats);\n+        gate_cfg(&gated_cfg, span, sess, feats);\n     }\n }\n \n@@ -563,11 +544,11 @@ pub fn eval_condition(\n     cfg: &ast::MetaItem,\n     sess: &ParseSess,\n     features: Option<&Features>,\n-    eval: &mut impl FnMut(&ast::MetaItem) -> bool,\n+    eval: &mut impl FnMut(Condition) -> bool,\n ) -> bool {\n     match cfg.kind {\n         ast::MetaItemKind::List(ref mis) if cfg.name_or_empty() == sym::version => {\n-            try_gate_cfg(cfg, sess, features);\n+            try_gate_cfg(sym::version, cfg.span, sess, features);\n             let (min_version, span) = match &mis[..] {\n                 [NestedMetaItem::Literal(Lit { kind: LitKind::Str(sym, ..), span, .. })] => {\n                     (sym, span)\n@@ -649,6 +630,25 @@ pub fn eval_condition(\n \n                     !eval_condition(mis[0].meta_item().unwrap(), sess, features, eval)\n                 }\n+                sym::target => {\n+                    if let Some(features) = features && !features.cfg_target_compact {\n+                        feature_err(\n+                            sess,\n+                            sym::cfg_target_compact,\n+                            cfg.span,\n+                            &\"compact `cfg(target(..))` is experimental and subject to change\"\n+                        ).emit();\n+                    }\n+\n+                    mis.iter().fold(true, |res, mi| {\n+                        let mut mi = mi.meta_item().unwrap().clone();\n+                        if let [seg, ..] = &mut mi.path.segments[..] {\n+                            seg.ident.name = Symbol::intern(&format!(\"target_{}\", seg.ident.name));\n+                        }\n+\n+                        res & eval_condition(&mi, sess, features, eval)\n+                    })\n+                }\n                 _ => {\n                     struct_span_err!(\n                         sess.span_diagnostic,\n@@ -662,7 +662,32 @@ pub fn eval_condition(\n                 }\n             }\n         }\n-        ast::MetaItemKind::Word | ast::MetaItemKind::NameValue(..) => eval(cfg),\n+        ast::MetaItemKind::Word | MetaItemKind::NameValue(..) if cfg.path.segments.len() != 1 => {\n+            sess.span_diagnostic\n+                .span_err(cfg.path.span, \"`cfg` predicate key must be an identifier\");\n+            true\n+        }\n+        MetaItemKind::NameValue(ref lit) if !lit.kind.is_str() => {\n+            handle_errors(\n+                sess,\n+                lit.span,\n+                AttrError::UnsupportedLiteral(\n+                    \"literal in `cfg` predicate value must be a string\",\n+                    lit.kind.is_bytestr(),\n+                ),\n+            );\n+            true\n+        }\n+        ast::MetaItemKind::Word | ast::MetaItemKind::NameValue(..) => {\n+            let ident = cfg.ident().expect(\"multi-segment cfg predicate\");\n+            eval(Condition {\n+                name: ident.name,\n+                name_span: ident.span,\n+                value: cfg.value_str(),\n+                value_span: cfg.name_value_literal_span(),\n+                span: cfg.span,\n+            })\n+        }\n     }\n }\n "}, {"sha": "c3f9f0cf3621f8edf806b25bfa8f19e05abf8e48", "filename": "compiler/rustc_attr/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c64d0af379e6e48ac1e798d65e2031265aa22/compiler%2Frustc_attr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c64d0af379e6e48ac1e798d65e2031265aa22/compiler%2Frustc_attr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Flib.rs?ref=fe9c64d0af379e6e48ac1e798d65e2031265aa22", "patch": "@@ -4,6 +4,7 @@\n //! The goal is to move the definition of `MetaItem` and things that don't need to be in `syntax`\n //! to this crate.\n \n+#![feature(let_chains)]\n #![feature(let_else)]\n \n #[macro_use]"}, {"sha": "5a02661513ca72f416dbf5e078af7538ca9ab0ad", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c64d0af379e6e48ac1e798d65e2031265aa22/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c64d0af379e6e48ac1e798d65e2031265aa22/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=fe9c64d0af379e6e48ac1e798d65e2031265aa22", "patch": "@@ -319,6 +319,8 @@ declare_features! (\n     (active, cfg_sanitize, \"1.41.0\", Some(39699), None),\n     /// Allows `cfg(target_abi = \"...\")`.\n     (active, cfg_target_abi, \"1.55.0\", Some(80970), None),\n+    /// Allows `cfg(target(abi = \"...\"))`.\n+    (active, cfg_target_compact, \"1.63.0\", Some(96901), None),\n     /// Allows `cfg(target_has_atomic_load_store = \"...\")`.\n     (active, cfg_target_has_atomic, \"1.60.0\", Some(94039), None),\n     /// Allows `cfg(target_has_atomic_equal_alignment = \"...\")`."}, {"sha": "63103061c9c29ba61f64bb34a45ec4ffb7c45454", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 69, "deletions": 23, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c64d0af379e6e48ac1e798d65e2031265aa22/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c64d0af379e6e48ac1e798d65e2031265aa22/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=fe9c64d0af379e6e48ac1e798d65e2031265aa22", "patch": "@@ -536,9 +536,11 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n     fn encode_crate_root(&mut self) -> LazyValue<CrateRoot> {\n         let tcx = self.tcx;\n-        let mut i = self.position();\n+        let mut i = 0;\n+        let preamble_bytes = self.position() - i;\n \n         // Encode the crate deps\n+        i = self.position();\n         let crate_deps = self.encode_crate_deps();\n         let dylib_dependency_formats = self.encode_dylib_dependency_formats();\n         let dep_bytes = self.position() - i;\n@@ -564,7 +566,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let native_libraries = self.encode_native_libraries();\n         let native_lib_bytes = self.position() - i;\n \n+        i = self.position();\n         let foreign_modules = self.encode_foreign_modules();\n+        let foreign_modules_bytes = self.position() - i;\n \n         // Encode DefPathTable\n         i = self.position();\n@@ -584,6 +588,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         i = self.position();\n         let incoherent_impls = self.encode_incoherent_impls();\n         let incoherent_impls_bytes = self.position() - i;\n+\n         // Encode MIR.\n         i = self.position();\n         self.encode_mir();\n@@ -596,6 +601,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let item_bytes = self.position() - i;\n \n         // Encode the allocation index\n+        i = self.position();\n         let interpret_alloc_index = {\n             let mut interpret_alloc_index = Vec::new();\n             let mut n = 0;\n@@ -618,6 +624,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             }\n             self.lazy_array(interpret_alloc_index)\n         };\n+        let interpret_alloc_index_bytes = self.position() - i;\n \n         // Encode the proc macro data. This affects 'tables',\n         // so we need to do this before we encode the tables\n@@ -662,9 +669,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let source_map = self.encode_source_map();\n         let source_map_bytes = self.position() - i;\n \n+        i = self.position();\n         let attrs = tcx.hir().krate_attrs();\n         let has_default_lib_allocator = tcx.sess.contains_name(&attrs, sym::default_lib_allocator);\n-\n         let root = self.lazy(CrateRoot {\n             name: tcx.crate_name(LOCAL_CRATE),\n             extra_filename: tcx.sess.opts.cg.extra_filename.clone(),\n@@ -707,9 +714,34 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             expn_hashes,\n             def_path_hash_map,\n         });\n+        let final_bytes = self.position() - i;\n \n         let total_bytes = self.position();\n \n+        let computed_total_bytes = preamble_bytes\n+            + dep_bytes\n+            + lib_feature_bytes\n+            + lang_item_bytes\n+            + diagnostic_item_bytes\n+            + native_lib_bytes\n+            + foreign_modules_bytes\n+            + def_path_table_bytes\n+            + traits_bytes\n+            + impls_bytes\n+            + incoherent_impls_bytes\n+            + mir_bytes\n+            + item_bytes\n+            + interpret_alloc_index_bytes\n+            + proc_macro_data_bytes\n+            + tables_bytes\n+            + debugger_visualizers_bytes\n+            + exported_symbols_bytes\n+            + hygiene_bytes\n+            + def_path_hash_map_bytes\n+            + source_map_bytes\n+            + final_bytes;\n+        assert_eq!(total_bytes, computed_total_bytes);\n+\n         if tcx.sess.meta_stats() {\n             let mut zero_bytes = 0;\n             for e in self.opaque.data.iter() {\n@@ -718,27 +750,41 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 }\n             }\n \n-            eprintln!(\"metadata stats:\");\n-            eprintln!(\"                  dep bytes: {}\", dep_bytes);\n-            eprintln!(\"          lib feature bytes: {}\", lib_feature_bytes);\n-            eprintln!(\"            lang item bytes: {}\", lang_item_bytes);\n-            eprintln!(\"      diagnostic item bytes: {}\", diagnostic_item_bytes);\n-            eprintln!(\"               native bytes: {}\", native_lib_bytes);\n-            eprintln!(\" debugger visualizers bytes: {}\", debugger_visualizers_bytes);\n-            eprintln!(\"           source_map bytes: {}\", source_map_bytes);\n-            eprintln!(\"               traits bytes: {}\", traits_bytes);\n-            eprintln!(\"                impls bytes: {}\", impls_bytes);\n-            eprintln!(\"     incoherent_impls bytes: {}\", incoherent_impls_bytes);\n-            eprintln!(\"         exp. symbols bytes: {}\", exported_symbols_bytes);\n-            eprintln!(\"       def-path table bytes: {}\", def_path_table_bytes);\n-            eprintln!(\"      def-path hashes bytes: {}\", def_path_hash_map_bytes);\n-            eprintln!(\"      proc-macro-data-bytes: {}\", proc_macro_data_bytes);\n-            eprintln!(\"                  mir bytes: {}\", mir_bytes);\n-            eprintln!(\"                 item bytes: {}\", item_bytes);\n-            eprintln!(\"                table bytes: {}\", tables_bytes);\n-            eprintln!(\"              hygiene bytes: {}\", hygiene_bytes);\n-            eprintln!(\"                 zero bytes: {}\", zero_bytes);\n-            eprintln!(\"                total bytes: {}\", total_bytes);\n+            let perc = |bytes| (bytes * 100) as f64 / total_bytes as f64;\n+            let p = |label, bytes| {\n+                eprintln!(\"{:>21}: {:>8} bytes ({:4.1}%)\", label, bytes, perc(bytes));\n+            };\n+\n+            eprintln!(\"\");\n+            eprintln!(\n+                \"{} metadata bytes, of which {} bytes ({:.1}%) are zero\",\n+                total_bytes,\n+                zero_bytes,\n+                perc(zero_bytes)\n+            );\n+            p(\"preamble\", preamble_bytes);\n+            p(\"dep\", dep_bytes);\n+            p(\"lib feature\", lib_feature_bytes);\n+            p(\"lang item\", lang_item_bytes);\n+            p(\"diagnostic item\", diagnostic_item_bytes);\n+            p(\"native lib\", native_lib_bytes);\n+            p(\"foreign modules\", foreign_modules_bytes);\n+            p(\"def-path table\", def_path_table_bytes);\n+            p(\"traits\", traits_bytes);\n+            p(\"impls\", impls_bytes);\n+            p(\"incoherent_impls\", incoherent_impls_bytes);\n+            p(\"mir\", mir_bytes);\n+            p(\"item\", item_bytes);\n+            p(\"interpret_alloc_index\", interpret_alloc_index_bytes);\n+            p(\"proc-macro-data\", proc_macro_data_bytes);\n+            p(\"tables\", tables_bytes);\n+            p(\"debugger visualizers\", debugger_visualizers_bytes);\n+            p(\"exported symbols\", exported_symbols_bytes);\n+            p(\"hygiene\", hygiene_bytes);\n+            p(\"def-path hashes\", def_path_hash_map_bytes);\n+            p(\"source_map\", source_map_bytes);\n+            p(\"final\", final_bytes);\n+            eprintln!(\"\");\n         }\n \n         root"}, {"sha": "0a0c7659b086dc926c05cea97b564c23b31b762b", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 45, "deletions": 5, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c64d0af379e6e48ac1e798d65e2031265aa22/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c64d0af379e6e48ac1e798d65e2031265aa22/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=fe9c64d0af379e6e48ac1e798d65e2031265aa22", "patch": "@@ -52,11 +52,20 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 })\n             }\n             ExprKind::Repeat { value, count } => {\n-                let value_operand = unpack!(\n-                    block =\n-                        this.as_operand(block, scope, &this.thir[value], None, NeedsTemporary::No)\n-                );\n-                block.and(Rvalue::Repeat(value_operand, count))\n+                if Some(0) == count.try_eval_usize(this.tcx, this.param_env) {\n+                    this.build_zero_repeat(block, value, scope, source_info)\n+                } else {\n+                    let value_operand = unpack!(\n+                        block = this.as_operand(\n+                            block,\n+                            scope,\n+                            &this.thir[value],\n+                            None,\n+                            NeedsTemporary::No\n+                        )\n+                    );\n+                    block.and(Rvalue::Repeat(value_operand, count))\n+                }\n             }\n             ExprKind::Binary { op, lhs, rhs } => {\n                 let lhs = unpack!(\n@@ -516,6 +525,37 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n+    fn build_zero_repeat(\n+        &mut self,\n+        mut block: BasicBlock,\n+        value: ExprId,\n+        scope: Option<region::Scope>,\n+        outer_source_info: SourceInfo,\n+    ) -> BlockAnd<Rvalue<'tcx>> {\n+        let this = self;\n+        let value = &this.thir[value];\n+        let elem_ty = value.ty;\n+        if let Some(Category::Constant) = Category::of(&value.kind) {\n+            // Repeating a const does nothing\n+        } else {\n+            // For a non-const, we may need to generate an appropriate `Drop`\n+            let value_operand =\n+                unpack!(block = this.as_operand(block, scope, value, None, NeedsTemporary::No));\n+            if let Operand::Move(to_drop) = value_operand {\n+                let success = this.cfg.start_new_block();\n+                this.cfg.terminate(\n+                    block,\n+                    outer_source_info,\n+                    TerminatorKind::Drop { place: to_drop, target: success, unwind: None },\n+                );\n+                this.diverge_from(block);\n+                block = success;\n+            }\n+            this.record_operands_moved(&[value_operand]);\n+        }\n+        block.and(Rvalue::Aggregate(Box::new(AggregateKind::Array(elem_ty)), Vec::new()))\n+    }\n+\n     fn limit_capture_mutability(\n         &mut self,\n         upvar_span: Span,"}, {"sha": "a5f8a5847c2703eee2f802af4962f1c031fb87c6", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c64d0af379e6e48ac1e798d65e2031265aa22/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c64d0af379e6e48ac1e798d65e2031265aa22/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=fe9c64d0af379e6e48ac1e798d65e2031265aa22", "patch": "@@ -1033,6 +1033,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 self.cfg.block_data(start).terminator().kind,\n                 TerminatorKind::Assert { .. }\n                     | TerminatorKind::Call { .. }\n+                    | TerminatorKind::Drop { .. }\n                     | TerminatorKind::DropAndReplace { .. }\n                     | TerminatorKind::FalseUnwind { .. }\n                     | TerminatorKind::InlineAsm { .. }"}, {"sha": "bb6d892138a3848f39b405fb84c61a70f3765d96", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c64d0af379e6e48ac1e798d65e2031265aa22/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c64d0af379e6e48ac1e798d65e2031265aa22/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=fe9c64d0af379e6e48ac1e798d65e2031265aa22", "patch": "@@ -2291,16 +2291,9 @@ impl<'a> Parser<'a> {\n                         .span_label(else_span, \"expected an `if` or a block after this `else`\")\n                         .span_suggestion(\n                             cond.span.shrink_to_lo(),\n-                            \"add an `if` if this is the condition to an chained `if` statement after the `else`\",\n+                            \"add an `if` if this is the condition of a chained `else if` statement\",\n                             \"if \".to_string(),\n                             Applicability::MaybeIncorrect,\n-                        ).multipart_suggestion(\n-                            \"... otherwise, place this expression inside of a block if it is not an `if` condition\",\n-                            vec![\n-                                (cond.span.shrink_to_lo(), \"{ \".to_string()),\n-                                (cond.span.shrink_to_hi(), \" }\".to_string()),\n-                            ],\n-                            Applicability::MaybeIncorrect,\n                         )\n                         .emit();\n                     self.parse_if_after_cond(AttrVec::new(), cond.span.shrink_to_lo(), cond)?"}, {"sha": "406e9a4113ef394f6a9337ddf514553c614934ce", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c64d0af379e6e48ac1e798d65e2031265aa22/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c64d0af379e6e48ac1e798d65e2031265aa22/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=fe9c64d0af379e6e48ac1e798d65e2031265aa22", "patch": "@@ -427,6 +427,7 @@ symbols! {\n         cfg_panic,\n         cfg_sanitize,\n         cfg_target_abi,\n+        cfg_target_compact,\n         cfg_target_feature,\n         cfg_target_has_atomic,\n         cfg_target_has_atomic_equal_alignment,\n@@ -1375,6 +1376,7 @@ symbols! {\n         sym,\n         sync,\n         t32,\n+        target,\n         target_abi,\n         target_arch,\n         target_endian,"}, {"sha": "ed7d16f7a5419e96a66be92abf801dea597b9cf3", "filename": "compiler/rustc_trait_selection/src/traits/on_unimplemented.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c64d0af379e6e48ac1e798d65e2031265aa22/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c64d0af379e6e48ac1e798d65e2031265aa22/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs?ref=fe9c64d0af379e6e48ac1e798d65e2031265aa22", "patch": "@@ -89,8 +89,8 @@ impl<'tcx> OnUnimplementedDirective {\n                         None,\n                     )\n                 })?;\n-            attr::eval_condition(cond, &tcx.sess.parse_sess, Some(tcx.features()), &mut |item| {\n-                if let Some(symbol) = item.value_str() && let Err(guar) = parse_value(symbol) {\n+            attr::eval_condition(cond, &tcx.sess.parse_sess, Some(tcx.features()), &mut |cfg| {\n+                if let Some(value) = cfg.value && let Err(guar) = parse_value(value) {\n                     errored = Some(guar);\n                 }\n                 true\n@@ -226,14 +226,12 @@ impl<'tcx> OnUnimplementedDirective {\n                 condition,\n                 &tcx.sess.parse_sess,\n                 Some(tcx.features()),\n-                &mut |c| {\n-                    c.ident().map_or(false, |ident| {\n-                        let value = c.value_str().map(|s| {\n-                            OnUnimplementedFormatString(s).format(tcx, trait_ref, &options_map)\n-                        });\n+                &mut |cfg| {\n+                    let value = cfg.value.map(|v| {\n+                        OnUnimplementedFormatString(v).format(tcx, trait_ref, &options_map)\n+                    });\n \n-                        options.contains(&(ident.name, value))\n-                    })\n+                    options.contains(&(cfg.name, value))\n                 },\n             ) {\n                 debug!(\"evaluate: skipping {:?} due to condition\", command);"}, {"sha": "212b637d34365811bced93c8142f46c0b23434a0", "filename": "library/core/src/asserting.rs", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c64d0af379e6e48ac1e798d65e2031265aa22/library%2Fcore%2Fsrc%2Fasserting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c64d0af379e6e48ac1e798d65e2031265aa22/library%2Fcore%2Fsrc%2Fasserting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fasserting.rs?ref=fe9c64d0af379e6e48ac1e798d65e2031265aa22", "patch": "@@ -0,0 +1,109 @@\n+// Contains the machinery necessary to print useful `assert!` messages. Not intended for public\n+// usage, not even nightly use-cases.\n+//\n+// Based on https://github.com/dtolnay/case-studies/tree/master/autoref-specialization. When\n+// 'specialization' is robust enough (5 years? 10 years? Never?), `Capture` can be specialized\n+// to [Printable].\n+\n+#![allow(missing_debug_implementations)]\n+#![doc(hidden)]\n+#![unstable(feature = \"generic_assert_internals\", issue = \"44838\")]\n+\n+use crate::{\n+    fmt::{Debug, Formatter},\n+    marker::PhantomData,\n+};\n+\n+// ***** TryCapture - Generic *****\n+\n+/// Marker used by [Capture]\n+#[unstable(feature = \"generic_assert_internals\", issue = \"44838\")]\n+pub struct TryCaptureWithoutDebug;\n+\n+/// Catches an arbitrary `E` and modifies `to` accordingly\n+#[unstable(feature = \"generic_assert_internals\", issue = \"44838\")]\n+pub trait TryCaptureGeneric<E, M> {\n+    /// Similar to [TryCapturePrintable] but generic to any `E`.\n+    fn try_capture(&self, to: &mut Capture<E, M>);\n+}\n+\n+impl<E> TryCaptureGeneric<E, TryCaptureWithoutDebug> for &Wrapper<&E> {\n+    #[inline]\n+    fn try_capture(&self, _: &mut Capture<E, TryCaptureWithoutDebug>) {}\n+}\n+\n+impl<E> Debug for Capture<E, TryCaptureWithoutDebug> {\n+    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {\n+        f.write_str(\"N/A\")\n+    }\n+}\n+\n+// ***** TryCapture - Printable *****\n+\n+/// Marker used by [Capture]\n+#[unstable(feature = \"generic_assert_internals\", issue = \"44838\")]\n+pub struct TryCaptureWithDebug;\n+\n+/// Catches an arbitrary `E: Printable` and modifies `to` accordingly\n+#[unstable(feature = \"generic_assert_internals\", issue = \"44838\")]\n+pub trait TryCapturePrintable<E, M> {\n+    /// Similar as [TryCaptureGeneric] but specialized to any `E: Printable`.\n+    fn try_capture(&self, to: &mut Capture<E, M>);\n+}\n+\n+impl<E> TryCapturePrintable<E, TryCaptureWithDebug> for Wrapper<&E>\n+where\n+    E: Printable,\n+{\n+    #[inline]\n+    fn try_capture(&self, to: &mut Capture<E, TryCaptureWithDebug>) {\n+        to.elem = Some(*self.0);\n+    }\n+}\n+\n+impl<E> Debug for Capture<E, TryCaptureWithDebug>\n+where\n+    E: Printable,\n+{\n+    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {\n+        match self.elem {\n+            None => f.write_str(\"N/A\"),\n+            Some(ref value) => Debug::fmt(value, f),\n+        }\n+    }\n+}\n+\n+// ***** Others *****\n+\n+/// All possible captured `assert!` elements\n+///\n+/// # Types\n+///\n+/// * `E`: **E**lement that is going to be displayed.\n+/// * `M`: **M**arker used to differentiate [Capture]s in regards to [Debug].\n+#[unstable(feature = \"generic_assert_internals\", issue = \"44838\")]\n+pub struct Capture<E, M> {\n+    // If None, then `E` does not implements [Printable] or `E` wasn't evaluated (`assert!( ... )`\n+    // short-circuited).\n+    //\n+    // If Some, then `E` implements [Printable] and was evaluated.\n+    pub elem: Option<E>,\n+    phantom: PhantomData<M>,\n+}\n+\n+impl<M, T> Capture<M, T> {\n+    #[inline]\n+    pub const fn new() -> Self {\n+        Self { elem: None, phantom: PhantomData }\n+    }\n+}\n+\n+/// Necessary for the implementations of `TryCapture*`\n+#[unstable(feature = \"generic_assert_internals\", issue = \"44838\")]\n+pub struct Wrapper<T>(pub T);\n+\n+/// Tells which elements can be copied and displayed\n+#[unstable(feature = \"generic_assert_internals\", issue = \"44838\")]\n+pub trait Printable: Copy + Debug {}\n+\n+impl<T> Printable for T where T: Copy + Debug {}"}, {"sha": "cfcc3ffb9c092c5755f27dc3bcf76273682106f1", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c64d0af379e6e48ac1e798d65e2031265aa22/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c64d0af379e6e48ac1e798d65e2031265aa22/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=fe9c64d0af379e6e48ac1e798d65e2031265aa22", "patch": "@@ -310,6 +310,7 @@ pub mod ops;\n pub mod any;\n pub mod array;\n pub mod ascii;\n+pub mod asserting;\n #[unstable(feature = \"async_iterator\", issue = \"79024\")]\n pub mod async_iter;\n pub mod cell;"}, {"sha": "4b626ba6f2d5d62cdc6c39e86a865bd3d6ffcd18", "filename": "library/core/tests/asserting.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c64d0af379e6e48ac1e798d65e2031265aa22/library%2Fcore%2Ftests%2Fasserting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c64d0af379e6e48ac1e798d65e2031265aa22/library%2Fcore%2Ftests%2Fasserting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fasserting.rs?ref=fe9c64d0af379e6e48ac1e798d65e2031265aa22", "patch": "@@ -0,0 +1,37 @@\n+use core::asserting::{Capture, TryCaptureGeneric, TryCapturePrintable, Wrapper};\n+\n+macro_rules! test {\n+    ($test_name:ident, $elem:expr, $captured_elem:expr, $output:literal) => {\n+        #[test]\n+        fn $test_name() {\n+            let elem = $elem;\n+            let mut capture = Capture::new();\n+            assert!(capture.elem == None);\n+            (&Wrapper(&elem)).try_capture(&mut capture);\n+            assert!(capture.elem == $captured_elem);\n+            assert_eq!(format!(\"{:?}\", capture), $output);\n+        }\n+    };\n+}\n+\n+#[derive(Debug, PartialEq)]\n+struct NoCopy;\n+\n+#[derive(PartialEq)]\n+struct NoCopyNoDebug;\n+\n+#[derive(Clone, Copy, PartialEq)]\n+struct NoDebug;\n+\n+test!(\n+    capture_with_non_copyable_and_non_debugabble_elem_has_correct_params,\n+    NoCopyNoDebug,\n+    None,\n+    \"N/A\"\n+);\n+\n+test!(capture_with_non_copyable_elem_has_correct_params, NoCopy, None, \"N/A\");\n+\n+test!(capture_with_non_debugabble_elem_has_correct_params, NoDebug, None, \"N/A\");\n+\n+test!(capture_with_copyable_and_debugabble_elem_has_correct_params, 1i32, Some(1i32), \"1\");"}, {"sha": "9ea374e1045a56b372dd401dfcd83d0fd3905764", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c64d0af379e6e48ac1e798d65e2031265aa22/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c64d0af379e6e48ac1e798d65e2031265aa22/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=fe9c64d0af379e6e48ac1e798d65e2031265aa22", "patch": "@@ -35,6 +35,7 @@\n #![feature(float_minimum_maximum)]\n #![feature(future_join)]\n #![feature(future_poll_fn)]\n+#![feature(generic_assert_internals)]\n #![feature(array_try_from_fn)]\n #![feature(hasher_prefixfree_extras)]\n #![feature(hashmap_internals)]\n@@ -104,6 +105,7 @@ mod alloc;\n mod any;\n mod array;\n mod ascii;\n+mod asserting;\n mod atomic;\n mod bool;\n mod cell;"}, {"sha": "bca2275b1a957781988f76268f7590997aba3113", "filename": "src/test/ui/cfg/cfg-target-compact-errors.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c64d0af379e6e48ac1e798d65e2031265aa22/src%2Ftest%2Fui%2Fcfg%2Fcfg-target-compact-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c64d0af379e6e48ac1e798d65e2031265aa22/src%2Ftest%2Fui%2Fcfg%2Fcfg-target-compact-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcfg%2Fcfg-target-compact-errors.rs?ref=fe9c64d0af379e6e48ac1e798d65e2031265aa22", "patch": "@@ -0,0 +1,17 @@\n+// check-fail\n+\n+#![feature(cfg_target_compact)]\n+\n+#[cfg(target(o::o))]\n+//~^ ERROR `cfg` predicate key must be an identifier\n+fn one() {}\n+\n+#[cfg(target(os = 8))]\n+//~^ ERROR literal in `cfg` predicate value must be a string\n+fn two() {}\n+\n+#[cfg(target(os = \"linux\", pointer(width = \"64\")))]\n+//~^ ERROR invalid predicate `target_pointer`\n+fn three() {}\n+\n+fn main() {}"}, {"sha": "bb858301eb58196f28e3d56356a321726c55a15f", "filename": "src/test/ui/cfg/cfg-target-compact-errors.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c64d0af379e6e48ac1e798d65e2031265aa22/src%2Ftest%2Fui%2Fcfg%2Fcfg-target-compact-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c64d0af379e6e48ac1e798d65e2031265aa22/src%2Ftest%2Fui%2Fcfg%2Fcfg-target-compact-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcfg%2Fcfg-target-compact-errors.stderr?ref=fe9c64d0af379e6e48ac1e798d65e2031265aa22", "patch": "@@ -0,0 +1,22 @@\n+error: `cfg` predicate key must be an identifier\n+  --> $DIR/cfg-target-compact-errors.rs:5:14\n+   |\n+LL | #[cfg(target(o::o))]\n+   |              ^^^^\n+\n+error[E0565]: literal in `cfg` predicate value must be a string\n+  --> $DIR/cfg-target-compact-errors.rs:9:19\n+   |\n+LL | #[cfg(target(os = 8))]\n+   |                   ^\n+\n+error[E0537]: invalid predicate `target_pointer`\n+  --> $DIR/cfg-target-compact-errors.rs:13:28\n+   |\n+LL | #[cfg(target(os = \"linux\", pointer(width = \"64\")))]\n+   |                            ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0537, E0565.\n+For more information about an error, try `rustc --explain E0537`."}, {"sha": "dc95a80915c4307ed32591e89ecac5773fac9926", "filename": "src/test/ui/cfg/cfg-target-compact.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c64d0af379e6e48ac1e798d65e2031265aa22/src%2Ftest%2Fui%2Fcfg%2Fcfg-target-compact.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c64d0af379e6e48ac1e798d65e2031265aa22/src%2Ftest%2Fui%2Fcfg%2Fcfg-target-compact.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcfg%2Fcfg-target-compact.rs?ref=fe9c64d0af379e6e48ac1e798d65e2031265aa22", "patch": "@@ -0,0 +1,10 @@\n+// run-pass\n+#![feature(cfg_target_compact)]\n+\n+#[cfg(target(os = \"linux\", pointer_width = \"64\"))]\n+pub fn main() {\n+}\n+\n+#[cfg(not(target(os = \"linux\", pointer_width = \"64\")))]\n+pub fn main() {\n+}"}, {"sha": "bff807400396580b801b7faa38d079c9a9918f06", "filename": "src/test/ui/check-cfg/compact-names.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c64d0af379e6e48ac1e798d65e2031265aa22/src%2Ftest%2Fui%2Fcheck-cfg%2Fcompact-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c64d0af379e6e48ac1e798d65e2031265aa22/src%2Ftest%2Fui%2Fcheck-cfg%2Fcompact-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck-cfg%2Fcompact-names.rs?ref=fe9c64d0af379e6e48ac1e798d65e2031265aa22", "patch": "@@ -0,0 +1,15 @@\n+// This test check that we correctly emit an warning for compact cfg\n+//\n+// check-pass\n+// compile-flags:--check-cfg=names() -Z unstable-options\n+\n+#![feature(cfg_target_compact)]\n+\n+#[cfg(target(os = \"linux\", arch = \"arm\"))]\n+pub fn expected() {}\n+\n+#[cfg(target(os = \"linux\", architecture = \"arm\"))]\n+//~^ WARNING unexpected `cfg` condition name\n+pub fn unexpected() {}\n+\n+fn main() {}"}, {"sha": "f1fc4285a71b79a0f852934cefa28b2c27e4b245", "filename": "src/test/ui/check-cfg/compact-names.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c64d0af379e6e48ac1e798d65e2031265aa22/src%2Ftest%2Fui%2Fcheck-cfg%2Fcompact-names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c64d0af379e6e48ac1e798d65e2031265aa22/src%2Ftest%2Fui%2Fcheck-cfg%2Fcompact-names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck-cfg%2Fcompact-names.stderr?ref=fe9c64d0af379e6e48ac1e798d65e2031265aa22", "patch": "@@ -0,0 +1,10 @@\n+warning: unexpected `cfg` condition name\n+  --> $DIR/compact-names.rs:11:28\n+   |\n+LL | #[cfg(target(os = \"linux\", architecture = \"arm\"))]\n+   |                            ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(unexpected_cfgs)]` on by default\n+\n+warning: 1 warning emitted\n+"}, {"sha": "1f17057840ccadb5a56abfc50ca59c73a0a64d90", "filename": "src/test/ui/check-cfg/compact-values.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c64d0af379e6e48ac1e798d65e2031265aa22/src%2Ftest%2Fui%2Fcheck-cfg%2Fcompact-values.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c64d0af379e6e48ac1e798d65e2031265aa22/src%2Ftest%2Fui%2Fcheck-cfg%2Fcompact-values.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck-cfg%2Fcompact-values.rs?ref=fe9c64d0af379e6e48ac1e798d65e2031265aa22", "patch": "@@ -0,0 +1,15 @@\n+// This test check that we correctly emit an warning for compact cfg\n+//\n+// check-pass\n+// compile-flags:--check-cfg=values() -Z unstable-options\n+\n+#![feature(cfg_target_compact)]\n+\n+#[cfg(target(os = \"linux\", arch = \"arm\"))]\n+pub fn expected() {}\n+\n+#[cfg(target(os = \"linux\", arch = \"X\"))]\n+//~^ WARNING unexpected `cfg` condition value\n+pub fn unexpected() {}\n+\n+fn main() {}"}, {"sha": "a196e1537df57b09e5f2491a74c115369b111a75", "filename": "src/test/ui/check-cfg/compact-values.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c64d0af379e6e48ac1e798d65e2031265aa22/src%2Ftest%2Fui%2Fcheck-cfg%2Fcompact-values.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c64d0af379e6e48ac1e798d65e2031265aa22/src%2Ftest%2Fui%2Fcheck-cfg%2Fcompact-values.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck-cfg%2Fcompact-values.stderr?ref=fe9c64d0af379e6e48ac1e798d65e2031265aa22", "patch": "@@ -0,0 +1,11 @@\n+warning: unexpected `cfg` condition value\n+  --> $DIR/compact-values.rs:11:28\n+   |\n+LL | #[cfg(target(os = \"linux\", arch = \"X\"))]\n+   |                            ^^^^^^^^^^\n+   |\n+   = note: `#[warn(unexpected_cfgs)]` on by default\n+   = note: expected values for `target_arch` are: aarch64, arm, avr, bpf, hexagon, m68k, mips, mips64, msp430, nvptx64, powerpc, powerpc64, riscv32, riscv64, s390x, sparc, sparc64, wasm32, wasm64, x86, x86_64\n+\n+warning: 1 warning emitted\n+"}, {"sha": "2e7855328ecbffa90e83ef9aaf333a38312b2ccb", "filename": "src/test/ui/drop/repeat-drop-2.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c64d0af379e6e48ac1e798d65e2031265aa22/src%2Ftest%2Fui%2Fdrop%2Frepeat-drop-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c64d0af379e6e48ac1e798d65e2031265aa22/src%2Ftest%2Fui%2Fdrop%2Frepeat-drop-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Frepeat-drop-2.rs?ref=fe9c64d0af379e6e48ac1e798d65e2031265aa22", "patch": "@@ -0,0 +1,15 @@\n+fn borrowck_catch() {\n+    let foo = String::new();\n+    let _bar = foo;\n+    let _baz = [foo; 0]; //~ ERROR use of moved value: `foo` [E0382]\n+}\n+\n+const _: [String; 0] = [String::new(); 0];\n+//~^ ERROR destructors cannot be evaluated at compile-time [E0493]\n+\n+fn must_be_init() {\n+    let x: u8;\n+    let _ = [x; 0]; //~ ERROR: use of possibly-uninitialized variable: `x`\n+}\n+\n+fn main() {}"}, {"sha": "cdc58180c37b40847bc0c6fbdbf496c0da5310fe", "filename": "src/test/ui/drop/repeat-drop-2.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c64d0af379e6e48ac1e798d65e2031265aa22/src%2Ftest%2Fui%2Fdrop%2Frepeat-drop-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c64d0af379e6e48ac1e798d65e2031265aa22/src%2Ftest%2Fui%2Fdrop%2Frepeat-drop-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Frepeat-drop-2.stderr?ref=fe9c64d0af379e6e48ac1e798d65e2031265aa22", "patch": "@@ -0,0 +1,29 @@\n+error[E0382]: use of moved value: `foo`\n+  --> $DIR/repeat-drop-2.rs:4:17\n+   |\n+LL |     let foo = String::new();\n+   |         --- move occurs because `foo` has type `String`, which does not implement the `Copy` trait\n+LL |     let _bar = foo;\n+   |                --- value moved here\n+LL |     let _baz = [foo; 0];\n+   |                 ^^^ value used here after move\n+\n+error[E0493]: destructors cannot be evaluated at compile-time\n+  --> $DIR/repeat-drop-2.rs:7:25\n+   |\n+LL | const _: [String; 0] = [String::new(); 0];\n+   |                        -^^^^^^^^^^^^^----\n+   |                        ||\n+   |                        |constants cannot evaluate destructors\n+   |                        value is dropped here\n+\n+error[E0381]: use of possibly-uninitialized variable: `x`\n+  --> $DIR/repeat-drop-2.rs:12:14\n+   |\n+LL |     let _ = [x; 0];\n+   |              ^ use of possibly-uninitialized `x`\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0381, E0382, E0493.\n+For more information about an error, try `rustc --explain E0381`."}, {"sha": "03e832adb3b3b610612f12a2398f70913269078f", "filename": "src/test/ui/drop/repeat-drop.rs", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c64d0af379e6e48ac1e798d65e2031265aa22/src%2Ftest%2Fui%2Fdrop%2Frepeat-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c64d0af379e6e48ac1e798d65e2031265aa22/src%2Ftest%2Fui%2Fdrop%2Frepeat-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Frepeat-drop.rs?ref=fe9c64d0af379e6e48ac1e798d65e2031265aa22", "patch": "@@ -0,0 +1,120 @@\n+// run-pass\n+// ignore-wasm32-bare no unwinding panic\n+// ignore-avr no unwinding panic\n+// ignore-nvptx64 no unwinding panic\n+\n+static mut CHECK: usize = 0;\n+\n+struct DropChecker(usize);\n+\n+impl Drop for DropChecker {\n+    fn drop(&mut self) {\n+        unsafe {\n+            if CHECK != self.0 - 1 {\n+                panic!(\"Found {}, should have found {}\", CHECK, self.0 - 1);\n+            }\n+            CHECK = self.0;\n+        }\n+    }\n+}\n+\n+macro_rules! check_drops {\n+    ($l:literal) => {\n+        unsafe { assert_eq!(CHECK, $l) }\n+    };\n+}\n+\n+struct DropPanic;\n+\n+impl Drop for DropPanic {\n+    fn drop(&mut self) {\n+        panic!()\n+    }\n+}\n+\n+fn value_zero() {\n+    unsafe { CHECK = 0 };\n+    let foo = DropChecker(1);\n+    let v: [DropChecker; 0] = [foo; 0];\n+    check_drops!(1);\n+    std::mem::drop(v);\n+    check_drops!(1);\n+}\n+\n+fn value_one() {\n+    unsafe { CHECK = 0 };\n+    let foo = DropChecker(1);\n+    let v: [DropChecker; 1] = [foo; 1];\n+    check_drops!(0);\n+    std::mem::drop(v);\n+    check_drops!(1);\n+}\n+\n+const DROP_CHECKER: DropChecker = DropChecker(1);\n+\n+fn const_zero() {\n+    unsafe { CHECK = 0 };\n+    let v: [DropChecker; 0] = [DROP_CHECKER; 0];\n+    check_drops!(0);\n+    std::mem::drop(v);\n+    check_drops!(0);\n+}\n+\n+fn const_one() {\n+    unsafe { CHECK = 0 };\n+    let v: [DropChecker; 1] = [DROP_CHECKER; 1];\n+    check_drops!(0);\n+    std::mem::drop(v);\n+    check_drops!(1);\n+}\n+\n+fn const_generic_zero<const N: usize>() {\n+    unsafe { CHECK = 0 };\n+    let v: [DropChecker; N] = [DROP_CHECKER; N];\n+    check_drops!(0);\n+    std::mem::drop(v);\n+    check_drops!(0);\n+}\n+\n+fn const_generic_one<const N: usize>() {\n+    unsafe { CHECK = 0 };\n+    let v: [DropChecker; N] = [DROP_CHECKER; N];\n+    check_drops!(0);\n+    std::mem::drop(v);\n+    check_drops!(1);\n+}\n+\n+// Make sure that things are allowed to promote as expected\n+\n+fn allow_promote() {\n+    unsafe { CHECK = 0 };\n+    let foo = DropChecker(1);\n+    let v: &'static [DropChecker; 0] = &[foo; 0];\n+    check_drops!(1);\n+    std::mem::drop(v);\n+    check_drops!(1);\n+}\n+\n+// Verify that unwinding in the drop causes the right things to drop in the right order\n+fn on_unwind() {\n+    unsafe { CHECK = 0 };\n+    std::panic::catch_unwind(|| {\n+        let panic = DropPanic;\n+        let _local = DropChecker(2);\n+        let _v = (DropChecker(1), [panic; 0]);\n+        std::process::abort();\n+    })\n+    .unwrap_err();\n+    check_drops!(2);\n+}\n+\n+fn main() {\n+    value_zero();\n+    value_one();\n+    const_zero();\n+    const_one();\n+    const_generic_zero::<0>();\n+    const_generic_one::<1>();\n+    allow_promote();\n+    on_unwind();\n+}"}, {"sha": "df81b7d2297eae80732c4bebc28299789edd1060", "filename": "src/test/ui/feature-gates/feature-gate-cfg-target-compact.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c64d0af379e6e48ac1e798d65e2031265aa22/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-target-compact.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c64d0af379e6e48ac1e798d65e2031265aa22/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-target-compact.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-target-compact.rs?ref=fe9c64d0af379e6e48ac1e798d65e2031265aa22", "patch": "@@ -0,0 +1,13 @@\n+#[cfg(target(os = \"x\"))] //~ ERROR compact `cfg(target(..))` is experimental\n+struct Foo(u64, u64);\n+\n+#[cfg_attr(target(os = \"x\"), x)] //~ ERROR compact `cfg(target(..))` is experimental\n+struct Bar(u64, u64);\n+\n+#[cfg(not(any(all(target(os = \"x\")))))] //~ ERROR compact `cfg(target(..))` is experimental\n+fn foo() {}\n+\n+fn main() {\n+    cfg!(target(os = \"x\"));\n+    //~^ ERROR compact `cfg(target(..))` is experimental and subject to change\n+}"}, {"sha": "be6fe23ded17188799f13e35d87e7c54cf283ddd", "filename": "src/test/ui/feature-gates/feature-gate-cfg-target-compact.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c64d0af379e6e48ac1e798d65e2031265aa22/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-target-compact.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c64d0af379e6e48ac1e798d65e2031265aa22/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-target-compact.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-target-compact.stderr?ref=fe9c64d0af379e6e48ac1e798d65e2031265aa22", "patch": "@@ -0,0 +1,39 @@\n+error[E0658]: compact `cfg(target(..))` is experimental and subject to change\n+  --> $DIR/feature-gate-cfg-target-compact.rs:1:7\n+   |\n+LL | #[cfg(target(os = \"x\"))]\n+   |       ^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #96901 <https://github.com/rust-lang/rust/issues/96901> for more information\n+   = help: add `#![feature(cfg_target_compact)]` to the crate attributes to enable\n+\n+error[E0658]: compact `cfg(target(..))` is experimental and subject to change\n+  --> $DIR/feature-gate-cfg-target-compact.rs:4:12\n+   |\n+LL | #[cfg_attr(target(os = \"x\"), x)]\n+   |            ^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #96901 <https://github.com/rust-lang/rust/issues/96901> for more information\n+   = help: add `#![feature(cfg_target_compact)]` to the crate attributes to enable\n+\n+error[E0658]: compact `cfg(target(..))` is experimental and subject to change\n+  --> $DIR/feature-gate-cfg-target-compact.rs:7:19\n+   |\n+LL | #[cfg(not(any(all(target(os = \"x\")))))]\n+   |                   ^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #96901 <https://github.com/rust-lang/rust/issues/96901> for more information\n+   = help: add `#![feature(cfg_target_compact)]` to the crate attributes to enable\n+\n+error[E0658]: compact `cfg(target(..))` is experimental and subject to change\n+  --> $DIR/feature-gate-cfg-target-compact.rs:11:10\n+   |\n+LL |     cfg!(target(os = \"x\"));\n+   |          ^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #96901 <https://github.com/rust-lang/rust/issues/96901> for more information\n+   = help: add `#![feature(cfg_target_compact)]` to the crate attributes to enable\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "b9c1a75276c1fcbeb3e6e68ce06589d0e67194d9", "filename": "src/test/ui/parser/else-no-if.stderr", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe9c64d0af379e6e48ac1e798d65e2031265aa22/src%2Ftest%2Fui%2Fparser%2Felse-no-if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe9c64d0af379e6e48ac1e798d65e2031265aa22/src%2Ftest%2Fui%2Fparser%2Felse-no-if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Felse-no-if.stderr?ref=fe9c64d0af379e6e48ac1e798d65e2031265aa22", "patch": "@@ -6,14 +6,10 @@ LL |     } else false {\n    |       |\n    |       expected an `if` or a block after this `else`\n    |\n-help: add an `if` if this is the condition to an chained `if` statement after the `else`\n+help: add an `if` if this is the condition of a chained `else if` statement\n    |\n LL |     } else if false {\n    |            ++\n-help: ... otherwise, place this expression inside of a block if it is not an `if` condition\n-   |\n-LL |     } else { false } {\n-   |            +       +\n \n error: expected `{`, found `falsy`\n   --> $DIR/else-no-if.rs:10:12\n@@ -23,14 +19,10 @@ LL |     } else falsy() {\n    |       |\n    |       expected an `if` or a block after this `else`\n    |\n-help: add an `if` if this is the condition to an chained `if` statement after the `else`\n+help: add an `if` if this is the condition of a chained `else if` statement\n    |\n LL |     } else if falsy() {\n    |            ++\n-help: ... otherwise, place this expression inside of a block if it is not an `if` condition\n-   |\n-LL |     } else { falsy() } {\n-   |            +         +\n \n error: expected `{`, found `falsy`\n   --> $DIR/else-no-if.rs:17:12"}]}