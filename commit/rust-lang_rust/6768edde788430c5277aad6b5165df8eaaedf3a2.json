{"sha": "6768edde788430c5277aad6b5165df8eaaedf3a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3NjhlZGRlNzg4NDMwYzUyNzdhYWQ2YjUxNjVkZjhlYWFlZGYzYTI=", "commit": {"author": {"name": "Cobrand", "email": "cobrandw@gmail.com", "date": "2016-10-27T23:42:47Z"}, "committer": {"name": "Cobrand", "email": "cobrandw@gmail.com", "date": "2016-10-28T15:18:48Z"}, "message": "improve docs for Index and IndexMut", "tree": {"sha": "a042cec99f09d65e8f7eb7c4c846f6cf4bf82c50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a042cec99f09d65e8f7eb7c4c846f6cf4bf82c50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6768edde788430c5277aad6b5165df8eaaedf3a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6768edde788430c5277aad6b5165df8eaaedf3a2", "html_url": "https://github.com/rust-lang/rust/commit/6768edde788430c5277aad6b5165df8eaaedf3a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6768edde788430c5277aad6b5165df8eaaedf3a2/comments", "author": {"login": "Cobrand", "id": 8882127, "node_id": "MDQ6VXNlcjg4ODIxMjc=", "avatar_url": "https://avatars.githubusercontent.com/u/8882127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Cobrand", "html_url": "https://github.com/Cobrand", "followers_url": "https://api.github.com/users/Cobrand/followers", "following_url": "https://api.github.com/users/Cobrand/following{/other_user}", "gists_url": "https://api.github.com/users/Cobrand/gists{/gist_id}", "starred_url": "https://api.github.com/users/Cobrand/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Cobrand/subscriptions", "organizations_url": "https://api.github.com/users/Cobrand/orgs", "repos_url": "https://api.github.com/users/Cobrand/repos", "events_url": "https://api.github.com/users/Cobrand/events{/privacy}", "received_events_url": "https://api.github.com/users/Cobrand/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Cobrand", "id": 8882127, "node_id": "MDQ6VXNlcjg4ODIxMjc=", "avatar_url": "https://avatars.githubusercontent.com/u/8882127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Cobrand", "html_url": "https://github.com/Cobrand", "followers_url": "https://api.github.com/users/Cobrand/followers", "following_url": "https://api.github.com/users/Cobrand/following{/other_user}", "gists_url": "https://api.github.com/users/Cobrand/gists{/gist_id}", "starred_url": "https://api.github.com/users/Cobrand/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Cobrand/subscriptions", "organizations_url": "https://api.github.com/users/Cobrand/orgs", "repos_url": "https://api.github.com/users/Cobrand/repos", "events_url": "https://api.github.com/users/Cobrand/events{/privacy}", "received_events_url": "https://api.github.com/users/Cobrand/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07436946b6ee6345509b73c6e4dafb38b6a243f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/07436946b6ee6345509b73c6e4dafb38b6a243f1", "html_url": "https://github.com/rust-lang/rust/commit/07436946b6ee6345509b73c6e4dafb38b6a243f1"}], "stats": {"total": 85, "additions": 67, "deletions": 18}, "files": [{"sha": "0a86bec728e2c9d511661b59f4e289d3714a31ce", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 67, "deletions": 18, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/6768edde788430c5277aad6b5165df8eaaedf3a2/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6768edde788430c5277aad6b5165df8eaaedf3a2/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=6768edde788430c5277aad6b5165df8eaaedf3a2", "patch": "@@ -1879,10 +1879,18 @@ shr_assign_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n /// The `Index` trait is used to specify the functionality of indexing operations\n /// like `container[index]` when used in an immutable context.\n ///\n+/// `container[index]` is actually syntactic sugar for `*container.index(index)`,\n+/// but only when used as an immutable value. If a mutable value is requested,\n+/// [`IndexMut`] is used instead. This allows nice things such as\n+/// `let value = v[index]` if `value` implements [`Copy`].\n+///\n+/// [`IndexMut`]: ../../std/ops/trait.IndexMut.html\n+/// [`Copy`]: ../../std/marker/trait.Copy.html\n+///\n /// # Examples\n ///\n-/// This example implements `Index` on a read-only `NucleotideCount` container,\n-/// enabling individual counts to be retrieved with index syntax.\n+/// The following example implements `Index` on a read-only `NucleotideCount`\n+/// container, enabling individual counts to be retrieved with index syntax.\n ///\n /// ```\n /// use std::ops::Index;\n@@ -1934,37 +1942,78 @@ pub trait Index<Idx: ?Sized> {\n }\n \n /// The `IndexMut` trait is used to specify the functionality of indexing\n-/// operations like `container[index]`, when used in a mutable context.\n+/// operations like `container[index]` when used in a mutable context.\n+///\n+/// `container[index]` is actually syntactic sugar for\n+/// `*container.index_mut(index)`, but only when used as a mutable value. If\n+/// an immutable value is requested, the [`Index`] trait is used instead. This\n+/// allows nice things such as `v[index] = value` if `value` implements [`Copy`].\n+///\n+/// [`Index`]: ../../std/ops/trait.Index.html\n+/// [`Copy`]: ../../std/marker/trait.Copy.html\n ///\n /// # Examples\n ///\n-/// A trivial implementation of `IndexMut` for a type `Foo`. When `&mut Foo[2]`\n-/// happens, it ends up calling `index_mut`, and therefore, `main` prints\n-/// `Mutable indexing with 2!`.\n+/// A very simple implementation of a `Balance` struct that has two sides, where\n+/// each can be indexed mutably and immutably.\n ///\n /// ```\n-/// use std::ops::{Index, IndexMut};\n+/// use std::ops::{Index,IndexMut};\n ///\n-/// #[derive(Copy, Clone)]\n-/// struct Foo;\n+/// #[derive(Debug)]\n+/// enum Side {\n+///     Left,\n+///     Right,\n+/// }\n ///\n-/// impl Index<usize> for Foo {\n-///     type Output = Foo;\n+/// #[derive(Debug, PartialEq)]\n+/// enum Weight {\n+///     Kilogram(f32),\n+///     Pound(f32),\n+/// }\n+///\n+/// struct Balance {\n+///     pub left: Weight,\n+///     pub right:Weight,\n+/// }\n ///\n-///     fn index(&self, _index: usize) -> &Foo {\n-///         self\n+/// impl Index<Side> for Balance {\n+///     type Output = Weight;\n+///\n+///     fn index<'a>(&'a self, index: Side) -> &'a Weight {\n+///         println!(\"Accessing {:?}-side of balance immutably\", index);\n+///         match index {\n+///             Side::Left => &self.left,\n+///             Side::Right => &self.right,\n+///         }\n ///     }\n /// }\n ///\n-/// impl IndexMut<usize> for Foo {\n-///     fn index_mut(&mut self, index: usize) -> &mut Foo {\n-///         println!(\"Mutable indexing with {}!\", index);\n-///         self\n+/// impl IndexMut<Side> for Balance {\n+///     fn index_mut<'a>(&'a mut self, index: Side) -> &'a mut Weight {\n+///         println!(\"Accessing {:?}-side of balance mutably\", index);\n+///         match index {\n+///             Side::Left => &mut self.left,\n+///             Side::Right => &mut self.right,\n+///         }\n ///     }\n /// }\n ///\n /// fn main() {\n-///     &mut Foo[2];\n+///     let mut balance = Balance {\n+///         right: Weight::Kilogram(2.5),\n+///         left: Weight::Pound(1.5),\n+///     };\n+///\n+///     // In this case balance[Side::Right] is sugar for\n+///     // *balance.index(Side::Right), since we are only reading\n+///     // balance[Side::Right], not writing it.\n+///     assert_eq!(balance[Side::Right],Weight::Kilogram(2.5));\n+///\n+///     // However in this case balance[Side::Left] is sugar for\n+///     // *balance.index_mut(Side::Left), since we are writing\n+///     // balance[Side::Left].\n+///     balance[Side::Left] = Weight::Kilogram(3.0);\n /// }\n /// ```\n #[lang = \"index_mut\"]"}]}