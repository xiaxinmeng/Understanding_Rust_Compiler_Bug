{"sha": "8f1ce8275347e915b1cc824567e96369875cefd4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmMWNlODI3NTM0N2U5MTViMWNjODI0NTY3ZTk2MzY5ODc1Y2VmZDQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-09-01T14:40:45Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-09-01T14:40:45Z"}, "message": "move to gen-server impl", "tree": {"sha": "1d7b56d7947a5c6a20a6547b5342e3363e6c0e0f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d7b56d7947a5c6a20a6547b5342e3363e6c0e0f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f1ce8275347e915b1cc824567e96369875cefd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f1ce8275347e915b1cc824567e96369875cefd4", "html_url": "https://github.com/rust-lang/rust/commit/8f1ce8275347e915b1cc824567e96369875cefd4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f1ce8275347e915b1cc824567e96369875cefd4/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3588d6b2da6e63730cc560c9986ba7fda5de816e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3588d6b2da6e63730cc560c9986ba7fda5de816e", "html_url": "https://github.com/rust-lang/rust/commit/3588d6b2da6e63730cc560c9986ba7fda5de816e"}], "stats": {"total": 756, "additions": 181, "deletions": 575}, "files": [{"sha": "b47db0df42de1859cba99db92acc0d8e7b228aad", "filename": "crates/gen_lsp_server/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f1ce8275347e915b1cc824567e96369875cefd4/crates%2Fgen_lsp_server%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f1ce8275347e915b1cc824567e96369875cefd4/crates%2Fgen_lsp_server%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fgen_lsp_server%2Fsrc%2Flib.rs?ref=8f1ce8275347e915b1cc824567e96369875cefd4", "patch": "@@ -21,7 +21,7 @@ use languageserver_types::{\n \n pub type Result<T> = ::std::result::Result<T, failure::Error>;\n pub use {\n-    msg::{RawMessage, RawRequest, RawResponse, RawResponseError, RawNotification},\n+    msg::{RawMessage, RawRequest, RawResponse, RawResponseError, RawNotification, ErrorCode},\n     stdio::{stdio_transport, Threads},\n };\n "}, {"sha": "533d7da3ec6c326dcaa2324a7c9bdced0c5b6c67", "filename": "crates/gen_lsp_server/src/msg.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8f1ce8275347e915b1cc824567e96369875cefd4/crates%2Fgen_lsp_server%2Fsrc%2Fmsg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f1ce8275347e915b1cc824567e96369875cefd4/crates%2Fgen_lsp_server%2Fsrc%2Fmsg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fgen_lsp_server%2Fsrc%2Fmsg.rs?ref=8f1ce8275347e915b1cc824567e96369875cefd4", "patch": "@@ -120,6 +120,16 @@ impl RawResponse {\n }\n \n impl RawNotification {\n+    pub fn new<N>(params: N::Params) -> RawNotification\n+    where\n+        N: Notification,\n+        N::Params: Serialize,\n+    {\n+        RawNotification {\n+            method: N::METHOD.to_string(),\n+            params: to_value(&params).unwrap(),\n+        }\n+    }\n     pub fn cast<N>(self) -> ::std::result::Result<N::Params, RawNotification>\n     where\n         N: Notification,"}, {"sha": "32c1219e1d3ad898630716bdaf54047bc5a9d48a", "filename": "crates/server/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8f1ce8275347e915b1cc824567e96369875cefd4/crates%2Fserver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8f1ce8275347e915b1cc824567e96369875cefd4/crates%2Fserver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2FCargo.toml?ref=8f1ce8275347e915b1cc824567e96369875cefd4", "patch": "@@ -23,3 +23,4 @@ text_unit = { version = \"0.1.2\", features = [\"serde\"] }\n libsyntax2 = { path = \"../libsyntax2\" }\n libeditor = { path = \"../libeditor\" }\n libanalysis = { path = \"../libanalysis\" }\n+gen_lsp_server = { path = \"../gen_lsp_server\" }"}, {"sha": "8065349448fd6a4c4fd7c0adcbe95ff30fc2a243", "filename": "crates/server/src/dispatch.rs", "status": "removed", "additions": 0, "deletions": 151, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/3588d6b2da6e63730cc560c9986ba7fda5de816e/crates%2Fserver%2Fsrc%2Fdispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3588d6b2da6e63730cc560c9986ba7fda5de816e/crates%2Fserver%2Fsrc%2Fdispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fdispatch.rs?ref=3588d6b2da6e63730cc560c9986ba7fda5de816e", "patch": "@@ -1,151 +0,0 @@\n-use std::marker::PhantomData;\n-\n-use serde::{\n-    ser::Serialize,\n-    de::DeserializeOwned,\n-};\n-use serde_json;\n-use drop_bomb::DropBomb;\n-\n-use ::{\n-    Result,\n-    req::{ClientRequest, Notification},\n-    io::{RawResponse, RawRequest, RawNotification},\n-};\n-\n-pub struct Responder<R: ClientRequest> {\n-    id: u64,\n-    bomb: DropBomb,\n-    ph: PhantomData<fn(R)>,\n-}\n-\n-impl<R: ClientRequest> Responder<R> {\n-    pub fn into_response(mut self, result: Result<R::Result>) -> Result<RawResponse> {\n-        self.bomb.defuse();\n-        let res = match result {\n-            Ok(result) => {\n-                RawResponse {\n-                    id: self.id,\n-                    result: serde_json::to_value(result)?,\n-                    error: serde_json::Value::Null,\n-                }\n-            }\n-            Err(e) => {\n-                error_response(\n-                    self.id,\n-                    ErrorCode::InternalError,\n-                    format!(\"internal error: {}\", e),\n-                )?\n-            }\n-        };\n-        Ok(res)\n-    }\n-}\n-\n-fn parse_request_as<R: ClientRequest>(raw: RawRequest)\n-                                      -> Result<::std::result::Result<(R::Params, Responder<R>), RawRequest>>\n-{\n-    if raw.method != R::METHOD {\n-        return Ok(Err(raw));\n-    }\n-\n-    let params: R::Params = serde_json::from_value(raw.params)?;\n-    let responder = Responder {\n-        id: raw.id,\n-        bomb: DropBomb::new(\"dropped request\"),\n-        ph: PhantomData,\n-    };\n-    Ok(Ok((params, responder)))\n-}\n-\n-pub fn handle_request<R, F>(req: RawRequest, f: F) -> Result<::std::result::Result<u64, RawRequest>>\n-    where\n-        R: ClientRequest,\n-        F: FnOnce(R::Params, Responder<R>) -> Result<()>\n-{\n-    let id = req.id;\n-    match parse_request_as::<R>(req)? {\n-        Ok((params, responder)) => {\n-            let () = f(params, responder)?;\n-            Ok(Ok(id))\n-        },\n-        Err(r) => Ok(Err(r)),\n-    }\n-}\n-\n-fn parse_notification_as<N>(raw: RawNotification) -> Result<::std::result::Result<N::Params, RawNotification>>\n-    where\n-        N: Notification,\n-        N::Params: DeserializeOwned,\n-{\n-    if raw.method != N::METHOD {\n-        return Ok(Err(raw));\n-    }\n-    let params: N::Params = serde_json::from_value(raw.params)?;\n-    Ok(Ok(params))\n-}\n-\n-pub fn handle_notification<N, F>(not: &mut Option<RawNotification>, f: F) -> Result<()>\n-    where\n-        N: Notification,\n-        N::Params: DeserializeOwned,\n-        F: FnOnce(N::Params) -> Result<()>\n-{\n-    match not.take() {\n-        None => Ok(()),\n-        Some(n) => match parse_notification_as::<N>(n)? {\n-            Ok(params) => f(params),\n-            Err(n) => {\n-                *not = Some(n);\n-                Ok(())\n-            }\n-        }\n-    }\n-}\n-\n-pub fn send_notification<N>(params: N::Params) -> RawNotification\n-    where\n-        N: Notification,\n-        N::Params: Serialize\n-{\n-    RawNotification {\n-        method: N::METHOD.to_string(),\n-        params: serde_json::to_value(params)\n-            .unwrap(),\n-    }\n-}\n-\n-pub fn unknown_method(id: u64) -> Result<RawResponse> {\n-    error_response(id, ErrorCode::MethodNotFound, \"unknown method\")\n-}\n-\n-fn error_response(id: u64, code: ErrorCode, message: impl Into<String>) -> Result<RawResponse> {\n-    #[derive(Serialize)]\n-    struct Error {\n-        code: i32,\n-        message: String,\n-    }\n-    let resp = RawResponse {\n-        id,\n-        result: serde_json::Value::Null,\n-        error: serde_json::to_value(Error {\n-            code: code as i32,\n-            message: message.into(),\n-        })?,\n-    };\n-    Ok(resp)\n-}\n-\n-#[allow(unused)]\n-enum ErrorCode {\n-    ParseError = -32700,\n-    InvalidRequest = -32600,\n-    MethodNotFound = -32601,\n-    InvalidParams = -32602,\n-    InternalError = -32603,\n-    ServerErrorStart = -32099,\n-    ServerErrorEnd = -32000,\n-    ServerNotInitialized = -32002,\n-    UnknownErrorCode = -32001,\n-    RequestCancelled = -32800,\n-}"}, {"sha": "f247327abf655d7077d28cd0b10113dca930072a", "filename": "crates/server/src/io.rs", "status": "removed", "additions": 0, "deletions": 207, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/3588d6b2da6e63730cc560c9986ba7fda5de816e/crates%2Fserver%2Fsrc%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3588d6b2da6e63730cc560c9986ba7fda5de816e/crates%2Fserver%2Fsrc%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fio.rs?ref=3588d6b2da6e63730cc560c9986ba7fda5de816e", "patch": "@@ -1,207 +0,0 @@\n-use std::{\n-    thread,\n-    io::{\n-        stdout, stdin,\n-        BufRead, Write,\n-    },\n-};\n-use serde_json::{Value, from_str, to_string};\n-use crossbeam_channel::{Receiver, Sender, bounded};\n-\n-use Result;\n-\n-\n-#[derive(Debug, Serialize, Deserialize)]\n-#[serde(untagged)]\n-pub enum RawMsg {\n-    Request(RawRequest),\n-    Notification(RawNotification),\n-    Response(RawResponse),\n-}\n-\n-#[derive(Debug, Serialize, Deserialize)]\n-pub struct RawRequest {\n-    pub id: u64,\n-    pub method: String,\n-    pub params: Value,\n-}\n-\n-#[derive(Debug, Serialize, Deserialize)]\n-pub struct RawNotification {\n-    pub method: String,\n-    pub params: Value,\n-}\n-\n-#[derive(Debug, Serialize, Deserialize)]\n-pub struct RawResponse {\n-    // JSON RPC allows this to be null if it was impossible\n-    // to decode the request's id. Ignore this special case\n-    // and just die horribly.\n-    pub id: u64,\n-    #[serde(default)]\n-    pub result: Value,\n-    #[serde(default)]\n-    pub error: Value,\n-}\n-\n-struct MsgReceiver {\n-    chan: Receiver<RawMsg>,\n-    thread: Option<thread::JoinHandle<Result<()>>>,\n-}\n-\n-impl MsgReceiver {\n-    fn recv(&mut self) -> Result<RawMsg> {\n-        match self.chan.recv() {\n-            Some(msg) => Ok(msg),\n-            None => {\n-                self.cleanup()?;\n-                unreachable!()\n-            }\n-        }\n-    }\n-\n-    fn cleanup(&mut self) -> Result<()> {\n-        self.thread\n-            .take()\n-            .ok_or_else(|| format_err!(\"MsgReceiver thread panicked\"))?\n-            .join()\n-            .map_err(|_| format_err!(\"MsgReceiver thread panicked\"))??;\n-        bail!(\"client disconnected\")\n-    }\n-\n-    fn stop(self) -> Result<()> {\n-        // Can't really self.thread.join() here, b/c it might be\n-        // blocking on read\n-        Ok(())\n-    }\n-}\n-\n-struct MsgSender {\n-    chan: Sender<RawMsg>,\n-    thread: thread::JoinHandle<Result<()>>,\n-}\n-\n-impl MsgSender {\n-    fn send(&mut self, msg: RawMsg) {\n-        self.chan.send(msg)\n-    }\n-\n-    fn stop(self) -> Result<()> {\n-        drop(self.chan);\n-        self.thread.join()\n-            .map_err(|_| format_err!(\"MsgSender thread panicked\"))??;\n-        Ok(())\n-    }\n-}\n-\n-pub struct Io {\n-    receiver: MsgReceiver,\n-    sender: MsgSender,\n-}\n-\n-impl Io {\n-    pub fn from_stdio() -> Io {\n-        let sender = {\n-            let (tx, rx) = bounded(16);\n-            MsgSender {\n-                chan: tx,\n-                thread: thread::spawn(move || {\n-                    let stdout = stdout();\n-                    let mut stdout = stdout.lock();\n-                    for msg in rx {\n-                        #[derive(Serialize)]\n-                        struct JsonRpc {\n-                            jsonrpc: &'static str,\n-                            #[serde(flatten)]\n-                            msg: RawMsg,\n-                        }\n-                        let text = to_string(&JsonRpc {\n-                            jsonrpc: \"2.0\",\n-                            msg,\n-                        })?;\n-                        write_msg_text(&mut stdout, &text)?;\n-                    }\n-                    Ok(())\n-                }),\n-            }\n-        };\n-        let receiver = {\n-            let (tx, rx) = bounded(16);\n-            MsgReceiver {\n-                chan: rx,\n-                thread: Some(thread::spawn(move || {\n-                    let stdin = stdin();\n-                    let mut stdin = stdin.lock();\n-                    while let Some(text) = read_msg_text(&mut stdin)? {\n-                        let msg: RawMsg = from_str(&text)?;\n-                        tx.send(msg);\n-                    }\n-                    Ok(())\n-                })),\n-            }\n-        };\n-        Io { receiver, sender }\n-    }\n-\n-    pub fn send(&mut self, msg: RawMsg) {\n-        self.sender.send(msg)\n-    }\n-\n-    pub fn recv(&mut self) -> Result<RawMsg> {\n-        self.receiver.recv()\n-    }\n-\n-    pub fn receiver(&mut self) -> &mut Receiver<RawMsg> {\n-        &mut self.receiver.chan\n-    }\n-\n-    pub fn cleanup_receiver(&mut self) -> Result<()> {\n-        self.receiver.cleanup()\n-    }\n-\n-    pub fn stop(self) -> Result<()> {\n-        self.receiver.stop()?;\n-        self.sender.stop()?;\n-        Ok(())\n-    }\n-}\n-\n-\n-fn read_msg_text(inp: &mut impl BufRead) -> Result<Option<String>> {\n-    let mut size = None;\n-    let mut buf = String::new();\n-    loop {\n-        buf.clear();\n-        if inp.read_line(&mut buf)? == 0 {\n-            return Ok(None);\n-        }\n-        if !buf.ends_with(\"\\r\\n\") {\n-            bail!(\"malformed header: {:?}\", buf);\n-        }\n-        let buf = &buf[..buf.len() - 2];\n-        if buf.is_empty() {\n-            break;\n-        }\n-        let mut parts = buf.splitn(2, \": \");\n-        let header_name = parts.next().unwrap();\n-        let header_value = parts.next().ok_or_else(|| format_err!(\"malformed header: {:?}\", buf))?;\n-        if header_name == \"Content-Length\" {\n-            size = Some(header_value.parse::<usize>()?);\n-        }\n-    }\n-    let size = size.ok_or_else(|| format_err!(\"no Content-Length\"))?;\n-    let mut buf = buf.into_bytes();\n-    buf.resize(size, 0);\n-    inp.read_exact(&mut buf)?;\n-    let buf = String::from_utf8(buf)?;\n-    debug!(\"< {}\", buf);\n-    Ok(Some(buf))\n-}\n-\n-fn write_msg_text(out: &mut impl Write, msg: &str) -> Result<()> {\n-    debug!(\"> {}\", msg);\n-    write!(out, \"Content-Length: {}\\r\\n\\r\\n\", msg.len())?;\n-    out.write_all(msg.as_bytes())?;\n-    out.flush()?;\n-    Ok(())\n-}"}, {"sha": "3e3bd44a13ebabfbc839c5b07fdc02f786d4595d", "filename": "crates/server/src/main.rs", "status": "modified", "additions": 6, "deletions": 98, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/8f1ce8275347e915b1cc824567e96369875cefd4/crates%2Fserver%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f1ce8275347e915b1cc824567e96369875cefd4/crates%2Fserver%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fmain.rs?ref=8f1ce8275347e915b1cc824567e96369875cefd4", "patch": "@@ -17,26 +17,20 @@ extern crate walkdir;\n extern crate libeditor;\n extern crate libanalysis;\n extern crate libsyntax2;\n+extern crate gen_lsp_server;\n extern crate im;\n extern crate relative_path;\n \n-mod io;\n mod caps;\n mod req;\n-mod dispatch;\n mod conv;\n mod main_loop;\n mod vfs;\n mod path_map;\n mod server_world;\n \n-use threadpool::ThreadPool;\n-use crossbeam_channel::bounded;\n use flexi_logger::{Logger, Duplicate};\n-\n-use ::{\n-    io::{Io, RawMsg, RawResponse, RawNotification},\n-};\n+use gen_lsp_server::{run_server, stdio_transport};\n \n pub type Result<T> = ::std::result::Result<T, ::failure::Error>;\n \n@@ -60,96 +54,10 @@ fn main() -> Result<()> {\n }\n \n fn main_inner() -> Result<()> {\n-    let mut io = Io::from_stdio();\n-    let res = initialize(&mut io);\n+    let (receiver, sender, threads) = stdio_transport();\n+    run_server(caps::server_capabilities(), main_loop::main_loop, receiver, sender)?;\n     info!(\"shutting down IO...\");\n-    let io_res = io.stop();\n+    threads.join()?;\n     info!(\"... IO is down\");\n-    match (res, io_res) {\n-        (Ok(()), Ok(())) => Ok(()),\n-        (res, Ok(())) => res,\n-        (Ok(()), io_res) => io_res,\n-        (res, Err(io_err)) => {\n-            error!(\"shutdown error: {:?}\", io_err);\n-            res\n-        }\n-    }\n-}\n-\n-fn initialize(io: &mut Io) -> Result<()> {\n-    match io.recv()? {\n-        RawMsg::Notification(n) =>\n-            bail!(\"expected initialize request, got {:?}\", n),\n-        RawMsg::Response(res) =>\n-            bail!(\"expected initialize request, got {:?}\", res),\n-\n-        RawMsg::Request(req) => {\n-            let req = dispatch::handle_request::<req::Initialize, _>(req, |_params, resp| {\n-                let res = req::InitializeResult { capabilities: caps::server_capabilities() };\n-                let resp = resp.into_response(Ok(res))?;\n-                io.send(RawMsg::Response(resp));\n-                Ok(())\n-            })?;\n-            if let Err(req) = req {\n-                bail!(\"expected initialize request, got {:?}\", req)\n-            }\n-            match io.recv()? {\n-                RawMsg::Notification(n) => {\n-                    if n.method != \"initialized\" {\n-                        bail!(\"expected initialized notification\");\n-                    }\n-                }\n-                _ => bail!(\"expected initialized notification\"),\n-            }\n-        }\n-    }\n-    initialized(io)\n-}\n-\n-enum Task {\n-    Respond(RawResponse),\n-    Notify(RawNotification),\n-    Die(::failure::Error),\n-}\n-\n-fn initialized(io: &mut Io) -> Result<()> {\n-    {\n-        let mut pool = ThreadPool::new(4);\n-        let (task_sender, task_receiver) = bounded::<Task>(16);\n-        let (fs_events_receiver, watcher) = vfs::watch(vec![\n-            ::std::env::current_dir()?,\n-        ]);\n-        info!(\"lifecycle: handshake finished, server ready to serve requests\");\n-        let res = main_loop::main_loop(\n-            io,\n-            &mut pool,\n-            task_sender,\n-            task_receiver.clone(),\n-            fs_events_receiver,\n-        );\n-\n-        info!(\"waiting for background jobs to finish...\");\n-        task_receiver.for_each(drop);\n-        pool.join();\n-        info!(\"...background jobs have finished\");\n-\n-        info!(\"waiting for file watcher to finish...\");\n-        watcher.stop()?;\n-        info!(\"...file watcher has finished\");\n-\n-        res\n-    }?;\n-\n-    match io.recv()? {\n-        RawMsg::Notification(n) => {\n-            if n.method == \"exit\" {\n-                info!(\"lifecycle: shutdown complete\");\n-                return Ok(());\n-            }\n-            bail!(\"unexpected notification during shutdown: {:?}\", n)\n-        }\n-        m => {\n-            bail!(\"unexpected message during shutdown: {:?}\", m)\n-        }\n-    }\n+    Ok(())\n }"}, {"sha": "34d07780532df74d98b99af6dd33e1d7973b2a42", "filename": "crates/server/src/main_loop/mod.rs", "status": "modified", "additions": 163, "deletions": 118, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/8f1ce8275347e915b1cc824567e96369875cefd4/crates%2Fserver%2Fsrc%2Fmain_loop%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f1ce8275347e915b1cc824567e96369875cefd4/crates%2Fserver%2Fsrc%2Fmain_loop%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fmain_loop%2Fmod.rs?ref=8f1ce8275347e915b1cc824567e96369875cefd4", "patch": "@@ -6,72 +6,108 @@ use std::{\n };\n \n use threadpool::ThreadPool;\n-use crossbeam_channel::{Sender, Receiver};\n+use serde::{Serialize, de::DeserializeOwned};\n+use crossbeam_channel::{bounded, Sender, Receiver};\n use languageserver_types::{NumberOrString};\n use libanalysis::{FileId, JobHandle, JobToken};\n+use gen_lsp_server::{RawRequest, RawNotification, RawMessage, RawResponse, ErrorCode};\n \n use {\n-    req, dispatch,\n-    Task, Result,\n-    io::{Io, RawMsg, RawRequest, RawNotification},\n-    vfs::FileEvent,\n+    req,\n+    Result,\n+    vfs::{self, FileEvent},\n     server_world::{ServerWorldState, ServerWorld},\n     main_loop::subscriptions::{Subscriptions},\n };\n \n+enum Task {\n+    Respond(RawResponse),\n+    Notify(RawNotification),\n+}\n+\n pub(super) fn main_loop(\n-    io: &mut Io,\n-    pool: &mut ThreadPool,\n-    task_sender: Sender<Task>,\n-    task_receiver: Receiver<Task>,\n-    fs_events_receiver: Receiver<Vec<FileEvent>>,\n+    receriver: &mut Receiver<RawMessage>,\n+    sender: &mut Sender<RawMessage>,\n ) -> Result<()> {\n+    let pool = ThreadPool::new(4);\n+    let (task_sender, task_receiver) = bounded::<Task>(16);\n+    let (fs_events_receiver, watcher) = vfs::watch(vec![\n+        ::std::env::current_dir()?,\n+    ]);\n+\n     info!(\"server initialized, serving requests\");\n     let mut state = ServerWorldState::new();\n \n-    let mut pending_requests: HashMap<u64, JobHandle> = HashMap::new();\n-    let mut fs_events_receiver = Some(&fs_events_receiver);\n+    let mut pending_requests = HashMap::new();\n     let mut subs = Subscriptions::new();\n+    main_loop_inner(\n+        &pool,\n+        receriver,\n+        sender,\n+        task_receiver.clone(),\n+        task_sender,\n+        fs_events_receiver,\n+        &mut state,\n+        &mut pending_requests,\n+        &mut subs,\n+    )?;\n+\n+    info!(\"waiting for background jobs to finish...\");\n+    task_receiver.for_each(drop);\n+    pool.join();\n+    info!(\"...background jobs have finished\");\n+\n+    info!(\"waiting for file watcher to finish...\");\n+    watcher.stop()?;\n+    info!(\"...file watcher has finished\");\n+    Ok(())\n+}\n+\n+fn main_loop_inner(\n+    pool: &ThreadPool,\n+    msg_receiver: &mut Receiver<RawMessage>,\n+    msg_sender: &mut Sender<RawMessage>,\n+    task_receiver: Receiver<Task>,\n+    task_sender: Sender<Task>,\n+    fs_receiver: Receiver<Vec<FileEvent>>,\n+    state: &mut ServerWorldState,\n+    pending_requests: &mut HashMap<u64, JobHandle>,\n+    subs: &mut Subscriptions,\n+) -> Result<u64> {\n+    let mut fs_receiver = Some(fs_receiver);\n     loop {\n         enum Event {\n-            Msg(RawMsg),\n+            Msg(RawMessage),\n             Task(Task),\n             Fs(Vec<FileEvent>),\n-            ReceiverDead,\n             FsWatcherDead,\n         }\n         let event = select! {\n-            recv(io.receiver(), msg) => match msg {\n+            recv(msg_receiver, msg) => match msg {\n                 Some(msg) => Event::Msg(msg),\n-                None => Event::ReceiverDead,\n+                None => bail!(\"client exited without shutdown\"),\n             },\n             recv(task_receiver, task) => Event::Task(task.unwrap()),\n-            recv(fs_events_receiver, events) => match events {\n+            recv(fs_receiver, events) => match events {\n                 Some(events) => Event::Fs(events),\n                 None => Event::FsWatcherDead,\n             }\n         };\n         let mut state_changed = false;\n         match event {\n-            Event::ReceiverDead => {\n-                io.cleanup_receiver()?;\n-                unreachable!();\n-            }\n             Event::FsWatcherDead => {\n-                fs_events_receiver = None;\n+                fs_receiver = None;\n             }\n             Event::Task(task) => {\n                 match task {\n                     Task::Respond(response) => {\n                         if let Some(handle) = pending_requests.remove(&response.id) {\n                             assert!(handle.has_completed());\n                         }\n-                        io.send(RawMsg::Response(response))\n+                        msg_sender.send(RawMessage::Response(response))\n                     }\n                     Task::Notify(n) =>\n-                        io.send(RawMsg::Notification(n)),\n-                    Task::Die(error) =>\n-                        return Err(error),\n+                        msg_sender.send(RawMessage::Notification(n)),\n                 }\n                 continue;\n             }\n@@ -82,16 +118,29 @@ pub(super) fn main_loop(\n             }\n             Event::Msg(msg) => {\n                 match msg {\n-                    RawMsg::Request(req) => {\n-                        if !on_request(io, &mut state, &mut pending_requests, pool, &task_sender, req)? {\n-                            return Ok(());\n+                    RawMessage::Request(req) => {\n+                        let req = match req.cast::<req::Shutdown>() {\n+                            Ok((id, _params)) => return Ok(id),\n+                            Err(req) => req,\n+                        };\n+                        match on_request(state, pending_requests, pool, &task_sender, req)? {\n+                            None => (),\n+                            Some(req) => {\n+                                error!(\"unknown request: {:?}\", req);\n+                                let resp = RawResponse::err(\n+                                    req.id,\n+                                    ErrorCode::MethodNotFound as i32,\n+                                    \"unknown request\".to_string(),\n+                                );\n+                                msg_sender.send(RawMessage::Response(resp))\n+                            }\n                         }\n                     }\n-                    RawMsg::Notification(not) => {\n-                        on_notification(io, &mut state, &mut pending_requests, &mut subs, not)?;\n+                    RawMessage::Notification(not) => {\n+                        on_notification(msg_sender, state, pending_requests, subs, not)?;\n                         state_changed = true;\n                     }\n-                    RawMsg::Response(resp) => {\n+                    RawMessage::Response(resp) => {\n                         error!(\"unexpected response: {:?}\", resp)\n                     }\n                 }\n@@ -110,13 +159,12 @@ pub(super) fn main_loop(\n }\n \n fn on_request(\n-    io: &mut Io,\n     world: &mut ServerWorldState,\n     pending_requests: &mut HashMap<u64, JobHandle>,\n     pool: &ThreadPool,\n     sender: &Sender<Task>,\n     req: RawRequest,\n-) -> Result<bool> {\n+) -> Result<Option<RawRequest>> {\n     let mut pool_dispatcher = PoolDispatcher {\n         req: Some(req),\n         res: None,\n@@ -141,81 +189,73 @@ fn on_request(\n         Ok((id, handle)) => {\n             let inserted = pending_requests.insert(id, handle).is_none();\n             assert!(inserted, \"duplicate request: {}\", id);\n+            Ok(None)\n         },\n-        Err(req) => {\n-            let req = dispatch::handle_request::<req::Shutdown, _>(req, |(), resp| {\n-                let resp = resp.into_response(Ok(()))?;\n-                io.send(RawMsg::Response(resp));\n-                Ok(())\n-            })?;\n-            match req {\n-                Ok(_id) => {\n-                    info!(\"lifecycle: initiating shutdown\");\n-                    return Ok(false);\n-                }\n-                Err(req) => {\n-                    error!(\"unknown method: {:?}\", req);\n-                    io.send(RawMsg::Response(dispatch::unknown_method(req.id)?));\n-                }\n-            }\n-        }\n+        Err(req) => Ok(Some(req)),\n     }\n-    Ok(true)\n }\n \n fn on_notification(\n-    io: &mut Io,\n+    msg_sender: &mut Sender<RawMessage>,\n     state: &mut ServerWorldState,\n     pending_requests: &mut HashMap<u64, JobHandle>,\n     subs: &mut Subscriptions,\n     not: RawNotification,\n ) -> Result<()> {\n-    let mut not = Some(not);\n-    dispatch::handle_notification::<req::Cancel, _>(&mut not, |params| {\n-        let id = match params.id {\n-            NumberOrString::Number(id) => id,\n-            NumberOrString::String(id) => {\n-                panic!(\"string id's not supported: {:?}\", id);\n+    let not = match not.cast::<req::Cancel>() {\n+        Ok(params) => {\n+            let id = match params.id {\n+                NumberOrString::Number(id) => id,\n+                NumberOrString::String(id) => {\n+                    panic!(\"string id's not supported: {:?}\", id);\n+                }\n+            };\n+            if let Some(handle) = pending_requests.remove(&id) {\n+                handle.cancel();\n             }\n-        };\n-        if let Some(handle) = pending_requests.remove(&id) {\n-            handle.cancel();\n+            return Ok(())\n         }\n-        Ok(())\n-    })?;\n-    dispatch::handle_notification::<req::DidOpenTextDocument, _>(&mut not, |params| {\n-        let uri = params.text_document.uri;\n-        let path = uri.to_file_path()\n-            .map_err(|()| format_err!(\"invalid uri: {}\", uri))?;\n-        let file_id = state.add_mem_file(path, params.text_document.text);\n-        subs.add_sub(file_id);\n-        Ok(())\n-    })?;\n-    dispatch::handle_notification::<req::DidChangeTextDocument, _>(&mut not, |mut params| {\n-        let uri = params.text_document.uri;\n-        let path = uri.to_file_path()\n-            .map_err(|()| format_err!(\"invalid uri: {}\", uri))?;\n-        let text = params.content_changes.pop()\n-            .ok_or_else(|| format_err!(\"empty changes\"))?\n-            .text;\n-        state.change_mem_file(path.as_path(), text)?;\n-        Ok(())\n-    })?;\n-    dispatch::handle_notification::<req::DidCloseTextDocument, _>(&mut not, |params| {\n-        let uri = params.text_document.uri;\n-        let path = uri.to_file_path()\n-            .map_err(|()| format_err!(\"invalid uri: {}\", uri))?;\n-        let file_id = state.remove_mem_file(path.as_path())?;\n-        subs.remove_sub(file_id);\n-        let not = req::PublishDiagnosticsParams { uri, diagnostics: Vec::new() };\n-        let not = dispatch::send_notification::<req::PublishDiagnostics>(not);\n-        io.send(RawMsg::Notification(not));\n-        Ok(())\n-    })?;\n-\n-    if let Some(not) = not {\n-        error!(\"unhandled notification: {:?}\", not);\n-    }\n+        Err(not) => not,\n+    };\n+    let not = match not.cast::<req::DidOpenTextDocument>() {\n+        Ok(params) => {\n+            let uri = params.text_document.uri;\n+            let path = uri.to_file_path()\n+                .map_err(|()| format_err!(\"invalid uri: {}\", uri))?;\n+            let file_id = state.add_mem_file(path, params.text_document.text);\n+            subs.add_sub(file_id);\n+            return Ok(())\n+        }\n+        Err(not) => not,\n+    };\n+    let not = match not.cast::<req::DidChangeTextDocument>() {\n+        Ok(mut params) => {\n+            let uri = params.text_document.uri;\n+            let path = uri.to_file_path()\n+                .map_err(|()| format_err!(\"invalid uri: {}\", uri))?;\n+            let text = params.content_changes.pop()\n+                .ok_or_else(|| format_err!(\"empty changes\"))?\n+                .text;\n+            state.change_mem_file(path.as_path(), text)?;\n+            return Ok(())\n+        }\n+        Err(not) => not,\n+    };\n+    let not = match not.cast::<req::DidCloseTextDocument>() {\n+        Ok(params) => {\n+            let uri = params.text_document.uri;\n+            let path = uri.to_file_path()\n+                .map_err(|()| format_err!(\"invalid uri: {}\", uri))?;\n+            let file_id = state.remove_mem_file(path.as_path())?;\n+            subs.remove_sub(file_id);\n+            let params = req::PublishDiagnosticsParams { uri, diagnostics: Vec::new() };\n+            let not = RawNotification::new::<req::PublishDiagnostics>(params);\n+            msg_sender.send(RawMessage::Notification(not));\n+            return Ok(())\n+        }\n+        Err(not) => not,\n+    };\n+    error!(\"unhandled notification: {:?}\", not);\n     Ok(())\n }\n \n@@ -228,34 +268,39 @@ struct PoolDispatcher<'a> {\n }\n \n impl<'a> PoolDispatcher<'a> {\n-    fn on<'b, R: req::ClientRequest>(\n+    fn on<'b, R>(\n         &'b mut self,\n         f: fn(ServerWorld, R::Params, JobToken) -> Result<R::Result>\n-    ) -> Result<&'b mut Self> {\n+    ) -> Result<&'b mut Self>\n+    where R: req::Request,\n+          R::Params: DeserializeOwned + Send + 'static,\n+          R::Result: Serialize + 'static,\n+    {\n         let req = match self.req.take() {\n             None => return Ok(self),\n             Some(req) => req,\n         };\n         let world = self.world;\n         let sender = self.sender;\n         let pool = self.pool;\n-        let (handle, token) = JobHandle::new();\n-        let req = dispatch::handle_request::<R, _>(req, |params, resp| {\n-            let world = world.snapshot();\n-            let sender = sender.clone();\n-            pool.execute(move || {\n-                let res = f(world, params, token);\n-                let task = match resp.into_response(res) {\n-                    Ok(resp) => Task::Respond(resp),\n-                    Err(e) => Task::Die(e),\n-                };\n-                sender.send(task);\n-            });\n-            Ok(())\n-        })?;\n-        match req {\n-            Ok(id) => self.res = Some((id, handle)),\n-            Err(req) => self.req = Some(req),\n+        match req.cast::<R>() {\n+            Ok((id, params)) => {\n+                let (handle, token) = JobHandle::new();\n+                let world = world.snapshot();\n+                let sender = sender.clone();\n+                pool.execute(move || {\n+                    let resp = match f(world, params, token) {\n+                        Ok(resp) => RawResponse::ok(id, resp),\n+                        Err(e) => RawResponse::err(id, ErrorCode::InternalError as i32, e.to_string()),\n+                    };\n+                    let task = Task::Respond(resp);\n+                    sender.send(task);\n+                });\n+                self.res = Some((id, handle));\n+            }\n+            Err(req) => {\n+                self.req = Some(req)\n+            }\n         }\n         Ok(self)\n     }\n@@ -282,7 +327,7 @@ fn update_file_notifications_on_threadpool(\n                     error!(\"failed to compute diagnostics: {:?}\", e)\n                 }\n                 Ok(params) => {\n-                    let not = dispatch::send_notification::<req::PublishDiagnostics>(params);\n+                    let not = RawNotification::new::<req::PublishDiagnostics>(params);\n                     sender.send(Task::Notify(not));\n                 }\n             }\n@@ -291,7 +336,7 @@ fn update_file_notifications_on_threadpool(\n                     error!(\"failed to compute decorations: {:?}\", e)\n                 }\n                 Ok(params) => {\n-                    let not = dispatch::send_notification::<req::PublishDecorations>(params);\n+                    let not = RawNotification::new::<req::PublishDecorations>(params);\n                     sender.send(Task::Notify(not))\n                 }\n             }"}]}