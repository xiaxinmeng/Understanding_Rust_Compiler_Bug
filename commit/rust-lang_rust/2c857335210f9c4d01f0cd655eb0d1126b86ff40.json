{"sha": "2c857335210f9c4d01f0cd655eb0d1126b86ff40", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjODU3MzM1MjEwZjljNGQwMWYwY2Q2NTVlYjBkMTEyNmI4NmZmNDA=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-22T22:44:59Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-23T04:27:08Z"}, "message": "Fix indents.", "tree": {"sha": "1feeff996c7a65a91fe72faf661c59ff74b17826", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1feeff996c7a65a91fe72faf661c59ff74b17826"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c857335210f9c4d01f0cd655eb0d1126b86ff40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c857335210f9c4d01f0cd655eb0d1126b86ff40", "html_url": "https://github.com/rust-lang/rust/commit/2c857335210f9c4d01f0cd655eb0d1126b86ff40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c857335210f9c4d01f0cd655eb0d1126b86ff40/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e1804db1836c268a0e41f05e29be30836913383", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e1804db1836c268a0e41f05e29be30836913383", "html_url": "https://github.com/rust-lang/rust/commit/1e1804db1836c268a0e41f05e29be30836913383"}], "stats": {"total": 272, "additions": 131, "deletions": 141}, "files": [{"sha": "b3f914441125cf654643f3967edc17c75f1291c5", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 131, "deletions": 141, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/2c857335210f9c4d01f0cd655eb0d1126b86ff40/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c857335210f9c4d01f0cd655eb0d1126b86ff40/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=2c857335210f9c4d01f0cd655eb0d1126b86ff40", "patch": "@@ -1198,88 +1198,86 @@ impl<'a> Parser<'a> {\n             };\n             (ident, TraitItemKind::Const(ty, default))\n         } else if self.token.is_path_start() {\n-                // trait item macro.\n-                // code copied from parse_macro_use_or_failure... abstraction!\n-                let lo = self.span.lo;\n-                let pth = self.parse_path(PathStyle::Mod)?;\n-                self.expect(&token::Not)?;\n+            // trait item macro.\n+            // code copied from parse_macro_use_or_failure... abstraction!\n+            let lo = self.span.lo;\n+            let pth = self.parse_path(PathStyle::Mod)?;\n+            self.expect(&token::Not)?;\n \n-                // eat a matched-delimiter token tree:\n-                let delim = self.expect_open_delim()?;\n-                let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n-                                                SeqSep::none(),\n-                                                |pp| pp.parse_token_tree())?;\n-                if delim != token::Brace {\n-                    self.expect(&token::Semi)?\n-                }\n+            // eat a matched-delimiter token tree:\n+            let delim = self.expect_open_delim()?;\n+            let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n+                                            SeqSep::none(),\n+                                            |pp| pp.parse_token_tree())?;\n+            if delim != token::Brace {\n+                self.expect(&token::Semi)?\n+            }\n \n-                let mac = spanned(lo, self.last_span.hi, Mac_ { path: pth, tts: tts });\n-                (keywords::Invalid.ident(), ast::TraitItemKind::Macro(mac))\n-            } else {\n-                let (constness, unsafety, abi) = match self.parse_fn_front_matter() {\n-                    Ok(cua) => cua,\n-                    Err(e) => {\n-                        loop {\n-                            match self.token {\n-                                token::Eof => break,\n-                                token::CloseDelim(token::Brace) |\n-                                token::Semi => {\n-                                    self.bump();\n-                                    break;\n-                                }\n-                                token::OpenDelim(token::Brace) => {\n-                                    self.parse_token_tree()?;\n-                                    break;\n-                                }\n-                                _ => self.bump()\n+            let mac = spanned(lo, self.last_span.hi, Mac_ { path: pth, tts: tts });\n+            (keywords::Invalid.ident(), ast::TraitItemKind::Macro(mac))\n+        } else {\n+            let (constness, unsafety, abi) = match self.parse_fn_front_matter() {\n+                Ok(cua) => cua,\n+                Err(e) => {\n+                    loop {\n+                        match self.token {\n+                            token::Eof => break,\n+                            token::CloseDelim(token::Brace) |\n+                            token::Semi => {\n+                                self.bump();\n+                                break;\n+                            }\n+                            token::OpenDelim(token::Brace) => {\n+                                self.parse_token_tree()?;\n+                                break;\n                             }\n+                            _ => self.bump(),\n                         }\n-\n-                        return Err(e);\n                     }\n-                };\n \n-                let ident = self.parse_ident()?;\n-                let mut generics = self.parse_generics()?;\n+                    return Err(e);\n+                }\n+            };\n \n-                let d = self.parse_fn_decl_with_self(|p: &mut Parser<'a>|{\n-                    // This is somewhat dubious; We don't want to allow\n-                    // argument names to be left off if there is a\n-                    // definition...\n-                    p.parse_arg_general(false)\n-                })?;\n+            let ident = self.parse_ident()?;\n+            let mut generics = self.parse_generics()?;\n \n-                generics.where_clause = self.parse_where_clause()?;\n-                let sig = ast::MethodSig {\n-                    unsafety: unsafety,\n-                    constness: constness,\n-                    decl: d,\n-                    generics: generics,\n-                    abi: abi,\n-                };\n+            let d = self.parse_fn_decl_with_self(|p: &mut Parser<'a>|{\n+                // This is somewhat dubious; We don't want to allow\n+                // argument names to be left off if there is a\n+                // definition...\n+                p.parse_arg_general(false)\n+            })?;\n \n-                let body = match self.token {\n-                    token::Semi => {\n-                        self.bump();\n-                        debug!(\"parse_trait_methods(): parsing required method\");\n-                        None\n-                    }\n-                    token::OpenDelim(token::Brace) => {\n-                        debug!(\"parse_trait_methods(): parsing provided method\");\n-                        let (inner_attrs, body) =\n-                            self.parse_inner_attrs_and_block()?;\n-                        attrs.extend(inner_attrs.iter().cloned());\n-                        Some(body)\n-                    }\n+            generics.where_clause = self.parse_where_clause()?;\n+            let sig = ast::MethodSig {\n+                unsafety: unsafety,\n+                constness: constness,\n+                decl: d,\n+                generics: generics,\n+                abi: abi,\n+            };\n \n-                    _ => {\n-                        let token_str = self.this_token_to_string();\n-                        return Err(self.fatal(&format!(\"expected `;` or `{{`, found `{}`\",\n-                                                    token_str)[..]))\n-                    }\n-                };\n-                (ident, ast::TraitItemKind::Method(sig, body))\n+            let body = match self.token {\n+                token::Semi => {\n+                    self.bump();\n+                    debug!(\"parse_trait_methods(): parsing required method\");\n+                    None\n+                }\n+                token::OpenDelim(token::Brace) => {\n+                    debug!(\"parse_trait_methods(): parsing provided method\");\n+                    let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n+                    attrs.extend(inner_attrs.iter().cloned());\n+                    Some(body)\n+                }\n+                _ => {\n+                    let token_str = self.this_token_to_string();\n+                    return Err(self.fatal(&format!(\"expected `;` or `{{`, found `{}`\", token_str)));\n+                }\n             };\n+            (ident, ast::TraitItemKind::Method(sig, body))\n+        };\n+\n         Ok(TraitItem {\n             id: ast::DUMMY_NODE_ID,\n             ident: name,\n@@ -3562,39 +3560,37 @@ impl<'a> Parser<'a> {\n         let lo = self.span.lo;\n         let pat;\n         match self.token {\n-          token::Underscore => {\n-            // Parse _\n-            self.bump();\n-            pat = PatKind::Wild;\n-          }\n-          token::BinOp(token::And) | token::AndAnd => {\n-            // Parse &pat / &mut pat\n-            self.expect_and()?;\n-            let mutbl = self.parse_mutability()?;\n-            if let token::Lifetime(ident) = self.token {\n-                return Err(self.fatal(&format!(\"unexpected lifetime `{}` in pattern\", ident)));\n+            token::Underscore => {\n+                // Parse _\n+                self.bump();\n+                pat = PatKind::Wild;\n+            }\n+            token::BinOp(token::And) | token::AndAnd => {\n+                // Parse &pat / &mut pat\n+                self.expect_and()?;\n+                let mutbl = self.parse_mutability()?;\n+                if let token::Lifetime(ident) = self.token {\n+                    return Err(self.fatal(&format!(\"unexpected lifetime `{}` in pattern\", ident)));\n+                }\n+                let subpat = self.parse_pat()?;\n+                pat = PatKind::Ref(subpat, mutbl);\n+            }\n+            token::OpenDelim(token::Paren) => {\n+                // Parse (pat,pat,pat,...) as tuple pattern\n+                self.bump();\n+                let (fields, ddpos) = self.parse_pat_tuple_elements(true)?;\n+                self.expect(&token::CloseDelim(token::Paren))?;\n+                pat = PatKind::Tuple(fields, ddpos);\n+            }\n+            token::OpenDelim(token::Bracket) => {\n+                // Parse [pat,pat,...] as slice pattern\n+                self.bump();\n+                let (before, slice, after) = self.parse_pat_vec_elements()?;\n+                self.expect(&token::CloseDelim(token::Bracket))?;\n+                pat = PatKind::Vec(before, slice, after);\n             }\n-\n-            let subpat = self.parse_pat()?;\n-            pat = PatKind::Ref(subpat, mutbl);\n-          }\n-          token::OpenDelim(token::Paren) => {\n-            // Parse (pat,pat,pat,...) as tuple pattern\n-            self.bump();\n-            let (fields, ddpos) = self.parse_pat_tuple_elements(true)?;\n-            self.expect(&token::CloseDelim(token::Paren))?;\n-            pat = PatKind::Tuple(fields, ddpos);\n-          }\n-          token::OpenDelim(token::Bracket) => {\n-            // Parse [pat,pat,...] as slice pattern\n-            self.bump();\n-            let (before, slice, after) = self.parse_pat_vec_elements()?;\n-            self.expect(&token::CloseDelim(token::Bracket))?;\n-            pat = PatKind::Vec(before, slice, after);\n-          }\n-          _ => {\n             // At this point, token != _, &, &&, (, [\n-            if self.eat_keyword(keywords::Mut) {\n+            _ => if self.eat_keyword(keywords::Mut) {\n                 // Parse mut ident @ pat\n                 pat = self.parse_pat_ident(BindingMode::ByValue(Mutability::Mutable))?;\n             } else if self.eat_keyword(keywords::Ref) {\n@@ -3605,51 +3601,49 @@ impl<'a> Parser<'a> {\n                 // Parse box pat\n                 let subpat = self.parse_pat()?;\n                 pat = PatKind::Box(subpat);\n+            } else if self.token.is_ident() && self.token.is_path_start() &&\n+                      self.look_ahead(1, |t| match *t {\n+                          token::OpenDelim(token::Paren) | token::OpenDelim(token::Brace) |\n+                          token::DotDotDot | token::ModSep | token::Not => false,\n+                          _ => true,\n+                      }) {\n+                // Parse ident @ pat\n+                // This can give false positives and parse nullary enums,\n+                // they are dealt with later in resolve\n+                let binding_mode = BindingMode::ByValue(Mutability::Immutable);\n+                pat = self.parse_pat_ident(binding_mode)?;\n             } else if self.token.is_path_start() {\n                 // Parse pattern starting with a path\n-                if self.token.is_ident() && self.look_ahead(1, |t| match *t {\n-                    token::OpenDelim(token::Paren) | token::OpenDelim(token::Brace) |\n-                    token::DotDotDot | token::ModSep | token::Not => false,\n-                    _ => true,\n-                }) {\n-                    // Parse ident @ pat\n-                    // This can give false positives and parse nullary enums,\n-                    // they are dealt with later in resolve\n-                    let binding_mode = BindingMode::ByValue(Mutability::Immutable);\n-                    pat = self.parse_pat_ident(binding_mode)?;\n+                let (qself, path) = if self.eat_lt() {\n+                    // Parse a qualified path\n+                    let (qself, path) = self.parse_qualified_path(PathStyle::Expr)?;\n+                    (Some(qself), path)\n                 } else {\n-                    let (qself, path) = if self.eat_lt() {\n-                        // Parse a qualified path\n-                        let (qself, path) =\n-                            self.parse_qualified_path(PathStyle::Expr)?;\n-                        (Some(qself), path)\n-                    } else {\n-                        // Parse an unqualified path\n-                        (None, self.parse_path(PathStyle::Expr)?)\n-                    };\n-                    match self.token {\n-                      token::Not if qself.is_none() => {\n+                    // Parse an unqualified path\n+                    (None, self.parse_path(PathStyle::Expr)?)\n+                };\n+                match self.token {\n+                    token::Not if qself.is_none() => {\n                         // Parse macro invocation\n                         self.bump();\n                         let delim = self.expect_open_delim()?;\n-                        let tts = self.parse_seq_to_end(\n-                            &token::CloseDelim(delim),\n-                            SeqSep::none(), |p| p.parse_token_tree())?;\n-                        let mac = Mac_ { path: path, tts: tts };\n-                        pat = PatKind::Mac(codemap::Spanned {node: mac,\n-                                                               span: mk_sp(lo, self.last_span.hi)});\n-                      }\n-                      token::DotDotDot => {\n+                        let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n+                                                        SeqSep::none(),\n+                                                        |p| p.parse_token_tree())?;\n+                        let mac = spanned(lo, self.last_span.hi, Mac_ { path: path, tts: tts });\n+                        pat = PatKind::Mac(mac);\n+                    }\n+                    token::DotDotDot => {\n                         // Parse range\n                         let hi = self.last_span.hi;\n                         let begin =\n                               self.mk_expr(lo, hi, ExprKind::Path(qself, path), ThinVec::new());\n                         self.bump();\n                         let end = self.parse_pat_range_end()?;\n                         pat = PatKind::Range(begin, end);\n-                      }\n-                      token::OpenDelim(token::Brace) => {\n-                         if qself.is_some() {\n+                    }\n+                    token::OpenDelim(token::Brace) => {\n+                        if qself.is_some() {\n                             return Err(self.fatal(\"unexpected `{` after qualified path\"));\n                         }\n                         // Parse struct pattern\n@@ -3661,8 +3655,8 @@ impl<'a> Parser<'a> {\n                         });\n                         self.bump();\n                         pat = PatKind::Struct(path, fields, etc);\n-                      }\n-                      token::OpenDelim(token::Paren) => {\n+                    }\n+                    token::OpenDelim(token::Paren) => {\n                         if qself.is_some() {\n                             return Err(self.fatal(\"unexpected `(` after qualified path\"));\n                         }\n@@ -3671,11 +3665,8 @@ impl<'a> Parser<'a> {\n                         let (fields, ddpos) = self.parse_pat_tuple_elements(false)?;\n                         self.expect(&token::CloseDelim(token::Paren))?;\n                         pat = PatKind::TupleStruct(path, fields, ddpos)\n-                      }\n-                      _ => {\n-                        pat = PatKind::Path(qself, path);\n-                      }\n                     }\n+                    _ => pat = PatKind::Path(qself, path),\n                 }\n             } else {\n                 // Try to parse everything else as literal with optional minus\n@@ -3695,7 +3686,6 @@ impl<'a> Parser<'a> {\n                     }\n                 }\n             }\n-          }\n         }\n \n         let hi = self.last_span.hi;"}]}