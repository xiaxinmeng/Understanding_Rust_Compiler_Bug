{"sha": "7846dbe0c8de17f59cdfc3d2b914d58faad7eade", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4NDZkYmUwYzhkZTE3ZjU5Y2RmYzNkMmI5MTRkNThmYWFkN2VhZGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-26T14:04:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-26T14:04:25Z"}, "message": "Auto merge of #40826 - frewsxcv:rollup, r=frewsxcv\n\nRollup of 7 pull requests\n\n- Successful merges: #40642, #40734, #40740, #40771, #40807, #40820, #40821\n- Failed merges:", "tree": {"sha": "87a4a8f5945327ad7b3c9700160dcdfa83133245", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87a4a8f5945327ad7b3c9700160dcdfa83133245"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7846dbe0c8de17f59cdfc3d2b914d58faad7eade", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7846dbe0c8de17f59cdfc3d2b914d58faad7eade", "html_url": "https://github.com/rust-lang/rust/commit/7846dbe0c8de17f59cdfc3d2b914d58faad7eade", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bcfd5c48b7ec96cc28bef2cc5e29b4ae0ce6c3ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/bcfd5c48b7ec96cc28bef2cc5e29b4ae0ce6c3ac", "html_url": "https://github.com/rust-lang/rust/commit/bcfd5c48b7ec96cc28bef2cc5e29b4ae0ce6c3ac"}, {"sha": "dc52625d61e11f5cbdde5debdcf9b1e1fc48324f", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc52625d61e11f5cbdde5debdcf9b1e1fc48324f", "html_url": "https://github.com/rust-lang/rust/commit/dc52625d61e11f5cbdde5debdcf9b1e1fc48324f"}], "stats": {"total": 386, "additions": 240, "deletions": 146}, "files": [{"sha": "255445c318dca7c830e4e325df5155715259ba44", "filename": "src/doc/unstable-book/src/inclusive-range-syntax.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Fdoc%2Funstable-book%2Fsrc%2Finclusive-range-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Fdoc%2Funstable-book%2Fsrc%2Finclusive-range-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Finclusive-range-syntax.md?ref=7846dbe0c8de17f59cdfc3d2b914d58faad7eade", "patch": "@@ -6,5 +6,15 @@ The tracking issue for this feature is: [#28237]\n \n ------------------------\n \n+To get a range that goes from 0 to 10 and includes the value 10, you\n+can write `0...10`:\n \n+```rust\n+#![feature(inclusive_range_syntax)]\n \n+fn main() {\n+    for i in 0...10 {\n+        println!(\"{}\", i);\n+    }\n+}\n+```"}, {"sha": "60dab943a3acfa094b93b275162bacc294610b78", "filename": "src/libcore/num/dec2flt/algorithm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs?ref=7846dbe0c8de17f59cdfc3d2b914d58faad7eade", "patch": "@@ -141,7 +141,7 @@ pub fn fast_path<T: RawFloat>(integral: &[u8], fractional: &[u8], e: i64) -> Opt\n ///\n /// It rounds ``f`` to a float with 64 bit significand and multiplies it by the best approximation\n /// of `10^e` (in the same floating point format). This is often enough to get the correct result.\n-/// However, when the result is close to halfway between two adjecent (ordinary) floats, the\n+/// However, when the result is close to halfway between two adjacent (ordinary) floats, the\n /// compound rounding error from multiplying two approximation means the result may be off by a\n /// few bits. When this happens, the iterative Algorithm R fixes things up.\n ///\n@@ -392,7 +392,7 @@ fn underflow<T: RawFloat>(x: Big, v: Big, rem: Big) -> T {\n     //\n     // Therefore, when the rounded-off bits are != 0.5 ULP, they decide the rounding\n     // on their own. When they are equal and the remainder is non-zero, the value still\n-    // needs to be rounded up. Only when the rounded off bits are 1/2 and the remainer\n+    // needs to be rounded up. Only when the rounded off bits are 1/2 and the remainder\n     // is zero, we have a half-to-even situation.\n     let bits = x.bit_length();\n     let lsb = bits - T::sig_bits() as usize;"}, {"sha": "307e4974d9769f6a1762c6c32951b6e88866674d", "filename": "src/libcore/slice/sort.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibcore%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibcore%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fsort.rs?ref=7846dbe0c8de17f59cdfc3d2b914d58faad7eade", "patch": "@@ -152,8 +152,8 @@ fn partial_insertion_sort<T, F>(v: &mut [T], is_less: &mut F) -> bool\n fn insertion_sort<T, F>(v: &mut [T], is_less: &mut F)\n     where F: FnMut(&T, &T) -> bool\n {\n-    for i in 2..v.len()+1 {\n-        shift_tail(&mut v[..i], is_less);\n+    for i in 1..v.len() {\n+        shift_tail(&mut v[..i+1], is_less);\n     }\n }\n "}, {"sha": "5ee9258852b0b8bb75892e79ff02403afa68ec33", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=7846dbe0c8de17f59cdfc3d2b914d58faad7eade", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use hir::def_id::CrateNum;\n use std::fmt::Debug;\n use std::sync::Arc;\n \n@@ -81,7 +82,7 @@ pub enum DepNode<D: Clone + Debug> {\n     TypeckItemType(D),\n     UnusedTraitCheck,\n     CheckConst(D),\n-    Privacy,\n+    PrivacyAccessLevels(CrateNum),\n     IntrinsicCheck(D),\n     MatchCheck(D),\n \n@@ -230,7 +231,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             CheckEntryFn => Some(CheckEntryFn),\n             Variance => Some(Variance),\n             UnusedTraitCheck => Some(UnusedTraitCheck),\n-            Privacy => Some(Privacy),\n+            PrivacyAccessLevels(k) => Some(PrivacyAccessLevels(k)),\n             Reachability => Some(Reachability),\n             DeadCheck => Some(DeadCheck),\n             LateLintCheck => Some(LateLintCheck),"}, {"sha": "5dbabcc923048482f8f06884ac3ec25c1ae7e82c", "filename": "src/librustc/dep_graph/edges.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fedges.rs?ref=7846dbe0c8de17f59cdfc3d2b914d58faad7eade", "patch": "@@ -101,11 +101,15 @@ impl<D: Clone + Debug + Eq + Hash> DepGraphEdges<D> {\n     }\n \n     /// Indicates that the current task `C` reads `v` by adding an\n-    /// edge from `v` to `C`. If there is no current task, panics. If\n-    /// you want to suppress this edge, use `ignore`.\n+    /// edge from `v` to `C`. If there is no current task, has no\n+    /// effect. Note that *reading* from tracked state is harmless if\n+    /// you are not in a task; what is bad is *writing* to tracked\n+    /// state (and leaking data that you read into a tracked task).\n     pub fn read(&mut self, v: DepNode<D>) {\n-        let source = self.make_node(v);\n-        self.add_edge_from_current_node(|current| (source, current))\n+        if self.current_node().is_some() {\n+            let source = self.make_node(v);\n+            self.add_edge_from_current_node(|current| (source, current))\n+        }\n     }\n \n     /// Indicates that the current task `C` writes `v` by adding an"}, {"sha": "bedb6ff2771f064e468b5789a0ffb0a04b33fc85", "filename": "src/librustc/dep_graph/shadow.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustc%2Fdep_graph%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustc%2Fdep_graph%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fshadow.rs?ref=7846dbe0c8de17f59cdfc3d2b914d58faad7eade", "patch": "@@ -80,7 +80,13 @@ impl ShadowGraph {\n \n             let mut stack = self.stack.borrow_mut();\n             match *message {\n-                DepMessage::Read(ref n) => self.check_edge(Some(Some(n)), top(&stack)),\n+                // It is ok to READ shared state outside of a\n+                // task. That can't do any harm (at least, the only\n+                // way it can do harm is by leaking that data into a\n+                // query or task, which would be a problem\n+                // anyway). What would be bad is WRITING to that\n+                // state.\n+                DepMessage::Read(_) => { }\n                 DepMessage::Write(ref n) => self.check_edge(top(&stack), Some(Some(n))),\n                 DepMessage::PushTask(ref n) => stack.push(Some(n.clone())),\n                 DepMessage::PushIgnore => stack.push(None),\n@@ -116,7 +122,7 @@ impl ShadowGraph {\n             (None, None) => unreachable!(),\n \n             // nothing on top of the stack\n-            (None, Some(n)) | (Some(n), None) => bug!(\"read/write of {:?} but no current task\", n),\n+            (None, Some(n)) | (Some(n), None) => bug!(\"write of {:?} but no current task\", n),\n \n             // this corresponds to an Ignore being top of the stack\n             (Some(None), _) | (_, Some(None)) => (),"}, {"sha": "f4f2f4cf9211b532aa19a18001802a763a17225b", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=7846dbe0c8de17f59cdfc3d2b914d58faad7eade", "patch": "@@ -159,6 +159,10 @@ impl Lifetime {\n     pub fn is_elided(&self) -> bool {\n         self.name == keywords::Invalid.name()\n     }\n+\n+    pub fn is_static(&self) -> bool {\n+        self.name == keywords::StaticLifetime.name()\n+    }\n }\n \n /// A lifetime definition, eg `'a: 'b+'c+'d`"}, {"sha": "d35f965e2ffd767332f88977af762b6db35d14de", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=7846dbe0c8de17f59cdfc3d2b914d58faad7eade", "patch": "@@ -44,9 +44,10 @@ use std::ops::Deref;\n use syntax::attr;\n use syntax::ast;\n use syntax::symbol::Symbol;\n-use syntax_pos::{MultiSpan, Span};\n+use syntax_pos::{DUMMY_SP, MultiSpan, Span};\n use errors::{self, Diagnostic, DiagnosticBuilder};\n use hir;\n+use hir::def_id::LOCAL_CRATE;\n use hir::intravisit as hir_visit;\n use syntax::visit as ast_visit;\n \n@@ -1231,10 +1232,11 @@ fn check_lint_name_cmdline(sess: &Session, lint_cx: &LintStore,\n /// Perform lint checking on a crate.\n ///\n /// Consumes the `lint_store` field of the `Session`.\n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             access_levels: &AccessLevels) {\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let _task = tcx.dep_graph.in_task(DepNode::LateLintCheck);\n \n+    let access_levels = &ty::queries::privacy_access_levels::get(tcx, DUMMY_SP, LOCAL_CRATE);\n+\n     let krate = tcx.hir.krate();\n \n     // We want to own the lint store, so move it out of the session."}, {"sha": "56bbc0480c30afb44237f67ad276edb96ce76630", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=7846dbe0c8de17f59cdfc3d2b914d58faad7eade", "patch": "@@ -255,8 +255,8 @@ pub trait CrateStore {\n     fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)>;\n     fn used_crate_source(&self, cnum: CrateNum) -> CrateSource;\n     fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum>;\n-    fn encode_metadata<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 reexports: &def::ExportMap,\n+    fn encode_metadata<'a, 'tcx>(&self,\n+                                 tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  link_meta: &LinkMeta,\n                                  reachable: &NodeSet) -> Vec<u8>;\n     fn metadata_encoding_version(&self) -> &[u8];\n@@ -412,10 +412,10 @@ impl CrateStore for DummyCrateStore {\n         { vec![] }\n     fn used_crate_source(&self, cnum: CrateNum) -> CrateSource { bug!(\"used_crate_source\") }\n     fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum> { None }\n-    fn encode_metadata<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           reexports: &def::ExportMap,\n-                           link_meta: &LinkMeta,\n-                           reachable: &NodeSet) -> Vec<u8> { vec![] }\n+    fn encode_metadata<'a, 'tcx>(&self,\n+                                 tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                 link_meta: &LinkMeta,\n+                                 reachable: &NodeSet) -> Vec<u8> { vec![] }\n     fn metadata_encoding_version(&self) -> &[u8] { bug!(\"metadata_encoding_version\") }\n }\n "}, {"sha": "8926ff5c1fbbb080dce5afbfe165418548395d66", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=7846dbe0c8de17f59cdfc3d2b914d58faad7eade", "patch": "@@ -21,12 +21,13 @@ use hir::itemlikevisit::ItemLikeVisitor;\n use middle::privacy;\n use ty::{self, TyCtxt};\n use hir::def::Def;\n-use hir::def_id::{DefId};\n+use hir::def_id::{DefId, LOCAL_CRATE};\n use lint;\n use util::nodemap::FxHashSet;\n \n use syntax::{ast, codemap};\n use syntax::attr;\n+use syntax::codemap::DUMMY_SP;\n use syntax_pos;\n \n // Any local node that may call something in its body block should be\n@@ -592,9 +593,9 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n     }\n }\n \n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             access_levels: &privacy::AccessLevels) {\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let _task = tcx.dep_graph.in_task(DepNode::DeadCheck);\n+    let access_levels = &ty::queries::privacy_access_levels::get(tcx, DUMMY_SP, LOCAL_CRATE);\n     let krate = tcx.hir.krate();\n     let live_symbols = find_live(tcx, access_levels, krate);\n     let mut visitor = DeadVisitor { tcx: tcx, live_symbols: live_symbols };"}, {"sha": "b0e39442af98c9997f9885949d3b2e56e07d3178", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=7846dbe0c8de17f59cdfc3d2b914d58faad7eade", "patch": "@@ -27,7 +27,9 @@ use util::nodemap::{NodeSet, FxHashSet};\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax::attr;\n+use syntax::codemap::DUMMY_SP;\n use hir;\n+use hir::def_id::LOCAL_CRATE;\n use hir::intravisit::{Visitor, NestedVisitorMap};\n use hir::itemlikevisit::ItemLikeVisitor;\n use hir::intravisit;\n@@ -359,11 +361,11 @@ impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a,\n     }\n }\n \n-pub fn find_reachable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                access_levels: &privacy::AccessLevels)\n-                                -> NodeSet {\n+pub fn find_reachable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> NodeSet {\n     let _task = tcx.dep_graph.in_task(DepNode::Reachability);\n \n+    let access_levels = &ty::queries::privacy_access_levels::get(tcx, DUMMY_SP, LOCAL_CRATE);\n+\n     let any_library = tcx.sess.crate_types.borrow().iter().any(|ty| {\n         *ty == config::CrateTypeRlib || *ty == config::CrateTypeDylib ||\n         *ty == config::CrateTypeProcMacro"}, {"sha": "5094e28475b2640e9faea82e38e71fe28b91bba1", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=7846dbe0c8de17f59cdfc3d2b914d58faad7eade", "patch": "@@ -29,7 +29,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::ptr::P;\n use syntax::symbol::keywords;\n-use syntax_pos::Span;\n+use syntax_pos::{mk_sp, Span};\n use errors::DiagnosticBuilder;\n use util::nodemap::{NodeMap, NodeSet, FxHashSet, FxHashMap, DefIdMap};\n use rustc_back::slice;\n@@ -434,7 +434,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             self.resolve_elided_lifetimes(slice::ref_slice(lifetime_ref));\n             return;\n         }\n-        if lifetime_ref.name == keywords::StaticLifetime.name() {\n+        if lifetime_ref.is_static() {\n             self.insert_lifetime(lifetime_ref, Region::Static);\n             return;\n         }\n@@ -1434,7 +1434,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             let lifetime_i = &lifetimes[i];\n \n             for lifetime in lifetimes {\n-                if lifetime.lifetime.name == keywords::StaticLifetime.name() {\n+                if lifetime.lifetime.is_static() {\n                     let lifetime = lifetime.lifetime;\n                     let mut err = struct_span_err!(self.sess, lifetime.span, E0262,\n                                   \"invalid lifetime parameter name: `{}`\", lifetime.name);\n@@ -1464,7 +1464,17 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             self.check_lifetime_def_for_shadowing(old_scope, &lifetime_i.lifetime);\n \n             for bound in &lifetime_i.bounds {\n-                self.resolve_lifetime_ref(bound);\n+                if !bound.is_static() {\n+                    self.resolve_lifetime_ref(bound);\n+                } else {\n+                    self.insert_lifetime(bound, Region::Static);\n+                    let full_span = mk_sp(lifetime_i.lifetime.span.lo, bound.span.hi);\n+                    self.sess.struct_span_warn(full_span,\n+                        &format!(\"unnecessary lifetime parameter `{}`\", lifetime_i.lifetime.name))\n+                        .help(&format!(\"you can use the `'static` lifetime directly, in place \\\n+                                        of `{}`\", lifetime_i.lifetime.name))\n+                        .emit();\n+                }\n             }\n         }\n     }"}, {"sha": "4115b4669f4b20874938c929313f10030c394bb8", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=7846dbe0c8de17f59cdfc3d2b914d58faad7eade", "patch": "@@ -656,10 +656,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n /// Given the list of enabled features that were not language features (i.e. that\n /// were expected to be library features), and the list of features used from\n /// libraries, identify activated features that don't exist and error about them.\n-pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                 access_levels: &AccessLevels) {\n+pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let sess = &tcx.sess;\n \n+    let access_levels = &ty::queries::privacy_access_levels::get(tcx, DUMMY_SP, LOCAL_CRATE);\n+\n     if tcx.stability.borrow().staged_api[&LOCAL_CRATE] && tcx.sess.features.borrow().staged_api {\n         let _task = tcx.dep_graph.in_task(DepNode::StabilityIndex);\n         let krate = tcx.hir.krate();"}, {"sha": "da56514ea82fbf9e485c3f1f761ff9253f9b54cc", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=7846dbe0c8de17f59cdfc3d2b914d58faad7eade", "patch": "@@ -15,7 +15,7 @@ use session::Session;\n use lint;\n use middle;\n use hir::TraitMap;\n-use hir::def::Def;\n+use hir::def::{Def, ExportMap};\n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use hir::map as hir_map;\n use hir::map::DisambiguatedDefPathData;\n@@ -416,6 +416,9 @@ pub struct GlobalCtxt<'tcx> {\n     /// is relevant; generated by resolve.\n     pub trait_map: TraitMap,\n \n+    /// Export map produced by name resolution.\n+    pub export_map: ExportMap,\n+\n     pub named_region_map: resolve_lifetime::NamedRegionMap,\n \n     pub region_maps: RegionMaps,\n@@ -698,6 +701,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             region_maps: region_maps,\n             variance_computed: Cell::new(false),\n             trait_map: resolutions.trait_map,\n+            export_map: resolutions.export_map,\n             fulfilled_predicates: RefCell::new(fulfilled_predicates),\n             hir: hir,\n             maps: maps::Maps::new(dep_graph, providers),"}, {"sha": "da4e58addd71b08b9d3d5da76f664b80550ac863", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=7846dbe0c8de17f59cdfc3d2b914d58faad7eade", "patch": "@@ -11,6 +11,7 @@\n use dep_graph::{DepGraph, DepNode, DepTrackingMap, DepTrackingMapConfig};\n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use middle::const_val::ConstVal;\n+use middle::privacy::AccessLevels;\n use mir;\n use ty::{self, Ty, TyCtxt};\n \n@@ -189,6 +190,12 @@ impl<'tcx> QueryDescription for queries::mir_shims<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::privacy_access_levels<'tcx> {\n+    fn describe(_: TyCtxt, _: CrateNum) -> String {\n+        format!(\"privacy access levels\")\n+    }\n+}\n+\n macro_rules! define_maps {\n     (<$tcx:tt>\n      $($(#[$attr:meta])*\n@@ -406,6 +413,9 @@ define_maps! { <'tcx>\n     /// other items, such as enum variant explicit discriminants.\n     pub monomorphic_const_eval: MonomorphicConstEval(DefId) -> Result<ConstVal<'tcx>, ()>,\n \n+    /// Performs the privacy check and computes \"access levels\".\n+    pub privacy_access_levels: PrivacyAccessLevels(CrateNum) -> Rc<AccessLevels>,\n+\n     pub mir_shims: mir_shim(ty::InstanceDef<'tcx>) -> &'tcx RefCell<mir::Mir<'tcx>>\n }\n "}, {"sha": "4283b10ec624fb01bf47458b9a53fb0e8f905c6d", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=7846dbe0c8de17f59cdfc3d2b914d58faad7eade", "patch": "@@ -17,11 +17,11 @@ pub use self::fold::TypeFoldable;\n \n use dep_graph::{self, DepNode};\n use hir::{map as hir_map, FreevarMap, TraitMap};\n-use middle;\n use hir::def::{Def, CtorKind, ExportMap};\n use hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n use middle::const_val::ConstVal;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n+use middle::privacy::AccessLevels;\n use middle::region::{CodeExtent, ROOT_CODE_EXTENT};\n use middle::resolve_lifetime::ObjectLifetimeDefault;\n use mir::Mir;\n@@ -108,10 +108,12 @@ mod sty;\n \n /// The complete set of all analyses described in this module. This is\n /// produced by the driver and fed to trans and later passes.\n+///\n+/// NB: These contents are being migrated into queries using the\n+/// *on-demand* infrastructure.\n #[derive(Clone)]\n pub struct CrateAnalysis {\n-    pub export_map: ExportMap,\n-    pub access_levels: middle::privacy::AccessLevels,\n+    pub access_levels: Rc<AccessLevels>,\n     pub reachable: NodeSet,\n     pub name: String,\n     pub glob_map: Option<hir::GlobMap>,\n@@ -122,6 +124,7 @@ pub struct Resolutions {\n     pub freevars: FreevarMap,\n     pub trait_map: TraitMap,\n     pub maybe_unused_trait_imports: NodeSet,\n+    pub export_map: ExportMap,\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Debug)]"}, {"sha": "53adc9d95972a00a72e23d531f8d43902d02b3da", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=7846dbe0c8de17f59cdfc3d2b914d58faad7eade", "patch": "@@ -48,6 +48,7 @@ use std::fs;\n use std::io::{self, Write};\n use std::iter;\n use std::path::{Path, PathBuf};\n+use std::rc::Rc;\n use syntax::{ast, diagnostics, visit};\n use syntax::attr;\n use syntax::ext::base::ExtCtxt;\n@@ -807,18 +808,18 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n         expanded_crate: krate,\n         defs: resolver.definitions,\n         analysis: ty::CrateAnalysis {\n-            export_map: resolver.export_map,\n-            access_levels: AccessLevels::default(),\n+            access_levels: Rc::new(AccessLevels::default()),\n             reachable: NodeSet(),\n             name: crate_name.to_string(),\n             glob_map: if resolver.make_glob_map { Some(resolver.glob_map) } else { None },\n         },\n         resolutions: Resolutions {\n             freevars: resolver.freevars,\n+            export_map: resolver.export_map,\n             trait_map: resolver.trait_map,\n             maybe_unused_trait_imports: resolver.maybe_unused_trait_imports,\n         },\n-        hir_forest: hir_forest\n+        hir_forest: hir_forest,\n     })\n }\n \n@@ -888,6 +889,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     let mut local_providers = ty::maps::Providers::default();\n     mir::provide(&mut local_providers);\n+    rustc_privacy::provide(&mut local_providers);\n     typeck::provide(&mut local_providers);\n     ty::provide(&mut local_providers);\n \n@@ -931,9 +933,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n              || consts::check_crate(tcx));\n \n         analysis.access_levels =\n-            time(time_passes, \"privacy checking\", || {\n-                rustc_privacy::check_crate(tcx, &analysis.export_map)\n-            });\n+            time(time_passes, \"privacy checking\", || rustc_privacy::check_crate(tcx));\n \n         time(time_passes,\n              \"intrinsic checking\",\n@@ -1000,19 +1000,15 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n         analysis.reachable =\n             time(time_passes,\n                  \"reachability checking\",\n-                 || reachable::find_reachable(tcx, &analysis.access_levels));\n+                 || reachable::find_reachable(tcx));\n \n-        time(time_passes, \"death checking\", || {\n-            middle::dead::check_crate(tcx, &analysis.access_levels);\n-        });\n+        time(time_passes, \"death checking\", || middle::dead::check_crate(tcx));\n \n         time(time_passes, \"unused lib feature checking\", || {\n-            stability::check_unused_or_stable_features(tcx, &analysis.access_levels)\n+            stability::check_unused_or_stable_features(tcx)\n         });\n \n-        time(time_passes,\n-             \"lint checking\",\n-             || lint::check_crate(tcx, &analysis.access_levels));\n+        time(time_passes, \"lint checking\", || lint::check_crate(tcx));\n \n         // The above three passes generate errors w/o aborting\n         if sess.err_count() > 0 {"}, {"sha": "17484138ad3a0d26a847df11d15e809742bba62e", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=7846dbe0c8de17f59cdfc3d2b914d58faad7eade", "patch": "@@ -496,12 +496,12 @@ impl CrateStore for cstore::CStore {\n         self.do_extern_mod_stmt_cnum(emod_id)\n     }\n \n-    fn encode_metadata<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 reexports: &def::ExportMap,\n+    fn encode_metadata<'a, 'tcx>(&self,\n+                                 tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  link_meta: &LinkMeta,\n                                  reachable: &NodeSet) -> Vec<u8>\n     {\n-        encoder::encode_metadata(tcx, self, reexports, link_meta, reachable)\n+        encoder::encode_metadata(tcx, self, link_meta, reachable)\n     }\n \n     fn metadata_encoding_version(&self) -> &[u8]"}, {"sha": "a324c166e738d4cea6a2d53aafabeb0bd34f318d", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=7846dbe0c8de17f59cdfc3d2b914d58faad7eade", "patch": "@@ -13,7 +13,6 @@ use index::Index;\n use schema::*;\n \n use rustc::middle::cstore::{LinkMeta, LinkagePreference, NativeLibrary};\n-use rustc::hir::def;\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefIndex, DefId};\n use rustc::hir::map::definitions::DefPathTable;\n use rustc::middle::dependency_format::Linkage;\n@@ -48,7 +47,6 @@ use super::index_builder::{FromId, IndexBuilder, Untracked};\n pub struct EncodeContext<'a, 'tcx: 'a> {\n     opaque: opaque::Encoder<'a>,\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    reexports: &'a def::ExportMap,\n     link_meta: &'a LinkMeta,\n     cstore: &'a cstore::CStore,\n     exported_symbols: &'a NodeSet,\n@@ -306,7 +304,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let def_id = tcx.hir.local_def_id(id);\n \n         let data = ModData {\n-            reexports: match self.reexports.get(&id) {\n+            reexports: match tcx.export_map.get(&id) {\n                 Some(exports) if *vis == hir::Public => self.lazy_seq_ref(exports),\n                 _ => LazySeq::empty(),\n             },\n@@ -1423,7 +1421,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  cstore: &cstore::CStore,\n-                                 reexports: &def::ExportMap,\n                                  link_meta: &LinkMeta,\n                                  exported_symbols: &NodeSet)\n                                  -> Vec<u8> {\n@@ -1437,7 +1434,6 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let mut ecx = EncodeContext {\n             opaque: opaque::Encoder::new(&mut cursor),\n             tcx: tcx,\n-            reexports: reexports,\n             link_meta: link_meta,\n             cstore: cstore,\n             exported_symbols: exported_symbols,"}, {"sha": "64821f5d44bf495d4126bc25516121db4720d933", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=7846dbe0c8de17f59cdfc3d2b914d58faad7eade", "patch": "@@ -17,6 +17,7 @@\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![deny(warnings)]\n \n+#![cfg_attr(stage0, feature(field_init_shorthand))]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n@@ -25,23 +26,24 @@ extern crate rustc;\n #[macro_use] extern crate syntax;\n extern crate syntax_pos;\n \n-use rustc::dep_graph::DepNode;\n use rustc::hir::{self, PatKind};\n-use rustc::hir::def::{self, Def};\n-use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n+use rustc::hir::def::Def;\n+use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, CrateNum, DefId};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::DeepVisitor;\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::lint;\n use rustc::middle::privacy::{AccessLevel, AccessLevels};\n use rustc::ty::{self, TyCtxt, Ty, TypeFoldable};\n use rustc::ty::fold::TypeVisitor;\n+use rustc::ty::maps::Providers;\n use rustc::util::nodemap::NodeSet;\n use syntax::ast;\n-use syntax_pos::Span;\n+use syntax_pos::{DUMMY_SP, Span};\n \n use std::cmp;\n use std::mem::replace;\n+use std::rc::Rc;\n \n pub mod diagnostics;\n \n@@ -71,7 +73,6 @@ impl<'a, 'tcx> Visitor<'tcx> for PubRestrictedVisitor<'a, 'tcx> {\n \n struct EmbargoVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    export_map: &'a def::ExportMap,\n \n     // Accessibility levels for reachable nodes\n     access_levels: AccessLevels,\n@@ -324,7 +325,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n         // This code is here instead of in visit_item so that the\n         // crate module gets processed as well.\n         if self.prev_level.is_some() {\n-            if let Some(exports) = self.export_map.get(&id) {\n+            if let Some(exports) = self.tcx.export_map.get(&id) {\n                 for export in exports {\n                     if let Some(node_id) = self.tcx.hir.as_local_node_id(export.def.def_id()) {\n                         self.update(node_id, Some(AccessLevel::Exported));\n@@ -1204,10 +1205,23 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n     fn visit_pat(&mut self, _: &'tcx hir::Pat) {}\n }\n \n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             export_map: &def::ExportMap)\n-                             -> AccessLevels {\n-    let _task = tcx.dep_graph.in_task(DepNode::Privacy);\n+pub fn provide(providers: &mut Providers) {\n+    *providers = Providers {\n+        privacy_access_levels,\n+        ..*providers\n+    };\n+}\n+\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Rc<AccessLevels> {\n+    tcx.dep_graph.with_ignore(|| { // FIXME\n+        ty::queries::privacy_access_levels::get(tcx, DUMMY_SP, LOCAL_CRATE)\n+    })\n+}\n+\n+fn privacy_access_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                   krate: CrateNum)\n+                                   -> Rc<AccessLevels> {\n+    assert_eq!(krate, LOCAL_CRATE);\n \n     let krate = tcx.hir.krate();\n \n@@ -1226,7 +1240,6 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // items which are reachable from external crates based on visibility.\n     let mut visitor = EmbargoVisitor {\n         tcx: tcx,\n-        export_map: export_map,\n         access_levels: Default::default(),\n         prev_level: Some(AccessLevel::Public),\n         changed: false,\n@@ -1270,7 +1283,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         krate.visit_all_item_likes(&mut DeepVisitor::new(&mut visitor));\n     }\n \n-    visitor.access_levels\n+    Rc::new(visitor.access_levels)\n }\n \n __build_diagnostic_array! { librustc_privacy, DIAGNOSTICS }"}, {"sha": "f7ca468fddaef037cedac253beac73e9d8841145", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=7846dbe0c8de17f59cdfc3d2b914d58faad7eade", "patch": "@@ -755,7 +755,6 @@ fn write_metadata(cx: &SharedCrateContext,\n \n     let cstore = &cx.tcx().sess.cstore;\n     let metadata = cstore.encode_metadata(cx.tcx(),\n-                                          cx.export_map(),\n                                           cx.link_meta(),\n                                           exported_symbols);\n     if kind == MetadataKind::Uncompressed {\n@@ -1056,15 +1055,14 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // particular items that will be processed.\n     let krate = tcx.hir.krate();\n \n-    let ty::CrateAnalysis { export_map, reachable, name, .. } = analysis;\n+    let ty::CrateAnalysis { reachable, name, .. } = analysis;\n     let exported_symbols = find_exported_symbols(tcx, reachable);\n \n     let check_overflow = tcx.sess.overflow_checks();\n \n     let link_meta = link::build_link_meta(incremental_hashes_map, &name);\n \n     let shared_ccx = SharedCrateContext::new(tcx,\n-                                             export_map,\n                                              link_meta.clone(),\n                                              exported_symbols,\n                                              check_overflow);"}, {"sha": "73602dc420b3f9999be6534e41e5df674004cc91", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=7846dbe0c8de17f59cdfc3d2b914d58faad7eade", "patch": "@@ -14,7 +14,6 @@ use rustc::dep_graph::{DepGraph, DepGraphSafe, DepNode, DepTrackingMap,\n                        DepTrackingMapConfig, WorkProduct};\n use middle::cstore::LinkMeta;\n use rustc::hir;\n-use rustc::hir::def::ExportMap;\n use rustc::hir::def_id::DefId;\n use rustc::traits;\n use debuginfo;\n@@ -68,7 +67,6 @@ pub struct SharedCrateContext<'a, 'tcx: 'a> {\n     metadata_llmod: ModuleRef,\n     metadata_llcx: ContextRef,\n \n-    export_map: ExportMap,\n     exported_symbols: NodeSet,\n     link_meta: LinkMeta,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -402,7 +400,6 @@ unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextR\n \n impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n     pub fn new(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n-               export_map: ExportMap,\n                link_meta: LinkMeta,\n                exported_symbols: NodeSet,\n                check_overflow: bool)\n@@ -459,7 +456,6 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         SharedCrateContext {\n             metadata_llmod: metadata_llmod,\n             metadata_llcx: metadata_llcx,\n-            export_map: export_map,\n             exported_symbols: exported_symbols,\n             link_meta: link_meta,\n             empty_param_env: tcx.empty_parameter_environment(),\n@@ -499,10 +495,6 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         self.metadata_llcx\n     }\n \n-    pub fn export_map<'a>(&'a self) -> &'a ExportMap {\n-        &self.export_map\n-    }\n-\n     pub fn exported_symbols<'a>(&'a self) -> &'a NodeSet {\n         &self.exported_symbols\n     }\n@@ -702,10 +694,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         unsafe { llvm::LLVMRustGetModuleDataLayout(self.llmod()) }\n     }\n \n-    pub fn export_map<'a>(&'a self) -> &'a ExportMap {\n-        &self.shared.export_map\n-    }\n-\n     pub fn exported_symbols<'a>(&'a self) -> &'a NodeSet {\n         &self.shared.exported_symbols\n     }"}, {"sha": "a47d5f9937a02c337745038043e5d09735b9c2b2", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=7846dbe0c8de17f59cdfc3d2b914d58faad7eade", "patch": "@@ -13,7 +13,7 @@ use rustc_driver::{driver, target_features, abort_on_err};\n use rustc::dep_graph::DepGraph;\n use rustc::session::{self, config};\n use rustc::hir::def_id::DefId;\n-use rustc::hir::def::{Def, ExportMap};\n+use rustc::hir::def::Def;\n use rustc::middle::privacy::AccessLevels;\n use rustc::ty::{self, TyCtxt, GlobalArenas};\n use rustc::hir::map as hir_map;\n@@ -64,7 +64,6 @@ pub struct DocContext<'a, 'tcx: 'a> {\n     pub ty_substs: RefCell<FxHashMap<Def, clean::Type>>,\n     /// Table node id of lifetime parameter definition -> substituted lifetime\n     pub lt_substs: RefCell<FxHashMap<ast::NodeId, clean::Lifetime>>,\n-    pub export_map: ExportMap,\n }\n \n impl<'a, 'tcx> DocContext<'a, 'tcx> {\n@@ -180,13 +179,13 @@ pub fn run_core(search_paths: SearchPaths,\n             sess.fatal(\"Compilation failed, aborting rustdoc\");\n         }\n \n-        let ty::CrateAnalysis { access_levels, export_map, .. } = analysis;\n+        let ty::CrateAnalysis { access_levels, .. } = analysis;\n \n         // Convert from a NodeId set to a DefId set since we don't always have easy access\n         // to the map from defid -> nodeid\n         let access_levels = AccessLevels {\n-            map: access_levels.map.into_iter()\n-                                  .map(|(k, v)| (tcx.hir.local_def_id(k), v))\n+            map: access_levels.map.iter()\n+                                  .map(|(&k, &v)| (tcx.hir.local_def_id(k), v))\n                                   .collect()\n         };\n \n@@ -198,7 +197,6 @@ pub fn run_core(search_paths: SearchPaths,\n             renderinfo: Default::default(),\n             ty_substs: Default::default(),\n             lt_substs: Default::default(),\n-            export_map: export_map,\n         };\n         debug!(\"crate: {:?}\", tcx.hir.krate());\n "}, {"sha": "2793307697852b8aa1b36a0e971e2bc115f549e4", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=7846dbe0c8de17f59cdfc3d2b914d58faad7eade", "patch": "@@ -198,7 +198,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             self.visit_item(item, None, &mut om);\n         }\n         self.inside_public_path = orig_inside_public_path;\n-        if let Some(exports) = self.cx.export_map.get(&id) {\n+        if let Some(exports) = self.cx.tcx.export_map.get(&id) {\n             for export in exports {\n                 if let Def::Macro(def_id, ..) = export.def {\n                     if def_id.krate == LOCAL_CRATE {"}, {"sha": "5b628d51d1513986eb31cbc17d2ff19756553849", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 84, "deletions": 53, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=7846dbe0c8de17f59cdfc3d2b914d58faad7eade", "patch": "@@ -1290,28 +1290,42 @@ pub trait BufRead: Read {\n     /// If an I/O error is encountered then all bytes read so far will be\n     /// present in `buf` and its length will have been adjusted appropriately.\n     ///\n-    /// # Examples\n-    ///\n-    /// A locked standard input implements `BufRead`. In this example, we'll\n-    /// read from standard input until we see an `a` byte.\n-    ///\n     /// [`fill_buf`]: #tymethod.fill_buf\n     /// [`ErrorKind::Interrupted`]: enum.ErrorKind.html#variant.Interrupted\n     ///\n-    /// ```\n-    /// use std::io;\n-    /// use std::io::prelude::*;\n+    /// # Examples\n     ///\n-    /// fn foo() -> io::Result<()> {\n-    /// let stdin = io::stdin();\n-    /// let mut stdin = stdin.lock();\n-    /// let mut buffer = Vec::new();\n+    /// [`std::io::Cursor`][`Cursor`] is a type that implements `BufRead`. In\n+    /// this example, we use [`Cursor`] to read all the bytes in a byte slice\n+    /// in hyphen delimited segments:\n     ///\n-    /// stdin.read_until(b'a', &mut buffer)?;\n+    /// [`Cursor`]: struct.Cursor.html\n     ///\n-    /// println!(\"{:?}\", buffer);\n-    /// # Ok(())\n-    /// # }\n+    /// ```\n+    /// use std::io::{self, BufRead};\n+    ///\n+    /// let mut cursor = io::Cursor::new(b\"lorem-ipsum\");\n+    /// let mut buf = vec![];\n+    ///\n+    /// // cursor is at 'l'\n+    /// let num_bytes = cursor.read_until(b'-', &mut buf)\n+    ///     .expect(\"reading from cursor won't fail\");\n+    /// assert_eq!(num_bytes, 6);\n+    /// assert_eq!(buf, b\"lorem-\");\n+    /// buf.clear();\n+    ///\n+    /// // cursor is at 'i'\n+    /// let num_bytes = cursor.read_until(b'-', &mut buf)\n+    ///     .expect(\"reading from cursor won't fail\");\n+    /// assert_eq!(num_bytes, 5);\n+    /// assert_eq!(buf, b\"ipsum\");\n+    /// buf.clear();\n+    ///\n+    /// // cursor is at EOF\n+    /// let num_bytes = cursor.read_until(b'-', &mut buf)\n+    ///     .expect(\"reading from cursor won't fail\");\n+    /// assert_eq!(num_bytes, 0);\n+    /// assert_eq!(buf, b\"\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> Result<usize> {\n@@ -1337,28 +1351,36 @@ pub trait BufRead: Read {\n     ///\n     /// # Examples\n     ///\n-    /// A locked standard input implements `BufRead`. In this example, we'll\n-    /// read all of the lines from standard input. If we were to do this in\n-    /// an actual project, the [`lines`] method would be easier, of\n-    /// course.\n+    /// [`std::io::Cursor`][`Cursor`] is a type that implements `BufRead`. In\n+    /// this example, we use [`Cursor`] to read all the lines in a byte slice:\n     ///\n-    /// [`lines`]: #method.lines\n-    /// [`read_until`]: #method.read_until\n+    /// [`Cursor`]: struct.Cursor.html\n     ///\n     /// ```\n-    /// use std::io;\n-    /// use std::io::prelude::*;\n-    ///\n-    /// let stdin = io::stdin();\n-    /// let mut stdin = stdin.lock();\n-    /// let mut buffer = String::new();\n-    ///\n-    /// while stdin.read_line(&mut buffer).unwrap() > 0 {\n-    ///     // work with buffer\n-    ///     println!(\"{:?}\", buffer);\n-    ///\n-    ///     buffer.clear();\n-    /// }\n+    /// use std::io::{self, BufRead};\n+    ///\n+    /// let mut cursor = io::Cursor::new(b\"foo\\nbar\");\n+    /// let mut buf = String::new();\n+    ///\n+    /// // cursor is at 'f'\n+    /// let num_bytes = cursor.read_line(&mut buf)\n+    ///     .expect(\"reading from cursor won't fail\");\n+    /// assert_eq!(num_bytes, 4);\n+    /// assert_eq!(buf, \"foo\\n\");\n+    /// buf.clear();\n+    ///\n+    /// // cursor is at 'b'\n+    /// let num_bytes = cursor.read_line(&mut buf)\n+    ///     .expect(\"reading from cursor won't fail\");\n+    /// assert_eq!(num_bytes, 3);\n+    /// assert_eq!(buf, \"bar\");\n+    /// buf.clear();\n+    ///\n+    /// // cursor is at EOF\n+    /// let num_bytes = cursor.read_line(&mut buf)\n+    ///     .expect(\"reading from cursor won't fail\");\n+    /// assert_eq!(num_bytes, 0);\n+    /// assert_eq!(buf, \"\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn read_line(&mut self, buf: &mut String) -> Result<usize> {\n@@ -1378,24 +1400,28 @@ pub trait BufRead: Read {\n     /// This function will yield errors whenever [`read_until`] would have\n     /// also yielded an error.\n     ///\n-    /// # Examples\n-    ///\n-    /// A locked standard input implements `BufRead`. In this example, we'll\n-    /// read some input from standard input, splitting on commas.\n-    ///\n     /// [`io::Result`]: type.Result.html\n     /// [`Vec<u8>`]: ../vec/struct.Vec.html\n     /// [`read_until`]: #method.read_until\n     ///\n+    /// # Examples\n+    ///\n+    /// [`std::io::Cursor`][`Cursor`] is a type that implements `BufRead`. In\n+    /// this example, we use [`Cursor`] to iterate over all hyphen delimited\n+    /// segments in a byte slice\n+    ///\n+    /// [`Cursor`]: struct.Cursor.html\n+    ///\n     /// ```\n-    /// use std::io;\n-    /// use std::io::prelude::*;\n+    /// use std::io::{self, BufRead};\n     ///\n-    /// let stdin = io::stdin();\n+    /// let cursor = io::Cursor::new(b\"lorem-ipsum-dolor\");\n     ///\n-    /// for content in stdin.lock().split(b',') {\n-    ///     println!(\"{:?}\", content.unwrap());\n-    /// }\n+    /// let mut split_iter = cursor.split(b'-').map(|l| l.unwrap());\n+    /// assert_eq!(split_iter.next(), Some(b\"lorem\".to_vec()));\n+    /// assert_eq!(split_iter.next(), Some(b\"ipsum\".to_vec()));\n+    /// assert_eq!(split_iter.next(), Some(b\"dolor\".to_vec()));\n+    /// assert_eq!(split_iter.next(), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn split(self, byte: u8) -> Split<Self> where Self: Sized {\n@@ -1413,17 +1439,22 @@ pub trait BufRead: Read {\n     ///\n     /// # Examples\n     ///\n-    /// A locked standard input implements `BufRead`:\n+    /// [`std::io::Cursor`][`Cursor`] is a type that implements `BufRead`. In\n+    /// this example, we use [`Cursor`] to iterate over all the lines in a byte\n+    /// slice.\n+    ///\n+    /// [`Cursor`]: struct.Cursor.html\n     ///\n     /// ```\n-    /// use std::io;\n-    /// use std::io::prelude::*;\n+    /// use std::io::{self, BufRead};\n     ///\n-    /// let stdin = io::stdin();\n+    /// let cursor = io::Cursor::new(b\"lorem\\nipsum\\r\\ndolor\");\n     ///\n-    /// for line in stdin.lock().lines() {\n-    ///     println!(\"{}\", line.unwrap());\n-    /// }\n+    /// let mut lines_iter = cursor.lines().map(|l| l.unwrap());\n+    /// assert_eq!(lines_iter.next(), Some(String::from(\"lorem\")));\n+    /// assert_eq!(lines_iter.next(), Some(String::from(\"ipsum\")));\n+    /// assert_eq!(lines_iter.next(), Some(String::from(\"dolor\")));\n+    /// assert_eq!(lines_iter.next(), None);\n     /// ```\n     ///\n     /// # Errors"}, {"sha": "38534ab0a36876ec56346e519985365ea7213437", "filename": "src/test/compile-fail/static-lifetime-bound.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Ftest%2Fcompile-fail%2Fstatic-lifetime-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7846dbe0c8de17f59cdfc3d2b914d58faad7eade/src%2Ftest%2Fcompile-fail%2Fstatic-lifetime-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-lifetime-bound.rs?ref=7846dbe0c8de17f59cdfc3d2b914d58faad7eade", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn f<'a: 'static>(_: &'a i32) {} //~WARN unnecessary lifetime parameter `'a`\n+\n+fn main() {\n+    let x = 0;\n+    f(&x); //~ERROR does not live long enough\n+}"}]}