{"sha": "d3ec4609d64e26f5c5bf0ad118e6074755419a27", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzZWM0NjA5ZDY0ZTI2ZjVjNWJmMGFkMTE4ZTYwNzQ3NTU0MTlhMjc=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2019-04-29T02:04:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-04-29T02:04:28Z"}, "message": "Merge pull request #3484 from topecongiro/config_derive\n\nAdd config_proc_macro", "tree": {"sha": "9d0814c5c91af919a064f68b89b616f6337c3531", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d0814c5c91af919a064f68b89b616f6337c3531"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3ec4609d64e26f5c5bf0ad118e6074755419a27", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcxlutCRBK7hj4Ov3rIwAAdHIIAH9mCgneFKbIesBTzmNCDz5W\nStZgGNJu2et/F5acNf/yK94A+PrBV2jUtGUy9HbM/iwnbyVEdgRmmsGCMtsQ8Utq\nm4Wq8MvSSHkZI2A4AUqNoVwv4ue9r/NU03RZF1Uzmx9wKudArQZ/KkD5JO4V4xS8\nrYidXYDJNikzhwqvzunuy6gNUnAWoGMnr5a0+h1HJNN3cVaOtsTggUD04sGuVS+G\nKT1EtMTMetf53Ec3HggkZgaRW6r+kmum/VThHTS6vlPxdA1zO3xFZhYTV1FZ/q/t\nskoL4V6zjRzmLIvmlbI81RK29c90g3G7j1lAsiEf7pAFm/lrL5NNnn6WfnaZls4=\n=gAC2\n-----END PGP SIGNATURE-----\n", "payload": "tree 9d0814c5c91af919a064f68b89b616f6337c3531\nparent aa53d2dc423b6affbdf9a553c489c3c4be4934da\nparent 3dec18a681c7ff4eef2d4eb5e62c0278b6110e22\nauthor Seiichi Uchida <seuchida@gmail.com> 1556503468 +0900\ncommitter GitHub <noreply@github.com> 1556503468 +0900\n\nMerge pull request #3484 from topecongiro/config_derive\n\nAdd config_proc_macro"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3ec4609d64e26f5c5bf0ad118e6074755419a27", "html_url": "https://github.com/rust-lang/rust/commit/d3ec4609d64e26f5c5bf0ad118e6074755419a27", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3ec4609d64e26f5c5bf0ad118e6074755419a27/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa53d2dc423b6affbdf9a553c489c3c4be4934da", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa53d2dc423b6affbdf9a553c489c3c4be4934da", "html_url": "https://github.com/rust-lang/rust/commit/aa53d2dc423b6affbdf9a553c489c3c4be4934da"}, {"sha": "3dec18a681c7ff4eef2d4eb5e62c0278b6110e22", "url": "https://api.github.com/repos/rust-lang/rust/commits/3dec18a681c7ff4eef2d4eb5e62c0278b6110e22", "html_url": "https://github.com/rust-lang/rust/commit/3dec18a681c7ff4eef2d4eb5e62c0278b6110e22"}], "stats": {"total": 735, "additions": 548, "deletions": 187}, "files": [{"sha": "dd148264be3589f1edb6c12f8a159ac54902cc7b", "filename": "Cargo.lock", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d3ec4609d64e26f5c5bf0ad118e6074755419a27/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/d3ec4609d64e26f5c5bf0ad118e6074755419a27/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=d3ec4609d64e26f5c5bf0ad118e6074755419a27", "patch": "@@ -143,6 +143,15 @@ dependencies = [\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"config_proc_macro\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"proc-macro2 0.4.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quote 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.15.32 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"constant_time_eq\"\n version = \"0.1.3\"\n@@ -772,6 +781,7 @@ dependencies = [\n  \"atty 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"bytecount 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cargo_metadata 0.7.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"config_proc_macro 0.1.0\",\n  \"derive-new 0.5.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"diff 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"dirs 1.0.5 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "ba888db72abcf2f282272fd9e4f71eb46c0cafa1", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3ec4609d64e26f5c5bf0ad118e6074755419a27/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d3ec4609d64e26f5c5bf0ad118e6074755419a27/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=d3ec4609d64e26f5c5bf0ad118e6074755419a27", "patch": "@@ -60,6 +60,8 @@ dirs = \"1.0.4\"\n ignore = \"0.4.6\"\n annotate-snippets = { version = \"0.5.0\", features = [\"ansi_term\"] }\n \n+config_proc_macro = { path = \"config_proc_macro\" }\n+\n # A noop dependency that changes in the Rust repository, it's a bit of a hack.\n # See the `src/tools/rustc-workspace-hack/README.md` file in `rust-lang/rust`\n # for more information."}, {"sha": "9f970225adb6a6ada5c22d46d02684b6b0f5525e", "filename": "config_proc_macro/.gitignore", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d3ec4609d64e26f5c5bf0ad118e6074755419a27/config_proc_macro%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/d3ec4609d64e26f5c5bf0ad118e6074755419a27/config_proc_macro%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config_proc_macro%2F.gitignore?ref=d3ec4609d64e26f5c5bf0ad118e6074755419a27", "patch": "@@ -0,0 +1 @@\n+target/\n\\ No newline at end of file"}, {"sha": "6ee8e34b13fc58880eeed1bd67e8ad5e7a1106f8", "filename": "config_proc_macro/Cargo.lock", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d3ec4609d64e26f5c5bf0ad118e6074755419a27/config_proc_macro%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/d3ec4609d64e26f5c5bf0ad118e6074755419a27/config_proc_macro%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config_proc_macro%2FCargo.lock?ref=d3ec4609d64e26f5c5bf0ad118e6074755419a27", "patch": "@@ -0,0 +1,68 @@\n+# This file is automatically @generated by Cargo.\n+# It is not intended for manual editing.\n+[[package]]\n+name = \"config_proc_macro\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"proc-macro2 0.4.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quote 0.6.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.89 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.15.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"proc-macro2\"\n+version = \"0.4.27\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"unicode-xid 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"quote\"\n+version = \"0.6.11\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"proc-macro2 0.4.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"serde\"\n+version = \"1.0.89\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"serde_derive 1.0.89 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"serde_derive\"\n+version = \"1.0.89\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"proc-macro2 0.4.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quote 0.6.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.15.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"syn\"\n+version = \"0.15.29\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"proc-macro2 0.4.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quote 0.6.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unicode-xid 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"unicode-xid\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[metadata]\n+\"checksum proc-macro2 0.4.27 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4d317f9caece796be1980837fd5cb3dfec5613ebdb04ad0956deea83ce168915\"\n+\"checksum quote 0.6.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cdd8e04bd9c52e0342b406469d494fcb033be4bdbe5c606016defbb1681411e1\"\n+\"checksum serde 1.0.89 (registry+https://github.com/rust-lang/crates.io-index)\" = \"92514fb95f900c9b5126e32d020f5c6d40564c27a5ea6d1d7d9f157a96623560\"\n+\"checksum serde_derive 1.0.89 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bb6eabf4b5914e88e24eea240bb7c9f9a2cbc1bbbe8d961d381975ec3c6b806c\"\n+\"checksum syn 0.15.29 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1825685f977249735d510a242a6727b46efe914bb67e38d30c071b1b72b1d5c2\"\n+\"checksum unicode-xid 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fc72304796d0818e357ead4e000d19c9c174ab23dc11093ac919054d20a6a7fc\""}, {"sha": "45f80bf09563514493d1f4dface8b2f315e787c5", "filename": "config_proc_macro/Cargo.toml", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d3ec4609d64e26f5c5bf0ad118e6074755419a27/config_proc_macro%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d3ec4609d64e26f5c5bf0ad118e6074755419a27/config_proc_macro%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config_proc_macro%2FCargo.toml?ref=d3ec4609d64e26f5c5bf0ad118e6074755419a27", "patch": "@@ -0,0 +1,20 @@\n+[package]\n+name = \"config_proc_macro\"\n+version = \"0.1.0\"\n+authors = [\"topecongiro <seuchida@gmail.com>\"]\n+edition = \"2018\"\n+\n+[lib]\n+proc-macro = true\n+\n+[dependencies]\n+proc-macro2 = \"0.4\"\n+quote = \"0.6\"\n+syn = { version = \"0.15\", features = [\"full\", \"visit\"] }\n+\n+[dev-dependencies]\n+serde = { version = \"1.0\", features = [\"derive\"] }\n+\n+[features]\n+default = []\n+debug-with-rustfmt = []"}, {"sha": "0df68772ae633921443912ac92551e4593bd4dd5", "filename": "config_proc_macro/src/attrs.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/d3ec4609d64e26f5c5bf0ad118e6074755419a27/config_proc_macro%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ec4609d64e26f5c5bf0ad118e6074755419a27/config_proc_macro%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config_proc_macro%2Fsrc%2Fattrs.rs?ref=d3ec4609d64e26f5c5bf0ad118e6074755419a27", "patch": "@@ -0,0 +1,57 @@\n+//! This module provides utilities for handling attributes on variants\n+//! of `config_type` enum. Currently there are two types of attributes\n+//! that could appear on the variants of `config_type` enum: `doc_hint`\n+//! and `value`. Both comes in the form of name-value pair whose value\n+//! is string literal.\n+\n+/// Returns the value of the first `doc_hint` attribute in the given slice or\n+/// `None` if `doc_hint` attribute is not available.\n+pub fn find_doc_hint(attrs: &[syn::Attribute]) -> Option<String> {\n+    attrs.iter().filter_map(doc_hint).next()\n+}\n+\n+/// Returns `true` if the given attribute is a `doc_hint` attribute.\n+pub fn is_doc_hint(attr: &syn::Attribute) -> bool {\n+    is_attr_name_value(attr, \"doc_hint\")\n+}\n+\n+/// Returns a string literal value if the given attribute is `doc_hint`\n+/// attribute or `None` otherwise.\n+pub fn doc_hint(attr: &syn::Attribute) -> Option<String> {\n+    get_name_value_str_lit(attr, \"doc_hint\")\n+}\n+\n+/// Returns the value of the first `value` attribute in the given slice or\n+/// `None` if `value` attribute is not available.\n+pub fn find_config_value(attrs: &[syn::Attribute]) -> Option<String> {\n+    attrs.iter().filter_map(config_value).next()\n+}\n+\n+/// Returns a string literal value if the given attribute is `value`\n+/// attribute or `None` otherwise.\n+pub fn config_value(attr: &syn::Attribute) -> Option<String> {\n+    get_name_value_str_lit(attr, \"value\")\n+}\n+\n+/// Returns `true` if the given attribute is a `value` attribute.\n+pub fn is_config_value(attr: &syn::Attribute) -> bool {\n+    is_attr_name_value(attr, \"value\")\n+}\n+\n+fn is_attr_name_value(attr: &syn::Attribute, name: &str) -> bool {\n+    attr.interpret_meta().map_or(false, |meta| match meta {\n+        syn::Meta::NameValue(syn::MetaNameValue { ref ident, .. }) if ident == name => true,\n+        _ => false,\n+    })\n+}\n+\n+fn get_name_value_str_lit(attr: &syn::Attribute, name: &str) -> Option<String> {\n+    attr.interpret_meta().and_then(|meta| match meta {\n+        syn::Meta::NameValue(syn::MetaNameValue {\n+            ref ident,\n+            lit: syn::Lit::Str(ref lit_str),\n+            ..\n+        }) if ident == name => Some(lit_str.value()),\n+        _ => None,\n+    })\n+}"}, {"sha": "93a78b8463ec58d9f098f5d77105ae8683c3dc9f", "filename": "config_proc_macro/src/config_type.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d3ec4609d64e26f5c5bf0ad118e6074755419a27/config_proc_macro%2Fsrc%2Fconfig_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ec4609d64e26f5c5bf0ad118e6074755419a27/config_proc_macro%2Fsrc%2Fconfig_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config_proc_macro%2Fsrc%2Fconfig_type.rs?ref=d3ec4609d64e26f5c5bf0ad118e6074755419a27", "patch": "@@ -0,0 +1,15 @@\n+use proc_macro2::TokenStream;\n+\n+use crate::item_enum::define_config_type_on_enum;\n+use crate::item_struct::define_config_type_on_struct;\n+\n+/// Defines `config_type` on enum or struct.\n+// FIXME: Implement this on struct.\n+pub fn define_config_type(input: &syn::Item) -> TokenStream {\n+    match input {\n+        syn::Item::Struct(st) => define_config_type_on_struct(st),\n+        syn::Item::Enum(en) => define_config_type_on_enum(en),\n+        _ => panic!(\"Expected enum or struct\"),\n+    }\n+    .unwrap()\n+}"}, {"sha": "eb7254ada7a851f86e995e1d0a7581dd43c0e24f", "filename": "config_proc_macro/src/item_enum.rs", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/d3ec4609d64e26f5c5bf0ad118e6074755419a27/config_proc_macro%2Fsrc%2Fitem_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ec4609d64e26f5c5bf0ad118e6074755419a27/config_proc_macro%2Fsrc%2Fitem_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config_proc_macro%2Fsrc%2Fitem_enum.rs?ref=d3ec4609d64e26f5c5bf0ad118e6074755419a27", "patch": "@@ -0,0 +1,178 @@\n+use proc_macro2::TokenStream;\n+use quote::quote;\n+\n+use crate::attrs::*;\n+use crate::utils::*;\n+\n+type Variants = syn::punctuated::Punctuated<syn::Variant, syn::Token![,]>;\n+\n+/// Defines and implements `config_type` enum.\n+pub fn define_config_type_on_enum(em: &syn::ItemEnum) -> syn::Result<TokenStream> {\n+    let syn::ItemEnum {\n+        vis,\n+        enum_token,\n+        ident,\n+        generics,\n+        variants,\n+        ..\n+    } = em;\n+\n+    let mod_name_str = format!(\"__define_config_type_on_enum_{}\", ident);\n+    let mod_name = syn::Ident::new(&mod_name_str, ident.span());\n+    let variants = fold_quote(variants.iter().map(process_variant), |meta| quote!(#meta,));\n+\n+    let impl_doc_hint = impl_doc_hint(&em.ident, &em.variants);\n+    let impl_from_str = impl_from_str(&em.ident, &em.variants);\n+    let impl_serde = impl_serde(&em.ident, &em.variants);\n+    let impl_deserialize = impl_deserialize(&em.ident, &em.variants);\n+\n+    Ok(quote! {\n+        #[allow(non_snake_case)]\n+        mod #mod_name {\n+            #[derive(Debug, Copy, Clone, Eq, PartialEq)]\n+            pub #enum_token #ident #generics { #variants }\n+            #impl_doc_hint\n+            #impl_from_str\n+            #impl_serde\n+            #impl_deserialize\n+        }\n+        #vis use #mod_name::#ident;\n+    })\n+}\n+\n+/// Remove attributes specific to `config_proc_macro` from enum variant fields.\n+fn process_variant(variant: &syn::Variant) -> TokenStream {\n+    let metas = variant\n+        .attrs\n+        .iter()\n+        .filter(|attr| !is_doc_hint(attr) && !is_config_value(attr));\n+    let attrs = fold_quote(metas, |meta| quote!(#meta));\n+    let syn::Variant { ident, fields, .. } = variant;\n+    quote!(#attrs #ident #fields)\n+}\n+\n+fn impl_doc_hint(ident: &syn::Ident, variants: &Variants) -> TokenStream {\n+    let doc_hint = variants\n+        .iter()\n+        .map(doc_hint_of_variant)\n+        .collect::<Vec<_>>()\n+        .join(\"|\");\n+    let doc_hint = format!(\"[{}]\", doc_hint);\n+    quote! {\n+        use crate::config::ConfigType;\n+        impl ConfigType for #ident {\n+            fn doc_hint() -> String {\n+                #doc_hint.to_owned()\n+            }\n+        }\n+    }\n+}\n+\n+fn impl_from_str(ident: &syn::Ident, variants: &Variants) -> TokenStream {\n+    let vs = variants\n+        .iter()\n+        .filter(|v| is_unit(v))\n+        .map(|v| (config_value_of_variant(v), &v.ident));\n+    let if_patterns = fold_quote(vs, |(s, v)| {\n+        quote! {\n+            if #s.eq_ignore_ascii_case(s) {\n+                return Ok(#ident::#v);\n+            }\n+        }\n+    });\n+    quote! {\n+        impl ::std::str::FromStr for #ident {\n+            type Err = &'static str;\n+\n+            fn from_str(s: &str) -> Result<Self, Self::Err> {\n+                #if_patterns\n+                return Err(\"Bad variant\");\n+            }\n+        }\n+    }\n+}\n+\n+fn doc_hint_of_variant(variant: &syn::Variant) -> String {\n+    find_doc_hint(&variant.attrs).unwrap_or(variant.ident.to_string())\n+}\n+\n+fn config_value_of_variant(variant: &syn::Variant) -> String {\n+    find_config_value(&variant.attrs).unwrap_or(variant.ident.to_string())\n+}\n+\n+fn impl_serde(ident: &syn::Ident, variants: &Variants) -> TokenStream {\n+    let arms = fold_quote(variants.iter(), |v| {\n+        let v_ident = &v.ident;\n+        let pattern = match v.fields {\n+            syn::Fields::Named(..) => quote!(#ident::v_ident{..}),\n+            syn::Fields::Unnamed(..) => quote!(#ident::#v_ident(..)),\n+            syn::Fields::Unit => quote!(#ident::#v_ident),\n+        };\n+        let option_value = config_value_of_variant(v);\n+        quote! {\n+            #pattern => serializer.serialize_str(&#option_value),\n+        }\n+    });\n+\n+    quote! {\n+        impl ::serde::ser::Serialize for #ident {\n+            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+            where\n+                S: ::serde::ser::Serializer,\n+            {\n+                use serde::ser::Error;\n+                match self {\n+                    #arms\n+                    _ => Err(S::Error::custom(format!(\"Cannot serialize {:?}\", self))),\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+// Currently only unit variants are supported.\n+fn impl_deserialize(ident: &syn::Ident, variants: &Variants) -> TokenStream {\n+    let supported_vs = variants.iter().filter(|v| is_unit(v));\n+    let if_patterns = fold_quote(supported_vs, |v| {\n+        let config_value = config_value_of_variant(v);\n+        let variant_ident = &v.ident;\n+        quote! {\n+            if #config_value.eq_ignore_ascii_case(s) {\n+                return Ok(#ident::#variant_ident);\n+            }\n+        }\n+    });\n+\n+    let supported_vs = variants.iter().filter(|v| is_unit(v));\n+    let allowed = fold_quote(supported_vs.map(config_value_of_variant), |s| quote!(#s,));\n+\n+    quote! {\n+        impl<'de> serde::de::Deserialize<'de> for #ident {\n+            fn deserialize<D>(d: D) -> Result<Self, D::Error>\n+            where\n+                D: serde::Deserializer<'de>,\n+            {\n+                use serde::de::{Error, Visitor};\n+                use std::marker::PhantomData;\n+                use std::fmt;\n+                struct StringOnly<T>(PhantomData<T>);\n+                impl<'de, T> Visitor<'de> for StringOnly<T>\n+                where T: serde::Deserializer<'de> {\n+                    type Value = String;\n+                    fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                        formatter.write_str(\"string\")\n+                    }\n+                    fn visit_str<E>(self, value: &str) -> Result<String, E> {\n+                        Ok(String::from(value))\n+                    }\n+                }\n+                let s = &d.deserialize_string(StringOnly::<D>(PhantomData))?;\n+\n+                #if_patterns\n+\n+                static ALLOWED: &'static[&str] = &[#allowed];\n+                Err(D::Error::unknown_variant(&s, ALLOWED))\n+            }\n+        }\n+    }\n+}"}, {"sha": "f03ff7e30d82ef67adec6abe43f995f3bb7de9ee", "filename": "config_proc_macro/src/item_struct.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d3ec4609d64e26f5c5bf0ad118e6074755419a27/config_proc_macro%2Fsrc%2Fitem_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ec4609d64e26f5c5bf0ad118e6074755419a27/config_proc_macro%2Fsrc%2Fitem_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config_proc_macro%2Fsrc%2Fitem_struct.rs?ref=d3ec4609d64e26f5c5bf0ad118e6074755419a27", "patch": "@@ -0,0 +1,5 @@\n+use proc_macro2::TokenStream;\n+\n+pub fn define_config_type_on_struct(_st: &syn::ItemStruct) -> syn::Result<TokenStream> {\n+    unimplemented!()\n+}"}, {"sha": "66cfd3c727dda36692979e8c639610cc5b0a9791", "filename": "config_proc_macro/src/lib.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d3ec4609d64e26f5c5bf0ad118e6074755419a27/config_proc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ec4609d64e26f5c5bf0ad118e6074755419a27/config_proc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config_proc_macro%2Fsrc%2Flib.rs?ref=d3ec4609d64e26f5c5bf0ad118e6074755419a27", "patch": "@@ -0,0 +1,27 @@\n+//! This crate provides a derive macro for `ConfigType`.\n+\n+#![recursion_limit = \"256\"]\n+\n+extern crate proc_macro;\n+\n+mod attrs;\n+mod config_type;\n+mod item_enum;\n+mod item_struct;\n+mod utils;\n+\n+use proc_macro::TokenStream;\n+use syn::parse_macro_input;\n+\n+#[proc_macro_attribute]\n+pub fn config_type(_args: TokenStream, input: TokenStream) -> TokenStream {\n+    let input = parse_macro_input!(input as syn::Item);\n+    let output = config_type::define_config_type(&input);\n+\n+    #[cfg(feature = \"debug-with-rustfmt\")]\n+    {\n+        utils::debug_with_rustfmt(&output);\n+    }\n+\n+    TokenStream::from(output)\n+}"}, {"sha": "fec6a8e4907a6312bf29e7acae67adc3123e0df3", "filename": "config_proc_macro/src/utils.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d3ec4609d64e26f5c5bf0ad118e6074755419a27/config_proc_macro%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ec4609d64e26f5c5bf0ad118e6074755419a27/config_proc_macro%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config_proc_macro%2Fsrc%2Futils.rs?ref=d3ec4609d64e26f5c5bf0ad118e6074755419a27", "patch": "@@ -0,0 +1,45 @@\n+use proc_macro2::TokenStream;\n+use quote::{quote, ToTokens};\n+\n+pub fn fold_quote<F, I, T>(input: impl Iterator<Item = I>, f: F) -> TokenStream\n+where\n+    F: Fn(I) -> T,\n+    T: ToTokens,\n+{\n+    input.fold(quote! {}, |acc, x| {\n+        let y = f(x);\n+        quote! { #acc #y }\n+    })\n+}\n+\n+pub fn is_unit(v: &syn::Variant) -> bool {\n+    match v.fields {\n+        syn::Fields::Unit => true,\n+        _ => false,\n+    }\n+}\n+\n+#[cfg(feature = \"debug-with-rustfmt\")]\n+/// Pretty-print the output of proc macro using rustfmt.\n+pub fn debug_with_rustfmt(input: &TokenStream) {\n+    use std::io::Write;\n+    use std::process::{Command, Stdio};\n+\n+    let mut child = Command::new(\"rustfmt\")\n+        .stdin(Stdio::piped())\n+        .stdout(Stdio::piped())\n+        .spawn()\n+        .expect(\"Failed to spawn rustfmt in stdio mode\");\n+    {\n+        let stdin = child.stdin.as_mut().expect(\"Failed to get stdin\");\n+        stdin\n+            .write_all(format!(\"{}\", input).as_bytes())\n+            .expect(\"Failed to write to stdin\");\n+    }\n+    let rustfmt_output = child.wait_with_output().expect(\"rustfmt has failed\");\n+\n+    eprintln!(\n+        \"{}\",\n+        String::from_utf8(rustfmt_output.stdout).expect(\"rustfmt returned non-UTF8 string\")\n+    );\n+}"}, {"sha": "a8b8a901ac93c406affb0282132ae9b16c02b1c0", "filename": "config_proc_macro/tests/smoke.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d3ec4609d64e26f5c5bf0ad118e6074755419a27/config_proc_macro%2Ftests%2Fsmoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ec4609d64e26f5c5bf0ad118e6074755419a27/config_proc_macro%2Ftests%2Fsmoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config_proc_macro%2Ftests%2Fsmoke.rs?ref=d3ec4609d64e26f5c5bf0ad118e6074755419a27", "patch": "@@ -0,0 +1,20 @@\n+pub mod config {\n+    pub trait ConfigType: Sized {\n+        fn doc_hint() -> String;\n+    }\n+}\n+\n+#[allow(dead_code)]\n+#[allow(unused_imports)]\n+mod tests {\n+    use config_proc_macro::config_type;\n+\n+    #[config_type]\n+    enum Bar {\n+        Foo,\n+        Bar,\n+        #[doc_hint = \"foo_bar\"]\n+        FooBar,\n+        FooFoo(i32),\n+    }\n+}"}, {"sha": "0270bd0eb0b31092a8f7f4e2c44f7987a5583942", "filename": "src/config/lists.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d3ec4609d64e26f5c5bf0ad118e6074755419a27/src%2Fconfig%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ec4609d64e26f5c5bf0ad118e6074755419a27/src%2Fconfig%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Flists.rs?ref=d3ec4609d64e26f5c5bf0ad118e6074755419a27", "patch": "@@ -1,6 +1,7 @@\n //! Configuration options related to rewriting a list.\n \n-use crate::config::config_type::ConfigType;\n+use config_proc_macro::config_type;\n+\n use crate::config::IndentStyle;\n \n /// The definitive formatting tactic for lists.\n@@ -25,31 +26,27 @@ impl DefinitiveListTactic {\n /// Formatting tactic for lists. This will be cast down to a\n /// `DefinitiveListTactic` depending on the number and length of the items and\n /// their comments.\n-#[derive(Eq, PartialEq, Debug, Copy, Clone)]\n+#[config_type]\n pub enum ListTactic {\n-    // One item per row.\n+    /// One item per row.\n     Vertical,\n-    // All items on one row.\n+    /// All items on one row.\n     Horizontal,\n-    // Try Horizontal layout, if that fails then vertical.\n+    /// Try Horizontal layout, if that fails then vertical.\n     HorizontalVertical,\n-    // HorizontalVertical with a soft limit of n characters.\n+    /// HorizontalVertical with a soft limit of n characters.\n     LimitedHorizontalVertical(usize),\n-    // Pack as many items as possible per row over (possibly) many rows.\n+    /// Pack as many items as possible per row over (possibly) many rows.\n     Mixed,\n }\n \n-impl_enum_serialize_and_deserialize!(ListTactic, Vertical, Horizontal, HorizontalVertical, Mixed);\n-\n-#[derive(Eq, PartialEq, Debug, Copy, Clone)]\n+#[config_type]\n pub enum SeparatorTactic {\n     Always,\n     Never,\n     Vertical,\n }\n \n-impl_enum_serialize_and_deserialize!(SeparatorTactic, Always, Never, Vertical);\n-\n impl SeparatorTactic {\n     pub fn from_bool(b: bool) -> SeparatorTactic {\n         if b {\n@@ -61,14 +58,12 @@ impl SeparatorTactic {\n }\n \n /// Where to put separator.\n-#[derive(Eq, PartialEq, Debug, Copy, Clone)]\n+#[config_type]\n pub enum SeparatorPlace {\n     Front,\n     Back,\n }\n \n-impl_enum_serialize_and_deserialize!(SeparatorPlace, Front, Back);\n-\n impl SeparatorPlace {\n     pub fn is_front(self) -> bool {\n         self == SeparatorPlace::Front"}, {"sha": "9b0060bfdb6baf25b3c7265bb3be3f260a76dddb", "filename": "src/config/options.rs", "status": "modified", "additions": 90, "deletions": 172, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/d3ec4609d64e26f5c5bf0ad118e6074755419a27/src%2Fconfig%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ec4609d64e26f5c5bf0ad118e6074755419a27/src%2Fconfig%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Foptions.rs?ref=d3ec4609d64e26f5c5bf0ad118e6074755419a27", "patch": "@@ -3,133 +3,22 @@ use std::fmt;\n use std::path::{Path, PathBuf};\n \n use atty;\n+use config_proc_macro::config_type;\n use serde::de::{Deserialize, Deserializer, SeqAccess, Visitor};\n \n-use crate::config::config_type::ConfigType;\n use crate::config::lists::*;\n use crate::config::Config;\n \n-/// Macro that will stringify the enum variants or a provided textual repr\n-#[macro_export]\n-macro_rules! configuration_option_enum_stringify {\n-    ($variant:ident) => {\n-        stringify!($variant)\n-    };\n-\n-    ($_variant:ident: $value:expr) => {\n-        stringify!($value)\n-    };\n-}\n-\n-/// Macro for deriving implementations of Serialize/Deserialize for enums\n-#[macro_export]\n-macro_rules! impl_enum_serialize_and_deserialize {\n-    ( $e:ident, $( $variant:ident $(: $value:expr)* ),* ) => {\n-        impl ::serde::ser::Serialize for $e {\n-            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n-                where S: ::serde::ser::Serializer\n-            {\n-                use serde::ser::Error;\n-\n-                // We don't know whether the user of the macro has given us all options.\n-                #[allow(unreachable_patterns)]\n-                match *self {\n-                    $(\n-                        $e::$variant => serializer.serialize_str(\n-                            configuration_option_enum_stringify!($variant $(: $value)*)\n-                        ),\n-                    )*\n-                    _ => {\n-                        Err(S::Error::custom(format!(\"Cannot serialize {:?}\", self)))\n-                    }\n-                }\n-            }\n-        }\n-\n-        impl<'de> ::serde::de::Deserialize<'de> for $e {\n-            fn deserialize<D>(d: D) -> Result<Self, D::Error>\n-                    where D: ::serde::Deserializer<'de> {\n-                use serde::de::{Error, Visitor};\n-                use std::marker::PhantomData;\n-                use std::fmt;\n-                struct StringOnly<T>(PhantomData<T>);\n-                impl<'de, T> Visitor<'de> for StringOnly<T>\n-                        where T: ::serde::Deserializer<'de> {\n-                    type Value = String;\n-                    fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                        formatter.write_str(\"string\")\n-                    }\n-                    fn visit_str<E>(self, value: &str) -> Result<String, E> {\n-                        Ok(String::from(value))\n-                    }\n-                }\n-                let s = d.deserialize_string(StringOnly::<D>(PhantomData))?;\n-                $(\n-                    if configuration_option_enum_stringify!($variant $(: $value)*)\n-                        .eq_ignore_ascii_case(&s) {\n-                      return Ok($e::$variant);\n-                    }\n-                )*\n-                static ALLOWED: &'static[&str] = &[\n-                    $(configuration_option_enum_stringify!($variant $(: $value)*),)*];\n-                Err(D::Error::unknown_variant(&s, ALLOWED))\n-            }\n-        }\n-\n-        impl ::std::str::FromStr for $e {\n-            type Err = &'static str;\n-\n-            fn from_str(s: &str) -> Result<Self, Self::Err> {\n-                $(\n-                    if configuration_option_enum_stringify!($variant $(: $value)*)\n-                        .eq_ignore_ascii_case(s) {\n-                        return Ok($e::$variant);\n-                    }\n-                )*\n-                Err(\"Bad variant\")\n-            }\n-        }\n-\n-        impl ConfigType for $e {\n-            fn doc_hint() -> String {\n-                let mut variants = Vec::new();\n-                $(\n-                    variants.push(\n-                        configuration_option_enum_stringify!($variant $(: $value)*)\n-                    );\n-                )*\n-                format!(\"[{}]\", variants.join(\"|\"))\n-            }\n-        }\n-    };\n-}\n-\n-macro_rules! configuration_option_enum {\n-    ($e:ident: $( $name:ident $(: $value:expr)* ),+ $(,)*) => (\n-        #[derive(Copy, Clone, Eq, PartialEq)]\n-        pub enum $e {\n-            $( $name ),+\n-        }\n-\n-        impl ::std::fmt::Debug for $e {\n-            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {\n-                f.write_str(match self {\n-                    $(\n-                        $e::$name => configuration_option_enum_stringify!($name $(: $value)*),\n-                    )+\n-                })\n-            }\n-        }\n-\n-        impl_enum_serialize_and_deserialize!($e, $( $name $(: $value)* ),+);\n-    );\n-}\n-\n-configuration_option_enum! { NewlineStyle:\n-    Auto, // Auto-detect based on the raw source input\n-    Windows, // \\r\\n\n-    Unix, // \\n\n-    Native, // \\r\\n in Windows, \\n on other platforms\n+#[config_type]\n+pub enum NewlineStyle {\n+    /// Auto-detect based on the raw source input.\n+    Auto,\n+    /// Force CRLF (`\\r\\n`).\n+    Windows,\n+    /// Force CR (`\\n).\n+    Unix,\n+    /// `\\r\\n` in Windows, `\\n`` on other platforms.\n+    Native,\n }\n \n impl NewlineStyle {\n@@ -188,53 +77,67 @@ impl NewlineStyle {\n     }\n }\n \n-configuration_option_enum! { BraceStyle:\n+#[config_type]\n+/// Where to put the opening brace of items (`fn`, `impl`, etc.).\n+pub enum BraceStyle {\n+    /// Put the opening brace on the next line.\n     AlwaysNextLine,\n+    /// Put the opening brace on the same line, if possible.\n     PreferSameLine,\n-    // Prefer same line except where there is a where-clause, in which case force\n-    // the brace to the next line.\n+    /// Prefer the same line except where there is a where-clause, in which\n+    /// case force the brace to be put on the next line.\n     SameLineWhere,\n }\n \n-configuration_option_enum! { ControlBraceStyle:\n-    // K&R style, Rust community default\n+#[config_type]\n+/// Where to put the opening brace of conditional expressions (`if`, `match`, etc.).\n+pub enum ControlBraceStyle {\n+    /// K&R style, Rust community default\n     AlwaysSameLine,\n-    // Stroustrup style\n+    /// Stroustrup style\n     ClosingNextLine,\n-    // Allman style\n+    /// Allman style\n     AlwaysNextLine,\n }\n \n-configuration_option_enum! { IndentStyle:\n-    // First line on the same line as the opening brace, all lines aligned with\n-    // the first line.\n+#[config_type]\n+/// How to indent.\n+pub enum IndentStyle {\n+    /// First line on the same line as the opening brace, all lines aligned with\n+    /// the first line.\n     Visual,\n-    // First line is on a new line and all lines align with block indent.\n+    /// First line is on a new line and all lines align with **block** indent.\n     Block,\n }\n \n-configuration_option_enum! { Density:\n-    // Fit as much on one line as possible.\n+#[config_type]\n+/// How to place a list-like items.\n+pub enum Density {\n+    /// Fit as much on one line as possible.\n     Compressed,\n-    // Use more lines.\n+    /// Use more lines.\n     Tall,\n-    // Place every item on a separate line.\n+    /// Place every item on a separate line.\n     Vertical,\n }\n \n-configuration_option_enum! { TypeDensity:\n-    // No spaces around \"=\" and \"+\"\n+#[config_type]\n+/// Spacing around type combinators.\n+pub enum TypeDensity {\n+    /// No spaces around \"=\" and \"+\"\n     Compressed,\n-    // Spaces around \" = \" and \" + \"\n+    /// Spaces around \" = \" and \" + \"\n     Wide,\n }\n \n-configuration_option_enum! { Heuristics:\n-    // Turn off any heuristics\n+#[config_type]\n+/// To what extent does rustfmt pursue its heuristics?\n+pub enum Heuristics {\n+    /// Turn off any heuristics\n     Off,\n-    // Turn on max heuristics\n+    /// Turn on max heuristics\n     Max,\n-    // Use Rustfmt's defaults\n+    /// Use Rustfmt's defaults\n     Default,\n }\n \n@@ -249,45 +152,51 @@ impl Density {\n     }\n }\n \n-configuration_option_enum! { ReportTactic:\n+#[config_type]\n+pub enum ReportTactic {\n     Always,\n     Unnumbered,\n     Never,\n }\n \n-// What Rustfmt should emit. Mostly corresponds to the `--emit` command line\n-// option.\n-configuration_option_enum! { EmitMode:\n-    // Emits to files.\n+/// What Rustfmt should emit. Mostly corresponds to the `--emit` command line\n+/// option.\n+#[config_type]\n+pub enum EmitMode {\n+    /// Emits to files.\n     Files,\n-    // Writes the output to stdout.\n+    /// Writes the output to stdout.\n     Stdout,\n-    // Displays how much of the input file was processed\n+    /// Displays how much of the input file was processed\n     Coverage,\n-    // Unfancy stdout\n+    /// Unfancy stdout\n     Checkstyle,\n-    // Output the changed lines (for internal value only)\n+    /// Output the changed lines (for internal value only)\n     ModifiedLines,\n-    // Checks if a diff can be generated. If so, rustfmt outputs a diff and quits with exit code 1.\n-    // This option is designed to be run in CI where a non-zero exit signifies non-standard code\n-    // formatting. Used for `--check`.\n+    /// Checks if a diff can be generated. If so, rustfmt outputs a diff and\n+    /// quits with exit code 1.\n+    /// This option is designed to be run in CI where a non-zero exit signifies\n+    /// non-standard code formatting. Used for `--check`.\n     Diff,\n }\n \n-// Client-preference for coloured output.\n-configuration_option_enum! { Color:\n-    // Always use color, whether it is a piped or terminal output\n+/// Client-preference for coloured output.\n+#[config_type]\n+pub enum Color {\n+    /// Always use color, whether it is a piped or terminal output\n     Always,\n-    // Never use color\n+    /// Never use color\n     Never,\n-    // Automatically use color, if supported by terminal\n+    /// Automatically use color, if supported by terminal\n     Auto,\n }\n \n-configuration_option_enum! { Version:\n-    // 1.x.y\n+#[config_type]\n+/// rustfmt format style version.\n+pub enum Version {\n+    /// 1.x.y. When specified, rustfmt will format in the same style as 1.0.0.\n     One,\n-    // 2.x.y\n+    /// 2.x.y. When specified, rustfmt will formatin the the latest style.\n     Two,\n }\n \n@@ -302,12 +211,14 @@ impl Color {\n     }\n }\n \n-// How chatty should Rustfmt be?\n-configuration_option_enum! { Verbosity:\n-    // Emit more.\n+/// How chatty should Rustfmt be?\n+#[config_type]\n+pub enum Verbosity {\n+    /// Emit more.\n     Verbose,\n+    /// Default.\n     Normal,\n-    // Emit as little as possible.\n+    /// Emit as little as possible.\n     Quiet,\n }\n \n@@ -473,10 +384,17 @@ pub trait CliOptions {\n     fn config_path(&self) -> Option<&Path>;\n }\n \n-// The edition of the compiler (RFC 2052)\n-configuration_option_enum! { Edition:\n-    Edition2015: 2015,\n-    Edition2018: 2018,\n+/// The edition of the syntax and semntics of code (RFC 2052).\n+#[config_type]\n+pub enum Edition {\n+    #[value = \"2015\"]\n+    #[doc_hint = \"2015\"]\n+    /// Edition 2015.\n+    Edition2015,\n+    #[value = \"2018\"]\n+    #[doc_hint = \"2018\"]\n+    /// Edition 2018.\n+    Edition2018,\n }\n \n impl Default for Edition {"}]}