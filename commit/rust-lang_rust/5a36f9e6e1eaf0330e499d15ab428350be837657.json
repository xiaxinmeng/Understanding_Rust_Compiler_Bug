{"sha": "5a36f9e6e1eaf0330e499d15ab428350be837657", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhMzZmOWU2ZTFlYWYwMzMwZTQ5OWQxNWFiNDI4MzUwYmU4Mzc2NTc=", "commit": {"author": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2018-12-17T18:49:45Z"}, "committer": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2018-12-26T21:40:22Z"}, "message": "Fixed several ICEs.", "tree": {"sha": "d6d072a768b48744fc59950168861f5695cd60e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6d072a768b48744fc59950168861f5695cd60e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a36f9e6e1eaf0330e499d15ab428350be837657", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a36f9e6e1eaf0330e499d15ab428350be837657", "html_url": "https://github.com/rust-lang/rust/commit/5a36f9e6e1eaf0330e499d15ab428350be837657", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a36f9e6e1eaf0330e499d15ab428350be837657/comments", "author": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65f50582cf3e06e6f6dd68d3e5e5b841ac4ea6e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/65f50582cf3e06e6f6dd68d3e5e5b841ac4ea6e9", "html_url": "https://github.com/rust-lang/rust/commit/65f50582cf3e06e6f6dd68d3e5e5b841ac4ea6e9"}], "stats": {"total": 188, "additions": 116, "deletions": 72}, "files": [{"sha": "923be2a76aa6688f82e8ac76ea6198b9a35fd1e4", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5a36f9e6e1eaf0330e499d15ab428350be837657/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a36f9e6e1eaf0330e499d15ab428350be837657/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=5a36f9e6e1eaf0330e499d15ab428350be837657", "patch": "@@ -17,6 +17,8 @@ use util::nodemap::FxHashMap;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::cmp;\n \n+use super::report_unexpected_variant_def;\n+\n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// The `is_arg` argument indicates whether this pattern is the\n     /// *outermost* pattern in an argument (e.g., in `fn foo(&x:\n@@ -736,12 +738,6 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                       expected: Ty<'tcx>) -> Ty<'tcx>\n     {\n         let tcx = self.tcx;\n-        let report_unexpected_def = |def: Def| {\n-            span_err!(tcx.sess, pat.span, E0533,\n-                      \"expected unit struct/variant or constant, found {} `{}`\",\n-                      def.kind_name(),\n-                      hir::print::to_string(tcx.hir(), |s| s.print_qpath(qpath, false)));\n-        };\n \n         // Resolve the path and check the definition for errors.\n         let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(qpath, pat.id, pat.span);\n@@ -751,7 +747,11 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                 return tcx.types.err;\n             }\n             Def::Method(..) => {\n-                report_unexpected_def(def);\n+                report_unexpected_variant_def(tcx, &def, pat.span, qpath);\n+                return tcx.types.err;\n+            }\n+            Def::VariantCtor(_, CtorKind::Fictive) => {\n+                report_unexpected_variant_def(tcx, &def, pat.span, qpath);\n                 return tcx.types.err;\n             }\n             Def::VariantCtor(_, CtorKind::Const) |"}, {"sha": "bf878f87e36931ed81142da0962f0312c3693a5a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 80, "deletions": 65, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/5a36f9e6e1eaf0330e499d15ab428350be837657/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a36f9e6e1eaf0330e499d15ab428350be837657/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5a36f9e6e1eaf0330e499d15ab428350be837657", "patch": "@@ -85,8 +85,8 @@ mod op;\n \n use astconv::AstConv;\n use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n-use rustc::hir::{self, GenericArg, ItemKind, Node, PatKind};\n-use rustc::hir::def::Def;\n+use rustc::hir::{self, ExprKind, GenericArg, ItemKind, Node, PatKind, QPath};\n+use rustc::hir::def::{CtorKind, Def};\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n@@ -1864,6 +1864,16 @@ pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     check_representable(tcx, sp, def_id);\n }\n \n+fn report_unexpected_variant_def<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                                 def: &Def,\n+                                                 span: Span,\n+                                                 qpath: &QPath) {\n+    span_err!(tcx.sess, span, E0533,\n+              \"expected unit struct/variant or constant, found {} `{}`\",\n+              def.kind_name(),\n+              hir::print::to_string(tcx.hir(), |s| s.print_qpath(qpath, false)));\n+}\n+\n impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n \n@@ -2947,7 +2957,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n \n                 let is_closure = match arg.node {\n-                    hir::ExprKind::Closure(..) => true,\n+                    ExprKind::Closure(..) => true,\n                     _ => false\n                 };\n \n@@ -3097,8 +3107,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         if let Some(mut err) = self.demand_suptype_diag(expr.span, expected_ty, ty) {\n-            // Add help to type error if this is an `if` condition with an assignment\n-            if let (ExpectIfCondition, &hir::ExprKind::Assign(ref lhs, ref rhs))\n+            // Add help to type error if this is an `if` condition with an assignment.\n+            if let (ExpectIfCondition, &ExprKind::Assign(ref lhs, ref rhs))\n                  = (expected, &expr.node)\n             {\n                 let msg = \"try comparing for equality\";\n@@ -3691,12 +3701,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn check_struct_path(&self,\n-                             qpath: &hir::QPath,\n+                             qpath: &QPath,\n                              node_id: ast::NodeId)\n                              -> Option<(&'tcx ty::VariantDef,  Ty<'tcx>)> {\n         let path_span = match *qpath {\n-            hir::QPath::Resolved(_, ref path) => path.span,\n-            hir::QPath::TypeRelative(ref qself, _) => qself.span\n+            QPath::Resolved(_, ref path) => path.span,\n+            QPath::TypeRelative(ref qself, _) => qself.span\n         };\n         let (def, ty) = self.finish_resolving_struct_path(qpath, path_span, node_id);\n         let variant = match def {\n@@ -3749,7 +3759,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn check_expr_struct(&self,\n                          expr: &hir::Expr,\n                          expected: Expectation<'tcx>,\n-                         qpath: &hir::QPath,\n+                         qpath: &QPath,\n                          fields: &'gcx [hir::Field],\n                          base_expr: &'gcx Option<P<hir::Expr>>) -> Ty<'tcx>\n     {\n@@ -3763,8 +3773,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             };\n \n         let path_span = match *qpath {\n-            hir::QPath::Resolved(_, ref path) => path.span,\n-            hir::QPath::TypeRelative(ref qself, _) => qself.span\n+            QPath::Resolved(_, ref path) => path.span,\n+            QPath::TypeRelative(ref qself, _) => qself.span\n         };\n \n         // Prohibit struct expressions when non-exhaustive flag is set.\n@@ -3836,9 +3846,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Warn for non-block expressions with diverging children.\n         match expr.node {\n-            hir::ExprKind::Block(..) |\n-            hir::ExprKind::Loop(..) | hir::ExprKind::While(..) |\n-            hir::ExprKind::If(..) | hir::ExprKind::Match(..) => {}\n+            ExprKind::Block(..) |\n+            ExprKind::Loop(..) | ExprKind::While(..) |\n+            ExprKind::If(..) | ExprKind::Match(..) => {}\n \n             _ => self.warn_if_unreachable(expr.id, expr.span, \"expression\")\n         }\n@@ -3879,7 +3889,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let tcx = self.tcx;\n         let id = expr.id;\n         match expr.node {\n-            hir::ExprKind::Box(ref subexpr) => {\n+            ExprKind::Box(ref subexpr) => {\n                 let expected_inner = expected.to_option(self).map_or(NoExpectation, |ty| {\n                     match ty.sty {\n                         ty::Adt(def, _) if def.is_box()\n@@ -3891,16 +3901,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 tcx.mk_box(referent_ty)\n             }\n \n-            hir::ExprKind::Lit(ref lit) => {\n+            ExprKind::Lit(ref lit) => {\n                 self.check_lit(&lit, expected)\n             }\n-            hir::ExprKind::Binary(op, ref lhs, ref rhs) => {\n+            ExprKind::Binary(op, ref lhs, ref rhs) => {\n                 self.check_binop(expr, op, lhs, rhs)\n             }\n-            hir::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n+            ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n                 self.check_binop_assign(expr, op, lhs, rhs)\n             }\n-            hir::ExprKind::Unary(unop, ref oprnd) => {\n+            ExprKind::Unary(unop, ref oprnd) => {\n                 let expected_inner = match unop {\n                     hir::UnNot | hir::UnNeg => {\n                         expected\n@@ -3968,7 +3978,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 oprnd_t\n             }\n-            hir::ExprKind::AddrOf(mutbl, ref oprnd) => {\n+            ExprKind::AddrOf(mutbl, ref oprnd) => {\n                 let hint = expected.only_has_type(self).map_or(NoExpectation, |ty| {\n                     match ty.sty {\n                         ty::Ref(_, ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n@@ -4008,13 +4018,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     tcx.mk_ref(region, tm)\n                 }\n             }\n-            hir::ExprKind::Path(ref qpath) => {\n+            ExprKind::Path(ref qpath) => {\n                 let (def, opt_ty, segs) = self.resolve_ty_and_def_ufcs(qpath, expr.id, expr.span);\n-                let ty = if def != Def::Err {\n-                    self.instantiate_value_path(segs, opt_ty, def, expr.span, id).0\n-                } else {\n-                    self.set_tainted_by_errors();\n-                    tcx.types.err\n+                let ty = match def {\n+                    Def::Err => {\n+                        self.set_tainted_by_errors();\n+                        tcx.types.err\n+                    }\n+                    Def::VariantCtor(_, CtorKind::Fictive) => {\n+                        report_unexpected_variant_def(tcx, &def, expr.span, qpath);\n+                        tcx.types.err\n+                    }\n+                    _ => self.instantiate_value_path(segs, opt_ty, def, expr.span, id).0,\n                 };\n \n                 if let ty::FnDef(..) = ty.sty {\n@@ -4061,13 +4076,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 ty\n             }\n-            hir::ExprKind::InlineAsm(_, ref outputs, ref inputs) => {\n+            ExprKind::InlineAsm(_, ref outputs, ref inputs) => {\n                 for expr in outputs.iter().chain(inputs.iter()) {\n                     self.check_expr(expr);\n                 }\n                 tcx.mk_unit()\n             }\n-            hir::ExprKind::Break(destination, ref expr_opt) => {\n+            ExprKind::Break(destination, ref expr_opt) => {\n                 if let Ok(target_id) = destination.target_id {\n                     let (e_ty, cause);\n                     if let Some(ref e) = *expr_opt {\n@@ -4140,7 +4155,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                         // ... except when we try to 'break rust;'.\n                         // ICE this expression in particular (see #43162).\n-                        if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = e.node {\n+                        if let ExprKind::Path(QPath::Resolved(_, ref path)) = e.node {\n                             if path.segments.len() == 1 && path.segments[0].ident.name == \"rust\" {\n                                 fatally_break_rust(self.tcx.sess);\n                             }\n@@ -4151,15 +4166,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n \n             }\n-            hir::ExprKind::Continue(destination) => {\n+            ExprKind::Continue(destination) => {\n                 if destination.target_id.is_ok() {\n                     tcx.types.never\n                 } else {\n                     // There was an error; make type-check fail.\n                     tcx.types.err\n                 }\n             }\n-            hir::ExprKind::Ret(ref expr_opt) => {\n+            ExprKind::Ret(ref expr_opt) => {\n                 if self.ret_coercion.is_none() {\n                     struct_span_err!(self.tcx.sess, expr.span, E0572,\n                                      \"return statement outside of function body\").emit();\n@@ -4191,7 +4206,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 tcx.types.never\n             }\n-            hir::ExprKind::Assign(ref lhs, ref rhs) => {\n+            ExprKind::Assign(ref lhs, ref rhs) => {\n                 let lhs_ty = self.check_expr_with_needs(&lhs, Needs::MutPlace);\n \n                 let rhs_ty = self.check_expr_coercable_to_type(&rhs, lhs_ty);\n@@ -4221,11 +4236,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     tcx.mk_unit()\n                 }\n             }\n-            hir::ExprKind::If(ref cond, ref then_expr, ref opt_else_expr) => {\n+            ExprKind::If(ref cond, ref then_expr, ref opt_else_expr) => {\n                 self.check_then_else(&cond, then_expr, opt_else_expr.as_ref().map(|e| &**e),\n                                      expr.span, expected)\n             }\n-            hir::ExprKind::While(ref cond, ref body, _) => {\n+            ExprKind::While(ref cond, ref body, _) => {\n                 let ctxt = BreakableCtxt {\n                     // cannot use break with a value from a while loop\n                     coerce: None,\n@@ -4249,7 +4264,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 self.tcx.mk_unit()\n             }\n-            hir::ExprKind::Loop(ref body, _, source) => {\n+            ExprKind::Loop(ref body, _, source) => {\n                 let coerce = match source {\n                     // you can only use break with a value from a normal `loop { }`\n                     hir::LoopSource::Loop => {\n@@ -4289,22 +4304,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 ctxt.coerce.map(|c| c.complete(self)).unwrap_or_else(|| self.tcx.mk_unit())\n             }\n-            hir::ExprKind::Match(ref discrim, ref arms, match_src) => {\n+            ExprKind::Match(ref discrim, ref arms, match_src) => {\n                 self.check_match(expr, &discrim, arms, expected, match_src)\n             }\n-            hir::ExprKind::Closure(capture, ref decl, body_id, _, gen) => {\n+            ExprKind::Closure(capture, ref decl, body_id, _, gen) => {\n                 self.check_expr_closure(expr, capture, &decl, body_id, gen, expected)\n             }\n-            hir::ExprKind::Block(ref body, _) => {\n+            ExprKind::Block(ref body, _) => {\n                 self.check_block_with_expected(&body, expected)\n             }\n-            hir::ExprKind::Call(ref callee, ref args) => {\n+            ExprKind::Call(ref callee, ref args) => {\n                 self.check_call(expr, &callee, args, expected)\n             }\n-            hir::ExprKind::MethodCall(ref segment, span, ref args) => {\n+            ExprKind::MethodCall(ref segment, span, ref args) => {\n                 self.check_method_call(expr, segment, span, args, expected, needs)\n             }\n-            hir::ExprKind::Cast(ref e, ref t) => {\n+            ExprKind::Cast(ref e, ref t) => {\n                 // Find the type of `e`. Supply hints based on the type we are casting to,\n                 // if appropriate.\n                 let t_cast = self.to_ty_saving_user_provided_ty(t);\n@@ -4329,12 +4344,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n-            hir::ExprKind::Type(ref e, ref t) => {\n+            ExprKind::Type(ref e, ref t) => {\n                 let ty = self.to_ty_saving_user_provided_ty(&t);\n                 self.check_expr_eq_type(&e, ty);\n                 ty\n             }\n-            hir::ExprKind::Array(ref args) => {\n+            ExprKind::Array(ref args) => {\n                 let uty = expected.to_option(self).and_then(|uty| {\n                     match uty.sty {\n                         ty::Array(ty, _) | ty::Slice(ty) => Some(ty),\n@@ -4358,7 +4373,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 };\n                 tcx.mk_array(element_ty, args.len() as u64)\n             }\n-            hir::ExprKind::Repeat(ref element, ref count) => {\n+            ExprKind::Repeat(ref element, ref count) => {\n                 let count_def_id = tcx.hir().local_def_id(count.id);\n                 let param_env = ty::ParamEnv::empty();\n                 let substs = Substs::identity_for_item(tcx.global_tcx(), count_def_id);\n@@ -4414,7 +4429,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     tcx.types.err\n                 }\n             }\n-            hir::ExprKind::Tup(ref elts) => {\n+            ExprKind::Tup(ref elts) => {\n                 let flds = expected.only_has_type(self).and_then(|ty| {\n                     let ty = self.resolve_type_vars_with_obligations(ty);\n                     match ty.sty {\n@@ -4444,13 +4459,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     tuple\n                 }\n             }\n-            hir::ExprKind::Struct(ref qpath, ref fields, ref base_expr) => {\n+            ExprKind::Struct(ref qpath, ref fields, ref base_expr) => {\n                 self.check_expr_struct(expr, expected, qpath, fields, base_expr)\n             }\n-            hir::ExprKind::Field(ref base, field) => {\n+            ExprKind::Field(ref base, field) => {\n                 self.check_field(expr, needs, &base, field)\n             }\n-            hir::ExprKind::Index(ref base, ref idx) => {\n+            ExprKind::Index(ref base, ref idx) => {\n                 let base_t = self.check_expr_with_needs(&base, needs);\n                 let idx_t = self.check_expr(&idx);\n \n@@ -4476,7 +4491,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 let mut needs_note = true;\n                                 // If the index is an integer, we can show the actual\n                                 // fixed expression:\n-                                if let hir::ExprKind::Lit(ref lit) = idx.node {\n+                                if let ExprKind::Lit(ref lit) = idx.node {\n                                     if let ast::LitKind::Int(i,\n                                             ast::LitIntType::Unsuffixed) = lit.node {\n                                         let snip = tcx.sess.source_map().span_to_snippet(base.span);\n@@ -4501,7 +4516,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n-            hir::ExprKind::Yield(ref value) => {\n+            ExprKind::Yield(ref value) => {\n                 match self.yield_ty {\n                     Some(ty) => {\n                         self.check_expr_coercable_to_type(&value, ty);\n@@ -4519,21 +4534,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     // Finish resolving a path in a struct expression or pattern `S::A { .. }` if necessary.\n     // The newly resolved definition is written into `type_dependent_defs`.\n     fn finish_resolving_struct_path(&self,\n-                                    qpath: &hir::QPath,\n+                                    qpath: &QPath,\n                                     path_span: Span,\n                                     node_id: ast::NodeId)\n                                     -> (Def, Ty<'tcx>)\n     {\n         match *qpath {\n-            hir::QPath::Resolved(ref maybe_qself, ref path) => {\n+            QPath::Resolved(ref maybe_qself, ref path) => {\n                 let self_ty = maybe_qself.as_ref().map(|qself| self.to_ty(qself));\n                 let ty = AstConv::def_to_ty(self, self_ty, path, true);\n                 (path.def, ty)\n             }\n-            hir::QPath::TypeRelative(ref qself, ref segment) => {\n+            QPath::TypeRelative(ref qself, ref segment) => {\n                 let ty = self.to_ty(qself);\n \n-                let def = if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = qself.node {\n+                let def = if let hir::TyKind::Path(QPath::Resolved(_, ref path)) = qself.node {\n                     path.def\n                 } else {\n                     Def::Err\n@@ -4553,18 +4568,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     // Resolve associated value path into a base type and associated constant or method definition.\n     // The newly resolved definition is written into `type_dependent_defs`.\n     pub fn resolve_ty_and_def_ufcs<'b>(&self,\n-                                       qpath: &'b hir::QPath,\n+                                       qpath: &'b QPath,\n                                        node_id: ast::NodeId,\n                                        span: Span)\n                                        -> (Def, Option<Ty<'tcx>>, &'b [hir::PathSegment])\n     {\n         let (ty, qself, item_segment) = match *qpath {\n-            hir::QPath::Resolved(ref opt_qself, ref path) => {\n+            QPath::Resolved(ref opt_qself, ref path) => {\n                 return (path.def,\n                         opt_qself.as_ref().map(|qself| self.to_ty(qself)),\n                         &path.segments[..]);\n             }\n-            hir::QPath::TypeRelative(ref qself, ref segment) => {\n+            QPath::TypeRelative(ref qself, ref segment) => {\n                 (self.to_ty(qself), qself, segment)\n             }\n         };\n@@ -4935,13 +4950,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // `BlockTailExpression` only relevant if the tail expr would be\n             // useful on its own.\n             match expression.node {\n-                hir::ExprKind::Call(..) |\n-                hir::ExprKind::MethodCall(..) |\n-                hir::ExprKind::If(..) |\n-                hir::ExprKind::While(..) |\n-                hir::ExprKind::Loop(..) |\n-                hir::ExprKind::Match(..) |\n-                hir::ExprKind::Block(..) => {\n+                ExprKind::Call(..) |\n+                ExprKind::MethodCall(..) |\n+                ExprKind::If(..) |\n+                ExprKind::While(..) |\n+                ExprKind::Loop(..) |\n+                ExprKind::Match(..) |\n+                ExprKind::Block(..) => {\n                     let sp = self.tcx.sess.source_map().next_point(cause_span);\n                     err.span_suggestion_with_applicability(\n                         sp,\n@@ -5449,7 +5464,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // If our calling expression is indeed the function itself, we're good!\n         // If not, generate an error that this can only be called directly.\n         if let Node::Expr(expr) = self.tcx.hir().get(self.tcx.hir().get_parent_node(node_id)) {\n-            if let hir::ExprKind::Call(ref callee, ..) = expr.node {\n+            if let ExprKind::Call(ref callee, ..) = expr.node {\n                 if callee.id == node_id {\n                     return\n                 }"}, {"sha": "f97592f5d3b150ce55182fede7a4b6f648c96cd1", "filename": "src/test/ui/type-alias-enum-variants-panic.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5a36f9e6e1eaf0330e499d15ab428350be837657/src%2Ftest%2Fui%2Ftype-alias-enum-variants-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a36f9e6e1eaf0330e499d15ab428350be837657/src%2Ftest%2Fui%2Ftype-alias-enum-variants-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-enum-variants-panic.rs?ref=5a36f9e6e1eaf0330e499d15ab428350be837657", "patch": "@@ -1,10 +1,17 @@\n+// ignore-tidy-linelength\n+\n #![feature(type_alias_enum_variants)]\n \n+#![allow(unreachable_code)]\n+\n enum Enum { Variant {} }\n type Alias = Enum;\n \n fn main() {\n     Alias::Variant;\n+    //~^ ERROR expected unit struct/variant or constant, found struct variant `<Alias>::Variant` [E0533]\n     let Alias::Variant = panic!();\n+    //~^ ERROR expected unit struct/variant or constant, found struct variant `<Alias>::Variant` [E0533]\n     let Alias::Variant(..) = panic!();\n+    //~^ ERROR expected tuple struct/variant, found struct variant `<Alias>::Variant` [E0164]\n }"}, {"sha": "3480d116383eea2546361d4e1e429576616a1483", "filename": "src/test/ui/type-alias-enum-variants-panic.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5a36f9e6e1eaf0330e499d15ab428350be837657/src%2Ftest%2Fui%2Ftype-alias-enum-variants-panic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5a36f9e6e1eaf0330e499d15ab428350be837657/src%2Ftest%2Fui%2Ftype-alias-enum-variants-panic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-enum-variants-panic.stderr?ref=5a36f9e6e1eaf0330e499d15ab428350be837657", "patch": "@@ -0,0 +1,22 @@\n+error[E0533]: expected unit struct/variant or constant, found struct variant `<Alias>::Variant`\n+  --> $DIR/type-alias-enum-variants-panic.rs:11:5\n+   |\n+LL |     Alias::Variant;\n+   |     ^^^^^^^^^^^^^^\n+\n+error[E0533]: expected unit struct/variant or constant, found struct variant `<Alias>::Variant`\n+  --> $DIR/type-alias-enum-variants-panic.rs:13:9\n+   |\n+LL |     let Alias::Variant = panic!();\n+   |         ^^^^^^^^^^^^^^\n+\n+error[E0164]: expected tuple struct/variant, found struct variant `<Alias>::Variant`\n+  --> $DIR/type-alias-enum-variants-panic.rs:15:9\n+   |\n+LL |     let Alias::Variant(..) = panic!();\n+   |         ^^^^^^^^^^^^^^^^^^ not a tuple variant or struct\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors occurred: E0164, E0533.\n+For more information about an error, try `rustc --explain E0164`."}]}