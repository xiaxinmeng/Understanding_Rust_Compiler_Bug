{"sha": "0eb575c702f56735d8bc6c3d76cb4d9bdeb13e84", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlYjU3NWM3MDJmNTY3MzVkOGJjNmMzZDc2Y2I0ZDliZGViMTNlODQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-02T13:58:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-02T13:58:11Z"}, "message": "Auto merge of #33303 - Aatch:mir-coercion-cast, r=arielb1\n\n[MIR] Handle coercion casts properly when building the MIR\n\nCoercion casts (`expr as T` where the type of `expr` can be coerced to\n`T`) are essentially no-ops, as the actual work is done by a coercion.\nPreviously a check for type equality was used to avoid emitting the\nredundant cast in the MIR, but this failed for coercion casts of\nfunction items that had lifetime parameters. The MIR trans code doesn't\nhandle `FnPtr -> FnPtr` casts and produced an error.\n\nAlso fixes a bug with type ascription expressions not having any\nadjustments applied.\n\nFixes #33295\n\n/cc @eddyb", "tree": {"sha": "bb0c0f392548a68d376211883cb4d09a91c9ef98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb0c0f392548a68d376211883cb4d09a91c9ef98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0eb575c702f56735d8bc6c3d76cb4d9bdeb13e84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0eb575c702f56735d8bc6c3d76cb4d9bdeb13e84", "html_url": "https://github.com/rust-lang/rust/commit/0eb575c702f56735d8bc6c3d76cb4d9bdeb13e84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0eb575c702f56735d8bc6c3d76cb4d9bdeb13e84/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1a575cb077d2070cc4527fa43bf9ef790f89f04", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1a575cb077d2070cc4527fa43bf9ef790f89f04", "html_url": "https://github.com/rust-lang/rust/commit/e1a575cb077d2070cc4527fa43bf9ef790f89f04"}, {"sha": "3906aef5c6df5a6d71d0a6b0c9c816b9160f9de1", "url": "https://api.github.com/repos/rust-lang/rust/commits/3906aef5c6df5a6d71d0a6b0c9c816b9160f9de1", "html_url": "https://github.com/rust-lang/rust/commit/3906aef5c6df5a6d71d0a6b0c9c816b9160f9de1"}], "stats": {"total": 842, "additions": 448, "deletions": 394}, "files": [{"sha": "88757c6873c5ffcb6d819f5ac19a9431de69f41e", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0eb575c702f56735d8bc6c3d76cb4d9bdeb13e84/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb575c702f56735d8bc6c3d76cb4d9bdeb13e84/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=0eb575c702f56735d8bc6c3d76cb4d9bdeb13e84", "patch": "@@ -87,12 +87,9 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             }\n             ExprKind::Cast { source } => {\n                 let source = this.hir.mirror(source);\n-                if source.ty == expr.ty {\n-                    this.expr_as_rvalue(block, source)\n-                } else {\n-                    let source = unpack!(block = this.as_operand(block, source));\n-                    block.and(Rvalue::Cast(CastKind::Misc, source, expr.ty))\n-                }\n+\n+                let source = unpack!(block = this.as_operand(block, source));\n+                block.and(Rvalue::Cast(CastKind::Misc, source, expr.ty))\n             }\n             ExprKind::ReifyFnPointer { source } => {\n                 let source = unpack!(block = this.as_operand(block, source));"}, {"sha": "6d527f77800f6c031c059a02db13d56343941f21", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 403, "deletions": 388, "changes": 791, "blob_url": "https://github.com/rust-lang/rust/blob/0eb575c702f56735d8bc6c3d76cb4d9bdeb13e84/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb575c702f56735d8bc6c3d76cb4d9bdeb13e84/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=0eb575c702f56735d8bc6c3d76cb4d9bdeb13e84", "patch": "@@ -21,6 +21,7 @@ use rustc_const_eval as const_eval;\n use rustc::middle::region::CodeExtent;\n use rustc::hir::pat_util;\n use rustc::ty::{self, VariantDef, Ty};\n+use rustc::ty::cast::CastKind as TyCastKind;\n use rustc::mir::repr::*;\n use rustc::hir;\n use syntax::ptr::P;\n@@ -29,398 +30,12 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n     type Output = Expr<'tcx>;\n \n     fn make_mirror<'a>(self, cx: &mut Cx<'a, 'tcx>) -> Expr<'tcx> {\n-        debug!(\"Expr::make_mirror(): id={}, span={:?}\", self.id, self.span);\n-\n-        let expr_ty = cx.tcx.expr_ty(self); // note: no adjustments (yet)!\n         let temp_lifetime = cx.tcx.region_maps.temporary_scope(self.id);\n         let expr_extent = cx.tcx.region_maps.node_extent(self.id);\n \n-        let kind = match self.node {\n-            // Here comes the interesting stuff:\n-            hir::ExprMethodCall(_, _, ref args) => {\n-                // Rewrite a.b(c) into UFCS form like Trait::b(a, c)\n-                let expr = method_callee(cx, self, ty::MethodCall::expr(self.id));\n-                let args = args.iter()\n-                               .map(|e| e.to_ref())\n-                               .collect();\n-                ExprKind::Call {\n-                    ty: expr.ty,\n-                    fun: expr.to_ref(),\n-                    args: args,\n-                }\n-            }\n-\n-            hir::ExprCall(ref fun, ref args) => {\n-                if cx.tcx.is_method_call(self.id) {\n-                    // The callee is something implementing Fn, FnMut, or FnOnce.\n-                    // Find the actual method implementation being called and\n-                    // build the appropriate UFCS call expression with the\n-                    // callee-object as self parameter.\n-\n-                    // rewrite f(u, v) into FnOnce::call_once(f, (u, v))\n-\n-                    let method = method_callee(cx, self, ty::MethodCall::expr(self.id));\n-\n-                    let sig = match method.ty.sty {\n-                        ty::TyFnDef(_, _, fn_ty) => &fn_ty.sig,\n-                        _ => span_bug!(self.span, \"type of method is not an fn\")\n-                    };\n-\n-                    let sig = cx.tcx.no_late_bound_regions(sig).unwrap_or_else(|| {\n-                        span_bug!(self.span, \"method call has late-bound regions\")\n-                    });\n-\n-                    assert_eq!(sig.inputs.len(), 2);\n-\n-                    let tupled_args = Expr {\n-                        ty: sig.inputs[1],\n-                        temp_lifetime: temp_lifetime,\n-                        span: self.span,\n-                        kind: ExprKind::Tuple {\n-                            fields: args.iter().map(ToRef::to_ref).collect()\n-                        }\n-                    };\n-\n-                    ExprKind::Call {\n-                        ty: method.ty,\n-                        fun: method.to_ref(),\n-                        args: vec![fun.to_ref(), tupled_args.to_ref()]\n-                    }\n-                } else {\n-                    let adt_data = if let hir::ExprPath(..) = fun.node {\n-                        // Tuple-like ADTs are represented as ExprCall. We convert them here.\n-                        expr_ty.ty_adt_def().and_then(|adt_def|{\n-                            match cx.tcx.def_map.borrow()[&fun.id].full_def() {\n-                                Def::Variant(_, variant_id) => {\n-                                    Some((adt_def, adt_def.variant_index_with_id(variant_id)))\n-                                },\n-                                Def::Struct(..) => {\n-                                    Some((adt_def, 0))\n-                                },\n-                                _ => None\n-                            }\n-                        })\n-                    } else { None };\n-                    if let Some((adt_def, index)) = adt_data {\n-                        let substs = cx.tcx.mk_substs(cx.tcx.node_id_item_substs(fun.id).substs);\n-                        let field_refs = args.iter().enumerate().map(|(idx, e)| FieldExprRef {\n-                            name: Field::new(idx),\n-                            expr: e.to_ref()\n-                        }).collect();\n-                        ExprKind::Adt {\n-                            adt_def: adt_def,\n-                            substs: substs,\n-                            variant_index: index,\n-                            fields: field_refs,\n-                            base: None\n-                        }\n-                    } else {\n-                        ExprKind::Call {\n-                            ty: cx.tcx.node_id_to_type(fun.id),\n-                            fun: fun.to_ref(),\n-                            args: args.to_ref(),\n-                        }\n-                    }\n-                }\n-            }\n-\n-            hir::ExprAddrOf(mutbl, ref expr) => {\n-                let region = match expr_ty.sty {\n-                    ty::TyRef(r, _) => r,\n-                    _ => span_bug!(expr.span, \"type of & not region\"),\n-                };\n-                ExprKind::Borrow {\n-                    region: *region,\n-                    borrow_kind: to_borrow_kind(mutbl),\n-                    arg: expr.to_ref(),\n-                }\n-            }\n-\n-            hir::ExprBlock(ref blk) => {\n-                ExprKind::Block { body: &blk }\n-            }\n-\n-            hir::ExprAssign(ref lhs, ref rhs) => {\n-                ExprKind::Assign {\n-                    lhs: lhs.to_ref(),\n-                    rhs: rhs.to_ref(),\n-                }\n-            }\n-\n-            hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n-                if cx.tcx.is_method_call(self.id) {\n-                    let pass_args = if op.node.is_by_value() {\n-                        PassArgs::ByValue\n-                    } else {\n-                        PassArgs::ByRef\n-                    };\n-                    overloaded_operator(cx, self, ty::MethodCall::expr(self.id),\n-                                        pass_args, lhs.to_ref(), vec![rhs])\n-                } else {\n-                    ExprKind::AssignOp {\n-                        op: bin_op(op.node),\n-                        lhs: lhs.to_ref(),\n-                        rhs: rhs.to_ref(),\n-                    }\n-                }\n-            }\n-\n-            hir::ExprLit(..) => ExprKind::Literal {\n-                literal: cx.const_eval_literal(self)\n-            },\n-\n-            hir::ExprBinary(op, ref lhs, ref rhs) => {\n-                if cx.tcx.is_method_call(self.id) {\n-                    let pass_args = if op.node.is_by_value() {\n-                        PassArgs::ByValue\n-                    } else {\n-                        PassArgs::ByRef\n-                    };\n-                    overloaded_operator(cx, self, ty::MethodCall::expr(self.id),\n-                                        pass_args, lhs.to_ref(), vec![rhs])\n-                } else {\n-                    // FIXME overflow\n-                    match op.node {\n-                        hir::BinOp_::BiAnd => {\n-                            ExprKind::LogicalOp {\n-                                op: LogicalOp::And,\n-                                lhs: lhs.to_ref(),\n-                                rhs: rhs.to_ref(),\n-                            }\n-                        }\n-                        hir::BinOp_::BiOr => {\n-                            ExprKind::LogicalOp {\n-                                op: LogicalOp::Or,\n-                                lhs: lhs.to_ref(),\n-                                rhs: rhs.to_ref(),\n-                            }\n-                        }\n-                        _ => {\n-                            let op = bin_op(op.node);\n-                            ExprKind::Binary {\n-                                op: op,\n-                                lhs: lhs.to_ref(),\n-                                rhs: rhs.to_ref(),\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-\n-            hir::ExprIndex(ref lhs, ref index) => {\n-                if cx.tcx.is_method_call(self.id) {\n-                    overloaded_lvalue(cx, self, ty::MethodCall::expr(self.id),\n-                                      PassArgs::ByValue, lhs.to_ref(), vec![index])\n-                } else {\n-                    ExprKind::Index {\n-                        lhs: lhs.to_ref(),\n-                        index: index.to_ref(),\n-                    }\n-                }\n-            }\n-\n-            hir::ExprUnary(hir::UnOp::UnDeref, ref arg) => {\n-                if cx.tcx.is_method_call(self.id) {\n-                    overloaded_lvalue(cx, self, ty::MethodCall::expr(self.id),\n-                                      PassArgs::ByValue, arg.to_ref(), vec![])\n-                } else {\n-                    ExprKind::Deref { arg: arg.to_ref() }\n-                }\n-            }\n-\n-            hir::ExprUnary(hir::UnOp::UnNot, ref arg) => {\n-                if cx.tcx.is_method_call(self.id) {\n-                    overloaded_operator(cx, self, ty::MethodCall::expr(self.id),\n-                                        PassArgs::ByValue, arg.to_ref(), vec![])\n-                } else {\n-                    ExprKind::Unary {\n-                        op: UnOp::Not,\n-                        arg: arg.to_ref(),\n-                    }\n-                }\n-            }\n-\n-            hir::ExprUnary(hir::UnOp::UnNeg, ref arg) => {\n-                if cx.tcx.is_method_call(self.id) {\n-                    overloaded_operator(cx, self, ty::MethodCall::expr(self.id),\n-                                        PassArgs::ByValue, arg.to_ref(), vec![])\n-                } else {\n-                    // FIXME runtime-overflow\n-                    if let hir::ExprLit(_) = arg.node {\n-                        ExprKind::Literal {\n-                            literal: cx.const_eval_literal(self),\n-                        }\n-                    } else {\n-                        ExprKind::Unary {\n-                            op: UnOp::Neg,\n-                            arg: arg.to_ref(),\n-                        }\n-                    }\n-                }\n-            }\n-\n-            hir::ExprStruct(_, ref fields, ref base) => {\n-                match expr_ty.sty {\n-                    ty::TyStruct(adt, substs) => {\n-                        let field_refs = field_refs(&adt.variants[0], fields);\n-                        ExprKind::Adt {\n-                            adt_def: adt,\n-                            variant_index: 0,\n-                            substs: substs,\n-                            fields: field_refs,\n-                            base: base.as_ref().map(|base| {\n-                                FruInfo {\n-                                    base: base.to_ref(),\n-                                    field_types: cx.tcx.tables\n-                                        .borrow()\n-                                        .fru_field_types[&self.id]\n-                                        .clone()\n-                                }\n-                            })\n-                        }\n-                    }\n-                    ty::TyEnum(adt, substs) => {\n-                        match cx.tcx.def_map.borrow()[&self.id].full_def() {\n-                            Def::Variant(enum_id, variant_id) => {\n-                                debug_assert!(adt.did == enum_id);\n-                                assert!(base.is_none());\n-\n-                                let index = adt.variant_index_with_id(variant_id);\n-                                let field_refs = field_refs(&adt.variants[index], fields);\n-                                ExprKind::Adt {\n-                                    adt_def: adt,\n-                                    variant_index: index,\n-                                    substs: substs,\n-                                    fields: field_refs,\n-                                    base: None\n-                                }\n-                            }\n-                            ref def => {\n-                                span_bug!(\n-                                    self.span,\n-                                    \"unexpected def: {:?}\",\n-                                    def);\n-                            }\n-                        }\n-                    }\n-                    _ => {\n-                        span_bug!(\n-                            self.span,\n-                            \"unexpected type for struct literal: {:?}\",\n-                            expr_ty);\n-                    }\n-                }\n-            }\n-\n-            hir::ExprClosure(..) => {\n-                let closure_ty = cx.tcx.expr_ty(self);\n-                let (def_id, substs) = match closure_ty.sty {\n-                    ty::TyClosure(def_id, ref substs) => (def_id, substs),\n-                    _ => {\n-                        span_bug!(self.span,\n-                                  \"closure expr w/o closure type: {:?}\",\n-                                  closure_ty);\n-                    }\n-                };\n-                let upvars = cx.tcx.with_freevars(self.id, |freevars| {\n-                    freevars.iter()\n-                            .enumerate()\n-                            .map(|(i, fv)| capture_freevar(cx, self, fv, substs.upvar_tys[i]))\n-                            .collect()\n-                });\n-                ExprKind::Closure {\n-                    closure_id: def_id,\n-                    substs: &substs,\n-                    upvars: upvars,\n-                }\n-            }\n-\n-            hir::ExprPath(..) => {\n-                convert_path_expr(cx, self)\n-            }\n-\n-            hir::ExprInlineAsm(ref asm, ref outputs, ref inputs) => {\n-                ExprKind::InlineAsm {\n-                    asm: asm,\n-                    outputs: outputs.to_ref(),\n-                    inputs: inputs.to_ref()\n-                }\n-            }\n-\n-            // Now comes the rote stuff:\n-\n-            hir::ExprRepeat(ref v, ref c) => ExprKind::Repeat {\n-                value: v.to_ref(),\n-                count: TypedConstVal {\n-                    ty: cx.tcx.expr_ty(c),\n-                    span: c.span,\n-                    value: match const_eval::eval_const_expr(cx.tcx, c) {\n-                        ConstVal::Integral(ConstInt::Usize(u)) => u,\n-                        other => bug!(\"constant evaluation of repeat count yielded {:?}\", other),\n-                    },\n-                }\n-            },\n-            hir::ExprRet(ref v) =>\n-                ExprKind::Return { value: v.to_ref() },\n-            hir::ExprBreak(label) =>\n-                ExprKind::Break { label: label.map(|_| loop_label(cx, self)) },\n-            hir::ExprAgain(label) =>\n-                ExprKind::Continue { label: label.map(|_| loop_label(cx, self)) },\n-            hir::ExprMatch(ref discr, ref arms, _) =>\n-                ExprKind::Match { discriminant: discr.to_ref(),\n-                                  arms: arms.iter().map(|a| convert_arm(cx, a)).collect() },\n-            hir::ExprIf(ref cond, ref then, ref otherwise) =>\n-                ExprKind::If { condition: cond.to_ref(),\n-                               then: block::to_expr_ref(cx, then),\n-                               otherwise: otherwise.to_ref() },\n-            hir::ExprWhile(ref cond, ref body, _) =>\n-                ExprKind::Loop { condition: Some(cond.to_ref()),\n-                                 body: block::to_expr_ref(cx, body) },\n-            hir::ExprLoop(ref body, _) =>\n-                ExprKind::Loop { condition: None,\n-                                 body: block::to_expr_ref(cx, body) },\n-            hir::ExprField(ref source, name) => {\n-                let index = match cx.tcx.expr_ty_adjusted(source).sty {\n-                    ty::TyStruct(adt_def, _) =>\n-                        adt_def.variants[0].index_of_field_named(name.node),\n-                    ref ty =>\n-                        span_bug!(\n-                            self.span,\n-                            \"field of non-struct: {:?}\",\n-                            ty),\n-                };\n-                let index = index.unwrap_or_else(|| {\n-                    span_bug!(\n-                        self.span,\n-                        \"no index found for field `{}`\",\n-                        name.node)\n-                });\n-                ExprKind::Field { lhs: source.to_ref(), name: Field::new(index) }\n-            }\n-            hir::ExprTupField(ref source, index) =>\n-                ExprKind::Field { lhs: source.to_ref(),\n-                                  name: Field::new(index.node as usize) },\n-            hir::ExprCast(ref source, _) =>\n-                ExprKind::Cast { source: source.to_ref() },\n-            hir::ExprType(ref source, _) =>\n-                return source.make_mirror(cx),\n-            hir::ExprBox(ref value) =>\n-                ExprKind::Box {\n-                    value: value.to_ref(),\n-                    value_extents: cx.tcx.region_maps.node_extent(value.id)\n-                },\n-            hir::ExprVec(ref fields) =>\n-                ExprKind::Vec { fields: fields.to_ref() },\n-            hir::ExprTup(ref fields) =>\n-                ExprKind::Tuple { fields: fields.to_ref() },\n-        };\n+        debug!(\"Expr::make_mirror(): id={}, span={:?}\", self.id, self.span);\n \n-        let mut expr = Expr {\n-            temp_lifetime: temp_lifetime,\n-            ty: expr_ty,\n-            span: self.span,\n-            kind: kind,\n-        };\n+        let mut expr = make_mirror_unadjusted(cx, self);\n \n         debug!(\"make_mirror: unadjusted-expr={:?} applying adjustments={:?}\",\n                expr, cx.tcx.tables.borrow().adjustments.get(&self.id));\n@@ -587,6 +202,406 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n     }\n }\n \n+fn make_mirror_unadjusted<'a, 'tcx>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr) -> Expr<'tcx> {\n+    let expr_ty = cx.tcx.expr_ty(expr);\n+    let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n+\n+    let kind = match expr.node {\n+        // Here comes the interesting stuff:\n+        hir::ExprMethodCall(_, _, ref args) => {\n+            // Rewrite a.b(c) into UFCS form like Trait::b(a, c)\n+            let expr = method_callee(cx, expr, ty::MethodCall::expr(expr.id));\n+            let args = args.iter()\n+                .map(|e| e.to_ref())\n+                .collect();\n+            ExprKind::Call {\n+                ty: expr.ty,\n+                fun: expr.to_ref(),\n+                args: args,\n+            }\n+        }\n+\n+        hir::ExprCall(ref fun, ref args) => {\n+            if cx.tcx.is_method_call(expr.id) {\n+                // The callee is something implementing Fn, FnMut, or FnOnce.\n+                // Find the actual method implementation being called and\n+                // build the appropriate UFCS call expression with the\n+                // callee-object as expr parameter.\n+\n+                // rewrite f(u, v) into FnOnce::call_once(f, (u, v))\n+\n+                let method = method_callee(cx, expr, ty::MethodCall::expr(expr.id));\n+\n+                let sig = match method.ty.sty {\n+                    ty::TyFnDef(_, _, fn_ty) => &fn_ty.sig,\n+                    _ => span_bug!(expr.span, \"type of method is not an fn\")\n+                };\n+\n+                let sig = cx.tcx.no_late_bound_regions(sig).unwrap_or_else(|| {\n+                    span_bug!(expr.span, \"method call has late-bound regions\")\n+                });\n+\n+                assert_eq!(sig.inputs.len(), 2);\n+\n+                let tupled_args = Expr {\n+                    ty: sig.inputs[1],\n+                    temp_lifetime: temp_lifetime,\n+                    span: expr.span,\n+                    kind: ExprKind::Tuple {\n+                        fields: args.iter().map(ToRef::to_ref).collect()\n+                    }\n+                };\n+\n+                ExprKind::Call {\n+                    ty: method.ty,\n+                    fun: method.to_ref(),\n+                    args: vec![fun.to_ref(), tupled_args.to_ref()]\n+                }\n+            } else {\n+                let adt_data = if let hir::ExprPath(..) = fun.node {\n+                    // Tuple-like ADTs are represented as ExprCall. We convert them here.\n+                    expr_ty.ty_adt_def().and_then(|adt_def|{\n+                        match cx.tcx.def_map.borrow()[&fun.id].full_def() {\n+                            Def::Variant(_, variant_id) => {\n+                                Some((adt_def, adt_def.variant_index_with_id(variant_id)))\n+                            },\n+                            Def::Struct(..) => {\n+                                Some((adt_def, 0))\n+                            },\n+                            _ => None\n+                        }\n+                    })\n+                } else { None };\n+                if let Some((adt_def, index)) = adt_data {\n+                    let substs = cx.tcx.mk_substs(cx.tcx.node_id_item_substs(fun.id).substs);\n+                    let field_refs = args.iter().enumerate().map(|(idx, e)| FieldExprRef {\n+                        name: Field::new(idx),\n+                        expr: e.to_ref()\n+                    }).collect();\n+                    ExprKind::Adt {\n+                        adt_def: adt_def,\n+                        substs: substs,\n+                        variant_index: index,\n+                        fields: field_refs,\n+                        base: None\n+                    }\n+                } else {\n+                    ExprKind::Call {\n+                        ty: cx.tcx.node_id_to_type(fun.id),\n+                        fun: fun.to_ref(),\n+                        args: args.to_ref(),\n+                    }\n+                }\n+            }\n+        }\n+\n+        hir::ExprAddrOf(mutbl, ref expr) => {\n+            let region = match expr_ty.sty {\n+                ty::TyRef(r, _) => r,\n+                _ => span_bug!(expr.span, \"type of & not region\"),\n+            };\n+            ExprKind::Borrow {\n+                region: *region,\n+                borrow_kind: to_borrow_kind(mutbl),\n+                arg: expr.to_ref(),\n+            }\n+        }\n+\n+        hir::ExprBlock(ref blk) => {\n+            ExprKind::Block { body: &blk }\n+        }\n+\n+        hir::ExprAssign(ref lhs, ref rhs) => {\n+            ExprKind::Assign {\n+                lhs: lhs.to_ref(),\n+                rhs: rhs.to_ref(),\n+            }\n+        }\n+\n+        hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n+            if cx.tcx.is_method_call(expr.id) {\n+                let pass_args = if op.node.is_by_value() {\n+                    PassArgs::ByValue\n+                } else {\n+                    PassArgs::ByRef\n+                };\n+                overloaded_operator(cx, expr, ty::MethodCall::expr(expr.id),\n+                                    pass_args, lhs.to_ref(), vec![rhs])\n+            } else {\n+                ExprKind::AssignOp {\n+                    op: bin_op(op.node),\n+                    lhs: lhs.to_ref(),\n+                    rhs: rhs.to_ref(),\n+                }\n+            }\n+        }\n+\n+        hir::ExprLit(..) => ExprKind::Literal {\n+            literal: cx.const_eval_literal(expr)\n+        },\n+\n+        hir::ExprBinary(op, ref lhs, ref rhs) => {\n+            if cx.tcx.is_method_call(expr.id) {\n+                let pass_args = if op.node.is_by_value() {\n+                    PassArgs::ByValue\n+                } else {\n+                    PassArgs::ByRef\n+                };\n+                overloaded_operator(cx, expr, ty::MethodCall::expr(expr.id),\n+                                    pass_args, lhs.to_ref(), vec![rhs])\n+            } else {\n+                // FIXME overflow\n+                match op.node {\n+                    hir::BinOp_::BiAnd => {\n+                        ExprKind::LogicalOp {\n+                            op: LogicalOp::And,\n+                            lhs: lhs.to_ref(),\n+                            rhs: rhs.to_ref(),\n+                        }\n+                    }\n+                    hir::BinOp_::BiOr => {\n+                        ExprKind::LogicalOp {\n+                            op: LogicalOp::Or,\n+                            lhs: lhs.to_ref(),\n+                            rhs: rhs.to_ref(),\n+                        }\n+                    }\n+                    _ => {\n+                        let op = bin_op(op.node);\n+                        ExprKind::Binary {\n+                            op: op,\n+                            lhs: lhs.to_ref(),\n+                            rhs: rhs.to_ref(),\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        hir::ExprIndex(ref lhs, ref index) => {\n+            if cx.tcx.is_method_call(expr.id) {\n+                overloaded_lvalue(cx, expr, ty::MethodCall::expr(expr.id),\n+                                  PassArgs::ByValue, lhs.to_ref(), vec![index])\n+            } else {\n+                ExprKind::Index {\n+                    lhs: lhs.to_ref(),\n+                    index: index.to_ref(),\n+                }\n+            }\n+        }\n+\n+        hir::ExprUnary(hir::UnOp::UnDeref, ref arg) => {\n+            if cx.tcx.is_method_call(expr.id) {\n+                overloaded_lvalue(cx, expr, ty::MethodCall::expr(expr.id),\n+                                  PassArgs::ByValue, arg.to_ref(), vec![])\n+            } else {\n+                ExprKind::Deref { arg: arg.to_ref() }\n+            }\n+        }\n+\n+        hir::ExprUnary(hir::UnOp::UnNot, ref arg) => {\n+            if cx.tcx.is_method_call(expr.id) {\n+                overloaded_operator(cx, expr, ty::MethodCall::expr(expr.id),\n+                                    PassArgs::ByValue, arg.to_ref(), vec![])\n+            } else {\n+                ExprKind::Unary {\n+                    op: UnOp::Not,\n+                    arg: arg.to_ref(),\n+                }\n+            }\n+        }\n+\n+        hir::ExprUnary(hir::UnOp::UnNeg, ref arg) => {\n+            if cx.tcx.is_method_call(expr.id) {\n+                overloaded_operator(cx, expr, ty::MethodCall::expr(expr.id),\n+                                    PassArgs::ByValue, arg.to_ref(), vec![])\n+            } else {\n+                // FIXME runtime-overflow\n+                if let hir::ExprLit(_) = arg.node {\n+                    ExprKind::Literal {\n+                        literal: cx.const_eval_literal(expr),\n+                    }\n+                } else {\n+                    ExprKind::Unary {\n+                        op: UnOp::Neg,\n+                        arg: arg.to_ref(),\n+                    }\n+                }\n+            }\n+        }\n+\n+        hir::ExprStruct(_, ref fields, ref base) => {\n+            match expr_ty.sty {\n+                ty::TyStruct(adt, substs) => {\n+                    let field_refs = field_refs(&adt.variants[0], fields);\n+                    ExprKind::Adt {\n+                        adt_def: adt,\n+                        variant_index: 0,\n+                        substs: substs,\n+                        fields: field_refs,\n+                        base: base.as_ref().map(|base| {\n+                            FruInfo {\n+                                base: base.to_ref(),\n+                                field_types: cx.tcx.tables\n+                                    .borrow()\n+                                    .fru_field_types[&expr.id]\n+                                    .clone()\n+                            }\n+                        })\n+                    }\n+                }\n+                ty::TyEnum(adt, substs) => {\n+                    match cx.tcx.def_map.borrow()[&expr.id].full_def() {\n+                        Def::Variant(enum_id, variant_id) => {\n+                            debug_assert!(adt.did == enum_id);\n+                            assert!(base.is_none());\n+\n+                            let index = adt.variant_index_with_id(variant_id);\n+                            let field_refs = field_refs(&adt.variants[index], fields);\n+                            ExprKind::Adt {\n+                                adt_def: adt,\n+                                variant_index: index,\n+                                substs: substs,\n+                                fields: field_refs,\n+                                base: None\n+                            }\n+                        }\n+                        ref def => {\n+                            span_bug!(\n+                                expr.span,\n+                                \"unexpected def: {:?}\",\n+                                def);\n+                        }\n+                    }\n+                }\n+                _ => {\n+                    span_bug!(\n+                        expr.span,\n+                        \"unexpected type for struct literal: {:?}\",\n+                        expr_ty);\n+                }\n+            }\n+        }\n+\n+        hir::ExprClosure(..) => {\n+            let closure_ty = cx.tcx.expr_ty(expr);\n+            let (def_id, substs) = match closure_ty.sty {\n+                ty::TyClosure(def_id, ref substs) => (def_id, substs),\n+                _ => {\n+                    span_bug!(expr.span,\n+                              \"closure expr w/o closure type: {:?}\",\n+                              closure_ty);\n+                }\n+            };\n+            let upvars = cx.tcx.with_freevars(expr.id, |freevars| {\n+                freevars.iter()\n+                    .enumerate()\n+                    .map(|(i, fv)| capture_freevar(cx, expr, fv, substs.upvar_tys[i]))\n+                    .collect()\n+            });\n+            ExprKind::Closure {\n+                closure_id: def_id,\n+                substs: &substs,\n+                upvars: upvars,\n+            }\n+        }\n+\n+        hir::ExprPath(..) => {\n+            convert_path_expr(cx, expr)\n+        }\n+\n+        hir::ExprInlineAsm(ref asm, ref outputs, ref inputs) => {\n+            ExprKind::InlineAsm {\n+                asm: asm,\n+                outputs: outputs.to_ref(),\n+                inputs: inputs.to_ref()\n+            }\n+        }\n+\n+        // Now comes the rote stuff:\n+\n+        hir::ExprRepeat(ref v, ref c) => ExprKind::Repeat {\n+            value: v.to_ref(),\n+            count: TypedConstVal {\n+                ty: cx.tcx.expr_ty(c),\n+                span: c.span,\n+                value: match const_eval::eval_const_expr(cx.tcx, c) {\n+                    ConstVal::Integral(ConstInt::Usize(u)) => u,\n+                    other => bug!(\"constant evaluation of repeat count yielded {:?}\", other),\n+                },\n+            }\n+        },\n+        hir::ExprRet(ref v) =>\n+            ExprKind::Return { value: v.to_ref() },\n+        hir::ExprBreak(label) =>\n+            ExprKind::Break { label: label.map(|_| loop_label(cx, expr)) },\n+        hir::ExprAgain(label) =>\n+            ExprKind::Continue { label: label.map(|_| loop_label(cx, expr)) },\n+        hir::ExprMatch(ref discr, ref arms, _) =>\n+            ExprKind::Match { discriminant: discr.to_ref(),\n+                              arms: arms.iter().map(|a| convert_arm(cx, a)).collect() },\n+        hir::ExprIf(ref cond, ref then, ref otherwise) =>\n+            ExprKind::If { condition: cond.to_ref(),\n+                           then: block::to_expr_ref(cx, then),\n+                           otherwise: otherwise.to_ref() },\n+        hir::ExprWhile(ref cond, ref body, _) =>\n+            ExprKind::Loop { condition: Some(cond.to_ref()),\n+                             body: block::to_expr_ref(cx, body) },\n+        hir::ExprLoop(ref body, _) =>\n+            ExprKind::Loop { condition: None,\n+                             body: block::to_expr_ref(cx, body) },\n+        hir::ExprField(ref source, name) => {\n+            let index = match cx.tcx.expr_ty_adjusted(source).sty {\n+                ty::TyStruct(adt_def, _) =>\n+                    adt_def.variants[0].index_of_field_named(name.node),\n+                ref ty =>\n+                    span_bug!(\n+                        expr.span,\n+                        \"field of non-struct: {:?}\",\n+                        ty),\n+            };\n+            let index = index.unwrap_or_else(|| {\n+                span_bug!(\n+                    expr.span,\n+                    \"no index found for field `{}`\",\n+                    name.node)\n+            });\n+            ExprKind::Field { lhs: source.to_ref(), name: Field::new(index) }\n+        }\n+        hir::ExprTupField(ref source, index) =>\n+            ExprKind::Field { lhs: source.to_ref(),\n+                              name: Field::new(index.node as usize) },\n+        hir::ExprCast(ref source, _) => {\n+            // Check to see if this cast is a \"coercion cast\", where the cast is actually done\n+            // using a coercion (or is a no-op).\n+            if let Some(&TyCastKind::CoercionCast) = cx.tcx.cast_kinds.borrow().get(&source.id) {\n+                // Skip the actual cast itexpr, as it's now a no-op.\n+                return source.make_mirror(cx);\n+            } else {\n+                ExprKind::Cast { source: source.to_ref() }\n+            }\n+        }\n+        hir::ExprType(ref source, _) =>\n+            return source.make_mirror(cx),\n+        hir::ExprBox(ref value) =>\n+            ExprKind::Box {\n+                value: value.to_ref(),\n+                value_extents: cx.tcx.region_maps.node_extent(value.id)\n+            },\n+        hir::ExprVec(ref fields) =>\n+            ExprKind::Vec { fields: fields.to_ref() },\n+        hir::ExprTup(ref fields) =>\n+            ExprKind::Tuple { fields: fields.to_ref() },\n+    };\n+\n+    Expr {\n+        temp_lifetime: temp_lifetime,\n+        ty: expr_ty,\n+        span: expr.span,\n+        kind: kind,\n+    }\n+}\n+\n fn method_callee<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,\n                                expr: &hir::Expr,\n                                method_call: ty::MethodCall)"}, {"sha": "b227be9c543b21d427b27343f7b12c631a6db86b", "filename": "src/test/run-pass/mir_ascription_coercion.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0eb575c702f56735d8bc6c3d76cb4d9bdeb13e84/src%2Ftest%2Frun-pass%2Fmir_ascription_coercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb575c702f56735d8bc6c3d76cb4d9bdeb13e84/src%2Ftest%2Frun-pass%2Fmir_ascription_coercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_ascription_coercion.rs?ref=0eb575c702f56735d8bc6c3d76cb4d9bdeb13e84", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that the result of type ascription has adjustments applied\n+\n+#![feature(rustc_attrs, type_ascription)]\n+\n+#[rustc_mir]\n+fn main() {\n+    let x = [1, 2, 3];\n+    // The RHS should coerce to &[i32]\n+    let _y : &[i32] = &x : &[i32; 3];\n+}"}, {"sha": "4d5c59276d7506a056c77915d6007cc65cd0b5c3", "filename": "src/test/run-pass/mir_coercion_casts.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0eb575c702f56735d8bc6c3d76cb4d9bdeb13e84/src%2Ftest%2Frun-pass%2Fmir_coercion_casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb575c702f56735d8bc6c3d76cb4d9bdeb13e84/src%2Ftest%2Frun-pass%2Fmir_coercion_casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_coercion_casts.rs?ref=0eb575c702f56735d8bc6c3d76cb4d9bdeb13e84", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests the coercion casts are handled properly\n+\n+#![feature(rustc_attrs)]\n+\n+#[rustc_mir]\n+fn main() {\n+    // This should produce only a reification of f,\n+    // not a fn -> fn cast as well\n+    let _ = f as fn(&());\n+}\n+\n+fn f<'a>(_: &'a ()) { }"}]}