{"sha": "d831141638f59b7f3aca28de33d089d7e74ac3fd", "node_id": "C_kwDOAAsO6NoAKGQ4MzExNDE2MzhmNTliN2YzYWNhMjhkZTMzZDA4OWQ3ZTc0YWMzZmQ", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2023-05-05T15:28:28Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2023-05-22T16:58:28Z"}, "message": "rustc_privacy: Remove some `Option`s\n\nin cases where they are guaranteed to be `Some`", "tree": {"sha": "a95c4a1b5018047ae9856c46cf501f22142100ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a95c4a1b5018047ae9856c46cf501f22142100ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d831141638f59b7f3aca28de33d089d7e74ac3fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d831141638f59b7f3aca28de33d089d7e74ac3fd", "html_url": "https://github.com/rust-lang/rust/commit/d831141638f59b7f3aca28de33d089d7e74ac3fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d831141638f59b7f3aca28de33d089d7e74ac3fd/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3b830d4dafd90abed6206879b3556a0fa13d315", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3b830d4dafd90abed6206879b3556a0fa13d315", "html_url": "https://github.com/rust-lang/rust/commit/e3b830d4dafd90abed6206879b3556a0fa13d315"}], "stats": {"total": 57, "additions": 25, "deletions": 32}, "files": [{"sha": "8eabb3a31a5bf73bafaa7b95c38db0f5f192e243", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 25, "deletions": 32, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/d831141638f59b7f3aca28de33d089d7e74ac3fd/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d831141638f59b7f3aca28de33d089d7e74ac3fd/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=d831141638f59b7f3aca28de33d089d7e74ac3fd", "patch": "@@ -459,7 +459,7 @@ struct EmbargoVisitor<'tcx> {\n }\n \n struct ReachEverythingInTheInterfaceVisitor<'a, 'tcx> {\n-    effective_vis: Option<EffectiveVisibility>,\n+    effective_vis: EffectiveVisibility,\n     item_def_id: LocalDefId,\n     ev: &'a mut EmbargoVisitor<'tcx>,\n     level: Level,\n@@ -507,7 +507,7 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n     fn reach(\n         &mut self,\n         def_id: LocalDefId,\n-        effective_vis: Option<EffectiveVisibility>,\n+        effective_vis: EffectiveVisibility,\n     ) -> ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n         ReachEverythingInTheInterfaceVisitor {\n             effective_vis,\n@@ -520,7 +520,7 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n     fn reach_through_impl_trait(\n         &mut self,\n         def_id: LocalDefId,\n-        effective_vis: Option<EffectiveVisibility>,\n+        effective_vis: EffectiveVisibility,\n     ) -> ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n         ReachEverythingInTheInterfaceVisitor {\n             effective_vis,\n@@ -554,8 +554,8 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n         // Since we are starting from an externally visible module,\n         // all the parents in the loop below are also guaranteed to be modules.\n         let mut module_def_id = macro_module_def_id;\n-        let macro_ev = self.get(local_def_id);\n-        assert!(macro_ev.is_some());\n+        // If the macro eff vis is not in the table the condition above will return.\n+        let macro_ev = self.get(local_def_id).unwrap();\n         loop {\n             let changed_reachability =\n                 self.update_macro_reachable(module_def_id, macro_module_def_id, macro_ev);\n@@ -572,7 +572,7 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n         &mut self,\n         module_def_id: LocalDefId,\n         defining_mod: LocalDefId,\n-        macro_ev: Option<EffectiveVisibility>,\n+        macro_ev: EffectiveVisibility,\n     ) -> bool {\n         if self.macro_reachable.insert((module_def_id, defining_mod)) {\n             self.update_macro_reachable_mod(module_def_id, defining_mod, macro_ev);\n@@ -586,7 +586,7 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n         &mut self,\n         module_def_id: LocalDefId,\n         defining_mod: LocalDefId,\n-        macro_ev: Option<EffectiveVisibility>,\n+        macro_ev: EffectiveVisibility,\n     ) {\n         let module = self.tcx.hir().get_module(module_def_id).0;\n         for item_id in module.item_ids {\n@@ -618,14 +618,14 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n         def_kind: DefKind,\n         vis: ty::Visibility,\n         module: LocalDefId,\n-        macro_ev: Option<EffectiveVisibility>,\n+        macro_ev: EffectiveVisibility,\n     ) {\n-        self.update(def_id, macro_ev, Level::Reachable);\n+        self.update(def_id, Some(macro_ev), Level::Reachable);\n         match def_kind {\n             // No type privacy, so can be directly marked as reachable.\n             DefKind::Const | DefKind::Static(_) | DefKind::TraitAlias | DefKind::TyAlias => {\n                 if vis.is_accessible_from(module, self.tcx) {\n-                    self.update(def_id, macro_ev, Level::Reachable);\n+                    self.update(def_id, Some(macro_ev), Level::Reachable);\n                 }\n             }\n \n@@ -637,7 +637,7 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n                 let item = self.tcx.hir().expect_item(def_id);\n                 if let hir::ItemKind::Macro(MacroDef { macro_rules: false, .. }, _) = item.kind {\n                     if vis.is_accessible_from(module, self.tcx) {\n-                        self.update(def_id, macro_ev, Level::Reachable);\n+                        self.update(def_id, Some(macro_ev), Level::Reachable);\n                     }\n                 }\n             }\n@@ -790,7 +790,7 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     // FIXME: This is some serious pessimization intended to workaround deficiencies\n                     // in the reachability pass (`middle/reachable.rs`). Types are marked as link-time\n                     // reachable if they are returned via `impl Trait`, even from private functions.\n-                    let exist_ev = Some(EffectiveVisibility::from_vis(ty::Visibility::Public));\n+                    let exist_ev = EffectiveVisibility::from_vis(ty::Visibility::Public);\n                     self.reach_through_impl_trait(item.owner_id.def_id, exist_ev)\n                         .generics()\n                         .predicates()\n@@ -802,12 +802,12 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             | hir::ItemKind::Static(..)\n             | hir::ItemKind::Fn(..)\n             | hir::ItemKind::TyAlias(..) => {\n-                if item_ev.is_some() {\n+                if let Some(item_ev) = item_ev {\n                     self.reach(item.owner_id.def_id, item_ev).generics().predicates().ty();\n                 }\n             }\n             hir::ItemKind::Trait(.., trait_item_refs) => {\n-                if item_ev.is_some() {\n+                if let Some(item_ev) = item_ev {\n                     self.reach(item.owner_id.def_id, item_ev).generics().predicates();\n \n                     for trait_item_ref in trait_item_refs {\n@@ -827,23 +827,21 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                 }\n             }\n             hir::ItemKind::TraitAlias(..) => {\n-                if item_ev.is_some() {\n+                if let Some(item_ev) = item_ev {\n                     self.reach(item.owner_id.def_id, item_ev).generics().predicates();\n                 }\n             }\n             // Visit everything except for private impl items.\n             hir::ItemKind::Impl(ref impl_) => {\n-                if item_ev.is_some() {\n+                if let Some(item_ev) = item_ev {\n                     self.reach(item.owner_id.def_id, item_ev)\n                         .generics()\n                         .predicates()\n                         .ty()\n                         .trait_ref();\n \n                     for impl_item_ref in impl_.items {\n-                        let impl_item_ev = self.get(impl_item_ref.id.owner_id.def_id);\n-\n-                        if impl_item_ev.is_some() {\n+                        if let Some(impl_item_ev) = self.get(impl_item_ref.id.owner_id.def_id) {\n                             self.reach(impl_item_ref.id.owner_id.def_id, impl_item_ev)\n                                 .generics()\n                                 .predicates()\n@@ -855,12 +853,11 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n \n             // Visit everything, but enum variants have their own levels.\n             hir::ItemKind::Enum(ref def, _) => {\n-                if item_ev.is_some() {\n+                if let Some(item_ev) = item_ev {\n                     self.reach(item.owner_id.def_id, item_ev).generics().predicates();\n                 }\n                 for variant in def.variants {\n-                    let variant_ev = self.get(variant.def_id);\n-                    if variant_ev.is_some() {\n+                    if let Some(variant_ev) = self.get(variant.def_id) {\n                         for field in variant.data.fields() {\n                             self.reach(field.def_id, variant_ev).ty();\n                         }\n@@ -869,8 +866,7 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                         self.reach(item.owner_id.def_id, variant_ev).ty();\n                     }\n                     if let Some(ctor_def_id) = variant.data.ctor_def_id() {\n-                        let ctor_ev = self.get(ctor_def_id);\n-                        if ctor_ev.is_some() {\n+                        if let Some(ctor_ev) = self.get(ctor_def_id) {\n                             self.reach(item.owner_id.def_id, ctor_ev).ty();\n                         }\n                     }\n@@ -879,8 +875,7 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             // Visit everything, but foreign items have their own levels.\n             hir::ItemKind::ForeignMod { items, .. } => {\n                 for foreign_item in items {\n-                    let foreign_item_ev = self.get(foreign_item.id.owner_id.def_id);\n-                    if foreign_item_ev.is_some() {\n+                    if let Some(foreign_item_ev) = self.get(foreign_item.id.owner_id.def_id) {\n                         self.reach(foreign_item.id.owner_id.def_id, foreign_item_ev)\n                             .generics()\n                             .predicates()\n@@ -890,18 +885,16 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             }\n             // Visit everything except for private fields.\n             hir::ItemKind::Struct(ref struct_def, _) | hir::ItemKind::Union(ref struct_def, _) => {\n-                if item_ev.is_some() {\n+                if let Some(item_ev) = item_ev {\n                     self.reach(item.owner_id.def_id, item_ev).generics().predicates();\n                     for field in struct_def.fields() {\n-                        let field_ev = self.get(field.def_id);\n-                        if field_ev.is_some() {\n+                        if let Some(field_ev) = self.get(field.def_id) {\n                             self.reach(field.def_id, field_ev).ty();\n                         }\n                     }\n                 }\n                 if let Some(ctor_def_id) = struct_def.ctor_def_id() {\n-                    let ctor_ev = self.get(ctor_def_id);\n-                    if ctor_ev.is_some() {\n+                    if let Some(ctor_ev) = self.get(ctor_def_id) {\n                         self.reach(item.owner_id.def_id, ctor_ev).ty();\n                     }\n                 }\n@@ -960,7 +953,7 @@ impl<'tcx> DefIdVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'tcx>\n         _descr: &dyn fmt::Display,\n     ) -> ControlFlow<Self::BreakTy> {\n         if let Some(def_id) = def_id.as_local() {\n-            self.ev.update_eff_vis(def_id, self.effective_vis, None, self.level);\n+            self.ev.update_eff_vis(def_id, Some(self.effective_vis), None, self.level);\n         }\n         ControlFlow::Continue(())\n     }"}]}