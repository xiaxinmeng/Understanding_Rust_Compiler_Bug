{"sha": "965e5287baf7666785941eb03ba41c06a7c1e2f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2NWU1Mjg3YmFmNzY2Njc4NTk0MWViMDNiYTQxYzA2YTdjMWUyZjE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-07-04T00:29:06Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-07-04T00:29:06Z"}, "message": "Add concept-index entries to docs, plus fix a few minor nits.", "tree": {"sha": "3d6e925567ae2a069dd8b6b1a6041ff0fdb3a567", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d6e925567ae2a069dd8b6b1a6041ff0fdb3a567"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/965e5287baf7666785941eb03ba41c06a7c1e2f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/965e5287baf7666785941eb03ba41c06a7c1e2f1", "html_url": "https://github.com/rust-lang/rust/commit/965e5287baf7666785941eb03ba41c06a7c1e2f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/965e5287baf7666785941eb03ba41c06a7c1e2f1/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df0fa603d091eb92e9ce7d2be969ae78a11057e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/df0fa603d091eb92e9ce7d2be969ae78a11057e2", "html_url": "https://github.com/rust-lang/rust/commit/df0fa603d091eb92e9ce7d2be969ae78a11057e2"}], "stats": {"total": 260, "additions": 248, "deletions": 12}, "files": [{"sha": "725ce572c782edab0904e4617532ed9ffc1e1da3", "filename": "doc/rust.texi", "status": "modified", "additions": 248, "deletions": 12, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/965e5287baf7666785941eb03ba41c06a7c1e2f1/doc%2Frust.texi", "raw_url": "https://github.com/rust-lang/rust/raw/965e5287baf7666785941eb03ba41c06a7c1e2f1/doc%2Frust.texi", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.texi?ref=965e5287baf7666785941eb03ba41c06a7c1e2f1", "patch": "@@ -207,6 +207,7 @@ receiver side.\n \n @sp 1\n @item Predictable native code, simple runtime\n+@cindex DWARF\n \n The meaning and cost of every operation within a Rust program is intended to\n be easy to model for the reader. The code should not ``surprise'' the\n@@ -299,9 +300,10 @@ Boxed immutable values are reference-counted and have a deterministic\n destruction order: top-down, immediately upon release of the last live\n reference.\n \n-State values can refer to immutable values, but not vice-versa. Rust therefore\n-encourages the programmer to write in a style that consists primarily of\n-immutable types, but also permits limited, local (per-task) mutability.\n+State values can refer to non-state values, but not vice-versa. Rust\n+therefore encourages the programmer to write in a style that consists\n+primarily of immutable types, but also permits limited, local\n+(per-task) mutability.\n \n @sp 1\n @item Stack-based iterators\n@@ -437,7 +439,7 @@ Every storage slot in a Rust frame participates in not only a conventional\n structural static type system, describing the interpretation of memory in the\n slot, but also a @emph{typestate} system. The static typestates of a program\n describe the set of @emph{pure, dynamic predicates} that provably hold over\n-some set of slots, at each point in the program's control flow graph within\n+some set of slots, at each point in the program's control-flow graph within\n each frame. The static calculation of the typestates of a program is a\n function-local dataflow problem, and handles user-defined predicates in a\n similar fashion to the way the type system permits user-defined types.\n@@ -573,6 +575,8 @@ Additional specific influences can be seen from the following languages:\n @node    Ref.Lex\n @section Ref.Lex\n @c * Ref.Lex::                     Lexical structure.\n+@cindex Lexical structure\n+@cindex Token\n \n The lexical structure of a Rust source file or crate file is defined in terms\n of Unicode character codes and character properties.\n@@ -621,6 +625,7 @@ token or a syntactic extension token.\n @node       Ref.Lex.Ident\n @subsection Ref.Lex.Ident\n @c * Ref.Lex.Ident::             Identifier tokens.\n+@cindex Identifier token\n \n Identifiers follow the pattern of C identifiers: they begin with a\n @emph{letter} or @emph{underscore}, and continue with any combination of\n@@ -640,6 +645,7 @@ A @dfn{decimal digit} is a character in the range U+0030-U+0039\n @c * Ref.Lex.Key::                Keyword tokens.\n \n The keywords are:\n+@cindex Keywords\n \n @sp 2\n \n@@ -719,6 +725,11 @@ The keywords are:\n @node       Ref.Lex.Num\n @subsection Ref.Lex.Num\n @c * Ref.Lex.Num::                 Numeric tokens.\n+@cindex Number token\n+@cindex Hex token\n+@cindex Decimal token\n+@cindex Binary token\n+@cindex Floating-point token\n \n A @dfn{number literal} is either an @emph{integer literal} or a\n @emph{floating-point literal}.\n@@ -740,7 +751,7 @@ and @emph{underscores}.\n @end enumerate\n \n @sp 1\n-A @dfn{floating point literal} has one of two forms:\n+A @dfn{floating-point literal} has one of two forms:\n @enumerate\n @item Two @emph{decimal literals} separated by a period\n character U+002E ('.'), with an optional @emph{exponent} trailing after the\n@@ -765,6 +776,10 @@ A @dfn{sign character} is either U+002B or U+002D (@code{'+'} or @code{'-'}).\n @node       Ref.Lex.Text\n @subsection Ref.Lex.Text\n @c * Ref.Lex.Key::                 String and character tokens.\n+@cindex String token\n+@cindex Character token\n+@cindex Escape sequence\n+@cindex Unicode\n \n A @dfn{character literal} is a single Unicode character enclosed within two\n U+0027 (single-quote) characters, with the exception of U+0027 itself, which\n@@ -812,6 +827,9 @@ region). @xref{Ref.Comp.Syntax}.\n @subsection Ref.Lex.Sym\n @c * Ref.Lex.Sym::                 Special symbol tokens.\n \n+@cindex Symbol\n+@cindex Operator\n+\n The special symbols are:\n \n @sp 2\n@@ -877,6 +895,9 @@ The special symbols are:\n @node    Ref.Path\n @section Ref.Path\n @c * Ref.Path::               References to slots and items.\n+@cindex Names of items or slots\n+@cindex Path name\n+@cindex Type parameters\n \n A @dfn{path} is a ubiquitous syntactic form in Rust that deserves special\n attention. A path denotes a slot or an\n@@ -943,12 +964,14 @@ x.y.(1 + v).z;\n @section Ref.Gram\n @c * Ref.Gram::                    Grammar.\n \n-@emph{TODO: LL(1), it reads like C, Alef and bits of Napier; formalize here}.\n+@emph{TODO: mostly LL(1), it reads like C, Alef and bits of Napier;\n+formalize here}.\n \n @page\n @node    Ref.Comp\n @section Ref.Comp\n @c * Ref.Comp::                    Compilation and component model.\n+@cindex Compilation model\n \n Rust is a @emph{compiled} language. Its semantics are divided along a\n @emph{phase distinction} between compile-time and run-time. Those semantic\n@@ -970,6 +993,7 @@ successful produces a single crate in executable form.\n @node       Ref.Comp.Crate\n @subsection Ref.Comp.Crate\n @c * Ref.Comp.Crate::              Units of compilation and linking.\n+@cindex Crate\n \n A @dfn{crate} is a unit of compilation and linking, as well as versioning,\n distribution and runtime loading. Crates are defined by @emph{crate source\n@@ -1059,6 +1083,7 @@ mod bar @{\n \n @node       Ref.Comp.Meta\n @subsection Ref.Comp.Meta\n+@cindex Metadata, in crates\n \n In a crate, a @code{meta} directive associates free form key-value metadata\n with the crate. This metadata can, in turn, be used in providing partial\n@@ -1070,6 +1095,7 @@ Alternatively, metadata can serve as a simple form of documentation.\n @node          Ref.Comp.Syntax\n @subsection    Ref.Comp.Syntax\n @c * Ref.Comp.Syntax::        Syntax extension.\n+@cindex Syntax extension\n \n Rust provides a notation for @dfn{syntax extension}. The notation is a marked\n syntactic form that can appear as an expression, statement or item in the body\n@@ -1118,6 +1144,9 @@ let bool matched = re.match(pattern, s);\n @node    Ref.Mem\n @section Ref.Mem\n @c * Ref.Mem::                     Semantic model of memory.\n+@cindex Memory model\n+@cindex Box\n+@cindex Slot\n \n A Rust task's memory consists of a static set of @emph{items}, a set of tasks\n each with its own @emph{stack}, and a @emph{heap}. Immutable portions of the\n@@ -1137,6 +1166,11 @@ consist of @emph{boxes}.\n @node       Ref.Mem.Alloc\n @subsection Ref.Mem.Alloc\n @c * Ref.Mem.Alloc::               Memory allocation model.\n+@cindex Item\n+@cindex Stack\n+@cindex Heap\n+@cindex Shared box\n+@cindex Task-local box\n \n The @dfn{items} of a program are those functions, iterators, objects, modules\n and types that have their value calculated at compile-time and stored uniquely\n@@ -1169,6 +1203,7 @@ execution of other tasks.\n @node       Ref.Mem.Own\n @subsection Ref.Mem.Own\n @c * Ref.Mem.Own::                 Memory ownership model.\n+@cindex Ownership\n \n A task @emph{owns} all the @emph{stack-local} slot allocations in its stack\n and @emph{task-local} boxes accessible from its stack. A task @emph{shares}\n@@ -1191,6 +1226,10 @@ references to any boxes.\n @node       Ref.Mem.Slot\n @subsection Ref.Mem.Slot\n @c * Ref.Mem.Slot::                Stack memory model.\n+@cindex Stack\n+@cindex Slot\n+@cindex Local slot\n+@cindex Alias slot\n \n A task's stack contains slots.\n \n@@ -1238,6 +1277,8 @@ fn incr(& mutable int i) @{\n @node       Ref.Mem.Box\n @subsection Ref.Mem.Box\n @c * Ref.Mem.Box::                 Heap memory model.\n+@cindex Box\n+@cindex Dereference operator\n \n A @dfn{box} is a reference to a reference-counted heap allocation holding\n another value.\n@@ -1293,6 +1334,9 @@ fn main() @{\n @node       Ref.Mem.Acct\n @subsection Ref.Mem.Acct\n @c * Ref.Mem.Acct::                Memory accounting model.\n+@cindex Domain\n+@cindex Accounting\n+@cindex Memory budget\n \n Every task belongs to a domain, and that domain tracks the amount of memory\n allocated and not yet released by tasks within it. @xref{Ref.Task.Dom}. Each\n@@ -1315,6 +1359,8 @@ cost is transferred to the receiving domain.\n @node    Ref.Task\n @section Ref.Task\n @c * Ref.Task::                    Semantic model of tasks.\n+@cindex Task\n+@cindex Process\n \n An executing Rust program consists of a tree of tasks. A Rust @dfn{task}\n consists of an entry function, a stack, a set of outgoing communication\n@@ -1339,6 +1385,14 @@ operating-system processes.\n @subsection Ref.Task.Comm\n @c * Ref.Task.Comm::               Inter-task communication.\n \n+@cindex Communication\n+@cindex Port\n+@cindex Channel\n+@cindex Message passing\n+@cindex Send statement\n+@cindex Receive statement\n+@cindex Flush statement\n+\n With the exception of @emph{unsafe} constructs, Rust tasks are isolated from\n interfering with one another's memory directly. Instead of manipulating shared\n storage, Rust tasks communicate with one another using a typed, asynchronous,\n@@ -1393,6 +1447,15 @@ operator is @code{<-}. @xref{Ref.Stmt.Recv}.\n @subsection Ref.Task.Life\n @c * Ref.Task.Life::               Task lifecycle and state transitions.\n \n+@cindex Lifecycle of task\n+@cindex Scheduling\n+@cindex Running, task state\n+@cindex Blocked, task state\n+@cindex Failing, task state\n+@cindex Dead, task state\n+@cindex Soft failure\n+@cindex Hard failure\n+\n The @dfn{lifecycle} of a task consists of a finite set of states and events\n that cause transitions between the states. The lifecycle states of a task are:\n \n@@ -1442,6 +1505,10 @@ reclamation when the last reference to it drops.\n @subsection Ref.Task.Dom\n @c * Ref.Task.Dom::                Task domains\n \n+@cindex Domain\n+@cindex Process\n+@cindex Thread\n+\n Every task belongs to a domain. A @dfn{domain} is a structure that owns tasks,\n schedules tasks, tracks memory allocation within tasks and manages access to\n runtime services on behalf of tasks.\n@@ -1463,6 +1530,10 @@ domain.\n @subsection Ref.Task.Sched\n @c * Ref.Task.Sched::              Task scheduling model.\n \n+@cindex Scheduling\n+@cindex Preemption\n+@cindex Yielding control\n+\n Every task is @emph{scheduled} within its domain. @xref{Ref.Task.Dom}. The\n currently scheduled task is given a finite @emph{time slice} in which to\n execute, after which it is @emph{descheduled} at a loop-edge or similar\n@@ -1478,6 +1549,10 @@ deschedules the task.\n @section Ref.Item\n @c * Ref.Item::               The components of a module.\n \n+@cindex Item\n+@cindex Type parameters\n+@cindex Module item\n+\n An @dfn{item} is a component of a module. Items are entirely determined at\n compile-time, remain constant during execution, and may reside in read-only\n memory.\n@@ -1516,6 +1591,11 @@ are no general parametric types.\n @subsection Ref.Item.Mod\n @c * Ref.Item.Mod::           Items defining sub-modules.\n \n+@cindex Module item\n+@cindex Importing names\n+@cindex Exporting names\n+@cindex Visibility control\n+\n A @dfn{module item} contains declarations of other @emph{items}. The items\n within a module may be functions, modules, objects or types. These\n declarations have both static and dynamic interpretation. The purpose of a\n@@ -1553,6 +1633,9 @@ and outside of it.\n @subsubsection Ref.Item.Mod.Import\n @c * Ref.Item.Mod.Import::     Declarations for module-local synonyms.\n \n+@cindex Importing names\n+@cindex Visibility control\n+\n An @dfn{import declaration} creates one or more local name bindings synonymous\n with some other name. Usually an import declaration is used to shorten the\n path required to refer to a module item.\n@@ -1575,6 +1658,9 @@ fn main() @{\n @subsubsection Ref.Item.Mod.Export\n @c * Ref.Item.Mod.Import::     Declarations for restricting visibility.\n \n+@cindex Exporting names\n+@cindex Visibility control\n+\n An @dfn{export declaration} restricts the set of local declarations within a\n module that can be accessed from code outside the module. By default, all\n local declarations in a module are exported. If a module contains an export\n@@ -1606,6 +1692,11 @@ fn main() @{\n @node       Ref.Item.Fn\n @subsection Ref.Item.Fn\n @c * Ref.Item.Fn::            Items defining functions.\n+@cindex Functions\n+@cindex Slots, function input and output\n+@cindex Effect of a function\n+@cindex Predicate\n+\n \n A @dfn{function item} defines a sequence of statements associated with a name\n and a set of parameters. Functions are declared with the keyword\n@@ -1642,6 +1733,11 @@ fn add(int x, int y) -> int @{\n @subsection    Ref.Item.Iter\n @c * Ref.Item.Iter::          Items defining iterators.\n \n+@cindex Iterators\n+@cindex Put statement\n+@cindex Put each statement\n+@cindex Foreach statement\n+\n Iterators are function-like items that can @code{put} multiple values during\n their execution before returning or tail-calling.\n \n@@ -1679,6 +1775,8 @@ for each (int x = range(0,100)) @{\n @node       Ref.Item.Obj\n @subsection Ref.Item.Obj\n @c * Ref.Item.Obj::          Items defining objects.\n+@cindex Objects\n+@cindex Object constructors\n \n An @dfn{object item} defines the @emph{state} and @emph{methods} of a set of\n @emph{object values}. Object values have object types.  @xref{Ref.Type.Obj}.\n@@ -1710,6 +1808,7 @@ check (c.get() == 3);\n @node       Ref.Item.Type\n @subsection Ref.Item.Type\n @c * Ref.Item.Type::          Items defining the types of values and slots.\n+@cindex Types\n \n A @dfn{type} defines an @emph{interpretation} of a value in\n memory. @xref{Ref.Type}. Types are declared with the keyword @code{type}. A\n@@ -1738,6 +1837,7 @@ restricted form of @code{tag} type. @xref{Ref.Type.Tag}.\n @page\n @node    Ref.Type\n @section Ref.Type\n+@cindex Types\n \n Every slot and value in a Rust program has a type. The @dfn{type} of a\n @emph{value} defines the interpretation of the memory holding it. The type of\n@@ -1773,6 +1873,10 @@ Rust; they cannot be used as user-defined identifiers in any context.\n \n @node       Ref.Type.Any\n @subsection Ref.Type.Any\n+@cindex Any type\n+@cindex Dynamic type, see @i{Any type}\n+@cindex Reflection\n+@cindex Alt type statement\n \n The type @code{any} is the union of all possible Rust types. A value of type\n @code{any} is represented in memory as a pair consisting of a boxed value of\n@@ -1784,6 +1888,10 @@ type extraction. @xref{Ref.Stmt.Alt}.\n \n @node       Ref.Type.Mach\n @subsection Ref.Type.Mach\n+@cindex Machine types\n+@cindex Floating-point types\n+@cindex Integer types\n+@cindex Word types\n \n The machine types are the following:\n \n@@ -1825,12 +1933,15 @@ The signed two's complement word types @code{i8}, @code{i16}, @code{i32} and\n @end ifhtml\n  respectively.\n @item\n-The IEEE 754 single-precision and double-precision floating point types:\n+The IEEE 754 single-precision and double-precision floating-point types:\n @code{f32} and @code{f64}, respectively.\n @end itemize\n \n @node       Ref.Type.Int\n @subsection Ref.Type.Int\n+@cindex Machine-dependent types\n+@cindex Integer types\n+@cindex Word types\n \n \n The Rust type @code{uint}@footnote{A Rust @code{uint} is analogous to a C99\n@@ -1845,6 +1956,8 @@ rust type @code{uint} on the same target machine.\n \n @node       Ref.Type.Float\n @subsection Ref.Type.Float\n+@cindex Machine-dependent types\n+@cindex Floating-point types\n \n The Rust type @code{float} is a machine-specific type equal to one of the\n supported Rust floating-point machine types (@code{f32} or @code{f64}). It is\n@@ -1853,13 +1966,18 @@ target machine, or if the target machine has no floating-point hardware\n support, the largest floating-point type supported by the software\n floating-point library used to support the other floating-point machine types.\n \n-Note that due to the preference for hardware-supported floating point, the\n+Note that due to the preference for hardware-supported floating-point, the\n type @code{float} may not be equal to the largest @emph{supported}\n floating-point type.\n \n \n @node       Ref.Type.Prim\n @subsection Ref.Type.Prim\n+@cindex Primitive types\n+@cindex Integer types\n+@cindex Floating-point types\n+@cindex Character type\n+@cindex Boolean type\n \n The primitive types are the following:\n \n@@ -1882,6 +2000,8 @@ The machine-dependent integer and floating-point types.\n \n @node       Ref.Type.Big\n @subsection Ref.Type.Big\n+@cindex Integer types\n+@cindex Big integer type\n \n The Rust type @code{big}@footnote{A Rust @code{big} is analogous to a Lisp\n bignum or a Python long integer.} is an arbitrary precision integer type that\n@@ -1895,6 +2015,12 @@ should only exhaust its range due to memory exhaustion.\n \n @node       Ref.Type.Text\n @subsection Ref.Type.Text\n+@cindex Text types\n+@cindex String type\n+@cindex Character type\n+@cindex Unicode\n+@cindex UCS-4\n+@cindex UTF-8\n \n The types @code{char} and @code{str} hold textual data.\n \n@@ -1906,6 +2032,8 @@ A value of type @code{str} is a Unicode string, represented as a vector of\n \n @node       Ref.Type.Rec\n @subsection Ref.Type.Rec\n+@cindex Record types\n+@cindex Structure types, see @i{Record types}\n \n The record type-constructor @code{rec} forms a new heterogeneous product of\n values.@footnote{The @code{rec} type-constructor is analogous to the\n@@ -1923,6 +2051,7 @@ let int px = p.x;\n \n @node       Ref.Type.Tup\n @subsection Ref.Type.Tup\n+@cindex Tuple types\n \n The tuple type-constructor @code{tup} forms a new heterogeneous product of\n values exactly as the @code{rec} type-constructor does, with the difference\n@@ -1943,6 +2072,8 @@ check (p._1 == \"world\");\n \n @node       Ref.Type.Vec\n @subsection Ref.Type.Vec\n+@cindex Vector types\n+@cindex Array types, see @i{Vector types}\n \n The vector type-constructor @code{vec} represents a homogeneous array of\n values of a given type. A vector has a fixed size. If the member-type of a\n@@ -1981,6 +2112,8 @@ vector is always bounds-checked.\n \n @node       Ref.Type.Tag\n @subsection Ref.Type.Tag\n+@cindex Tag types\n+@cindex Union types, see @i{Tag types}\n \n The @code{tag} type-constructor forms new heterogeneous disjoint union\n types.@footnote{The @code{tag} type is analogous to a @code{data} constructor\n@@ -2019,6 +2152,7 @@ let list[int] a = cons(7, cons(13, nil));\n \n @node       Ref.Type.Fn\n @subsection Ref.Type.Fn\n+@cindex Function types\n \n The function type-constructor @code{fn} forms new function types. A function\n type consists of a sequence of input slots, an optional set of input\n@@ -2040,6 +2174,7 @@ x = bo(5,7);\n \n @node       Ref.Type.Iter\n @subsection Ref.Type.Iter\n+@cindex Iterator types\n \n The iterator type-constructor @code{iter} forms new iterator types. An\n iterator type consists a sequence of input slots, an optional set of input\n@@ -2062,6 +2197,8 @@ for each (int i = range(5,7)) @{\n \n @node       Ref.Type.Port\n @subsection Ref.Type.Port\n+@cindex Port types\n+@cindex Communication\n \n The port type-constructor @code{port} forms types that describe ports. A port\n is the @emph{receiving end} of a typed, asynchronous, simplex inter-task\n@@ -2083,6 +2220,8 @@ v <- p;\n \n @node       Ref.Type.Chan\n @subsection Ref.Type.Chan\n+@cindex Channel types\n+@cindex Communication\n \n The channel type-constructor @code{chan} forms types that describe channels. A\n channel is the @emph{sending end} of a typed, asynchronous, simplex inter-task\n@@ -2117,6 +2256,7 @@ c <| v;\n \n @node       Ref.Type.Task\n @subsection Ref.Type.Task\n+@cindex Task type\n \n The task type @code{task} describes values that are @emph{live\n tasks}.\n@@ -2138,6 +2278,7 @@ holding those references), the released task immediately fails.\n @node       Ref.Type.Obj\n @subsection Ref.Type.Obj\n @c * Ref.Type.Obj::                Object types.\n+@cindex Object types\n \n A @dfn{object type} describes values of abstract type, that carry some hidden\n @emph{fields} and are accessed through a set of un-ordered\n@@ -2203,6 +2344,7 @@ give_ints(t2);\n @node       Ref.Type.Constr\n @subsection Ref.Type.Constr\n @c * Ref.Type.Constr::             Constrained types.\n+@cindex Constrained types\n \n A @dfn{constrained type} is a type that carries a @emph{formal constraint}\n (@pxref{Ref.Stmt.Stat.Constr}), which is similar to a normal constraint except\n@@ -2228,13 +2370,15 @@ let ordered_range rng2 = rec(low=15, high=17);\n @node       Ref.Type.Type\n @subsection Ref.Type.Type\n @c * Ref.Type.Type::               Types describing types.\n+@cindex Type type\n \n @emph{TODO}.\n \n @page\n @node    Ref.Expr\n @section Ref.Expr\n @c * Ref.Expr::               Parsed and primitive expressions.\n+@cindex Expressions\n \n Rust has two kinds of expressions: @emph{parsed expressions} and\n @emph{primitive expressions}.  The former are syntactic sugar and are\n@@ -2252,6 +2396,7 @@ right hand side of copy statements, @xref{Ref.Stmt.Copy}.\n @node    Ref.Stmt\n @section Ref.Stmt\n @c * Ref.Stmt::               Executable statements.\n+@cindex Statements\n \n A @dfn{statement} is a component of a block, which is in turn a components of\n an outer block, a function or an iterator. When a function is spawned into a\n@@ -2290,6 +2435,7 @@ actions.\n @node       Ref.Stmt.Stat\n @subsection Ref.Stmt.Stat\n @c * Ref.Stmt.Stat::         The static typestate system of statement analysis.\n+@cindex Typestate system\n \n Statements have a detailed static semantics. The static semantics determine,\n on a statement-by-statement basis, the @emph{effects} the statement has on its\n@@ -2303,7 +2449,7 @@ system.\n \n @menu\n * Ref.Stmt.Stat.Point::         Inter-statement positions of logical judgements.\n-* Ref.Stmt.Stat.CFG::           The control flow graph formed by statements.\n+* Ref.Stmt.Stat.CFG::           The control-flow graph formed by statements.\n * Ref.Stmt.Stat.Constr::        Predicates applied to slots.\n * Ref.Stmt.Stat.Cond::          Constraints required and implied by a statement.\n * Ref.Stmt.Stat.Typestate::     Constraints that hold at points.\n@@ -2313,6 +2459,7 @@ system.\n @node          Ref.Stmt.Stat.Point\n @subsubsection Ref.Stmt.Stat.Point\n @c * Ref.Stmt.Stat.Point::         Inter-statement positions of logical judgements.\n+@cindex Points\n \n A @dfn{point} exists before and after any statement in a Rust program.\n For example, this code:\n@@ -2343,7 +2490,8 @@ memory.\n \n @node          Ref.Stmt.Stat.CFG\n @subsubsection Ref.Stmt.Stat.CFG\n-@c * Ref.Stmt.Stat.CFG::           The control flow graph formed by statements.\n+@c * Ref.Stmt.Stat.CFG::           The control-flow graph formed by statements.\n+@cindex Control-flow graph\n \n Each @emph{point} can be considered a vertex in a directed @emph{graph}. Each\n kind of statement implies a single edge in this graph between the point before\n@@ -2352,11 +2500,13 @@ from the points of the statement to points before other statements. The edges\n between points represent @emph{possible} indivisible control transfers that\n might occur during execution.\n \n-This implicit graph is called the @dfn{control flow graph}, or @dfn{CFG}.\n+This implicit graph is called the @dfn{control-flow graph}, or @dfn{CFG}.\n \n @node          Ref.Stmt.Stat.Constr\n @subsubsection Ref.Stmt.Stat.Constr\n @c * Ref.Stmt.Stat.Constr::          Predicates applied to slots.\n+@cindex Predicate\n+@cindex Constraint\n \n A @dfn{predicate} is any pure boolean function. @xref{Ref.Item.Fn}.\n \n@@ -2387,6 +2537,9 @@ in those slots must be immutable.\n @node          Ref.Stmt.Stat.Cond\n @subsubsection Ref.Stmt.Stat.Cond\n @c * Ref.Stmt.Stat.Cond::          Constraints required and implied by a statement.\n+@cindex Condition\n+@cindex Precondition\n+@cindex Postcondition\n \n A @dfn{condition} is a set of zero or more constraints.\n \n@@ -2405,6 +2558,9 @@ postcondition is considered to be @emph{dropped} by the statement.\n @node          Ref.Stmt.Stat.Typestate\n @subsubsection Ref.Stmt.Stat.Typestate\n @c * Ref.Stmt.Stat.Typestate::     Constraints that hold at points.\n+@cindex Typestate\n+@cindex Prestate\n+@cindex Poststate\n \n The typestate checking system @emph{calculates} an additional\n condition for each point called its typestate. For a given statement,\n@@ -2453,6 +2609,8 @@ static (compile-time) error.\n @node          Ref.Stmt.Stat.Check\n @subsubsection Ref.Stmt.Stat.Check\n @c * Ref.Stmt.Stat.Check::         Relating dynamic state to static typestate.\n+@cindex Check statement\n+@cindex Assertions, see @i{Check statement}\n \n The key mechanism that connects run-time semantics and compile-time analysis\n of typestates is the use of @code{check} statements. @xref{Ref.Stmt.Check}. A\n@@ -2484,6 +2642,7 @@ to hold in order to execute properly.\n @node       Ref.Stmt.Decl\n @subsection Ref.Stmt.Decl\n @c * Ref.Stmt.Decl::                Statement declaring an item or slot.\n+@cindex Declaration statement\n \n A @dfn{declaration statement} is one that introduces a @emph{name} into the\n enclosing statement block. The declared name may denote a new slot or a new\n@@ -2512,6 +2671,10 @@ declaring a function-local item.\n @node          Ref.Stmt.Decl.Slot\n @subsubsection Ref.Stmt.Decl.Slot\n @c * Ref.Stmt.Decl.Slot::                Statement declaring an slot.\n+@cindex Local slot\n+@cindex Variable, see @i{Local slot}\n+@cindex Type inference\n+@cindex Automatic slot\n \n A @code{slot declaration statement} has one one of two forms:\n \n@@ -2540,6 +2703,8 @@ object signatures must always declared types for all argument slots.\n @node       Ref.Stmt.Copy\n @subsection Ref.Stmt.Copy\n @c * Ref.Stmt.Copy::                Statement for copying a value.\n+@cindex Copy statement\n+@cindex Assignment operator, see @i{Copy statement}\n \n A @dfn{copy statement} consists of an @emph{lval} followed by an equals-sign\n (@code{=}) and a primitive expression. @xref{Ref.Expr}.\n@@ -2564,6 +2729,7 @@ x.y = z + 2;\n @node       Ref.Stmt.Spawn\n @subsection Ref.Stmt.Spawn\n @c * Ref.Stmt.Spawn::               Statements creating new tasks.\n+@cindex Spawn statement\n \n A @code{spawn} statement consists of keyword @code{spawn}, followed by a\n normal @emph{call} statement (@pxref{Ref.Stmt.Call}).  A @code{spawn}\n@@ -2594,6 +2760,8 @@ auto result <- out;\n @node       Ref.Stmt.Send\n @subsection Ref.Stmt.Send\n @c * Ref.Stmt.Send::            Statements for sending a value into a channel.\n+@cindex Send statement\n+@cindex Communication\n \n Sending a value through a channel can be done via two different statements.\n Both statements take an @emph{lval}, denoting a channel, and a value to send\n@@ -2624,6 +2792,8 @@ c <| \"hello, world\";\n @node       Ref.Stmt.Flush\n @subsection Ref.Stmt.Flush\n @c * Ref.Stmt.Flush::              Statement for flushing a channel queue.\n+@cindex Flush statement\n+@cindex Communication\n \n A @code{flush} statement takes a channel and blocks the flushing task until\n the channel's queue has emptied. It can be used to implement a more precise\n@@ -2640,6 +2810,8 @@ flush c;\n @node       Ref.Stmt.Recv\n @subsection Ref.Stmt.Recv\n @c * Ref.Stmt.Recv::           Statement for receiving a value from a channel.\n+@cindex Receive statement\n+@cindex Communication\n \n The @dfn{receive statement} takes an @var{lval} to receive into and an\n expression denoting a port, and applies the @emph{receive operator}\n@@ -2659,6 +2831,8 @@ let str s <- p;\n @node       Ref.Stmt.Call\n @subsection Ref.Stmt.Call\n @c * Ref.Stmt.Call::               Statement for calling a function.\n+@cindex Call statement\n+@cindex Function calls\n \n A @dfn{call statement} invokes a function, providing a tuple of input slots\n and an alias slot to serve as the function's output, bound to the @var{lval}\n@@ -2677,6 +2851,9 @@ let int x = add(1, 2);\n @node       Ref.Stmt.Bind\n @subsection Ref.Stmt.Bind\n @c * Ref.Stmt.Bind::          Statement for binding arguments to functions.\n+@cindex Bind statement\n+@cindex Closures\n+@cindex Currying\n \n A @dfn{bind statement} constructs a new function from an existing\n function.@footnote{The @code{bind} statement is analogous to the @code{bind}\n@@ -2722,6 +2899,7 @@ of them can be achieved with @code{bind} statements.\n @node       Ref.Stmt.Ret\n @subsection Ref.Stmt.Ret\n @c * Ref.Stmt.Ret::                Statement for stopping and producing a value.\n+@cindex Return statement\n \n Executing a @code{ret} statement@footnote{A @code{ret} statement is analogous\n to a @code{return} statement in the C family.}  copies a value into the output\n@@ -2741,6 +2919,8 @@ fn max(int a, int b) -> int @{\n @node       Ref.Stmt.Be\n @subsection Ref.Stmt.Be\n @c * Ref.Stmt.Be::                 Statement for stopping and executing a tail call.\n+@cindex Be statement\n+@cindex Tail calls\n \n Executing a @code{be} statement @footnote{A @code{be} statement in is\n analogous to a @code{become} statement in Newsqueak or Alef.}  destroys the\n@@ -2770,6 +2950,8 @@ copy of itself.\n @node       Ref.Stmt.Put\n @subsection Ref.Stmt.Put\n @c * Ref.Stmt.Put::                Statement for pausing and producing a value.\n+@cindex Put statement\n+@cindex Iterators\n \n Executing a @code{put} statement copies a value into the output slot of the\n current iterator, suspends execution of the current iterator, and transfers\n@@ -2789,6 +2971,9 @@ execution and destroying the iterator frame.\n @node       Ref.Stmt.Fail\n @subsection Ref.Stmt.Fail\n @c * Ref.Stmt.Fail::               Statement for causing task failure.\n+@cindex Fail statement\n+@cindex Failure\n+@cindex Unwinding\n \n Executing a @code{fail} statement causes a task to enter the @emph{failing}\n state. In the @emph{failing} state, a task unwinds its stack, destroying all\n@@ -2798,6 +2983,8 @@ point it halts execution in the @emph{dead} state.\n @node       Ref.Stmt.Log\n @subsection Ref.Stmt.Log\n @c * Ref.Stmt.Log::                Statement for logging values to diagnostic buffers.\n+@cindex Log statement\n+@cindex Logging\n \n Executing a @code{log} statement may, depending on runtime configuration,\n cause a value to be appended to an internal diagnostic logging buffer provided\n@@ -2815,6 +3002,10 @@ contains a log statement.\n @node       Ref.Stmt.Note\n @subsection Ref.Stmt.Note\n @c * Ref.Stmt.Note::                Statement for logging values during failure.\n+@cindex Note statement\n+@cindex Logging\n+@cindex Unwinding\n+@cindex Failure\n \n A @code{note} statement has no effect during normal execution. The purpose of\n a @code{note} statement is to provide additional diagnostic information to the\n@@ -2858,6 +3049,9 @@ logged during unwinding, @emph{not} the original value that was denoted by the\n @node       Ref.Stmt.While\n @subsection Ref.Stmt.While\n @c * Ref.Stmt.While::              Statement for simple conditional looping.\n+@cindex While statement\n+@cindex Loops\n+@cindex Control-flow\n \n A @code{while} statement is a loop construct. A @code{while} loop may be\n either a simple @code{while} or a @code{do}-@code{while} loop.\n@@ -2892,13 +3086,19 @@ do @{\n @node       Ref.Stmt.Break\n @subsection Ref.Stmt.Break\n @c * Ref.Stmt.Break::              Statement for terminating a loop.\n+@cindex Break statement\n+@cindex Loops\n+@cindex Control-flow\n \n Executing a @code{break} statement immediately terminates the innermost loop\n enclosing it. It is only permitted in the body of a loop.\n \n @node       Ref.Stmt.Cont\n @subsection Ref.Stmt.Cont\n @c * Ref.Stmt.Cont::               Statement for terminating a single loop iteration.\n+@cindex Continue statement\n+@cindex Loops\n+@cindex Control-flow\n \n Executing a @code{cont} statement immediately terminates the current iteration\n of the innermost loop enclosing it, returning control to the loop\n@@ -2913,6 +3113,9 @@ A @code{cont} statement is only permitted in the body of a loop.\n @node       Ref.Stmt.For\n @subsection Ref.Stmt.For\n @c * Ref.Stmt.For::                Statement for looping over strings and vectors.\n+@cindex For statement\n+@cindex Loops\n+@cindex Control-flow\n \n A @dfn{for loop} is controlled by a vector or string. The for loop\n bounds-checks the underlying sequence @emph{once} when initiating the loop,\n@@ -2945,6 +3148,9 @@ for (&foo e in v) @{\n @node          Ref.Stmt.Foreach\n @subsection    Ref.Stmt.Foreach\n @c * Ref.Stmt.Foreach::           Statement for general conditional looping.\n+@cindex Foreach statement\n+@cindex Loops\n+@cindex Control-flow\n \n An @dfn{foreach loop} is denoted by the @code{for each} keywords, and is\n controlled by an iterator. The loop executes once for each value @code{put} by\n@@ -2963,6 +3169,8 @@ for each (&str s = _str.split(txt, \"\\n\")) @{\n @node       Ref.Stmt.If\n @subsection Ref.Stmt.If\n @c * Ref.Stmt.If::                 Statement for simple conditional branching.\n+@cindex If statement\n+@cindex Control-flow\n \n An @code{if} statement is a conditional branch in program control. The form of\n an @code{if} statement is a parenthesized condition expression, followed by a\n@@ -2975,6 +3183,9 @@ block is skipped and any @code{else} block is executed.\n @node       Ref.Stmt.Alt\n @subsection Ref.Stmt.Alt\n @c * Ref.Stmt.Alt::                Statement for complex conditional branching.\n+@cindex Alt statement\n+@cindex Control-flow\n+@cindex Switch statement, see @i{Alt statement}\n \n An @code{alt} statement is a multi-directional branch in program control.\n There are three kinds of @code{alt} statement: communication @code{alt}\n@@ -2997,6 +3208,10 @@ statement following the @code{alt} when the case block completes.\n @node          Ref.Stmt.Alt.Comm\n @subsubsection Ref.Stmt.Alt.Comm\n @c * Ref.Stmt.Alt.Comm::           Statement for branching on communication events.\n+@cindex Communication alt statement\n+@cindex Control-flow\n+@cindex Communication\n+@cindex Multiplexing\n \n The simplest form of @code{alt} statement is the a @emph{communication}\n @code{alt}. The cases of a communication @code{alt}'s arms are send, receive\n@@ -3030,6 +3245,8 @@ alt @{\n @node          Ref.Stmt.Alt.Pat\n @subsubsection Ref.Stmt.Alt.Pat\n @c * Ref.Stmt.Alt.Pat::            Statement for branching on pattern matches.\n+@cindex Pattern alt statement\n+@cindex Control-flow\n \n A pattern @code{alt} statement branches on a @emph{pattern}. The exact form of\n matching that occurs depends on the pattern. Patterns consist of some\n@@ -3069,6 +3286,8 @@ alt (x) @{\n @node          Ref.Stmt.Alt.Type\n @subsubsection Ref.Stmt.Alt.Type\n @c * Ref.Stmt.Alt.Type::           Statement for branching on type.\n+@cindex Type alt statement\n+@cindex Control-flow\n \n An @code{alt type} statement is similar to a pattern @code{alt}, but branches\n on the @emph{type} of its head expression, rather than the value. The head\n@@ -3102,6 +3321,8 @@ alt type (x) @{\n @node       Ref.Stmt.Prove\n @subsection Ref.Stmt.Prove\n @c * Ref.Stmt.Prove::              Statement for static assertion of typestate.\n+@cindex Prove statement\n+@cindex Typestate system\n \n A @code{prove} statement has no run-time effect. Its purpose is to statically\n check (and document) that its argument constraint holds at its statement entry\n@@ -3111,6 +3332,8 @@ the program containing it will fail to compile.\n @node       Ref.Stmt.Check\n @subsection Ref.Stmt.Check\n @c * Ref.Stmt.Check::              Statement for dynamic assertion of typestate.\n+@cindex Check statement\n+@cindex Typestate system\n \n A @code{check} statement connects dynamic assertions made at run-time to the\n static typestate system. A @code{check} statement takes a constraint to check\n@@ -3152,10 +3375,13 @@ fn test() @{\n @node       Ref.Stmt.IfCheck\n @subsection Ref.Stmt.IfCheck\n @c * Ref.Stmt.IfCheck::            Statement for dynamic testing of typestate.\n+@cindex If check statement\n+@cindex Typestate system\n+@cindex Control-flow\n \n An @code{if check} statement combines a @code{if} statement and a @code{check}\n statement in an indivisible unit that can be used to build more complex\n-conditional control flow than the @code{check} statement affords.\n+conditional control-flow than the @code{check} statement affords.\n \n In fact, @code{if check} is a ``more primitive'' statement @code{check};\n instances of the latter can be rewritten as instances of the former. The\n@@ -3182,6 +3408,7 @@ if check even(x) @{\n @node    Ref.Run\n @section Ref.Run\n @c * Ref.Run::                     Organization of runtime services.\n+@cindex Runtime library\n \n The Rust @dfn{runtime} is a relatively compact collection of C and Rust code\n that provides fundamental services and datatypes to all Rust tasks at\n@@ -3201,6 +3428,7 @@ communication, reflection, logging and signal handling.\n @node       Ref.Run.Mem\n @subsection Ref.Run.Mem\n @c * Ref.Run.Mem::                 Runtime memory management service.\n+@cindex Memory allocation\n \n The runtime memory-management system is based on a @emph{service-provider\n interface}, through which the runtime requests blocks of memory from its\n@@ -3215,6 +3443,7 @@ allocating and freeing boxed values.\n @node       Ref.Run.Type\n @subsection Ref.Run.Type\n @c * Ref.Run.Mem::                 Runtime built-in type services.\n+@cindex Built-in types\n \n The runtime provides C and Rust code to manage several built-in types:\n @itemize\n@@ -3231,6 +3460,9 @@ records, and tags is open-coded by the Rust compiler.\n @node       Ref.Run.Comm\n @subsection Ref.Run.Comm\n @c * Ref.Run.Comm::                Runtime communication service.\n+@cindex Communication\n+@cindex Process\n+@cindex Thread\n \n The runtime provides code to manage inter-task communication.  This includes\n the system of task-lifecycle state transitions depending on the contents of\n@@ -3241,6 +3473,8 @@ communication facilities.\n @node       Ref.Run.Refl\n @subsection Ref.Run.Refl\n @c * Ref.Run.Refl::                Runtime reflection system.\n+@cindex Reflection\n+@cindex DWARF\n \n The runtime reflection system is driven by the DWARF tables emitted into a\n crate at compile-time. Reflecting on a slot or item allocates a Rust data\n@@ -3249,6 +3483,7 @@ structure corresponding to the DWARF DIE for that slot or item.\n @node       Ref.Run.Log\n @subsection Ref.Run.Log\n @c * Ref.Run.Log::                 Runtime logging system.\n+@cindex Logging\n \n The runtime contains a system for directing logging statements to a logging\n console and/or internal logging buffers. @xref{Ref.Stmt.Log}.  Logging\n@@ -3279,6 +3514,7 @@ need to filter logs based on these two built-in dimensions.\n @node       Ref.Run.Sig\n @subsection Ref.Run.Sig\n @c * Ref.Run.Sig::               Runtime signal handler.\n+@cindex Signals\n \n The runtime signal-handling system is driven by a signal-dispatch table and a\n signal queue associated with each task. Sending a signal to a task inserts the"}]}