{"sha": "48e193c7f65b32e2cf2ed2181ba87bd2f8b95bfb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4ZTE5M2M3ZjY1YjMyZTJjZjJlZDIxODFiYTg3YmQyZjhiOTViZmI=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2018-04-30T07:13:51Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2018-04-30T07:13:51Z"}, "message": "Factor out visit_impl_items", "tree": {"sha": "2f640626e125ff78f1670094757b48ec5f67e196", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f640626e125ff78f1670094757b48ec5f67e196"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48e193c7f65b32e2cf2ed2181ba87bd2f8b95bfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48e193c7f65b32e2cf2ed2181ba87bd2f8b95bfb", "html_url": "https://github.com/rust-lang/rust/commit/48e193c7f65b32e2cf2ed2181ba87bd2f8b95bfb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48e193c7f65b32e2cf2ed2181ba87bd2f8b95bfb/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f3f48c85c02bccd6d91365b60ce982b058aa1ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f3f48c85c02bccd6d91365b60ce982b058aa1ca", "html_url": "https://github.com/rust-lang/rust/commit/9f3f48c85c02bccd6d91365b60ce982b058aa1ca"}], "stats": {"total": 95, "additions": 50, "deletions": 45}, "files": [{"sha": "1ac8e2553e85406094a3e5e8be1da0e104683aa1", "filename": "src/items.rs", "status": "modified", "additions": 50, "deletions": 45, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/48e193c7f65b32e2cf2ed2181ba87bd2f8b95bfb/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48e193c7f65b32e2cf2ed2181ba87bd2f8b95bfb/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=48e193c7f65b32e2cf2ed2181ba87bd2f8b95bfb", "patch": "@@ -578,6 +578,55 @@ impl<'a> FmtVisitor<'a> {\n \n         combine_strs_with_missing_comments(&context, &attrs_str, &variant_body, span, shape, false)\n     }\n+\n+    fn visit_impl_items(&mut self, items: &[ast::ImplItem]) {\n+        if self.get_context().config.reorder_impl_items() {\n+            // Create visitor for each items, then reorder them.\n+            let mut buffer = vec![];\n+            for item in items {\n+                self.visit_impl_item(item);\n+                buffer.push((self.buffer.clone(), item.clone()));\n+                self.buffer.clear();\n+            }\n+            // type -> const -> macro -> method\n+            use ast::ImplItemKind::*;\n+            fn need_empty_line(a: &ast::ImplItemKind, b: &ast::ImplItemKind) -> bool {\n+                match (a, b) {\n+                    (Type(..), Type(..)) | (Const(..), Const(..)) => false,\n+                    _ => true,\n+                }\n+            }\n+\n+            buffer.sort_by(|(_, a), (_, b)| match (&a.node, &b.node) {\n+                (Type(..), _) => Ordering::Less,\n+                (_, Type(..)) => Ordering::Greater,\n+                (Const(..), _) => Ordering::Less,\n+                (_, Const(..)) => Ordering::Greater,\n+                (Macro(..), _) => Ordering::Less,\n+                (_, Macro(..)) => Ordering::Greater,\n+                _ => Ordering::Less,\n+            });\n+            let mut prev_kind = None;\n+            for (buf, item) in buffer {\n+                // Make sure that there are at least a single empty line between\n+                // different impl items.\n+                if prev_kind\n+                    .as_ref()\n+                    .map_or(false, |prev_kind| need_empty_line(prev_kind, &item.node))\n+                {\n+                    self.push_str(\"\\n\");\n+                }\n+                let indent_str = self.block_indent.to_string_with_newline(self.config);\n+                self.push_str(&indent_str);\n+                self.push_str(buf.trim());\n+                prev_kind = Some(item.node.clone());\n+            }\n+        } else {\n+            for item in items {\n+                self.visit_impl_item(item);\n+            }\n+        }\n+    }\n }\n \n pub fn format_impl(\n@@ -672,51 +721,7 @@ pub fn format_impl(\n             visitor.last_pos = item.span.lo() + BytePos(open_pos as u32);\n \n             visitor.visit_attrs(&item.attrs, ast::AttrStyle::Inner);\n-            if context.config.reorder_impl_items() {\n-                // Create visitor for each items, then reorder them.\n-                let mut buffer = vec![];\n-                for item in items {\n-                    visitor.visit_impl_item(item);\n-                    buffer.push((visitor.buffer.clone(), item.clone()));\n-                    visitor.buffer.clear();\n-                }\n-                // type -> const -> macro -> method\n-                use ast::ImplItemKind::*;\n-                fn need_empty_line(a: &ast::ImplItemKind, b: &ast::ImplItemKind) -> bool {\n-                    match (a, b) {\n-                        (Type(..), Type(..)) | (Const(..), Const(..)) => false,\n-                        _ => true,\n-                    }\n-                }\n-\n-                buffer.sort_by(|(_, a), (_, b)| match (&a.node, &b.node) {\n-                    (Type(..), _) => Ordering::Less,\n-                    (_, Type(..)) => Ordering::Greater,\n-                    (Const(..), _) => Ordering::Less,\n-                    (_, Const(..)) => Ordering::Greater,\n-                    (Macro(..), _) => Ordering::Less,\n-                    (_, Macro(..)) => Ordering::Greater,\n-                    _ => Ordering::Less,\n-                });\n-                let mut prev_kind = None;\n-                for (buf, item) in buffer {\n-                    // Make sure that there are at least a single empty line between\n-                    // different impl items.\n-                    if prev_kind\n-                        .as_ref()\n-                        .map_or(false, |prev_kind| need_empty_line(prev_kind, &item.node))\n-                    {\n-                        visitor.push_str(\"\\n\");\n-                    }\n-                    visitor.push_str(&item_indent.to_string_with_newline(context.config));\n-                    visitor.push_str(buf.trim());\n-                    prev_kind = Some(item.node.clone());\n-                }\n-            } else {\n-                for item in items {\n-                    visitor.visit_impl_item(item);\n-                }\n-            }\n+            visitor.visit_impl_items(items);\n \n             visitor.format_missing(item.span.hi() - BytePos(1));\n "}]}