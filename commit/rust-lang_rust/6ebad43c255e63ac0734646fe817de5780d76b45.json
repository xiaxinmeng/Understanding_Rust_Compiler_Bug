{"sha": "6ebad43c255e63ac0734646fe817de5780d76b45", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlYmFkNDNjMjU1ZTYzYWMwNzM0NjQ2ZmU4MTdkZTU3ODBkNzZiNDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-02T22:47:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-02T22:47:35Z"}, "message": "Auto merge of #77470 - jonas-schievink:rollup-9a2hulp, r=jonas-schievink\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #75377 (Fix Debug implementations of some of the HashMap and BTreeMap iterator types)\n - #76107 (Write manifest for MAJOR.MINOR channel to enable rustup convenience)\n - #76745 (Move Wrapping<T> ui tests into library)\n - #77182 (Add missing examples for Fd traits)\n - #77251 (Bypass const_item_mutation if const's type has Drop impl)\n - #77264 (Only use LOCAL_{STDOUT,STDERR} when set_{print/panic} is used. )\n - #77421 (Revert \"resolve: Avoid \"self-confirming\" import resolutions in one more case\")\n - #77452 (Permit ty::Bool in const generics for v0 mangling)\n\nFailed merges:\n\nr? `@ghost`", "tree": {"sha": "807dbc3a528785d6119b683c2a511bbc2f9629f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/807dbc3a528785d6119b683c2a511bbc2f9629f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ebad43c255e63ac0734646fe817de5780d76b45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ebad43c255e63ac0734646fe817de5780d76b45", "html_url": "https://github.com/rust-lang/rust/commit/6ebad43c255e63ac0734646fe817de5780d76b45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ebad43c255e63ac0734646fe817de5780d76b45/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8876ffc9235dade728e1fbc4be4c85415fdd0bcd", "url": "https://api.github.com/repos/rust-lang/rust/commits/8876ffc9235dade728e1fbc4be4c85415fdd0bcd", "html_url": "https://github.com/rust-lang/rust/commit/8876ffc9235dade728e1fbc4be4c85415fdd0bcd"}, {"sha": "eff63980142872227dcd66bf429f7337b1b68c31", "url": "https://api.github.com/repos/rust-lang/rust/commits/eff63980142872227dcd66bf429f7337b1b68c31", "html_url": "https://github.com/rust-lang/rust/commit/eff63980142872227dcd66bf429f7337b1b68c31"}], "stats": {"total": 543, "additions": 398, "deletions": 145}, "files": [{"sha": "b6d57b899ddab28a562e05725b82e7152e5af784", "filename": "compiler/rustc_mir/src/transform/check_const_item_mutation.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6ebad43c255e63ac0734646fe817de5780d76b45/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_const_item_mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ebad43c255e63ac0734646fe817de5780d76b45/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_const_item_mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_const_item_mutation.rs?ref=6ebad43c255e63ac0734646fe817de5780d76b45", "patch": "@@ -31,6 +31,35 @@ impl<'a, 'tcx> ConstMutationChecker<'a, 'tcx> {\n             None\n         }\n     }\n+\n+    fn is_const_item_without_destructor(&self, local: Local) -> Option<DefId> {\n+        let def_id = self.is_const_item(local)?;\n+        let mut any_dtor = |_tcx, _def_id| Ok(());\n+\n+        // We avoid linting mutation of a const item if the const's type has a\n+        // Drop impl. The Drop logic observes the mutation which was performed.\n+        //\n+        //     pub struct Log { msg: &'static str }\n+        //     pub const LOG: Log = Log { msg: \"\" };\n+        //     impl Drop for Log {\n+        //         fn drop(&mut self) { println!(\"{}\", self.msg); }\n+        //     }\n+        //\n+        //     LOG.msg = \"wow\";  // prints \"wow\"\n+        //\n+        // FIXME(https://github.com/rust-lang/rust/issues/77425):\n+        // Drop this exception once there is a stable attribute to suppress the\n+        // const item mutation lint for a single specific const only. Something\n+        // equivalent to:\n+        //\n+        //     #[const_mutation_allowed]\n+        //     pub const LOG: Log = Log { msg: \"\" };\n+        match self.tcx.calculate_dtor(def_id, &mut any_dtor) {\n+            Some(_) => None,\n+            None => Some(def_id),\n+        }\n+    }\n+\n     fn lint_const_item_usage(\n         &self,\n         const_item: DefId,\n@@ -59,7 +88,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ConstMutationChecker<'a, 'tcx> {\n             // Assigning directly to a constant (e.g. `FOO = true;`) is a hard error,\n             // so emitting a lint would be redundant.\n             if !lhs.projection.is_empty() {\n-                if let Some(def_id) = self.is_const_item(lhs.local) {\n+                if let Some(def_id) = self.is_const_item_without_destructor(lhs.local) {\n                     // Don't lint on writes through a pointer\n                     // (e.g. `unsafe { *FOO = 0; *BAR.field = 1; }`)\n                     if !matches!(lhs.projection.last(), Some(PlaceElem::Deref)) {"}, {"sha": "adff4542b0ff8a38cecc1f7fed87e7d9088c8fe3", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6ebad43c255e63ac0734646fe817de5780d76b45/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ebad43c255e63ac0734646fe817de5780d76b45/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=6ebad43c255e63ac0734646fe817de5780d76b45", "patch": "@@ -875,12 +875,6 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     /// consolidate multiple unresolved import errors into a single diagnostic.\n     fn finalize_import(&mut self, import: &'b Import<'b>) -> Option<UnresolvedImportError> {\n         let orig_vis = import.vis.replace(ty::Visibility::Invisible);\n-        let orig_unusable_binding = match &import.kind {\n-            ImportKind::Single { target_bindings, .. } => {\n-                Some(mem::replace(&mut self.r.unusable_binding, target_bindings[TypeNS].get()))\n-            }\n-            _ => None,\n-        };\n         let prev_ambiguity_errors_len = self.r.ambiguity_errors.len();\n         let path_res = self.r.resolve_path(\n             &import.module_path,\n@@ -891,9 +885,6 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             import.crate_lint(),\n         );\n         let no_ambiguity = self.r.ambiguity_errors.len() == prev_ambiguity_errors_len;\n-        if let Some(orig_unusable_binding) = orig_unusable_binding {\n-            self.r.unusable_binding = orig_unusable_binding;\n-        }\n         import.vis.set(orig_vis);\n         if let PathResult::Failed { .. } | PathResult::NonModule(..) = path_res {\n             // Consider erroneous imports used to avoid duplicate diagnostics.\n@@ -904,7 +895,8 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 // Consistency checks, analogous to `finalize_macro_resolutions`.\n                 if let Some(initial_module) = import.imported_module.get() {\n                     if !ModuleOrUniformRoot::same_def(module, initial_module) && no_ambiguity {\n-                        span_bug!(import.span, \"inconsistent resolution for an import\");\n+                        let msg = \"inconsistent resolution for an import\";\n+                        self.r.session.span_err(import.span, msg);\n                     }\n                 } else {\n                     if self.r.privacy_errors.is_empty() {\n@@ -926,7 +918,6 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             }\n             PathResult::Failed { is_error_from_last_segment: true, span, label, suggestion } => {\n                 if no_ambiguity {\n-                    assert!(import.imported_module.get().is_none());\n                     let err = match self.make_path_suggestion(\n                         span,\n                         import.module_path.clone(),"}, {"sha": "da9c93143bfb345d7836bb0cfe996c3c9fb2287c", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ebad43c255e63ac0734646fe817de5780d76b45/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ebad43c255e63ac0734646fe817de5780d76b45/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=6ebad43c255e63ac0734646fe817de5780d76b45", "patch": "@@ -504,6 +504,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n \n         match ct.ty.kind() {\n             ty::Uint(_) => {}\n+            ty::Bool => {}\n             _ => {\n                 bug!(\"symbol_names: unsupported constant of type `{}` ({:?})\", ct.ty, ct);\n             }"}, {"sha": "2b244a04d22231cb49bb143be1d165b025fd8227", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 51, "deletions": 7, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/6ebad43c255e63ac0734646fe817de5780d76b45/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ebad43c255e63ac0734646fe817de5780d76b45/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=6ebad43c255e63ac0734646fe817de5780d76b45", "patch": "@@ -297,14 +297,23 @@ pub struct IntoIter<K, V> {\n     length: usize,\n }\n \n-#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for IntoIter<K, V> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+impl<K, V> IntoIter<K, V> {\n+    /// Returns an iterator of references over the remaining items.\n+    #[inline]\n+    pub(super) fn iter(&self) -> Iter<'_, K, V> {\n         let range = Range {\n             front: self.front.as_ref().map(|f| f.reborrow()),\n             back: self.back.as_ref().map(|b| b.reborrow()),\n         };\n-        f.debug_list().entries(range).finish()\n+\n+        Iter { range: range, length: self.length }\n+    }\n+}\n+\n+#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n+impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for IntoIter<K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_list().entries(self.iter()).finish()\n     }\n }\n \n@@ -351,35 +360,53 @@ impl<K, V: fmt::Debug> fmt::Debug for Values<'_, K, V> {\n ///\n /// [`values_mut`]: BTreeMap::values_mut\n #[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n-#[derive(Debug)]\n pub struct ValuesMut<'a, K: 'a, V: 'a> {\n     inner: IterMut<'a, K, V>,\n }\n \n+#[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n+impl<K, V: fmt::Debug> fmt::Debug for ValuesMut<'_, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_list().entries(self.inner.iter().map(|(_, val)| val)).finish()\n+    }\n+}\n+\n /// An owning iterator over the keys of a `BTreeMap`.\n ///\n /// This `struct` is created by the [`into_keys`] method on [`BTreeMap`].\n /// See its documentation for more.\n ///\n /// [`into_keys`]: BTreeMap::into_keys\n #[unstable(feature = \"map_into_keys_values\", issue = \"75294\")]\n-#[derive(Debug)]\n pub struct IntoKeys<K, V> {\n     inner: IntoIter<K, V>,\n }\n \n+#[unstable(feature = \"map_into_keys_values\", issue = \"75294\")]\n+impl<K: fmt::Debug, V> fmt::Debug for IntoKeys<K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_list().entries(self.inner.iter().map(|(key, _)| key)).finish()\n+    }\n+}\n+\n /// An owning iterator over the values of a `BTreeMap`.\n ///\n /// This `struct` is created by the [`into_values`] method on [`BTreeMap`].\n /// See its documentation for more.\n ///\n /// [`into_values`]: BTreeMap::into_values\n #[unstable(feature = \"map_into_keys_values\", issue = \"75294\")]\n-#[derive(Debug)]\n pub struct IntoValues<K, V> {\n     inner: IntoIter<K, V>,\n }\n \n+#[unstable(feature = \"map_into_keys_values\", issue = \"75294\")]\n+impl<K, V: fmt::Debug> fmt::Debug for IntoValues<K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_list().entries(self.inner.iter().map(|(_, val)| val)).finish()\n+    }\n+}\n+\n /// An iterator over a sub-range of entries in a `BTreeMap`.\n ///\n /// This `struct` is created by the [`range`] method on [`BTreeMap`]. See its\n@@ -1465,6 +1492,14 @@ impl<K, V> ExactSizeIterator for IterMut<'_, K, V> {\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<K, V> FusedIterator for IterMut<'_, K, V> {}\n \n+impl<'a, K, V> IterMut<'a, K, V> {\n+    /// Returns an iterator of references over the remaining items.\n+    #[inline]\n+    pub(super) fn iter(&self) -> Iter<'_, K, V> {\n+        Iter { range: self.range.iter(), length: self.length }\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> IntoIterator for BTreeMap<K, V> {\n     type Item = (K, V);\n@@ -1949,6 +1984,15 @@ impl<'a, K, V> RangeMut<'a, K, V> {\n     unsafe fn next_unchecked(&mut self) -> (&'a K, &'a mut V) {\n         unsafe { unwrap_unchecked(self.front.as_mut()).next_unchecked() }\n     }\n+\n+    /// Returns an iterator of references over the remaining items.\n+    #[inline]\n+    pub(super) fn iter(&self) -> Range<'_, K, V> {\n+        Range {\n+            front: self.front.as_ref().map(|f| f.reborrow()),\n+            back: self.back.as_ref().map(|b| b.reborrow()),\n+        }\n+    }\n }\n \n #[stable(feature = \"btree_range\", since = \"1.17.0\")]"}, {"sha": "5d4ecb2669a96de3bc4c5db7b92687296ebc5f3e", "filename": "library/core/tests/num/wrapping.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/6ebad43c255e63ac0734646fe817de5780d76b45/library%2Fcore%2Ftests%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ebad43c255e63ac0734646fe817de5780d76b45/library%2Fcore%2Ftests%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fwrapping.rs?ref=6ebad43c255e63ac0734646fe817de5780d76b45", "patch": "@@ -0,0 +1,76 @@\n+use core::num::Wrapping;\n+\n+macro_rules! wrapping_operation {\n+    ($result:expr, $lhs:ident $op:tt $rhs:expr) => {\n+        assert_eq!($result, $lhs $op $rhs);\n+        assert_eq!($result, &$lhs $op $rhs);\n+        assert_eq!($result, $lhs $op &$rhs);\n+        assert_eq!($result, &$lhs $op &$rhs);\n+    };\n+    ($result:expr, $op:tt $expr:expr) => {\n+        assert_eq!($result, $op $expr);\n+        assert_eq!($result, $op &$expr);\n+    };\n+}\n+\n+macro_rules! wrapping_assignment {\n+    ($result:expr, $lhs:ident $op:tt $rhs:expr) => {\n+        let mut lhs1 = $lhs;\n+        lhs1 $op $rhs;\n+        assert_eq!($result, lhs1);\n+\n+        let mut lhs2 = $lhs;\n+        lhs2 $op &$rhs;\n+        assert_eq!($result, lhs2);\n+    };\n+}\n+\n+macro_rules! wrapping_test {\n+    ($type:ty, $min:expr, $max:expr) => {\n+        #[test]\n+        fn wrapping_$type() {\n+            let zero: Wrapping<$type> = Wrapping(0);\n+            let one: Wrapping<$type> = Wrapping(1);\n+            let min: Wrapping<$type> = Wrapping($min);\n+            let max: Wrapping<$type> = Wrapping($max);\n+\n+            wrapping_operation!(min, max + one);\n+            wrapping_assignment!(min, max += one);\n+            wrapping_operation!(max, min - one);\n+            wrapping_assignment!(max, min -= one);\n+            wrapping_operation!(max, max * one);\n+            wrapping_assignment!(max, max *= one);\n+            wrapping_operation!(max, max / one);\n+            wrapping_assignment!(max, max /= one);\n+            wrapping_operation!(zero, max % one);\n+            wrapping_assignment!(zero, max %= one);\n+            wrapping_operation!(zero, zero & max);\n+            wrapping_assignment!(zero, zero &= max);\n+            wrapping_operation!(max, zero | max);\n+            wrapping_assignment!(max, zero |= max);\n+            wrapping_operation!(zero, max ^ max);\n+            wrapping_assignment!(zero, max ^= max);\n+            wrapping_operation!(zero, zero << 1usize);\n+            wrapping_assignment!(zero, zero <<= 1usize);\n+            wrapping_operation!(zero, zero >> 1usize);\n+            wrapping_assignment!(zero, zero >>= 1usize);\n+            wrapping_operation!(zero, -zero);\n+            wrapping_operation!(max, !min);\n+        }\n+    };\n+}\n+\n+wrapping_test!(i8, i8::MIN, i8::MAX);\n+wrapping_test!(i16, i16::MIN, i16::MAX);\n+wrapping_test!(i32, i32::MIN, i32::MAX);\n+wrapping_test!(i64, i64::MIN, i64::MAX);\n+#[cfg(not(target_os = \"emscripten\"))]\n+wrapping_test!(i128, i128::MIN, i128::MAX);\n+wrapping_test!(isize, isize::MIN, isize::MAX);\n+wrapping_test!(u8, u8::MIN, u8::MAX);\n+wrapping_test!(u16, u16::MIN, u16::MAX);\n+wrapping_test!(u32, u32::MIN, u32::MAX);\n+wrapping_test!(u64, u64::MIN, u64::MAX);\n+#[cfg(not(target_os = \"emscripten\"))]\n+wrapping_test!(u128, u128::MIN, u128::MAX);\n+wrapping_test!(usize, usize::MIN, usize::MAX);"}, {"sha": "f12cefffbf662c1bcbde1def4377b624739eb995", "filename": "library/std/src/collections/hash/map.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6ebad43c255e63ac0734646fe817de5780d76b45/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ebad43c255e63ac0734646fe817de5780d76b45/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs?ref=6ebad43c255e63ac0734646fe817de5780d76b45", "patch": "@@ -2042,13 +2042,9 @@ impl<K, V> ExactSizeIterator for ValuesMut<'_, K, V> {\n impl<K, V> FusedIterator for ValuesMut<'_, K, V> {}\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n-impl<K, V> fmt::Debug for ValuesMut<'_, K, V>\n-where\n-    K: fmt::Debug,\n-    V: fmt::Debug,\n-{\n+impl<K, V: fmt::Debug> fmt::Debug for ValuesMut<'_, K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_list().entries(self.inner.iter()).finish()\n+        f.debug_list().entries(self.inner.iter().map(|(_, val)| val)).finish()\n     }\n }\n \n@@ -2076,7 +2072,7 @@ impl<K, V> ExactSizeIterator for IntoKeys<K, V> {\n impl<K, V> FusedIterator for IntoKeys<K, V> {}\n \n #[unstable(feature = \"map_into_keys_values\", issue = \"75294\")]\n-impl<K: Debug, V: Debug> fmt::Debug for IntoKeys<K, V> {\n+impl<K: Debug, V> fmt::Debug for IntoKeys<K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_list().entries(self.inner.iter().map(|(k, _)| k)).finish()\n     }\n@@ -2106,7 +2102,7 @@ impl<K, V> ExactSizeIterator for IntoValues<K, V> {\n impl<K, V> FusedIterator for IntoValues<K, V> {}\n \n #[unstable(feature = \"map_into_keys_values\", issue = \"75294\")]\n-impl<K: Debug, V: Debug> fmt::Debug for IntoValues<K, V> {\n+impl<K, V: Debug> fmt::Debug for IntoValues<K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_list().entries(self.inner.iter().map(|(_, v)| v)).finish()\n     }"}, {"sha": "36b49401591f5243b4849425e22ed2c717a2be70", "filename": "library/std/src/io/stdio.rs", "status": "modified", "additions": 60, "deletions": 23, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/6ebad43c255e63ac0734646fe817de5780d76b45/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ebad43c255e63ac0734646fe817de5780d76b45/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs?ref=6ebad43c255e63ac0734646fe817de5780d76b45", "patch": "@@ -9,26 +9,41 @@ use crate::cell::RefCell;\n use crate::fmt;\n use crate::io::{self, BufReader, Initializer, IoSlice, IoSliceMut, LineWriter};\n use crate::lazy::SyncOnceCell;\n+use crate::sync::atomic::{AtomicBool, Ordering};\n use crate::sync::{Mutex, MutexGuard};\n use crate::sys::stdio;\n use crate::sys_common;\n use crate::sys_common::remutex::{ReentrantMutex, ReentrantMutexGuard};\n use crate::thread::LocalKey;\n \n thread_local! {\n-    /// Stdout used by print! and println! macros\n+    /// Used by the test crate to capture the output of the print! and println! macros.\n     static LOCAL_STDOUT: RefCell<Option<Box<dyn Write + Send>>> = {\n         RefCell::new(None)\n     }\n }\n \n thread_local! {\n-    /// Stderr used by eprint! and eprintln! macros, and panics\n+    /// Used by the test crate to capture the output of the eprint! and eprintln! macros, and panics.\n     static LOCAL_STDERR: RefCell<Option<Box<dyn Write + Send>>> = {\n         RefCell::new(None)\n     }\n }\n \n+/// Flag to indicate LOCAL_STDOUT and/or LOCAL_STDERR is used.\n+///\n+/// If both are None and were never set on any thread, this flag is set to\n+/// false, and both LOCAL_STDOUT and LOCAL_STDOUT can be safely ignored on all\n+/// threads, saving some time and memory registering an unused thread local.\n+///\n+/// Note about memory ordering: This contains information about whether two\n+/// thread local variables might be in use. Although this is a global flag, the\n+/// memory ordering between threads does not matter: we only want this flag to\n+/// have a consistent order between set_print/set_panic and print_to *within\n+/// the same thread*. Within the same thread, things always have a perfectly\n+/// consistent order. So Ordering::Relaxed is fine.\n+static LOCAL_STREAMS: AtomicBool = AtomicBool::new(false);\n+\n /// A handle to a raw instance of the standard input stream of this process.\n ///\n /// This handle is not synchronized or buffered in any fashion. Constructed via\n@@ -890,10 +905,18 @@ impl fmt::Debug for StderrLock<'_> {\n #[doc(hidden)]\n pub fn set_panic(sink: Option<Box<dyn Write + Send>>) -> Option<Box<dyn Write + Send>> {\n     use crate::mem;\n-    LOCAL_STDERR.with(move |slot| mem::replace(&mut *slot.borrow_mut(), sink)).and_then(|mut s| {\n-        let _ = s.flush();\n-        Some(s)\n-    })\n+    if sink.is_none() && !LOCAL_STREAMS.load(Ordering::Relaxed) {\n+        // LOCAL_STDERR is definitely None since LOCAL_STREAMS is false.\n+        return None;\n+    }\n+    let s = LOCAL_STDERR.with(move |slot| mem::replace(&mut *slot.borrow_mut(), sink)).and_then(\n+        |mut s| {\n+            let _ = s.flush();\n+            Some(s)\n+        },\n+    );\n+    LOCAL_STREAMS.store(true, Ordering::Relaxed);\n+    s\n }\n \n /// Resets the thread-local stdout handle to the specified writer\n@@ -913,10 +936,18 @@ pub fn set_panic(sink: Option<Box<dyn Write + Send>>) -> Option<Box<dyn Write +\n #[doc(hidden)]\n pub fn set_print(sink: Option<Box<dyn Write + Send>>) -> Option<Box<dyn Write + Send>> {\n     use crate::mem;\n-    LOCAL_STDOUT.with(move |slot| mem::replace(&mut *slot.borrow_mut(), sink)).and_then(|mut s| {\n-        let _ = s.flush();\n-        Some(s)\n-    })\n+    if sink.is_none() && !LOCAL_STREAMS.load(Ordering::Relaxed) {\n+        // LOCAL_STDOUT is definitely None since LOCAL_STREAMS is false.\n+        return None;\n+    }\n+    let s = LOCAL_STDOUT.with(move |slot| mem::replace(&mut *slot.borrow_mut(), sink)).and_then(\n+        |mut s| {\n+            let _ = s.flush();\n+            Some(s)\n+        },\n+    );\n+    LOCAL_STREAMS.store(true, Ordering::Relaxed);\n+    s\n }\n \n /// Write `args` to output stream `local_s` if possible, `global_s`\n@@ -937,20 +968,26 @@ fn print_to<T>(\n ) where\n     T: Write,\n {\n-    let result = local_s\n-        .try_with(|s| {\n-            // Note that we completely remove a local sink to write to in case\n-            // our printing recursively panics/prints, so the recursive\n-            // panic/print goes to the global sink instead of our local sink.\n-            let prev = s.borrow_mut().take();\n-            if let Some(mut w) = prev {\n-                let result = w.write_fmt(args);\n-                *s.borrow_mut() = Some(w);\n-                return result;\n-            }\n-            global_s().write_fmt(args)\n+    let result = LOCAL_STREAMS\n+        .load(Ordering::Relaxed)\n+        .then(|| {\n+            local_s\n+                .try_with(|s| {\n+                    // Note that we completely remove a local sink to write to in case\n+                    // our printing recursively panics/prints, so the recursive\n+                    // panic/print goes to the global sink instead of our local sink.\n+                    let prev = s.borrow_mut().take();\n+                    if let Some(mut w) = prev {\n+                        let result = w.write_fmt(args);\n+                        *s.borrow_mut() = Some(w);\n+                        return result;\n+                    }\n+                    global_s().write_fmt(args)\n+                })\n+                .ok()\n         })\n-        .unwrap_or_else(|_| global_s().write_fmt(args));\n+        .flatten()\n+        .unwrap_or_else(|| global_s().write_fmt(args));\n \n     if let Err(e) = result {\n         panic!(\"failed printing to {}: {}\", label, e);"}, {"sha": "b2bd5f4da5012aea5cbc0a3d85ed66e639aef0de", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ebad43c255e63ac0734646fe817de5780d76b45/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ebad43c255e63ac0734646fe817de5780d76b45/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=6ebad43c255e63ac0734646fe817de5780d76b45", "patch": "@@ -226,6 +226,7 @@\n #![feature(asm)]\n #![feature(associated_type_bounds)]\n #![feature(atomic_mut_ptr)]\n+#![feature(bool_to_option)]\n #![feature(box_syntax)]\n #![feature(c_variadic)]\n #![feature(cfg_accessible)]"}, {"sha": "ef3c689bd392144b4e03a6b9bb14b93bd5b05dc6", "filename": "library/std/src/sys/unix/ext/io.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6ebad43c255e63ac0734646fe817de5780d76b45/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ebad43c255e63ac0734646fe817de5780d76b45/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fio.rs?ref=6ebad43c255e63ac0734646fe817de5780d76b45", "patch": "@@ -25,6 +25,19 @@ pub trait AsRawFd {\n     /// This method does **not** pass ownership of the raw file descriptor\n     /// to the caller. The descriptor is only guaranteed to be valid while\n     /// the original object has not yet been destroyed.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```no_run\n+    /// use std::fs::File;\n+    /// # use std::io;\n+    /// use std::os::unix::io::{AsRawFd, RawFd};\n+    ///\n+    /// let mut f = File::open(\"foo.txt\")?;\n+    /// // Note that `raw_fd` is only valid as long as `f` exists.\n+    /// let raw_fd: RawFd = f.as_raw_fd();\n+    /// # Ok::<(), io::Error>(())\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_raw_fd(&self) -> RawFd;\n }\n@@ -45,6 +58,21 @@ pub trait FromRawFd {\n     /// descriptor they are wrapping. Usage of this function could\n     /// accidentally allow violating this contract which can cause memory\n     /// unsafety in code that relies on it being true.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```no_run\n+    /// use std::fs::File;\n+    /// # use std::io;\n+    /// use std::os::unix::io::{FromRawFd, IntoRawFd, RawFd};\n+    ///\n+    /// let f = File::open(\"foo.txt\")?;\n+    /// let raw_fd: RawFd = f.into_raw_fd();\n+    /// // SAFETY: no other functions should call `from_raw_fd`, so there\n+    /// // is only one owner for the file descriptor.\n+    /// let f = unsafe { File::from_raw_fd(raw_fd) };\n+    /// # Ok::<(), io::Error>(())\n+    /// ```\n     #[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n     unsafe fn from_raw_fd(fd: RawFd) -> Self;\n }\n@@ -58,6 +86,18 @@ pub trait IntoRawFd {\n     /// This function **transfers ownership** of the underlying file descriptor\n     /// to the caller. Callers are then the unique owners of the file descriptor\n     /// and must close the descriptor once it's no longer needed.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```no_run\n+    /// use std::fs::File;\n+    /// # use std::io;\n+    /// use std::os::unix::io::{IntoRawFd, RawFd};\n+    ///\n+    /// let f = File::open(\"foo.txt\")?;\n+    /// let raw_fd: RawFd = f.into_raw_fd();\n+    /// # Ok::<(), io::Error>(())\n+    /// ```\n     #[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n     fn into_raw_fd(self) -> RawFd;\n }"}, {"sha": "0e0f915ea53c20069e7fcbfea0b1d55922a15794", "filename": "src/test/ui/imports/issue-62767.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6ebad43c255e63ac0734646fe817de5780d76b45/src%2Ftest%2Fui%2Fimports%2Fissue-62767.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ebad43c255e63ac0734646fe817de5780d76b45/src%2Ftest%2Fui%2Fimports%2Fissue-62767.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-62767.rs?ref=6ebad43c255e63ac0734646fe817de5780d76b45", "patch": "@@ -1,5 +1,4 @@\n-// check-pass\n-\n+// Minimized case from #62767.\n mod m {\n     pub enum Same {\n         Same,\n@@ -8,8 +7,22 @@ mod m {\n \n use m::*;\n \n-// The variant `Same` introduced by this import is not considered when resolving the prefix\n-// `Same::` during import validation (issue #62767).\n-use Same::Same;\n+// The variant `Same` introduced by this import is also considered when resolving the prefix\n+// `Same::` during import validation to avoid effects similar to time travel (#74556).\n+use Same::Same; //~ ERROR unresolved import `Same`\n+\n+// Case from #74556.\n+mod foo {\n+    pub mod bar {\n+        pub mod bar {\n+            pub fn foobar() {}\n+        }\n+    }\n+}\n+\n+use foo::*;\n+use bar::bar; //~ ERROR unresolved import `bar::bar`\n+              //~| ERROR inconsistent resolution for an import\n+use bar::foobar;\n \n fn main() {}"}, {"sha": "a4334bda6dd870b8d1864fa13eba6de6c63c02d8", "filename": "src/test/ui/imports/issue-62767.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6ebad43c255e63ac0734646fe817de5780d76b45/src%2Ftest%2Fui%2Fimports%2Fissue-62767.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6ebad43c255e63ac0734646fe817de5780d76b45/src%2Ftest%2Fui%2Fimports%2Fissue-62767.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-62767.stderr?ref=6ebad43c255e63ac0734646fe817de5780d76b45", "patch": "@@ -0,0 +1,21 @@\n+error: inconsistent resolution for an import\n+  --> $DIR/issue-62767.rs:24:5\n+   |\n+LL | use bar::bar;\n+   |     ^^^^^^^^\n+\n+error[E0432]: unresolved import `Same`\n+  --> $DIR/issue-62767.rs:12:5\n+   |\n+LL | use Same::Same;\n+   |     ^^^^ `Same` is a variant, not a module\n+\n+error[E0432]: unresolved import `bar::bar`\n+  --> $DIR/issue-62767.rs:24:5\n+   |\n+LL | use bar::bar;\n+   |     ^^^^^^^^ no `bar` in `foo::bar::bar`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0432`."}, {"sha": "c49a13f1065b5c7c9921577a5480d0c2f8d7fa00", "filename": "src/test/ui/lint/lint-const-item-mutation.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6ebad43c255e63ac0734646fe817de5780d76b45/src%2Ftest%2Fui%2Flint%2Flint-const-item-mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ebad43c255e63ac0734646fe817de5780d76b45/src%2Ftest%2Fui%2Flint%2Flint-const-item-mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-const-item-mutation.rs?ref=6ebad43c255e63ac0734646fe817de5780d76b45", "patch": "@@ -9,9 +9,26 @@ impl MyStruct {\n     fn use_mut(&mut self) {}\n }\n \n+struct Mutable {\n+    msg: &'static str,\n+}\n+impl Drop for Mutable {\n+    fn drop(&mut self) {\n+        println!(\"{}\", self.msg);\n+    }\n+}\n+\n+struct Mutable2 { // this one has drop glue but not a Drop impl\n+    msg: &'static str,\n+    other: String,\n+}\n+\n const ARRAY: [u8; 1] = [25];\n const MY_STRUCT: MyStruct = MyStruct { field: true, inner_array: ['a'], raw_ptr: 2 as *mut u8 };\n const RAW_PTR: *mut u8 = 1 as *mut u8;\n+const MUTABLE: Mutable = Mutable { msg: \"\" };\n+const MUTABLE2: Mutable2 = Mutable2 { msg: \"\", other: String::new() };\n+const VEC: Vec<i32> = Vec::new();\n \n fn main() {\n     ARRAY[0] = 5; //~ WARN attempting to modify\n@@ -29,4 +46,8 @@ fn main() {\n         *RAW_PTR = 0;\n         *MY_STRUCT.raw_ptr = 0;\n     }\n+\n+    MUTABLE.msg = \"wow\"; // no warning, because Drop observes the mutation\n+    MUTABLE2.msg = \"wow\"; //~ WARN attempting to modify\n+    VEC.push(0); //~ WARN taking a mutable reference to a `const` item\n }"}, {"sha": "11b5124b2d26ab956b5e18a2ad56666e545a108f", "filename": "src/test/ui/lint/lint-const-item-mutation.stderr", "status": "modified", "additions": 51, "deletions": 13, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/6ebad43c255e63ac0734646fe817de5780d76b45/src%2Ftest%2Fui%2Flint%2Flint-const-item-mutation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6ebad43c255e63ac0734646fe817de5780d76b45/src%2Ftest%2Fui%2Flint%2Flint-const-item-mutation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-const-item-mutation.stderr?ref=6ebad43c255e63ac0734646fe817de5780d76b45", "patch": "@@ -1,45 +1,45 @@\n warning: attempting to modify a `const` item\n-  --> $DIR/lint-const-item-mutation.rs:17:5\n+  --> $DIR/lint-const-item-mutation.rs:34:5\n    |\n LL |     ARRAY[0] = 5;\n    |     ^^^^^^^^^^^^\n    |\n    = note: `#[warn(const_item_mutation)]` on by default\n    = note: each usage of a `const` item creates a new temporary - the original `const` item will not be modified\n note: `const` item defined here\n-  --> $DIR/lint-const-item-mutation.rs:12:1\n+  --> $DIR/lint-const-item-mutation.rs:26:1\n    |\n LL | const ARRAY: [u8; 1] = [25];\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: attempting to modify a `const` item\n-  --> $DIR/lint-const-item-mutation.rs:18:5\n+  --> $DIR/lint-const-item-mutation.rs:35:5\n    |\n LL |     MY_STRUCT.field = false;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: each usage of a `const` item creates a new temporary - the original `const` item will not be modified\n note: `const` item defined here\n-  --> $DIR/lint-const-item-mutation.rs:13:1\n+  --> $DIR/lint-const-item-mutation.rs:27:1\n    |\n LL | const MY_STRUCT: MyStruct = MyStruct { field: true, inner_array: ['a'], raw_ptr: 2 as *mut u8 };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: attempting to modify a `const` item\n-  --> $DIR/lint-const-item-mutation.rs:19:5\n+  --> $DIR/lint-const-item-mutation.rs:36:5\n    |\n LL |     MY_STRUCT.inner_array[0] = 'b';\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: each usage of a `const` item creates a new temporary - the original `const` item will not be modified\n note: `const` item defined here\n-  --> $DIR/lint-const-item-mutation.rs:13:1\n+  --> $DIR/lint-const-item-mutation.rs:27:1\n    |\n LL | const MY_STRUCT: MyStruct = MyStruct { field: true, inner_array: ['a'], raw_ptr: 2 as *mut u8 };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: taking a mutable reference to a `const` item\n-  --> $DIR/lint-const-item-mutation.rs:20:5\n+  --> $DIR/lint-const-item-mutation.rs:37:5\n    |\n LL |     MY_STRUCT.use_mut();\n    |     ^^^^^^^^^^^^^^^^^^^\n@@ -52,38 +52,76 @@ note: mutable reference created due to call to this method\n LL |     fn use_mut(&mut self) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^\n note: `const` item defined here\n-  --> $DIR/lint-const-item-mutation.rs:13:1\n+  --> $DIR/lint-const-item-mutation.rs:27:1\n    |\n LL | const MY_STRUCT: MyStruct = MyStruct { field: true, inner_array: ['a'], raw_ptr: 2 as *mut u8 };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: taking a mutable reference to a `const` item\n-  --> $DIR/lint-const-item-mutation.rs:21:5\n+  --> $DIR/lint-const-item-mutation.rs:38:5\n    |\n LL |     &mut MY_STRUCT;\n    |     ^^^^^^^^^^^^^^\n    |\n    = note: each usage of a `const` item creates a new temporary\n    = note: the mutable reference will refer to this temporary, not the original `const` item\n note: `const` item defined here\n-  --> $DIR/lint-const-item-mutation.rs:13:1\n+  --> $DIR/lint-const-item-mutation.rs:27:1\n    |\n LL | const MY_STRUCT: MyStruct = MyStruct { field: true, inner_array: ['a'], raw_ptr: 2 as *mut u8 };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: taking a mutable reference to a `const` item\n-  --> $DIR/lint-const-item-mutation.rs:22:5\n+  --> $DIR/lint-const-item-mutation.rs:39:5\n    |\n LL |     (&mut MY_STRUCT).use_mut();\n    |     ^^^^^^^^^^^^^^^^\n    |\n    = note: each usage of a `const` item creates a new temporary\n    = note: the mutable reference will refer to this temporary, not the original `const` item\n note: `const` item defined here\n-  --> $DIR/lint-const-item-mutation.rs:13:1\n+  --> $DIR/lint-const-item-mutation.rs:27:1\n    |\n LL | const MY_STRUCT: MyStruct = MyStruct { field: true, inner_array: ['a'], raw_ptr: 2 as *mut u8 };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: 6 warnings emitted\n+warning: attempting to modify a `const` item\n+  --> $DIR/lint-const-item-mutation.rs:51:5\n+   |\n+LL |     MUTABLE2.msg = \"wow\";\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: each usage of a `const` item creates a new temporary - the original `const` item will not be modified\n+note: `const` item defined here\n+  --> $DIR/lint-const-item-mutation.rs:30:1\n+   |\n+LL | const MUTABLE2: Mutable2 = Mutable2 { msg: \"\", other: String::new() };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+warning: taking a mutable reference to a `const` item\n+  --> $DIR/lint-const-item-mutation.rs:52:5\n+   |\n+LL |     VEC.push(0);\n+   |     ^^^^^^^^^^^\n+   |\n+   = note: each usage of a `const` item creates a new temporary\n+   = note: the mutable reference will refer to this temporary, not the original `const` item\n+note: mutable reference created due to call to this method\n+  --> $SRC_DIR/alloc/src/vec.rs:LL:COL\n+   |\n+LL | /     pub fn push(&mut self, value: T) {\n+LL | |         // This will panic or abort if we would allocate > isize::MAX bytes\n+LL | |         // or if the length increment would overflow for zero-sized types.\n+LL | |         if self.len == self.buf.capacity() {\n+...  |\n+LL | |         }\n+LL | |     }\n+   | |_____^\n+note: `const` item defined here\n+  --> $DIR/lint-const-item-mutation.rs:31:1\n+   |\n+LL | const VEC: Vec<i32> = Vec::new();\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+warning: 8 warnings emitted\n "}, {"sha": "61ba255dac04d78d0453617b59161e38a5eb0f30", "filename": "src/test/ui/symbol-names/issue-76365.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6ebad43c255e63ac0734646fe817de5780d76b45/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-76365.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ebad43c255e63ac0734646fe817de5780d76b45/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-76365.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-76365.rs?ref=6ebad43c255e63ac0734646fe817de5780d76b45", "patch": "@@ -0,0 +1,18 @@\n+// check-pass\n+// revisions: legacy v0\n+//[legacy]compile-flags: -Z symbol-mangling-version=legacy --crate-type=lib\n+    //[v0]compile-flags: -Z symbol-mangling-version=v0 --crate-type=lib\n+\n+#![feature(min_const_generics)]\n+\n+pub struct Bar<const F: bool>;\n+\n+impl Bar<true> {\n+    pub fn foo() {}\n+}\n+\n+impl<const F: bool> Bar<F> {\n+    pub fn bar() {}\n+}\n+\n+fn main() {}"}, {"sha": "f0bc479ee0ff28d2478b75fec605a5fb377452b0", "filename": "src/test/ui/wrapping-int-combinations.rs", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/8876ffc9235dade728e1fbc4be4c85415fdd0bcd/src%2Ftest%2Fui%2Fwrapping-int-combinations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8876ffc9235dade728e1fbc4be4c85415fdd0bcd/src%2Ftest%2Fui%2Fwrapping-int-combinations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwrapping-int-combinations.rs?ref=8876ffc9235dade728e1fbc4be4c85415fdd0bcd", "patch": "@@ -1,77 +0,0 @@\n-// run-pass\n-\n-use std::num::Wrapping;\n-\n-macro_rules! wrapping_operation {\n-    ($result:expr, $lhs:ident $op:tt $rhs:expr) => {\n-        assert_eq!($result, $lhs $op $rhs);\n-        assert_eq!($result, &$lhs $op $rhs);\n-        assert_eq!($result, $lhs $op &$rhs);\n-        assert_eq!($result, &$lhs $op &$rhs);\n-    };\n-    ($result:expr, $op:tt $expr:expr) => {\n-        assert_eq!($result, $op $expr);\n-        assert_eq!($result, $op &$expr);\n-    };\n-}\n-\n-macro_rules! wrapping_assignment {\n-    ($result:expr, $lhs:ident $op:tt $rhs:expr) => {\n-        let mut lhs1 = $lhs;\n-        lhs1 $op $rhs;\n-        assert_eq!($result, lhs1);\n-\n-        let mut lhs2 = $lhs;\n-        lhs2 $op &$rhs;\n-        assert_eq!($result, lhs2);\n-    };\n-}\n-\n-macro_rules! wrapping_test {\n-    ($type:ty, $min:expr, $max:expr) => {\n-        let zero: Wrapping<$type> = Wrapping(0);\n-        let one: Wrapping<$type> = Wrapping(1);\n-        let min: Wrapping<$type> = Wrapping($min);\n-        let max: Wrapping<$type> = Wrapping($max);\n-\n-        wrapping_operation!(min, max + one);\n-        wrapping_assignment!(min, max += one);\n-        wrapping_operation!(max, min - one);\n-        wrapping_assignment!(max, min -= one);\n-        wrapping_operation!(max, max * one);\n-        wrapping_assignment!(max, max *= one);\n-        wrapping_operation!(max, max / one);\n-        wrapping_assignment!(max, max /= one);\n-        wrapping_operation!(zero, max % one);\n-        wrapping_assignment!(zero, max %= one);\n-        wrapping_operation!(zero, zero & max);\n-        wrapping_assignment!(zero, zero &= max);\n-        wrapping_operation!(max, zero | max);\n-        wrapping_assignment!(max, zero |= max);\n-        wrapping_operation!(zero, max ^ max);\n-        wrapping_assignment!(zero, max ^= max);\n-        wrapping_operation!(zero, zero << 1usize);\n-        wrapping_assignment!(zero, zero <<= 1usize);\n-        wrapping_operation!(zero, zero >> 1usize);\n-        wrapping_assignment!(zero, zero >>= 1usize);\n-        wrapping_operation!(zero, -zero);\n-        wrapping_operation!(max, !min);\n-    };\n-}\n-\n-fn main() {\n-    wrapping_test!(i8, std::i8::MIN, std::i8::MAX);\n-    wrapping_test!(i16, std::i16::MIN, std::i16::MAX);\n-    wrapping_test!(i32, std::i32::MIN, std::i32::MAX);\n-    wrapping_test!(i64, std::i64::MIN, std::i64::MAX);\n-    #[cfg(not(target_os = \"emscripten\"))]\n-    wrapping_test!(i128, std::i128::MIN, std::i128::MAX);\n-    wrapping_test!(isize, std::isize::MIN, std::isize::MAX);\n-    wrapping_test!(u8, std::u8::MIN, std::u8::MAX);\n-    wrapping_test!(u16, std::u16::MIN, std::u16::MAX);\n-    wrapping_test!(u32, std::u32::MIN, std::u32::MAX);\n-    wrapping_test!(u64, std::u64::MIN, std::u64::MAX);\n-    #[cfg(not(target_os = \"emscripten\"))]\n-    wrapping_test!(u128, std::u128::MIN, std::u128::MAX);\n-    wrapping_test!(usize, std::usize::MIN, std::usize::MAX);\n-}"}, {"sha": "e1dc9111bf3260580c68eccce80c22f906fd7387", "filename": "src/tools/build-manifest/src/main.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ebad43c255e63ac0734646fe817de5780d76b45/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ebad43c255e63ac0734646fe817de5780d76b45/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=6ebad43c255e63ac0734646fe817de5780d76b45", "patch": "@@ -294,6 +294,10 @@ impl Builder {\n         if self.versions.channel() != rust_version {\n             self.write_channel_files(&rust_version, &manifest);\n         }\n+        if self.versions.channel() == \"stable\" {\n+            let major_minor = rust_version.split('.').take(2).collect::<Vec<_>>().join(\".\");\n+            self.write_channel_files(&major_minor, &manifest);\n+        }\n     }\n \n     /// If a tool does not pass its tests, don't ship it."}]}