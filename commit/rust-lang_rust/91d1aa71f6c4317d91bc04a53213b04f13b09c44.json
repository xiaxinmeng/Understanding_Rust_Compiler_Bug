{"sha": "91d1aa71f6c4317d91bc04a53213b04f13b09c44", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxZDFhYTcxZjZjNDMxN2Q5MWJjMDRhNTMyMTNiMDRmMTNiMDljNDQ=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2015-04-04T10:03:59Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2015-04-05T16:52:57Z"}, "message": "Format all str docs to 80 char line breaks", "tree": {"sha": "2c3b357971de6548555249b16a26d46d5dd9f93b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c3b357971de6548555249b16a26d46d5dd9f93b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91d1aa71f6c4317d91bc04a53213b04f13b09c44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91d1aa71f6c4317d91bc04a53213b04f13b09c44", "html_url": "https://github.com/rust-lang/rust/commit/91d1aa71f6c4317d91bc04a53213b04f13b09c44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91d1aa71f6c4317d91bc04a53213b04f13b09c44/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2bff14da1e1c5600b4d66a8324b4e9f522cb559", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2bff14da1e1c5600b4d66a8324b4e9f522cb559", "html_url": "https://github.com/rust-lang/rust/commit/c2bff14da1e1c5600b4d66a8324b4e9f522cb559"}], "stats": {"total": 283, "additions": 174, "deletions": 109}, "files": [{"sha": "7c562baa82b07a1321d49da9b01fdcd39dbb38ed", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 174, "deletions": 109, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/91d1aa71f6c4317d91bc04a53213b04f13b09c44/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91d1aa71f6c4317d91bc04a53213b04f13b09c44/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=91d1aa71f6c4317d91bc04a53213b04f13b09c44", "patch": "@@ -432,7 +432,8 @@ impl str {\n \n     /// Replaces all occurrences of one string with another.\n     ///\n-    /// `replace` takes two arguments, a sub-`&str` to find in `self`, and a second `&str` to\n+    /// `replace` takes two arguments, a sub-`&str` to find in `self`, and a\n+    /// second `&str` to\n     /// replace it with. If the original `&str` isn't found, no change occurs.\n     ///\n     /// # Examples\n@@ -584,14 +585,16 @@ impl str {\n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by a pattern.\n     ///\n-    /// The pattern can be a simple `&str`, `char`, or a closure that determines\n-    /// the split.\n-    /// Additional libraries might provide more complex patterns like regular expressions.\n+    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// determines the split.\n+    /// Additional libraries might provide more complex patterns like\n+    /// regular expressions.\n     ///\n     /// # Iterator behavior\n     ///\n-    /// The returned iterator will be double ended if the pattern allows a reverse search\n-    /// and forward/reverse search yields the same elements. This is true for, eg, `char` but not\n+    /// The returned iterator will be double ended if the pattern allows a\n+    /// reverse search and forward/reverse search yields the same elements.\n+    /// This is true for, eg, `char` but not\n     /// for `&str`.\n     ///\n     /// If the pattern allows a reverse search but its results might differ\n@@ -615,13 +618,13 @@ impl str {\n     /// assert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n     /// ```\n     ///\n-    /// More complex patterns with a lambda:\n+    /// More complex patterns with closures:\n     ///\n     /// ```\n     /// let v: Vec<&str> = \"abc1def2ghi\".split(|c: char| c.is_numeric()).collect();\n     /// assert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n     ///\n-    /// let v: Vec<&str> = \"lionXtigerXleopard\".split(|c: char| c.is_uppercase()).collect();\n+    /// let v: Vec<&str> = \"lionXtigerXleopard\".split(char::is_uppercase).collect();\n     /// assert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -632,14 +635,17 @@ impl str {\n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by a pattern and yielded in reverse order.\n     ///\n-    /// The pattern can be a simple `&str`, `char`, or a closure that determines\n-    /// the split.\n-    /// Additional libraries might provide more complex patterns like regular expressions.\n+    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// determines the split.\n+    /// Additional libraries might provide more complex patterns like\n+    /// regular expressions.\n     ///\n     /// # Iterator behavior\n     ///\n-    /// The returned iterator requires that the pattern supports a reverse search,\n-    /// and it will be double ended if a forward/reverse search yields the same elements.\n+    /// The returned iterator requires that the pattern supports a\n+    /// reverse search,\n+    /// and it will be double ended if a forward/reverse search yields\n+    /// the same elements.\n     ///\n     /// For iterating from the front, `split()` can be used.\n     ///\n@@ -661,13 +667,13 @@ impl str {\n     /// assert_eq!(v, [\"leopard\", \"tiger\", \"lion\"]);\n     /// ```\n     ///\n-    /// More complex patterns with a lambda:\n+    /// More complex patterns with closures:\n     ///\n     /// ```rust\n     /// let v: Vec<&str> = \"abc1def2ghi\".rsplit(|c: char| c.is_numeric()).collect();\n     /// assert_eq!(v, [\"ghi\", \"def\", \"abc\"]);\n     ///\n-    /// let v: Vec<&str> = \"lionXtigerXleopard\".rsplit(|c: char| c.is_uppercase()).collect();\n+    /// let v: Vec<&str> = \"lionXtigerXleopard\".rsplit(char::is_uppercase).collect();\n     /// assert_eq!(v, [\"leopard\", \"tiger\", \"lion\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -680,20 +686,23 @@ impl str {\n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by a pattern.\n     ///\n-    /// The pattern can be a simple `&str`, `char`, or a closure that determines\n-    /// the split.\n-    /// Additional libraries might provide more complex patterns like regular expressions.\n+    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// determines the split.\n+    /// Additional libraries might provide more complex patterns\n+    /// like regular expressions.\n     ///\n-    /// Equivalent to `split`, except that the trailing substring is skipped if empty.\n+    /// Equivalent to `split`, except that the trailing substring\n+    /// is skipped if empty.\n     ///\n-    /// This method can be used for string data that is _terminated_, rather than\n-    /// _seperated_ by some string.\n+    /// This method can be used for string data that is _terminated_,\n+    /// rather than _seperated_ by a pattern.\n     ///\n     /// # Iterator behavior\n     ///\n-    /// The returned iterator will be double ended if the pattern allows a reverse search\n-    /// and forward/reverse search yields the same elements. This is true for, eg, `char` but not\n-    /// for `&str`.\n+    /// The returned iterator will be double ended if the pattern allows a\n+    /// reverse search\n+    /// and forward/reverse search yields the same elements. This is true\n+    /// for, eg, `char` but not for `&str`.\n     ///\n     /// If the pattern allows a reverse search but its results might differ\n     /// from a forward search, `rsplit_terminator()` can be used.\n@@ -710,7 +719,7 @@ impl str {\n     /// assert_eq!(v, [\"A\", \"\", \"B\", \"\"]);\n     /// ```\n     ///\n-    /// More complex patterns with a lambda:\n+    /// More complex patterns with closures:\n     ///\n     /// ```\n     /// let v: Vec<&str> = \"abc1def2ghi3\".split_terminator(|c: char| c.is_numeric()).collect();\n@@ -724,19 +733,22 @@ impl str {\n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by a pattern and yielded in reverse order.\n     ///\n-    /// The pattern can be a simple `&str`, `char`, or a closure that determines\n-    /// the split.\n-    /// Additional libraries might provide more complex patterns like regular expressions.\n+    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// determines the split.\n+    /// Additional libraries might provide more complex patterns like\n+    /// regular expressions.\n     ///\n-    /// Equivalent to `split`, except that the trailing substring is skipped if empty.\n+    /// Equivalent to `split`, except that the trailing substring is\n+    /// skipped if empty.\n     ///\n-    /// This method can be used for string data that is _terminated_, rather than\n-    /// _seperated_ by some string.\n+    /// This method can be used for string data that is _terminated_,\n+    /// rather than _seperated_ by a pattern.\n     ///\n     /// # Iterator behavior\n     ///\n-    /// The returned iterator requires that the pattern supports a reverse search,\n-    /// and it will be double ended if a forward/reverse search yields the same elements.\n+    /// The returned iterator requires that the pattern supports a\n+    /// reverse search, and it will be double ended if a forward/reverse\n+    /// search yields the same elements.\n     ///\n     /// For iterating from the front, `split_terminator()` can be used.\n     ///\n@@ -752,7 +764,7 @@ impl str {\n     /// assert_eq!(v, [\"\", \"B\", \"\", \"A\"]);\n     /// ```\n     ///\n-    /// More complex patterns with a lambda:\n+    /// More complex patterns with closures:\n     ///\n     /// ```\n     /// let v: Vec<&str> = \"abc1def2ghi3\".rsplit_terminator(|c: char| c.is_numeric()).collect();\n@@ -771,13 +783,15 @@ impl str {\n     ///\n     /// The last element returned, if any, will contain the remainder of the\n     /// string.\n-    /// The pattern can be a simple `&str`, `char`, or a closure that determines\n-    /// the split.\n-    /// Additional libraries might provide more complex patterns like regular expressions.\n+    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// determines the split.\n+    /// Additional libraries might provide more complex patterns like\n+    /// regular expressions.\n     ///\n     /// # Iterator behavior\n     ///\n-    /// The returned iterator will not be double ended, because it is not efficient to support.\n+    /// The returned iterator will not be double ended, because it is\n+    /// not efficient to support.\n     ///\n     /// If the pattern allows a reverse search, `rsplitn()` can be used.\n     ///\n@@ -799,7 +813,7 @@ impl str {\n     /// assert_eq!(v, [\"\"]);\n     /// ```\n     ///\n-    /// More complex patterns with a lambda:\n+    /// More complex patterns with closures:\n     ///\n     /// ```\n     /// let v: Vec<&str> = \"abc1def2ghi\".splitn(2, |c: char| c.is_numeric()).collect();\n@@ -817,13 +831,15 @@ impl str {\n     /// The last element returned, if any, will contain the remainder of the\n     /// string.\n     ///\n-    /// The pattern can be a simple `&str`, `char`, or a closure that determines\n-    /// the split.\n-    /// Additional libraries might provide more complex patterns like regular expressions.\n+    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// determines the split.\n+    /// Additional libraries might provide more complex patterns like\n+    /// regular expressions.\n     ///\n     /// # Iterator behavior\n     ///\n-    /// The returned iterator will not be double ended, because it is not efficient to support.\n+    /// The returned iterator will not be double ended, because it is not\n+    /// efficient to support.\n     ///\n     /// `splitn()` can be used for splitting from the front.\n     ///\n@@ -842,7 +858,7 @@ impl str {\n     /// assert_eq!(v, [\"leopard\", \"lion::tiger\"]);\n     /// ```\n     ///\n-    /// More complex patterns with a lambda:\n+    /// More complex patterns with closures:\n     ///\n     /// ```\n     /// let v: Vec<&str> = \"abc1def2ghi\".rsplitn(2, |c: char| c.is_numeric()).collect();\n@@ -857,14 +873,17 @@ impl str {\n \n     /// An iterator over the matches of a pattern within `self`.\n     ///\n-    /// The pattern can be a simple `&str`, `char`, or a closure that determines\n-    /// the split.\n-    /// Additional libraries might provide more complex patterns like regular expressions.\n+    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// determines the split.\n+    /// Additional libraries might provide more complex patterns like\n+    /// regular expressions.\n     ///\n     /// # Iterator behavior\n     ///\n-    /// The returned iterator will be double ended if the pattern allows a reverse search\n-    /// and forward/reverse search yields the same elements. This is true for, eg, `char` but not\n+    /// The returned iterator will be double ended if the pattern allows\n+    /// a reverse search\n+    /// and forward/reverse search yields the same elements. This is true\n+    /// for, eg, `char` but not\n     /// for `&str`.\n     ///\n     /// If the pattern allows a reverse search but its results might differ\n@@ -886,16 +905,20 @@ impl str {\n         core_str::StrExt::matches(&self[..], pat)\n     }\n \n-    /// An iterator over the matches of a pattern within `self`, yielded in reverse order.\n+    /// An iterator over the matches of a pattern within `self`, yielded in\n+    /// reverse order.\n     ///\n-    /// The pattern can be a simple `&str`, `char`, or a closure that determines\n-    /// the split.\n-    /// Additional libraries might provide more complex patterns like regular expressions.\n+    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// determines the split.\n+    /// Additional libraries might provide more complex patterns like\n+    /// regular expressions.\n     ///\n     /// # Iterator behavior\n     ///\n-    /// The returned iterator requires that the pattern supports a reverse search,\n-    /// and it will be double ended if a forward/reverse search yields the same elements.\n+    /// The returned iterator requires that the pattern supports a\n+    /// reverse search,\n+    /// and it will be double ended if a forward/reverse search yields\n+    /// the same elements.\n     ///\n     /// For iterating from the front, `matches()` can be used.\n     ///\n@@ -917,20 +940,25 @@ impl str {\n         core_str::StrExt::rmatches(&self[..], pat)\n     }\n \n-    /// An iterator over the start and end indices of the disjoint matches of a pattern within\n-    /// `self`.\n+    /// An iterator over the start and end indices of the disjoint matches\n+    /// of a pattern within `self`.\n     ///\n-    /// For matches of `pat` within `self` that overlap, only the indices corresponding to the first\n+    /// For matches of `pat` within `self` that overlap, only the indices\n+    /// corresponding to the first\n     /// match are returned.\n     ///\n-    /// The pattern can be a simple `&str`, `char`, or a closure that determines\n+    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// determines\n     /// the split.\n-    /// Additional libraries might provide more complex patterns like regular expressions.\n+    /// Additional libraries might provide more complex patterns like\n+    /// regular expressions.\n     ///\n     /// # Iterator behavior\n     ///\n-    /// The returned iterator will be double ended if the pattern allows a reverse search\n-    /// and forward/reverse search yields the same elements. This is true for, eg, `char` but not\n+    /// The returned iterator will be double ended if the pattern allows a\n+    /// reverse search\n+    /// and forward/reverse search yields the same elements. This is true for,\n+    /// eg, `char` but not\n     /// for `&str`.\n     ///\n     /// If the pattern allows a reverse search but its results might differ\n@@ -941,10 +969,10 @@ impl str {\n     /// ```\n     /// # #![feature(collections)]\n     /// let v: Vec<(usize, usize)> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n-    /// assert_eq!(v, [(0,3), (6,9), (12,15)]);\n+    /// assert_eq!(v, [(0, 3), (6, 9), (12, 15)]);\n     ///\n     /// let v: Vec<(usize, usize)> = \"1abcabc2\".match_indices(\"abc\").collect();\n-    /// assert_eq!(v, [(1,4), (4,7)]);\n+    /// assert_eq!(v, [(1, 4), (4, 7)]);\n     ///\n     /// let v: Vec<(usize, usize)> = \"ababa\".match_indices(\"aba\").collect();\n     /// assert_eq!(v, [(0, 3)]); // only the first `aba`\n@@ -957,20 +985,26 @@ impl str {\n         core_str::StrExt::match_indices(&self[..], pat)\n     }\n \n-    /// An iterator over the start and end indices of the disjoint matches of a pattern within\n+    /// An iterator over the start and end indices of the disjoint matches of\n+    /// a pattern within\n     /// `self`, yielded in reverse order.\n     ///\n-    /// For matches of `pat` within `self` that overlap, only the indices corresponding to the last\n+    /// For matches of `pat` within `self` that overlap, only the indices\n+    /// corresponding to the last\n     /// match are returned.\n     ///\n-    /// The pattern can be a simple `&str`, `char`, or a closure that determines\n+    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// determines\n     /// the split.\n-    /// Additional libraries might provide more complex patterns like regular expressions.\n+    /// Additional libraries might provide more complex patterns like\n+    /// regular expressions.\n     ///\n     /// # Iterator behavior\n     ///\n-    /// The returned iterator requires that the pattern supports a reverse search,\n-    /// and it will be double ended if a forward/reverse search yields the same elements.\n+    /// The returned iterator requires that the pattern supports a\n+    /// reverse search,\n+    /// and it will be double ended if a forward/reverse search yields\n+    /// the same elements.\n     ///\n     /// For iterating from the front, `match_indices()` can be used.\n     ///\n@@ -979,10 +1013,10 @@ impl str {\n     /// ```\n     /// # #![feature(collections)]\n     /// let v: Vec<(usize, usize)> = \"abcXXXabcYYYabc\".rmatch_indices(\"abc\").collect();\n-    /// assert_eq!(v, [(12,15), (6,9), (0,3)]);\n+    /// assert_eq!(v, [(12, 15), (6, 9), (0, 3)]);\n     ///\n     /// let v: Vec<(usize, usize)> = \"1abcabc2\".rmatch_indices(\"abc\").collect();\n-    /// assert_eq!(v, [(4,7), (1,4)]);\n+    /// assert_eq!(v, [(4, 7), (1, 4)]);\n     ///\n     /// let v: Vec<(usize, usize)> = \"ababa\".rmatch_indices(\"aba\").collect();\n     /// assert_eq!(v, [(2, 5)]); // only the last `aba`\n@@ -1023,7 +1057,8 @@ impl str {\n         core_str::StrExt::lines(&self[..])\n     }\n \n-    /// An iterator over the lines of a string, separated by either `\\n` or `\\r\\n`.\n+    /// An iterator over the lines of a string, separated by either\n+    /// `\\n` or `\\r\\n`.\n     ///\n     /// As with `.lines()`, this does not include an empty trailing line.\n     ///\n@@ -1085,7 +1120,8 @@ impl str {\n     ///\n     /// # Unsafety\n     ///\n-    /// Caller must check both UTF-8 character boundaries and the boundaries of the entire slice as\n+    /// Caller must check both UTF-8 character boundaries and the boundaries\n+    /// of the entire slice as\n     /// well.\n     ///\n     /// # Examples\n@@ -1128,13 +1164,15 @@ impl str {\n         core_str::StrExt::ends_with(&self[..], pat)\n     }\n \n-    /// Returns a string with all pre- and suffixes that match a pattern repeatedly removed.\n+    /// Returns a string with all pre- and suffixes that match a pattern\n+    /// repeatedly removed.\n     ///\n-    /// The pattern can be a simple `&str`, or a closure that determines the split.\n+    /// The pattern can be a simple `char`, or a closure that determines\n+    /// the split.\n     ///\n     /// # Examples\n     ///\n-    /// Simple `&str` patterns:\n+    /// Simple patterns:\n     ///\n     /// ```\n     /// assert_eq!(\"11foo1bar11\".trim_matches('1'), \"foo1bar\");\n@@ -1143,7 +1181,7 @@ impl str {\n     /// assert_eq!(\"12foo1bar12\".trim_matches(x), \"foo1bar\");\n     /// ```\n     ///\n-    /// More complex patterns with a lambda:\n+    /// More complex patterns with closures:\n     ///\n     /// ```\n     /// assert_eq!(\"123foo1bar123\".trim_matches(|c: char| c.is_numeric()), \"foo1bar\");\n@@ -1155,13 +1193,15 @@ impl str {\n         core_str::StrExt::trim_matches(&self[..], pat)\n     }\n \n-    /// Returns a string with all prefixes that match a pattern repeatedly removed.\n+    /// Returns a string with all prefixes that match a pattern\n+    /// repeatedly removed.\n     ///\n-    /// The pattern can be a simple `&str`, or a closure that determines the split.\n+    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// determines the split.\n     ///\n     /// # Examples\n     ///\n-    /// Simple `&str` patterns:\n+    /// Simple patterns:\n     ///\n     /// ```\n     /// assert_eq!(\"11foo1bar11\".trim_left_matches('1'), \"foo1bar11\");\n@@ -1170,7 +1210,7 @@ impl str {\n     /// assert_eq!(\"12foo1bar12\".trim_left_matches(x), \"foo1bar12\");\n     /// ```\n     ///\n-    /// More complex patterns with a lambda:\n+    /// More complex patterns with closures:\n     ///\n     /// ```\n     /// assert_eq!(\"123foo1bar123\".trim_left_matches(|c: char| c.is_numeric()), \"foo1bar123\");\n@@ -1180,21 +1220,23 @@ impl str {\n         core_str::StrExt::trim_left_matches(&self[..], pat)\n     }\n \n-    /// Returns a string with all suffixes that match a pattern repeatedly removed.\n+    /// Returns a string with all suffixes that match a pattern\n+    /// repeatedly removed.\n     ///\n-    /// The pattern can be a simple `&str`, or a closure that determines the split.\n+    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// determines the split.\n     ///\n     /// # Examples\n     ///\n-    /// Simple `&str` patterns:\n+    /// Simple patterns:\n     ///\n     /// ```\n     /// assert_eq!(\"11foo1bar11\".trim_right_matches('1'), \"11foo1bar\");\n     /// let x: &[_] = &['1', '2'];\n     /// assert_eq!(\"12foo1bar12\".trim_right_matches(x), \"12foo1bar\");\n     /// ```\n     ///\n-    /// More complex patterns with a lambda:\n+    /// More complex patterns with closures:\n     ///\n     /// ```\n     /// assert_eq!(\"123foo1bar123\".trim_right_matches(|c: char| c.is_numeric()), \"123foo1bar\");\n@@ -1206,9 +1248,11 @@ impl str {\n         core_str::StrExt::trim_right_matches(&self[..], pat)\n     }\n \n-    /// Check that `index`-th byte lies at the start and/or end of a UTF-8 code point sequence.\n+    /// Check that `index`-th byte lies at the start and/or end of a\n+    /// UTF-8 code point sequence.\n     ///\n-    /// The start and end of the string (when `index == self.len()`) are considered to be\n+    /// The start and end of the string (when `index == self.len()`) are\n+    /// considered to be\n     /// boundaries.\n     ///\n     /// # Panics\n@@ -1251,7 +1295,8 @@ impl str {\n     ///\n     /// # Examples\n     ///\n-    /// This example manually iterates through the characters of a string; this should normally be\n+    /// This example manually iterates through the characters of a string;\n+    /// this should normally be\n     /// done by `.chars()` or `.char_indices()`.\n     ///\n     /// ```\n@@ -1302,7 +1347,8 @@ impl str {\n     ///\n     /// # Examples\n     ///\n-    /// This example manually iterates through the characters of a string; this should normally be\n+    /// This example manually iterates through the characters of a string;\n+    /// this should normally be\n     /// done by `.chars().rev()` or `.char_indices()`.\n     ///\n     /// ```\n@@ -1365,7 +1411,8 @@ impl str {\n         core_str::StrExt::char_at(&self[..], i)\n     }\n \n-    /// Given a byte position, return the `char` at that position, counting from the end.\n+    /// Given a byte position, return the `char` at that position, counting\n+    /// from the end.\n     ///\n     /// # Panics\n     ///\n@@ -1400,31 +1447,36 @@ impl str {\n         core_str::StrExt::as_bytes(&self[..])\n     }\n \n-    /// Returns the byte index of the first character of `self` that matches the pattern, if it\n+    /// Returns the byte index of the first character of `self` that matches\n+    /// the pattern, if it\n     /// exists.\n     ///\n     /// Returns `None` if it doesn't exist.\n     ///\n-    /// The pattern can be a simple `&str`, or a closure that determines the split.\n+    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// determines the\n+    /// split.\n     ///\n     /// # Examples\n     ///\n-    /// Simple `&str` patterns:\n+    /// Simple patterns:\n     ///\n     /// ```\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     ///\n     /// assert_eq!(s.find('L'), Some(0));\n     /// assert_eq!(s.find('\u00e9'), Some(14));\n+    /// assert_eq!(s.find(\"L\u00e9opard\"), Some(13));\n     ///\n     /// ```\n     ///\n-    /// More complex patterns with a lambda:\n+    /// More complex patterns with closures:\n     ///\n     /// ```\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     ///\n     /// assert_eq!(s.find(|c: char| c.is_whitespace()), Some(5));\n+    /// assert_eq!(s.find(char::is_lowercase), Some(1));\n     /// ```\n     ///\n     /// Not finding the pattern:\n@@ -1440,16 +1492,18 @@ impl str {\n         core_str::StrExt::find(&self[..], pat)\n     }\n \n-    /// Returns the byte index of the last character of `self` that matches the pattern, if it\n+    /// Returns the byte index of the last character of `self` that\n+    /// matches the pattern, if it\n     /// exists.\n     ///\n     /// Returns `None` if it doesn't exist.\n     ///\n-    /// The pattern can be a simple `&str`, or a closure that determines the split.\n+    /// The pattern can be a simple `&str`, `char`,\n+    /// or a closure that determines the split.\n     ///\n     /// # Examples\n     ///\n-    /// Simple `&str` patterns:\n+    /// Simple patterns:\n     ///\n     /// ```\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n@@ -1458,12 +1512,13 @@ impl str {\n     /// assert_eq!(s.rfind('\u00e9'), Some(14));\n     /// ```\n     ///\n-    /// More complex patterns with a lambda:\n+    /// More complex patterns with closures:\n     ///\n     /// ```\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     ///\n     /// assert_eq!(s.rfind(|c: char| c.is_whitespace()), Some(12));\n+    /// assert_eq!(s.rfind(char::is_lowercase), Some(20));\n     /// ```\n     ///\n     /// Not finding the pattern:\n@@ -1483,7 +1538,8 @@ impl str {\n \n     /// Retrieves the first character from a `&str` and returns it.\n     ///\n-    /// This does not allocate a new string; instead, it returns a slice that points one character\n+    /// This does not allocate a new string; instead, it returns a slice that\n+    /// points one character\n     /// beyond the character that was shifted.\n     ///\n     /// If the slice does not contain any characters, None is returned instead.\n@@ -1511,7 +1567,8 @@ impl str {\n         core_str::StrExt::slice_shift_char(&self[..])\n     }\n \n-    /// Returns the byte offset of an inner slice relative to an enclosing outer slice.\n+    /// Returns the byte offset of an inner slice relative to an enclosing\n+    /// outer slice.\n     ///\n     /// # Panics\n     ///\n@@ -1536,7 +1593,8 @@ impl str {\n \n     /// Return an unsafe pointer to the `&str`'s buffer.\n     ///\n-    /// The caller must ensure that the string outlives this pointer, and that it is not\n+    /// The caller must ensure that the string outlives this pointer, and\n+    /// that it is not\n     /// reallocated (e.g. by pushing to the string).\n     ///\n     /// # Examples\n@@ -1612,7 +1670,8 @@ impl str {\n     ///\n     /// [graphemes]: http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries\n     ///\n-    /// If `is_extended` is true, the iterator is over the *extended grapheme clusters*;\n+    /// If `is_extended` is true, the iterator is over the\n+    /// *extended grapheme clusters*;\n     /// otherwise, the iterator is over the *legacy grapheme clusters*.\n     /// [UAX#29](http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries)\n     /// recommends extended grapheme cluster boundaries for general processing.\n@@ -1637,7 +1696,8 @@ impl str {\n         UnicodeStr::graphemes(&self[..], is_extended)\n     }\n \n-    /// Returns an iterator over the grapheme clusters of `self` and their byte offsets. See\n+    /// Returns an iterator over the grapheme clusters of `self` and their\n+    /// byte offsets. See\n     /// `graphemes()` for more information.\n     ///\n     /// # Examples\n@@ -1657,7 +1717,8 @@ impl str {\n \n     /// An iterator over the non-empty words of `self`.\n     ///\n-    /// A 'word' is a subsequence separated by any sequence of whitespace. Sequences of whitespace\n+    /// A 'word' is a subsequence separated by any sequence of whitespace.\n+    /// Sequences of whitespace\n     /// are collapsed, so empty \"words\" are not included.\n     ///\n     /// # Examples\n@@ -1679,11 +1740,15 @@ impl str {\n     ///\n     /// Control characters have zero width.\n     ///\n-    /// `is_cjk` determines behavior for characters in the Ambiguous category: if `is_cjk` is\n-    /// `true`, these are 2 columns wide; otherwise, they are 1. In CJK locales, `is_cjk` should be\n+    /// `is_cjk` determines behavior for characters in the Ambiguous category:\n+    /// if `is_cjk` is\n+    /// `true`, these are 2 columns wide; otherwise, they are 1.\n+    /// In CJK locales, `is_cjk` should be\n     /// `true`, else it should be `false`.\n-    /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/) recommends that these\n-    /// characters be treated as 1 column (i.e., `is_cjk = false`) if the locale is unknown.\n+    /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)\n+    /// recommends that these\n+    /// characters be treated as 1 column (i.e., `is_cjk = false`) if the\n+    /// locale is unknown.\n     #[unstable(feature = \"unicode\",\n                reason = \"this functionality may only be provided by libunicode\")]\n     pub fn width(&self, is_cjk: bool) -> usize {"}]}