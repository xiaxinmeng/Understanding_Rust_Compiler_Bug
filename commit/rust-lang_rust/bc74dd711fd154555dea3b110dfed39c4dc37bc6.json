{"sha": "bc74dd711fd154555dea3b110dfed39c4dc37bc6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjNzRkZDcxMWZkMTU0NTU1ZGVhM2IxMTBkZmVkMzljNGRjMzdiYzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-11T14:06:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-11T14:06:04Z"}, "message": "Auto merge of #77727 - thomcc:mach-info-order, r=Amanieu\n\nAvoid SeqCst or static mut in mach_timebase_info and QueryPerformanceFrequency caches\n\nThis patch went through a couple iterations but the end result is replacing a pattern where an `AtomicUsize` (updated with many SeqCst ops) guards a `static mut` with a single `AtomicU64` that is known to use 0 as a value indicating that it is not initialized.\n\nThe code in both places exists to cache values used in the conversion of Instants to Durations on macOS, iOS, and Windows.\n\nI have no numbers to prove that this improves performance (It seems a little futile to benchmark something like this), but it's much simpler, safer, and in practice we'd expect it to be faster everywhere where Relaxed operations on AtomicU64 are cheaper than SeqCst operations on AtomicUsize, which is a lot of places.\n\nAnyway, it also removes a bunch of unsafe code and greatly simplifies the logic, so IMO that alone would be worth it unless it was a regression.\n\nIf you want to take a look at the assembly output though, see https://godbolt.org/z/rbr6vn for x86_64, https://godbolt.org/z/cqcbqv for aarch64 (Note that this just the output of the mac side, but i'd expect the windows part to be the same and don't feel like doing another godbolt for it). There are several versions of this function in the godbolt:\n\n- `info_new`: version in the current patch\n- `info_less_new`: version in initial PR\n- `info_original`: version currently in the tree\n- `info_orig_but_better_orderings`: a version that just tries to change the original code's orderings from SeqCst to the (probably) minimal orderings required for soundness/correctness.\n\nThe biggest concern I have here is if we can use AtomicU64, or if there are targets that dont have it that this code supports. AFAICT: no. (If that changes in the future, it's easy enough to do something different for them)\n\nr? `@Amanieu` because he caught a couple issues last time I tried to do a patch reducing orderings \ud83d\ude05\n\n---\n\n<details>\n<summary>I rewrote this whole message so the original is inside here</summary>\n\nI happened to notice the code we use for caching the result of mach_timebase_info uses SeqCst exclusively.\n\nHowever, thinking a little more, it's actually pretty easy to avoid the static mut by packing the timebase info into an AtomicU64.\n\nThis entirely avoids needing to do the compare_exchange. The AtomicU64 can be read/written using Relaxed ops, which on current macos/ios platforms (x86_64/aarch64) have no overhead compared to direct loads/stores. This simplifies the code and makes it a lot safer too.\n\nI have no numbers to prove that this improves performance (It seems a little futile to benchmark something like this), although it should do that on both targets it applies to.\n\nThat said, it also removes a bunch of unsafe code and simplifies the logic (arguably at least \u2014 there are only two states now, initialized or not), so I think it's a net win even without concrete numbers.\n\nIf you want to take a look at the assembly output though, see below. It has the new version, the original, and a version of the original with lower Orderings (which is still worse than the version in this PR)\n\n- godbolt.org/z/obfqf9 x86_64-apple-darwin\n\n- godbolt.org/z/Wz5cWc aarch64-unknown-linux-gnu (godbolt can't do aarch64-apple-ios but that doesn't matter here)\n\nA different (and more efficient) option than this would be to just use the AtomicU64 and use the knowledge that after initialization the denominator should be nonzero... That felt like it's relying on too many things I'm not confident in, so I didn't want to do that.\n</details>", "tree": {"sha": "6723fd40832cff0a9f286cf52fdb81736a9af785", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6723fd40832cff0a9f286cf52fdb81736a9af785"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc74dd711fd154555dea3b110dfed39c4dc37bc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc74dd711fd154555dea3b110dfed39c4dc37bc6", "html_url": "https://github.com/rust-lang/rust/commit/bc74dd711fd154555dea3b110dfed39c4dc37bc6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc74dd711fd154555dea3b110dfed39c4dc37bc6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c38f001db5e16f1e0db47c5aed80394e9df5430a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c38f001db5e16f1e0db47c5aed80394e9df5430a", "html_url": "https://github.com/rust-lang/rust/commit/c38f001db5e16f1e0db47c5aed80394e9df5430a"}, {"sha": "4f3722051092bfe33ec87836e8dd4d6d155c1fc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f3722051092bfe33ec87836e8dd4d6d155c1fc1", "html_url": "https://github.com/rust-lang/rust/commit/4f3722051092bfe33ec87836e8dd4d6d155c1fc1"}], "stats": {"total": 92, "additions": 50, "deletions": 42}, "files": [{"sha": "fac4b05ad0b5f5ec8ffd1b2beee789061c76cdc5", "filename": "library/std/src/sys/unix/time.rs", "status": "modified", "additions": 33, "deletions": 23, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/bc74dd711fd154555dea3b110dfed39c4dc37bc6/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc74dd711fd154555dea3b110dfed39c4dc37bc6/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs?ref=bc74dd711fd154555dea3b110dfed39c4dc37bc6", "patch": "@@ -117,8 +117,7 @@ impl Hash for Timespec {\n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n mod inner {\n     use crate::fmt;\n-    use crate::mem;\n-    use crate::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n+    use crate::sync::atomic::{AtomicU64, Ordering};\n     use crate::sys::cvt;\n     use crate::sys_common::mul_div_u64;\n     use crate::time::Duration;\n@@ -233,31 +232,42 @@ mod inner {\n     }\n \n     fn info() -> mach_timebase_info {\n-        static mut INFO: mach_timebase_info = mach_timebase_info { numer: 0, denom: 0 };\n-        static STATE: AtomicUsize = AtomicUsize::new(0);\n-\n-        unsafe {\n-            // If a previous thread has filled in this global state, use that.\n-            if STATE.load(SeqCst) == 2 {\n-                return INFO;\n-            }\n+        // INFO_BITS conceptually is an `Option<mach_timebase_info>`. We can do\n+        // this in 64 bits because we know 0 is never a valid value for the\n+        // `denom` field.\n+        //\n+        // Encoding this as a single `AtomicU64` allows us to use `Relaxed`\n+        // operations, as we are only interested in in the effects on a single\n+        // memory location.\n+        static INFO_BITS: AtomicU64 = AtomicU64::new(0);\n+\n+        // If a previous thread has initialized `INFO_BITS`, use it.\n+        let info_bits = INFO_BITS.load(Ordering::Relaxed);\n+        if info_bits != 0 {\n+            return info_from_bits(info_bits);\n+        }\n \n-            // ... otherwise learn for ourselves ...\n-            let mut info = mem::zeroed();\n-            extern \"C\" {\n-                fn mach_timebase_info(info: mach_timebase_info_t) -> kern_return_t;\n-            }\n+        // ... otherwise learn for ourselves ...\n+        extern \"C\" {\n+            fn mach_timebase_info(info: mach_timebase_info_t) -> kern_return_t;\n+        }\n \n+        let mut info = info_from_bits(0);\n+        unsafe {\n             mach_timebase_info(&mut info);\n-\n-            // ... and attempt to be the one thread that stores it globally for\n-            // all other threads\n-            if STATE.compare_exchange(0, 1, SeqCst, SeqCst).is_ok() {\n-                INFO = info;\n-                STATE.store(2, SeqCst);\n-            }\n-            return info;\n         }\n+        INFO_BITS.store(info_to_bits(info), Ordering::Relaxed);\n+        info\n+    }\n+\n+    #[inline]\n+    fn info_to_bits(info: mach_timebase_info) -> u64 {\n+        ((info.denom as u64) << 32) | (info.numer as u64)\n+    }\n+\n+    #[inline]\n+    fn info_from_bits(bits: u64) -> mach_timebase_info {\n+        mach_timebase_info { numer: bits as u32, denom: (bits >> 32) as u32 }\n     }\n }\n "}, {"sha": "91e4f7654840d7025d7c8e1735bdff30f52300d0", "filename": "library/std/src/sys/windows/time.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/bc74dd711fd154555dea3b110dfed39c4dc37bc6/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc74dd711fd154555dea3b110dfed39c4dc37bc6/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ftime.rs?ref=bc74dd711fd154555dea3b110dfed39c4dc37bc6", "patch": "@@ -165,7 +165,7 @@ fn intervals2dur(intervals: u64) -> Duration {\n \n mod perf_counter {\n     use super::NANOS_PER_SEC;\n-    use crate::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n+    use crate::sync::atomic::{AtomicU64, Ordering};\n     use crate::sys::c;\n     use crate::sys::cvt;\n     use crate::sys_common::mul_div_u64;\n@@ -197,27 +197,25 @@ mod perf_counter {\n     }\n \n     fn frequency() -> c::LARGE_INTEGER {\n-        static mut FREQUENCY: c::LARGE_INTEGER = 0;\n-        static STATE: AtomicUsize = AtomicUsize::new(0);\n-\n+        // Either the cached result of `QueryPerformanceFrequency` or `0` for\n+        // uninitialized. Storing this as a single `AtomicU64` allows us to use\n+        // `Relaxed` operations, as we are only interested in the effects on a\n+        // single memory location.\n+        static FREQUENCY: AtomicU64 = AtomicU64::new(0);\n+\n+        let cached = FREQUENCY.load(Ordering::Relaxed);\n+        // If a previous thread has filled in this global state, use that.\n+        if cached != 0 {\n+            return cached as c::LARGE_INTEGER;\n+        }\n+        // ... otherwise learn for ourselves ...\n+        let mut frequency = 0;\n         unsafe {\n-            // If a previous thread has filled in this global state, use that.\n-            if STATE.load(SeqCst) == 2 {\n-                return FREQUENCY;\n-            }\n-\n-            // ... otherwise learn for ourselves ...\n-            let mut frequency = 0;\n             cvt(c::QueryPerformanceFrequency(&mut frequency)).unwrap();\n-\n-            // ... and attempt to be the one thread that stores it globally for\n-            // all other threads\n-            if STATE.compare_exchange(0, 1, SeqCst, SeqCst).is_ok() {\n-                FREQUENCY = frequency;\n-                STATE.store(2, SeqCst);\n-            }\n-            frequency\n         }\n+\n+        FREQUENCY.store(frequency as u64, Ordering::Relaxed);\n+        frequency\n     }\n \n     fn query() -> c::LARGE_INTEGER {"}]}