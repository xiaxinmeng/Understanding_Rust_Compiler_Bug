{"sha": "55120b3d83ff3608b392e3af80491f1eab2cd238", "node_id": "C_kwDOAAsO6NoAKDU1MTIwYjNkODNmZjM2MDhiMzkyZTNhZjgwNDkxZjFlYWIyY2QyMzg", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-03-15T09:17:30Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-03-15T09:17:30Z"}, "message": "Add signature help for tuple struct patterns", "tree": {"sha": "625928c88d2365f82a7ed7555662a0b8f3abd2c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/625928c88d2365f82a7ed7555662a0b8f3abd2c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55120b3d83ff3608b392e3af80491f1eab2cd238", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55120b3d83ff3608b392e3af80491f1eab2cd238", "html_url": "https://github.com/rust-lang/rust/commit/55120b3d83ff3608b392e3af80491f1eab2cd238", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55120b3d83ff3608b392e3af80491f1eab2cd238/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03a6ab0b62b2fbaefbf39bee6605b3a1050b8083", "url": "https://api.github.com/repos/rust-lang/rust/commits/03a6ab0b62b2fbaefbf39bee6605b3a1050b8083", "html_url": "https://github.com/rust-lang/rust/commit/03a6ab0b62b2fbaefbf39bee6605b3a1050b8083"}], "stats": {"total": 238, "additions": 213, "deletions": 25}, "files": [{"sha": "4b2c139f6f455b3f8fa5ad462c6343d5d9faaeed", "filename": "crates/ide/src/signature_help.rs", "status": "modified", "additions": 205, "deletions": 18, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/55120b3d83ff3608b392e3af80491f1eab2cd238/crates%2Fide%2Fsrc%2Fsignature_help.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55120b3d83ff3608b392e3af80491f1eab2cd238/crates%2Fide%2Fsrc%2Fsignature_help.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsignature_help.rs?ref=55120b3d83ff3608b392e3af80491f1eab2cd238", "patch": "@@ -109,7 +109,13 @@ pub(crate) fn signature_help(db: &RootDatabase, position: FilePosition) -> Optio\n                     }\n                     return signature_help_for_record_pat(&sema, record, token);\n                 },\n-                ast::TupleStructPat(tuple_pat) => {},\n+                ast::TupleStructPat(tuple_pat) => {\n+                    let cursor_outside = tuple_pat.r_paren_token().as_ref() == Some(&token);\n+                    if cursor_outside {\n+                        continue;\n+                    }\n+                    return signature_help_for_tuple_struct_pat(&sema, tuple_pat, token);\n+                },\n                 _ => (),\n             }\n         }\n@@ -367,6 +373,90 @@ fn signature_help_for_record_lit(\n     )\n }\n \n+fn signature_help_for_record_pat(\n+    sema: &Semantics<'_, RootDatabase>,\n+    record: ast::RecordPat,\n+    token: SyntaxToken,\n+) -> Option<SignatureHelp> {\n+    signature_help_for_record_(\n+        sema,\n+        record.record_pat_field_list()?.syntax().children_with_tokens(),\n+        &record.path()?,\n+        record\n+            .record_pat_field_list()?\n+            .fields()\n+            .filter_map(|field| sema.resolve_record_pat_field(&field)),\n+        token,\n+    )\n+}\n+\n+fn signature_help_for_tuple_struct_pat(\n+    sema: &Semantics<'_, RootDatabase>,\n+    pat: ast::TupleStructPat,\n+    token: SyntaxToken,\n+) -> Option<SignatureHelp> {\n+    let rest_pat = pat.fields().find(|it| matches!(it, ast::Pat::RestPat(_)));\n+    let is_left_of_rest_pat =\n+        rest_pat.map_or(true, |it| token.text_range().start() < it.syntax().text_range().end());\n+\n+    let mut res = SignatureHelp {\n+        doc: None,\n+        signature: String::new(),\n+        parameters: vec![],\n+        active_parameter: None,\n+    };\n+\n+    let db = sema.db;\n+    let path_res = sema.resolve_path(&pat.path()?)?;\n+    let fields: Vec<_> = if let PathResolution::Def(ModuleDef::Variant(variant)) = path_res {\n+        let en = variant.parent_enum(db);\n+\n+        res.doc = en.docs(db).map(|it| it.into());\n+        format_to!(res.signature, \"enum {}::{} (\", en.name(db), variant.name(db));\n+        variant.fields(db)\n+    } else {\n+        let adt = match path_res {\n+            PathResolution::SelfType(imp) => imp.self_ty(db).as_adt()?,\n+            PathResolution::Def(ModuleDef::Adt(adt)) => adt,\n+            _ => return None,\n+        };\n+\n+        match adt {\n+            hir::Adt::Struct(it) => {\n+                res.doc = it.docs(db).map(|it| it.into());\n+                format_to!(res.signature, \"struct {} (\", it.name(db));\n+                it.fields(db)\n+            }\n+            _ => return None,\n+        }\n+    };\n+    let commas = pat\n+        .syntax()\n+        .children_with_tokens()\n+        .filter_map(syntax::NodeOrToken::into_token)\n+        .filter(|t| t.kind() == syntax::T![,]);\n+    res.active_parameter = Some(if is_left_of_rest_pat {\n+        commas.take_while(|t| t.text_range().start() <= token.text_range().start()).count()\n+    } else {\n+        let n_commas = commas\n+            .collect::<Vec<_>>()\n+            .into_iter()\n+            .rev()\n+            .take_while(|t| t.text_range().start() > token.text_range().start())\n+            .count();\n+        fields.len().saturating_sub(1).saturating_sub(n_commas)\n+    });\n+\n+    let mut buf = String::new();\n+    for ty in fields.into_iter().map(|it| it.ty(db)) {\n+        format_to!(buf, \"{}\", ty.display_truncated(db, Some(20)));\n+        res.push_call_param(&buf);\n+        buf.clear();\n+    }\n+    res.signature.push_str(\")\");\n+    Some(res)\n+}\n+\n fn signature_help_for_record_(\n     sema: &Semantics<'_, RootDatabase>,\n     field_list_children: SyntaxElementChildren,\n@@ -442,23 +532,6 @@ fn signature_help_for_record_(\n     Some(res)\n }\n \n-fn signature_help_for_record_pat(\n-    sema: &Semantics<'_, RootDatabase>,\n-    record: ast::RecordPat,\n-    token: SyntaxToken,\n-) -> Option<SignatureHelp> {\n-    signature_help_for_record_(\n-        sema,\n-        record.record_pat_field_list()?.syntax().children_with_tokens(),\n-        &record.path()?,\n-        record\n-            .record_pat_field_list()?\n-            .fields()\n-            .filter_map(|field| sema.resolve_record_pat_field(&field)),\n-        token,\n-    )\n-}\n-\n #[cfg(test)]\n mod tests {\n     use std::iter;\n@@ -480,6 +553,7 @@ mod tests {\n         (database, FilePosition { file_id, offset })\n     }\n \n+    #[track_caller]\n     fn check(ra_fixture: &str, expect: Expect) {\n         let fixture = format!(\n             r#\"\n@@ -931,6 +1005,119 @@ fn main() {\n         );\n     }\n \n+    #[test]\n+    fn tuple_struct_pat() {\n+        check(\n+            r#\"\n+/// A cool tuple struct\n+struct S(u32, i32);\n+fn main() {\n+    let S(0, $0);\n+}\n+\"#,\n+            expect![[r#\"\n+                A cool tuple struct\n+                ------\n+                struct S (u32, i32)\n+                          ---  ^^^\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn tuple_struct_pat_rest() {\n+        check(\n+            r#\"\n+/// A cool tuple struct\n+struct S(u32, i32, f32, u16);\n+fn main() {\n+    let S(0, .., $0);\n+}\n+\"#,\n+            expect![[r#\"\n+                A cool tuple struct\n+                ------\n+                struct S (u32, i32, f32, u16)\n+                          ---  ---  ---  ^^^\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+/// A cool tuple struct\n+struct S(u32, i32, f32, u16, u8);\n+fn main() {\n+    let S(0, .., $0, 0);\n+}\n+\"#,\n+            expect![[r#\"\n+                A cool tuple struct\n+                ------\n+                struct S (u32, i32, f32, u16, u8)\n+                          ---  ---  ---  ^^^  --\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+/// A cool tuple struct\n+struct S(u32, i32, f32, u16);\n+fn main() {\n+    let S($0, .., 1);\n+}\n+\"#,\n+            expect![[r#\"\n+                A cool tuple struct\n+                ------\n+                struct S (u32, i32, f32, u16)\n+                          ^^^  ---  ---  ---\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+/// A cool tuple struct\n+struct S(u32, i32, f32, u16, u8);\n+fn main() {\n+    let S(1, .., 1, $0, 2);\n+}\n+\"#,\n+            expect![[r#\"\n+                A cool tuple struct\n+                ------\n+                struct S (u32, i32, f32, u16, u8)\n+                          ---  ---  ---  ^^^  --\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+/// A cool tuple struct\n+struct S(u32, i32, f32, u16);\n+fn main() {\n+    let S(1, $0.., 1);\n+}\n+\"#,\n+            expect![[r#\"\n+                A cool tuple struct\n+                ------\n+                struct S (u32, i32, f32, u16)\n+                          ---  ^^^  ---  ---\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+/// A cool tuple struct\n+struct S(u32, i32, f32, u16);\n+fn main() {\n+    let S(1, ..$0, 1);\n+}\n+\"#,\n+            expect![[r#\"\n+                A cool tuple struct\n+                ------\n+                struct S (u32, i32, f32, u16)\n+                          ---  ^^^  ---  ---\n+            \"#]],\n+        );\n+    }\n+\n     #[test]\n     fn generic_struct() {\n         check("}, {"sha": "5f4977886f6ebe076fde8f190af25ac50af95d0c", "filename": "crates/parser/src/grammar/patterns.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/55120b3d83ff3608b392e3af80491f1eab2cd238/crates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55120b3d83ff3608b392e3af80491f1eab2cd238/crates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs?ref=55120b3d83ff3608b392e3af80491f1eab2cd238", "patch": "@@ -431,14 +431,15 @@ fn slice_pat(p: &mut Parser<'_>) -> CompletedMarker {\n \n fn pat_list(p: &mut Parser<'_>, ket: SyntaxKind) {\n     while !p.at(EOF) && !p.at(ket) {\n-        if !p.at_ts(PAT_TOP_FIRST) {\n-            p.error(\"expected a pattern\");\n-            break;\n-        }\n-\n         pattern_top(p);\n-        if !p.at(ket) {\n-            p.expect(T![,]);\n+        if !p.at(T![,]) {\n+            if p.at_ts(PAT_TOP_FIRST) {\n+                p.error(format!(\"expected {:?}, got {:?}\", T![,], p.current()));\n+            } else {\n+                break;\n+            }\n+        } else {\n+            p.bump(T![,]);\n         }\n     }\n }"}]}