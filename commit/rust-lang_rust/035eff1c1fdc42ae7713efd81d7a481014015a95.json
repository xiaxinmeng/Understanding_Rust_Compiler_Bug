{"sha": "035eff1c1fdc42ae7713efd81d7a481014015a95", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzNWVmZjFjMWZkYzQyYWU3NzEzZWZkODFkN2E0ODEwMTQwMTVhOTU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-01-13T04:26:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-01-13T04:26:43Z"}, "message": "Rollup merge of #57351 - oli-obk:cheap_const_ops, r=RalfJung\n\nDon't actually create a full MIR stack frame when not needed\n\nr? @dotdash\n\nThis should significantly reduce overhead during const propagation and reduce overhead *after* copy propagation (cc https://github.com/rust-lang/rust/issues/36673)", "tree": {"sha": "d20a5ffc18cf40db462067ef19d48f8e84c425ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d20a5ffc18cf40db462067ef19d48f8e84c425ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/035eff1c1fdc42ae7713efd81d7a481014015a95", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcOr4DCRBK7hj4Ov3rIwAAdHIIAFsV9F8Di1EjQwf9oOyQWOSc\ntgECMmIXnDrvfD2/UAKOl+X67G346Conwlao67mmVjGSqqHazyjyGvfTQb/Ih0bB\nxX9gE7Rz8F7dKcxpArGKwx5JUQLyeiz7H7QdvhnpuhmvvHIN3bUOL1RYyOR5b7kp\nOD6grIxbypvLmQkjcTOcnxbttyAheJyI8l6e5UK5tXiB+267GW+0fLXOkeS8dBfp\nv6aNzQNtCYb3N+czSeDbHSPQCOzswbDRX8gEfvn/CKPkaCA8GOYF6bclDtlLIT1f\nI0NXJGbM8xpaEltbtNWwR7EcYWyzmy6G2fXzW7d9+TMobAx16VHFWf82bSY7lac=\n=96v3\n-----END PGP SIGNATURE-----\n", "payload": "tree d20a5ffc18cf40db462067ef19d48f8e84c425ca\nparent 75a369c5b11459baa6bf7734eeb6135998a0a7de\nparent dec79e44705992d607b001cd349c98807761d3d8\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1547353603 +0100\ncommitter GitHub <noreply@github.com> 1547353603 +0100\n\nRollup merge of #57351 - oli-obk:cheap_const_ops, r=RalfJung\n\nDon't actually create a full MIR stack frame when not needed\n\nr? @dotdash\n\nThis should significantly reduce overhead during const propagation and reduce overhead *after* copy propagation (cc https://github.com/rust-lang/rust/issues/36673)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/035eff1c1fdc42ae7713efd81d7a481014015a95", "html_url": "https://github.com/rust-lang/rust/commit/035eff1c1fdc42ae7713efd81d7a481014015a95", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/035eff1c1fdc42ae7713efd81d7a481014015a95/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75a369c5b11459baa6bf7734eeb6135998a0a7de", "url": "https://api.github.com/repos/rust-lang/rust/commits/75a369c5b11459baa6bf7734eeb6135998a0a7de", "html_url": "https://github.com/rust-lang/rust/commit/75a369c5b11459baa6bf7734eeb6135998a0a7de"}, {"sha": "dec79e44705992d607b001cd349c98807761d3d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/dec79e44705992d607b001cd349c98807761d3d8", "html_url": "https://github.com/rust-lang/rust/commit/dec79e44705992d607b001cd349c98807761d3d8"}], "stats": {"total": 50, "additions": 36, "deletions": 14}, "files": [{"sha": "f5f40481679385eae8372f11e161f48ae8132ccb", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 36, "deletions": 14, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/035eff1c1fdc42ae7713efd81d7a481014015a95/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/035eff1c1fdc42ae7713efd81d7a481014015a95/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=035eff1c1fdc42ae7713efd81d7a481014015a95", "patch": "@@ -35,6 +35,16 @@ const STEPS_UNTIL_DETECTOR_ENABLED: isize = 1_000_000;\n /// Should be a power of two for performance reasons.\n const DETECTOR_SNAPSHOT_PERIOD: isize = 256;\n \n+/// Warning: do not use this function if you expect to start interpreting the given `Mir`.\n+/// The `EvalContext` is only meant to be used to query values from constants and statics.\n+///\n+/// This function is used during const propagation. We cannot use `mk_eval_cx`, because copy\n+/// propagation happens *during* the computation of the MIR of the current function. So if we\n+/// tried to call the `optimized_mir` query, we'd get a cycle error because we are (transitively)\n+/// inside the `optimized_mir` query of the `Instance` given.\n+///\n+/// Since we are looking at the MIR of the function in an abstract manner, we don't have a\n+/// `ParamEnv` available to us. This function creates a `ParamEnv` for the given instance.\n pub fn mk_borrowck_eval_cx<'a, 'mir, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     instance: Instance<'tcx>,\n@@ -43,9 +53,22 @@ pub fn mk_borrowck_eval_cx<'a, 'mir, 'tcx>(\n ) -> EvalResult<'tcx, CompileTimeEvalContext<'a, 'mir, 'tcx>> {\n     debug!(\"mk_borrowck_eval_cx: {:?}\", instance);\n     let param_env = tcx.param_env(instance.def_id());\n+    mk_eval_cx_inner(tcx, instance, mir, span, param_env)\n+}\n+\n+/// This is just a helper function to reduce code duplication between `mk_borrowck_eval_cx` and\n+/// `mk_eval_cx`. Do not call this function directly.\n+fn mk_eval_cx_inner<'a, 'mir, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    instance: Instance<'tcx>,\n+    mir: &'mir mir::Mir<'tcx>,\n+    span: Span,\n+    param_env: ty::ParamEnv<'tcx>,\n+) -> EvalResult<'tcx, CompileTimeEvalContext<'a, 'mir, 'tcx>> {\n     let mut ecx = EvalContext::new(tcx.at(span), param_env, CompileTimeInterpreter::new());\n-    // insert a stack frame so any queries have the correct substs\n-    // cannot use `push_stack_frame`; if we do `const_prop` explodes\n+    // Insert a stack frame so any queries have the correct substs.\n+    // We also avoid all the extra work performed by push_stack_frame,\n+    // like initializing local variables\n     ecx.stack.push(interpret::Frame {\n         block: mir::START_BLOCK,\n         locals: IndexVec::new(),\n@@ -60,24 +83,23 @@ pub fn mk_borrowck_eval_cx<'a, 'mir, 'tcx>(\n     Ok(ecx)\n }\n \n-pub fn mk_eval_cx<'a, 'tcx>(\n+/// Warning: do not use this function if you expect to start interpreting the given `Mir`.\n+/// The `EvalContext` is only meant to be used to do field and index projections into constants for\n+/// `simd_shuffle` and const patterns in match arms.\n+///\n+/// The function containing the `match` that is currently being analyzed may have generic bounds\n+/// that inform us about the generic bounds of the constant. E.g. using an associated constant\n+/// of a function's generic parameter will require knowledge about the bounds on the generic\n+/// parameter. These bounds are passed to `mk_eval_cx` via the `ParamEnv` argument.\n+fn mk_eval_cx<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     instance: Instance<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n ) -> EvalResult<'tcx, CompileTimeEvalContext<'a, 'tcx, 'tcx>> {\n     debug!(\"mk_eval_cx: {:?}, {:?}\", instance, param_env);\n     let span = tcx.def_span(instance.def_id());\n-    let mut ecx = EvalContext::new(tcx.at(span), param_env, CompileTimeInterpreter::new());\n-    let mir = ecx.load_mir(instance.def)?;\n-    // insert a stack frame so any queries have the correct substs\n-    ecx.push_stack_frame(\n-        instance,\n-        mir.span,\n-        mir,\n-        None,\n-        StackPopCleanup::Goto(None), // never pop\n-    )?;\n-    Ok(ecx)\n+    let mir = tcx.optimized_mir(instance.def.def_id());\n+    mk_eval_cx_inner(tcx, instance, mir, span, param_env)\n }\n \n pub(crate) fn eval_promoted<'a, 'mir, 'tcx>("}]}