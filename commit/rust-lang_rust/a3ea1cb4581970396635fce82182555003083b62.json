{"sha": "a3ea1cb4581970396635fce82182555003083b62", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzZWExY2I0NTgxOTcwMzk2NjM1ZmNlODIxODI1NTUwMDMwODNiNjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-22T17:01:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-22T17:01:53Z"}, "message": "Auto merge of #1101 - christianpoveda:stat-shim, r=RalfJung\n\nAdd statx shim for linux target\n\nThis is an attempt to fix: https://github.com/rust-lang/miri/issues/999 (for linux only)\n\nCurrently there is one problem that I haven't been able to solve. `std::fs::metadata` fails because the creation time is not available even though it is provided in the shim code.\n\nIn order to inform the caller that the field was provided, the `stx_flag` field must have the bits of `STATX_BTIME` set (which they are). The creation time is in the `stx_btime` field of the `statx` struct (see [1]). The relevant code in `libstd` is here (probably?): https://github.com/rust-lang/rust/blob/master/src/libstd/sys/unix/fs.rs#L322\n\nAnother important point is that we are just providing the fields that are available in \"all\" platforms (this is, without using any platform specific traits or so). This can be improved later.\n\nReferences:\n[1] Man page: http://man7.org/linux/man-pages/man2/statx.2.html\n[2] libc `statx` struct: https://docs.rs/libc/0.2.63/libc/struct.statx.html\n\nEdit: The problem is that my filesystem is not providing it and I thought all filesystems could provide it. I changed the code so it only provides those dates if they are available. now we are ready to go.\n\nr? @RalfJung @oli-obk", "tree": {"sha": "117175e27b253a617fe09418bf5c413796cfc9e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/117175e27b253a617fe09418bf5c413796cfc9e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3ea1cb4581970396635fce82182555003083b62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3ea1cb4581970396635fce82182555003083b62", "html_url": "https://github.com/rust-lang/rust/commit/a3ea1cb4581970396635fce82182555003083b62", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3ea1cb4581970396635fce82182555003083b62/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7809bfb0e3e8efc3e08740f387ed2543bbfb150", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7809bfb0e3e8efc3e08740f387ed2543bbfb150", "html_url": "https://github.com/rust-lang/rust/commit/a7809bfb0e3e8efc3e08740f387ed2543bbfb150"}, {"sha": "b0c7625dd109197cc38710da64e5eeb401f97379", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0c7625dd109197cc38710da64e5eeb401f97379", "html_url": "https://github.com/rust-lang/rust/commit/b0c7625dd109197cc38710da64e5eeb401f97379"}], "stats": {"total": 340, "additions": 303, "deletions": 37}, "files": [{"sha": "5d7db0d1269342bbef3fd6ead6ae5321da74c6ef", "filename": "src/helpers.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a3ea1cb4581970396635fce82182555003083b62/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ea1cb4581970396635fce82182555003083b62/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=a3ea1cb4581970396635fce82182555003083b62", "patch": "@@ -509,3 +509,45 @@ fn bytes_to_os_str<'tcx, 'a>(bytes: &'a [u8]) -> InterpResult<'tcx, &'a OsStr> {\n         .map_err(|_| err_unsup_format!(\"{:?} is not a valid utf-8 string\", bytes))?;\n     Ok(&OsStr::new(s))\n }\n+\n+// FIXME: change `ImmTy::from_int` so it returns an `InterpResult` instead and remove this\n+// function.\n+pub fn immty_from_int_checked<'tcx>(\n+    int: impl Into<i128>,\n+    layout: TyLayout<'tcx>,\n+) -> InterpResult<'tcx, ImmTy<'tcx, Tag>> {\n+    let int = int.into();\n+    // If `int` does not fit in `size` bits, we error instead of letting\n+    // `ImmTy::from_int` panic.\n+    let size = layout.size;\n+    let truncated = truncate(int as u128, size);\n+    if sign_extend(truncated, size) as i128 != int {\n+        throw_unsup_format!(\n+            \"Signed value {:#x} does not fit in {} bits\",\n+            int,\n+            size.bits()\n+        )\n+    }\n+    Ok(ImmTy::from_int(int, layout))\n+}\n+\n+// FIXME: change `ImmTy::from_uint` so it returns an `InterpResult` instead and remove this\n+// function.\n+pub fn immty_from_uint_checked<'tcx>(\n+    int: impl Into<u128>,\n+    layout: TyLayout<'tcx>,\n+) -> InterpResult<'tcx, ImmTy<'tcx, Tag>> {\n+    let int = int.into();\n+    // If `int` does not fit in `size` bits, we error instead of letting\n+    // `ImmTy::from_int` panic.\n+    let size = layout.size;\n+    if truncate(int, size) != int {\n+        throw_unsup_format!(\n+            \"Unsigned value {:#x} does not fit in {} bits\",\n+            int,\n+            size.bits()\n+        )\n+    }\n+    Ok(ImmTy::from_uint(int, layout))\n+}\n+"}, {"sha": "3994cf78780aafb869b6ab985815ca3dbf5f2302", "filename": "src/shims/env.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3ea1cb4581970396635fce82182555003083b62/src%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ea1cb4581970396635fce82182555003083b62/src%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fenv.rs?ref=a3ea1cb4581970396635fce82182555003083b62", "patch": "@@ -20,8 +20,12 @@ impl EnvVars {\n         ecx: &mut InterpCx<'mir, 'tcx, Evaluator<'tcx>>,\n         mut excluded_env_vars: Vec<String>,\n     ) {\n-        // Exclude `TERM` var to avoid terminfo trying to open the termcap file.\n-        excluded_env_vars.push(\"TERM\".to_owned());\n+\n+        // FIXME: this can be removed when we have the `stat64` shim for macos.\n+        if ecx.tcx.sess.target.target.target_os.to_lowercase() != \"linux\" {\n+            // Exclude `TERM` var to avoid terminfo trying to open the termcap file.\n+            excluded_env_vars.push(\"TERM\".to_owned());\n+        }\n \n         if ecx.machine.communicate {\n             for (name, value) in env::vars() {"}, {"sha": "55742bd060b35f4d4c4b03a0b07845cf58ca6784", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a3ea1cb4581970396635fce82182555003083b62/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ea1cb4581970396635fce82182555003083b62/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=a3ea1cb4581970396635fce82182555003083b62", "patch": "@@ -303,14 +303,25 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     .expect(\"Failed to get libc::SYS_getrandom\")\n                     .to_machine_usize(this)?;\n \n-                // `libc::syscall(NR_GETRANDOM, buf.as_mut_ptr(), buf.len(), GRND_NONBLOCK)`\n-                // is called if a `HashMap` is created the regular way (e.g. HashMap<K, V>).\n+                let sys_statx = this\n+                    .eval_path_scalar(&[\"libc\", \"SYS_statx\"])?\n+                    .expect(\"Failed to get libc::SYS_statx\")\n+                    .to_machine_usize(this)?;\n+\n                 match this.read_scalar(args[0])?.to_machine_usize(this)? {\n+                    // `libc::syscall(NR_GETRANDOM, buf.as_mut_ptr(), buf.len(), GRND_NONBLOCK)`\n+                    // is called if a `HashMap` is created the regular way (e.g. HashMap<K, V>).\n                     id if id == sys_getrandom => {\n                         // The first argument is the syscall id,\n                         // so skip over it.\n                         linux_getrandom(this, &args[1..], dest)?;\n                     }\n+                    id if id == sys_statx => {\n+                        // The first argument is the syscall id,\n+                        // so skip over it.\n+                        let result = this.statx(args[1], args[2], args[3], args[4], args[5])?;\n+                        this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n+                    }\n                     id => throw_unsup_format!(\"miri does not support syscall ID {}\", id),\n                 }\n             }"}, {"sha": "47f3f50b76aff2e6c2069a5178155fc069a27161", "filename": "src/shims/fs.rs", "status": "modified", "additions": 195, "deletions": 3, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/a3ea1cb4581970396635fce82182555003083b62/src%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ea1cb4581970396635fce82182555003083b62/src%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ffs.rs?ref=a3ea1cb4581970396635fce82182555003083b62", "patch": "@@ -1,12 +1,16 @@\n use std::collections::HashMap;\n-use std::convert::TryFrom;\n+use std::convert::{TryInto, TryFrom};\n use std::fs::{remove_file, File, OpenOptions};\n use std::io::{Read, Write};\n+use std::path::PathBuf;\n+use std::time::SystemTime;\n \n-use rustc::ty::layout::{Size, Align};\n+use rustc::ty::layout::{Size, Align, LayoutOf};\n \n use crate::stacked_borrows::Tag;\n use crate::*;\n+use helpers::immty_from_uint_checked;\n+use shims::time::system_time_to_duration;\n \n #[derive(Debug)]\n pub struct FileHandle {\n@@ -98,7 +102,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let path = this.read_os_str_from_c_str(this.read_scalar(path_op)?.not_undef()?)?;\n \n-        let fd = options.open(path).map(|file| {\n+        let fd = options.open(&path).map(|file| {\n             let mut fh = &mut this.machine.file_handler;\n             fh.low += 1;\n             fh.handles.insert(fh.low, FileHandle { file }).unwrap_none();\n@@ -257,6 +261,181 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.try_unwrap_io_result(result)\n     }\n \n+    fn statx(\n+        &mut self,\n+        dirfd_op: OpTy<'tcx, Tag>, // Should be an `int`\n+        pathname_op: OpTy<'tcx, Tag>, // Should be a `const char *`\n+        flags_op: OpTy<'tcx, Tag>, // Should be an `int`\n+        _mask_op: OpTy<'tcx, Tag>, // Should be an `unsigned int`\n+        statxbuf_op: OpTy<'tcx, Tag> // Should be a `struct statx *`\n+    ) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        this.check_no_isolation(\"statx\")?;\n+\n+        let statxbuf_scalar = this.read_scalar(statxbuf_op)?.not_undef()?;\n+        let pathname_scalar = this.read_scalar(pathname_op)?.not_undef()?;\n+\n+        // If the statxbuf or pathname pointers are null, the function fails with `EFAULT`.\n+        if this.is_null(statxbuf_scalar)? || this.is_null(pathname_scalar)? {\n+            let efault = this.eval_libc(\"EFAULT\")?;\n+            this.set_last_error(efault)?;\n+            return Ok(-1);\n+        }\n+\n+        // Under normal circumstances, we would use `deref_operand(statxbuf_op)` to produce a\n+        // proper `MemPlace` and then write the results of this function to it. However, the\n+        // `syscall` function is untyped. This means that all the `statx` parameters are provided\n+        // as `isize`s instead of having the proper types. Thus, we have to recover the layout of\n+        // `statxbuf_op` by using the `libc::statx` struct type.\n+        let statxbuf_place = {\n+            // FIXME: This long path is required because `libc::statx` is an struct and also a\n+            // function and `resolve_path` is returning the latter.\n+            let statx_ty = this\n+                .resolve_path(&[\"libc\", \"unix\", \"linux_like\", \"linux\", \"gnu\", \"statx\"])?\n+                .ty(*this.tcx);\n+            let statxbuf_ty = this.tcx.mk_mut_ptr(statx_ty);\n+            let statxbuf_layout = this.layout_of(statxbuf_ty)?;\n+            let statxbuf_imm = ImmTy::from_scalar(statxbuf_scalar, statxbuf_layout);\n+            this.ref_to_mplace(statxbuf_imm)?\n+        };\n+\n+        let path: PathBuf = this.read_os_str_from_c_str(pathname_scalar)?.into();\n+        // `flags` should be a `c_int` but the `syscall` function provides an `isize`.\n+        let flags: i32 = this\n+            .read_scalar(flags_op)?\n+            .to_machine_isize(&*this.tcx)?\n+            .try_into()\n+            .map_err(|e| err_unsup_format!(\n+                \"Failed to convert pointer sized operand to integer: {}\",\n+                e\n+            ))?;\n+        // `dirfd` should be a `c_int` but the `syscall` function provides an `isize`.\n+        let dirfd: i32 = this\n+            .read_scalar(dirfd_op)?\n+            .to_machine_isize(&*this.tcx)?\n+            .try_into()\n+            .map_err(|e| err_unsup_format!(\n+                \"Failed to convert pointer sized operand to integer: {}\",\n+                e\n+            ))?;\n+        // we only support interpreting `path` as an absolute directory or as a directory relative\n+        // to `dirfd` when the latter is `AT_FDCWD`. The behavior of `statx` with a relative path\n+        // and a directory file descriptor other than `AT_FDCWD` is specified but it cannot be\n+        // tested from `libstd`. If you found this error, please open an issue reporting it.\n+        if !(path.is_absolute() || dirfd == this.eval_libc_i32(\"AT_FDCWD\")?)\n+        {\n+            throw_unsup_format!(\n+                \"Using statx with a relative path and a file descriptor different from `AT_FDCWD` is not supported\"\n+            )\n+        }\n+\n+        // the `_mask_op` paramter specifies the file information that the caller requested.\n+        // However `statx` is allowed to return information that was not requested or to not\n+        // return information that was requested. This `mask` represents the information we can\n+        // actually provide in any host platform.\n+        let mut mask =\n+            this.eval_libc(\"STATX_TYPE\")?.to_u32()? | this.eval_libc(\"STATX_SIZE\")?.to_u32()?;\n+\n+        // If the `AT_SYMLINK_NOFOLLOW` flag is set, we query the file's metadata without following\n+        // symbolic links.\n+        let metadata = if flags & this.eval_libc(\"AT_SYMLINK_NOFOLLOW\")?.to_i32()? != 0 {\n+            // FIXME: metadata for symlinks need testing.\n+            std::fs::symlink_metadata(path)\n+        } else {\n+            std::fs::metadata(path)\n+        };\n+\n+        let metadata = match metadata {\n+            Ok(metadata) => metadata,\n+            Err(e) => {\n+                this.set_last_error_from_io_error(e)?;\n+                return Ok(-1);\n+            }\n+        };\n+\n+        let file_type = metadata.file_type();\n+\n+        let mode_name = if file_type.is_file() {\n+            \"S_IFREG\"\n+        } else if file_type.is_dir() {\n+            \"S_IFDIR\"\n+        } else {\n+            \"S_IFLNK\"\n+        };\n+\n+        // The `mode` field specifies the type of the file and the permissions over the file for\n+        // the owner, its group and other users. Given that we can only provide the file type\n+        // without using platform specific methods, we only set the bits corresponding to the file\n+        // type. This should be an `__u16` but `libc` provides its values as `u32`.\n+        let mode: u16 = this.eval_libc(mode_name)?\n+                .to_u32()?\n+                .try_into()\n+                .unwrap_or_else(|_| bug!(\"libc contains bad value for `{}` constant\", mode_name));\n+\n+        let size = metadata.len();\n+\n+        let (access_sec, access_nsec) = extract_sec_and_nsec(\n+            metadata.accessed(),\n+            &mut mask,\n+            this.eval_libc(\"STATX_ATIME\")?.to_u32()?\n+        )?;\n+\n+        let (created_sec, created_nsec) = extract_sec_and_nsec(\n+            metadata.created(),\n+            &mut mask,\n+            this.eval_libc(\"STATX_BTIME\")?.to_u32()?\n+        )?;\n+\n+        let (modified_sec, modified_nsec) = extract_sec_and_nsec(\n+            metadata.modified(),\n+            &mut mask,\n+            this.eval_libc(\"STATX_MTIME\")?.to_u32()?\n+        )?;\n+\n+        let __u32_layout = this.libc_ty_layout(\"__u32\")?;\n+        let __u64_layout = this.libc_ty_layout(\"__u64\")?;\n+        let __u16_layout = this.libc_ty_layout(\"__u16\")?;\n+\n+        // Now we transform all this fields into `ImmTy`s and write them to `statxbuf`. We write a\n+        // zero for the unavailable fields.\n+        // FIXME: Provide more fields using platform specific methods.\n+        let imms = [\n+            immty_from_uint_checked(mask, __u32_layout)?,  // stx_mask\n+            immty_from_uint_checked(0u128, __u32_layout)?, // stx_blksize\n+            immty_from_uint_checked(0u128, __u64_layout)?, // stx_attributes\n+            immty_from_uint_checked(0u128, __u32_layout)?, // stx_nlink\n+            immty_from_uint_checked(0u128, __u32_layout)?, // stx_uid\n+            immty_from_uint_checked(0u128, __u32_layout)?, // stx_gid\n+            immty_from_uint_checked(mode, __u16_layout)?,  // stx_mode\n+            immty_from_uint_checked(0u128, __u16_layout)?, // statx padding\n+            immty_from_uint_checked(0u128, __u64_layout)?, // stx_ino\n+            immty_from_uint_checked(size, __u64_layout)?,  // stx_size\n+            immty_from_uint_checked(0u128, __u64_layout)?, // stx_blocks\n+            immty_from_uint_checked(0u128, __u64_layout)?, // stx_attributes\n+            immty_from_uint_checked(access_sec, __u64_layout)?, // stx_atime.tv_sec\n+            immty_from_uint_checked(access_nsec, __u32_layout)?, // stx_atime.tv_nsec\n+            immty_from_uint_checked(0u128, __u32_layout)?, // statx_timestamp padding\n+            immty_from_uint_checked(created_sec, __u64_layout)?, // stx_btime.tv_sec\n+            immty_from_uint_checked(created_nsec, __u32_layout)?, // stx_btime.tv_nsec\n+            immty_from_uint_checked(0u128, __u32_layout)?, // statx_timestamp padding\n+            immty_from_uint_checked(0u128, __u64_layout)?, // stx_ctime.tv_sec\n+            immty_from_uint_checked(0u128, __u32_layout)?, // stx_ctime.tv_nsec\n+            immty_from_uint_checked(0u128, __u32_layout)?, // statx_timestamp padding\n+            immty_from_uint_checked(modified_sec, __u64_layout)?, // stx_mtime.tv_sec\n+            immty_from_uint_checked(modified_nsec, __u32_layout)?, // stx_mtime.tv_nsec\n+            immty_from_uint_checked(0u128, __u32_layout)?, // statx_timestamp padding\n+            immty_from_uint_checked(0u128, __u64_layout)?, // stx_rdev_major\n+            immty_from_uint_checked(0u128, __u64_layout)?, // stx_rdev_minor\n+            immty_from_uint_checked(0u128, __u64_layout)?, // stx_dev_major\n+            immty_from_uint_checked(0u128, __u64_layout)?, // stx_dev_minor\n+        ];\n+\n+        this.write_packed_immediates(&statxbuf_place, &imms)?;\n+\n+        Ok(0)\n+    }\n+\n     /// Function used when a handle is not found inside `FileHandler`. It returns `Ok(-1)`and sets\n     /// the last OS error to `libc::EBADF` (invalid file descriptor). This function uses\n     /// `T: From<i32>` instead of `i32` directly because some fs functions return different integer\n@@ -268,3 +447,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok((-1).into())\n     }\n }\n+\n+// Extracts the number of seconds and nanoseconds elapsed between `time` and the unix epoch, and\n+// then sets the `mask` bits determined by `flag` when `time` is Ok. If `time` is an error, it\n+// returns `(0, 0)` without setting any bits.\n+fn extract_sec_and_nsec<'tcx>(time: std::io::Result<SystemTime>, mask: &mut u32, flag: u32) -> InterpResult<'tcx, (u64, u32)> {\n+    if let Ok(time) = time {\n+        let duration = system_time_to_duration(&time)?;\n+        *mask |= flag;\n+        Ok((duration.as_secs(), duration.subsec_nanos()))\n+    } else {\n+        Ok((0, 0))\n+    }\n+}"}, {"sha": "da9ea07c4f257b8f9392a1946753486fa639a2d8", "filename": "src/shims/time.rs", "status": "modified", "additions": 12, "deletions": 27, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a3ea1cb4581970396635fce82182555003083b62/src%2Fshims%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ea1cb4581970396635fce82182555003083b62/src%2Fshims%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftime.rs?ref=a3ea1cb4581970396635fce82182555003083b62", "patch": "@@ -1,34 +1,19 @@\n use std::time::{Duration, SystemTime};\n \n-use rustc::ty::layout::TyLayout;\n-\n use crate::stacked_borrows::Tag;\n use crate::*;\n+use helpers::immty_from_int_checked;\n \n-// Returns the time elapsed between now and the unix epoch as a `Duration` and the sign of the time\n-// interval\n+// Returns the time elapsed between now and the unix epoch as a `Duration`.\n fn get_time<'tcx>() -> InterpResult<'tcx, Duration> {\n-    SystemTime::now()\n-        .duration_since(SystemTime::UNIX_EPOCH)\n-        .map_err(|_| err_unsup_format!(\"Times before the Unix epoch are not supported\").into())\n+    system_time_to_duration(&SystemTime::now())\n }\n \n-fn int_to_immty_checked<'tcx>(\n-    int: i128,\n-    layout: TyLayout<'tcx>,\n-) -> InterpResult<'tcx, ImmTy<'tcx, Tag>> {\n-    // If `int` does not fit in `size` bits, we error instead of letting\n-    // `ImmTy::from_int` panic.\n-    let size = layout.size;\n-    let truncated = truncate(int as u128, size);\n-    if sign_extend(truncated, size) as i128 != int {\n-        throw_unsup_format!(\n-            \"Signed value {:#x} does not fit in {} bits\",\n-            int,\n-            size.bits()\n-        )\n-    }\n-    Ok(ImmTy::from_int(int, layout))\n+// Returns the time elapsed between the provided time and the unix epoch as a `Duration`.\n+pub fn system_time_to_duration<'tcx>(time: &SystemTime) -> InterpResult<'tcx, Duration> {\n+    time\n+        .duration_since(SystemTime::UNIX_EPOCH)\n+        .map_err(|_| err_unsup_format!(\"Times before the Unix epoch are not supported\").into())\n }\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n@@ -57,8 +42,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let tv_nsec = duration.subsec_nanos() as i128;\n \n         let imms = [\n-            int_to_immty_checked(tv_sec, this.libc_ty_layout(\"time_t\")?)?,\n-            int_to_immty_checked(tv_nsec, this.libc_ty_layout(\"c_long\")?)?,\n+            immty_from_int_checked(tv_sec, this.libc_ty_layout(\"time_t\")?)?,\n+            immty_from_int_checked(tv_nsec, this.libc_ty_layout(\"c_long\")?)?,\n         ];\n \n         this.write_packed_immediates(&tp, &imms)?;\n@@ -89,8 +74,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let tv_usec = duration.subsec_micros() as i128;\n \n         let imms = [\n-            int_to_immty_checked(tv_sec, this.libc_ty_layout(\"time_t\")?)?,\n-            int_to_immty_checked(tv_usec, this.libc_ty_layout(\"suseconds_t\")?)?,\n+            immty_from_int_checked(tv_sec, this.libc_ty_layout(\"time_t\")?)?,\n+            immty_from_int_checked(tv_usec, this.libc_ty_layout(\"suseconds_t\")?)?,\n         ];\n \n         this.write_packed_immediates(&tv, &imms)?;"}, {"sha": "b8f9e3229af67c918cf419b18b4eaaaab23135d9", "filename": "tests/run-pass/fs.rs", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a3ea1cb4581970396635fce82182555003083b62/tests%2Frun-pass%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ea1cb4581970396635fce82182555003083b62/tests%2Frun-pass%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffs.rs?ref=a3ea1cb4581970396635fce82182555003083b62", "patch": "@@ -2,11 +2,32 @@\n // compile-flags: -Zmiri-disable-isolation\n \n use std::fs::{File, remove_file};\n-use std::io::{Read, Write, ErrorKind};\n+use std::io::{Read, Write, ErrorKind, Result};\n+use std::path::{PathBuf, Path};\n+\n+#[cfg(target_os = \"linux\")]\n+fn test_metadata(bytes: &[u8], path: &Path) -> Result<()> {\n+    // Test that the file metadata is correct.\n+    let metadata = path.metadata()?;\n+    // `path` should point to a file.\n+    assert!(metadata.is_file());\n+    // The size of the file must be equal to the number of written bytes.\n+    assert_eq!(bytes.len() as u64, metadata.len());\n+    Ok(())\n+}\n+\n+// FIXME: Implement stat64 for macos.\n+#[cfg(not(target_os = \"linux\"))]\n+fn test_metadata(_bytes: &[u8], _path: &Path) -> Result<()> {\n+    Ok(())\n+}\n \n fn main() {\n-    let path = std::env::temp_dir().join(\"miri_test_fs.txt\");\n+    let tmp = std::env::temp_dir();\n+    let filename = PathBuf::from(\"miri_test_fs.txt\");\n+    let path = tmp.join(&filename);\n     let bytes = b\"Hello, World!\\n\";\n+\n     // Test creating, writing and closing a file (closing is tested when `file` is dropped).\n     let mut file = File::create(&path).unwrap();\n     // Writing 0 bytes should not change the file contents.\n@@ -21,12 +42,23 @@ fn main() {\n     // Reading until EOF should get the whole text.\n     file.read_to_end(&mut contents).unwrap();\n     assert_eq!(bytes, contents.as_slice());\n-    // Removing file should succeed\n+\n+    // Test that metadata of an absolute path is correct.\n+    test_metadata(bytes, &path).unwrap();\n+    // Test that metadata of a relative path is correct.\n+    std::env::set_current_dir(tmp).unwrap();\n+    test_metadata(bytes, &filename).unwrap();\n+\n+    // Removing file should succeed.\n     remove_file(&path).unwrap();\n \n     // The two following tests also check that the `__errno_location()` shim is working properly.\n     // Opening a non-existing file should fail with a \"not found\" error.\n     assert_eq!(ErrorKind::NotFound, File::open(&path).unwrap_err().kind());\n     // Removing a non-existing file should fail with a \"not found\" error.\n     assert_eq!(ErrorKind::NotFound, remove_file(&path).unwrap_err().kind());\n+    // Reading the metadata of a non-existing file should fail with a \"not found\" error.\n+    if cfg!(target_os = \"linux\") { // FIXME: Implement stat64 for macos.\n+        assert_eq!(ErrorKind::NotFound, test_metadata(bytes, &path).unwrap_err().kind());\n+    }\n }"}]}