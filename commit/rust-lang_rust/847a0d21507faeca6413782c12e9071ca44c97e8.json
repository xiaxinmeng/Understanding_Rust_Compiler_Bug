{"sha": "847a0d21507faeca6413782c12e9071ca44c97e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0N2EwZDIxNTA3ZmFlY2E2NDEzNzgyYzEyZTkwNzFjYTQ0Yzk3ZTg=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-02-10T03:11:27Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-02-14T20:33:21Z"}, "message": "Some error recovery in the parser", "tree": {"sha": "f95d0589b5459ca8ea4fd33da2315c88bd2d9c7e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f95d0589b5459ca8ea4fd33da2315c88bd2d9c7e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/847a0d21507faeca6413782c12e9071ca44c97e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/847a0d21507faeca6413782c12e9071ca44c97e8", "html_url": "https://github.com/rust-lang/rust/commit/847a0d21507faeca6413782c12e9071ca44c97e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/847a0d21507faeca6413782c12e9071ca44c97e8/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ffd2a0b9d78191b8a3d97f687077852d15c9b7aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffd2a0b9d78191b8a3d97f687077852d15c9b7aa", "html_url": "https://github.com/rust-lang/rust/commit/ffd2a0b9d78191b8a3d97f687077852d15c9b7aa"}], "stats": {"total": 214, "additions": 173, "deletions": 41}, "files": [{"sha": "572c51cc2f4bac4dbc571b605e3f4e3283dc9e95", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 150, "deletions": 32, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/847a0d21507faeca6413782c12e9071ca44c97e8/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847a0d21507faeca6413782c12e9071ca44c97e8/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=847a0d21507faeca6413782c12e9071ca44c97e8", "patch": "@@ -105,6 +105,12 @@ pub enum ParsePub {\n     No,\n }\n \n+#[derive(Clone, Copy, PartialEq)]\n+pub enum SemiColonMode {\n+    Break,\n+    Ignore,\n+}\n+\n /// Possibly accept an `token::Interpolated` expression (a pre-parsed expression\n /// dropped into the token stream, which happens while parsing the result of\n /// macro expansion). Placement of these is not as complex as I feared it would\n@@ -843,7 +849,10 @@ impl<'a> Parser<'a> {\n     /// Eat and discard tokens until one of `kets` is encountered. Respects token trees,\n     /// passes through any errors encountered. Used for error recovery.\n     pub fn eat_to_tokens(&mut self, kets: &[&token::Token]) {\n-        self.parse_seq_to_before_tokens(kets, seq_sep_none(), |p| p.parse_token_tree());\n+        self.parse_seq_to_before_tokens(kets,\n+                                        seq_sep_none(),\n+                                        |p| p.parse_token_tree(),\n+                                        |mut e| e.cancel());\n     }\n \n     /// Parse a sequence, including the closing delimiter. The function\n@@ -871,15 +880,18 @@ impl<'a> Parser<'a> {\n                                          -> Vec<T>\n         where F: FnMut(&mut Parser<'a>) -> PResult<'a,  T>,\n     {\n-        self.parse_seq_to_before_tokens(&[ket], sep, f)\n+        self.parse_seq_to_before_tokens(&[ket], sep, f, |mut e| e.emit())\n     }\n \n-    pub fn parse_seq_to_before_tokens<T, F>(&mut self,\n+    // `fe` is an error handler.\n+    fn parse_seq_to_before_tokens<T, F, Fe>(&mut self,\n                                             kets: &[&token::Token],\n                                             sep: SeqSep,\n-                                            mut f: F)\n+                                            mut f: F,\n+                                            mut fe: Fe)\n                                             -> Vec<T>\n         where F: FnMut(&mut Parser<'a>) -> PResult<'a,  T>,\n+              Fe: FnMut(DiagnosticBuilder)\n     {\n         let mut first: bool = true;\n         let mut v = vec!();\n@@ -889,8 +901,8 @@ impl<'a> Parser<'a> {\n                     if first {\n                         first = false;\n                     } else {\n-                        if let Err(mut e) = self.expect(t) {\n-                            e.emit();\n+                        if let Err(e) = self.expect(t) {\n+                            fe(e);\n                             break;\n                         }\n                     }\n@@ -903,8 +915,8 @@ impl<'a> Parser<'a> {\n \n             match f(self) {\n                 Ok(t) => v.push(t),\n-                Err(mut e) => {\n-                    e.emit();\n+                Err(e) => {\n+                    fe(e);\n                     break;\n                 }\n             }\n@@ -1263,7 +1275,7 @@ impl<'a> Parser<'a> {\n                                 break;\n                             }\n                         }\n-                        \n+\n                         return Err(e);\n                     }\n                 };\n@@ -2339,14 +2351,37 @@ impl<'a> Parser<'a> {\n \n                             while self.token != token::CloseDelim(token::Brace) {\n                                 if self.eat(&token::DotDot) {\n-                                    base = Some(try!(self.parse_expr()));\n+                                    match self.parse_expr() {\n+                                        Ok(e) => {\n+                                            base = Some(e);\n+                                        }\n+                                        Err(mut e) => {\n+                                            e.emit();\n+                                            self.recover_stmt();\n+                                        }\n+                                    }\n                                     break;\n                                 }\n \n-                                fields.push(try!(self.parse_field()));\n-                                try!(self.commit_expr(&fields.last().unwrap().expr,\n-                                                 &[token::Comma],\n-                                                 &[token::CloseDelim(token::Brace)]));\n+                                match self.parse_field() {\n+                                    Ok(f) => fields.push(f),\n+                                    Err(mut e) => {\n+                                        e.emit();\n+                                        self.recover_stmt();\n+                                        break;\n+                                    }\n+                                }\n+\n+                                match self.commit_expr(&fields.last().unwrap().expr,\n+                                                       &[token::Comma],\n+                                                       &[token::CloseDelim(token::Brace)]) {\n+                                    Ok(()) => {}\n+                                    Err(mut e) => {\n+                                        e.emit();\n+                                        self.recover_stmt();\n+                                        break;\n+                                    }\n+                                }\n                             }\n \n                             hi = self.span.hi;\n@@ -2748,6 +2783,7 @@ impl<'a> Parser<'a> {\n                         if let Some(&sp) = self.open_braces.last() {\n                             err.span_note(sp, \"unclosed delimiter\");\n                         };\n+\n                         Err(err)\n                     },\n                     /* we ought to allow different depths of unquotation */\n@@ -3195,8 +3231,8 @@ impl<'a> Parser<'a> {\n     fn parse_match_expr(&mut self, attrs: ThinAttributes) -> PResult<'a, P<Expr>> {\n         let match_span = self.last_span;\n         let lo = self.last_span.lo;\n-        let discriminant = try!(self.parse_expr_res(\n-            Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None));\n+        let discriminant = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL,\n+                                                    None));\n         if let Err(mut e) = self.commit_expr_expecting(&discriminant,\n                                                        token::OpenDelim(token::Brace)) {\n             if self.token == token::Token::Semi {\n@@ -3208,7 +3244,19 @@ impl<'a> Parser<'a> {\n             try!(self.parse_inner_attributes()).into_thin_attrs());\n         let mut arms: Vec<Arm> = Vec::new();\n         while self.token != token::CloseDelim(token::Brace) {\n-            arms.push(try!(self.parse_arm()));\n+            match self.parse_arm() {\n+                Ok(arm) => arms.push(arm),\n+                Err(mut e) => {\n+                    // Recover by skipping to the end of the block.\n+                    e.emit();\n+                    self.recover_stmt();\n+                    let hi = self.span.hi;\n+                    if self.token == token::CloseDelim(token::Brace) {\n+                        self.bump();\n+                    }\n+                    return Ok(self.mk_expr(lo, hi, ExprMatch(discriminant, arms), attrs));\n+                }\n+            }\n         }\n         let hi = self.span.hi;\n         self.bump();\n@@ -3566,7 +3614,11 @@ impl<'a> Parser<'a> {\n                         }\n                         // Parse struct pattern\n                         self.bump();\n-                        let (fields, etc) = try!(self.parse_pat_fields());\n+                        let (fields, etc) = self.parse_pat_fields().unwrap_or_else(|mut e| {\n+                            e.emit();\n+                            self.recover_stmt();\n+                            (vec![], false)\n+                        });\n                         self.bump();\n                         pat = PatKind::Struct(path, fields, etc);\n                       }\n@@ -3720,10 +3772,72 @@ impl<'a> Parser<'a> {\n \n     /// Parse a statement. may include decl.\n     pub fn parse_stmt(&mut self) -> PResult<'a, Option<Stmt>> {\n-        Ok(try!(self.parse_stmt_()))\n+        Ok(self.parse_stmt_().map(P))\n+    }\n+\n+    // Eat tokens until we can be relatively sure we reached the end of the\n+    // statement. This is something of a best-effort heuristic.\n+    //\n+    // We terminate when we find an unmatched `}` (without consuming it).\n+    fn recover_stmt(&mut self) {\n+        self.recover_stmt_(SemiColonMode::Ignore)\n+    }\n+    // If `break_on_semi` is `Break`, then we will stop consuming tokens after\n+    // finding (and consuming) a `;` outside of `{}` or `[]` (note that this is\n+    // approximate - it can mean we break too early due to macros, but that\n+    // shoud only lead to sub-optimal recovery, not inaccurate parsing).\n+    fn recover_stmt_(&mut self, break_on_semi: SemiColonMode) {\n+        let mut brace_depth = 0;\n+        let mut bracket_depth = 0;\n+        loop {\n+            match self.token {\n+                token::OpenDelim(token::DelimToken::Brace) => {\n+                    brace_depth += 1;\n+                    self.bump();\n+                }\n+                token::OpenDelim(token::DelimToken::Bracket) => {\n+                    bracket_depth += 1;\n+                    self.bump();\n+                }\n+                token::CloseDelim(token::DelimToken::Brace) => {\n+                    if brace_depth == 0 {\n+                        return;\n+                    }\n+                    brace_depth -= 1;\n+                    self.bump();\n+                }\n+                token::CloseDelim(token::DelimToken::Bracket) => {\n+                    bracket_depth -= 1;\n+                    if bracket_depth < 0 {\n+                        bracket_depth = 0;\n+                    }\n+                    self.bump();\n+                }\n+                token::Eof => return,\n+                token::Semi => {\n+                    self.bump();\n+                    if break_on_semi == SemiColonMode::Break &&\n+                       brace_depth == 0 &&\n+                       bracket_depth == 0 {\n+                        return;\n+                    }\n+                }\n+                _ => {\n+                    self.bump()\n+                }\n+            }\n+        }\n     }\n \n-    fn parse_stmt_(&mut self) -> PResult<'a, Option<Stmt>> {\n+    fn parse_stmt_(&mut self) -> Option<Stmt> {\n+        self.parse_stmt_without_recovery().unwrap_or_else(|mut e| {\n+            e.emit();\n+            self.recover_stmt_(SemiColonMode::Break);\n+            None\n+        })\n+    }\n+\n+    fn parse_stmt_without_recovery(&mut self) -> PResult<'a, Option<Stmt>> {\n         maybe_whole!(Some deref self, NtStmt);\n \n         let attrs = try!(self.parse_outer_attributes());\n@@ -3879,7 +3993,7 @@ impl<'a> Parser<'a> {\n         let lo = self.span.lo;\n         try!(self.expect(&token::OpenDelim(token::Brace)));\n         Ok((try!(self.parse_inner_attributes()),\n-         try!(self.parse_block_tail(lo, BlockCheckMode::Default))))\n+            try!(self.parse_block_tail(lo, BlockCheckMode::Default))))\n     }\n \n     /// Parse the rest of a block expression or function body\n@@ -3889,7 +4003,7 @@ impl<'a> Parser<'a> {\n         let mut expr = None;\n \n         while !self.eat(&token::CloseDelim(token::Brace)) {\n-            let Spanned {node, span} = if let Some(s) = try!(self.parse_stmt_()) {\n+            let Spanned {node, span} = if let Some(s) = self.parse_stmt_() {\n                 s\n             } else {\n                 // Found only `;` or `}`.\n@@ -3974,17 +4088,21 @@ impl<'a> Parser<'a> {\n         }))\n     }\n \n-    fn handle_expression_like_statement(\n-            &mut self,\n-            e: P<Expr>,\n-            span: Span,\n-            stmts: &mut Vec<Stmt>,\n-            last_block_expr: &mut Option<P<Expr>>) -> PResult<'a, ()> {\n+    fn handle_expression_like_statement(&mut self,\n+                                        e: P<Expr>,\n+                                        span: Span,\n+                                        stmts: &mut Vec<Stmt>,\n+                                        last_block_expr: &mut Option<P<Expr>>)\n+                                        -> PResult<'a, ()> {\n         // expression without semicolon\n         if classify::expr_requires_semi_to_be_stmt(&e) {\n             // Just check for errors and recover; do not eat semicolon yet.\n-            try!(self.commit_stmt(&[],\n-                             &[token::Semi, token::CloseDelim(token::Brace)]));\n+            if let Err(mut e) =\n+                self.commit_stmt(&[], &[token::Semi, token::CloseDelim(token::Brace)])\n+            {\n+                e.emit();\n+                self.recover_stmt();\n+            }\n         }\n \n         match self.token {\n@@ -4381,13 +4499,13 @@ impl<'a> Parser<'a> {\n                 }\n             ));\n \n+        let args: Vec<_> = args.into_iter().filter_map(|x| x).collect();\n+\n         if variadic && args.is_empty() {\n             self.span_err(sp,\n                           \"variadic function must be declared with at least one named argument\");\n         }\n \n-        let args = args.into_iter().filter_map(|x| x).collect();\n-\n         Ok((args, variadic))\n     }\n "}, {"sha": "67f619b4de4f433f79f771dd6fe431cf24c2f584", "filename": "src/test/compile-fail/issue-30715.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/847a0d21507faeca6413782c12e9071ca44c97e8/src%2Ftest%2Fcompile-fail%2Fissue-30715.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847a0d21507faeca6413782c12e9071ca44c97e8/src%2Ftest%2Fcompile-fail%2Fissue-30715.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-30715.rs?ref=847a0d21507faeca6413782c12e9071ca44c97e8", "patch": "@@ -25,7 +25,7 @@ macro_rules! parallel {\n fn main() {\n     parallel! {\n         for i in 0..n {\n-            x += i; //~ ERROR no rules expected the token `+=`\n-        }\n+            x += i; //~ ERROR expected `:`, found `+=`\n+        } //~ ERROR unexpected end of macro invocation\n     }\n }"}, {"sha": "364a7e9cf6d75cb025ea9fc3f4691739ff95d2b2", "filename": "src/test/compile-fail/macro-incomplete-parse.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/847a0d21507faeca6413782c12e9071ca44c97e8/src%2Ftest%2Fcompile-fail%2Fmacro-incomplete-parse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847a0d21507faeca6413782c12e9071ca44c97e8/src%2Ftest%2Fcompile-fail%2Fmacro-incomplete-parse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-incomplete-parse.rs?ref=847a0d21507faeca6413782c12e9071ca44c97e8", "patch": "@@ -18,7 +18,7 @@ macro_rules! ignored_item {\n \n macro_rules! ignored_expr {\n     () => ( 1,  //~ ERROR unexpected token: `,`\n-            2 ) //~ ERROR macro expansion ignores token `2`\n+            2 )\n }\n \n macro_rules! ignored_pat {\n@@ -28,7 +28,7 @@ macro_rules! ignored_pat {\n ignored_item!(); //~ NOTE caused by the macro expansion here\n \n fn main() {\n-    ignored_expr!(); //~ NOTE caused by the macro expansion here\n+    ignored_expr!();\n     match 1 {\n         ignored_pat!() => (), //~ NOTE caused by the macro expansion here\n         _ => (),"}, {"sha": "ff434d87e1fb2c141955f5f363ad7d4837a56974", "filename": "src/test/parse-fail/brace-after-qualified-path-in-match.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/847a0d21507faeca6413782c12e9071ca44c97e8/src%2Ftest%2Fparse-fail%2Fbrace-after-qualified-path-in-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847a0d21507faeca6413782c12e9071ca44c97e8/src%2Ftest%2Fparse-fail%2Fbrace-after-qualified-path-in-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fbrace-after-qualified-path-in-match.rs?ref=847a0d21507faeca6413782c12e9071ca44c97e8", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -Z parse-only\n+\n fn foo() {\n     match x {\n         <T as Trait>::Type{key: value} => (),"}, {"sha": "41a3b06e6556e9bd1d8ba065256f345de9b1cf90", "filename": "src/test/parse-fail/issue-10636-2.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/847a0d21507faeca6413782c12e9071ca44c97e8/src%2Ftest%2Fparse-fail%2Fissue-10636-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847a0d21507faeca6413782c12e9071ca44c97e8/src%2Ftest%2Fparse-fail%2Fissue-10636-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-10636-2.rs?ref=847a0d21507faeca6413782c12e9071ca44c97e8", "patch": "@@ -8,8 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// FIXME(31528) we emit a bunch of silly errors here due to continuing past the\n+// first one. This would be easy-ish to address by better recovery in tokenisation.\n+\n // compile-flags: -Z parse-only\n \n-pub fn trace_option(option: Option<isize>) {\n+pub fn trace_option(option: Option<isize>) { //~ HELP did you mean to close this delimiter?\n     option.map(|some| 42; //~ NOTE: unclosed delimiter\n+                          //~^ ERROR: expected one of\n } //~ ERROR: incorrect close delimiter\n+//~^ ERROR: expected one of\n+//~ ERROR: this file contains an un-closed delimiter"}, {"sha": "b99d0493ff7333b2f402829193a766a3ecc1f382", "filename": "src/test/parse-fail/match-refactor-to-expr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/847a0d21507faeca6413782c12e9071ca44c97e8/src%2Ftest%2Fparse-fail%2Fmatch-refactor-to-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847a0d21507faeca6413782c12e9071ca44c97e8/src%2Ftest%2Fparse-fail%2Fmatch-refactor-to-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fmatch-refactor-to-expr.rs?ref=847a0d21507faeca6413782c12e9071ca44c97e8", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -Z parse-only\n+\n fn main() {\n     let foo =\n         match //~ NOTE did you mean to remove this `match` keyword?"}, {"sha": "d3aa4b72b78a55190c1fdadb9e6d982c217a7709", "filename": "src/test/parse-fail/paren-after-qualified-path-in-match.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/847a0d21507faeca6413782c12e9071ca44c97e8/src%2Ftest%2Fparse-fail%2Fparen-after-qualified-path-in-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847a0d21507faeca6413782c12e9071ca44c97e8/src%2Ftest%2Fparse-fail%2Fparen-after-qualified-path-in-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fparen-after-qualified-path-in-match.rs?ref=847a0d21507faeca6413782c12e9071ca44c97e8", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -Z parse-only\n+\n fn foo() {\n     match x {\n         <T as Trait>::Type(2) => (),"}, {"sha": "a163b38b49270ac25f18c67d055074e39689c038", "filename": "src/test/parse-fail/pat-lt-bracket-4.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/847a0d21507faeca6413782c12e9071ca44c97e8/src%2Ftest%2Fparse-fail%2Fpat-lt-bracket-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847a0d21507faeca6413782c12e9071ca44c97e8/src%2Ftest%2Fparse-fail%2Fpat-lt-bracket-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fpat-lt-bracket-4.rs?ref=847a0d21507faeca6413782c12e9071ca44c97e8", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -Z parse-only\n+\n enum BtNode {\n     Node(u32,Box<BtNode>,Box<BtNode>),\n     Leaf(u32),"}, {"sha": "e57298f72804af423ba7a55a3c6e5e9d91529934", "filename": "src/test/parse-fail/struct-literal-in-for.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/847a0d21507faeca6413782c12e9071ca44c97e8/src%2Ftest%2Fparse-fail%2Fstruct-literal-in-for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847a0d21507faeca6413782c12e9071ca44c97e8/src%2Ftest%2Fparse-fail%2Fstruct-literal-in-for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fstruct-literal-in-for.rs?ref=847a0d21507faeca6413782c12e9071ca44c97e8", "patch": "@@ -23,7 +23,7 @@ impl Foo {\n fn main() {\n     for x in Foo {\n         x: 3    //~ ERROR expected type, found `3`\n-    }.hi() {\n+    }.hi() { //~ ERROR expected one of `.`, `;`, `}`, or an operator, found `{`\n         println!(\"yo\");\n     }\n }"}, {"sha": "6bf41b7a450aff70a1c6492c4ce331b7c82e3b5d", "filename": "src/test/parse-fail/struct-literal-in-if.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/847a0d21507faeca6413782c12e9071ca44c97e8/src%2Ftest%2Fparse-fail%2Fstruct-literal-in-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847a0d21507faeca6413782c12e9071ca44c97e8/src%2Ftest%2Fparse-fail%2Fstruct-literal-in-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fstruct-literal-in-if.rs?ref=847a0d21507faeca6413782c12e9071ca44c97e8", "patch": "@@ -23,7 +23,7 @@ impl Foo {\n fn main() {\n     if Foo {\n         x: 3    //~ ERROR expected type, found `3`\n-    }.hi() {\n+    }.hi() { //~ ERROR expected one of `.`, `;`, `}`, or an operator, found `{`\n         println!(\"yo\");\n     }\n }"}, {"sha": "679f4542824fbd0ff4155e7429add1bd28daac80", "filename": "src/test/parse-fail/struct-literal-in-match-discriminant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/847a0d21507faeca6413782c12e9071ca44c97e8/src%2Ftest%2Fparse-fail%2Fstruct-literal-in-match-discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847a0d21507faeca6413782c12e9071ca44c97e8/src%2Ftest%2Fparse-fail%2Fstruct-literal-in-match-discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fstruct-literal-in-match-discriminant.rs?ref=847a0d21507faeca6413782c12e9071ca44c97e8", "patch": "@@ -20,6 +20,6 @@ fn main() {\n     } {\n         Foo {\n             x: x\n-        } => {}\n+        } => {} //~ ERROR expected one of `.`, `;`, `}`, or an operator, found `=>`\n     }\n }"}, {"sha": "b388aac2c54875400a3ea4b0e35c770ec43c2fd5", "filename": "src/test/parse-fail/struct-literal-in-while.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/847a0d21507faeca6413782c12e9071ca44c97e8/src%2Ftest%2Fparse-fail%2Fstruct-literal-in-while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847a0d21507faeca6413782c12e9071ca44c97e8/src%2Ftest%2Fparse-fail%2Fstruct-literal-in-while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fstruct-literal-in-while.rs?ref=847a0d21507faeca6413782c12e9071ca44c97e8", "patch": "@@ -23,7 +23,7 @@ impl Foo {\n fn main() {\n     while Foo {\n         x: 3    //~ ERROR expected type, found `3`\n-    }.hi() {\n+    }.hi() { //~ ERROR expected one of `.`, `;`, `}`, or an operator, found `{`\n         println!(\"yo\");\n     }\n }"}]}