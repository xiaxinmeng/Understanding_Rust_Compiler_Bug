{"sha": "b4457fb8a2157d7e9a983ba67e5554509017379d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0NDU3ZmI4YTIxNTdkN2U5YTk4M2JhNjdlNTU1NDUwOTAxNzM3OWQ=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-03-31T03:34:38Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-03-31T03:34:38Z"}, "message": "Rollup merge of #23859 - pnkfelix:fsk-lesser-box, r=nikomatsakis\n\nDisallow writing through mutable pointers stored in non-mut Box.\r\n\r\nFix #14270 \r\n\r\nThe fix works by making `cmt::freely_aliasable` result more fine-grained.\r\n\r\nInstead of encoding the aliasability (i.e. whether the cmt is uniquely writable or not) as an option, now pass back an enum indicating either: 1. freely-aliasable (thus not uniquely-writable), 2. non-aliasable (thus uniquely writable), or 3. unique but immutable (and thus not uniquely writable, according to proposal from issue #14270.)\r\n\r\nThis is all of course a giant hack that will hopefully go away with an eventually removal of special treatment of `Box<T>` (aka `ty_unique`) from the compiler.", "tree": {"sha": "533961f62e1e4535b67fb7240930d7018f99bbfe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/533961f62e1e4535b67fb7240930d7018f99bbfe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4457fb8a2157d7e9a983ba67e5554509017379d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4457fb8a2157d7e9a983ba67e5554509017379d", "html_url": "https://github.com/rust-lang/rust/commit/b4457fb8a2157d7e9a983ba67e5554509017379d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4457fb8a2157d7e9a983ba67e5554509017379d/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c0329cfa8ff70365e3fc02a75e31ef82b2cdc75", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c0329cfa8ff70365e3fc02a75e31ef82b2cdc75", "html_url": "https://github.com/rust-lang/rust/commit/2c0329cfa8ff70365e3fc02a75e31ef82b2cdc75"}, {"sha": "e4340531c2af4b39b5ee7c111fae4f6f27ac8bf7", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4340531c2af4b39b5ee7c111fae4f6f27ac8bf7", "html_url": "https://github.com/rust-lang/rust/commit/e4340531c2af4b39b5ee7c111fae4f6f27ac8bf7"}], "stats": {"total": 288, "additions": 223, "deletions": 65}, "files": [{"sha": "e98b438d370c70055c9cbda771733033b8464814", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b4457fb8a2157d7e9a983ba67e5554509017379d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4457fb8a2157d7e9a983ba67e5554509017379d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=b4457fb8a2157d7e9a983ba67e5554509017379d", "patch": "@@ -885,6 +885,11 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         }\n     }\n \n+    // When this returns true, it means that the expression *is* a\n+    // method-call (i.e. via the operator-overload).  This true result\n+    // also implies that walk_overloaded_operator already took care of\n+    // recursively processing the input arguments, and thus the caller\n+    // should not do so.\n     fn walk_overloaded_operator(&mut self,\n                                 expr: &ast::Expr,\n                                 receiver: &ast::Expr,"}, {"sha": "3738e38f68704988e75dfc6c1231570f1e6c2fa2", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 118, "deletions": 51, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/b4457fb8a2157d7e9a983ba67e5554509017379d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4457fb8a2157d7e9a983ba67e5554509017379d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=b4457fb8a2157d7e9a983ba67e5554509017379d", "patch": "@@ -71,6 +71,8 @@ pub use self::Note::*;\n pub use self::deref_kind::*;\n pub use self::categorization::*;\n \n+use self::Aliasability::*;\n+\n use middle::check_const;\n use middle::def;\n use middle::region;\n@@ -295,23 +297,29 @@ pub trait Typer<'tcx> : ty::ClosureTyper<'tcx> {\n \n impl MutabilityCategory {\n     pub fn from_mutbl(m: ast::Mutability) -> MutabilityCategory {\n-        match m {\n+        let ret = match m {\n             MutImmutable => McImmutable,\n             MutMutable => McDeclared\n-        }\n+        };\n+        debug!(\"MutabilityCategory::{}({:?}) => {:?}\",\n+               \"from_mutbl\", m, ret);\n+        ret\n     }\n \n     pub fn from_borrow_kind(borrow_kind: ty::BorrowKind) -> MutabilityCategory {\n-        match borrow_kind {\n+        let ret = match borrow_kind {\n             ty::ImmBorrow => McImmutable,\n             ty::UniqueImmBorrow => McImmutable,\n             ty::MutBorrow => McDeclared,\n-        }\n+        };\n+        debug!(\"MutabilityCategory::{}({:?}) => {:?}\",\n+               \"from_borrow_kind\", borrow_kind, ret);\n+        ret\n     }\n \n-    pub fn from_pointer_kind(base_mutbl: MutabilityCategory,\n-                             ptr: PointerKind) -> MutabilityCategory {\n-        match ptr {\n+    fn from_pointer_kind(base_mutbl: MutabilityCategory,\n+                         ptr: PointerKind) -> MutabilityCategory {\n+        let ret = match ptr {\n             Unique => {\n                 base_mutbl.inherit()\n             }\n@@ -321,11 +329,14 @@ impl MutabilityCategory {\n             UnsafePtr(m) => {\n                 MutabilityCategory::from_mutbl(m)\n             }\n-        }\n+        };\n+        debug!(\"MutabilityCategory::{}({:?}, {:?}) => {:?}\",\n+               \"from_pointer_kind\", base_mutbl, ptr, ret);\n+        ret\n     }\n \n     fn from_local(tcx: &ty::ctxt, id: ast::NodeId) -> MutabilityCategory {\n-        match tcx.map.get(id) {\n+        let ret = match tcx.map.get(id) {\n             ast_map::NodeLocal(p) | ast_map::NodeArg(p) => match p.node {\n                 ast::PatIdent(bind_mode, _, _) => {\n                     if bind_mode == ast::BindByValue(ast::MutMutable) {\n@@ -337,30 +348,39 @@ impl MutabilityCategory {\n                 _ => tcx.sess.span_bug(p.span, \"expected identifier pattern\")\n             },\n             _ => tcx.sess.span_bug(tcx.map.span(id), \"expected identifier pattern\")\n-        }\n+        };\n+        debug!(\"MutabilityCategory::{}(tcx, id={:?}) => {:?}\",\n+               \"from_local\", id, ret);\n+        ret\n     }\n \n     pub fn inherit(&self) -> MutabilityCategory {\n-        match *self {\n+        let ret = match *self {\n             McImmutable => McImmutable,\n             McDeclared => McInherited,\n             McInherited => McInherited,\n-        }\n+        };\n+        debug!(\"{:?}.inherit() => {:?}\", self, ret);\n+        ret\n     }\n \n     pub fn is_mutable(&self) -> bool {\n-        match *self {\n+        let ret = match *self {\n             McImmutable => false,\n             McInherited => true,\n             McDeclared => true,\n-        }\n+        };\n+        debug!(\"{:?}.is_mutable() => {:?}\", self, ret);\n+        ret\n     }\n \n     pub fn is_immutable(&self) -> bool {\n-        match *self {\n+        let ret = match *self {\n             McImmutable => true,\n             McDeclared | McInherited => false\n-        }\n+        };\n+        debug!(\"{:?}.is_immutable() => {:?}\", self, ret);\n+        ret\n     }\n \n     pub fn to_user_str(&self) -> &'static str {\n@@ -733,7 +753,9 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             }\n         };\n \n-        Ok(Rc::new(cmt_result))\n+        let ret = Rc::new(cmt_result);\n+        debug!(\"cat_upvar ret={}\", ret.repr(self.tcx()));\n+        Ok(ret)\n     }\n \n     fn env_deref(&self,\n@@ -794,14 +816,18 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             McDeclared | McInherited => { }\n         }\n \n-        cmt_ {\n+        let ret = cmt_ {\n             id: id,\n             span: span,\n             cat: cat_deref(Rc::new(cmt_result), 0, env_ptr),\n             mutbl: deref_mutbl,\n             ty: var_ty,\n             note: NoteClosureEnv(upvar_id)\n-        }\n+        };\n+\n+        debug!(\"env_deref ret {}\", ret.repr(self.tcx()));\n+\n+        ret\n     }\n \n     pub fn cat_rvalue_node(&self,\n@@ -831,22 +857,26 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 }\n             }\n         };\n-        self.cat_rvalue(id, span, re, expr_ty)\n+        let ret = self.cat_rvalue(id, span, re, expr_ty);\n+        debug!(\"cat_rvalue_node ret {}\", ret.repr(self.tcx()));\n+        ret\n     }\n \n     pub fn cat_rvalue(&self,\n                       cmt_id: ast::NodeId,\n                       span: Span,\n                       temp_scope: ty::Region,\n                       expr_ty: Ty<'tcx>) -> cmt<'tcx> {\n-        Rc::new(cmt_ {\n+        let ret = Rc::new(cmt_ {\n             id:cmt_id,\n             span:span,\n             cat:cat_rvalue(temp_scope),\n             mutbl:McDeclared,\n             ty:expr_ty,\n             note: NoteNone\n-        })\n+        });\n+        debug!(\"cat_rvalue ret {}\", ret.repr(self.tcx()));\n+        ret\n     }\n \n     pub fn cat_field<N:ast_node>(&self,\n@@ -855,14 +885,16 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                  f_name: ast::Name,\n                                  f_ty: Ty<'tcx>)\n                                  -> cmt<'tcx> {\n-        Rc::new(cmt_ {\n+        let ret = Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n             mutbl: base_cmt.mutbl.inherit(),\n             cat: cat_interior(base_cmt, InteriorField(NamedField(f_name))),\n             ty: f_ty,\n             note: NoteNone\n-        })\n+        });\n+        debug!(\"cat_field ret {}\", ret.repr(self.tcx()));\n+        ret\n     }\n \n     pub fn cat_tup_field<N:ast_node>(&self,\n@@ -871,14 +903,16 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                      f_idx: usize,\n                                      f_ty: Ty<'tcx>)\n                                      -> cmt<'tcx> {\n-        Rc::new(cmt_ {\n+        let ret = Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n             mutbl: base_cmt.mutbl.inherit(),\n             cat: cat_interior(base_cmt, InteriorField(PositionalField(f_idx))),\n             ty: f_ty,\n             note: NoteNone\n-        })\n+        });\n+        debug!(\"cat_tup_field ret {}\", ret.repr(self.tcx()));\n+        ret\n     }\n \n     fn cat_deref<N:ast_node>(&self,\n@@ -913,10 +947,14 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         };\n         let base_cmt_ty = base_cmt.ty;\n         match ty::deref(base_cmt_ty, true) {\n-            Some(mt) => self.cat_deref_common(node, base_cmt, deref_cnt,\n+            Some(mt) => {\n+                let ret = self.cat_deref_common(node, base_cmt, deref_cnt,\n                                               mt.ty,\n                                               deref_context,\n-                                              /* implicit: */ false),\n+                                                /* implicit: */ false);\n+                debug!(\"cat_deref ret {}\", ret.repr(self.tcx()));\n+                ret\n+            }\n             None => {\n                 debug!(\"Explicit deref of non-derefable type: {}\",\n                        base_cmt_ty.repr(self.tcx()));\n@@ -954,14 +992,16 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 (base_cmt.mutbl.inherit(), cat_interior(base_cmt, interior))\n             }\n         };\n-        Ok(Rc::new(cmt_ {\n+        let ret = Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n             cat: cat,\n             mutbl: m,\n             ty: deref_ty,\n             note: NoteNone\n-        }))\n+        });\n+        debug!(\"cat_deref_common ret {}\", ret.repr(self.tcx()));\n+        Ok(ret)\n     }\n \n     pub fn cat_index<N:ast_node>(&self,\n@@ -1009,8 +1049,10 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         };\n \n         let m = base_cmt.mutbl.inherit();\n-        return Ok(interior(elt, base_cmt.clone(), base_cmt.ty,\n-                           m, context, element_ty));\n+        let ret = interior(elt, base_cmt.clone(), base_cmt.ty,\n+                           m, context, element_ty);\n+        debug!(\"cat_index ret {}\", ret.repr(self.tcx()));\n+        return Ok(ret);\n \n         fn interior<'tcx, N: ast_node>(elt: &N,\n                                        of_cmt: cmt<'tcx>,\n@@ -1039,14 +1081,14 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                              context: InteriorOffsetKind)\n                              -> McResult<cmt<'tcx>>\n     {\n-        match try!(deref_kind(base_cmt.ty, Some(context))) {\n+        let ret = match try!(deref_kind(base_cmt.ty, Some(context))) {\n             deref_ptr(ptr) => {\n                 // for unique ptrs, we inherit mutability from the\n                 // owning reference.\n                 let m = MutabilityCategory::from_pointer_kind(base_cmt.mutbl, ptr);\n \n                 // the deref is explicit in the resulting cmt\n-                Ok(Rc::new(cmt_ {\n+                Rc::new(cmt_ {\n                     id:elt.id(),\n                     span:elt.span(),\n                     cat:cat_deref(base_cmt.clone(), 0, ptr),\n@@ -1056,13 +1098,15 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                         None => self.tcx().sess.bug(\"Found non-derefable type\")\n                     },\n                     note: NoteNone\n-                }))\n+                })\n             }\n \n             deref_interior(_) => {\n-                Ok(base_cmt)\n+                base_cmt\n             }\n-        }\n+        };\n+        debug!(\"deref_vec ret {}\", ret.repr(self.tcx()));\n+        Ok(ret)\n     }\n \n     /// Given a pattern P like: `[_, ..Q, _]`, where `vec_cmt` is the cmt for `P`, `slice_pat` is\n@@ -1112,14 +1156,16 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                         interior_ty: Ty<'tcx>,\n                                         interior: InteriorKind)\n                                         -> cmt<'tcx> {\n-        Rc::new(cmt_ {\n+        let ret = Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n             mutbl: base_cmt.mutbl.inherit(),\n             cat: cat_interior(base_cmt, interior),\n             ty: interior_ty,\n             note: NoteNone\n-        })\n+        });\n+        debug!(\"cat_imm_interior ret={}\", ret.repr(self.tcx()));\n+        ret\n     }\n \n     pub fn cat_downcast<N:ast_node>(&self,\n@@ -1128,14 +1174,16 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                     downcast_ty: Ty<'tcx>,\n                                     variant_did: ast::DefId)\n                                     -> cmt<'tcx> {\n-        Rc::new(cmt_ {\n+        let ret = Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n             mutbl: base_cmt.mutbl.inherit(),\n             cat: cat_downcast(base_cmt, variant_did),\n             ty: downcast_ty,\n             note: NoteNone\n-        })\n+        });\n+        debug!(\"cat_downcast ret={}\", ret.repr(self.tcx()));\n+        ret\n     }\n \n     pub fn cat_pattern<F>(&self, cmt: cmt<'tcx>, pat: &ast::Pat, mut op: F) -> McResult<()>\n@@ -1341,17 +1389,25 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     }\n }\n \n-#[derive(Copy)]\n+#[derive(Copy, Clone, Debug)]\n pub enum InteriorSafety {\n     InteriorUnsafe,\n     InteriorSafe\n }\n \n-#[derive(Copy)]\n+#[derive(Clone, Debug)]\n+pub enum Aliasability {\n+    FreelyAliasable(AliasableReason),\n+    NonAliasable,\n+    ImmutableUnique(Box<Aliasability>),\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n pub enum AliasableReason {\n     AliasableBorrowed,\n     AliasableClosure(ast::NodeId), // Aliasable due to capture Fn closure env\n     AliasableOther,\n+    UnaliasableImmutable, // Created as needed upon seeing ImmutableUnique\n     AliasableStatic(InteriorSafety),\n     AliasableStaticMut(InteriorSafety),\n }\n@@ -1380,9 +1436,9 @@ impl<'tcx> cmt_<'tcx> {\n         }\n     }\n \n-    /// Returns `Some(_)` if this lvalue represents a freely aliasable pointer type.\n+    /// Returns `FreelyAliasable(_)` if this lvalue represents a freely aliasable pointer type.\n     pub fn freely_aliasable(&self, ctxt: &ty::ctxt<'tcx>)\n-                            -> Option<AliasableReason> {\n+                            -> Aliasability {\n         // Maybe non-obvious: copied upvars can only be considered\n         // non-aliasable in once closures, since any other kind can be\n         // aliased and eventually recused.\n@@ -1393,17 +1449,27 @@ impl<'tcx> cmt_<'tcx> {\n             cat_deref(ref b, _, BorrowedPtr(ty::UniqueImmBorrow, _)) |\n             cat_deref(ref b, _, Implicit(ty::UniqueImmBorrow, _)) |\n             cat_downcast(ref b, _) |\n-            cat_deref(ref b, _, Unique) |\n             cat_interior(ref b, _) => {\n                 // Aliasability depends on base cmt\n                 b.freely_aliasable(ctxt)\n             }\n \n+            cat_deref(ref b, _, Unique) => {\n+                let sub = b.freely_aliasable(ctxt);\n+                if b.mutbl.is_mutable() {\n+                    // Aliasability depends on base cmt alone\n+                    sub\n+                } else {\n+                    // Do not allow mutation through an immutable box.\n+                    ImmutableUnique(Box::new(sub))\n+                }\n+            }\n+\n             cat_rvalue(..) |\n             cat_local(..) |\n             cat_upvar(..) |\n             cat_deref(_, _, UnsafePtr(..)) => { // yes, it's aliasable, but...\n-                None\n+                NonAliasable\n             }\n \n             cat_static_item(..) => {\n@@ -1414,17 +1480,18 @@ impl<'tcx> cmt_<'tcx> {\n                 };\n \n                 if self.mutbl.is_mutable() {\n-                    Some(AliasableStaticMut(int_safe))\n+                    FreelyAliasable(AliasableStaticMut(int_safe))\n                 } else {\n-                    Some(AliasableStatic(int_safe))\n+                    FreelyAliasable(AliasableStatic(int_safe))\n                 }\n             }\n \n             cat_deref(ref base, _, BorrowedPtr(ty::ImmBorrow, _)) |\n             cat_deref(ref base, _, Implicit(ty::ImmBorrow, _)) => {\n                 match base.cat {\n-                    cat_upvar(Upvar{ id, .. }) => Some(AliasableClosure(id.closure_expr_id)),\n-                    _ => Some(AliasableBorrowed)\n+                    cat_upvar(Upvar{ id, .. }) =>\n+                        FreelyAliasable(AliasableClosure(id.closure_expr_id)),\n+                    _ => FreelyAliasable(AliasableBorrowed)\n                 }\n             }\n         }"}, {"sha": "ce7b492c51af158de887e36a92efb09feacb8a6e", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b4457fb8a2157d7e9a983ba67e5554509017379d/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4457fb8a2157d7e9a983ba67e5554509017379d/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=b4457fb8a2157d7e9a983ba67e5554509017379d", "patch": "@@ -943,13 +943,20 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                                       cmt: mc::cmt<'tcx>)\n                                                       -> bool {\n             match cmt.freely_aliasable(this.tcx()) {\n-                None => {\n+                mc::Aliasability::NonAliasable => {\n                     return true;\n                 }\n-                Some(mc::AliasableStaticMut(..)) => {\n+                mc::Aliasability::FreelyAliasable(mc::AliasableStaticMut(..)) => {\n                     return true;\n                 }\n-                Some(cause) => {\n+                mc::Aliasability::ImmutableUnique(_) => {\n+                    this.bccx.report_aliasability_violation(\n+                        span,\n+                        MutabilityViolation,\n+                        mc::AliasableReason::UnaliasableImmutable);\n+                    return false;\n+                }\n+                mc::Aliasability::FreelyAliasable(cause) => {\n                     this.bccx.report_aliasability_violation(\n                         span,\n                         MutabilityViolation,"}, {"sha": "733d486d2d22d3ae495b10f2ddc233b423a1de4a", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b4457fb8a2157d7e9a983ba67e5554509017379d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4457fb8a2157d7e9a983ba67e5554509017379d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=b4457fb8a2157d7e9a983ba67e5554509017379d", "patch": "@@ -151,10 +151,11 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n               assignee_cmt: mc::cmt<'tcx>,\n               mode: euv::MutateMode)\n     {\n-        debug!(\"mutate(assignment_id={}, assignee_cmt={})\",\n-               assignment_id, assignee_cmt.repr(self.tcx()));\n+        let opt_lp = opt_loan_path(&assignee_cmt);\n+        debug!(\"mutate(assignment_id={}, assignee_cmt={}) opt_lp={:?}\",\n+               assignment_id, assignee_cmt.repr(self.tcx()), opt_lp);\n \n-        match opt_loan_path(&assignee_cmt) {\n+        match opt_lp {\n             Some(lp) => {\n                 gather_moves::gather_assignment(self.bccx, &self.move_data,\n                                                 assignment_id, assignment_span,\n@@ -181,12 +182,16 @@ fn check_aliasability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                 req_kind: ty::BorrowKind)\n                                 -> Result<(),()> {\n \n-    match (cmt.freely_aliasable(bccx.tcx), req_kind) {\n-        (None, _) => {\n+    let aliasability = cmt.freely_aliasable(bccx.tcx);\n+    debug!(\"check_aliasability aliasability={:?} req_kind={:?}\",\n+           aliasability, req_kind);\n+\n+    match (aliasability, req_kind) {\n+        (mc::Aliasability::NonAliasable, _) => {\n             /* Uniquely accessible path -- OK for `&` and `&mut` */\n             Ok(())\n         }\n-        (Some(mc::AliasableStatic(safety)), ty::ImmBorrow) => {\n+        (mc::Aliasability::FreelyAliasable(mc::AliasableStatic(safety)), ty::ImmBorrow) => {\n             // Borrow of an immutable static item:\n             match safety {\n                 mc::InteriorUnsafe => {\n@@ -202,13 +207,20 @@ fn check_aliasability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                 }\n             }\n         }\n-        (Some(mc::AliasableStaticMut(..)), _) => {\n+        (mc::Aliasability::FreelyAliasable(mc::AliasableStaticMut(..)), _) => {\n             // Even touching a static mut is considered unsafe. We assume the\n             // user knows what they're doing in these cases.\n             Ok(())\n         }\n-        (Some(alias_cause), ty::UniqueImmBorrow) |\n-        (Some(alias_cause), ty::MutBorrow) => {\n+        (mc::Aliasability::ImmutableUnique(_), ty::MutBorrow) => {\n+            bccx.report_aliasability_violation(\n+                        borrow_span,\n+                        BorrowViolation(loan_cause),\n+                        mc::AliasableReason::UnaliasableImmutable);\n+            Err(())\n+        }\n+        (mc::Aliasability::FreelyAliasable(alias_cause), ty::UniqueImmBorrow) |\n+        (mc::Aliasability::FreelyAliasable(alias_cause), ty::MutBorrow) => {\n             bccx.report_aliasability_violation(\n                         borrow_span,\n                         BorrowViolation(loan_cause),\n@@ -376,7 +388,8 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                                       req_kind: ty::BorrowKind)\n                                       -> Result<(),()> {\n             //! Implements the M-* rules in README.md.\n-\n+            debug!(\"check_mutability(cause={:?} cmt={} req_kind={:?}\",\n+                   cause, cmt.repr(bccx.tcx), req_kind);\n             match req_kind {\n                 ty::UniqueImmBorrow | ty::ImmBorrow => {\n                     match cmt.mutbl {"}, {"sha": "268e469b7f91580b0e5a0773baea799e5e27f19e", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b4457fb8a2157d7e9a983ba67e5554509017379d/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4457fb8a2157d7e9a983ba67e5554509017379d/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=b4457fb8a2157d7e9a983ba67e5554509017379d", "patch": "@@ -844,6 +844,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     &format!(\"{} in an aliasable location\",\n                              prefix));\n             }\n+            mc::AliasableReason::UnaliasableImmutable => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    &format!(\"{} in an immutable container\",\n+                             prefix));\n+            }\n             mc::AliasableClosure(id) => {\n                 self.tcx.sess.span_err(span,\n                                        &format!(\"{} in a captured outer \\"}, {"sha": "64033623fe2d13e86ca3349dd9d520de47346564", "filename": "src/test/compile-fail/borrowck-issue-14498.rs", "status": "modified", "additions": 61, "deletions": 1, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b4457fb8a2157d7e9a983ba67e5554509017379d/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-14498.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4457fb8a2157d7e9a983ba67e5554509017379d/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-14498.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-14498.rs?ref=b4457fb8a2157d7e9a983ba67e5554509017379d", "patch": "@@ -9,56 +9,116 @@\n // except according to those terms.\n \n // This tests that we can't modify Box<&mut T> contents while they\n-// are borrowed.\n+// are borrowed (#14498).\n+//\n+// Also includes tests of the errors reported when the Box in question\n+// is immutable (#14270).\n \n #![feature(box_syntax)]\n \n struct A { a: isize }\n struct B<'a> { a: Box<&'a mut isize> }\n \n+fn indirect_write_to_imm_box() {\n+    let mut x: isize = 1;\n+    let y: Box<_> = box &mut x;\n+    let p = &y;\n+    ***p = 2; //~ ERROR cannot assign to data in an immutable container\n+    drop(p);\n+}\n+\n fn borrow_in_var_from_var() {\n+    let mut x: isize = 1;\n+    let mut y: Box<_> = box &mut x;\n+    let p = &y;\n+    let q = &***p;\n+    **y = 2; //~ ERROR cannot assign to `**y` because it is borrowed\n+    drop(p);\n+    drop(q);\n+}\n+\n+fn borrow_in_var_from_var_via_imm_box() {\n     let mut x: isize = 1;\n     let y: Box<_> = box &mut x;\n     let p = &y;\n     let q = &***p;\n     **y = 2; //~ ERROR cannot assign to `**y` because it is borrowed\n+    //~^         ERROR cannot assign to data in an immutable container\n     drop(p);\n     drop(q);\n }\n \n fn borrow_in_var_from_field() {\n+    let mut x = A { a: 1 };\n+    let mut y: Box<_> = box &mut x.a;\n+    let p = &y;\n+    let q = &***p;\n+    **y = 2; //~ ERROR cannot assign to `**y` because it is borrowed\n+    drop(p);\n+    drop(q);\n+}\n+\n+fn borrow_in_var_from_field_via_imm_box() {\n     let mut x = A { a: 1 };\n     let y: Box<_> = box &mut x.a;\n     let p = &y;\n     let q = &***p;\n     **y = 2; //~ ERROR cannot assign to `**y` because it is borrowed\n+    //~^         ERROR cannot assign to data in an immutable container\n     drop(p);\n     drop(q);\n }\n \n fn borrow_in_field_from_var() {\n+    let mut x: isize = 1;\n+    let mut y = B { a: box &mut x };\n+    let p = &y.a;\n+    let q = &***p;\n+    **y.a = 2; //~ ERROR cannot assign to `**y.a` because it is borrowed\n+    drop(p);\n+    drop(q);\n+}\n+\n+fn borrow_in_field_from_var_via_imm_box() {\n     let mut x: isize = 1;\n     let y = B { a: box &mut x };\n     let p = &y.a;\n     let q = &***p;\n     **y.a = 2; //~ ERROR cannot assign to `**y.a` because it is borrowed\n+    //~^           ERROR cannot assign to data in an immutable container\n     drop(p);\n     drop(q);\n }\n \n fn borrow_in_field_from_field() {\n+    let mut x = A { a: 1 };\n+    let mut y = B { a: box &mut x.a };\n+    let p = &y.a;\n+    let q = &***p;\n+    **y.a = 2; //~ ERROR cannot assign to `**y.a` because it is borrowed\n+    drop(p);\n+    drop(q);\n+}\n+\n+fn borrow_in_field_from_field_via_imm_box() {\n     let mut x = A { a: 1 };\n     let y = B { a: box &mut x.a };\n     let p = &y.a;\n     let q = &***p;\n     **y.a = 2; //~ ERROR cannot assign to `**y.a` because it is borrowed\n+    //~^           ERROR cannot assign to data in an immutable container\n     drop(p);\n     drop(q);\n }\n \n fn main() {\n+    indirect_write_to_imm_box();\n     borrow_in_var_from_var();\n+    borrow_in_var_from_var_via_imm_box();\n     borrow_in_var_from_field();\n+    borrow_in_var_from_field_via_imm_box();\n     borrow_in_field_from_var();\n+    borrow_in_field_from_var_via_imm_box();\n     borrow_in_field_from_field();\n+    borrow_in_field_from_field_via_imm_box();\n }"}]}