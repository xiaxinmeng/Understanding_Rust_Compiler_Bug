{"sha": "7840a0b753a065a41999f1fb6028f67d33e3fdd5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4NDBhMGI3NTNhMDY1YTQxOTk5ZjFmYjYwMjhmNjdkMzNlM2ZkZDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-31T17:10:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-31T17:10:11Z"}, "message": "Auto merge of #57967 - eddyb:rmangle, r=michaelwoerister\n\nIntroduce Rust symbol mangling scheme.\n\nThis is an implementation of a \"feature-complete\" Rust mangling scheme, in the vein of rust-lang/rfcs#2603 ~~- but with some differences, see https://github.com/rust-lang/rfcs/pull/2603#issuecomment-458410463 for details~~ (@michaelwoerister integrated my proposed changes into the RFC itself).\n\nOn nightly, you can now control the mangling scheme with `-Z symbol-mangling-version`, which can be:\n* `legacy`: the older mangling version, still the default currently\n* `v0`: the new RFC mangling version, as implemented by this PR\n\nTo test the new mangling, set `RUSTFLAGS=-Zsymbol-mangling-version=v0` (or change [`rustflags` in `.cargo/config.toml`](https://doc.rust-lang.org/cargo/reference/config.html#configuration-keys)). Please note that only symbols from crates built with that flag will use the new mangling, and that tool support (e.g. debuggers) will be limited initially, and it may take a while for everything to be upstreamed. However, `RUST_BACKTRACE` should work out of the box with either mangling version.\n\n<hr/>\n\nThe demangling implementation PR is https://github.com/alexcrichton/rustc-demangle/pull/23\n~~(this PR already uses it via a git dependency, to allow testing)~~.\n\nDiscussion of the *design* of the mangling scheme should still happen on the RFC, but this PR's specific implementation details can be reviewed in parallel.\n\n*Notes for reviewers*:\n* ~~only the last 6 commits are specific to this branch, if necessary I can open a separate PR for everything else (it was meant to be its own small refactoring, but it got a bit out of hand)~~\n~~based on #58140~~\n* the \"harness\" commit is only there because it does some extra validation (comparing the demangling from `rustc-demangle` to the compiler's pretty-printing, adjusted slightly to produce the same output), that I would like to try on crater\n* ~~there is the question of whether we should turn on the new mangling now, wait for tools to support it (I'm working on that), and/or have it under a `-Z` flag for now~~ (we're gating this on `-Z symbol-mangling-version=v0`, see above)\n\nr? @nikomatsakis / @michaelwoerister cc @rust-lang/compiler", "tree": {"sha": "9cbd890e3a5d1ec24a358581e8f4e0d449dde7f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9cbd890e3a5d1ec24a358581e8f4e0d449dde7f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7840a0b753a065a41999f1fb6028f67d33e3fdd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7840a0b753a065a41999f1fb6028f67d33e3fdd5", "html_url": "https://github.com/rust-lang/rust/commit/7840a0b753a065a41999f1fb6028f67d33e3fdd5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7840a0b753a065a41999f1fb6028f67d33e3fdd5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75f464481ed8c924086fc0b9a2d31841bbdbcabd", "url": "https://api.github.com/repos/rust-lang/rust/commits/75f464481ed8c924086fc0b9a2d31841bbdbcabd", "html_url": "https://github.com/rust-lang/rust/commit/75f464481ed8c924086fc0b9a2d31841bbdbcabd"}, {"sha": "3652ea4594918d5f4c7e7a073d3e3105c726d1ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/3652ea4594918d5f4c7e7a073d3e3105c726d1ef", "html_url": "https://github.com/rust-lang/rust/commit/3652ea4594918d5f4c7e7a073d3e3105c726d1ef"}], "stats": {"total": 2254, "additions": 1672, "deletions": 582}, "files": [{"sha": "a13bc0e74760ad30eb4a111677b77c8a525e05fd", "filename": "Cargo.lock", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7840a0b753a065a41999f1fb6028f67d33e3fdd5/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7840a0b753a065a41999f1fb6028f67d33e3fdd5/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7840a0b753a065a41999f1fb6028f67d33e3fdd5", "patch": "@@ -120,7 +120,7 @@ dependencies = [\n  \"cfg-if 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"compiler_builtins 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-demangle 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-demangle 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-std-workspace-core 1.0.0\",\n ]\n \n@@ -2023,6 +2023,11 @@ dependencies = [\n  \"unicase 2.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"punycode\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"quick-error\"\n version = \"1.2.2\"\n@@ -2492,7 +2497,7 @@ dependencies = [\n \n [[package]]\n name = \"rustc-demangle\"\n-version = \"0.1.10\"\n+version = \"0.1.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"compiler_builtins 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2648,7 +2653,7 @@ dependencies = [\n  \"cc 1.0.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"memmap 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-demangle 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-demangle 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_llvm 0.0.0\",\n ]\n \n@@ -2665,7 +2670,7 @@ dependencies = [\n  \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n- \"rustc-demangle 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-demangle 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_allocator 0.0.0\",\n  \"rustc_apfloat 0.0.0\",\n  \"rustc_codegen_utils 0.0.0\",\n@@ -2687,7 +2692,9 @@ version = \"0.0.0\"\n dependencies = [\n  \"flate2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"punycode 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n+ \"rustc-demangle 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_metadata 0.0.0\",\n  \"rustc_mir 0.0.0\",\n@@ -4276,6 +4283,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum proptest 0.9.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"24f5844db2f839e97e3021980975f6ebf8691d9b9b2ca67ed3feb38dc3edb52c\"\n \"checksum pulldown-cmark 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d6fdf85cda6cadfae5428a54661d431330b312bc767ddbc57adbedc24da66e32\"\n \"checksum pulldown-cmark 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"051e60ace841b3bfecd402fe5051c06cb3bec4a6e6fdd060a37aa8eb829a1db3\"\n+\"checksum punycode 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6ddd112cca70a4d30883b2d21568a1d376ff8be4758649f64f973c6845128ad3\"\n \"checksum quick-error 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9274b940887ce9addde99c4eee6b5c44cc494b182b97e73dc8ffdcb3397fd3f0\"\n \"checksum quine-mc_cluskey 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"07589615d719a60c8dd8a4622e7946465dfef20d1a428f969e3443e7386d5f45\"\n \"checksum quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7a6e920b65c65f10b2ae65c831a81a073a89edd28c7cce89475bff467ab4167a\"\n@@ -4313,7 +4321,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum rustc-ap-serialize 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cf09c60aaee892b0fd107544cfe607d8d463e7f33da34aa823566b8fd2b17f53\"\n \"checksum rustc-ap-syntax 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"69f38cc120ff317678bbda8c4f58c1bbc1de64b615383ab01480482dde5e95a1\"\n \"checksum rustc-ap-syntax_pos 407.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"20a0a201141c5c416b1924b079eeefc7b013e34ece0740ce4997f358b3684a7f\"\n-\"checksum rustc-demangle 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"82ae957aa1b3055d8e086486723c0ccd3d7b8fa190ae8fa2e35543b6171c810e\"\n+\"checksum rustc-demangle 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a7f4dccf6f4891ebcc0c39f9b6eb1a83b9bf5d747cb439ec6fba4f3b977038af\"\n \"checksum rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7540fc8b0c49f096ee9c961cda096467dce8084bec6bdca2fc83895fd9b28cb8\"\n \"checksum rustc-rayon 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8d98c51d9cbbe810c8b6693236d3412d8cd60513ff27a3e1b6af483dca0af544\"\n \"checksum rustc-rayon 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0d2e07e19601f21c59aad953c2632172ba70cb27e685771514ea66e4062b3363\""}, {"sha": "f61677fa594993d3061a90068de6ca4dad70cec1", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=7840a0b753a065a41999f1fb6028f67d33e3fdd5", "patch": "@@ -624,6 +624,10 @@ rustc_queries! {\n             fatal_cycle\n             desc { \"test whether a crate has #![no_builtins]\" }\n         }\n+        query symbol_mangling_version(_: CrateNum) -> SymbolManglingVersion {\n+            fatal_cycle\n+            desc { \"query a crate's symbol mangling version\" }\n+        }\n \n         query extern_crate(_: DefId) -> Option<&'tcx ExternCrate> {\n             eval_always"}, {"sha": "d8efa17defe3d06e6bed593c225a2f65a89548ff", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=7840a0b753a065a41999f1fb6028f67d33e3fdd5", "patch": "@@ -131,6 +131,14 @@ impl SwitchWithOptPath {\n     }\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+pub enum SymbolManglingVersion {\n+    Legacy,\n+    V0,\n+}\n+\n+impl_stable_hash_via_hash!(SymbolManglingVersion);\n+\n #[derive(Clone, Copy, PartialEq, Hash)]\n pub enum DebugInfo {\n     None,\n@@ -838,11 +846,14 @@ macro_rules! options {\n             Some(\"an optional path to the profiling data output directory\");\n         pub const parse_merge_functions: Option<&str> =\n             Some(\"one of: `disabled`, `trampolines`, or `aliases`\");\n+        pub const parse_symbol_mangling_version: Option<&str> =\n+            Some(\"either `legacy` or `v0` (RFC 2603)\");\n     }\n \n     #[allow(dead_code)]\n     mod $mod_set {\n-        use super::{$struct_name, Passes, Sanitizer, LtoCli, LinkerPluginLto, SwitchWithOptPath};\n+        use super::{$struct_name, Passes, Sanitizer, LtoCli, LinkerPluginLto, SwitchWithOptPath,\n+            SymbolManglingVersion};\n         use rustc_target::spec::{LinkerFlavor, MergeFunctions, PanicStrategy, RelroLevel};\n         use std::path::PathBuf;\n         use std::str::FromStr;\n@@ -1112,6 +1123,18 @@ macro_rules! options {\n             }\n             true\n         }\n+\n+        fn parse_symbol_mangling_version(\n+            slot: &mut SymbolManglingVersion,\n+            v: Option<&str>,\n+        ) -> bool {\n+            *slot = match v {\n+                Some(\"legacy\") => SymbolManglingVersion::Legacy,\n+                Some(\"v0\") => SymbolManglingVersion::V0,\n+                _ => return false,\n+            };\n+            true\n+        }\n     }\n ) }\n \n@@ -1457,6 +1480,9 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"only allow the listed language features to be enabled in code (space separated)\"),\n     emit_artifact_notifications: bool = (false, parse_bool, [UNTRACKED],\n         \"emit notifications after each artifact has been output (only in the JSON format)\"),\n+    symbol_mangling_version: SymbolManglingVersion = (SymbolManglingVersion::Legacy,\n+        parse_symbol_mangling_version, [TRACKED],\n+        \"which mangling version to use for symbol names\"),\n }\n \n pub fn default_lib_output() -> CrateType {\n@@ -2551,7 +2577,8 @@ mod dep_tracking {\n     use std::path::PathBuf;\n     use std::collections::hash_map::DefaultHasher;\n     use super::{CrateType, DebugInfo, ErrorOutputType, OptLevel, OutputTypes,\n-                Passes, Sanitizer, LtoCli, LinkerPluginLto, SwitchWithOptPath};\n+                Passes, Sanitizer, LtoCli, LinkerPluginLto, SwitchWithOptPath,\n+                SymbolManglingVersion};\n     use syntax::feature_gate::UnstableFeatures;\n     use rustc_target::spec::{MergeFunctions, PanicStrategy, RelroLevel, TargetTriple};\n     use syntax::edition::Edition;\n@@ -2620,6 +2647,7 @@ mod dep_tracking {\n     impl_dep_tracking_hash_via_hash!(Edition);\n     impl_dep_tracking_hash_via_hash!(LinkerPluginLto);\n     impl_dep_tracking_hash_via_hash!(SwitchWithOptPath);\n+    impl_dep_tracking_hash_via_hash!(SymbolManglingVersion);\n \n     impl_dep_tracking_hash_for_sortable_vec_of!(String);\n     impl_dep_tracking_hash_for_sortable_vec_of!(PathBuf);\n@@ -2693,7 +2721,7 @@ mod tests {\n     use std::collections::{BTreeMap, BTreeSet};\n     use std::iter::FromIterator;\n     use std::path::PathBuf;\n-    use super::{Externs, OutputType, OutputTypes};\n+    use super::{Externs, OutputType, OutputTypes, SymbolManglingVersion};\n     use rustc_target::spec::{MergeFunctions, PanicStrategy, RelroLevel};\n     use syntax::symbol::sym;\n     use syntax::edition::{Edition, DEFAULT_EDITION};\n@@ -3367,6 +3395,10 @@ mod tests {\n         opts = reference.clone();\n         opts.debugging_opts.allow_features = Some(vec![String::from(\"lang_items\")]);\n         assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.debugging_opts.symbol_mangling_version = SymbolManglingVersion::V0;\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n     }\n \n     #[test]"}, {"sha": "a2bced97102a68393b8307a61f344bc1aadf42c3", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=7840a0b753a065a41999f1fb6028f67d33e3fdd5", "patch": "@@ -20,7 +20,7 @@ use crate::mir::mono::CodegenUnit;\n use crate::mir;\n use crate::mir::interpret::GlobalId;\n use crate::session::CrateDisambiguator;\n-use crate::session::config::{EntryFnType, OutputFilenames, OptLevel};\n+use crate::session::config::{EntryFnType, OutputFilenames, OptLevel, SymbolManglingVersion};\n use crate::traits::{self, Vtable};\n use crate::traits::query::{\n     CanonicalPredicateGoal, CanonicalProjectionGoal,"}, {"sha": "4ae8303c76d3ca8af57212305a144db5d05669d6", "filename": "src/librustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Flibrustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Flibrustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2FCargo.toml?ref=7840a0b753a065a41999f1fb6028f67d33e3fdd5", "patch": "@@ -13,7 +13,7 @@ test = false\n [dependencies]\n cc = \"1.0.1\" # Used to locate MSVC\n num_cpus = \"1.0\"\n-rustc-demangle = \"0.1.4\"\n+rustc-demangle = \"0.1.15\"\n rustc_llvm = { path = \"../librustc_llvm\" }\n memmap = \"0.6\"\n "}, {"sha": "0b34ec8e8bc1cb857e12637510d717ac4cf3e3ce", "filename": "src/librustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Flibrustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Flibrustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2FCargo.toml?ref=7840a0b753a065a41999f1fb6028f67d33e3fdd5", "patch": "@@ -14,7 +14,7 @@ test = false\n bitflags = \"1.0.4\"\n cc = \"1.0.1\"\n num_cpus = \"1.0\"\n-rustc-demangle = \"0.1.4\"\n+rustc-demangle = \"0.1.15\"\n memmap = \"0.6\"\n log = \"0.4.5\"\n libc = \"0.2.44\""}, {"sha": "268be2b109114d764fee9e60bb1b107ca8eb073e", "filename": "src/librustc_codegen_utils/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Flibrustc_codegen_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Flibrustc_codegen_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2FCargo.toml?ref=7840a0b753a065a41999f1fb6028f67d33e3fdd5", "patch": "@@ -13,6 +13,8 @@ test = false\n [dependencies]\n flate2 = \"1.0\"\n log = \"0.4\"\n+punycode = \"0.4.0\"\n+rustc-demangle = \"0.1.15\"\n \n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "ea1d08354528b3dc1f9bef55a053bb2c3c884cc9", "filename": "src/librustc_codegen_utils/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Flibrustc_codegen_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Flibrustc_codegen_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flib.rs?ref=7840a0b753a065a41999f1fb6028f67d33e3fdd5", "patch": "@@ -7,7 +7,9 @@\n #![feature(arbitrary_self_types)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![feature(core_intrinsics)]\n #![feature(custom_attribute)]\n+#![feature(never_type)]\n #![feature(nll)]\n #![allow(unused_attributes)]\n #![feature(rustc_diagnostic_macros)]"}, {"sha": "37847b1b0988f681dd16d77388deb0899500daef", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 60, "deletions": 486, "changes": 546, "blob_url": "https://github.com/rust-lang/rust/blob/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=7840a0b753a065a41999f1fb6028f67d33e3fdd5", "patch": "@@ -87,148 +87,33 @@\n //! virtually impossible. Thus, symbol hash generation exclusively relies on\n //! DefPaths which are much more robust in the face of changes to the code base.\n \n-use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::hir::Node;\n use rustc::hir::CodegenFnAttrFlags;\n-use rustc::hir::map::{DefPathData, DisambiguatedDefPathData};\n-use rustc::ich::NodeIdHashingMode;\n-use rustc::ty::print::{PrettyPrinter, Printer, Print};\n+use rustc::session::config::SymbolManglingVersion;\n use rustc::ty::query::Providers;\n-use rustc::ty::subst::{Kind, SubstsRef, UnpackedKind};\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc::mir::interpret::{ConstValue, Scalar};\n-use rustc::util::common::record_time;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc::ty::{self, TyCtxt};\n use rustc_mir::monomorphize::item::{InstantiationMode, MonoItem, MonoItemExt};\n use rustc_mir::monomorphize::Instance;\n \n use syntax_pos::symbol::InternedString;\n \n use log::debug;\n \n-use std::fmt::{self, Write};\n-use std::mem::{self, discriminant};\n+mod legacy;\n+mod v0;\n \n pub fn provide(providers: &mut Providers<'_>) {\n     *providers = Providers {\n-        symbol_name,\n+        symbol_name: |tcx, instance| ty::SymbolName {\n+            name: symbol_name(tcx, instance),\n+        },\n \n         ..*providers\n     };\n }\n \n-fn get_symbol_hash<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-\n-    // the DefId of the item this name is for\n-    def_id: DefId,\n-\n-    // instance this name will be for\n-    instance: Instance<'tcx>,\n-\n-    // type of the item, without any generic\n-    // parameters substituted; this is\n-    // included in the hash as a kind of\n-    // safeguard.\n-    item_type: Ty<'tcx>,\n-\n-    // values for generic type parameters,\n-    // if any.\n-    substs: SubstsRef<'tcx>,\n-) -> u64 {\n-    debug!(\n-        \"get_symbol_hash(def_id={:?}, parameters={:?})\",\n-        def_id, substs\n-    );\n-\n-    let mut hasher = StableHasher::<u64>::new();\n-    let mut hcx = tcx.create_stable_hashing_context();\n-\n-    record_time(&tcx.sess.perf_stats.symbol_hash_time, || {\n-        // the main symbol name is not necessarily unique; hash in the\n-        // compiler's internal def-path, guaranteeing each symbol has a\n-        // truly unique path\n-        tcx.def_path_hash(def_id).hash_stable(&mut hcx, &mut hasher);\n-\n-        // Include the main item-type. Note that, in this case, the\n-        // assertions about `needs_subst` may not hold, but this item-type\n-        // ought to be the same for every reference anyway.\n-        assert!(!item_type.has_erasable_regions());\n-        hcx.while_hashing_spans(false, |hcx| {\n-            hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-                item_type.hash_stable(hcx, &mut hasher);\n-            });\n-        });\n-\n-        // If this is a function, we hash the signature as well.\n-        // This is not *strictly* needed, but it may help in some\n-        // situations, see the `run-make/a-b-a-linker-guard` test.\n-        if let ty::FnDef(..) = item_type.sty {\n-            item_type.fn_sig(tcx).hash_stable(&mut hcx, &mut hasher);\n-        }\n-\n-        // also include any type parameters (for generic items)\n-        assert!(!substs.has_erasable_regions());\n-        assert!(!substs.needs_subst());\n-        substs.hash_stable(&mut hcx, &mut hasher);\n-\n-        let is_generic = substs.non_erasable_generics().next().is_some();\n-        let avoid_cross_crate_conflicts =\n-            // If this is an instance of a generic function, we also hash in\n-            // the ID of the instantiating crate. This avoids symbol conflicts\n-            // in case the same instances is emitted in two crates of the same\n-            // project.\n-            is_generic ||\n-\n-            // If we're dealing with an instance of a function that's inlined from\n-            // another crate but we're marking it as globally shared to our\n-            // compliation (aka we're not making an internal copy in each of our\n-            // codegen units) then this symbol may become an exported (but hidden\n-            // visibility) symbol. This means that multiple crates may do the same\n-            // and we want to be sure to avoid any symbol conflicts here.\n-            match MonoItem::Fn(instance).instantiation_mode(tcx) {\n-                InstantiationMode::GloballyShared { may_conflict: true } => true,\n-                _ => false,\n-            };\n-\n-        if avoid_cross_crate_conflicts {\n-            let instantiating_crate = if is_generic {\n-                if !def_id.is_local() && tcx.sess.opts.share_generics() {\n-                    // If we are re-using a monomorphization from another crate,\n-                    // we have to compute the symbol hash accordingly.\n-                    let upstream_monomorphizations = tcx.upstream_monomorphizations_for(def_id);\n-\n-                    upstream_monomorphizations\n-                        .and_then(|monos| monos.get(&substs).cloned())\n-                        .unwrap_or(LOCAL_CRATE)\n-                } else {\n-                    LOCAL_CRATE\n-                }\n-            } else {\n-                LOCAL_CRATE\n-            };\n-\n-            (&tcx.original_crate_name(instantiating_crate).as_str()[..])\n-                .hash_stable(&mut hcx, &mut hasher);\n-            (&tcx.crate_disambiguator(instantiating_crate)).hash_stable(&mut hcx, &mut hasher);\n-        }\n-\n-        // We want to avoid accidental collision between different types of instances.\n-        // Especially, VtableShim may overlap with its original instance without this.\n-        discriminant(&instance.def).hash_stable(&mut hcx, &mut hasher);\n-    });\n-\n-    // 64 bits should be enough to avoid collisions.\n-    hasher.finish()\n-}\n-\n-fn symbol_name(tcx: TyCtxt<'_, 'tcx, 'tcx>, instance: Instance<'tcx>) -> ty::SymbolName {\n-    ty::SymbolName {\n-        name: compute_symbol_name(tcx, instance),\n-    }\n-}\n-\n-fn compute_symbol_name(tcx: TyCtxt<'_, 'tcx, 'tcx>, instance: Instance<'tcx>) -> InternedString {\n+fn symbol_name(tcx: TyCtxt<'_, 'tcx, 'tcx>, instance: Instance<'tcx>) -> InternedString {\n     let def_id = instance.def_id();\n     let substs = instance.substs;\n \n@@ -278,376 +163,65 @@ fn compute_symbol_name(tcx: TyCtxt<'_, 'tcx, 'tcx>, instance: Instance<'tcx>) ->\n         return tcx.item_name(def_id).as_interned_str();\n     }\n \n-    // We want to compute the \"type\" of this item. Unfortunately, some\n-    // kinds of items (e.g., closures) don't have an entry in the\n-    // item-type array. So walk back up the find the closest parent\n-    // that DOES have an entry.\n-    let mut ty_def_id = def_id;\n-    let instance_ty;\n-    loop {\n-        let key = tcx.def_key(ty_def_id);\n-        match key.disambiguated_data.data {\n-            DefPathData::TypeNs(_) | DefPathData::ValueNs(_) => {\n-                instance_ty = tcx.type_of(ty_def_id);\n-                break;\n-            }\n-            _ => {\n-                // if we're making a symbol for something, there ought\n-                // to be a value or type-def or something in there\n-                // *somewhere*\n-                ty_def_id.index = key.parent.unwrap_or_else(|| {\n-                    bug!(\n-                        \"finding type for {:?}, encountered def-id {:?} with no \\\n-                         parent\",\n-                        def_id,\n-                        ty_def_id\n-                    );\n-                });\n-            }\n-        }\n-    }\n \n-    // Erase regions because they may not be deterministic when hashed\n-    // and should not matter anyhow.\n-    let instance_ty = tcx.erase_regions(&instance_ty);\n+    let is_generic = substs.non_erasable_generics().next().is_some();\n+    let avoid_cross_crate_conflicts =\n+        // If this is an instance of a generic function, we also hash in\n+        // the ID of the instantiating crate. This avoids symbol conflicts\n+        // in case the same instances is emitted in two crates of the same\n+        // project.\n+        is_generic ||\n \n-    let hash = get_symbol_hash(tcx, def_id, instance, instance_ty, substs);\n-\n-    let mut printer = SymbolPrinter {\n-        tcx,\n-        path: SymbolPath::new(),\n-        keep_within_component: false,\n-    }.print_def_path(def_id, &[]).unwrap();\n-\n-    if instance.is_vtable_shim() {\n-        let _ = printer.write_str(\"{{vtable-shim}}\");\n-    }\n-\n-    InternedString::intern(&printer.path.finish(hash))\n-}\n-\n-// Follow C++ namespace-mangling style, see\n-// http://en.wikipedia.org/wiki/Name_mangling for more info.\n-//\n-// It turns out that on macOS you can actually have arbitrary symbols in\n-// function names (at least when given to LLVM), but this is not possible\n-// when using unix's linker. Perhaps one day when we just use a linker from LLVM\n-// we won't need to do this name mangling. The problem with name mangling is\n-// that it seriously limits the available characters. For example we can't\n-// have things like &T in symbol names when one would theoretically\n-// want them for things like impls of traits on that type.\n-//\n-// To be able to work on all platforms and get *some* reasonable output, we\n-// use C++ name-mangling.\n-#[derive(Debug)]\n-struct SymbolPath {\n-    result: String,\n-    temp_buf: String,\n-}\n-\n-impl SymbolPath {\n-    fn new() -> Self {\n-        let mut result = SymbolPath {\n-            result: String::with_capacity(64),\n-            temp_buf: String::with_capacity(16),\n+        // If we're dealing with an instance of a function that's inlined from\n+        // another crate but we're marking it as globally shared to our\n+        // compliation (aka we're not making an internal copy in each of our\n+        // codegen units) then this symbol may become an exported (but hidden\n+        // visibility) symbol. This means that multiple crates may do the same\n+        // and we want to be sure to avoid any symbol conflicts here.\n+        match MonoItem::Fn(instance).instantiation_mode(tcx) {\n+            InstantiationMode::GloballyShared { may_conflict: true } => true,\n+            _ => false,\n         };\n-        result.result.push_str(\"_ZN\"); // _Z == Begin name-sequence, N == nested\n-        result\n-    }\n-\n-    fn finalize_pending_component(&mut self) {\n-        if !self.temp_buf.is_empty() {\n-            let _ = write!(self.result, \"{}{}\", self.temp_buf.len(), self.temp_buf);\n-            self.temp_buf.clear();\n-        }\n-    }\n-\n-    fn finish(mut self, hash: u64) -> String {\n-        self.finalize_pending_component();\n-        // E = end name-sequence\n-        let _ = write!(self.result, \"17h{:016x}E\", hash);\n-        self.result\n-    }\n-}\n-\n-struct SymbolPrinter<'a, 'tcx> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    path: SymbolPath,\n-\n-    // When `true`, `finalize_pending_component` isn't used.\n-    // This is needed when recursing into `path_qualified`,\n-    // or `path_generic_args`, as any nested paths are\n-    // logically within one component.\n-    keep_within_component: bool,\n-}\n-\n-// HACK(eddyb) this relies on using the `fmt` interface to get\n-// `PrettyPrinter` aka pretty printing of e.g. types in paths,\n-// symbol names should have their own printing machinery.\n-\n-impl Printer<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n-    type Error = fmt::Error;\n-\n-    type Path = Self;\n-    type Region = Self;\n-    type Type = Self;\n-    type DynExistential = Self;\n-    type Const = Self;\n-\n-    fn tcx(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n-        self.tcx\n-    }\n-\n-    fn print_region(\n-        self,\n-        _region: ty::Region<'_>,\n-    ) -> Result<Self::Region, Self::Error> {\n-        Ok(self)\n-    }\n-\n-    fn print_type(\n-        self,\n-        ty: Ty<'tcx>,\n-    ) -> Result<Self::Type, Self::Error> {\n-        match ty.sty {\n-            // Print all nominal types as paths (unlike `pretty_print_type`).\n-            ty::FnDef(def_id, substs) |\n-            ty::Opaque(def_id, substs) |\n-            ty::Projection(ty::ProjectionTy { item_def_id: def_id, substs }) |\n-            ty::UnnormalizedProjection(ty::ProjectionTy { item_def_id: def_id, substs }) |\n-            ty::Closure(def_id, ty::ClosureSubsts { substs }) |\n-            ty::Generator(def_id, ty::GeneratorSubsts { substs }, _) => {\n-                self.print_def_path(def_id, substs)\n-            }\n-            _ => self.pretty_print_type(ty),\n-        }\n-    }\n-\n-    fn print_dyn_existential(\n-        mut self,\n-        predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n-    ) -> Result<Self::DynExistential, Self::Error> {\n-        let mut first = true;\n-        for p in predicates {\n-            if !first {\n-                write!(self, \"+\")?;\n-            }\n-            first = false;\n-            self = p.print(self)?;\n-        }\n-        Ok(self)\n-    }\n \n-    fn print_const(\n-        mut self,\n-        ct: &'tcx ty::Const<'tcx>,\n-    ) -> Result<Self::Const, Self::Error> {\n-        // only print integers\n-        if let ConstValue::Scalar(Scalar::Raw { .. }) = ct.val {\n-            if ct.ty.is_integral() {\n-                return self.pretty_print_const(ct);\n-            }\n-        }\n-        self.write_str(\"_\")?;\n-        Ok(self)\n-    }\n-\n-    fn path_crate(\n-        mut self,\n-        cnum: CrateNum,\n-    ) -> Result<Self::Path, Self::Error> {\n-        self.write_str(&self.tcx.original_crate_name(cnum).as_str())?;\n-        Ok(self)\n-    }\n-    fn path_qualified(\n-        self,\n-        self_ty: Ty<'tcx>,\n-        trait_ref: Option<ty::TraitRef<'tcx>>,\n-    ) -> Result<Self::Path, Self::Error> {\n-        // Similar to `pretty_path_qualified`, but for the other\n-        // types that are printed as paths (see `print_type` above).\n-        match self_ty.sty {\n-            ty::FnDef(..) |\n-            ty::Opaque(..) |\n-            ty::Projection(_) |\n-            ty::UnnormalizedProjection(_) |\n-            ty::Closure(..) |\n-            ty::Generator(..)\n-                if trait_ref.is_none() =>\n-            {\n-                self.print_type(self_ty)\n-            }\n-\n-            _ => self.pretty_path_qualified(self_ty, trait_ref)\n-        }\n-    }\n+    let instantiating_crate = if avoid_cross_crate_conflicts {\n+        Some(if is_generic {\n+            if !def_id.is_local() && tcx.sess.opts.share_generics() {\n+                // If we are re-using a monomorphization from another crate,\n+                // we have to compute the symbol hash accordingly.\n+                let upstream_monomorphizations = tcx.upstream_monomorphizations_for(def_id);\n \n-    fn path_append_impl(\n-        self,\n-        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n-        _disambiguated_data: &DisambiguatedDefPathData,\n-        self_ty: Ty<'tcx>,\n-        trait_ref: Option<ty::TraitRef<'tcx>>,\n-    ) -> Result<Self::Path, Self::Error> {\n-        self.pretty_path_append_impl(\n-            |mut cx| {\n-                cx = print_prefix(cx)?;\n-\n-                if cx.keep_within_component {\n-                    // HACK(eddyb) print the path similarly to how `FmtPrinter` prints it.\n-                    cx.write_str(\"::\")?;\n-                } else {\n-                    cx.path.finalize_pending_component();\n-                }\n-\n-                Ok(cx)\n-            },\n-            self_ty,\n-            trait_ref,\n-        )\n-    }\n-    fn path_append(\n-        mut self,\n-        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n-        disambiguated_data: &DisambiguatedDefPathData,\n-    ) -> Result<Self::Path, Self::Error> {\n-        self = print_prefix(self)?;\n-\n-        // Skip `::{{constructor}}` on tuple/unit structs.\n-        match disambiguated_data.data {\n-            DefPathData::Ctor => return Ok(self),\n-            _ => {}\n-        }\n-\n-        if self.keep_within_component {\n-            // HACK(eddyb) print the path similarly to how `FmtPrinter` prints it.\n-            self.write_str(\"::\")?;\n-        } else {\n-            self.path.finalize_pending_component();\n-        }\n-\n-        self.write_str(&disambiguated_data.data.as_interned_str().as_str())?;\n-        Ok(self)\n-    }\n-    fn path_generic_args(\n-        mut self,\n-        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n-        args: &[Kind<'tcx>],\n-    )  -> Result<Self::Path, Self::Error> {\n-        self = print_prefix(self)?;\n-\n-        let args = args.iter().cloned().filter(|arg| {\n-            match arg.unpack() {\n-                UnpackedKind::Lifetime(_) => false,\n-                _ => true,\n+                upstream_monomorphizations\n+                    .and_then(|monos| monos.get(&substs).cloned())\n+                    .unwrap_or(LOCAL_CRATE)\n+            } else {\n+                LOCAL_CRATE\n             }\n-        });\n-\n-        if args.clone().next().is_some() {\n-            self.generic_delimiters(|cx| cx.comma_sep(args))\n         } else {\n-            Ok(self)\n-        }\n-    }\n-}\n-\n-impl PrettyPrinter<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n-    fn region_should_not_be_omitted(\n-        &self,\n-        _region: ty::Region<'_>,\n-    ) -> bool {\n-        false\n-    }\n-    fn comma_sep<T>(\n-        mut self,\n-        mut elems: impl Iterator<Item = T>,\n-    ) -> Result<Self, Self::Error>\n-        where T: Print<'tcx, 'tcx, Self, Output = Self, Error = Self::Error>\n-    {\n-        if let Some(first) = elems.next() {\n-            self = first.print(self)?;\n-            for elem in elems {\n-                self.write_str(\",\")?;\n-                self = elem.print(self)?;\n-            }\n-        }\n-        Ok(self)\n-    }\n-\n-    fn generic_delimiters(\n-        mut self,\n-        f: impl FnOnce(Self) -> Result<Self, Self::Error>,\n-    ) -> Result<Self, Self::Error> {\n-        write!(self, \"<\")?;\n-\n-        let kept_within_component =\n-            mem::replace(&mut self.keep_within_component, true);\n-        self = f(self)?;\n-        self.keep_within_component = kept_within_component;\n-\n-        write!(self, \">\")?;\n-\n-        Ok(self)\n-    }\n-}\n-\n-impl fmt::Write for SymbolPrinter<'_, '_> {\n-    fn write_str(&mut self, s: &str) -> fmt::Result {\n-        // Name sanitation. LLVM will happily accept identifiers with weird names, but\n-        // gas doesn't!\n-        // gas accepts the following characters in symbols: a-z, A-Z, 0-9, ., _, $\n-        // NVPTX assembly has more strict naming rules than gas, so additionally, dots\n-        // are replaced with '$' there.\n-\n-        for c in s.chars() {\n-            if self.path.temp_buf.is_empty() {\n-                match c {\n-                    'a'..='z' | 'A'..='Z' | '_' => {}\n-                    _ => {\n-                        // Underscore-qualify anything that didn't start as an ident.\n-                        self.path.temp_buf.push('_');\n-                    }\n-                }\n-            }\n-            match c {\n-                // Escape these with $ sequences\n-                '@' => self.path.temp_buf.push_str(\"$SP$\"),\n-                '*' => self.path.temp_buf.push_str(\"$BP$\"),\n-                '&' => self.path.temp_buf.push_str(\"$RF$\"),\n-                '<' => self.path.temp_buf.push_str(\"$LT$\"),\n-                '>' => self.path.temp_buf.push_str(\"$GT$\"),\n-                '(' => self.path.temp_buf.push_str(\"$LP$\"),\n-                ')' => self.path.temp_buf.push_str(\"$RP$\"),\n-                ',' => self.path.temp_buf.push_str(\"$C$\"),\n-\n-                '-' | ':' | '.' if self.tcx.has_strict_asm_symbol_naming() => {\n-                    // NVPTX doesn't support these characters in symbol names.\n-                    self.path.temp_buf.push('$')\n-                }\n-\n-                // '.' doesn't occur in types and functions, so reuse it\n-                // for ':' and '-'\n-                '-' | ':' => self.path.temp_buf.push('.'),\n-\n-                // Avoid segmentation fault on some platforms, see #60925.\n-                'm' if self.path.temp_buf.ends_with(\".llv\") => self.path.temp_buf.push_str(\"$6d$\"),\n+            LOCAL_CRATE\n+        })\n+    } else {\n+        None\n+    };\n \n-                // These are legal symbols\n-                'a'..='z' | 'A'..='Z' | '0'..='9' | '_' | '.' | '$' => self.path.temp_buf.push(c),\n+    // Pick the crate responsible for the symbol mangling version, which has to:\n+    // 1. be stable for each instance, whether it's being defined or imported\n+    // 2. obey each crate's own `-Z symbol-mangling-version`, as much as possible\n+    // We solve these as follows:\n+    // 1. because symbol names depend on both `def_id` and `instantiating_crate`,\n+    // both their `CrateNum`s are stable for any given instance, so we can pick\n+    // either and have a stable choice of symbol mangling version\n+    // 2. we favor `instantiating_crate` where possible (i.e. when `Some`)\n+    let mangling_version_crate = instantiating_crate.unwrap_or(def_id.krate);\n+    let mangling_version = if mangling_version_crate == LOCAL_CRATE {\n+        tcx.sess.opts.debugging_opts.symbol_mangling_version\n+    } else {\n+        tcx.symbol_mangling_version(mangling_version_crate)\n+    };\n \n-                _ => {\n-                    self.path.temp_buf.push('$');\n-                    for c in c.escape_unicode().skip(1) {\n-                        match c {\n-                            '{' => {}\n-                            '}' => self.path.temp_buf.push('$'),\n-                            c => self.path.temp_buf.push(c),\n-                        }\n-                    }\n-                }\n-            }\n-        }\n+    let mangled = match mangling_version {\n+        SymbolManglingVersion::Legacy => legacy::mangle(tcx, instance, instantiating_crate),\n+        SymbolManglingVersion::V0 => v0::mangle(tcx, instance, instantiating_crate),\n+    };\n \n-        Ok(())\n-    }\n+    InternedString::intern(&mangled)\n }"}, {"sha": "53682b9bdc2c8ef47605270d39bfb8b1f754de00", "filename": "src/librustc_codegen_utils/symbol_names/legacy.rs", "status": "added", "additions": 463, "deletions": 0, "changes": 463, "blob_url": "https://github.com/rust-lang/rust/blob/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs?ref=7840a0b753a065a41999f1fb6028f67d33e3fdd5", "patch": "@@ -0,0 +1,463 @@\n+use rustc::hir::def_id::CrateNum;\n+use rustc::hir::map::{DefPathData, DisambiguatedDefPathData};\n+use rustc::ich::NodeIdHashingMode;\n+use rustc::mir::interpret::{ConstValue, Scalar};\n+use rustc::ty::print::{PrettyPrinter, Printer, Print};\n+use rustc::ty::subst::{Kind, UnpackedKind};\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc::util::common::record_time;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_mir::monomorphize::Instance;\n+\n+use log::debug;\n+\n+use std::fmt::{self, Write};\n+use std::mem::{self, discriminant};\n+\n+pub(super) fn mangle(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    instance: Instance<'tcx>,\n+    instantiating_crate: Option<CrateNum>,\n+) -> String {\n+    let def_id = instance.def_id();\n+\n+    // We want to compute the \"type\" of this item. Unfortunately, some\n+    // kinds of items (e.g., closures) don't have an entry in the\n+    // item-type array. So walk back up the find the closest parent\n+    // that DOES have an entry.\n+    let mut ty_def_id = def_id;\n+    let instance_ty;\n+    loop {\n+        let key = tcx.def_key(ty_def_id);\n+        match key.disambiguated_data.data {\n+            DefPathData::TypeNs(_) | DefPathData::ValueNs(_) => {\n+                instance_ty = tcx.type_of(ty_def_id);\n+                break;\n+            }\n+            _ => {\n+                // if we're making a symbol for something, there ought\n+                // to be a value or type-def or something in there\n+                // *somewhere*\n+                ty_def_id.index = key.parent.unwrap_or_else(|| {\n+                    bug!(\n+                        \"finding type for {:?}, encountered def-id {:?} with no \\\n+                         parent\",\n+                        def_id,\n+                        ty_def_id\n+                    );\n+                });\n+            }\n+        }\n+    }\n+\n+    // Erase regions because they may not be deterministic when hashed\n+    // and should not matter anyhow.\n+    let instance_ty = tcx.erase_regions(&instance_ty);\n+\n+    let hash = get_symbol_hash(tcx, instance, instance_ty, instantiating_crate);\n+\n+    let mut printer = SymbolPrinter {\n+        tcx,\n+        path: SymbolPath::new(),\n+        keep_within_component: false,\n+    }.print_def_path(def_id, &[]).unwrap();\n+\n+    if instance.is_vtable_shim() {\n+        let _ = printer.write_str(\"{{vtable-shim}}\");\n+    }\n+\n+    printer.path.finish(hash)\n+}\n+\n+fn get_symbol_hash<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+\n+    // instance this name will be for\n+    instance: Instance<'tcx>,\n+\n+    // type of the item, without any generic\n+    // parameters substituted; this is\n+    // included in the hash as a kind of\n+    // safeguard.\n+    item_type: Ty<'tcx>,\n+\n+    instantiating_crate: Option<CrateNum>,\n+) -> u64 {\n+    let def_id = instance.def_id();\n+    let substs = instance.substs;\n+    debug!(\n+        \"get_symbol_hash(def_id={:?}, parameters={:?})\",\n+        def_id, substs\n+    );\n+\n+    let mut hasher = StableHasher::<u64>::new();\n+    let mut hcx = tcx.create_stable_hashing_context();\n+\n+    record_time(&tcx.sess.perf_stats.symbol_hash_time, || {\n+        // the main symbol name is not necessarily unique; hash in the\n+        // compiler's internal def-path, guaranteeing each symbol has a\n+        // truly unique path\n+        tcx.def_path_hash(def_id).hash_stable(&mut hcx, &mut hasher);\n+\n+        // Include the main item-type. Note that, in this case, the\n+        // assertions about `needs_subst` may not hold, but this item-type\n+        // ought to be the same for every reference anyway.\n+        assert!(!item_type.has_erasable_regions());\n+        hcx.while_hashing_spans(false, |hcx| {\n+            hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+                item_type.hash_stable(hcx, &mut hasher);\n+            });\n+        });\n+\n+        // If this is a function, we hash the signature as well.\n+        // This is not *strictly* needed, but it may help in some\n+        // situations, see the `run-make/a-b-a-linker-guard` test.\n+        if let ty::FnDef(..) = item_type.sty {\n+            item_type.fn_sig(tcx).hash_stable(&mut hcx, &mut hasher);\n+        }\n+\n+        // also include any type parameters (for generic items)\n+        assert!(!substs.has_erasable_regions());\n+        assert!(!substs.needs_subst());\n+        substs.hash_stable(&mut hcx, &mut hasher);\n+\n+        if let Some(instantiating_crate) = instantiating_crate {\n+            (&tcx.original_crate_name(instantiating_crate).as_str()[..])\n+                .hash_stable(&mut hcx, &mut hasher);\n+            (&tcx.crate_disambiguator(instantiating_crate)).hash_stable(&mut hcx, &mut hasher);\n+        }\n+\n+        // We want to avoid accidental collision between different types of instances.\n+        // Especially, VtableShim may overlap with its original instance without this.\n+        discriminant(&instance.def).hash_stable(&mut hcx, &mut hasher);\n+    });\n+\n+    // 64 bits should be enough to avoid collisions.\n+    hasher.finish()\n+}\n+\n+// Follow C++ namespace-mangling style, see\n+// http://en.wikipedia.org/wiki/Name_mangling for more info.\n+//\n+// It turns out that on macOS you can actually have arbitrary symbols in\n+// function names (at least when given to LLVM), but this is not possible\n+// when using unix's linker. Perhaps one day when we just use a linker from LLVM\n+// we won't need to do this name mangling. The problem with name mangling is\n+// that it seriously limits the available characters. For example we can't\n+// have things like &T in symbol names when one would theoretically\n+// want them for things like impls of traits on that type.\n+//\n+// To be able to work on all platforms and get *some* reasonable output, we\n+// use C++ name-mangling.\n+#[derive(Debug)]\n+struct SymbolPath {\n+    result: String,\n+    temp_buf: String,\n+}\n+\n+impl SymbolPath {\n+    fn new() -> Self {\n+        let mut result = SymbolPath {\n+            result: String::with_capacity(64),\n+            temp_buf: String::with_capacity(16),\n+        };\n+        result.result.push_str(\"_ZN\"); // _Z == Begin name-sequence, N == nested\n+        result\n+    }\n+\n+    fn finalize_pending_component(&mut self) {\n+        if !self.temp_buf.is_empty() {\n+            let _ = write!(self.result, \"{}{}\", self.temp_buf.len(), self.temp_buf);\n+            self.temp_buf.clear();\n+        }\n+    }\n+\n+    fn finish(mut self, hash: u64) -> String {\n+        self.finalize_pending_component();\n+        // E = end name-sequence\n+        let _ = write!(self.result, \"17h{:016x}E\", hash);\n+        self.result\n+    }\n+}\n+\n+struct SymbolPrinter<'a, 'tcx> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    path: SymbolPath,\n+\n+    // When `true`, `finalize_pending_component` isn't used.\n+    // This is needed when recursing into `path_qualified`,\n+    // or `path_generic_args`, as any nested paths are\n+    // logically within one component.\n+    keep_within_component: bool,\n+}\n+\n+// HACK(eddyb) this relies on using the `fmt` interface to get\n+// `PrettyPrinter` aka pretty printing of e.g. types in paths,\n+// symbol names should have their own printing machinery.\n+\n+impl Printer<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n+    type Error = fmt::Error;\n+\n+    type Path = Self;\n+    type Region = Self;\n+    type Type = Self;\n+    type DynExistential = Self;\n+    type Const = Self;\n+\n+    fn tcx(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+        self.tcx\n+    }\n+\n+    fn print_region(\n+        self,\n+        _region: ty::Region<'_>,\n+    ) -> Result<Self::Region, Self::Error> {\n+        Ok(self)\n+    }\n+\n+    fn print_type(\n+        self,\n+        ty: Ty<'tcx>,\n+    ) -> Result<Self::Type, Self::Error> {\n+        match ty.sty {\n+            // Print all nominal types as paths (unlike `pretty_print_type`).\n+            ty::FnDef(def_id, substs) |\n+            ty::Opaque(def_id, substs) |\n+            ty::Projection(ty::ProjectionTy { item_def_id: def_id, substs }) |\n+            ty::UnnormalizedProjection(ty::ProjectionTy { item_def_id: def_id, substs }) |\n+            ty::Closure(def_id, ty::ClosureSubsts { substs }) |\n+            ty::Generator(def_id, ty::GeneratorSubsts { substs }, _) => {\n+                self.print_def_path(def_id, substs)\n+            }\n+            _ => self.pretty_print_type(ty),\n+        }\n+    }\n+\n+    fn print_dyn_existential(\n+        mut self,\n+        predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+    ) -> Result<Self::DynExistential, Self::Error> {\n+        let mut first = true;\n+        for p in predicates {\n+            if !first {\n+                write!(self, \"+\")?;\n+            }\n+            first = false;\n+            self = p.print(self)?;\n+        }\n+        Ok(self)\n+    }\n+\n+    fn print_const(\n+        mut self,\n+        ct: &'tcx ty::Const<'tcx>,\n+    ) -> Result<Self::Const, Self::Error> {\n+        // only print integers\n+        if let ConstValue::Scalar(Scalar::Raw { .. }) = ct.val {\n+            if ct.ty.is_integral() {\n+                return self.pretty_print_const(ct);\n+            }\n+        }\n+        self.write_str(\"_\")?;\n+        Ok(self)\n+    }\n+\n+    fn path_crate(\n+        mut self,\n+        cnum: CrateNum,\n+    ) -> Result<Self::Path, Self::Error> {\n+        self.write_str(&self.tcx.original_crate_name(cnum).as_str())?;\n+        Ok(self)\n+    }\n+    fn path_qualified(\n+        self,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        // Similar to `pretty_path_qualified`, but for the other\n+        // types that are printed as paths (see `print_type` above).\n+        match self_ty.sty {\n+            ty::FnDef(..) |\n+            ty::Opaque(..) |\n+            ty::Projection(_) |\n+            ty::UnnormalizedProjection(_) |\n+            ty::Closure(..) |\n+            ty::Generator(..)\n+                if trait_ref.is_none() =>\n+            {\n+                self.print_type(self_ty)\n+            }\n+\n+            _ => self.pretty_path_qualified(self_ty, trait_ref)\n+        }\n+    }\n+\n+    fn path_append_impl(\n+        self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        _disambiguated_data: &DisambiguatedDefPathData,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        self.pretty_path_append_impl(\n+            |mut cx| {\n+                cx = print_prefix(cx)?;\n+\n+                if cx.keep_within_component {\n+                    // HACK(eddyb) print the path similarly to how `FmtPrinter` prints it.\n+                    cx.write_str(\"::\")?;\n+                } else {\n+                    cx.path.finalize_pending_component();\n+                }\n+\n+                Ok(cx)\n+            },\n+            self_ty,\n+            trait_ref,\n+        )\n+    }\n+    fn path_append(\n+        mut self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        disambiguated_data: &DisambiguatedDefPathData,\n+    ) -> Result<Self::Path, Self::Error> {\n+        self = print_prefix(self)?;\n+\n+        // Skip `::{{constructor}}` on tuple/unit structs.\n+        match disambiguated_data.data {\n+            DefPathData::Ctor => return Ok(self),\n+            _ => {}\n+        }\n+\n+        if self.keep_within_component {\n+            // HACK(eddyb) print the path similarly to how `FmtPrinter` prints it.\n+            self.write_str(\"::\")?;\n+        } else {\n+            self.path.finalize_pending_component();\n+        }\n+\n+        self.write_str(&disambiguated_data.data.as_interned_str().as_str())?;\n+        Ok(self)\n+    }\n+    fn path_generic_args(\n+        mut self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        args: &[Kind<'tcx>],\n+    )  -> Result<Self::Path, Self::Error> {\n+        self = print_prefix(self)?;\n+\n+        let args = args.iter().cloned().filter(|arg| {\n+            match arg.unpack() {\n+                UnpackedKind::Lifetime(_) => false,\n+                _ => true,\n+            }\n+        });\n+\n+        if args.clone().next().is_some() {\n+            self.generic_delimiters(|cx| cx.comma_sep(args))\n+        } else {\n+            Ok(self)\n+        }\n+    }\n+}\n+\n+impl PrettyPrinter<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n+    fn region_should_not_be_omitted(\n+        &self,\n+        _region: ty::Region<'_>,\n+    ) -> bool {\n+        false\n+    }\n+    fn comma_sep<T>(\n+        mut self,\n+        mut elems: impl Iterator<Item = T>,\n+    ) -> Result<Self, Self::Error>\n+        where T: Print<'tcx, 'tcx, Self, Output = Self, Error = Self::Error>\n+    {\n+        if let Some(first) = elems.next() {\n+            self = first.print(self)?;\n+            for elem in elems {\n+                self.write_str(\",\")?;\n+                self = elem.print(self)?;\n+            }\n+        }\n+        Ok(self)\n+    }\n+\n+    fn generic_delimiters(\n+        mut self,\n+        f: impl FnOnce(Self) -> Result<Self, Self::Error>,\n+    ) -> Result<Self, Self::Error> {\n+        write!(self, \"<\")?;\n+\n+        let kept_within_component =\n+            mem::replace(&mut self.keep_within_component, true);\n+        self = f(self)?;\n+        self.keep_within_component = kept_within_component;\n+\n+        write!(self, \">\")?;\n+\n+        Ok(self)\n+    }\n+}\n+\n+impl fmt::Write for SymbolPrinter<'_, '_> {\n+    fn write_str(&mut self, s: &str) -> fmt::Result {\n+        // Name sanitation. LLVM will happily accept identifiers with weird names, but\n+        // gas doesn't!\n+        // gas accepts the following characters in symbols: a-z, A-Z, 0-9, ., _, $\n+        // NVPTX assembly has more strict naming rules than gas, so additionally, dots\n+        // are replaced with '$' there.\n+\n+        for c in s.chars() {\n+            if self.path.temp_buf.is_empty() {\n+                match c {\n+                    'a'..='z' | 'A'..='Z' | '_' => {}\n+                    _ => {\n+                        // Underscore-qualify anything that didn't start as an ident.\n+                        self.path.temp_buf.push('_');\n+                    }\n+                }\n+            }\n+            match c {\n+                // Escape these with $ sequences\n+                '@' => self.path.temp_buf.push_str(\"$SP$\"),\n+                '*' => self.path.temp_buf.push_str(\"$BP$\"),\n+                '&' => self.path.temp_buf.push_str(\"$RF$\"),\n+                '<' => self.path.temp_buf.push_str(\"$LT$\"),\n+                '>' => self.path.temp_buf.push_str(\"$GT$\"),\n+                '(' => self.path.temp_buf.push_str(\"$LP$\"),\n+                ')' => self.path.temp_buf.push_str(\"$RP$\"),\n+                ',' => self.path.temp_buf.push_str(\"$C$\"),\n+\n+                '-' | ':' | '.' if self.tcx.has_strict_asm_symbol_naming() => {\n+                    // NVPTX doesn't support these characters in symbol names.\n+                    self.path.temp_buf.push('$')\n+                }\n+\n+                // '.' doesn't occur in types and functions, so reuse it\n+                // for ':' and '-'\n+                '-' | ':' => self.path.temp_buf.push('.'),\n+\n+                // Avoid crashing LLVM in certain (LTO-related) situations, see #60925.\n+                'm' if self.path.temp_buf.ends_with(\".llv\") => self.path.temp_buf.push_str(\"$6d$\"),\n+\n+                // These are legal symbols\n+                'a'..='z' | 'A'..='Z' | '0'..='9' | '_' | '.' | '$' => self.path.temp_buf.push(c),\n+\n+                _ => {\n+                    self.path.temp_buf.push('$');\n+                    for c in c.escape_unicode().skip(1) {\n+                        match c {\n+                            '{' => {}\n+                            '}' => self.path.temp_buf.push('$'),\n+                            c => self.path.temp_buf.push(c),\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+}"}, {"sha": "1615a097b3bf9e0938f86af47ad9844d2ad80f88", "filename": "src/librustc_codegen_utils/symbol_names/v0.rs", "status": "added", "additions": 657, "deletions": 0, "changes": 657, "blob_url": "https://github.com/rust-lang/rust/blob/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs?ref=7840a0b753a065a41999f1fb6028f67d33e3fdd5", "patch": "@@ -0,0 +1,657 @@\n+use rustc::hir;\n+use rustc::hir::def_id::{CrateNum, DefId};\n+use rustc::hir::map::{DefPathData, DisambiguatedDefPathData};\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::print::{Printer, Print};\n+use rustc::ty::subst::{Kind, Subst, UnpackedKind};\n+use rustc_data_structures::base_n;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_mir::monomorphize::Instance;\n+use rustc_target::spec::abi::Abi;\n+use syntax::ast::{IntTy, UintTy, FloatTy};\n+\n+use std::fmt::Write;\n+use std::ops::Range;\n+\n+pub(super) fn mangle(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    instance: Instance<'tcx>,\n+    instantiating_crate: Option<CrateNum>,\n+) -> String {\n+    let def_id = instance.def_id();\n+    // FIXME(eddyb) this should ideally not be needed.\n+    let substs =\n+        tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), instance.substs);\n+\n+    let prefix = \"_R\";\n+    let mut cx = SymbolMangler {\n+        tcx,\n+        compress: Some(Box::new(CompressionCaches {\n+            start_offset: prefix.len(),\n+\n+            paths: FxHashMap::default(),\n+            types: FxHashMap::default(),\n+            consts: FxHashMap::default(),\n+        })),\n+        binders: vec![],\n+        out: String::from(prefix),\n+    };\n+    cx = if instance.is_vtable_shim() {\n+        cx.path_append_ns(\n+            |cx| cx.print_def_path(def_id, substs),\n+            'S',\n+            0,\n+            \"\",\n+        ).unwrap()\n+    } else {\n+        cx.print_def_path(def_id, substs).unwrap()\n+    };\n+    if let Some(instantiating_crate) = instantiating_crate {\n+        cx = cx.print_def_path(instantiating_crate.as_def_id(), &[]).unwrap();\n+    }\n+    cx.out\n+}\n+\n+struct CompressionCaches<'tcx> {\n+    // The length of the prefix in `out` (e.g. 2 for `_R`).\n+    start_offset: usize,\n+\n+    // The values are start positions in `out`, in bytes.\n+    paths: FxHashMap<(DefId, &'tcx [Kind<'tcx>]), usize>,\n+    types: FxHashMap<Ty<'tcx>, usize>,\n+    consts: FxHashMap<&'tcx ty::Const<'tcx>, usize>,\n+}\n+\n+struct BinderLevel {\n+    /// The range of distances from the root of what's\n+    /// being printed, to the lifetimes in a binder.\n+    /// Specifically, a `BrAnon(i)` lifetime has depth\n+    /// `lifetime_depths.start + i`, going away from the\n+    /// the root and towards its use site, as `i` increases.\n+    /// This is used to flatten rustc's pairing of `BrAnon`\n+    /// (intra-binder disambiguation) with a `DebruijnIndex`\n+    /// (binder addressing), to \"true\" de Bruijn indices,\n+    /// by subtracting the depth of a certain lifetime, from\n+    /// the innermost depth at its use site.\n+    lifetime_depths: Range<u32>,\n+}\n+\n+struct SymbolMangler<'a, 'tcx> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    compress: Option<Box<CompressionCaches<'tcx>>>,\n+    binders: Vec<BinderLevel>,\n+    out: String,\n+}\n+\n+impl SymbolMangler<'_, 'tcx> {\n+    fn push(&mut self, s: &str) {\n+        self.out.push_str(s);\n+    }\n+\n+    /// Push a `_`-terminated base 62 integer, using the format\n+    /// specified in the RFC as `<base-62-number>`, that is:\n+    /// * `x = 0` is encoded as just the `\"_\"` terminator\n+    /// * `x > 0` is encoded as `x - 1` in base 62, followed by `\"_\"`,\n+    ///   e.g. `1` becomes `\"0_\"`, `62` becomes `\"Z_\"`, etc.\n+    fn push_integer_62(&mut self, x: u64) {\n+        if let Some(x) = x.checked_sub(1) {\n+            base_n::push_str(x as u128, 62, &mut self.out);\n+        }\n+        self.push(\"_\");\n+    }\n+\n+    /// Push a `tag`-prefixed base 62 integer, when larger than `0`, that is:\n+    /// * `x = 0` is encoded as `\"\"` (nothing)\n+    /// * `x > 0` is encoded as the `tag` followed by `push_integer_62(x - 1)`\n+    ///   e.g. `1` becomes `tag + \"_\"`, `2` becomes `tag + \"0_\"`, etc.\n+    fn push_opt_integer_62(&mut self, tag: &str, x: u64) {\n+        if let Some(x) = x.checked_sub(1) {\n+            self.push(tag);\n+            self.push_integer_62(x);\n+        }\n+    }\n+\n+    fn push_disambiguator(&mut self, dis: u64) {\n+        self.push_opt_integer_62(\"s\", dis);\n+    }\n+\n+    fn push_ident(&mut self, ident: &str) {\n+        let mut use_punycode = false;\n+        for b in ident.bytes() {\n+            match b {\n+                b'_' | b'a'..=b'z' | b'A'..=b'Z' | b'0'..=b'9' => {}\n+                0x80..=0xff => use_punycode = true,\n+                _ => bug!(\"symbol_names: bad byte {} in ident {:?}\", b, ident),\n+            }\n+        }\n+\n+        let punycode_string;\n+        let ident = if use_punycode {\n+            self.push(\"u\");\n+\n+            // FIXME(eddyb) we should probably roll our own punycode implementation.\n+            let mut punycode_bytes = match ::punycode::encode(ident) {\n+                Ok(s) => s.into_bytes(),\n+                Err(()) => bug!(\"symbol_names: punycode encoding failed for ident {:?}\", ident),\n+            };\n+\n+            // Replace `-` with `_`.\n+            if let Some(c) = punycode_bytes.iter_mut().rfind(|&&mut c| c == b'-') {\n+                *c = b'_';\n+            }\n+\n+            // FIXME(eddyb) avoid rechecking UTF-8 validity.\n+            punycode_string = String::from_utf8(punycode_bytes).unwrap();\n+            &punycode_string\n+        } else {\n+            ident\n+        };\n+\n+        let _ = write!(self.out, \"{}\", ident.len());\n+\n+        // Write a separating `_` if necessary (leading digit or `_`).\n+        match ident.chars().next() {\n+            Some('_') | Some('0'..='9') => {\n+                self.push(\"_\");\n+            }\n+            _ => {}\n+        }\n+\n+        self.push(ident);\n+    }\n+\n+    fn path_append_ns(\n+        mut self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self, !>,\n+        ns: char,\n+        disambiguator: u64,\n+        name: &str,\n+    ) -> Result<Self, !> {\n+        self.push(\"N\");\n+        self.out.push(ns);\n+        self = print_prefix(self)?;\n+        self.push_disambiguator(disambiguator as u64);\n+        self.push_ident(name);\n+        Ok(self)\n+    }\n+\n+    fn print_backref(mut self, i: usize) -> Result<Self, !> {\n+        self.push(\"B\");\n+        self.push_integer_62((i - self.compress.as_ref().unwrap().start_offset) as u64);\n+        Ok(self)\n+    }\n+\n+    fn in_binder<T>(\n+        mut self,\n+        value: &ty::Binder<T>,\n+        print_value: impl FnOnce(Self, &T) -> Result<Self, !>\n+    ) -> Result<Self, !>\n+        where T: TypeFoldable<'tcx>\n+    {\n+        let regions = if value.has_late_bound_regions() {\n+            self.tcx.collect_referenced_late_bound_regions(value)\n+        } else {\n+            FxHashSet::default()\n+        };\n+\n+        let mut lifetime_depths =\n+            self.binders.last().map(|b| b.lifetime_depths.end).map_or(0..0, |i| i..i);\n+\n+        let lifetimes = regions.into_iter().map(|br| {\n+            match br {\n+                ty::BrAnon(i) => i + 1,\n+                _ => bug!(\"symbol_names: non-anonymized region `{:?}` in `{:?}`\", br, value),\n+            }\n+        }).max().unwrap_or(0);\n+\n+        self.push_opt_integer_62(\"G\", lifetimes as u64);\n+        lifetime_depths.end += lifetimes;\n+\n+        self.binders.push(BinderLevel { lifetime_depths });\n+        self = print_value(self, value.skip_binder())?;\n+        self.binders.pop();\n+\n+        Ok(self)\n+    }\n+}\n+\n+impl Printer<'tcx, 'tcx> for SymbolMangler<'_, 'tcx> {\n+    type Error = !;\n+\n+    type Path = Self;\n+    type Region = Self;\n+    type Type = Self;\n+    type DynExistential = Self;\n+    type Const = Self;\n+\n+    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+        self.tcx\n+    }\n+\n+    fn print_def_path(\n+        mut self,\n+        def_id: DefId,\n+        substs: &'tcx [Kind<'tcx>],\n+    ) -> Result<Self::Path, Self::Error> {\n+        if let Some(&i) = self.compress.as_ref().and_then(|c| c.paths.get(&(def_id, substs))) {\n+            return self.print_backref(i);\n+        }\n+        let start = self.out.len();\n+\n+        self = self.default_print_def_path(def_id, substs)?;\n+\n+        // Only cache paths that do not refer to an enclosing\n+        // binder (which would change depending on context).\n+        if !substs.iter().any(|k| k.has_escaping_bound_vars()) {\n+            if let Some(c) = &mut self.compress {\n+                c.paths.insert((def_id, substs), start);\n+            }\n+        }\n+        Ok(self)\n+    }\n+\n+    fn print_impl_path(\n+        self,\n+        impl_def_id: DefId,\n+        substs: &'tcx [Kind<'tcx>],\n+        mut self_ty: Ty<'tcx>,\n+        mut impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        let key = self.tcx.def_key(impl_def_id);\n+        let parent_def_id = DefId { index: key.parent.unwrap(), ..impl_def_id };\n+\n+        let mut param_env = self.tcx.param_env(impl_def_id)\n+            .with_reveal_all();\n+        if !substs.is_empty() {\n+            param_env = param_env.subst(self.tcx, substs);\n+        }\n+\n+        match &mut impl_trait_ref {\n+            Some(impl_trait_ref) => {\n+                assert_eq!(impl_trait_ref.self_ty(), self_ty);\n+                *impl_trait_ref =\n+                    self.tcx.normalize_erasing_regions(param_env, *impl_trait_ref);\n+                self_ty = impl_trait_ref.self_ty();\n+            }\n+            None => {\n+                self_ty = self.tcx.normalize_erasing_regions(param_env, self_ty);\n+            }\n+        }\n+\n+        self.path_append_impl(\n+            |cx| cx.print_def_path(parent_def_id, &[]),\n+            &key.disambiguated_data,\n+            self_ty,\n+            impl_trait_ref,\n+        )\n+    }\n+\n+    fn print_region(\n+        mut self,\n+        region: ty::Region<'_>,\n+    ) -> Result<Self::Region, Self::Error> {\n+        let i = match *region {\n+            // Erased lifetimes use the index 0, for a\n+            // shorter mangling of `L_`.\n+            ty::ReErased => 0,\n+\n+            // Late-bound lifetimes use indices starting at 1,\n+            // see `BinderLevel` for more details.\n+            ty::ReLateBound(debruijn, ty::BrAnon(i)) => {\n+                let binder = &self.binders[self.binders.len() - 1 - debruijn.index()];\n+                let depth = binder.lifetime_depths.start + i;\n+\n+                1 + (self.binders.last().unwrap().lifetime_depths.end - 1 - depth)\n+            }\n+\n+            _ => bug!(\"symbol_names: non-erased region `{:?}`\", region),\n+        };\n+        self.push(\"L\");\n+        self.push_integer_62(i as u64);\n+        Ok(self)\n+    }\n+\n+    fn print_type(\n+        mut self,\n+        ty: Ty<'tcx>,\n+    ) -> Result<Self::Type, Self::Error> {\n+        // Basic types, never cached (single-character).\n+        let basic_type = match ty.sty {\n+            ty::Bool => \"b\",\n+            ty::Char => \"c\",\n+            ty::Str => \"e\",\n+            ty::Tuple(_) if ty.is_unit() => \"u\",\n+            ty::Int(IntTy::I8) => \"a\",\n+            ty::Int(IntTy::I16) => \"s\",\n+            ty::Int(IntTy::I32) => \"l\",\n+            ty::Int(IntTy::I64) => \"x\",\n+            ty::Int(IntTy::I128) => \"n\",\n+            ty::Int(IntTy::Isize) => \"i\",\n+            ty::Uint(UintTy::U8) => \"h\",\n+            ty::Uint(UintTy::U16) => \"t\",\n+            ty::Uint(UintTy::U32) => \"m\",\n+            ty::Uint(UintTy::U64) => \"y\",\n+            ty::Uint(UintTy::U128) => \"o\",\n+            ty::Uint(UintTy::Usize) => \"j\",\n+            ty::Float(FloatTy::F32) => \"f\",\n+            ty::Float(FloatTy::F64) => \"d\",\n+            ty::Never => \"z\",\n+\n+            // Placeholders (should be demangled as `_`).\n+            ty::Param(_) | ty::Bound(..) | ty::Placeholder(_) |\n+            ty::Infer(_) | ty::Error => \"p\",\n+\n+            _ => \"\",\n+        };\n+        if !basic_type.is_empty() {\n+            self.push(basic_type);\n+            return Ok(self);\n+        }\n+\n+        if let Some(&i) = self.compress.as_ref().and_then(|c| c.types.get(&ty)) {\n+            return self.print_backref(i);\n+        }\n+        let start = self.out.len();\n+\n+        match ty.sty {\n+            // Basic types, handled above.\n+            ty::Bool | ty::Char | ty::Str |\n+            ty::Int(_) | ty::Uint(_) | ty::Float(_) |\n+            ty::Never => unreachable!(),\n+            ty::Tuple(_) if ty.is_unit() => unreachable!(),\n+\n+            // Placeholders, also handled as part of basic types.\n+            ty::Param(_) | ty::Bound(..) | ty::Placeholder(_) |\n+            ty::Infer(_) | ty::Error => unreachable!(),\n+\n+            ty::Ref(r, ty, mutbl) => {\n+                self.push(match mutbl {\n+                    hir::MutImmutable => \"R\",\n+                    hir::MutMutable => \"Q\",\n+                });\n+                if *r != ty::ReErased {\n+                    self = r.print(self)?;\n+                }\n+                self = ty.print(self)?;\n+            }\n+\n+            ty::RawPtr(mt) => {\n+                self.push(match mt.mutbl {\n+                    hir::MutImmutable => \"P\",\n+                    hir::MutMutable => \"O\",\n+                });\n+                self = mt.ty.print(self)?;\n+            }\n+\n+            ty::Array(ty, len) => {\n+                self.push(\"A\");\n+                self = ty.print(self)?;\n+                self = self.print_const(len)?;\n+            }\n+            ty::Slice(ty) => {\n+                self.push(\"S\");\n+                self = ty.print(self)?;\n+            }\n+\n+            ty::Tuple(tys) => {\n+                self.push(\"T\");\n+                for ty in tys.iter().map(|k| k.expect_ty()) {\n+                    self = ty.print(self)?;\n+                }\n+                self.push(\"E\");\n+            }\n+\n+            // Mangle all nominal types as paths.\n+            ty::Adt(&ty::AdtDef { did: def_id, .. }, substs) |\n+            ty::FnDef(def_id, substs) |\n+            ty::Opaque(def_id, substs) |\n+            ty::Projection(ty::ProjectionTy { item_def_id: def_id, substs }) |\n+            ty::UnnormalizedProjection(ty::ProjectionTy { item_def_id: def_id, substs }) |\n+            ty::Closure(def_id, ty::ClosureSubsts { substs }) |\n+            ty::Generator(def_id, ty::GeneratorSubsts { substs }, _) => {\n+                self = self.print_def_path(def_id, substs)?;\n+            }\n+            ty::Foreign(def_id) => {\n+                self = self.print_def_path(def_id, &[])?;\n+            }\n+\n+            ty::FnPtr(sig) => {\n+                self.push(\"F\");\n+                self = self.in_binder(&sig, |mut cx, sig| {\n+                    if sig.unsafety == hir::Unsafety::Unsafe {\n+                        cx.push(\"U\");\n+                    }\n+                    match sig.abi {\n+                        Abi::Rust => {}\n+                        Abi::C => cx.push(\"KC\"),\n+                        abi => {\n+                            cx.push(\"K\");\n+                            let name = abi.name();\n+                            if name.contains('-') {\n+                                cx.push_ident(&name.replace('-', \"_\"));\n+                            } else {\n+                                cx.push_ident(name);\n+                            }\n+                        }\n+                    }\n+                    for &ty in sig.inputs() {\n+                        cx = ty.print(cx)?;\n+                    }\n+                    if sig.c_variadic {\n+                        cx.push(\"v\");\n+                    }\n+                    cx.push(\"E\");\n+                    sig.output().print(cx)\n+                })?;\n+            }\n+\n+            ty::Dynamic(predicates, r) => {\n+                self.push(\"D\");\n+                self = self.in_binder(&predicates, |cx, predicates| {\n+                    cx.print_dyn_existential(predicates)\n+                })?;\n+                self = r.print(self)?;\n+            }\n+\n+            ty::GeneratorWitness(_) => {\n+                bug!(\"symbol_names: unexpected `GeneratorWitness`\")\n+            }\n+        }\n+\n+        // Only cache types that do not refer to an enclosing\n+        // binder (which would change depending on context).\n+        if !ty.has_escaping_bound_vars() {\n+            if let Some(c) = &mut self.compress {\n+                c.types.insert(ty, start);\n+            }\n+        }\n+        Ok(self)\n+    }\n+\n+    fn print_dyn_existential(\n+        mut self,\n+        predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+    ) -> Result<Self::DynExistential, Self::Error> {\n+        for predicate in predicates {\n+            match *predicate {\n+                ty::ExistentialPredicate::Trait(trait_ref) => {\n+                    // Use a type that can't appear in defaults of type parameters.\n+                    let dummy_self = self.tcx.mk_ty_infer(ty::FreshTy(0));\n+                    let trait_ref = trait_ref.with_self_ty(self.tcx, dummy_self);\n+                    self = self.print_def_path(trait_ref.def_id, trait_ref.substs)?;\n+                }\n+                ty::ExistentialPredicate::Projection(projection) => {\n+                    let name = self.tcx.associated_item(projection.item_def_id).ident;\n+                    self.push(\"p\");\n+                    self.push_ident(&name.as_str());\n+                    self = projection.ty.print(self)?;\n+                }\n+                ty::ExistentialPredicate::AutoTrait(def_id) => {\n+                    self = self.print_def_path(def_id, &[])?;\n+                }\n+            }\n+        }\n+        self.push(\"E\");\n+        Ok(self)\n+    }\n+\n+    fn print_const(\n+        mut self,\n+        ct: &'tcx ty::Const<'tcx>,\n+    ) -> Result<Self::Const, Self::Error> {\n+        if let Some(&i) = self.compress.as_ref().and_then(|c| c.consts.get(&ct)) {\n+            return self.print_backref(i);\n+        }\n+        let start = self.out.len();\n+\n+        match ct.ty.sty {\n+            ty::Uint(_) => {}\n+            _ => {\n+                bug!(\"symbol_names: unsupported constant of type `{}` ({:?})\",\n+                    ct.ty, ct);\n+            }\n+        }\n+        self = ct.ty.print(self)?;\n+\n+        if let Some(bits) = ct.assert_bits(self.tcx, ty::ParamEnv::empty().and(ct.ty)) {\n+            let _ = write!(self.out, \"{:x}_\", bits);\n+        } else {\n+            // NOTE(eddyb) despite having the path, we need to\n+            // encode a placeholder, as the path could refer\n+            // back to e.g. an `impl` using the constant.\n+            self.push(\"p\");\n+        }\n+\n+        // Only cache consts that do not refer to an enclosing\n+        // binder (which would change depending on context).\n+        if !ct.has_escaping_bound_vars() {\n+            if let Some(c) = &mut self.compress {\n+                c.consts.insert(ct, start);\n+            }\n+        }\n+        Ok(self)\n+    }\n+\n+    fn path_crate(\n+        mut self,\n+        cnum: CrateNum,\n+    ) -> Result<Self::Path, Self::Error> {\n+        self.push(\"C\");\n+        let fingerprint = self.tcx.crate_disambiguator(cnum).to_fingerprint();\n+        self.push_disambiguator(fingerprint.to_smaller_hash());\n+        let name = self.tcx.original_crate_name(cnum).as_str();\n+        self.push_ident(&name);\n+        Ok(self)\n+    }\n+    fn path_qualified(\n+        mut self,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        assert!(trait_ref.is_some());\n+        let trait_ref = trait_ref.unwrap();\n+\n+        self.push(\"Y\");\n+        self = self_ty.print(self)?;\n+        self.print_def_path(trait_ref.def_id, trait_ref.substs)\n+    }\n+\n+    fn path_append_impl(\n+        mut self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        disambiguated_data: &DisambiguatedDefPathData,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        self.push(match trait_ref {\n+            Some(_) => \"X\",\n+            None => \"M\",\n+        });\n+        self.push_disambiguator(disambiguated_data.disambiguator as u64);\n+        self = print_prefix(self)?;\n+        self = self_ty.print(self)?;\n+        if let Some(trait_ref) = trait_ref {\n+            self = self.print_def_path(trait_ref.def_id, trait_ref.substs)?;\n+        }\n+        Ok(self)\n+    }\n+    fn path_append(\n+        self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        disambiguated_data: &DisambiguatedDefPathData,\n+    ) -> Result<Self::Path, Self::Error> {\n+        let ns = match disambiguated_data.data {\n+            // Uppercase categories are more stable than lowercase ones.\n+            DefPathData::TypeNs(_) => 't',\n+            DefPathData::ValueNs(_) => 'v',\n+            DefPathData::ClosureExpr => 'C',\n+            DefPathData::Ctor => 'c',\n+            DefPathData::AnonConst => 'k',\n+            DefPathData::ImplTrait => 'i',\n+\n+            // These should never show up as `path_append` arguments.\n+            DefPathData::CrateRoot\n+            | DefPathData::Misc\n+            | DefPathData::Impl\n+            | DefPathData::MacroNs(_)\n+            | DefPathData::LifetimeNs(_)\n+            | DefPathData::GlobalMetaData(_) => {\n+                bug!(\"symbol_names: unexpected DefPathData: {:?}\", disambiguated_data.data)\n+            }\n+        };\n+\n+        let name = disambiguated_data.data.get_opt_name().map(|s| s.as_str());\n+\n+        self.path_append_ns(\n+            print_prefix,\n+            ns,\n+            disambiguated_data.disambiguator as u64,\n+            name.as_ref().map_or(\"\", |s| &s[..])\n+        )\n+    }\n+    fn path_generic_args(\n+        mut self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        args: &[Kind<'tcx>],\n+    ) -> Result<Self::Path, Self::Error> {\n+        // Don't print any regions if they're all erased.\n+        let print_regions = args.iter().any(|arg| {\n+            match arg.unpack() {\n+                UnpackedKind::Lifetime(r) => *r != ty::ReErased,\n+                _ => false,\n+            }\n+        });\n+        let args = args.iter().cloned().filter(|arg| {\n+            match arg.unpack() {\n+                UnpackedKind::Lifetime(_) => print_regions,\n+                _ => true,\n+            }\n+        });\n+\n+        if args.clone().next().is_none() {\n+            return print_prefix(self);\n+        }\n+\n+        self.push(\"I\");\n+        self = print_prefix(self)?;\n+        for arg in args {\n+            match arg.unpack() {\n+                UnpackedKind::Lifetime(lt) => {\n+                    self = lt.print(self)?;\n+                }\n+                UnpackedKind::Type(ty) => {\n+                    self = ty.print(self)?;\n+                }\n+                UnpackedKind::Const(c) => {\n+                    self.push(\"K\");\n+                    // FIXME(const_generics) implement `ty::print::Print` on `ty::Const`.\n+                    // self = c.print(self)?;\n+                    self = self.print_const(c)?;\n+                }\n+            }\n+        }\n+        self.push(\"E\");\n+\n+        Ok(self)\n+    }\n+}"}, {"sha": "b935ccb7398e23e33407343ffa7a991bffbaa1fb", "filename": "src/librustc_codegen_utils/symbol_names_test.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs?ref=7840a0b753a065a41999f1fb6028f67d33e3fdd5", "patch": "@@ -39,8 +39,12 @@ impl<'a, 'tcx> SymbolNamesTest<'a, 'tcx> {\n             if attr.check_name(SYMBOL_NAME) {\n                 // for now, can only use on monomorphic names\n                 let instance = Instance::mono(tcx, def_id);\n-                let name = self.tcx.symbol_name(instance);\n-                tcx.sess.span_err(attr.span, &format!(\"symbol-name({})\", name));\n+                let mangled = self.tcx.symbol_name(instance);\n+                tcx.sess.span_err(attr.span, &format!(\"symbol-name({})\", mangled));\n+                if let Ok(demangling) = rustc_demangle::try_demangle(&mangled.as_str()) {\n+                    tcx.sess.span_err(attr.span, &format!(\"demangling({})\", demangling));\n+                    tcx.sess.span_err(attr.span, &format!(\"demangling-alt({:#})\", demangling));\n+                }\n             } else if attr.check_name(DEF_PATH) {\n                 let path = tcx.def_path_str(def_id);\n                 tcx.sess.span_err(attr.span, &format!(\"def-path({})\", path));"}, {"sha": "e04372ea280b5dd0c8fab7b8a79cc9588877a606", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=7840a0b753a065a41999f1fb6028f67d33e3fdd5", "patch": "@@ -176,6 +176,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n         r.map(|c| &*tcx.arena.alloc(c))\n     }\n     is_no_builtins => { cdata.root.no_builtins }\n+    symbol_mangling_version => { cdata.root.symbol_mangling_version }\n     impl_defaultness => { cdata.get_impl_defaultness(def_id.index) }\n     reachable_non_generics => {\n         let reachable_non_generics = tcx"}, {"sha": "586fc507dd3ebaa81ec0b3a61bd3f7cede2f8070", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=7840a0b753a065a41999f1fb6028f67d33e3fdd5", "patch": "@@ -498,6 +498,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             panic_runtime: attr::contains_name(&attrs, sym::panic_runtime),\n             profiler_runtime: attr::contains_name(&attrs, sym::profiler_runtime),\n             sanitizer_runtime: attr::contains_name(&attrs, sym::sanitizer_runtime),\n+            symbol_mangling_version: tcx.sess.opts.debugging_opts.symbol_mangling_version,\n \n             crate_deps,\n             dylib_dependency_formats,"}, {"sha": "8d1de4fd6c392a03a4bff6df3080c5581f4d29e5", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=7840a0b753a065a41999f1fb6028f67d33e3fdd5", "patch": "@@ -8,6 +8,7 @@ use rustc::middle::cstore::{DepKind, LinkagePreference, NativeLibrary, ForeignMo\n use rustc::middle::lang_items;\n use rustc::mir;\n use rustc::session::CrateDisambiguator;\n+use rustc::session::config::SymbolManglingVersion;\n use rustc::ty::{self, Ty, ReprOptions};\n use rustc_target::spec::{PanicStrategy, TargetTriple};\n use rustc_data_structures::svh::Svh;\n@@ -189,6 +190,7 @@ pub struct CrateRoot<'tcx> {\n     pub panic_runtime: bool,\n     pub profiler_runtime: bool,\n     pub sanitizer_runtime: bool,\n+    pub symbol_mangling_version: SymbolManglingVersion,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]"}, {"sha": "307c4e2c1e273b061c987bc20c538996e42c4c68", "filename": "src/test/codegen/drop.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Fcodegen%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Fcodegen%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fdrop.rs?ref=7840a0b753a065a41999f1fb6028f67d33e3fdd5", "patch": "@@ -19,15 +19,18 @@ pub fn droppy() {\n // that's one new drop call per call to possibly_unwinding(), and finally 3 drop calls for the\n // regular function exit. We used to have problems with quadratic growths of drop calls in such\n // functions.\n-// CHECK-NOT: invoke{{.*}}drop{{.*}}SomeUniqueName\n-// CHECK: call{{.*}}drop{{.*}}SomeUniqueName\n-// CHECK: call{{.*}}drop{{.*}}SomeUniqueName\n-// CHECK-NOT: call{{.*}}drop{{.*}}SomeUniqueName\n-// CHECK: invoke{{.*}}drop{{.*}}SomeUniqueName\n-// CHECK: call{{.*}}drop{{.*}}SomeUniqueName\n-// CHECK: invoke{{.*}}drop{{.*}}SomeUniqueName\n-// CHECK: call{{.*}}drop{{.*}}SomeUniqueName\n-// CHECK-NOT: {{(call|invoke).*}}drop{{.*}}SomeUniqueName\n+// FIXME(eddyb) the `void @` forces a match on the instruction, instead of the\n+// comment, that's `; call core::ptr::real_drop_in_place::<drop::SomeUniqueName>`\n+// for the `v0` mangling, should switch to matching on that once `legacy` is gone.\n+// CHECK-NOT: invoke void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n+// CHECK: call void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n+// CHECK: call void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n+// CHECK-NOT: call void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n+// CHECK: invoke void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n+// CHECK: call void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n+// CHECK: invoke void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n+// CHECK: call void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n+// CHECK-NOT: {{(call|invoke) void @.*}}drop_in_place{{.*}}SomeUniqueName\n // The next line checks for the } that ends the function definition\n // CHECK-LABEL: {{^[}]}}\n     let _s = SomeUniqueName;"}, {"sha": "902882144996fe6ef875ecb938a5446d06d27806", "filename": "src/test/codegen/external-no-mangle-fns.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Fcodegen%2Fexternal-no-mangle-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Fcodegen%2Fexternal-no-mangle-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fexternal-no-mangle-fns.rs?ref=7840a0b753a065a41999f1fb6028f67d33e3fdd5", "patch": "@@ -33,7 +33,9 @@ const HIDDEN: () = {\n };\n \n // The surrounding item should not accidentally become external\n-// CHECK: define internal{{.*}} void @_ZN22external_no_mangle_fns1x\n+// CHECK-LABEL: ; external_no_mangle_fns::x\n+// CHECK-NEXT: ; Function Attrs:\n+// CHECK-NEXT: define internal\n #[inline(never)]\n fn x() {\n     // CHECK: define void @g()"}, {"sha": "e44373926b76aa45cb952d54f11808fe367fe62d", "filename": "src/test/codegen/external-no-mangle-statics.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Fcodegen%2Fexternal-no-mangle-statics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Fcodegen%2Fexternal-no-mangle-statics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fexternal-no-mangle-statics.rs?ref=7840a0b753a065a41999f1fb6028f67d33e3fdd5", "patch": "@@ -75,4 +75,6 @@ fn x() {\n     #[no_mangle]\n     pub static mut P: u8 = 0;\n }\n-// CHECK: define internal void @_ZN26external_no_mangle_statics1x{{.*$}}\n+// CHECK-LABEL: ; external_no_mangle_statics::x\n+// CHECK-NEXT: ; Function Attrs:\n+// CHECK-NEXT: define internal"}, {"sha": "8d9192c6fa0c1fe953a60e1ef03bed6f7795eb4a", "filename": "src/test/codegen/internalize-closures.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Fcodegen%2Finternalize-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Fcodegen%2Finternalize-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Finternalize-closures.rs?ref=7840a0b753a065a41999f1fb6028f67d33e3fdd5", "patch": "@@ -4,7 +4,11 @@ pub fn main() {\n \n     // We want to make sure that closures get 'internal' linkage instead of\n     // 'weak_odr' when they are not shared between codegen units\n-    // CHECK: define internal {{.*}}_ZN20internalize_closures4main{{.*}}$u7b$$u7b$closure$u7d$$u7d$\n+    // FIXME(eddyb) `legacy` mangling uses `{{closure}}`, while `v0`\n+    // uses `{closure#0}`, switch to the latter once `legacy` is gone.\n+    // CHECK-LABEL: ; internalize_closures::main::{{.*}}closure\n+    // CHECK-NEXT: ; Function Attrs:\n+    // CHECK-NEXT: define internal\n     let c = |x:i32| { x + 1 };\n     let _ = c(1);\n }"}, {"sha": "de5a237c5f8a357e9f2b9e8ed7127dc1ccafb0bf", "filename": "src/test/codegen/link-dead-code.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Fcodegen%2Flink-dead-code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Fcodegen%2Flink-dead-code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Flink-dead-code.rs?ref=7840a0b753a065a41999f1fb6028f67d33e3fdd5", "patch": "@@ -5,12 +5,18 @@\n // This test makes sure that, when -Clink-dead-code is specified, we generate\n // code for functions that would otherwise be skipped.\n \n-// CHECK-LABEL: define hidden i32 @_ZN14link_dead_code8const_fn\n+// CHECK-LABEL: ; link_dead_code::const_fn\n+// CHECK-NEXT: ; Function Attrs:\n+// CHECK-NEXT: define hidden\n const fn const_fn() -> i32 { 1 }\n \n-// CHECK-LABEL: define hidden i32 @_ZN14link_dead_code9inline_fn\n+// CHECK-LABEL: ; link_dead_code::inline_fn\n+// CHECK-NEXT: ; Function Attrs:\n+// CHECK-NEXT: define hidden\n #[inline]\n fn inline_fn() -> i32 { 2 }\n \n-// CHECK-LABEL: define hidden i32 @_ZN14link_dead_code10private_fn\n+// CHECK-LABEL: ; link_dead_code::private_fn\n+// CHECK-NEXT: ; Function Attrs:\n+// CHECK-NEXT: define hidden\n fn private_fn() -> i32 { 3 }"}, {"sha": "e5430fbf17a1dbc3438be7499e912184c0ad3170", "filename": "src/test/codegen/local-generics-in-exe-internalized.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Fcodegen%2Flocal-generics-in-exe-internalized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Fcodegen%2Flocal-generics-in-exe-internalized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Flocal-generics-in-exe-internalized.rs?ref=7840a0b753a065a41999f1fb6028f67d33e3fdd5", "patch": "@@ -2,7 +2,9 @@\n \n // Check that local generics are internalized if they are in the same CGU\n \n-// CHECK: define internal {{.*}} @_ZN34local_generics_in_exe_internalized3foo{{.*}}\n+// CHECK-LABEL: ; local_generics_in_exe_internalized::foo\n+// CHECK-NEXT: ; Function Attrs:\n+// CHECK-NEXT: define internal\n pub fn foo<T>(x: T, y: T) -> (T, T) {\n     (x, y)\n }"}, {"sha": "523216deb8400936cc8cd331458aae093a810640", "filename": "src/test/codegen/target-cpu-on-functions.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Fcodegen%2Ftarget-cpu-on-functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Fcodegen%2Ftarget-cpu-on-functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ftarget-cpu-on-functions.rs?ref=7840a0b753a065a41999f1fb6028f67d33e3fdd5", "patch": "@@ -13,7 +13,9 @@ pub extern fn exported() {\n     not_exported();\n }\n \n-// CHECK-LABEL: define {{.*}} @_ZN23target_cpu_on_functions12not_exported{{.*}}() {{.*}} #0\n+// CHECK-LABEL: ; target_cpu_on_functions::not_exported\n+// CHECK-NEXT: ; Function Attrs:\n+// CHECK-NEXT: define {{.*}}() {{.*}} #0\n fn not_exported() {}\n \n // CHECK: attributes #0 = {{.*}} \"target-cpu\"=\"{{.*}}\""}, {"sha": "54526e8ef23b3df36886334fb91d74d2bebfaca3", "filename": "src/test/run-make-fulldeps/a-b-a-linker-guard/Makefile", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Frun-make-fulldeps%2Fa-b-a-linker-guard%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Frun-make-fulldeps%2Fa-b-a-linker-guard%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fa-b-a-linker-guard%2FMakefile?ref=7840a0b753a065a41999f1fb6028f67d33e3fdd5", "patch": "@@ -4,9 +4,12 @@\n # of types, it will not run with a dylib that has a different set of\n # types.\n \n+# NOTE(eddyb) this test only works with the `legacy` mangling,\n+# and will probably get removed once `legacy` is gone.\n+\n all:\n-\t$(RUSTC) a.rs --cfg x -C prefer-dynamic\n-\t$(RUSTC) b.rs -C prefer-dynamic\n+\t$(RUSTC) a.rs --cfg x -C prefer-dynamic -Z symbol-mangling-version=legacy\n+\t$(RUSTC) b.rs -C prefer-dynamic -Z symbol-mangling-version=legacy\n \t$(call RUN,b)\n-\t$(RUSTC) a.rs --cfg y -C prefer-dynamic\n+\t$(RUSTC) a.rs --cfg y -C prefer-dynamic -Z symbol-mangling-version=legacy\n \t$(call FAIL,b)"}, {"sha": "451af809b22239f5c1fd61fc142f86c401c40b84", "filename": "src/test/run-make-fulldeps/stable-symbol-names/Makefile", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Frun-make-fulldeps%2Fstable-symbol-names%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Frun-make-fulldeps%2Fstable-symbol-names%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fstable-symbol-names%2FMakefile?ref=7840a0b753a065a41999f1fb6028f67d33e3fdd5", "patch": "@@ -3,14 +3,15 @@\n # The following command will:\n #  1. dump the symbols of a library using `nm`\n #  2. extract only those lines that we are interested in via `grep`\n-#  3. from those lines, extract just the symbol name via `sed`\n-#     (symbol names always start with \"_ZN\" and end with \"E\")\n+#  3. from those lines, extract just the symbol name via `sed`, which:\n+#    * always starts with \"_ZN\" and ends with \"E\" (`legacy` mangling)\n+#    * always starts with \"_R\" (`v0` mangling)\n #  4. sort those symbol names for deterministic comparison\n #  5. write the result into a file\n \n dump-symbols = nm \"$(TMPDIR)/lib$(1).rlib\" \\\n              | grep -E \"$(2)\" \\\n-             | sed \"s/.*\\(_ZN.*E\\).*/\\1/\" \\\n+             | sed -E \"s/.*(_ZN.*E|_R[a-zA-Z0-9_]*).*/\\1/\" \\\n              | sort \\\n              > \"$(TMPDIR)/$(1)$(3).nm\"\n "}, {"sha": "7901866015bf2ffa564a7a4b8e10ddb8961baeb4", "filename": "src/test/run-make-fulldeps/symbol-visibility/Makefile", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Frun-make-fulldeps%2Fsymbol-visibility%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Frun-make-fulldeps%2Fsymbol-visibility%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsymbol-visibility%2FMakefile?ref=7840a0b753a065a41999f1fb6028f67d33e3fdd5", "patch": "@@ -19,6 +19,9 @@ EXE_NAME=an_executable\n COMBINED_CDYLIB_NAME=libcombined_rlib_dylib.dylib\n endif\n \n+# `grep` regex for symbols produced by either `legacy` or `v0` mangling\n+RE_ANY_RUST_SYMBOL=\"_ZN.*h.*E\\|_R[a-zA-Z0-9_]+\"\n+\n all:\n \t$(RUSTC) -Zshare-generics=no an_rlib.rs\n \t$(RUSTC) -Zshare-generics=no a_cdylib.rs\n@@ -31,20 +34,20 @@ all:\n \t# Check that a cdylib exports the public #[no_mangle] functions of dependencies\n \t[ \"$$($(NM) $(TMPDIR)/$(CDYLIB_NAME) | grep -c public_c_function_from_rlib)\" -eq \"1\" ]\n \t# Check that a cdylib DOES NOT export any public Rust functions\n-\t[ \"$$($(NM) $(TMPDIR)/$(CDYLIB_NAME) | grep -c _ZN.*h.*E)\" -eq \"0\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(CDYLIB_NAME) | grep -c $(RE_ANY_RUST_SYMBOL))\" -eq \"0\" ]\n \n \t# Check that a Rust dylib exports its monomorphic functions\n \t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_c_function_from_rust_dylib)\" -eq \"1\" ]\n-\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c _ZN.*public_rust_function_from_rust_dylib.*E)\" -eq \"1\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_rust_function_from_rust_dylib)\" -eq \"1\" ]\n \t# Check that a Rust dylib does not export generics if -Zshare-generics=no\n-\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c _ZN.*public_generic_function_from_rust_dylib.*E)\" -eq \"0\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_generic_function_from_rust_dylib)\" -eq \"0\" ]\n \n \n \t# Check that a Rust dylib exports the monomorphic functions from its dependencies\n \t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_c_function_from_rlib)\" -eq \"1\" ]\n \t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_rust_function_from_rlib)\" -eq \"1\" ]\n \t# Check that a Rust dylib does not export generics if -Zshare-generics=no\n-\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c _ZN.*public_generic_function_from_rlib.*E)\" -eq \"0\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_generic_function_from_rlib)\" -eq \"0\" ]\n \n \t# Check that an executable does not export any dynamic symbols\n \t[ \"$$($(NM) $(TMPDIR)/$(EXE_NAME) | grep -c public_c_function_from_rlib)\" -eq \"0\" ]\n@@ -58,7 +61,7 @@ all:\n \t# Check that a cdylib exports the public #[no_mangle] functions of dependencies\n \t[ \"$$($(NM) $(TMPDIR)/$(COMBINED_CDYLIB_NAME) | grep -c public_c_function_from_rlib)\" -eq \"1\" ]\n \t# Check that a cdylib DOES NOT export any public Rust functions\n-\t[ \"$$($(NM) $(TMPDIR)/$(COMBINED_CDYLIB_NAME) | grep -c _ZN.*h.*E)\" -eq \"0\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(COMBINED_CDYLIB_NAME) | grep -c $(RE_ANY_RUST_SYMBOL))\" -eq \"0\" ]\n \n \n \t$(RUSTC) -Zshare-generics=yes an_rlib.rs\n@@ -71,17 +74,17 @@ all:\n \t# Check that a cdylib exports the public #[no_mangle] functions of dependencies\n \t[ \"$$($(NM) $(TMPDIR)/$(CDYLIB_NAME) | grep -c public_c_function_from_rlib)\" -eq \"1\" ]\n \t# Check that a cdylib DOES NOT export any public Rust functions\n-\t[ \"$$($(NM) $(TMPDIR)/$(CDYLIB_NAME) | grep -c _ZN.*h.*E)\" -eq \"0\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(CDYLIB_NAME) | grep -c $(RE_ANY_RUST_SYMBOL))\" -eq \"0\" ]\n \n \t# Check that a Rust dylib exports its monomorphic functions, including generics this time\n \t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_c_function_from_rust_dylib)\" -eq \"1\" ]\n-\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c _ZN.*public_rust_function_from_rust_dylib.*E)\" -eq \"1\" ]\n-\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c _ZN.*public_generic_function_from_rust_dylib.*E)\" -eq \"1\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_rust_function_from_rust_dylib)\" -eq \"1\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_generic_function_from_rust_dylib)\" -eq \"1\" ]\n \n \t# Check that a Rust dylib exports the monomorphic functions from its dependencies\n \t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_c_function_from_rlib)\" -eq \"1\" ]\n \t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_rust_function_from_rlib)\" -eq \"1\" ]\n-\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c _ZN.*public_generic_function_from_rlib.*E)\" -eq \"1\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_generic_function_from_rlib)\" -eq \"1\" ]\n \n \t# Check that an executable does not export any dynamic symbols\n \t[ \"$$($(NM) $(TMPDIR)/$(EXE_NAME) | grep -c public_c_function_from_rlib)\" -eq \"0\" ]"}, {"sha": "c73ba293ee25b998ed573b5e2e32a9a612931bec", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=7840a0b753a065a41999f1fb6028f67d33e3fdd5", "patch": "@@ -42,6 +42,21 @@ fn expected(fn_name: &str) -> String {\n     format!(\" backtrace::{}\", fn_name)\n }\n \n+fn contains_verbose_expected(s: &str, fn_name: &str) -> bool {\n+    // HACK(eddyb) work around the fact that verbosely demangled stack traces\n+    // (from `RUST_BACKTRACE=full`, or, as is the case here, panic-in-panic)\n+    // may contain symbols with hashes in them, i.e. `backtrace[...]::`.\n+    let prefix = \" backtrace\";\n+    let suffix = &format!(\"::{}\", fn_name);\n+    s.match_indices(prefix).any(|(i, _)| {\n+        s[i + prefix.len()..]\n+            .trim_start_matches('[')\n+            .trim_start_matches(char::is_alphanumeric)\n+            .trim_start_matches(']')\n+            .starts_with(suffix)\n+    })\n+}\n+\n fn runtest(me: &str) {\n     // Make sure that the stack trace is printed\n     let p = template(me).arg(\"fail\").env(\"RUST_BACKTRACE\", \"1\").spawn().unwrap();\n@@ -79,7 +94,7 @@ fn runtest(me: &str) {\n     let s = str::from_utf8(&out.stderr).unwrap();\n     // loosened the following from double::h to double:: due to\n     // spurious failures on mac, 32bit, optimized\n-    assert!(s.contains(\"stack backtrace\") && s.contains(&expected(\"double\")),\n+    assert!(s.contains(\"stack backtrace\") && contains_verbose_expected(s, \"double\"),\n             \"bad output3: {}\", s);\n \n     // Make sure a stack trace isn't printed too many times"}, {"sha": "5f5ee7cfe4410b8709353440f67dac1af550e316", "filename": "src/test/run-pass/struct-ctor-mangling.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Frun-pass%2Fstruct-ctor-mangling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Frun-pass%2Fstruct-ctor-mangling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-ctor-mangling.rs?ref=7840a0b753a065a41999f1fb6028f67d33e3fdd5", "patch": "@@ -0,0 +1,12 @@\n+fn size_of_val<T>(_: &T) -> usize {\n+    std::mem::size_of::<T>()\n+}\n+\n+struct Foo(i64);\n+\n+// Test that the (symbol) mangling of `Foo` (the `struct` type) and that of\n+// `typeof Foo` (the function type of the `struct` constructor) don't collide.\n+fn main() {\n+    size_of_val(&Foo(0));\n+    size_of_val(&Foo);\n+}"}, {"sha": "e26168dcfc48826d503ef8ba70582587cefb697a", "filename": "src/test/ui/symbol-names/basic.legacy.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Fui%2Fsymbol-names%2Fbasic.legacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Fui%2Fsymbol-names%2Fbasic.legacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fbasic.legacy.stderr?ref=7840a0b753a065a41999f1fb6028f67d33e3fdd5", "patch": "@@ -0,0 +1,26 @@\n+error: symbol-name(_ZN5basic4main17hd72940ef9669d526E)\n+  --> $DIR/basic.rs:7:1\n+   |\n+LL | #[rustc_symbol_name]\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: demangling(basic::main::hd72940ef9669d526)\n+  --> $DIR/basic.rs:7:1\n+   |\n+LL | #[rustc_symbol_name]\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: demangling-alt(basic::main)\n+  --> $DIR/basic.rs:7:1\n+   |\n+LL | #[rustc_symbol_name]\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: def-path(main)\n+  --> $DIR/basic.rs:14:1\n+   |\n+LL | #[rustc_def_path]\n+   | ^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "aa88184eddfd462b69332a68cdaf588cba37dedb", "filename": "src/test/ui/symbol-names/basic.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Fui%2Fsymbol-names%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Fui%2Fsymbol-names%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fbasic.rs?ref=7840a0b753a065a41999f1fb6028f67d33e3fdd5", "patch": "@@ -1,6 +1,18 @@\n+// revisions: legacy v0\n+//[legacy]compile-flags: -Z symbol-mangling-version=legacy\n+    //[v0]compile-flags: -Z symbol-mangling-version=v0\n+\n #![feature(rustc_attrs)]\n \n-#[rustc_symbol_name] //~ ERROR _ZN5basic4main\n-#[rustc_def_path] //~ ERROR def-path(main)\n+#[rustc_symbol_name]\n+//[legacy]~^ ERROR symbol-name(_ZN5basic4main\n+//[legacy]~| ERROR demangling(basic::main\n+//[legacy]~| ERROR demangling-alt(basic::main)\n+ //[v0]~^^^^ ERROR symbol-name(_RNvCs4fqI2P2rA04_5basic4main)\n+    //[v0]~| ERROR demangling(basic[317d481089b8c8fe]::main)\n+    //[v0]~| ERROR demangling-alt(basic::main)\n+#[rustc_def_path]\n+//[legacy]~^ ERROR def-path(main)\n+   //[v0]~^^ ERROR def-path(main)\n fn main() {\n }"}, {"sha": "7539cbada8b7b5a258d4993fc1ad08fedad63372", "filename": "src/test/ui/symbol-names/basic.stderr", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/75f464481ed8c924086fc0b9a2d31841bbdbcabd/src%2Ftest%2Fui%2Fsymbol-names%2Fbasic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75f464481ed8c924086fc0b9a2d31841bbdbcabd/src%2Ftest%2Fui%2Fsymbol-names%2Fbasic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fbasic.stderr?ref=75f464481ed8c924086fc0b9a2d31841bbdbcabd", "patch": "@@ -1,14 +0,0 @@\n-error: symbol-name(_ZN5basic4main17hd72940ef9669d526E)\n-  --> $DIR/basic.rs:3:1\n-   |\n-LL | #[rustc_symbol_name]\n-   | ^^^^^^^^^^^^^^^^^^^^\n-\n-error: def-path(main)\n-  --> $DIR/basic.rs:4:1\n-   |\n-LL | #[rustc_def_path]\n-   | ^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n-"}, {"sha": "40a39daaedce14978b548fa3a750ff0d114001ab", "filename": "src/test/ui/symbol-names/basic.v0.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Fui%2Fsymbol-names%2Fbasic.v0.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Fui%2Fsymbol-names%2Fbasic.v0.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fbasic.v0.stderr?ref=7840a0b753a065a41999f1fb6028f67d33e3fdd5", "patch": "@@ -0,0 +1,26 @@\n+error: symbol-name(_RNvCs4fqI2P2rA04_5basic4main)\n+  --> $DIR/basic.rs:7:1\n+   |\n+LL | #[rustc_symbol_name]\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: demangling(basic[317d481089b8c8fe]::main)\n+  --> $DIR/basic.rs:7:1\n+   |\n+LL | #[rustc_symbol_name]\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: demangling-alt(basic::main)\n+  --> $DIR/basic.rs:7:1\n+   |\n+LL | #[rustc_symbol_name]\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: def-path(main)\n+  --> $DIR/basic.rs:14:1\n+   |\n+LL | #[rustc_def_path]\n+   | ^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "c1d22a919d9004197ec5208d08f15b6935cc6091", "filename": "src/test/ui/symbol-names/impl1.legacy.stderr", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.legacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.legacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.legacy.stderr?ref=7840a0b753a065a41999f1fb6028f67d33e3fdd5", "patch": "@@ -0,0 +1,74 @@\n+error: symbol-name(_ZN5impl13foo3Foo3bar17he53b9bee7600ed8dE)\n+  --> $DIR/impl1.rs:13:9\n+   |\n+LL |         #[rustc_symbol_name]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: demangling(impl1::foo::Foo::bar::he53b9bee7600ed8d)\n+  --> $DIR/impl1.rs:13:9\n+   |\n+LL |         #[rustc_symbol_name]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: demangling-alt(impl1::foo::Foo::bar)\n+  --> $DIR/impl1.rs:13:9\n+   |\n+LL |         #[rustc_symbol_name]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: def-path(foo::Foo::bar)\n+  --> $DIR/impl1.rs:20:9\n+   |\n+LL |         #[rustc_def_path]\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error: symbol-name(_ZN5impl13bar33_$LT$impl$u20$impl1..foo..Foo$GT$3baz17h86c41f0462d901d4E)\n+  --> $DIR/impl1.rs:31:9\n+   |\n+LL |         #[rustc_symbol_name]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: demangling(impl1::bar::<impl impl1::foo::Foo>::baz::h86c41f0462d901d4)\n+  --> $DIR/impl1.rs:31:9\n+   |\n+LL |         #[rustc_symbol_name]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: demangling-alt(impl1::bar::<impl impl1::foo::Foo>::baz)\n+  --> $DIR/impl1.rs:31:9\n+   |\n+LL |         #[rustc_symbol_name]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: def-path(bar::<impl foo::Foo>::baz)\n+  --> $DIR/impl1.rs:38:9\n+   |\n+LL |         #[rustc_def_path]\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error: symbol-name(_ZN198_$LT$$u5b$$RF$dyn$u20$impl1..Foo$u2b$Assoc$u20$$u3d$$u20$extern$u20$$u22$C$u22$$u20$fn$LP$$RF$u8$RP$$u2b$impl1..AutoTrait$u3b$$u20$_$u5d$$u20$as$u20$impl1..main..$u7b$$u7b$closure$u7d$$u7d$..Bar$GT$6method17h6f205aef6a8ccc7bE)\n+  --> $DIR/impl1.rs:63:13\n+   |\n+LL |             #[rustc_symbol_name]\n+   |             ^^^^^^^^^^^^^^^^^^^^\n+\n+error: demangling(<[&dyn impl1::Foo+Assoc = extern \"C\" fn(&u8)+impl1::AutoTrait; _] as impl1::main::{{closure}}::Bar>::method::h6f205aef6a8ccc7b)\n+  --> $DIR/impl1.rs:63:13\n+   |\n+LL |             #[rustc_symbol_name]\n+   |             ^^^^^^^^^^^^^^^^^^^^\n+\n+error: demangling-alt(<[&dyn impl1::Foo+Assoc = extern \"C\" fn(&u8)+impl1::AutoTrait; _] as impl1::main::{{closure}}::Bar>::method)\n+  --> $DIR/impl1.rs:63:13\n+   |\n+LL |             #[rustc_symbol_name]\n+   |             ^^^^^^^^^^^^^^^^^^^^\n+\n+error: def-path(<[&dyn Foo<Assoc = for<'r> extern \"C\" fn(&'r u8)> + AutoTrait; _] as main::{{closure}}#1::Bar>::method)\n+  --> $DIR/impl1.rs:70:13\n+   |\n+LL |             #[rustc_def_path]\n+   |             ^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 12 previous errors\n+"}, {"sha": "9ed93bb98185a5dad2209dee6a48ab1607495293", "filename": "src/test/ui/symbol-names/impl1.rs", "status": "modified", "additions": 56, "deletions": 5, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.rs?ref=7840a0b753a065a41999f1fb6028f67d33e3fdd5", "patch": "@@ -1,12 +1,25 @@\n-#![feature(rustc_attrs)]\n+// ignore-tidy-linelength\n+// revisions: legacy v0\n+//[legacy]compile-flags: -Z symbol-mangling-version=legacy\n+    //[v0]compile-flags: -Z symbol-mangling-version=v0\n+\n+#![feature(optin_builtin_traits, rustc_attrs)]\n #![allow(dead_code)]\n \n mod foo {\n     pub struct Foo { x: u32 }\n \n     impl Foo {\n-        #[rustc_symbol_name] //~ ERROR _ZN5impl13foo3Foo3bar\n-        #[rustc_def_path] //~ ERROR def-path(foo::Foo::bar)\n+        #[rustc_symbol_name]\n+        //[legacy]~^ ERROR symbol-name(_ZN5impl13foo3Foo3bar\n+        //[legacy]~| ERROR demangling(impl1::foo::Foo::bar\n+        //[legacy]~| ERROR demangling-alt(impl1::foo::Foo::bar)\n+         //[v0]~^^^^ ERROR symbol-name(_RNvMNtCs4fqI2P2rA04_5impl13fooNtB2_3Foo3bar)\n+            //[v0]~| ERROR demangling(<impl1[317d481089b8c8fe]::foo::Foo>::bar)\n+            //[v0]~| ERROR demangling-alt(<impl1::foo::Foo>::bar)\n+        #[rustc_def_path]\n+        //[legacy]~^ ERROR def-path(foo::Foo::bar)\n+           //[v0]~^^ ERROR def-path(foo::Foo::bar)\n         fn bar() { }\n     }\n }\n@@ -15,11 +28,49 @@ mod bar {\n     use foo::Foo;\n \n     impl Foo {\n-        #[rustc_symbol_name] //~ ERROR _ZN5impl13bar33_$LT$impl$u20$impl1..foo..Foo$GT$3baz\n-        #[rustc_def_path] //~ ERROR def-path(bar::<impl foo::Foo>::baz)\n+        #[rustc_symbol_name]\n+        //[legacy]~^ ERROR symbol-name(_ZN5impl13bar33_$LT$impl$u20$impl1..foo..Foo$GT$3baz\n+        //[legacy]~| ERROR demangling(impl1::bar::<impl impl1::foo::Foo>::baz\n+        //[legacy]~| ERROR demangling-alt(impl1::bar::<impl impl1::foo::Foo>::baz)\n+         //[v0]~^^^^ ERROR symbol-name(_RNvMNtCs4fqI2P2rA04_5impl13barNtNtB4_3foo3Foo3baz)\n+            //[v0]~| ERROR demangling(<impl1[317d481089b8c8fe]::foo::Foo>::baz)\n+            //[v0]~| ERROR demangling-alt(<impl1::foo::Foo>::baz)\n+        #[rustc_def_path]\n+        //[legacy]~^ ERROR def-path(bar::<impl foo::Foo>::baz)\n+           //[v0]~^^ ERROR def-path(bar::<impl foo::Foo>::baz)\n         fn baz() { }\n     }\n }\n \n+trait Foo {\n+    type Assoc;\n+}\n+\n+auto trait AutoTrait {}\n+\n fn main() {\n+    // Test closure mangling, and disambiguators.\n+    || {};\n+    || {\n+        trait Bar {\n+            fn method(&self) {}\n+        }\n+\n+        // Test type mangling, by putting them in an `impl` header.\n+        // FIXME(eddyb) test C varargs when `core::ffi::VaList` stops leaking into the signature\n+        // (which is a problem because `core` has an unpredictable hash) - see also #44930.\n+        impl Bar for [&'_ (dyn Foo<Assoc = extern fn(&u8, /*...*/)> + AutoTrait); 3] {\n+            #[rustc_symbol_name]\n+            //[legacy]~^ ERROR symbol-name(_ZN198_$LT$$u5b$$RF$dyn$u20$impl1..Foo$u2b$Assoc$u20$$u3d$$u20$extern$u20$$u22$C$u22$$u20$fn$LP$$RF$u8$RP$$u2b$impl1..AutoTrait$u3b$$u20$_$u5d$$u20$as$u20$impl1..main..$u7b$$u7b$closure$u7d$$u7d$..Bar$GT$6method\n+            //[legacy]~| ERROR demangling(<[&dyn impl1::Foo+Assoc = extern \"C\" fn(&u8)+impl1::AutoTrait; _] as impl1::main::{{closure}}::Bar>::method\n+            //[legacy]~| ERROR demangling-alt(<[&dyn impl1::Foo+Assoc = extern \"C\" fn(&u8)+impl1::AutoTrait; _] as impl1::main::{{closure}}::Bar>::method)\n+             //[v0]~^^^^ ERROR symbol-name(_RNvXNCNvCs4fqI2P2rA04_5impl14mains_0ARDNtB6_3Foop5AssocFG0_KCRL0_hEuNtB6_9AutoTraitEL_j3_NtB2_3Bar6method)\n+                //[v0]~| ERROR demangling(<[&dyn impl1[317d481089b8c8fe]::Foo<Assoc = for<'a, 'b> extern \"C\" fn(&'b u8)> + impl1[317d481089b8c8fe]::AutoTrait; 3: usize] as impl1[317d481089b8c8fe]::main::{closure#1}::Bar>::method)\n+                //[v0]~| ERROR demangling-alt(<[&dyn impl1::Foo<Assoc = for<'a, 'b> extern \"C\" fn(&'b u8)> + impl1::AutoTrait; 3] as impl1::main::{closure#1}::Bar>::method)\n+            #[rustc_def_path]\n+            //[legacy]~^ ERROR def-path(<[&dyn Foo<Assoc = for<'r> extern \"C\" fn(&'r u8)> + AutoTrait; _] as main::{{closure}}#1::Bar>::method)\n+               //[v0]~^^ ERROR def-path(<[&dyn Foo<Assoc = for<'r> extern \"C\" fn(&'r u8)> + AutoTrait; _] as main::{{closure}}#1::Bar>::method)\n+            fn method(&self) {}\n+        }\n+    };\n }"}, {"sha": "20e48782a3a9e5dfeafeab1c854b5cc9234155e6", "filename": "src/test/ui/symbol-names/impl1.stderr", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/75f464481ed8c924086fc0b9a2d31841bbdbcabd/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75f464481ed8c924086fc0b9a2d31841bbdbcabd/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.stderr?ref=75f464481ed8c924086fc0b9a2d31841bbdbcabd", "patch": "@@ -1,26 +0,0 @@\n-error: symbol-name(_ZN5impl13foo3Foo3bar17he53b9bee7600ed8dE)\n-  --> $DIR/impl1.rs:8:9\n-   |\n-LL |         #[rustc_symbol_name]\n-   |         ^^^^^^^^^^^^^^^^^^^^\n-\n-error: def-path(foo::Foo::bar)\n-  --> $DIR/impl1.rs:9:9\n-   |\n-LL |         #[rustc_def_path]\n-   |         ^^^^^^^^^^^^^^^^^\n-\n-error: symbol-name(_ZN5impl13bar33_$LT$impl$u20$impl1..foo..Foo$GT$3baz17h86c41f0462d901d4E)\n-  --> $DIR/impl1.rs:18:9\n-   |\n-LL |         #[rustc_symbol_name]\n-   |         ^^^^^^^^^^^^^^^^^^^^\n-\n-error: def-path(bar::<impl foo::Foo>::baz)\n-  --> $DIR/impl1.rs:19:9\n-   |\n-LL |         #[rustc_def_path]\n-   |         ^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 4 previous errors\n-"}, {"sha": "1c4b256c9e9339412a14776fe81dbded2f697485", "filename": "src/test/ui/symbol-names/impl1.v0.stderr", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.v0.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.v0.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.v0.stderr?ref=7840a0b753a065a41999f1fb6028f67d33e3fdd5", "patch": "@@ -0,0 +1,74 @@\n+error: symbol-name(_RNvMNtCs4fqI2P2rA04_5impl13fooNtB2_3Foo3bar)\n+  --> $DIR/impl1.rs:13:9\n+   |\n+LL |         #[rustc_symbol_name]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: demangling(<impl1[317d481089b8c8fe]::foo::Foo>::bar)\n+  --> $DIR/impl1.rs:13:9\n+   |\n+LL |         #[rustc_symbol_name]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: demangling-alt(<impl1::foo::Foo>::bar)\n+  --> $DIR/impl1.rs:13:9\n+   |\n+LL |         #[rustc_symbol_name]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: def-path(foo::Foo::bar)\n+  --> $DIR/impl1.rs:20:9\n+   |\n+LL |         #[rustc_def_path]\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error: symbol-name(_RNvMNtCs4fqI2P2rA04_5impl13barNtNtB4_3foo3Foo3baz)\n+  --> $DIR/impl1.rs:31:9\n+   |\n+LL |         #[rustc_symbol_name]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: demangling(<impl1[317d481089b8c8fe]::foo::Foo>::baz)\n+  --> $DIR/impl1.rs:31:9\n+   |\n+LL |         #[rustc_symbol_name]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: demangling-alt(<impl1::foo::Foo>::baz)\n+  --> $DIR/impl1.rs:31:9\n+   |\n+LL |         #[rustc_symbol_name]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: def-path(bar::<impl foo::Foo>::baz)\n+  --> $DIR/impl1.rs:38:9\n+   |\n+LL |         #[rustc_def_path]\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error: symbol-name(_RNvXNCNvCs4fqI2P2rA04_5impl14mains_0ARDNtB6_3Foop5AssocFG0_KCRL0_hEuNtB6_9AutoTraitEL_j3_NtB2_3Bar6method)\n+  --> $DIR/impl1.rs:63:13\n+   |\n+LL |             #[rustc_symbol_name]\n+   |             ^^^^^^^^^^^^^^^^^^^^\n+\n+error: demangling(<[&dyn impl1[317d481089b8c8fe]::Foo<Assoc = for<'a, 'b> extern \"C\" fn(&'b u8)> + impl1[317d481089b8c8fe]::AutoTrait; 3: usize] as impl1[317d481089b8c8fe]::main::{closure#1}::Bar>::method)\n+  --> $DIR/impl1.rs:63:13\n+   |\n+LL |             #[rustc_symbol_name]\n+   |             ^^^^^^^^^^^^^^^^^^^^\n+\n+error: demangling-alt(<[&dyn impl1::Foo<Assoc = for<'a, 'b> extern \"C\" fn(&'b u8)> + impl1::AutoTrait; 3] as impl1::main::{closure#1}::Bar>::method)\n+  --> $DIR/impl1.rs:63:13\n+   |\n+LL |             #[rustc_symbol_name]\n+   |             ^^^^^^^^^^^^^^^^^^^^\n+\n+error: def-path(<[&dyn Foo<Assoc = for<'r> extern \"C\" fn(&'r u8)> + AutoTrait; _] as main::{{closure}}#1::Bar>::method)\n+  --> $DIR/impl1.rs:70:13\n+   |\n+LL |             #[rustc_def_path]\n+   |             ^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 12 previous errors\n+"}, {"sha": "0bbe424aa025b99574792a4eb2534d081daaabc0", "filename": "src/test/ui/symbol-names/issue-60925.legacy.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-60925.legacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-60925.legacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-60925.legacy.stderr?ref=7840a0b753a065a41999f1fb6028f67d33e3fdd5", "patch": "@@ -0,0 +1,20 @@\n+error: symbol-name(_ZN11issue_609253foo36Foo$LT$issue_60925..llv$6d$..Foo$GT$3foo17h059a991a004536adE)\n+  --> $DIR/issue-60925.rs:21:9\n+   |\n+LL |         #[rustc_symbol_name]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: demangling(issue_60925::foo::Foo<issue_60925::llv$6d$..Foo$GT$::foo::h059a991a004536ad)\n+  --> $DIR/issue-60925.rs:21:9\n+   |\n+LL |         #[rustc_symbol_name]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: demangling-alt(issue_60925::foo::Foo<issue_60925::llv$6d$..Foo$GT$::foo)\n+  --> $DIR/issue-60925.rs:21:9\n+   |\n+LL |         #[rustc_symbol_name]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "09d68eebb950e77377363f24b46cf4fe7386eb57", "filename": "src/test/ui/symbol-names/issue-60925.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-60925.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-60925.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-60925.rs?ref=7840a0b753a065a41999f1fb6028f67d33e3fdd5", "patch": "@@ -1,8 +1,13 @@\n+// ignore-tidy-linelength\n+// revisions: legacy v0\n+//[legacy]compile-flags: -Z symbol-mangling-version=legacy\n+    //[v0]compile-flags: -Z symbol-mangling-version=v0\n+\n #![feature(rustc_attrs)]\n \n // This test is the same code as in ui/issue-53912.rs but this test checks that the symbol mangling\n // fix produces the correct result, whereas that test just checks that the reproduction compiles\n-// successfully and doesn't segfault\n+// successfully and doesn't crash LLVM\n \n fn dummy() {}\n \n@@ -14,7 +19,12 @@ mod foo {\n \n     impl Foo<::llvm::Foo> {\n         #[rustc_symbol_name]\n-//~^ ERROR _ZN11issue_609253foo36Foo$LT$issue_60925..llv$6d$..Foo$GT$3foo17h059a991a004536adE\n+        //[legacy]~^ ERROR symbol-name(_ZN11issue_609253foo36Foo$LT$issue_60925..llv$6d$..Foo$GT$3foo\n+        //[legacy]~| ERROR demangling(issue_60925::foo::Foo<issue_60925::llv$6d$..Foo$GT$::foo\n+        //[legacy]~| ERROR demangling-alt(issue_60925::foo::Foo<issue_60925::llv$6d$..Foo$GT$::foo)\n+         //[v0]~^^^^ ERROR symbol-name(_RNvMNtCs4fqI2P2rA04_11issue_609253fooINtB2_3FooNtNtB4_4llvm3FooE3foo)\n+            //[v0]~| ERROR demangling(<issue_60925[317d481089b8c8fe]::foo::Foo<issue_60925[317d481089b8c8fe]::llvm::Foo>>::foo)\n+            //[v0]~| ERROR demangling-alt(<issue_60925::foo::Foo<issue_60925::llvm::Foo>>::foo)\n         pub(crate) fn foo() {\n             for _ in 0..0 {\n                 for _ in &[::dummy()] {"}, {"sha": "ae753f0cebbcdf7b4f36c2bebbac69b3762ece10", "filename": "src/test/ui/symbol-names/issue-60925.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-60925.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-60925.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-60925.stderr?ref=7840a0b753a065a41999f1fb6028f67d33e3fdd5", "patch": "@@ -4,5 +4,17 @@ error: symbol-name(_ZN11issue_609253foo36Foo$LT$issue_60925..llv$6d$..Foo$GT$3fo\n LL |         #[rustc_symbol_name]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error: demangling(issue_60925::foo::Foo<issue_60925::llv$6d$..Foo$GT$::foo::h059a991a004536ad)\n+  --> $DIR/issue-60925.rs:16:9\n+   |\n+LL |         #[rustc_symbol_name]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: demangling-alt(issue_60925::foo::Foo<issue_60925::llv$6d$..Foo$GT$::foo)\n+  --> $DIR/issue-60925.rs:16:9\n+   |\n+LL |         #[rustc_symbol_name]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n "}, {"sha": "5ead40211d20ddb7a98e4497a8e4244316fdffa4", "filename": "src/test/ui/symbol-names/issue-60925.v0.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-60925.v0.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7840a0b753a065a41999f1fb6028f67d33e3fdd5/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-60925.v0.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-60925.v0.stderr?ref=7840a0b753a065a41999f1fb6028f67d33e3fdd5", "patch": "@@ -0,0 +1,20 @@\n+error: symbol-name(_RNvMNtCs4fqI2P2rA04_11issue_609253fooINtB2_3FooNtNtB4_4llvm3FooE3foo)\n+  --> $DIR/issue-60925.rs:21:9\n+   |\n+LL |         #[rustc_symbol_name]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: demangling(<issue_60925[317d481089b8c8fe]::foo::Foo<issue_60925[317d481089b8c8fe]::llvm::Foo>>::foo)\n+  --> $DIR/issue-60925.rs:21:9\n+   |\n+LL |         #[rustc_symbol_name]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: demangling-alt(<issue_60925::foo::Foo<issue_60925::llvm::Foo>>::foo)\n+  --> $DIR/issue-60925.rs:21:9\n+   |\n+LL |         #[rustc_symbol_name]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+"}]}