{"sha": "53e03fb7c10f39229241fedc001a2c28ffb569e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzZTAzZmI3YzEwZjM5MjI5MjQxZmVkYzAwMWEyYzI4ZmZiNTY5ZTY=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-12-20T00:39:37Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-12-22T15:20:23Z"}, "message": "Make the special \"missing patterns\" constructor real", "tree": {"sha": "95cd26e52c6d651f57e3680fc43addc17dfc4273", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95cd26e52c6d651f57e3680fc43addc17dfc4273"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53e03fb7c10f39229241fedc001a2c28ffb569e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53e03fb7c10f39229241fedc001a2c28ffb569e6", "html_url": "https://github.com/rust-lang/rust/commit/53e03fb7c10f39229241fedc001a2c28ffb569e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53e03fb7c10f39229241fedc001a2c28ffb569e6/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a541cea354fe5866cf2addafe730c0d7c0dd0c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a541cea354fe5866cf2addafe730c0d7c0dd0c2", "html_url": "https://github.com/rust-lang/rust/commit/2a541cea354fe5866cf2addafe730c0d7c0dd0c2"}], "stats": {"total": 121, "additions": 57, "deletions": 64}, "files": [{"sha": "da7b0e62503969ac08da544c58f50c5b30c3807e", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 46, "deletions": 62, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/53e03fb7c10f39229241fedc001a2c28ffb569e6/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e03fb7c10f39229241fedc001a2c28ffb569e6/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=53e03fb7c10f39229241fedc001a2c28ffb569e6", "patch": "@@ -607,6 +607,9 @@ pub(super) enum Constructor<'tcx> {\n     /// Fake extra constructor for enums that aren't allowed to be matched exhaustively. Also used\n     /// for those types for which we cannot list constructors explicitly, like `f64` and `str`.\n     NonExhaustive,\n+    /// Stands for constructors that are not seen in the matrix, as explained in the documentation\n+    /// for [`SplitWildcard`].\n+    Missing,\n     /// Wildcard pattern.\n     Wildcard,\n }\n@@ -758,8 +761,8 @@ impl<'tcx> Constructor<'tcx> {\n         match (self, other) {\n             // Wildcards cover anything\n             (_, Wildcard) => true,\n-            // Wildcards are only covered by wildcards\n-            (Wildcard, _) => false,\n+            // The missing ctors are not covered by anything in the matrix except wildcards.\n+            (Missing | Wildcard, _) => false,\n \n             (Single, Single) => true,\n             (Variant(self_id), Variant(other_id)) => self_id == other_id,\n@@ -832,7 +835,7 @@ impl<'tcx> Constructor<'tcx> {\n                 .any(|other| slice.is_covered_by(other)),\n             // This constructor is never covered by anything else\n             NonExhaustive => false,\n-            Str(..) | FloatRange(..) | Opaque | Wildcard => {\n+            Str(..) | FloatRange(..) | Opaque | Missing | Wildcard => {\n                 span_bug!(pcx.span, \"found unexpected ctor in all_ctors: {:?}\", self)\n             }\n         }\n@@ -1002,7 +1005,7 @@ impl<'tcx> SplitWildcard<'tcx> {\n     }\n \n     /// Iterate over the constructors for this type that are not present in the matrix.\n-    fn iter_missing<'a, 'p>(\n+    pub(super) fn iter_missing<'a, 'p>(\n         &'a self,\n         pcx: PatCtxt<'a, 'p, 'tcx>,\n     ) -> impl Iterator<Item = &'a Constructor<'tcx>> + Captures<'p> {\n@@ -1013,64 +1016,45 @@ impl<'tcx> SplitWildcard<'tcx> {\n     /// top of the file, if any constructors are missing we can ignore the present ones.\n     fn into_ctors(self, pcx: PatCtxt<'_, '_, 'tcx>) -> SmallVec<[Constructor<'tcx>; 1]> {\n         if self.any_missing(pcx) {\n-            // Some constructors are missing, thus we can specialize with the wildcard constructor,\n-            // which will stand for those constructors that are missing, and matches the same rows\n-            // as any of them (namely the wildcard rows).\n-            return smallvec![Wildcard];\n+            // Some constructors are missing, thus we can specialize with the special `Missing`\n+            // constructor, which stands for those constructors that are not seen in the matrix,\n+            // and matches the same rows as any of them (namely the wildcard rows). See the top of\n+            // the file for details.\n+            // However, when all constructors are missing we can also specialize with the full\n+            // `Wildcard` constructor. The difference will depend on what we want in diagnostics.\n+\n+            // If some constructors are missing, we typically want to report those constructors,\n+            // e.g.:\n+            // ```\n+            //     enum Direction { N, S, E, W }\n+            //     let Direction::N = ...;\n+            // ```\n+            // we can report 3 witnesses: `S`, `E`, and `W`.\n+            //\n+            // However, if the user didn't actually specify a constructor\n+            // in this arm, e.g., in\n+            // ```\n+            //     let x: (Direction, Direction, bool) = ...;\n+            //     let (_, _, false) = x;\n+            // ```\n+            // we don't want to show all 16 possible witnesses `(<direction-1>, <direction-2>,\n+            // true)` - we are satisfied with `(_, _, true)`. So if all constructors are missing we\n+            // prefer to report just a wildcard `_`.\n+            //\n+            // The exception is: if we are at the top-level, for example in an empty match, we\n+            // sometimes prefer reporting the list of constructors instead of just `_`.\n+            let report_when_all_missing = pcx.is_top_level && !IntRange::is_integral(pcx.ty);\n+            let ctor = if !self.matrix_ctors.is_empty() || report_when_all_missing {\n+                Missing\n+            } else {\n+                Wildcard\n+            };\n+            return smallvec![ctor];\n         }\n \n         // All the constructors are present in the matrix, so we just go through them all.\n         self.all_ctors\n     }\n-\n-    /// List the patterns corresponding to the missing constructors. In some cases, instead of\n-    /// listing all constructors of a given type, we prefer to simply report a wildcard.\n-    pub(super) fn report_missing_patterns<'p>(\n-        &self,\n-        pcx: PatCtxt<'_, 'p, 'tcx>,\n-    ) -> SmallVec<[Pat<'tcx>; 1]> {\n-        // There are 2 ways we can report a witness here.\n-        // Commonly, we can report all the \"free\"\n-        // constructors as witnesses, e.g., if we have:\n-        //\n-        // ```\n-        //     enum Direction { N, S, E, W }\n-        //     let Direction::N = ...;\n-        // ```\n-        //\n-        // we can report 3 witnesses: `S`, `E`, and `W`.\n-        //\n-        // However, there is a case where we don't want\n-        // to do this and instead report a single `_` witness:\n-        // if the user didn't actually specify a constructor\n-        // in this arm, e.g., in\n-        //\n-        // ```\n-        //     let x: (Direction, Direction, bool) = ...;\n-        //     let (_, _, false) = x;\n-        // ```\n-        //\n-        // we don't want to show all 16 possible witnesses\n-        // `(<direction-1>, <direction-2>, true)` - we are\n-        // satisfied with `(_, _, true)`. In this case,\n-        // `used_ctors` is empty.\n-        // The exception is: if we are at the top-level, for example in an empty match, we\n-        // sometimes prefer reporting the list of constructors instead of just `_`.\n-        let report_when_all_missing = pcx.is_top_level && !IntRange::is_integral(pcx.ty);\n-        if self.matrix_ctors.is_empty() && !report_when_all_missing {\n-            // All constructors are unused. Report only a wildcard\n-            // rather than each individual constructor.\n-            smallvec![Pat::wildcard_from_ty(pcx.ty)]\n-        } else {\n-            // Construct for each missing constructor a \"wild\" version of this\n-            // constructor, that matches everything that can be built with\n-            // it. For example, if `ctor` is a `Constructor::Variant` for\n-            // `Option::Some`, we get the pattern `Some(_)`.\n-            self.iter_missing(pcx)\n-                .map(|missing_ctor| Fields::wildcards(pcx, &missing_ctor).apply(pcx, missing_ctor))\n-                .collect()\n-        }\n-    }\n }\n \n /// Some fields need to be explicitly hidden away in certain cases; see the comment above the\n@@ -1211,9 +1195,8 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                 }\n                 _ => bug!(\"bad slice pattern {:?} {:?}\", constructor, ty),\n             },\n-            Str(..) | FloatRange(..) | IntRange(..) | NonExhaustive | Opaque | Wildcard => {\n-                Fields::empty()\n-            }\n+            Str(..) | FloatRange(..) | IntRange(..) | NonExhaustive | Opaque | Missing\n+            | Wildcard => Fields::empty(),\n         };\n         debug!(\"Fields::wildcards({:?}, {:?}) = {:#?}\", constructor, ty, ret);\n         ret\n@@ -1297,9 +1280,10 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n             &FloatRange(lo, hi, end) => PatKind::Range(PatRange { lo, hi, end }),\n             IntRange(range) => return range.to_pat(pcx.cx.tcx, pcx.ty),\n             NonExhaustive => PatKind::Wild,\n+            Wildcard => return Pat::wildcard_from_ty(pcx.ty),\n             Opaque => bug!(\"we should not try to apply an opaque constructor\"),\n-            Wildcard => bug!(\n-                \"trying to apply a wildcard constructor; this should have been done in `apply_constructors`\"\n+            Missing => bug!(\n+                \"trying to apply the `Missing` constructor; this should have been done in `apply_constructors`\"\n             ),\n         };\n "}, {"sha": "f74cb6ade47701abcd908cb2120bb16fd57d161c", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/53e03fb7c10f39229241fedc001a2c28ffb569e6/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e03fb7c10f39229241fedc001a2c28ffb569e6/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=53e03fb7c10f39229241fedc001a2c28ffb569e6", "patch": "@@ -784,10 +784,19 @@ impl<'tcx> Usefulness<'tcx> {\n     ) -> Self {\n         match self {\n             UsefulWithWitness(witnesses) => {\n-                let new_witnesses = if ctor.is_wildcard() {\n+                let new_witnesses = if matches!(ctor, Constructor::Missing) {\n                     let mut split_wildcard = SplitWildcard::new(pcx);\n                     split_wildcard.split(pcx, matrix.head_ctors(pcx.cx));\n-                    let new_patterns = split_wildcard.report_missing_patterns(pcx);\n+                    // Construct for each missing constructor a \"wild\" version of this\n+                    // constructor, that matches everything that can be built with\n+                    // it. For example, if `ctor` is a `Constructor::Variant` for\n+                    // `Option::Some`, we get the pattern `Some(_)`.\n+                    let new_patterns: Vec<_> = split_wildcard\n+                        .iter_missing(pcx)\n+                        .map(|missing_ctor| {\n+                            Fields::wildcards(pcx, missing_ctor).apply(pcx, missing_ctor)\n+                        })\n+                        .collect();\n                     witnesses\n                         .into_iter()\n                         .flat_map(|witness| {"}]}