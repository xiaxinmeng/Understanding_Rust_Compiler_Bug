{"sha": "a09e9c99a4c58ab6208aa44c4061df9aa2e40197", "node_id": "C_kwDOAAsO6NoAKGEwOWU5Yzk5YTRjNThhYjYyMDhhYTQ0YzQwNjFkZjlhYTJlNDAxOTc", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-08-06T21:00:49Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-08-06T21:08:10Z"}, "message": "Decode SourceFile out of order.", "tree": {"sha": "90ab06380487490bc784296005b09b5a4358a010", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90ab06380487490bc784296005b09b5a4358a010"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a09e9c99a4c58ab6208aa44c4061df9aa2e40197", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a09e9c99a4c58ab6208aa44c4061df9aa2e40197", "html_url": "https://github.com/rust-lang/rust/commit/a09e9c99a4c58ab6208aa44c4061df9aa2e40197", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a09e9c99a4c58ab6208aa44c4061df9aa2e40197/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f20ceb1c6fd7fa29a91677be548d6f8ca6c4b172", "url": "https://api.github.com/repos/rust-lang/rust/commits/f20ceb1c6fd7fa29a91677be548d6f8ca6c4b172", "html_url": "https://github.com/rust-lang/rust/commit/f20ceb1c6fd7fa29a91677be548d6f8ca6c4b172"}], "stats": {"total": 303, "additions": 154, "deletions": 149}, "files": [{"sha": "29acacbf3b3aca512b75326aa5a1b0735cfbdefb", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 94, "deletions": 93, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/a09e9c99a4c58ab6208aa44c4061df9aa2e40197/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09e9c99a4c58ab6208aa44c4061df9aa2e40197/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=a09e9c99a4c58ab6208aa44c4061df9aa2e40197", "patch": "@@ -37,6 +37,7 @@ use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{self, BytePos, ExpnId, Pos, Span, SyntaxContext, DUMMY_SP};\n \n use proc_macro::bridge::client::ProcMacro;\n+use std::cell::RefCell;\n use std::io;\n use std::iter::TrustedLen;\n use std::mem;\n@@ -99,7 +100,7 @@ pub(crate) struct CrateMetadata {\n     /// Proc macro descriptions for this crate, if it's a proc macro crate.\n     raw_proc_macros: Option<&'static [ProcMacro]>,\n     /// Source maps for code from the crate.\n-    source_map_import_info: OnceCell<Vec<ImportedSourceFile>>,\n+    source_map_import_info: RefCell<Vec<Option<ImportedSourceFile>>>,\n     /// For every definition in this crate, maps its `DefPathHash` to its `DefIndex`.\n     def_path_hash_map: DefPathHashMapRef<'static>,\n     /// Likewise for ExpnHash.\n@@ -143,7 +144,8 @@ pub(crate) struct CrateMetadata {\n }\n \n /// Holds information about a rustc_span::SourceFile imported from another crate.\n-/// See `imported_source_files()` for more information.\n+/// See `imported_source_file()` for more information.\n+#[derive(Clone)]\n struct ImportedSourceFile {\n     /// This SourceFile's byte-offset within the source_map of its original crate\n     original_start_pos: rustc_span::BytePos,\n@@ -528,7 +530,7 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for Span {\n         };\n \n         // Index of the file in the corresponding crate's list of encoded files.\n-        let metadata_index = usize::decode(decoder);\n+        let metadata_index = u32::decode(decoder);\n \n         // There are two possibilities here:\n         // 1. This is a 'local span', which is located inside a `SourceFile`\n@@ -556,10 +558,10 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for Span {\n         // to be based on the *foreign* crate (e.g. crate C), not the crate\n         // we are writing metadata for (e.g. crate B). This allows us to\n         // treat the 'local' and 'foreign' cases almost identically during deserialization:\n-        // we can call `imported_source_files` for the proper crate, and binary search\n+        // we can call `imported_source_file` for the proper crate, and binary search\n         // through the returned slice using our span.\n-        let imported_source_files = if tag == TAG_VALID_SPAN_LOCAL {\n-            decoder.cdata().imported_source_files(sess)\n+        let source_file = if tag == TAG_VALID_SPAN_LOCAL {\n+            decoder.cdata().imported_source_file(metadata_index, sess)\n         } else {\n             // When we encode a proc-macro crate, all `Span`s should be encoded\n             // with `TAG_VALID_SPAN_LOCAL`\n@@ -587,13 +589,9 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for Span {\n             decoder.last_source_file_index = 0;\n \n             let foreign_data = decoder.cdata().cstore.get_crate_data(cnum);\n-            foreign_data.imported_source_files(sess)\n+            foreign_data.imported_source_file(metadata_index, sess)\n         };\n \n-        // Optimize for the case that most spans within a translated item\n-        // originate from the same source_file.\n-        let source_file = &imported_source_files[metadata_index];\n-\n         // Make sure our binary search above is correct.\n         debug_assert!(\n             lo >= source_file.original_start_pos && lo <= source_file.original_end_pos,\n@@ -1438,7 +1436,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     ///\n     /// Proc macro crates don't currently export spans, so this function does not have\n     /// to work for them.\n-    fn imported_source_files(self, sess: &Session) -> &'a [ImportedSourceFile] {\n+    fn imported_source_file(self, source_file_index: u32, sess: &Session) -> ImportedSourceFile {\n         fn filter<'a>(sess: &Session, path: Option<&'a Path>) -> Option<&'a Path> {\n             path.filter(|_| {\n                 // Only spend time on further checks if we have what to translate *to*.\n@@ -1526,94 +1524,97 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             }\n         };\n \n-        self.cdata.source_map_import_info.get_or_init(|| {\n-            let external_source_map = self.root.source_map.decode(self);\n-\n-            external_source_map\n-                .enumerate()\n-                .map(|(source_file_index, source_file_to_import)| {\n-                    // We can't reuse an existing SourceFile, so allocate a new one\n-                    // containing the information we need.\n-                    let rustc_span::SourceFile {\n-                        mut name,\n-                        src_hash,\n-                        start_pos,\n-                        end_pos,\n-                        lines,\n-                        multibyte_chars,\n-                        non_narrow_chars,\n-                        normalized_pos,\n-                        name_hash,\n-                        ..\n-                    } = source_file_to_import;\n-\n-                    // If this file is under $sysroot/lib/rustlib/src/ but has not been remapped\n-                    // during rust bootstrapping by `remap-debuginfo = true`, and the user\n-                    // wish to simulate that behaviour by -Z simulate-remapped-rust-src-base,\n-                    // then we change `name` to a similar state as if the rust was bootstrapped\n-                    // with `remap-debuginfo = true`.\n-                    // This is useful for testing so that tests about the effects of\n-                    // `try_to_translate_virtual_to_real` don't have to worry about how the\n-                    // compiler is bootstrapped.\n-                    if let Some(virtual_dir) =\n-                        &sess.opts.unstable_opts.simulate_remapped_rust_src_base\n-                    {\n-                        if let Some(real_dir) = &sess.opts.real_rust_source_base_dir {\n-                            if let rustc_span::FileName::Real(ref mut old_name) = name {\n-                                if let rustc_span::RealFileName::LocalPath(local) = old_name {\n-                                    if let Ok(rest) = local.strip_prefix(real_dir) {\n-                                        *old_name = rustc_span::RealFileName::Remapped {\n-                                            local_path: None,\n-                                            virtual_name: virtual_dir.join(rest),\n-                                        };\n-                                    }\n+        let mut import_info = self.cdata.source_map_import_info.borrow_mut();\n+        for _ in import_info.len()..=(source_file_index as usize) {\n+            import_info.push(None);\n+        }\n+        import_info[source_file_index as usize]\n+            .get_or_insert_with(|| {\n+                let source_file_to_import = self\n+                    .root\n+                    .source_map\n+                    .get(self, source_file_index)\n+                    .expect(\"missing source file\")\n+                    .decode(self);\n+\n+                // We can't reuse an existing SourceFile, so allocate a new one\n+                // containing the information we need.\n+                let rustc_span::SourceFile {\n+                    mut name,\n+                    src_hash,\n+                    start_pos,\n+                    end_pos,\n+                    lines,\n+                    multibyte_chars,\n+                    non_narrow_chars,\n+                    normalized_pos,\n+                    name_hash,\n+                    ..\n+                } = source_file_to_import;\n+\n+                // If this file is under $sysroot/lib/rustlib/src/ but has not been remapped\n+                // during rust bootstrapping by `remap-debuginfo = true`, and the user\n+                // wish to simulate that behaviour by -Z simulate-remapped-rust-src-base,\n+                // then we change `name` to a similar state as if the rust was bootstrapped\n+                // with `remap-debuginfo = true`.\n+                // This is useful for testing so that tests about the effects of\n+                // `try_to_translate_virtual_to_real` don't have to worry about how the\n+                // compiler is bootstrapped.\n+                if let Some(virtual_dir) = &sess.opts.unstable_opts.simulate_remapped_rust_src_base\n+                {\n+                    if let Some(real_dir) = &sess.opts.real_rust_source_base_dir {\n+                        if let rustc_span::FileName::Real(ref mut old_name) = name {\n+                            if let rustc_span::RealFileName::LocalPath(local) = old_name {\n+                                if let Ok(rest) = local.strip_prefix(real_dir) {\n+                                    *old_name = rustc_span::RealFileName::Remapped {\n+                                        local_path: None,\n+                                        virtual_name: virtual_dir.join(rest),\n+                                    };\n                                 }\n                             }\n                         }\n                     }\n+                }\n \n-                    // If this file's path has been remapped to `/rustc/$hash`,\n-                    // we might be able to reverse that (also see comments above,\n-                    // on `try_to_translate_virtual_to_real`).\n-                    try_to_translate_virtual_to_real(&mut name);\n-\n-                    let source_length = (end_pos - start_pos).to_usize();\n-\n-                    let local_version = sess.source_map().new_imported_source_file(\n-                        name,\n-                        src_hash,\n-                        name_hash,\n-                        source_length,\n-                        self.cnum,\n-                        lines,\n-                        multibyte_chars,\n-                        non_narrow_chars,\n-                        normalized_pos,\n-                        start_pos,\n-                        end_pos,\n-                        source_file_index\n-                            .try_into()\n-                            .expect(\"cannot import more than U32_MAX files\"),\n-                    );\n-                    debug!(\n-                        \"CrateMetaData::imported_source_files alloc \\\n+                // If this file's path has been remapped to `/rustc/$hash`,\n+                // we might be able to reverse that (also see comments above,\n+                // on `try_to_translate_virtual_to_real`).\n+                try_to_translate_virtual_to_real(&mut name);\n+\n+                let source_length = (end_pos - start_pos).to_usize();\n+\n+                let local_version = sess.source_map().new_imported_source_file(\n+                    name,\n+                    src_hash,\n+                    name_hash,\n+                    source_length,\n+                    self.cnum,\n+                    lines,\n+                    multibyte_chars,\n+                    non_narrow_chars,\n+                    normalized_pos,\n+                    start_pos,\n+                    end_pos,\n+                    source_file_index,\n+                );\n+                debug!(\n+                    \"CrateMetaData::imported_source_files alloc \\\n                          source_file {:?} original (start_pos {:?} end_pos {:?}) \\\n                          translated (start_pos {:?} end_pos {:?})\",\n-                        local_version.name,\n-                        start_pos,\n-                        end_pos,\n-                        local_version.start_pos,\n-                        local_version.end_pos\n-                    );\n+                    local_version.name,\n+                    start_pos,\n+                    end_pos,\n+                    local_version.start_pos,\n+                    local_version.end_pos\n+                );\n \n-                    ImportedSourceFile {\n-                        original_start_pos: start_pos,\n-                        original_end_pos: end_pos,\n-                        translated_source_file: local_version,\n-                    }\n-                })\n-                .collect()\n-        })\n+                ImportedSourceFile {\n+                    original_start_pos: start_pos,\n+                    original_end_pos: end_pos,\n+                    translated_source_file: local_version,\n+                }\n+            })\n+            .clone()\n     }\n \n     fn get_generator_diagnostic_data(\n@@ -1676,7 +1677,7 @@ impl CrateMetadata {\n             trait_impls,\n             incoherent_impls: Default::default(),\n             raw_proc_macros,\n-            source_map_import_info: OnceCell::new(),\n+            source_map_import_info: RefCell::new(Vec::new()),\n             def_path_hash_map,\n             expn_hash_map: Default::default(),\n             alloc_decoding_state,"}, {"sha": "8b4220d4492a058b25fdf71269263e7f8e05430a", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a09e9c99a4c58ab6208aa44c4061df9aa2e40197/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09e9c99a4c58ab6208aa44c4061df9aa2e40197/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=a09e9c99a4c58ab6208aa44c4061df9aa2e40197", "patch": "@@ -675,6 +675,9 @@ impl CrateStore for CStore {\n     }\n \n     fn import_source_files(&self, sess: &Session, cnum: CrateNum) {\n-        self.get_crate_data(cnum).imported_source_files(sess);\n+        let cdata = self.get_crate_data(cnum);\n+        for file_index in 0..cdata.root.source_map.size() {\n+            cdata.imported_source_file(file_index as u32, sess);\n+        }\n     }\n }"}, {"sha": "576875f08c206bd11c3480708eefae4620a397ee", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 55, "deletions": 54, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/a09e9c99a4c58ab6208aa44c4061df9aa2e40197/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09e9c99a4c58ab6208aa44c4061df9aa2e40197/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=a09e9c99a4c58ab6208aa44c4061df9aa2e40197", "patch": "@@ -272,7 +272,7 @@ impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for Span {\n                     // Introduce a new scope so that we drop the 'lock()' temporary\n                     match &*s.source_file_cache.0.external_src.lock() {\n                         ExternalSource::Foreign { original_start_pos, metadata_index, .. } => {\n-                            (*original_start_pos, *metadata_index as usize)\n+                            (*original_start_pos, *metadata_index)\n                         }\n                         src => panic!(\"Unexpected external source {:?}\", src),\n                     }\n@@ -286,6 +286,8 @@ impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for Span {\n                 let source_files =\n                     s.required_source_files.as_mut().expect(\"Already encoded SourceMap!\");\n                 let (source_file_index, _) = source_files.insert_full(s.source_file_cache.1);\n+                let source_file_index: u32 =\n+                    source_file_index.try_into().expect(\"cannot export more than U32_MAX files\");\n \n                 (TAG_VALID_SPAN_LOCAL, span.lo, span.hi, source_file_index)\n             };\n@@ -452,7 +454,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.lazy(DefPathHashMapRef::BorrowedFromTcx(self.tcx.def_path_hash_to_def_index_map()))\n     }\n \n-    fn encode_source_map(&mut self) -> LazyArray<rustc_span::SourceFile> {\n+    fn encode_source_map(&mut self) -> LazyTable<u32, LazyValue<rustc_span::SourceFile>> {\n         let source_map = self.tcx.sess.source_map();\n         let all_source_files = source_map.files();\n \n@@ -463,65 +465,64 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let working_directory = &self.tcx.sess.opts.working_dir;\n \n+        let mut adapted = TableBuilder::default();\n+\n         // Only serialize `SourceFile`s that were used during the encoding of a `Span`.\n         //\n         // The order in which we encode source files is important here: the on-disk format for\n         // `Span` contains the index of the corresponding `SourceFile`.\n-        let adapted = required_source_files\n-            .iter()\n-            .map(|&source_file_index| &all_source_files[source_file_index])\n-            .map(|source_file| {\n-                // Don't serialize imported `SourceFile`s, unless we're in a proc-macro crate.\n-                assert!(!source_file.is_imported() || self.is_proc_macro);\n-\n-                // At export time we expand all source file paths to absolute paths because\n-                // downstream compilation sessions can have a different compiler working\n-                // directory, so relative paths from this or any other upstream crate\n-                // won't be valid anymore.\n-                //\n-                // At this point we also erase the actual on-disk path and only keep\n-                // the remapped version -- as is necessary for reproducible builds.\n-                match source_file.name {\n-                    FileName::Real(ref original_file_name) => {\n-                        let adapted_file_name =\n-                            source_map.path_mapping().to_embeddable_absolute_path(\n-                                original_file_name.clone(),\n-                                working_directory,\n-                            );\n-\n-                        if adapted_file_name != *original_file_name {\n-                            let mut adapted: SourceFile = (**source_file).clone();\n-                            adapted.name = FileName::Real(adapted_file_name);\n-                            adapted.name_hash = {\n-                                let mut hasher: StableHasher = StableHasher::new();\n-                                adapted.name.hash(&mut hasher);\n-                                hasher.finish::<u128>()\n-                            };\n-                            Lrc::new(adapted)\n-                        } else {\n-                            // Nothing to adapt\n-                            source_file.clone()\n-                        }\n+        for (on_disk_index, &source_file_index) in required_source_files.iter().enumerate() {\n+            let source_file = &all_source_files[source_file_index];\n+            // Don't serialize imported `SourceFile`s, unless we're in a proc-macro crate.\n+            assert!(!source_file.is_imported() || self.is_proc_macro);\n+\n+            // At export time we expand all source file paths to absolute paths because\n+            // downstream compilation sessions can have a different compiler working\n+            // directory, so relative paths from this or any other upstream crate\n+            // won't be valid anymore.\n+            //\n+            // At this point we also erase the actual on-disk path and only keep\n+            // the remapped version -- as is necessary for reproducible builds.\n+            let mut source_file = match source_file.name {\n+                FileName::Real(ref original_file_name) => {\n+                    let adapted_file_name = source_map\n+                        .path_mapping()\n+                        .to_embeddable_absolute_path(original_file_name.clone(), working_directory);\n+\n+                    if adapted_file_name != *original_file_name {\n+                        let mut adapted: SourceFile = (**source_file).clone();\n+                        adapted.name = FileName::Real(adapted_file_name);\n+                        adapted.name_hash = {\n+                            let mut hasher: StableHasher = StableHasher::new();\n+                            adapted.name.hash(&mut hasher);\n+                            hasher.finish::<u128>()\n+                        };\n+                        Lrc::new(adapted)\n+                    } else {\n+                        // Nothing to adapt\n+                        source_file.clone()\n                     }\n-                    // expanded code, not from a file\n-                    _ => source_file.clone(),\n                 }\n-            })\n-            .map(|mut source_file| {\n-                // We're serializing this `SourceFile` into our crate metadata,\n-                // so mark it as coming from this crate.\n-                // This also ensures that we don't try to deserialize the\n-                // `CrateNum` for a proc-macro dependency - since proc macro\n-                // dependencies aren't loaded when we deserialize a proc-macro,\n-                // trying to remap the `CrateNum` would fail.\n-                if self.is_proc_macro {\n-                    Lrc::make_mut(&mut source_file).cnum = LOCAL_CRATE;\n-                }\n-                source_file\n-            })\n-            .collect::<Vec<_>>();\n+                // expanded code, not from a file\n+                _ => source_file.clone(),\n+            };\n+\n+            // We're serializing this `SourceFile` into our crate metadata,\n+            // so mark it as coming from this crate.\n+            // This also ensures that we don't try to deserialize the\n+            // `CrateNum` for a proc-macro dependency - since proc macro\n+            // dependencies aren't loaded when we deserialize a proc-macro,\n+            // trying to remap the `CrateNum` would fail.\n+            if self.is_proc_macro {\n+                Lrc::make_mut(&mut source_file).cnum = LOCAL_CRATE;\n+            }\n+\n+            let on_disk_index: u32 =\n+                on_disk_index.try_into().expect(\"cannot export more than U32_MAX files\");\n+            adapted.set(on_disk_index, self.lazy(source_file));\n+        }\n \n-        self.lazy_array(adapted.iter().map(|rc| &**rc))\n+        adapted.encode(&mut self.opaque)\n     }\n \n     fn encode_crate_root(&mut self) -> LazyValue<CrateRoot> {"}, {"sha": "7a39f4d4e6b25e95b086c18cd387d40c930654fe", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a09e9c99a4c58ab6208aa44c4061df9aa2e40197/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09e9c99a4c58ab6208aa44c4061df9aa2e40197/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=a09e9c99a4c58ab6208aa44c4061df9aa2e40197", "patch": "@@ -249,7 +249,7 @@ pub(crate) struct CrateRoot {\n \n     def_path_hash_map: LazyValue<DefPathHashMapRef<'static>>,\n \n-    source_map: LazyArray<rustc_span::SourceFile>,\n+    source_map: LazyTable<u32, LazyValue<rustc_span::SourceFile>>,\n \n     compiler_builtins: bool,\n     needs_allocator: bool,"}]}