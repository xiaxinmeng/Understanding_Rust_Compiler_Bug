{"sha": "a2b932c0b614aa5a68f7d24977fab241998a89ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyYjkzMmMwYjYxNGFhNWE2OGY3ZDI0OTc3ZmFiMjQxOTk4YTg5ZWY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-08-17T21:16:41Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-08-18T02:35:52Z"}, "message": "core: Shuffle around float parsing\n\nStop using stability to hide the implementation details of ParseFloatError and\ninstead move the error type into the `dec2flt` module. Also move the\nimplementation blocks of `FromStr for f{32,64}` into `dec2flt` directly.", "tree": {"sha": "c1641403f5a09d5bdad31b4389a2d3390f63baf2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1641403f5a09d5bdad31b4389a2d3390f63baf2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2b932c0b614aa5a68f7d24977fab241998a89ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2b932c0b614aa5a68f7d24977fab241998a89ef", "html_url": "https://github.com/rust-lang/rust/commit/a2b932c0b614aa5a68f7d24977fab241998a89ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2b932c0b614aa5a68f7d24977fab241998a89ef/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5990249e48efe285fb37be104697af7e68cb3013", "url": "https://api.github.com/repos/rust-lang/rust/commits/5990249e48efe285fb37be104697af7e68cb3013", "html_url": "https://github.com/rust-lang/rust/commit/5990249e48efe285fb37be104697af7e68cb3013"}], "stats": {"total": 271, "additions": 133, "deletions": 138}, "files": [{"sha": "4e6b6f04e9e9225a522a96bb705ad5d3f23f3eeb", "filename": "src/libcore/num/dec2flt/mod.rs", "status": "modified", "additions": 87, "deletions": 13, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/a2b932c0b614aa5a68f7d24977fab241998a89ef/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b932c0b614aa5a68f7d24977fab241998a89ef/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs?ref=a2b932c0b614aa5a68f7d24977fab241998a89ef", "patch": "@@ -96,8 +96,9 @@\n             issue = \"0\")]\n \n use prelude::v1::*;\n-use num::ParseFloatError as PFE;\n-use num::FloatErrorKind;\n+use fmt;\n+use str::FromStr;\n+\n use self::parse::{parse_decimal, Decimal, Sign};\n use self::parse::ParseResult::{self, Valid, ShortcutToInf, ShortcutToZero};\n use self::num::digits_to_big;\n@@ -110,14 +111,87 @@ mod num;\n pub mod rawfp;\n pub mod parse;\n \n-/// Entry point for decimal-to-f32 conversion.\n-pub fn to_f32(s: &str) -> Result<f32, PFE> {\n-    dec2flt(s)\n+macro_rules! from_str_float_impl {\n+    ($t:ty, $func:ident) => {\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl FromStr for $t {\n+            type Err = ParseFloatError;\n+\n+            /// Converts a string in base 10 to a float.\n+            /// Accepts an optional decimal exponent.\n+            ///\n+            /// This function accepts strings such as\n+            ///\n+            /// * '3.14'\n+            /// * '-3.14'\n+            /// * '2.5E10', or equivalently, '2.5e10'\n+            /// * '2.5E-10'\n+            /// * '.' (understood as 0)\n+            /// * '5.'\n+            /// * '.5', or, equivalently,  '0.5'\n+            /// * 'inf', '-inf', 'NaN'\n+            ///\n+            /// Leading and trailing whitespace represent an error.\n+            ///\n+            /// # Arguments\n+            ///\n+            /// * src - A string\n+            ///\n+            /// # Return value\n+            ///\n+            /// `Err(ParseFloatError)` if the string did not represent a valid\n+            /// number.  Otherwise, `Ok(n)` where `n` is the floating-point\n+            /// number represented by `src`.\n+            #[inline]\n+            fn from_str(src: &str) -> Result<Self, ParseFloatError> {\n+                dec2flt(src)\n+            }\n+        }\n+    }\n+}\n+from_str_float_impl!(f32, to_f32);\n+from_str_float_impl!(f64, to_f64);\n+\n+/// An error which can be returned when parsing a float.\n+#[derive(Debug, Clone, PartialEq)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct ParseFloatError {\n+    kind: FloatErrorKind\n+}\n+\n+#[derive(Debug, Clone, PartialEq)]\n+enum FloatErrorKind {\n+    Empty,\n+    Invalid,\n+}\n+\n+impl ParseFloatError {\n+    #[unstable(feature = \"int_error_internals\",\n+               reason = \"available through Error trait and this method should \\\n+                         not be exposed publicly\",\n+               issue = \"0\")]\n+    #[doc(hidden)]\n+    pub fn __description(&self) -> &str {\n+        match self.kind {\n+            FloatErrorKind::Empty => \"cannot parse float from empty string\",\n+            FloatErrorKind::Invalid => \"invalid float literal\",\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for ParseFloatError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.__description().fmt(f)\n+    }\n+}\n+\n+pub fn pfe_empty() -> ParseFloatError {\n+    ParseFloatError { kind: FloatErrorKind::Empty }\n }\n \n-/// Entry point for decimal-to-f64 conversion.\n-pub fn to_f64(s: &str) -> Result<f64, PFE> {\n-    dec2flt(s)\n+pub fn pfe_invalid() -> ParseFloatError {\n+    ParseFloatError { kind: FloatErrorKind::Invalid }\n }\n \n /// Split decimal string into sign and the rest, without inspecting or validating the rest.\n@@ -131,9 +205,9 @@ fn extract_sign(s: &str) -> (Sign, &str) {\n }\n \n /// Convert a decimal string into a floating point number.\n-fn dec2flt<T: RawFloat>(s: &str) -> Result<T, PFE> {\n+fn dec2flt<T: RawFloat>(s: &str) -> Result<T, ParseFloatError> {\n     if s.is_empty() {\n-        return Err(PFE { __kind: FloatErrorKind::Empty });\n+        return Err(pfe_empty())\n     }\n     let (sign, s) = extract_sign(s);\n     let flt = match parse_decimal(s) {\n@@ -143,7 +217,7 @@ fn dec2flt<T: RawFloat>(s: &str) -> Result<T, PFE> {\n         ParseResult::Invalid => match s {\n             \"inf\" => T::infinity(),\n             \"NaN\" => T::nan(),\n-            _ => { return Err(PFE { __kind: FloatErrorKind::Invalid }); }\n+            _ => { return Err(pfe_invalid()); }\n         }\n     };\n \n@@ -155,7 +229,7 @@ fn dec2flt<T: RawFloat>(s: &str) -> Result<T, PFE> {\n \n /// The main workhorse for the decimal-to-float conversion: Orchestrate all the preprocessing\n /// and figure out which algorithm should do the actual conversion.\n-fn convert<T: RawFloat>(mut decimal: Decimal) -> Result<T, PFE> {\n+fn convert<T: RawFloat>(mut decimal: Decimal) -> Result<T, ParseFloatError> {\n     simplify(&mut decimal);\n     if let Some(x) = trivial_cases(&decimal) {\n         return Ok(x);\n@@ -172,7 +246,7 @@ fn convert<T: RawFloat>(mut decimal: Decimal) -> Result<T, PFE> {\n     // If we exceed this, perhaps while calculating `f * 10^e` in Algorithm R or Algorithm M,\n     // we'll crash. So we error out before getting too close, with a generous safety margin.\n     if max_digits > 375 {\n-        return Err(PFE { __kind: FloatErrorKind::Invalid });\n+        return Err(pfe_invalid());\n     }\n     let f = digits_to_big(decimal.integral, decimal.fractional);\n "}, {"sha": "88c3b756793a2b9bb9dd4664024f69c4f4a01ea7", "filename": "src/libcore/num/float_macros.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a2b932c0b614aa5a68f7d24977fab241998a89ef/src%2Flibcore%2Fnum%2Ffloat_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b932c0b614aa5a68f7d24977fab241998a89ef/src%2Flibcore%2Fnum%2Ffloat_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat_macros.rs?ref=a2b932c0b614aa5a68f7d24977fab241998a89ef", "patch": "@@ -23,8 +23,7 @@ macro_rules! from_str_radix_float_impl {\n     ($T:ty) => {\n         fn from_str_radix(src: &str, radix: u32)\n                           -> Result<$T, ParseFloatError> {\n-            use num::FloatErrorKind::*;\n-            use num::ParseFloatError as PFE;\n+            use num::dec2flt::{pfe_empty, pfe_invalid};\n \n             // Special values\n             match src {\n@@ -35,8 +34,8 @@ macro_rules! from_str_radix_float_impl {\n             }\n \n             let (is_positive, src) =  match src.slice_shift_char() {\n-                None             => return Err(PFE { __kind: Empty }),\n-                Some(('-', \"\"))  => return Err(PFE { __kind: Empty }),\n+                None             => return Err(pfe_empty()),\n+                Some(('-', \"\"))  => return Err(pfe_empty()),\n                 Some(('-', src)) => (false, src),\n                 Some((_, _))     => (true,  src),\n             };\n@@ -88,7 +87,7 @@ macro_rules! from_str_radix_float_impl {\n                             break;  // start of fractional part\n                         },\n                         _ => {\n-                            return Err(PFE { __kind: Invalid });\n+                            return Err(pfe_invalid())\n                         },\n                     },\n                 }\n@@ -122,7 +121,7 @@ macro_rules! from_str_radix_float_impl {\n                                 break; // start of exponent\n                             },\n                             _ => {\n-                                return Err(PFE { __kind: Invalid });\n+                                return Err(pfe_invalid())\n                             },\n                         },\n                     }\n@@ -135,7 +134,7 @@ macro_rules! from_str_radix_float_impl {\n                     let base = match c {\n                         'E' | 'e' if radix == 10 => 10.0,\n                         'P' | 'p' if radix == 16 => 2.0,\n-                        _ => return Err(PFE { __kind: Invalid }),\n+                        _ => return Err(pfe_invalid()),\n                     };\n \n                     // Parse the exponent as decimal integer\n@@ -144,13 +143,13 @@ macro_rules! from_str_radix_float_impl {\n                         Some(('-', src)) => (false, src.parse::<usize>()),\n                         Some(('+', src)) => (true,  src.parse::<usize>()),\n                         Some((_, _))     => (true,  src.parse::<usize>()),\n-                        None             => return Err(PFE { __kind: Invalid }),\n+                        None             => return Err(pfe_invalid()),\n                     };\n \n                     match (is_positive, exp) {\n                         (true,  Ok(exp)) => base.powi(exp as i32),\n                         (false, Ok(exp)) => 1.0 / base.powi(exp as i32),\n-                        (_, Err(_))      => return Err(PFE { __kind: Invalid }),\n+                        (_, Err(_))      => return Err(pfe_invalid()),\n                     }\n                 },\n                 None => 1.0, // no exponent"}, {"sha": "8770f46bc8ec9569b1ad0d8885ee1b278f9d1eca", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 1, "deletions": 78, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/a2b932c0b614aa5a68f7d24977fab241998a89ef/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b932c0b614aa5a68f7d24977fab241998a89ef/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=a2b932c0b614aa5a68f7d24977fab241998a89ef", "patch": "@@ -1365,47 +1365,6 @@ pub trait Float: Sized {\n     fn to_radians(self) -> Self;\n }\n \n-macro_rules! from_str_float_impl {\n-    ($t:ty, $func:ident) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl FromStr for $t {\n-            type Err = ParseFloatError;\n-\n-            /// Converts a string in base 10 to a float.\n-            /// Accepts an optional decimal exponent.\n-            ///\n-            /// This function accepts strings such as\n-            ///\n-            /// * '3.14'\n-            /// * '-3.14'\n-            /// * '2.5E10', or equivalently, '2.5e10'\n-            /// * '2.5E-10'\n-            /// * '.' (understood as 0)\n-            /// * '5.'\n-            /// * '.5', or, equivalently,  '0.5'\n-            /// * 'inf', '-inf', 'NaN'\n-            ///\n-            /// Leading and trailing whitespace represent an error.\n-            ///\n-            /// # Arguments\n-            ///\n-            /// * src - A string\n-            ///\n-            /// # Return value\n-            ///\n-            /// `Err(ParseFloatError)` if the string did not represent a valid\n-            /// number.  Otherwise, `Ok(n)` where `n` is the floating-point\n-            /// number represented by `src`.\n-            #[inline]\n-            fn from_str(src: &str) -> Result<Self, ParseFloatError> {\n-                dec2flt::$func(src)\n-            }\n-        }\n-    }\n-}\n-from_str_float_impl!(f32, to_f32);\n-from_str_float_impl!(f64, to_f64);\n-\n macro_rules! from_str_radix_int_impl {\n     ($($t:ty)*) => {$(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1548,40 +1507,4 @@ impl fmt::Display for ParseIntError {\n     }\n }\n \n-/// An error which can be returned when parsing a float.\n-#[derive(Debug, Clone, PartialEq)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct ParseFloatError {\n-    #[doc(hidden)]\n-    #[unstable(feature = \"float_error_internals\",\n-               reason = \"should not be exposed publicly\",\n-               issue = \"0\")]\n-    pub __kind: FloatErrorKind\n-}\n-\n-#[derive(Debug, Clone, PartialEq)]\n-#[unstable(feature = \"float_error_internals\",\n-           reason = \"should not be exposed publicly\",\n-           issue = \"0\")]\n-#[doc(hidden)]\n-pub enum FloatErrorKind {\n-    Empty,\n-    Invalid,\n-}\n-\n-impl ParseFloatError {\n-    #[doc(hidden)]\n-    pub fn __description(&self) -> &str {\n-        match self.__kind {\n-            FloatErrorKind::Empty => \"cannot parse float from empty string\",\n-            FloatErrorKind::Invalid => \"invalid float literal\",\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Display for ParseFloatError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.__description().fmt(f)\n-    }\n-}\n+pub use num::dec2flt::ParseFloatError;"}, {"sha": "b6bb5fddf4a4bdc4fed02347bfc312cc53636f0e", "filename": "src/libcoretest/atomic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2b932c0b614aa5a68f7d24977fab241998a89ef/src%2Flibcoretest%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b932c0b614aa5a68f7d24977fab241998a89ef/src%2Flibcoretest%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fatomic.rs?ref=a2b932c0b614aa5a68f7d24977fab241998a89ef", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::atomic::*;\n-use core::atomic::Ordering::SeqCst;\n+use core::sync::atomic::*;\n+use core::sync::atomic::Ordering::SeqCst;\n \n #[test]\n fn bool_() {"}, {"sha": "131cf62957537ea4283ae43383ee2293d7329c12", "filename": "src/libcoretest/num/dec2flt/mod.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/a2b932c0b614aa5a68f7d24977fab241998a89ef/src%2Flibcoretest%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b932c0b614aa5a68f7d24977fab241998a89ef/src%2Flibcoretest%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fdec2flt%2Fmod.rs?ref=a2b932c0b614aa5a68f7d24977fab241998a89ef", "patch": "@@ -12,7 +12,6 @@\n \n use std::{i64, f32, f64};\n use test;\n-use core::num::dec2flt::{to_f32, to_f64};\n \n mod parse;\n mod rawfp;\n@@ -27,11 +26,11 @@ macro_rules! test_literal {\n         let inputs = &[stringify!($x).into(), format!(\"{:?}\", x64), format!(\"{:e}\", x64)];\n         for input in inputs {\n             if input != \"inf\" {\n-                assert_eq!(to_f64(input), Ok(x64));\n-                assert_eq!(to_f32(input), Ok(x32));\n+                assert_eq!(input.parse(), Ok(x64));\n+                assert_eq!(input.parse(), Ok(x32));\n                 let neg_input = &format!(\"-{}\", input);\n-                assert_eq!(to_f64(neg_input), Ok(-x64));\n-                assert_eq!(to_f32(neg_input), Ok(-x32));\n+                assert_eq!(neg_input.parse(), Ok(-x64));\n+                assert_eq!(neg_input.parse(), Ok(-x32));\n             }\n         }\n     })\n@@ -99,83 +98,83 @@ fn fast_path_correct() {\n \n #[test]\n fn lonely_dot() {\n-    assert_eq!(to_f64(\".\"), Ok(0.0));\n+    assert_eq!(\".\".parse(), Ok(0.0));\n }\n \n #[test]\n fn nan() {\n-    assert!(to_f64(\"NaN\").unwrap().is_nan());\n-    assert!(to_f32(\"NaN\").unwrap().is_nan());\n+    assert!(\"NaN\".parse::<f32>().unwrap().is_nan());\n+    assert!(\"NaN\".parse::<f64>().unwrap().is_nan());\n }\n \n #[test]\n fn inf() {\n-    assert_eq!(to_f64(\"inf\"), Ok(f64::INFINITY));\n-    assert_eq!(to_f64(\"-inf\"), Ok(f64::NEG_INFINITY));\n-    assert_eq!(to_f32(\"inf\"), Ok(f32::INFINITY));\n-    assert_eq!(to_f32(\"-inf\"), Ok(f32::NEG_INFINITY));\n+    assert_eq!(\"inf\".parse(), Ok(f64::INFINITY));\n+    assert_eq!(\"-inf\".parse(), Ok(f64::NEG_INFINITY));\n+    assert_eq!(\"inf\".parse(), Ok(f32::INFINITY));\n+    assert_eq!(\"-inf\".parse(), Ok(f32::NEG_INFINITY));\n }\n \n #[test]\n fn massive_exponent() {\n     let max = i64::MAX;\n-    assert_eq!(to_f64(&format!(\"1e{}000\", max)), Ok(f64::INFINITY));\n-    assert_eq!(to_f64(&format!(\"1e-{}000\", max)), Ok(0.0));\n-    assert_eq!(to_f64(&format!(\"1e{}000\", max)), Ok(f64::INFINITY));\n+    assert_eq!(format!(\"1e{}000\", max).parse(), Ok(f64::INFINITY));\n+    assert_eq!(format!(\"1e-{}000\", max).parse(), Ok(0.0));\n+    assert_eq!(format!(\"1e{}000\", max).parse(), Ok(f64::INFINITY));\n }\n \n #[bench]\n fn bench_0(b: &mut test::Bencher) {\n-    b.iter(|| to_f64(\"0.0\"));\n+    b.iter(|| \"0.0\".parse::<f64>());\n }\n \n #[bench]\n fn bench_42(b: &mut test::Bencher) {\n-    b.iter(|| to_f64(\"42\"));\n+    b.iter(|| \"42\".parse::<f64>());\n }\n \n #[bench]\n fn bench_huge_int(b: &mut test::Bencher) {\n     // 2^128 - 1\n-    b.iter(|| to_f64(\"170141183460469231731687303715884105727\"));\n+    b.iter(|| \"170141183460469231731687303715884105727\".parse::<f64>());\n }\n \n #[bench]\n fn bench_short_decimal(b: &mut test::Bencher) {\n-    b.iter(|| to_f64(\"1234.5678\"));\n+    b.iter(|| \"1234.5678\".parse::<f64>());\n }\n \n #[bench]\n fn bench_pi_long(b: &mut test::Bencher) {\n-    b.iter(|| to_f64(\"3.14159265358979323846264338327950288\"));\n+    b.iter(|| \"3.14159265358979323846264338327950288\".parse::<f64>());\n }\n \n #[bench]\n fn bench_pi_short(b: &mut test::Bencher) {\n-    b.iter(|| to_f64(\"3.141592653589793\"))\n+    b.iter(|| \"3.141592653589793\".parse::<f64>())\n }\n \n #[bench]\n fn bench_1e150(b: &mut test::Bencher) {\n-    b.iter(|| to_f64(\"1e150\"));\n+    b.iter(|| \"1e150\".parse::<f64>());\n }\n \n #[bench]\n fn bench_long_decimal_and_exp(b: &mut test::Bencher) {\n-    b.iter(|| to_f64(\"727501488517303786137132964064381141071e-123\"));\n+    b.iter(|| \"727501488517303786137132964064381141071e-123\".parse::<f64>());\n }\n \n #[bench]\n fn bench_min_subnormal(b: &mut test::Bencher) {\n-    b.iter(|| to_f64(\"5e-324\"));\n+    b.iter(|| \"5e-324\".parse::<f64>());\n }\n \n #[bench]\n fn bench_min_normal(b: &mut test::Bencher) {\n-    b.iter(|| to_f64(\"2.2250738585072014e-308\"));\n+    b.iter(|| \"2.2250738585072014e-308\".parse::<f64>());\n }\n \n #[bench]\n fn bench_max(b: &mut test::Bencher) {\n-    b.iter(|| to_f64(\"1.7976931348623157e308\"));\n+    b.iter(|| \"1.7976931348623157e308\".parse::<f64>());\n }"}, {"sha": "25591db64d9070bbc3c781a8a0d3d3a4b5bed9b2", "filename": "src/libcoretest/num/uint_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2b932c0b614aa5a68f7d24977fab241998a89ef/src%2Flibcoretest%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b932c0b614aa5a68f7d24977fab241998a89ef/src%2Flibcoretest%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fuint_macros.rs?ref=a2b932c0b614aa5a68f7d24977fab241998a89ef", "patch": "@@ -14,7 +14,7 @@ mod tests {\n     use core::$T_i::*;\n     use num;\n     use core::ops::{BitOr, BitAnd, BitXor, Shl, Shr, Not};\n-    use std::str;\n+    use std::str::FromStr;\n \n     #[test]\n     fn test_overflows() {\n@@ -152,5 +152,5 @@ mod tests {\n         assert_eq!($T::from_str_radix(\"Z\", 10).ok(), None::<$T>);\n         assert_eq!($T::from_str_radix(\"_\", 2).ok(), None::<$T>);\n     }\n-\n+}\n )}"}, {"sha": "8c75d4680faebd7fbeef1258fd5a38442053b2e9", "filename": "src/test/compile-fail/issue-1920-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2b932c0b614aa5a68f7d24977fab241998a89ef/src%2Ftest%2Fcompile-fail%2Fissue-1920-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b932c0b614aa5a68f7d24977fab241998a89ef/src%2Ftest%2Fcompile-fail%2Fissue-1920-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1920-1.rs?ref=a2b932c0b614aa5a68f7d24977fab241998a89ef", "patch": "@@ -17,6 +17,6 @@ mod foo {\n fn assert_clone<T>() where T : Clone { }\n \n fn main() {\n-    assert_clone::<foo::core::atomic::AtomicBool>();\n+    assert_clone::<foo::core::sync::atomic::AtomicBool>();\n     //~^ ERROR the trait `foo::core::clone::Clone` is not implemented for the type `foo::core::\n-}\n\\ No newline at end of file\n+}"}, {"sha": "57eb82a156bbfaf55c6328c74f94cef5ce0d9870", "filename": "src/test/compile-fail/issue-1920-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a2b932c0b614aa5a68f7d24977fab241998a89ef/src%2Ftest%2Fcompile-fail%2Fissue-1920-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b932c0b614aa5a68f7d24977fab241998a89ef/src%2Ftest%2Fcompile-fail%2Fissue-1920-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1920-2.rs?ref=a2b932c0b614aa5a68f7d24977fab241998a89ef", "patch": "@@ -15,6 +15,6 @@ extern crate core as bar;\n fn assert_clone<T>() where T : Clone { }\n \n fn main() {\n-    assert_clone::<bar::atomic::AtomicBool>();\n-    //~^ ERROR the trait `bar::clone::Clone` is not implemented for the type `bar::atomic::\n-}\n\\ No newline at end of file\n+    assert_clone::<bar::sync::atomic::AtomicBool>();\n+    //~^ ERROR the trait `bar::clone::Clone` is not implemented for the type `bar::sync::atomic::\n+}"}, {"sha": "0ef7747c8a84f124c4310cd9b4fe825c29053a0d", "filename": "src/test/compile-fail/issue-1920-3.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a2b932c0b614aa5a68f7d24977fab241998a89ef/src%2Ftest%2Fcompile-fail%2Fissue-1920-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b932c0b614aa5a68f7d24977fab241998a89ef/src%2Ftest%2Fcompile-fail%2Fissue-1920-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1920-3.rs?ref=a2b932c0b614aa5a68f7d24977fab241998a89ef", "patch": "@@ -19,6 +19,6 @@ extern crate core;\n fn assert_clone<T>() where T : Clone { }\n \n fn main() {\n-    assert_clone::<foo::core::atomic::AtomicBool>();\n-    //~^ ERROR the trait `core::clone::Clone` is not implemented for the type `core::atomic::\n-}\n\\ No newline at end of file\n+    assert_clone::<foo::core::sync::atomic::AtomicBool>();\n+    //~^ ERROR the trait `core::clone::Clone` is not implemented for the type `core::sync::atomic::\n+}"}]}