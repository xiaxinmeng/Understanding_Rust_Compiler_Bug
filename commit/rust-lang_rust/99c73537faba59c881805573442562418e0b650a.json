{"sha": "99c73537faba59c881805573442562418e0b650a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5YzczNTM3ZmFiYTU5Yzg4MTgwNTU3MzQ0MjU2MjQxOGUwYjY1MGE=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-05-16T18:04:00Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-05-21T15:49:09Z"}, "message": "Remove TypeVariableTable", "tree": {"sha": "f82ef98fd5dee996f79acbcbd738a18f98a39220", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f82ef98fd5dee996f79acbcbd738a18f98a39220"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99c73537faba59c881805573442562418e0b650a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99c73537faba59c881805573442562418e0b650a", "html_url": "https://github.com/rust-lang/rust/commit/99c73537faba59c881805573442562418e0b650a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99c73537faba59c881805573442562418e0b650a/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9716c0b949b1a1a95b3f36928faed3abc21c0bda", "url": "https://api.github.com/repos/rust-lang/rust/commits/9716c0b949b1a1a95b3f36928faed3abc21c0bda", "html_url": "https://github.com/rust-lang/rust/commit/9716c0b949b1a1a95b3f36928faed3abc21c0bda"}], "stats": {"total": 104, "additions": 48, "deletions": 56}, "files": [{"sha": "20c512517b62ad72e31762294806778af90f9034", "filename": "crates/hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99c73537faba59c881805573442562418e0b650a/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c73537faba59c881805573442562418e0b650a/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=99c73537faba59c881805573442562418e0b650a", "patch": "@@ -101,7 +101,7 @@ impl<'a> InferenceContext<'a> {\n             // here, we would coerce from `!` to `?T`.\n             match to_ty.kind(&Interner) {\n                 TyKind::InferenceVar(tv, TyVariableKind::General) => {\n-                    self.table.type_variable_table.set_diverging(*tv, true);\n+                    self.table.set_diverging(*tv, true);\n                 }\n                 _ => {}\n             }"}, {"sha": "8674c1b0cea8da9471fc42ecc1f0ae500a38ce21", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 47, "deletions": 55, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/99c73537faba59c881805573442562418e0b650a/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c73537faba59c881805573442562418e0b650a/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=99c73537faba59c881805573442562418e0b650a", "patch": "@@ -127,29 +127,6 @@ pub(crate) fn unify(\n     ))\n }\n \n-#[derive(Clone, Debug)]\n-pub(super) struct TypeVariableTable {\n-    inner: Vec<TypeVariableData>,\n-}\n-\n-impl TypeVariableTable {\n-    pub(super) fn set_diverging(&mut self, iv: InferenceVar, diverging: bool) {\n-        self.inner[iv.index() as usize].diverging = diverging;\n-    }\n-\n-    fn fallback_value(&self, iv: InferenceVar, kind: TyVariableKind) -> Ty {\n-        match kind {\n-            _ if self.inner.get(iv.index() as usize).map_or(false, |data| data.diverging) => {\n-                TyKind::Never\n-            }\n-            TyVariableKind::General => TyKind::Error,\n-            TyVariableKind::Integer => TyKind::Scalar(Scalar::Int(IntTy::I32)),\n-            TyVariableKind::Float => TyKind::Scalar(Scalar::Float(FloatTy::F64)),\n-        }\n-        .intern(&Interner)\n-    }\n-}\n-\n #[derive(Copy, Clone, Debug)]\n pub(crate) struct TypeVariableData {\n     diverging: bool,\n@@ -162,7 +139,7 @@ pub(crate) struct InferenceTable<'a> {\n     pub db: &'a dyn HirDatabase,\n     pub trait_env: Arc<TraitEnvironment>,\n     pub(super) var_unification_table: ChalkInferenceTable,\n-    pub(super) type_variable_table: TypeVariableTable,\n+    pub(super) type_variable_table: Vec<TypeVariableData>,\n     pending_obligations: Vec<Canonicalized<InEnvironment<Goal>>>,\n }\n \n@@ -172,7 +149,7 @@ impl<'a> InferenceTable<'a> {\n             db,\n             trait_env,\n             var_unification_table: ChalkInferenceTable::new(),\n-            type_variable_table: TypeVariableTable { inner: Vec::new() },\n+            type_variable_table: Vec::new(),\n             pending_obligations: Vec::new(),\n         }\n     }\n@@ -184,18 +161,38 @@ impl<'a> InferenceTable<'a> {\n     /// marked as diverging if necessary, so that resolving them gives the right\n     /// result.\n     pub(super) fn propagate_diverging_flag(&mut self) {\n-        for i in 0..self.type_variable_table.inner.len() {\n-            if !self.type_variable_table.inner[i].diverging {\n+        for i in 0..self.type_variable_table.len() {\n+            if !self.type_variable_table[i].diverging {\n                 continue;\n             }\n             let v = InferenceVar::from(i as u32);\n             let root = self.var_unification_table.inference_var_root(v);\n-            if let Some(data) = self.type_variable_table.inner.get_mut(root.index() as usize) {\n+            if let Some(data) = self.type_variable_table.get_mut(root.index() as usize) {\n                 data.diverging = true;\n             }\n         }\n     }\n \n+    pub(super) fn set_diverging(&mut self, iv: InferenceVar, diverging: bool) {\n+        self.type_variable_table[iv.index() as usize].diverging = diverging;\n+    }\n+\n+    fn fallback_value(&self, iv: InferenceVar, kind: TyVariableKind) -> Ty {\n+        match kind {\n+            _ if self\n+                .type_variable_table\n+                .get(iv.index() as usize)\n+                .map_or(false, |data| data.diverging) =>\n+            {\n+                TyKind::Never\n+            }\n+            TyVariableKind::General => TyKind::Error,\n+            TyVariableKind::Integer => TyKind::Scalar(Scalar::Int(IntTy::I32)),\n+            TyVariableKind::Float => TyKind::Scalar(Scalar::Float(FloatTy::F64)),\n+        }\n+        .intern(&Interner)\n+    }\n+\n     pub(super) fn canonicalize<T: Fold<Interner> + HasInterner<Interner = Interner>>(\n         &mut self,\n         t: T,\n@@ -239,16 +236,19 @@ impl<'a> InferenceTable<'a> {\n         var\n     }\n \n+    fn extend_type_variable_table(&mut self, to_index: usize) {\n+        self.type_variable_table.extend(\n+            (0..1 + to_index - self.type_variable_table.len())\n+                .map(|_| TypeVariableData { diverging: false }),\n+        );\n+    }\n+\n     fn new_var(&mut self, kind: TyVariableKind, diverging: bool) -> Ty {\n         let var = self.var_unification_table.new_variable(UniverseIndex::ROOT);\n         // Chalk might have created some type variables for its own purposes that we don't know about...\n-        // TODO refactor this?\n-        self.type_variable_table.inner.extend(\n-            (0..1 + var.index() as usize - self.type_variable_table.inner.len())\n-                .map(|_| TypeVariableData { diverging: false }),\n-        );\n-        assert_eq!(var.index() as usize, self.type_variable_table.inner.len() - 1);\n-        self.type_variable_table.inner[var.index() as usize].diverging = diverging;\n+        self.extend_type_variable_table(var.index() as usize);\n+        assert_eq!(var.index() as usize, self.type_variable_table.len() - 1);\n+        self.type_variable_table[var.index() as usize].diverging = diverging;\n         var.to_ty_with_kind(&Interner, kind)\n     }\n \n@@ -289,12 +289,7 @@ impl<'a> InferenceTable<'a> {\n         T: HasInterner<Interner = Interner> + Fold<Interner>,\n     {\n         t.fold_with(\n-            &mut resolve::Resolver {\n-                type_variable_table: &self.type_variable_table,\n-                var_unification_table: &mut self.var_unification_table,\n-                var_stack,\n-                fallback,\n-            },\n+            &mut resolve::Resolver { table: self, var_stack, fallback },\n             DebruijnIndex::INNERMOST,\n         )\n         .expect(\"fold failed unexpectedly\")\n@@ -433,14 +428,12 @@ impl<'a> InferenceTable<'a> {\n \n impl<'a> fmt::Debug for InferenceTable<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"InferenceTable\")\n-            .field(\"num_vars\", &self.type_variable_table.inner.len())\n-            .finish()\n+        f.debug_struct(\"InferenceTable\").field(\"num_vars\", &self.type_variable_table.len()).finish()\n     }\n }\n \n mod resolve {\n-    use super::{ChalkInferenceTable, TypeVariableTable};\n+    use super::InferenceTable;\n     use crate::{\n         ConcreteConst, Const, ConstData, ConstValue, DebruijnIndex, GenericArg, InferenceVar,\n         Interner, Ty, TyVariableKind, VariableKind,\n@@ -452,13 +445,12 @@ mod resolve {\n     };\n     use hir_def::type_ref::ConstScalar;\n \n-    pub(super) struct Resolver<'a, F> {\n-        pub type_variable_table: &'a TypeVariableTable,\n-        pub var_unification_table: &'a mut ChalkInferenceTable,\n+    pub(super) struct Resolver<'a, 'b, F> {\n+        pub table: &'a mut InferenceTable<'b>,\n         pub var_stack: &'a mut Vec<InferenceVar>,\n         pub fallback: F,\n     }\n-    impl<'a, 'i, F> Folder<'i, Interner> for Resolver<'a, F>\n+    impl<'a, 'b, 'i, F> Folder<'i, Interner> for Resolver<'a, 'b, F>\n     where\n         F: Fn(InferenceVar, VariableKind, GenericArg, DebruijnIndex) -> GenericArg + 'i,\n     {\n@@ -476,23 +468,23 @@ mod resolve {\n             kind: TyVariableKind,\n             outer_binder: DebruijnIndex,\n         ) -> Fallible<Ty> {\n-            let var = self.var_unification_table.inference_var_root(var);\n+            let var = self.table.var_unification_table.inference_var_root(var);\n             if self.var_stack.contains(&var) {\n                 // recursive type\n-                let default = self.type_variable_table.fallback_value(var, kind).cast(&Interner);\n+                let default = self.table.fallback_value(var, kind).cast(&Interner);\n                 return Ok((self.fallback)(var, VariableKind::Ty(kind), default, outer_binder)\n                     .assert_ty_ref(&Interner)\n                     .clone());\n             }\n-            let result = if let Some(known_ty) = self.var_unification_table.probe_var(var) {\n+            let result = if let Some(known_ty) = self.table.var_unification_table.probe_var(var) {\n                 // known_ty may contain other variables that are known by now\n                 self.var_stack.push(var);\n                 let result =\n                     known_ty.fold_with(self, outer_binder).expect(\"fold failed unexpectedly\");\n                 self.var_stack.pop();\n                 result.assert_ty_ref(&Interner).clone()\n             } else {\n-                let default = self.type_variable_table.fallback_value(var, kind).cast(&Interner);\n+                let default = self.table.fallback_value(var, kind).cast(&Interner);\n                 (self.fallback)(var, VariableKind::Ty(kind), default, outer_binder)\n                     .assert_ty_ref(&Interner)\n                     .clone()\n@@ -506,7 +498,7 @@ mod resolve {\n             var: InferenceVar,\n             outer_binder: DebruijnIndex,\n         ) -> Fallible<Const> {\n-            let var = self.var_unification_table.inference_var_root(var);\n+            let var = self.table.var_unification_table.inference_var_root(var);\n             let default = ConstData {\n                 ty: ty.clone(),\n                 value: ConstValue::Concrete(ConcreteConst { interned: ConstScalar::Unknown }),\n@@ -519,7 +511,7 @@ mod resolve {\n                     .assert_const_ref(&Interner)\n                     .clone());\n             }\n-            let result = if let Some(known_ty) = self.var_unification_table.probe_var(var) {\n+            let result = if let Some(known_ty) = self.table.var_unification_table.probe_var(var) {\n                 // known_ty may contain other variables that are known by now\n                 self.var_stack.push(var);\n                 let result ="}]}