{"sha": "f40ecff9644e723752732d9d1f6723260ee7bb23", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0MGVjZmY5NjQ0ZTcyMzc1MjczMmQ5ZDFmNjcyMzI2MGVlN2JiMjM=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-10-17T01:27:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-17T01:27:15Z"}, "message": "Rollup merge of #77751 - vojtechkral:vecdeque-binary-search, r=scottmcm,dtolnay\n\nliballoc: VecDeque: Add binary search functions\n\nI am submitting rust-lang/rfcs#2997 as a PR as suggested by @scottmcm\n\nI haven't yet created a tracking issue - if there's a favorable feedback I'll create one and update the issue links in the unstable attribs.", "tree": {"sha": "2d3f23e4f6d40e73c8f09809616bb115b120d851", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d3f23e4f6d40e73c8f09809616bb115b120d851"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f40ecff9644e723752732d9d1f6723260ee7bb23", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfikhzCRBK7hj4Ov3rIwAAdHIIAJOs0DnKzjAm/psbWZ/Sz8Xq\nKsDjNwV/HFyaa1vumJfrIGTk0RehzPGqdymZl+0y9+TODlLUnHrlSlUUyCwMCtgE\njWSnTrdvKPL6NRBofVSBgNbUgvBIcZkSImeeDaWzPt8Zu1QWksOTkFchRFoqp91x\nD7R/Aal7oUdzcSHX5Nw8eBZqYizjYPRMpHDfPxeYksRyqPzTKlToPN+/4PZG26Wd\nnJCxiPUdxFdis3aDMc2XSOzdKOA/CyAGenc9Xsr5epyzhZ2q78jpSpEx+Yowf7x5\nYiZi07bSA83WDipw9wzQ19o8w7EbPa68aSyVZP5a0b/vpngCz+a/SM0CBFALQmU=\n=EkCL\n-----END PGP SIGNATURE-----\n", "payload": "tree 2d3f23e4f6d40e73c8f09809616bb115b120d851\nparent 496e2feed684afc3eb43a3e4ac933fc61a5a8305\nparent c7a787a3276cadad7ee51577f65158b4888c058c\nauthor Dylan DPC <dylan.dpc@gmail.com> 1602898035 +0200\ncommitter GitHub <noreply@github.com> 1602898035 +0200\n\nRollup merge of #77751 - vojtechkral:vecdeque-binary-search, r=scottmcm,dtolnay\n\nliballoc: VecDeque: Add binary search functions\n\nI am submitting rust-lang/rfcs#2997 as a PR as suggested by @scottmcm\n\nI haven't yet created a tracking issue - if there's a favorable feedback I'll create one and update the issue links in the unstable attribs.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f40ecff9644e723752732d9d1f6723260ee7bb23", "html_url": "https://github.com/rust-lang/rust/commit/f40ecff9644e723752732d9d1f6723260ee7bb23", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f40ecff9644e723752732d9d1f6723260ee7bb23/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "496e2feed684afc3eb43a3e4ac933fc61a5a8305", "url": "https://api.github.com/repos/rust-lang/rust/commits/496e2feed684afc3eb43a3e4ac933fc61a5a8305", "html_url": "https://github.com/rust-lang/rust/commit/496e2feed684afc3eb43a3e4ac933fc61a5a8305"}, {"sha": "c7a787a3276cadad7ee51577f65158b4888c058c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7a787a3276cadad7ee51577f65158b4888c058c", "html_url": "https://github.com/rust-lang/rust/commit/c7a787a3276cadad7ee51577f65158b4888c058c"}], "stats": {"total": 179, "additions": 178, "deletions": 1}, "files": [{"sha": "94dac1cd1769b455389362e95965b7188d51000f", "filename": "library/alloc/src/collections/vec_deque.rs", "status": "modified", "additions": 138, "deletions": 1, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/f40ecff9644e723752732d9d1f6723260ee7bb23/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40ecff9644e723752732d9d1f6723260ee7bb23/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque.rs?ref=f40ecff9644e723752732d9d1f6723260ee7bb23", "patch": "@@ -2181,7 +2181,7 @@ impl<T> VecDeque<T> {\n     ///\n     /// This method does not allocate and does not change the order of the\n     /// inserted elements. As it returns a mutable slice, this can be used to\n-    /// sort or binary search a deque.\n+    /// sort a deque.\n     ///\n     /// Once the internal storage is contiguous, the [`as_slices`] and\n     /// [`as_mut_slices`] methods will return the entire contents of the\n@@ -2430,6 +2430,143 @@ impl<T> VecDeque<T> {\n             self.wrap_copy(self.tail, self.head, k);\n         }\n     }\n+\n+    /// Binary searches this sorted `VecDeque` for a given element.\n+    ///\n+    /// If the value is found then [`Result::Ok`] is returned, containing the\n+    /// index of the matching element. If there are multiple matches, then any\n+    /// one of the matches could be returned. If the value is not found then\n+    /// [`Result::Err`] is returned, containing the index where a matching\n+    /// element could be inserted while maintaining sorted order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Looks up a series of four elements. The first is found, with a\n+    /// uniquely determined position; the second and third are not\n+    /// found; the fourth could match any position in `[1, 4]`.\n+    ///\n+    /// ```\n+    /// #![feature(vecdeque_binary_search)]\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let deque: VecDeque<_> = vec![0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55].into();\n+    ///\n+    /// assert_eq!(deque.binary_search(&13),  Ok(9));\n+    /// assert_eq!(deque.binary_search(&4),   Err(7));\n+    /// assert_eq!(deque.binary_search(&100), Err(13));\n+    /// let r = deque.binary_search(&1);\n+    /// assert!(matches!(r, Ok(1..=4)));\n+    /// ```\n+    ///\n+    /// If you want to insert an item to a sorted `VecDeque`, while maintaining\n+    /// sort order:\n+    ///\n+    /// ```\n+    /// #![feature(vecdeque_binary_search)]\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut deque: VecDeque<_> = vec![0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55].into();\n+    /// let num = 42;\n+    /// let idx = deque.binary_search(&num).unwrap_or_else(|x| x);\n+    /// deque.insert(idx, num);\n+    /// assert_eq!(deque, &[0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 42, 55]);\n+    /// ```\n+    #[unstable(feature = \"vecdeque_binary_search\", issue = \"78021\")]\n+    #[inline]\n+    pub fn binary_search(&self, x: &T) -> Result<usize, usize>\n+    where\n+        T: Ord,\n+    {\n+        self.binary_search_by(|e| e.cmp(x))\n+    }\n+\n+    /// Binary searches this sorted `VecDeque` with a comparator function.\n+    ///\n+    /// The comparator function should implement an order consistent\n+    /// with the sort order of the underlying `VecDeque`, returning an\n+    /// order code that indicates whether its argument is `Less`,\n+    /// `Equal` or `Greater` than the desired target.\n+    ///\n+    /// If the value is found then [`Result::Ok`] is returned, containing the\n+    /// index of the matching element. If there are multiple matches, then any\n+    /// one of the matches could be returned. If the value is not found then\n+    /// [`Result::Err`] is returned, containing the index where a matching\n+    /// element could be inserted while maintaining sorted order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Looks up a series of four elements. The first is found, with a\n+    /// uniquely determined position; the second and third are not\n+    /// found; the fourth could match any position in `[1, 4]`.\n+    ///\n+    /// ```\n+    /// #![feature(vecdeque_binary_search)]\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let deque: VecDeque<_> = vec![0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55].into();\n+    ///\n+    /// assert_eq!(deque.binary_search_by(|x| x.cmp(&13)),  Ok(9));\n+    /// assert_eq!(deque.binary_search_by(|x| x.cmp(&4)),   Err(7));\n+    /// assert_eq!(deque.binary_search_by(|x| x.cmp(&100)), Err(13));\n+    /// let r = deque.binary_search_by(|x| x.cmp(&1));\n+    /// assert!(matches!(r, Ok(1..=4)));\n+    /// ```\n+    #[unstable(feature = \"vecdeque_binary_search\", issue = \"78021\")]\n+    pub fn binary_search_by<'a, F>(&'a self, mut f: F) -> Result<usize, usize>\n+    where\n+        F: FnMut(&'a T) -> Ordering,\n+    {\n+        let (front, back) = self.as_slices();\n+\n+        if let Some(Ordering::Less | Ordering::Equal) = back.first().map(|elem| f(elem)) {\n+            back.binary_search_by(f).map(|idx| idx + front.len()).map_err(|idx| idx + front.len())\n+        } else {\n+            front.binary_search_by(f)\n+        }\n+    }\n+\n+    /// Binary searches this sorted `VecDeque` with a key extraction function.\n+    ///\n+    /// Assumes that the `VecDeque` is sorted by the key, for instance with\n+    /// [`make_contiguous().sort_by_key()`](#method.make_contiguous) using the same\n+    /// key extraction function.\n+    ///\n+    /// If the value is found then [`Result::Ok`] is returned, containing the\n+    /// index of the matching element. If there are multiple matches, then any\n+    /// one of the matches could be returned. If the value is not found then\n+    /// [`Result::Err`] is returned, containing the index where a matching\n+    /// element could be inserted while maintaining sorted order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Looks up a series of four elements in a slice of pairs sorted by\n+    /// their second elements. The first is found, with a uniquely\n+    /// determined position; the second and third are not found; the\n+    /// fourth could match any position in `[1, 4]`.\n+    ///\n+    /// ```\n+    /// #![feature(vecdeque_binary_search)]\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let deque: VecDeque<_> = vec![(0, 0), (2, 1), (4, 1), (5, 1),\n+    ///          (3, 1), (1, 2), (2, 3), (4, 5), (5, 8), (3, 13),\n+    ///          (1, 21), (2, 34), (4, 55)].into();\n+    ///\n+    /// assert_eq!(deque.binary_search_by_key(&13, |&(a,b)| b),  Ok(9));\n+    /// assert_eq!(deque.binary_search_by_key(&4, |&(a,b)| b),   Err(7));\n+    /// assert_eq!(deque.binary_search_by_key(&100, |&(a,b)| b), Err(13));\n+    /// let r = deque.binary_search_by_key(&1, |&(a,b)| b);\n+    /// assert!(matches!(r, Ok(1..=4)));\n+    /// ```\n+    #[unstable(feature = \"vecdeque_binary_search\", issue = \"78021\")]\n+    #[inline]\n+    pub fn binary_search_by_key<'a, B, F>(&'a self, b: &B, mut f: F) -> Result<usize, usize>\n+    where\n+        F: FnMut(&'a T) -> B,\n+        B: Ord,\n+    {\n+        self.binary_search_by(|k| f(k).cmp(b))\n+    }\n }\n \n impl<T: Clone> VecDeque<T> {"}, {"sha": "b7cc03f8eb999403f45f2a70939bbf92f960c569", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f40ecff9644e723752732d9d1f6723260ee7bb23/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40ecff9644e723752732d9d1f6723260ee7bb23/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=f40ecff9644e723752732d9d1f6723260ee7bb23", "patch": "@@ -20,6 +20,7 @@\n #![feature(inplace_iteration)]\n #![feature(iter_map_while)]\n #![feature(int_bits_const)]\n+#![feature(vecdeque_binary_search)]\n \n use std::collections::hash_map::DefaultHasher;\n use std::hash::{Hash, Hasher};"}, {"sha": "05cb3a2c03d79a49780436dfe9889e918af955af", "filename": "library/alloc/tests/vec_deque.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f40ecff9644e723752732d9d1f6723260ee7bb23/library%2Falloc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f40ecff9644e723752732d9d1f6723260ee7bb23/library%2Falloc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec_deque.rs?ref=f40ecff9644e723752732d9d1f6723260ee7bb23", "patch": "@@ -1659,3 +1659,42 @@ fn test_drain_leak() {\n     drop(v);\n     assert_eq!(unsafe { DROPS }, 7);\n }\n+\n+#[test]\n+fn test_binary_search() {\n+    // Contiguous (front only) search:\n+    let deque: VecDeque<_> = vec![1, 2, 3, 5, 6].into();\n+    assert!(deque.as_slices().1.is_empty());\n+    assert_eq!(deque.binary_search(&3), Ok(2));\n+    assert_eq!(deque.binary_search(&4), Err(3));\n+\n+    // Split search (both front & back non-empty):\n+    let mut deque: VecDeque<_> = vec![5, 6].into();\n+    deque.push_front(3);\n+    deque.push_front(2);\n+    deque.push_front(1);\n+    deque.push_back(10);\n+    assert!(!deque.as_slices().0.is_empty());\n+    assert!(!deque.as_slices().1.is_empty());\n+    assert_eq!(deque.binary_search(&0), Err(0));\n+    assert_eq!(deque.binary_search(&1), Ok(0));\n+    assert_eq!(deque.binary_search(&5), Ok(3));\n+    assert_eq!(deque.binary_search(&7), Err(5));\n+    assert_eq!(deque.binary_search(&20), Err(6));\n+}\n+\n+#[test]\n+fn test_binary_search_by() {\n+    let deque: VecDeque<_> = vec![(1,), (2,), (3,), (5,), (6,)].into();\n+\n+    assert_eq!(deque.binary_search_by(|&(v,)| v.cmp(&3)), Ok(2));\n+    assert_eq!(deque.binary_search_by(|&(v,)| v.cmp(&4)), Err(3));\n+}\n+\n+#[test]\n+fn test_binary_search_by_key() {\n+    let deque: VecDeque<_> = vec![(1,), (2,), (3,), (5,), (6,)].into();\n+\n+    assert_eq!(deque.binary_search_by_key(&3, |&(v,)| v), Ok(2));\n+    assert_eq!(deque.binary_search_by_key(&4, |&(v,)| v), Err(3));\n+}"}]}