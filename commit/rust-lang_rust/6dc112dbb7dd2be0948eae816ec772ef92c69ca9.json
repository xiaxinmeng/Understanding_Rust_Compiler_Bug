{"sha": "6dc112dbb7dd2be0948eae816ec772ef92c69ca9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkYzExMmRiYjdkZDJiZTA5NDhlYWU4MTZlYzc3MmVmOTJjNjljYTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-05T17:16:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-05T17:16:03Z"}, "message": "Auto merge of #31349 - nikomatsakis:issue-31157-obligation-forest-cache, r=aturon\n\nHave the `ObligationForest` keep some per-tree state (or type `T`) and have it give a mutable reference for use when processing obligations. In this case, it will be a hashmap. This obviously affects the work that @soltanmm has been doing on snapshotting. I partly want to toss this out there for discussion.\n\nFixes #31157. (The test in question goes to approx. 30s instead of 5 minutes for me.)\ncc #30977.\ncc @aturon @arielb1 @soltanmm\n\nr? @aturon who reviewed original `ObligationForest`", "tree": {"sha": "7d0fc2e142de5fe7696f91e57868a0017adbac1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d0fc2e142de5fe7696f91e57868a0017adbac1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6dc112dbb7dd2be0948eae816ec772ef92c69ca9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6dc112dbb7dd2be0948eae816ec772ef92c69ca9", "html_url": "https://github.com/rust-lang/rust/commit/6dc112dbb7dd2be0948eae816ec772ef92c69ca9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6dc112dbb7dd2be0948eae816ec772ef92c69ca9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98422e8c156d9cf343c93da30f71d9a4cabda25f", "url": "https://api.github.com/repos/rust-lang/rust/commits/98422e8c156d9cf343c93da30f71d9a4cabda25f", "html_url": "https://github.com/rust-lang/rust/commit/98422e8c156d9cf343c93da30f71d9a4cabda25f"}, {"sha": "35d6efb23283994472ce4e17c4df3c9d4d75197e", "url": "https://api.github.com/repos/rust-lang/rust/commits/35d6efb23283994472ce4e17c4df3c9d4d75197e", "html_url": "https://github.com/rust-lang/rust/commit/35d6efb23283994472ce4e17c4df3c9d4d75197e"}], "stats": {"total": 466, "additions": 314, "deletions": 152}, "files": [{"sha": "bb411e76e929bbe935377b9bf08d9c33b9279579", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 123, "deletions": 56, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/6dc112dbb7dd2be0948eae816ec772ef92c69ca9/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc112dbb7dd2be0948eae816ec772ef92c69ca9/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=6dc112dbb7dd2be0948eae816ec772ef92c69ca9", "patch": "@@ -36,6 +36,7 @@ pub struct GlobalFulfilledPredicates<'tcx> {\n     dep_graph: DepGraph,\n }\n \n+#[derive(Debug)]\n pub struct LocalFulfilledPredicates<'tcx> {\n     set: FnvHashSet<ty::Predicate<'tcx>>\n }\n@@ -66,7 +67,8 @@ pub struct FulfillmentContext<'tcx> {\n \n     // A list of all obligations that have been registered with this\n     // fulfillment context.\n-    predicates: ObligationForest<PendingPredicateObligation<'tcx>>,\n+    predicates: ObligationForest<PendingPredicateObligation<'tcx>,\n+                                 LocalFulfilledPredicates<'tcx>>,\n \n     // A set of constraints that regionck must validate. Each\n     // constraint has the form `T:'a`, meaning \"some type `T` must\n@@ -192,7 +194,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n             obligation: obligation,\n             stalled_on: vec![]\n         };\n-        self.predicates.push_root(obligation);\n+        self.predicates.push_tree(obligation, LocalFulfilledPredicates::new());\n     }\n \n     pub fn region_obligations(&self,\n@@ -278,10 +280,11 @@ impl<'tcx> FulfillmentContext<'tcx> {\n             let outcome = {\n                 let region_obligations = &mut self.region_obligations;\n                 self.predicates.process_obligations(\n-                    |obligation, backtrace| process_predicate(selcx,\n-                                                              obligation,\n-                                                              backtrace,\n-                                                              region_obligations))\n+                    |obligation, tree, backtrace| process_predicate(selcx,\n+                                                                     tree,\n+                                                                     obligation,\n+                                                                     backtrace,\n+                                                                     region_obligations))\n             };\n \n             debug!(\"select_where_possible: outcome={:?}\", outcome);\n@@ -315,61 +318,97 @@ impl<'tcx> FulfillmentContext<'tcx> {\n \n /// Like `process_predicate1`, but wrap result into a pending predicate.\n fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n+                              tree_cache: &mut LocalFulfilledPredicates<'tcx>,\n                               pending_obligation: &mut PendingPredicateObligation<'tcx>,\n-                              backtrace: Backtrace<PendingPredicateObligation<'tcx>>,\n+                              mut backtrace: Backtrace<PendingPredicateObligation<'tcx>>,\n                               region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>)\n                               -> Result<Option<Vec<PendingPredicateObligation<'tcx>>>,\n                                         FulfillmentErrorCode<'tcx>>\n {\n-    match process_predicate1(selcx, pending_obligation, backtrace, region_obligations) {\n+    match process_predicate1(selcx, pending_obligation, backtrace.clone(), region_obligations) {\n         Ok(Some(v)) => {\n-            // FIXME(#30977) the right thing to do here, I think, is to permit\n-            // DAGs. That is, we should detect whenever this predicate\n-            // has appeared somewhere in the current tree./ If it's a\n-            // parent, that's a cycle, and we should either error out\n-            // or consider it ok. But if it's NOT a parent, we can\n-            // ignore it, since it will be proven (or not) separately.\n-            // However, this is a touch tricky, so I'm doing something\n-            // a bit hackier for now so that the `huge-struct.rs` passes.\n+            // FIXME(#30977) The code below is designed to detect (and\n+            // permit) DAGs, while still ensuring that the reasoning\n+            // is acyclic. However, it does a few things\n+            // suboptimally. For example, it refreshes type variables\n+            // a lot, probably more than needed, but also less than\n+            // you might want.\n+            //\n+            //   - more than needed: I want to be very sure we don't\n+            //     accidentally treat a cycle as a DAG, so I am\n+            //     refreshing type variables as we walk the ancestors;\n+            //     but we are going to repeat this a lot, which is\n+            //     sort of silly, and it would be nicer to refresh\n+            //     them *in place* so that later predicate processing\n+            //     can benefit from the same work;\n+            //   - less than you might want: we only add items in the cache here,\n+            //     but maybe we learn more about type variables and could add them into\n+            //     the cache later on.\n \n             let tcx = selcx.tcx();\n \n-            let retain_vec: Vec<_> = {\n-                let mut dedup = FnvHashSet();\n-                v.iter()\n-                 .map(|o| {\n+            // Compute a little FnvHashSet for the ancestors. We only\n+            // do this the first time that we care.\n+            let mut cache = None;\n+            let mut is_ancestor = |predicate: &ty::Predicate<'tcx>| {\n+                if cache.is_none() {\n+                    let mut c = FnvHashSet();\n+                    for ancestor in backtrace.by_ref() {\n+                        // Ugh. This just feels ridiculously\n+                        // inefficient.  But we need to compare\n+                        // predicates without being concerned about\n+                        // the vagaries of type inference, so for now\n+                        // just ensure that they are always\n+                        // up-to-date. (I suppose we could just use a\n+                        // snapshot and check if they are unifiable?)\n+                        let resolved_predicate =\n+                            selcx.infcx().resolve_type_vars_if_possible(\n+                                &ancestor.obligation.predicate);\n+                        c.insert(resolved_predicate);\n+                    }\n+                    cache = Some(c);\n+                }\n+\n+                cache.as_ref().unwrap().contains(predicate)\n+            };\n+\n+            let pending_predicate_obligations: Vec<_> =\n+                v.into_iter()\n+                 .filter_map(|obligation| {\n+                     // Probably silly, but remove any inference\n+                     // variables. This is actually crucial to the\n+                     // ancestor check below, but it's not clear that\n+                     // it makes sense to ALWAYS do it.\n+                     let obligation = selcx.infcx().resolve_type_vars_if_possible(&obligation);\n+\n                      // Screen out obligations that we know globally\n                      // are true. This should really be the DAG check\n                      // mentioned above.\n-                     if tcx.fulfilled_predicates.borrow().check_duplicate(&o.predicate) {\n-                         return false;\n+                     if tcx.fulfilled_predicates.borrow().check_duplicate(&obligation.predicate) {\n+                         return None;\n                      }\n \n-                     // If we see two siblings that are exactly the\n-                     // same, no need to add them twice.\n-                     if !dedup.insert(&o.predicate) {\n-                         return false;\n+                     // Check whether this obligation appears somewhere else in the tree.\n+                     if tree_cache.is_duplicate_or_add(&obligation.predicate) {\n+                         // If the obligation appears as a parent,\n+                         // allow it, because that is a cycle.\n+                         // Otherwise though we can just ignore\n+                         // it. Note that we have to be careful around\n+                         // inference variables here -- for the\n+                         // purposes of the ancestor check, we retain\n+                         // the invariant that all type variables are\n+                         // fully refreshed.\n+                         if !(&mut is_ancestor)(&obligation.predicate) {\n+                             return None;\n+                         }\n                      }\n \n-                     true\n+                     Some(PendingPredicateObligation {\n+                         obligation: obligation,\n+                         stalled_on: vec![]\n+                     })\n                  })\n-                 .collect()\n-            };\n-\n-            let pending_predicate_obligations =\n-                v.into_iter()\n-                 .zip(retain_vec)\n-                 .flat_map(|(o, retain)| {\n-                     if retain {\n-                         Some(PendingPredicateObligation {\n-                             obligation: o,\n-                             stalled_on: vec![]\n-                         })\n-                     } else {\n-                         None\n-                     }\n-                 })\n-                .collect();\n+                 .collect();\n \n             Ok(Some(pending_predicate_obligations))\n         }\n@@ -405,7 +444,7 @@ fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n         pending_obligation.stalled_on = vec![];\n     }\n \n-    let obligation = &pending_obligation.obligation;\n+    let obligation = &mut pending_obligation.obligation;\n \n     // If we exceed the recursion limit, take a moment to look for a\n     // cycle so we can give a better error report from here, where we\n@@ -417,18 +456,31 @@ fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n         }\n     }\n \n+    if obligation.predicate.has_infer_types() {\n+        obligation.predicate = selcx.infcx().resolve_type_vars_if_possible(&obligation.predicate);\n+    }\n+\n     match obligation.predicate {\n         ty::Predicate::Trait(ref data) => {\n+            if selcx.tcx().fulfilled_predicates.borrow().check_duplicate_trait(data) {\n+                return Ok(Some(vec![]));\n+            }\n+\n             if coinductive_match(selcx, obligation, data, &backtrace) {\n                 return Ok(Some(vec![]));\n             }\n \n             let trait_obligation = obligation.with(data.clone());\n             match selcx.select(&trait_obligation) {\n                 Ok(Some(vtable)) => {\n+                    info!(\"selecting trait `{:?}` at depth {} yielded Ok(Some)\",\n+                          data, obligation.recursion_depth);\n                     Ok(Some(vtable.nested_obligations()))\n                 }\n                 Ok(None) => {\n+                    info!(\"selecting trait `{:?}` at depth {} yielded Ok(None)\",\n+                          data, obligation.recursion_depth);\n+\n                     // This is a bit subtle: for the most part, the\n                     // only reason we can fail to make progress on\n                     // trait selection is because we don't have enough\n@@ -457,6 +509,8 @@ fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                     Ok(None)\n                 }\n                 Err(selection_err) => {\n+                    info!(\"selecting trait `{:?}` at depth {} yielded Err\",\n+                          data, obligation.recursion_depth);\n                     Err(CodeSelectionError(selection_err))\n                 }\n             }\n@@ -642,18 +696,28 @@ impl<'tcx> GlobalFulfilledPredicates<'tcx> {\n \n     pub fn check_duplicate(&self, key: &ty::Predicate<'tcx>) -> bool {\n         if let ty::Predicate::Trait(ref data) = *key {\n-            // For the global predicate registry, when we find a match, it\n-            // may have been computed by some other task, so we want to\n-            // add a read from the node corresponding to the predicate\n-            // processing to make sure we get the transitive dependencies.\n-            if self.set.contains(data) {\n-                debug_assert!(data.is_global());\n-                self.dep_graph.read(data.dep_node());\n-                return true;\n-            }\n+            self.check_duplicate_trait(data)\n+        } else {\n+            false\n         }\n+    }\n+\n+    pub fn check_duplicate_trait(&self, data: &ty::PolyTraitPredicate<'tcx>) -> bool {\n+        // For the global predicate registry, when we find a match, it\n+        // may have been computed by some other task, so we want to\n+        // add a read from the node corresponding to the predicate\n+        // processing to make sure we get the transitive dependencies.\n+        if self.set.contains(data) {\n+            debug_assert!(data.is_global());\n+            self.dep_graph.read(data.dep_node());\n+            debug!(\"check_duplicate: global predicate `{:?}` already proved elsewhere\", data);\n+\n+            info!(\"check_duplicate_trait hit: `{:?}`\", data);\n \n-        return false;\n+            true\n+        } else {\n+            false\n+        }\n     }\n \n     fn add_if_global(&mut self, key: &ty::Predicate<'tcx>) {\n@@ -663,7 +727,10 @@ impl<'tcx> GlobalFulfilledPredicates<'tcx> {\n             // already has the required read edges, so we don't need\n             // to add any more edges here.\n             if data.is_global() {\n-                self.set.insert(data.clone());\n+                if self.set.insert(data.clone()) {\n+                    debug!(\"add_if_global: global predicate `{:?}` added\", data);\n+                    info!(\"check_duplicate_trait entry: `{:?}`\", data);\n+                }\n             }\n         }\n     }"}, {"sha": "d76d7f6ba340e67c9e563594ed084378ce91cf09", "filename": "src/librustc_data_structures/obligation_forest/README.md", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6dc112dbb7dd2be0948eae816ec772ef92c69ca9/src%2Flibrustc_data_structures%2Fobligation_forest%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/6dc112dbb7dd2be0948eae816ec772ef92c69ca9/src%2Flibrustc_data_structures%2Fobligation_forest%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2FREADME.md?ref=6dc112dbb7dd2be0948eae816ec772ef92c69ca9", "patch": "@@ -9,15 +9,18 @@ place).\n `ObligationForest` supports two main public operations (there are a\n few others not discussed here):\n \n-1. Add a new root obligation (`push_root`).\n+1. Add a new root obligations (`push_tree`).\n 2. Process the pending obligations (`process_obligations`).\n \n When a new obligation `N` is added, it becomes the root of an\n-obligation tree. This tree is a singleton to start, so `N` is both the\n-root and the only leaf. Each time the `process_obligations` method is\n-called, it will invoke its callback with every pending obligation (so\n-that will include `N`, the first time). The callback shoud process the\n-obligation `O` that it is given and return one of three results:\n+obligation tree. This tree can also carry some per-tree state `T`,\n+which is given at the same time. This tree is a singleton to start, so\n+`N` is both the root and the only leaf. Each time the\n+`process_obligations` method is called, it will invoke its callback\n+with every pending obligation (so that will include `N`, the first\n+time). The callback also receives a (mutable) reference to the\n+per-tree state `T`. The callback should process the obligation `O`\n+that it is given and return one of three results:\n \n - `Ok(None)` -> ambiguous result. Obligation was neither a success\n   nor a failure. It is assumed that further attempts to process the"}, {"sha": "25a77adba2820b50e6e0db74913aba76fd32178d", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 98, "deletions": 49, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/6dc112dbb7dd2be0948eae816ec772ef92c69ca9/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc112dbb7dd2be0948eae816ec772ef92c69ca9/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=6dc112dbb7dd2be0948eae816ec772ef92c69ca9", "patch": "@@ -19,11 +19,16 @@ use std::fmt::Debug;\n use std::mem;\n \n mod node_index;\n+use self::node_index::NodeIndex;\n+\n+mod tree_index;\n+use self::tree_index::TreeIndex;\n+\n \n #[cfg(test)]\n mod test;\n \n-pub struct ObligationForest<O> {\n+pub struct ObligationForest<O,T> {\n     /// The list of obligations. In between calls to\n     /// `process_obligations`, this list only contains nodes in the\n     /// `Pending` or `Success` state (with a non-zero number of\n@@ -37,19 +42,23 @@ pub struct ObligationForest<O> {\n     /// at a higher index than its parent. This is needed by the\n     /// backtrace iterator (which uses `split_at`).\n     nodes: Vec<Node<O>>,\n+    trees: Vec<Tree<T>>,\n     snapshots: Vec<usize>\n }\n \n pub struct Snapshot {\n     len: usize,\n }\n \n-pub use self::node_index::NodeIndex;\n+struct Tree<T> {\n+    root: NodeIndex,\n+    state: T,\n+}\n \n struct Node<O> {\n     state: NodeState<O>,\n     parent: Option<NodeIndex>,\n-    root: NodeIndex, // points to the root, which may be the current node\n+    tree: TreeIndex,\n }\n \n /// The state of one node in some tree within the forest. This\n@@ -99,9 +108,10 @@ pub struct Error<O,E> {\n     pub backtrace: Vec<O>,\n }\n \n-impl<O: Debug> ObligationForest<O> {\n-    pub fn new() -> ObligationForest<O> {\n+impl<O: Debug, T: Debug> ObligationForest<O, T> {\n+    pub fn new() -> ObligationForest<O, T> {\n         ObligationForest {\n+            trees: vec![],\n             nodes: vec![],\n             snapshots: vec![]\n         }\n@@ -114,30 +124,39 @@ impl<O: Debug> ObligationForest<O> {\n     }\n \n     pub fn start_snapshot(&mut self) -> Snapshot {\n-        self.snapshots.push(self.nodes.len());\n+        self.snapshots.push(self.trees.len());\n         Snapshot { len: self.snapshots.len() }\n     }\n \n     pub fn commit_snapshot(&mut self, snapshot: Snapshot) {\n         assert_eq!(snapshot.len, self.snapshots.len());\n-        let nodes_len = self.snapshots.pop().unwrap();\n-        assert!(self.nodes.len() >= nodes_len);\n+        let trees_len = self.snapshots.pop().unwrap();\n+        assert!(self.trees.len() >= trees_len);\n     }\n \n     pub fn rollback_snapshot(&mut self, snapshot: Snapshot) {\n         // Check that we are obeying stack discipline.\n         assert_eq!(snapshot.len, self.snapshots.len());\n-        let nodes_len = self.snapshots.pop().unwrap();\n+        let trees_len = self.snapshots.pop().unwrap();\n \n-        // The only action permitted while in a snapshot is to push\n-        // new root obligations. Because no processing will have been\n-        // done, those roots should still be in the pending state.\n-        debug_assert!(self.nodes[nodes_len..].iter().all(|n| match n.state {\n-            NodeState::Pending { .. } => true,\n-            _ => false,\n-        }));\n+        // If nothing happened in snapshot, done.\n+        if self.trees.len() == trees_len {\n+            return;\n+        }\n \n-        self.nodes.truncate(nodes_len);\n+        // Find root of first tree; because nothing can happen in a\n+        // snapshot but pushing trees, all nodes after that should be\n+        // roots of other trees as well\n+        let first_root_index = self.trees[trees_len].root.get();\n+        debug_assert!(\n+            self.nodes[first_root_index..]\n+                .iter()\n+                .zip(first_root_index..)\n+                .all(|(root, root_index)| self.trees[root.tree.get()].root.get() == root_index));\n+\n+        // Pop off tree/root pairs pushed during snapshot.\n+        self.trees.truncate(trees_len);\n+        self.nodes.truncate(first_root_index);\n     }\n \n     pub fn in_snapshot(&self) -> bool {\n@@ -147,9 +166,11 @@ impl<O: Debug> ObligationForest<O> {\n     /// Adds a new tree to the forest.\n     ///\n     /// This CAN be done during a snapshot.\n-    pub fn push_root(&mut self, obligation: O) {\n+    pub fn push_tree(&mut self, obligation: O, tree_state: T) {\n         let index = NodeIndex::new(self.nodes.len());\n-        self.nodes.push(Node::new(index, None, obligation));\n+        let tree = TreeIndex::new(self.trees.len());\n+        self.trees.push(Tree { root: index, state: tree_state });\n+        self.nodes.push(Node::new(tree, None, obligation));\n     }\n \n     /// Convert all remaining obligations to the given error.\n@@ -186,7 +207,7 @@ impl<O: Debug> ObligationForest<O> {\n     ///\n     /// This CANNOT be unrolled (presently, at least).\n     pub fn process_obligations<E,F>(&mut self, mut action: F) -> Outcome<O,E>\n-        where E: Debug, F: FnMut(&mut O, Backtrace<O>) -> Result<Option<Vec<O>>, E>\n+        where E: Debug, F: FnMut(&mut O, &mut T, Backtrace<O>) -> Result<Option<Vec<O>>, E>\n     {\n         debug!(\"process_obligations(len={})\", self.nodes.len());\n         assert!(!self.in_snapshot()); // cannot unroll this action\n@@ -210,15 +231,15 @@ impl<O: Debug> ObligationForest<O> {\n                    index, self.nodes[index].state);\n \n             let result = {\n-                let parent = self.nodes[index].parent;\n+                let Node { tree, parent, .. } = self.nodes[index];\n                 let (prefix, suffix) = self.nodes.split_at_mut(index);\n                 let backtrace = Backtrace::new(prefix, parent);\n                 match suffix[0].state {\n                     NodeState::Error |\n                     NodeState::Success { .. } =>\n                         continue,\n                     NodeState::Pending { ref mut obligation } =>\n-                        action(obligation, backtrace),\n+                        action(obligation, &mut self.trees[tree.get()].state, backtrace),\n                 }\n             };\n \n@@ -268,11 +289,11 @@ impl<O: Debug> ObligationForest<O> {\n             self.update_parent(index);\n         } else {\n             // create child work\n-            let root_index = self.nodes[index].root;\n+            let tree_index = self.nodes[index].tree;\n             let node_index = NodeIndex::new(index);\n             self.nodes.extend(\n                 children.into_iter()\n-                        .map(|o| Node::new(root_index, Some(node_index), o)));\n+                        .map(|o| Node::new(tree_index, Some(node_index), o)));\n         }\n \n         // change state from `Pending` to `Success`, temporarily swapping in `Error`\n@@ -311,8 +332,9 @@ impl<O: Debug> ObligationForest<O> {\n     /// skip the remaining obligations from a tree once some other\n     /// node in the tree is found to be in error.\n     fn inherit_error(&mut self, child: usize) {\n-        let root = self.nodes[child].root.get();\n-        if let NodeState::Error = self.nodes[root].state {\n+        let tree = self.nodes[child].tree;\n+        let root = self.trees[tree.get()].root;\n+        if let NodeState::Error = self.nodes[root.get()].state {\n             self.nodes[child].state = NodeState::Error;\n         }\n     }\n@@ -353,7 +375,8 @@ impl<O: Debug> ObligationForest<O> {\n     /// indices. Cannot be used during a transaction.\n     fn compress(&mut self) -> Vec<O> {\n         assert!(!self.in_snapshot()); // didn't write code to unroll this action\n-        let mut rewrites: Vec<_> = (0..self.nodes.len()).collect();\n+        let mut node_rewrites: Vec<_> = (0..self.nodes.len()).collect();\n+        let mut tree_rewrites: Vec<_> = (0..self.trees.len()).collect();\n \n         // Finish propagating error state. Note that in this case we\n         // only have to check immediate parents, rather than all\n@@ -366,55 +389,81 @@ impl<O: Debug> ObligationForest<O> {\n             }\n         }\n \n+        // Determine which trees to remove by checking if their root\n+        // is popped.\n+        let mut dead_trees = 0;\n+        let trees_len = self.trees.len();\n+        for i in 0..trees_len {\n+            let root_node = self.trees[i].root;\n+            if self.nodes[root_node.get()].is_popped() {\n+                dead_trees += 1;\n+            } else if dead_trees > 0 {\n+                self.trees.swap(i, i - dead_trees);\n+                tree_rewrites[i] -= dead_trees;\n+            }\n+        }\n+\n         // Now go through and move all nodes that are either\n         // successful or which have an error over into to the end of\n         // the list, preserving the relative order of the survivors\n         // (which is important for the `inherit_error` logic).\n-        let mut dead = 0;\n+        let mut dead_nodes = 0;\n         for i in 0..nodes_len {\n             if self.nodes[i].is_popped() {\n-                dead += 1;\n-            } else if dead > 0 {\n-                self.nodes.swap(i, i - dead);\n-                rewrites[i] -= dead;\n+                dead_nodes += 1;\n+            } else if dead_nodes > 0 {\n+                self.nodes.swap(i, i - dead_nodes);\n+                node_rewrites[i] -= dead_nodes;\n             }\n         }\n \n+        // No compression needed.\n+        if dead_nodes == 0 && dead_trees == 0 {\n+            return vec![];\n+        }\n+\n+        // Pop off the trees we killed.\n+        self.trees.truncate(trees_len - dead_trees);\n+\n         // Pop off all the nodes we killed and extract the success\n         // stories.\n         let successful =\n-            (0 .. dead).map(|_| self.nodes.pop().unwrap())\n-                       .flat_map(|node| match node.state {\n-                           NodeState::Error => None,\n-                           NodeState::Pending { .. } => unreachable!(),\n-                           NodeState::Success { obligation, num_incomplete_children } => {\n-                               assert_eq!(num_incomplete_children, 0);\n-                               Some(obligation)\n-                           }\n-                       })\n-                       .collect();\n-\n-        // Adjust the parent indices, since we compressed things.\n+            (0 .. dead_nodes)\n+            .map(|_| self.nodes.pop().unwrap())\n+            .flat_map(|node| match node.state {\n+                NodeState::Error => None,\n+                NodeState::Pending { .. } => unreachable!(),\n+                NodeState::Success { obligation, num_incomplete_children } => {\n+                    assert_eq!(num_incomplete_children, 0);\n+                    Some(obligation)\n+                }\n+            })\n+            .collect();\n+\n+        // Adjust the various indices, since we compressed things.\n+        for tree in &mut self.trees {\n+            tree.root = NodeIndex::new(node_rewrites[tree.root.get()]);\n+        }\n         for node in &mut self.nodes {\n             if let Some(ref mut index) = node.parent {\n-                let new_index = rewrites[index.get()];\n-                debug_assert!(new_index < (nodes_len - dead));\n+                let new_index = node_rewrites[index.get()];\n+                debug_assert!(new_index < (nodes_len - dead_nodes));\n                 *index = NodeIndex::new(new_index);\n             }\n \n-            node.root = NodeIndex::new(rewrites[node.root.get()]);\n+            node.tree = TreeIndex::new(tree_rewrites[node.tree.get()]);\n         }\n \n         successful\n     }\n }\n \n impl<O> Node<O> {\n-    fn new(root: NodeIndex, parent: Option<NodeIndex>, obligation: O) -> Node<O> {\n+    fn new(tree: TreeIndex, parent: Option<NodeIndex>, obligation: O) -> Node<O> {\n         Node {\n             parent: parent,\n             state: NodeState::Pending { obligation: obligation },\n-            root: root\n+            tree: tree,\n         }\n     }\n "}, {"sha": "9a0a4218d4593d662ad1cee5b6217366abf58ab7", "filename": "src/librustc_data_structures/obligation_forest/test.rs", "status": "modified", "additions": 56, "deletions": 41, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/6dc112dbb7dd2be0948eae816ec772ef92c69ca9/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc112dbb7dd2be0948eae816ec772ef92c69ca9/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs?ref=6dc112dbb7dd2be0948eae816ec772ef92c69ca9", "patch": "@@ -13,22 +13,24 @@ use super::{ObligationForest, Outcome, Error};\n #[test]\n fn push_pop() {\n     let mut forest = ObligationForest::new();\n-    forest.push_root(\"A\");\n-    forest.push_root(\"B\");\n-    forest.push_root(\"C\");\n+    forest.push_tree(\"A\", \"A\");\n+    forest.push_tree(\"B\", \"B\");\n+    forest.push_tree(\"C\", \"C\");\n \n     // first round, B errors out, A has subtasks, and C completes, creating this:\n     //      A |-> A.1\n     //        |-> A.2\n     //        |-> A.3\n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(|obligation, _| {\n-        match *obligation {\n-            \"A\" => Ok(Some(vec![\"A.1\", \"A.2\", \"A.3\"])),\n-            \"B\" => Err(\"B is for broken\"),\n-            \"C\" => Ok(Some(vec![])),\n-            _ => unreachable!(),\n-        }\n-    });\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(|obligation, tree, _| {\n+            assert_eq!(obligation.chars().next(), tree.chars().next());\n+            match *obligation {\n+                \"A\" => Ok(Some(vec![\"A.1\", \"A.2\", \"A.3\"])),\n+                \"B\" => Err(\"B is for broken\"),\n+                \"C\" => Ok(Some(vec![])),\n+                _ => unreachable!(),\n+            }\n+        });\n     assert_eq!(ok, vec![\"C\"]);\n     assert_eq!(err, vec![Error {error: \"B is for broken\",\n                                 backtrace: vec![\"B\"]}]);\n@@ -39,9 +41,10 @@ fn push_pop() {\n     //        |-> A.3 |-> A.3.i\n     //      D |-> D.1\n     //        |-> D.2\n-    forest.push_root(\"D\");\n+    forest.push_tree(\"D\", \"D\");\n     let Outcome { completed: ok, errors: err, .. }: Outcome<&'static str, ()> =\n-        forest.process_obligations(|obligation, _| {\n+        forest.process_obligations(|obligation, tree, _| {\n+            assert_eq!(obligation.chars().next(), tree.chars().next());\n             match *obligation {\n                 \"A.1\" => Ok(None),\n                 \"A.2\" => Ok(None),\n@@ -58,26 +61,30 @@ fn push_pop() {\n     // propagates to A.3.i, but not D.1 or D.2.\n     //      D |-> D.1 |-> D.1.i\n     //        |-> D.2 |-> D.2.i\n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(|obligation, _| {\n-        match *obligation {\n-            \"A.1\" => Ok(Some(vec![])),\n-            \"A.2\" => Err(\"A is for apple\"),\n-            \"D.1\" => Ok(Some(vec![\"D.1.i\"])),\n-            \"D.2\" => Ok(Some(vec![\"D.2.i\"])),\n-            _ => unreachable!(),\n-        }\n-    });\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(|obligation, tree, _| {\n+            assert_eq!(obligation.chars().next(), tree.chars().next());\n+            match *obligation {\n+                \"A.1\" => Ok(Some(vec![])),\n+                \"A.2\" => Err(\"A is for apple\"),\n+                \"D.1\" => Ok(Some(vec![\"D.1.i\"])),\n+                \"D.2\" => Ok(Some(vec![\"D.2.i\"])),\n+                _ => unreachable!(),\n+            }\n+        });\n     assert_eq!(ok, vec![\"A.1\"]);\n     assert_eq!(err, vec![Error { error: \"A is for apple\",\n                                  backtrace: vec![\"A.2\", \"A\"] }]);\n \n     // fourth round: error in D.1.i that should propagate to D.2.i\n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(|obligation, _| {\n-        match *obligation {\n-            \"D.1.i\" => Err(\"D is for dumb\"),\n-            _ => panic!(\"unexpected obligation {:?}\", obligation),\n-        }\n-    });\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(|obligation, tree, _| {\n+            assert_eq!(obligation.chars().next(), tree.chars().next());\n+            match *obligation {\n+                \"D.1.i\" => Err(\"D is for dumb\"),\n+                _ => panic!(\"unexpected obligation {:?}\", obligation),\n+            }\n+        });\n     assert_eq!(ok, Vec::<&'static str>::new());\n     assert_eq!(err, vec![Error { error: \"D is for dumb\",\n                                  backtrace: vec![\"D.1.i\", \"D.1\", \"D\"] }]);\n@@ -94,10 +101,11 @@ fn push_pop() {\n #[test]\n fn success_in_grandchildren() {\n     let mut forest = ObligationForest::new();\n-    forest.push_root(\"A\");\n+    forest.push_tree(\"A\", \"A\");\n \n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(),_>(|obligation, _| {\n+        forest.process_obligations::<(),_>(|obligation, tree, _| {\n+            assert_eq!(obligation.chars().next(), tree.chars().next());\n             match *obligation {\n                 \"A\" => Ok(Some(vec![\"A.1\", \"A.2\", \"A.3\"])),\n                 _ => unreachable!(),\n@@ -107,7 +115,8 @@ fn success_in_grandchildren() {\n     assert!(err.is_empty());\n \n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(),_>(|obligation, _| {\n+        forest.process_obligations::<(),_>(|obligation, tree, _| {\n+            assert_eq!(obligation.chars().next(), tree.chars().next());\n             match *obligation {\n                 \"A.1\" => Ok(Some(vec![])),\n                 \"A.2\" => Ok(Some(vec![\"A.2.i\", \"A.2.ii\"])),\n@@ -119,7 +128,8 @@ fn success_in_grandchildren() {\n     assert!(err.is_empty());\n \n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(),_>(|obligation, _| {\n+        forest.process_obligations::<(),_>(|obligation, tree, _| {\n+            assert_eq!(obligation.chars().next(), tree.chars().next());\n             match *obligation {\n                 \"A.2.i\" => Ok(Some(vec![\"A.2.i.a\"])),\n                 \"A.2.ii\" => Ok(Some(vec![])),\n@@ -130,7 +140,8 @@ fn success_in_grandchildren() {\n     assert!(err.is_empty());\n \n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(),_>(|obligation, _| {\n+        forest.process_obligations::<(),_>(|obligation, tree, _| {\n+            assert_eq!(obligation.chars().next(), tree.chars().next());\n             match *obligation {\n                 \"A.2.i.a\" => Ok(Some(vec![])),\n                 _ => unreachable!(),\n@@ -140,7 +151,7 @@ fn success_in_grandchildren() {\n     assert!(err.is_empty());\n \n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(),_>(|_, _| unreachable!());\n+        forest.process_obligations::<(),_>(|_, _, _| unreachable!());\n     assert!(ok.is_empty());\n     assert!(err.is_empty());\n }\n@@ -150,9 +161,10 @@ fn to_errors_no_throw() {\n     // check that converting multiple children with common parent (A)\n     // only yields one of them (and does not panic, in particular).\n     let mut forest = ObligationForest::new();\n-    forest.push_root(\"A\");\n+    forest.push_tree(\"A\", \"A\");\n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(),_>(|obligation, _| {\n+        forest.process_obligations::<(),_>(|obligation, tree, _| {\n+            assert_eq!(obligation.chars().next(), tree.chars().next());\n             match *obligation {\n                 \"A\" => Ok(Some(vec![\"A.1\", \"A.2\", \"A.3\"])),\n                 _ => unreachable!(),\n@@ -168,10 +180,11 @@ fn to_errors_no_throw() {\n fn backtrace() {\n     // check that converting multiple children with common parent (A)\n     // only yields one of them (and does not panic, in particular).\n-    let mut forest: ObligationForest<&'static str> = ObligationForest::new();\n-    forest.push_root(\"A\");\n+    let mut forest = ObligationForest::new();\n+    forest.push_tree(\"A\", \"A\");\n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(),_>(|obligation, mut backtrace| {\n+        forest.process_obligations::<(),_>(|obligation, tree, mut backtrace| {\n+            assert_eq!(obligation.chars().next(), tree.chars().next());\n             assert!(backtrace.next().is_none());\n             match *obligation {\n                 \"A\" => Ok(Some(vec![\"A.1\"])),\n@@ -181,7 +194,8 @@ fn backtrace() {\n     assert!(ok.is_empty());\n     assert!(err.is_empty());\n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(),_>(|obligation, mut backtrace| {\n+        forest.process_obligations::<(),_>(|obligation, tree, mut backtrace| {\n+            assert_eq!(obligation.chars().next(), tree.chars().next());\n             assert!(backtrace.next().unwrap() == &\"A\");\n             assert!(backtrace.next().is_none());\n             match *obligation {\n@@ -192,7 +206,8 @@ fn backtrace() {\n     assert!(ok.is_empty());\n     assert!(err.is_empty());\n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(),_>(|obligation, mut backtrace| {\n+        forest.process_obligations::<(),_>(|obligation, tree, mut backtrace| {\n+            assert_eq!(obligation.chars().next(), tree.chars().next());\n             assert!(backtrace.next().unwrap() == &\"A.1\");\n             assert!(backtrace.next().unwrap() == &\"A\");\n             assert!(backtrace.next().is_none());"}, {"sha": "a9f5483f45b3e24ad71340cb43df2a58e26f0f7a", "filename": "src/librustc_data_structures/obligation_forest/tree_index.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6dc112dbb7dd2be0948eae816ec772ef92c69ca9/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftree_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc112dbb7dd2be0948eae816ec772ef92c69ca9/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftree_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftree_index.rs?ref=6dc112dbb7dd2be0948eae816ec772ef92c69ca9", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::u32;\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub struct TreeIndex {\n+    index: u32\n+}\n+\n+impl TreeIndex {\n+    pub fn new(value: usize) -> TreeIndex {\n+        assert!(value < (u32::MAX as usize));\n+        TreeIndex { index: value as u32 }\n+    }\n+\n+    pub fn get(self) -> usize {\n+        self.index as usize\n+    }\n+}\n+"}]}