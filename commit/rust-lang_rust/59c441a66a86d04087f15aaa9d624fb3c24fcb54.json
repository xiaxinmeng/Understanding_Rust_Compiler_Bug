{"sha": "59c441a66a86d04087f15aaa9d624fb3c24fcb54", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5YzQ0MWE2NmE4NmQwNDA4N2YxNWFhYTlkNjI0ZmIzYzI0ZmNiNTQ=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-07-29T23:40:23Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-07-29T23:40:30Z"}, "message": "Encode, decode, and thread through typechecking all the param kinds, not just the counts.", "tree": {"sha": "b21b5af66371deab773ec64271ec15dcff6646ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b21b5af66371deab773ec64271ec15dcff6646ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59c441a66a86d04087f15aaa9d624fb3c24fcb54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59c441a66a86d04087f15aaa9d624fb3c24fcb54", "html_url": "https://github.com/rust-lang/rust/commit/59c441a66a86d04087f15aaa9d624fb3c24fcb54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59c441a66a86d04087f15aaa9d624fb3c24fcb54/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a684f6078f7f67ae7f6396b3f8f58cc6e78bdc4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a684f6078f7f67ae7f6396b3f8f58cc6e78bdc4c", "html_url": "https://github.com/rust-lang/rust/commit/a684f6078f7f67ae7f6396b3f8f58cc6e78bdc4c"}], "stats": {"total": 247, "additions": 143, "deletions": 104}, "files": [{"sha": "065f4dc66bc1c4621ff2e525dd0f5cbed82c0299", "filename": "src/comp/metadata/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59c441a66a86d04087f15aaa9d624fb3c24fcb54/src%2Fcomp%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59c441a66a86d04087f15aaa9d624fb3c24fcb54/src%2Fcomp%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcommon.rs?ref=59c441a66a86d04087f15aaa9d624fb3c24fcb54", "patch": "@@ -20,9 +20,9 @@ const tag_items_data: uint = 0x08u;\n \n const tag_items_data_item: uint = 0x09u;\n \n-const tag_items_data_item_kind: uint = 0x0au;\n+const tag_items_data_item_family: uint = 0x0au;\n \n-const tag_items_data_item_ty_param_count: uint = 0x0bu;\n+const tag_items_data_item_ty_param_kinds: uint = 0x0bu;\n \n const tag_items_data_item_type: uint = 0x0cu;\n "}, {"sha": "7a397fff317c8288f15f5beb7b5208faf459c24b", "filename": "src/comp/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59c441a66a86d04087f15aaa9d624fb3c24fcb54/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59c441a66a86d04087f15aaa9d624fb3c24fcb54/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcsearch.rs?ref=59c441a66a86d04087f15aaa9d624fb3c24fcb54", "patch": "@@ -35,7 +35,7 @@ fn get_tag_variants(tcx: ty::ctxt, def: ast::def_id) -> ty::variant_info[] {\n     ret decoder::get_tag_variants(cdata, def, tcx, resolver)\n }\n \n-fn get_type(tcx: ty::ctxt, def: ast::def_id) -> ty::ty_param_count_and_ty {\n+fn get_type(tcx: ty::ctxt, def: ast::def_id) -> ty::ty_param_kinds_and_ty {\n     let cstore = tcx.sess.get_cstore();\n     let cnum = def.crate;\n     let cdata = cstore::get_crate_data(cstore, cnum).data;"}, {"sha": "45c9dcf3b37aafc66106e12003f3659cbaa72350", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 40, "deletions": 24, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/59c441a66a86d04087f15aaa9d624fb3c24fcb54/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59c441a66a86d04087f15aaa9d624fb3c24fcb54/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=59c441a66a86d04087f15aaa9d624fb3c24fcb54", "patch": "@@ -20,6 +20,7 @@ export get_symbol;\n export get_tag_variants;\n export get_type;\n export get_type_param_count;\n+export get_type_param_kinds;\n export lookup_defs;\n export get_crate_attributes;\n export list_crate_metadata;\n@@ -77,9 +78,9 @@ fn lookup_item(item_id: int, data: &@u8[]) -> ebmlivec::doc {\n     ret find_item(item_id, items);\n }\n \n-fn item_kind(item: &ebmlivec::doc) -> u8 {\n-    let kind = ebmlivec::get_doc(item, tag_items_data_item_kind);\n-    ret ebmlivec::doc_as_uint(kind) as u8;\n+fn item_family(item: &ebmlivec::doc) -> u8 {\n+    let fam = ebmlivec::get_doc(item, tag_items_data_item_family);\n+    ret ebmlivec::doc_as_uint(fam) as u8;\n }\n \n fn item_symbol(item: &ebmlivec::doc) -> str {\n@@ -113,13 +114,24 @@ fn item_type(item: &ebmlivec::doc, this_cnum: ast::crate_num, tcx: ty::ctxt,\n                       def_parser, tcx);\n }\n \n-fn item_ty_param_count(item: &ebmlivec::doc) -> uint {\n-    let ty_param_count: uint = 0u;\n-    let tp = tag_items_data_item_ty_param_count;\n-    for each p: ebmlivec::doc  in ebmlivec::tagged_docs(item, tp) {\n-        ty_param_count = ebmlivec::vint_at(ebmlivec::doc_data(p), 0u).val;\n+fn item_ty_param_kinds(item: &ebmlivec::doc) -> ast::kind[] {\n+    let ks: ast::kind[] = ~[];\n+    let tp = tag_items_data_item_ty_param_kinds;\n+    for each p: ebmlivec::doc in ebmlivec::tagged_docs(item, tp) {\n+        let dat : u8[] = ebmlivec::doc_data(p);\n+        let vi = ebmlivec::vint_at(dat, 0u);\n+        let i = 0u;\n+        while i < vi.val {\n+            let k = alt dat.(vi.next + i) as char {\n+              'u' { ast::kind_unique }\n+              's' { ast::kind_shared }\n+              'p' { ast::kind_pinned }\n+            };\n+            ks += ~[k];\n+            i += 1u;\n+        }\n     }\n-    ret ty_param_count;\n+    ret ks;\n }\n \n fn tag_variant_ids(item: &ebmlivec::doc, this_cnum: ast::crate_num) ->\n@@ -162,11 +174,11 @@ fn lookup_defs(data: &@u8[], cnum: ast::crate_num, path: &ast::ident[]) ->\n fn lookup_def(cnum: ast::crate_num, data: @u8[], did_: &ast::def_id) ->\n    ast::def {\n     let item = lookup_item(did_.node, data);\n-    let kind_ch = item_kind(item);\n+    let fam_ch = item_family(item);\n     let did = {crate: cnum, node: did_.node};\n     // We treat references to tags as references to types.\n     let def =\n-        alt kind_ch as char {\n+        alt fam_ch as char {\n           'c' { ast::def_const(did) }\n           'f' { ast::def_fn(did, ast::impure_fn) }\n           'p' { ast::def_fn(did, ast::pure_fn) }\n@@ -186,22 +198,26 @@ fn lookup_def(cnum: ast::crate_num, data: @u8[], did_: &ast::def_id) ->\n }\n \n fn get_type(data: @u8[], def: ast::def_id, tcx: &ty::ctxt,\n-            extres: &external_resolver) -> ty::ty_param_count_and_ty {\n+            extres: &external_resolver) -> ty::ty_param_kinds_and_ty {\n     let this_cnum = def.crate;\n     let node_id = def.node;\n     let item = lookup_item(node_id, data);\n     let t = item_type(item, this_cnum, tcx, extres);\n-    let tp_count;\n-    let kind_ch = item_kind(item);\n-    let has_ty_params = kind_has_type_params(kind_ch);\n+    let tp_kinds : ast::kind[];\n+    let fam_ch = item_family(item);\n+    let has_ty_params = family_has_type_params(fam_ch);\n     if has_ty_params {\n-        tp_count = item_ty_param_count(item);\n-    } else { tp_count = 0u; }\n-    ret {count: tp_count, ty: t};\n+        tp_kinds = item_ty_param_kinds(item);\n+    } else { tp_kinds = ~[]; }\n+    ret {kinds: tp_kinds, ty: t};\n }\n \n fn get_type_param_count(data: @u8[], id: ast::node_id) -> uint {\n-    ret item_ty_param_count(lookup_item(id, data));\n+    ret ivec::len(get_type_param_kinds(data, id));\n+}\n+\n+fn get_type_param_kinds(data: @u8[], id: ast::node_id) -> ast::kind[] {\n+    ret item_ty_param_kinds(lookup_item(id, data));\n }\n \n fn get_symbol(data: @u8[], id: ast::node_id) -> str {\n@@ -235,8 +251,8 @@ fn get_tag_variants(data: &@u8[], def: ast::def_id, tcx: &ty::ctxt,\n     ret infos;\n }\n \n-fn kind_has_type_params(kind_ch: u8) -> bool {\n-    ret alt kind_ch as char {\n+fn family_has_type_params(fam_ch: u8) -> bool {\n+    ret alt fam_ch as char {\n           'c' { false }\n           'f' { true }\n           'p' { true }\n@@ -260,11 +276,11 @@ fn read_path(d: &ebmlivec::doc) -> {path: str, pos: uint} {\n \n fn describe_def(items: &ebmlivec::doc, id: ast::def_id) -> str {\n     if id.crate != ast::local_crate { ret \"external\"; }\n-    ret item_kind_to_str(item_kind(find_item(id.node, items)));\n+    ret item_family_to_str(item_family(find_item(id.node, items)));\n }\n \n-fn item_kind_to_str(kind: u8) -> str {\n-    alt kind as char {\n+fn item_family_to_str(fam: u8) -> str {\n+    alt fam as char {\n       'c' { ret \"const\"; }\n       'f' { ret \"fn\"; }\n       'p' { ret \"pred\"; }"}, {"sha": "b9a1fa3886a0f0d40a64e80f6fae66e10658c17e", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 34, "deletions": 26, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/59c441a66a86d04087f15aaa9d624fb3c24fcb54/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59c441a66a86d04087f15aaa9d624fb3c24fcb54/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=59c441a66a86d04087f15aaa9d624fb3c24fcb54", "patch": "@@ -160,17 +160,25 @@ fn encode_item_paths(ebml_w: &ebmlivec::writer, crate: &@crate) ->\n \n \n // Item info table encoding\n-fn encode_kind(ebml_w: &ebmlivec::writer, c: u8) {\n-    ebmlivec::start_tag(ebml_w, tag_items_data_item_kind);\n+fn encode_family(ebml_w: &ebmlivec::writer, c: u8) {\n+    ebmlivec::start_tag(ebml_w, tag_items_data_item_family);\n     ebml_w.writer.write(~[c]);\n     ebmlivec::end_tag(ebml_w);\n }\n \n fn def_to_str(did: &def_id) -> str { ret #fmt(\"%d:%d\", did.crate, did.node); }\n \n-fn encode_type_param_count(ebml_w: &ebmlivec::writer, tps: &ty_param[]) {\n-    ebmlivec::start_tag(ebml_w, tag_items_data_item_ty_param_count);\n+fn encode_type_param_kinds(ebml_w: &ebmlivec::writer, tps: &ty_param[]) {\n+    ebmlivec::start_tag(ebml_w, tag_items_data_item_ty_param_kinds);\n     ebmlivec::write_vint(ebml_w.writer, ivec::len[ty_param](tps));\n+    for tp: ty_param in tps {\n+        let c = alt tp.kind {\n+          kind_unique. { 'u' }\n+          kind_shared. { 's' }\n+          kind_pinned. { 'p' }\n+        };\n+        ebml_w.writer.write(~[c as u8]);\n+    }\n     ebmlivec::end_tag(ebml_w);\n }\n \n@@ -218,15 +226,15 @@ fn encode_tag_variant_info(ecx: &@encode_ctxt, ebml_w: &ebmlivec::writer,\n         index += ~[{val: variant.node.id, pos: ebml_w.writer.tell()}];\n         ebmlivec::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(variant.node.id));\n-        encode_kind(ebml_w, 'v' as u8);\n+        encode_family(ebml_w, 'v' as u8);\n         encode_tag_id(ebml_w, local_def(id));\n         encode_type(ecx, ebml_w,\n                     node_id_to_monotype(ecx.ccx.tcx, variant.node.id));\n         if ivec::len[variant_arg](variant.node.args) > 0u {\n             encode_symbol(ecx, ebml_w, variant.node.id);\n         }\n         encode_discriminant(ecx, ebml_w, variant.node.id);\n-        encode_type_param_count(ebml_w, ty_params);\n+        encode_type_param_kinds(ebml_w, ty_params);\n         ebmlivec::end_tag(ebml_w);\n     }\n }\n@@ -237,47 +245,47 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: &ebmlivec::writer,\n       item_const(_, _) {\n         ebmlivec::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n-        encode_kind(ebml_w, 'c' as u8);\n+        encode_family(ebml_w, 'c' as u8);\n         encode_type(ecx, ebml_w, node_id_to_monotype(ecx.ccx.tcx, item.id));\n         encode_symbol(ecx, ebml_w, item.id);\n         ebmlivec::end_tag(ebml_w);\n       }\n       item_fn(fd, tps) {\n         ebmlivec::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n-        encode_kind(ebml_w,\n+        encode_family(ebml_w,\n                     alt fd.decl.purity { pure_fn. { 'p' } impure_fn. { 'f' } }\n                         as u8);\n-        encode_type_param_count(ebml_w, tps);\n+        encode_type_param_kinds(ebml_w, tps);\n         encode_type(ecx, ebml_w, node_id_to_monotype(ecx.ccx.tcx, item.id));\n         encode_symbol(ecx, ebml_w, item.id);\n         ebmlivec::end_tag(ebml_w);\n       }\n       item_mod(_) {\n         ebmlivec::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n-        encode_kind(ebml_w, 'm' as u8);\n+        encode_family(ebml_w, 'm' as u8);\n         ebmlivec::end_tag(ebml_w);\n       }\n       item_native_mod(_) {\n         ebmlivec::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n-        encode_kind(ebml_w, 'n' as u8);\n+        encode_family(ebml_w, 'n' as u8);\n         ebmlivec::end_tag(ebml_w);\n       }\n       item_ty(_, tps) {\n         ebmlivec::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n-        encode_kind(ebml_w, 'y' as u8);\n-        encode_type_param_count(ebml_w, tps);\n+        encode_family(ebml_w, 'y' as u8);\n+        encode_type_param_kinds(ebml_w, tps);\n         encode_type(ecx, ebml_w, node_id_to_monotype(ecx.ccx.tcx, item.id));\n         ebmlivec::end_tag(ebml_w);\n       }\n       item_tag(variants, tps) {\n         ebmlivec::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n-        encode_kind(ebml_w, 't' as u8);\n-        encode_type_param_count(ebml_w, tps);\n+        encode_family(ebml_w, 't' as u8);\n+        encode_type_param_kinds(ebml_w, tps);\n         encode_type(ecx, ebml_w, node_id_to_monotype(ecx.ccx.tcx, item.id));\n         for v: variant  in variants {\n             encode_variant_id(ebml_w, local_def(v.node.id));\n@@ -290,17 +298,17 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: &ebmlivec::writer,\n \n         ebmlivec::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(ctor_id));\n-        encode_kind(ebml_w, 'y' as u8);\n-        encode_type_param_count(ebml_w, tps);\n+        encode_family(ebml_w, 'y' as u8);\n+        encode_type_param_kinds(ebml_w, tps);\n         encode_type(ecx, ebml_w, ty::ty_fn_ret(ecx.ccx.tcx, fn_ty));\n         encode_symbol(ecx, ebml_w, item.id);\n         ebmlivec::end_tag(ebml_w);\n \n         index += ~[{val: ctor_id, pos: ebml_w.writer.tell()}];\n         ebmlivec::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(ctor_id));\n-        encode_kind(ebml_w, 'f' as u8);\n-        encode_type_param_count(ebml_w, tps);\n+        encode_family(ebml_w, 'f' as u8);\n+        encode_type_param_kinds(ebml_w, tps);\n         encode_type(ecx, ebml_w, fn_ty);\n         encode_symbol(ecx, ebml_w, ctor_id);\n         ebmlivec::end_tag(ebml_w);\n@@ -310,16 +318,16 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: &ebmlivec::writer,\n \n         ebmlivec::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n-        encode_kind(ebml_w, 'y' as u8);\n-        encode_type_param_count(ebml_w, tps);\n+        encode_family(ebml_w, 'y' as u8);\n+        encode_type_param_kinds(ebml_w, tps);\n         encode_type(ecx, ebml_w, ty::ty_fn_ret(ecx.ccx.tcx, fn_ty));\n         ebmlivec::end_tag(ebml_w);\n \n         index += ~[{val: ctor_id, pos: ebml_w.writer.tell()}];\n         ebmlivec::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(ctor_id));\n-        encode_kind(ebml_w, 'f' as u8);\n-        encode_type_param_count(ebml_w, tps);\n+        encode_family(ebml_w, 'f' as u8);\n+        encode_type_param_kinds(ebml_w, tps);\n         encode_type(ecx, ebml_w, fn_ty);\n         encode_symbol(ecx, ebml_w, ctor_id);\n         ebmlivec::end_tag(ebml_w);\n@@ -333,14 +341,14 @@ fn encode_info_for_native_item(ecx: &@encode_ctxt, ebml_w: &ebmlivec::writer,\n     alt nitem.node {\n       native_item_ty. {\n         encode_def_id(ebml_w, local_def(nitem.id));\n-        encode_kind(ebml_w, 'T' as u8);\n+        encode_family(ebml_w, 'T' as u8);\n         encode_type(ecx, ebml_w,\n                     ty::mk_native(ecx.ccx.tcx, local_def(nitem.id)));\n       }\n       native_item_fn(_, _, tps) {\n         encode_def_id(ebml_w, local_def(nitem.id));\n-        encode_kind(ebml_w, 'F' as u8);\n-        encode_type_param_count(ebml_w, tps);\n+        encode_family(ebml_w, 'F' as u8);\n+        encode_type_param_kinds(ebml_w, tps);\n         encode_type(ecx, ebml_w, node_id_to_monotype(ecx.ccx.tcx, nitem.id));\n         encode_symbol(ecx, ebml_w, nitem.id);\n       }"}, {"sha": "1590a8fc0956b72c3fd95b9d5fdb74bc9462f15c", "filename": "src/comp/middle/kind.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/59c441a66a86d04087f15aaa9d624fb3c24fcb54/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59c441a66a86d04087f15aaa9d624fb3c24fcb54/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=59c441a66a86d04087f15aaa9d624fb3c24fcb54", "patch": "@@ -138,6 +138,11 @@ fn check_expr(tcx: &ty::ctxt, e: &@ast::expr) {\n       ast::expr_move(a, b) { need_shared_lhs_rhs(tcx, a, b, \"<-\"); }\n       ast::expr_assign(a, b) { need_shared_lhs_rhs(tcx, a, b, \"=\"); }\n       ast::expr_swap(a, b) { need_shared_lhs_rhs(tcx, a, b, \"<->\"); }\n+      ast::expr_call(callee, args) {\n+        // FIXME: when ready, start checking param kinds against args.\n+        // This will break stdlib again.\n+        // let tpt = ty::expr_ty_params_and_ty(tcx, callee);\n+      }\n       _ { }\n     }\n }"}, {"sha": "5a8efa4f2db9f914a4a910ca7799d7479a87a9c5", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/59c441a66a86d04087f15aaa9d624fb3c24fcb54/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59c441a66a86d04087f15aaa9d624fb3c24fcb54/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=59c441a66a86d04087f15aaa9d624fb3c24fcb54", "patch": "@@ -296,11 +296,12 @@ fn type_of_arg(cx: @local_ctxt, sp: &span, arg: &ty::arg) -> TypeRef {\n     ret typ;\n }\n \n-fn type_of_ty_param_count_and_ty(lcx: @local_ctxt, sp: &span,\n-                                 tpt: &ty::ty_param_count_and_ty) -> TypeRef {\n+fn type_of_ty_param_kinds_and_ty(lcx: @local_ctxt, sp: &span,\n+                                 tpt: &ty::ty_param_kinds_and_ty) -> TypeRef {\n     alt ty::struct(lcx.ccx.tcx, tpt.ty) {\n       ty::ty_fn(_, _, _, _, _) {\n-        let llfnty = type_of_fn_from_ty(lcx.ccx, sp, tpt.ty, tpt.count);\n+        let llfnty = type_of_fn_from_ty(lcx.ccx, sp, tpt.ty,\n+                                        std::ivec::len(tpt.kinds));\n         ret T_fn_pair(*lcx.ccx, llfnty);\n       }\n       _ {\n@@ -3970,14 +3971,14 @@ fn lval_val(cx: &@block_ctxt, val: ValueRef) -> lval_result {\n }\n \n fn trans_external_path(cx: &@block_ctxt, did: &ast::def_id,\n-                       tpt: &ty::ty_param_count_and_ty) -> ValueRef {\n+                       tpt: &ty::ty_param_kinds_and_ty) -> ValueRef {\n     let lcx = cx.fcx.lcx;\n     let name = csearch::get_symbol(lcx.ccx.sess.get_cstore(), did);\n     ret get_extern_const(lcx.ccx.externs, lcx.ccx.llmod, name,\n-                         type_of_ty_param_count_and_ty(lcx, cx.sp, tpt));\n+                         type_of_ty_param_kinds_and_ty(lcx, cx.sp, tpt));\n }\n \n-fn lval_generic_fn(cx: &@block_ctxt, tpt: &ty::ty_param_count_and_ty,\n+fn lval_generic_fn(cx: &@block_ctxt, tpt: &ty::ty_param_kinds_and_ty,\n                    fn_id: &ast::def_id, id: ast::node_id) -> lval_result {\n     let lv;\n     if fn_id.crate == ast::local_crate {\n@@ -4101,10 +4102,11 @@ fn trans_var(cx: &@block_ctxt, sp: &span, id: ast::node_id) ->\n             ret lval_mem(cx, ccx.consts.get(did.node));\n         } else {\n             let tp = ty::node_id_to_monotype(ccx.tcx, id);\n+            let k: ast::kind[] = ~[];\n             ret lval_val(cx,\n                          load_if_immediate(cx,\n                                            trans_external_path(cx, did,\n-                                                               {count: 0u,\n+                                                               {kinds: k,\n                                                                 ty: tp}),\n                                            tp));\n         }"}, {"sha": "c25821b2b63eb761772ce378c628274a62bab598", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/59c441a66a86d04087f15aaa9d624fb3c24fcb54/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59c441a66a86d04087f15aaa9d624fb3c24fcb54/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=59c441a66a86d04087f15aaa9d624fb3c24fcb54", "patch": "@@ -44,6 +44,7 @@ export def_has_ty_params;\n export eq_ty;\n export expr_has_ty_params;\n export expr_ty;\n+export expr_ty_params_and_ty;\n export fold_ty;\n export field;\n export field_idx;\n@@ -113,7 +114,7 @@ export t;\n export tag_variants;\n export tag_variant_with_id;\n export ty_param_substs_opt_and_ty;\n-export ty_param_count_and_ty;\n+export ty_param_kinds_and_ty;\n export ty_native_fn;\n export ty_bool;\n export ty_bot;\n@@ -304,9 +305,9 @@ tag type_err {\n     terr_constr_mismatch(@type_constr, @type_constr);\n }\n \n-type ty_param_count_and_ty = {count: uint, ty: t};\n+type ty_param_kinds_and_ty = {kinds: ast::kind[], ty: t};\n \n-type type_cache = hashmap[ast::def_id, ty_param_count_and_ty];\n+type type_cache = hashmap[ast::def_id, ty_param_kinds_and_ty];\n \n const idx_nil: uint = 0u;\n \n@@ -400,7 +401,7 @@ fn mk_ctxt(s: session::session, dm: resolve::def_map, amap: ast_map::map,\n            freevars: freevars::freevar_map) -> ctxt {\n     let ntt: node_type_table =\n         @smallintmap::mk[ty::ty_param_substs_opt_and_ty]();\n-    let tcache = new_def_hash[ty::ty_param_count_and_ty]();\n+    let tcache = new_def_hash[ty::ty_param_kinds_and_ty]();\n     let ts = @interner::mk[@raw_t](hash_raw_ty, eq_raw_ty);\n     let cx =\n         @{ts: ts,\n@@ -2832,7 +2833,7 @@ fn tag_variant_with_id(cx: &ctxt, tag_id: &ast::def_id,\n \n // If the given item is in an external crate, looks up its type and adds it to\n // the type cache. Returns the type parameters and type.\n-fn lookup_item_type(cx: ctxt, did: ast::def_id) -> ty_param_count_and_ty {\n+fn lookup_item_type(cx: ctxt, did: ast::def_id) -> ty_param_kinds_and_ty {\n     if did.crate == ast::local_crate {\n         // The item is in this crate. The caller should have added it to the\n         // type cache already; we simply return it."}, {"sha": "e6077e2ff0d9671b8f2718d5a1a0fa873c84e2e1", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 46, "deletions": 39, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/59c441a66a86d04087f15aaa9d624fb3c24fcb54/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59c441a66a86d04087f15aaa9d624fb3c24fcb54/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=59c441a66a86d04087f15aaa9d624fb3c24fcb54", "patch": "@@ -25,7 +25,7 @@ import middle::ty::node_type_table;\n import middle::ty::pat_ty;\n import middle::ty::ty_param_substs_opt_and_ty;\n import util::ppaux::ty_to_str;\n-import middle::ty::ty_param_count_and_ty;\n+import middle::ty::ty_param_kinds_and_ty;\n import middle::ty::ty_nil;\n import middle::ty::unify::ures_ok;\n import middle::ty::unify::ures_err;\n@@ -78,7 +78,7 @@ type fn_ctxt =\n \n \n // Used for ast_ty_to_ty() below.\n-type ty_getter = fn(&ast::def_id) -> ty::ty_param_count_and_ty ;\n+type ty_getter = fn(&ast::def_id) -> ty::ty_param_kinds_and_ty ;\n \n fn lookup_local(fcx: &@fn_ctxt, sp: &span, id: ast::node_id) -> int {\n     alt fcx.locals.find(id) {\n@@ -103,23 +103,24 @@ fn lookup_def(fcx: &@fn_ctxt, sp: &span, id: ast::node_id) -> ast::def {\n }\n \n // Returns the type parameter count and the type for the given definition.\n-fn ty_param_count_and_ty_for_def(fcx: &@fn_ctxt, sp: &span, defn: &ast::def)\n-   -> ty_param_count_and_ty {\n+fn ty_param_kinds_and_ty_for_def(fcx: &@fn_ctxt, sp: &span, defn: &ast::def)\n+   -> ty_param_kinds_and_ty {\n+    let no_kinds: ast::kind[] = ~[];\n     alt defn {\n       ast::def_arg(id) {\n         assert (fcx.locals.contains_key(id.node));\n         let typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, id.node));\n-        ret {count: 0u, ty: typ};\n+        ret {kinds: no_kinds, ty: typ};\n       }\n       ast::def_local(id) {\n         assert (fcx.locals.contains_key(id.node));\n         let typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, id.node));\n-        ret {count: 0u, ty: typ};\n+        ret {kinds: no_kinds, ty: typ};\n       }\n       ast::def_obj_field(id) {\n         assert (fcx.locals.contains_key(id.node));\n         let typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, id.node));\n-        ret {count: 0u, ty: typ};\n+        ret {kinds: no_kinds, ty: typ};\n       }\n       ast::def_fn(id, _) { ret ty::lookup_item_type(fcx.ccx.tcx, id); }\n       ast::def_native_fn(id) { ret ty::lookup_item_type(fcx.ccx.tcx, id); }\n@@ -128,13 +129,13 @@ fn ty_param_count_and_ty_for_def(fcx: &@fn_ctxt, sp: &span, defn: &ast::def)\n       ast::def_binding(id) {\n         assert (fcx.locals.contains_key(id.node));\n         let typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, id.node));\n-        ret {count: 0u, ty: typ};\n+        ret {kinds: no_kinds, ty: typ};\n       }\n       ast::def_mod(_) {\n         // Hopefully part of a path.\n         // TODO: return a type that's more poisonous, perhaps?\n \n-        ret {count: 0u, ty: ty::mk_nil(fcx.ccx.tcx)};\n+        ret {kinds: no_kinds, ty: ty::mk_nil(fcx.ccx.tcx)};\n       }\n       ast::def_ty(_) {\n         fcx.ccx.tcx.sess.span_fatal(sp, \"expected value but found type\");\n@@ -151,9 +152,9 @@ fn ty_param_count_and_ty_for_def(fcx: &@fn_ctxt, sp: &span, defn: &ast::def)\n // Instantiates the given path, which must refer to an item with the given\n // number of type parameters and type.\n fn instantiate_path(fcx: &@fn_ctxt, pth: &ast::path,\n-                    tpt: &ty_param_count_and_ty, sp: &span) ->\n+                    tpt: &ty_param_kinds_and_ty, sp: &span) ->\n    ty_param_substs_opt_and_ty {\n-    let ty_param_count = tpt.count;\n+    let ty_param_count = ivec::len(tpt.kinds);\n     let bind_result =\n         bind_params_in_type(sp, fcx.ccx.tcx, bind next_ty_var_id(fcx), tpt.ty,\n                             ty_param_count);\n@@ -287,7 +288,9 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n         // \"foo = int\" like OCaml?\n \n         let params_opt_and_ty = getter(id);\n-        if params_opt_and_ty.count == 0u { ret params_opt_and_ty.ty; }\n+        if ivec::len(params_opt_and_ty.kinds) == 0u {\n+            ret params_opt_and_ty.ty;\n+        }\n         // The typedef is type-parametric. Do the type substitution.\n         //\n \n@@ -421,7 +424,7 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n // ast_ty_to_ty.\n fn ast_ty_to_ty_crate(ccx: @crate_ctxt, ast_ty: &@ast::ty) -> ty::t {\n     fn getter(ccx: @crate_ctxt, id: &ast::def_id) ->\n-       ty::ty_param_count_and_ty {\n+       ty::ty_param_kinds_and_ty {\n         ret ty::lookup_item_type(ccx.tcx, id);\n     }\n     let f = bind getter(ccx, _);\n@@ -512,11 +515,20 @@ mod collect {\n         }\n         ret tps;\n     }\n+\n+    fn ty_param_kinds(tps: &ast::ty_param[]) -> ast::kind[] {\n+        let k: ast::kind[] = ~[];\n+        for p: ast::ty_param in tps {\n+            k += ~[p.kind]\n+        }\n+        ret k;\n+    }\n+\n     fn ty_of_fn_decl(cx: &@ctxt, convert: &fn(&@ast::ty) -> ty::t ,\n                      ty_of_arg: &fn(&ast::arg) -> arg , decl: &ast::fn_decl,\n                      proto: ast::proto, ty_params: &ast::ty_param[],\n                      def_id: &option::t[ast::def_id]) ->\n-       ty::ty_param_count_and_ty {\n+       ty::ty_param_kinds_and_ty {\n         let input_tys = ~[];\n         for a: ast::arg  in decl.inputs { input_tys += ~[ty_of_arg(a)]; }\n         let output_ty = convert(decl.output);\n@@ -528,27 +540,25 @@ mod collect {\n         let t_fn =\n             ty::mk_fn(cx.tcx, proto_to_ty_proto(proto), input_tys, output_ty,\n                       decl.cf, out_constrs);\n-        let ty_param_count = ivec::len[ast::ty_param](ty_params);\n-        let tpt = {count: ty_param_count, ty: t_fn};\n+        let tpt = {kinds: ty_param_kinds(ty_params), ty: t_fn};\n         alt def_id { some(did) { cx.tcx.tcache.insert(did, tpt); } _ { } }\n         ret tpt;\n     }\n     fn ty_of_native_fn_decl(cx: &@ctxt, convert: &fn(&@ast::ty) -> ty::t ,\n                             ty_of_arg: &fn(&ast::arg) -> arg ,\n                             decl: &ast::fn_decl, abi: ast::native_abi,\n                             ty_params: &ast::ty_param[], def_id: &ast::def_id)\n-       -> ty::ty_param_count_and_ty {\n+       -> ty::ty_param_kinds_and_ty {\n         let input_tys = ~[];\n         for a: ast::arg  in decl.inputs { input_tys += ~[ty_of_arg(a)]; }\n         let output_ty = convert(decl.output);\n \n         let t_fn = ty::mk_native_fn(cx.tcx, abi, input_tys, output_ty);\n-        let ty_param_count = ivec::len[ast::ty_param](ty_params);\n-        let tpt = {count: ty_param_count, ty: t_fn};\n+        let tpt = {kinds: ty_param_kinds(ty_params), ty: t_fn};\n         cx.tcx.tcache.insert(def_id, tpt);\n         ret tpt;\n     }\n-    fn getter(cx: @ctxt, id: &ast::def_id) -> ty::ty_param_count_and_ty {\n+    fn getter(cx: @ctxt, id: &ast::def_id) -> ty::ty_param_kinds_and_ty {\n         if id.crate != ast::local_crate {\n             // This is a type we need to load in from the crate reader.\n             ret csearch::get_type(cx.tcx, id);\n@@ -603,15 +613,15 @@ mod collect {\n              constrs: out_constrs};\n     }\n     fn ty_of_obj(cx: @ctxt, id: &ast::ident, ob: &ast::_obj,\n-                 ty_params: &ast::ty_param[]) -> ty::ty_param_count_and_ty {\n+                 ty_params: &ast::ty_param[]) -> ty::ty_param_kinds_and_ty {\n         let methods = get_obj_method_types(cx, ob);\n         let t_obj = ty::mk_obj(cx.tcx, ty::sort_methods(methods));\n         t_obj = ty::rename(cx.tcx, t_obj, id);\n-        ret {count: ivec::len(ty_params), ty: t_obj};\n+        ret {kinds: ty_param_kinds(ty_params), ty: t_obj};\n     }\n     fn ty_of_obj_ctor(cx: @ctxt, id: &ast::ident, ob: &ast::_obj,\n                       ctor_id: ast::node_id, ty_params: &ast::ty_param[]) ->\n-       ty::ty_param_count_and_ty {\n+       ty::ty_param_kinds_and_ty {\n         let t_obj = ty_of_obj(cx, id, ob, ty_params);\n \n         let t_inputs: arg[] = ~[];\n@@ -624,17 +634,18 @@ mod collect {\n         let t_fn =\n             ty::mk_fn(cx.tcx, ast::proto_fn, t_inputs, t_obj.ty, ast::return,\n                       ~[]);\n-        let tpt = {count: t_obj.count, ty: t_fn};\n+        let tpt = {kinds: ty_param_kinds(ty_params), ty: t_fn};\n         cx.tcx.tcache.insert(local_def(ctor_id), tpt);\n         ret tpt;\n     }\n-    fn ty_of_item(cx: &@ctxt, it: &@ast::item) -> ty::ty_param_count_and_ty {\n+    fn ty_of_item(cx: &@ctxt, it: &@ast::item) -> ty::ty_param_kinds_and_ty {\n         let get = bind getter(cx, _);\n         let convert = bind ast_ty_to_ty(cx.tcx, get, _);\n+        let no_kinds: ast::kind[] = ~[];\n         alt it.node {\n           ast::item_const(t, _) {\n             let typ = convert(t);\n-            let tpt = {count: 0u, ty: typ};\n+            let tpt = {kinds: no_kinds, ty: typ};\n             cx.tcx.tcache.insert(local_def(it.id), tpt);\n             ret tpt;\n           }\n@@ -657,15 +668,14 @@ mod collect {\n             // call to resolve any named types.\n \n             let typ = convert(t);\n-            let ty_param_count = ivec::len[ast::ty_param](tps);\n-            let tpt = {count: ty_param_count, ty: typ};\n+            let tpt = {kinds: ty_param_kinds(tps), ty: typ};\n             cx.tcx.tcache.insert(local_def(it.id), tpt);\n             ret tpt;\n           }\n           ast::item_res(f, _, tps, _) {\n             let t_arg = ty_of_arg(cx, f.decl.inputs.(0));\n             let t_res =\n-                {count: ivec::len(tps),\n+                {kinds: ty_param_kinds(tps),\n                  ty:\n                      ty::mk_res(cx.tcx, local_def(it.id), t_arg.ty,\n                                 mk_ty_params(cx, tps))};\n@@ -674,12 +684,9 @@ mod collect {\n           }\n           ast::item_tag(_, tps) {\n             // Create a new generic polytype.\n-\n-            let ty_param_count = ivec::len[ast::ty_param](tps);\n-\n             let subtys: ty::t[] = mk_ty_params(cx, tps);\n             let t = ty::mk_tag(cx.tcx, local_def(it.id), subtys);\n-            let tpt = {count: ty_param_count, ty: t};\n+            let tpt = {kinds: ty_param_kinds(tps), ty: t};\n             cx.tcx.tcache.insert(local_def(it.id), tpt);\n             ret tpt;\n           }\n@@ -688,7 +695,8 @@ mod collect {\n         }\n     }\n     fn ty_of_native_item(cx: &@ctxt, it: &@ast::native_item,\n-                         abi: ast::native_abi) -> ty::ty_param_count_and_ty {\n+                         abi: ast::native_abi) -> ty::ty_param_kinds_and_ty {\n+        let no_kinds: ast::kind[] = ~[];\n         alt it.node {\n           ast::native_item_fn(_, fn_decl, params) {\n             let get = bind getter(cx, _);\n@@ -703,7 +711,7 @@ mod collect {\n               none. { }\n             }\n             let t = ty::mk_native(cx.tcx, ast::local_def(it.id));\n-            let tpt = {count: 0u, ty: t};\n+            let tpt = {kinds: no_kinds, ty: t};\n             cx.tcx.tcache.insert(local_def(it.id), tpt);\n             ret tpt;\n           }\n@@ -714,7 +722,6 @@ mod collect {\n                              ty_params: &ast::ty_param[]) {\n         // Create a set of parameter types shared among all the variants.\n \n-        let ty_param_count = ivec::len[ast::ty_param](ty_params);\n         let ty_param_tys: ty::t[] = mk_ty_params(cx, ty_params);\n         for variant: ast::variant  in variants {\n             // Nullary tag constructors get turned into constants; n-ary tag\n@@ -739,7 +746,7 @@ mod collect {\n                     ty::mk_fn(cx.tcx, ast::proto_fn, args, tag_t, ast::return,\n                               ~[]);\n             }\n-            let tpt = {count: ty_param_count, ty: result_ty};\n+            let tpt = {kinds: ty_param_kinds(ty_params), ty: result_ty};\n             cx.tcx.tcache.insert(local_def(variant.node.id), tpt);\n             write::ty_only(cx.tcx, variant.node.id, result_ty);\n         }\n@@ -819,7 +826,7 @@ mod collect {\n             write::ty_only(cx.tcx, it.id, t_res);\n             write::ty_only(cx.tcx, ctor_id, t_ctor);\n             cx.tcx.tcache.insert(local_def(ctor_id),\n-                                 {count: ivec::len(tps), ty: t_ctor});\n+                                 {kinds: ty_param_kinds(tps), ty: t_ctor});\n             write::ty_only(cx.tcx, dtor_id, t_dtor);\n           }\n           _ {\n@@ -1792,7 +1799,7 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n       }\n       ast::expr_path(pth) {\n         let defn = lookup_def(fcx, pth.span, id);\n-        let tpt = ty_param_count_and_ty_for_def(fcx, expr.span, defn);\n+        let tpt = ty_param_kinds_and_ty_for_def(fcx, expr.span, defn);\n         if ty::def_has_ty_params(defn) {\n             let path_tpot = instantiate_path(fcx, pth, tpt, expr.span);\n             write::ty_fixup(fcx, id, path_tpot);"}]}