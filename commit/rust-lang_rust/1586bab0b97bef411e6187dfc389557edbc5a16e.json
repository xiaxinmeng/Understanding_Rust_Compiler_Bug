{"sha": "1586bab0b97bef411e6187dfc389557edbc5a16e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1ODZiYWIwYjk3YmVmNDExZTYxODdkZmMzODk1NTdlZGJjNWExNmU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-05-10T11:55:24Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-05-10T17:01:26Z"}, "message": "Simplify proto conversion\n\nTrait based infra in conv.rs is significantly more complicated than\nwhat we actually need here.", "tree": {"sha": "f4d8b67d398ca663d003099be63da9ebb7652826", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4d8b67d398ca663d003099be63da9ebb7652826"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1586bab0b97bef411e6187dfc389557edbc5a16e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1586bab0b97bef411e6187dfc389557edbc5a16e", "html_url": "https://github.com/rust-lang/rust/commit/1586bab0b97bef411e6187dfc389557edbc5a16e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1586bab0b97bef411e6187dfc389557edbc5a16e/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4578154b608fa075595103d0c933da60d55b25c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/4578154b608fa075595103d0c933da60d55b25c8", "html_url": "https://github.com/rust-lang/rust/commit/4578154b608fa075595103d0c933da60d55b25c8"}], "stats": {"total": 1746, "additions": 807, "deletions": 939}, "files": [{"sha": "5da28edd24144396e8a3f73f92706f8873529b33", "filename": "crates/ra_ide/src/display/navigation_target.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1586bab0b97bef411e6187dfc389557edbc5a16e/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1586bab0b97bef411e6187dfc389557edbc5a16e/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs?ref=1586bab0b97bef411e6187dfc389557edbc5a16e", "patch": "@@ -11,7 +11,7 @@ use ra_syntax::{\n     TextRange,\n };\n \n-use crate::FileSymbol;\n+use crate::{FileRange, FileSymbol};\n \n use super::short_label::ShortLabel;\n \n@@ -22,10 +22,11 @@ use super::short_label::ShortLabel;\n /// code, like a function or a struct, but this is not strictly required.\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct NavigationTarget {\n+    // FIXME: use FileRange?\n     file_id: FileId,\n+    full_range: TextRange,\n     name: SmolStr,\n     kind: SyntaxKind,\n-    full_range: TextRange,\n     focus_range: Option<TextRange>,\n     container_name: Option<SmolStr>,\n     description: Option<String>,\n@@ -63,6 +64,10 @@ impl NavigationTarget {\n         self.file_id\n     }\n \n+    pub fn file_range(&self) -> FileRange {\n+        FileRange { file_id: self.file_id, range: self.full_range }\n+    }\n+\n     pub fn full_range(&self) -> TextRange {\n         self.full_range\n     }"}, {"sha": "37f77cc47c50a6af30a55325b3ec679391c5e2bf", "filename": "crates/ra_text_edit/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1586bab0b97bef411e6187dfc389557edbc5a16e/crates%2Fra_text_edit%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1586bab0b97bef411e6187dfc389557edbc5a16e/crates%2Fra_text_edit%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_text_edit%2Fsrc%2Flib.rs?ref=1586bab0b97bef411e6187dfc389557edbc5a16e", "patch": "@@ -75,6 +75,7 @@ impl TextEdit {\n         self.indels.is_empty()\n     }\n \n+    // FXME: impl IntoIter instead\n     pub fn as_indels(&self) -> &[Indel] {\n         &self.indels\n     }"}, {"sha": "f64c90b5b17ad2bbbccdbdd92f5e44f4dbacc35d", "filename": "crates/rust-analyzer/src/conv.rs", "status": "removed", "additions": 0, "deletions": 726, "changes": 726, "blob_url": "https://github.com/rust-lang/rust/blob/4578154b608fa075595103d0c933da60d55b25c8/crates%2Frust-analyzer%2Fsrc%2Fconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4578154b608fa075595103d0c933da60d55b25c8/crates%2Frust-analyzer%2Fsrc%2Fconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconv.rs?ref=4578154b608fa075595103d0c933da60d55b25c8", "patch": "@@ -1,726 +0,0 @@\n-//! Convenience module responsible for translating between rust-analyzer's types\n-//! and LSP types.\n-\n-use lsp_types::{\n-    self, CreateFile, DiagnosticSeverity, DocumentChangeOperation, DocumentChanges, Documentation,\n-    Location, LocationLink, MarkupContent, MarkupKind, ParameterInformation, ParameterLabel,\n-    Position, Range, RenameFile, ResourceOp, SemanticTokenModifier, SemanticTokenType,\n-    SignatureInformation, SymbolKind, TextDocumentEdit, TextDocumentIdentifier, TextDocumentItem,\n-    TextDocumentPositionParams, Url, VersionedTextDocumentIdentifier, WorkspaceEdit,\n-};\n-use ra_ide::{\n-    translate_offset_with_edit, CompletionItem, CompletionItemKind, FileId, FilePosition,\n-    FileRange, FileSystemEdit, Fold, FoldKind, Highlight, HighlightModifier, HighlightTag,\n-    InlayHint, InlayKind, InsertTextFormat, LineCol, LineIndex, NavigationTarget, RangeInfo,\n-    ReferenceAccess, Severity, SourceChange, SourceFileEdit,\n-};\n-use ra_syntax::{SyntaxKind, TextRange, TextSize};\n-use ra_text_edit::{Indel, TextEdit};\n-use ra_vfs::LineEndings;\n-\n-use crate::{\n-    req,\n-    semantic_tokens::{self, ModifierSet, CONSTANT, CONTROL_FLOW, MUTABLE, UNSAFE},\n-    world::WorldSnapshot,\n-    Result,\n-};\n-use semantic_tokens::{\n-    ATTRIBUTE, BUILTIN_TYPE, ENUM_MEMBER, FORMAT_SPECIFIER, LIFETIME, TYPE_ALIAS, UNION,\n-    UNRESOLVED_REFERENCE,\n-};\n-\n-pub trait Conv {\n-    type Output;\n-    fn conv(self) -> Self::Output;\n-}\n-\n-pub trait ConvWith<CTX> {\n-    type Output;\n-    fn conv_with(self, ctx: CTX) -> Self::Output;\n-}\n-\n-pub trait TryConvWith<CTX> {\n-    type Output;\n-    fn try_conv_with(self, ctx: CTX) -> Result<Self::Output>;\n-}\n-\n-impl Conv for SyntaxKind {\n-    type Output = SymbolKind;\n-\n-    fn conv(self) -> <Self as Conv>::Output {\n-        match self {\n-            SyntaxKind::FN_DEF => SymbolKind::Function,\n-            SyntaxKind::STRUCT_DEF => SymbolKind::Struct,\n-            SyntaxKind::ENUM_DEF => SymbolKind::Enum,\n-            SyntaxKind::ENUM_VARIANT => SymbolKind::EnumMember,\n-            SyntaxKind::TRAIT_DEF => SymbolKind::Interface,\n-            SyntaxKind::MACRO_CALL => SymbolKind::Function,\n-            SyntaxKind::MODULE => SymbolKind::Module,\n-            SyntaxKind::TYPE_ALIAS_DEF => SymbolKind::TypeParameter,\n-            SyntaxKind::RECORD_FIELD_DEF => SymbolKind::Field,\n-            SyntaxKind::STATIC_DEF => SymbolKind::Constant,\n-            SyntaxKind::CONST_DEF => SymbolKind::Constant,\n-            SyntaxKind::IMPL_DEF => SymbolKind::Object,\n-            _ => SymbolKind::Variable,\n-        }\n-    }\n-}\n-\n-impl Conv for ReferenceAccess {\n-    type Output = ::lsp_types::DocumentHighlightKind;\n-\n-    fn conv(self) -> Self::Output {\n-        use lsp_types::DocumentHighlightKind;\n-        match self {\n-            ReferenceAccess::Read => DocumentHighlightKind::Read,\n-            ReferenceAccess::Write => DocumentHighlightKind::Write,\n-        }\n-    }\n-}\n-\n-impl Conv for CompletionItemKind {\n-    type Output = ::lsp_types::CompletionItemKind;\n-\n-    fn conv(self) -> <Self as Conv>::Output {\n-        use lsp_types::CompletionItemKind::*;\n-        match self {\n-            CompletionItemKind::Keyword => Keyword,\n-            CompletionItemKind::Snippet => Snippet,\n-            CompletionItemKind::Module => Module,\n-            CompletionItemKind::Function => Function,\n-            CompletionItemKind::Struct => Struct,\n-            CompletionItemKind::Enum => Enum,\n-            CompletionItemKind::EnumVariant => EnumMember,\n-            CompletionItemKind::BuiltinType => Struct,\n-            CompletionItemKind::Binding => Variable,\n-            CompletionItemKind::Field => Field,\n-            CompletionItemKind::Trait => Interface,\n-            CompletionItemKind::TypeAlias => Struct,\n-            CompletionItemKind::Const => Constant,\n-            CompletionItemKind::Static => Value,\n-            CompletionItemKind::Method => Method,\n-            CompletionItemKind::TypeParam => TypeParameter,\n-            CompletionItemKind::Macro => Method,\n-            CompletionItemKind::Attribute => EnumMember,\n-        }\n-    }\n-}\n-\n-impl Conv for Severity {\n-    type Output = DiagnosticSeverity;\n-    fn conv(self) -> DiagnosticSeverity {\n-        match self {\n-            Severity::Error => DiagnosticSeverity::Error,\n-            Severity::WeakWarning => DiagnosticSeverity::Hint,\n-        }\n-    }\n-}\n-\n-impl ConvWith<(&LineIndex, LineEndings)> for CompletionItem {\n-    type Output = ::lsp_types::CompletionItem;\n-\n-    fn conv_with(self, ctx: (&LineIndex, LineEndings)) -> ::lsp_types::CompletionItem {\n-        let mut additional_text_edits = Vec::new();\n-        let mut text_edit = None;\n-        // LSP does not allow arbitrary edits in completion, so we have to do a\n-        // non-trivial mapping here.\n-        for indel in self.text_edit().as_indels() {\n-            if indel.delete.contains_range(self.source_range()) {\n-                text_edit = Some(if indel.delete == self.source_range() {\n-                    indel.conv_with((ctx.0, ctx.1))\n-                } else {\n-                    assert!(self.source_range().end() == indel.delete.end());\n-                    let range1 = TextRange::new(indel.delete.start(), self.source_range().start());\n-                    let range2 = self.source_range();\n-                    let edit1 = Indel::replace(range1, String::new());\n-                    let edit2 = Indel::replace(range2, indel.insert.clone());\n-                    additional_text_edits.push(edit1.conv_with((ctx.0, ctx.1)));\n-                    edit2.conv_with((ctx.0, ctx.1))\n-                })\n-            } else {\n-                assert!(self.source_range().intersect(indel.delete).is_none());\n-                additional_text_edits.push(indel.conv_with((ctx.0, ctx.1)));\n-            }\n-        }\n-        let text_edit = text_edit.unwrap();\n-\n-        let mut res = lsp_types::CompletionItem {\n-            label: self.label().to_string(),\n-            detail: self.detail().map(|it| it.to_string()),\n-            filter_text: Some(self.lookup().to_string()),\n-            kind: self.kind().map(|it| it.conv()),\n-            text_edit: Some(text_edit.into()),\n-            additional_text_edits: Some(additional_text_edits),\n-            documentation: self.documentation().map(|it| it.conv()),\n-            deprecated: Some(self.deprecated()),\n-            command: if self.trigger_call_info() {\n-                let cmd = lsp_types::Command {\n-                    title: \"triggerParameterHints\".into(),\n-                    command: \"editor.action.triggerParameterHints\".into(),\n-                    arguments: None,\n-                };\n-                Some(cmd)\n-            } else {\n-                None\n-            },\n-            ..Default::default()\n-        };\n-\n-        if self.score().is_some() {\n-            res.preselect = Some(true)\n-        }\n-\n-        if self.deprecated() {\n-            res.tags = Some(vec![lsp_types::CompletionItemTag::Deprecated])\n-        }\n-\n-        res.insert_text_format = Some(match self.insert_text_format() {\n-            InsertTextFormat::Snippet => lsp_types::InsertTextFormat::Snippet,\n-            InsertTextFormat::PlainText => lsp_types::InsertTextFormat::PlainText,\n-        });\n-\n-        res\n-    }\n-}\n-\n-impl ConvWith<&LineIndex> for Position {\n-    type Output = TextSize;\n-\n-    fn conv_with(self, line_index: &LineIndex) -> TextSize {\n-        let line_col = LineCol { line: self.line as u32, col_utf16: self.character as u32 };\n-        line_index.offset(line_col)\n-    }\n-}\n-\n-impl ConvWith<&LineIndex> for TextSize {\n-    type Output = Position;\n-\n-    fn conv_with(self, line_index: &LineIndex) -> Position {\n-        let line_col = line_index.line_col(self);\n-        Position::new(u64::from(line_col.line), u64::from(line_col.col_utf16))\n-    }\n-}\n-\n-impl ConvWith<&LineIndex> for TextRange {\n-    type Output = Range;\n-\n-    fn conv_with(self, line_index: &LineIndex) -> Range {\n-        Range::new(self.start().conv_with(line_index), self.end().conv_with(line_index))\n-    }\n-}\n-\n-impl ConvWith<&LineIndex> for Range {\n-    type Output = TextRange;\n-\n-    fn conv_with(self, line_index: &LineIndex) -> TextRange {\n-        TextRange::new(self.start.conv_with(line_index), self.end.conv_with(line_index))\n-    }\n-}\n-\n-impl Conv for ra_ide::Documentation {\n-    type Output = lsp_types::Documentation;\n-    fn conv(self) -> Documentation {\n-        Documentation::MarkupContent(MarkupContent {\n-            kind: MarkupKind::Markdown,\n-            value: crate::markdown::format_docs(self.as_str()),\n-        })\n-    }\n-}\n-\n-impl ConvWith<bool> for ra_ide::FunctionSignature {\n-    type Output = lsp_types::SignatureInformation;\n-    fn conv_with(self, concise: bool) -> Self::Output {\n-        let (label, documentation, params) = if concise {\n-            let mut params = self.parameters;\n-            if self.has_self_param {\n-                params.remove(0);\n-            }\n-            (params.join(\", \"), None, params)\n-        } else {\n-            (self.to_string(), self.doc.map(|it| it.conv()), self.parameters)\n-        };\n-\n-        let parameters: Vec<ParameterInformation> = params\n-            .into_iter()\n-            .map(|param| ParameterInformation {\n-                label: ParameterLabel::Simple(param),\n-                documentation: None,\n-            })\n-            .collect();\n-\n-        SignatureInformation { label, documentation, parameters: Some(parameters) }\n-    }\n-}\n-\n-impl ConvWith<(&LineIndex, LineEndings)> for TextEdit {\n-    type Output = Vec<lsp_types::TextEdit>;\n-\n-    fn conv_with(self, ctx: (&LineIndex, LineEndings)) -> Vec<lsp_types::TextEdit> {\n-        self.as_indels().iter().map_conv_with(ctx).collect()\n-    }\n-}\n-\n-impl ConvWith<(&LineIndex, LineEndings)> for &Indel {\n-    type Output = lsp_types::TextEdit;\n-\n-    fn conv_with(\n-        self,\n-        (line_index, line_endings): (&LineIndex, LineEndings),\n-    ) -> lsp_types::TextEdit {\n-        let mut new_text = self.insert.clone();\n-        if line_endings == LineEndings::Dos {\n-            new_text = new_text.replace('\\n', \"\\r\\n\");\n-        }\n-        lsp_types::TextEdit { range: self.delete.conv_with(line_index), new_text }\n-    }\n-}\n-\n-pub(crate) struct FoldConvCtx<'a> {\n-    pub(crate) text: &'a str,\n-    pub(crate) line_index: &'a LineIndex,\n-    pub(crate) line_folding_only: bool,\n-}\n-\n-impl ConvWith<&FoldConvCtx<'_>> for Fold {\n-    type Output = lsp_types::FoldingRange;\n-\n-    fn conv_with(self, ctx: &FoldConvCtx) -> lsp_types::FoldingRange {\n-        let kind = match self.kind {\n-            FoldKind::Comment => Some(lsp_types::FoldingRangeKind::Comment),\n-            FoldKind::Imports => Some(lsp_types::FoldingRangeKind::Imports),\n-            FoldKind::Mods => None,\n-            FoldKind::Block => None,\n-        };\n-\n-        let range = self.range.conv_with(&ctx.line_index);\n-\n-        if ctx.line_folding_only {\n-            // Clients with line_folding_only == true (such as VSCode) will fold the whole end line\n-            // even if it contains text not in the folding range. To prevent that we exclude\n-            // range.end.line from the folding region if there is more text after range.end\n-            // on the same line.\n-            let has_more_text_on_end_line = ctx.text\n-                [TextRange::new(self.range.end(), TextSize::of(ctx.text))]\n-            .chars()\n-            .take_while(|it| *it != '\\n')\n-            .any(|it| !it.is_whitespace());\n-\n-            let end_line = if has_more_text_on_end_line {\n-                range.end.line.saturating_sub(1)\n-            } else {\n-                range.end.line\n-            };\n-\n-            lsp_types::FoldingRange {\n-                start_line: range.start.line,\n-                start_character: None,\n-                end_line,\n-                end_character: None,\n-                kind,\n-            }\n-        } else {\n-            lsp_types::FoldingRange {\n-                start_line: range.start.line,\n-                start_character: Some(range.start.character),\n-                end_line: range.end.line,\n-                end_character: Some(range.end.character),\n-                kind,\n-            }\n-        }\n-    }\n-}\n-\n-impl ConvWith<&LineIndex> for InlayHint {\n-    type Output = req::InlayHint;\n-    fn conv_with(self, line_index: &LineIndex) -> Self::Output {\n-        req::InlayHint {\n-            label: self.label.to_string(),\n-            range: self.range.conv_with(line_index),\n-            kind: match self.kind {\n-                InlayKind::ParameterHint => req::InlayKind::ParameterHint,\n-                InlayKind::TypeHint => req::InlayKind::TypeHint,\n-                InlayKind::ChainingHint => req::InlayKind::ChainingHint,\n-            },\n-        }\n-    }\n-}\n-\n-impl Conv for Highlight {\n-    type Output = (u32, u32);\n-\n-    fn conv(self) -> Self::Output {\n-        let mut mods = ModifierSet::default();\n-        let type_ = match self.tag {\n-            HighlightTag::Struct => SemanticTokenType::STRUCT,\n-            HighlightTag::Enum => SemanticTokenType::ENUM,\n-            HighlightTag::Union => UNION,\n-            HighlightTag::TypeAlias => TYPE_ALIAS,\n-            HighlightTag::Trait => SemanticTokenType::INTERFACE,\n-            HighlightTag::BuiltinType => BUILTIN_TYPE,\n-            HighlightTag::SelfType => SemanticTokenType::TYPE,\n-            HighlightTag::Field => SemanticTokenType::MEMBER,\n-            HighlightTag::Function => SemanticTokenType::FUNCTION,\n-            HighlightTag::Module => SemanticTokenType::NAMESPACE,\n-            HighlightTag::Constant => {\n-                mods |= CONSTANT;\n-                mods |= SemanticTokenModifier::STATIC;\n-                SemanticTokenType::VARIABLE\n-            }\n-            HighlightTag::Static => {\n-                mods |= SemanticTokenModifier::STATIC;\n-                SemanticTokenType::VARIABLE\n-            }\n-            HighlightTag::EnumVariant => ENUM_MEMBER,\n-            HighlightTag::Macro => SemanticTokenType::MACRO,\n-            HighlightTag::Local => SemanticTokenType::VARIABLE,\n-            HighlightTag::TypeParam => SemanticTokenType::TYPE_PARAMETER,\n-            HighlightTag::Lifetime => LIFETIME,\n-            HighlightTag::ByteLiteral | HighlightTag::NumericLiteral => SemanticTokenType::NUMBER,\n-            HighlightTag::CharLiteral | HighlightTag::StringLiteral => SemanticTokenType::STRING,\n-            HighlightTag::Comment => SemanticTokenType::COMMENT,\n-            HighlightTag::Attribute => ATTRIBUTE,\n-            HighlightTag::Keyword => SemanticTokenType::KEYWORD,\n-            HighlightTag::UnresolvedReference => UNRESOLVED_REFERENCE,\n-            HighlightTag::FormatSpecifier => FORMAT_SPECIFIER,\n-        };\n-\n-        for modifier in self.modifiers.iter() {\n-            let modifier = match modifier {\n-                HighlightModifier::Definition => SemanticTokenModifier::DECLARATION,\n-                HighlightModifier::ControlFlow => CONTROL_FLOW,\n-                HighlightModifier::Mutable => MUTABLE,\n-                HighlightModifier::Unsafe => UNSAFE,\n-            };\n-            mods |= modifier;\n-        }\n-\n-        (semantic_tokens::type_index(type_), mods.0)\n-    }\n-}\n-\n-impl<T: ConvWith<CTX>, CTX> ConvWith<CTX> for Option<T> {\n-    type Output = Option<T::Output>;\n-\n-    fn conv_with(self, ctx: CTX) -> Self::Output {\n-        self.map(|x| ConvWith::conv_with(x, ctx))\n-    }\n-}\n-\n-impl TryConvWith<&WorldSnapshot> for &Url {\n-    type Output = FileId;\n-    fn try_conv_with(self, world: &WorldSnapshot) -> Result<FileId> {\n-        world.uri_to_file_id(self)\n-    }\n-}\n-\n-impl TryConvWith<&WorldSnapshot> for FileId {\n-    type Output = Url;\n-    fn try_conv_with(self, world: &WorldSnapshot) -> Result<Url> {\n-        world.file_id_to_uri(self)\n-    }\n-}\n-\n-impl TryConvWith<&WorldSnapshot> for &TextDocumentItem {\n-    type Output = FileId;\n-    fn try_conv_with(self, world: &WorldSnapshot) -> Result<FileId> {\n-        self.uri.try_conv_with(world)\n-    }\n-}\n-\n-impl TryConvWith<&WorldSnapshot> for &VersionedTextDocumentIdentifier {\n-    type Output = FileId;\n-    fn try_conv_with(self, world: &WorldSnapshot) -> Result<FileId> {\n-        self.uri.try_conv_with(world)\n-    }\n-}\n-\n-impl TryConvWith<&WorldSnapshot> for &TextDocumentIdentifier {\n-    type Output = FileId;\n-    fn try_conv_with(self, world: &WorldSnapshot) -> Result<FileId> {\n-        world.uri_to_file_id(&self.uri)\n-    }\n-}\n-\n-impl TryConvWith<&WorldSnapshot> for &TextDocumentPositionParams {\n-    type Output = FilePosition;\n-    fn try_conv_with(self, world: &WorldSnapshot) -> Result<FilePosition> {\n-        let file_id = self.text_document.try_conv_with(world)?;\n-        let line_index = world.analysis().file_line_index(file_id)?;\n-        let offset = self.position.conv_with(&line_index);\n-        Ok(FilePosition { file_id, offset })\n-    }\n-}\n-\n-impl TryConvWith<&WorldSnapshot> for (&TextDocumentIdentifier, Range) {\n-    type Output = FileRange;\n-    fn try_conv_with(self, world: &WorldSnapshot) -> Result<FileRange> {\n-        let file_id = self.0.try_conv_with(world)?;\n-        let line_index = world.analysis().file_line_index(file_id)?;\n-        let range = self.1.conv_with(&line_index);\n-        Ok(FileRange { file_id, range })\n-    }\n-}\n-\n-impl<T: TryConvWith<CTX>, CTX: Copy> TryConvWith<CTX> for Vec<T> {\n-    type Output = Vec<<T as TryConvWith<CTX>>::Output>;\n-    fn try_conv_with(self, ctx: CTX) -> Result<Self::Output> {\n-        let mut res = Vec::with_capacity(self.len());\n-        for item in self {\n-            res.push(item.try_conv_with(ctx)?);\n-        }\n-        Ok(res)\n-    }\n-}\n-\n-impl TryConvWith<&WorldSnapshot> for SourceChange {\n-    type Output = req::SourceChange;\n-    fn try_conv_with(self, world: &WorldSnapshot) -> Result<req::SourceChange> {\n-        let cursor_position = match self.cursor_position {\n-            None => None,\n-            Some(pos) => {\n-                let line_index = world.analysis().file_line_index(pos.file_id)?;\n-                let edit = self\n-                    .source_file_edits\n-                    .iter()\n-                    .find(|it| it.file_id == pos.file_id)\n-                    .map(|it| &it.edit);\n-                let line_col = match edit {\n-                    Some(edit) => translate_offset_with_edit(&*line_index, pos.offset, edit),\n-                    None => line_index.line_col(pos.offset),\n-                };\n-                let position =\n-                    Position::new(u64::from(line_col.line), u64::from(line_col.col_utf16));\n-                Some(TextDocumentPositionParams {\n-                    text_document: TextDocumentIdentifier::new(pos.file_id.try_conv_with(world)?),\n-                    position,\n-                })\n-            }\n-        };\n-        let mut document_changes: Vec<DocumentChangeOperation> = Vec::new();\n-        for resource_op in self.file_system_edits.try_conv_with(world)? {\n-            document_changes.push(DocumentChangeOperation::Op(resource_op));\n-        }\n-        for text_document_edit in self.source_file_edits.try_conv_with(world)? {\n-            document_changes.push(DocumentChangeOperation::Edit(text_document_edit));\n-        }\n-        let workspace_edit = WorkspaceEdit {\n-            changes: None,\n-            document_changes: Some(DocumentChanges::Operations(document_changes)),\n-        };\n-        Ok(req::SourceChange { label: self.label, workspace_edit, cursor_position })\n-    }\n-}\n-\n-impl TryConvWith<&WorldSnapshot> for SourceFileEdit {\n-    type Output = TextDocumentEdit;\n-    fn try_conv_with(self, world: &WorldSnapshot) -> Result<TextDocumentEdit> {\n-        let text_document = VersionedTextDocumentIdentifier {\n-            uri: self.file_id.try_conv_with(world)?,\n-            version: None,\n-        };\n-        let line_index = world.analysis().file_line_index(self.file_id)?;\n-        let line_endings = world.file_line_endings(self.file_id);\n-        let edits =\n-            self.edit.as_indels().iter().map_conv_with((&line_index, line_endings)).collect();\n-        Ok(TextDocumentEdit { text_document, edits })\n-    }\n-}\n-\n-impl TryConvWith<&WorldSnapshot> for FileSystemEdit {\n-    type Output = ResourceOp;\n-    fn try_conv_with(self, world: &WorldSnapshot) -> Result<ResourceOp> {\n-        let res = match self {\n-            FileSystemEdit::CreateFile { source_root, path } => {\n-                let uri = world.path_to_uri(source_root, &path)?;\n-                ResourceOp::Create(CreateFile { uri, options: None })\n-            }\n-            FileSystemEdit::MoveFile { src, dst_source_root, dst_path } => {\n-                let old_uri = world.file_id_to_uri(src)?;\n-                let new_uri = world.path_to_uri(dst_source_root, &dst_path)?;\n-                ResourceOp::Rename(RenameFile { old_uri, new_uri, options: None })\n-            }\n-        };\n-        Ok(res)\n-    }\n-}\n-\n-impl TryConvWith<&WorldSnapshot> for &NavigationTarget {\n-    type Output = Location;\n-    fn try_conv_with(self, world: &WorldSnapshot) -> Result<Location> {\n-        let line_index = world.analysis().file_line_index(self.file_id())?;\n-        let range = self.range();\n-        to_location(self.file_id(), range, &world, &line_index)\n-    }\n-}\n-\n-impl TryConvWith<&WorldSnapshot> for (FileId, RangeInfo<NavigationTarget>) {\n-    type Output = LocationLink;\n-    fn try_conv_with(self, world: &WorldSnapshot) -> Result<LocationLink> {\n-        let (src_file_id, target) = self;\n-\n-        let target_uri = target.info.file_id().try_conv_with(world)?;\n-        let src_line_index = world.analysis().file_line_index(src_file_id)?;\n-        let tgt_line_index = world.analysis().file_line_index(target.info.file_id())?;\n-\n-        let target_range = target.info.full_range().conv_with(&tgt_line_index);\n-\n-        let target_selection_range = target\n-            .info\n-            .focus_range()\n-            .map(|it| it.conv_with(&tgt_line_index))\n-            .unwrap_or(target_range);\n-\n-        let res = LocationLink {\n-            origin_selection_range: Some(target.range.conv_with(&src_line_index)),\n-            target_uri,\n-            target_range,\n-            target_selection_range,\n-        };\n-        Ok(res)\n-    }\n-}\n-\n-impl TryConvWith<&WorldSnapshot> for (FileId, RangeInfo<Vec<NavigationTarget>>) {\n-    type Output = req::GotoDefinitionResponse;\n-    fn try_conv_with(self, world: &WorldSnapshot) -> Result<req::GotoTypeDefinitionResponse> {\n-        let (file_id, RangeInfo { range, info: navs }) = self;\n-        let links = navs\n-            .into_iter()\n-            .map(|nav| (file_id, RangeInfo::new(range, nav)))\n-            .try_conv_with_to_vec(world)?;\n-        if world.config.client_caps.location_link {\n-            Ok(links.into())\n-        } else {\n-            let locations: Vec<Location> = links\n-                .into_iter()\n-                .map(|link| Location { uri: link.target_uri, range: link.target_selection_range })\n-                .collect();\n-            Ok(locations.into())\n-        }\n-    }\n-}\n-\n-pub fn to_call_hierarchy_item(\n-    file_id: FileId,\n-    range: TextRange,\n-    world: &WorldSnapshot,\n-    line_index: &LineIndex,\n-    nav: NavigationTarget,\n-) -> Result<lsp_types::CallHierarchyItem> {\n-    Ok(lsp_types::CallHierarchyItem {\n-        name: nav.name().to_string(),\n-        kind: nav.kind().conv(),\n-        tags: None,\n-        detail: nav.description().map(|it| it.to_string()),\n-        uri: file_id.try_conv_with(&world)?,\n-        range: nav.range().conv_with(&line_index),\n-        selection_range: range.conv_with(&line_index),\n-    })\n-}\n-\n-pub fn to_location(\n-    file_id: FileId,\n-    range: TextRange,\n-    world: &WorldSnapshot,\n-    line_index: &LineIndex,\n-) -> Result<Location> {\n-    let url = file_id.try_conv_with(world)?;\n-    let loc = Location::new(url, range.conv_with(line_index));\n-    Ok(loc)\n-}\n-\n-pub trait MapConvWith<CTX>: Sized {\n-    type Output;\n-\n-    fn map_conv_with(self, ctx: CTX) -> ConvWithIter<Self, CTX> {\n-        ConvWithIter { iter: self, ctx }\n-    }\n-}\n-\n-impl<CTX, I> MapConvWith<CTX> for I\n-where\n-    I: Iterator,\n-    I::Item: ConvWith<CTX>,\n-{\n-    type Output = <I::Item as ConvWith<CTX>>::Output;\n-}\n-\n-pub struct ConvWithIter<I, CTX> {\n-    iter: I,\n-    ctx: CTX,\n-}\n-\n-impl<I, CTX> Iterator for ConvWithIter<I, CTX>\n-where\n-    I: Iterator,\n-    I::Item: ConvWith<CTX>,\n-    CTX: Copy,\n-{\n-    type Item = <I::Item as ConvWith<CTX>>::Output;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        self.iter.next().map(|item| item.conv_with(self.ctx))\n-    }\n-}\n-\n-pub trait TryConvWithToVec<CTX>: Sized {\n-    type Output;\n-\n-    fn try_conv_with_to_vec(self, ctx: CTX) -> Result<Vec<Self::Output>>;\n-}\n-\n-impl<I, CTX> TryConvWithToVec<CTX> for I\n-where\n-    I: Iterator,\n-    I::Item: TryConvWith<CTX>,\n-    CTX: Copy,\n-{\n-    type Output = <I::Item as TryConvWith<CTX>>::Output;\n-\n-    fn try_conv_with_to_vec(self, ctx: CTX) -> Result<Vec<Self::Output>> {\n-        self.map(|it| it.try_conv_with(ctx)).collect()\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use test_utils::extract_ranges;\n-\n-    #[test]\n-    fn conv_fold_line_folding_only_fixup() {\n-        let text = r#\"<fold>mod a;\n-mod b;\n-mod c;</fold>\n-\n-fn main() <fold>{\n-    if cond <fold>{\n-        a::do_a();\n-    }</fold> else <fold>{\n-        b::do_b();\n-    }</fold>\n-}</fold>\"#;\n-\n-        let (ranges, text) = extract_ranges(text, \"fold\");\n-        assert_eq!(ranges.len(), 4);\n-        let folds = vec![\n-            Fold { range: ranges[0], kind: FoldKind::Mods },\n-            Fold { range: ranges[1], kind: FoldKind::Block },\n-            Fold { range: ranges[2], kind: FoldKind::Block },\n-            Fold { range: ranges[3], kind: FoldKind::Block },\n-        ];\n-\n-        let line_index = LineIndex::new(&text);\n-        let ctx = FoldConvCtx { text: &text, line_index: &line_index, line_folding_only: true };\n-        let converted: Vec<_> = folds.into_iter().map_conv_with(&ctx).collect();\n-\n-        let expected_lines = [(0, 2), (4, 10), (5, 6), (7, 9)];\n-        assert_eq!(converted.len(), expected_lines.len());\n-        for (folding_range, (start_line, end_line)) in converted.iter().zip(expected_lines.iter()) {\n-            assert_eq!(folding_range.start_line, *start_line);\n-            assert_eq!(folding_range.start_character, None);\n-            assert_eq!(folding_range.end_line, *end_line);\n-            assert_eq!(folding_range.end_character, None);\n-        }\n-    }\n-}"}, {"sha": "4bb16a496c09555739a12cae8af52803332b9576", "filename": "crates/rust-analyzer/src/from_proto.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1586bab0b97bef411e6187dfc389557edbc5a16e/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1586bab0b97bef411e6187dfc389557edbc5a16e/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs?ref=1586bab0b97bef411e6187dfc389557edbc5a16e", "patch": "@@ -0,0 +1,42 @@\n+//! Conversion lsp_types types to rust-analyzer specific ones.\n+use ra_db::{FileId, FilePosition, FileRange};\n+use ra_ide::{LineCol, LineIndex};\n+use ra_syntax::{TextRange, TextSize};\n+\n+use crate::{world::WorldSnapshot, Result};\n+\n+pub(crate) fn offset(line_index: &LineIndex, position: lsp_types::Position) -> TextSize {\n+    let line_col = LineCol { line: position.line as u32, col_utf16: position.character as u32 };\n+    line_index.offset(line_col)\n+}\n+\n+pub(crate) fn text_range(line_index: &LineIndex, range: lsp_types::Range) -> TextRange {\n+    let start = offset(line_index, range.start);\n+    let end = offset(line_index, range.end);\n+    TextRange::new(start, end)\n+}\n+\n+pub(crate) fn file_id(world: &WorldSnapshot, url: &lsp_types::Url) -> Result<FileId> {\n+    world.uri_to_file_id(url)\n+}\n+\n+pub(crate) fn file_position(\n+    world: &WorldSnapshot,\n+    tdpp: lsp_types::TextDocumentPositionParams,\n+) -> Result<FilePosition> {\n+    let file_id = file_id(world, &tdpp.text_document.uri)?;\n+    let line_index = world.analysis().file_line_index(file_id)?;\n+    let offset = offset(&*line_index, tdpp.position);\n+    Ok(FilePosition { file_id, offset })\n+}\n+\n+pub(crate) fn file_range(\n+    world: &WorldSnapshot,\n+    text_document_identifier: lsp_types::TextDocumentIdentifier,\n+    range: lsp_types::Range,\n+) -> Result<FileRange> {\n+    let file_id = file_id(world, &text_document_identifier.uri)?;\n+    let line_index = world.analysis().file_line_index(file_id)?;\n+    let range = text_range(&line_index, range);\n+    Ok(FileRange { file_id, range })\n+}"}, {"sha": "6d719108c31a42832579ebd421589950f2f5a226", "filename": "crates/rust-analyzer/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1586bab0b97bef411e6187dfc389557edbc5a16e/crates%2Frust-analyzer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1586bab0b97bef411e6187dfc389557edbc5a16e/crates%2Frust-analyzer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flib.rs?ref=1586bab0b97bef411e6187dfc389557edbc5a16e", "patch": "@@ -20,9 +20,11 @@ macro_rules! eprintln {\n mod vfs_glob;\n mod caps;\n mod cargo_target_spec;\n-mod conv;\n+mod to_proto;\n+mod from_proto;\n mod main_loop;\n mod markdown;\n+// TODO: rename to lsp_ext\n pub mod req;\n pub mod config;\n mod world;"}, {"sha": "e27d85dc923838fc9dbede40fd2e25491503d003", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1586bab0b97bef411e6187dfc389557edbc5a16e/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1586bab0b97bef411e6187dfc389557edbc5a16e/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=1586bab0b97bef411e6187dfc389557edbc5a16e", "patch": "@@ -37,8 +37,8 @@ use threadpool::ThreadPool;\n \n use crate::{\n     config::{Config, FilesWatcher},\n-    conv::{ConvWith, TryConvWith},\n     diagnostics::DiagnosticTask,\n+    from_proto,\n     main_loop::{\n         pending_requests::{PendingRequest, PendingRequests},\n         subscriptions::Subscriptions,\n@@ -584,7 +584,7 @@ fn on_notification(\n         Ok(params) => {\n             let DidChangeTextDocumentParams { text_document, content_changes } = params;\n             let world = state.snapshot();\n-            let file_id = text_document.try_conv_with(&world)?;\n+            let file_id = from_proto::file_id(&world, &text_document.uri)?;\n             let line_index = world.analysis().file_line_index(file_id)?;\n             let uri = text_document.uri;\n             let path = uri.to_file_path().map_err(|()| format!(\"invalid uri: {}\", uri))?;\n@@ -694,7 +694,7 @@ fn apply_document_changes(\n                     line_index = Cow::Owned(LineIndex::new(&old_text));\n                 }\n                 index_valid = IndexValid::UpToLineExclusive(range.start.line);\n-                let range = range.conv_with(&line_index);\n+                let range = from_proto::text_range(&line_index, range);\n                 let mut text = old_text.to_owned();\n                 match std::panic::catch_unwind(move || {\n                     text.replace_range(Range::<usize>::from(range), &change.text);"}, {"sha": "daa5b4411ad4afd3da87e34dc7015b8756b5a2e8", "filename": "crates/rust-analyzer/src/main_loop/handlers.rs", "status": "modified", "additions": 185, "deletions": 207, "changes": 392, "blob_url": "https://github.com/rust-lang/rust/blob/1586bab0b97bef411e6187dfc389557edbc5a16e/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1586bab0b97bef411e6187dfc389557edbc5a16e/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=1586bab0b97bef411e6187dfc389557edbc5a16e", "patch": "@@ -22,6 +22,7 @@ use ra_ide::{\n     Assist, FileId, FilePosition, FileRange, Query, RangeInfo, Runnable, RunnableKind, SearchScope,\n };\n use ra_prof::profile;\n+use ra_project_model::TargetKind;\n use ra_syntax::{AstNode, SyntaxKind, TextRange, TextSize};\n use rustc_hash::FxHashMap;\n use serde::{Deserialize, Serialize};\n@@ -31,18 +32,14 @@ use stdx::format_to;\n use crate::{\n     cargo_target_spec::CargoTargetSpec,\n     config::RustfmtConfig,\n-    conv::{\n-        to_call_hierarchy_item, to_location, Conv, ConvWith, FoldConvCtx, MapConvWith, TryConvWith,\n-        TryConvWithToVec,\n-    },\n     diagnostics::DiagnosticTask,\n-    from_json,\n+    from_json, from_proto,\n     req::{self, InlayHint, InlayHintsParams},\n     semantic_tokens::SemanticTokensBuilder,\n+    to_proto,\n     world::WorldSnapshot,\n     LspError, Result,\n };\n-use ra_project_model::TargetKind;\n \n pub fn handle_analyzer_status(world: WorldSnapshot, _: ()) -> Result<String> {\n     let _p = profile(\"handle_analyzer_status\");\n@@ -58,9 +55,9 @@ pub fn handle_analyzer_status(world: WorldSnapshot, _: ()) -> Result<String> {\n \n pub fn handle_syntax_tree(world: WorldSnapshot, params: req::SyntaxTreeParams) -> Result<String> {\n     let _p = profile(\"handle_syntax_tree\");\n-    let id = params.text_document.try_conv_with(&world)?;\n+    let id = from_proto::file_id(&world, &params.text_document.uri)?;\n     let line_index = world.analysis().file_line_index(id)?;\n-    let text_range = params.range.map(|p| p.conv_with(&line_index));\n+    let text_range = params.range.map(|r| from_proto::text_range(&line_index, r));\n     let res = world.analysis().syntax_tree(id, text_range)?;\n     Ok(res)\n }\n@@ -70,9 +67,9 @@ pub fn handle_expand_macro(\n     params: req::ExpandMacroParams,\n ) -> Result<Option<req::ExpandedMacro>> {\n     let _p = profile(\"handle_expand_macro\");\n-    let file_id = params.text_document.try_conv_with(&world)?;\n+    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n     let line_index = world.analysis().file_line_index(file_id)?;\n-    let offset = params.position.map(|p| p.conv_with(&line_index));\n+    let offset = params.position.map(|p| from_proto::offset(&line_index, p));\n \n     match offset {\n         None => Ok(None),\n@@ -88,16 +85,16 @@ pub fn handle_selection_range(\n     params: req::SelectionRangeParams,\n ) -> Result<Option<Vec<req::SelectionRange>>> {\n     let _p = profile(\"handle_selection_range\");\n-    let file_id = params.text_document.try_conv_with(&world)?;\n+    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n     let line_index = world.analysis().file_line_index(file_id)?;\n     let res: Result<Vec<req::SelectionRange>> = params\n         .positions\n         .into_iter()\n-        .map_conv_with(&line_index)\n         .map(|position| {\n+            let offset = from_proto::offset(&line_index, position);\n             let mut ranges = Vec::new();\n             {\n-                let mut range = TextRange::new(position, position);\n+                let mut range = TextRange::new(offset, offset);\n                 loop {\n                     ranges.push(range);\n                     let frange = FileRange { file_id, range };\n@@ -110,12 +107,12 @@ pub fn handle_selection_range(\n                 }\n             }\n             let mut range = req::SelectionRange {\n-                range: ranges.last().unwrap().conv_with(&line_index),\n+                range: to_proto::range(&line_index, *ranges.last().unwrap()),\n                 parent: None,\n             };\n-            for r in ranges.iter().rev().skip(1) {\n+            for &r in ranges.iter().rev().skip(1) {\n                 range = req::SelectionRange {\n-                    range: r.conv_with(&line_index),\n+                    range: to_proto::range(&line_index, r),\n                     parent: Some(Box::new(range)),\n                 }\n             }\n@@ -131,22 +128,19 @@ pub fn handle_find_matching_brace(\n     params: req::FindMatchingBraceParams,\n ) -> Result<Vec<Position>> {\n     let _p = profile(\"handle_find_matching_brace\");\n-    let file_id = params.text_document.try_conv_with(&world)?;\n+    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n     let line_index = world.analysis().file_line_index(file_id)?;\n     let res = params\n         .offsets\n         .into_iter()\n-        .map_conv_with(&line_index)\n-        .map(|offset| {\n-            if let Ok(Some(matching_brace_offset)) =\n-                world.analysis().matching_brace(FilePosition { file_id, offset })\n-            {\n-                matching_brace_offset\n-            } else {\n-                offset\n-            }\n+        .map(|position| {\n+            let offset = from_proto::offset(&line_index, position);\n+            let offset = match world.analysis().matching_brace(FilePosition { file_id, offset }) {\n+                Ok(Some(matching_brace_offset)) => matching_brace_offset,\n+                Err(_) | Ok(None) => offset,\n+            };\n+            to_proto::position(&line_index, offset)\n         })\n-        .map_conv_with(&line_index)\n         .collect();\n     Ok(res)\n }\n@@ -156,19 +150,20 @@ pub fn handle_join_lines(\n     params: req::JoinLinesParams,\n ) -> Result<req::SourceChange> {\n     let _p = profile(\"handle_join_lines\");\n-    let frange = (&params.text_document, params.range).try_conv_with(&world)?;\n-    world.analysis().join_lines(frange)?.try_conv_with(&world)\n+    let frange = from_proto::file_range(&world, params.text_document, params.range)?;\n+    let source_change = world.analysis().join_lines(frange)?;\n+    to_proto::source_change(&world, source_change)\n }\n \n pub fn handle_on_enter(\n     world: WorldSnapshot,\n     params: req::TextDocumentPositionParams,\n ) -> Result<Option<req::SourceChange>> {\n     let _p = profile(\"handle_on_enter\");\n-    let position = params.try_conv_with(&world)?;\n+    let position = from_proto::file_position(&world, params)?;\n     match world.analysis().on_enter(position)? {\n         None => Ok(None),\n-        Some(edit) => Ok(Some(edit.try_conv_with(&world)?)),\n+        Some(source_change) => to_proto::source_change(&world, source_change).map(Some),\n     }\n }\n \n@@ -178,7 +173,7 @@ pub fn handle_on_type_formatting(\n     params: req::DocumentOnTypeFormattingParams,\n ) -> Result<Option<Vec<TextEdit>>> {\n     let _p = profile(\"handle_on_type_formatting\");\n-    let mut position = params.text_document_position.try_conv_with(&world)?;\n+    let mut position = from_proto::file_position(&world, params.text_document_position)?;\n     let line_index = world.analysis().file_line_index(position.file_id)?;\n     let line_endings = world.file_line_endings(position.file_id);\n \n@@ -208,7 +203,7 @@ pub fn handle_on_type_formatting(\n     // This should be a single-file edit\n     let edit = edit.source_file_edits.pop().unwrap();\n \n-    let change: Vec<TextEdit> = edit.edit.conv_with((&line_index, line_endings));\n+    let change = to_proto::text_edit_vec(&line_index, line_endings, edit.edit);\n     Ok(Some(change))\n }\n \n@@ -217,20 +212,19 @@ pub fn handle_document_symbol(\n     params: req::DocumentSymbolParams,\n ) -> Result<Option<req::DocumentSymbolResponse>> {\n     let _p = profile(\"handle_document_symbol\");\n-    let file_id = params.text_document.try_conv_with(&world)?;\n+    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n     let line_index = world.analysis().file_line_index(file_id)?;\n-    let url = file_id.try_conv_with(&world)?;\n \n     let mut parents: Vec<(DocumentSymbol, Option<usize>)> = Vec::new();\n \n     for symbol in world.analysis().file_structure(file_id)? {\n         let doc_symbol = DocumentSymbol {\n             name: symbol.label,\n             detail: symbol.detail,\n-            kind: symbol.kind.conv(),\n+            kind: to_proto::symbol_kind(symbol.kind),\n             deprecated: Some(symbol.deprecated),\n-            range: symbol.node_range.conv_with(&line_index),\n-            selection_range: symbol.navigation_range.conv_with(&line_index),\n+            range: to_proto::range(&line_index, symbol.node_range),\n+            selection_range: to_proto::range(&line_index, symbol.navigation_range),\n             children: None,\n         };\n         parents.push((doc_symbol, symbol.parent));\n@@ -249,34 +243,35 @@ pub fn handle_document_symbol(\n         }\n     }\n \n-    if world.config.client_caps.hierarchical_symbols {\n-        Ok(Some(document_symbols.into()))\n+    let res = if world.config.client_caps.hierarchical_symbols {\n+        document_symbols.into()\n     } else {\n+        let url = to_proto::url(&world, file_id)?;\n         let mut symbol_information = Vec::<SymbolInformation>::new();\n         for symbol in document_symbols {\n             flatten_document_symbol(&symbol, None, &url, &mut symbol_information);\n         }\n+        symbol_information.into()\n+    };\n+    return Ok(Some(res));\n \n-        Ok(Some(symbol_information.into()))\n-    }\n-}\n-\n-fn flatten_document_symbol(\n-    symbol: &DocumentSymbol,\n-    container_name: Option<String>,\n-    url: &Url,\n-    res: &mut Vec<SymbolInformation>,\n-) {\n-    res.push(SymbolInformation {\n-        name: symbol.name.clone(),\n-        kind: symbol.kind,\n-        deprecated: symbol.deprecated,\n-        location: Location::new(url.clone(), symbol.range),\n-        container_name: container_name,\n-    });\n+    fn flatten_document_symbol(\n+        symbol: &DocumentSymbol,\n+        container_name: Option<String>,\n+        url: &Url,\n+        res: &mut Vec<SymbolInformation>,\n+    ) {\n+        res.push(SymbolInformation {\n+            name: symbol.name.clone(),\n+            kind: symbol.kind,\n+            deprecated: symbol.deprecated,\n+            location: Location::new(url.clone(), symbol.range),\n+            container_name: container_name,\n+        });\n \n-    for child in symbol.children.iter().flatten() {\n-        flatten_document_symbol(child, Some(symbol.name.clone()), url, res);\n+        for child in symbol.children.iter().flatten() {\n+            flatten_document_symbol(child, Some(symbol.name.clone()), url, res);\n+        }\n     }\n }\n \n@@ -313,8 +308,8 @@ pub fn handle_workspace_symbol(\n         for nav in world.analysis().symbol_search(query)? {\n             let info = SymbolInformation {\n                 name: nav.name().to_string(),\n-                kind: nav.kind().conv(),\n-                location: nav.try_conv_with(world)?,\n+                kind: to_proto::symbol_kind(nav.kind()),\n+                location: to_proto::location(world, nav.file_range())?,\n                 container_name: nav.container_name().map(|v| v.to_string()),\n                 deprecated: None,\n             };\n@@ -329,12 +324,16 @@ pub fn handle_goto_definition(\n     params: req::GotoDefinitionParams,\n ) -> Result<Option<req::GotoDefinitionResponse>> {\n     let _p = profile(\"handle_goto_definition\");\n-    let position = params.text_document_position_params.try_conv_with(&world)?;\n+    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n     let nav_info = match world.analysis().goto_definition(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n-    let res = (position.file_id, nav_info).try_conv_with(&world)?;\n+    let res = to_proto::goto_definition_response(\n+        &world,\n+        FileRange { file_id: position.file_id, range: nav_info.range },\n+        nav_info.info,\n+    )?;\n     Ok(Some(res))\n }\n \n@@ -343,12 +342,16 @@ pub fn handle_goto_implementation(\n     params: req::GotoImplementationParams,\n ) -> Result<Option<req::GotoImplementationResponse>> {\n     let _p = profile(\"handle_goto_implementation\");\n-    let position = params.text_document_position_params.try_conv_with(&world)?;\n+    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n     let nav_info = match world.analysis().goto_implementation(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n-    let res = (position.file_id, nav_info).try_conv_with(&world)?;\n+    let res = to_proto::goto_definition_response(\n+        &world,\n+        FileRange { file_id: position.file_id, range: nav_info.range },\n+        nav_info.info,\n+    )?;\n     Ok(Some(res))\n }\n \n@@ -357,12 +360,16 @@ pub fn handle_goto_type_definition(\n     params: req::GotoTypeDefinitionParams,\n ) -> Result<Option<req::GotoTypeDefinitionResponse>> {\n     let _p = profile(\"handle_goto_type_definition\");\n-    let position = params.text_document_position_params.try_conv_with(&world)?;\n+    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n     let nav_info = match world.analysis().goto_type_definition(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n-    let res = (position.file_id, nav_info).try_conv_with(&world)?;\n+    let res = to_proto::goto_definition_response(\n+        &world,\n+        FileRange { file_id: position.file_id, range: nav_info.range },\n+        nav_info.info,\n+    )?;\n     Ok(Some(res))\n }\n \n@@ -371,18 +378,23 @@ pub fn handle_parent_module(\n     params: req::TextDocumentPositionParams,\n ) -> Result<Vec<Location>> {\n     let _p = profile(\"handle_parent_module\");\n-    let position = params.try_conv_with(&world)?;\n-    world.analysis().parent_module(position)?.iter().try_conv_with_to_vec(&world)\n+    let position = from_proto::file_position(&world, params)?;\n+    world\n+        .analysis()\n+        .parent_module(position)?\n+        .into_iter()\n+        .map(|it| to_proto::location(&world, it.file_range()))\n+        .collect::<Result<Vec<_>>>()\n }\n \n pub fn handle_runnables(\n     world: WorldSnapshot,\n     params: req::RunnablesParams,\n ) -> Result<Vec<req::Runnable>> {\n     let _p = profile(\"handle_runnables\");\n-    let file_id = params.text_document.try_conv_with(&world)?;\n+    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n     let line_index = world.analysis().file_line_index(file_id)?;\n-    let offset = params.position.map(|it| it.conv_with(&line_index));\n+    let offset = params.position.map(|it| from_proto::offset(&line_index, it));\n     let mut res = Vec::new();\n     let workspace_root = world.workspace_root_for(file_id);\n     let cargo_spec = CargoTargetSpec::for_file(&world, file_id)?;\n@@ -439,7 +451,7 @@ pub fn handle_completion(\n     params: req::CompletionParams,\n ) -> Result<Option<req::CompletionResponse>> {\n     let _p = profile(\"handle_completion\");\n-    let position = params.text_document_position.try_conv_with(&world)?;\n+    let position = from_proto::file_position(&world, params.text_document_position)?;\n     let completion_triggered_after_single_colon = {\n         let mut res = false;\n         if let Some(ctx) = params.context {\n@@ -468,8 +480,10 @@ pub fn handle_completion(\n     };\n     let line_index = world.analysis().file_line_index(position.file_id)?;\n     let line_endings = world.file_line_endings(position.file_id);\n-    let items: Vec<CompletionItem> =\n-        items.into_iter().map(|item| item.conv_with((&line_index, line_endings))).collect();\n+    let items: Vec<CompletionItem> = items\n+        .into_iter()\n+        .map(|item| to_proto::completion_item(&line_index, line_endings, item))\n+        .collect();\n \n     Ok(Some(items.into()))\n }\n@@ -479,52 +493,51 @@ pub fn handle_folding_range(\n     params: FoldingRangeParams,\n ) -> Result<Option<Vec<FoldingRange>>> {\n     let _p = profile(\"handle_folding_range\");\n-    let file_id = params.text_document.try_conv_with(&world)?;\n+    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n     let folds = world.analysis().folding_ranges(file_id)?;\n     let text = world.analysis().file_text(file_id)?;\n     let line_index = world.analysis().file_line_index(file_id)?;\n-    let ctx = FoldConvCtx {\n-        text: &text,\n-        line_index: &line_index,\n-        line_folding_only: world.config.client_caps.line_folding_only,\n-    };\n-    let res = Some(folds.into_iter().map_conv_with(&ctx).collect());\n-    Ok(res)\n+    let line_folding_only = world.config.client_caps.line_folding_only;\n+    let res = folds\n+        .into_iter()\n+        .map(|it| to_proto::folding_range(&*text, &line_index, line_folding_only, it))\n+        .collect();\n+    Ok(Some(res))\n }\n \n pub fn handle_signature_help(\n     world: WorldSnapshot,\n     params: req::SignatureHelpParams,\n ) -> Result<Option<req::SignatureHelp>> {\n     let _p = profile(\"handle_signature_help\");\n-    let position = params.text_document_position_params.try_conv_with(&world)?;\n-    if let Some(call_info) = world.analysis().call_info(position)? {\n-        let concise = !world.config.call_info_full;\n-        let mut active_parameter = call_info.active_parameter.map(|it| it as i64);\n-        if concise && call_info.signature.has_self_param {\n-            active_parameter = active_parameter.map(|it| it.saturating_sub(1));\n-        }\n-        let sig_info = call_info.signature.conv_with(concise);\n-\n-        Ok(Some(req::SignatureHelp {\n-            signatures: vec![sig_info],\n-            active_signature: Some(0),\n-            active_parameter,\n-        }))\n-    } else {\n-        Ok(None)\n+    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n+    let call_info = match world.analysis().call_info(position)? {\n+        None => return Ok(None),\n+        Some(it) => it,\n+    };\n+    let concise = !world.config.call_info_full;\n+    let mut active_parameter = call_info.active_parameter.map(|it| it as i64);\n+    if concise && call_info.signature.has_self_param {\n+        active_parameter = active_parameter.map(|it| it.saturating_sub(1));\n     }\n+    let sig_info = to_proto::signature_information(call_info.signature, concise);\n+\n+    Ok(Some(req::SignatureHelp {\n+        signatures: vec![sig_info],\n+        active_signature: Some(0),\n+        active_parameter,\n+    }))\n }\n \n pub fn handle_hover(world: WorldSnapshot, params: req::HoverParams) -> Result<Option<Hover>> {\n     let _p = profile(\"handle_hover\");\n-    let position = params.text_document_position_params.try_conv_with(&world)?;\n+    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n     let info = match world.analysis().hover(position)? {\n         None => return Ok(None),\n         Some(info) => info,\n     };\n     let line_index = world.analysis.file_line_index(position.file_id)?;\n-    let range = info.range.conv_with(&line_index);\n+    let range = to_proto::range(&line_index, info.range);\n     let res = Hover {\n         contents: HoverContents::Markup(MarkupContent {\n             kind: MarkupKind::Markdown,\n@@ -540,23 +553,22 @@ pub fn handle_prepare_rename(\n     params: req::TextDocumentPositionParams,\n ) -> Result<Option<PrepareRenameResponse>> {\n     let _p = profile(\"handle_prepare_rename\");\n-    let position = params.try_conv_with(&world)?;\n+    let position = from_proto::file_position(&world, params)?;\n \n     let optional_change = world.analysis().rename(position, \"dummy\")?;\n     let range = match optional_change {\n         None => return Ok(None),\n         Some(it) => it.range,\n     };\n \n-    let file_id = params.text_document.try_conv_with(&world)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n-    let range = range.conv_with(&line_index);\n+    let line_index = world.analysis().file_line_index(position.file_id)?;\n+    let range = to_proto::range(&line_index, range);\n     Ok(Some(PrepareRenameResponse::Range(range)))\n }\n \n pub fn handle_rename(world: WorldSnapshot, params: RenameParams) -> Result<Option<WorkspaceEdit>> {\n     let _p = profile(\"handle_rename\");\n-    let position = params.text_document_position.try_conv_with(&world)?;\n+    let position = from_proto::file_position(&world, params.text_document_position)?;\n \n     if params.new_name.is_empty() {\n         return Err(LspError::new(\n@@ -567,22 +579,21 @@ pub fn handle_rename(world: WorldSnapshot, params: RenameParams) -> Result<Optio\n     }\n \n     let optional_change = world.analysis().rename(position, &*params.new_name)?;\n-    let change = match optional_change {\n+    let source_change = match optional_change {\n         None => return Ok(None),\n         Some(it) => it.info,\n     };\n \n-    let source_change_req = change.try_conv_with(&world)?;\n-\n-    Ok(Some(source_change_req.workspace_edit))\n+    let source_change = to_proto::source_change(&world, source_change)?;\n+    Ok(Some(source_change.workspace_edit))\n }\n \n pub fn handle_references(\n     world: WorldSnapshot,\n     params: req::ReferenceParams,\n ) -> Result<Option<Vec<Location>>> {\n     let _p = profile(\"handle_references\");\n-    let position = params.text_document_position.try_conv_with(&world)?;\n+    let position = from_proto::file_position(&world, params.text_document_position)?;\n \n     let refs = match world.analysis().find_all_refs(position, None)? {\n         None => return Ok(None),\n@@ -591,33 +602,13 @@ pub fn handle_references(\n \n     let locations = if params.context.include_declaration {\n         refs.into_iter()\n-            .filter_map(|reference| {\n-                let line_index =\n-                    world.analysis().file_line_index(reference.file_range.file_id).ok()?;\n-                to_location(\n-                    reference.file_range.file_id,\n-                    reference.file_range.range,\n-                    &world,\n-                    &line_index,\n-                )\n-                .ok()\n-            })\n+            .filter_map(|reference| to_proto::location(&world, reference.file_range).ok())\n             .collect()\n     } else {\n         // Only iterate over the references if include_declaration was false\n         refs.references()\n             .iter()\n-            .filter_map(|reference| {\n-                let line_index =\n-                    world.analysis().file_line_index(reference.file_range.file_id).ok()?;\n-                to_location(\n-                    reference.file_range.file_id,\n-                    reference.file_range.range,\n-                    &world,\n-                    &line_index,\n-                )\n-                .ok()\n-            })\n+            .filter_map(|reference| to_proto::location(&world, reference.file_range).ok())\n             .collect()\n     };\n \n@@ -629,12 +620,12 @@ pub fn handle_formatting(\n     params: DocumentFormattingParams,\n ) -> Result<Option<Vec<TextEdit>>> {\n     let _p = profile(\"handle_formatting\");\n-    let file_id = params.text_document.try_conv_with(&world)?;\n+    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n     let file = world.analysis().file_text(file_id)?;\n     let crate_ids = world.analysis().crate_for(file_id)?;\n \n     let file_line_index = world.analysis().file_line_index(file_id)?;\n-    let end_position = TextSize::of(file.as_str()).conv_with(&file_line_index);\n+    let end_position = to_proto::position(&file_line_index, TextSize::of(file.as_str()));\n \n     let mut rustfmt = match &world.config.rustfmt {\n         RustfmtConfig::Rustfmt { extra_args } => {\n@@ -700,33 +691,14 @@ pub fn handle_formatting(\n     }]))\n }\n \n-fn create_single_code_action(assist: Assist, world: &WorldSnapshot) -> Result<CodeAction> {\n-    let arg = to_value(assist.source_change.try_conv_with(world)?)?;\n-    let title = assist.label;\n-    let command = Command {\n-        title: title.clone(),\n-        command: \"rust-analyzer.applySourceChange\".to_string(),\n-        arguments: Some(vec![arg]),\n-    };\n-\n-    Ok(CodeAction {\n-        title,\n-        kind: Some(String::new()),\n-        diagnostics: None,\n-        edit: None,\n-        command: Some(command),\n-        is_preferred: None,\n-    })\n-}\n-\n pub fn handle_code_action(\n     world: WorldSnapshot,\n     params: req::CodeActionParams,\n ) -> Result<Option<CodeActionResponse>> {\n     let _p = profile(\"handle_code_action\");\n-    let file_id = params.text_document.try_conv_with(&world)?;\n+    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n     let line_index = world.analysis().file_line_index(file_id)?;\n-    let range = params.range.conv_with(&line_index);\n+    let range = from_proto::text_range(&line_index, params.range);\n \n     let diagnostics = world.analysis().diagnostics(file_id)?;\n     let mut res = CodeActionResponse::default();\n@@ -739,7 +711,7 @@ pub fn handle_code_action(\n \n     for source_edit in fixes_from_diagnostics {\n         let title = source_edit.label.clone();\n-        let edit = source_edit.try_conv_with(&world)?;\n+        let edit = to_proto::source_change(&world, source_edit)?;\n \n         let command = Command {\n             title,\n@@ -758,7 +730,7 @@ pub fn handle_code_action(\n     }\n \n     for fix in world.check_fixes.get(&file_id).into_iter().flatten() {\n-        let fix_range = fix.range.conv_with(&line_index);\n+        let fix_range = from_proto::text_range(&line_index, fix.range);\n         if fix_range.intersect(range).is_none() {\n             continue;\n         }\n@@ -779,21 +751,21 @@ pub fn handle_code_action(\n                 .1\n                 .push(assist),\n             None => {\n-                res.push(create_single_code_action(assist, &world)?.into());\n+                res.push(to_proto::code_action(&world, assist)?.into());\n             }\n         }\n     }\n \n     for (group_label, (idx, assists)) in grouped_assists {\n         if assists.len() == 1 {\n-            res[idx] =\n-                create_single_code_action(assists.into_iter().next().unwrap(), &world)?.into();\n+            res[idx] = to_proto::code_action(&world, assists.into_iter().next().unwrap())?.into();\n         } else {\n             let title = group_label;\n \n             let mut arguments = Vec::with_capacity(assists.len());\n             for assist in assists {\n-                arguments.push(to_value(assist.source_change.try_conv_with(&world)?)?);\n+                let source_change = to_proto::source_change(&world, assist.source_change)?;\n+                arguments.push(to_value(source_change)?);\n             }\n \n             let command = Some(Command {\n@@ -838,7 +810,7 @@ pub fn handle_code_lens(\n     params: req::CodeLensParams,\n ) -> Result<Option<Vec<CodeLens>>> {\n     let _p = profile(\"handle_code_lens\");\n-    let file_id = params.text_document.try_conv_with(&world)?;\n+    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n     let line_index = world.analysis().file_line_index(file_id)?;\n \n     let mut lenses: Vec<CodeLens> = Default::default();\n@@ -902,7 +874,7 @@ pub fn handle_code_lens(\n                 _ => false,\n             })\n             .map(|it| {\n-                let range = it.node_range.conv_with(&line_index);\n+                let range = to_proto::range(&line_index, it.node_range);\n                 let pos = range.start;\n                 let lens_params = req::GotoImplementationParams {\n                     text_document_position_params: req::TextDocumentPositionParams::new(\n@@ -979,34 +951,33 @@ pub fn handle_document_highlight(\n     params: req::DocumentHighlightParams,\n ) -> Result<Option<Vec<DocumentHighlight>>> {\n     let _p = profile(\"handle_document_highlight\");\n-    let file_id = params.text_document_position_params.text_document.try_conv_with(&world)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n+    let line_index = world.analysis().file_line_index(position.file_id)?;\n \n-    let refs = match world.analysis().find_all_refs(\n-        params.text_document_position_params.try_conv_with(&world)?,\n-        Some(SearchScope::single_file(file_id)),\n-    )? {\n+    let refs = match world\n+        .analysis()\n+        .find_all_refs(position, Some(SearchScope::single_file(position.file_id)))?\n+    {\n         None => return Ok(None),\n         Some(refs) => refs,\n     };\n \n-    Ok(Some(\n-        refs.into_iter()\n-            .filter(|reference| reference.file_range.file_id == file_id)\n-            .map(|reference| DocumentHighlight {\n-                range: reference.file_range.range.conv_with(&line_index),\n-                kind: reference.access.map(|it| it.conv()),\n-            })\n-            .collect(),\n-    ))\n+    let res = refs\n+        .into_iter()\n+        .filter(|reference| reference.file_range.file_id == position.file_id)\n+        .map(|reference| DocumentHighlight {\n+            range: to_proto::range(&line_index, reference.file_range.range),\n+            kind: reference.access.map(to_proto::document_highlight_kind),\n+        })\n+        .collect();\n+    Ok(Some(res))\n }\n \n pub fn handle_ssr(world: WorldSnapshot, params: req::SsrParams) -> Result<req::SourceChange> {\n     let _p = profile(\"handle_ssr\");\n-    world\n-        .analysis()\n-        .structural_search_replace(&params.query, params.parse_only)??\n-        .try_conv_with(&world)\n+    let source_change =\n+        world.analysis().structural_search_replace(&params.query, params.parse_only)??;\n+    to_proto::source_change(&world, source_change)\n }\n \n pub fn publish_diagnostics(world: &WorldSnapshot, file_id: FileId) -> Result<DiagnosticTask> {\n@@ -1017,8 +988,8 @@ pub fn publish_diagnostics(world: &WorldSnapshot, file_id: FileId) -> Result<Dia\n         .diagnostics(file_id)?\n         .into_iter()\n         .map(|d| Diagnostic {\n-            range: d.range.conv_with(&line_index),\n-            severity: Some(d.severity.conv()),\n+            range: to_proto::range(&line_index, d.range),\n+            severity: Some(to_proto::diagnostic_severity(d.severity)),\n             code: None,\n             source: Some(\"rust-analyzer\".to_string()),\n             message: d.message,\n@@ -1045,7 +1016,7 @@ fn to_lsp_runnable(\n         RunnableKind::Bin => \"run binary\".to_string(),\n     };\n     Ok(req::Runnable {\n-        range: runnable.range.conv_with(&line_index),\n+        range: to_proto::range(&line_index, runnable.range),\n         label,\n         bin: \"cargo\".to_string(),\n         args,\n@@ -1064,13 +1035,13 @@ pub fn handle_inlay_hints(\n     params: InlayHintsParams,\n ) -> Result<Vec<InlayHint>> {\n     let _p = profile(\"handle_inlay_hints\");\n-    let file_id = params.text_document.try_conv_with(&world)?;\n+    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n     let analysis = world.analysis();\n     let line_index = analysis.file_line_index(file_id)?;\n     Ok(analysis\n         .inlay_hints(file_id, &world.config.inlay_hints)?\n         .into_iter()\n-        .map_conv_with(&line_index)\n+        .map(|it| to_proto::inlay_int(&line_index, it))\n         .collect())\n }\n \n@@ -1079,21 +1050,19 @@ pub fn handle_call_hierarchy_prepare(\n     params: CallHierarchyPrepareParams,\n ) -> Result<Option<Vec<CallHierarchyItem>>> {\n     let _p = profile(\"handle_call_hierarchy_prepare\");\n-    let position = params.text_document_position_params.try_conv_with(&world)?;\n-    let file_id = position.file_id;\n+    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n \n     let nav_info = match world.analysis().call_hierarchy(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n \n-    let line_index = world.analysis().file_line_index(file_id)?;\n-    let RangeInfo { range, info: navs } = nav_info;\n+    let RangeInfo { range: _, info: navs } = nav_info;\n     let res = navs\n         .into_iter()\n         .filter(|it| it.kind() == SyntaxKind::FN_DEF)\n-        .filter_map(|it| to_call_hierarchy_item(file_id, range, &world, &line_index, it).ok())\n-        .collect();\n+        .map(|it| to_proto::call_hierarchy_item(&world, it))\n+        .collect::<Result<Vec<_>>>()?;\n \n     Ok(Some(res))\n }\n@@ -1106,7 +1075,7 @@ pub fn handle_call_hierarchy_incoming(\n     let item = params.item;\n \n     let doc = TextDocumentIdentifier::new(item.uri);\n-    let frange: FileRange = (&doc, item.range).try_conv_with(&world)?;\n+    let frange = from_proto::file_range(&world, doc, item.range)?;\n     let fpos = FilePosition { file_id: frange.file_id, offset: frange.range.start() };\n \n     let call_items = match world.analysis().incoming_calls(fpos)? {\n@@ -1119,11 +1088,14 @@ pub fn handle_call_hierarchy_incoming(\n     for call_item in call_items.into_iter() {\n         let file_id = call_item.target.file_id();\n         let line_index = world.analysis().file_line_index(file_id)?;\n-        let range = call_item.target.range();\n-        let item = to_call_hierarchy_item(file_id, range, &world, &line_index, call_item.target)?;\n+        let item = to_proto::call_hierarchy_item(&world, call_item.target)?;\n         res.push(CallHierarchyIncomingCall {\n             from: item,\n-            from_ranges: call_item.ranges.iter().map(|it| it.conv_with(&line_index)).collect(),\n+            from_ranges: call_item\n+                .ranges\n+                .into_iter()\n+                .map(|it| to_proto::range(&line_index, it))\n+                .collect(),\n         });\n     }\n \n@@ -1138,7 +1110,7 @@ pub fn handle_call_hierarchy_outgoing(\n     let item = params.item;\n \n     let doc = TextDocumentIdentifier::new(item.uri);\n-    let frange: FileRange = (&doc, item.range).try_conv_with(&world)?;\n+    let frange = from_proto::file_range(&world, doc, item.range)?;\n     let fpos = FilePosition { file_id: frange.file_id, offset: frange.range.start() };\n \n     let call_items = match world.analysis().outgoing_calls(fpos)? {\n@@ -1151,11 +1123,14 @@ pub fn handle_call_hierarchy_outgoing(\n     for call_item in call_items.into_iter() {\n         let file_id = call_item.target.file_id();\n         let line_index = world.analysis().file_line_index(file_id)?;\n-        let range = call_item.target.range();\n-        let item = to_call_hierarchy_item(file_id, range, &world, &line_index, call_item.target)?;\n+        let item = to_proto::call_hierarchy_item(&world, call_item.target)?;\n         res.push(CallHierarchyOutgoingCall {\n             to: item,\n-            from_ranges: call_item.ranges.iter().map(|it| it.conv_with(&line_index)).collect(),\n+            from_ranges: call_item\n+                .ranges\n+                .into_iter()\n+                .map(|it| to_proto::range(&line_index, it))\n+                .collect(),\n         });\n     }\n \n@@ -1168,19 +1143,20 @@ pub fn handle_semantic_tokens(\n ) -> Result<Option<SemanticTokensResult>> {\n     let _p = profile(\"handle_semantic_tokens\");\n \n-    let file_id = params.text_document.try_conv_with(&world)?;\n+    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n     let text = world.analysis().file_text(file_id)?;\n     let line_index = world.analysis().file_line_index(file_id)?;\n \n     let mut builder = SemanticTokensBuilder::default();\n \n     for highlight_range in world.analysis().highlight(file_id)?.into_iter() {\n-        let (token_index, modifier_bitset) = highlight_range.highlight.conv();\n+        let (token_index, modifier_bitset) =\n+            to_proto::token_type_index_modifiers_bitself(highlight_range.highlight);\n         for mut range in line_index.lines(highlight_range.range) {\n             if text[range].ends_with('\\n') {\n                 range = TextRange::new(range.start(), range.end() - TextSize::of('\\n'));\n             }\n-            let range = range.conv_with(&line_index);\n+            let range = to_proto::range(&line_index, range);\n             builder.push(range, token_index, modifier_bitset);\n         }\n     }\n@@ -1196,14 +1172,16 @@ pub fn handle_semantic_tokens_range(\n ) -> Result<Option<SemanticTokensRangeResult>> {\n     let _p = profile(\"handle_semantic_tokens_range\");\n \n-    let frange = (&params.text_document, params.range).try_conv_with(&world)?;\n+    let frange = from_proto::file_range(&world, params.text_document, params.range)?;\n     let line_index = world.analysis().file_line_index(frange.file_id)?;\n \n     let mut builder = SemanticTokensBuilder::default();\n \n     for highlight_range in world.analysis().highlight_range(frange)?.into_iter() {\n-        let (token_type, token_modifiers) = highlight_range.highlight.conv();\n-        builder.push(highlight_range.range.conv_with(&line_index), token_type, token_modifiers);\n+        let (token_type, token_modifiers) =\n+            to_proto::token_type_index_modifiers_bitself(highlight_range.highlight);\n+        let range = to_proto::range(&line_index, highlight_range.range);\n+        builder.push(range, token_type, token_modifiers);\n     }\n \n     let tokens = builder.build();"}, {"sha": "39f2e6d4d105774b360a9311516f7060b3d3958e", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "added", "additions": 566, "deletions": 0, "changes": 566, "blob_url": "https://github.com/rust-lang/rust/blob/1586bab0b97bef411e6187dfc389557edbc5a16e/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1586bab0b97bef411e6187dfc389557edbc5a16e/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=1586bab0b97bef411e6187dfc389557edbc5a16e", "patch": "@@ -0,0 +1,566 @@\n+//! Conversion of rust-analyzer specific types to lsp_types equivalents.\n+use ra_db::{FileId, FileRange};\n+use ra_ide::{\n+    translate_offset_with_edit, Assist, CompletionItem, CompletionItemKind, Documentation,\n+    FileSystemEdit, Fold, FoldKind, FunctionSignature, Highlight, HighlightModifier, HighlightTag,\n+    InlayHint, InlayKind, InsertTextFormat, LineIndex, NavigationTarget, ReferenceAccess, Severity,\n+    SourceChange, SourceFileEdit,\n+};\n+use ra_syntax::{SyntaxKind, TextRange, TextSize};\n+use ra_text_edit::{Indel, TextEdit};\n+use ra_vfs::LineEndings;\n+\n+use crate::{req, semantic_tokens, world::WorldSnapshot, Result};\n+\n+pub(crate) fn position(line_index: &LineIndex, offset: TextSize) -> lsp_types::Position {\n+    let line_col = line_index.line_col(offset);\n+    let line = u64::from(line_col.line);\n+    let character = u64::from(line_col.col_utf16);\n+    lsp_types::Position::new(line, character)\n+}\n+\n+pub(crate) fn range(line_index: &LineIndex, range: TextRange) -> lsp_types::Range {\n+    let start = position(line_index, range.start());\n+    let end = position(line_index, range.end());\n+    lsp_types::Range::new(start, end)\n+}\n+\n+pub(crate) fn symbol_kind(syntax_kind: SyntaxKind) -> lsp_types::SymbolKind {\n+    match syntax_kind {\n+        SyntaxKind::FN_DEF => lsp_types::SymbolKind::Function,\n+        SyntaxKind::STRUCT_DEF => lsp_types::SymbolKind::Struct,\n+        SyntaxKind::ENUM_DEF => lsp_types::SymbolKind::Enum,\n+        SyntaxKind::ENUM_VARIANT => lsp_types::SymbolKind::EnumMember,\n+        SyntaxKind::TRAIT_DEF => lsp_types::SymbolKind::Interface,\n+        SyntaxKind::MACRO_CALL => lsp_types::SymbolKind::Function,\n+        SyntaxKind::MODULE => lsp_types::SymbolKind::Module,\n+        SyntaxKind::TYPE_ALIAS_DEF => lsp_types::SymbolKind::TypeParameter,\n+        SyntaxKind::RECORD_FIELD_DEF => lsp_types::SymbolKind::Field,\n+        SyntaxKind::STATIC_DEF => lsp_types::SymbolKind::Constant,\n+        SyntaxKind::CONST_DEF => lsp_types::SymbolKind::Constant,\n+        SyntaxKind::IMPL_DEF => lsp_types::SymbolKind::Object,\n+        _ => lsp_types::SymbolKind::Variable,\n+    }\n+}\n+\n+pub(crate) fn document_highlight_kind(\n+    reference_access: ReferenceAccess,\n+) -> lsp_types::DocumentHighlightKind {\n+    match reference_access {\n+        ReferenceAccess::Read => lsp_types::DocumentHighlightKind::Read,\n+        ReferenceAccess::Write => lsp_types::DocumentHighlightKind::Write,\n+    }\n+}\n+\n+pub(crate) fn diagnostic_severity(severity: Severity) -> lsp_types::DiagnosticSeverity {\n+    match severity {\n+        Severity::Error => lsp_types::DiagnosticSeverity::Error,\n+        Severity::WeakWarning => lsp_types::DiagnosticSeverity::Hint,\n+    }\n+}\n+\n+pub(crate) fn documentation(documentation: Documentation) -> lsp_types::Documentation {\n+    let value = crate::markdown::format_docs(documentation.as_str());\n+    let markup_content = lsp_types::MarkupContent { kind: lsp_types::MarkupKind::Markdown, value };\n+    lsp_types::Documentation::MarkupContent(markup_content)\n+}\n+\n+pub(crate) fn insert_text_format(\n+    insert_text_format: InsertTextFormat,\n+) -> lsp_types::InsertTextFormat {\n+    match insert_text_format {\n+        InsertTextFormat::Snippet => lsp_types::InsertTextFormat::Snippet,\n+        InsertTextFormat::PlainText => lsp_types::InsertTextFormat::PlainText,\n+    }\n+}\n+\n+pub(crate) fn completion_item_kind(\n+    completion_item_kind: CompletionItemKind,\n+) -> lsp_types::CompletionItemKind {\n+    match completion_item_kind {\n+        CompletionItemKind::Keyword => lsp_types::CompletionItemKind::Keyword,\n+        CompletionItemKind::Snippet => lsp_types::CompletionItemKind::Snippet,\n+        CompletionItemKind::Module => lsp_types::CompletionItemKind::Module,\n+        CompletionItemKind::Function => lsp_types::CompletionItemKind::Function,\n+        CompletionItemKind::Struct => lsp_types::CompletionItemKind::Struct,\n+        CompletionItemKind::Enum => lsp_types::CompletionItemKind::Enum,\n+        CompletionItemKind::EnumVariant => lsp_types::CompletionItemKind::EnumMember,\n+        CompletionItemKind::BuiltinType => lsp_types::CompletionItemKind::Struct,\n+        CompletionItemKind::Binding => lsp_types::CompletionItemKind::Variable,\n+        CompletionItemKind::Field => lsp_types::CompletionItemKind::Field,\n+        CompletionItemKind::Trait => lsp_types::CompletionItemKind::Interface,\n+        CompletionItemKind::TypeAlias => lsp_types::CompletionItemKind::Struct,\n+        CompletionItemKind::Const => lsp_types::CompletionItemKind::Constant,\n+        CompletionItemKind::Static => lsp_types::CompletionItemKind::Value,\n+        CompletionItemKind::Method => lsp_types::CompletionItemKind::Method,\n+        CompletionItemKind::TypeParam => lsp_types::CompletionItemKind::TypeParameter,\n+        CompletionItemKind::Macro => lsp_types::CompletionItemKind::Method,\n+        CompletionItemKind::Attribute => lsp_types::CompletionItemKind::EnumMember,\n+    }\n+}\n+\n+pub(crate) fn text_edit(\n+    line_index: &LineIndex,\n+    line_endings: LineEndings,\n+    indel: Indel,\n+) -> lsp_types::TextEdit {\n+    let range = range(line_index, indel.delete);\n+    let new_text = match line_endings {\n+        LineEndings::Unix => indel.insert,\n+        LineEndings::Dos => indel.insert.replace('\\n', \"\\r\\n\"),\n+    };\n+    lsp_types::TextEdit { range, new_text }\n+}\n+\n+pub(crate) fn text_edit_vec(\n+    line_index: &LineIndex,\n+    line_endings: LineEndings,\n+    text_edit: TextEdit,\n+) -> Vec<lsp_types::TextEdit> {\n+    text_edit\n+        .as_indels()\n+        .iter()\n+        .map(|it| self::text_edit(line_index, line_endings, it.clone()))\n+        .collect()\n+}\n+\n+pub(crate) fn completion_item(\n+    line_index: &LineIndex,\n+    line_endings: LineEndings,\n+    completion_item: CompletionItem,\n+) -> lsp_types::CompletionItem {\n+    let mut additional_text_edits = Vec::new();\n+    let mut text_edit = None;\n+    // LSP does not allow arbitrary edits in completion, so we have to do a\n+    // non-trivial mapping here.\n+    let source_range = completion_item.source_range();\n+    for indel in completion_item.text_edit().as_indels() {\n+        if indel.delete.contains_range(source_range) {\n+            text_edit = Some(if indel.delete == source_range {\n+                self::text_edit(line_index, line_endings, indel.clone())\n+            } else {\n+                assert!(source_range.end() == indel.delete.end());\n+                let range1 = TextRange::new(indel.delete.start(), source_range.start());\n+                let range2 = source_range;\n+                let indel1 = Indel::replace(range1, String::new());\n+                let indel2 = Indel::replace(range2, indel.insert.clone());\n+                additional_text_edits.push(self::text_edit(line_index, line_endings, indel1));\n+                self::text_edit(line_index, line_endings, indel2)\n+            })\n+        } else {\n+            assert!(source_range.intersect(indel.delete).is_none());\n+            let text_edit = self::text_edit(line_index, line_endings, indel.clone());\n+            additional_text_edits.push(text_edit);\n+        }\n+    }\n+    let text_edit = text_edit.unwrap();\n+\n+    let mut res = lsp_types::CompletionItem {\n+        label: completion_item.label().to_string(),\n+        detail: completion_item.detail().map(|it| it.to_string()),\n+        filter_text: Some(completion_item.lookup().to_string()),\n+        kind: completion_item.kind().map(completion_item_kind),\n+        text_edit: Some(text_edit.into()),\n+        additional_text_edits: Some(additional_text_edits),\n+        documentation: completion_item.documentation().map(documentation),\n+        deprecated: Some(completion_item.deprecated()),\n+        command: if completion_item.trigger_call_info() {\n+            let cmd = lsp_types::Command {\n+                title: \"triggerParameterHints\".into(),\n+                command: \"editor.action.triggerParameterHints\".into(),\n+                arguments: None,\n+            };\n+            Some(cmd)\n+        } else {\n+            None\n+        },\n+        ..Default::default()\n+    };\n+\n+    if completion_item.score().is_some() {\n+        res.preselect = Some(true)\n+    }\n+\n+    if completion_item.deprecated() {\n+        res.tags = Some(vec![lsp_types::CompletionItemTag::Deprecated])\n+    }\n+\n+    res.insert_text_format = Some(insert_text_format(completion_item.insert_text_format()));\n+\n+    res\n+}\n+\n+pub(crate) fn signature_information(\n+    signature: FunctionSignature,\n+    concise: bool,\n+) -> lsp_types::SignatureInformation {\n+    let (label, documentation, params) = if concise {\n+        let mut params = signature.parameters;\n+        if signature.has_self_param {\n+            params.remove(0);\n+        }\n+        (params.join(\", \"), None, params)\n+    } else {\n+        (signature.to_string(), signature.doc.map(documentation), signature.parameters)\n+    };\n+\n+    let parameters: Vec<lsp_types::ParameterInformation> = params\n+        .into_iter()\n+        .map(|param| lsp_types::ParameterInformation {\n+            label: lsp_types::ParameterLabel::Simple(param),\n+            documentation: None,\n+        })\n+        .collect();\n+\n+    lsp_types::SignatureInformation { label, documentation, parameters: Some(parameters) }\n+}\n+\n+pub(crate) fn inlay_int(line_index: &LineIndex, inlay_hint: InlayHint) -> req::InlayHint {\n+    req::InlayHint {\n+        label: inlay_hint.label.to_string(),\n+        range: range(line_index, inlay_hint.range),\n+        kind: match inlay_hint.kind {\n+            InlayKind::ParameterHint => req::InlayKind::ParameterHint,\n+            InlayKind::TypeHint => req::InlayKind::TypeHint,\n+            InlayKind::ChainingHint => req::InlayKind::ChainingHint,\n+        },\n+    }\n+}\n+\n+// TODO: this is wrong\n+pub(crate) fn token_type_index_modifiers_bitself(highlight: Highlight) -> (u32, u32) {\n+    let mut mods = semantic_tokens::ModifierSet::default();\n+    let type_ = match highlight.tag {\n+        HighlightTag::Struct => lsp_types::SemanticTokenType::STRUCT,\n+        HighlightTag::Enum => lsp_types::SemanticTokenType::ENUM,\n+        HighlightTag::Union => semantic_tokens::UNION,\n+        HighlightTag::TypeAlias => semantic_tokens::TYPE_ALIAS,\n+        HighlightTag::Trait => lsp_types::SemanticTokenType::INTERFACE,\n+        HighlightTag::BuiltinType => semantic_tokens::BUILTIN_TYPE,\n+        HighlightTag::SelfType => lsp_types::SemanticTokenType::TYPE,\n+        HighlightTag::Field => lsp_types::SemanticTokenType::MEMBER,\n+        HighlightTag::Function => lsp_types::SemanticTokenType::FUNCTION,\n+        HighlightTag::Module => lsp_types::SemanticTokenType::NAMESPACE,\n+        HighlightTag::Constant => {\n+            mods |= semantic_tokens::CONSTANT;\n+            mods |= lsp_types::SemanticTokenModifier::STATIC;\n+            lsp_types::SemanticTokenType::VARIABLE\n+        }\n+        HighlightTag::Static => {\n+            mods |= lsp_types::SemanticTokenModifier::STATIC;\n+            lsp_types::SemanticTokenType::VARIABLE\n+        }\n+        HighlightTag::EnumVariant => semantic_tokens::ENUM_MEMBER,\n+        HighlightTag::Macro => lsp_types::SemanticTokenType::MACRO,\n+        HighlightTag::Local => lsp_types::SemanticTokenType::VARIABLE,\n+        HighlightTag::TypeParam => lsp_types::SemanticTokenType::TYPE_PARAMETER,\n+        HighlightTag::Lifetime => semantic_tokens::LIFETIME,\n+        HighlightTag::ByteLiteral | HighlightTag::NumericLiteral => {\n+            lsp_types::SemanticTokenType::NUMBER\n+        }\n+        HighlightTag::CharLiteral | HighlightTag::StringLiteral => {\n+            lsp_types::SemanticTokenType::STRING\n+        }\n+        HighlightTag::Comment => lsp_types::SemanticTokenType::COMMENT,\n+        HighlightTag::Attribute => semantic_tokens::ATTRIBUTE,\n+        HighlightTag::Keyword => lsp_types::SemanticTokenType::KEYWORD,\n+        HighlightTag::UnresolvedReference => semantic_tokens::UNRESOLVED_REFERENCE,\n+        HighlightTag::FormatSpecifier => semantic_tokens::FORMAT_SPECIFIER,\n+    };\n+\n+    for modifier in highlight.modifiers.iter() {\n+        let modifier = match modifier {\n+            HighlightModifier::Definition => lsp_types::SemanticTokenModifier::DECLARATION,\n+            HighlightModifier::ControlFlow => semantic_tokens::CONTROL_FLOW,\n+            HighlightModifier::Mutable => semantic_tokens::MUTABLE,\n+            HighlightModifier::Unsafe => semantic_tokens::UNSAFE,\n+        };\n+        mods |= modifier;\n+    }\n+\n+    (semantic_tokens::type_index(type_), mods.0)\n+}\n+\n+pub(crate) fn folding_range(\n+    text: &str,\n+    line_index: &LineIndex,\n+    line_folding_only: bool,\n+    fold: Fold,\n+) -> lsp_types::FoldingRange {\n+    let kind = match fold.kind {\n+        FoldKind::Comment => Some(lsp_types::FoldingRangeKind::Comment),\n+        FoldKind::Imports => Some(lsp_types::FoldingRangeKind::Imports),\n+        FoldKind::Mods | FoldKind::Block => None,\n+    };\n+\n+    let range = range(line_index, fold.range);\n+\n+    if line_folding_only {\n+        // Clients with line_folding_only == true (such as VSCode) will fold the whole end line\n+        // even if it contains text not in the folding range. To prevent that we exclude\n+        // range.end.line from the folding region if there is more text after range.end\n+        // on the same line.\n+        let has_more_text_on_end_line = text[TextRange::new(fold.range.end(), TextSize::of(text))]\n+            .chars()\n+            .take_while(|it| *it != '\\n')\n+            .any(|it| !it.is_whitespace());\n+\n+        let end_line = if has_more_text_on_end_line {\n+            range.end.line.saturating_sub(1)\n+        } else {\n+            range.end.line\n+        };\n+\n+        lsp_types::FoldingRange {\n+            start_line: range.start.line,\n+            start_character: None,\n+            end_line,\n+            end_character: None,\n+            kind,\n+        }\n+    } else {\n+        lsp_types::FoldingRange {\n+            start_line: range.start.line,\n+            start_character: Some(range.start.character),\n+            end_line: range.end.line,\n+            end_character: Some(range.end.character),\n+            kind,\n+        }\n+    }\n+}\n+\n+pub(crate) fn url(world: &WorldSnapshot, file_id: FileId) -> Result<lsp_types::Url> {\n+    world.file_id_to_uri(file_id)\n+}\n+\n+pub(crate) fn text_document_identifier(\n+    world: &WorldSnapshot,\n+    file_id: FileId,\n+) -> Result<lsp_types::TextDocumentIdentifier> {\n+    let res = lsp_types::TextDocumentIdentifier { uri: url(world, file_id)? };\n+    Ok(res)\n+}\n+\n+pub(crate) fn versioned_text_document_identifier(\n+    world: &WorldSnapshot,\n+    file_id: FileId,\n+    version: Option<i64>,\n+) -> Result<lsp_types::VersionedTextDocumentIdentifier> {\n+    let res = lsp_types::VersionedTextDocumentIdentifier { uri: url(world, file_id)?, version };\n+    Ok(res)\n+}\n+\n+pub(crate) fn location(world: &WorldSnapshot, frange: FileRange) -> Result<lsp_types::Location> {\n+    let url = url(world, frange.file_id)?;\n+    let line_index = world.analysis().file_line_index(frange.file_id)?;\n+    let range = range(&line_index, frange.range);\n+    let loc = lsp_types::Location::new(url, range);\n+    Ok(loc)\n+}\n+\n+pub(crate) fn location_link(\n+    world: &WorldSnapshot,\n+    src: FileRange,\n+    target: NavigationTarget,\n+) -> Result<lsp_types::LocationLink> {\n+    let src_location = location(world, src)?;\n+    let (target_uri, target_range, target_selection_range) = location_info(world, target)?;\n+    let res = lsp_types::LocationLink {\n+        origin_selection_range: Some(src_location.range),\n+        target_uri,\n+        target_range,\n+        target_selection_range,\n+    };\n+    Ok(res)\n+}\n+\n+fn location_info(\n+    world: &WorldSnapshot,\n+    target: NavigationTarget,\n+) -> Result<(lsp_types::Url, lsp_types::Range, lsp_types::Range)> {\n+    let line_index = world.analysis().file_line_index(target.file_id())?;\n+\n+    let target_uri = url(world, target.file_id())?;\n+    let target_range = range(&line_index, target.full_range());\n+    let target_selection_range =\n+        target.focus_range().map(|it| range(&line_index, it)).unwrap_or(target_range);\n+    Ok((target_uri, target_range, target_selection_range))\n+}\n+\n+pub(crate) fn goto_definition_response(\n+    world: &WorldSnapshot,\n+    src: FileRange,\n+    targets: Vec<NavigationTarget>,\n+) -> Result<lsp_types::GotoDefinitionResponse> {\n+    if world.config.client_caps.location_link {\n+        let links = targets\n+            .into_iter()\n+            .map(|nav| location_link(world, src, nav))\n+            .collect::<Result<Vec<_>>>()?;\n+        Ok(links.into())\n+    } else {\n+        let locations = targets\n+            .into_iter()\n+            .map(|nav| {\n+                location(\n+                    world,\n+                    FileRange {\n+                        file_id: nav.file_id(),\n+                        range: nav.focus_range().unwrap_or(nav.range()),\n+                    },\n+                )\n+            })\n+            .collect::<Result<Vec<_>>>()?;\n+        Ok(locations.into())\n+    }\n+}\n+\n+pub(crate) fn text_document_edit(\n+    world: &WorldSnapshot,\n+    source_file_edit: SourceFileEdit,\n+) -> Result<lsp_types::TextDocumentEdit> {\n+    let text_document = versioned_text_document_identifier(world, source_file_edit.file_id, None)?;\n+    let line_index = world.analysis().file_line_index(source_file_edit.file_id)?;\n+    let line_endings = world.file_line_endings(source_file_edit.file_id);\n+    let edits = source_file_edit\n+        .edit\n+        .as_indels()\n+        .iter()\n+        .map(|it| text_edit(&line_index, line_endings, it.clone()))\n+        .collect();\n+    Ok(lsp_types::TextDocumentEdit { text_document, edits })\n+}\n+\n+pub(crate) fn resource_op(\n+    world: &WorldSnapshot,\n+    file_system_edit: FileSystemEdit,\n+) -> Result<lsp_types::ResourceOp> {\n+    let res = match file_system_edit {\n+        FileSystemEdit::CreateFile { source_root, path } => {\n+            let uri = world.path_to_uri(source_root, &path)?;\n+            lsp_types::ResourceOp::Create(lsp_types::CreateFile { uri, options: None })\n+        }\n+        FileSystemEdit::MoveFile { src, dst_source_root, dst_path } => {\n+            let old_uri = world.file_id_to_uri(src)?;\n+            let new_uri = world.path_to_uri(dst_source_root, &dst_path)?;\n+            lsp_types::ResourceOp::Rename(lsp_types::RenameFile { old_uri, new_uri, options: None })\n+        }\n+    };\n+    Ok(res)\n+}\n+\n+pub(crate) fn source_change(\n+    world: &WorldSnapshot,\n+    source_change: SourceChange,\n+) -> Result<req::SourceChange> {\n+    let cursor_position = match source_change.cursor_position {\n+        None => None,\n+        Some(pos) => {\n+            let line_index = world.analysis().file_line_index(pos.file_id)?;\n+            let edit = source_change\n+                .source_file_edits\n+                .iter()\n+                .find(|it| it.file_id == pos.file_id)\n+                .map(|it| &it.edit);\n+            let line_col = match edit {\n+                Some(edit) => translate_offset_with_edit(&*line_index, pos.offset, edit),\n+                None => line_index.line_col(pos.offset),\n+            };\n+            let position =\n+                lsp_types::Position::new(u64::from(line_col.line), u64::from(line_col.col_utf16));\n+            Some(lsp_types::TextDocumentPositionParams {\n+                text_document: text_document_identifier(world, pos.file_id)?,\n+                position,\n+            })\n+        }\n+    };\n+    let mut document_changes: Vec<lsp_types::DocumentChangeOperation> = Vec::new();\n+    for op in source_change.file_system_edits {\n+        let op = resource_op(&world, op)?;\n+        document_changes.push(lsp_types::DocumentChangeOperation::Op(op));\n+    }\n+    for edit in source_change.source_file_edits {\n+        let edit = text_document_edit(&world, edit)?;\n+        document_changes.push(lsp_types::DocumentChangeOperation::Edit(edit));\n+    }\n+    let workspace_edit = lsp_types::WorkspaceEdit {\n+        changes: None,\n+        document_changes: Some(lsp_types::DocumentChanges::Operations(document_changes)),\n+    };\n+    Ok(req::SourceChange { label: source_change.label, workspace_edit, cursor_position })\n+}\n+\n+pub fn call_hierarchy_item(\n+    world: &WorldSnapshot,\n+    target: NavigationTarget,\n+) -> Result<lsp_types::CallHierarchyItem> {\n+    let name = target.name().to_string();\n+    let detail = target.description().map(|it| it.to_string());\n+    let kind = symbol_kind(target.kind());\n+    let (uri, range, selection_range) = location_info(world, target)?;\n+    Ok(lsp_types::CallHierarchyItem { name, kind, tags: None, detail, uri, range, selection_range })\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use test_utils::extract_ranges;\n+\n+    use super::*;\n+\n+    #[test]\n+    fn conv_fold_line_folding_only_fixup() {\n+        let text = r#\"<fold>mod a;\n+mod b;\n+mod c;</fold>\n+\n+fn main() <fold>{\n+    if cond <fold>{\n+        a::do_a();\n+    }</fold> else <fold>{\n+        b::do_b();\n+    }</fold>\n+}</fold>\"#;\n+\n+        let (ranges, text) = extract_ranges(text, \"fold\");\n+        assert_eq!(ranges.len(), 4);\n+        let folds = vec![\n+            Fold { range: ranges[0], kind: FoldKind::Mods },\n+            Fold { range: ranges[1], kind: FoldKind::Block },\n+            Fold { range: ranges[2], kind: FoldKind::Block },\n+            Fold { range: ranges[3], kind: FoldKind::Block },\n+        ];\n+\n+        let line_index = LineIndex::new(&text);\n+        let converted: Vec<lsp_types::FoldingRange> =\n+            folds.into_iter().map(|it| folding_range(&text, &line_index, true, it)).collect();\n+\n+        let expected_lines = [(0, 2), (4, 10), (5, 6), (7, 9)];\n+        assert_eq!(converted.len(), expected_lines.len());\n+        for (folding_range, (start_line, end_line)) in converted.iter().zip(expected_lines.iter()) {\n+            assert_eq!(folding_range.start_line, *start_line);\n+            assert_eq!(folding_range.start_character, None);\n+            assert_eq!(folding_range.end_line, *end_line);\n+            assert_eq!(folding_range.end_character, None);\n+        }\n+    }\n+}\n+\n+pub(crate) fn code_action(world: &WorldSnapshot, assist: Assist) -> Result<lsp_types::CodeAction> {\n+    let source_change = source_change(&world, assist.source_change)?;\n+    let arg = serde_json::to_value(source_change)?;\n+    let title = assist.label;\n+    let command = lsp_types::Command {\n+        title: title.clone(),\n+        command: \"rust-analyzer.applySourceChange\".to_string(),\n+        arguments: Some(vec![arg]),\n+    };\n+\n+    Ok(lsp_types::CodeAction {\n+        title,\n+        kind: Some(String::new()),\n+        diagnostics: None,\n+        edit: None,\n+        command: Some(command),\n+        is_preferred: None,\n+    })\n+}"}]}