{"sha": "2835d9d1d3ab3f09f0117cad8f0a6e0abe142282", "node_id": "C_kwDOAAsO6NoAKDI4MzVkOWQxZDNhYjNmMDlmMDExN2NhZDhmMGE2ZTBhYmUxNDIyODI", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-06-16T01:16:40Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-06-17T03:32:46Z"}, "message": "Simplify even more candidates", "tree": {"sha": "2f8f302a9f4657a5a5b70ecfbc53139f425cc3e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f8f302a9f4657a5a5b70ecfbc53139f425cc3e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2835d9d1d3ab3f09f0117cad8f0a6e0abe142282", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2835d9d1d3ab3f09f0117cad8f0a6e0abe142282", "html_url": "https://github.com/rust-lang/rust/commit/2835d9d1d3ab3f09f0117cad8f0a6e0abe142282", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2835d9d1d3ab3f09f0117cad8f0a6e0abe142282/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1311bb56f3946fcdcf8dd54fecf245ef408e6d04", "url": "https://api.github.com/repos/rust-lang/rust/commits/1311bb56f3946fcdcf8dd54fecf245ef408e6d04", "html_url": "https://github.com/rust-lang/rust/commit/1311bb56f3946fcdcf8dd54fecf245ef408e6d04"}], "stats": {"total": 249, "additions": 88, "deletions": 161}, "files": [{"sha": "d4cde7e2c6528871e2ecbca2bef68fe068f773db", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2835d9d1d3ab3f09f0117cad8f0a6e0abe142282/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2835d9d1d3ab3f09f0117cad8f0a6e0abe142282/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=2835d9d1d3ab3f09f0117cad8f0a6e0abe142282", "patch": "@@ -781,8 +781,13 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                             );\n                             return;\n                         }\n-                        Ok(Some(ImplSource::Closure(data))) => {\n-                            if !tcx.is_const_fn_raw(data.closure_def_id) {\n+                        Ok(Some(ImplSource::Closure(_))) => {\n+                            let ty::Closure(closure_def_id, substs) =\n+                                *poly_trait_pred.self_ty().no_bound_vars().unwrap().kind()\n+                            else {\n+                                unreachable!()\n+                            };\n+                            if !tcx.is_const_fn_raw(closure_def_id) {\n                                 self.check_op(ops::FnCallNonConst {\n                                     caller,\n                                     callee,"}, {"sha": "98179c0f933dc32d01527bd28b4e71f74a7d0ba7", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 26, "deletions": 75, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/2835d9d1d3ab3f09f0117cad8f0a6e0abe142282/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2835d9d1d3ab3f09f0117cad8f0a6e0abe142282/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=2835d9d1d3ab3f09f0117cad8f0a6e0abe142282", "patch": "@@ -664,16 +664,16 @@ pub enum ImplSource<'tcx, N> {\n     /// ImplSource automatically generated for a closure. The `DefId` is the ID\n     /// of the closure expression. This is an `ImplSource::UserDefined` in spirit, but the\n     /// impl is generated by the compiler and does not appear in the source.\n-    Closure(ImplSourceClosureData<'tcx, N>),\n+    Closure(Vec<N>),\n \n     /// Same as above, but for a function pointer type with the given signature.\n-    FnPointer(ImplSourceFnPointerData<'tcx, N>),\n+    FnPointer(Vec<N>),\n \n     /// ImplSource automatically generated for a generator.\n-    Generator(ImplSourceGeneratorData<'tcx, N>),\n+    Generator(Vec<N>),\n \n     /// ImplSource automatically generated for a generator backing an async future.\n-    Future(ImplSourceFutureData<'tcx, N>),\n+    Future(Vec<N>),\n \n     /// ImplSource for a trait alias.\n     TraitAlias(ImplSourceTraitAliasData<'tcx, N>),\n@@ -683,12 +683,13 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n     pub fn nested_obligations(self) -> Vec<N> {\n         match self {\n             ImplSource::UserDefined(i) => i.nested,\n-            ImplSource::Param(n, _) | ImplSource::Builtin(n) => n,\n-            ImplSource::Closure(c) => c.nested,\n-            ImplSource::Generator(c) => c.nested,\n-            ImplSource::Future(c) => c.nested,\n+            ImplSource::Param(n, _)\n+            | ImplSource::Builtin(n)\n+            | ImplSource::FnPointer(n)\n+            | ImplSource::Closure(n)\n+            | ImplSource::Generator(n)\n+            | ImplSource::Future(n) => n,\n             ImplSource::Object(d) => d.nested,\n-            ImplSource::FnPointer(d) => d.nested,\n             ImplSource::TraitAlias(d) => d.nested,\n             ImplSource::TraitUpcasting(d) => d.nested,\n         }\n@@ -697,12 +698,13 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n     pub fn borrow_nested_obligations(&self) -> &[N] {\n         match self {\n             ImplSource::UserDefined(i) => &i.nested,\n-            ImplSource::Param(n, _) | ImplSource::Builtin(n) => n,\n-            ImplSource::Closure(c) => &c.nested,\n-            ImplSource::Generator(c) => &c.nested,\n-            ImplSource::Future(c) => &c.nested,\n+            ImplSource::Param(n, _)\n+            | ImplSource::Builtin(n)\n+            | ImplSource::FnPointer(n)\n+            | ImplSource::Closure(n)\n+            | ImplSource::Generator(n)\n+            | ImplSource::Future(n) => &n,\n             ImplSource::Object(d) => &d.nested,\n-            ImplSource::FnPointer(d) => &d.nested,\n             ImplSource::TraitAlias(d) => &d.nested,\n             ImplSource::TraitUpcasting(d) => &d.nested,\n         }\n@@ -711,12 +713,13 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n     pub fn borrow_nested_obligations_mut(&mut self) -> &mut [N] {\n         match self {\n             ImplSource::UserDefined(i) => &mut i.nested,\n-            ImplSource::Param(n, _) | ImplSource::Builtin(n) => n,\n-            ImplSource::Closure(c) => &mut c.nested,\n-            ImplSource::Generator(c) => &mut c.nested,\n-            ImplSource::Future(c) => &mut c.nested,\n+            ImplSource::Param(n, _)\n+            | ImplSource::Builtin(n)\n+            | ImplSource::FnPointer(n)\n+            | ImplSource::Closure(n)\n+            | ImplSource::Generator(n)\n+            | ImplSource::Future(n) => n,\n             ImplSource::Object(d) => &mut d.nested,\n-            ImplSource::FnPointer(d) => &mut d.nested,\n             ImplSource::TraitAlias(d) => &mut d.nested,\n             ImplSource::TraitUpcasting(d) => &mut d.nested,\n         }\n@@ -739,25 +742,10 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n                 vtable_base: o.vtable_base,\n                 nested: o.nested.into_iter().map(f).collect(),\n             }),\n-            ImplSource::Closure(c) => ImplSource::Closure(ImplSourceClosureData {\n-                closure_def_id: c.closure_def_id,\n-                substs: c.substs,\n-                nested: c.nested.into_iter().map(f).collect(),\n-            }),\n-            ImplSource::Generator(c) => ImplSource::Generator(ImplSourceGeneratorData {\n-                generator_def_id: c.generator_def_id,\n-                substs: c.substs,\n-                nested: c.nested.into_iter().map(f).collect(),\n-            }),\n-            ImplSource::Future(c) => ImplSource::Future(ImplSourceFutureData {\n-                generator_def_id: c.generator_def_id,\n-                substs: c.substs,\n-                nested: c.nested.into_iter().map(f).collect(),\n-            }),\n-            ImplSource::FnPointer(p) => ImplSource::FnPointer(ImplSourceFnPointerData {\n-                fn_ty: p.fn_ty,\n-                nested: p.nested.into_iter().map(f).collect(),\n-            }),\n+            ImplSource::Closure(n) => ImplSource::Closure(n.into_iter().map(f).collect()),\n+            ImplSource::Generator(n) => ImplSource::Generator(n.into_iter().map(f).collect()),\n+            ImplSource::Future(n) => ImplSource::Future(n.into_iter().map(f).collect()),\n+            ImplSource::FnPointer(n) => ImplSource::FnPointer(n.into_iter().map(f).collect()),\n             ImplSource::TraitAlias(d) => ImplSource::TraitAlias(ImplSourceTraitAliasData {\n                 alias_def_id: d.alias_def_id,\n                 substs: d.substs,\n@@ -791,36 +779,6 @@ pub struct ImplSourceUserDefinedData<'tcx, N> {\n     pub nested: Vec<N>,\n }\n \n-#[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, Lift)]\n-#[derive(TypeFoldable, TypeVisitable)]\n-pub struct ImplSourceGeneratorData<'tcx, N> {\n-    pub generator_def_id: DefId,\n-    pub substs: SubstsRef<'tcx>,\n-    /// Nested obligations. This can be non-empty if the generator\n-    /// signature contains associated types.\n-    pub nested: Vec<N>,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, Lift)]\n-#[derive(TypeFoldable, TypeVisitable)]\n-pub struct ImplSourceFutureData<'tcx, N> {\n-    pub generator_def_id: DefId,\n-    pub substs: SubstsRef<'tcx>,\n-    /// Nested obligations. This can be non-empty if the generator\n-    /// signature contains associated types.\n-    pub nested: Vec<N>,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, Lift)]\n-#[derive(TypeFoldable, TypeVisitable)]\n-pub struct ImplSourceClosureData<'tcx, N> {\n-    pub closure_def_id: DefId,\n-    pub substs: SubstsRef<'tcx>,\n-    /// Nested obligations. This can be non-empty if the closure\n-    /// signature contains associated types.\n-    pub nested: Vec<N>,\n-}\n-\n #[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, Lift)]\n #[derive(TypeFoldable, TypeVisitable)]\n pub struct ImplSourceTraitUpcastingData<N> {\n@@ -848,13 +806,6 @@ pub struct ImplSourceObjectData<N> {\n     pub nested: Vec<N>,\n }\n \n-#[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, Lift)]\n-#[derive(TypeFoldable, TypeVisitable)]\n-pub struct ImplSourceFnPointerData<'tcx, N> {\n-    pub fn_ty: Ty<'tcx>,\n-    pub nested: Vec<N>,\n-}\n-\n #[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, Lift)]\n #[derive(TypeFoldable, TypeVisitable)]\n pub struct ImplSourceTraitAliasData<'tcx, N> {"}, {"sha": "bc0e656a656cbe318ef40ac78d6ab8bb3e6522fd", "filename": "compiler/rustc_middle/src/traits/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2835d9d1d3ab3f09f0117cad8f0a6e0abe142282/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2835d9d1d3ab3f09f0117cad8f0a6e0abe142282/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs?ref=2835d9d1d3ab3f09f0117cad8f0a6e0abe142282", "patch": "@@ -42,36 +42,6 @@ impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceUserDefinedData<'tcx,\n     }\n }\n \n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceGeneratorData<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"ImplSourceGeneratorData(generator_def_id={:?}, substs={:?}, nested={:?})\",\n-            self.generator_def_id, self.substs, self.nested\n-        )\n-    }\n-}\n-\n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceFutureData<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"ImplSourceFutureData(generator_def_id={:?}, substs={:?}, nested={:?})\",\n-            self.generator_def_id, self.substs, self.nested\n-        )\n-    }\n-}\n-\n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceClosureData<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"ImplSourceClosureData(closure_def_id={:?}, substs={:?}, nested={:?})\",\n-            self.closure_def_id, self.substs, self.nested\n-        )\n-    }\n-}\n-\n impl<N: fmt::Debug> fmt::Debug for traits::ImplSourceTraitUpcastingData<N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n@@ -92,12 +62,6 @@ impl<N: fmt::Debug> fmt::Debug for traits::ImplSourceObjectData<N> {\n     }\n }\n \n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceFnPointerData<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"ImplSourceFnPointerData(fn_ty={:?}, nested={:?})\", self.fn_ty, self.nested)\n-    }\n-}\n-\n impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceTraitAliasData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!("}, {"sha": "1477c8957f6e1c149d9faa8bfa787caaf3f71ec4", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/2835d9d1d3ab3f09f0117cad8f0a6e0abe142282/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2835d9d1d3ab3f09f0117cad8f0a6e0abe142282/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=2835d9d1d3ab3f09f0117cad8f0a6e0abe142282", "patch": "@@ -3,17 +3,14 @@\n use super::specialization_graph;\n use super::translate_substs;\n use super::util;\n+use super::ImplSourceUserDefinedData;\n use super::MismatchedProjectionTypes;\n use super::Obligation;\n use super::ObligationCause;\n use super::PredicateObligation;\n use super::Selection;\n use super::SelectionContext;\n use super::SelectionError;\n-use super::{\n-    ImplSourceClosureData, ImplSourceFnPointerData, ImplSourceFutureData, ImplSourceGeneratorData,\n-    ImplSourceUserDefinedData,\n-};\n use super::{Normalized, NormalizedTy, ProjectionCacheEntry, ProjectionCacheKey};\n \n use crate::errors::InherentProjectionNormalizationOverflow;\n@@ -2015,9 +2012,14 @@ fn confirm_select_candidate<'cx, 'tcx>(\n fn confirm_generator_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    impl_source: ImplSourceGeneratorData<'tcx, PredicateObligation<'tcx>>,\n+    nested: Vec<PredicateObligation<'tcx>>,\n ) -> Progress<'tcx> {\n-    let gen_sig = impl_source.substs.as_generator().poly_sig();\n+    let ty::Generator(_, substs, _) =\n+        selcx.infcx.shallow_resolve(obligation.predicate.self_ty()).kind()\n+    else {\n+        unreachable!()\n+    };\n+    let gen_sig = substs.as_generator().poly_sig();\n     let Normalized { value: gen_sig, obligations } = normalize_with_depth(\n         selcx,\n         obligation.param_env,\n@@ -2055,16 +2057,21 @@ fn confirm_generator_candidate<'cx, 'tcx>(\n     });\n \n     confirm_param_env_candidate(selcx, obligation, predicate, false)\n-        .with_addl_obligations(impl_source.nested)\n+        .with_addl_obligations(nested)\n         .with_addl_obligations(obligations)\n }\n \n fn confirm_future_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    impl_source: ImplSourceFutureData<'tcx, PredicateObligation<'tcx>>,\n+    nested: Vec<PredicateObligation<'tcx>>,\n ) -> Progress<'tcx> {\n-    let gen_sig = impl_source.substs.as_generator().poly_sig();\n+    let ty::Generator(_, substs, _) =\n+        selcx.infcx.shallow_resolve(obligation.predicate.self_ty()).kind()\n+    else {\n+        unreachable!()\n+    };\n+    let gen_sig = substs.as_generator().poly_sig();\n     let Normalized { value: gen_sig, obligations } = normalize_with_depth(\n         selcx,\n         obligation.param_env,\n@@ -2094,7 +2101,7 @@ fn confirm_future_candidate<'cx, 'tcx>(\n     });\n \n     confirm_param_env_candidate(selcx, obligation, predicate, false)\n-        .with_addl_obligations(impl_source.nested)\n+        .with_addl_obligations(nested)\n         .with_addl_obligations(obligations)\n }\n \n@@ -2155,9 +2162,9 @@ fn confirm_builtin_candidate<'cx, 'tcx>(\n fn confirm_fn_pointer_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    fn_pointer_impl_source: ImplSourceFnPointerData<'tcx, PredicateObligation<'tcx>>,\n+    nested: Vec<PredicateObligation<'tcx>>,\n ) -> Progress<'tcx> {\n-    let fn_type = selcx.infcx.shallow_resolve(fn_pointer_impl_source.fn_ty);\n+    let fn_type = selcx.infcx.shallow_resolve(obligation.predicate.self_ty());\n     let sig = fn_type.fn_sig(selcx.tcx());\n     let Normalized { value: sig, obligations } = normalize_with_depth(\n         selcx,\n@@ -2168,16 +2175,21 @@ fn confirm_fn_pointer_candidate<'cx, 'tcx>(\n     );\n \n     confirm_callable_candidate(selcx, obligation, sig, util::TupleArgumentsFlag::Yes)\n-        .with_addl_obligations(fn_pointer_impl_source.nested)\n+        .with_addl_obligations(nested)\n         .with_addl_obligations(obligations)\n }\n \n fn confirm_closure_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    impl_source: ImplSourceClosureData<'tcx, PredicateObligation<'tcx>>,\n+    nested: Vec<PredicateObligation<'tcx>>,\n ) -> Progress<'tcx> {\n-    let closure_sig = impl_source.substs.as_closure().sig();\n+    let ty::Closure(_, substs) =\n+        selcx.infcx.shallow_resolve(obligation.predicate.self_ty()).kind()\n+    else {\n+        unreachable!()\n+    };\n+    let closure_sig = substs.as_closure().sig();\n     let Normalized { value: closure_sig, obligations } = normalize_with_depth(\n         selcx,\n         obligation.param_env,\n@@ -2189,7 +2201,7 @@ fn confirm_closure_candidate<'cx, 'tcx>(\n     debug!(?obligation, ?closure_sig, ?obligations, \"confirm_closure_candidate\");\n \n     confirm_callable_candidate(selcx, obligation, closure_sig, util::TupleArgumentsFlag::No)\n-        .with_addl_obligations(impl_source.nested)\n+        .with_addl_obligations(nested)\n         .with_addl_obligations(obligations)\n }\n "}, {"sha": "d369a087c9b8cae52143c5bce6308585aad4c772", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2835d9d1d3ab3f09f0117cad8f0a6e0abe142282/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2835d9d1d3ab3f09f0117cad8f0a6e0abe142282/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=2835d9d1d3ab3f09f0117cad8f0a6e0abe142282", "patch": "@@ -27,7 +27,6 @@ use crate::traits::vtable::{\n };\n use crate::traits::{\n     BuiltinDerivedObligation, ImplDerivedObligation, ImplDerivedObligationCause, ImplSource,\n-    ImplSourceClosureData, ImplSourceFnPointerData, ImplSourceFutureData, ImplSourceGeneratorData,\n     ImplSourceObjectData, ImplSourceTraitAliasData, ImplSourceTraitUpcastingData,\n     ImplSourceUserDefinedData, Normalized, Obligation, ObligationCause,\n     OutputTypeParameterMismatch, PredicateObligation, Selection, SelectionError,\n@@ -664,8 +663,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n         is_const: bool,\n-    ) -> Result<ImplSourceFnPointerData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>>\n-    {\n+    ) -> Result<Vec<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n         debug!(?obligation, \"confirm_fn_pointer_candidate\");\n \n         let tcx = self.tcx();\n@@ -717,7 +715,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let tr = ty::TraitRef::from_lang_item(self.tcx(), LangItem::Sized, cause.span, [output_ty]);\n         nested.push(Obligation::new(self.infcx.tcx, cause, obligation.param_env, tr));\n \n-        Ok(ImplSourceFnPointerData { fn_ty: self_ty, nested })\n+        Ok(nested)\n     }\n \n     fn confirm_trait_alias_candidate(\n@@ -749,8 +747,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn confirm_generator_candidate(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n-    ) -> Result<ImplSourceGeneratorData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>>\n-    {\n+    ) -> Result<Vec<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n         // Okay to skip binder because the substs on generator types never\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters.\n@@ -783,13 +780,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let nested = self.confirm_poly_trait_refs(obligation, trait_ref)?;\n         debug!(?trait_ref, ?nested, \"generator candidate obligations\");\n \n-        Ok(ImplSourceGeneratorData { generator_def_id, substs, nested })\n+        Ok(nested)\n     }\n \n     fn confirm_future_candidate(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n-    ) -> Result<ImplSourceFutureData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n+    ) -> Result<Vec<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n         // Okay to skip binder because the substs on generator types never\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters.\n@@ -813,14 +810,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let nested = self.confirm_poly_trait_refs(obligation, trait_ref)?;\n         debug!(?trait_ref, ?nested, \"future candidate obligations\");\n \n-        Ok(ImplSourceFutureData { generator_def_id, substs, nested })\n+        Ok(nested)\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n     fn confirm_closure_candidate(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n-    ) -> Result<ImplSourceClosureData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n+    ) -> Result<Vec<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n         let kind = self\n             .tcx()\n             .fn_trait_kind_from_def_id(obligation.predicate.def_id())\n@@ -847,7 +844,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ));\n         }\n \n-        Ok(ImplSourceClosureData { closure_def_id, substs, nested })\n+        Ok(nested)\n     }\n \n     /// In the case of closure types and fn pointers,"}, {"sha": "cc7700f378a0f28afbc51729b3df240a0d5cf697", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2835d9d1d3ab3f09f0117cad8f0a6e0abe142282/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2835d9d1d3ab3f09f0117cad8f0a6e0abe142282/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=2835d9d1d3ab3f09f0117cad8f0a6e0abe142282", "patch": "@@ -177,38 +177,41 @@ fn resolve_associated_item<'tcx>(\n \n             Some(ty::Instance::new(leaf_def.item.def_id, substs))\n         }\n-        traits::ImplSource::Generator(generator_data) => {\n+        traits::ImplSource::Generator(_) => {\n+            let ty::Generator(generator_def_id, substs, _) = *rcvr_substs.type_at(0).kind() else {\n+                unreachable!()\n+            };\n             if cfg!(debug_assertions) && tcx.item_name(trait_item_id) != sym::resume {\n                 // For compiler developers who'd like to add new items to `Generator`,\n                 // you either need to generate a shim body, or perhaps return\n                 // `InstanceDef::Item` pointing to a trait default method body if\n                 // it is given a default implementation by the trait.\n                 span_bug!(\n-                    tcx.def_span(generator_data.generator_def_id),\n+                    tcx.def_span(generator_def_id),\n                     \"no definition for `{trait_ref}::{}` for built-in generator type\",\n                     tcx.item_name(trait_item_id)\n                 )\n             }\n-            Some(Instance {\n-                def: ty::InstanceDef::Item(generator_data.generator_def_id),\n-                substs: generator_data.substs,\n-            })\n+            Some(Instance { def: ty::InstanceDef::Item(generator_def_id), substs })\n         }\n-        traits::ImplSource::Future(future_data) => {\n+        traits::ImplSource::Future(_) => {\n+            let ty::Generator(generator_def_id, substs, _) = *rcvr_substs.type_at(0).kind() else {\n+                unreachable!()\n+            };\n             if Some(trait_item_id) == tcx.lang_items().future_poll_fn() {\n                 // `Future::poll` is generated by the compiler.\n-                Some(Instance {\n-                    def: ty::InstanceDef::Item(future_data.generator_def_id),\n-                    substs: future_data.substs,\n-                })\n+                Some(Instance { def: ty::InstanceDef::Item(generator_def_id), substs: substs })\n             } else {\n                 // All other methods are default methods of the `Future` trait.\n                 // (this assumes that `ImplSource::Future` is only used for methods on `Future`)\n                 debug_assert!(tcx.defaultness(trait_item_id).has_value());\n                 Some(Instance::new(trait_item_id, rcvr_substs))\n             }\n         }\n-        traits::ImplSource::Closure(closure_data) => {\n+        traits::ImplSource::Closure(_) => {\n+            let ty::Closure(closure_def_id, substs) = *rcvr_substs.type_at(0).kind() else {\n+                unreachable!()\n+            };\n             if cfg!(debug_assertions)\n                 && ![sym::call, sym::call_mut, sym::call_once]\n                     .contains(&tcx.item_name(trait_item_id))\n@@ -218,20 +221,15 @@ fn resolve_associated_item<'tcx>(\n                 // `InstanceDef::Item` pointing to a trait default method body if\n                 // it is given a default implementation by the trait.\n                 span_bug!(\n-                    tcx.def_span(closure_data.closure_def_id),\n+                    tcx.def_span(closure_def_id),\n                     \"no definition for `{trait_ref}::{}` for built-in closure type\",\n                     tcx.item_name(trait_item_id)\n                 )\n             }\n             let trait_closure_kind = tcx.fn_trait_kind_from_def_id(trait_id).unwrap();\n-            Instance::resolve_closure(\n-                tcx,\n-                closure_data.closure_def_id,\n-                closure_data.substs,\n-                trait_closure_kind,\n-            )\n+            Instance::resolve_closure(tcx, closure_def_id, substs, trait_closure_kind)\n         }\n-        traits::ImplSource::FnPointer(ref data) => match data.fn_ty.kind() {\n+        traits::ImplSource::FnPointer(_) => match rcvr_substs.type_at(0).kind() {\n             ty::FnDef(..) | ty::FnPtr(..) => {\n                 if cfg!(debug_assertions)\n                     && ![sym::call, sym::call_mut, sym::call_once]\n@@ -247,7 +245,7 @@ fn resolve_associated_item<'tcx>(\n                     )\n                 }\n                 Some(Instance {\n-                    def: ty::InstanceDef::FnPtrShim(trait_item_id, data.fn_ty),\n+                    def: ty::InstanceDef::FnPtrShim(trait_item_id, rcvr_substs.type_at(0)),\n                     substs: rcvr_substs,\n                 })\n             }"}]}