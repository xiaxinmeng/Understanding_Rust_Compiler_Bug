{"sha": "bd4bd59ad7946f0717f1babb38a971b608fe4f3b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkNGJkNTlhZDc5NDZmMDcxN2YxYmFiYjM4YTk3MWI2MDhmZTRmM2I=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-05-13T20:40:22Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-06-12T15:50:17Z"}, "message": "Helper method for whether type has structural equality\n\nThis helper method works for all types, falling back to a query for\n`TyKind::Adt`s to determine whether the implement the\n`{Partial,}StructuralEq` traits.", "tree": {"sha": "66b47f3b9e00b9c767164e102be67ee4f2153d38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66b47f3b9e00b9c767164e102be67ee4f2153d38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd4bd59ad7946f0717f1babb38a971b608fe4f3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd4bd59ad7946f0717f1babb38a971b608fe4f3b", "html_url": "https://github.com/rust-lang/rust/commit/bd4bd59ad7946f0717f1babb38a971b608fe4f3b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd4bd59ad7946f0717f1babb38a971b608fe4f3b/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50c0192c64241d723066add22c53d472e2b9cba9", "url": "https://api.github.com/repos/rust-lang/rust/commits/50c0192c64241d723066add22c53d472e2b9cba9", "html_url": "https://github.com/rust-lang/rust/commit/50c0192c64241d723066add22c53d472e2b9cba9"}], "stats": {"total": 103, "additions": 85, "deletions": 18}, "files": [{"sha": "be15e6c576f69379f628818b89adda626770167b", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bd4bd59ad7946f0717f1babb38a971b608fe4f3b/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd4bd59ad7946f0717f1babb38a971b608fe4f3b/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=bd4bd59ad7946f0717f1babb38a971b608fe4f3b", "patch": "@@ -789,6 +789,17 @@ rustc_queries! {\n             desc { \"computing whether `{}` needs drop\", env.value }\n         }\n \n+        /// Query backing `TyS::is_structural_eq_shallow`.\n+        ///\n+        /// This is only correct for ADTs. Call `is_structural_eq_shallow` to handle all types\n+        /// correctly.\n+        query has_structural_eq_impls(ty: Ty<'tcx>) -> bool {\n+            desc {\n+                \"computing whether `{:?}` implements `PartialStructuralEq` and `StructuralEq`\",\n+                ty\n+            }\n+        }\n+\n         /// A list of types where the ADT requires drop if and only if any of\n         /// those types require drop. If the ADT is known to always need drop\n         /// then `Err(AlwaysRequiresDrop)` is returned."}, {"sha": "252a11129beda03f2961000de4f992799baca131", "filename": "src/librustc_middle/ty/util.rs", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/bd4bd59ad7946f0717f1babb38a971b608fe4f3b/src%2Flibrustc_middle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd4bd59ad7946f0717f1babb38a971b608fe4f3b/src%2Flibrustc_middle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Futil.rs?ref=bd4bd59ad7946f0717f1babb38a971b608fe4f3b", "patch": "@@ -778,6 +778,57 @@ impl<'tcx> ty::TyS<'tcx> {\n         }\n     }\n \n+    /// Returns `true` if equality for this type is both total and structural.\n+    ///\n+    /// Total equality for a type is indicated by an `Eq` impl for that type.\n+    ///\n+    /// Primitive types (`u32`, `str`) have structural equality by definition. For composite data\n+    /// types, equality for the type as a whole is structural when it is the same as equality\n+    /// between all components (fields, array elements, etc.) of that type. For ADTs, structural\n+    /// equality is indicated by an implementation of `PartialStructuralEq` and `StructuralEq` for\n+    /// that type.\n+    ///\n+    /// This function is \"shallow\" because it may return `true` for a composite type whose fields\n+    /// are not `StructuralEq`. For example, `[T; 4]` has structural equality regardless of `T`\n+    /// because equality for arrays is determined by the equality of each array element. If you\n+    /// want to know whether a given call to `PartialEq::eq` will proceed structurally all the way\n+    /// down, you will need to use a type visitor.\n+    #[inline]\n+    pub fn is_structural_eq_shallow(&'tcx self, tcx: TyCtxt<'tcx>) -> bool {\n+        match self.kind {\n+            // Look for an impl of both `PartialStructuralEq` and `StructuralEq`.\n+            Adt(..) => tcx.has_structural_eq_impls(self),\n+\n+            // Primitive types that satisfy `Eq`.\n+            Bool | Char | Int(_) | Uint(_) | Str | Never => true,\n+\n+            // Composite types that satisfy `Eq` when all of their fields do.\n+            //\n+            // Because this function is \"shallow\", we return `true` for these composites regardless\n+            // of the type(s) contained within.\n+            Ref(..) | Array(..) | Slice(_) | Tuple(..) => true,\n+\n+            // Raw pointers use bitwise comparison.\n+            RawPtr(_) | FnPtr(_) => true,\n+\n+            // Floating point numbers are not `Eq`.\n+            Float(_) => false,\n+\n+            // Conservatively return `false` for all others...\n+\n+            // Anonymous function types\n+            FnDef(..) | Closure(..) | Dynamic(..) | Generator(..) => false,\n+\n+            // Generic or inferred types\n+            //\n+            // FIXME(ecstaticmorse): Maybe we should `bug` here? This should probably only be\n+            // called for known, fully-monomorphized types.\n+            Projection(_) | Opaque(..) | Param(_) | Bound(..) | Placeholder(_) | Infer(_) => false,\n+\n+            Foreign(_) | GeneratorWitness(..) | Error => false,\n+        }\n+    }\n+\n     pub fn same_type(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n         match (&a.kind, &b.kind) {\n             (&Adt(did_a, substs_a), &Adt(did_b, substs_b)) => {"}, {"sha": "936c1a84e142eb9a595c042c016dfe695eac7303", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd4bd59ad7946f0717f1babb38a971b608fe4f3b/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd4bd59ad7946f0717f1babb38a971b608fe4f3b/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=bd4bd59ad7946f0717f1babb38a971b608fe4f3b", "patch": "@@ -2,7 +2,6 @@\n //!\n //! See the `Qualif` trait for more info.\n \n-use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, subst::SubstsRef, AdtDef, Ty};\n use rustc_span::DUMMY_SP;\n@@ -137,10 +136,7 @@ impl Qualif for CustomEq {\n         substs: SubstsRef<'tcx>,\n     ) -> bool {\n         let ty = cx.tcx.mk_ty(ty::Adt(adt, substs));\n-        let id = cx.tcx.hir().local_def_id_to_hir_id(cx.def_id.as_local().unwrap());\n-        cx.tcx\n-            .infer_ctxt()\n-            .enter(|infcx| !traits::type_marked_structural(id, cx.body.span, &infcx, ty))\n+        !ty.is_structural_eq_shallow(cx.tcx)\n     }\n }\n "}, {"sha": "46b687d76e50431e89e1c1c33f43e10bfd769ebc", "filename": "src/librustc_mir_build/hair/pattern/const_to_pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd4bd59ad7946f0717f1babb38a971b608fe4f3b/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd4bd59ad7946f0717f1babb38a971b608fe4f3b/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs?ref=bd4bd59ad7946f0717f1babb38a971b608fe4f3b", "patch": "@@ -80,7 +80,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n     }\n \n     fn type_marked_structural(&self, ty: Ty<'tcx>) -> bool {\n-        traits::type_marked_structural(self.id, self.span, &self.infcx, ty)\n+        ty.is_structural_eq_shallow(self.infcx.tcx)\n     }\n \n     fn to_pat("}, {"sha": "225bbfeb262fdd7277898bac6ed911f0373c991a", "filename": "src/librustc_trait_selection/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd4bd59ad7946f0717f1babb38a971b608fe4f3b/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd4bd59ad7946f0717f1babb38a971b608fe4f3b/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs?ref=bd4bd59ad7946f0717f1babb38a971b608fe4f3b", "patch": "@@ -553,6 +553,7 @@ fn type_implements_trait<'tcx>(\n \n pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     object_safety::provide(providers);\n+    structural_match::provide(providers);\n     *providers = ty::query::Providers {\n         specialization_graph_of: specialize::specialization_graph_provider,\n         specializes: specialize::specializes,"}, {"sha": "d01163a29d5bab07c40492daa4f492ce0757c8a8", "filename": "src/librustc_trait_selection/traits/structural_match.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bd4bd59ad7946f0717f1babb38a971b608fe4f3b/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd4bd59ad7946f0717f1babb38a971b608fe4f3b/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs?ref=bd4bd59ad7946f0717f1babb38a971b608fe4f3b", "patch": "@@ -1,10 +1,11 @@\n use crate::infer::{InferCtxt, TyCtxtInferExt};\n use crate::traits::ObligationCause;\n-use crate::traits::{self, ConstPatternStructural, TraitEngine};\n+use crate::traits::{self, TraitEngine};\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::lang_items::{StructuralPeqTraitLangItem, StructuralTeqTraitLangItem};\n+use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, AdtDef, Ty, TyCtxt, TypeFoldable, TypeVisitor};\n use rustc_span::Span;\n \n@@ -45,14 +46,14 @@ pub enum NonStructuralMatchTy<'tcx> {\n /// that arose when the requirement was not enforced completely, see\n /// Rust RFC 1445, rust-lang/rust#61188, and rust-lang/rust#62307.\n pub fn search_for_structural_match_violation<'tcx>(\n-    id: hir::HirId,\n+    _id: hir::HirId,\n     span: Span,\n     tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,\n ) -> Option<NonStructuralMatchTy<'tcx>> {\n     // FIXME: we should instead pass in an `infcx` from the outside.\n     tcx.infer_ctxt().enter(|infcx| {\n-        let mut search = Search { id, span, infcx, found: None, seen: FxHashSet::default() };\n+        let mut search = Search { infcx, span, found: None, seen: FxHashSet::default() };\n         ty.visit_with(&mut search);\n         search.found\n     })\n@@ -66,26 +67,25 @@ pub fn search_for_structural_match_violation<'tcx>(\n /// Note that this does *not* recursively check if the substructure of `adt_ty`\n /// implements the traits.\n pub fn type_marked_structural(\n-    id: hir::HirId,\n-    span: Span,\n     infcx: &InferCtxt<'_, 'tcx>,\n     adt_ty: Ty<'tcx>,\n+    cause: ObligationCause<'tcx>,\n ) -> bool {\n     let mut fulfillment_cx = traits::FulfillmentContext::new();\n-    let cause = ObligationCause::new(span, id, ConstPatternStructural);\n     // require `#[derive(PartialEq)]`\n-    let structural_peq_def_id = infcx.tcx.require_lang_item(StructuralPeqTraitLangItem, Some(span));\n+    let structural_peq_def_id =\n+        infcx.tcx.require_lang_item(StructuralPeqTraitLangItem, Some(cause.span));\n     fulfillment_cx.register_bound(\n         infcx,\n         ty::ParamEnv::empty(),\n         adt_ty,\n         structural_peq_def_id,\n-        cause,\n+        cause.clone(),\n     );\n     // for now, require `#[derive(Eq)]`. (Doing so is a hack to work around\n     // the type `for<'a> fn(&'a ())` failing to implement `Eq` itself.)\n-    let cause = ObligationCause::new(span, id, ConstPatternStructural);\n-    let structural_teq_def_id = infcx.tcx.require_lang_item(StructuralTeqTraitLangItem, Some(span));\n+    let structural_teq_def_id =\n+        infcx.tcx.require_lang_item(StructuralTeqTraitLangItem, Some(cause.span));\n     fulfillment_cx.register_bound(\n         infcx,\n         ty::ParamEnv::empty(),\n@@ -110,7 +110,6 @@ pub fn type_marked_structural(\n /// find instances of ADTs (specifically structs or enums) that do not implement\n /// the structural-match traits (`StructuralPartialEq` and `StructuralEq`).\n struct Search<'a, 'tcx> {\n-    id: hir::HirId,\n     span: Span,\n \n     infcx: InferCtxt<'a, 'tcx>,\n@@ -129,7 +128,7 @@ impl Search<'a, 'tcx> {\n     }\n \n     fn type_marked_structural(&self, adt_ty: Ty<'tcx>) -> bool {\n-        type_marked_structural(self.id, self.span, &self.infcx, adt_ty)\n+        adt_ty.is_structural_eq_shallow(self.tcx())\n     }\n }\n \n@@ -266,3 +265,12 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for Search<'a, 'tcx> {\n         false\n     }\n }\n+\n+pub fn provide(providers: &mut Providers<'_>) {\n+    providers.has_structural_eq_impls = |tcx, ty| {\n+        tcx.infer_ctxt().enter(|infcx| {\n+            let cause = ObligationCause::dummy();\n+            type_marked_structural(&infcx, ty, cause)\n+        })\n+    };\n+}"}]}