{"sha": "4e04d57efa665ae62a2af4c2d785809f15c17599", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlMDRkNTdlZmE2NjVhZTYyYTJhZjRjMmQ3ODU4MDlmMTVjMTc1OTk=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-03-27T00:43:14Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-04-01T00:55:13Z"}, "message": "Added type-specific overflow checks when computing enum discriminant values.\n\nMoved such overflow checking into one place (in `rustc::middle::ty`,\nsince it needs to be run on-demand during `const_eval` in some\nscenarios), and revised `rustc_typeck` accordingly.\n\n(Note that we only check for overflow if program did not provide a\ndiscriminant value explicitly.)\n\nFix #23030\n\nFix #23221\n\nFix #23235", "tree": {"sha": "424c1b1b472505f8c0ba1e78baee5aa43975b7d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/424c1b1b472505f8c0ba1e78baee5aa43975b7d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e04d57efa665ae62a2af4c2d785809f15c17599", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e04d57efa665ae62a2af4c2d785809f15c17599", "html_url": "https://github.com/rust-lang/rust/commit/4e04d57efa665ae62a2af4c2d785809f15c17599", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e04d57efa665ae62a2af4c2d785809f15c17599/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d754722a04b99fdcae0fd97fa2a4395521145ef2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d754722a04b99fdcae0fd97fa2a4395521145ef2", "html_url": "https://github.com/rust-lang/rust/commit/d754722a04b99fdcae0fd97fa2a4395521145ef2"}], "stats": {"total": 397, "additions": 279, "deletions": 118}, "files": [{"sha": "0a29ed90ad46100d863d69a2e799c34000632a69", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4e04d57efa665ae62a2af4c2d785809f15c17599/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e04d57efa665ae62a2af4c2d785809f15c17599/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=4e04d57efa665ae62a2af4c2d785809f15c17599", "patch": "@@ -68,6 +68,8 @@ register_diagnostics! {\n     E0019,\n     E0020,\n     E0022,\n+    E0079, // enum variant: expected signed integer constant\n+    E0080, // enum variant: constant evaluation error\n     E0109,\n     E0110,\n     E0133,\n@@ -128,7 +130,8 @@ register_diagnostics! {\n     E0313, // lifetime of borrowed pointer outlives lifetime of captured variable\n     E0314, // closure outlives stack frame\n     E0315, // cannot invoke closure outside of its lifetime\n-    E0316 // nested quantification of lifetimes\n+    E0316, // nested quantification of lifetimes\n+    E0370  // discriminant overflow\n }\n \n __build_diagnostic_array! { DIAGNOSTICS }"}, {"sha": "c40f31d837a90a876040e68fdc795afedfc9670c", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 257, "deletions": 48, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/4e04d57efa665ae62a2af4c2d785809f15c17599/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e04d57efa665ae62a2af4c2d785809f15c17599/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=4e04d57efa665ae62a2af4c2d785809f15c17599", "patch": "@@ -73,6 +73,8 @@ use std::cmp;\n use std::fmt;\n use std::hash::{Hash, SipHasher, Hasher};\n use std::mem;\n+use std::num::ToPrimitive;\n+use std::num::wrapping::WrappingOps;\n use std::ops;\n use std::rc::Rc;\n use std::vec::IntoIter;\n@@ -83,9 +85,11 @@ use syntax::ast::{CrateNum, DefId, Ident, ItemTrait, LOCAL_CRATE};\n use syntax::ast::{MutImmutable, MutMutable, Name, NamedField, NodeId};\n use syntax::ast::{StmtExpr, StmtSemi, StructField, UnnamedField, Visibility};\n use syntax::ast_util::{self, is_local, lit_is_str, local_def};\n-use syntax::attr::{self, AttrMetaMethods};\n+use syntax::attr::{self, AttrMetaMethods, SignedInt, UnsignedInt};\n use syntax::codemap::Span;\n use syntax::parse::token::{self, InternedString, special_idents};\n+use syntax::print::pprust;\n+use syntax::ptr::P;\n use syntax::{ast, ast_map};\n \n pub type Disr = u64;\n@@ -5489,63 +5493,268 @@ pub fn type_is_empty(cx: &ctxt, ty: Ty) -> bool {\n      }\n }\n \n+trait IntTypeExt {\n+    fn to_ty<'tcx>(&self, cx: &ctxt<'tcx>) -> Ty<'tcx>;\n+    fn i64_to_disr(&self, val: i64) -> Option<Disr>;\n+    fn u64_to_disr(&self, val: u64) -> Option<Disr>;\n+    fn disr_incr(&self, val: Disr) -> Option<Disr>;\n+    fn disr_string(&self, val: Disr) -> String;\n+    fn disr_wrap_incr(&self, val: Option<Disr>) -> Disr;\n+}\n+\n+impl IntTypeExt for attr::IntType {\n+    fn to_ty<'tcx>(&self, cx: &ctxt<'tcx>) -> Ty<'tcx> {\n+        match *self {\n+            SignedInt(ast::TyI8)      => cx.types.i8,\n+            SignedInt(ast::TyI16)     => cx.types.i16,\n+            SignedInt(ast::TyI32)     => cx.types.i32,\n+            SignedInt(ast::TyI64)     => cx.types.i64,\n+            SignedInt(ast::TyIs)   => cx.types.int,\n+            UnsignedInt(ast::TyU8)    => cx.types.u8,\n+            UnsignedInt(ast::TyU16)   => cx.types.u16,\n+            UnsignedInt(ast::TyU32)   => cx.types.u32,\n+            UnsignedInt(ast::TyU64)   => cx.types.u64,\n+            UnsignedInt(ast::TyUs) => cx.types.uint,\n+        }\n+    }\n+\n+    fn i64_to_disr(&self, val: i64) -> Option<Disr> {\n+        match *self {\n+            SignedInt(ast::TyI8)    => val.to_i8()  .map(|v| v as Disr),\n+            SignedInt(ast::TyI16)   => val.to_i16() .map(|v| v as Disr),\n+            SignedInt(ast::TyI32)   => val.to_i32() .map(|v| v as Disr),\n+            SignedInt(ast::TyI64)   => val.to_i64() .map(|v| v as Disr),\n+            UnsignedInt(ast::TyU8)  => val.to_u8()  .map(|v| v as Disr),\n+            UnsignedInt(ast::TyU16) => val.to_u16() .map(|v| v as Disr),\n+            UnsignedInt(ast::TyU32) => val.to_u32() .map(|v| v as Disr),\n+            UnsignedInt(ast::TyU64) => val.to_u64() .map(|v| v as Disr),\n+\n+            UnsignedInt(ast::TyUs) |\n+            SignedInt(ast::TyIs) => unreachable!(),\n+        }\n+    }\n+\n+    fn u64_to_disr(&self, val: u64) -> Option<Disr> {\n+        match *self {\n+            SignedInt(ast::TyI8)    => val.to_i8()  .map(|v| v as Disr),\n+            SignedInt(ast::TyI16)   => val.to_i16() .map(|v| v as Disr),\n+            SignedInt(ast::TyI32)   => val.to_i32() .map(|v| v as Disr),\n+            SignedInt(ast::TyI64)   => val.to_i64() .map(|v| v as Disr),\n+            UnsignedInt(ast::TyU8)  => val.to_u8()  .map(|v| v as Disr),\n+            UnsignedInt(ast::TyU16) => val.to_u16() .map(|v| v as Disr),\n+            UnsignedInt(ast::TyU32) => val.to_u32() .map(|v| v as Disr),\n+            UnsignedInt(ast::TyU64) => val.to_u64() .map(|v| v as Disr),\n+\n+            UnsignedInt(ast::TyUs) |\n+            SignedInt(ast::TyIs) => unreachable!(),\n+        }\n+    }\n+\n+    fn disr_incr(&self, val: Disr) -> Option<Disr> {\n+        macro_rules! add1 {\n+            ($e:expr) => { $e.and_then(|v|v.checked_add(1)).map(|v| v as Disr) }\n+        }\n+        match *self {\n+            // SignedInt repr means we *want* to reinterpret the bits\n+            // treating the highest bit of Disr as a sign-bit, so\n+            // cast to i64 before range-checking.\n+            SignedInt(ast::TyI8)    => add1!((val as i64).to_i8()),\n+            SignedInt(ast::TyI16)   => add1!((val as i64).to_i16()),\n+            SignedInt(ast::TyI32)   => add1!((val as i64).to_i32()),\n+            SignedInt(ast::TyI64)   => add1!(Some(val as i64)),\n+\n+            UnsignedInt(ast::TyU8)  => add1!(val.to_u8()),\n+            UnsignedInt(ast::TyU16) => add1!(val.to_u16()),\n+            UnsignedInt(ast::TyU32) => add1!(val.to_u32()),\n+            UnsignedInt(ast::TyU64) => add1!(Some(val)),\n+\n+            UnsignedInt(ast::TyUs) |\n+            SignedInt(ast::TyIs) => unreachable!(),\n+        }\n+    }\n+\n+    // This returns a String because (1.) it is only used for\n+    // rendering an error message and (2.) a string can represent the\n+    // full range from `i64::MIN` through `u64::MAX`.\n+    fn disr_string(&self, val: Disr) -> String {\n+        match *self {\n+            SignedInt(ast::TyI8)    => format!(\"{}\", val as i8 ),\n+            SignedInt(ast::TyI16)   => format!(\"{}\", val as i16),\n+            SignedInt(ast::TyI32)   => format!(\"{}\", val as i32),\n+            SignedInt(ast::TyI64)   => format!(\"{}\", val as i64),\n+            UnsignedInt(ast::TyU8)  => format!(\"{}\", val as u8 ),\n+            UnsignedInt(ast::TyU16) => format!(\"{}\", val as u16),\n+            UnsignedInt(ast::TyU32) => format!(\"{}\", val as u32),\n+            UnsignedInt(ast::TyU64) => format!(\"{}\", val as u64),\n+\n+            UnsignedInt(ast::TyUs) |\n+            SignedInt(ast::TyIs) => unreachable!(),\n+        }\n+    }\n+\n+    fn disr_wrap_incr(&self, val: Option<Disr>) -> Disr {\n+        macro_rules! add1 {\n+            ($e:expr) => { ($e).wrapping_add(1) as Disr }\n+        }\n+        let val = val.unwrap_or(ty::INITIAL_DISCRIMINANT_VALUE);\n+        match *self {\n+            SignedInt(ast::TyI8)    => add1!(val as i8 ),\n+            SignedInt(ast::TyI16)   => add1!(val as i16),\n+            SignedInt(ast::TyI32)   => add1!(val as i32),\n+            SignedInt(ast::TyI64)   => add1!(val as i64),\n+            UnsignedInt(ast::TyU8)  => add1!(val as u8 ),\n+            UnsignedInt(ast::TyU16) => add1!(val as u16),\n+            UnsignedInt(ast::TyU32) => add1!(val as u32),\n+            UnsignedInt(ast::TyU64) => add1!(val as u64),\n+\n+            UnsignedInt(ast::TyUs) |\n+            SignedInt(ast::TyIs) => unreachable!(),\n+        }\n+    }\n+}\n+\n+/// Returns `(normalized_type, ty)`, where `normalized_type` is the\n+/// IntType representation of one of {i64,i32,i16,i8,u64,u32,u16,u8},\n+/// and `ty` is the original type (i.e. may include `isize` or\n+/// `usize`).\n+pub fn enum_repr_type<'tcx>(cx: &ctxt<'tcx>,\n+                            opt_hint: Option<&attr::ReprAttr>)\n+                            -> (attr::IntType, Ty<'tcx>)\n+{\n+    let repr_type = match opt_hint {\n+        // Feed in the given type\n+        Some(&attr::ReprInt(_, int_t)) => int_t,\n+        // ... but provide sensible default if none provided\n+        //\n+        // NB. Historically `fn enum_variants` generate i64 here, while\n+        // rustc_typeck::check would generate isize.\n+        _ => SignedInt(ast::TyIs),\n+    };\n+\n+    let repr_type_ty = repr_type.to_ty(cx);\n+    let repr_type = match repr_type {\n+        SignedInt(ast::TyIs) =>\n+            SignedInt(cx.sess.target.int_type),\n+        UnsignedInt(ast::TyUs) =>\n+            UnsignedInt(cx.sess.target.uint_type),\n+        other => other\n+    };\n+\n+    (repr_type, repr_type_ty)\n+}\n+\n+fn report_discrim_overflow(cx: &ctxt,\n+                           variant_span: Span,\n+                           variant_name: &str,\n+                           repr_type: attr::IntType,\n+                           prev_val: Disr) {\n+    let computed_value = repr_type.disr_wrap_incr(Some(prev_val));\n+    let computed_value = repr_type.disr_string(computed_value);\n+    let prev_val = repr_type.disr_string(prev_val);\n+    let repr_type = repr_type.to_ty(cx).user_string(cx);\n+    span_err!(cx.sess, variant_span, E0370,\n+              \"enum discriminant overflowed on value after {}: {}; \\\n+               set explicitly via {} = {} if that is desired outcome\",\n+              prev_val, repr_type, variant_name, computed_value);\n+}\n+\n+// This computes the discriminant values for the sequence of Variants\n+// attached to a particular enum, taking into account the #[repr] (if\n+// any) provided via the `opt_hint`.\n+fn compute_enum_variants<'tcx>(cx: &ctxt<'tcx>,\n+                               vs: &'tcx [P<ast::Variant>],\n+                               opt_hint: Option<&attr::ReprAttr>)\n+                               -> Vec<Rc<ty::VariantInfo<'tcx>>> {\n+    let mut variants: Vec<Rc<ty::VariantInfo>> = Vec::new();\n+    let mut prev_disr_val: Option<ty::Disr> = None;\n+\n+    let (repr_type, repr_type_ty) = ty::enum_repr_type(cx, opt_hint);\n+\n+    for v in vs {\n+        // If the discriminant value is specified explicitly in the\n+        // enum, check whether the initialization expression is valid,\n+        // otherwise use the last value plus one.\n+        let current_disr_val;\n+\n+        // This closure marks cases where, when an error occurs during\n+        // the computation, attempt to assign a (hopefully) fresh\n+        // value to avoid spurious error reports downstream.\n+        let attempt_fresh_value = move || -> Disr {\n+            repr_type.disr_wrap_incr(prev_disr_val)\n+        };\n+\n+        match v.node.disr_expr {\n+            Some(ref e) => {\n+                debug!(\"disr expr, checking {}\", pprust::expr_to_string(&**e));\n+\n+                // check_expr (from check_const pass) doesn't guarantee\n+                // that the expression is in a form that eval_const_expr can\n+                // handle, so we may still get an internal compiler error\n+                //\n+                // pnkfelix: The above comment was transcribed from\n+                // the version of this code taken from rustc_typeck.\n+                // Presumably the implication is that we need to deal\n+                // with such ICE's as they arise.\n+                //\n+                // Since this can be called from `ty::enum_variants`\n+                // anyway, best thing is to make `eval_const_expr`\n+                // more robust (on case-by-case basis).\n+\n+                match const_eval::eval_const_expr_partial(cx, &**e, Some(repr_type_ty)) {\n+                    Ok(const_eval::const_int(val)) => current_disr_val = val as Disr,\n+                    Ok(const_eval::const_uint(val)) => current_disr_val = val as Disr,\n+                    Ok(_) => {\n+                        span_err!(cx.sess, e.span, E0079,\n+                                  \"expected signed integer constant\");\n+                        current_disr_val = attempt_fresh_value();\n+                    }\n+                    Err(ref err) => {\n+                        span_err!(cx.sess, err.span, E0080,\n+                                  \"constant evaluation error: {}\",\n+                                  err.description());\n+                        current_disr_val = attempt_fresh_value();\n+                    }\n+                }\n+            },\n+            None => {\n+                current_disr_val = match prev_disr_val {\n+                    Some(prev_disr_val) => {\n+                        if let Some(v) = repr_type.disr_incr(prev_disr_val) {\n+                            v\n+                        } else {\n+                            report_discrim_overflow(cx, v.span, v.node.name.as_str(),\n+                                                    repr_type, prev_disr_val);\n+                            attempt_fresh_value()\n+                        }\n+                    }\n+                    None => ty::INITIAL_DISCRIMINANT_VALUE\n+                }\n+            }\n+        }\n+\n+        let variant_info = Rc::new(VariantInfo::from_ast_variant(cx, &**v, current_disr_val));\n+        prev_disr_val = Some(current_disr_val);\n+\n+        variants.push(variant_info);\n+    }\n+\n+    return variants;\n+}\n+\n pub fn enum_variants<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                            -> Rc<Vec<Rc<VariantInfo<'tcx>>>> {\n     memoized(&cx.enum_var_cache, id, |id: ast::DefId| {\n         if ast::LOCAL_CRATE != id.krate {\n             Rc::new(csearch::get_enum_variants(cx, id))\n         } else {\n-            /*\n-              Although both this code and check_enum_variants in typeck/check\n-              call eval_const_expr, it should never get called twice for the same\n-              expr, since check_enum_variants also updates the enum_var_cache\n-             */\n             match cx.map.get(id.node) {\n                 ast_map::NodeItem(ref item) => {\n                     match item.node {\n                         ast::ItemEnum(ref enum_definition, _) => {\n-                            let mut last_discriminant: Option<Disr> = None;\n-                            Rc::new(enum_definition.variants.iter().map(|variant| {\n-\n-                                let mut discriminant = INITIAL_DISCRIMINANT_VALUE;\n-                                if let Some(ref e) = variant.node.disr_expr {\n-                                    // Preserve all values, and prefer signed.\n-                                    let ty = Some(cx.types.i64);\n-                                    match const_eval::eval_const_expr_partial(cx, &**e, ty) {\n-                                        Ok(const_eval::const_int(val)) => {\n-                                            discriminant = val as Disr;\n-                                        }\n-                                        Ok(const_eval::const_uint(val)) => {\n-                                            discriminant = val as Disr;\n-                                        }\n-                                        Ok(_) => {\n-                                            span_err!(cx.sess, e.span, E0304,\n-                                                      \"expected signed integer constant\");\n-                                        }\n-                                        Err(err) => {\n-                                            span_err!(cx.sess, err.span, E0305,\n-                                                      \"constant evaluation error: {}\",\n-                                                      err.description());\n-                                        }\n-                                    }\n-                                } else {\n-                                    if let Some(val) = last_discriminant {\n-                                        if let Some(v) = val.checked_add(1) {\n-                                            discriminant = v\n-                                        } else {\n-                                            cx.sess.span_err(\n-                                                variant.span,\n-                                                &format!(\"Discriminant overflowed!\"));\n-                                        }\n-                                    } else {\n-                                        discriminant = INITIAL_DISCRIMINANT_VALUE;\n-                                    }\n-                                }\n-\n-                                last_discriminant = Some(discriminant);\n-                                Rc::new(VariantInfo::from_ast_variant(cx, &**variant,\n-                                                                      discriminant))\n-                            }).collect())\n+                            Rc::new(compute_enum_variants(\n+                                cx,\n+                                &enum_definition.variants,\n+                                lookup_repr_hints(cx, id).get(0)))\n                         }\n                         _ => {\n                             cx.sess.bug(\"enum_variants: id not bound to an enum\")"}, {"sha": "fbff4e84788822d06dbf54cc62e3b6cd2c862e5b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 18, "deletions": 67, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/4e04d57efa665ae62a2af4c2d785809f15c17599/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e04d57efa665ae62a2af4c2d785809f15c17599/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4e04d57efa665ae62a2af4c2d785809f15c17599", "patch": "@@ -85,7 +85,7 @@ use astconv::{self, ast_region_to_region, ast_ty_to_ty, AstConv, PathParamMode};\n use check::_match::pat_ctxt;\n use fmt_macros::{Parser, Piece, Position};\n use middle::astconv_util::{check_path_args, NO_TPS, NO_REGIONS};\n-use middle::{const_eval, def};\n+use middle::def;\n use middle::infer;\n use middle::mem_categorization as mc;\n use middle::mem_categorization::McResult;\n@@ -94,7 +94,7 @@ use middle::privacy::{AllPublic, LastMod};\n use middle::region::{self, CodeExtent};\n use middle::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace, TypeSpace};\n use middle::traits;\n-use middle::ty::{FnSig, GenericPredicates, VariantInfo, TypeScheme};\n+use middle::ty::{FnSig, GenericPredicates, TypeScheme};\n use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n use middle::ty::{self, HasProjectionTypes, RegionEscape, ToPolyTraitRef, Ty};\n use middle::ty::liberate_late_bound_regions;\n@@ -4283,68 +4283,30 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     fn do_check<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                           vs: &'tcx [P<ast::Variant>],\n                           id: ast::NodeId,\n-                          hint: attr::ReprAttr)\n-                          -> Vec<Rc<ty::VariantInfo<'tcx>>> {\n+                          hint: attr::ReprAttr) {\n         #![allow(trivial_numeric_casts)]\n \n         let rty = ty::node_id_to_type(ccx.tcx, id);\n-        let mut variants: Vec<Rc<ty::VariantInfo>> = Vec::new();\n         let mut disr_vals: Vec<ty::Disr> = Vec::new();\n-        let mut prev_disr_val: Option<ty::Disr> = None;\n \n-        for v in vs {\n+        let inh = static_inherited_fields(ccx);\n+        let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(rty), id);\n \n-            // If the discriminant value is specified explicitly in the enum check whether the\n-            // initialization expression is valid, otherwise use the last value plus one.\n-            let mut current_disr_val = match prev_disr_val {\n-                Some(prev_disr_val) => {\n-                    if let Some(v) = prev_disr_val.checked_add(1) {\n-                        v\n-                    } else {\n-                        ty::INITIAL_DISCRIMINANT_VALUE\n-                    }\n-                }\n-                None => ty::INITIAL_DISCRIMINANT_VALUE\n-            };\n+        let (_, repr_type_ty) = ty::enum_repr_type(ccx.tcx, Some(&hint));\n+        for v in vs {\n+            if let Some(ref e) = v.node.disr_expr {\n+                check_const_with_ty(&fcx, e.span, e, repr_type_ty);\n+            }\n+        }\n \n-            match v.node.disr_expr {\n-                Some(ref e) => {\n-                    debug!(\"disr expr, checking {}\", pprust::expr_to_string(&**e));\n+        let def_id = local_def(id);\n \n-                    let inh = static_inherited_fields(ccx);\n-                    let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(rty), e.id);\n-                    let declty = match hint {\n-                        attr::ReprAny | attr::ReprPacked |\n-                        attr::ReprExtern => fcx.tcx().types.isize,\n+        // ty::enum_variants guards against discriminant overflows, so\n+        // we need not check for that.\n+        let variants = ty::enum_variants(ccx.tcx, def_id);\n \n-                        attr::ReprInt(_, attr::SignedInt(ity)) => {\n-                            ty::mk_mach_int(fcx.tcx(), ity)\n-                        }\n-                        attr::ReprInt(_, attr::UnsignedInt(ity)) => {\n-                            ty::mk_mach_uint(fcx.tcx(), ity)\n-                        },\n-                    };\n-                    check_const_with_ty(&fcx, e.span, &**e, declty);\n-                    // check_expr (from check_const pass) doesn't guarantee\n-                    // that the expression is in a form that eval_const_expr can\n-                    // handle, so we may still get an internal compiler error\n-\n-                    match const_eval::eval_const_expr_partial(ccx.tcx, &**e, Some(declty)) {\n-                        Ok(const_eval::const_int(val)) => current_disr_val = val as Disr,\n-                        Ok(const_eval::const_uint(val)) => current_disr_val = val as Disr,\n-                        Ok(_) => {\n-                            span_err!(ccx.tcx.sess, e.span, E0079,\n-                                \"expected signed integer constant\");\n-                        }\n-                        Err(ref err) => {\n-                            span_err!(ccx.tcx.sess, err.span, E0080,\n-                                      \"constant evaluation error: {}\",\n-                                      err.description());\n-                        }\n-                    }\n-                },\n-                None => ()\n-            };\n+        for (v, variant) in vs.iter().zip(variants.iter()) {\n+            let current_disr_val = variant.disr_val;\n \n             // Check for duplicate discriminant values\n             match disr_vals.iter().position(|&x| x == current_disr_val) {\n@@ -4372,15 +4334,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                 }\n             }\n             disr_vals.push(current_disr_val);\n-\n-            let variant_info = Rc::new(VariantInfo::from_ast_variant(ccx.tcx, &**v,\n-                                                                     current_disr_val));\n-            prev_disr_val = Some(current_disr_val);\n-\n-            variants.push(variant_info);\n         }\n-\n-        return variants;\n     }\n \n     let hint = *ty::lookup_repr_hints(ccx.tcx, ast::DefId { krate: ast::LOCAL_CRATE, node: id })\n@@ -4396,10 +4350,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         };\n     }\n \n-    let variants = do_check(ccx, vs, id, hint);\n-\n-    // cache so that ty::enum_variants won't repeat this work\n-    ccx.tcx.enum_var_cache.borrow_mut().insert(local_def(id), Rc::new(variants));\n+    do_check(ccx, vs, id, hint);\n \n     check_representable(ccx.tcx, sp, id, \"enum\");\n "}, {"sha": "a8d93c8bd111a054b8a49bfc9f97c3de14913fd8", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e04d57efa665ae62a2af4c2d785809f15c17599/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e04d57efa665ae62a2af4c2d785809f15c17599/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=4e04d57efa665ae62a2af4c2d785809f15c17599", "patch": "@@ -51,8 +51,6 @@ register_diagnostics! {\n     E0075,\n     E0076,\n     E0077,\n-    E0079,\n-    E0080,\n     E0081,\n     E0082,\n     E0083,"}]}