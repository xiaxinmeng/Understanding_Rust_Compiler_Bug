{"sha": "d9190da9825b729ce63becf727b2cfdad3e8561a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5MTkwZGE5ODI1YjcyOWNlNjNiZWNmNzI3YjJjZmRhZDNlODU2MWE=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-05-14T17:27:13Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-05-15T13:22:11Z"}, "message": "Refactor Substs methods on generic parameters", "tree": {"sha": "1bffa6455bfc02acbcd9963f47823469d8e22987", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1bffa6455bfc02acbcd9963f47823469d8e22987"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9190da9825b729ce63becf727b2cfdad3e8561a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9190da9825b729ce63becf727b2cfdad3e8561a", "html_url": "https://github.com/rust-lang/rust/commit/d9190da9825b729ce63becf727b2cfdad3e8561a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9190da9825b729ce63becf727b2cfdad3e8561a/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "030f10f752b6584e4f1974c104dd644dfffd80ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/030f10f752b6584e4f1974c104dd644dfffd80ad", "html_url": "https://github.com/rust-lang/rust/commit/030f10f752b6584e4f1974c104dd644dfffd80ad"}], "stats": {"total": 699, "additions": 393, "deletions": 306}, "files": [{"sha": "d90ba51fffc263f9b87ee4654cd9e5ce471fde79", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d9190da9825b729ce63becf727b2cfdad3e8561a/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9190da9825b729ce63becf727b2cfdad3e8561a/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=d9190da9825b729ce63becf727b2cfdad3e8561a", "patch": "@@ -21,9 +21,9 @@ use hir::def_id::DefId;\n use middle::free_region::RegionRelations;\n use middle::region;\n use middle::lang_items;\n-use ty::subst::Substs;\n+use ty::subst::{UnpackedKind, Substs};\n use ty::{TyVid, IntVid, FloatVid};\n-use ty::{self, Ty, TyCtxt};\n+use ty::{self, Ty, TyCtxt, GenericParamDefKind};\n use ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n use ty::fold::TypeFoldable;\n use ty::relate::RelateResult;\n@@ -941,10 +941,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                  span: Span,\n                                  def_id: DefId)\n                                  -> &'tcx Substs<'tcx> {\n-        Substs::for_item(self.tcx, def_id, |def, _| {\n-            self.region_var_for_def(span, def)\n-        }, |def, _| {\n-            self.type_var_for_def(span, def)\n+        Substs::for_item(self.tcx, def_id, |param, _| {\n+            match param.kind {\n+                GenericParamDefKind::Lifetime => {\n+                    UnpackedKind::Lifetime(self.region_var_for_def(span, param))\n+                }\n+                GenericParamDefKind::Type(_) => {\n+                    UnpackedKind::Type(self.type_var_for_def(span, param))\n+                }\n+            }\n         })\n     }\n "}, {"sha": "4b5c767b0314549caee2ea9fe528f8efec0aa087", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d9190da9825b729ce63becf727b2cfdad3e8561a/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9190da9825b729ce63becf727b2cfdad3e8561a/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=d9190da9825b729ce63becf727b2cfdad3e8561a", "patch": "@@ -22,8 +22,8 @@ use hir::def_id::DefId;\n use infer::outlives::env::OutlivesEnvironment;\n use middle::region;\n use middle::const_val::ConstEvalErr;\n-use ty::subst::Substs;\n-use ty::{self, AdtKind, Slice, Ty, TyCtxt, TypeFoldable, ToPredicate};\n+use ty::subst::{UnpackedKind, Substs};\n+use ty::{self, AdtKind, Slice, Ty, TyCtxt, GenericParamDefKind, TypeFoldable, ToPredicate};\n use ty::error::{ExpectedFound, TypeError};\n use infer::{InferCtxt};\n \n@@ -841,10 +841,16 @@ fn vtable_methods<'a, 'tcx>(\n                 // the method may have some early-bound lifetimes, add\n                 // regions for those\n                 let substs = trait_ref.map_bound(|trait_ref| {\n-                    Substs::for_item(\n-                        tcx, def_id,\n-                        |_, _| tcx.types.re_erased,\n-                        |def, _| trait_ref.substs.type_for_def(def))\n+                    Substs::for_item(tcx, def_id, |param, _| {\n+                        match param.kind {\n+                            GenericParamDefKind::Lifetime => {\n+                                UnpackedKind::Lifetime(tcx.types.re_erased)\n+                            }\n+                            GenericParamDefKind::Type(_) => {\n+                                UnpackedKind::Type(trait_ref.substs.type_for_def(param))\n+                            }\n+                        }\n+                    })\n                 });\n \n                 // the trait type may have higher-ranked lifetimes in it;"}, {"sha": "924271ea3d474a379cd406846d5f4d63996d5c39", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d9190da9825b729ce63becf727b2cfdad3e8561a/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9190da9825b729ce63becf727b2cfdad3e8561a/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=d9190da9825b729ce63becf727b2cfdad3e8561a", "patch": "@@ -32,7 +32,7 @@ use middle::lang_items;\n use middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n use middle::stability;\n use mir::{self, Mir, interpret};\n-use ty::subst::{Kind, Substs, Subst};\n+use ty::subst::{Kind, UnpackedKind, Substs, Subst};\n use ty::ReprOptions;\n use ty::Instance;\n use traits;\n@@ -44,6 +44,7 @@ use ty::{PolyFnSig, InferTy, ParamTy, ProjectionTy, ExistentialPredicate, Predic\n use ty::RegionKind;\n use ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n use ty::TypeVariants::*;\n+use ty::GenericParamDefKind;\n use ty::layout::{LayoutDetails, TargetDataLayout};\n use ty::maps;\n use ty::steal::Steal;\n@@ -2325,16 +2326,22 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn mk_box(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         let def_id = self.require_lang_item(lang_items::OwnedBoxLangItem);\n         let adt_def = self.adt_def(def_id);\n-        let substs = Substs::for_item(self, def_id, |_, _| bug!(), |def, substs| {\n-            if def.index == 0 {\n-                ty\n-            } else {\n-                match def.kind {\n-                    ty::GenericParamDefKind::Type(ty_param) => {\n-                        assert!(ty_param.has_default);\n-                        self.type_of(def.def_id).subst(self, substs)\n+        let substs = Substs::for_item(self, def_id, |param, substs| {\n+            match param.kind {\n+                GenericParamDefKind::Lifetime => bug!(),\n+                GenericParamDefKind::Type(_) => {\n+                    if param.index == 0 {\n+                        UnpackedKind::Type(ty)\n+                    } else {\n+                        match param.kind {\n+                            ty::GenericParamDefKind::Type(ty_param) => {\n+                                assert!(ty_param.has_default);\n+                                UnpackedKind::Type(\n+                                    self.type_of(param.def_id).subst(self, substs))\n+                            }\n+                            _ => unreachable!()\n+                        }\n                     }\n-                    _ => unreachable!()\n                 }\n             }\n         });"}, {"sha": "5c2b5c5cd45576d62f79db99db12f18f59569aef", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/d9190da9825b729ce63becf727b2cfdad3e8561a/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9190da9825b729ce63becf727b2cfdad3e8561a/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=d9190da9825b729ce63becf727b2cfdad3e8561a", "patch": "@@ -11,7 +11,7 @@\n // Type substitutions.\n \n use hir::def_id::DefId;\n-use ty::{self, Lift, Slice, Region, Ty, TyCtxt};\n+use ty::{self, Lift, Slice, Region, Ty, TyCtxt, GenericParamDefKind};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n use serialize::{self, Encodable, Encoder, Decodable, Decoder};\n@@ -174,80 +174,80 @@ impl<'tcx> Decodable for Kind<'tcx> {\n     }\n }\n \n-/// A substitution mapping type/region parameters to new values.\n+/// A substitution mapping generic parameters to new values.\n pub type Substs<'tcx> = Slice<Kind<'tcx>>;\n \n impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     /// Creates a Substs that maps each generic parameter to itself.\n     pub fn identity_for_item(tcx: TyCtxt<'a, 'gcx, 'tcx>, def_id: DefId)\n                              -> &'tcx Substs<'tcx> {\n-        Substs::for_item(tcx, def_id, |def, _| {\n-            tcx.mk_region(ty::ReEarlyBound(def.to_early_bound_region_data()))\n-        }, |def, _| tcx.mk_ty_param_from_def(def))\n+        Substs::for_item(tcx, def_id, |param, _| {\n+            match param.kind {\n+                GenericParamDefKind::Lifetime => {\n+                    UnpackedKind::Lifetime(\n+                        tcx.mk_region(ty::ReEarlyBound(param.to_early_bound_region_data())))\n+                }\n+                GenericParamDefKind::Type(_) => {\n+                    UnpackedKind::Type(tcx.mk_ty_param_from_def(param))\n+                }\n+            }\n+        })\n     }\n \n     /// Creates a Substs for generic parameter definitions,\n-    /// by calling closures to obtain each region and type.\n+    /// by calling closures to obtain each kind.\n     /// The closures get to observe the Substs as they're\n     /// being built, which can be used to correctly\n-    /// substitute defaults of type parameters.\n-    pub fn for_item<FR, FT>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                            def_id: DefId,\n-                            mut mk_region: FR,\n-                            mut mk_type: FT)\n-                            -> &'tcx Substs<'tcx>\n-    where FR: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> ty::Region<'tcx>,\n-          FT: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> Ty<'tcx> {\n+    /// substitute defaults of generic parameters.\n+    pub fn for_item<F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                       def_id: DefId,\n+                       mut mk_kind: F)\n+                       -> &'tcx Substs<'tcx>\n+    where F: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> UnpackedKind<'tcx>\n+    {\n         let defs = tcx.generics_of(def_id);\n         let mut substs = Vec::with_capacity(defs.count());\n-        Substs::fill_item(&mut substs, tcx, defs, &mut mk_region, &mut mk_type);\n+        Substs::fill_item(&mut substs, tcx, defs, &mut mk_kind);\n         tcx.intern_substs(&substs)\n     }\n \n-    pub fn extend_to<FR, FT>(&self,\n-                             tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                             def_id: DefId,\n-                             mut mk_region: FR,\n-                             mut mk_type: FT)\n-                             -> &'tcx Substs<'tcx>\n-    where FR: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> ty::Region<'tcx>,\n-          FT: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> Ty<'tcx>\n+    pub fn extend_to<F>(&self,\n+                        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                        def_id: DefId,\n+                        mut mk_kind: F)\n+                        -> &'tcx Substs<'tcx>\n+    where F: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> UnpackedKind<'tcx>\n     {\n         let defs = tcx.generics_of(def_id);\n         let mut result = Vec::with_capacity(defs.count());\n         result.extend(self[..].iter().cloned());\n-        Substs::fill_single(&mut result, defs, &mut mk_region, &mut mk_type);\n+        Substs::fill_single(&mut result, defs, &mut mk_kind);\n         tcx.intern_substs(&result)\n     }\n \n-    pub fn fill_item<FR, FT>(substs: &mut Vec<Kind<'tcx>>,\n+    pub fn fill_item<F>(substs: &mut Vec<Kind<'tcx>>,\n                              tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                              defs: &ty::Generics,\n-                             mk_region: &mut FR,\n-                             mk_type: &mut FT)\n-    where FR: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> ty::Region<'tcx>,\n-          FT: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> Ty<'tcx> {\n+                             mk_kind: &mut F)\n+    where F: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> UnpackedKind<'tcx>\n+    {\n \n         if let Some(def_id) = defs.parent {\n             let parent_defs = tcx.generics_of(def_id);\n-            Substs::fill_item(substs, tcx, parent_defs, mk_region, mk_type);\n+            Substs::fill_item(substs, tcx, parent_defs, mk_kind);\n         }\n-        Substs::fill_single(substs, defs, mk_region, mk_type)\n+        Substs::fill_single(substs, defs, mk_kind)\n     }\n \n-    fn fill_single<FR, FT>(substs: &mut Vec<Kind<'tcx>>,\n+    fn fill_single<F>(substs: &mut Vec<Kind<'tcx>>,\n                            defs: &ty::Generics,\n-                           mk_region: &mut FR,\n-                           mk_type: &mut FT)\n-    where FR: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> ty::Region<'tcx>,\n-          FT: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> Ty<'tcx> {\n+                           mk_kind: &mut F)\n+    where F: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> UnpackedKind<'tcx>\n+    {\n         for param in &defs.params {\n-            let kind = match param.kind {\n-                ty::GenericParamDefKind::Lifetime => mk_region(param, substs).into(),\n-                ty::GenericParamDefKind::Type(_) => mk_type(param, substs).into(),\n-            };\n+            let kind = mk_kind(param, substs);\n             assert_eq!(param.index as usize, substs.len());\n-            substs.push(kind);\n+            substs.push(kind.pack());\n         }\n     }\n "}, {"sha": "91280e5b8a3fdfee8d98d378c8282cba44fb49f3", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d9190da9825b729ce63becf727b2cfdad3e8561a/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9190da9825b729ce63becf727b2cfdad3e8561a/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=d9190da9825b729ce63becf727b2cfdad3e8561a", "patch": "@@ -17,9 +17,9 @@ use hir;\n use ich::NodeIdHashingMode;\n use middle::const_val::ConstVal;\n use traits::{self, ObligationCause};\n-use ty::{self, Ty, TyCtxt, TypeFoldable};\n+use ty::{self, Ty, TyCtxt, GenericParamDefKind, TypeFoldable};\n use ty::fold::TypeVisitor;\n-use ty::subst::UnpackedKind;\n+use ty::subst::{Substs, UnpackedKind};\n use ty::maps::TyCtxtAt;\n use ty::TypeVariants::*;\n use ty::layout::{Integer, IntegerExt};\n@@ -573,11 +573,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     /// Given the def-id of some item that has no type parameters, make\n     /// a suitable \"empty substs\" for it.\n-    pub fn empty_substs_for_def_id(self, item_def_id: DefId) -> &'tcx ty::Substs<'tcx> {\n-        ty::Substs::for_item(self, item_def_id,\n-                             |_, _| self.types.re_erased,\n-                             |_, _| {\n-            bug!(\"empty_substs_for_def_id: {:?} has type parameters\", item_def_id)\n+    pub fn empty_substs_for_def_id(self, item_def_id: DefId) -> &'tcx Substs<'tcx> {\n+        Substs::for_item(self, item_def_id, |param, _| {\n+            match param.kind {\n+                GenericParamDefKind::Lifetime => UnpackedKind::Lifetime(self.types.re_erased),\n+                GenericParamDefKind::Type(_) => {\n+                    bug!(\"empty_substs_for_def_id: {:?} has type parameters\", item_def_id)\n+                }\n+            }\n         })\n     }\n "}, {"sha": "c8d4ccaf0bbb2b18e8e93f61a4ed918a39919a32", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d9190da9825b729ce63becf727b2cfdad3e8561a/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9190da9825b729ce63becf727b2cfdad3e8561a/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=d9190da9825b729ce63becf727b2cfdad3e8561a", "patch": "@@ -196,8 +196,8 @@ use rustc::hir::def_id::DefId;\n use rustc::middle::const_val::ConstVal;\n use rustc::mir::interpret::{AllocId, ConstValue};\n use rustc::middle::lang_items::{ExchangeMallocFnLangItem, StartFnLangItem};\n-use rustc::ty::subst::{Substs, Kind};\n-use rustc::ty::{self, TypeFoldable, Ty, TyCtxt};\n+use rustc::ty::subst::{Substs, Kind, UnpackedKind};\n+use rustc::ty::{self, TypeFoldable, Ty, TyCtxt, GenericParamDefKind};\n use rustc::ty::adjustment::CustomCoerceUnsized;\n use rustc::session::config;\n use rustc::mir::{self, Location, Promoted};\n@@ -1112,10 +1112,16 @@ fn create_mono_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         continue;\n                     }\n \n-                    let substs = Substs::for_item(tcx,\n-                                                  method.def_id,\n-                                                  |_, _| tcx.types.re_erased,\n-                                                  |def, _| trait_ref.substs.type_for_def(def));\n+                    let substs = Substs::for_item(tcx, method.def_id, |param, _| {\n+                        match param.kind {\n+                            GenericParamDefKind::Lifetime => {\n+                                UnpackedKind::Lifetime(tcx.types.re_erased)\n+                            }\n+                            GenericParamDefKind::Type(_) => {\n+                                UnpackedKind::Type(trait_ref.substs.type_for_def(param))\n+                            }\n+                        }\n+                    });\n \n                     let instance = ty::Instance::resolve(tcx,\n                                                          ty::ParamEnv::reveal_all(),"}, {"sha": "8596d546b09a247c2db7aab3d17f5744b289dbeb", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d9190da9825b729ce63becf727b2cfdad3e8561a/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9190da9825b729ce63becf727b2cfdad3e8561a/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=d9190da9825b729ce63becf727b2cfdad3e8561a", "patch": "@@ -12,8 +12,8 @@ use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::infer;\n use rustc::mir::*;\n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::subst::{Kind, Subst, Substs};\n+use rustc::ty::{self, Ty, TyCtxt, GenericParamDefKind};\n+use rustc::ty::subst::{Kind, UnpackedKind, Subst, Substs};\n use rustc::ty::maps::Providers;\n \n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n@@ -427,12 +427,12 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n     ) {\n         let tcx = self.tcx;\n \n-        let substs = Substs::for_item(\n-            tcx,\n-            self.def_id,\n-            |_, _| tcx.types.re_erased,\n-            |_, _| ty\n-        );\n+        let substs = Substs::for_item(tcx, self.def_id, |param, _| {\n+            match param.kind {\n+                GenericParamDefKind::Lifetime => UnpackedKind::Lifetime(tcx.types.re_erased),\n+                GenericParamDefKind::Type(_) => UnpackedKind::Type(ty),\n+            }\n+        });\n \n         // `func == Clone::clone(&ty) -> ty`\n         let func_ty = tcx.mk_fn_def(self.def_id, substs);"}, {"sha": "f60c78702b6f3744381655cbae4a3426a2edd46f", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 80, "deletions": 64, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/d9190da9825b729ce63becf727b2cfdad3e8561a/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9190da9825b729ce63becf727b2cfdad3e8561a/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=d9190da9825b729ce63becf727b2cfdad3e8561a", "patch": "@@ -20,7 +20,8 @@ use middle::resolve_lifetime as rl;\n use namespace::Namespace;\n use rustc::ty::subst::{Kind, UnpackedKind, Subst, Substs};\n use rustc::traits;\n-use rustc::ty::{self, RegionKind, Ty, TyCtxt, GenericParamDefKind, ToPredicate, TypeFoldable};\n+use rustc::ty::{self, RegionKind, Ty, TyCtxt, ToPredicate, TypeFoldable};\n+use rustc::ty::GenericParamDefKind;\n use rustc::ty::wf::object_region_bounds;\n use rustc_target::spec::abi;\n use std::slice;\n@@ -264,66 +265,76 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         };\n \n         let own_self = self_ty.is_some() as usize;\n-        let substs = Substs::for_item(tcx, def_id, |def, _| {\n-            let i = def.index as usize - own_self;\n-            if let Some(lifetime) = parameters.lifetimes.get(i) {\n-                self.ast_region_to_region(lifetime, Some(def))\n-            } else {\n-                tcx.types.re_static\n-            }\n-        }, |def, substs| {\n-            let i = def.index as usize;\n-\n-            // Handle Self first, so we can adjust the index to match the AST.\n-            if let (0, Some(ty)) = (i, self_ty) {\n-                return ty;\n-            }\n+        let substs = Substs::for_item(tcx, def_id, |param, substs| {\n+            match param.kind {\n+                GenericParamDefKind::Lifetime => {\n+                    let i = param.index as usize - own_self;\n+                    let lt = if let Some(lifetime) = parameters.lifetimes.get(i) {\n+                        self.ast_region_to_region(lifetime, Some(param))\n+                    } else {\n+                        tcx.types.re_static\n+                    };\n+                    UnpackedKind::Lifetime(lt)\n+                }\n+                GenericParamDefKind::Type(_) => {\n+                    let i = param.index as usize;\n \n-            let has_default = match def.kind {\n-                GenericParamDefKind::Type(ty) => ty.has_default,\n-                _ => unreachable!()\n-            };\n+                    // Handle Self first, so we can adjust the index to match the AST.\n+                    if let (0, Some(ty)) = (i, self_ty) {\n+                        return UnpackedKind::Type(ty);\n+                    }\n \n-            let i = i - (lt_accepted + own_self);\n-            if i < ty_provided {\n-                // A provided type parameter.\n-                self.ast_ty_to_ty(&parameters.types[i])\n-            } else if infer_types {\n-                // No type parameters were provided, we can infer all.\n-                let ty_var = if !default_needs_object_self(def) {\n-                    self.ty_infer_for_def(def, span)\n-                } else {\n-                    self.ty_infer(span)\n-                };\n-                ty_var\n-            } else if has_default {\n-                // No type parameter provided, but a default exists.\n-\n-                // If we are converting an object type, then the\n-                // `Self` parameter is unknown. However, some of the\n-                // other type parameters may reference `Self` in their\n-                // defaults. This will lead to an ICE if we are not\n-                // careful!\n-                if default_needs_object_self(def) {\n-                    struct_span_err!(tcx.sess, span, E0393,\n-                                     \"the type parameter `{}` must be explicitly specified\",\n-                                     def.name)\n-                        .span_label(span, format!(\"missing reference to `{}`\", def.name))\n-                        .note(&format!(\"because of the default `Self` reference, \\\n-                                        type parameters must be specified on object types\"))\n-                        .emit();\n-                    tcx.types.err\n-                } else {\n-                    // This is a default type parameter.\n-                    self.normalize_ty(\n-                        span,\n-                        tcx.at(span).type_of(def.def_id)\n-                            .subst_spanned(tcx, substs, Some(span))\n-                    )\n+                    let has_default = match param.kind {\n+                        GenericParamDefKind::Type(ty) => ty.has_default,\n+                        _ => unreachable!()\n+                    };\n+\n+                    let i = i - (lt_accepted + own_self);\n+                    let ty = if i < ty_provided {\n+                        // A provided type parameter.\n+                        self.ast_ty_to_ty(&parameters.types[i])\n+                    } else if infer_types {\n+                        // No type parameters were provided, we can infer all.\n+                        let ty_var = if !default_needs_object_self(param) {\n+                            self.ty_infer_for_def(param, span)\n+                        } else {\n+                            self.ty_infer(span)\n+                        };\n+                        ty_var\n+                    } else if has_default {\n+                        // No type parameter provided, but a default exists.\n+\n+                        // If we are converting an object type, then the\n+                        // `Self` parameter is unknown. However, some of the\n+                        // other type parameters may reference `Self` in their\n+                        // defaults. This will lead to an ICE if we are not\n+                        // careful!\n+                        if default_needs_object_self(param) {\n+                            struct_span_err!(tcx.sess, span, E0393,\n+                                             \"the type parameter `{}` must be explicitly \\\n+                                             specified\",\n+                                             param.name)\n+                                .span_label(span,\n+                                            format!(\"missing reference to `{}`\", param.name))\n+                                .note(&format!(\"because of the default `Self` reference, \\\n+                                                type parameters must be specified on object \\\n+                                                types\"))\n+                                .emit();\n+                            tcx.types.err\n+                        } else {\n+                            // This is a default type parameter.\n+                            self.normalize_ty(\n+                                span,\n+                                tcx.at(span).type_of(param.def_id)\n+                                    .subst_spanned(tcx, substs, Some(span))\n+                            )\n+                        }\n+                    } else {\n+                        // We've already errored above about the mismatch.\n+                        tcx.types.err\n+                    };\n+                    UnpackedKind::Type(ty)\n                 }\n-            } else {\n-                // We've already errored above about the mismatch.\n-                tcx.types.err\n             }\n         });\n \n@@ -1154,12 +1165,17 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let mut substs = Vec::with_capacity(generics.count());\n         if let Some(parent_id) = generics.parent {\n             let parent_generics = tcx.generics_of(parent_id);\n-            Substs::fill_item(\n-                &mut substs, tcx, parent_generics,\n-                &mut |def, _| tcx.mk_region(\n-                    ty::ReEarlyBound(def.to_early_bound_region_data())),\n-                &mut |def, _| tcx.mk_ty_param_from_def(def)\n-            );\n+            Substs::fill_item(&mut substs, tcx, parent_generics, &mut |param, _| {\n+                match param.kind {\n+                    GenericParamDefKind::Lifetime => {\n+                        UnpackedKind::Lifetime(\n+                            tcx.mk_region(ty::ReEarlyBound(param.to_early_bound_region_data())))\n+                    }\n+                    GenericParamDefKind::Type(_) => {\n+                        UnpackedKind::Type(tcx.mk_ty_param_from_def(param))\n+                    }\n+                }\n+            });\n \n             // Replace all lifetimes with 'static\n             for subst in &mut substs {"}, {"sha": "152f020c4769e5d968cf4166fadf42fb75b7cffb", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d9190da9825b729ce63becf727b2cfdad3e8561a/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9190da9825b729ce63becf727b2cfdad3e8561a/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=d9190da9825b729ce63becf727b2cfdad3e8561a", "patch": "@@ -18,8 +18,8 @@ use rustc::infer::{InferOk, InferResult};\n use rustc::infer::LateBoundRegionConversionTime;\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::traits::error_reporting::ArgKind;\n-use rustc::ty::{self, ToPolyTraitRef, Ty};\n-use rustc::ty::subst::Substs;\n+use rustc::ty::{self, ToPolyTraitRef, Ty, GenericParamDefKind};\n+use rustc::ty::subst::{UnpackedKind, Substs};\n use rustc::ty::TypeFoldable;\n use std::cmp;\n use std::iter;\n@@ -104,15 +104,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // inference phase (`upvar.rs`).\n         let base_substs =\n             Substs::identity_for_item(self.tcx, self.tcx.closure_base_def_id(expr_def_id));\n-        let substs = base_substs.extend_to(\n-            self.tcx,\n-            expr_def_id,\n-            |_, _| span_bug!(expr.span, \"closure has region param\"),\n-            |_, _| {\n-                self.infcx\n-                    .next_ty_var(TypeVariableOrigin::ClosureSynthetic(expr.span))\n-            },\n-        );\n+        let substs = base_substs.extend_to(self.tcx,expr_def_id, |param, _| {\n+            match param.kind {\n+                GenericParamDefKind::Lifetime => {\n+                    span_bug!(expr.span, \"closure has region param\")\n+                }\n+                GenericParamDefKind::Type(_) => {\n+                    UnpackedKind::Type(self.infcx\n+                        .next_ty_var(TypeVariableOrigin::ClosureSynthetic(expr.span)))\n+                }\n+            }\n+        });\n         if let Some(GeneratorTypes { yield_ty, interior, movability }) = generator_types {\n             let substs = ty::GeneratorSubsts { substs };\n             self.demand_eqtype("}, {"sha": "c208e0fae64290aaedb234c1e0b4e735bb936f22", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 33, "deletions": 26, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/d9190da9825b729ce63becf727b2cfdad3e8561a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9190da9825b729ce63becf727b2cfdad3e8561a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=d9190da9825b729ce63becf727b2cfdad3e8561a", "patch": "@@ -15,8 +15,8 @@ use check::{FnCtxt, PlaceOp, callee, Needs};\n use hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::traits;\n-use rustc::ty::{self, Ty};\n-use rustc::ty::subst::Subst;\n+use rustc::ty::{self, Ty, GenericParamDefKind};\n+use rustc::ty::subst::{UnpackedKind, Subst};\n use rustc::ty::adjustment::{Adjustment, Adjust, OverloadedDeref};\n use rustc::ty::adjustment::{AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::fold::TypeFoldable;\n@@ -317,30 +317,37 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         assert_eq!(method_generics.parent_count, parent_substs.len());\n         let provided = &segment.parameters;\n         let own_counts = method_generics.own_counts();\n-        Substs::for_item(self.tcx, pick.item.def_id, |def, _| {\n-            let i = def.index as usize;\n-            if i < parent_substs.len() {\n-                parent_substs.region_at(i)\n-            } else if let Some(lifetime)\n-                    = provided.as_ref().and_then(|p| p.lifetimes.get(i - parent_substs.len())) {\n-                AstConv::ast_region_to_region(self.fcx, lifetime, Some(def))\n-            } else {\n-                self.region_var_for_def(self.span, def)\n-            }\n-        }, |def, _cur_substs| {\n-            let i = def.index as usize;\n-            if i < parent_substs.len() {\n-                parent_substs.type_at(i)\n-            } else if let Some(ast_ty)\n-                = provided.as_ref().and_then(|p| {\n-                    let idx =\n-                        i - parent_substs.len() - own_counts.lifetimes;\n-                    p.types.get(idx)\n-                })\n-            {\n-                self.to_ty(ast_ty)\n-            } else {\n-                self.type_var_for_def(self.span, def)\n+        Substs::for_item(self.tcx, pick.item.def_id, |param, _| {\n+            match param.kind {\n+                GenericParamDefKind::Lifetime => {\n+                    let i = param.index as usize;\n+                    let lt = if i < parent_substs.len() {\n+                        parent_substs.region_at(i)\n+                    } else if let Some(lifetime)\n+                            = provided.as_ref().and_then(|p| p.lifetimes.get(i - parent_substs.len())) {\n+                        AstConv::ast_region_to_region(self.fcx, lifetime, Some(param))\n+                    } else {\n+                        self.region_var_for_def(self.span, param)\n+                    };\n+                    UnpackedKind::Lifetime(lt)\n+                }\n+                GenericParamDefKind::Type(_) => {\n+                    let i = param.index as usize;\n+                    let ty = if i < parent_substs.len() {\n+                        parent_substs.type_at(i)\n+                    } else if let Some(ast_ty)\n+                        = provided.as_ref().and_then(|p| {\n+                            let idx =\n+                                i - parent_substs.len() - own_counts.lifetimes;\n+                            p.types.get(idx)\n+                        })\n+                    {\n+                        self.to_ty(ast_ty)\n+                    } else {\n+                        self.type_var_for_def(self.span, param)\n+                    };\n+                    UnpackedKind::Type(ty)\n+                }\n             }\n         })\n     }"}, {"sha": "298b8548e36e7f761d0b60471541cdd96d137184", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d9190da9825b729ce63becf727b2cfdad3e8561a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9190da9825b729ce63becf727b2cfdad3e8561a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=d9190da9825b729ce63becf727b2cfdad3e8561a", "patch": "@@ -19,7 +19,8 @@ use namespace::Namespace;\n use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, Ty, ToPredicate, ToPolyTraitRef, TraitRef, TypeFoldable};\n-use rustc::ty::subst::Subst;\n+use rustc::ty::GenericParamDefKind;\n+use rustc::ty::subst::{UnpackedKind, Subst};\n use rustc::infer::{self, InferOk};\n \n use syntax::ast;\n@@ -253,16 +254,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                trait_def_id);\n \n         // Construct a trait-reference `self_ty : Trait<input_tys>`\n-        let substs = Substs::for_item(self.tcx,\n-                                      trait_def_id,\n-                                      |def, _| self.region_var_for_def(span, def),\n-                                      |def, _substs| {\n-            if def.index == 0 {\n-                self_ty\n-            } else if let Some(ref input_types) = opt_input_types {\n-                input_types[def.index as usize - 1]\n-            } else {\n-                self.type_var_for_def(span, def)\n+        let substs = Substs::for_item(self.tcx, trait_def_id, |param, _| {\n+            match param.kind {\n+                GenericParamDefKind::Lifetime => {\n+                    UnpackedKind::Lifetime(self.region_var_for_def(span, param))\n+                }\n+                GenericParamDefKind::Type(_) => {\n+                    let ty = if param.index == 0 {\n+                        self_ty\n+                    } else if let Some(ref input_types) = opt_input_types {\n+                        input_types[param.index as usize - 1]\n+                    } else {\n+                        self.type_var_for_def(span, param)\n+                    };\n+                    UnpackedKind::Type(ty)\n+                }\n             }\n         });\n "}, {"sha": "a96796bb148cb7ea1f1386c7f56731948ff16bad", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 36, "deletions": 22, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d9190da9825b729ce63becf727b2cfdad3e8561a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9190da9825b729ce63becf727b2cfdad3e8561a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=d9190da9825b729ce63becf727b2cfdad3e8561a", "patch": "@@ -17,9 +17,10 @@ use check::FnCtxt;\n use hir::def_id::DefId;\n use hir::def::Def;\n use namespace::Namespace;\n-use rustc::ty::subst::{Subst, Substs};\n+use rustc::ty::subst::{UnpackedKind, Subst, Substs};\n use rustc::traits::{self, ObligationCause};\n use rustc::ty::{self, Ty, ToPolyTraitRef, ToPredicate, TraitRef, TypeFoldable};\n+use rustc::ty::GenericParamDefKind;\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::util::nodemap::FxHashSet;\n use rustc::infer::{self, InferOk};\n@@ -1387,21 +1388,28 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         if generics.params.is_empty() {\n             xform_fn_sig.subst(self.tcx, substs)\n         } else {\n-            let substs = Substs::for_item(self.tcx, method, |def, _| {\n-                let i = def.index as usize;\n-                if i < substs.len() {\n-                    substs.region_at(i)\n-                } else {\n-                    // In general, during probe we erase regions. See\n-                    // `impl_self_ty()` for an explanation.\n-                    self.tcx.types.re_erased\n-                }\n-            }, |def, _cur_substs| {\n-                let i = def.index as usize;\n-                if i < substs.len() {\n-                    substs.type_at(i)\n-                } else {\n-                    self.type_var_for_def(self.span, def)\n+            let substs = Substs::for_item(self.tcx, method, |param, _| {\n+                match param.kind {\n+                    GenericParamDefKind::Lifetime => {\n+                        let i = param.index as usize;\n+                        let lt = if i < substs.len() {\n+                            substs.region_at(i)\n+                        } else {\n+                            // In general, during probe we erase regions. See\n+                            // `impl_self_ty()` for an explanation.\n+                            self.tcx.types.re_erased\n+                        };\n+                        UnpackedKind::Lifetime(lt)\n+                    }\n+                    GenericParamDefKind::Type(_) => {\n+                        let i = param.index as usize;\n+                        let ty = if i < substs.len() {\n+                            substs.type_at(i)\n+                        } else {\n+                            self.type_var_for_def(self.span, param)\n+                        };\n+                        UnpackedKind::Type(ty)\n+                    }\n                 }\n             });\n             xform_fn_sig.subst(self.tcx, substs)\n@@ -1414,12 +1422,18 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     }\n \n     fn fresh_item_substs(&self, def_id: DefId) -> &'tcx Substs<'tcx> {\n-        Substs::for_item(self.tcx,\n-                         def_id,\n-                         |_, _| self.tcx.types.re_erased,\n-                         |_, _| self.next_ty_var(\n-                             TypeVariableOrigin::SubstitutionPlaceholder(\n-                                 self.tcx.def_span(def_id))))\n+        Substs::for_item(self.tcx, def_id, |param, _| {\n+            match param.kind {\n+                GenericParamDefKind::Lifetime => {\n+                    UnpackedKind::Lifetime(self.tcx.types.re_erased)\n+                }\n+                GenericParamDefKind::Type(_) => {\n+                    UnpackedKind::Type(self.next_ty_var(\n+                        TypeVariableOrigin::SubstitutionPlaceholder(\n+                        self.tcx.def_span(def_id))))\n+                }\n+            }\n+        })\n     }\n \n     /// Replace late-bound-regions bound by `value` with `'static` using"}, {"sha": "99e47f92daf0f4ca9827792354e544bd66a50064", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 68, "deletions": 61, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/d9190da9825b729ce63becf727b2cfdad3e8561a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9190da9825b729ce63becf727b2cfdad3e8561a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d9190da9825b729ce63becf727b2cfdad3e8561a", "patch": "@@ -94,7 +94,7 @@ use rustc::infer::anon_types::AnonTypeDecl;\n use rustc::infer::type_variable::{TypeVariableOrigin};\n use rustc::middle::region;\n use rustc::mir::interpret::{GlobalId};\n-use rustc::ty::subst::{Kind, Subst, Substs};\n+use rustc::ty::subst::{Kind, UnpackedKind, Subst, Substs};\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, TraitEngine};\n use rustc::ty::{self, Ty, TyCtxt, GenericParamDefKind, Visibility, ToPredicate};\n use rustc::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n@@ -4758,71 +4758,78 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n             (None, None) => (0, false)\n         };\n-        let substs = Substs::for_item(self.tcx, def.def_id(), |def, _| {\n-            let mut i = def.index as usize;\n-\n-            let segment = if i < fn_start {\n-                i -= has_self as usize;\n-                type_segment\n-            } else {\n-                i -= fn_start;\n-                fn_segment\n-            };\n-            let lifetimes = segment.map_or(&[][..], |(s, _)| {\n-                s.parameters.as_ref().map_or(&[][..], |p| &p.lifetimes[..])\n-            });\n-\n-            if let Some(lifetime) = lifetimes.get(i) {\n-                AstConv::ast_region_to_region(self, lifetime, Some(def))\n-            } else {\n-                self.re_infer(span, Some(def)).unwrap()\n-            }\n-        }, |def, substs| {\n-            let mut i = def.index as usize;\n-\n-            let segment = if i < fn_start {\n-                // Handle Self first, so we can adjust the index to match the AST.\n-                if has_self && i == 0 {\n-                    return opt_self_ty.unwrap_or_else(|| {\n-                        self.type_var_for_def(span, def)\n+        let substs = Substs::for_item(self.tcx, def.def_id(), |param, substs| {\n+            match param.kind {\n+                GenericParamDefKind::Lifetime => {\n+                    let mut i = param.index as usize;\n+\n+                    let segment = if i < fn_start {\n+                        i -= has_self as usize;\n+                        type_segment\n+                    } else {\n+                        i -= fn_start;\n+                        fn_segment\n+                    };\n+                    let lifetimes = segment.map_or(&[][..], |(s, _)| {\n+                        s.parameters.as_ref().map_or(&[][..], |p| &p.lifetimes[..])\n                     });\n+\n+                    let lt = if let Some(lifetime) = lifetimes.get(i) {\n+                        AstConv::ast_region_to_region(self, lifetime, Some(param))\n+                    } else {\n+                        self.re_infer(span, Some(param)).unwrap()\n+                    };\n+                    UnpackedKind::Lifetime(lt)\n                 }\n-                i -= has_self as usize;\n-                type_segment\n-            } else {\n-                i -= fn_start;\n-                fn_segment\n-            };\n-            let (types, infer_types) = segment.map_or((&[][..], true), |(s, _)| {\n-                (s.parameters.as_ref().map_or(&[][..], |p| &p.types[..]), s.infer_types)\n-            });\n+                GenericParamDefKind::Type(_) => {\n+                    let mut i = param.index as usize;\n+\n+                    let segment = if i < fn_start {\n+                        // Handle Self first, so we can adjust the index to match the AST.\n+                        if has_self && i == 0 {\n+                            return UnpackedKind::Type(opt_self_ty.unwrap_or_else(|| {\n+                                self.type_var_for_def(span, param)\n+                            }));\n+                        }\n+                        i -= has_self as usize;\n+                        type_segment\n+                    } else {\n+                        i -= fn_start;\n+                        fn_segment\n+                    };\n+                    let (types, infer_types) = segment.map_or((&[][..], true), |(s, _)| {\n+                        (s.parameters.as_ref().map_or(&[][..], |p| &p.types[..]), s.infer_types)\n+                    });\n \n-            // Skip over the lifetimes in the same segment.\n-            if let Some((_, generics)) = segment {\n-                i -= generics.own_counts().lifetimes;\n-            }\n+                    // Skip over the lifetimes in the same segment.\n+                    if let Some((_, generics)) = segment {\n+                        i -= generics.own_counts().lifetimes;\n+                    }\n \n-            let has_default = match def.kind {\n-                GenericParamDefKind::Type(ty) => ty.has_default,\n-                _ => unreachable!()\n-            };\n+                    let has_default = match param.kind {\n+                        GenericParamDefKind::Type(ty) => ty.has_default,\n+                        _ => unreachable!()\n+                    };\n \n-            if let Some(ast_ty) = types.get(i) {\n-                // A provided type parameter.\n-                self.to_ty(ast_ty)\n-            } else if !infer_types && has_default {\n-                // No type parameter provided, but a default exists.\n-                let default = self.tcx.type_of(def.def_id);\n-                self.normalize_ty(\n-                    span,\n-                    default.subst_spanned(self.tcx, substs, Some(span))\n-                )\n-            } else {\n-                // No type parameters were provided, we can infer all.\n-                // This can also be reached in some error cases:\n-                // We prefer to use inference variables instead of\n-                // TyError to let type inference recover somewhat.\n-                self.type_var_for_def(span, def)\n+                    let ty = if let Some(ast_ty) = types.get(i) {\n+                        // A provided type parameter.\n+                        self.to_ty(ast_ty)\n+                    } else if !infer_types && has_default {\n+                        // No type parameter provided, but a default exists.\n+                        let default = self.tcx.type_of(param.def_id);\n+                        self.normalize_ty(\n+                            span,\n+                            default.subst_spanned(self.tcx, substs, Some(span))\n+                        )\n+                    } else {\n+                        // No type parameters were provided, we can infer all.\n+                        // This can also be reached in some error cases:\n+                        // We prefer to use inference variables instead of\n+                        // TyError to let type inference recover somewhat.\n+                        self.type_var_for_def(span, param)\n+                    };\n+                    UnpackedKind::Type(ty)\n+                }\n             }\n         });\n "}, {"sha": "5c6a78de313b64049e61685ae038758c9fcb65d7", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d9190da9825b729ce63becf727b2cfdad3e8561a/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9190da9825b729ce63becf727b2cfdad3e8561a/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=d9190da9825b729ce63becf727b2cfdad3e8561a", "patch": "@@ -11,11 +11,10 @@\n use check::{Inherited, FnCtxt};\n use constrained_type_params::{identify_constrained_type_params, Parameter};\n \n-use ty::GenericParamDefKind;\n-\n use hir::def_id::DefId;\n use rustc::traits::{self, ObligationCauseCode};\n-use rustc::ty::{self, Lift, Ty, TyCtxt};\n+use rustc::ty::{self, Lift, Ty, TyCtxt, GenericParamDefKind};\n+use rustc::ty::subst::{UnpackedKind, Substs};\n use rustc::ty::util::ExplicitSelf;\n use rustc::util::nodemap::{FxHashSet, FxHashMap};\n use rustc::middle::lang_items;\n@@ -406,22 +405,28 @@ fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     // For more examples see tests `defaults-well-formedness.rs` and `type-check-defaults.rs`.\n     //\n     // First we build the defaulted substitution.\n-    let substs = ty::subst::Substs::for_item(fcx.tcx, def_id, |def, _| {\n-            // All regions are identity.\n-            fcx.tcx.mk_region(ty::ReEarlyBound(def.to_early_bound_region_data()))\n-        }, |def, _| {\n-            // If the param has a default,\n-            if is_our_default(def) {\n-                let default_ty = fcx.tcx.type_of(def.def_id);\n-                // and it's not a dependent default\n-                if !default_ty.needs_subst() {\n-                    // then substitute with the default.\n-                    return default_ty;\n+    let substs = Substs::for_item(fcx.tcx, def_id, |param, _| {\n+        match param.kind {\n+            GenericParamDefKind::Lifetime => {\n+                // All regions are identity.\n+                UnpackedKind::Lifetime(\n+                    fcx.tcx.mk_region(ty::ReEarlyBound(param.to_early_bound_region_data())))\n+            }\n+            GenericParamDefKind::Type(_) => {\n+                // If the param has a default,\n+                if is_our_default(param) {\n+                    let default_ty = fcx.tcx.type_of(param.def_id);\n+                    // and it's not a dependent default\n+                    if !default_ty.needs_subst() {\n+                        // then substitute with the default.\n+                        return UnpackedKind::Type(default_ty);\n+                    }\n                 }\n+                // Mark unwanted params as err.\n+                UnpackedKind::Type(fcx.tcx.types.err)\n             }\n-            // Mark unwanted params as err.\n-            fcx.tcx.types.err\n-        });\n+        }\n+    });\n     // Now we build the substituted predicates.\n     for &pred in predicates.predicates.iter() {\n         struct CountParams { params: FxHashSet<u32> }"}, {"sha": "1a2480bf45e3b61b236621a7836f92106c6d9c4d", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d9190da9825b729ce63becf727b2cfdad3e8561a/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9190da9825b729ce63becf727b2cfdad3e8561a/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=d9190da9825b729ce63becf727b2cfdad3e8561a", "patch": "@@ -30,7 +30,8 @@ use constrained_type_params as ctp;\n use middle::lang_items::SizedTraitLangItem;\n use middle::resolve_lifetime as rl;\n use rustc::mir::mono::Linkage;\n-use rustc::ty::subst::Substs;\n+use rustc::ty::subst::{UnpackedKind, Substs};\n+use rustc::ty::GenericParamDefKind;\n use rustc::ty::{ToPredicate, ReprOptions};\n use rustc::ty::{self, AdtKind, ToPolyTraitRef, Ty, TyCtxt};\n use rustc::ty::maps::Providers;\n@@ -1096,15 +1097,17 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n \n             let substs = ty::ClosureSubsts {\n-                substs: Substs::for_item(\n-                    tcx,\n-                    def_id,\n-                    |def, _| {\n-                        let region = def.to_early_bound_region_data();\n-                        tcx.mk_region(ty::ReEarlyBound(region))\n-                    },\n-                    |def, _| tcx.mk_ty_param_from_def(def)\n-                )\n+                substs: Substs::for_item(tcx, def_id, |param, _| {\n+                    match param.kind {\n+                        GenericParamDefKind::Lifetime => {\n+                            let region = param.to_early_bound_region_data();\n+                            UnpackedKind::Lifetime(tcx.mk_region(ty::ReEarlyBound(region)))\n+                        }\n+                        GenericParamDefKind::Type(_) => {\n+                            UnpackedKind::Type(tcx.mk_ty_param_from_def(param))\n+                        }\n+                    }\n+                })\n             };\n \n             tcx.mk_closure(def_id, substs)"}]}