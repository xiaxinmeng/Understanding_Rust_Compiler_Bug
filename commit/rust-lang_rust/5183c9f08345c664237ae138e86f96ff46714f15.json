{"sha": "5183c9f08345c664237ae138e86f96ff46714f15", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxODNjOWYwODM0NWM2NjQyMzdhZTEzOGU4NmY5NmZmNDY3MTRmMTU=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-02-28T00:20:04Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-02-28T00:20:04Z"}, "message": "Introduce TypeCtor::Scalar", "tree": {"sha": "a0e660cb49fd67951ee2209d9fc75a2108243df7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0e660cb49fd67951ee2209d9fc75a2108243df7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5183c9f08345c664237ae138e86f96ff46714f15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5183c9f08345c664237ae138e86f96ff46714f15", "html_url": "https://github.com/rust-lang/rust/commit/5183c9f08345c664237ae138e86f96ff46714f15", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5183c9f08345c664237ae138e86f96ff46714f15/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a4076c14d0e3f7ae03908c2b9cd1a52851d401c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a4076c14d0e3f7ae03908c2b9cd1a52851d401c", "html_url": "https://github.com/rust-lang/rust/commit/2a4076c14d0e3f7ae03908c2b9cd1a52851d401c"}], "stats": {"total": 730, "additions": 350, "deletions": 380}, "files": [{"sha": "4109b2ea84faf4526956af37bf2cfa81f46eab45", "filename": "crates/hir/src/code_model.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5183c9f08345c664237ae138e86f96ff46714f15/crates%2Fhir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5183c9f08345c664237ae138e86f96ff46714f15/crates%2Fhir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fcode_model.rs?ref=5183c9f08345c664237ae138e86f96ff46714f15", "patch": "@@ -32,8 +32,8 @@ use hir_ty::{\n     method_resolution,\n     traits::{FnTrait, Solution, SolutionVariables},\n     ApplicationTy, BoundVar, CallableDefId, Canonical, DebruijnIndex, FnSig, GenericPredicate,\n-    InEnvironment, Obligation, ProjectionPredicate, ProjectionTy, Substs, TraitEnvironment, Ty,\n-    TyDefId, TyKind, TypeCtor,\n+    InEnvironment, Obligation, ProjectionPredicate, ProjectionTy, Scalar, Substs, TraitEnvironment,\n+    Ty, TyDefId, TyKind, TypeCtor,\n };\n use rustc_hash::FxHashSet;\n use stdx::{format_to, impl_from};\n@@ -1553,7 +1553,10 @@ impl Type {\n         )\n     }\n     pub fn is_bool(&self) -> bool {\n-        matches!(self.ty.value, Ty::Apply(ApplicationTy { ctor: TypeCtor::Bool, .. }))\n+        matches!(\n+            self.ty.value,\n+            Ty::Apply(ApplicationTy { ctor: TypeCtor::Scalar(Scalar::Bool), .. })\n+        )\n     }\n \n     pub fn is_mutable_reference(&self) -> bool {"}, {"sha": "40beb2f7a7c82d626d4f3f92110f5fd8915b7161", "filename": "crates/hir_def/src/body/lower.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5183c9f08345c664237ae138e86f96ff46714f15/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5183c9f08345c664237ae138e86f96ff46714f15/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs?ref=5183c9f08345c664237ae138e86f96ff46714f15", "patch": "@@ -24,7 +24,7 @@ use test_utils::mark;\n use crate::{\n     adt::StructKind,\n     body::{Body, BodySourceMap, Expander, LabelSource, PatPtr, SyntheticSyntax},\n-    builtin_type::{BuiltinFloat, BuiltinInt},\n+    builtin_type::{BuiltinFloat, BuiltinInt, BuiltinUint},\n     db::DefDatabase,\n     diagnostics::{InactiveCode, MacroError, UnresolvedProcMacro},\n     expr::{\n@@ -1065,19 +1065,24 @@ impl From<ast::LiteralKind> for Literal {\n     fn from(ast_lit_kind: ast::LiteralKind) -> Self {\n         match ast_lit_kind {\n             LiteralKind::IntNumber(lit) => {\n-                if let Some(float_suffix) = lit.suffix().and_then(BuiltinFloat::from_suffix) {\n-                    return Literal::Float(Default::default(), Some(float_suffix));\n+                if let builtin @ Some(_) = lit.suffix().and_then(BuiltinFloat::from_suffix) {\n+                    return Literal::Float(Default::default(), builtin);\n+                } else if let builtin @ Some(_) =\n+                    lit.suffix().and_then(|it| BuiltinInt::from_suffix(&it))\n+                {\n+                    Literal::Int(Default::default(), builtin)\n+                } else {\n+                    let builtin = lit.suffix().and_then(|it| BuiltinUint::from_suffix(&it));\n+                    Literal::Uint(Default::default(), builtin)\n                 }\n-                let ty = lit.suffix().and_then(|it| BuiltinInt::from_suffix(&it));\n-                Literal::Int(Default::default(), ty)\n             }\n             LiteralKind::FloatNumber(lit) => {\n                 let ty = lit.suffix().and_then(|it| BuiltinFloat::from_suffix(&it));\n                 Literal::Float(Default::default(), ty)\n             }\n             LiteralKind::ByteString(_) => Literal::ByteString(Default::default()),\n             LiteralKind::String(_) => Literal::String(Default::default()),\n-            LiteralKind::Byte => Literal::Int(Default::default(), Some(BuiltinInt::U8)),\n+            LiteralKind::Byte => Literal::Uint(Default::default(), Some(BuiltinUint::U8)),\n             LiteralKind::Bool(val) => Literal::Bool(val),\n             LiteralKind::Char => Literal::Char(Default::default()),\n         }"}, {"sha": "7cbaf30b858403f411044176fed313d5e1d056cb", "filename": "crates/hir_def/src/builtin_type.rs", "status": "modified", "additions": 60, "deletions": 72, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/5183c9f08345c664237ae138e86f96ff46714f15/crates%2Fhir_def%2Fsrc%2Fbuiltin_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5183c9f08345c664237ae138e86f96ff46714f15/crates%2Fhir_def%2Fsrc%2Fbuiltin_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbuiltin_type.rs?ref=5183c9f08345c664237ae138e86f96ff46714f15", "patch": "@@ -6,38 +6,32 @@\n use std::fmt;\n \n use hir_expand::name::{name, AsName, Name};\n-\n-#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]\n-pub enum Signedness {\n-    Signed,\n-    Unsigned,\n-}\n-\n-#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]\n-pub enum IntBitness {\n-    Xsize,\n-    X8,\n-    X16,\n-    X32,\n-    X64,\n-    X128,\n-}\n-\n-#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]\n-pub enum FloatBitness {\n-    X32,\n-    X64,\n+/// Different signed int types.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub enum BuiltinInt {\n+    Isize,\n+    I8,\n+    I16,\n+    I32,\n+    I64,\n+    I128,\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct BuiltinInt {\n-    pub signedness: Signedness,\n-    pub bitness: IntBitness,\n+/// Different unsigned int types.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub enum BuiltinUint {\n+    Usize,\n+    U8,\n+    U16,\n+    U32,\n+    U64,\n+    U128,\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct BuiltinFloat {\n-    pub bitness: FloatBitness,\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub enum BuiltinFloat {\n+    F32,\n+    F64,\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -46,6 +40,7 @@ pub enum BuiltinType {\n     Bool,\n     Str,\n     Int(BuiltinInt),\n+    Uint(BuiltinUint),\n     Float(BuiltinFloat),\n }\n \n@@ -56,19 +51,19 @@ impl BuiltinType {\n         (name![bool], BuiltinType::Bool),\n         (name![str],  BuiltinType::Str),\n \n-        (name![isize], BuiltinType::Int(BuiltinInt::ISIZE)),\n+        (name![isize], BuiltinType::Int(BuiltinInt::Isize)),\n         (name![i8],    BuiltinType::Int(BuiltinInt::I8)),\n         (name![i16],   BuiltinType::Int(BuiltinInt::I16)),\n         (name![i32],   BuiltinType::Int(BuiltinInt::I32)),\n         (name![i64],   BuiltinType::Int(BuiltinInt::I64)),\n         (name![i128],  BuiltinType::Int(BuiltinInt::I128)),\n \n-        (name![usize], BuiltinType::Int(BuiltinInt::USIZE)),\n-        (name![u8],    BuiltinType::Int(BuiltinInt::U8)),\n-        (name![u16],   BuiltinType::Int(BuiltinInt::U16)),\n-        (name![u32],   BuiltinType::Int(BuiltinInt::U32)),\n-        (name![u64],   BuiltinType::Int(BuiltinInt::U64)),\n-        (name![u128],  BuiltinType::Int(BuiltinInt::U128)),\n+        (name![usize], BuiltinType::Uint(BuiltinUint::Usize)),\n+        (name![u8],    BuiltinType::Uint(BuiltinUint::U8)),\n+        (name![u16],   BuiltinType::Uint(BuiltinUint::U16)),\n+        (name![u32],   BuiltinType::Uint(BuiltinUint::U32)),\n+        (name![u64],   BuiltinType::Uint(BuiltinUint::U64)),\n+        (name![u128],  BuiltinType::Uint(BuiltinUint::U128)),\n \n         (name![f32], BuiltinType::Float(BuiltinFloat::F32)),\n         (name![f64], BuiltinType::Float(BuiltinFloat::F64)),\n@@ -81,24 +76,25 @@ impl AsName for BuiltinType {\n             BuiltinType::Char => name![char],\n             BuiltinType::Bool => name![bool],\n             BuiltinType::Str => name![str],\n-            BuiltinType::Int(BuiltinInt { signedness, bitness }) => match (signedness, bitness) {\n-                (Signedness::Signed, IntBitness::Xsize) => name![isize],\n-                (Signedness::Signed, IntBitness::X8) => name![i8],\n-                (Signedness::Signed, IntBitness::X16) => name![i16],\n-                (Signedness::Signed, IntBitness::X32) => name![i32],\n-                (Signedness::Signed, IntBitness::X64) => name![i64],\n-                (Signedness::Signed, IntBitness::X128) => name![i128],\n-\n-                (Signedness::Unsigned, IntBitness::Xsize) => name![usize],\n-                (Signedness::Unsigned, IntBitness::X8) => name![u8],\n-                (Signedness::Unsigned, IntBitness::X16) => name![u16],\n-                (Signedness::Unsigned, IntBitness::X32) => name![u32],\n-                (Signedness::Unsigned, IntBitness::X64) => name![u64],\n-                (Signedness::Unsigned, IntBitness::X128) => name![u128],\n+            BuiltinType::Int(it) => match it {\n+                BuiltinInt::Isize => name![isize],\n+                BuiltinInt::I8 => name![i8],\n+                BuiltinInt::I16 => name![i16],\n+                BuiltinInt::I32 => name![i32],\n+                BuiltinInt::I64 => name![i64],\n+                BuiltinInt::I128 => name![i128],\n+            },\n+            BuiltinType::Uint(it) => match it {\n+                BuiltinUint::Usize => name![usize],\n+                BuiltinUint::U8 => name![u8],\n+                BuiltinUint::U16 => name![u16],\n+                BuiltinUint::U32 => name![u32],\n+                BuiltinUint::U64 => name![u64],\n+                BuiltinUint::U128 => name![u128],\n             },\n-            BuiltinType::Float(BuiltinFloat { bitness }) => match bitness {\n-                FloatBitness::X32 => name![f32],\n-                FloatBitness::X64 => name![f64],\n+            BuiltinType::Float(it) => match it {\n+                BuiltinFloat::F32 => name![f32],\n+                BuiltinFloat::F64 => name![f64],\n             },\n         }\n     }\n@@ -113,31 +109,26 @@ impl fmt::Display for BuiltinType {\n \n #[rustfmt::skip]\n impl BuiltinInt {\n-    pub const ISIZE: BuiltinInt = BuiltinInt { signedness: Signedness::Signed, bitness: IntBitness::Xsize   };\n-    pub const I8   : BuiltinInt = BuiltinInt { signedness: Signedness::Signed, bitness: IntBitness::X8      };\n-    pub const I16  : BuiltinInt = BuiltinInt { signedness: Signedness::Signed, bitness: IntBitness::X16     };\n-    pub const I32  : BuiltinInt = BuiltinInt { signedness: Signedness::Signed, bitness: IntBitness::X32     };\n-    pub const I64  : BuiltinInt = BuiltinInt { signedness: Signedness::Signed, bitness: IntBitness::X64     };\n-    pub const I128 : BuiltinInt = BuiltinInt { signedness: Signedness::Signed, bitness: IntBitness::X128    };\n-\n-    pub const USIZE: BuiltinInt = BuiltinInt { signedness: Signedness::Unsigned, bitness: IntBitness::Xsize };\n-    pub const U8   : BuiltinInt = BuiltinInt { signedness: Signedness::Unsigned, bitness: IntBitness::X8    };\n-    pub const U16  : BuiltinInt = BuiltinInt { signedness: Signedness::Unsigned, bitness: IntBitness::X16   };\n-    pub const U32  : BuiltinInt = BuiltinInt { signedness: Signedness::Unsigned, bitness: IntBitness::X32   };\n-    pub const U64  : BuiltinInt = BuiltinInt { signedness: Signedness::Unsigned, bitness: IntBitness::X64   };\n-    pub const U128 : BuiltinInt = BuiltinInt { signedness: Signedness::Unsigned, bitness: IntBitness::X128  };\n-\n-\n     pub fn from_suffix(suffix: &str) -> Option<BuiltinInt> {\n         let res = match suffix {\n-            \"isize\" => Self::ISIZE,\n+            \"isize\" => Self::Isize,\n             \"i8\"    => Self::I8,\n             \"i16\"   => Self::I16,\n             \"i32\"   => Self::I32,\n             \"i64\"   => Self::I64,\n             \"i128\"  => Self::I128,\n \n-            \"usize\" => Self::USIZE,\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+}\n+\n+#[rustfmt::skip]\n+impl BuiltinUint {\n+    pub fn from_suffix(suffix: &str) -> Option<BuiltinUint> {\n+        let res = match suffix {\n+            \"usize\" => Self::Usize,\n             \"u8\"    => Self::U8,\n             \"u16\"   => Self::U16,\n             \"u32\"   => Self::U32,\n@@ -152,9 +143,6 @@ impl BuiltinInt {\n \n #[rustfmt::skip]\n impl BuiltinFloat {\n-    pub const F32: BuiltinFloat = BuiltinFloat { bitness: FloatBitness::X32 };\n-    pub const F64: BuiltinFloat = BuiltinFloat { bitness: FloatBitness::X64 };\n-\n     pub fn from_suffix(suffix: &str) -> Option<BuiltinFloat> {\n         let res = match suffix {\n             \"f32\" => BuiltinFloat::F32,"}, {"sha": "24be9377395ec21e17bd7521218c5133896bfb31", "filename": "crates/hir_def/src/expr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5183c9f08345c664237ae138e86f96ff46714f15/crates%2Fhir_def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5183c9f08345c664237ae138e86f96ff46714f15/crates%2Fhir_def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fexpr.rs?ref=5183c9f08345c664237ae138e86f96ff46714f15", "patch": "@@ -17,7 +17,7 @@ use la_arena::{Idx, RawIdx};\n use syntax::ast::RangeOp;\n \n use crate::{\n-    builtin_type::{BuiltinFloat, BuiltinInt},\n+    builtin_type::{BuiltinFloat, BuiltinInt, BuiltinUint},\n     path::{GenericArgs, Path},\n     type_ref::{Mutability, Rawness, TypeRef},\n     BlockId,\n@@ -43,6 +43,7 @@ pub enum Literal {\n     Char(char),\n     Bool(bool),\n     Int(u64, Option<BuiltinInt>),\n+    Uint(u64, Option<BuiltinUint>),\n     Float(u64, Option<BuiltinFloat>), // FIXME: f64 is not Eq\n }\n "}, {"sha": "cfe9cedb0de0615cd706df7de6b341771c9b4c7d", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5183c9f08345c664237ae138e86f96ff46714f15/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5183c9f08345c664237ae138e86f96ff46714f15/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=5183c9f08345c664237ae138e86f96ff46714f15", "patch": "@@ -4,7 +4,8 @@ use std::{borrow::Cow, fmt};\n \n use crate::{\n     db::HirDatabase, utils::generics, ApplicationTy, CallableDefId, FnSig, GenericPredicate,\n-    Lifetime, Obligation, OpaqueTy, OpaqueTyId, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n+    Lifetime, Obligation, OpaqueTy, OpaqueTyId, ProjectionTy, Scalar, Substs, TraitRef, Ty,\n+    TypeCtor,\n };\n use arrayvec::ArrayVec;\n use hir_def::{\n@@ -241,10 +242,11 @@ impl HirDisplay for ApplicationTy {\n         }\n \n         match self.ctor {\n-            TypeCtor::Bool => write!(f, \"bool\")?,\n-            TypeCtor::Char => write!(f, \"char\")?,\n-            TypeCtor::Int(t) => write!(f, \"{}\", t)?,\n-            TypeCtor::Float(t) => write!(f, \"{}\", t)?,\n+            TypeCtor::Scalar(Scalar::Bool) => write!(f, \"bool\")?,\n+            TypeCtor::Scalar(Scalar::Char) => write!(f, \"char\")?,\n+            TypeCtor::Scalar(Scalar::Float(t)) => write!(f, \"{}\", t)?,\n+            TypeCtor::Scalar(Scalar::Int(t)) => write!(f, \"{}\", t)?,\n+            TypeCtor::Scalar(Scalar::Uint(t)) => write!(f, \"{}\", t)?,\n             TypeCtor::Str => write!(f, \"str\")?,\n             TypeCtor::Slice => {\n                 let t = self.parameters.as_single();"}, {"sha": "657f011d26a8ba2a41d7c47b560b897025aea5e9", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5183c9f08345c664237ae138e86f96ff46714f15/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5183c9f08345c664237ae138e86f96ff46714f15/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=5183c9f08345c664237ae138e86f96ff46714f15", "patch": "@@ -41,7 +41,7 @@ use super::{\n     InEnvironment, ProjectionTy, Substs, TraitEnvironment, TraitRef, Ty, TypeCtor, TypeWalk,\n };\n use crate::{\n-    db::HirDatabase, infer::diagnostics::InferenceDiagnostic, lower::ImplTraitLoweringMode,\n+    db::HirDatabase, infer::diagnostics::InferenceDiagnostic, lower::ImplTraitLoweringMode, Scalar,\n };\n \n pub(crate) use unify::unify;\n@@ -684,8 +684,8 @@ impl InferTy {\n     fn fallback_value(self) -> Ty {\n         match self {\n             InferTy::TypeVar(..) => Ty::Unknown,\n-            InferTy::IntVar(..) => Ty::simple(TypeCtor::Int(IntTy::i32())),\n-            InferTy::FloatVar(..) => Ty::simple(TypeCtor::Float(FloatTy::f64())),\n+            InferTy::IntVar(..) => Ty::simple(TypeCtor::Scalar(Scalar::Int(IntTy::I32))),\n+            InferTy::FloatVar(..) => Ty::simple(TypeCtor::Scalar(Scalar::Float(FloatTy::F64))),\n             InferTy::MaybeNeverTypeVar(..) => Ty::simple(TypeCtor::Never),\n         }\n     }"}, {"sha": "c25f3f34b2984336821459ee215a469ee0f60bd8", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 46, "deletions": 17, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/5183c9f08345c664237ae138e86f96ff46714f15/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5183c9f08345c664237ae138e86f96ff46714f15/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=5183c9f08345c664237ae138e86f96ff46714f15", "patch": "@@ -4,7 +4,6 @@ use std::iter::{repeat, repeat_with};\n use std::{mem, sync::Arc};\n \n use hir_def::{\n-    builtin_type::Signedness,\n     expr::{Array, BinaryOp, Expr, ExprId, Literal, Statement, UnaryOp},\n     path::{GenericArg, GenericArgs},\n     resolver::resolver_for_expr,\n@@ -16,10 +15,11 @@ use test_utils::mark;\n \n use crate::{\n     autoderef, method_resolution, op,\n+    primitive::UintTy,\n     traits::{FnTrait, InEnvironment},\n     utils::{generics, variant_data, Generics},\n-    ApplicationTy, Binders, CallableDefId, InferTy, IntTy, Mutability, Obligation, OpaqueTyId,\n-    Rawness, Substs, TraitRef, Ty, TypeCtor,\n+    ApplicationTy, Binders, CallableDefId, InferTy, Mutability, Obligation, OpaqueTyId, Rawness,\n+    Scalar, Substs, TraitRef, Ty, TypeCtor,\n };\n \n use super::{\n@@ -120,7 +120,10 @@ impl<'a> InferenceContext<'a> {\n             Expr::Missing => Ty::Unknown,\n             Expr::If { condition, then_branch, else_branch } => {\n                 // if let is desugared to match, so this is always simple if\n-                self.infer_expr(*condition, &Expectation::has_type(Ty::simple(TypeCtor::Bool)));\n+                self.infer_expr(\n+                    *condition,\n+                    &Expectation::has_type(Ty::simple(TypeCtor::Scalar(Scalar::Bool))),\n+                );\n \n                 let condition_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let mut both_arms_diverge = Diverges::Always;\n@@ -203,7 +206,10 @@ impl<'a> InferenceContext<'a> {\n                     label: label.map(|label| self.body[label].name.clone()),\n                 });\n                 // while let is desugared to a match loop, so this is always simple while\n-                self.infer_expr(*condition, &Expectation::has_type(Ty::simple(TypeCtor::Bool)));\n+                self.infer_expr(\n+                    *condition,\n+                    &Expectation::has_type(Ty::simple(TypeCtor::Scalar(Scalar::Bool))),\n+                );\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n                 let _ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n                 // the body may not run, so it diverging doesn't mean we diverge\n@@ -321,7 +327,7 @@ impl<'a> InferenceContext<'a> {\n                     if let Some(guard_expr) = arm.guard {\n                         self.infer_expr(\n                             guard_expr,\n-                            &Expectation::has_type(Ty::simple(TypeCtor::Bool)),\n+                            &Expectation::has_type(Ty::simple(TypeCtor::Scalar(Scalar::Bool))),\n                         );\n                     }\n \n@@ -534,10 +540,13 @@ impl<'a> InferenceContext<'a> {\n                         match &inner_ty {\n                             // Fast path for builtins\n                             Ty::Apply(ApplicationTy {\n-                                ctor: TypeCtor::Int(IntTy { signedness: Signedness::Signed, .. }),\n+                                ctor: TypeCtor::Scalar(Scalar::Int(_)),\n+                                ..\n+                            })\n+                            | Ty::Apply(ApplicationTy {\n+                                ctor: TypeCtor::Scalar(Scalar::Float(_)),\n                                 ..\n                             })\n-                            | Ty::Apply(ApplicationTy { ctor: TypeCtor::Float(_), .. })\n                             | Ty::Infer(InferTy::IntVar(..))\n                             | Ty::Infer(InferTy::FloatVar(..)) => inner_ty,\n                             // Otherwise we resolve via the std::ops::Neg trait\n@@ -548,8 +557,18 @@ impl<'a> InferenceContext<'a> {\n                     UnaryOp::Not => {\n                         match &inner_ty {\n                             // Fast path for builtins\n-                            Ty::Apply(ApplicationTy { ctor: TypeCtor::Bool, .. })\n-                            | Ty::Apply(ApplicationTy { ctor: TypeCtor::Int(_), .. })\n+                            Ty::Apply(ApplicationTy {\n+                                ctor: TypeCtor::Scalar(Scalar::Bool),\n+                                ..\n+                            })\n+                            | Ty::Apply(ApplicationTy {\n+                                ctor: TypeCtor::Scalar(Scalar::Int(_)),\n+                                ..\n+                            })\n+                            | Ty::Apply(ApplicationTy {\n+                                ctor: TypeCtor::Scalar(Scalar::Uint(_)),\n+                                ..\n+                            })\n                             | Ty::Infer(InferTy::IntVar(..)) => inner_ty,\n                             // Otherwise we resolve via the std::ops::Not trait\n                             _ => self\n@@ -561,7 +580,9 @@ impl<'a> InferenceContext<'a> {\n             Expr::BinaryOp { lhs, rhs, op } => match op {\n                 Some(op) => {\n                     let lhs_expectation = match op {\n-                        BinaryOp::LogicOp(..) => Expectation::has_type(Ty::simple(TypeCtor::Bool)),\n+                        BinaryOp::LogicOp(..) => {\n+                            Expectation::has_type(Ty::simple(TypeCtor::Scalar(Scalar::Bool)))\n+                        }\n                         _ => Expectation::none(),\n                     };\n                     let lhs_ty = self.infer_expr(*lhs, &lhs_expectation);\n@@ -688,30 +709,38 @@ impl<'a> InferenceContext<'a> {\n                         );\n                         self.infer_expr(\n                             *repeat,\n-                            &Expectation::has_type(Ty::simple(TypeCtor::Int(IntTy::usize()))),\n+                            &Expectation::has_type(Ty::simple(TypeCtor::Scalar(Scalar::Uint(\n+                                UintTy::Usize,\n+                            )))),\n                         );\n                     }\n                 }\n \n                 Ty::apply_one(TypeCtor::Array, elem_ty)\n             }\n             Expr::Literal(lit) => match lit {\n-                Literal::Bool(..) => Ty::simple(TypeCtor::Bool),\n+                Literal::Bool(..) => Ty::simple(TypeCtor::Scalar(Scalar::Bool)),\n                 Literal::String(..) => {\n                     Ty::apply_one(TypeCtor::Ref(Mutability::Shared), Ty::simple(TypeCtor::Str))\n                 }\n                 Literal::ByteString(..) => {\n-                    let byte_type = Ty::simple(TypeCtor::Int(IntTy::u8()));\n+                    let byte_type = Ty::simple(TypeCtor::Scalar(Scalar::Uint(UintTy::U8)));\n                     let array_type = Ty::apply_one(TypeCtor::Array, byte_type);\n                     Ty::apply_one(TypeCtor::Ref(Mutability::Shared), array_type)\n                 }\n-                Literal::Char(..) => Ty::simple(TypeCtor::Char),\n+                Literal::Char(..) => Ty::simple(TypeCtor::Scalar(Scalar::Char)),\n                 Literal::Int(_v, ty) => match ty {\n-                    Some(int_ty) => Ty::simple(TypeCtor::Int((*int_ty).into())),\n+                    Some(int_ty) => Ty::simple(TypeCtor::Scalar(Scalar::Int((*int_ty).into()))),\n+                    None => self.table.new_integer_var(),\n+                },\n+                Literal::Uint(_v, ty) => match ty {\n+                    Some(int_ty) => Ty::simple(TypeCtor::Scalar(Scalar::Uint((*int_ty).into()))),\n                     None => self.table.new_integer_var(),\n                 },\n                 Literal::Float(_v, ty) => match ty {\n-                    Some(float_ty) => Ty::simple(TypeCtor::Float((*float_ty).into())),\n+                    Some(float_ty) => {\n+                        Ty::simple(TypeCtor::Scalar(Scalar::Float((*float_ty).into())))\n+                    }\n                     None => self.table.new_float_var(),\n                 },\n             },"}, {"sha": "57eb8cede7795e6ef18083703ff93d2717124d9d", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5183c9f08345c664237ae138e86f96ff46714f15/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5183c9f08345c664237ae138e86f96ff46714f15/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=5183c9f08345c664237ae138e86f96ff46714f15", "patch": "@@ -8,8 +8,8 @@ use test_utils::mark;\n \n use super::{InferenceContext, Obligation};\n use crate::{\n-    BoundVar, Canonical, DebruijnIndex, GenericPredicate, InEnvironment, InferTy, Substs, Ty,\n-    TyKind, TypeCtor, TypeWalk,\n+    BoundVar, Canonical, DebruijnIndex, GenericPredicate, InEnvironment, InferTy, Scalar, Substs,\n+    Ty, TyKind, TypeCtor, TypeWalk,\n };\n \n impl<'a> InferenceContext<'a> {\n@@ -300,10 +300,24 @@ impl InferenceTable {\n             | (other, Ty::Infer(InferTy::TypeVar(tv)))\n             | (Ty::Infer(InferTy::MaybeNeverTypeVar(tv)), other)\n             | (other, Ty::Infer(InferTy::MaybeNeverTypeVar(tv)))\n-            | (Ty::Infer(InferTy::IntVar(tv)), other @ ty_app!(TypeCtor::Int(_)))\n-            | (other @ ty_app!(TypeCtor::Int(_)), Ty::Infer(InferTy::IntVar(tv)))\n-            | (Ty::Infer(InferTy::FloatVar(tv)), other @ ty_app!(TypeCtor::Float(_)))\n-            | (other @ ty_app!(TypeCtor::Float(_)), Ty::Infer(InferTy::FloatVar(tv))) => {\n+            | (Ty::Infer(InferTy::IntVar(tv)), other @ ty_app!(TypeCtor::Scalar(Scalar::Int(_))))\n+            | (other @ ty_app!(TypeCtor::Scalar(Scalar::Int(_))), Ty::Infer(InferTy::IntVar(tv)))\n+            | (\n+                Ty::Infer(InferTy::IntVar(tv)),\n+                other @ ty_app!(TypeCtor::Scalar(Scalar::Uint(_))),\n+            )\n+            | (\n+                other @ ty_app!(TypeCtor::Scalar(Scalar::Uint(_))),\n+                Ty::Infer(InferTy::IntVar(tv)),\n+            )\n+            | (\n+                Ty::Infer(InferTy::FloatVar(tv)),\n+                other @ ty_app!(TypeCtor::Scalar(Scalar::Float(_))),\n+            )\n+            | (\n+                other @ ty_app!(TypeCtor::Scalar(Scalar::Float(_))),\n+                Ty::Infer(InferTy::FloatVar(tv)),\n+            ) => {\n                 // the type var is unknown since we tried to resolve it\n                 self.var_unification_table.union_value(*tv, TypeVarValue::Known(other.clone()));\n                 true"}, {"sha": "2a45479a8e71b4286fff834cbe873b67e4667b1d", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 22, "deletions": 29, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/5183c9f08345c664237ae138e86f96ff46714f15/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5183c9f08345c664237ae138e86f96ff46714f15/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=5183c9f08345c664237ae138e86f96ff46714f15", "patch": "@@ -38,7 +38,7 @@ use itertools::Itertools;\n use crate::{\n     db::HirDatabase,\n     display::HirDisplay,\n-    primitive::{FloatTy, IntTy},\n+    primitive::{FloatTy, IntTy, UintTy},\n     utils::{generics, make_mut_slice, Generics},\n };\n \n@@ -58,23 +58,24 @@ pub enum Lifetime {\n     Static,\n }\n \n+/// Types of scalar values.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[allow(missing_docs)]\n+pub enum Scalar {\n+    Bool,\n+    Char,\n+    Int(IntTy),\n+    Uint(UintTy),\n+    Float(FloatTy),\n+}\n+\n /// A type constructor or type name: this might be something like the primitive\n /// type `bool`, a struct like `Vec`, or things like function pointers or\n /// tuples.\n #[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n pub enum TypeCtor {\n-    /// The primitive boolean type. Written as `bool`.\n-    Bool,\n-\n-    /// The primitive character type; holds a Unicode scalar value\n-    /// (a non-surrogate code point). Written as `char`.\n-    Char,\n-\n-    /// A primitive integer type. For example, `i32`.\n-    Int(IntTy),\n-\n-    /// A primitive floating-point type. For example, `f64`.\n-    Float(FloatTy),\n+    /// a scalar type like `bool` or `u32`\n+    Scalar(Scalar),\n \n     /// Structures, enumerations and unions.\n     Adt(AdtId),\n@@ -152,10 +153,7 @@ pub enum TypeCtor {\n impl TypeCtor {\n     pub fn num_ty_params(self, db: &dyn HirDatabase) -> usize {\n         match self {\n-            TypeCtor::Bool\n-            | TypeCtor::Char\n-            | TypeCtor::Int(_)\n-            | TypeCtor::Float(_)\n+            TypeCtor::Scalar(_)\n             | TypeCtor::Str\n             | TypeCtor::Never => 0,\n             TypeCtor::Slice\n@@ -197,10 +195,7 @@ impl TypeCtor {\n \n     pub fn krate(self, db: &dyn HirDatabase) -> Option<CrateId> {\n         match self {\n-            TypeCtor::Bool\n-            | TypeCtor::Char\n-            | TypeCtor::Int(_)\n-            | TypeCtor::Float(_)\n+            TypeCtor::Scalar(_)\n             | TypeCtor::Str\n             | TypeCtor::Never\n             | TypeCtor::Slice\n@@ -232,10 +227,7 @@ impl TypeCtor {\n \n     pub fn as_generic_def(self) -> Option<GenericDefId> {\n         match self {\n-            TypeCtor::Bool\n-            | TypeCtor::Char\n-            | TypeCtor::Int(_)\n-            | TypeCtor::Float(_)\n+            TypeCtor::Scalar(_)\n             | TypeCtor::Str\n             | TypeCtor::Never\n             | TypeCtor::Slice\n@@ -741,11 +733,12 @@ impl Ty {\n     }\n     pub fn builtin(builtin: BuiltinType) -> Self {\n         Ty::simple(match builtin {\n-            BuiltinType::Char => TypeCtor::Char,\n-            BuiltinType::Bool => TypeCtor::Bool,\n+            BuiltinType::Char => TypeCtor::Scalar(Scalar::Char),\n+            BuiltinType::Bool => TypeCtor::Scalar(Scalar::Bool),\n             BuiltinType::Str => TypeCtor::Str,\n-            BuiltinType::Int(t) => TypeCtor::Int(IntTy::from(t).into()),\n-            BuiltinType::Float(t) => TypeCtor::Float(FloatTy::from(t).into()),\n+            BuiltinType::Int(t) => TypeCtor::Scalar(Scalar::Int(t.into())),\n+            BuiltinType::Uint(t) => TypeCtor::Scalar(Scalar::Uint(t.into())),\n+            BuiltinType::Float(t) => TypeCtor::Scalar(Scalar::Float(t.into())),\n         })\n     }\n "}, {"sha": "3c817701d4e6bdeb5122a99d3203cc9557d85d30", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 26, "deletions": 64, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/5183c9f08345c664237ae138e86f96ff46714f15/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5183c9f08345c664237ae138e86f96ff46714f15/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=5183c9f08345c664237ae138e86f96ff46714f15", "patch": "@@ -7,22 +7,19 @@ use std::{iter, sync::Arc};\n use arrayvec::ArrayVec;\n use base_db::CrateId;\n use hir_def::{\n-    builtin_type::{IntBitness, Signedness},\n-    lang_item::LangItemTarget,\n-    type_ref::Mutability,\n-    AssocContainerId, AssocItemId, FunctionId, GenericDefId, HasModule, ImplId, Lookup, ModuleId,\n-    TraitId,\n+    lang_item::LangItemTarget, type_ref::Mutability, AssocContainerId, AssocItemId, FunctionId,\n+    GenericDefId, HasModule, ImplId, Lookup, ModuleId, TraitId,\n };\n use hir_expand::name::Name;\n use rustc_hash::{FxHashMap, FxHashSet};\n \n use crate::{\n     autoderef,\n     db::HirDatabase,\n-    primitive::{FloatBitness, FloatTy, IntTy},\n+    primitive::{FloatTy, IntTy, UintTy},\n     utils::all_super_traits,\n-    ApplicationTy, Canonical, DebruijnIndex, InEnvironment, Substs, TraitEnvironment, TraitRef, Ty,\n-    TyKind, TypeCtor, TypeWalk,\n+    ApplicationTy, Canonical, DebruijnIndex, InEnvironment, Scalar, Substs, TraitEnvironment,\n+    TraitRef, Ty, TyKind, TypeCtor, TypeWalk,\n };\n \n /// This is used as a key for indexing impls.\n@@ -46,59 +43,23 @@ impl TyFingerprint {\n }\n \n pub(crate) const ALL_INT_FPS: [TyFingerprint; 12] = [\n-    TyFingerprint::Apply(TypeCtor::Int(IntTy {\n-        signedness: Signedness::Unsigned,\n-        bitness: IntBitness::X8,\n-    })),\n-    TyFingerprint::Apply(TypeCtor::Int(IntTy {\n-        signedness: Signedness::Unsigned,\n-        bitness: IntBitness::X16,\n-    })),\n-    TyFingerprint::Apply(TypeCtor::Int(IntTy {\n-        signedness: Signedness::Unsigned,\n-        bitness: IntBitness::X32,\n-    })),\n-    TyFingerprint::Apply(TypeCtor::Int(IntTy {\n-        signedness: Signedness::Unsigned,\n-        bitness: IntBitness::X64,\n-    })),\n-    TyFingerprint::Apply(TypeCtor::Int(IntTy {\n-        signedness: Signedness::Unsigned,\n-        bitness: IntBitness::X128,\n-    })),\n-    TyFingerprint::Apply(TypeCtor::Int(IntTy {\n-        signedness: Signedness::Unsigned,\n-        bitness: IntBitness::Xsize,\n-    })),\n-    TyFingerprint::Apply(TypeCtor::Int(IntTy {\n-        signedness: Signedness::Signed,\n-        bitness: IntBitness::X8,\n-    })),\n-    TyFingerprint::Apply(TypeCtor::Int(IntTy {\n-        signedness: Signedness::Signed,\n-        bitness: IntBitness::X16,\n-    })),\n-    TyFingerprint::Apply(TypeCtor::Int(IntTy {\n-        signedness: Signedness::Signed,\n-        bitness: IntBitness::X32,\n-    })),\n-    TyFingerprint::Apply(TypeCtor::Int(IntTy {\n-        signedness: Signedness::Signed,\n-        bitness: IntBitness::X64,\n-    })),\n-    TyFingerprint::Apply(TypeCtor::Int(IntTy {\n-        signedness: Signedness::Signed,\n-        bitness: IntBitness::X128,\n-    })),\n-    TyFingerprint::Apply(TypeCtor::Int(IntTy {\n-        signedness: Signedness::Signed,\n-        bitness: IntBitness::Xsize,\n-    })),\n+    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Int(IntTy::I8))),\n+    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Int(IntTy::I16))),\n+    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Int(IntTy::I32))),\n+    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Int(IntTy::I64))),\n+    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Int(IntTy::I128))),\n+    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Int(IntTy::Isize))),\n+    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Uint(UintTy::U8))),\n+    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Uint(UintTy::U16))),\n+    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Uint(UintTy::U32))),\n+    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Uint(UintTy::U64))),\n+    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Uint(UintTy::U128))),\n+    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Uint(UintTy::Usize))),\n ];\n \n pub(crate) const ALL_FLOAT_FPS: [TyFingerprint; 2] = [\n-    TyFingerprint::Apply(TypeCtor::Float(FloatTy { bitness: FloatBitness::X32 })),\n-    TyFingerprint::Apply(TypeCtor::Float(FloatTy { bitness: FloatBitness::X64 })),\n+    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Float(FloatTy::F32))),\n+    TyFingerprint::Apply(TypeCtor::Scalar(Scalar::Float(FloatTy::F64))),\n ];\n \n /// Trait impls defined or available in some crate.\n@@ -257,14 +218,15 @@ impl Ty {\n                 TypeCtor::ForeignType(type_alias_id) => {\n                     return mod_to_crate_ids(type_alias_id.lookup(db.upcast()).module(db.upcast()));\n                 }\n-                TypeCtor::Bool => lang_item_crate!(\"bool\"),\n-                TypeCtor::Char => lang_item_crate!(\"char\"),\n-                TypeCtor::Float(f) => match f.bitness {\n+                TypeCtor::Scalar(Scalar::Bool) => lang_item_crate!(\"bool\"),\n+                TypeCtor::Scalar(Scalar::Char) => lang_item_crate!(\"char\"),\n+                TypeCtor::Scalar(Scalar::Float(f)) => match f {\n                     // There are two lang items: one in libcore (fXX) and one in libstd (fXX_runtime)\n-                    FloatBitness::X32 => lang_item_crate!(\"f32\", \"f32_runtime\"),\n-                    FloatBitness::X64 => lang_item_crate!(\"f64\", \"f64_runtime\"),\n+                    FloatTy::F32 => lang_item_crate!(\"f32\", \"f32_runtime\"),\n+                    FloatTy::F64 => lang_item_crate!(\"f64\", \"f64_runtime\"),\n                 },\n-                TypeCtor::Int(i) => lang_item_crate!(i.ty_to_string()),\n+                TypeCtor::Scalar(Scalar::Int(t)) => lang_item_crate!(t.ty_to_string()),\n+                TypeCtor::Scalar(Scalar::Uint(t)) => lang_item_crate!(t.ty_to_string()),\n                 TypeCtor::Str => lang_item_crate!(\"str_alloc\", \"str\"),\n                 TypeCtor::Slice => lang_item_crate!(\"slice_alloc\", \"slice\"),\n                 TypeCtor::RawPtr(Mutability::Shared) => lang_item_crate!(\"const_ptr\"),"}, {"sha": "a4999c51d4d4de82d2e473793502550ac2efd3db", "filename": "crates/hir_ty/src/op.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5183c9f08345c664237ae138e86f96ff46714f15/crates%2Fhir_ty%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5183c9f08345c664237ae138e86f96ff46714f15/crates%2Fhir_ty%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fop.rs?ref=5183c9f08345c664237ae138e86f96ff46714f15", "patch": "@@ -2,23 +2,27 @@\n use hir_def::expr::{ArithOp, BinaryOp, CmpOp};\n \n use super::{InferTy, Ty, TypeCtor};\n-use crate::ApplicationTy;\n+use crate::{ApplicationTy, Scalar};\n \n pub(super) fn binary_op_return_ty(op: BinaryOp, lhs_ty: Ty, rhs_ty: Ty) -> Ty {\n     match op {\n-        BinaryOp::LogicOp(_) | BinaryOp::CmpOp(_) => Ty::simple(TypeCtor::Bool),\n+        BinaryOp::LogicOp(_) | BinaryOp::CmpOp(_) => Ty::simple(TypeCtor::Scalar(Scalar::Bool)),\n         BinaryOp::Assignment { .. } => Ty::unit(),\n         BinaryOp::ArithOp(ArithOp::Shl) | BinaryOp::ArithOp(ArithOp::Shr) => match lhs_ty {\n             Ty::Apply(ApplicationTy { ctor, .. }) => match ctor {\n-                TypeCtor::Int(..) | TypeCtor::Float(..) => lhs_ty,\n+                TypeCtor::Scalar(Scalar::Int(_))\n+                | TypeCtor::Scalar(Scalar::Uint(_))\n+                | TypeCtor::Scalar(Scalar::Float(_)) => lhs_ty,\n                 _ => Ty::Unknown,\n             },\n             Ty::Infer(InferTy::IntVar(..)) | Ty::Infer(InferTy::FloatVar(..)) => lhs_ty,\n             _ => Ty::Unknown,\n         },\n         BinaryOp::ArithOp(_) => match rhs_ty {\n             Ty::Apply(ApplicationTy { ctor, .. }) => match ctor {\n-                TypeCtor::Int(..) | TypeCtor::Float(..) => rhs_ty,\n+                TypeCtor::Scalar(Scalar::Int(_))\n+                | TypeCtor::Scalar(Scalar::Uint(_))\n+                | TypeCtor::Scalar(Scalar::Float(_)) => rhs_ty,\n                 _ => Ty::Unknown,\n             },\n             Ty::Infer(InferTy::IntVar(..)) | Ty::Infer(InferTy::FloatVar(..)) => rhs_ty,\n@@ -29,15 +33,11 @@ pub(super) fn binary_op_return_ty(op: BinaryOp, lhs_ty: Ty, rhs_ty: Ty) -> Ty {\n \n pub(super) fn binary_op_rhs_expectation(op: BinaryOp, lhs_ty: Ty) -> Ty {\n     match op {\n-        BinaryOp::LogicOp(..) => Ty::simple(TypeCtor::Bool),\n+        BinaryOp::LogicOp(..) => Ty::simple(TypeCtor::Scalar(Scalar::Bool)),\n         BinaryOp::Assignment { op: None } => lhs_ty,\n         BinaryOp::CmpOp(CmpOp::Eq { .. }) => match lhs_ty {\n             Ty::Apply(ApplicationTy { ctor, .. }) => match ctor {\n-                TypeCtor::Int(..)\n-                | TypeCtor::Float(..)\n-                | TypeCtor::Str\n-                | TypeCtor::Char\n-                | TypeCtor::Bool => lhs_ty,\n+                TypeCtor::Scalar(_) | TypeCtor::Str => lhs_ty,\n                 _ => Ty::Unknown,\n             },\n             Ty::Infer(InferTy::IntVar(..)) | Ty::Infer(InferTy::FloatVar(..)) => lhs_ty,\n@@ -48,7 +48,9 @@ pub(super) fn binary_op_rhs_expectation(op: BinaryOp, lhs_ty: Ty) -> Ty {\n         | BinaryOp::Assignment { op: Some(_) }\n         | BinaryOp::ArithOp(_) => match lhs_ty {\n             Ty::Apply(ApplicationTy { ctor, .. }) => match ctor {\n-                TypeCtor::Int(..) | TypeCtor::Float(..) => lhs_ty,\n+                TypeCtor::Scalar(Scalar::Int(_))\n+                | TypeCtor::Scalar(Scalar::Uint(_))\n+                | TypeCtor::Scalar(Scalar::Float(_)) => lhs_ty,\n                 _ => Ty::Unknown,\n             },\n             Ty::Infer(InferTy::IntVar(..)) | Ty::Infer(InferTy::FloatVar(..)) => lhs_ty,"}, {"sha": "e727c9581cb80cfa22016747cb7d18ad7253dd6c", "filename": "crates/hir_ty/src/primitive.rs", "status": "modified", "additions": 74, "deletions": 83, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/5183c9f08345c664237ae138e86f96ff46714f15/crates%2Fhir_ty%2Fsrc%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5183c9f08345c664237ae138e86f96ff46714f15/crates%2Fhir_ty%2Fsrc%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fprimitive.rs?ref=5183c9f08345c664237ae138e86f96ff46714f15", "patch": "@@ -5,18 +5,28 @@\n \n use std::fmt;\n \n-pub use hir_def::builtin_type::{BuiltinFloat, BuiltinInt, FloatBitness, IntBitness, Signedness};\n-\n-#[derive(Copy, Clone, Eq, PartialEq, Hash)]\n-pub struct IntTy {\n-    pub signedness: Signedness,\n-    pub bitness: IntBitness,\n+pub use hir_def::builtin_type::{BuiltinFloat, BuiltinInt, BuiltinUint};\n+\n+/// Different signed int types.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub enum IntTy {\n+    Isize,\n+    I8,\n+    I16,\n+    I32,\n+    I64,\n+    I128,\n }\n \n-impl fmt::Debug for IntTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(self, f)\n-    }\n+/// Different unsigned int types.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub enum UintTy {\n+    Usize,\n+    U8,\n+    U16,\n+    U32,\n+    U64,\n+    U128,\n }\n \n impl fmt::Display for IntTy {\n@@ -26,75 +36,41 @@ impl fmt::Display for IntTy {\n }\n \n impl IntTy {\n-    pub fn isize() -> IntTy {\n-        IntTy { signedness: Signedness::Signed, bitness: IntBitness::Xsize }\n-    }\n-\n-    pub fn i8() -> IntTy {\n-        IntTy { signedness: Signedness::Signed, bitness: IntBitness::X8 }\n-    }\n-\n-    pub fn i16() -> IntTy {\n-        IntTy { signedness: Signedness::Signed, bitness: IntBitness::X16 }\n-    }\n-\n-    pub fn i32() -> IntTy {\n-        IntTy { signedness: Signedness::Signed, bitness: IntBitness::X32 }\n-    }\n-\n-    pub fn i64() -> IntTy {\n-        IntTy { signedness: Signedness::Signed, bitness: IntBitness::X64 }\n-    }\n-\n-    pub fn i128() -> IntTy {\n-        IntTy { signedness: Signedness::Signed, bitness: IntBitness::X128 }\n-    }\n-\n-    pub fn usize() -> IntTy {\n-        IntTy { signedness: Signedness::Unsigned, bitness: IntBitness::Xsize }\n-    }\n-\n-    pub fn u8() -> IntTy {\n-        IntTy { signedness: Signedness::Unsigned, bitness: IntBitness::X8 }\n-    }\n-\n-    pub fn u16() -> IntTy {\n-        IntTy { signedness: Signedness::Unsigned, bitness: IntBitness::X16 }\n-    }\n-\n-    pub fn u32() -> IntTy {\n-        IntTy { signedness: Signedness::Unsigned, bitness: IntBitness::X32 }\n-    }\n-\n-    pub fn u64() -> IntTy {\n-        IntTy { signedness: Signedness::Unsigned, bitness: IntBitness::X64 }\n+    pub fn ty_to_string(self) -> &'static str {\n+        match self {\n+            IntTy::Isize => \"isize\",\n+            IntTy::I8 => \"i8\",\n+            IntTy::I16 => \"i16\",\n+            IntTy::I32 => \"i32\",\n+            IntTy::I64 => \"i64\",\n+            IntTy::I128 => \"i128\",\n+        }\n     }\n+}\n \n-    pub fn u128() -> IntTy {\n-        IntTy { signedness: Signedness::Unsigned, bitness: IntBitness::X128 }\n+impl fmt::Display for UintTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", self.ty_to_string())\n     }\n+}\n \n+impl UintTy {\n     pub fn ty_to_string(self) -> &'static str {\n-        match (self.signedness, self.bitness) {\n-            (Signedness::Signed, IntBitness::Xsize) => \"isize\",\n-            (Signedness::Signed, IntBitness::X8) => \"i8\",\n-            (Signedness::Signed, IntBitness::X16) => \"i16\",\n-            (Signedness::Signed, IntBitness::X32) => \"i32\",\n-            (Signedness::Signed, IntBitness::X64) => \"i64\",\n-            (Signedness::Signed, IntBitness::X128) => \"i128\",\n-            (Signedness::Unsigned, IntBitness::Xsize) => \"usize\",\n-            (Signedness::Unsigned, IntBitness::X8) => \"u8\",\n-            (Signedness::Unsigned, IntBitness::X16) => \"u16\",\n-            (Signedness::Unsigned, IntBitness::X32) => \"u32\",\n-            (Signedness::Unsigned, IntBitness::X64) => \"u64\",\n-            (Signedness::Unsigned, IntBitness::X128) => \"u128\",\n+        match self {\n+            UintTy::Usize => \"usize\",\n+            UintTy::U8 => \"u8\",\n+            UintTy::U16 => \"u16\",\n+            UintTy::U32 => \"u32\",\n+            UintTy::U64 => \"u64\",\n+            UintTy::U128 => \"u128\",\n         }\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct FloatTy {\n-    pub bitness: FloatBitness,\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub enum FloatTy {\n+    F32,\n+    F64,\n }\n \n impl fmt::Debug for FloatTy {\n@@ -110,30 +86,45 @@ impl fmt::Display for FloatTy {\n }\n \n impl FloatTy {\n-    pub fn f32() -> FloatTy {\n-        FloatTy { bitness: FloatBitness::X32 }\n-    }\n-\n-    pub fn f64() -> FloatTy {\n-        FloatTy { bitness: FloatBitness::X64 }\n-    }\n-\n     pub fn ty_to_string(self) -> &'static str {\n-        match self.bitness {\n-            FloatBitness::X32 => \"f32\",\n-            FloatBitness::X64 => \"f64\",\n+        match self {\n+            FloatTy::F32 => \"f32\",\n+            FloatTy::F64 => \"f64\",\n         }\n     }\n }\n \n impl From<BuiltinInt> for IntTy {\n     fn from(t: BuiltinInt) -> Self {\n-        IntTy { signedness: t.signedness, bitness: t.bitness }\n+        match t {\n+            BuiltinInt::Isize => Self::Isize,\n+            BuiltinInt::I8 => Self::I8,\n+            BuiltinInt::I16 => Self::I16,\n+            BuiltinInt::I32 => Self::I32,\n+            BuiltinInt::I64 => Self::I64,\n+            BuiltinInt::I128 => Self::I128,\n+        }\n+    }\n+}\n+\n+impl From<BuiltinUint> for UintTy {\n+    fn from(t: BuiltinUint) -> Self {\n+        match t {\n+            BuiltinUint::Usize => Self::Usize,\n+            BuiltinUint::U8 => Self::U8,\n+            BuiltinUint::U16 => Self::U16,\n+            BuiltinUint::U32 => Self::U32,\n+            BuiltinUint::U64 => Self::U64,\n+            BuiltinUint::U128 => Self::U128,\n+        }\n     }\n }\n \n impl From<BuiltinFloat> for FloatTy {\n     fn from(t: BuiltinFloat) -> Self {\n-        FloatTy { bitness: t.bitness }\n+        match t {\n+            BuiltinFloat::F32 => Self::F32,\n+            BuiltinFloat::F64 => Self::F64,\n+        }\n     }\n }"}, {"sha": "0e9fc326529c7da71b5482fe80b40c6820b48a4a", "filename": "crates/hir_ty/src/traits/chalk/mapping.rs", "status": "modified", "additions": 60, "deletions": 80, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/5183c9f08345c664237ae138e86f96ff46714f15/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5183c9f08345c664237ae138e86f96ff46714f15/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs?ref=5183c9f08345c664237ae138e86f96ff46714f15", "patch": "@@ -4,7 +4,7 @@\n //! conversions.\n \n use chalk_ir::{\n-    cast::Cast, fold::shift::Shift, interner::HasInterner, LifetimeData, PlaceholderIndex, Scalar,\n+    cast::Cast, fold::shift::Shift, interner::HasInterner, LifetimeData, PlaceholderIndex,\n     UniverseIndex,\n };\n use chalk_solve::rust_ir;\n@@ -14,10 +14,11 @@ use hir_def::{type_ref::Mutability, AssocContainerId, GenericDefId, Lookup, Type\n \n use crate::{\n     db::HirDatabase,\n-    primitive::{FloatBitness, FloatTy, IntBitness, IntTy, Signedness},\n+    primitive::{FloatTy, IntTy, UintTy},\n     traits::{Canonical, Obligation},\n     ApplicationTy, CallableDefId, GenericPredicate, InEnvironment, OpaqueTy, OpaqueTyId,\n-    ProjectionPredicate, ProjectionTy, Substs, TraitEnvironment, TraitRef, Ty, TyKind, TypeCtor,\n+    ProjectionPredicate, ProjectionTy, Scalar, Substs, TraitEnvironment, TraitRef, Ty, TyKind,\n+    TypeCtor,\n };\n \n use super::interner::*;\n@@ -63,19 +64,31 @@ impl ToChalk for Ty {\n                     chalk_ir::TyKind::Foreign(foreign_type_id).intern(&Interner)\n                 }\n \n-                TypeCtor::Bool => chalk_ir::TyKind::Scalar(Scalar::Bool).intern(&Interner),\n-                TypeCtor::Char => chalk_ir::TyKind::Scalar(Scalar::Char).intern(&Interner),\n-                TypeCtor::Int(int_ty) => {\n-                    chalk_ir::TyKind::Scalar(int_ty_to_chalk(int_ty)).intern(&Interner)\n-                }\n-                TypeCtor::Float(FloatTy { bitness: FloatBitness::X32 }) => {\n-                    chalk_ir::TyKind::Scalar(Scalar::Float(chalk_ir::FloatTy::F32))\n-                        .intern(&Interner)\n-                }\n-                TypeCtor::Float(FloatTy { bitness: FloatBitness::X64 }) => {\n-                    chalk_ir::TyKind::Scalar(Scalar::Float(chalk_ir::FloatTy::F64))\n-                        .intern(&Interner)\n-                }\n+                TypeCtor::Scalar(scalar) => chalk_ir::TyKind::Scalar(match scalar {\n+                    Scalar::Bool => chalk_ir::Scalar::Bool,\n+                    Scalar::Char => chalk_ir::Scalar::Char,\n+                    Scalar::Int(it) => chalk_ir::Scalar::Int(match it {\n+                        IntTy::Isize => chalk_ir::IntTy::Isize,\n+                        IntTy::I8 => chalk_ir::IntTy::I8,\n+                        IntTy::I16 => chalk_ir::IntTy::I16,\n+                        IntTy::I32 => chalk_ir::IntTy::I32,\n+                        IntTy::I64 => chalk_ir::IntTy::I64,\n+                        IntTy::I128 => chalk_ir::IntTy::I128,\n+                    }),\n+                    Scalar::Uint(it) => chalk_ir::Scalar::Uint(match it {\n+                        UintTy::Usize => chalk_ir::UintTy::Usize,\n+                        UintTy::U8 => chalk_ir::UintTy::U8,\n+                        UintTy::U16 => chalk_ir::UintTy::U16,\n+                        UintTy::U32 => chalk_ir::UintTy::U32,\n+                        UintTy::U64 => chalk_ir::UintTy::U64,\n+                        UintTy::U128 => chalk_ir::UintTy::U128,\n+                    }),\n+                    Scalar::Float(it) => chalk_ir::Scalar::Float(match it {\n+                        FloatTy::F32 => chalk_ir::FloatTy::F32,\n+                        FloatTy::F64 => chalk_ir::FloatTy::F64,\n+                    }),\n+                })\n+                .intern(&Interner),\n \n                 TypeCtor::Tuple { cardinality } => {\n                     let substitution = apply_ty.parameters.to_chalk(db);\n@@ -219,21 +232,37 @@ impl ToChalk for Ty {\n                 apply_ty_from_chalk(db, TypeCtor::OpaqueType(from_chalk(db, opaque_type_id)), subst)\n             }\n \n-            chalk_ir::TyKind::Scalar(Scalar::Bool) => Ty::simple(TypeCtor::Bool),\n-            chalk_ir::TyKind::Scalar(Scalar::Char) => Ty::simple(TypeCtor::Char),\n-            chalk_ir::TyKind::Scalar(Scalar::Int(int_ty)) => Ty::simple(TypeCtor::Int(IntTy {\n-                signedness: Signedness::Signed,\n-                bitness: bitness_from_chalk_int(int_ty),\n-            })),\n-            chalk_ir::TyKind::Scalar(Scalar::Uint(uint_ty)) => Ty::simple(TypeCtor::Int(IntTy {\n-                signedness: Signedness::Unsigned,\n-                bitness: bitness_from_chalk_uint(uint_ty),\n-            })),\n-            chalk_ir::TyKind::Scalar(Scalar::Float(chalk_ir::FloatTy::F32)) => {\n-                Ty::simple(TypeCtor::Float(FloatTy { bitness: FloatBitness::X32 }))\n+            chalk_ir::TyKind::Scalar(chalk_ir::Scalar::Bool) => {\n+                Ty::simple(TypeCtor::Scalar(Scalar::Bool))\n+            }\n+            chalk_ir::TyKind::Scalar(chalk_ir::Scalar::Char) => {\n+                Ty::simple(TypeCtor::Scalar(Scalar::Char))\n+            }\n+            chalk_ir::TyKind::Scalar(chalk_ir::Scalar::Int(int_ty)) => {\n+                Ty::simple(TypeCtor::Scalar(Scalar::Int(match int_ty {\n+                    chalk_ir::IntTy::Isize => IntTy::Isize,\n+                    chalk_ir::IntTy::I8 => IntTy::I8,\n+                    chalk_ir::IntTy::I16 => IntTy::I16,\n+                    chalk_ir::IntTy::I32 => IntTy::I32,\n+                    chalk_ir::IntTy::I64 => IntTy::I64,\n+                    chalk_ir::IntTy::I128 => IntTy::I128,\n+                })))\n             }\n-            chalk_ir::TyKind::Scalar(Scalar::Float(chalk_ir::FloatTy::F64)) => {\n-                Ty::simple(TypeCtor::Float(FloatTy { bitness: FloatBitness::X64 }))\n+            chalk_ir::TyKind::Scalar(chalk_ir::Scalar::Uint(int_ty)) => {\n+                Ty::simple(TypeCtor::Scalar(Scalar::Uint(match int_ty {\n+                    chalk_ir::UintTy::Usize => UintTy::Usize,\n+                    chalk_ir::UintTy::U8 => UintTy::U8,\n+                    chalk_ir::UintTy::U16 => UintTy::U16,\n+                    chalk_ir::UintTy::U32 => UintTy::U32,\n+                    chalk_ir::UintTy::U64 => UintTy::U64,\n+                    chalk_ir::UintTy::U128 => UintTy::U128,\n+                })))\n+            }\n+            chalk_ir::TyKind::Scalar(chalk_ir::Scalar::Float(float_ty)) => {\n+                Ty::simple(TypeCtor::Scalar(Scalar::Float(match float_ty {\n+                    chalk_ir::FloatTy::F32 => FloatTy::F32,\n+                    chalk_ir::FloatTy::F64 => FloatTy::F64,\n+                })))\n             }\n             chalk_ir::TyKind::Tuple(cardinality, subst) => {\n                 apply_ty_from_chalk(db, TypeCtor::Tuple { cardinality: cardinality as u16 }, subst)\n@@ -293,7 +322,7 @@ fn ref_to_chalk(\n fn array_to_chalk(db: &dyn HirDatabase, subst: Substs) -> chalk_ir::Ty<Interner> {\n     let arg = subst[0].clone().to_chalk(db);\n     let usize_ty =\n-        chalk_ir::TyKind::Scalar(Scalar::Uint(chalk_ir::UintTy::Usize)).intern(&Interner);\n+        chalk_ir::TyKind::Scalar(chalk_ir::Scalar::Uint(chalk_ir::UintTy::Usize)).intern(&Interner);\n     let const_ = chalk_ir::ConstData {\n         ty: usize_ty,\n         value: chalk_ir::ConstValue::Concrete(chalk_ir::ConcreteConst { interned: () }),\n@@ -364,55 +393,6 @@ impl ToChalk for OpaqueTyId {\n     }\n }\n \n-fn bitness_from_chalk_uint(uint_ty: chalk_ir::UintTy) -> IntBitness {\n-    use chalk_ir::UintTy;\n-\n-    match uint_ty {\n-        UintTy::Usize => IntBitness::Xsize,\n-        UintTy::U8 => IntBitness::X8,\n-        UintTy::U16 => IntBitness::X16,\n-        UintTy::U32 => IntBitness::X32,\n-        UintTy::U64 => IntBitness::X64,\n-        UintTy::U128 => IntBitness::X128,\n-    }\n-}\n-\n-fn bitness_from_chalk_int(int_ty: chalk_ir::IntTy) -> IntBitness {\n-    use chalk_ir::IntTy;\n-\n-    match int_ty {\n-        IntTy::Isize => IntBitness::Xsize,\n-        IntTy::I8 => IntBitness::X8,\n-        IntTy::I16 => IntBitness::X16,\n-        IntTy::I32 => IntBitness::X32,\n-        IntTy::I64 => IntBitness::X64,\n-        IntTy::I128 => IntBitness::X128,\n-    }\n-}\n-\n-fn int_ty_to_chalk(int_ty: IntTy) -> Scalar {\n-    use chalk_ir::{IntTy, UintTy};\n-\n-    match int_ty.signedness {\n-        Signedness::Signed => Scalar::Int(match int_ty.bitness {\n-            IntBitness::Xsize => IntTy::Isize,\n-            IntBitness::X8 => IntTy::I8,\n-            IntBitness::X16 => IntTy::I16,\n-            IntBitness::X32 => IntTy::I32,\n-            IntBitness::X64 => IntTy::I64,\n-            IntBitness::X128 => IntTy::I128,\n-        }),\n-        Signedness::Unsigned => Scalar::Uint(match int_ty.bitness {\n-            IntBitness::Xsize => UintTy::Usize,\n-            IntBitness::X8 => UintTy::U8,\n-            IntBitness::X16 => UintTy::U16,\n-            IntBitness::X32 => UintTy::U32,\n-            IntBitness::X64 => UintTy::U64,\n-            IntBitness::X128 => UintTy::U128,\n-        }),\n-    }\n-}\n-\n impl ToChalk for Mutability {\n     type Chalk = chalk_ir::Mutability;\n     fn to_chalk(self, _db: &dyn HirDatabase) -> Self::Chalk {"}]}