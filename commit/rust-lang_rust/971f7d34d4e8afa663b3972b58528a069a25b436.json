{"sha": "971f7d34d4e8afa663b3972b58528a069a25b436", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3MWY3ZDM0ZDRlOGFmYTY2M2IzOTcyYjU4NTI4YTA2OWEyNWI0MzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-27T07:16:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-27T07:16:13Z"}, "message": "Auto merge of #51815 - oli-obk:lowering_cleanups2, r=nikomatsakis\n\nLowering cleanups [2/N]\n\nDouble indirections are unnecessary", "tree": {"sha": "7e34e59abbed7e5e0a20bf79d64f01c85b8bd1a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e34e59abbed7e5e0a20bf79d64f01c85b8bd1a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/971f7d34d4e8afa663b3972b58528a069a25b436", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/971f7d34d4e8afa663b3972b58528a069a25b436", "html_url": "https://github.com/rust-lang/rust/commit/971f7d34d4e8afa663b3972b58528a069a25b436", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/971f7d34d4e8afa663b3972b58528a069a25b436/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "612c28004cba9e8e7bcd7e2a9dcdf2c2736f0e81", "url": "https://api.github.com/repos/rust-lang/rust/commits/612c28004cba9e8e7bcd7e2a9dcdf2c2736f0e81", "html_url": "https://github.com/rust-lang/rust/commit/612c28004cba9e8e7bcd7e2a9dcdf2c2736f0e81"}, {"sha": "e65947d701ec678b149487454d3a7149caca7db0", "url": "https://api.github.com/repos/rust-lang/rust/commits/e65947d701ec678b149487454d3a7149caca7db0", "html_url": "https://github.com/rust-lang/rust/commit/e65947d701ec678b149487454d3a7149caca7db0"}], "stats": {"total": 60, "additions": 32, "deletions": 28}, "files": [{"sha": "a3f86c542836e22c60447f6c8bcbb63331e07492", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/971f7d34d4e8afa663b3972b58528a069a25b436/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/971f7d34d4e8afa663b3972b58528a069a25b436/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=971f7d34d4e8afa663b3972b58528a069a25b436", "patch": "@@ -1074,11 +1074,15 @@ impl<'a> LoweringContext<'a> {\n                         -> hir::GenericArg {\n         match arg {\n             ast::GenericArg::Lifetime(lt) => GenericArg::Lifetime(self.lower_lifetime(&lt)),\n-            ast::GenericArg::Type(ty) => GenericArg::Type(self.lower_ty(&ty, itctx)),\n+            ast::GenericArg::Type(ty) => GenericArg::Type(self.lower_ty_direct(&ty, itctx)),\n         }\n     }\n \n     fn lower_ty(&mut self, t: &Ty, itctx: ImplTraitContext) -> P<hir::Ty> {\n+        P(self.lower_ty_direct(t, itctx))\n+    }\n+\n+    fn lower_ty_direct(&mut self, t: &Ty, itctx: ImplTraitContext) -> hir::Ty {\n         let kind = match t.node {\n             TyKind::Infer => hir::TyInfer,\n             TyKind::Err => hir::TyErr,\n@@ -1115,10 +1119,10 @@ impl<'a> LoweringContext<'a> {\n             ),\n             TyKind::Never => hir::TyNever,\n             TyKind::Tup(ref tys) => {\n-                hir::TyTup(tys.iter().map(|ty| self.lower_ty(ty, itctx)).collect())\n+                hir::TyTup(tys.iter().map(|ty| self.lower_ty_direct(ty, itctx)).collect())\n             }\n             TyKind::Paren(ref ty) => {\n-                return self.lower_ty(ty, itctx);\n+                return self.lower_ty_direct(ty, itctx);\n             }\n             TyKind::Path(ref qself, ref path) => {\n                 let id = self.lower_node_id(t.id);\n@@ -1228,12 +1232,12 @@ impl<'a> LoweringContext<'a> {\n         };\n \n         let LoweredNodeId { node_id, hir_id } = self.lower_node_id(t.id);\n-        P(hir::Ty {\n+        hir::Ty {\n             id: node_id,\n             node: kind,\n             span: t.span,\n             hir_id,\n-        })\n+        }\n     }\n \n     fn lower_existential_impl_trait(\n@@ -1636,7 +1640,7 @@ impl<'a> LoweringContext<'a> {\n             // e.g. `Vec` in `Vec::new` or `<I as Iterator>::Item` in\n             // `<I as Iterator>::Item::default`.\n             let new_id = self.next_id();\n-            self.ty_path(new_id, p.span, hir::QPath::Resolved(qself, path))\n+            P(self.ty_path(new_id, p.span, hir::QPath::Resolved(qself, path)))\n         };\n \n         // Anything after the base path are associated \"extensions\",\n@@ -1667,7 +1671,7 @@ impl<'a> LoweringContext<'a> {\n \n             // Wrap the associated extension in another type node.\n             let new_id = self.next_id();\n-            ty = self.ty_path(new_id, p.span, qpath);\n+            ty = P(self.ty_path(new_id, p.span, qpath));\n         }\n \n         // Should've returned in the for loop above.\n@@ -1802,10 +1806,10 @@ impl<'a> LoweringContext<'a> {\n             |this| {\n                 const DISALLOWED: ImplTraitContext = ImplTraitContext::Disallowed;\n                 let &ParenthesisedArgs { ref inputs, ref output, span } = data;\n-                let inputs = inputs.iter().map(|ty| this.lower_ty(ty, DISALLOWED)).collect();\n+                let inputs = inputs.iter().map(|ty| this.lower_ty_direct(ty, DISALLOWED)).collect();\n                 let mk_tup = |this: &mut Self, tys, span| {\n                     let LoweredNodeId { node_id, hir_id } = this.next_id();\n-                    P(hir::Ty { node: hir::TyTup(tys), id: node_id, hir_id, span })\n+                    hir::Ty { node: hir::TyTup(tys), id: node_id, hir_id, span }\n                 };\n \n                 (\n@@ -1818,7 +1822,7 @@ impl<'a> LoweringContext<'a> {\n                                 ty: output\n                                     .as_ref()\n                                     .map(|ty| this.lower_ty(&ty, DISALLOWED))\n-                                    .unwrap_or_else(|| mk_tup(this, hir::HirVec::new(), span)),\n+                                    .unwrap_or_else(|| P(mk_tup(this, hir::HirVec::new(), span))),\n                                 span: output.as_ref().map_or(span, |ty| ty.span),\n                             }\n                         ],\n@@ -1894,9 +1898,9 @@ impl<'a> LoweringContext<'a> {\n             .iter()\n             .map(|arg| {\n                 if let Some(def_id) = fn_def_id {\n-                    self.lower_ty(&arg.ty, ImplTraitContext::Universal(def_id))\n+                    self.lower_ty_direct(&arg.ty, ImplTraitContext::Universal(def_id))\n                 } else {\n-                    self.lower_ty(&arg.ty, ImplTraitContext::Disallowed)\n+                    self.lower_ty_direct(&arg.ty, ImplTraitContext::Disallowed)\n                 }\n             })\n             .collect::<HirVec<_>>();\n@@ -1936,7 +1940,7 @@ impl<'a> LoweringContext<'a> {\n     // fn_def_id: DefId of the parent function. Used to create child impl trait definition.\n     fn lower_async_fn_ret_ty(\n         &mut self,\n-        inputs: &[P<hir::Ty>],\n+        inputs: &[hir::Ty],\n         output: &FunctionRetTy,\n         fn_def_id: DefId,\n     ) -> hir::FunctionRetTy {\n@@ -3661,7 +3665,7 @@ impl<'a> LoweringContext<'a> {\n                 let e1 = self.lower_expr(e1);\n                 let e2 = self.lower_expr(e2);\n                 let ty_path = P(self.std_path(span, &[\"ops\", \"RangeInclusive\"], None, false));\n-                let ty = self.ty_path(id, span, hir::QPath::Resolved(None, ty_path));\n+                let ty = P(self.ty_path(id, span, hir::QPath::Resolved(None, ty_path)));\n                 let new_seg = P(hir::PathSegment::from_name(Symbol::intern(\"new\")));\n                 let new_path = hir::QPath::TypeRelative(ty, new_seg);\n                 let new = P(self.expr(span, hir::ExprPath(new_path), ThinVec::new()));\n@@ -4549,7 +4553,7 @@ impl<'a> LoweringContext<'a> {\n             .resolve_str_path(span, self.crate_root, components, params, is_value)\n     }\n \n-    fn ty_path(&mut self, id: LoweredNodeId, span: Span, qpath: hir::QPath) -> P<hir::Ty> {\n+    fn ty_path(&mut self, id: LoweredNodeId, span: Span, qpath: hir::QPath) -> hir::Ty {\n         let mut id = id;\n         let node = match qpath {\n             hir::QPath::Resolved(None, path) => {\n@@ -4574,12 +4578,12 @@ impl<'a> LoweringContext<'a> {\n             }\n             _ => hir::TyPath(qpath),\n         };\n-        P(hir::Ty {\n+        hir::Ty {\n             id: id.node_id,\n             hir_id: id.hir_id,\n             node,\n             span,\n-        })\n+        }\n     }\n \n     /// Invoked to create the lifetime argument for a type `&T`"}, {"sha": "68ff74a0e51129860bc09c7d06e044602a9b1f9c", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/971f7d34d4e8afa663b3972b58528a069a25b436/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/971f7d34d4e8afa663b3972b58528a069a25b436/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=971f7d34d4e8afa663b3972b58528a069a25b436", "patch": "@@ -383,7 +383,7 @@ impl PathSegment {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum GenericArg {\n     Lifetime(Lifetime),\n-    Type(P<Ty>),\n+    Type(Ty),\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -412,7 +412,7 @@ impl GenericArgs {\n         self.args.is_empty() && self.bindings.is_empty() && !self.parenthesized\n     }\n \n-    pub fn inputs(&self) -> &[P<Ty>] {\n+    pub fn inputs(&self) -> &[Ty] {\n         if self.parenthesized {\n             for arg in &self.args {\n                 match arg {\n@@ -1658,7 +1658,7 @@ pub enum Ty_ {\n     /// The never type (`!`)\n     TyNever,\n     /// A tuple (`(A, B, C, D,...)`)\n-    TyTup(HirVec<P<Ty>>),\n+    TyTup(HirVec<Ty>),\n     /// A path to a type definition (`module::module::...::Type`), or an\n     /// associated type, e.g. `<Vec<T> as Trait>::Type` or `<T>::Target`.\n     ///\n@@ -1719,7 +1719,7 @@ pub struct Arg {\n /// Represents the header (not the body) of a function declaration\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct FnDecl {\n-    pub inputs: HirVec<P<Ty>>,\n+    pub inputs: HirVec<Ty>,\n     pub output: FunctionRetTy,\n     pub variadic: bool,\n     /// True if this function has an `self`, `&self` or `&mut self` receiver"}, {"sha": "076c3c5f17df892f207cd3a7f704a6675fafa972", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/971f7d34d4e8afa663b3972b58528a069a25b436/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/971f7d34d4e8afa663b3972b58528a069a25b436/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=971f7d34d4e8afa663b3972b58528a069a25b436", "patch": "@@ -1792,7 +1792,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n     fn visit_fn_like_elision(\n         &mut self,\n-        inputs: &'tcx [P<hir::Ty>],\n+        inputs: &'tcx [hir::Ty],\n         output: Option<&'tcx P<hir::Ty>>,\n     ) {\n         debug!(\"visit_fn_like_elision: enter\");"}, {"sha": "e5559b7012dc978145a233602ed09f59f6dbd79b", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/971f7d34d4e8afa663b3972b58528a069a25b436/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/971f7d34d4e8afa663b3972b58528a069a25b436/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=971f7d34d4e8afa663b3972b58528a069a25b436", "patch": "@@ -963,7 +963,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 ..\n             }) => {\n                 (self.tcx.sess.codemap().def_span(span), decl.inputs.iter()\n-                        .map(|arg| match arg.clone().into_inner().node {\n+                        .map(|arg| match arg.clone().node {\n                     hir::TyTup(ref tys) => ArgKind::Tuple(\n                         Some(arg.span),\n                         tys.iter()"}, {"sha": "272819ba2dd96940796d1978b14b8b8a055043b1", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/971f7d34d4e8afa663b3972b58528a069a25b436/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/971f7d34d4e8afa663b3972b58528a069a25b436/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=971f7d34d4e8afa663b3972b58528a069a25b436", "patch": "@@ -263,7 +263,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n                     }));\n                 }\n                 ty::GenericParamDefKind::Type {..} => {\n-                    args.push(hir::GenericArg::Type(P(self.ty_param_to_ty(param.clone()))));\n+                    args.push(hir::GenericArg::Type(self.ty_param_to_ty(param.clone())));\n                 }\n             }\n         }"}, {"sha": "3cc0745b195e696782c040f4c2c478ff14b4ae9c", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/971f7d34d4e8afa663b3972b58528a069a25b436/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/971f7d34d4e8afa663b3972b58528a069a25b436/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=971f7d34d4e8afa663b3972b58528a069a25b436", "patch": "@@ -2150,7 +2150,7 @@ pub struct Arguments {\n     pub values: Vec<Argument>,\n }\n \n-impl<'a> Clean<Arguments> for (&'a [P<hir::Ty>], &'a [Spanned<ast::Name>]) {\n+impl<'a> Clean<Arguments> for (&'a [hir::Ty], &'a [Spanned<ast::Name>]) {\n     fn clean(&self, cx: &DocContext) -> Arguments {\n         Arguments {\n             values: self.0.iter().enumerate().map(|(i, ty)| {\n@@ -2168,7 +2168,7 @@ impl<'a> Clean<Arguments> for (&'a [P<hir::Ty>], &'a [Spanned<ast::Name>]) {\n     }\n }\n \n-impl<'a> Clean<Arguments> for (&'a [P<hir::Ty>], hir::BodyId) {\n+impl<'a> Clean<Arguments> for (&'a [hir::Ty], hir::BodyId) {\n     fn clean(&self, cx: &DocContext) -> Arguments {\n         let body = cx.tcx.hir.body(self.1);\n \n@@ -2184,7 +2184,7 @@ impl<'a> Clean<Arguments> for (&'a [P<hir::Ty>], hir::BodyId) {\n }\n \n impl<'a, A: Copy> Clean<FnDecl> for (&'a hir::FnDecl, A)\n-    where (&'a [P<hir::Ty>], A): Clean<Arguments>\n+    where (&'a [hir::Ty], A): Clean<Arguments>\n {\n     fn clean(&self, cx: &DocContext) -> FnDecl {\n         FnDecl {\n@@ -2926,7 +2926,7 @@ impl Clean<Type> for hir::Ty {\n                                         }\n                                     });\n                                     if let Some(ty) = type_.cloned() {\n-                                        ty_substs.insert(ty_param_def, ty.into_inner().clean(cx));\n+                                        ty_substs.insert(ty_param_def, ty.clean(cx));\n                                     } else if let Some(default) = default.clone() {\n                                         ty_substs.insert(ty_param_def,\n                                                          default.into_inner().clean(cx));"}]}