{"sha": "2ee89144e21c10a95b411ff72235da6e29c04a94", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlZTg5MTQ0ZTIxYzEwYTk1YjQxMWZmNzIyMzVkYTZlMjljMDRhOTQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2020-11-22T14:58:58Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2021-09-17T16:47:48Z"}, "message": "introduce new fallback algorithm\n\nWe now fallback type variables using the following rules:\n\n* Construct a coercion graph `A -> B` where `A` and `B` are unresolved\n  type variables or the `!` type.\n* Let D be those variables that are reachable from `!`.\n* Let N be those variables that are reachable from a variable not in\nD.\n* All variables in (D \\ N) fallback to `!`.\n* All variables in (D & N) fallback to `()`.", "tree": {"sha": "2c639b798247fc8c3c1fc647e72d22aba99b91ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c639b798247fc8c3c1fc647e72d22aba99b91ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ee89144e21c10a95b411ff72235da6e29c04a94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ee89144e21c10a95b411ff72235da6e29c04a94", "html_url": "https://github.com/rust-lang/rust/commit/2ee89144e21c10a95b411ff72235da6e29c04a94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ee89144e21c10a95b411ff72235da6e29c04a94/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0c38af27cb5f6f961809601b717d6afc3b190ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0c38af27cb5f6f961809601b717d6afc3b190ee", "html_url": "https://github.com/rust-lang/rust/commit/e0c38af27cb5f6f961809601b717d6afc3b190ee"}], "stats": {"total": 402, "additions": 347, "deletions": 55}, "files": [{"sha": "7302aa13cc4d8bff5f008343e7f93a07cbc883ba", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2ee89144e21c10a95b411ff72235da6e29c04a94/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ee89144e21c10a95b411ff72235da6e29c04a94/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=2ee89144e21c10a95b411ff72235da6e29c04a94", "patch": "@@ -707,11 +707,17 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// No attempt is made to resolve `ty`.\n     pub fn type_var_diverges(&'a self, ty: Ty<'_>) -> Diverging {\n         match *ty.kind() {\n-            ty::Infer(ty::TyVar(vid)) => self.inner.borrow_mut().type_variables().var_diverges(vid),\n+            ty::Infer(ty::TyVar(vid)) => self.ty_vid_diverges(vid),\n             _ => Diverging::NotDiverging,\n         }\n     }\n \n+    /// Returns true if the type inference variable `vid` was created\n+    /// as a diverging type variable. No attempt is made to resolve `vid`.\n+    pub fn ty_vid_diverges(&'a self, vid: ty::TyVid) -> Diverging {\n+        self.inner.borrow_mut().type_variables().var_diverges(vid)\n+    }\n+\n     /// Returns the origin of the type variable identified by `vid`, or `None`\n     /// if this is not a type variable.\n     ///\n@@ -1070,6 +1076,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         })\n     }\n \n+    /// Number of type variables created so far.\n+    pub fn num_ty_vars(&self) -> usize {\n+        self.inner.borrow_mut().type_variables().num_vars()\n+    }\n+\n     pub fn next_ty_var_id(&self, diverging: Diverging, origin: TypeVariableOrigin) -> TyVid {\n         self.inner.borrow_mut().type_variables().new_var(self.universe(), diverging, origin)\n     }"}, {"sha": "1e17ba204b2c7ff2fc0548e9d0dda3532e0deb04", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ee89144e21c10a95b411ff72235da6e29c04a94/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ee89144e21c10a95b411ff72235da6e29c04a94/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=2ee89144e21c10a95b411ff72235da6e29c04a94", "patch": "@@ -1672,6 +1672,14 @@ impl<'tcx> TyS<'tcx> {\n         matches!(self.kind(), Infer(TyVar(_)))\n     }\n \n+    #[inline]\n+    pub fn ty_vid(&self) -> Option<ty::TyVid> {\n+        match self.kind() {\n+            &Infer(TyVar(vid)) => Some(vid),\n+            _ => None,\n+        }\n+    }\n+\n     #[inline]\n     pub fn is_ty_infer(&self) -> bool {\n         matches!(self.kind(), Infer(_))"}, {"sha": "2866cd987587aca82a3e3958aab4d256e0b66ba9", "filename": "compiler/rustc_typeck/src/check/fallback.rs", "status": "modified", "additions": 244, "deletions": 35, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/2ee89144e21c10a95b411ff72235da6e29c04a94/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ee89144e21c10a95b411ff72235da6e29c04a94/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs?ref=2ee89144e21c10a95b411ff72235da6e29c04a94", "patch": "@@ -1,4 +1,7 @@\n use crate::check::FnCtxt;\n+use rustc_data_structures::{\n+    fx::FxHashMap, graph::vec_graph::VecGraph, graph::WithSuccessors, stable_set::FxHashSet,\n+};\n use rustc_infer::infer::type_variable::Diverging;\n use rustc_middle::ty::{self, Ty};\n \n@@ -8,22 +11,30 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n     pub(super) fn type_inference_fallback(&self) -> bool {\n         // All type checking constraints were added, try to fallback unsolved variables.\n         self.select_obligations_where_possible(false, |_| {});\n-        let mut fallback_has_occurred = false;\n \n+        // Check if we have any unsolved varibales. If not, no need for fallback.\n+        let unsolved_variables = self.unsolved_variables();\n+        if unsolved_variables.is_empty() {\n+            return false;\n+        }\n+\n+        let diverging_fallback = self.calculate_diverging_fallback(&unsolved_variables);\n+\n+        let mut fallback_has_occurred = false;\n         // We do fallback in two passes, to try to generate\n         // better error messages.\n         // The first time, we do *not* replace opaque types.\n-        for ty in &self.unsolved_variables() {\n+        for ty in unsolved_variables {\n             debug!(\"unsolved_variable = {:?}\", ty);\n-            fallback_has_occurred |= self.fallback_if_possible(ty);\n+            fallback_has_occurred |= self.fallback_if_possible(ty, &diverging_fallback);\n         }\n \n-        // We now see if we can make progress. This might\n-        // cause us to unify inference variables for opaque types,\n-        // since we may have unified some other type variables\n-        // during the first phase of fallback.\n-        // This means that we only replace inference variables with their underlying\n-        // opaque types as a last resort.\n+        // We now see if we can make progress. This might cause us to\n+        // unify inference variables for opaque types, since we may\n+        // have unified some other type variables during the first\n+        // phase of fallback.  This means that we only replace\n+        // inference variables with their underlying opaque types as a\n+        // last resort.\n         //\n         // In code like this:\n         //\n@@ -62,36 +73,44 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n     //\n     // - Unconstrained floats are replaced with with `f64`.\n     //\n-    // - Non-numerics get replaced with `!` when `#![feature(never_type_fallback)]`\n-    //   is enabled. Otherwise, they are replaced with `()`.\n+    // - Non-numerics may get replaced with `()` or `!`, depending on\n+    //   how they were categorized by `calculate_diverging_fallback`\n+    //   (and the setting of `#![feature(never_type_fallback)]`).\n+    //\n+    // Fallback becomes very dubious if we have encountered\n+    // type-checking errors.  In that case, fallback to Error.\n     //\n-    // Fallback becomes very dubious if we have encountered type-checking errors.\n-    // In that case, fallback to Error.\n     // The return value indicates whether fallback has occurred.\n-    fn fallback_if_possible(&self, ty: Ty<'tcx>) -> bool {\n+    fn fallback_if_possible(\n+        &self,\n+        ty: Ty<'tcx>,\n+        diverging_fallback: &FxHashMap<Ty<'tcx>, Ty<'tcx>>,\n+    ) -> bool {\n         // Careful: we do NOT shallow-resolve `ty`. We know that `ty`\n-        // is an unsolved variable, and we determine its fallback based\n-        // solely on how it was created, not what other type variables\n-        // it may have been unified with since then.\n+        // is an unsolved variable, and we determine its fallback\n+        // based solely on how it was created, not what other type\n+        // variables it may have been unified with since then.\n         //\n-        // The reason this matters is that other attempts at fallback may\n-        // (in principle) conflict with this fallback, and we wish to generate\n-        // a type error in that case. (However, this actually isn't true right now,\n-        // because we're only using the builtin fallback rules. This would be\n-        // true if we were using user-supplied fallbacks. But it's still useful\n-        // to write the code to detect bugs.)\n+        // The reason this matters is that other attempts at fallback\n+        // may (in principle) conflict with this fallback, and we wish\n+        // to generate a type error in that case. (However, this\n+        // actually isn't true right now, because we're only using the\n+        // builtin fallback rules. This would be true if we were using\n+        // user-supplied fallbacks. But it's still useful to write the\n+        // code to detect bugs.)\n         //\n-        // (Note though that if we have a general type variable `?T` that is then unified\n-        // with an integer type variable `?I` that ultimately never gets\n-        // resolved to a special integral type, `?T` is not considered unsolved,\n-        // but `?I` is. The same is true for float variables.)\n+        // (Note though that if we have a general type variable `?T`\n+        // that is then unified with an integer type variable `?I`\n+        // that ultimately never gets resolved to a special integral\n+        // type, `?T` is not considered unsolved, but `?I` is. The\n+        // same is true for float variables.)\n         let fallback = match ty.kind() {\n             _ if self.is_tainted_by_errors() => self.tcx.ty_error(),\n             ty::Infer(ty::IntVar(_)) => self.tcx.types.i32,\n             ty::Infer(ty::FloatVar(_)) => self.tcx.types.f64,\n-            _ => match self.type_var_diverges(ty) {\n-                Diverging::Diverges => self.tcx.mk_diverging_default(),\n-                Diverging::NotDiverging => return false,\n+            _ => match diverging_fallback.get(&ty) {\n+                Some(&fallback_ty) => fallback_ty,\n+                None => return false,\n             },\n         };\n         debug!(\"fallback_if_possible(ty={:?}): defaulting to `{:?}`\", ty, fallback);\n@@ -105,11 +124,10 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         true\n     }\n \n-    /// Second round of fallback: Unconstrained type variables\n-    /// created from the instantiation of an opaque\n-    /// type fall back to the opaque type itself. This is a\n-    /// somewhat incomplete attempt to manage \"identity passthrough\"\n-    /// for `impl Trait` types.\n+    /// Second round of fallback: Unconstrained type variables created\n+    /// from the instantiation of an opaque type fall back to the\n+    /// opaque type itself. This is a somewhat incomplete attempt to\n+    /// manage \"identity passthrough\" for `impl Trait` types.\n     ///\n     /// For example, in this code:\n     ///\n@@ -158,4 +176,195 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n             return false;\n         }\n     }\n+\n+    /// The \"diverging fallback\" system is rather complicated. This is\n+    /// a result of our need to balance 'do the right thing' with\n+    /// backwards compatibility.\n+    ///\n+    /// \"Diverging\" type variables are variables created when we\n+    /// coerce a `!` type into an unbound type variable `?X`. If they\n+    /// never wind up being constrained, the \"right and natural\" thing\n+    /// is that `?X` should \"fallback\" to `!`. This means that e.g. an\n+    /// expression like `Some(return)` will ultimately wind up with a\n+    /// type like `Option<!>` (presuming it is not assigned or\n+    /// constrained to have some other type).\n+    ///\n+    /// However, the fallback used to be `()` (before the `!` type was\n+    /// added).  Moreover, there are cases where the `!` type 'leaks\n+    /// out' from dead code into type variables that affect live\n+    /// code. The most common case is something like this:\n+    ///\n+    /// ```rust\n+    /// match foo() {\n+    ///     22 => Default::default(), // call this type `?D`\n+    ///     _ => return, // return has type `!`\n+    /// } // call the type of this match `?M`\n+    /// ```\n+    ///\n+    /// Here, coercing the type `!` into `?M` will create a diverging\n+    /// type variable `?X` where `?X <: ?M`.  We also have that `?D <:\n+    /// ?M`. If `?M` winds up unconstrained, then `?X` will\n+    /// fallback. If it falls back to `!`, then all the type variables\n+    /// will wind up equal to `!` -- this includes the type `?D`\n+    /// (since `!` doesn't implement `Default`, we wind up a \"trait\n+    /// not implemented\" error in code like this). But since the\n+    /// original fallback was `()`, this code used to compile with `?D\n+    /// = ()`. This is somewhat surprising, since `Default::default()`\n+    /// on its own would give an error because the types are\n+    /// insufficiently constrained.\n+    ///\n+    /// Our solution to this dilemma is to modify diverging variables\n+    /// so that they can *either* fallback to `!` (the default) or to\n+    /// `()` (the backwards compatibility case). We decide which\n+    /// fallback to use based on whether there is a coercion pattern\n+    /// like this:\n+    ///\n+    /// ```\n+    /// ?Diverging -> ?V\n+    /// ?NonDiverging -> ?V\n+    /// ?V != ?NonDiverging\n+    /// ```\n+    ///\n+    /// Here `?Diverging` represents some diverging type variable and\n+    /// `?NonDiverging` represents some non-diverging type\n+    /// variable. `?V` can be any type variable (diverging or not), so\n+    /// long as it is not equal to `?NonDiverging`.\n+    ///\n+    /// Intuitively, what we are looking for is a case where a\n+    /// \"non-diverging\" type variable (like `?M` in our example above)\n+    /// is coerced *into* some variable `?V` that would otherwise\n+    /// fallback to `!`. In that case, we make `?V` fallback to `!`,\n+    /// along with anything that would flow into `?V`.\n+    ///\n+    /// The algorithm we use:\n+    /// * Identify all variables that are coerced *into* by a\n+    ///   diverging variable.  Do this by iterating over each\n+    ///   diverging, unsolved variable and finding all variables\n+    ///   reachable from there. Call that set `D`.\n+    /// * Walk over all unsolved, non-diverging variables, and find\n+    ///   any variable that has an edge into `D`.\n+    fn calculate_diverging_fallback(\n+        &self,\n+        unsolved_variables: &[Ty<'tcx>],\n+    ) -> FxHashMap<Ty<'tcx>, Ty<'tcx>> {\n+        debug!(\"calculate_diverging_fallback({:?})\", unsolved_variables);\n+\n+        // Construct a coercion graph where an edge `A -> B` indicates\n+        // a type variable is that is coerced\n+        let coercion_graph = self.create_coercion_graph();\n+\n+        // Extract the unsolved type inference variable vids; note that some\n+        // unsolved variables are integer/float variables and are excluded.\n+        let unsolved_vids: Vec<_> =\n+            unsolved_variables.iter().filter_map(|ty| ty.ty_vid()).collect();\n+\n+        // Find all type variables that are reachable from a diverging\n+        // type variable. These will typically default to `!`, unless\n+        // we find later that they are *also* reachable from some\n+        // other type variable outside this set.\n+        let mut roots_reachable_from_diverging = FxHashSet::default();\n+        let mut diverging_vids = vec![];\n+        let mut non_diverging_vids = vec![];\n+        for &unsolved_vid in &unsolved_vids {\n+            debug!(\n+                \"calculate_diverging_fallback: unsolved_vid={:?} diverges={:?}\",\n+                unsolved_vid,\n+                self.infcx.ty_vid_diverges(unsolved_vid)\n+            );\n+            match self.infcx.ty_vid_diverges(unsolved_vid) {\n+                Diverging::Diverges => {\n+                    diverging_vids.push(unsolved_vid);\n+                    let root_vid = self.infcx.root_var(unsolved_vid);\n+                    debug!(\n+                        \"calculate_diverging_fallback: root_vid={:?} reaches {:?}\",\n+                        root_vid,\n+                        coercion_graph.depth_first_search(root_vid).collect::<Vec<_>>()\n+                    );\n+                    roots_reachable_from_diverging\n+                        .extend(coercion_graph.depth_first_search(root_vid));\n+                }\n+                Diverging::NotDiverging => {\n+                    non_diverging_vids.push(unsolved_vid);\n+                }\n+            }\n+        }\n+        debug!(\n+            \"calculate_diverging_fallback: roots_reachable_from_diverging={:?}\",\n+            roots_reachable_from_diverging,\n+        );\n+\n+        // Find all type variables N0 that are not reachable from a\n+        // diverging variable, and then compute the set reachable from\n+        // N0, which we call N. These are the *non-diverging* type\n+        // variables. (Note that this set consists of \"root variables\".)\n+        let mut roots_reachable_from_non_diverging = FxHashSet::default();\n+        for &non_diverging_vid in &non_diverging_vids {\n+            let root_vid = self.infcx.root_var(non_diverging_vid);\n+            if roots_reachable_from_diverging.contains(&root_vid) {\n+                continue;\n+            }\n+            roots_reachable_from_non_diverging.extend(coercion_graph.depth_first_search(root_vid));\n+        }\n+        debug!(\n+            \"calculate_diverging_fallback: roots_reachable_from_non_diverging={:?}\",\n+            roots_reachable_from_non_diverging,\n+        );\n+\n+        // For each diverging variable, figure out whether it can\n+        // reach a member of N. If so, it falls back to `()`. Else\n+        // `!`.\n+        let mut diverging_fallback = FxHashMap::default();\n+        for &diverging_vid in &diverging_vids {\n+            let diverging_ty = self.tcx.mk_ty_var(diverging_vid);\n+            let root_vid = self.infcx.root_var(diverging_vid);\n+            let can_reach_non_diverging = coercion_graph\n+                .depth_first_search(root_vid)\n+                .any(|n| roots_reachable_from_non_diverging.contains(&n));\n+            if can_reach_non_diverging {\n+                debug!(\"fallback to (): {:?}\", diverging_vid);\n+                diverging_fallback.insert(diverging_ty, self.tcx.types.unit);\n+            } else {\n+                debug!(\"fallback to !: {:?}\", diverging_vid);\n+                diverging_fallback.insert(diverging_ty, self.tcx.mk_diverging_default());\n+            }\n+        }\n+\n+        diverging_fallback\n+    }\n+\n+    /// Returns a graph whose nodes are (unresolved) inference variables and where\n+    /// an edge `?A -> ?B` indicates that the variable `?A` is coerced to `?B`.\n+    fn create_coercion_graph(&self) -> VecGraph<ty::TyVid> {\n+        let pending_obligations = self.fulfillment_cx.borrow_mut().pending_obligations();\n+        debug!(\"create_coercion_graph: pending_obligations={:?}\", pending_obligations);\n+        let coercion_edges: Vec<(ty::TyVid, ty::TyVid)> = pending_obligations\n+            .into_iter()\n+            .filter_map(|obligation| {\n+                // The predicates we are looking for look like `Coerce(?A -> ?B)`.\n+                // They will have no bound variables.\n+                obligation.predicate.kind().no_bound_vars()\n+            })\n+            .filter_map(|atom| {\n+                if let ty::PredicateKind::Coerce(ty::CoercePredicate { a, b }) = atom {\n+                    let a_vid = self.root_vid(a)?;\n+                    let b_vid = self.root_vid(b)?;\n+                    Some((a_vid, b_vid))\n+                } else {\n+                    return None;\n+                };\n+\n+                let a_vid = self.root_vid(a)?;\n+                let b_vid = self.root_vid(b)?;\n+                Some((a_vid, b_vid))\n+            })\n+            .collect();\n+        debug!(\"create_coercion_graph: coercion_edges={:?}\", coercion_edges);\n+        let num_ty_vars = self.infcx.num_ty_vars();\n+        VecGraph::new(num_ty_vars, coercion_edges)\n+    }\n+\n+    /// If `ty` is an unresolved type variable, returns its root vid.\n+    fn root_vid(&self, ty: Ty<'tcx>) -> Option<ty::TyVid> {\n+        Some(self.infcx.root_var(self.infcx.shallow_resolve(ty).ty_vid()?))\n+    }\n }"}, {"sha": "f323f40ba31c64f1265652d91a50ffea39fd76a7", "filename": "src/test/ui/never_type/diverging-fallback-control-flow.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2ee89144e21c10a95b411ff72235da6e29c04a94/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-control-flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ee89144e21c10a95b411ff72235da6e29c04a94/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-control-flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-control-flow.rs?ref=2ee89144e21c10a95b411ff72235da6e29c04a94", "patch": "@@ -4,27 +4,24 @@\n #![allow(unused_assignments)]\n #![allow(unused_variables)]\n #![allow(unreachable_code)]\n-\n // Test various cases where we permit an unconstrained variable\n-// to fallback based on control-flow.\n-//\n-// These represent current behavior, but are pretty dubious.  I would\n-// like to revisit these and potentially change them. --nmatsakis\n-\n+// to fallback based on control-flow. In all of these cases,\n+// the type variable winds up being the target of both a `!` coercion\n+// and a coercion from a non-`!` variable, and hence falls back to `()`.\n #![feature(never_type, never_type_fallback)]\n \n-trait BadDefault {\n+trait UnitDefault {\n     fn default() -> Self;\n }\n \n-impl BadDefault for u32 {\n+impl UnitDefault for u32 {\n     fn default() -> Self {\n         0\n     }\n }\n \n-impl BadDefault for ! {\n-    fn default() -> ! {\n+impl UnitDefault for () {\n+    fn default() -> () {\n         panic!()\n     }\n }\n@@ -33,7 +30,7 @@ fn assignment() {\n     let x;\n \n     if true {\n-        x = BadDefault::default();\n+        x = UnitDefault::default();\n     } else {\n         x = return;\n     }\n@@ -45,13 +42,13 @@ fn assignment_rev() {\n     if true {\n         x = return;\n     } else {\n-        x = BadDefault::default();\n+        x = UnitDefault::default();\n     }\n }\n \n fn if_then_else() {\n     let _x = if true {\n-        BadDefault::default()\n+        UnitDefault::default()\n     } else {\n         return;\n     };\n@@ -61,19 +58,19 @@ fn if_then_else_rev() {\n     let _x = if true {\n         return;\n     } else {\n-        BadDefault::default()\n+        UnitDefault::default()\n     };\n }\n \n fn match_arm() {\n-    let _x = match Ok(BadDefault::default()) {\n+    let _x = match Ok(UnitDefault::default()) {\n         Ok(v) => v,\n         Err(()) => return,\n     };\n }\n \n fn match_arm_rev() {\n-    let _x = match Ok(BadDefault::default()) {\n+    let _x = match Ok(UnitDefault::default()) {\n         Err(()) => return,\n         Ok(v) => v,\n     };\n@@ -84,7 +81,7 @@ fn loop_break() {\n         if false {\n             break return;\n         } else {\n-            break BadDefault::default();\n+            break UnitDefault::default();\n         }\n     };\n }\n@@ -94,9 +91,9 @@ fn loop_break_rev() {\n         if false {\n             break return;\n         } else {\n-            break BadDefault::default();\n+            break UnitDefault::default();\n         }\n     };\n }\n \n-fn main() { }\n+fn main() {}"}, {"sha": "a3a15f0ed885dec684e51dd2a10a8daf3b3df7fd", "filename": "src/test/ui/never_type/diverging-fallback-no-leak.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2ee89144e21c10a95b411ff72235da6e29c04a94/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-no-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ee89144e21c10a95b411ff72235da6e29c04a94/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-no-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-no-leak.rs?ref=2ee89144e21c10a95b411ff72235da6e29c04a94", "patch": "@@ -0,0 +1,15 @@\n+#![feature(never_type_fallback)]\n+\n+fn make_unit() {}\n+\n+trait Test {}\n+impl Test for i32 {}\n+impl Test for () {}\n+\n+fn unconstrained_arg<T: Test>(_: T) {}\n+\n+fn main() {\n+    // Here the type variable falls back to `!`,\n+    // and hence we get a type error:\n+    unconstrained_arg(return); //~ ERROR trait bound `!: Test` is not satisfied\n+}"}, {"sha": "27615fe4e77eb804b1b56a01befe2a0abec65a49", "filename": "src/test/ui/never_type/diverging-fallback-no-leak.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2ee89144e21c10a95b411ff72235da6e29c04a94/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-no-leak.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2ee89144e21c10a95b411ff72235da6e29c04a94/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-no-leak.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-no-leak.stderr?ref=2ee89144e21c10a95b411ff72235da6e29c04a94", "patch": "@@ -0,0 +1,18 @@\n+error[E0277]: the trait bound `!: Test` is not satisfied\n+  --> $DIR/diverging-fallback-no-leak.rs:14:5\n+   |\n+LL |     unconstrained_arg(return);\n+   |     ^^^^^^^^^^^^^^^^^ the trait `Test` is not implemented for `!`\n+   |\n+   = note: this trait is implemented for `()`.\n+   = note: this error might have been caused by changes to Rust's type-inference algorithm (see issue #48950 <https://github.com/rust-lang/rust/issues/48950> for more information).\n+   = help: did you intend to use the type `()` here instead?\n+note: required by a bound in `unconstrained_arg`\n+  --> $DIR/diverging-fallback-no-leak.rs:9:25\n+   |\n+LL | fn unconstrained_arg<T: Test>(_: T) {}\n+   |                         ^^^^ required by this bound in `unconstrained_arg`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "9a6c965cefb09d36654eea6ad9f7c93b8dd26e49", "filename": "src/test/ui/never_type/diverging-fallback-unconstrained-return.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2ee89144e21c10a95b411ff72235da6e29c04a94/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-unconstrained-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ee89144e21c10a95b411ff72235da6e29c04a94/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-unconstrained-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-unconstrained-return.rs?ref=2ee89144e21c10a95b411ff72235da6e29c04a94", "patch": "@@ -0,0 +1,34 @@\n+// Variant of diverging-falllback-control-flow that tests\n+// the specific case of a free function with an unconstrained\n+// return type. This captures the pattern we saw in the wild\n+// in the objc crate, where changing the fallback from `!` to `()`\n+// resulted in unsoundness.\n+//\n+// check-pass\n+\n+#![feature(never_type_fallback)]\n+\n+fn make_unit() {}\n+\n+trait UnitReturn {}\n+impl UnitReturn for i32 {}\n+impl UnitReturn for () {}\n+\n+fn unconstrained_return<T: UnitReturn>() -> T {\n+    unsafe {\n+        let make_unit_fn: fn() = make_unit;\n+        let ffi: fn() -> T = std::mem::transmute(make_unit_fn);\n+        ffi()\n+    }\n+}\n+\n+fn main() {\n+    // In Ye Olde Days, the `T` parameter of `unconstrained_return`\n+    // winds up \"entangled\" with the `!` type that results from\n+    // `panic!`, and hence falls back to `()`. This is kind of unfortunate\n+    // and unexpected. When we introduced the `!` type, the original\n+    // idea was to change that fallback to `!`, but that would have resulted\n+    // in this code no longer compiling (or worse, in some cases it injected\n+    // unsound results).\n+    let _ = if true { unconstrained_return() } else { panic!() };\n+}"}]}