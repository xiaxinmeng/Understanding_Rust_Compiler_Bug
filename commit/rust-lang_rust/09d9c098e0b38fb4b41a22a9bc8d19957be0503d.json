{"sha": "09d9c098e0b38fb4b41a22a9bc8d19957be0503d", "node_id": "C_kwDOAAsO6NoAKDA5ZDljMDk4ZTBiMzhmYjRiNDFhMjJhOWJjOGQxOTk1N2JlMDUwM2Q", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-11-20T21:33:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-11-20T21:33:48Z"}, "message": "Rollup merge of #89741 - sdroege:arc-rc-from-inner-unsafe, r=Mark-Simulacrum\n\nMark `Arc::from_inner` / `Rc::from_inner` as unsafe\n\nWhile it's an internal function, it is easy to create invalid Arc/Rcs to\na dangling pointer with it.\n\nFixes https://github.com/rust-lang/rust/issues/89740", "tree": {"sha": "ef06cddb6ef5d9c082add7c38e043ea334d03cca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef06cddb6ef5d9c082add7c38e043ea334d03cca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09d9c098e0b38fb4b41a22a9bc8d19957be0503d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhmWm8CRBK7hj4Ov3rIwAAcxEIAKaj2b08+uo0uryaz+3VSeHl\nknSCcE0gwQp2u7KYM7QMSr0LINdzzPCvRNjNRTQCt+/ZGvm+mUrMRyCSaHXmSvTa\n/mu/Dwdo1wA1SHGzZBirRq9FnLSP3L5PCZSopW2JO9FRwqAIhf5i+wfukdbEVNfG\n8bHUEGbX1N96If/9fEWQ3Ajhop4RInr1qD4gmwsc7OXK5yFduNX06lCe0FcgnnFo\n2Voe2fbddLZX1CcUH8w4YhIWzn033K/KhEbRhzIszzw7zvGM3onaRMJj0xThd9Ys\nW/XpJqeJCLiAfAx9BtlrEgTuOjDsZzQfc4HoRSORbzPQeeUuOFEKMhn3aolBhBQ=\n=CPJ1\n-----END PGP SIGNATURE-----\n", "payload": "tree ef06cddb6ef5d9c082add7c38e043ea334d03cca\nparent 93542a8240c5f926ac5f3f99cef99366082f9c2b\nparent 2e2c38e59be7d0308c8a58c0843e7af8d7211ee7\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1637444028 +0100\ncommitter GitHub <noreply@github.com> 1637444028 +0100\n\nRollup merge of #89741 - sdroege:arc-rc-from-inner-unsafe, r=Mark-Simulacrum\n\nMark `Arc::from_inner` / `Rc::from_inner` as unsafe\n\nWhile it's an internal function, it is easy to create invalid Arc/Rcs to\na dangling pointer with it.\n\nFixes https://github.com/rust-lang/rust/issues/89740\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09d9c098e0b38fb4b41a22a9bc8d19957be0503d", "html_url": "https://github.com/rust-lang/rust/commit/09d9c098e0b38fb4b41a22a9bc8d19957be0503d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09d9c098e0b38fb4b41a22a9bc8d19957be0503d/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93542a8240c5f926ac5f3f99cef99366082f9c2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/93542a8240c5f926ac5f3f99cef99366082f9c2b", "html_url": "https://github.com/rust-lang/rust/commit/93542a8240c5f926ac5f3f99cef99366082f9c2b"}, {"sha": "2e2c38e59be7d0308c8a58c0843e7af8d7211ee7", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e2c38e59be7d0308c8a58c0843e7af8d7211ee7", "html_url": "https://github.com/rust-lang/rust/commit/2e2c38e59be7d0308c8a58c0843e7af8d7211ee7"}], "stats": {"total": 77, "additions": 45, "deletions": 32}, "files": [{"sha": "c4e5e44fec0b2df34fd417e65acebdcab582b15d", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/09d9c098e0b38fb4b41a22a9bc8d19957be0503d/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d9c098e0b38fb4b41a22a9bc8d19957be0503d/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=09d9c098e0b38fb4b41a22a9bc8d19957be0503d", "patch": "@@ -341,12 +341,12 @@ impl<T: ?Sized> Rc<T> {\n         unsafe { self.ptr.as_ref() }\n     }\n \n-    fn from_inner(ptr: NonNull<RcBox<T>>) -> Self {\n+    unsafe fn from_inner(ptr: NonNull<RcBox<T>>) -> Self {\n         Self { ptr, phantom: PhantomData }\n     }\n \n     unsafe fn from_ptr(ptr: *mut RcBox<T>) -> Self {\n-        Self::from_inner(unsafe { NonNull::new_unchecked(ptr) })\n+        unsafe { Self::from_inner(NonNull::new_unchecked(ptr)) }\n     }\n }\n \n@@ -367,9 +367,11 @@ impl<T> Rc<T> {\n         // pointers, which ensures that the weak destructor never frees\n         // the allocation while the strong destructor is running, even\n         // if the weak pointer is stored inside the strong one.\n-        Self::from_inner(\n-            Box::leak(box RcBox { strong: Cell::new(1), weak: Cell::new(1), value }).into(),\n-        )\n+        unsafe {\n+            Self::from_inner(\n+                Box::leak(box RcBox { strong: Cell::new(1), weak: Cell::new(1), value }).into(),\n+            )\n+        }\n     }\n \n     /// Constructs a new `Rc<T>` using a weak reference to itself. Attempting\n@@ -420,16 +422,16 @@ impl<T> Rc<T> {\n         // otherwise.\n         let data = data_fn(&weak);\n \n-        unsafe {\n+        let strong = unsafe {\n             let inner = init_ptr.as_ptr();\n             ptr::write(ptr::addr_of_mut!((*inner).value), data);\n \n             let prev_value = (*inner).strong.get();\n             debug_assert_eq!(prev_value, 0, \"No prior strong references should exist\");\n             (*inner).strong.set(1);\n-        }\n \n-        let strong = Rc::from_inner(init_ptr);\n+            Rc::from_inner(init_ptr)\n+        };\n \n         // Strong references should collectively own a shared weak reference,\n         // so don't run the destructor for our old weak reference.\n@@ -521,10 +523,12 @@ impl<T> Rc<T> {\n         // pointers, which ensures that the weak destructor never frees\n         // the allocation while the strong destructor is running, even\n         // if the weak pointer is stored inside the strong one.\n-        Ok(Self::from_inner(\n-            Box::leak(Box::try_new(RcBox { strong: Cell::new(1), weak: Cell::new(1), value })?)\n-                .into(),\n-        ))\n+        unsafe {\n+            Ok(Self::from_inner(\n+                Box::leak(Box::try_new(RcBox { strong: Cell::new(1), weak: Cell::new(1), value })?)\n+                    .into(),\n+            ))\n+        }\n     }\n \n     /// Constructs a new `Rc` with uninitialized contents, returning an error if the allocation fails\n@@ -746,7 +750,7 @@ impl<T> Rc<mem::MaybeUninit<T>> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     #[inline]\n     pub unsafe fn assume_init(self) -> Rc<T> {\n-        Rc::from_inner(mem::ManuallyDrop::new(self).ptr.cast())\n+        unsafe { Rc::from_inner(mem::ManuallyDrop::new(self).ptr.cast()) }\n     }\n }\n \n@@ -1214,9 +1218,11 @@ impl Rc<dyn Any> {\n     /// ```\n     pub fn downcast<T: Any>(self) -> Result<Rc<T>, Rc<dyn Any>> {\n         if (*self).is::<T>() {\n-            let ptr = self.ptr.cast::<RcBox<T>>();\n-            forget(self);\n-            Ok(Rc::from_inner(ptr))\n+            unsafe {\n+                let ptr = self.ptr.cast::<RcBox<T>>();\n+                forget(self);\n+                Ok(Rc::from_inner(ptr))\n+            }\n         } else {\n             Err(self)\n         }\n@@ -1489,8 +1495,10 @@ impl<T: ?Sized> Clone for Rc<T> {\n     /// ```\n     #[inline]\n     fn clone(&self) -> Rc<T> {\n-        self.inner().inc_strong();\n-        Self::from_inner(self.ptr)\n+        unsafe {\n+            self.inner().inc_strong();\n+            Self::from_inner(self.ptr)\n+        }\n     }\n }\n \n@@ -2245,11 +2253,14 @@ impl<T: ?Sized> Weak<T> {\n     #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n     pub fn upgrade(&self) -> Option<Rc<T>> {\n         let inner = self.inner()?;\n+\n         if inner.strong() == 0 {\n             None\n         } else {\n-            inner.inc_strong();\n-            Some(Rc::from_inner(self.ptr))\n+            unsafe {\n+                inner.inc_strong();\n+                Some(Rc::from_inner(self.ptr))\n+            }\n         }\n     }\n "}, {"sha": "733a898b285ac54c205547197d6ec0c9a1a577a2", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/09d9c098e0b38fb4b41a22a9bc8d19957be0503d/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d9c098e0b38fb4b41a22a9bc8d19957be0503d/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=09d9c098e0b38fb4b41a22a9bc8d19957be0503d", "patch": "@@ -252,7 +252,7 @@ impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Arc<U>> for Arc<T> {}\n impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<Arc<U>> for Arc<T> {}\n \n impl<T: ?Sized> Arc<T> {\n-    fn from_inner(ptr: NonNull<ArcInner<T>>) -> Self {\n+    unsafe fn from_inner(ptr: NonNull<ArcInner<T>>) -> Self {\n         Self { ptr, phantom: PhantomData }\n     }\n \n@@ -348,7 +348,7 @@ impl<T> Arc<T> {\n             weak: atomic::AtomicUsize::new(1),\n             data,\n         };\n-        Self::from_inner(Box::leak(x).into())\n+        unsafe { Self::from_inner(Box::leak(x).into()) }\n     }\n \n     /// Constructs a new `Arc<T>` using a weak reference to itself. Attempting\n@@ -397,7 +397,7 @@ impl<T> Arc<T> {\n \n         // Now we can properly initialize the inner value and turn our weak\n         // reference into a strong reference.\n-        unsafe {\n+        let strong = unsafe {\n             let inner = init_ptr.as_ptr();\n             ptr::write(ptr::addr_of_mut!((*inner).data), data);\n \n@@ -415,9 +415,9 @@ impl<T> Arc<T> {\n             // possible with safe code alone.\n             let prev_value = (*inner).strong.fetch_add(1, Release);\n             debug_assert_eq!(prev_value, 0, \"No prior strong references should exist\");\n-        }\n \n-        let strong = Arc::from_inner(init_ptr);\n+            Arc::from_inner(init_ptr)\n+        };\n \n         // Strong references should collectively own a shared weak reference,\n         // so don't run the destructor for our old weak reference.\n@@ -529,7 +529,7 @@ impl<T> Arc<T> {\n             weak: atomic::AtomicUsize::new(1),\n             data,\n         })?;\n-        Ok(Self::from_inner(Box::leak(x).into()))\n+        unsafe { Ok(Self::from_inner(Box::leak(x).into())) }\n     }\n \n     /// Constructs a new `Arc` with uninitialized contents, returning an error\n@@ -743,7 +743,7 @@ impl<T> Arc<mem::MaybeUninit<T>> {\n     #[must_use = \"`self` will be dropped if the result is not used\"]\n     #[inline]\n     pub unsafe fn assume_init(self) -> Arc<T> {\n-        Arc::from_inner(mem::ManuallyDrop::new(self).ptr.cast())\n+        unsafe { Arc::from_inner(mem::ManuallyDrop::new(self).ptr.cast()) }\n     }\n }\n \n@@ -1341,7 +1341,7 @@ impl<T: ?Sized> Clone for Arc<T> {\n             abort();\n         }\n \n-        Self::from_inner(self.ptr)\n+        unsafe { Self::from_inner(self.ptr) }\n     }\n }\n \n@@ -1668,9 +1668,11 @@ impl Arc<dyn Any + Send + Sync> {\n         T: Any + Send + Sync + 'static,\n     {\n         if (*self).is::<T>() {\n-            let ptr = self.ptr.cast::<ArcInner<T>>();\n-            mem::forget(self);\n-            Ok(Arc::from_inner(ptr))\n+            unsafe {\n+                let ptr = self.ptr.cast::<ArcInner<T>>();\n+                mem::forget(self);\n+                Ok(Arc::from_inner(ptr))\n+            }\n         } else {\n             Err(self)\n         }\n@@ -1899,7 +1901,7 @@ impl<T: ?Sized> Weak<T> {\n             // value can be initialized after `Weak` references have already been created. In that case, we\n             // expect to observe the fully initialized value.\n             match inner.strong.compare_exchange_weak(n, n + 1, Acquire, Relaxed) {\n-                Ok(_) => return Some(Arc::from_inner(self.ptr)), // null checked above\n+                Ok(_) => return Some(unsafe { Arc::from_inner(self.ptr) }), // null checked above\n                 Err(old) => n = old,\n             }\n         }"}]}