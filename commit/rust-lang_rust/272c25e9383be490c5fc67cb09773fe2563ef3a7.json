{"sha": "272c25e9383be490c5fc67cb09773fe2563ef3a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3MmMyNWU5MzgzYmU0OTBjNWZjNjdjYjA5NzczZmUyNTYzZWYzYTc=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-24T23:41:54Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-26T06:52:57Z"}, "message": "libsyntax: minor cleanup", "tree": {"sha": "912c59905180812fe44c6d6a8e9a2b68434d29c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/912c59905180812fe44c6d6a8e9a2b68434d29c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/272c25e9383be490c5fc67cb09773fe2563ef3a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/272c25e9383be490c5fc67cb09773fe2563ef3a7", "html_url": "https://github.com/rust-lang/rust/commit/272c25e9383be490c5fc67cb09773fe2563ef3a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/272c25e9383be490c5fc67cb09773fe2563ef3a7/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3635480b157389ce3e65bb5b9ccd0ced8e21e1c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/3635480b157389ce3e65bb5b9ccd0ced8e21e1c7", "html_url": "https://github.com/rust-lang/rust/commit/3635480b157389ce3e65bb5b9ccd0ced8e21e1c7"}], "stats": {"total": 384, "additions": 246, "deletions": 138}, "files": [{"sha": "f7b115912da234975ec7adfcfc246ea3a6201fe9", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/272c25e9383be490c5fc67cb09773fe2563ef3a7/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/272c25e9383be490c5fc67cb09773fe2563ef3a7/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=272c25e9383be490c5fc67cb09773fe2563ef3a7", "patch": "@@ -151,9 +151,12 @@ impl parser_attr for Parser {\n     }\n \n     fn parse_meta_seq() -> ~[@ast::meta_item] {\n-        return self.parse_seq(token::LPAREN, token::RPAREN,\n-                           seq_sep_trailing_disallowed(token::COMMA),\n-                           |p| p.parse_meta_item()).node;\n+        self.parse_seq(\n+            token::LPAREN,\n+            token::RPAREN,\n+            seq_sep_trailing_disallowed(token::COMMA),\n+            |p| p.parse_meta_item()\n+        ).node\n     }\n \n     fn parse_optional_meta() -> ~[@ast::meta_item] {"}, {"sha": "c7f029e9733db861dc01532e80e7a2d986073640", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 88, "deletions": 45, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/272c25e9383be490c5fc67cb09773fe2563ef3a7/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/272c25e9383be490c5fc67cb09773fe2563ef3a7/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=272c25e9383be490c5fc67cb09773fe2563ef3a7", "patch": "@@ -29,20 +29,20 @@ pub struct SeqSep {\n \n pub fn seq_sep_trailing_disallowed(t: token::Token) -> SeqSep {\n     SeqSep {\n-        sep: option::Some(t),\n-        trailing_sep_allowed: false\n+        sep: Some(t),\n+        trailing_sep_allowed: false,\n     }\n }\n pub fn seq_sep_trailing_allowed(t: token::Token) -> SeqSep {\n     SeqSep {\n-        sep: option::Some(t),\n-        trailing_sep_allowed: true\n+        sep: Some(t),\n+        trailing_sep_allowed: true,\n     }\n }\n pub fn seq_sep_none() -> SeqSep {\n     SeqSep {\n-        sep: option::None,\n-        trailing_sep_allowed: false\n+        sep: None,\n+        trailing_sep_allowed: false,\n     }\n }\n \n@@ -54,12 +54,20 @@ pub impl Parser {\n     fn unexpected_last(t: token::Token) -> ! {\n         self.span_fatal(\n             *self.last_span,\n-            ~\"unexpected token: `\" + token_to_str(self.reader, t) + ~\"`\");\n+            fmt!(\n+                \"unexpected token: `%s`\",\n+                token_to_str(self.reader, t)\n+            )\n+        );\n     }\n \n     fn unexpected() -> ! {\n-        self.fatal(~\"unexpected token: `\"\n-                   + token_to_str(self.reader, *self.token) + ~\"`\");\n+        self.fatal(\n+            fmt!(\n+                \"unexpected token: `%s`\",\n+                token_to_str(self.reader, *self.token)\n+            )\n+        );\n     }\n \n     // expect and consume the token t. Signal an error if\n@@ -81,12 +89,23 @@ pub impl Parser {\n         self.check_strict_keywords();\n         self.check_reserved_keywords();\n         match *self.token {\n-          token::IDENT(i, _) => { self.bump(); return i; }\n-          token::INTERPOLATED(token::nt_ident(*)) => { self.bug(\n-              ~\"ident interpolation not converted to real token\"); }\n-          _ => { self.fatal(~\"expected ident, found `\"\n-                         + token_to_str(self.reader, *self.token)\n-                         + ~\"`\"); }\n+            token::IDENT(i, _) => {\n+                self.bump();\n+                i\n+            }\n+            token::INTERPOLATED(token::nt_ident(*)) => {\n+                self.bug(\n+                    ~\"ident interpolation not converted to real token\"\n+                );\n+            }\n+            _ => {\n+                self.fatal(\n+                    fmt!(\n+                        \"expected ident, found `%s`\",\n+                         token_to_str(self.reader, *self.token)\n+                    )\n+                );\n+            }\n         }\n     }\n \n@@ -155,9 +174,13 @@ pub impl Parser {\n     fn expect_keyword(word: &~str) {\n         self.require_keyword(word);\n         if !self.eat_keyword(word) {\n-            self.fatal(~\"expected `\" + *word + ~\"`, found `\" +\n-                       token_to_str(self.reader, *self.token) +\n-                       ~\"`\");\n+            self.fatal(\n+                fmt!(\n+                    \"expected `%s`, found `%s`\",\n+                    *word,\n+                    token_to_str(self.reader, *self.token)\n+                )\n+            );\n         }\n     }\n \n@@ -177,7 +200,7 @@ pub impl Parser {\n \n     fn check_strict_keywords_(w: &~str) {\n         if self.is_strict_keyword(w) {\n-            self.fatal(~\"found `\" + *w + ~\"` in ident position\");\n+            self.fatal(fmt!(\"found `%s` in ident position\", *w));\n         }\n     }\n \n@@ -197,7 +220,7 @@ pub impl Parser {\n \n     fn check_reserved_keywords_(w: &~str) {\n         if self.is_reserved_keyword(w) {\n-            self.fatal(~\"`\" + *w + ~\"` is a reserved keyword\");\n+            self.fatal(fmt!(\"`%s` is a reserved keyword\", *w));\n         }\n     }\n \n@@ -207,9 +230,11 @@ pub impl Parser {\n         if *self.token == token::GT {\n             self.bump();\n         } else if *self.token == token::BINOP(token::SHR) {\n-            self.replace_token(token::GT,\n-                               self.span.lo + BytePos(1u),\n-                               self.span.hi);\n+            self.replace_token(\n+                token::GT,\n+                self.span.lo + BytePos(1u),\n+                self.span.hi\n+            );\n         } else {\n             let mut s: ~str = ~\"expected `\";\n             s += token_to_str(self.reader, token::GT);\n@@ -222,8 +247,10 @@ pub impl Parser {\n \n     // parse a sequence bracketed by '<' and '>', stopping\n     // before the '>'.\n-    fn parse_seq_to_before_gt<T:Copy>(sep: Option<token::Token>,\n-                                       f: fn(Parser) -> T) -> ~[T] {\n+    fn parse_seq_to_before_gt<T: Copy>(\n+        sep: Option<token::Token>,\n+        f: fn(Parser) -> T\n+    ) -> ~[T] {\n         let mut first = true;\n         let mut v = ~[];\n         while *self.token != token::GT\n@@ -241,17 +268,21 @@ pub impl Parser {\n         return v;\n     }\n \n-    fn parse_seq_to_gt<T:Copy>(sep: Option<token::Token>,\n-                                f: fn(Parser) -> T) -> ~[T] {\n+    fn parse_seq_to_gt<T: Copy>(\n+        sep: Option<token::Token>,\n+        f: fn(Parser) -> T\n+    ) -> ~[T] {\n         let v = self.parse_seq_to_before_gt(sep, f);\n         self.expect_gt();\n \n         return v;\n     }\n \n     // parse a sequence bracketed by '<' and '>'\n-    fn parse_seq_lt_gt<T:Copy>(sep: Option<token::Token>,\n-                                f: fn(Parser) -> T) -> spanned<~[T]> {\n+    fn parse_seq_lt_gt<T: Copy>(\n+        sep: Option<token::Token>,\n+        f: fn(Parser) -> T\n+    ) -> spanned<~[T]> {\n         let lo = self.span.lo;\n         self.expect(&token::LT);\n         let result = self.parse_seq_to_before_gt::<T>(sep, f);\n@@ -263,18 +294,24 @@ pub impl Parser {\n     // parse a sequence, including the closing delimiter. The function\n     // f must consume tokens until reaching the next separator or\n     // closing bracket.\n-    fn parse_seq_to_end<T:Copy>(ket: token::Token, sep: SeqSep,\n-                                 f: fn(Parser) -> T) -> ~[T] {\n+    fn parse_seq_to_end<T: Copy>(\n+        ket: token::Token,\n+        sep: SeqSep,\n+        f: fn(Parser) -> T\n+    ) -> ~[T] {\n         let val = self.parse_seq_to_before_end(ket, sep, f);\n         self.bump();\n-        return val;\n+        val\n     }\n \n     // parse a sequence, not including the closing delimiter. The function\n     // f must consume tokens until reaching the next separator or\n     // closing bracket.\n-    fn parse_seq_to_before_end<T:Copy>(ket: token::Token, sep: SeqSep,\n-                                        f: fn(Parser) -> T) -> ~[T] {\n+    fn parse_seq_to_before_end<T: Copy>(\n+        ket: token::Token,\n+        sep: SeqSep,\n+        f: fn(Parser) -> T\n+    ) -> ~[T] {\n         let mut first: bool = true;\n         let mut v: ~[T] = ~[];\n         while *self.token != ket {\n@@ -288,31 +325,37 @@ pub impl Parser {\n             if sep.trailing_sep_allowed && *self.token == ket { break; }\n             v.push(f(self));\n         }\n-        return v;\n+        v\n     }\n \n     // parse a sequence, including the closing delimiter. The function\n     // f must consume tokens until reaching the next separator or\n     // closing bracket.\n-    fn parse_unspanned_seq<T:Copy>(+bra: token::Token,\n-                                   +ket: token::Token,\n-                                    sep: SeqSep,\n-                                    f: fn(Parser) -> T) -> ~[T] {\n+    fn parse_unspanned_seq<T: Copy>(\n+        +bra: token::Token,\n+        +ket: token::Token,\n+        sep: SeqSep,\n+        f: fn(Parser) -> T\n+    ) -> ~[T] {\n         self.expect(&bra);\n-        let result = self.parse_seq_to_before_end::<T>(ket, sep, f);\n+        let result = self.parse_seq_to_before_end(ket, sep, f);\n         self.bump();\n-        return result;\n+        result\n     }\n \n     // NB: Do not use this function unless you actually plan to place the\n     // spanned list in the AST.\n-    fn parse_seq<T:Copy>(bra: token::Token, ket: token::Token, sep: SeqSep,\n-                          f: fn(Parser) -> T) -> spanned<~[T]> {\n+    fn parse_seq<T: Copy>(\n+        +bra: token::Token,\n+        +ket: token::Token,\n+        sep: SeqSep,\n+        f: fn(Parser) -> T\n+    ) -> spanned<~[T]> {\n         let lo = self.span.lo;\n         self.expect(&bra);\n-        let result = self.parse_seq_to_before_end::<T>(ket, sep, f);\n+        let result = self.parse_seq_to_before_end(ket, sep, f);\n         let hi = self.span.hi;\n         self.bump();\n-        return spanned(lo, hi, result);\n+        spanned(lo, hi, result)\n     }\n }"}, {"sha": "36729dcb5ac2614786ff22275b50e3ac2fcdcf90", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 152, "deletions": 90, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/272c25e9383be490c5fc67cb09773fe2563ef3a7/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/272c25e9383be490c5fc67cb09773fe2563ef3a7/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=272c25e9383be490c5fc67cb09773fe2563ef3a7", "patch": "@@ -422,16 +422,21 @@ pub impl Parser {\n             self.expect(&token::GT);\n         }\n         let inputs = self.parse_unspanned_seq(\n-            token::LPAREN, token::RPAREN,\n+            token::LPAREN,\n+            token::RPAREN,\n             seq_sep_trailing_disallowed(token::COMMA),\n-            |p| p.parse_arg_general(false));\n+            |p| p.parse_arg_general(false)\n+        );\n         let (ret_style, ret_ty) = self.parse_ret_ty();\n         ast::fn_decl { inputs: inputs, output: ret_ty, cf: ret_style }\n     }\n \n     fn parse_trait_methods() -> ~[trait_method] {\n-        do self.parse_unspanned_seq(token::LBRACE, token::RBRACE,\n-                                    seq_sep_none()) |p| {\n+        do self.parse_unspanned_seq(\n+            token::LBRACE,\n+            token::RBRACE,\n+            seq_sep_none()\n+        ) |p| {\n             let attrs = p.parse_outer_attributes();\n             let lo = p.span.lo;\n             let is_static = p.parse_staticness();\n@@ -619,9 +624,11 @@ pub impl Parser {\n             ty_ptr(self.parse_mt())\n         } else if *self.token == token::LBRACE {\n             let elems = self.parse_unspanned_seq(\n-                token::LBRACE, token::RBRACE,\n+                token::LBRACE,\n+                token::RBRACE,\n                 seq_sep_trailing_allowed(token::COMMA),\n-                |p| p.parse_ty_field());\n+                |p| p.parse_ty_field()\n+            );\n             if vec::len(elems) == 0u {\n                 self.unexpected_last(token::RBRACE);\n             }\n@@ -1175,10 +1182,11 @@ pub impl Parser {\n                 } else if *self.token == token::COMMA {\n                     // Vector with two or more elements.\n                     self.bump();\n-                    let remaining_exprs =\n-                        self.parse_seq_to_end(token::RBRACKET,\n-                            seq_sep_trailing_allowed(token::COMMA),\n-                            |p| p.parse_expr());\n+                    let remaining_exprs = self.parse_seq_to_end(\n+                        token::RBRACKET,\n+                        seq_sep_trailing_allowed(token::COMMA),\n+                        |p| p.parse_expr()\n+                    );\n                     ex = expr_vec(~[first_expr] + remaining_exprs, mutbl);\n                 } else {\n                     // Vector with one element.\n@@ -1230,10 +1238,12 @@ pub impl Parser {\n                 };\n \n                 let ket = token::flip_delimiter(&*self.token);\n-                let tts = self.parse_unspanned_seq(*self.token,\n-                                                   ket,\n-                                                   seq_sep_none(),\n-                                                   |p| p.parse_token_tree());\n+                let tts = self.parse_unspanned_seq(\n+                    *self.token,\n+                    ket,\n+                    seq_sep_none(),\n+                    |p| p.parse_token_tree()\n+                );\n                 let hi = self.span.hi;\n \n                 return self.mk_mac_expr(lo, hi, mac_invoc_tt(pth, tts));\n@@ -1310,8 +1320,10 @@ pub impl Parser {\n                     self.bump();\n                     let tys = if self.eat(&token::MOD_SEP) {\n                         self.expect(&token::LT);\n-                        self.parse_seq_to_gt(Some(token::COMMA),\n-                                             |p| p.parse_ty(false))\n+                        self.parse_seq_to_gt(\n+                            Some(token::COMMA),\n+                            |p| p.parse_ty(false)\n+                        )\n                     } else {\n                         ~[]\n                     };\n@@ -1320,9 +1332,11 @@ pub impl Parser {\n                     match *self.token {\n                         token::LPAREN if self.permits_call() => {\n                             let es = self.parse_unspanned_seq(\n-                                token::LPAREN, token::RPAREN,\n+                                token::LPAREN,\n+                                token::RPAREN,\n                                 seq_sep_trailing_disallowed(token::COMMA),\n-                                |p| p.parse_expr());\n+                                |p| p.parse_expr()\n+                            );\n                             hi = self.span.hi;\n \n                             let nd = expr_method_call(e, i, tys, es, NoSugar);\n@@ -1342,9 +1356,11 @@ pub impl Parser {\n               // expr(...)\n               token::LPAREN if self.permits_call() => {\n                 let es = self.parse_unspanned_seq(\n-                    token::LPAREN, token::RPAREN,\n+                    token::LPAREN,\n+                    token::RPAREN,\n                     seq_sep_trailing_disallowed(token::COMMA),\n-                    |p| p.parse_expr());\n+                    |p| p.parse_expr()\n+                );\n                 hi = self.span.hi;\n \n                 let nd = expr_call(e, es, NoSugar);\n@@ -1373,15 +1389,15 @@ pub impl Parser {\n             || *self.token == token::BINOP(token::PLUS) {\n             let zerok = *self.token == token::BINOP(token::STAR);\n             self.bump();\n-            return (None, zerok);\n+            (None, zerok)\n         } else {\n             let sep = *self.token;\n             self.bump();\n             if *self.token == token::BINOP(token::STAR)\n                 || *self.token == token::BINOP(token::PLUS) {\n                 let zerok = *self.token == token::BINOP(token::STAR);\n                 self.bump();\n-                return (Some(sep), zerok);\n+                (Some(sep), zerok)\n             } else {\n                 self.fatal(~\"expected `*` or `+`\");\n             }\n@@ -1397,18 +1413,25 @@ pub impl Parser {\n             match *p.token {\n               token::RPAREN | token::RBRACE | token::RBRACKET\n               => {\n-                p.fatal(~\"incorrect close delimiter: `\"\n-                           + token_to_str(p.reader, *p.token) + ~\"`\");\n+                p.fatal(\n+                    fmt!(\n+                        \"incorrect close delimiter: `%s`\",\n+                        token_to_str(p.reader, *p.token)\n+                    )\n+                );\n               }\n               /* we ought to allow different depths of unquotation */\n               token::DOLLAR if *p.quote_depth > 0u => {\n                 p.bump();\n                 let sp = *p.span;\n \n                 if *p.token == token::LPAREN {\n-                    let seq = p.parse_seq(token::LPAREN, token::RPAREN,\n-                                          seq_sep_none(),\n-                                          |p| p.parse_token_tree());\n+                    let seq = p.parse_seq(\n+                        token::LPAREN,\n+                        token::RPAREN,\n+                        seq_sep_none(),\n+                        |p| p.parse_token_tree()\n+                    );\n                     let (s, z) = p.parse_sep_and_zerok();\n                     tt_seq(mk_sp(sp.lo ,p.span.hi), seq.node, s, z)\n                 } else {\n@@ -1429,23 +1452,29 @@ pub impl Parser {\n         }\n \n         match *self.token {\n-          token::EOF => {\n+            token::EOF => {\n                 self.fatal(~\"file ended in the middle of a macro invocation\");\n-          }\n-          token::LPAREN | token::LBRACE | token::LBRACKET => {\n-              // tjc: ??????\n-            let ket = token::flip_delimiter(&*self.token);\n-            tt_delim(vec::append(\n-                // the open delimiter:\n-                ~[parse_any_tt_tok(self)],\n-                vec::append(\n-                    self.parse_seq_to_before_end(\n-                        ket, seq_sep_none(),\n-                        |p| p.parse_token_tree()),\n-                    // the close delimiter:\n-                    ~[parse_any_tt_tok(self)])))\n-          }\n-          _ => parse_non_delim_tt_tok(self)\n+            }\n+            token::LPAREN | token::LBRACE | token::LBRACKET => {\n+                // tjc: ??????\n+                let ket = token::flip_delimiter(&*self.token);\n+                tt_delim(\n+                    vec::append(\n+                        // the open delimiter:\n+                        ~[parse_any_tt_tok(self)],\n+                        vec::append(\n+                            self.parse_seq_to_before_end(\n+                                ket,\n+                                seq_sep_none(),\n+                                |p| p.parse_token_tree()\n+                            ),\n+                            // the close delimiter:\n+                            ~[parse_any_tt_tok(self)]\n+                        )\n+                    )\n+                )\n+            }\n+            _ => parse_non_delim_tt_tok(self)\n         }\n     }\n \n@@ -1462,22 +1491,28 @@ pub impl Parser {\n         // the interpolation of matchers\n         maybe_whole!(self, nt_matchers);\n         let name_idx = @mut 0u;\n-        return match *self.token {\n-          token::LBRACE | token::LPAREN | token::LBRACKET => {\n-            self.parse_matcher_subseq(name_idx, *self.token,\n-                                      // tjc: not sure why we need a copy\n-                                      token::flip_delimiter(&*self.token))\n-          }\n-          _ => self.fatal(~\"expected open delimiter\")\n+        match *self.token {\n+            token::LBRACE | token::LPAREN | token::LBRACKET => {\n+                self.parse_matcher_subseq(\n+                    name_idx,\n+                    *self.token,\n+                    // tjc: not sure why we need a copy\n+                    token::flip_delimiter(&*self.token)\n+                )\n+            }\n+            _ => self.fatal(~\"expected open delimiter\")\n         }\n     }\n \n \n     // This goofy function is necessary to correctly match parens in matchers.\n     // Otherwise, `$( ( )` would be a valid matcher, and `$( () )` would be\n     // invalid. It's similar to common::parse_seq.\n-    fn parse_matcher_subseq(name_idx: @mut uint, bra: token::Token,\n-                            ket: token::Token) -> ~[matcher] {\n+    fn parse_matcher_subseq(\n+        name_idx: @mut uint,\n+        bra: token::Token,\n+        ket: token::Token\n+    ) -> ~[matcher] {\n         let mut ret_val = ~[];\n         let mut lparens = 0u;\n \n@@ -1501,9 +1536,11 @@ pub impl Parser {\n             self.bump();\n             if *self.token == token::LPAREN {\n                 let name_idx_lo = *name_idx;\n-                let ms = self.parse_matcher_subseq(name_idx,\n-                                                   token::LPAREN,\n-                                                   token::RPAREN);\n+                let ms = self.parse_matcher_subseq(\n+                    name_idx,\n+                    token::LPAREN,\n+                    token::RPAREN\n+                );\n                 if ms.len() == 0u {\n                     self.fatal(~\"repetition body must be nonempty\");\n                 }\n@@ -2276,10 +2313,13 @@ pub impl Parser {\n                                   }\n                                 _ => {\n                                     args = self.parse_unspanned_seq(\n-                                        token::LPAREN, token::RPAREN,\n-                                        seq_sep_trailing_disallowed\n-                                            (token::COMMA),\n-                                        |p| p.parse_pat(refutable));\n+                                        token::LPAREN,\n+                                        token::RPAREN,\n+                                        seq_sep_trailing_disallowed(\n+                                            token::COMMA\n+                                        ),\n+                                        |p| p.parse_pat(refutable)\n+                                    );\n                                   }\n                               },\n                               _ => ()\n@@ -2423,8 +2463,11 @@ pub impl Parser {\n             };\n \n             let tts = self.parse_unspanned_seq(\n-                token::LPAREN, token::RPAREN, seq_sep_none(),\n-                |p| p.parse_token_tree());\n+                token::LPAREN,\n+                token::RPAREN,\n+                seq_sep_none(),\n+                |p| p.parse_token_tree()\n+            );\n             let hi = self.span.hi;\n \n             if id == token::special_idents::invalid {\n@@ -2720,7 +2763,8 @@ pub impl Parser {\n             let _lifetimes = self.parse_lifetimes();\n             self.parse_seq_to_gt(\n                 Some(token::COMMA),\n-                |p| p.parse_ty_param())\n+                |p| p.parse_ty_param()\n+            )\n         } else { ~[] }\n     }\n \n@@ -2729,8 +2773,11 @@ pub impl Parser {\n     {\n         let args_or_capture_items: ~[arg_or_capture_item] =\n             self.parse_unspanned_seq(\n-                token::LPAREN, token::RPAREN,\n-                seq_sep_trailing_disallowed(token::COMMA), parse_arg_fn);\n+                token::LPAREN,\n+                token::RPAREN,\n+                seq_sep_trailing_disallowed(token::COMMA),\n+                parse_arg_fn\n+            );\n \n         let inputs = either::lefts(args_or_capture_items);\n \n@@ -2810,10 +2857,11 @@ pub impl Parser {\n                 token::COMMA => {\n                     self.bump();\n                     let sep = seq_sep_trailing_disallowed(token::COMMA);\n-                    args_or_capture_items =\n-                        self.parse_seq_to_before_end(token::RPAREN,\n-                                                     sep,\n-                                                     parse_arg_fn);\n+                    args_or_capture_items = self.parse_seq_to_before_end(\n+                        token::RPAREN,\n+                        sep,\n+                        parse_arg_fn\n+                    );\n                 }\n                 token::RPAREN => {\n                     args_or_capture_items = ~[];\n@@ -2826,10 +2874,11 @@ pub impl Parser {\n             }\n         } else {\n             let sep = seq_sep_trailing_disallowed(token::COMMA);\n-            args_or_capture_items =\n-                self.parse_seq_to_before_end(token::RPAREN,\n-                                             sep,\n-                                             parse_arg_fn);\n+            args_or_capture_items = self.parse_seq_to_before_end(\n+                token::RPAREN,\n+                sep,\n+                parse_arg_fn\n+            );\n         }\n \n         self.expect(&token::RPAREN);\n@@ -2854,9 +2903,11 @@ pub impl Parser {\n                 ~[]\n             } else {\n                 self.parse_unspanned_seq(\n-                    token::BINOP(token::OR), token::BINOP(token::OR),\n+                    token::BINOP(token::OR),\n+                    token::BINOP(token::OR),\n                     seq_sep_trailing_disallowed(token::COMMA),\n-                    |p| p.parse_fn_block_arg())\n+                    |p| p.parse_fn_block_arg()\n+                )\n             }\n         };\n         let output = if self.eat(&token::RARROW) {\n@@ -3054,8 +3105,10 @@ pub impl Parser {\n \n     fn parse_trait_ref_list(ket: token::Token) -> ~[@trait_ref] {\n         self.parse_seq_to_before_end(\n-            ket, seq_sep_none(),\n-            |p| p.parse_trait_ref())\n+            ket,\n+            seq_sep_none(),\n+            |p| p.parse_trait_ref()\n+        )\n     }\n \n     fn parse_item_struct() -> item_info {\n@@ -3102,9 +3155,11 @@ pub impl Parser {\n         } else if *self.token == token::LPAREN {\n             // It's a tuple-like struct.\n             is_tuple_like = true;\n-            fields = do self.parse_unspanned_seq(token::LPAREN, token::RPAREN,\n-                                                 seq_sep_trailing_allowed\n-                                                    (token::COMMA)) |p| {\n+            fields = do self.parse_unspanned_seq(\n+                token::LPAREN,\n+                token::RPAREN,\n+                seq_sep_trailing_allowed(token::COMMA)\n+            ) |p| {\n                 let lo = p.span.lo;\n                 let struct_field_ = ast::struct_field_ {\n                     kind: unnamed_field,\n@@ -3667,9 +3722,11 @@ pub impl Parser {\n                 } else if *self.token == token::LPAREN {\n                     all_nullary = false;\n                     let arg_tys = self.parse_unspanned_seq(\n-                        token::LPAREN, token::RPAREN,\n+                        token::LPAREN,\n+                        token::RPAREN,\n                         seq_sep_trailing_disallowed(token::COMMA),\n-                        |p| p.parse_ty(false));\n+                        |p| p.parse_ty(false)\n+                    );\n                     for arg_tys.each |ty| {\n                         args.push(ast::variant_arg {\n                             ty: *ty,\n@@ -3915,13 +3972,16 @@ pub impl Parser {\n             };\n             // eat a matched-delimiter token tree:\n             let tts = match *self.token {\n-              token::LPAREN | token::LBRACE => {\n-                let ket = token::flip_delimiter(&*self.token);\n-                self.parse_unspanned_seq(*self.token, ket,\n-                                         seq_sep_none(),\n-                                         |p| p.parse_token_tree())\n-              }\n-              _ => self.fatal(~\"expected open delimiter\")\n+                token::LPAREN | token::LBRACE => {\n+                    let ket = token::flip_delimiter(&*self.token);\n+                    self.parse_unspanned_seq(\n+                        *self.token,\n+                        ket,\n+                        seq_sep_none(),\n+                        |p| p.parse_token_tree()\n+                    )\n+                }\n+                _ => self.fatal(~\"expected open delimiter\")\n             };\n             // single-variant-enum... :\n             let m = ast::mac_invoc_tt(pth, tts);\n@@ -4007,9 +4067,11 @@ pub impl Parser {\n                   // foo::bar::{a,b,c}\n                   token::LBRACE => {\n                     let idents = self.parse_unspanned_seq(\n-                        token::LBRACE, token::RBRACE,\n+                        token::LBRACE,\n+                        token::RBRACE,\n                         seq_sep_trailing_allowed(token::COMMA),\n-                        |p| p.parse_path_list_ident());\n+                        |p| p.parse_path_list_ident()\n+                    );\n                     let path = @ast::path { span: mk_sp(lo, self.span.hi),\n                                             global: false,\n                                             idents: path,"}]}