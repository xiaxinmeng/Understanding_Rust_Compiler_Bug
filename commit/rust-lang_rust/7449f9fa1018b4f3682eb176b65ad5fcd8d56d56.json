{"sha": "7449f9fa1018b4f3682eb176b65ad5fcd8d56d56", "node_id": "C_kwDOAAsO6NoAKDc0NDlmOWZhMTAxOGI0ZjM2ODJlYjE3NmI2NWFkNWZjZDhkNTZkNTY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-07T19:03:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-07T19:03:34Z"}, "message": "Auto merge of #13894 - lowr:patch/fallback-before-final-obligation-resolution, r=lnicola\n\nApply fallback before final obligation resolution\n\nFixes #13249\nFixes #13518\n\nWe've been applying fallback to type variables independently even when there are some unresolved obligations that associate them. This PR applies fallback to unresolved scalar type variables before the final attempt of resolving obligations, which enables us to infer more.\n\nUnlike rustc, which has separate storages for each kind of type variables, we currently don't have a way to retrieve only integer/float type variables without folding/visiting every single type we've inferred. I've repurposed `TypeVariableData` as bitflags that also hold the kind of the type variable it's referring to so that we can \"reconstruct\" scalar type variables from their indices.\n\nThis PR increases the number of ??ty for rust-analyzer repo not because we regress and fail to infer the existing code but because we fail to infer the new code. It seems we have problems inferring some functions bitflags produces.", "tree": {"sha": "e35e559251f3192c5b53a8907f1d0927b5063107", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e35e559251f3192c5b53a8907f1d0927b5063107"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7449f9fa1018b4f3682eb176b65ad5fcd8d56d56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7449f9fa1018b4f3682eb176b65ad5fcd8d56d56", "html_url": "https://github.com/rust-lang/rust/commit/7449f9fa1018b4f3682eb176b65ad5fcd8d56d56", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7449f9fa1018b4f3682eb176b65ad5fcd8d56d56/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1a99014b356c6aa41a69ceecf1f8cc68d901006", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1a99014b356c6aa41a69ceecf1f8cc68d901006", "html_url": "https://github.com/rust-lang/rust/commit/f1a99014b356c6aa41a69ceecf1f8cc68d901006"}, {"sha": "d01630c8f39e88aa175db9dbe92a9e2a188007ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/d01630c8f39e88aa175db9dbe92a9e2a188007ab", "html_url": "https://github.com/rust-lang/rust/commit/d01630c8f39e88aa175db9dbe92a9e2a188007ab"}], "stats": {"total": 154, "additions": 139, "deletions": 15}, "files": [{"sha": "59cd66756cd95f3c77d9b1de19207f5a77421fee", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7449f9fa1018b4f3682eb176b65ad5fcd8d56d56/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7449f9fa1018b4f3682eb176b65ad5fcd8d56d56/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7449f9fa1018b4f3682eb176b65ad5fcd8d56d56", "patch": "@@ -557,6 +557,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"arrayvec\",\n  \"base-db\",\n+ \"bitflags\",\n  \"chalk-derive\",\n  \"chalk-ir\",\n  \"chalk-recursive\","}, {"sha": "ae837ac6dce880a0e4f756705fdbb2ccd567ec3a", "filename": "crates/hir-ty/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7449f9fa1018b4f3682eb176b65ad5fcd8d56d56/crates%2Fhir-ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7449f9fa1018b4f3682eb176b65ad5fcd8d56d56/crates%2Fhir-ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2FCargo.toml?ref=7449f9fa1018b4f3682eb176b65ad5fcd8d56d56", "patch": "@@ -13,6 +13,7 @@ doctest = false\n cov-mark = \"2.0.0-pre.1\"\n itertools = \"0.10.5\"\n arrayvec = \"0.7.2\"\n+bitflags = \"1.3.2\"\n smallvec = \"1.10.0\"\n ena = \"0.14.0\"\n tracing = \"0.1.35\""}, {"sha": "6b59f1c20daa225b9d4f283bfc4a36a48ed0df3d", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7449f9fa1018b4f3682eb176b65ad5fcd8d56d56/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7449f9fa1018b4f3682eb176b65ad5fcd8d56d56/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=7449f9fa1018b4f3682eb176b65ad5fcd8d56d56", "patch": "@@ -512,6 +512,8 @@ impl<'a> InferenceContext<'a> {\n     fn resolve_all(self) -> InferenceResult {\n         let InferenceContext { mut table, mut result, .. } = self;\n \n+        table.fallback_if_possible();\n+\n         // FIXME resolve obligations as well (use Guidance if necessary)\n         table.resolve_obligations_as_possible();\n "}, {"sha": "e7ddd1591fe8a52a2cf04c6949e3589cebd5533a", "filename": "crates/hir-ty/src/infer/unify.rs", "status": "modified", "additions": 70, "deletions": 15, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/7449f9fa1018b4f3682eb176b65ad5fcd8d56d56/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7449f9fa1018b4f3682eb176b65ad5fcd8d56d56/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs?ref=7449f9fa1018b4f3682eb176b65ad5fcd8d56d56", "patch": "@@ -1,6 +1,6 @@\n //! Unification and canonicalization logic.\n \n-use std::{fmt, mem, sync::Arc};\n+use std::{fmt, iter, mem, sync::Arc};\n \n use chalk_ir::{\n     cast::Cast, fold::TypeFoldable, interner::HasInterner, zip::Zip, CanonicalVarKind, FloatTy,\n@@ -128,9 +128,13 @@ pub(crate) fn unify(\n     ))\n }\n \n-#[derive(Copy, Clone, Debug)]\n-pub(crate) struct TypeVariableData {\n-    diverging: bool,\n+bitflags::bitflags! {\n+    #[derive(Default)]\n+    pub(crate) struct TypeVariableFlags: u8 {\n+        const DIVERGING = 1 << 0;\n+        const INTEGER = 1 << 1;\n+        const FLOAT = 1 << 2;\n+    }\n }\n \n type ChalkInferenceTable = chalk_solve::infer::InferenceTable<Interner>;\n@@ -140,14 +144,14 @@ pub(crate) struct InferenceTable<'a> {\n     pub(crate) db: &'a dyn HirDatabase,\n     pub(crate) trait_env: Arc<TraitEnvironment>,\n     var_unification_table: ChalkInferenceTable,\n-    type_variable_table: Vec<TypeVariableData>,\n+    type_variable_table: Vec<TypeVariableFlags>,\n     pending_obligations: Vec<Canonicalized<InEnvironment<Goal>>>,\n }\n \n pub(crate) struct InferenceTableSnapshot {\n     var_table_snapshot: chalk_solve::infer::InferenceSnapshot<Interner>,\n     pending_obligations: Vec<Canonicalized<InEnvironment<Goal>>>,\n-    type_variable_table_snapshot: Vec<TypeVariableData>,\n+    type_variable_table_snapshot: Vec<TypeVariableFlags>,\n }\n \n impl<'a> InferenceTable<'a> {\n@@ -169,27 +173,27 @@ impl<'a> InferenceTable<'a> {\n     /// result.\n     pub(super) fn propagate_diverging_flag(&mut self) {\n         for i in 0..self.type_variable_table.len() {\n-            if !self.type_variable_table[i].diverging {\n+            if !self.type_variable_table[i].contains(TypeVariableFlags::DIVERGING) {\n                 continue;\n             }\n             let v = InferenceVar::from(i as u32);\n             let root = self.var_unification_table.inference_var_root(v);\n             if let Some(data) = self.type_variable_table.get_mut(root.index() as usize) {\n-                data.diverging = true;\n+                *data |= TypeVariableFlags::DIVERGING;\n             }\n         }\n     }\n \n     pub(super) fn set_diverging(&mut self, iv: InferenceVar, diverging: bool) {\n-        self.type_variable_table[iv.index() as usize].diverging = diverging;\n+        self.type_variable_table[iv.index() as usize].set(TypeVariableFlags::DIVERGING, diverging);\n     }\n \n     fn fallback_value(&self, iv: InferenceVar, kind: TyVariableKind) -> Ty {\n         match kind {\n             _ if self\n                 .type_variable_table\n                 .get(iv.index() as usize)\n-                .map_or(false, |data| data.diverging) =>\n+                .map_or(false, |data| data.contains(TypeVariableFlags::DIVERGING)) =>\n             {\n                 TyKind::Never\n             }\n@@ -247,18 +251,24 @@ impl<'a> InferenceTable<'a> {\n     }\n \n     fn extend_type_variable_table(&mut self, to_index: usize) {\n-        self.type_variable_table.extend(\n-            (0..1 + to_index - self.type_variable_table.len())\n-                .map(|_| TypeVariableData { diverging: false }),\n-        );\n+        let count = to_index - self.type_variable_table.len() + 1;\n+        self.type_variable_table.extend(iter::repeat(TypeVariableFlags::default()).take(count));\n     }\n \n     fn new_var(&mut self, kind: TyVariableKind, diverging: bool) -> Ty {\n         let var = self.var_unification_table.new_variable(UniverseIndex::ROOT);\n         // Chalk might have created some type variables for its own purposes that we don't know about...\n         self.extend_type_variable_table(var.index() as usize);\n         assert_eq!(var.index() as usize, self.type_variable_table.len() - 1);\n-        self.type_variable_table[var.index() as usize].diverging = diverging;\n+        let flags = self.type_variable_table.get_mut(var.index() as usize).unwrap();\n+        if diverging {\n+            *flags |= TypeVariableFlags::DIVERGING;\n+        }\n+        if matches!(kind, TyVariableKind::Integer) {\n+            *flags |= TypeVariableFlags::INTEGER;\n+        } else if matches!(kind, TyVariableKind::Float) {\n+            *flags |= TypeVariableFlags::FLOAT;\n+        }\n         var.to_ty_with_kind(Interner, kind)\n     }\n \n@@ -340,6 +350,51 @@ impl<'a> InferenceTable<'a> {\n         self.resolve_with_fallback(t, &|_, _, d, _| d)\n     }\n \n+    /// Apply a fallback to unresolved scalar types. Integer type variables and float type\n+    /// variables are replaced with i32 and f64, respectively.\n+    ///\n+    /// This method is only intended to be called just before returning inference results (i.e. in\n+    /// `InferenceContext::resolve_all()`).\n+    ///\n+    /// FIXME: This method currently doesn't apply fallback to unconstrained general type variables\n+    /// whereas rustc replaces them with `()` or `!`.\n+    pub(super) fn fallback_if_possible(&mut self) {\n+        let int_fallback = TyKind::Scalar(Scalar::Int(IntTy::I32)).intern(Interner);\n+        let float_fallback = TyKind::Scalar(Scalar::Float(FloatTy::F64)).intern(Interner);\n+\n+        let scalar_vars: Vec<_> = self\n+            .type_variable_table\n+            .iter()\n+            .enumerate()\n+            .filter_map(|(index, flags)| {\n+                let kind = if flags.contains(TypeVariableFlags::INTEGER) {\n+                    TyVariableKind::Integer\n+                } else if flags.contains(TypeVariableFlags::FLOAT) {\n+                    TyVariableKind::Float\n+                } else {\n+                    return None;\n+                };\n+\n+                // FIXME: This is not really the nicest way to get `InferenceVar`s. Can we get them\n+                // without directly constructing them from `index`?\n+                let var = InferenceVar::from(index as u32).to_ty(Interner, kind);\n+                Some(var)\n+            })\n+            .collect();\n+\n+        for var in scalar_vars {\n+            let maybe_resolved = self.resolve_ty_shallow(&var);\n+            if let TyKind::InferenceVar(_, kind) = maybe_resolved.kind(Interner) {\n+                let fallback = match kind {\n+                    TyVariableKind::Integer => &int_fallback,\n+                    TyVariableKind::Float => &float_fallback,\n+                    TyVariableKind::General => unreachable!(),\n+                };\n+                self.unify(&var, fallback);\n+            }\n+        }\n+    }\n+\n     /// Unify two relatable values (e.g. `Ty`) and register new trait goals that arise from that.\n     pub(crate) fn unify<T: ?Sized + Zip<Interner>>(&mut self, ty1: &T, ty2: &T) -> bool {\n         let result = match self.try_unify(ty1, ty2) {"}, {"sha": "d01fe0632859c3f295d5e01fbb1a18a002397d3e", "filename": "crates/hir-ty/src/tests/traits.rs", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/7449f9fa1018b4f3682eb176b65ad5fcd8d56d56/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7449f9fa1018b4f3682eb176b65ad5fcd8d56d56/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs?ref=7449f9fa1018b4f3682eb176b65ad5fcd8d56d56", "patch": "@@ -4100,3 +4100,68 @@ where\n     \"#,\n     );\n }\n+\n+#[test]\n+fn bin_op_with_scalar_fallback() {\n+    // Extra impls are significant so that chalk doesn't give us definite guidances.\n+    check_types(\n+        r#\"\n+//- minicore: add\n+use core::ops::Add;\n+\n+struct Vec2<T>(T, T);\n+\n+impl Add for Vec2<i32> {\n+    type Output = Self;\n+    fn add(self, rhs: Self) -> Self::Output { loop {} }\n+}\n+impl Add for Vec2<u32> {\n+    type Output = Self;\n+    fn add(self, rhs: Self) -> Self::Output { loop {} }\n+}\n+impl Add for Vec2<f32> {\n+    type Output = Self;\n+    fn add(self, rhs: Self) -> Self::Output { loop {} }\n+}\n+impl Add for Vec2<f64> {\n+    type Output = Self;\n+    fn add(self, rhs: Self) -> Self::Output { loop {} }\n+}\n+\n+fn test() {\n+    let a = Vec2(1, 2);\n+    let b = Vec2(3, 4);\n+    let c = a + b;\n+      //^ Vec2<i32>\n+    let a = Vec2(1., 2.);\n+    let b = Vec2(3., 4.);\n+    let c = a + b;\n+      //^ Vec2<f64>\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn trait_method_with_scalar_fallback() {\n+    check_types(\n+        r#\"\n+trait Trait {\n+    type Output;\n+    fn foo(&self) -> Self::Output;\n+}\n+impl<T> Trait for T {\n+    type Output = T;\n+    fn foo(&self) -> Self::Output { loop {} }\n+}\n+fn test() {\n+    let a = 42;\n+    let b = a.foo();\n+      //^ i32\n+    let a = 3.14;\n+    let b = a.foo();\n+      //^ f64\n+}\n+\"#,\n+    );\n+}"}]}