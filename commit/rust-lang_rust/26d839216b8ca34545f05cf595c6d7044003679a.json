{"sha": "26d839216b8ca34545f05cf595c6d7044003679a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2ZDgzOTIxNmI4Y2EzNDU0NWYwNWNmNTk1YzZkNzA0NDAwMzY3OWE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-10-27T20:14:56Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-10-27T20:25:20Z"}, "message": "Add more std docs", "tree": {"sha": "a135d8049b0401e3ec0708eeec89b31923c41eeb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a135d8049b0401e3ec0708eeec89b31923c41eeb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26d839216b8ca34545f05cf595c6d7044003679a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26d839216b8ca34545f05cf595c6d7044003679a", "html_url": "https://github.com/rust-lang/rust/commit/26d839216b8ca34545f05cf595c6d7044003679a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26d839216b8ca34545f05cf595c6d7044003679a/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00404ebe62734025b93bc6ec4e5e2a9640032984", "url": "https://api.github.com/repos/rust-lang/rust/commits/00404ebe62734025b93bc6ec4e5e2a9640032984", "html_url": "https://github.com/rust-lang/rust/commit/00404ebe62734025b93bc6ec4e5e2a9640032984"}], "stats": {"total": 171, "additions": 164, "deletions": 7}, "files": [{"sha": "f6d150bc295cf6956119791b289ddee0fb5518be", "filename": "src/lib/comm.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26d839216b8ca34545f05cf595c6d7044003679a/src%2Flib%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26d839216b8ca34545f05cf595c6d7044003679a/src%2Flib%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fcomm.rs?ref=26d839216b8ca34545f05cf595c6d7044003679a", "patch": "@@ -7,6 +7,12 @@ Communication between tasks is facilitated by ports (in the receiving task),\n and channels (in the sending task). Any number of channels may feed into a\n single port.\n \n+Ports and channels may only transmit values of unique types; that is,\n+values that are statically guaranteed to be accessed by a single\n+'owner' at a time.  Unique types include scalars, vectors, strings,\n+and records, tags, tuples and unique boxes (~T) thereof. Most notably,\n+shared boxes (@T) may not be transmitted across channels.\n+\n Example:\n \n > use std::task;"}, {"sha": "415856847204a133d7f26f2cb8053d33963a51a3", "filename": "src/lib/task.rs", "status": "modified", "additions": 158, "deletions": 7, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/26d839216b8ca34545f05cf595c6d7044003679a/src%2Flib%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26d839216b8ca34545f05cf595c6d7044003679a/src%2Flib%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftask.rs?ref=26d839216b8ca34545f05cf595c6d7044003679a", "patch": "@@ -2,6 +2,29 @@\n Module: task\n \n Task management.\n+\n+An executing Rust program consists of a tree of tasks, each with their own\n+stack, and sole ownership of their allocated heap data. Tasks communicate\n+with each other using ports and channels.\n+\n+When a task fails, that failure will propagate to its parent (the task\n+that spawned it) and the parent will fail as well. The reverse is not\n+true: when a parent task fails its children will continue executing. When\n+the root (main) task fails, all tasks fail, and then so does the entire\n+process.\n+\n+A task may remove itself from this failure propagation mechanism by\n+calling the <unsupervise> function, after which failure will only\n+result in the termination of that task.\n+\n+Tasks may execute in parallel and are scheduled automatically by the runtime.\n+\n+Example:\n+\n+> spawn(\"Hello, World\", fn (&&msg: str) {\n+>   log msg;\n+> });\n+\n */\n import cast = unsafe::reinterpret_cast;\n import comm;\n@@ -49,6 +72,8 @@ native \"c-stack-cdecl\" mod rustrt2 = \"rustrt\" {\n     fn migrate_alloc(alloc: *u8, target: task_id);\n }\n \n+/* Section: Types */\n+\n type rust_task =\n     {id: task,\n      mutable notify_enabled: u32,\n@@ -58,24 +83,85 @@ type rust_task =\n resource rust_task_ptr(task: *rust_task) { rustrt2::drop_task(task); }\n \n type task_id = int;\n+\n+/*\n+Type: task\n+\n+A handle to a task\n+*/\n type task = task_id;\n+\n+/*\n+Type: joinable_task\n+\n+A task that sends notification upon termination\n+*/\n type joinable_task = (task, comm::port<task_notification>);\n \n+/*\n+Tag: task_result\n+\n+Indicates the manner in which a task exited\n+*/\n+tag task_result {\n+    /* Variant: tr_success */\n+    tr_success;\n+    /* Variant: tr_failure */\n+    tr_failure;\n+}\n+\n+/*\n+Tag: task_notification\n+\n+Message sent upon task exit to indicate normal or abnormal termination\n+*/\n+tag task_notification {\n+    /* Variant: exit */\n+    exit(task, task_result);\n+}\n+\n+/* Section: Operations */\n+\n+/*\n+Type: get_task\n+\n+Retreives a handle to the currently executing task\n+*/\n fn get_task() -> task { rustrt2::get_task_id() }\n \n-/**\n- * Hints the scheduler to yield this task for a specified ammount of time.\n- *\n- * arg: time_in_us maximum number of microseconds to yield control for\n- */\n+/*\n+Function: sleep\n+\n+Hints the scheduler to yield this task for a specified ammount of time.\n+\n+Parameters:\n+\n+time_in_us - maximum number of microseconds to yield control for\n+*/\n fn sleep(time_in_us: uint) { ret rustrt::task_sleep(time_in_us); }\n \n+/*\n+Function: yield\n+\n+Yield control to the task scheduler\n+\n+The scheduler may schedule another task to execute.\n+*/\n fn yield() { ret rustrt::task_yield(); }\n \n-tag task_result { tr_success; tr_failure; }\n+/*\n+Function: join\n+\n+Wait for a child task to exit\n+\n+The child task must have been spawned with <spawn_joinable>, which\n+produces a notification port that the child uses to communicate its\n+exit status.\n \n-tag task_notification { exit(task, task_result); }\n+Returns:\n \n+A task_result indicating whether the task terminated normally or failed\n+*/\n fn join(task_port: joinable_task) -> task_result {\n     let (id, port) = task_port;\n     alt comm::recv::<task_notification>(port) {\n@@ -87,23 +173,88 @@ fn join(task_port: joinable_task) -> task_result {\n     }\n }\n \n+/*\n+Function: unsupervise\n+\n+Detaches this task from its parent in the task tree\n+\n+An unsupervised task will not propagate its failure up the task tree\n+*/\n fn unsupervise() { ret sys::unsupervise(); }\n \n+/*\n+Function: pin\n+\n+Pins the current task and future child tasks to a single scheduler thread\n+*/\n fn pin() { rustrt2::pin_task(); }\n \n+/*\n+Function: unpin\n+\n+Unpin the current task and future child tasks\n+*/\n fn unpin() { rustrt2::unpin_task(); }\n \n+/*\n+Function: set_min_stack\n+\n+Set the minimum stack size (in bytes) for tasks spawned in the future.\n+\n+This function has global effect and should probably not be used.\n+*/\n fn set_min_stack(stack_size: uint) { rustrt2::set_min_stack(stack_size); }\n \n+/*\n+Function: spawn\n+\n+Creates and executes a new child task\n+\n+Sets up a new task with its own call stack and schedules it to be executed.\n+Upon execution the new task will call function `f` with the provided\n+argument `data`.\n+\n+Function `f` is a bare function, meaning it may not close over any data, as do\n+shared functions (fn@) and lambda blocks. `data` must be a uniquely owned\n+type; it is moved into the new task and thus can no longer be accessed\n+locally.\n+\n+Parameters:\n+\n+data - A unique-type value to pass to the new task\n+f - A function to execute in the new task\n+\n+Returns:\n+\n+A handle to the new task\n+*/\n fn spawn<unique T>(-data: T, f: fn(T)) -> task {\n     spawn_inner(data, f, none)\n }\n \n+/*\n+Function: spawn_notify\n+\n+Create and execute a new child task, requesting notification upon its\n+termination\n+\n+Immediately before termination, either on success or failure, the spawned\n+task will send a <task_notification> message on the provided channel.\n+*/\n fn spawn_notify<unique T>(-data: T, f: fn(T),\n                          notify: comm::chan<task_notification>) -> task {\n     spawn_inner(data, f, some(notify))\n }\n \n+/*\n+Function: spawn_joinable\n+\n+Create and execute a task which can later be joined with the <join> function\n+\n+This is a convenience wrapper around spawn_notify which, when paired\n+with <join> can be easily used to spawn a task then wait for it to\n+complete.\n+*/\n fn spawn_joinable<unique T>(-data: T, f: fn(T)) -> joinable_task {\n     let p = comm::port::<task_notification>();\n     let id = spawn_notify(data, f, comm::chan::<task_notification>(p));"}]}