{"sha": "715e9340a1006e37aed381e320ddf30311c2c2a6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxNWU5MzQwYTEwMDZlMzdhZWQzODFlMzIwZGRmMzAzMTFjMmMyYTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-15T02:09:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-15T02:09:34Z"}, "message": "Auto merge of #74532 - fusion-engineering-forks:atomic-from-mut, r=KodrAus\n\nAdd Atomic*::from_mut.\n\nThe atomic equivalent of [`Cell::from_mut`](https://doc.rust-lang.org/stable/std/cell/struct.Cell.html#method.from_mut).", "tree": {"sha": "db28a6d9ed5d99e81f39e651799ae91de9a63c20", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db28a6d9ed5d99e81f39e651799ae91de9a63c20"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/715e9340a1006e37aed381e320ddf30311c2c2a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/715e9340a1006e37aed381e320ddf30311c2c2a6", "html_url": "https://github.com/rust-lang/rust/commit/715e9340a1006e37aed381e320ddf30311c2c2a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/715e9340a1006e37aed381e320ddf30311c2c2a6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "255ceeb5ff9875b7f525aa101c8adc155f3e0ef8", "url": "https://api.github.com/repos/rust-lang/rust/commits/255ceeb5ff9875b7f525aa101c8adc155f3e0ef8", "html_url": "https://github.com/rust-lang/rust/commit/255ceeb5ff9875b7f525aa101c8adc155f3e0ef8"}, {"sha": "9914c3beed0f4a829e78eafb36bac39d418b71f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/9914c3beed0f4a829e78eafb36bac39d418b71f5", "html_url": "https://github.com/rust-lang/rust/commit/9914c3beed0f4a829e78eafb36bac39d418b71f5"}], "stats": {"total": 99, "additions": 98, "deletions": 1}, "files": [{"sha": "9d74f537491b1d076967137cbfeee1cdbc7defdc", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 98, "deletions": 1, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/715e9340a1006e37aed381e320ddf30311c2c2a6/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/715e9340a1006e37aed381e320ddf30311c2c2a6/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=715e9340a1006e37aed381e320ddf30311c2c2a6", "patch": "@@ -110,6 +110,7 @@ use self::Ordering::*;\n use crate::cell::UnsafeCell;\n use crate::fmt;\n use crate::intrinsics;\n+use crate::mem::align_of;\n \n use crate::hint::spin_loop;\n \n@@ -327,6 +328,27 @@ impl AtomicBool {\n         unsafe { &mut *(self.v.get() as *mut bool) }\n     }\n \n+    /// Get atomic access to a `&mut bool`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(atomic_from_mut)]\n+    /// use std::sync::atomic::{AtomicBool, Ordering};\n+    ///\n+    /// let mut some_bool = true;\n+    /// let a = AtomicBool::from_mut(&mut some_bool);\n+    /// a.store(false, Ordering::Relaxed);\n+    /// assert_eq!(some_bool, false);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"atomic_from_mut\", issue = \"76314\")]\n+    pub fn from_mut(v: &mut bool) -> &Self {\n+        // SAFETY: the mutable reference guarantees unique ownership, and\n+        // alignment of both `bool` and `Self` is 1.\n+        unsafe { &*(v as *mut bool as *mut Self) }\n+    }\n+\n     /// Consumes the atomic and returns the contained value.\n     ///\n     /// This is safe because passing `self` by value guarantees that no other threads are\n@@ -820,6 +842,30 @@ impl<T> AtomicPtr<T> {\n         unsafe { &mut *self.p.get() }\n     }\n \n+    /// Get atomic access to a pointer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(atomic_from_mut)]\n+    /// use std::sync::atomic::{AtomicPtr, Ordering};\n+    ///\n+    /// let mut some_ptr = &mut 123 as *mut i32;\n+    /// let a = AtomicPtr::from_mut(&mut some_ptr);\n+    /// a.store(&mut 456, Ordering::Relaxed);\n+    /// assert_eq!(unsafe { *some_ptr }, 456);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"atomic_from_mut\", issue = \"76314\")]\n+    pub fn from_mut(v: &mut *mut T) -> &Self {\n+        let [] = [(); align_of::<AtomicPtr<()>>() - align_of::<*mut ()>()];\n+        // SAFETY:\n+        //  - the mutable reference guarantees unique ownership.\n+        //  - the alignment of `*mut T` and `Self` is the same on all platforms\n+        //    supported by rust, as verified above.\n+        unsafe { &*(v as *mut *mut T as *mut Self) }\n+    }\n+\n     /// Consumes the atomic and returns the contained value.\n     ///\n     /// This is safe because passing `self` by value guarantees that no other threads are\n@@ -1104,6 +1150,13 @@ impl<T> From<*mut T> for AtomicPtr<T> {\n     }\n }\n \n+#[allow(unused_macros)] // This macro ends up being unused on some architectures.\n+macro_rules! if_not_8_bit {\n+    (u8, $($tt:tt)*) => { \"\" };\n+    (i8, $($tt:tt)*) => { \"\" };\n+    ($_:ident, $($tt:tt)*) => { $($tt)* };\n+}\n+\n #[cfg(target_has_atomic_load_store = \"8\")]\n macro_rules! atomic_int {\n     ($cfg_cas:meta,\n@@ -1115,7 +1168,8 @@ macro_rules! atomic_int {\n      $stable_nand:meta,\n      $const_stable:meta,\n      $stable_init_const:meta,\n-     $s_int_type:expr, $int_ref:expr,\n+     $(from_mut: cfg($from_mut_cfg:meta),)?\n+     $s_int_type:literal, $int_ref:expr,\n      $extra_feature:expr,\n      $min_fn:ident, $max_fn:ident,\n      $align:expr,\n@@ -1226,6 +1280,45 @@ assert_eq!(some_var.load(Ordering::SeqCst), 5);\n                 }\n             }\n \n+            doc_comment! {\n+                concat!(\"Get atomic access to a `&mut \", stringify!($int_type), \"`.\n+\n+\",\n+if_not_8_bit! {\n+    $int_type,\n+    concat!(\n+        \"**Note:** This function is only available on targets where `\",\n+        stringify!($int_type), \"` has an alignment of \", $align, \" bytes.\"\n+    )\n+},\n+\"\n+\n+# Examples\n+\n+```\n+#![feature(atomic_from_mut)]\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let mut some_int = 123;\n+let a = \", stringify!($atomic_type), \"::from_mut(&mut some_int);\n+a.store(100, Ordering::Relaxed);\n+assert_eq!(some_int, 100);\n+```\n+                \"),\n+                #[inline]\n+                $(#[cfg($from_mut_cfg)])?\n+                #[unstable(feature = \"atomic_from_mut\", issue = \"76314\")]\n+                pub fn from_mut(v: &mut $int_type) -> &Self {\n+                    let [] = [(); align_of::<Self>() - align_of::<$int_type>()];\n+                    // SAFETY:\n+                    //  - the mutable reference guarantees unique ownership.\n+                    //  - the alignment of `$int_type` and `Self` is the\n+                    //    same on all platforms enabled by `$from_mut_cfg`\n+                    //    as verified above.\n+                    unsafe { &*(v as *mut $int_type as *mut Self) }\n+                }\n+            }\n+\n             doc_comment! {\n                 concat!(\"Consumes the atomic and returns the contained value.\n \n@@ -1984,6 +2077,7 @@ atomic_int! {\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    from_mut: cfg(not(target_arch = \"x86\")),\n     \"i64\", \"../../../std/primitive.i64.html\",\n     \"\",\n     atomic_min, atomic_max,\n@@ -2002,6 +2096,7 @@ atomic_int! {\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    from_mut: cfg(not(target_arch = \"x86\")),\n     \"u64\", \"../../../std/primitive.u64.html\",\n     \"\",\n     atomic_umin, atomic_umax,\n@@ -2020,6 +2115,7 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    from_mut: cfg(not(target_arch = \"x86_64\")),\n     \"i128\", \"../../../std/primitive.i128.html\",\n     \"#![feature(integer_atomics)]\\n\\n\",\n     atomic_min, atomic_max,\n@@ -2038,6 +2134,7 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    from_mut: cfg(not(target_arch = \"x86_64\")),\n     \"u128\", \"../../../std/primitive.u128.html\",\n     \"#![feature(integer_atomics)]\\n\\n\",\n     atomic_umin, atomic_umax,"}]}