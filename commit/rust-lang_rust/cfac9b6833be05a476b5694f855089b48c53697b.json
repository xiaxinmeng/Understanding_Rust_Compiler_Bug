{"sha": "cfac9b6833be05a476b5694f855089b48c53697b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmYWM5YjY4MzNiZTA1YTQ3NmI1Njk0Zjg1NTA4OWI0OGM1MzY5N2I=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-06-01T22:46:32Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-06-02T17:08:04Z"}, "message": "improve borrowck to handle some frankly rather tricky cases\n\n- receivers of method calls are also borrowed\n- by-val arguments are also borrowed (needs tests)\n- assignment to components can interfere with loans", "tree": {"sha": "1fd8ab9fa8f1204c0f3ae2304c33b0bea3edb33a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1fd8ab9fa8f1204c0f3ae2304c33b0bea3edb33a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cfac9b6833be05a476b5694f855089b48c53697b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cfac9b6833be05a476b5694f855089b48c53697b", "html_url": "https://github.com/rust-lang/rust/commit/cfac9b6833be05a476b5694f855089b48c53697b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cfac9b6833be05a476b5694f855089b48c53697b/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5f2c1d61eae7e848c3d3e1506349e77c44175da", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5f2c1d61eae7e848c3d3e1506349e77c44175da", "html_url": "https://github.com/rust-lang/rust/commit/c5f2c1d61eae7e848c3d3e1506349e77c44175da"}], "stats": {"total": 323, "additions": 278, "deletions": 45}, "files": [{"sha": "261ee3ea802438366800853c4aa4310010e7793c", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cfac9b6833be05a476b5694f855089b48c53697b/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfac9b6833be05a476b5694f855089b48c53697b/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=cfac9b6833be05a476b5694f855089b48c53697b", "patch": "@@ -149,7 +149,7 @@ Borrowck results in two maps.\n \"];\n \n import syntax::ast;\n-import syntax::ast::{m_mutbl, m_imm, m_const};\n+import syntax::ast::{mutability, m_mutbl, m_imm, m_const};\n import syntax::visit;\n import syntax::ast_util;\n import syntax::ast_map;\n@@ -254,7 +254,8 @@ enum ptr_kind {uniq_ptr, gc_ptr, region_ptr, unsafe_ptr}\n // I am coining the term \"components\" to mean \"pieces of a data\n // structure accessible without a dereference\":\n enum comp_kind {comp_tuple, comp_res, comp_variant,\n-                comp_field(str), comp_index(ty::t)}\n+                comp_field(str, ast::mutability),\n+                comp_index(ty::t, ast::mutability)}\n \n // We pun on *T to mean both actual deref of a ptr as well\n // as accessing of components:\n@@ -422,8 +423,8 @@ impl to_str_methods for borrowck_ctxt {\n \n     fn comp_to_repr(comp: comp_kind) -> str {\n         alt comp {\n-          comp_field(fld) { fld }\n-          comp_index(_) { \"[]\" }\n+          comp_field(fld, _) { fld }\n+          comp_index(*) { \"[]\" }\n           comp_tuple { \"()\" }\n           comp_res { \"<res>\" }\n           comp_variant { \"<enum>\" }\n@@ -480,11 +481,11 @@ impl to_str_methods for borrowck_ctxt {\n           cat_deref(_, _, pk) { #fmt[\"dereference of %s %s pointer\",\n                                      mut_str, self.pk_to_sigil(pk)] }\n           cat_stack_upvar(_) { mut_str + \" upvar\" }\n-          cat_comp(_, comp_field(_)) { mut_str + \" field\" }\n+          cat_comp(_, comp_field(*)) { mut_str + \" field\" }\n           cat_comp(_, comp_tuple) { \"tuple content\" }\n           cat_comp(_, comp_res) { \"resource content\" }\n           cat_comp(_, comp_variant) { \"enum content\" }\n-          cat_comp(_, comp_index(t)) {\n+          cat_comp(_, comp_index(t, _)) {\n             alt ty::get(t).struct {\n               ty::ty_vec(*) | ty::ty_evec(*) {\n                 mut_str + \" vec content\"\n@@ -522,3 +523,14 @@ impl to_str_methods for borrowck_ctxt {\n         }\n     }\n }\n+\n+// The inherent mutability of a component is its default mutability\n+// assuming it is embedded in an immutable context.  In general, the\n+// mutability can be \"overridden\" if the component is embedded in a\n+// mutable structure.\n+fn inherent_mutability(ck: comp_kind) -> mutability {\n+    alt ck {\n+      comp_tuple | comp_res | comp_variant {m_imm}\n+      comp_field(_, m) | comp_index(_, m) {m}\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "31763bb11c2e73258fce5751caca8404ac1f65e8", "filename": "src/rustc/middle/borrowck/categorization.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/cfac9b6833be05a476b5694f855089b48c53697b/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfac9b6833be05a476b5694f855089b48c53697b/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs?ref=cfac9b6833be05a476b5694f855089b48c53697b", "patch": "@@ -30,43 +30,53 @@ then an index to jump forward to the relevant item.\n \"];\n \n export public_methods;\n+export opt_deref_kind;\n \n // Categorizes a derefable type.  Note that we include vectors and strings as\n // derefable (we model an index as the combination of a deref and then a\n // pointer adjustment).\n-fn deref_kind(tcx: ty::ctxt, t: ty::t) -> deref_kind {\n+fn opt_deref_kind(t: ty::t) -> option<deref_kind> {\n     alt ty::get(t).struct {\n       ty::ty_uniq(*) | ty::ty_vec(*) | ty::ty_str |\n       ty::ty_evec(_, ty::vstore_uniq) |\n       ty::ty_estr(ty::vstore_uniq) {\n-        deref_ptr(uniq_ptr)\n+        some(deref_ptr(uniq_ptr))\n       }\n \n       ty::ty_rptr(*) |\n       ty::ty_evec(_, ty::vstore_slice(_)) |\n       ty::ty_estr(ty::vstore_slice(_)) {\n-        deref_ptr(region_ptr)\n+        some(deref_ptr(region_ptr))\n       }\n \n       ty::ty_box(*) |\n       ty::ty_evec(_, ty::vstore_box) |\n       ty::ty_estr(ty::vstore_box) {\n-        deref_ptr(gc_ptr)\n+        some(deref_ptr(gc_ptr))\n       }\n \n       ty::ty_ptr(*) {\n-        deref_ptr(unsafe_ptr)\n+        some(deref_ptr(unsafe_ptr))\n       }\n \n       ty::ty_enum(*) {\n-        deref_comp(comp_variant)\n+        some(deref_comp(comp_variant))\n       }\n \n       ty::ty_res(*) {\n-        deref_comp(comp_res)\n+        some(deref_comp(comp_res))\n       }\n \n       _ {\n+        none\n+      }\n+    }\n+}\n+\n+fn deref_kind(tcx: ty::ctxt, t: ty::t) -> deref_kind {\n+    alt opt_deref_kind(t) {\n+      some(k) {k}\n+      none {\n         tcx.sess.bug(\n             #fmt[\"deref_cat() invoked on non-derefable type %s\",\n                  ty_to_str(tcx, t)]);\n@@ -281,11 +291,12 @@ impl public_methods for borrowck_ctxt {\n           m_imm { base_cmt.mutbl } // imm: as mutable as the container\n           m_mutbl | m_const { f_mutbl }\n         };\n+        let f_comp = comp_field(f_name, f_mutbl);\n         let lp = base_cmt.lp.map { |lp|\n-            @lp_comp(lp, comp_field(f_name))\n+            @lp_comp(lp, f_comp)\n         };\n         @{id: node.id(), span: node.span(),\n-          cat: cat_comp(base_cmt, comp_field(f_name)), lp:lp,\n+          cat: cat_comp(base_cmt, f_comp), lp:lp,\n           mutbl: m, ty: self.tcx.ty(node)}\n     }\n \n@@ -347,8 +358,8 @@ impl public_methods for borrowck_ctxt {\n         let deref_lp = base_cmt.lp.map { |lp| @lp_deref(lp, ptr) };\n         let deref_cmt = @{id:expr.id, span:expr.span,\n                           cat:cat_deref(base_cmt, 0u, ptr), lp:deref_lp,\n-                          mutbl:mt.mutbl, ty:mt.ty};\n-        let comp = comp_index(base_cmt.ty);\n+                          mutbl:m_imm, ty:mt.ty};\n+        let comp = comp_index(base_cmt.ty, mt.mutbl);\n         let index_lp = deref_lp.map { |lp| @lp_comp(lp, comp) };\n         @{id:expr.id, span:expr.span,\n           cat:cat_comp(deref_cmt, comp), lp:index_lp,"}, {"sha": "414f7f3dac7643158b784fa93198d7f795980996", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 43, "deletions": 20, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/cfac9b6833be05a476b5694f855089b48c53697b/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfac9b6833be05a476b5694f855089b48c53697b/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=cfac9b6833be05a476b5694f855089b48c53697b", "patch": "@@ -262,7 +262,7 @@ impl methods for check_loan_ctxt {\n \n     fn is_self_field(cmt: cmt) -> bool {\n         alt cmt.cat {\n-          cat_comp(cmt_base, comp_field(_)) {\n+          cat_comp(cmt_base, comp_field(*)) {\n             alt cmt_base.cat {\n               cat_special(sk_self) { true }\n               _ { false }\n@@ -314,31 +314,54 @@ impl methods for check_loan_ctxt {\n         // which will be checked for compat separately in\n         // check_for_conflicting_loans()\n         if at != at_mutbl_ref {\n-            let lp = alt cmt.lp {\n-              none { ret; }\n-              some(lp) { lp }\n-            };\n-            for self.walk_loans_of(ex.id, lp) { |loan|\n-                alt loan.mutbl {\n-                  m_mutbl | m_const { /*ok*/ }\n-                  m_imm {\n-                    self.bccx.span_err(\n-                        ex.span,\n-                        #fmt[\"%s prohibited due to outstanding loan\",\n-                             at.ing_form(self.bccx.cmt_to_str(cmt))]);\n-                    self.bccx.span_note(\n-                        loan.cmt.span,\n-                        #fmt[\"loan of %s granted here\",\n-                             self.bccx.cmt_to_str(loan.cmt)]);\n-                    ret;\n-                  }\n-                }\n+            for cmt.lp.each { |lp|\n+                self.check_for_loan_conflicting_with_assignment(\n+                    at, ex, cmt, lp);\n             }\n         }\n \n         self.bccx.add_to_mutbl_map(cmt);\n     }\n \n+    fn check_for_loan_conflicting_with_assignment(\n+        at: assignment_type,\n+        ex: @ast::expr,\n+        cmt: cmt,\n+        lp: @loan_path) {\n+\n+        for self.walk_loans_of(ex.id, lp) { |loan|\n+            alt loan.mutbl {\n+              m_mutbl | m_const { /*ok*/ }\n+              m_imm {\n+                self.bccx.span_err(\n+                    ex.span,\n+                    #fmt[\"%s prohibited due to outstanding loan\",\n+                         at.ing_form(self.bccx.cmt_to_str(cmt))]);\n+                self.bccx.span_note(\n+                    loan.cmt.span,\n+                    #fmt[\"loan of %s granted here\",\n+                         self.bccx.cmt_to_str(loan.cmt)]);\n+                ret;\n+              }\n+            }\n+        }\n+\n+        // Subtle: if the mutability of the component being assigned\n+        // is inherited from the thing that the component is embedded\n+        // within, then we have to check whether that thing has been\n+        // loaned out as immutable!  An example:\n+        //    let mut x = {f: some(3)};\n+        //    let y = &x; // x loaned out as immutable\n+        //    x.f = none; // changes type of y.f, which appears to be imm\n+        alt *lp {\n+          lp_comp(lp_base, ck) if inherent_mutability(ck) != m_mutbl {\n+            self.check_for_loan_conflicting_with_assignment(\n+                at, ex, cmt, lp_base);\n+          }\n+          lp_comp(*) | lp_local(*) | lp_arg(*) | lp_deref(*) {}\n+        }\n+    }\n+\n     fn report_purity_error(pc: purity_cause, sp: span, msg: str) {\n         alt pc {\n           pc_pure_fn {"}, {"sha": "da6dbe460ed6db501c65fbb0c695caefa84a6fc9", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 54, "deletions": 2, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/cfac9b6833be05a476b5694f855089b48c53697b/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfac9b6833be05a476b5694f855089b48c53697b/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=cfac9b6833be05a476b5694f855089b48c53697b", "patch": "@@ -6,7 +6,7 @@\n // their associated scopes.  In phase two, checking loans, we will then make\n // sure that all of these loans are honored.\n \n-import categorization::public_methods;\n+import categorization::{public_methods, opt_deref_kind};\n import loan::public_methods;\n import preserve::public_methods;\n \n@@ -30,6 +30,8 @@ fn req_loans_in_expr(ex: @ast::expr,\n     let bccx = self.bccx;\n     let tcx = bccx.tcx;\n \n+    #debug[\"req_loans_in_expr(ex=%s)\", pprust::expr_to_str(ex)];\n+\n     // If this expression is borrowed, have to ensure it remains valid:\n     for tcx.borrowings.find(ex.id).each { |borrow|\n         let cmt = self.bccx.cat_borrow_of_expr(ex);\n@@ -64,7 +66,39 @@ fn req_loans_in_expr(ex: @ast::expr,\n                 let arg_cmt = self.bccx.cat_expr(arg);\n                 self.guarantee_valid(arg_cmt, m_imm,  scope_r);\n               }\n-              ast::by_move | ast::by_copy | ast::by_val {}\n+              ast::by_val {\n+                // Rust's by-val does not actually give ownership to\n+                // the callee.  This means that if a pointer type is\n+                // passed, it is effectively a borrow, and so the\n+                // caller must guarantee that the data remains valid.\n+                //\n+                // Subtle: we only guarantee that the pointer is valid\n+                // and const.  Technically, we ought to pass in the\n+                // mutability that the caller expects (e.g., if the\n+                // formal argument has type @mut, we should guarantee\n+                // validity and mutability, not validity and const).\n+                // However, the type system already guarantees that\n+                // the caller's mutability is compatible with the\n+                // callee, so this is not necessary.  (Note that with\n+                // actual borrows, typeck is more liberal and allows\n+                // the pointer to be borrowed as immutable even if it\n+                // is mutable in the caller's frame, thus effectively\n+                // passing the buck onto us to enforce this)\n+\n+                alt opt_deref_kind(arg_ty.ty) {\n+                  some(deref_ptr(region_ptr)) {\n+                    /* region pointers are (by induction) guaranteed */\n+                  }\n+                  none {\n+                    /* not a pointer, no worries */\n+                  }\n+                  some(_) {\n+                    let arg_cmt = self.bccx.cat_borrow_of_expr(arg);\n+                    self.guarantee_valid(arg_cmt, m_const, scope_r);\n+                  }\n+                }\n+              }\n+              ast::by_move | ast::by_copy {}\n             }\n         }\n       }\n@@ -78,6 +112,24 @@ fn req_loans_in_expr(ex: @ast::expr,\n         }\n       }\n \n+      ast::expr_field(rcvr, _, _) |\n+      ast::expr_binary(_, rcvr, _) |\n+      ast::expr_unary(_, rcvr) if self.bccx.method_map.contains_key(ex.id) {\n+        // Receivers in method calls are always passed by ref.\n+        //\n+        // FIXME--this scope is both too large and too small.  We make\n+        // the scope the enclosing block, which surely includes any\n+        // immediate call (a.b()) but which is too big.  OTOH, in the\n+        // case of a naked field `a.b`, the value is copied\n+        // anyhow. This is probably best fixed if we address the\n+        // syntactic ambiguity.\n+\n+        // let scope_r = ty::re_scope(ex.id);\n+        let scope_r = ty::re_scope(self.tcx().region_map.get(ex.id));\n+        let rcvr_cmt = self.bccx.cat_expr(rcvr);\n+        self.guarantee_valid(rcvr_cmt, m_imm, scope_r);\n+      }\n+\n       _ { /*ok*/ }\n     }\n "}, {"sha": "e54ac388f0f38c73891f551d0471ddd6bab27cc4", "filename": "src/rustc/middle/borrowck/loan.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfac9b6833be05a476b5694f855089b48c53697b/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfac9b6833be05a476b5694f855089b48c53697b/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=cfac9b6833be05a476b5694f855089b48c53697b", "patch": "@@ -55,8 +55,8 @@ impl loan_methods for loan_ctxt {\n           cat_discr(base, _) {\n             self.loan(base, req_mutbl)\n           }\n-          cat_comp(cmt_base, comp_field(_)) |\n-          cat_comp(cmt_base, comp_index(_)) |\n+          cat_comp(cmt_base, comp_field(*)) |\n+          cat_comp(cmt_base, comp_index(*)) |\n           cat_comp(cmt_base, comp_tuple) |\n           cat_comp(cmt_base, comp_res) {\n             // For most components, the type of the embedded data is"}, {"sha": "250d1daed1247e4dd3b9d7bb4cabbaca4cb9c1d7", "filename": "src/rustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfac9b6833be05a476b5694f855089b48c53697b/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfac9b6833be05a476b5694f855089b48c53697b/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=cfac9b6833be05a476b5694f855089b48c53697b", "patch": "@@ -29,8 +29,8 @@ impl public_methods for borrowck_ctxt {\n             // This is basically a deref of a region ptr.\n             ok(())\n           }\n-          cat_comp(cmt_base, comp_field(_)) |\n-          cat_comp(cmt_base, comp_index(_)) |\n+          cat_comp(cmt_base, comp_field(*)) |\n+          cat_comp(cmt_base, comp_index(*)) |\n           cat_comp(cmt_base, comp_tuple) |\n           cat_comp(cmt_base, comp_res) {\n             // Most embedded components: if the base is stable, the"}, {"sha": "664bd2680390ac884f97d38630e4dd47da33aef5", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cfac9b6833be05a476b5694f855089b48c53697b/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfac9b6833be05a476b5694f855089b48c53697b/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=cfac9b6833be05a476b5694f855089b48c53697b", "patch": "@@ -27,14 +27,18 @@ fn re_scope_id_to_str(cx: ctxt, node_id: ast::node_id) -> str {\n       }\n       ast_map::node_expr(expr) {\n         alt expr.node {\n-          ast::expr_call(_, _, _) {\n+          ast::expr_call(*) {\n             #fmt(\"<call at %s>\",\n                  codemap::span_to_str(expr.span, cx.sess.codemap))\n           }\n-          ast::expr_alt(_, _, _) {\n+          ast::expr_alt(*) {\n             #fmt(\"<alt at %s>\",\n                  codemap::span_to_str(expr.span, cx.sess.codemap))\n           }\n+          ast::expr_field(*) | ast::expr_unary(*) | ast::expr_binary(*) {\n+            #fmt(\"<method at %s>\",\n+                 codemap::span_to_str(expr.span, cx.sess.codemap))\n+          }\n           _ { cx.sess.bug(\n               #fmt[\"re_scope refers to %s\",\n                    ast_map::node_id_to_str(cx.items, node_id)]) }"}, {"sha": "c418c855237357276de164065af552e78aace65d", "filename": "src/test/compile-fail/borrowck-assign-comp-idx.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cfac9b6833be05a476b5694f855089b48c53697b/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfac9b6833be05a476b5694f855089b48c53697b/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs?ref=cfac9b6833be05a476b5694f855089b48c53697b", "patch": "@@ -0,0 +1,38 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n+\n+type point = { x: int, y: int };\n+\n+fn a() {\n+    let mut p = [mut 1];\n+\n+    // Create an immutable pointer into p's contents:\n+    let _q: &int = &p[0]; //! NOTE loan of mutable vec content granted here\n+\n+    p[0] = 5; //! ERROR assigning to mutable vec content prohibited due to outstanding loan\n+}\n+\n+fn borrow(_x: [int]/&, _f: fn()) {}\n+\n+fn b() {\n+    // here we alias the mutable vector into an imm slice and try to\n+    // modify the original:\n+\n+    let mut p = [mut 1];\n+\n+    borrow(p) {|| //! NOTE loan of mutable vec content granted here\n+        p[0] = 5; //! ERROR assigning to mutable vec content prohibited due to outstanding loan\n+    }\n+}\n+\n+fn c() {\n+    // Legal because the scope of the borrow does not include the\n+    // modification:\n+    let mut p = [mut 1];\n+    borrow(p, {||});\n+    p[0] = 5;\n+}\n+\n+fn main() {\n+}\n+"}, {"sha": "c8830957c763533e55c8c838bab0c9484fa350c9", "filename": "src/test/compile-fail/borrowck-assign-comp.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/cfac9b6833be05a476b5694f855089b48c53697b/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfac9b6833be05a476b5694f855089b48c53697b/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp.rs?ref=cfac9b6833be05a476b5694f855089b48c53697b", "patch": "@@ -0,0 +1,47 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n+\n+type point = { x: int, y: int };\n+\n+fn a() {\n+    let mut p = {x: 3, y: 4};\n+    let _q = &p; //! NOTE loan of mutable local variable granted here\n+\n+    // This assignment is illegal because the field x is not\n+    // inherently mutable; since `p` was made immutable, `p.x` is now\n+    // immutable.  Otherwise the type of &_q.x (&int) would be wrong.\n+    p.x = 5; //! ERROR assigning to mutable field prohibited due to outstanding loan\n+}\n+\n+fn b() {\n+    let mut p = {x: 3, mut y: 4};\n+    let _q = &p;\n+\n+    // This assignment is legal because `y` is inherently mutable (and\n+    // hence &_q.y is &mut int).\n+    p.y = 5;\n+}\n+\n+fn c() {\n+    // this is sort of the opposite.  We take a loan to the interior of `p`\n+    // and then try to overwrite `p` as a whole.\n+\n+    let mut p = {x: 3, mut y: 4};\n+    let _q = &p.y; //! NOTE loan of mutable local variable granted here\n+    p = {x: 5, mut y: 7};//! ERROR assigning to mutable local variable prohibited due to outstanding loan\n+    copy p;\n+}\n+\n+fn d() {\n+    // just for completeness's sake, the easy case, where we take the\n+    // address of a subcomponent and then modify that subcomponent:\n+\n+    let mut p = {x: 3, mut y: 4};\n+    let _q = &p.y; //! NOTE loan of mutable field granted here\n+    p.y = 5; //! ERROR assigning to mutable field prohibited due to outstanding loan\n+    copy p;\n+}\n+\n+fn main() {\n+}\n+"}, {"sha": "87dd933aa7fe78ef1365c020a4b502ea69f42fac", "filename": "src/test/compile-fail/borrowck-loan-rcvr.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/cfac9b6833be05a476b5694f855089b48c53697b/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfac9b6833be05a476b5694f855089b48c53697b/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs?ref=cfac9b6833be05a476b5694f855089b48c53697b", "patch": "@@ -0,0 +1,46 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n+\n+type point = { x: int, y: int };\n+\n+impl foo for point {\n+    fn impurem() {\n+    }\n+\n+    pure fn purem() {\n+    }\n+}\n+\n+fn a() {\n+    let mut p = {x: 3, y: 4};\n+    p.purem();\n+    p.impurem();\n+}\n+\n+fn a2() {\n+    let mut p = {x: 3, y: 4};\n+    p.purem();\n+    p.impurem();\n+    p.x = p.y;\n+}\n+\n+fn b() {\n+    let mut p = {x: 3, y: 4};\n+\n+    &mut p; //! NOTE prior loan as mutable granted here\n+    //!^ NOTE prior loan as mutable granted here\n+\n+    p.purem(); //! ERROR loan of mutable local variable as immutable conflicts with prior loan\n+    p.impurem(); //! ERROR loan of mutable local variable as immutable conflicts with prior loan\n+}\n+\n+fn c() {\n+    let q = @mut {x: 3, y: 4};\n+    (*q).purem();\n+    (*q).impurem(); //! ERROR illegal borrow unless pure: creating immutable alias to aliasable, mutable memory\n+    //!^ NOTE impure due to access to impure function\n+}\n+\n+fn main() {\n+}\n+"}]}