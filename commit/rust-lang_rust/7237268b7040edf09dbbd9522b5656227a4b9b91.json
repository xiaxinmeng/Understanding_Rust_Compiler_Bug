{"sha": "7237268b7040edf09dbbd9522b5656227a4b9b91", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyMzcyNjhiNzA0MGVkZjA5ZGJiZDk1MjJiNTY1NjIyN2E0YjliOTE=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-15T19:27:09Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-15T19:28:29Z"}, "message": "Allow enum discriminator exprs to refer to declared consts\n\nAlso some work towards #3521\n\nCloses #2428", "tree": {"sha": "d240486e4b2b269748502d3d03a1e185f2ff15ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d240486e4b2b269748502d3d03a1e185f2ff15ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7237268b7040edf09dbbd9522b5656227a4b9b91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7237268b7040edf09dbbd9522b5656227a4b9b91", "html_url": "https://github.com/rust-lang/rust/commit/7237268b7040edf09dbbd9522b5656227a4b9b91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7237268b7040edf09dbbd9522b5656227a4b9b91/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6211ab187abf18f458f289fef3c48b14a0a0af8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6211ab187abf18f458f289fef3c48b14a0a0af8", "html_url": "https://github.com/rust-lang/rust/commit/f6211ab187abf18f458f289fef3c48b14a0a0af8"}], "stats": {"total": 330, "additions": 215, "deletions": 115}, "files": [{"sha": "b402f9727dc2f5695d72d04a545382996d8bc5bf", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7237268b7040edf09dbbd9522b5656227a4b9b91/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7237268b7040edf09dbbd9522b5656227a4b9b91/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=7237268b7040edf09dbbd9522b5656227a4b9b91", "patch": "@@ -182,6 +182,8 @@ fn visit_enum_def<E>(enum_definition: ast::enum_def, tps: ~[ast::ty_param],\n                 visit_enum_def(enum_definition, tps, e, v);\n             }\n         }\n+        // Visit the disr expr if it exists\n+        vr.node.disr_expr.iter(|ex| v.visit_expr(*ex, e, v));\n     }\n }\n "}, {"sha": "ea7b08140f39b1ec2967baf807b150d4c7654086", "filename": "src/rustc/middle/const_eval.rs", "status": "modified", "additions": 124, "deletions": 96, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/7237268b7040edf09dbbd9522b5656227a4b9b91/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7237268b7040edf09dbbd9522b5656227a4b9b91/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fconst_eval.rs?ref=7237268b7040edf09dbbd9522b5656227a4b9b91", "patch": "@@ -1,4 +1,4 @@\n-use syntax::{ast,ast_util,visit};\n+use syntax::{ast,ast_map,ast_util,visit};\n use ast::*;\n \n //\n@@ -135,28 +135,7 @@ fn classify(e: @expr,\n               // FIXME: (#3728) we can probably do something CCI-ish\n               // surrounding nonlocal constants. But we don't yet.\n               ast::expr_path(_) => {\n-                match def_map.find(e.id) {\n-                  Some(ast::def_const(def_id)) => {\n-                    if ast_util::is_local(def_id) {\n-                        let ty = ty::expr_ty(tcx, e);\n-                        if ty::type_is_integral(ty) {\n-                            integral_const\n-                        } else {\n-                            general_const\n-                        }\n-                    } else {\n-                        non_const\n-                    }\n-                  }\n-                  Some(_) => {\n-                    non_const\n-                  }\n-                  None => {\n-                    tcx.sess.span_bug(e.span,\n-                                      ~\"unknown path when \\\n-                                        classifying constants\");\n-                  }\n-                }\n+                lookup_constness(tcx, e)\n               }\n \n               _ => non_const\n@@ -167,6 +146,40 @@ fn classify(e: @expr,\n     }\n }\n \n+fn lookup_const(tcx: ty::ctxt, e: @expr) -> Option<@expr> {\n+    match tcx.def_map.find(e.id) {\n+        Some(ast::def_const(def_id)) => {\n+            if ast_util::is_local(def_id) {\n+                match tcx.items.find(def_id.node) {\n+                    None => None,\n+                    Some(ast_map::node_item(it, _)) => match it.node {\n+                        item_const(_, const_expr) => Some(const_expr),\n+                        _ => None\n+                    },\n+                    Some(_) => None\n+                }\n+            }\n+            else { None }\n+        }\n+        Some(_) => None,\n+        None => None\n+    }\n+}\n+\n+fn lookup_constness(tcx: ty::ctxt, e: @expr) -> constness {\n+    match lookup_const(tcx, e) {\n+        Some(rhs) => {\n+            let ty = ty::expr_ty(tcx, rhs);\n+            if ty::type_is_integral(ty) {\n+                integral_const\n+            } else {\n+                general_const\n+            }\n+        }\n+        None => non_const\n+    }\n+}\n+\n fn process_crate(crate: @ast::crate,\n                  def_map: resolve::DefMap,\n                  tcx: ty::ctxt) {\n@@ -204,58 +217,67 @@ impl const_val : cmp::Eq {\n     pure fn ne(other: &const_val) -> bool { !self.eq(other) }\n }\n \n-// FIXME: issue #1417\n fn eval_const_expr(tcx: middle::ty::ctxt, e: @expr) -> const_val {\n+    match eval_const_expr_partial(tcx, e) {\n+        Ok(r) => r,\n+        Err(s) => fail s\n+    }\n+}\n+\n+fn eval_const_expr_partial(tcx: middle::ty::ctxt, e: @expr)\n+    -> Result<const_val, ~str> {\n     use middle::ty;\n-    fn fromb(b: bool) -> const_val { const_int(b as i64) }\n+    fn fromb(b: bool) -> Result<const_val, ~str> { Ok(const_int(b as i64)) }\n     match e.node {\n       expr_unary(neg, inner) => {\n-        match eval_const_expr(tcx, inner) {\n-          const_float(f) => const_float(-f),\n-          const_int(i) => const_int(-i),\n-          const_uint(i) => const_uint(-i),\n-          const_str(_) => fail ~\"Negate on string\",\n-          const_bool(_) => fail ~\"Negate on boolean\"\n+        match eval_const_expr_partial(tcx, inner) {\n+          Ok(const_float(f)) => Ok(const_float(-f)),\n+          Ok(const_int(i)) => Ok(const_int(-i)),\n+          Ok(const_uint(i)) => Ok(const_uint(-i)),\n+          Ok(const_str(_)) => Err(~\"Negate on string\"),\n+          Ok(const_bool(_)) => Err(~\"Negate on boolean\"),\n+          err => err\n         }\n       }\n       expr_unary(not, inner) => {\n-        match eval_const_expr(tcx, inner) {\n-          const_int(i) => const_int(!i),\n-          const_uint(i) => const_uint(!i),\n-          const_bool(b) => const_bool(!b),\n-          _ => fail ~\"Not on float or string\"\n+        match eval_const_expr_partial(tcx, inner) {\n+          Ok(const_int(i)) => Ok(const_int(!i)),\n+          Ok(const_uint(i)) => Ok(const_uint(!i)),\n+          Ok(const_bool(b)) => Ok(const_bool(!b)),\n+          _ => Err(~\"Not on float or string\")\n         }\n       }\n       expr_binary(op, a, b) => {\n-        match (eval_const_expr(tcx, a), eval_const_expr(tcx, b)) {\n-          (const_float(a), const_float(b)) => {\n+        match (eval_const_expr_partial(tcx, a),\n+               eval_const_expr_partial(tcx, b)) {\n+          (Ok(const_float(a)), Ok(const_float(b))) => {\n             match op {\n-              add => const_float(a + b),\n-              subtract => const_float(a - b),\n-              mul => const_float(a * b),\n-              div => const_float(a / b),\n-              rem => const_float(a % b),\n+              add => Ok(const_float(a + b)),\n+              subtract => Ok(const_float(a - b)),\n+              mul => Ok(const_float(a * b)),\n+              div => Ok(const_float(a / b)),\n+              rem => Ok(const_float(a % b)),\n               eq => fromb(a == b),\n               lt => fromb(a < b),\n               le => fromb(a <= b),\n               ne => fromb(a != b),\n               ge => fromb(a >= b),\n               gt => fromb(a > b),\n-              _ => fail ~\"Can't do this op on floats\"\n+              _ => Err(~\"Can't do this op on floats\")\n             }\n           }\n-          (const_int(a), const_int(b)) => {\n+          (Ok(const_int(a)), Ok(const_int(b))) => {\n             match op {\n-              add => const_int(a + b),\n-              subtract => const_int(a - b),\n-              mul => const_int(a * b),\n-              div => const_int(a / b),\n-              rem => const_int(a % b),\n-              and | bitand => const_int(a & b),\n-              or | bitor => const_int(a | b),\n-              bitxor => const_int(a ^ b),\n-              shl => const_int(a << b),\n-              shr => const_int(a >> b),\n+              add => Ok(const_int(a + b)),\n+              subtract => Ok(const_int(a - b)),\n+              mul => Ok(const_int(a * b)),\n+              div => Ok(const_int(a / b)),\n+              rem => Ok(const_int(a % b)),\n+              and | bitand => Ok(const_int(a & b)),\n+              or | bitor => Ok(const_int(a | b)),\n+              bitxor => Ok(const_int(a ^ b)),\n+              shl => Ok(const_int(a << b)),\n+              shr => Ok(const_int(a >> b)),\n               eq => fromb(a == b),\n               lt => fromb(a < b),\n               le => fromb(a <= b),\n@@ -264,18 +286,18 @@ fn eval_const_expr(tcx: middle::ty::ctxt, e: @expr) -> const_val {\n               gt => fromb(a > b)\n             }\n           }\n-          (const_uint(a), const_uint(b)) => {\n+          (Ok(const_uint(a)), Ok(const_uint(b))) => {\n             match op {\n-              add => const_uint(a + b),\n-              subtract => const_uint(a - b),\n-              mul => const_uint(a * b),\n-              div => const_uint(a / b),\n-              rem => const_uint(a % b),\n-              and | bitand => const_uint(a & b),\n-              or | bitor => const_uint(a | b),\n-              bitxor => const_uint(a ^ b),\n-              shl => const_uint(a << b),\n-              shr => const_uint(a >> b),\n+              add => Ok(const_uint(a + b)),\n+              subtract => Ok(const_uint(a - b)),\n+              mul => Ok(const_uint(a * b)),\n+              div => Ok(const_uint(a / b)),\n+              rem => Ok(const_uint(a % b)),\n+              and | bitand => Ok(const_uint(a & b)),\n+              or | bitor => Ok(const_uint(a | b)),\n+              bitxor => Ok(const_uint(a ^ b)),\n+              shl => Ok(const_uint(a << b)),\n+              shr => Ok(const_uint(a >> b)),\n               eq => fromb(a == b),\n               lt => fromb(a < b),\n               le => fromb(a <= b),\n@@ -285,70 +307,76 @@ fn eval_const_expr(tcx: middle::ty::ctxt, e: @expr) -> const_val {\n             }\n           }\n           // shifts can have any integral type as their rhs\n-          (const_int(a), const_uint(b)) => {\n+          (Ok(const_int(a)), Ok(const_uint(b))) => {\n             match op {\n-              shl => const_int(a << b),\n-              shr => const_int(a >> b),\n-              _ => fail ~\"Can't do this op on an int and uint\"\n+              shl => Ok(const_int(a << b)),\n+              shr => Ok(const_int(a >> b)),\n+              _ => Err(~\"Can't do this op on an int and uint\")\n             }\n           }\n-          (const_uint(a), const_int(b)) => {\n+          (Ok(const_uint(a)), Ok(const_int(b))) => {\n             match op {\n-              shl => const_uint(a << b),\n-              shr => const_uint(a >> b),\n-              _ => fail ~\"Can't do this op on a uint and int\"\n+              shl => Ok(const_uint(a << b)),\n+              shr => Ok(const_uint(a >> b)),\n+              _ => Err(~\"Can't do this op on a uint and int\")\n             }\n           }\n-          (const_bool(a), const_bool(b)) => {\n-            const_bool(match op {\n+          (Ok(const_bool(a)), Ok(const_bool(b))) => {\n+            Ok(const_bool(match op {\n               and => a && b,\n               or => a || b,\n               bitxor => a ^ b,\n               bitand => a & b,\n               bitor => a | b,\n               eq => a == b,\n               ne => a != b,\n-              _ => fail ~\"Can't do this op on bools\"\n-             })\n+              _ => return Err(~\"Can't do this op on bools\")\n+             }))\n           }\n-          _ => fail ~\"Bad operands for binary\"\n+          _ => Err(~\"Bad operands for binary\")\n         }\n       }\n       expr_cast(base, _) => {\n         let ety = ty::expr_ty(tcx, e);\n-        let base = eval_const_expr(tcx, base);\n+        let base = eval_const_expr_partial(tcx, base);\n         match ty::get(ety).sty {\n           ty::ty_float(_) => {\n             match base {\n-              const_uint(u) => const_float(u as f64),\n-              const_int(i) => const_float(i as f64),\n-              const_float(_) => base,\n-              _ => fail ~\"Can't cast float to str\"\n+              Ok(const_uint(u)) => Ok(const_float(u as f64)),\n+              Ok(const_int(i)) => Ok(const_float(i as f64)),\n+              Ok(const_float(_)) => base,\n+              _ => Err(~\"Can't cast float to str\")\n             }\n           }\n           ty::ty_uint(_) => {\n             match base {\n-              const_uint(_) => base,\n-              const_int(i) => const_uint(i as u64),\n-              const_float(f) => const_uint(f as u64),\n-              _ => fail ~\"Can't cast str to uint\"\n+              Ok(const_uint(_)) => base,\n+              Ok(const_int(i)) => Ok(const_uint(i as u64)),\n+              Ok(const_float(f)) => Ok(const_uint(f as u64)),\n+              _ => Err(~\"Can't cast str to uint\")\n             }\n           }\n           ty::ty_int(_) | ty::ty_bool => {\n             match base {\n-              const_uint(u) => const_int(u as i64),\n-              const_int(_) => base,\n-              const_float(f) => const_int(f as i64),\n-              _ => fail ~\"Can't cast str to int\"\n+              Ok(const_uint(u)) => Ok(const_int(u as i64)),\n+              Ok(const_int(_)) => base,\n+              Ok(const_float(f)) => Ok(const_int(f as i64)),\n+              _ => Err(~\"Can't cast str to int\")\n             }\n           }\n-          _ => fail ~\"Can't cast this type\"\n+          _ => Err(~\"Can't cast this type\")\n         }\n       }\n-      expr_lit(lit) => lit_to_const(lit),\n+      expr_path(_) => {\n+          match lookup_const(tcx, e) {\n+              Some(actual_e) => eval_const_expr_partial(tcx, actual_e),\n+              None => Err(~\"Non-constant path in constant expr\")\n+          }\n+      }\n+      expr_lit(lit) => Ok(lit_to_const(lit)),\n       // If we have a vstore, just keep going; it has to be a string\n-      expr_vstore(e, _) => eval_const_expr(tcx, e),\n-      _ => fail ~\"Unsupported constant expr\"\n+      expr_vstore(e, _) => eval_const_expr_partial(tcx, e),\n+      _ => Err(~\"Unsupported constant expr\")\n     }\n }\n "}, {"sha": "b6e1729a07a7fb524fa8f5a3dded55686dd68442", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 51, "deletions": 7, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/7237268b7040edf09dbbd9522b5656227a4b9b91/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7237268b7040edf09dbbd9522b5656227a4b9b91/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=7237268b7040edf09dbbd9522b5656227a4b9b91", "patch": "@@ -257,7 +257,10 @@ enum RibKind {\n     MethodRibKind(node_id, MethodSort),\n \n     // We passed through a function *item* scope. Disallow upvars.\n-    OpaqueFunctionRibKind\n+    OpaqueFunctionRibKind,\n+\n+    // We're in a constant item. Can't refer to dynamic stuff.\n+    ConstantItemRibKind\n }\n \n // Methods can be required or provided. Required methods only occur in traits.\n@@ -3114,9 +3117,16 @@ impl Resolver {\n \n                     return None;\n                 }\n+                ConstantItemRibKind => {\n+                    // Still doesn't deal with upvars\n+                    self.session.span_err(span,\n+                                          ~\"attempt to use a non-constant \\\n+                                            value in a constant\");\n+\n+                }\n             }\n \n-            rib_index += 1u;\n+            rib_index += 1;\n         }\n \n         return Some(dl_def(def));\n@@ -3130,8 +3140,8 @@ impl Resolver {\n         // XXX: Try caching?\n \n         let mut i = (*ribs).len();\n-        while i != 0u {\n-            i -= 1u;\n+        while i != 0 {\n+            i -= 1;\n             let rib = (*ribs).get_elt(i);\n             match rib.bindings.find(name) {\n                 Some(def_like) => {\n@@ -3179,7 +3189,33 @@ impl Resolver {\n         }\n \n         match item.node {\n-            item_enum(_, type_parameters) |\n+\n+            // enum item: resolve all the variants' discrs,\n+            // then resolve the ty params\n+            item_enum(enum_def, type_parameters) => {\n+\n+                for enum_def.variants.each() |variant| {\n+                    do variant.node.disr_expr.iter() |dis_expr| {\n+                        // resolve the discriminator expr\n+                        // as a constant\n+                        self.with_constant_rib(|| {\n+                            self.resolve_expr(*dis_expr, visitor); \n+                        });\n+                    }\n+                }\n+\n+                // n.b. the discr expr gets visted twice.\n+                // but maybe it's okay since the first time will signal an\n+                // error if there is one? -- tjc\n+                do self.with_type_parameter_rib\n+                        (HasTypeParameters(&type_parameters, item.id, 0,\n+                                           NormalRibKind))\n+                        || {\n+\n+                    visit_item(item, (), visitor);\n+                }\n+            }\n+                \n             item_ty(_, type_parameters) => {\n                 do self.with_type_parameter_rib\n                         (HasTypeParameters(&type_parameters, item.id, 0u,\n@@ -3344,7 +3380,9 @@ impl Resolver {\n             }\n \n             item_const(*) => {\n-                visit_item(item, (), visitor);\n+                self.with_constant_rib(|| {\n+                    visit_item(item, (), visitor);\n+                });\n             }\n \n           item_mac(*) => {\n@@ -3401,6 +3439,12 @@ impl Resolver {\n         f();\n         (*self.label_ribs).pop();\n     }\n+    fn with_constant_rib(f: fn()) {\n+        (*self.value_ribs).push(@Rib(ConstantItemRibKind));\n+        f();\n+        (*self.value_ribs).pop();\n+    }\n+\n \n     fn resolve_function(rib_kind: RibKind,\n                         optional_declaration: Option<@fn_decl>,\n@@ -4127,7 +4171,7 @@ impl Resolver {\n                                                  namespace);\n         }\n \n-        if path.idents.len() > 1u {\n+        if path.idents.len() > 1 {\n             return self.resolve_module_relative_path(path,\n                                                   self.xray_context,\n                                                   namespace);"}, {"sha": "9a7f2192cb144af722671e05c2758a4855a5e135", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7237268b7040edf09dbbd9522b5656227a4b9b91/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7237268b7040edf09dbbd9522b5656227a4b9b91/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=7237268b7040edf09dbbd9522b5656227a4b9b91", "patch": "@@ -2219,9 +2219,14 @@ fn check_block(fcx0: @fn_ctxt, blk: ast::blk) -> bool {\n fn check_const(ccx: @crate_ctxt, _sp: span, e: @ast::expr, id: ast::node_id) {\n     let rty = ty::node_id_to_type(ccx.tcx, id);\n     let fcx = blank_fn_ctxt(ccx, rty, e.id);\n+    let declty = fcx.ccx.tcx.tcache.get(local_def(id)).ty;\n+    check_const_with_ty(fcx, _sp, e, declty);\n+}\n+\n+fn check_const_with_ty(fcx: @fn_ctxt, _sp: span, e: @ast::expr,\n+                       declty: ty::t) {\n     check_expr(fcx, e, None);\n     let cty = fcx.expr_ty(e);\n-    let declty = fcx.ccx.tcx.tcache.get(local_def(id)).ty;\n     demand::suptype(fcx, e.span, declty, cty);\n     regionck::regionck_expr(fcx, e);\n     writeback::resolve_type_vars_in_expr(fcx, e);\n@@ -2259,27 +2264,31 @@ fn check_enum_variants(ccx: @crate_ctxt,\n                 variants: &mut ~[ty::variant_info]) {\n         let rty = ty::node_id_to_type(ccx.tcx, id);\n         for vs.each |v| {\n-            match v.node.disr_expr {\n-              Some(e) => {\n-                let fcx = blank_fn_ctxt(ccx, rty, e.id);\n-                check_expr(fcx, e, None);\n-                let cty = fcx.expr_ty(e);\n+            do v.node.disr_expr.iter |e_ref| {\n+                let e = *e_ref;\n+                debug!(\"disr expr, checking %s\",\n+                       expr_to_str(e, ccx.tcx.sess.intr()));\n                 let declty = ty::mk_int(ccx.tcx);\n-                demand::suptype(fcx, e.span, declty, cty);\n+                let fcx = blank_fn_ctxt(ccx, rty, e.id);\n+                check_const_with_ty(fcx, e.span, e, declty);\n                 // check_expr (from check_const pass) doesn't guarantee\n                 // that the expression is in an form that eval_const_expr can\n                 // handle, so we may still get an internal compiler error\n-                match const_eval::eval_const_expr(ccx.tcx, e) {\n-                  const_eval::const_int(val) => {\n+\n+                match const_eval::eval_const_expr_partial(ccx.tcx, e) {\n+                  Ok(const_eval::const_int(val)) => {\n                     *disr_val = val as int;\n                   }\n-                  _ => {\n+                  Ok(_) => {\n                     ccx.tcx.sess.span_err(e.span, ~\"expected signed integer \\\n                                                     constant\");\n                   }\n+                  Err(err) => {\n+                    ccx.tcx.sess.span_err(e.span,\n+                     #fmt(\"expected constant: %s\", err));\n+\n+                  }\n                 }\n-              }\n-              _ => ()\n             }\n             if vec::contains(*disr_vals, &*disr_val) {\n                 ccx.tcx.sess.span_err(v.span,"}, {"sha": "5af0417af047fe03673b0a1f3374f6a9effab181", "filename": "src/test/compile-fail/issue-3521-2.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7237268b7040edf09dbbd9522b5656227a4b9b91/src%2Ftest%2Fcompile-fail%2Fissue-3521-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7237268b7040edf09dbbd9522b5656227a4b9b91/src%2Ftest%2Fcompile-fail%2Fissue-3521-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3521-2.rs?ref=7237268b7040edf09dbbd9522b5656227a4b9b91", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    let foo = 100;\n+\n+    const y: int = foo + 1; //~ ERROR: attempt to use a non-constant value in a constant\n+\n+    log(error, y);\n+}"}, {"sha": "76fc674e73448fdd5388a1d84f12b4d4cca674af", "filename": "src/test/run-pass/issue-2428.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7237268b7040edf09dbbd9522b5656227a4b9b91/src%2Ftest%2Frun-pass%2Fissue-2428.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7237268b7040edf09dbbd9522b5656227a4b9b91/src%2Ftest%2Frun-pass%2Fissue-2428.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2428.rs?ref=7237268b7040edf09dbbd9522b5656227a4b9b91", "patch": "@@ -0,0 +1,10 @@\n+fn main() {\n+    let foo = 100;\n+    const quux: int = 5;\n+\n+    enum Stuff {\n+        Bar = quux\n+    }\n+\n+    assert (Bar as int == quux);\n+}"}]}