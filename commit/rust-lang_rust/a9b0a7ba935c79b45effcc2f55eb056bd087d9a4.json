{"sha": "a9b0a7ba935c79b45effcc2f55eb056bd087d9a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5YjBhN2JhOTM1Yzc5YjQ1ZWZmY2MyZjU1ZWIwNTZiZDA4N2Q5YTQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-08-26T22:01:48Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-08-28T01:53:30Z"}, "message": "rustbuild: Rewrite the configure script in Python\n\nThis commit rewrites our ancient `./configure` script from shell into Python.\nThe impetus for this change is to remove `config.mk` which is just a vestige of\nthe old makefile build system at this point. Instead all configuration is now\nsolely done through `config.toml`.\n\nThe python script allows us to more flexibly program (aka we can use loops\neasily) and create a `config.toml` which is based off `config.toml.example`.\nThis way we can preserve comments and munge various values as we see fit.\n\nIt is intended that the configure script here is a drop-in replacement for the\nprevious configure script, no functional change is intended. Also note that the\nrationale for this is also because our build system requires Python, so having a\npython script a bit earlier shouldn't cause too many problems.\n\nCloses #40730", "tree": {"sha": "05704d973b5e31cb63d59706dab4a919d0884bad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05704d973b5e31cb63d59706dab4a919d0884bad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9b0a7ba935c79b45effcc2f55eb056bd087d9a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9b0a7ba935c79b45effcc2f55eb056bd087d9a4", "html_url": "https://github.com/rust-lang/rust/commit/a9b0a7ba935c79b45effcc2f55eb056bd087d9a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9b0a7ba935c79b45effcc2f55eb056bd087d9a4/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "398aaffc94367ed59420f5ac0b0238c04c9e4fa5", "url": "https://api.github.com/repos/rust-lang/rust/commits/398aaffc94367ed59420f5ac0b0238c04c9e4fa5", "html_url": "https://github.com/rust-lang/rust/commit/398aaffc94367ed59420f5ac0b0238c04c9e4fa5"}], "stats": {"total": 1870, "additions": 653, "deletions": 1217}, "files": [{"sha": "a20e6e8f0218a3dc234a0e3f05767139611926bb", "filename": "config.toml.example", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a9b0a7ba935c79b45effcc2f55eb056bd087d9a4/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/a9b0a7ba935c79b45effcc2f55eb056bd087d9a4/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=a9b0a7ba935c79b45effcc2f55eb056bd087d9a4", "patch": "@@ -73,6 +73,10 @@\n # controlled by rustbuild's -j parameter.\n #link-jobs = 0\n \n+# When invoking `llvm-config` this configures whether the `--shared` argument is\n+# passed to prefer linking to shared libraries.\n+#link-shared = false\n+\n # =============================================================================\n # General build configuration options\n # =============================================================================\n@@ -166,6 +170,15 @@\n # to +10 on Unix platforms, and by using a \"low priority\" job object on Windows.\n #low-priority = false\n \n+# Arguments passed to the `./configure` script, used during distcheck. You\n+# probably won't fill this in but rather it's filled in by the `./configure`\n+# script.\n+#configure-args = []\n+\n+# Indicates that a local rebuild is ocurring instead of a full bootstrap,\n+# essentially skipping stage0 as the local compiler is recompiling itself again.\n+#local-rebuild = false\n+\n # =============================================================================\n # General install configuration options\n # =============================================================================\n@@ -195,6 +208,13 @@\n # =============================================================================\n [rust]\n \n+# Indicates that the build should be optimized for debugging Rust. Note that\n+# this is typically not what you want as it takes an incredibly large amount of\n+# time to have a debug-mode rustc compile any code (notably libstd). If this\n+# value is set to `true` it will affect a number of configuration options below\n+# as well, if unconfigured.\n+#debug = false\n+\n # Whether or not to optimize the compiler and standard library\n # Note: the slowness of the non optimized compiler compiling itself usually\n #       outweighs the time gains in not doing optimizations, therefore a\n@@ -249,6 +269,10 @@\n # desired in distributions, for example.\n #rpath = true\n \n+# Suppresses extraneous output from tests to ensure the output of the test\n+# harness is relatively clean.\n+#quiet-tests = false\n+\n # Flag indicating whether tests are compiled with optimizations (the -O flag) or\n # with debuginfo (the -g flag)\n #optimize-tests = true\n@@ -261,6 +285,9 @@\n # Flag indicating whether git info will be retrieved from .git automatically.\n #ignore-git = false\n \n+# When creating source tarballs whether or not to create a source tarball.\n+#dist-src = false\n+\n # =============================================================================\n # Options for specific targets\n #\n@@ -304,6 +331,10 @@\n # linked binaries\n #musl-root = \"...\"\n \n+# Used in testing for configuring where the QEMU images are located, you\n+# probably don't want to use this.\n+#qemu-rootfs = \"...\"\n+\n # =============================================================================\n # Distribution options\n #"}, {"sha": "eeb8d081d34549f5ca2b19f703bbb4e547264e46", "filename": "configure", "status": "modified", "additions": 10, "deletions": 772, "changes": 782, "blob_url": "https://github.com/rust-lang/rust/blob/a9b0a7ba935c79b45effcc2f55eb056bd087d9a4/configure", "raw_url": "https://github.com/rust-lang/rust/raw/a9b0a7ba935c79b45effcc2f55eb056bd087d9a4/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=a9b0a7ba935c79b45effcc2f55eb056bd087d9a4", "patch": "@@ -1,779 +1,17 @@\n #!/bin/sh\n \n-# /bin/sh on Solaris is not a POSIX compatible shell, but /usr/bin/bash is.\n-if [ `uname -s` = 'SunOS' -a \"${POSIX_SHELL}\" != \"true\" ]; then\n-    POSIX_SHELL=\"true\"\n-    export POSIX_SHELL\n-    exec /usr/bin/env bash $0 \"$@\"\n-fi\n-unset POSIX_SHELL # clear it so if we invoke other scripts, they run as bash as well\n+script=\"$(dirname $0)\"/src/bootstrap/configure.py\n \n-msg() {\n-    echo \"configure: $*\"\n-}\n-\n-step_msg() {\n-    msg\n-    msg \"$1\"\n-    msg\n-}\n-\n-warn() {\n-    echo \"configure: WARNING: $1\"\n-}\n-\n-err() {\n-    echo \"configure: error: $1\"\n-    exit 1\n-}\n-\n-run() {\n-    msg \"$@\"\n-    \"$@\"\n-}\n-\n-need_ok() {\n-    if [ $? -ne 0 ]\n-    then\n-        err \"$1\"\n-    fi\n-}\n-\n-need_cmd() {\n-    if command -v $1 >/dev/null 2>&1\n-    then msg \"found program '$1'\"\n-    else err \"program '$1' is missing, please install it\"\n-    fi\n-}\n-\n-make_dir() {\n-    if [ ! -d $1 ]\n-    then\n-        run mkdir -p $1\n-    fi\n-}\n-\n-copy_if_changed() {\n-    if cmp -s $1 $2\n-    then\n-        msg \"leaving $2 unchanged\"\n-    else\n-        run cp -f $1 $2\n-        chmod u-w $2 # make copied artifact read-only\n-    fi\n-}\n-\n-move_if_changed() {\n-    if cmp -s $1 $2\n-    then\n-        msg \"leaving $2 unchanged\"\n-    else\n-        run mv -f $1 $2\n-        chmod u-w $2 # make moved artifact read-only\n-    fi\n-}\n-\n-putvar() {\n-    local T\n-    eval T=\\$$1\n-    eval TLEN=\\${#$1}\n-    if [ $TLEN -gt 35 ]\n-    then\n-        printf \"configure: %-20s := %.35s ...\\n\" $1 \"$T\"\n-    else\n-        printf \"configure: %-20s := %s %s\\n\" $1 \"$T\" \"$2\"\n-    fi\n-    printf \"%-20s := %s\\n\" $1 \"$T\" >>config.tmp\n-}\n-\n-putpathvar() {\n-    local T\n-    eval T=\\$$1\n-    eval TLEN=\\${#$1}\n-    if [ $TLEN -gt 35 ]\n-    then\n-        printf \"configure: %-20s := %.35s ...\\n\" $1 \"$T\"\n-    else\n-        printf \"configure: %-20s := %s %s\\n\" $1 \"$T\" \"$2\"\n-    fi\n-    if [ -z \"$T\" ]\n-    then\n-        printf \"%-20s := \\n\" $1 >>config.tmp\n-    else\n-        printf \"%-20s := \\\"%s\\\"\\n\" $1 \"$T\" >>config.tmp\n-    fi\n-}\n-\n-probe() {\n-    local V=$1\n+try() {\n+    cmd=$1\n     shift\n-    local P\n-    local T\n-    for P\n-    do\n-        T=$(command -v $P 2>&1)\n-        if [ $? -eq 0 ]\n-        then\n-            VER0=$($P --version 2>/dev/null \\\n-                |  grep -o '[vV]\\?[0-9][0-9.][a-z0-9.-]*' | head -1 )\n-            if [ $? -eq 0 -a \"x${VER0}\" != \"x\" ]\n-            then\n-              VER=\"($VER0)\"\n-            else\n-              VER=\"\"\n-            fi\n-            break\n-        else\n-            VER=\"\"\n-            T=\"\"\n-        fi\n-    done\n-    eval $V=\\$T\n-    putpathvar $V \"$VER\"\n-}\n-\n-probe_need() {\n-    probe $*\n-    local V=$1\n-    shift\n-    eval VV=\\$$V\n-    if [ -z \"$VV\" ]\n-    then\n-        err \"$V needed, but unable to find any of: $*\"\n-    fi\n-}\n-\n-validate_opt () {\n-    for arg in $CFG_CONFIGURE_ARGS\n-    do\n-        isArgValid=0\n-        for option in $BOOL_OPTIONS\n-        do\n-            if test --disable-$option = $arg\n-            then\n-                isArgValid=1\n-            fi\n-            if test --enable-$option = $arg\n-            then\n-                isArgValid=1\n-            fi\n-        done\n-        for option in $VAL_OPTIONS\n-        do\n-            if echo \"$arg\" | grep -q -- \"--$option=\"\n-            then\n-                isArgValid=1\n-            fi\n-        done\n-        if [ \"$arg\" = \"--help\" ]\n-        then\n-            echo\n-            echo \"No more help available for Configure options,\"\n-            echo \"check the Wiki or join our IRC channel\"\n-            break\n-        else\n-            if test $isArgValid -eq 0\n-            then\n-                err \"Option '$arg' is not recognized\"\n-            fi\n-        fi\n-    done\n-}\n-\n-# `valopt OPTION_NAME DEFAULT DOC` extracts a string-valued option\n-# from command line, using provided default value for the option if\n-# not present, and saves it to the generated config.mk.\n-#\n-# `valopt_nosave` is much the same, except that it does not save the\n-# result to config.mk (instead the script should use `putvar` itself\n-# later on to save it).  `valopt_core` is the core upon which the\n-# other two are built.\n-\n-valopt_core() {\n-    VAL_OPTIONS=\"$VAL_OPTIONS $2\"\n-\n-    local SAVE=$1\n-    local OP=$2\n-    local DEFAULT=$3\n-    shift\n-    shift\n-    shift\n-    local DOC=\"$*\"\n-    if [ $HELP -eq 0 ]\n-    then\n-        local UOP=$(echo $OP | tr '[:lower:]' '[:upper:]' | tr '\\-' '\\_')\n-        local V=\"CFG_${UOP}\"\n-        local V_PROVIDED=\"${V}_PROVIDED\"\n-        eval $V=\"$DEFAULT\"\n-        for arg in $CFG_CONFIGURE_ARGS\n-        do\n-            if echo \"$arg\" | grep -q -- \"--$OP=\"\n-            then\n-                val=$(echo \"$arg\" | cut -f2 -d=)\n-                eval $V=$val\n-                eval $V_PROVIDED=1\n-            fi\n-        done\n-        if [ \"$SAVE\" = \"save\" ]\n-        then\n-            putvar $V\n-        fi\n-    else\n-        if [ -z \"$DEFAULT\" ]\n-        then\n-            DEFAULT=\"<none>\"\n-        fi\n-        OP=\"${OP}=[${DEFAULT}]\"\n-        printf \"    --%-30s %s\\n\" \"$OP\" \"$DOC\"\n-    fi\n-}\n-\n-valopt_nosave() {\n-    valopt_core nosave \"$@\"\n-}\n-\n-valopt() {\n-    valopt_core save \"$@\"\n-}\n-\n-# `opt OPTION_NAME DEFAULT DOC` extracts a boolean-valued option from\n-# command line, using the provided default value (0/1) for the option\n-# if not present, and saves it to the generated config.mk.\n-#\n-# `opt_nosave` is much the same, except that it does not save the\n-# result to config.mk (instead the script should use `putvar` itself\n-# later on to save it).  `opt_core` is the core upon which the other\n-# two are built.\n-\n-opt_core() {\n-    BOOL_OPTIONS=\"$BOOL_OPTIONS $2\"\n-\n-    local SAVE=$1\n-    local OP=$2\n-    local DEFAULT=$3\n-    shift\n-    shift\n-    shift\n-    local DOC=\"$*\"\n-    local FLAG=\"\"\n-\n-    if [ $DEFAULT -eq 0 ]\n-    then\n-        FLAG=\"enable\"\n-        DEFAULT_FLAG=\"disable\"\n-    else\n-        FLAG=\"disable\"\n-        DEFAULT_FLAG=\"enable\"\n-        DOC=\"don't $DOC\"\n-    fi\n-\n-    if [ $HELP -eq 0 ]\n-    then\n-        for arg in $CFG_CONFIGURE_ARGS\n-        do\n-            if [ \"$arg\" = \"--${FLAG}-${OP}\" ]\n-            then\n-                OP=$(echo $OP | tr 'a-z-' 'A-Z_')\n-                FLAG=$(echo $FLAG | tr 'a-z' 'A-Z')\n-                local V=\"CFG_${FLAG}_${OP}\"\n-                local V_PROVIDED=\"CFG_${FLAG}_${OP}_PROVIDED\"\n-                eval $V=1\n-                eval $V_PROVIDED=1\n-                if [ \"$SAVE\" = \"save\" ]\n-                then\n-                   putvar $V\n-                fi\n-            elif [ \"$arg\" = \"--${DEFAULT_FLAG}-${OP}\" ]\n-            then\n-                OP=$(echo $OP | tr 'a-z-' 'A-Z_')\n-                DEFAULT_FLAG=$(echo $DEFAULT_FLAG | tr 'a-z' 'A-Z')\n-                local V_PROVIDED=\"CFG_${DEFAULT_FLAG}_${OP}_PROVIDED\"\n-                eval $V_PROVIDED=1\n-            fi\n-        done\n-    else\n-        if [ -n \"$META\" ]\n-        then\n-            OP=\"$OP=<$META>\"\n-        fi\n-        printf \"    --%-30s %s\\n\" \"$FLAG-$OP\" \"$DOC\"\n-     fi\n-}\n-\n-opt_nosave() {\n-    opt_core nosave \"$@\"\n-}\n-\n-opt() {\n-    opt_core save \"$@\"\n-}\n-\n-envopt() {\n-    local NAME=$1\n-    local V=\"CFG_${NAME}\"\n-    eval VV=\\$$V\n-\n-    # If configure didn't set a value already, then check environment.\n-    #\n-    # (It is recommended that the configure script always check the\n-    # environment before setting any values to envopt variables; see\n-    # e.g.  how CFG_CC is handled, where it first checks `-z \"$CC\"`,\n-    # and issues msg if it ends up employing that provided value.)\n-    if [ -z \"$VV\" ]\n-    then\n-        eval $V=\\$$NAME\n-        eval VV=\\$$V\n-    fi\n-\n-    # If script or environment provided a value, save it.\n-    if [ -n \"$VV\" ]\n-    then\n-        putvar $V\n-    fi\n-}\n-\n-enable_if_not_disabled() {\n-    local OP=$1\n-    local UOP=$(echo $OP | tr '[:lower:]' '[:upper:]' | tr '\\-' '\\_')\n-    local ENAB_V=\"CFG_ENABLE_$UOP\"\n-    local EXPLICITLY_DISABLED=\"CFG_DISABLE_${UOP}_PROVIDED\"\n-    eval VV=\\$$EXPLICITLY_DISABLED\n-    if [ -z \"$VV\" ]; then\n-        eval $ENAB_V=1\n+    T=$($cmd --version 2>/dev/null)\n+    if [ $? -eq 0 ]; then\n+        exec $cmd \"$script\" \"$@\"\n     fi\n }\n \n-to_gnu_triple() {\n-    case $1 in\n-        i686-pc-windows-gnu) echo i686-w64-mingw32 ;;\n-        x86_64-pc-windows-gnu) echo x86_64-w64-mingw32 ;;\n-        *) echo $1 ;;\n-    esac\n-}\n-\n-# Prints the absolute path of a directory to stdout\n-abs_path() {\n-    local _path=\"$1\"\n-    # Unset CDPATH because it causes havok: it makes the destination unpredictable\n-    # and triggers 'cd' to print the path to stdout. Route `cd`'s output to /dev/null\n-    # for good measure.\n-    (unset CDPATH && cd \"$_path\" > /dev/null && pwd)\n-}\n-\n-HELP=0\n-for arg; do\n-    case \"$arg\" in\n-        --help) HELP=1;;\n-    esac\n-done\n-\n-msg \"looking for configure programs\"\n-need_cmd cmp\n-need_cmd mkdir\n-need_cmd printf\n-need_cmd cut\n-need_cmd head\n-need_cmd grep\n-need_cmd xargs\n-need_cmd cp\n-need_cmd find\n-need_cmd uname\n-need_cmd date\n-need_cmd tr\n-need_cmd sed\n-need_cmd file\n-need_cmd make\n-\n-CFG_SRC_DIR=\"$(abs_path $(dirname $0))/\"\n-CFG_SRC_DIR_RELATIVE=\"$(dirname $0)/\"\n-CFG_BUILD_DIR=\"$(pwd)/\"\n-CFG_SELF=\"$0\"\n-CFG_CONFIGURE_ARGS=\"$@\"\n-\n-\n-case \"${CFG_SRC_DIR}\" in\n-    *\\ * )\n-        err \"The path to the rust source directory contains spaces, which is not supported\"\n-        ;;\n-    *)\n-        ;;\n-esac\n-\n-\n-OPTIONS=\"\"\n-if [ \"$HELP\" -eq 1 ]\n-then\n-    echo\n-    echo \"Usage: $CFG_SELF [options]\"\n-    echo\n-    echo \"Options:\"\n-    echo\n-else\n-    msg \"recreating config.tmp\"\n-    echo '' >config.tmp\n-\n-    step_msg \"processing $CFG_SELF args\"\n-fi\n-\n-BOOL_OPTIONS=\"\"\n-VAL_OPTIONS=\"\"\n-\n-opt debug 0 \"debug mode; disables optimization unless \\`--enable-optimize\\` given\"\n-opt valgrind 0 \"run tests with valgrind (memcheck by default)\"\n-opt helgrind 0 \"run tests with helgrind instead of memcheck\"\n-opt valgrind-rpass 1 \"run rpass-valgrind tests with valgrind\"\n-opt docs     1 \"build standard library documentation\"\n-opt compiler-docs     0 \"build compiler documentation\"\n-opt optimize-tests 1 \"build tests with optimizations\"\n-opt debuginfo-tests 0 \"build tests with debugger metadata\"\n-opt quiet-tests 0 \"enable quieter output when running tests\"\n-opt libcpp 1 \"build llvm with libc++ instead of libstdc++ when using clang\"\n-opt llvm-assertions 0 \"build LLVM with assertions\"\n-opt debug-assertions 0 \"build with debugging assertions\"\n-opt fast-make 0 \"use .gitmodules as timestamp for submodule deps\"\n-opt ccache 0 \"invoke gcc/clang via ccache to reuse object files between builds\"\n-opt sccache 0 \"invoke gcc/clang via sccache to reuse object files between builds\"\n-opt local-rust 0 \"use an installed rustc rather than downloading a snapshot\"\n-opt local-rebuild 0 \"assume local-rust matches the current version, for rebuilds; implies local-rust, and is implied if local-rust already matches the current version\"\n-opt llvm-static-stdcpp 0 \"statically link to libstdc++ for LLVM\"\n-opt llvm-link-shared 0 \"prefer shared linking to LLVM (llvm-config --link-shared)\"\n-opt rpath 1 \"build rpaths into rustc itself\"\n-opt stage0-landing-pads 1 \"enable landing pads during bootstrap with stage0\"\n-# This is used by the automation to produce single-target nightlies\n-opt dist-host-only 0 \"only install bins for the host architecture\"\n-opt inject-std-version 1 \"inject the current compiler version of libstd into programs\"\n-opt llvm-version-check 1 \"check if the LLVM version is supported, build anyway\"\n-opt codegen-tests 1 \"run the src/test/codegen tests\"\n-opt option-checking 1 \"complain about unrecognized options in this configure script\"\n-opt ninja 0 \"build LLVM using the Ninja generator (for MSVC, requires building in the correct environment)\"\n-opt locked-deps 0 \"force Cargo.lock to be up to date\"\n-opt vendor 0 \"enable usage of vendored Rust crates\"\n-opt sanitizers 0 \"build the sanitizer runtimes (asan, lsan, msan, tsan)\"\n-opt dist-src 1 \"when building tarballs enables building a source tarball\"\n-opt cargo-openssl-static 0 \"static openssl in cargo\"\n-opt profiler 0 \"build the profiler runtime\"\n-\n-# Optimization and debugging options. These may be overridden by the release channel, etc.\n-opt_nosave optimize 1 \"build optimized rust code\"\n-opt_nosave optimize-cxx 1 \"build optimized C++ code\"\n-opt_nosave optimize-llvm 1 \"build optimized LLVM\"\n-opt_nosave llvm-assertions 0 \"build LLVM with assertions\"\n-opt_nosave debug-assertions 0 \"build with debugging assertions\"\n-opt_nosave llvm-release-debuginfo 0 \"build LLVM with debugger metadata\"\n-opt_nosave debuginfo 0 \"build with debugger metadata\"\n-opt_nosave debuginfo-lines 0 \"build with line number debugger metadata\"\n-opt_nosave debuginfo-only-std 0 \"build only libstd with debugging information\"\n-opt_nosave debug-jemalloc 0 \"build jemalloc with --enable-debug --enable-fill\"\n-\n-valopt localstatedir \"/var/lib\" \"local state directory\"\n-valopt sysconfdir \"/etc\" \"install system configuration files\"\n-\n-valopt datadir \"${CFG_PREFIX}/share\" \"install data\"\n-valopt infodir \"${CFG_PREFIX}/share/info\" \"install additional info\"\n-valopt llvm-root \"\" \"set LLVM root\"\n-valopt python \"\" \"set path to python\"\n-valopt jemalloc-root \"\" \"set directory where libjemalloc_pic.a is located\"\n-valopt build \"\" \"GNUs ./configure syntax LLVM build triple\"\n-valopt android-cross-path \"\" \"Android NDK standalone path (deprecated)\"\n-valopt i686-linux-android-ndk \"\" \"i686-linux-android NDK standalone path\"\n-valopt arm-linux-androideabi-ndk \"\" \"arm-linux-androideabi NDK standalone path\"\n-valopt armv7-linux-androideabi-ndk \"\" \"armv7-linux-androideabi NDK standalone path\"\n-valopt aarch64-linux-android-ndk \"\" \"aarch64-linux-android NDK standalone path\"\n-valopt x86_64-linux-android-ndk \"\" \"x86_64-linux-android NDK standalone path\"\n-valopt nacl-cross-path  \"\" \"NaCl SDK path (Pepper Canary is recommended). Must be absolute!\"\n-valopt musl-root \"/usr/local\" \"MUSL root installation directory (deprecated)\"\n-valopt musl-root-x86_64 \"\" \"x86_64-unknown-linux-musl install directory\"\n-valopt musl-root-i686 \"\" \"i686-unknown-linux-musl install directory\"\n-valopt musl-root-arm \"\" \"arm-unknown-linux-musleabi install directory\"\n-valopt musl-root-armhf \"\" \"arm-unknown-linux-musleabihf install directory\"\n-valopt musl-root-armv7 \"\" \"armv7-unknown-linux-musleabihf install directory\"\n-valopt extra-filename \"\" \"Additional data that is hashed and passed to the -C extra-filename flag\"\n-valopt qemu-armhf-rootfs \"\" \"rootfs in qemu testing, you probably don't want to use this\"\n-valopt qemu-aarch64-rootfs \"\" \"rootfs in qemu testing, you probably don't want to use this\"\n-valopt experimental-targets \"\" \"experimental LLVM targets to build\"\n-\n-if [ -e ${CFG_SRC_DIR}.git ]\n-then\n-    valopt release-channel \"dev\" \"the name of the release channel to build\"\n-else\n-    # If we have no git directory then we are probably a tarball distribution\n-    # and should default to stable channel - Issue 28322\n-    probe CFG_GIT          git\n-    msg \"git: no git directory. Changing default release channel to stable\"\n-    valopt release-channel \"stable\" \"the name of the release channel to build\"\n-fi\n-\n-# Used on systems where \"cc\" and \"ar\" are unavailable\n-valopt default-linker \"cc\" \"the default linker\"\n-valopt default-ar     \"ar\" \"the default ar\"\n-\n-# Many of these are saved below during the \"writing configuration\" step\n-# (others are conditionally saved).\n-opt_nosave manage-submodules 1 \"let the build manage the git submodules\"\n-opt_nosave clang 0 \"prefer clang to gcc for building the runtime\"\n-opt_nosave jemalloc 1 \"build liballoc with jemalloc\"\n-opt full-bootstrap 0 \"build three compilers instead of two\"\n-opt extended 0 \"build an extended rust tool set\"\n-\n-valopt_nosave prefix \"/usr/local\" \"set installation prefix\"\n-valopt_nosave local-rust-root \"/usr/local\" \"set prefix for local rust binary\"\n-valopt_nosave host \"${CFG_BUILD}\" \"GNUs ./configure syntax LLVM host triples\"\n-valopt_nosave target \"${CFG_HOST}\" \"GNUs ./configure syntax LLVM target triples\"\n-valopt_nosave mandir \"${CFG_PREFIX}/share/man\" \"install man pages in PATH\"\n-valopt_nosave docdir \"${CFG_PREFIX}/share/doc/rust\" \"install documentation in PATH\"\n-valopt_nosave bindir \"${CFG_PREFIX}/bin\" \"install binaries\"\n-\n-# On Windows this determines root of the subtree for target libraries.\n-# Host runtime libs always go to 'bin'.\n-valopt libdir \"${CFG_PREFIX}/lib\" \"install libraries\"\n-\n-case \"$CFG_LIBDIR\" in\n-    \"$CFG_PREFIX\"/*) CAT_INC=2;;\n-    \"$CFG_PREFIX\"*)  CAT_INC=1;;\n-    *)\n-        err \"libdir must begin with the prefix. Use --prefix to set it accordingly.\";;\n-esac\n-\n-CFG_LIBDIR_RELATIVE=`echo ${CFG_LIBDIR} | cut -c$((${#CFG_PREFIX}+${CAT_INC}))-`\n-\n-if [ $HELP -eq 1 ]\n-then\n-    echo\n-    exit 0\n-fi\n-\n-# Validate Options\n-if [ -z \"$CFG_DISABLE_OPTION_CHECKING\" ]\n-then\n-    step_msg \"validating $CFG_SELF args\"\n-    validate_opt\n-fi\n-\n-# Validate the release channel, and configure options\n-case \"$CFG_RELEASE_CHANNEL\" in\n-    nightly )\n-\tmsg \"overriding settings for $CFG_RELEASE_CHANNEL\"\n-        enable_if_not_disabled llvm-assertions\n-        # FIXME(stage0) re-enable this on the next stage0 now that #35566 is\n-        # fixed\n-        case \"$CFG_BUILD\" in\n-          *-pc-windows-gnu)\n-            ;;\n-          *)\n-            enable_if_not_disabled debuginfo-lines\n-            enable_if_not_disabled debuginfo-only-std\n-            ;;\n-        esac\n-\n-\t;;\n-    beta | stable)\n-\tmsg \"overriding settings for $CFG_RELEASE_CHANNEL\"\n-        case \"$CFG_BUILD\" in\n-          *-pc-windows-gnu)\n-            ;;\n-          *)\n-            enable_if_not_disabled debuginfo-lines\n-            enable_if_not_disabled debuginfo-only-std\n-            ;;\n-        esac\n-\t;;\n-    dev)\n-\t;;\n-    *)\n-        err \"release channel must be 'dev', 'nightly', 'beta' or 'stable'\"\n-        ;;\n-esac\n-\n-# Adjust perf and debug options for debug mode\n-if [ -n \"$CFG_ENABLE_DEBUG\" ]; then\n-    msg \"debug mode enabled, setting performance options\"\n-    if [ -z \"$CFG_ENABLE_OPTIMIZE_PROVIDED\" ]; then\n-        msg \"optimization not explicitly enabled, disabling optimization\"\n-        CFG_DISABLE_OPTIMIZE=1\n-        CFG_DISABLE_OPTIMIZE_CXX=1\n-    fi\n-\n-    # Set following variables to 1 unless setting already provided\n-    enable_if_not_disabled debug-assertions\n-    enable_if_not_disabled debug-jemalloc\n-    enable_if_not_disabled debuginfo\n-    enable_if_not_disabled llvm-assertions\n-fi\n-\n-# OK, now write the debugging options\n-if [ -n \"$CFG_DISABLE_OPTIMIZE\" ]; then putvar CFG_DISABLE_OPTIMIZE; fi\n-if [ -n \"$CFG_DISABLE_OPTIMIZE_CXX\" ]; then putvar CFG_DISABLE_OPTIMIZE_CXX; fi\n-if [ -n \"$CFG_DISABLE_OPTIMIZE_LLVM\" ]; then putvar CFG_DISABLE_OPTIMIZE_LLVM; fi\n-if [ -n \"$CFG_ENABLE_LLVM_ASSERTIONS\" ]; then putvar CFG_ENABLE_LLVM_ASSERTIONS; fi\n-if [ -n \"$CFG_ENABLE_DEBUG_ASSERTIONS\" ]; then putvar CFG_ENABLE_DEBUG_ASSERTIONS; fi\n-if [ -n \"$CFG_ENABLE_LLVM_RELEASE_DEBUGINFO\" ]; then putvar CFG_ENABLE_LLVM_RELEASE_DEBUGINFO; fi\n-if [ -n \"$CFG_ENABLE_DEBUGINFO\" ]; then putvar CFG_ENABLE_DEBUGINFO; fi\n-if [ -n \"$CFG_ENABLE_DEBUGINFO_LINES\" ]; then putvar CFG_ENABLE_DEBUGINFO_LINES; fi\n-if [ -n \"$CFG_ENABLE_DEBUGINFO_ONLY_STD\" ]; then putvar CFG_ENABLE_DEBUGINFO_ONLY_STD; fi\n-if [ -n \"$CFG_ENABLE_DEBUG_JEMALLOC\" ]; then putvar CFG_ENABLE_DEBUG_JEMALLOC; fi\n-\n-step_msg \"looking for build programs\"\n-\n-probe_need CFG_CURL curl\n-if [ -z \"$CFG_PYTHON_PROVIDED\" ]; then\n-    probe_need CFG_PYTHON      python2.7 python2 python\n-fi\n-\n-python_version=$($CFG_PYTHON -V 2>&1)\n-if [ $(echo $python_version | grep -c '^Python 2\\.7') -ne 1 ]; then\n-    err \"Found $python_version, but Python 2.7 is required\"\n-fi\n-\n-# the valgrind rpass tests will fail if you don't have a valgrind, but they're\n-# only disabled if you opt out.\n-if [ -z \"$CFG_VALGRIND\" ]\n-then\n-    # If the user has explicitly asked for valgrind tests, then fail\n-    if [ -n \"$CFG_ENABLE_VALGRIND\" ] && [ -n \"$CFG_ENABLE_VALGRIND_PROVIDED\" ]\n-    then\n-        err \"No valgrind present, but valgrind tests explicitly requested\"\n-    else\n-        CFG_DISABLE_VALGRIND_RPASS=1\n-        putvar CFG_DISABLE_VALGRIND_RPASS\n-    fi\n-fi\n-\n-# Do some sanity checks if running on buildbot\n-# (these env vars are set by rust-buildbot)\n-if [ -n \"$RUST_DIST_SERVER\" -a -n \"$ALLOW_NONZERO_RLIMIT_CORE\" ]; then\n-   # Frequently the llvm submodule directory is broken by the build\n-   # being killed\n-   llvm_lock=\"${CFG_SRC_DIR}/.git/modules/src/llvm/index.lock\"\n-   if [ -e \"$llvm_lock\" ]; then\n-       step_msg \"removing $llvm_lock\"\n-       rm -f \"$llvm_lock\"\n-   fi\n-fi\n-\n-BIN_SUF=\n-if [ \"$CFG_OSTYPE\" = \"pc-windows-gnu\" ] || [ \"$CFG_OSTYPE\" = \"pc-windows-msvc\" ]\n-then\n-    BIN_SUF=.exe\n-fi\n-\n-# --enable-local-rebuild implies --enable-local-rust too\n-if [ -n \"$CFG_ENABLE_LOCAL_REBUILD\" ]\n-then\n-    if [ -z \"$CFG_ENABLE_LOCAL_RUST\" ]\n-    then\n-        CFG_ENABLE_LOCAL_RUST=1\n-        putvar CFG_ENABLE_LOCAL_RUST\n-    fi\n-fi\n-\n-if [ -n \"$CFG_ENABLE_LOCAL_RUST\" ]\n-then\n-    system_rustc=$(which rustc)\n-    if [ -f ${CFG_LOCAL_RUST_ROOT}/bin/rustc${BIN_SUF} ]\n-    then\n-        : # everything already configured\n-    elif [ -n \"$system_rustc\" ]\n-    then\n-        # we assume that rustc is in a /bin directory\n-        CFG_LOCAL_RUST_ROOT=${system_rustc%/bin/rustc}\n-    else\n-        err \"no local rust to use\"\n-    fi\n-\n-    CMD=\"${CFG_LOCAL_RUST_ROOT}/bin/rustc${BIN_SUF}\"\n-    LRV=`LD_LIBRARY_PATH=${CFG_LOCAL_RUST_ROOT}/lib $CMD --version`\n-    if [ $? -ne 0 ]\n-    then\n-        step_msg \"failure while running $CMD --version\"\n-        exit 1\n-    fi\n-    step_msg \"using rustc at: ${CFG_LOCAL_RUST_ROOT} with version: $LRV\"\n-    putvar CFG_LOCAL_RUST_ROOT\n-fi\n-\n-# Same with jemalloc.  save the setting here.\n-if [ -n \"$CFG_DISABLE_JEMALLOC\" ]\n-then\n-    putvar CFG_DISABLE_JEMALLOC\n-fi\n-\n-# All safeguards based on $CFG_ENABLE_CLANG should occur before this\n-# point in the script; after this point, script logic should inspect\n-# $CFG_USING_CLANG rather than $CFG_ENABLE_CLANG.\n-\n-# Set CFG_{CC,CXX,CPP,CFLAGS,CXXFLAGS,LDFLAGS}\n-envopt CC\n-envopt CXX\n-envopt CPP\n-envopt CFLAGS\n-envopt CXXFLAGS\n-envopt LDFLAGS\n-\n-# a little post-processing of various config values\n-CFG_PREFIX=${CFG_PREFIX%/}\n-CFG_MANDIR=${CFG_MANDIR%/}\n-CFG_DOCDIR=${CFG_DOCDIR%/}\n-CFG_BINDIR=${CFG_BINDIR%/}\n-CFG_HOST=\"$(echo $CFG_HOST | tr ',' ' ')\"\n-CFG_TARGET=\"$(echo $CFG_TARGET | tr ',' ' ')\"\n-\n-# copy build-triples to host-triples so that builds are a subset of hosts\n-V_TEMP=\"\"\n-for i in $CFG_BUILD $CFG_HOST;\n-do\n-   echo \"$V_TEMP\" | grep -qF $i || V_TEMP=\"$V_TEMP${V_TEMP:+ }$i\"\n-done\n-CFG_HOST=$V_TEMP\n-\n-# copy host-triples to target-triples so that hosts are a subset of targets\n-V_TEMP=\"\"\n-for i in $CFG_HOST $CFG_TARGET;\n-do\n-   echo \"$V_TEMP\" | grep -qF $i || V_TEMP=\"$V_TEMP${V_TEMP:+ }$i\"\n-done\n-CFG_TARGET=$V_TEMP\n-\n-step_msg \"writing configuration\"\n-\n-putvar CFG_SRC_DIR\n-putvar CFG_SRC_DIR_RELATIVE\n-putvar CFG_BUILD_DIR\n-putvar CFG_OSTYPE\n-putvar CFG_CPUTYPE\n-putvar CFG_CONFIGURE_ARGS\n-putvar CFG_PREFIX\n-putvar CFG_HOST\n-putvar CFG_TARGET\n-putvar CFG_LIBDIR_RELATIVE\n-putvar CFG_DISABLE_MANAGE_SUBMODULES\n-putvar CFG_AARCH64_LINUX_ANDROID_NDK\n-putvar CFG_ARM_LINUX_ANDROIDEABI_NDK\n-putvar CFG_ARMV7_LINUX_ANDROIDEABI_NDK\n-putvar CFG_I686_LINUX_ANDROID_NDK\n-putvar CFG_X86_64_LINUX_ANDROID_NDK\n-putvar CFG_NACL_CROSS_PATH\n-putvar CFG_MANDIR\n-putvar CFG_DOCDIR\n-putvar CFG_BINDIR\n-putvar CFG_USING_LIBCPP\n-\n-msg\n-copy_if_changed ${CFG_SRC_DIR}src/bootstrap/mk/Makefile.in ./Makefile\n-move_if_changed config.tmp config.mk\n-rm -f config.tmp\n-touch config.stamp\n-\n-if [ -z \"$CFG_ENABLE_DEBUG\" ]; then\n-    step_msg \"configured in release mode. for development consider --enable-debug\"\n-else\n-    step_msg \"complete\"\n-fi\n-\n-if [ \"$CFG_SRC_DIR\" = `pwd` ]; then\n-    X_PY=x.py\n-else\n-    X_PY=${CFG_SRC_DIR_RELATIVE}x.py\n-fi\n-\n-msg \"run \\`python ${X_PY} --help\\`\"\n-msg\n+try python2.7 \"$@\"\n+try python27 \"$@\"\n+try python2 \"$@\"\n+exec python $script \"$@\""}, {"sha": "e543b8c070bcc8cca9c783b27a1dd2c3ad94a7c6", "filename": "src/bootstrap/README.md", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a9b0a7ba935c79b45effcc2f55eb056bd087d9a4/src%2Fbootstrap%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/a9b0a7ba935c79b45effcc2f55eb056bd087d9a4/src%2Fbootstrap%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FREADME.md?ref=a9b0a7ba935c79b45effcc2f55eb056bd087d9a4", "patch": "@@ -76,10 +76,9 @@ The script accepts commands, flags, and arguments to determine what to do:\n There are currently two methods for configuring the rustbuild build system.\n \n First, rustbuild offers a TOML-based configuration system with a `config.toml`\n-file in the same location as `config.mk`. An example of this configuration can\n-be found at `config.toml.example`, and the configuration file can also be passed\n-as `--config path/to/config.toml` if the build system is being invoked manually\n-(via the python script).\n+file. An example of this configuration can be found at `config.toml.example`,\n+and the configuration file can also be passed as `--config path/to/config.toml`\n+if the build system is being invoked manually (via the python script).\n \n Next, the `./configure` options serialized in `config.mk` will be\n parsed and read. That is, if any `./configure` options are passed, they'll be"}, {"sha": "4c1bd7bdca9e085cf3157b4bbb6e7674036de9a7", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 149, "deletions": 187, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/a9b0a7ba935c79b45effcc2f55eb056bd087d9a4/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/a9b0a7ba935c79b45effcc2f55eb056bd087d9a4/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=a9b0a7ba935c79b45effcc2f55eb056bd087d9a4", "patch": "@@ -167,6 +167,141 @@ def format_build_time(duration):\n     return str(datetime.timedelta(seconds=int(duration)))\n \n \n+def default_build_triple():\n+    \"\"\"Build triple as in LLVM\"\"\"\n+    default_encoding = sys.getdefaultencoding()\n+    try:\n+        ostype = subprocess.check_output(\n+            ['uname', '-s']).strip().decode(default_encoding)\n+        cputype = subprocess.check_output(\n+            ['uname', '-m']).strip().decode(default_encoding)\n+    except (subprocess.CalledProcessError, OSError):\n+        if sys.platform == 'win32':\n+            return 'x86_64-pc-windows-msvc'\n+        err = \"uname not found\"\n+        sys.exit(err)\n+\n+    # The goal here is to come up with the same triple as LLVM would,\n+    # at least for the subset of platforms we're willing to target.\n+    ostype_mapper = {\n+        'Bitrig': 'unknown-bitrig',\n+        'Darwin': 'apple-darwin',\n+        'DragonFly': 'unknown-dragonfly',\n+        'FreeBSD': 'unknown-freebsd',\n+        'Haiku': 'unknown-haiku',\n+        'NetBSD': 'unknown-netbsd',\n+        'OpenBSD': 'unknown-openbsd'\n+    }\n+\n+    # Consider the direct transformation first and then the special cases\n+    if ostype in ostype_mapper:\n+        ostype = ostype_mapper[ostype]\n+    elif ostype == 'Linux':\n+        os_from_sp = subprocess.check_output(\n+            ['uname', '-o']).strip().decode(default_encoding)\n+        if os_from_sp == 'Android':\n+            ostype = 'linux-android'\n+        else:\n+            ostype = 'unknown-linux-gnu'\n+    elif ostype == 'SunOS':\n+        ostype = 'sun-solaris'\n+        # On Solaris, uname -m will return a machine classification instead\n+        # of a cpu type, so uname -p is recommended instead.  However, the\n+        # output from that option is too generic for our purposes (it will\n+        # always emit 'i386' on x86/amd64 systems).  As such, isainfo -k\n+        # must be used instead.\n+        try:\n+            cputype = subprocess.check_output(\n+                ['isainfo', '-k']).strip().decode(default_encoding)\n+        except (subprocess.CalledProcessError, OSError):\n+            err = \"isainfo not found\"\n+            sys.exit(err)\n+    elif ostype.startswith('MINGW'):\n+        # msys' `uname` does not print gcc configuration, but prints msys\n+        # configuration. so we cannot believe `uname -m`:\n+        # msys1 is always i686 and msys2 is always x86_64.\n+        # instead, msys defines $MSYSTEM which is MINGW32 on i686 and\n+        # MINGW64 on x86_64.\n+        ostype = 'pc-windows-gnu'\n+        cputype = 'i686'\n+        if os.environ.get('MSYSTEM') == 'MINGW64':\n+            cputype = 'x86_64'\n+    elif ostype.startswith('MSYS'):\n+        ostype = 'pc-windows-gnu'\n+    elif ostype.startswith('CYGWIN_NT'):\n+        cputype = 'i686'\n+        if ostype.endswith('WOW64'):\n+            cputype = 'x86_64'\n+        ostype = 'pc-windows-gnu'\n+    else:\n+        err = \"unknown OS type: {}\".format(ostype)\n+        sys.exit(err)\n+\n+    cputype_mapper = {\n+        'BePC': 'i686',\n+        'aarch64': 'aarch64',\n+        'amd64': 'x86_64',\n+        'arm64': 'aarch64',\n+        'i386': 'i686',\n+        'i486': 'i686',\n+        'i686': 'i686',\n+        'i786': 'i686',\n+        'powerpc': 'powerpc',\n+        'powerpc64': 'powerpc64',\n+        'powerpc64le': 'powerpc64le',\n+        'ppc': 'powerpc',\n+        'ppc64': 'powerpc64',\n+        'ppc64le': 'powerpc64le',\n+        's390x': 's390x',\n+        'x64': 'x86_64',\n+        'x86': 'i686',\n+        'x86-64': 'x86_64',\n+        'x86_64': 'x86_64'\n+    }\n+\n+    # Consider the direct transformation first and then the special cases\n+    if cputype in cputype_mapper:\n+        cputype = cputype_mapper[cputype]\n+    elif cputype in {'xscale', 'arm'}:\n+        cputype = 'arm'\n+        if ostype == 'linux-android':\n+            ostype = 'linux-androideabi'\n+    elif cputype == 'armv6l':\n+        cputype = 'arm'\n+        if ostype == 'linux-android':\n+            ostype = 'linux-androideabi'\n+        else:\n+            ostype += 'eabihf'\n+    elif cputype in {'armv7l', 'armv8l'}:\n+        cputype = 'armv7'\n+        if ostype == 'linux-android':\n+            ostype = 'linux-androideabi'\n+        else:\n+            ostype += 'eabihf'\n+    elif cputype == 'mips':\n+        if sys.byteorder == 'big':\n+            cputype = 'mips'\n+        elif sys.byteorder == 'little':\n+            cputype = 'mipsel'\n+        else:\n+            raise ValueError(\"unknown byteorder: {}\".format(sys.byteorder))\n+    elif cputype == 'mips64':\n+        if sys.byteorder == 'big':\n+            cputype = 'mips64'\n+        elif sys.byteorder == 'little':\n+            cputype = 'mips64el'\n+        else:\n+            raise ValueError('unknown byteorder: {}'.format(sys.byteorder))\n+        # only the n64 ABI is supported, indicate it\n+        ostype += 'abi64'\n+    elif cputype == 'sparcv9':\n+        pass\n+    else:\n+        err = \"unknown cpu type: {}\".format(cputype)\n+        sys.exit(err)\n+\n+    return \"{}-{}\".format(cputype, ostype)\n+\n class RustBuild(object):\n     \"\"\"Provide all the methods required to build Rust\"\"\"\n     def __init__(self):\n@@ -177,7 +312,6 @@ def __init__(self):\n         self.build = ''\n         self.build_dir = os.path.join(os.getcwd(), \"build\")\n         self.clean = False\n-        self.config_mk = ''\n         self.config_toml = ''\n         self.printed = False\n         self.rust_root = os.path.abspath(os.path.join(__file__, '../../..'))\n@@ -374,26 +508,6 @@ def get_toml(self, key):\n                 return self.get_string(value) or value.strip()\n         return None\n \n-    def get_mk(self, key):\n-        \"\"\"Returns the value of the given key in config.mk, otherwise returns None\n-\n-        >>> rb = RustBuild()\n-        >>> rb.config_mk = 'key := value\\\\n'\n-        >>> rb.get_mk('key')\n-        'value'\n-\n-        If the key does not exists, the result is None:\n-\n-        >>> rb.get_mk('does_not_exists') == None\n-        True\n-        \"\"\"\n-        for line in iter(self.config_mk.splitlines()):\n-            if line.startswith(key + ' '):\n-                var = line[line.find(':=') + 2:].strip()\n-                if var != '':\n-                    return var\n-        return None\n-\n     def cargo(self):\n         \"\"\"Return config path for cargo\"\"\"\n         return self.program_config('cargo')\n@@ -407,15 +521,13 @@ def program_config(self, program):\n \n         >>> rb = RustBuild()\n         >>> rb.config_toml = 'rustc = \"rustc\"\\\\n'\n-        >>> rb.config_mk = 'CFG_LOCAL_RUST_ROOT := /tmp/rust\\\\n'\n         >>> rb.program_config('rustc')\n         'rustc'\n         >>> cargo_path = rb.program_config('cargo')\n         >>> cargo_path.rstrip(\".exe\") == os.path.join(\"/tmp/rust\",\n         ... \"bin\", \"cargo\")\n         True\n         >>> rb.config_toml = ''\n-        >>> rb.config_mk = ''\n         >>> cargo_path = rb.program_config('cargo')\n         >>> cargo_path.rstrip(\".exe\") == os.path.join(rb.bin_root(),\n         ... \"bin\", \"cargo\")\n@@ -424,10 +536,6 @@ def program_config(self, program):\n         config = self.get_toml(program)\n         if config:\n             return config\n-        config = self.get_mk('CFG_LOCAL_RUST_ROOT')\n-        if config:\n-            return os.path.join(config, \"bin\", \"{}{}\".format(\n-                program, self.exe_suffix()))\n         return os.path.join(self.bin_root(), \"bin\", \"{}{}\".format(\n             program, self.exe_suffix()))\n \n@@ -439,10 +547,14 @@ def get_string(line):\n         'devel'\n         \"\"\"\n         start = line.find('\"')\n-        if start == -1:\n-            return None\n-        end = start + 1 + line[start + 1:].find('\"')\n-        return line[start + 1:end]\n+        if start != -1:\n+            end = start + 1 + line[start + 1:].find('\"')\n+            return line[start + 1:end]\n+        start = line.find('\\'')\n+        if start != -1:\n+            end = start + 1 + line[start + 1:].find('\\'')\n+            return line[start + 1:end]\n+        return None\n \n     @staticmethod\n     def exe_suffix():\n@@ -521,154 +633,12 @@ def build_triple(self):\n         config = self.get_toml('build')\n         if config:\n             return config\n-        config = self.get_mk('CFG_BUILD')\n-        if config:\n-            return config\n-        try:\n-            ostype = subprocess.check_output(\n-                ['uname', '-s']).strip().decode(default_encoding)\n-            cputype = subprocess.check_output(\n-                ['uname', '-m']).strip().decode(default_encoding)\n-        except (subprocess.CalledProcessError, OSError):\n-            if sys.platform == 'win32':\n-                return 'x86_64-pc-windows-msvc'\n-            err = \"uname not found\"\n-            if self.verbose:\n-                raise Exception(err)\n-            sys.exit(err)\n-\n-        # The goal here is to come up with the same triple as LLVM would,\n-        # at least for the subset of platforms we're willing to target.\n-        ostype_mapper = {\n-            'Bitrig': 'unknown-bitrig',\n-            'Darwin': 'apple-darwin',\n-            'DragonFly': 'unknown-dragonfly',\n-            'FreeBSD': 'unknown-freebsd',\n-            'Haiku': 'unknown-haiku',\n-            'NetBSD': 'unknown-netbsd',\n-            'OpenBSD': 'unknown-openbsd'\n-        }\n-\n-        # Consider the direct transformation first and then the special cases\n-        if ostype in ostype_mapper:\n-            ostype = ostype_mapper[ostype]\n-        elif ostype == 'Linux':\n-            os_from_sp = subprocess.check_output(\n-                ['uname', '-o']).strip().decode(default_encoding)\n-            if os_from_sp == 'Android':\n-                ostype = 'linux-android'\n-            else:\n-                ostype = 'unknown-linux-gnu'\n-        elif ostype == 'SunOS':\n-            ostype = 'sun-solaris'\n-            # On Solaris, uname -m will return a machine classification instead\n-            # of a cpu type, so uname -p is recommended instead.  However, the\n-            # output from that option is too generic for our purposes (it will\n-            # always emit 'i386' on x86/amd64 systems).  As such, isainfo -k\n-            # must be used instead.\n-            try:\n-                cputype = subprocess.check_output(\n-                    ['isainfo', '-k']).strip().decode(default_encoding)\n-            except (subprocess.CalledProcessError, OSError):\n-                err = \"isainfo not found\"\n-                if self.verbose:\n-                    raise Exception(err)\n-                sys.exit(err)\n-        elif ostype.startswith('MINGW'):\n-            # msys' `uname` does not print gcc configuration, but prints msys\n-            # configuration. so we cannot believe `uname -m`:\n-            # msys1 is always i686 and msys2 is always x86_64.\n-            # instead, msys defines $MSYSTEM which is MINGW32 on i686 and\n-            # MINGW64 on x86_64.\n-            ostype = 'pc-windows-gnu'\n-            cputype = 'i686'\n-            if os.environ.get('MSYSTEM') == 'MINGW64':\n-                cputype = 'x86_64'\n-        elif ostype.startswith('MSYS'):\n-            ostype = 'pc-windows-gnu'\n-        elif ostype.startswith('CYGWIN_NT'):\n-            cputype = 'i686'\n-            if ostype.endswith('WOW64'):\n-                cputype = 'x86_64'\n-            ostype = 'pc-windows-gnu'\n-        else:\n-            err = \"unknown OS type: {}\".format(ostype)\n-            if self.verbose:\n-                raise ValueError(err)\n-            sys.exit(err)\n-\n-        cputype_mapper = {\n-            'BePC': 'i686',\n-            'aarch64': 'aarch64',\n-            'amd64': 'x86_64',\n-            'arm64': 'aarch64',\n-            'i386': 'i686',\n-            'i486': 'i686',\n-            'i686': 'i686',\n-            'i786': 'i686',\n-            'powerpc': 'powerpc',\n-            'powerpc64': 'powerpc64',\n-            'powerpc64le': 'powerpc64le',\n-            'ppc': 'powerpc',\n-            'ppc64': 'powerpc64',\n-            'ppc64le': 'powerpc64le',\n-            's390x': 's390x',\n-            'x64': 'x86_64',\n-            'x86': 'i686',\n-            'x86-64': 'x86_64',\n-            'x86_64': 'x86_64'\n-        }\n-\n-        # Consider the direct transformation first and then the special cases\n-        if cputype in cputype_mapper:\n-            cputype = cputype_mapper[cputype]\n-        elif cputype in {'xscale', 'arm'}:\n-            cputype = 'arm'\n-            if ostype == 'linux-android':\n-                ostype = 'linux-androideabi'\n-        elif cputype == 'armv6l':\n-            cputype = 'arm'\n-            if ostype == 'linux-android':\n-                ostype = 'linux-androideabi'\n-            else:\n-                ostype += 'eabihf'\n-        elif cputype in {'armv7l', 'armv8l'}:\n-            cputype = 'armv7'\n-            if ostype == 'linux-android':\n-                ostype = 'linux-androideabi'\n-            else:\n-                ostype += 'eabihf'\n-        elif cputype == 'mips':\n-            if sys.byteorder == 'big':\n-                cputype = 'mips'\n-            elif sys.byteorder == 'little':\n-                cputype = 'mipsel'\n-            else:\n-                raise ValueError(\"unknown byteorder: {}\".format(sys.byteorder))\n-        elif cputype == 'mips64':\n-            if sys.byteorder == 'big':\n-                cputype = 'mips64'\n-            elif sys.byteorder == 'little':\n-                cputype = 'mips64el'\n-            else:\n-                raise ValueError('unknown byteorder: {}'.format(sys.byteorder))\n-            # only the n64 ABI is supported, indicate it\n-            ostype += 'abi64'\n-        elif cputype == 'sparcv9':\n-            pass\n-        else:\n-            err = \"unknown cpu type: {}\".format(cputype)\n-            if self.verbose:\n-                raise ValueError(err)\n-            sys.exit(err)\n-\n-        return \"{}-{}\".format(cputype, ostype)\n+        return default_build_triple()\n \n     def update_submodules(self):\n         \"\"\"Update submodules\"\"\"\n         if (not os.path.exists(os.path.join(self.rust_root, \".git\"))) or \\\n-                self.get_toml('submodules') == \"false\" or \\\n-                self.get_mk('CFG_DISABLE_MANAGE_SUBMODULES') == \"1\":\n+                self.get_toml('submodules') == \"false\":\n             return\n         print('Updating submodules')\n         default_encoding = sys.getdefaultencoding()\n@@ -680,11 +650,9 @@ def update_submodules(self):\n         ).decode(default_encoding).splitlines()]\n         submodules = [module for module in submodules\n                       if not ((module.endswith(\"llvm\") and\n-                               (self.get_toml('llvm-config') or\n-                                self.get_mk('CFG_LLVM_ROOT'))) or\n+                               self.get_toml('llvm-config')) or\n                               (module.endswith(\"jemalloc\") and\n-                               (self.get_toml('jemalloc') or\n-                                self.get_mk('CFG_JEMALLOC_ROOT'))))]\n+                               self.get_toml('jemalloc')))]\n         run([\"git\", \"submodule\", \"update\",\n              \"--init\", \"--recursive\"] + submodules,\n             cwd=self.rust_root, verbose=self.verbose)\n@@ -721,21 +689,15 @@ def bootstrap():\n             build.config_toml = config.read()\n     except:\n         pass\n-    try:\n-        build.config_mk = open('config.mk').read()\n-    except:\n-        pass\n \n     if '\\nverbose = 2' in build.config_toml:\n         build.verbose = 2\n     elif '\\nverbose = 1' in build.config_toml:\n         build.verbose = 1\n \n-    build.use_vendored_sources = '\\nvendor = true' in build.config_toml or \\\n-                                 'CFG_ENABLE_VENDOR' in build.config_mk\n+    build.use_vendored_sources = '\\nvendor = true' in build.config_toml\n \n-    build.use_locked_deps = '\\nlocked-deps = true' in build.config_toml or \\\n-                            'CFG_ENABLE_LOCKED_DEPS' in build.config_mk\n+    build.use_locked_deps = '\\nlocked-deps = true' in build.config_toml\n \n     if 'SUDO_USER' in os.environ and not build.use_vendored_sources:\n         if os.environ.get('USER') != os.environ['SUDO_USER']:"}, {"sha": "2c25f374e12a4f32f82a7b8e97d96c591768fec6", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 51, "deletions": 252, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/a9b0a7ba935c79b45effcc2f55eb056bd087d9a4/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9b0a7ba935c79b45effcc2f55eb056bd087d9a4/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=a9b0a7ba935c79b45effcc2f55eb056bd087d9a4", "patch": "@@ -10,20 +10,20 @@\n \n //! Serialized configuration of a build.\n //!\n-//! This module implements parsing `config.mk` and `config.toml` configuration\n-//! files to tweak how the build runs.\n+//! This module implements parsing `config.toml` configuration files to tweak\n+//! how the build runs.\n \n use std::collections::HashMap;\n use std::env;\n-use std::fs::{self, File};\n+use std::fs::File;\n use std::io::prelude::*;\n use std::path::PathBuf;\n use std::process;\n use std::cmp;\n \n use num_cpus;\n use toml;\n-use util::{exe, push_exe_path};\n+use util::exe;\n use cache::{INTERNER, Interned};\n use flags::Flags;\n pub use flags::Subcommand;\n@@ -124,14 +124,12 @@ pub struct Config {\n     pub nodejs: Option<PathBuf>,\n     pub gdb: Option<PathBuf>,\n     pub python: Option<PathBuf>,\n-    pub configure_args: Vec<String>,\n     pub openssl_static: bool,\n-\n+    pub configure_args: Vec<String>,\n \n     // These are either the stage0 downloaded binaries or the locally installed ones.\n     pub initial_cargo: PathBuf,\n     pub initial_rustc: PathBuf,\n-\n }\n \n /// Per-target configuration stored in the global configuration structure.\n@@ -190,6 +188,8 @@ struct Build {\n     sanitizers: Option<bool>,\n     profiler: Option<bool>,\n     openssl_static: Option<bool>,\n+    configure_args: Option<Vec<String>>,\n+    local_rebuild: Option<bool>,\n }\n \n /// TOML representation of various global install decisions.\n@@ -219,6 +219,7 @@ struct Llvm {\n     targets: Option<String>,\n     experimental_targets: Option<String>,\n     link_jobs: Option<u32>,\n+    link_shared: Option<bool>,\n }\n \n #[derive(Deserialize, Default, Clone)]\n@@ -265,6 +266,9 @@ struct Rust {\n     debuginfo_tests: Option<bool>,\n     codegen_tests: Option<bool>,\n     ignore_git: Option<bool>,\n+    debug: Option<bool>,\n+    dist_src: Option<bool>,\n+    quiet_tests: Option<bool>,\n }\n \n /// TOML representation of how each build target is configured.\n@@ -374,6 +378,8 @@ impl Config {\n         set(&mut config.sanitizers, build.sanitizers);\n         set(&mut config.profiler, build.profiler);\n         set(&mut config.openssl_static, build.openssl_static);\n+        set(&mut config.configure_args, build.configure_args);\n+        set(&mut config.local_rebuild, build.local_rebuild);\n         config.verbose = cmp::max(config.verbose, flags.verbose);\n \n         if let Some(ref install) = toml.install {\n@@ -385,6 +391,17 @@ impl Config {\n             config.mandir = install.mandir.clone().map(PathBuf::from);\n         }\n \n+        // Store off these values as options because if they're not provided\n+        // we'll infer default values for them later\n+        let mut llvm_assertions = None;\n+        let mut debuginfo_lines = None;\n+        let mut debuginfo_only_std = None;\n+        let mut debug = None;\n+        let mut debug_jemalloc = None;\n+        let mut debuginfo = None;\n+        let mut debug_assertions = None;\n+        let mut optimize = None;\n+\n         if let Some(ref llvm) = toml.llvm {\n             match llvm.ccache {\n                 Some(StringOrBool::String(ref s)) => {\n@@ -397,31 +414,35 @@ impl Config {\n             }\n             set(&mut config.ninja, llvm.ninja);\n             set(&mut config.llvm_enabled, llvm.enabled);\n-            set(&mut config.llvm_assertions, llvm.assertions);\n+            llvm_assertions = llvm.assertions;\n             set(&mut config.llvm_optimize, llvm.optimize);\n             set(&mut config.llvm_release_debuginfo, llvm.release_debuginfo);\n             set(&mut config.llvm_version_check, llvm.version_check);\n             set(&mut config.llvm_static_stdcpp, llvm.static_libstdcpp);\n+            set(&mut config.llvm_link_shared, llvm.link_shared);\n             config.llvm_targets = llvm.targets.clone();\n             config.llvm_experimental_targets = llvm.experimental_targets.clone();\n             config.llvm_link_jobs = llvm.link_jobs;\n         }\n \n         if let Some(ref rust) = toml.rust {\n-            set(&mut config.rust_debug_assertions, rust.debug_assertions);\n-            set(&mut config.rust_debuginfo, rust.debuginfo);\n-            set(&mut config.rust_debuginfo_lines, rust.debuginfo_lines);\n-            set(&mut config.rust_debuginfo_only_std, rust.debuginfo_only_std);\n-            set(&mut config.rust_optimize, rust.optimize);\n+            debug = rust.debug;\n+            debug_assertions = rust.debug_assertions;\n+            debuginfo = rust.debuginfo;\n+            debuginfo_lines = rust.debuginfo_lines;\n+            debuginfo_only_std = rust.debuginfo_only_std;\n+            optimize = rust.optimize;\n+            debug_jemalloc = rust.debug_jemalloc;\n             set(&mut config.rust_optimize_tests, rust.optimize_tests);\n             set(&mut config.rust_debuginfo_tests, rust.debuginfo_tests);\n             set(&mut config.codegen_tests, rust.codegen_tests);\n             set(&mut config.rust_rpath, rust.rpath);\n-            set(&mut config.debug_jemalloc, rust.debug_jemalloc);\n             set(&mut config.use_jemalloc, rust.use_jemalloc);\n             set(&mut config.backtrace, rust.backtrace);\n             set(&mut config.channel, rust.channel.clone());\n             set(&mut config.ignore_git, rust.ignore_git);\n+            set(&mut config.rust_dist_src, rust.dist_src);\n+            set(&mut config.quiet_tests, rust.quiet_tests);\n             config.rustc_default_linker = rust.default_linker.clone();\n             config.rustc_default_ar = rust.default_ar.clone();\n             config.musl_root = rust.musl_root.clone().map(PathBuf::from);\n@@ -476,224 +497,26 @@ impl Config {\n             None => stage0_root.join(exe(\"cargo\", &config.build)),\n         };\n \n-        // compat with `./configure` while we're still using that\n-        if fs::metadata(\"config.mk\").is_ok() {\n-            config.update_with_config_mk();\n-        }\n+        // Now that we've reached the end of our configuration, infer the\n+        // default values for all options that we haven't otherwise stored yet.\n \n-        config\n-    }\n+        let default = config.channel == \"nightly\";\n+        config.llvm_assertions = llvm_assertions.unwrap_or(default);\n \n-    /// \"Temporary\" routine to parse `config.mk` into this configuration.\n-    ///\n-    /// While we still have `./configure` this implements the ability to decode\n-    /// that configuration into this. This isn't exactly a full-blown makefile\n-    /// parser, but hey it gets the job done!\n-    fn update_with_config_mk(&mut self) {\n-        let mut config = String::new();\n-        File::open(\"config.mk\").unwrap().read_to_string(&mut config).unwrap();\n-        for line in config.lines() {\n-            let mut parts = line.splitn(2, \":=\").map(|s| s.trim());\n-            let key = parts.next().unwrap();\n-            let value = match parts.next() {\n-                Some(n) if n.starts_with('\\\"') => &n[1..n.len() - 1],\n-                Some(n) => n,\n-                None => continue\n-            };\n-\n-            macro_rules! check {\n-                ($(($name:expr, $val:expr),)*) => {\n-                    if value == \"1\" {\n-                        $(\n-                            if key == concat!(\"CFG_ENABLE_\", $name) {\n-                                $val = true;\n-                                continue\n-                            }\n-                            if key == concat!(\"CFG_DISABLE_\", $name) {\n-                                $val = false;\n-                                continue\n-                            }\n-                        )*\n-                    }\n-                }\n-            }\n-\n-            check! {\n-                (\"MANAGE_SUBMODULES\", self.submodules),\n-                (\"COMPILER_DOCS\", self.compiler_docs),\n-                (\"DOCS\", self.docs),\n-                (\"LLVM_ASSERTIONS\", self.llvm_assertions),\n-                (\"LLVM_RELEASE_DEBUGINFO\", self.llvm_release_debuginfo),\n-                (\"OPTIMIZE_LLVM\", self.llvm_optimize),\n-                (\"LLVM_VERSION_CHECK\", self.llvm_version_check),\n-                (\"LLVM_STATIC_STDCPP\", self.llvm_static_stdcpp),\n-                (\"LLVM_LINK_SHARED\", self.llvm_link_shared),\n-                (\"OPTIMIZE\", self.rust_optimize),\n-                (\"DEBUG_ASSERTIONS\", self.rust_debug_assertions),\n-                (\"DEBUGINFO\", self.rust_debuginfo),\n-                (\"DEBUGINFO_LINES\", self.rust_debuginfo_lines),\n-                (\"DEBUGINFO_ONLY_STD\", self.rust_debuginfo_only_std),\n-                (\"JEMALLOC\", self.use_jemalloc),\n-                (\"DEBUG_JEMALLOC\", self.debug_jemalloc),\n-                (\"RPATH\", self.rust_rpath),\n-                (\"OPTIMIZE_TESTS\", self.rust_optimize_tests),\n-                (\"DEBUGINFO_TESTS\", self.rust_debuginfo_tests),\n-                (\"QUIET_TESTS\", self.quiet_tests),\n-                (\"LOCAL_REBUILD\", self.local_rebuild),\n-                (\"NINJA\", self.ninja),\n-                (\"CODEGEN_TESTS\", self.codegen_tests),\n-                (\"LOCKED_DEPS\", self.locked_deps),\n-                (\"VENDOR\", self.vendor),\n-                (\"FULL_BOOTSTRAP\", self.full_bootstrap),\n-                (\"EXTENDED\", self.extended),\n-                (\"SANITIZERS\", self.sanitizers),\n-                (\"PROFILER\", self.profiler),\n-                (\"DIST_SRC\", self.rust_dist_src),\n-                (\"CARGO_OPENSSL_STATIC\", self.openssl_static),\n-            }\n+        let default = match &config.channel[..] {\n+            \"stable\" | \"beta\" | \"nightly\" => true,\n+            _ => false,\n+        };\n+        config.rust_debuginfo_lines = debuginfo_lines.unwrap_or(default);\n+        config.rust_debuginfo_only_std = debuginfo_only_std.unwrap_or(default);\n \n-            match key {\n-                \"CFG_BUILD\" if value.len() > 0 => self.build = INTERNER.intern_str(value),\n-                \"CFG_HOST\" if value.len() > 0 => {\n-                    self.hosts.extend(value.split(\" \").map(|s| INTERNER.intern_str(s)));\n+        let default = debug == Some(true);\n+        config.debug_jemalloc = debug_jemalloc.unwrap_or(default);\n+        config.rust_debuginfo = debuginfo.unwrap_or(default);\n+        config.rust_debug_assertions = debug_assertions.unwrap_or(default);\n+        config.rust_optimize = optimize.unwrap_or(!default);\n \n-                }\n-                \"CFG_TARGET\" if value.len() > 0 => {\n-                    self.targets.extend(value.split(\" \").map(|s| INTERNER.intern_str(s)));\n-                }\n-                \"CFG_EXPERIMENTAL_TARGETS\" if value.len() > 0 => {\n-                    self.llvm_experimental_targets = Some(value.to_string());\n-                }\n-                \"CFG_MUSL_ROOT\" if value.len() > 0 => {\n-                    self.musl_root = Some(parse_configure_path(value));\n-                }\n-                \"CFG_MUSL_ROOT_X86_64\" if value.len() > 0 => {\n-                    let target = INTERNER.intern_str(\"x86_64-unknown-linux-musl\");\n-                    let target = self.target_config.entry(target).or_insert(Target::default());\n-                    target.musl_root = Some(parse_configure_path(value));\n-                }\n-                \"CFG_MUSL_ROOT_I686\" if value.len() > 0 => {\n-                    let target = INTERNER.intern_str(\"i686-unknown-linux-musl\");\n-                    let target = self.target_config.entry(target).or_insert(Target::default());\n-                    target.musl_root = Some(parse_configure_path(value));\n-                }\n-                \"CFG_MUSL_ROOT_ARM\" if value.len() > 0 => {\n-                    let target = INTERNER.intern_str(\"arm-unknown-linux-musleabi\");\n-                    let target = self.target_config.entry(target).or_insert(Target::default());\n-                    target.musl_root = Some(parse_configure_path(value));\n-                }\n-                \"CFG_MUSL_ROOT_ARMHF\" if value.len() > 0 => {\n-                    let target = INTERNER.intern_str(\"arm-unknown-linux-musleabihf\");\n-                    let target = self.target_config.entry(target).or_insert(Target::default());\n-                    target.musl_root = Some(parse_configure_path(value));\n-                }\n-                \"CFG_MUSL_ROOT_ARMV7\" if value.len() > 0 => {\n-                    let target = INTERNER.intern_str(\"armv7-unknown-linux-musleabihf\");\n-                    let target = self.target_config.entry(target).or_insert(Target::default());\n-                    target.musl_root = Some(parse_configure_path(value));\n-                }\n-                \"CFG_DEFAULT_AR\" if value.len() > 0 => {\n-                    self.rustc_default_ar = Some(value.to_string());\n-                }\n-                \"CFG_DEFAULT_LINKER\" if value.len() > 0 => {\n-                    self.rustc_default_linker = Some(value.to_string());\n-                }\n-                \"CFG_GDB\" if value.len() > 0 => {\n-                    self.gdb = Some(parse_configure_path(value));\n-                }\n-                \"CFG_RELEASE_CHANNEL\" => {\n-                    self.channel = value.to_string();\n-                }\n-                \"CFG_PREFIX\" => {\n-                    self.prefix = Some(PathBuf::from(value));\n-                }\n-                \"CFG_SYSCONFDIR\" => {\n-                    self.sysconfdir = Some(PathBuf::from(value));\n-                }\n-                \"CFG_DOCDIR\" => {\n-                    self.docdir = Some(PathBuf::from(value));\n-                }\n-                \"CFG_BINDIR\" => {\n-                    self.bindir = Some(PathBuf::from(value));\n-                }\n-                \"CFG_LIBDIR\" => {\n-                    self.libdir = Some(PathBuf::from(value));\n-                }\n-                \"CFG_LIBDIR_RELATIVE\" => {\n-                    self.libdir_relative = Some(PathBuf::from(value));\n-                }\n-                \"CFG_MANDIR\" => {\n-                    self.mandir = Some(PathBuf::from(value));\n-                }\n-                \"CFG_LLVM_ROOT\" if value.len() > 0 => {\n-                    let target = self.target_config.entry(self.build.clone())\n-                                     .or_insert(Target::default());\n-                    let root = parse_configure_path(value);\n-                    target.llvm_config = Some(push_exe_path(root, &[\"bin\", \"llvm-config\"]));\n-                }\n-                \"CFG_JEMALLOC_ROOT\" if value.len() > 0 => {\n-                    let target = self.target_config.entry(self.build.clone())\n-                                     .or_insert(Target::default());\n-                    target.jemalloc = Some(parse_configure_path(value).join(\"libjemalloc_pic.a\"));\n-                }\n-                \"CFG_ARM_LINUX_ANDROIDEABI_NDK\" if value.len() > 0 => {\n-                    let target = INTERNER.intern_str(\"arm-linux-androideabi\");\n-                    let target = self.target_config.entry(target).or_insert(Target::default());\n-                    target.ndk = Some(parse_configure_path(value));\n-                }\n-                \"CFG_ARMV7_LINUX_ANDROIDEABI_NDK\" if value.len() > 0 => {\n-                    let target = INTERNER.intern_str(\"armv7-linux-androideabi\");\n-                    let target = self.target_config.entry(target).or_insert(Target::default());\n-                    target.ndk = Some(parse_configure_path(value));\n-                }\n-                \"CFG_I686_LINUX_ANDROID_NDK\" if value.len() > 0 => {\n-                    let target = INTERNER.intern_str(\"i686-linux-android\");\n-                    let target = self.target_config.entry(target).or_insert(Target::default());\n-                    target.ndk = Some(parse_configure_path(value));\n-                }\n-                \"CFG_AARCH64_LINUX_ANDROID_NDK\" if value.len() > 0 => {\n-                    let target = INTERNER.intern_str(\"aarch64-linux-android\");\n-                    let target = self.target_config.entry(target).or_insert(Target::default());\n-                    target.ndk = Some(parse_configure_path(value));\n-                }\n-                \"CFG_X86_64_LINUX_ANDROID_NDK\" if value.len() > 0 => {\n-                    let target = INTERNER.intern_str(\"x86_64-linux-android\");\n-                    let target = self.target_config.entry(target).or_insert(Target::default());\n-                    target.ndk = Some(parse_configure_path(value));\n-                }\n-                \"CFG_LOCAL_RUST_ROOT\" if value.len() > 0 => {\n-                    let path = parse_configure_path(value);\n-                    self.initial_rustc = push_exe_path(path.clone(), &[\"bin\", \"rustc\"]);\n-                    self.initial_cargo = push_exe_path(path, &[\"bin\", \"cargo\"]);\n-                }\n-                \"CFG_PYTHON\" if value.len() > 0 => {\n-                    let path = parse_configure_path(value);\n-                    self.python = Some(path);\n-                }\n-                \"CFG_ENABLE_CCACHE\" if value == \"1\" => {\n-                    self.ccache = Some(exe(\"ccache\", &self.build));\n-                }\n-                \"CFG_ENABLE_SCCACHE\" if value == \"1\" => {\n-                    self.ccache = Some(exe(\"sccache\", &self.build));\n-                }\n-                \"CFG_CONFIGURE_ARGS\" if value.len() > 0 => {\n-                    self.configure_args = value.split_whitespace()\n-                                               .map(|s| s.to_string())\n-                                               .collect();\n-                }\n-                \"CFG_QEMU_ARMHF_ROOTFS\" if value.len() > 0 => {\n-                    let target = INTERNER.intern_str(\"arm-unknown-linux-gnueabihf\");\n-                    let target = self.target_config.entry(target).or_insert(Target::default());\n-                    target.qemu_rootfs = Some(parse_configure_path(value));\n-                }\n-                \"CFG_QEMU_AARCH64_ROOTFS\" if value.len() > 0 => {\n-                    let target = INTERNER.intern_str(\"aarch64-unknown-linux-gnu\");\n-                    let target = self.target_config.entry(target).or_insert(Target::default());\n-                    target.qemu_rootfs = Some(parse_configure_path(value));\n-                }\n-                _ => {}\n-            }\n-        }\n+        config\n     }\n \n     pub fn verbose(&self) -> bool {\n@@ -705,30 +528,6 @@ impl Config {\n     }\n }\n \n-#[cfg(not(windows))]\n-fn parse_configure_path(path: &str) -> PathBuf {\n-    path.into()\n-}\n-\n-#[cfg(windows)]\n-fn parse_configure_path(path: &str) -> PathBuf {\n-    // on windows, configure produces unix style paths e.g. /c/some/path but we\n-    // only want real windows paths\n-\n-    use std::process::Command;\n-    use build_helper;\n-\n-    // '/' is invalid in windows paths, so we can detect unix paths by the presence of it\n-    if !path.contains('/') {\n-        return path.into();\n-    }\n-\n-    let win_path = build_helper::output(Command::new(\"cygpath\").arg(\"-w\").arg(path));\n-    let win_path = win_path.trim();\n-\n-    win_path.into()\n-}\n-\n fn set<T>(field: &mut T, val: Option<T>) {\n     if let Some(v) = val {\n         *field = v;"}, {"sha": "0e11635c3a0b1e89b49049d35969c34897b176d6", "filename": "src/bootstrap/configure.py", "status": "added", "additions": 408, "deletions": 0, "changes": 408, "blob_url": "https://github.com/rust-lang/rust/blob/a9b0a7ba935c79b45effcc2f55eb056bd087d9a4/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/a9b0a7ba935c79b45effcc2f55eb056bd087d9a4/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=a9b0a7ba935c79b45effcc2f55eb056bd087d9a4", "patch": "@@ -0,0 +1,408 @@\n+#!/usr/bin/env python\n+# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+# ignore-tidy-linelength\n+\n+import sys\n+import os\n+rust_dir = os.path.dirname(os.path.abspath(__file__))\n+rust_dir = os.path.dirname(rust_dir)\n+rust_dir = os.path.dirname(rust_dir)\n+sys.path.append(os.path.join(rust_dir, \"src\", \"bootstrap\"))\n+import bootstrap\n+\n+class Option:\n+    def __init__(self, name, rustbuild, desc, value):\n+        self.name = name\n+        self.rustbuild = rustbuild\n+        self.desc = desc\n+        self.value = value\n+\n+options = []\n+\n+def o(*args):\n+    options.append(Option(*args, value=False))\n+\n+def v(*args):\n+    options.append(Option(*args, value=True))\n+\n+o(\"debug\", \"rust.debug\", \"debug mode; disables optimization unless `--enable-optimize` given\")\n+o(\"docs\", \"build.docs\", \"build standard library documentation\")\n+o(\"compiler-docs\", \"build.compiler-docs\", \"build compiler documentation\")\n+o(\"optimize-tests\", \"rust.optimize-tests\", \"build tests with optimizations\")\n+o(\"debuginfo-tests\", \"rust.debuginfo-tests\", \"build tests with debugger metadata\")\n+o(\"quiet-tests\", \"rust.quiet-tests\", \"enable quieter output when running tests\")\n+o(\"ccache\", \"llvm.ccache\", \"invoke gcc/clang via ccache to reuse object files between builds\")\n+o(\"sccache\", None, \"invoke gcc/clang via sccache to reuse object files between builds\")\n+o(\"local-rust\", None, \"use an installed rustc rather than downloading a snapshot\")\n+v(\"local-rust-root\", None, \"set prefix for local rust binary\")\n+o(\"local-rebuild\", \"build.local-rebuild\", \"assume local-rust matches the current version, for rebuilds; implies local-rust, and is implied if local-rust already matches the current version\")\n+o(\"llvm-static-stdcpp\", \"llvm.static-libstdcpp\", \"statically link to libstdc++ for LLVM\")\n+o(\"llvm-link-shared\", \"llvm.link-shared\", \"prefer shared linking to LLVM (llvm-config --link-shared)\")\n+o(\"rpath\", \"rust.rpath\", \"build rpaths into rustc itself\")\n+o(\"llvm-version-check\", \"llvm.version-check\", \"check if the LLVM version is supported, build anyway\")\n+o(\"codegen-tests\", \"rust.codegen-tests\", \"run the src/test/codegen tests\")\n+o(\"option-checking\", None, \"complain about unrecognized options in this configure script\")\n+o(\"ninja\", \"llvm.ninja\", \"build LLVM using the Ninja generator (for MSVC, requires building in the correct environment)\")\n+o(\"locked-deps\", \"build.locked-deps\", \"force Cargo.lock to be up to date\")\n+o(\"vendor\", \"build.vendor\", \"enable usage of vendored Rust crates\")\n+o(\"sanitizers\", \"build.sanitizers\", \"build the sanitizer runtimes (asan, lsan, msan, tsan)\")\n+o(\"dist-src\", \"rust.dist-src\", \"when building tarballs enables building a source tarball\")\n+o(\"cargo-openssl-static\", \"build.openssl-static\", \"static openssl in cargo\")\n+o(\"profiler\", \"build.profiler\", \"build the profiler runtime\")\n+\n+# Optimization and debugging options. These may be overridden by the release\n+# channel, etc.\n+o(\"optimize\", \"rust.optimize\", \"build optimized rust code\")\n+o(\"optimize-llvm\", \"llvm.optimize\", \"build optimized LLVM\")\n+o(\"llvm-assertions\", \"llvm.assertions\", \"build LLVM with assertions\")\n+o(\"debug-assertions\", \"rust.debug-assertions\", \"build with debugging assertions\")\n+o(\"llvm-release-debuginfo\", \"llvm.release-debuginfo\", \"build LLVM with debugger metadata\")\n+o(\"debuginfo\", \"rust.debuginfo\", \"build with debugger metadata\")\n+o(\"debuginfo-lines\", \"rust.debuginfo-lines\", \"build with line number debugger metadata\")\n+o(\"debuginfo-only-std\", \"rust.debuginfo-only-std\", \"build only libstd with debugging information\")\n+o(\"debug-jemalloc\", \"rust.debug-jemalloc\", \"build jemalloc with --enable-debug --enable-fill\")\n+\n+v(\"prefix\", \"install.prefix\", \"set installation prefix\")\n+v(\"localstatedir\", \"install.localstatedir\", \"local state directory\")\n+v(\"datadir\", \"install.datadir\", \"install data\")\n+v(\"sysconfdir\", \"install.sysconfdir\", \"install system configuration files\")\n+v(\"infodir\", \"install.infodir\", \"install additional info\")\n+v(\"libdir\", \"install.libdir\", \"install libraries\")\n+v(\"mandir\", \"install.mandir\", \"install man pages in PATH\")\n+v(\"docdir\", \"install.docdir\", \"install documentation in PATH\")\n+v(\"bindir\", \"install.bindir\", \"install binaries\")\n+\n+v(\"llvm-root\", None, \"set LLVM root\")\n+v(\"python\", \"build.python\", \"set path to python\")\n+v(\"jemalloc-root\", None, \"set directory where libjemalloc_pic.a is located\")\n+v(\"android-cross-path\", \"target.arm-linux-androideabi.android-ndk\",\n+  \"Android NDK standalone path (deprecated)\")\n+v(\"i686-linux-android-ndk\", \"target.i686-linux-android.android-ndk\",\n+  \"i686-linux-android NDK standalone path\")\n+v(\"arm-linux-androideabi-ndk\", \"target.arm-linux-androideabi.android-ndk\",\n+  \"arm-linux-androideabi NDK standalone path\")\n+v(\"armv7-linux-androideabi-ndk\", \"target.armv7-linux-androideabi.android-ndk\",\n+  \"armv7-linux-androideabi NDK standalone path\")\n+v(\"aarch64-linux-android-ndk\", \"target.aarch64-linux-android.android-ndk\",\n+  \"aarch64-linux-android NDK standalone path\")\n+v(\"x86_64-linux-android-ndk\", \"target.x86_64-linux-android.android-ndk\",\n+  \"x86_64-linux-android NDK standalone path\")\n+v(\"musl-root\", \"target.x86_64-unknown-linux-musl.musl-root\",\n+  \"MUSL root installation directory (deprecated)\")\n+v(\"musl-root-x86_64\", \"target.x86_64-unknown-linux-musl.musl-root\",\n+  \"x86_64-unknown-linux-musl install directory\")\n+v(\"musl-root-i686\", \"target.i686-unknown-linux-musl.musl-root\",\n+  \"i686-unknown-linux-musl install directory\")\n+v(\"musl-root-arm\", \"target.arm-unknown-linux-musleabi.musl-root\",\n+  \"arm-unknown-linux-musleabi install directory\")\n+v(\"musl-root-armhf\", \"target.arm-unknown-linux-musleabihf.musl-root\",\n+  \"arm-unknown-linux-musleabihf install directory\")\n+v(\"musl-root-armv7\", \"target.armv7-unknown-linux-musleabihf.musl-root\",\n+  \"armv7-unknown-linux-musleabihf install directory\")\n+v(\"qemu-armhf-rootfs\", \"target.arm-unknown-linux-gnueabihf.qemu-rootfs\",\n+  \"rootfs in qemu testing, you probably don't want to use this\")\n+v(\"qemu-aarch64-rootfs\", \"target.aarch64-unknown-linux-gnu.qemu-rootfs\",\n+  \"rootfs in qemu testing, you probably don't want to use this\")\n+v(\"experimental-targets\", \"llvm.experimental-targets\",\n+  \"experimental LLVM targets to build\")\n+v(\"release-channel\", \"rust.channel\", \"the name of the release channel to build\")\n+\n+# Used on systems where \"cc\" and \"ar\" are unavailable\n+v(\"default-linker\", \"rust.default-linker\", \"the default linker\")\n+v(\"default-ar\", \"rust.default-ar\", \"the default ar\")\n+\n+# Many of these are saved below during the \"writing configuration\" step\n+# (others are conditionally saved).\n+o(\"manage-submodules\", \"build.submodules\", \"let the build manage the git submodules\")\n+o(\"jemalloc\", \"rust.use-jemalloc\", \"build liballoc with jemalloc\")\n+o(\"full-bootstrap\", \"build.full-bootstrap\", \"build three compilers instead of two\")\n+o(\"extended\", \"build.extended\", \"build an extended rust tool set\")\n+\n+v(\"build\", \"build.build\", \"GNUs ./configure syntax LLVM build triple\")\n+v(\"host\", None, \"GNUs ./configure syntax LLVM host triples\")\n+v(\"target\", None, \"GNUs ./configure syntax LLVM target triples\")\n+\n+v(\"set\", None, \"set arbitrary key/value pairs in TOML configuration\")\n+\n+def p(msg):\n+    print(\"configure: \" + msg)\n+\n+def err(msg):\n+    print(\"configure: error: \" + msg)\n+    sys.exit(1)\n+\n+if '--help' in sys.argv or '-h' in sys.argv:\n+    print('Usage: ./configure [options]')\n+    print('')\n+    print('Options')\n+    for option in options:\n+        if 'android' in option.name:\n+            # no one needs to know about these obscure options\n+            continue\n+        if option.value:\n+            print('\\t{:30} {}'.format('--{}=VAL'.format(option.name), option.desc))\n+        else:\n+            print('\\t{:30} {}'.format('--enable-{}'.format(option.name), option.desc))\n+    print('')\n+    print('This configure script is a thin configuration shim over the true')\n+    print('configuration system, `config.toml`. You can explore the comments')\n+    print('in `config.toml.example` next to this configure script to see')\n+    print('more information about what each option is. Additionally you can')\n+    print('pass `--set` as an argument to set arbitrary key/value pairs')\n+    print('in the TOML configuration if desired')\n+    print('')\n+    print('Also note that all options which take `--enable` can similarly')\n+    print('be passed with `--disable-foo` to forcibly disable the option')\n+    sys.exit(0)\n+\n+# Parse all command line arguments into one of these three lists, handling\n+# boolean and value-based options separately\n+unknown_args = []\n+need_value_args = []\n+known_args = {}\n+\n+p(\"processing command line\")\n+i = 1\n+while i < len(sys.argv):\n+    arg = sys.argv[i]\n+    i += 1\n+    if not arg.startswith('--'):\n+        unknown_args.append(arg)\n+        continue\n+\n+    found = False\n+    for option in options:\n+        value = None\n+        if option.value:\n+            keyval = arg[2:].split('=', 1)\n+            key = keyval[0]\n+            if option.name != key:\n+                continue\n+\n+            if len(keyval) > 1:\n+                value = keyval[1]\n+            elif i < len(sys.argv):\n+                value = sys.argv[i]\n+                i += 1\n+            else:\n+                need_value_args.append(arg)\n+                continue\n+        else:\n+            if arg[2:] == 'enable-' + option.name:\n+                value = True\n+            elif arg[2:] == 'disable-' + option.name:\n+                value = False\n+            else:\n+                continue\n+\n+        found = True\n+        if not option.name in known_args:\n+            known_args[option.name] = []\n+        known_args[option.name].append((option, value))\n+        break\n+\n+    if not found:\n+        unknown_args.append(arg)\n+p(\"\")\n+\n+if 'option-checking' not in known_args or known_args['option-checking'][1]:\n+    if len(unknown_args) > 0:\n+        err(\"Option '\" + unknown_args[0] + \"' is not recognized\")\n+    if len(need_value_args) > 0:\n+        err(\"Option '{0}' needs a value ({0}=val)\".format(need_value_args[0]))\n+\n+# Parse all known arguments into a configuration structure that reflects the\n+# TOML we're going to write out\n+config = {}\n+\n+def build():\n+    if 'build' in known_args:\n+        return known_args['build'][0][1]\n+    return bootstrap.default_build_triple()\n+\n+def set(key, value):\n+      s = \"{:20} := {}\".format(key, value)\n+      if len(s) < 70:\n+          p(s)\n+      else:\n+          p(s[:70] + \" ...\")\n+\n+      arr = config\n+      parts = key.split('.')\n+      for i, part in enumerate(parts):\n+          if i == len(parts) - 1:\n+              arr[part] = value\n+          else:\n+              if not part in arr:\n+                  arr[part] = {}\n+              arr = arr[part]\n+\n+for key in known_args:\n+    # The `set` option is special and an be passed a bunch of times\n+    if key == 'set':\n+        for option, value in known_args[key]:\n+            keyval = value.split('=', 1)\n+            set(keyval[0], True if len(keyval) == 1 else keyval[1])\n+        continue\n+\n+    # Ensure each option is only passed once\n+    arr = known_args[key]\n+    if len(arr) > 1:\n+        err(\"Option '{}' provided more than once\".format(key))\n+    option, value = arr[0]\n+\n+    # If we have a clear avenue to set our value in rustbuild, do so\n+    if option.rustbuild is not None:\n+        set(option.rustbuild, value)\n+        continue\n+\n+    # Otherwise we're a \"special\" option and need some extra handling, so do\n+    # that here.\n+    if option.name == 'sccache':\n+        set('llvm.ccache', 'sccache')\n+    elif option.name == 'local-rust':\n+        for path in os.environ['PATH'].split(os.pathsep):\n+            if os.path.exists(path + '/rustc'):\n+                set('build.rustc', path + '/rustc')\n+                break\n+        for path in os.environ['PATH'].split(os.pathsep):\n+            if os.path.exists(path + '/cargo'):\n+                set('build.cargo', path + '/cargo')\n+                break\n+    elif option.name == 'local-rust-root':\n+        set('build.rustc', value + '/bin/rustc')\n+        set('build.cargo', value + '/bin/cargo')\n+    elif option.name == 'llvm-root':\n+        set('target.{}.llvm-config'.format(build()), value + '/bin/llvm-config')\n+    elif option.name == 'jemalloc-root':\n+        set('target.{}.jemalloc'.format(build()), value + '/libjemalloc_pic.a')\n+    elif option.name == 'host':\n+        set('build.host', value.split(','))\n+    elif option.name == 'target':\n+        set('build.target', value.split(','))\n+    elif option.name == 'option-checking':\n+        # this was handled above\n+        pass\n+    else:\n+        raise RuntimeError(\"unhandled option {}\".format(option.name))\n+\n+set('build.configure-args', sys.argv[1:])\n+\n+# \"Parse\" the `config.toml.example` file into the various sections, and we'll\n+# use this as a template of a `config.toml` to write out which preserves\n+# all the various comments and whatnot.\n+#\n+# Note that the `target` section is handled separately as we'll duplicate it\n+# per configure dtarget, so there's a bit of special handling for that here.\n+sections = {}\n+cur_section = None\n+sections[None] = []\n+section_order = [None]\n+targets = {}\n+\n+for line in open(rust_dir + '/config.toml.example').read().split(\"\\n\"):\n+    if line.startswith('['):\n+        cur_section = line[1:-1]\n+        if cur_section.startswith('target'):\n+            cur_section = 'target'\n+        elif '.' in cur_section:\n+            raise RuntimeError(\"don't know how to deal with section: {}\".format(cur_section))\n+        sections[cur_section] = [line]\n+        section_order.append(cur_section)\n+    else:\n+        sections[cur_section].append(line)\n+\n+# Fill out the `targets` array by giving all configured targets a copy of the\n+# `target` section we just loaded from the example config\n+configured_targets = [build()]\n+if 'build' in config:\n+    if 'host' in config['build']:\n+        configured_targets += config['build']['host']\n+    if 'target' in config['build']:\n+        configured_targets += config['build']['target']\n+if 'target' in config:\n+    for target in config['target']:\n+        configured_targets.append(target)\n+for target in configured_targets:\n+    targets[target] = sections['target'][:]\n+    targets[target][0] = targets[target][0].replace(\"x86_64-unknown-linux-gnu\", target)\n+\n+# Here we walk through the constructed configuration we have from the parsed\n+# command line arguemnts. We then apply each piece of configuration by\n+# basically just doing a `sed` to change the various configuration line to what\n+# we've got configure.\n+def to_toml(value):\n+    if isinstance(value, bool):\n+        if value:\n+            return \"true\"\n+        else:\n+            return \"false\"\n+    elif isinstance(value, list):\n+        return '[' + ', '.join(map(to_toml, value)) + ']'\n+    elif isinstance(value, str):\n+        return \"'\" + value + \"'\"\n+    else:\n+        raise 'no toml'\n+\n+def configure_section(lines, config):\n+    for key in config:\n+        value = config[key]\n+        found = False\n+        for i, line in enumerate(lines):\n+            if not line.startswith('#' + key + ' = '):\n+                continue\n+            found = True\n+            lines[i] = \"{} = {}\".format(key, to_toml(value))\n+            break\n+        if not found:\n+            raise RuntimeError(\"failed to find config line for {}\".format(key))\n+\n+for section_key in config:\n+    section_config = config[section_key]\n+    if not section_key in sections:\n+        raise RuntimeError(\"config key {} not in sections\".format(key))\n+\n+    if section_key == 'target':\n+        for target in section_config:\n+            configure_section(targets[target], section_config[target])\n+    else:\n+        configure_section(sections[section_key], section_config)\n+\n+# Now that we've built up our `config.toml`, write it all out in the same\n+# order that we read it in.\n+p(\"\")\n+p(\"writing `config.toml` in current directory\")\n+with open('config.toml', 'w') as f:\n+    for section in section_order:\n+        if section == 'target':\n+            for target in targets:\n+                for line in targets[target]:\n+                    f.write(line + \"\\n\")\n+        else:\n+            for line in sections[section]:\n+                f.write(line + \"\\n\")\n+\n+with open('Makefile', 'w') as f:\n+    contents = os.path.join(rust_dir, 'src', 'bootstrap', 'mk', 'Makefile.in')\n+    contents = open(contents).read()\n+    contents = contents.replace(\"$(CFG_SRC_DIR)\", rust_dir + '/')\n+    contents = contents.replace(\"$(CFG_PYTHON)\", sys.executable)\n+    f.write(contents)\n+\n+# Finally, clean up with a bit of a help message\n+relpath = os.path.dirname(__file__)\n+if relpath == '':\n+    relpath = '.'\n+\n+p(\"\")\n+p(\"run `python {}/x.py --help`\".format(relpath))\n+p(\"\")"}, {"sha": "153ffe509f3086d531739161e1918fc871e8a6d3", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a9b0a7ba935c79b45effcc2f55eb056bd087d9a4/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9b0a7ba935c79b45effcc2f55eb056bd087d9a4/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=a9b0a7ba935c79b45effcc2f55eb056bd087d9a4", "patch": "@@ -822,6 +822,7 @@ impl Step for PlainSourceTarball {\n             \"RELEASES.md\",\n             \"configure\",\n             \"x.py\",\n+            \"config.toml.example\",\n         ];\n         let src_dirs = [\n             \"man\","}, {"sha": "67495b891f80d9bdf31c4332cc3e9bd3746014f7", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9b0a7ba935c79b45effcc2f55eb056bd087d9a4/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/a9b0a7ba935c79b45effcc2f55eb056bd087d9a4/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=a9b0a7ba935c79b45effcc2f55eb056bd087d9a4", "patch": "@@ -8,8 +8,6 @@\n # option. This file may not be copied, modified, or distributed\n # except according to those terms.\n \n-include config.mk\n-\n ifdef VERBOSE\n Q :=\n BOOTSTRAP_ARGS := -v"}]}