{"sha": "7be359e51be1d95e84937438f05a6ce05004ab5d", "node_id": "C_kwDOAAsO6NoAKDdiZTM1OWU1MWJlMWQ5NWU4NDkzNzQzOGYwNWE2Y2UwNTAwNGFiNWQ", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-08-07T19:10:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-07T19:10:22Z"}, "message": "Rollup merge of #100019 - TaKO8Ki:suggest-boxed-trait-objects-instead-of-impl-trait, r=compiler-errors\n\nRevive suggestions for boxed trait objects instead of impl Trait\n\nThe suggestion implemented in #75608 was not working properly, so I fixed it.", "tree": {"sha": "02aade133a2cd3644765d600725e17fbcf78a36d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02aade133a2cd3644765d600725e17fbcf78a36d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7be359e51be1d95e84937438f05a6ce05004ab5d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi8A4eCRBK7hj4Ov3rIwAAHi0IABypQOYwkkejWCKBk9e7lPGe\nGvYHlosZv1Te55/x5xsspoh2Dh8GT4etR53++ql1xinb2Ml9HCwbAh2ZYuXGndYY\nXxqa8hG8lWL28x5x9d/FFLMmk4HevBgEgoN2sUH71vaOSLyGBtZKkMDJRvSyZHML\nQsErQd6038ky5F5nMk5a04s+z4JH18wjcmK0dEP5RDPiISNdBTJWkq9gzhadK0y7\nvefNCRAyIWPvyC+bsOjHUu8LoBYblqMr0FpzTBrpcAhlMqB9QSJy9+e6xwRAgLy3\n72COymsFKB3xwTmNKYMMG24xzTezgjZ4Eq7sLxkwq2I0CZSEUTjQab4T/Vl4OuQ=\n=Y+qA\n-----END PGP SIGNATURE-----\n", "payload": "tree 02aade133a2cd3644765d600725e17fbcf78a36d\nparent 9ee22ff7e82a0a806de72516a6a942bad2202dca\nparent 82f2c08200dabfecf82ad7eecd3bc6ff246bda5c\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1659899422 +0200\ncommitter GitHub <noreply@github.com> 1659899422 +0200\n\nRollup merge of #100019 - TaKO8Ki:suggest-boxed-trait-objects-instead-of-impl-trait, r=compiler-errors\n\nRevive suggestions for boxed trait objects instead of impl Trait\n\nThe suggestion implemented in #75608 was not working properly, so I fixed it.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7be359e51be1d95e84937438f05a6ce05004ab5d", "html_url": "https://github.com/rust-lang/rust/commit/7be359e51be1d95e84937438f05a6ce05004ab5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7be359e51be1d95e84937438f05a6ce05004ab5d/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ee22ff7e82a0a806de72516a6a942bad2202dca", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ee22ff7e82a0a806de72516a6a942bad2202dca", "html_url": "https://github.com/rust-lang/rust/commit/9ee22ff7e82a0a806de72516a6a942bad2202dca"}, {"sha": "82f2c08200dabfecf82ad7eecd3bc6ff246bda5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/82f2c08200dabfecf82ad7eecd3bc6ff246bda5c", "html_url": "https://github.com/rust-lang/rust/commit/82f2c08200dabfecf82ad7eecd3bc6ff246bda5c"}], "stats": {"total": 246, "additions": 217, "deletions": 29}, "files": [{"sha": "2d50412007d909b493571c7d774bc4c82b729dd0", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 35, "deletions": 28, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/7be359e51be1d95e84937438f05a6ce05004ab5d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7be359e51be1d95e84937438f05a6ce05004ab5d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=7be359e51be1d95e84937438f05a6ce05004ab5d", "patch": "@@ -4,7 +4,7 @@ use rustc_errors::{Applicability, MultiSpan};\n use rustc_hir::{self as hir, ExprKind};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::traits::Obligation;\n-use rustc_middle::ty::{self, ToPredicate, Ty, TypeVisitable};\n+use rustc_middle::ty::{self, ToPredicate, Ty};\n use rustc_span::Span;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::{\n@@ -94,7 +94,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let arm_ty = self.check_expr_with_expectation(&arm.body, expected);\n             all_arms_diverge &= self.diverges.get();\n \n-            let opt_suggest_box_span = self.opt_suggest_box_span(arm_ty, orig_expected);\n+            let opt_suggest_box_span = prior_arm.and_then(|(_, prior_arm_ty, _)| {\n+                self.opt_suggest_box_span(prior_arm_ty, arm_ty, orig_expected)\n+            });\n \n             let (arm_block_id, arm_span) = if let hir::ExprKind::Block(blk, _) = arm.body.kind {\n                 (Some(blk.hir_id), self.find_block_span(blk))\n@@ -473,43 +475,48 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     // provide a structured suggestion in that case.\n     pub(crate) fn opt_suggest_box_span(\n         &self,\n-        outer_ty: Ty<'tcx>,\n+        first_ty: Ty<'tcx>,\n+        second_ty: Ty<'tcx>,\n         orig_expected: Expectation<'tcx>,\n     ) -> Option<Span> {\n         match orig_expected {\n             Expectation::ExpectHasType(expected)\n                 if self.in_tail_expr\n-                    && self.ret_coercion.as_ref()?.borrow().merged_ty().has_opaque_types()\n-                    && self.can_coerce(outer_ty, expected) =>\n+                    && self.return_type_has_opaque\n+                    && self.can_coerce(first_ty, expected)\n+                    && self.can_coerce(second_ty, expected) =>\n             {\n                 let obligations = self.fulfillment_cx.borrow().pending_obligations();\n                 let mut suggest_box = !obligations.is_empty();\n-                for o in obligations {\n-                    match o.predicate.kind().skip_binder() {\n-                        ty::PredicateKind::Trait(t) => {\n-                            let pred =\n-                                ty::Binder::dummy(ty::PredicateKind::Trait(ty::TraitPredicate {\n-                                    trait_ref: ty::TraitRef {\n-                                        def_id: t.def_id(),\n-                                        substs: self.tcx.mk_substs_trait(outer_ty, &[]),\n+                'outer: for o in obligations {\n+                    for outer_ty in &[first_ty, second_ty] {\n+                        match o.predicate.kind().skip_binder() {\n+                            ty::PredicateKind::Trait(t) => {\n+                                let pred = ty::Binder::dummy(ty::PredicateKind::Trait(\n+                                    ty::TraitPredicate {\n+                                        trait_ref: ty::TraitRef {\n+                                            def_id: t.def_id(),\n+                                            substs: self.tcx.mk_substs_trait(*outer_ty, &[]),\n+                                        },\n+                                        constness: t.constness,\n+                                        polarity: t.polarity,\n                                     },\n-                                    constness: t.constness,\n-                                    polarity: t.polarity,\n-                                }));\n-                            let obl = Obligation::new(\n-                                o.cause.clone(),\n-                                self.param_env,\n-                                pred.to_predicate(self.tcx),\n-                            );\n-                            suggest_box &= self.predicate_must_hold_modulo_regions(&obl);\n-                            if !suggest_box {\n-                                // We've encountered some obligation that didn't hold, so the\n-                                // return expression can't just be boxed. We don't need to\n-                                // evaluate the rest of the obligations.\n-                                break;\n+                                ));\n+                                let obl = Obligation::new(\n+                                    o.cause.clone(),\n+                                    self.param_env,\n+                                    pred.to_predicate(self.tcx),\n+                                );\n+                                suggest_box &= self.predicate_must_hold_modulo_regions(&obl);\n+                                if !suggest_box {\n+                                    // We've encountered some obligation that didn't hold, so the\n+                                    // return expression can't just be boxed. We don't need to\n+                                    // evaluate the rest of the obligations.\n+                                    break 'outer;\n+                                }\n                             }\n+                            _ => {}\n                         }\n-                        _ => {}\n                     }\n                 }\n                 // If all the obligations hold (or there are no obligations) the tail expression"}, {"sha": "6d61f3dbb41c5abddf7c995be344fdf6918d8013", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7be359e51be1d95e84937438f05a6ce05004ab5d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7be359e51be1d95e84937438f05a6ce05004ab5d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=7be359e51be1d95e84937438f05a6ce05004ab5d", "patch": "@@ -1002,7 +1002,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let else_ty = self.check_expr_with_expectation(else_expr, expected);\n             let else_diverges = self.diverges.get();\n \n-            let opt_suggest_box_span = self.opt_suggest_box_span(else_ty, orig_expected);\n+            let opt_suggest_box_span = self.opt_suggest_box_span(then_ty, else_ty, orig_expected);\n             let if_cause = self.if_cause(\n                 sp,\n                 cond_expr.span,"}, {"sha": "3c65fd998c5afe9a9dc780f501900c673f597317", "filename": "src/test/ui/impl-trait/point-to-type-err-cause-on-impl-trait-return.stderr", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7be359e51be1d95e84937438f05a6ce05004ab5d/src%2Ftest%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7be359e51be1d95e84937438f05a6ce05004ab5d/src%2Ftest%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr?ref=7be359e51be1d95e84937438f05a6ce05004ab5d", "patch": "@@ -52,6 +52,16 @@ LL | |         1u32\n LL | |     }\n    | |_____- `if` and `else` have incompatible types\n    |\n+help: you could change the return type to be a boxed trait object\n+   |\n+LL | fn qux() -> Box<dyn std::fmt::Display> {\n+   |             ~~~~~~~                  +\n+help: if you change the return type to expect trait objects, box the returned expressions\n+   |\n+LL ~         Box::new(0i32)\n+LL |     } else {\n+LL ~         Box::new(1u32)\n+   |\n help: change the type of the numeric literal from `u32` to `i32`\n    |\n LL |         1i32\n@@ -114,6 +124,15 @@ LL | |         _ => 2u32,\n LL | |     }\n    | |_____- `match` arms have incompatible types\n    |\n+help: you could change the return type to be a boxed trait object\n+   |\n+LL | fn dog() -> Box<dyn std::fmt::Display> {\n+   |             ~~~~~~~                  +\n+help: if you change the return type to expect trait objects, box the returned expressions\n+   |\n+LL ~         0 => Box::new(0i32),\n+LL ~         1 => Box::new(1u32),\n+   |\n help: change the type of the numeric literal from `u32` to `i32`\n    |\n LL |         1 => 1i32,\n@@ -131,6 +150,16 @@ LL | |         1u32\n LL | |     }\n    | |_____- `if` and `else` have incompatible types\n    |\n+help: you could change the return type to be a boxed trait object\n+   |\n+LL | fn apt() -> Box<dyn std::fmt::Display> {\n+   |             ~~~~~~~                  +\n+help: if you change the return type to expect trait objects, box the returned expressions\n+   |\n+LL ~         Box::new(0i32)\n+LL |     } else {\n+LL ~         Box::new(1u32)\n+   |\n help: change the type of the numeric literal from `u32` to `i32`\n    |\n LL |         1i32"}, {"sha": "d302dc99bd8aa1e47cece81fb939dd0128370e52", "filename": "src/test/ui/mismatched_types/do-not-suggest-boxed-trait-objects-instead-of-impl-trait.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7be359e51be1d95e84937438f05a6ce05004ab5d/src%2Ftest%2Fui%2Fmismatched_types%2Fdo-not-suggest-boxed-trait-objects-instead-of-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7be359e51be1d95e84937438f05a6ce05004ab5d/src%2Ftest%2Fui%2Fmismatched_types%2Fdo-not-suggest-boxed-trait-objects-instead-of-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fdo-not-suggest-boxed-trait-objects-instead-of-impl-trait.rs?ref=7be359e51be1d95e84937438f05a6ce05004ab5d", "patch": "@@ -0,0 +1,23 @@\n+struct S;\n+struct Y;\n+\n+trait Trait {}\n+\n+impl Trait for Y {}\n+\n+fn foo() -> impl Trait {\n+    if true {\n+        S\n+    } else {\n+        Y //~ ERROR `if` and `else` have incompatible types\n+    }\n+}\n+\n+fn bar() -> impl Trait {\n+    match true {\n+        true => S,\n+        false => Y, //~ ERROR `match` arms have incompatible types\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "2f814445bbadfed8f69e2b8571f0fa65801c89d8", "filename": "src/test/ui/mismatched_types/do-not-suggest-boxed-trait-objects-instead-of-impl-trait.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7be359e51be1d95e84937438f05a6ce05004ab5d/src%2Ftest%2Fui%2Fmismatched_types%2Fdo-not-suggest-boxed-trait-objects-instead-of-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7be359e51be1d95e84937438f05a6ce05004ab5d/src%2Ftest%2Fui%2Fmismatched_types%2Fdo-not-suggest-boxed-trait-objects-instead-of-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fdo-not-suggest-boxed-trait-objects-instead-of-impl-trait.stderr?ref=7be359e51be1d95e84937438f05a6ce05004ab5d", "patch": "@@ -0,0 +1,26 @@\n+error[E0308]: `if` and `else` have incompatible types\n+  --> $DIR/do-not-suggest-boxed-trait-objects-instead-of-impl-trait.rs:12:9\n+   |\n+LL | /     if true {\n+LL | |         S\n+   | |         - expected because of this\n+LL | |     } else {\n+LL | |         Y\n+   | |         ^ expected struct `S`, found struct `Y`\n+LL | |     }\n+   | |_____- `if` and `else` have incompatible types\n+\n+error[E0308]: `match` arms have incompatible types\n+  --> $DIR/do-not-suggest-boxed-trait-objects-instead-of-impl-trait.rs:19:18\n+   |\n+LL | /     match true {\n+LL | |         true => S,\n+   | |                 - this is found to be of type `S`\n+LL | |         false => Y,\n+   | |                  ^ expected struct `S`, found struct `Y`\n+LL | |     }\n+   | |_____- `match` arms have incompatible types\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "f30feaed055740e1be7e06453636558118f64eb6", "filename": "src/test/ui/mismatched_types/suggest-boxed-trait-objects-instead-of-impl-trait.fixed", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7be359e51be1d95e84937438f05a6ce05004ab5d/src%2Ftest%2Fui%2Fmismatched_types%2Fsuggest-boxed-trait-objects-instead-of-impl-trait.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7be359e51be1d95e84937438f05a6ce05004ab5d/src%2Ftest%2Fui%2Fmismatched_types%2Fsuggest-boxed-trait-objects-instead-of-impl-trait.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fsuggest-boxed-trait-objects-instead-of-impl-trait.fixed?ref=7be359e51be1d95e84937438f05a6ce05004ab5d", "patch": "@@ -0,0 +1,28 @@\n+// run-rustfix\n+\n+#![allow(dead_code)]\n+\n+struct S;\n+struct Y;\n+\n+trait Trait {}\n+\n+impl Trait for S {}\n+impl Trait for Y {}\n+\n+fn foo() -> Box<dyn Trait> {\n+    if true {\n+        Box::new(S)\n+    } else {\n+        Box::new(Y) //~ ERROR `if` and `else` have incompatible types\n+    }\n+}\n+\n+fn bar() -> Box<dyn Trait> {\n+    match true {\n+        true => Box::new(S),\n+        false => Box::new(Y), //~ ERROR `match` arms have incompatible types\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "2bd8146e289d9e448e0bac3bff3c465971ee7ef7", "filename": "src/test/ui/mismatched_types/suggest-boxed-trait-objects-instead-of-impl-trait.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7be359e51be1d95e84937438f05a6ce05004ab5d/src%2Ftest%2Fui%2Fmismatched_types%2Fsuggest-boxed-trait-objects-instead-of-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7be359e51be1d95e84937438f05a6ce05004ab5d/src%2Ftest%2Fui%2Fmismatched_types%2Fsuggest-boxed-trait-objects-instead-of-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fsuggest-boxed-trait-objects-instead-of-impl-trait.rs?ref=7be359e51be1d95e84937438f05a6ce05004ab5d", "patch": "@@ -0,0 +1,28 @@\n+// run-rustfix\n+\n+#![allow(dead_code)]\n+\n+struct S;\n+struct Y;\n+\n+trait Trait {}\n+\n+impl Trait for S {}\n+impl Trait for Y {}\n+\n+fn foo() -> impl Trait {\n+    if true {\n+        S\n+    } else {\n+        Y //~ ERROR `if` and `else` have incompatible types\n+    }\n+}\n+\n+fn bar() -> impl Trait {\n+    match true {\n+        true => S,\n+        false => Y, //~ ERROR `match` arms have incompatible types\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "f58b9c3ec16de528c6d986cd2ac8c0fb9b7acd2c", "filename": "src/test/ui/mismatched_types/suggest-boxed-trait-objects-instead-of-impl-trait.stderr", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/7be359e51be1d95e84937438f05a6ce05004ab5d/src%2Ftest%2Fui%2Fmismatched_types%2Fsuggest-boxed-trait-objects-instead-of-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7be359e51be1d95e84937438f05a6ce05004ab5d/src%2Ftest%2Fui%2Fmismatched_types%2Fsuggest-boxed-trait-objects-instead-of-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fsuggest-boxed-trait-objects-instead-of-impl-trait.stderr?ref=7be359e51be1d95e84937438f05a6ce05004ab5d", "patch": "@@ -0,0 +1,47 @@\n+error[E0308]: `if` and `else` have incompatible types\n+  --> $DIR/suggest-boxed-trait-objects-instead-of-impl-trait.rs:17:9\n+   |\n+LL | /     if true {\n+LL | |         S\n+   | |         - expected because of this\n+LL | |     } else {\n+LL | |         Y\n+   | |         ^ expected struct `S`, found struct `Y`\n+LL | |     }\n+   | |_____- `if` and `else` have incompatible types\n+   |\n+help: you could change the return type to be a boxed trait object\n+   |\n+LL | fn foo() -> Box<dyn Trait> {\n+   |             ~~~~~~~      +\n+help: if you change the return type to expect trait objects, box the returned expressions\n+   |\n+LL ~         Box::new(S)\n+LL |     } else {\n+LL ~         Box::new(Y)\n+   |\n+\n+error[E0308]: `match` arms have incompatible types\n+  --> $DIR/suggest-boxed-trait-objects-instead-of-impl-trait.rs:24:18\n+   |\n+LL | /     match true {\n+LL | |         true => S,\n+   | |                 - this is found to be of type `S`\n+LL | |         false => Y,\n+   | |                  ^ expected struct `S`, found struct `Y`\n+LL | |     }\n+   | |_____- `match` arms have incompatible types\n+   |\n+help: you could change the return type to be a boxed trait object\n+   |\n+LL | fn bar() -> Box<dyn Trait> {\n+   |             ~~~~~~~      +\n+help: if you change the return type to expect trait objects, box the returned expressions\n+   |\n+LL ~         true => Box::new(S),\n+LL ~         false => Box::new(Y),\n+   |\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}]}