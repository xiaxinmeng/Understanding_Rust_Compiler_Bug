{"sha": "7d4665b0973892c76416d9113debb677342f6ff8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkNDY2NWIwOTczODkyYzc2NDE2ZDkxMTNkZWJiNjc3MzQyZjZmZjg=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-09T14:44:06Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-09T14:44:23Z"}, "message": "check_match: unify check_irrefutable & check_exhaustive more.", "tree": {"sha": "fb73b7b2d260ff5ec865074d504907716394c92e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb73b7b2d260ff5ec865074d504907716394c92e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d4665b0973892c76416d9113debb677342f6ff8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d4665b0973892c76416d9113debb677342f6ff8", "html_url": "https://github.com/rust-lang/rust/commit/7d4665b0973892c76416d9113debb677342f6ff8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d4665b0973892c76416d9113debb677342f6ff8/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b36a206a303e02dd55996f2c709cc36f69c99ff4", "url": "https://api.github.com/repos/rust-lang/rust/commits/b36a206a303e02dd55996f2c709cc36f69c99ff4", "html_url": "https://github.com/rust-lang/rust/commit/b36a206a303e02dd55996f2c709cc36f69c99ff4"}], "stats": {"total": 230, "additions": 135, "deletions": 95}, "files": [{"sha": "a6d955f3369100e7b1a007202a5fc0dcb9923c97", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d4665b0973892c76416d9113debb677342f6ff8/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d4665b0973892c76416d9113debb677342f6ff8/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=7d4665b0973892c76416d9113debb677342f6ff8", "patch": "@@ -517,9 +517,9 @@ struct PatternContext<'tcx> {\n pub struct Witness<'tcx>(Vec<Pattern<'tcx>>);\n \n impl<'tcx> Witness<'tcx> {\n-    pub fn single_pattern(&self) -> &Pattern<'tcx> {\n+    pub fn single_pattern(self) -> Pattern<'tcx> {\n         assert_eq!(self.0.len(), 1);\n-        &self.0[0]\n+        self.0.into_iter().next().unwrap()\n     }\n \n     fn push_wild_constructor<'a>("}, {"sha": "c7eeaaf6f23da527a2d35342dd0b0f5531ffcb7a", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 51, "deletions": 43, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/7d4665b0973892c76416d9113debb677342f6ff8/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d4665b0973892c76416d9113debb677342f6ff8/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=7d4665b0973892c76416d9113debb677342f6ff8", "patch": "@@ -1,4 +1,4 @@\n-use super::_match::{MatchCheckCtxt, Matrix, Witness, expand_pattern, is_useful};\n+use super::_match::{MatchCheckCtxt, Matrix, expand_pattern, is_useful};\n use super::_match::Usefulness::*;\n use super::_match::WitnessPreference::*;\n \n@@ -276,26 +276,26 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n                 expand_pattern(cx, pattern)\n             ]].into_iter().collect();\n \n-            let witness = match check_not_useful(cx, pattern_ty, &pats) {\n+            let witnesses = match check_not_useful(cx, pattern_ty, &pats) {\n                 Ok(_) => return,\n-                Err((witness, _)) => witness,\n+                Err(err) => err,\n             };\n \n-            let pattern_string = witness[0].single_pattern().to_string();\n+            let joined_patterns = joined_uncovered_patterns(&witnesses);\n             let mut err = struct_span_err!(\n                 self.tcx.sess, pat.span, E0005,\n-                \"refutable pattern in {}: `{}` not covered\",\n-                origin, pattern_string\n+                \"refutable pattern in {}: {} not covered\",\n+                origin, joined_patterns\n             );\n-            err.span_label(pat.span, match pat.node {\n-                PatKind::Path(hir::QPath::Resolved(None, ref path))\n-                        if path.segments.len() == 1 && path.segments[0].args.is_none() => {\n+            err.span_label(pat.span, match &pat.node {\n+                PatKind::Path(hir::QPath::Resolved(None, path))\n+                    if path.segments.len() == 1 && path.segments[0].args.is_none() => {\n                     format!(\"interpreted as {} {} pattern, not new variable\",\n                             path.res.article(), path.res.descr())\n                 }\n-                _ => format!(\"pattern `{}` not covered\", pattern_string),\n+                _ => pattern_not_convered_label(&witnesses, &joined_patterns),\n             });\n-            adt_defined_here(cx, pattern_ty.peel_refs(), &mut err);\n+            adt_defined_here(cx, &mut err, pattern_ty, &witnesses);\n             err.emit();\n         });\n     }\n@@ -437,11 +437,15 @@ fn check_not_useful(\n     cx: &mut MatchCheckCtxt<'_, 'tcx>,\n     ty: Ty<'tcx>,\n     matrix: &Matrix<'_, 'tcx>,\n-) -> Result<(), (Vec<Witness<'tcx>>, Pattern<'tcx>)> {\n+) -> Result<(), Vec<Pattern<'tcx>>> {\n     let wild_pattern = Pattern { ty, span: DUMMY_SP, kind: box PatternKind::Wild };\n     match is_useful(cx, matrix, &[&wild_pattern], ConstructWitness) {\n         NotUseful => Ok(()), // This is good, wildcard pattern isn't reachable.\n-        UsefulWithWitness(pats) => Err((pats, wild_pattern)),\n+        UsefulWithWitness(pats) => Err(if pats.is_empty() {\n+            vec![wild_pattern]\n+        } else {\n+            pats.into_iter().map(|w| w.single_pattern()).collect()\n+        }),\n         Useful => bug!(),\n     }\n }\n@@ -452,42 +456,26 @@ fn check_exhaustive<'tcx>(\n     sp: Span,\n     matrix: &Matrix<'_, 'tcx>,\n ) {\n-    let (pats, wild_pattern) = match check_not_useful(cx, scrut_ty, matrix) {\n+    let witnesses = match check_not_useful(cx, scrut_ty, matrix) {\n         Ok(_) => return,\n         Err(err) => err,\n     };\n \n-    let witnesses = if pats.is_empty() {\n-        vec![&wild_pattern]\n-    } else {\n-        pats.iter().map(|w| w.single_pattern()).collect()\n-    };\n-\n     let joined_patterns = joined_uncovered_patterns(&witnesses);\n-\n-    let mut err = create_e0004(cx.tcx.sess, sp, format!(\n-        \"non-exhaustive patterns: {} not covered\",\n-        joined_patterns,\n-    ));\n-    err.span_label(sp, match witnesses.len() {\n-        1 => format!(\"pattern {} not covered\", joined_patterns),\n-        _ => format!(\"patterns {} not covered\", joined_patterns),\n-    });\n-    // point at the definition of non-covered enum variants\n-    let scrut_ty = scrut_ty.peel_refs();\n-    adt_defined_here(cx, scrut_ty, &mut err);\n-    let patterns = witnesses.iter().map(|p| (**p).clone()).collect::<Vec<Pattern<'_>>>();\n-    if patterns.len() < 4 {\n-        for sp in maybe_point_at_variant(scrut_ty, &patterns) {\n-            err.span_label(sp, \"not covered\");\n-        }\n-    }\n-    err.help(\"ensure that all possible cases are being handled, \\\n-                possibly by adding wildcards or more match arms\");\n-    err.emit();\n+    let mut err = create_e0004(\n+        cx.tcx.sess, sp,\n+        format!(\"non-exhaustive patterns: {} not covered\", joined_patterns),\n+    );\n+    err.span_label(sp, pattern_not_convered_label(&witnesses, &joined_patterns));\n+    adt_defined_here(cx, &mut err, scrut_ty, &witnesses);\n+    err.help(\n+        \"ensure that all possible cases are being handled, \\\n+        possibly by adding wildcards or more match arms\"\n+    )\n+    .emit();\n }\n \n-fn joined_uncovered_patterns(witnesses: &[&Pattern<'_>]) -> String {\n+fn joined_uncovered_patterns(witnesses: &[Pattern<'_>]) -> String {\n     const LIMIT: usize = 3;\n     match witnesses {\n         [] => bug!(),\n@@ -504,11 +492,31 @@ fn joined_uncovered_patterns(witnesses: &[&Pattern<'_>]) -> String {\n     }\n }\n \n-fn adt_defined_here(cx: &mut MatchCheckCtxt<'_, '_>, ty: Ty<'_>, err: &mut DiagnosticBuilder<'_>) {\n+fn pattern_not_convered_label(witnesses: &[Pattern<'_>], joined_patterns: &str) -> String {\n+    match witnesses.len() {\n+        1 => format!(\"pattern {} not covered\", joined_patterns),\n+        _ => format!(\"patterns {} not covered\", joined_patterns),\n+    }\n+}\n+\n+/// Point at the definition of non-covered `enum` variants.\n+fn adt_defined_here(\n+    cx: &MatchCheckCtxt<'_, '_>,\n+    err: &mut DiagnosticBuilder<'_>,\n+    ty: Ty<'_>,\n+    witnesses: &[Pattern<'_>],\n+) {\n+    let ty = ty.peel_refs();\n     if let ty::Adt(def, _) = ty.sty {\n         if let Some(sp) = cx.tcx.hir().span_if_local(def.did) {\n             err.span_label(sp, format!(\"`{}` defined here\", ty));\n         }\n+\n+        if witnesses.len() < 4 {\n+            for sp in maybe_point_at_variant(ty, &witnesses) {\n+                err.span_label(sp, \"not covered\");\n+            }\n+        }\n     }\n }\n "}, {"sha": "24d2e3ce53937775ce8b336457a0e111f2d0a2b6", "filename": "src/test/ui/consts/const-match-check.eval1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d4665b0973892c76416d9113debb677342f6ff8/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d4665b0973892c76416d9113debb677342f6ff8/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr?ref=7d4665b0973892c76416d9113debb677342f6ff8", "patch": "@@ -1,8 +1,8 @@\n-error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` not covered\n+error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n   --> $DIR/const-match-check.rs:25:15\n    |\n LL |     A = { let 0 = 0; 0 },\n-   |               ^ pattern `std::i32::MIN..=-1i32` not covered\n+   |               ^ patterns `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n \n error: aborting due to previous error\n "}, {"sha": "5d59d06f7982ae204da75e934cdc8b9249081084", "filename": "src/test/ui/consts/const-match-check.eval2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d4665b0973892c76416d9113debb677342f6ff8/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d4665b0973892c76416d9113debb677342f6ff8/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr?ref=7d4665b0973892c76416d9113debb677342f6ff8", "patch": "@@ -1,8 +1,8 @@\n-error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` not covered\n+error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n   --> $DIR/const-match-check.rs:31:24\n    |\n LL |     let x: [i32; { let 0 = 0; 0 }] = [];\n-   |                        ^ pattern `std::i32::MIN..=-1i32` not covered\n+   |                        ^ patterns `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n \n error: aborting due to previous error\n "}, {"sha": "6d74c26f9f7a54eba330d7050bcca3ed70df8f00", "filename": "src/test/ui/consts/const-match-check.matchck.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7d4665b0973892c76416d9113debb677342f6ff8/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d4665b0973892c76416d9113debb677342f6ff8/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr?ref=7d4665b0973892c76416d9113debb677342f6ff8", "patch": "@@ -1,26 +1,26 @@\n-error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` not covered\n+error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n   --> $DIR/const-match-check.rs:4:22\n    |\n LL | const X: i32 = { let 0 = 0; 0 };\n-   |                      ^ pattern `std::i32::MIN..=-1i32` not covered\n+   |                      ^ patterns `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n \n-error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` not covered\n+error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n   --> $DIR/const-match-check.rs:8:23\n    |\n LL | static Y: i32 = { let 0 = 0; 0 };\n-   |                       ^ pattern `std::i32::MIN..=-1i32` not covered\n+   |                       ^ patterns `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n \n-error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` not covered\n+error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n   --> $DIR/const-match-check.rs:13:26\n    |\n LL |     const X: i32 = { let 0 = 0; 0 };\n-   |                          ^ pattern `std::i32::MIN..=-1i32` not covered\n+   |                          ^ patterns `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n \n-error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` not covered\n+error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n   --> $DIR/const-match-check.rs:19:26\n    |\n LL |     const X: i32 = { let 0 = 0; 0 };\n-   |                          ^ pattern `std::i32::MIN..=-1i32` not covered\n+   |                          ^ patterns `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n \n error: aborting due to 4 previous errors\n "}, {"sha": "60e16aaf895329fe497d05dcf01bf54d68993269", "filename": "src/test/ui/consts/const-pattern-irrefutable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d4665b0973892c76416d9113debb677342f6ff8/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d4665b0973892c76416d9113debb677342f6ff8/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.rs?ref=7d4665b0973892c76416d9113debb677342f6ff8", "patch": "@@ -9,8 +9,8 @@ use foo::d;\n const a: u8 = 2;\n \n fn main() {\n-    let a = 4; //~ ERROR refutable pattern in local binding: `0u8..=1u8` not covered\n-    let c = 4; //~ ERROR refutable pattern in local binding: `0u8..=1u8` not covered\n-    let d = 4; //~ ERROR refutable pattern in local binding: `0u8..=1u8` not covered\n+    let a = 4; //~ ERROR refutable pattern in local binding: `0u8..=1u8` and `3u8..=std::u8::MAX\n+    let c = 4; //~ ERROR refutable pattern in local binding: `0u8..=1u8` and `3u8..=std::u8::MAX\n+    let d = 4; //~ ERROR refutable pattern in local binding: `0u8..=1u8` and `3u8..=std::u8::MAX\n     fn f() {} // Check that the `NOTE`s still work with an item here (cf. issue #35115).\n }"}, {"sha": "06f5e90d2f1f723cf26dd00249e21a900b98fc49", "filename": "src/test/ui/consts/const-pattern-irrefutable.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d4665b0973892c76416d9113debb677342f6ff8/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d4665b0973892c76416d9113debb677342f6ff8/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.stderr?ref=7d4665b0973892c76416d9113debb677342f6ff8", "patch": "@@ -1,16 +1,16 @@\n-error[E0005]: refutable pattern in local binding: `0u8..=1u8` not covered\n+error[E0005]: refutable pattern in local binding: `0u8..=1u8` and `3u8..=std::u8::MAX` not covered\n   --> $DIR/const-pattern-irrefutable.rs:12:9\n    |\n LL |     let a = 4;\n    |         ^ interpreted as a constant pattern, not new variable\n \n-error[E0005]: refutable pattern in local binding: `0u8..=1u8` not covered\n+error[E0005]: refutable pattern in local binding: `0u8..=1u8` and `3u8..=std::u8::MAX` not covered\n   --> $DIR/const-pattern-irrefutable.rs:13:9\n    |\n LL |     let c = 4;\n    |         ^ interpreted as a constant pattern, not new variable\n \n-error[E0005]: refutable pattern in local binding: `0u8..=1u8` not covered\n+error[E0005]: refutable pattern in local binding: `0u8..=1u8` and `3u8..=std::u8::MAX` not covered\n   --> $DIR/const-pattern-irrefutable.rs:14:9\n    |\n LL |     let d = 4;"}, {"sha": "7f15f02d4d37bb3e96a382d16c8b45f6dddb3335", "filename": "src/test/ui/consts/const_let_refutable.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d4665b0973892c76416d9113debb677342f6ff8/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d4665b0973892c76416d9113debb677342f6ff8/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.stderr?ref=7d4665b0973892c76416d9113debb677342f6ff8", "patch": "@@ -1,8 +1,8 @@\n-error[E0005]: refutable pattern in function argument: `&[]` not covered\n+error[E0005]: refutable pattern in function argument: `&[]`, `&[_]` and `&[_, _, _]` not covered\n   --> $DIR/const_let_refutable.rs:3:16\n    |\n LL | const fn slice([a, b]: &[i32]) -> i32 {\n-   |                ^^^^^^ pattern `&[]` not covered\n+   |                ^^^^^^ patterns `&[]`, `&[_]` and `&[_, _, _]` not covered\n \n error[E0723]: can only call other `const fn` within a `const fn`, but `const <&i32 as std::ops::Add>::add` is not stable as `const fn`\n   --> $DIR/const_let_refutable.rs:4:5"}, {"sha": "7d59d553d88fd98d2463a1ab2375d7200bc0c549", "filename": "src/test/ui/empty/empty-never-array.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7d4665b0973892c76416d9113debb677342f6ff8/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d4665b0973892c76416d9113debb677342f6ff8/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.stderr?ref=7d4665b0973892c76416d9113debb677342f6ff8", "patch": "@@ -3,6 +3,7 @@ error[E0005]: refutable pattern in local binding: `T(_, _)` not covered\n    |\n LL | / enum Helper<T, U> {\n LL | |     T(T, [!; 0]),\n+   | |     - not covered\n LL | |     #[allow(dead_code)]\n LL | |     U(U),\n LL | | }"}, {"sha": "14aea2dc27eea3d9a4036b6063a0dffbc33793c6", "filename": "src/test/ui/for/for-loop-refutable-pattern-error-message.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d4665b0973892c76416d9113debb677342f6ff8/src%2Ftest%2Fui%2Ffor%2Ffor-loop-refutable-pattern-error-message.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d4665b0973892c76416d9113debb677342f6ff8/src%2Ftest%2Fui%2Ffor%2Ffor-loop-refutable-pattern-error-message.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffor%2Ffor-loop-refutable-pattern-error-message.stderr?ref=7d4665b0973892c76416d9113debb677342f6ff8", "patch": "@@ -1,8 +1,8 @@\n-error[E0005]: refutable pattern in `for` loop binding: `&std::i32::MIN..=0i32` not covered\n+error[E0005]: refutable pattern in `for` loop binding: `&std::i32::MIN..=0i32` and `&2i32..=std::i32::MAX` not covered\n   --> $DIR/for-loop-refutable-pattern-error-message.rs:2:9\n    |\n LL |     for &1 in [1].iter() {}\n-   |         ^^ pattern `&std::i32::MIN..=0i32` not covered\n+   |         ^^ patterns `&std::i32::MIN..=0i32` and `&2i32..=std::i32::MAX` not covered\n \n error: aborting due to previous error\n "}, {"sha": "5307153cb44039682a68287c278e69b889251f02", "filename": "src/test/ui/issues/issue-15381.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d4665b0973892c76416d9113debb677342f6ff8/src%2Ftest%2Fui%2Fissues%2Fissue-15381.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d4665b0973892c76416d9113debb677342f6ff8/src%2Ftest%2Fui%2Fissues%2Fissue-15381.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-15381.rs?ref=7d4665b0973892c76416d9113debb677342f6ff8", "patch": "@@ -2,7 +2,7 @@ fn main() {\n     let values: Vec<u8> = vec![1,2,3,4,5,6,7,8];\n \n     for &[x,y,z] in values.chunks(3).filter(|&xs| xs.len() == 3) {\n-        //~^ ERROR refutable pattern in `for` loop binding: `&[]` not covered\n+        //~^ ERROR refutable pattern in `for` loop binding: `&[]`, `&[_]`, `&[_, _]` and 1 more not\n         println!(\"y={}\", y);\n         //~^ ERROR borrow of possibly-uninitialized variable: `y`\n     }"}, {"sha": "47a0d514ad8737b34c5f7fe00f7f3e8e104747d7", "filename": "src/test/ui/issues/issue-15381.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d4665b0973892c76416d9113debb677342f6ff8/src%2Ftest%2Fui%2Fissues%2Fissue-15381.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d4665b0973892c76416d9113debb677342f6ff8/src%2Ftest%2Fui%2Fissues%2Fissue-15381.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-15381.stderr?ref=7d4665b0973892c76416d9113debb677342f6ff8", "patch": "@@ -1,8 +1,8 @@\n-error[E0005]: refutable pattern in `for` loop binding: `&[]` not covered\n+error[E0005]: refutable pattern in `for` loop binding: `&[]`, `&[_]`, `&[_, _]` and 1 more not covered\n   --> $DIR/issue-15381.rs:4:9\n    |\n LL |     for &[x,y,z] in values.chunks(3).filter(|&xs| xs.len() == 3) {\n-   |         ^^^^^^^^ pattern `&[]` not covered\n+   |         ^^^^^^^^ patterns `&[]`, `&[_]`, `&[_, _]` and 1 more not covered\n \n error[E0381]: borrow of possibly-uninitialized variable: `y`\n   --> $DIR/issue-15381.rs:6:26"}, {"sha": "813b2409cc8e1748307a1596c84c88e49fce52e5", "filename": "src/test/ui/issues/issue-31561.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d4665b0973892c76416d9113debb677342f6ff8/src%2Ftest%2Fui%2Fissues%2Fissue-31561.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d4665b0973892c76416d9113debb677342f6ff8/src%2Ftest%2Fui%2Fissues%2Fissue-31561.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-31561.rs?ref=7d4665b0973892c76416d9113debb677342f6ff8", "patch": "@@ -6,5 +6,5 @@ enum Thing {\n \n fn main() {\n     let Thing::Foo(y) = Thing::Foo(1);\n-    //~^ ERROR refutable pattern in local binding: `Bar` not covered\n+    //~^ ERROR refutable pattern in local binding: `Bar` and `Baz` not covered\n }"}, {"sha": "9ec26b024bce24f9cd8e3c2c4abfcc4c810441c6", "filename": "src/test/ui/issues/issue-31561.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d4665b0973892c76416d9113debb677342f6ff8/src%2Ftest%2Fui%2Fissues%2Fissue-31561.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d4665b0973892c76416d9113debb677342f6ff8/src%2Ftest%2Fui%2Fissues%2Fissue-31561.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-31561.stderr?ref=7d4665b0973892c76416d9113debb677342f6ff8", "patch": "@@ -1,15 +1,17 @@\n-error[E0005]: refutable pattern in local binding: `Bar` not covered\n+error[E0005]: refutable pattern in local binding: `Bar` and `Baz` not covered\n   --> $DIR/issue-31561.rs:8:9\n    |\n LL | / enum Thing {\n LL | |     Foo(u8),\n LL | |     Bar,\n+   | |     --- not covered\n LL | |     Baz\n+   | |     --- not covered\n LL | | }\n    | |_- `Thing` defined here\n ...\n LL |       let Thing::Foo(y) = Thing::Foo(1);\n-   |           ^^^^^^^^^^^^^ pattern `Bar` not covered\n+   |           ^^^^^^^^^^^^^ patterns `Bar` and `Baz` not covered\n \n error: aborting due to previous error\n "}, {"sha": "6f009acbdfe1818ac9984720917a2a5146f3e0d2", "filename": "src/test/ui/match/non-exhaustive-defined-here.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7d4665b0973892c76416d9113debb677342f6ff8/src%2Ftest%2Fui%2Fmatch%2Fnon-exhaustive-defined-here.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d4665b0973892c76416d9113debb677342f6ff8/src%2Ftest%2Fui%2Fmatch%2Fnon-exhaustive-defined-here.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fnon-exhaustive-defined-here.rs?ref=7d4665b0973892c76416d9113debb677342f6ff8", "patch": "@@ -15,10 +15,16 @@ enum E {\n     //~^ not covered\n     //~| not covered\n     //~| not covered\n+    //~| not covered\n+    //~| not covered\n+    //~| not covered\n     C\n     //~^ not covered\n     //~| not covered\n     //~| not covered\n+    //~| not covered\n+    //~| not covered\n+    //~| not covered\n }\n \n fn by_val(e: E) {\n@@ -27,23 +33,24 @@ fn by_val(e: E) {\n         E::A => {}\n     }\n \n-    let E::A = e; //~ ERROR refutable pattern in local binding: `B` not covered\n+    let E::A = e; //~ ERROR refutable pattern in local binding: `B` and `C` not covered\n }\n \n fn by_ref_once(e: &E) {\n     match e { //~ ERROR non-exhaustive patterns: `&B` and `&C` not covered\n         E::A => {}\n     }\n \n-    let E::A = e; //~ ERROR refutable pattern in local binding: `&B` not covered\n+    let E::A = e; //~ ERROR refutable pattern in local binding: `&B` and `&C` not covered\n }\n \n fn by_ref_thrice(e: & &mut &E) {\n     match e { //~ ERROR non-exhaustive patterns: `&&mut &B` and `&&mut &C` not covered\n         E::A => {}\n     }\n \n-    let E::A = e; //~ ERROR refutable pattern in local binding: `&&mut &B` not covered\n+    let E::A = e;\n+    //~^ ERROR refutable pattern in local binding: `&&mut &B` and `&&mut &C` not covered\n }\n \n enum Opt {"}, {"sha": "25b8bbdab2d8e7813d8c7f480aead2dce4f913f2", "filename": "src/test/ui/match/non-exhaustive-defined-here.stderr", "status": "modified", "additions": 33, "deletions": 14, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/7d4665b0973892c76416d9113debb677342f6ff8/src%2Ftest%2Fui%2Fmatch%2Fnon-exhaustive-defined-here.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d4665b0973892c76416d9113debb677342f6ff8/src%2Ftest%2Fui%2Fmatch%2Fnon-exhaustive-defined-here.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fnon-exhaustive-defined-here.stderr?ref=7d4665b0973892c76416d9113debb677342f6ff8", "patch": "@@ -1,5 +1,5 @@\n error[E0004]: non-exhaustive patterns: `B` and `C` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:26:11\n+  --> $DIR/non-exhaustive-defined-here.rs:32:11\n    |\n LL | / enum E {\n LL | |\n@@ -21,23 +21,29 @@ LL |       match e1 {\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error[E0005]: refutable pattern in local binding: `B` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:30:9\n+error[E0005]: refutable pattern in local binding: `B` and `C` not covered\n+  --> $DIR/non-exhaustive-defined-here.rs:36:9\n    |\n LL | / enum E {\n LL | |\n LL | |\n LL | |\n ...  |\n+LL | |     B,\n+   | |     - not covered\n+...  |\n+LL | |     C\n+   | |     - not covered\n+...  |\n LL | |\n LL | | }\n    | |_- `E` defined here\n ...\n LL |       let E::A = e;\n-   |           ^^^^ pattern `B` not covered\n+   |           ^^^^ patterns `B` and `C` not covered\n \n error[E0004]: non-exhaustive patterns: `&B` and `&C` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:34:11\n+  --> $DIR/non-exhaustive-defined-here.rs:40:11\n    |\n LL | / enum E {\n LL | |\n@@ -59,23 +65,29 @@ LL |       match e {\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error[E0005]: refutable pattern in local binding: `&B` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:38:9\n+error[E0005]: refutable pattern in local binding: `&B` and `&C` not covered\n+  --> $DIR/non-exhaustive-defined-here.rs:44:9\n    |\n LL | / enum E {\n LL | |\n LL | |\n LL | |\n ...  |\n+LL | |     B,\n+   | |     - not covered\n+...  |\n+LL | |     C\n+   | |     - not covered\n+...  |\n LL | |\n LL | | }\n    | |_- `E` defined here\n ...\n LL |       let E::A = e;\n-   |           ^^^^ pattern `&B` not covered\n+   |           ^^^^ patterns `&B` and `&C` not covered\n \n error[E0004]: non-exhaustive patterns: `&&mut &B` and `&&mut &C` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:42:11\n+  --> $DIR/non-exhaustive-defined-here.rs:48:11\n    |\n LL | / enum E {\n LL | |\n@@ -97,23 +109,29 @@ LL |       match e {\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error[E0005]: refutable pattern in local binding: `&&mut &B` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:46:9\n+error[E0005]: refutable pattern in local binding: `&&mut &B` and `&&mut &C` not covered\n+  --> $DIR/non-exhaustive-defined-here.rs:52:9\n    |\n LL | / enum E {\n LL | |\n LL | |\n LL | |\n ...  |\n+LL | |     B,\n+   | |     - not covered\n+...  |\n+LL | |     C\n+   | |     - not covered\n+...  |\n LL | |\n LL | | }\n    | |_- `E` defined here\n ...\n LL |       let E::A = e;\n-   |           ^^^^ pattern `&&mut &B` not covered\n+   |           ^^^^ patterns `&&mut &B` and `&&mut &C` not covered\n \n error[E0004]: non-exhaustive patterns: `None` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:58:11\n+  --> $DIR/non-exhaustive-defined-here.rs:65:11\n    |\n LL | / enum Opt {\n LL | |\n@@ -131,13 +149,14 @@ LL |       match e {\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0005]: refutable pattern in local binding: `None` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:62:9\n+  --> $DIR/non-exhaustive-defined-here.rs:69:9\n    |\n LL | / enum Opt {\n LL | |\n LL | |\n LL | |     Some(u8),\n LL | |     None,\n+   | |     ---- not covered\n LL | |\n LL | | }\n    | |_- `Opt` defined here"}, {"sha": "8bcde1cc4dbbfdccf0bc00d58cb2a41548805376", "filename": "src/test/ui/refutable-pattern-errors.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d4665b0973892c76416d9113debb677342f6ff8/src%2Ftest%2Fui%2Frefutable-pattern-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d4665b0973892c76416d9113debb677342f6ff8/src%2Ftest%2Fui%2Frefutable-pattern-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frefutable-pattern-errors.rs?ref=7d4665b0973892c76416d9113debb677342f6ff8", "patch": "@@ -1,7 +1,9 @@\n+// ignore-line-length\n+\n fn func((1, (Some(1), 2..=3)): (isize, (Option<isize>, isize))) { }\n //~^ ERROR refutable pattern in function argument: `(_, _)` not covered\n \n fn main() {\n     let (1, (Some(1), 2..=3)) = (1, (None, 2));\n-    //~^ ERROR refutable pattern in local binding: `(std::i32::MIN..=0i32, _)` not covered\n+    //~^ ERROR refutable pattern in local binding: `(std::i32::MIN..=0i32, _)` and `(2i32..=std::i32::MAX, _)` not covered\n }"}, {"sha": "3b13e25293d58578f440e5e49323ee427c05e497", "filename": "src/test/ui/refutable-pattern-errors.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d4665b0973892c76416d9113debb677342f6ff8/src%2Ftest%2Fui%2Frefutable-pattern-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d4665b0973892c76416d9113debb677342f6ff8/src%2Ftest%2Fui%2Frefutable-pattern-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frefutable-pattern-errors.stderr?ref=7d4665b0973892c76416d9113debb677342f6ff8", "patch": "@@ -1,14 +1,14 @@\n error[E0005]: refutable pattern in function argument: `(_, _)` not covered\n-  --> $DIR/refutable-pattern-errors.rs:1:9\n+  --> $DIR/refutable-pattern-errors.rs:3:9\n    |\n LL | fn func((1, (Some(1), 2..=3)): (isize, (Option<isize>, isize))) { }\n    |         ^^^^^^^^^^^^^^^^^^^^^ pattern `(_, _)` not covered\n \n-error[E0005]: refutable pattern in local binding: `(std::i32::MIN..=0i32, _)` not covered\n-  --> $DIR/refutable-pattern-errors.rs:5:9\n+error[E0005]: refutable pattern in local binding: `(std::i32::MIN..=0i32, _)` and `(2i32..=std::i32::MAX, _)` not covered\n+  --> $DIR/refutable-pattern-errors.rs:7:9\n    |\n LL |     let (1, (Some(1), 2..=3)) = (1, (None, 2));\n-   |         ^^^^^^^^^^^^^^^^^^^^^ pattern `(std::i32::MIN..=0i32, _)` not covered\n+   |         ^^^^^^^^^^^^^^^^^^^^^ patterns `(std::i32::MIN..=0i32, _)` and `(2i32..=std::i32::MAX, _)` not covered\n \n error: aborting due to 2 previous errors\n "}, {"sha": "29ff1dc37608930ae1b13adc60009646b38616ca", "filename": "src/test/ui/uninhabited/uninhabited-irrefutable.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7d4665b0973892c76416d9113debb677342f6ff8/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d4665b0973892c76416d9113debb677342f6ff8/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr?ref=7d4665b0973892c76416d9113debb677342f6ff8", "patch": "@@ -3,6 +3,7 @@ error[E0005]: refutable pattern in local binding: `A(_)` not covered\n    |\n LL | / enum Foo {\n LL | |     A(foo::SecretlyEmpty),\n+   | |     - not covered\n LL | |     B(foo::NotSoSecretlyEmpty),\n LL | |     C(NotSoSecretlyEmpty),\n LL | |     D(u32),"}]}