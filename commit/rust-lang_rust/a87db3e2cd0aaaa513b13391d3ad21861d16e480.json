{"sha": "a87db3e2cd0aaaa513b13391d3ad21861d16e480", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4N2RiM2UyY2QwYWFhYTUxM2IxMzM5MWQzYWQyMTg2MWQxNmU0ODA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-05-03T17:08:08Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-05-10T06:46:19Z"}, "message": "rustc: Use the new `for` protocol", "tree": {"sha": "2cd1cf8eebc5276d0aa12a6d458bd3703b2e08ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2cd1cf8eebc5276d0aa12a6d458bd3703b2e08ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a87db3e2cd0aaaa513b13391d3ad21861d16e480", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a87db3e2cd0aaaa513b13391d3ad21861d16e480", "html_url": "https://github.com/rust-lang/rust/commit/a87db3e2cd0aaaa513b13391d3ad21861d16e480", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a87db3e2cd0aaaa513b13391d3ad21861d16e480/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5eb6d19803ebcb5279f8a42b584a4d81152fa82d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5eb6d19803ebcb5279f8a42b584a4d81152fa82d", "html_url": "https://github.com/rust-lang/rust/commit/5eb6d19803ebcb5279f8a42b584a4d81152fa82d"}], "stats": {"total": 647, "additions": 628, "deletions": 19}, "files": [{"sha": "2f4a0d0b2a0e3b807cc73b2f466d2b3b4b7aaef9", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a87db3e2cd0aaaa513b13391d3ad21861d16e480/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87db3e2cd0aaaa513b13391d3ad21861d16e480/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=a87db3e2cd0aaaa513b13391d3ad21861d16e480", "patch": "@@ -44,14 +44,24 @@ pub fn get_type_param_count(cstore: @mut cstore::CStore, def: ast::def_id)\n }\n \n /// Iterates over all the language items in the given crate.\n+#[cfg(stage0)]\n pub fn each_lang_item(cstore: @mut cstore::CStore,\n                       cnum: ast::crate_num,\n                       f: &fn(ast::node_id, uint) -> bool) {\n     let crate_data = cstore::get_crate_data(cstore, cnum);\n     decoder::each_lang_item(crate_data, f)\n }\n+/// Iterates over all the language items in the given crate.\n+#[cfg(not(stage0))]\n+pub fn each_lang_item(cstore: @mut cstore::CStore,\n+                      cnum: ast::crate_num,\n+                      f: &fn(ast::node_id, uint) -> bool) -> bool {\n+    let crate_data = cstore::get_crate_data(cstore, cnum);\n+    decoder::each_lang_item(crate_data, f)\n+}\n \n /// Iterates over all the paths in the given crate.\n+#[cfg(stage0)]\n pub fn each_path(cstore: @mut cstore::CStore,\n                  cnum: ast::crate_num,\n                  f: &fn(&str, decoder::def_like) -> bool) {\n@@ -61,6 +71,17 @@ pub fn each_path(cstore: @mut cstore::CStore,\n     };\n     decoder::each_path(cstore.intr, crate_data, get_crate_data, f);\n }\n+/// Iterates over all the paths in the given crate.\n+#[cfg(not(stage0))]\n+pub fn each_path(cstore: @mut cstore::CStore,\n+                 cnum: ast::crate_num,\n+                 f: &fn(&str, decoder::def_like) -> bool) -> bool {\n+    let crate_data = cstore::get_crate_data(cstore, cnum);\n+    let get_crate_data: decoder::GetCrateDataCb = |cnum| {\n+        cstore::get_crate_data(cstore, cnum)\n+    };\n+    decoder::each_path(cstore.intr, crate_data, get_crate_data, f)\n+}\n \n pub fn get_item_path(tcx: ty::ctxt, def: ast::def_id) -> ast_map::path {\n     let cstore = tcx.cstore;"}, {"sha": "c121ddafc4daa846f0196df9a3a0696f5f707bc1", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 46, "deletions": 7, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/a87db3e2cd0aaaa513b13391d3ad21861d16e480/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87db3e2cd0aaaa513b13391d3ad21861d16e480/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=a87db3e2cd0aaaa513b13391d3ad21861d16e480", "patch": "@@ -196,13 +196,23 @@ fn item_def_id(d: ebml::Doc, cdata: cmd) -> ast::def_id {\n                                                     |d| parse_def_id(d)));\n }\n \n+#[cfg(stage0)]\n fn each_reexport(d: ebml::Doc, f: &fn(ebml::Doc) -> bool) {\n     for reader::tagged_docs(d, tag_items_data_item_reexport) |reexport_doc| {\n         if !f(reexport_doc) {\n             return;\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+fn each_reexport(d: ebml::Doc, f: &fn(ebml::Doc) -> bool) -> bool {\n+    for reader::tagged_docs(d, tag_items_data_item_reexport) |reexport_doc| {\n+        if !f(reexport_doc) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n \n fn variant_disr_val(d: ebml::Doc) -> Option<int> {\n     do reader::maybe_get_doc(d, tag_disr_val).chain |val_doc| {\n@@ -454,6 +464,7 @@ fn def_like_to_def(def_like: def_like) -> ast::def {\n }\n \n /// Iterates over the language items in the given crate.\n+#[cfg(stage0)]\n pub fn each_lang_item(cdata: cmd, f: &fn(ast::node_id, uint) -> bool) {\n     let root = reader::Doc(cdata.data);\n     let lang_items = reader::get_doc(root, tag_lang_items);\n@@ -469,11 +480,29 @@ pub fn each_lang_item(cdata: cmd, f: &fn(ast::node_id, uint) -> bool) {\n         }\n     }\n }\n+/// Iterates over the language items in the given crate.\n+#[cfg(not(stage0))]\n+pub fn each_lang_item(cdata: cmd, f: &fn(ast::node_id, uint) -> bool) -> bool {\n+    let root = reader::Doc(cdata.data);\n+    let lang_items = reader::get_doc(root, tag_lang_items);\n+    for reader::tagged_docs(lang_items, tag_lang_items_item) |item_doc| {\n+        let id_doc = reader::get_doc(item_doc, tag_lang_items_item_id);\n+        let id = reader::doc_as_u32(id_doc) as uint;\n+        let node_id_doc = reader::get_doc(item_doc,\n+                                          tag_lang_items_item_node_id);\n+        let node_id = reader::doc_as_u32(node_id_doc) as ast::node_id;\n+\n+        if !f(node_id, id) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n \n /// Iterates over all the paths in the given crate.\n-pub fn each_path(intr: @ident_interner, cdata: cmd,\n-                 get_crate_data: GetCrateDataCb,\n-                 f: &fn(&str, def_like) -> bool) {\n+pub fn _each_path(intr: @ident_interner, cdata: cmd,\n+                  get_crate_data: GetCrateDataCb,\n+                  f: &fn(&str, def_like) -> bool) -> bool {\n     let root = reader::Doc(cdata.data);\n     let items = reader::get_doc(root, tag_items);\n     let items_data = reader::get_doc(items, tag_items_data);\n@@ -555,10 +584,20 @@ pub fn each_path(intr: @ident_interner, cdata: cmd,\n         }\n     }\n \n-    // If broken, stop here.\n-    if broken {\n-        return;\n-    }\n+    return broken;\n+}\n+\n+#[cfg(stage0)]\n+pub fn each_path(intr: @ident_interner, cdata: cmd,\n+                 get_crate_data: GetCrateDataCb,\n+                 f: &fn(&str, def_like) -> bool) {\n+    _each_path(intr, cdata, get_crate_data, f);\n+}\n+#[cfg(not(stage0))]\n+pub fn each_path(intr: @ident_interner, cdata: cmd,\n+                 get_crate_data: GetCrateDataCb,\n+                 f: &fn(&str, def_like) -> bool) -> bool {\n+    _each_path(intr, cdata, get_crate_data, f)\n }\n \n pub fn get_item_path(intr: @ident_interner, cdata: cmd, id: ast::node_id)"}, {"sha": "7d25d5f3ec92e982c181a24cea6eb89e0c2c857f", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a87db3e2cd0aaaa513b13391d3ad21861d16e480/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87db3e2cd0aaaa513b13391d3ad21861d16e480/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=a87db3e2cd0aaaa513b13391d3ad21861d16e480", "patch": "@@ -1391,11 +1391,10 @@ pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n     ecx.stats.total_bytes = *wr.pos;\n \n     if (tcx.sess.meta_stats()) {\n-        do wr.bytes.each |e| {\n+        for wr.bytes.each |e| {\n             if *e == 0 {\n                 ecx.stats.zero_bytes += 1;\n             }\n-            true\n         }\n \n         io::println(\"metadata stats:\");"}, {"sha": "0708b7d38d321741c6b3b9ec286de466ed2bf07d", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a87db3e2cd0aaaa513b13391d3ad21861d16e480/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87db3e2cd0aaaa513b13391d3ad21861d16e480/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=a87db3e2cd0aaaa513b13391d3ad21861d16e480", "patch": "@@ -21,7 +21,10 @@ pub fn pick_file(file: Path, path: &Path) -> Option<Path> {\n \n pub trait FileSearch {\n     fn sysroot(&self) -> @Path;\n+    #[cfg(stage0)]\n     fn for_each_lib_search_path(&self, f: &fn(&Path) -> bool);\n+    #[cfg(not(stage0))]\n+    fn for_each_lib_search_path(&self, f: &fn(&Path) -> bool) -> bool;\n     fn get_target_lib_path(&self) -> Path;\n     fn get_target_lib_file_path(&self, file: &Path) -> Path;\n }\n@@ -37,6 +40,7 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n     }\n     impl FileSearch for FileSearchImpl {\n         fn sysroot(&self) -> @Path { self.sysroot }\n+        #[cfg(stage0)]\n         fn for_each_lib_search_path(&self, f: &fn(&Path) -> bool) {\n             debug!(\"filesearch: searching additional lib search paths\");\n             // a little weird\n@@ -60,6 +64,30 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n               result::Err(_) => true\n            };\n         }\n+        #[cfg(not(stage0))]\n+        fn for_each_lib_search_path(&self, f: &fn(&Path) -> bool) -> bool {\n+            debug!(\"filesearch: searching additional lib search paths\");\n+            // a little weird\n+            self.addl_lib_search_paths.each(f);\n+\n+            debug!(\"filesearch: searching target lib path\");\n+            if !f(&make_target_lib_path(self.sysroot,\n+                                        self.target_triple)) {\n+                return false;\n+            }\n+            debug!(\"filesearch: searching rustpkg lib path nearest\");\n+            if match get_rustpkg_lib_path_nearest() {\n+                    result::Ok(ref p) => f(p),\n+                    result::Err(_) => true\n+                } {\n+                    return true;\n+                }\n+           debug!(\"filesearch: searching rustpkg lib path\");\n+           match get_rustpkg_lib_path() {\n+              result::Ok(ref p) => f(p),\n+              result::Err(_) => true\n+           }\n+        }\n         fn get_target_lib_path(&self) -> Path {\n             make_target_lib_path(self.sysroot, self.target_triple)\n         }"}, {"sha": "27f6ae33ba3d1e5bd133778c7b07b1a72fa4c9ec", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a87db3e2cd0aaaa513b13391d3ad21861d16e480/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87db3e2cd0aaaa513b13391d3ad21861d16e480/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=a87db3e2cd0aaaa513b13391d3ad21861d16e480", "patch": "@@ -67,6 +67,7 @@ enum MoveError {\n pub impl<'self> CheckLoanCtxt<'self> {\n     fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n \n+    #[cfg(stage0)]\n     fn each_issued_loan(&self,\n                         scope_id: ast::node_id,\n                         op: &fn(&Loan) -> bool)\n@@ -84,7 +85,27 @@ pub impl<'self> CheckLoanCtxt<'self> {\n             }\n         }\n     }\n+    #[cfg(not(stage0))]\n+    fn each_issued_loan(&self,\n+                        scope_id: ast::node_id,\n+                        op: &fn(&Loan) -> bool) -> bool\n+    {\n+        //! Iterates over each loan that that has been issued\n+        //! on entrance to `scope_id`, regardless of whether it is\n+        //! actually *in scope* at that point.  Sometimes loans\n+        //! are issued for future scopes and thus they may have been\n+        //! *issued* but not yet be in effect.\n+\n+        for self.dfcx.each_bit_on_entry(scope_id) |loan_index| {\n+            let loan = &self.all_loans[loan_index];\n+            if !op(loan) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n \n+    #[cfg(stage0)]\n     fn each_in_scope_loan(&self,\n                           scope_id: ast::node_id,\n                           op: &fn(&Loan) -> bool)\n@@ -101,7 +122,26 @@ pub impl<'self> CheckLoanCtxt<'self> {\n             }\n         }\n     }\n+    #[cfg(not(stage0))]\n+    fn each_in_scope_loan(&self,\n+                          scope_id: ast::node_id,\n+                          op: &fn(&Loan) -> bool) -> bool\n+    {\n+        //! Like `each_issued_loan()`, but only considers loans that are\n+        //! currently in scope.\n \n+        let region_maps = self.tcx().region_maps;\n+        for self.each_issued_loan(scope_id) |loan| {\n+            if region_maps.is_subscope_of(scope_id, loan.kill_scope) {\n+                if !op(loan) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    #[cfg(stage0)]\n     fn each_in_scope_restriction(&self,\n                                  scope_id: ast::node_id,\n                                  loan_path: @LoanPath,\n@@ -120,6 +160,26 @@ pub impl<'self> CheckLoanCtxt<'self> {\n             }\n         }\n     }\n+    #[cfg(not(stage0))]\n+    fn each_in_scope_restriction(&self,\n+                                 scope_id: ast::node_id,\n+                                 loan_path: @LoanPath,\n+                                 op: &fn(&Loan, &Restriction) -> bool) -> bool\n+    {\n+        //! Iterates through all the in-scope restrictions for the\n+        //! given `loan_path`\n+\n+        for self.each_in_scope_loan(scope_id) |loan| {\n+            for loan.restrictions.each |restr| {\n+                if restr.loan_path == loan_path {\n+                    if !op(loan, restr) {\n+                        return false;\n+                    }\n+                }\n+            }\n+        }\n+        return true;\n+    }\n \n     fn loans_generated_by(&self, scope_id: ast::node_id) -> ~[uint] {\n         //! Returns a vector of the loans that are generated as"}, {"sha": "f1fa5144f4c7530594662acd7e58754485894411", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/a87db3e2cd0aaaa513b13391d3ad21861d16e480/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87db3e2cd0aaaa513b13391d3ad21861d16e480/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=a87db3e2cd0aaaa513b13391d3ad21861d16e480", "patch": "@@ -182,6 +182,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n     }\n \n \n+    #[cfg(stage0)]\n     pub fn each_bit_on_entry(&self,\n                              id: ast::node_id,\n                              f: &fn(uint) -> bool) {\n@@ -194,7 +195,21 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n                id, bits_to_str(on_entry));\n         self.each_bit(on_entry, f);\n     }\n+    #[cfg(not(stage0))]\n+    pub fn each_bit_on_entry(&self,\n+                             id: ast::node_id,\n+                             f: &fn(uint) -> bool) -> bool {\n+        //! Iterates through each bit that is set on entry to `id`.\n+        //! Only useful after `propagate()` has been called.\n+\n+        let (start, end) = self.compute_id_range(id);\n+        let on_entry = vec::slice(self.on_entry, start, end);\n+        debug!(\"each_bit_on_entry(id=%?, on_entry=%s)\",\n+               id, bits_to_str(on_entry));\n+        self.each_bit(on_entry, f)\n+    }\n \n+    #[cfg(stage0)]\n     pub fn each_gen_bit(&self,\n                         id: ast::node_id,\n                         f: &fn(uint) -> bool) {\n@@ -206,7 +221,20 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n                id, bits_to_str(gens));\n         self.each_bit(gens, f)\n     }\n+    #[cfg(not(stage0))]\n+    pub fn each_gen_bit(&self,\n+                        id: ast::node_id,\n+                        f: &fn(uint) -> bool) -> bool {\n+        //! Iterates through each bit in the gen set for `id`.\n \n+        let (start, end) = self.compute_id_range(id);\n+        let gens = vec::slice(self.gens, start, end);\n+        debug!(\"each_gen_bit(id=%?, gens=%s)\",\n+               id, bits_to_str(gens));\n+        self.each_bit(gens, f)\n+    }\n+\n+    #[cfg(stage0)]\n     fn each_bit(&self,\n                 words: &[uint],\n                 f: &fn(uint) -> bool) {\n@@ -236,6 +264,39 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n             }\n         }\n     }\n+    #[cfg(not(stage0))]\n+    fn each_bit(&self,\n+                words: &[uint],\n+                f: &fn(uint) -> bool) -> bool {\n+        //! Helper for iterating over the bits in a bit set.\n+\n+        for words.eachi |word_index, &word| {\n+            if word != 0 {\n+                let base_index = word_index * uint::bits;\n+                for uint::range(0, uint::bits) |offset| {\n+                    let bit = 1 << offset;\n+                    if (word & bit) != 0 {\n+                        // NB: we round up the total number of bits\n+                        // that we store in any given bit set so that\n+                        // it is an even multiple of uint::bits.  This\n+                        // means that there may be some stray bits at\n+                        // the end that do not correspond to any\n+                        // actual value.  So before we callback, check\n+                        // whether the bit_index is greater than the\n+                        // actual value the user specified and stop\n+                        // iterating if so.\n+                        let bit_index = base_index + offset;\n+                        if bit_index >= self.bits_per_id {\n+                            return true;\n+                        } else if !f(bit_index) {\n+                            return false;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return true;\n+    }\n }\n \n impl<O:DataFlowOperator+Copy+'static> DataFlowContext<O> {"}, {"sha": "e2b4684696a904f266d78aae8b2288c636e67b1d", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a87db3e2cd0aaaa513b13391d3ad21861d16e480/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87db3e2cd0aaaa513b13391d3ad21861d16e480/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=a87db3e2cd0aaaa513b13391d3ad21861d16e480", "patch": "@@ -86,13 +86,18 @@ pub impl LanguageItems {\n         }\n     }\n \n+    #[cfg(stage0)]\n     fn each_item(&self, f: &fn(def_id: def_id, i: uint) -> bool) {\n         for self.items.eachi |i, &item| {\n             if !f(item.get(), i) {\n                 break;\n             }\n         }\n     }\n+    #[cfg(not(stage0))]\n+    fn each_item(&self, f: &fn(def_id: def_id, i: uint) -> bool) -> bool {\n+        self.items.eachi(|i, &item| f(item.get(), i))\n+    }\n \n     pub fn item_name(index: uint) -> &'static str {\n         match index {"}, {"sha": "e1e74f7a84766fe59f40055d657de53ff823e927", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a87db3e2cd0aaaa513b13391d3ad21861d16e480/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87db3e2cd0aaaa513b13391d3ad21861d16e480/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=a87db3e2cd0aaaa513b13391d3ad21861d16e480", "patch": "@@ -2408,14 +2408,14 @@ pub impl Resolver {\n         let merge_import_resolution = |ident,\n                                        name_bindings: @mut NameBindings| {\n             let dest_import_resolution;\n-            match module_.import_resolutions.find(ident) {\n+            match module_.import_resolutions.find(&ident) {\n                 None => {\n                     // Create a new import resolution from this child.\n                     dest_import_resolution = @mut ImportResolution(privacy,\n                                                                    span,\n                                                                    state);\n                     module_.import_resolutions.insert\n-                        (*ident, dest_import_resolution);\n+                        (ident, dest_import_resolution);\n                 }\n                 Some(&existing_import_resolution) => {\n                     dest_import_resolution = existing_import_resolution;\n@@ -2424,7 +2424,7 @@ pub impl Resolver {\n \n             debug!(\"(resolving glob import) writing resolution `%s` in `%s` \\\n                     to `%s`, privacy=%?\",\n-                   *self.session.str_of(*ident),\n+                   *self.session.str_of(ident),\n                    self.module_to_str(containing_module),\n                    self.module_to_str(module_),\n                    copy dest_import_resolution.privacy);\n@@ -2443,13 +2443,13 @@ pub impl Resolver {\n         };\n \n         // Add all children from the containing module.\n-        for containing_module.children.each |ident, name_bindings| {\n+        for containing_module.children.each |&ident, name_bindings| {\n             merge_import_resolution(ident, *name_bindings);\n         }\n \n         // Add external module children from the containing module.\n         for containing_module.external_module_children.each\n-                |ident, module| {\n+                |&ident, module| {\n             let name_bindings =\n                 @mut Resolver::create_name_bindings_from_module(*module);\n             merge_import_resolution(ident, name_bindings);"}, {"sha": "a0fe66ead042551ed71c1b640f50aaa8b5ddd1c6", "filename": "src/librustc/middle/resolve_stage0.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a87db3e2cd0aaaa513b13391d3ad21861d16e480/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87db3e2cd0aaaa513b13391d3ad21861d16e480/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs?ref=a87db3e2cd0aaaa513b13391d3ad21861d16e480", "patch": "@@ -2424,14 +2424,14 @@ pub impl Resolver {\n         let merge_import_resolution = |ident,\n                                        name_bindings: @mut NameBindings| {\n             let dest_import_resolution;\n-            match module_.import_resolutions.find(ident) {\n+            match module_.import_resolutions.find(&ident) {\n                 None => {\n                     // Create a new import resolution from this child.\n                     dest_import_resolution = @mut ImportResolution(privacy,\n                                                                    span,\n                                                                    state);\n                     module_.import_resolutions.insert\n-                        (*ident, dest_import_resolution);\n+                        (ident, dest_import_resolution);\n                 }\n                 Some(existing_import_resolution) => {\n                     dest_import_resolution = *existing_import_resolution;\n@@ -2440,7 +2440,7 @@ pub impl Resolver {\n \n             debug!(\"(resolving glob import) writing resolution `%s` in `%s` \\\n                     to `%s`, privacy=%?\",\n-                   *self.session.str_of(*ident),\n+                   *self.session.str_of(ident),\n                    self.module_to_str(containing_module),\n                    self.module_to_str(module_),\n                    copy dest_import_resolution.privacy);\n@@ -2459,13 +2459,13 @@ pub impl Resolver {\n         };\n \n         // Add all children from the containing module.\n-        for containing_module.children.each |ident, name_bindings| {\n+        for containing_module.children.each |&ident, name_bindings| {\n             merge_import_resolution(ident, *name_bindings);\n         }\n \n         // Add external module children from the containing module.\n         for containing_module.external_module_children.each\n-                |ident, module| {\n+                |&ident, module| {\n             let name_bindings =\n                 @mut Resolver::create_name_bindings_from_module(*module);\n             merge_import_resolution(ident, name_bindings);"}, {"sha": "d8db5bac24dc581ceb38e0a3eed9e3cca502b2a4", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a87db3e2cd0aaaa513b13391d3ad21861d16e480/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87db3e2cd0aaaa513b13391d3ad21861d16e480/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=a87db3e2cd0aaaa513b13391d3ad21861d16e480", "patch": "@@ -1369,6 +1369,7 @@ pub struct mono_id_ {\n \n pub type mono_id = @mono_id_;\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for mono_param_id {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n@@ -1382,18 +1383,46 @@ impl to_bytes::IterBytes for mono_param_id {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for mono_param_id {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        match *self {\n+            mono_precise(t, ref mids) =>\n+                to_bytes::iter_bytes_3(&0u8, &ty::type_id(t), mids, lsb0, f),\n+\n+            mono_any => 1u8.iter_bytes(lsb0, f),\n \n+            mono_repr(ref a, ref b, ref c, ref d) =>\n+                to_bytes::iter_bytes_5(&2u8, a, b, c, d, lsb0, f)\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl to_bytes::IterBytes for MonoDataClass {\n     fn iter_bytes(&self, lsb0: bool, f:to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for MonoDataClass {\n+    fn iter_bytes(&self, lsb0: bool, f:to_bytes::Cb) -> bool {\n+        (*self as u8).iter_bytes(lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for mono_id_ {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.def, &self.params, lsb0, f);\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for mono_id_ {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        to_bytes::iter_bytes_2(&self.def, &self.params, lsb0, f)\n+    }\n+}\n \n pub fn umax(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n     let cond = build::ICmp(cx, lib::llvm::IntULT, a, b);"}, {"sha": "374bb23f2cb578d9d84c2e04f28a864c800a2932", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a87db3e2cd0aaaa513b13391d3ad21861d16e480/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87db3e2cd0aaaa513b13391d3ad21861d16e480/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=a87db3e2cd0aaaa513b13391d3ad21861d16e480", "patch": "@@ -155,11 +155,18 @@ pub impl DatumMode {\n     }\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for DatumMode {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for DatumMode {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        (*self as uint).iter_bytes(lsb0, f)\n+    }\n+}\n \n /// See `Datum cleanup styles` section at the head of this module.\n #[deriving(Eq)]"}, {"sha": "1c2c02b21e61f1d2f53218ba9128d30227aed5a4", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 262, "deletions": 0, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/a87db3e2cd0aaaa513b13391d3ad21861d16e480/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87db3e2cd0aaaa513b13391d3ad21861d16e480/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=a87db3e2cd0aaaa513b13391d3ad21861d16e480", "patch": "@@ -121,11 +121,18 @@ pub struct creader_cache_key {\n \n type creader_cache = @mut HashMap<creader_cache_key, t>;\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for creader_cache_key {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_3(&self.cnum, &self.pos, &self.len, lsb0, f);\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for creader_cache_key {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        to_bytes::iter_bytes_3(&self.cnum, &self.pos, &self.len, lsb0, f)\n+    }\n+}\n \n struct intern_key {\n     sty: *sty,\n@@ -145,13 +152,22 @@ impl cmp::Eq for intern_key {\n     }\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for intern_key {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         unsafe {\n             (*self.sty).iter_bytes(lsb0, f);\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for intern_key {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        unsafe {\n+            (*self.sty).iter_bytes(lsb0, f)\n+        }\n+    }\n+}\n \n pub enum ast_ty_to_ty_cache_entry {\n     atttce_unresolved,  /* not resolved yet */\n@@ -382,18 +398,33 @@ pub struct FnSig {\n     output: t\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for BareFnTy {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_3(&self.purity, &self.abis, &self.sig, lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for BareFnTy {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        to_bytes::iter_bytes_3(&self.purity, &self.abis, &self.sig, lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for ClosureTy {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_5(&self.purity, &self.sigil, &self.onceness,\n                                &self.region, &self.sig, lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for ClosureTy {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        to_bytes::iter_bytes_5(&self.purity, &self.sigil, &self.onceness,\n+                               &self.region, &self.sig, lsb0, f)\n+    }\n+}\n \n #[deriving(Eq, IterBytes)]\n pub struct param_ty {\n@@ -705,6 +736,7 @@ pub enum InferTy {\n     FloatVar(FloatVid)\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for InferTy {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n@@ -714,6 +746,16 @@ impl to_bytes::IterBytes for InferTy {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for InferTy {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        match *self {\n+          TyVar(ref tv) => to_bytes::iter_bytes_2(&0u8, tv, lsb0, f),\n+          IntVar(ref iv) => to_bytes::iter_bytes_2(&1u8, iv, lsb0, f),\n+          FloatVar(ref fv) => to_bytes::iter_bytes_2(&2u8, fv, lsb0, f),\n+        }\n+    }\n+}\n \n #[auto_encode]\n #[auto_decode]\n@@ -722,6 +764,7 @@ pub enum InferRegion {\n     ReSkolemized(uint, bound_region)\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for InferRegion {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n@@ -730,6 +773,15 @@ impl to_bytes::IterBytes for InferRegion {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for InferRegion {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        match *self {\n+            ReVar(ref rv) => to_bytes::iter_bytes_2(&0u8, rv, lsb0, f),\n+            ReSkolemized(ref v, _) => to_bytes::iter_bytes_2(&1u8, v, lsb0, f)\n+        }\n+    }\n+}\n \n impl cmp::Eq for InferRegion {\n     fn eq(&self, other: &InferRegion) -> bool {\n@@ -810,29 +862,57 @@ impl ToStr for IntVarValue {\n     }\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for TyVid {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         self.to_uint().iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for TyVid {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        self.to_uint().iter_bytes(lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for IntVid {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         self.to_uint().iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for IntVid {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        self.to_uint().iter_bytes(lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for FloatVid {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         self.to_uint().iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for FloatVid {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        self.to_uint().iter_bytes(lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for RegionVid {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         self.to_uint().iter_bytes(lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for RegionVid {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        self.to_uint().iter_bytes(lsb0, f)\n+    }\n+}\n \n pub struct TypeParameterDef {\n     def_id: ast::def_id,\n@@ -2637,6 +2717,7 @@ impl cmp::TotalEq for bound_region {\n     }\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for vstore {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n@@ -2651,37 +2732,87 @@ impl to_bytes::IterBytes for vstore {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for vstore {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        match *self {\n+          vstore_fixed(ref u) =>\n+          to_bytes::iter_bytes_2(&0u8, u, lsb0, f),\n \n+          vstore_uniq => 1u8.iter_bytes(lsb0, f),\n+          vstore_box => 2u8.iter_bytes(lsb0, f),\n+\n+          vstore_slice(ref r) =>\n+          to_bytes::iter_bytes_2(&3u8, r, lsb0, f),\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl to_bytes::IterBytes for substs {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n           to_bytes::iter_bytes_3(&self.self_r,\n                                  &self.self_ty,\n                                  &self.tps, lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for substs {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+          to_bytes::iter_bytes_3(&self.self_r,\n+                                 &self.self_ty,\n+                                 &self.tps, lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for mt {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n           to_bytes::iter_bytes_2(&self.ty,\n                                  &self.mutbl, lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for mt {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+          to_bytes::iter_bytes_2(&self.ty,\n+                                 &self.mutbl, lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for field {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n           to_bytes::iter_bytes_2(&self.ident,\n                                  &self.mt, lsb0, f)\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for field {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+          to_bytes::iter_bytes_2(&self.ident,\n+                                 &self.mt, lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for FnSig {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.inputs,\n                                &self.output,\n                                lsb0, f);\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for FnSig {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        to_bytes::iter_bytes_2(&self.inputs,\n+                               &self.output,\n+                               lsb0, f)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for sty {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n@@ -2756,6 +2887,81 @@ impl to_bytes::IterBytes for sty {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for sty {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        match *self {\n+          ty_nil => 0u8.iter_bytes(lsb0, f),\n+          ty_bool => 1u8.iter_bytes(lsb0, f),\n+\n+          ty_int(ref t) =>\n+          to_bytes::iter_bytes_2(&2u8, t, lsb0, f),\n+\n+          ty_uint(ref t) =>\n+          to_bytes::iter_bytes_2(&3u8, t, lsb0, f),\n+\n+          ty_float(ref t) =>\n+          to_bytes::iter_bytes_2(&4u8, t, lsb0, f),\n+\n+          ty_estr(ref v) =>\n+          to_bytes::iter_bytes_2(&5u8, v, lsb0, f),\n+\n+          ty_enum(ref did, ref substs) =>\n+          to_bytes::iter_bytes_3(&6u8, did, substs, lsb0, f),\n+\n+          ty_box(ref mt) =>\n+          to_bytes::iter_bytes_2(&7u8, mt, lsb0, f),\n+\n+          ty_evec(ref mt, ref v) =>\n+          to_bytes::iter_bytes_3(&8u8, mt, v, lsb0, f),\n+\n+          ty_unboxed_vec(ref mt) =>\n+          to_bytes::iter_bytes_2(&9u8, mt, lsb0, f),\n+\n+          ty_tup(ref ts) =>\n+          to_bytes::iter_bytes_2(&10u8, ts, lsb0, f),\n+\n+          ty_bare_fn(ref ft) =>\n+          to_bytes::iter_bytes_2(&12u8, ft, lsb0, f),\n+\n+          ty_self(ref did) => to_bytes::iter_bytes_2(&13u8, did, lsb0, f),\n+\n+          ty_infer(ref v) =>\n+          to_bytes::iter_bytes_2(&14u8, v, lsb0, f),\n+\n+          ty_param(ref p) =>\n+          to_bytes::iter_bytes_2(&15u8, p, lsb0, f),\n+\n+          ty_type => 16u8.iter_bytes(lsb0, f),\n+          ty_bot => 17u8.iter_bytes(lsb0, f),\n+\n+          ty_ptr(ref mt) =>\n+          to_bytes::iter_bytes_2(&18u8, mt, lsb0, f),\n+\n+          ty_uniq(ref mt) =>\n+          to_bytes::iter_bytes_2(&19u8, mt, lsb0, f),\n+\n+          ty_trait(ref did, ref substs, ref v, ref mutbl) =>\n+          to_bytes::iter_bytes_5(&20u8, did, substs, v, mutbl, lsb0, f),\n+\n+          ty_opaque_closure_ptr(ref ck) =>\n+          to_bytes::iter_bytes_2(&21u8, ck, lsb0, f),\n+\n+          ty_opaque_box => 22u8.iter_bytes(lsb0, f),\n+\n+          ty_struct(ref did, ref substs) =>\n+          to_bytes::iter_bytes_3(&23u8, did, substs, lsb0, f),\n+\n+          ty_rptr(ref r, ref mt) =>\n+          to_bytes::iter_bytes_3(&24u8, r, mt, lsb0, f),\n+\n+          ty_err => 25u8.iter_bytes(lsb0, f),\n+\n+          ty_closure(ref ct) =>\n+          to_bytes::iter_bytes_2(&26u8, ct, lsb0, f),\n+        }\n+    }\n+}\n \n pub fn node_id_to_trait_ref(cx: ctxt, id: ast::node_id) -> @ty::TraitRef {\n     match cx.trait_refs.find(&id) {\n@@ -4284,6 +4490,7 @@ pub fn determine_inherited_purity(parent: (ast::purity, ast::node_id),\n // Here, the supertraits are the transitive closure of the supertrait\n // relation on the supertraits from each bounded trait's constraint\n // list.\n+#[cfg(stage0)]\n pub fn each_bound_trait_and_supertraits(tcx: ctxt,\n                                         bounds: &ParamBounds,\n                                         f: &fn(@TraitRef) -> bool) {\n@@ -4323,6 +4530,61 @@ pub fn each_bound_trait_and_supertraits(tcx: ctxt,\n         }\n     }\n }\n+// Iterate over a type parameter's bounded traits and any supertraits\n+// of those traits, ignoring kinds.\n+// Here, the supertraits are the transitive closure of the supertrait\n+// relation on the supertraits from each bounded trait's constraint\n+// list.\n+#[cfg(not(stage0))]\n+pub fn each_bound_trait_and_supertraits(tcx: ctxt,\n+                                        bounds: param_bounds,\n+                                        f: &fn(&TraitRef) -> bool) -> bool {\n+    for bounds.each |bound| {\n+        let bound_trait_ref = match *bound {\n+            ty::bound_trait(bound_t) => bound_t,\n+\n+            ty::bound_copy | ty::bound_owned |\n+            ty::bound_const | ty::bound_durable => {\n+                loop; // skip non-trait bounds\n+            }\n+        };\n+\n+        let mut supertrait_set = HashMap::new();\n+        let mut trait_refs = ~[];\n+        let mut i = 0;\n+\n+        // Seed the worklist with the trait from the bound\n+        supertrait_set.insert(bound_trait_ref.def_id, ());\n+        trait_refs.push(bound_trait_ref);\n+\n+        // Add the given trait ty to the hash map\n+        while i < trait_refs.len() {\n+            debug!(\"each_bound_trait_and_supertraits(i=%?, trait_ref=%s)\",\n+                   i, trait_refs[i].repr(tcx));\n+\n+            if !f(trait_refs[i]) {\n+                return false;\n+            }\n+\n+            // Add supertraits to supertrait_set\n+            let supertrait_refs = trait_ref_supertraits(tcx, trait_refs[i]);\n+            for supertrait_refs.each |&supertrait_ref| {\n+                debug!(\"each_bound_trait_and_supertraits(supertrait_ref=%s)\",\n+                       supertrait_ref.repr(tcx));\n+\n+                let d_id = supertrait_ref.def_id;\n+                if !supertrait_set.contains_key(&d_id) {\n+                    // FIXME(#5527) Could have same trait multiple times\n+                    supertrait_set.insert(d_id, ());\n+                    trait_refs.push(supertrait_ref);\n+                }\n+            }\n+\n+            i += 1;\n+        }\n+    }\n+    return true;\n+}\n \n pub fn count_traits_and_supertraits(tcx: ctxt,\n                                     type_param_defs: &[TypeParameterDef]) -> uint {"}, {"sha": "1c3890e2e179c4b3cd17f690eca4aecf91865455", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a87db3e2cd0aaaa513b13391d3ad21861d16e480/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87db3e2cd0aaaa513b13391d3ad21861d16e480/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=a87db3e2cd0aaaa513b13391d3ad21861d16e480", "patch": "@@ -828,13 +828,22 @@ pub impl FnCtxt {\n         }\n     }\n \n+    #[cfg(stage0)]\n     fn opt_node_ty_substs(&self, id: ast::node_id,\n                           f: &fn(&ty::substs) -> bool) {\n         match self.inh.node_type_substs.find(&id) {\n             Some(s) => { f(s); }\n             None => ()\n         }\n     }\n+    #[cfg(not(stage0))]\n+    fn opt_node_ty_substs(&self, id: ast::node_id,\n+                          f: &fn(&ty::substs) -> bool) -> bool {\n+        match self.inh.node_type_substs.find(&id) {\n+            Some(s) => f(s),\n+            None => true\n+        }\n+    }\n \n     fn mk_subty(&self,\n                 a_is_expected: bool,"}, {"sha": "260d3f440f9cfdf23ba03a283a1c5b024e3cb59d", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a87db3e2cd0aaaa513b13391d3ad21861d16e480/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87db3e2cd0aaaa513b13391d3ad21861d16e480/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=a87db3e2cd0aaaa513b13391d3ad21861d16e480", "patch": "@@ -524,6 +524,7 @@ pub impl CoherenceChecker {\n         }\n     }\n \n+    #[cfg(stage0)]\n     fn each_provided_trait_method(&self,\n             trait_did: ast::def_id,\n             f: &fn(x: @ty::method) -> bool) {\n@@ -543,6 +544,27 @@ pub impl CoherenceChecker {\n             }\n         }\n     }\n+    #[cfg(not(stage0))]\n+    fn each_provided_trait_method(&self,\n+            trait_did: ast::def_id,\n+            f: &fn(x: @ty::method) -> bool) -> bool {\n+        // Make a list of all the names of the provided methods.\n+        // XXX: This is horrible.\n+        let mut provided_method_idents = HashSet::new();\n+        let tcx = self.crate_context.tcx;\n+        for ty::provided_trait_methods(tcx, trait_did).each |ident| {\n+            provided_method_idents.insert(*ident);\n+        }\n+\n+        for ty::trait_methods(tcx, trait_did).each |&method| {\n+            if provided_method_idents.contains(&method.ident) {\n+                if !f(method) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n \n     fn polytypes_unify(&self, polytype_a: ty_param_bounds_and_ty,\n                        polytype_b: ty_param_bounds_and_ty)"}, {"sha": "73c120ad35dd3e6dbe69d9c209a27a53e1c195cc", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a87db3e2cd0aaaa513b13391d3ad21861d16e480/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87db3e2cd0aaaa513b13391d3ad21861d16e480/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=a87db3e2cd0aaaa513b13391d3ad21861d16e480", "patch": "@@ -560,6 +560,7 @@ enum Constraint {\n     ConstrainVarSubReg(RegionVid, Region)\n }\n \n+#[cfg(stage0)]\n impl to_bytes::IterBytes for Constraint {\n    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n@@ -574,6 +575,21 @@ impl to_bytes::IterBytes for Constraint {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+impl to_bytes::IterBytes for Constraint {\n+   fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+        match *self {\n+          ConstrainVarSubVar(ref v0, ref v1) =>\n+          to_bytes::iter_bytes_3(&0u8, v0, v1, lsb0, f),\n+\n+          ConstrainRegSubVar(ref ra, ref va) =>\n+          to_bytes::iter_bytes_3(&1u8, ra, va, lsb0, f),\n+\n+          ConstrainVarSubReg(ref va, ref ra) =>\n+          to_bytes::iter_bytes_3(&2u8, va, ra, lsb0, f)\n+        }\n+    }\n+}\n \n #[deriving(Eq, IterBytes)]\n struct TwoRegions {\n@@ -1756,6 +1772,7 @@ pub impl RegionVarBindings {\n         }\n     }\n \n+    #[cfg(stage0)]\n     fn each_edge(&mut self,\n                  graph: &Graph,\n                  node_idx: RegionVid,\n@@ -1771,6 +1788,23 @@ pub impl RegionVarBindings {\n             edge_idx = edge_ptr.next_edge[dir as uint];\n         }\n     }\n+    #[cfg(not(stage0))]\n+    fn each_edge(&mut self,\n+                 graph: &Graph,\n+                 node_idx: RegionVid,\n+                 dir: Direction,\n+                 op: &fn(edge: &GraphEdge) -> bool) -> bool {\n+        let mut edge_idx =\n+            graph.nodes[node_idx.to_uint()].head_edge[dir as uint];\n+        while edge_idx != uint::max_value {\n+            let edge_ptr = &graph.edges[edge_idx];\n+            if !op(edge_ptr) {\n+                return false;\n+            }\n+            edge_idx = edge_ptr.next_edge[dir as uint];\n+        }\n+        return true;\n+    }\n }\n \n fn iterate_until_fixed_point("}, {"sha": "8bf81a090cf29a3535a833541115e68c36c109e9", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a87db3e2cd0aaaa513b13391d3ad21861d16e480/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87db3e2cd0aaaa513b13391d3ad21861d16e480/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=a87db3e2cd0aaaa513b13391d3ad21861d16e480", "patch": "@@ -199,6 +199,7 @@ pub mod reader {\n         }\n     }\n \n+    #[cfg(stage0)]\n     pub fn docs(d: Doc, it: &fn(uint, Doc) -> bool) {\n         let mut pos = d.start;\n         while pos < d.end {\n@@ -211,7 +212,22 @@ pub mod reader {\n             }\n         }\n     }\n+    #[cfg(not(stage0))]\n+    pub fn docs(d: Doc, it: &fn(uint, Doc) -> bool) -> bool {\n+        let mut pos = d.start;\n+        while pos < d.end {\n+            let elt_tag = vuint_at(*d.data, pos);\n+            let elt_size = vuint_at(*d.data, elt_tag.next);\n+            pos = elt_size.next + elt_size.val;\n+            let doc = Doc { data: d.data, start: elt_size.next, end: pos };\n+            if !it(elt_tag.val, doc) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n \n+    #[cfg(stage0)]\n     pub fn tagged_docs(d: Doc, tg: uint, it: &fn(Doc) -> bool) {\n         let mut pos = d.start;\n         while pos < d.end {\n@@ -227,6 +243,23 @@ pub mod reader {\n             }\n         }\n     }\n+    #[cfg(not(stage0))]\n+    pub fn tagged_docs(d: Doc, tg: uint, it: &fn(Doc) -> bool) -> bool {\n+        let mut pos = d.start;\n+        while pos < d.end {\n+            let elt_tag = vuint_at(*d.data, pos);\n+            let elt_size = vuint_at(*d.data, elt_tag.next);\n+            pos = elt_size.next + elt_size.val;\n+            if elt_tag.val == tg {\n+                let doc = Doc { data: d.data, start: elt_size.next,\n+                                end: pos };\n+                if !it(doc) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n \n     pub fn doc_data(d: Doc) -> ~[u8] {\n         vec::slice::<u8>(*d.data, d.start, d.end).to_vec()"}]}