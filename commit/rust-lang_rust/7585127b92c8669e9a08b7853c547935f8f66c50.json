{"sha": "7585127b92c8669e9a08b7853c547935f8f66c50", "node_id": "C_kwDOAAsO6NoAKDc1ODUxMjdiOTJjODY2OWU5YTA4Yjc4NTNjNTQ3OTM1ZjhmNjZjNTA", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-01-06T11:31:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-06T11:31:19Z"}, "message": "Merge #11208\n\n11208: feat: expand attribute macros on impl and trait items r=jonas-schievink a=jonas-schievink\n\nfixes https://github.com/rust-analyzer/rust-analyzer/issues/11104\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonas.schievink@ferrous-systems.com>", "tree": {"sha": "dd2d2227767036ad1fbd007c3f382e7573d9605a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd2d2227767036ad1fbd007c3f382e7573d9605a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7585127b92c8669e9a08b7853c547935f8f66c50", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh1tMHCRBK7hj4Ov3rIwAAh9IIAK591I8KFl0VxzJyZ+GpG9TA\n3GIDiCLvaJj4Z7Av/V9icRjlcO+BCgDX9SGyz+rnxhl7LDvw00b8GMsUc+EAPR9R\nH+13LiveCQGnzewpuy8ZYZNAh+pUAqxILc6bgu6/fjutSPTqAaw7Kw6Dh6RNjRJp\nGo6+DMwlw8PrjsHIOeXLbUhDYBDdN4HYDTmCkghb+8gk95kVegUUX3IU/y3QDPUh\neQrNYbDZv3tFdse63+fpfc8Kc0qJWmPW4n6BQwTjodzAOX7cvRPNdMx25ktOba5Q\nV4VoOKveTg2Zlnh0oYKPQEvnzwz8ftNw8lU6ldkS2+Nyn0Xbz3gbW/y6o2RB6tk=\n=s7xZ\n-----END PGP SIGNATURE-----\n", "payload": "tree dd2d2227767036ad1fbd007c3f382e7573d9605a\nparent c1d3b7a91ac84eaa8c7fd10834cbecbcd93610be\nparent 3ff68f25b8f2cff8d69607bb540a180926bcbb30\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1641468679 +0000\ncommitter GitHub <noreply@github.com> 1641468679 +0000\n\nMerge #11208\n\n11208: feat: expand attribute macros on impl and trait items r=jonas-schievink a=jonas-schievink\n\nfixes https://github.com/rust-analyzer/rust-analyzer/issues/11104\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonas.schievink@ferrous-systems.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7585127b92c8669e9a08b7853c547935f8f66c50", "html_url": "https://github.com/rust-lang/rust/commit/7585127b92c8669e9a08b7853c547935f8f66c50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7585127b92c8669e9a08b7853c547935f8f66c50/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1d3b7a91ac84eaa8c7fd10834cbecbcd93610be", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1d3b7a91ac84eaa8c7fd10834cbecbcd93610be", "html_url": "https://github.com/rust-lang/rust/commit/c1d3b7a91ac84eaa8c7fd10834cbecbcd93610be"}, {"sha": "3ff68f25b8f2cff8d69607bb540a180926bcbb30", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ff68f25b8f2cff8d69607bb540a180926bcbb30", "html_url": "https://github.com/rust-lang/rust/commit/3ff68f25b8f2cff8d69607bb540a180926bcbb30"}], "stats": {"total": 364, "additions": 243, "deletions": 121}, "files": [{"sha": "505b07cc8ac92d01f52f633dee3b306221049c74", "filename": "crates/hir_def/src/body.rs", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7585127b92c8669e9a08b7853c547935f8f66c50/crates%2Fhir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7585127b92c8669e9a08b7853c547935f8f66c50/crates%2Fhir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody.rs?ref=7585127b92c8669e9a08b7853c547935f8f66c50", "patch": "@@ -12,7 +12,8 @@ use cfg::{CfgExpr, CfgOptions};\n use drop_bomb::DropBomb;\n use either::Either;\n use hir_expand::{\n-    ast_id_map::AstIdMap, hygiene::Hygiene, AstId, ExpandResult, HirFileId, InFile, MacroDefId,\n+    ast_id_map::AstIdMap, hygiene::Hygiene, AstId, ExpandError, ExpandResult, HirFileId, InFile,\n+    MacroCallId, MacroDefId,\n };\n use la_arena::{Arena, ArenaMap};\n use limit::Limit;\n@@ -124,6 +125,23 @@ impl Expander {\n             }\n         };\n \n+        Ok(self.enter_expand_inner(db, call_id, err))\n+    }\n+\n+    pub fn enter_expand_id<T: ast::AstNode>(\n+        &mut self,\n+        db: &dyn DefDatabase,\n+        call_id: MacroCallId,\n+    ) -> ExpandResult<Option<(Mark, T)>> {\n+        self.enter_expand_inner(db, call_id, None)\n+    }\n+\n+    fn enter_expand_inner<T: ast::AstNode>(\n+        &mut self,\n+        db: &dyn DefDatabase,\n+        call_id: MacroCallId,\n+        mut err: Option<ExpandError>,\n+    ) -> ExpandResult<Option<(Mark, T)>> {\n         if err.is_none() {\n             err = db.macro_expand_error(call_id);\n         }\n@@ -138,17 +156,17 @@ impl Expander {\n                     tracing::warn!(\"no error despite `parse_or_expand` failing\");\n                 }\n \n-                return Ok(ExpandResult::only_err(err.unwrap_or_else(|| {\n+                return ExpandResult::only_err(err.unwrap_or_else(|| {\n                     mbe::ExpandError::Other(\"failed to parse macro invocation\".into())\n-                })));\n+                }));\n             }\n         };\n \n         let node = match T::cast(raw_node) {\n             Some(it) => it,\n             None => {\n                 // This can happen without being an error, so only forward previous errors.\n-                return Ok(ExpandResult { value: None, err });\n+                return ExpandResult { value: None, err };\n             }\n         };\n \n@@ -164,7 +182,7 @@ impl Expander {\n         self.current_file_id = file_id;\n         self.ast_id_map = db.ast_id_map(file_id);\n \n-        Ok(ExpandResult { value: Some((mark, node)), err })\n+        ExpandResult { value: Some((mark, node)), err }\n     }\n \n     pub fn exit(&mut self, db: &dyn DefDatabase, mut mark: Mark) {"}, {"sha": "7a9e414ece5140ef64d3e7a2522eba680d8cd5cb", "filename": "crates/hir_def/src/child_by_source.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7585127b92c8669e9a08b7853c547935f8f66c50/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7585127b92c8669e9a08b7853c547935f8f66c50/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs?ref=7585127b92c8669e9a08b7853c547935f8f66c50", "patch": "@@ -30,6 +30,7 @@ pub trait ChildBySource {\n impl ChildBySource for TraitId {\n     fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap, file_id: HirFileId) {\n         let data = db.trait_data(*self);\n+        // FIXME attribute macros\n         for (_name, item) in data.items.iter() {\n             match *item {\n                 AssocItemId::FunctionId(func) => {\n@@ -61,6 +62,7 @@ impl ChildBySource for TraitId {\n impl ChildBySource for ImplId {\n     fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap, file_id: HirFileId) {\n         let data = db.impl_data(*self);\n+        // FIXME attribute macros\n         for &item in data.items.iter() {\n             match item {\n                 AssocItemId::FunctionId(func) => {"}, {"sha": "753084fb4bc783fa89c9655c60295d4668df386b", "filename": "crates/hir_def/src/data.rs", "status": "modified", "additions": 45, "deletions": 23, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/7585127b92c8669e9a08b7853c547935f8f66c50/crates%2Fhir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7585127b92c8669e9a08b7853c547935f8f66c50/crates%2Fhir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdata.rs?ref=7585127b92c8669e9a08b7853c547935f8f66c50", "patch": "@@ -2,19 +2,20 @@\n \n use std::sync::Arc;\n \n-use hir_expand::{name::Name, InFile};\n+use hir_expand::{name::Name, AstId, ExpandResult, InFile};\n use syntax::ast;\n \n use crate::{\n     attr::Attrs,\n-    body::Expander,\n+    body::{Expander, Mark},\n     db::DefDatabase,\n     intern::Interned,\n     item_tree::{self, AssocItem, FnFlags, ItemTreeId, ModItem, Param},\n+    nameres::attr_resolution::ResolvedAttr,\n     type_ref::{TraitRef, TypeBound, TypeRef},\n     visibility::RawVisibility,\n-    AssocItemId, ConstId, ConstLoc, FunctionId, FunctionLoc, HasModule, ImplId, Intern,\n-    ItemContainerId, Lookup, ModuleId, StaticId, TraitId, TypeAliasId, TypeAliasLoc,\n+    AssocItemId, AstIdWithPath, ConstId, ConstLoc, FunctionId, FunctionLoc, HasModule, ImplId,\n+    Intern, ItemContainerId, Lookup, ModuleId, StaticId, TraitId, TypeAliasId, TypeAliasLoc,\n };\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -348,14 +349,29 @@ fn collect_items(\n     let item_tree = tree_id.item_tree(db);\n     let crate_graph = db.crate_graph();\n     let cfg_options = &crate_graph[module.krate].cfg_options;\n+    let def_map = module.def_map(db);\n \n     let mut items = Vec::new();\n-    for item in assoc_items {\n+    'items: for item in assoc_items {\n         let attrs = item_tree.attrs(db, module.krate, ModItem::from(item).into());\n         if !attrs.is_cfg_enabled(cfg_options) {\n             continue;\n         }\n \n+        for attr in &*attrs {\n+            let ast_id = AstIdWithPath {\n+                path: (*attr.path).clone(),\n+                ast_id: AstId::new(expander.current_file_id(), item.ast_id(&item_tree).upcast()),\n+            };\n+            if let Ok(ResolvedAttr::Macro(call_id)) =\n+                def_map.resolve_attr_macro(db, module.local_id, ast_id, attr)\n+            {\n+                let res = expander.enter_expand_id(db, call_id);\n+                items.extend(collect_macro_items(db, module, expander, container, limit, res));\n+                continue 'items;\n+            }\n+        }\n+\n         match item {\n             AssocItem::Function(id) => {\n                 let item = &item_tree[id];\n@@ -385,28 +401,34 @@ fn collect_items(\n                 let res = expander.enter_expand(db, call);\n \n                 if let Ok(res) = res {\n-                    if let Some((mark, mac)) = res.value {\n-                        let src: InFile<ast::MacroItems> = expander.to_source(mac);\n-                        let tree_id = item_tree::TreeId::new(src.file_id, None);\n-                        let item_tree = tree_id.item_tree(db);\n-                        let iter =\n-                            item_tree.top_level_items().iter().filter_map(ModItem::as_assoc_item);\n-                        items.extend(collect_items(\n-                            db,\n-                            module,\n-                            expander,\n-                            iter,\n-                            tree_id,\n-                            container,\n-                            limit - 1,\n-                        ));\n-\n-                        expander.exit(db, mark);\n-                    }\n+                    items.extend(collect_macro_items(db, module, expander, container, limit, res));\n                 }\n             }\n         }\n     }\n \n     items\n }\n+\n+fn collect_macro_items(\n+    db: &dyn DefDatabase,\n+    module: ModuleId,\n+    expander: &mut Expander,\n+    container: ItemContainerId,\n+    limit: usize,\n+    res: ExpandResult<Option<(Mark, ast::MacroItems)>>,\n+) -> Vec<(Name, AssocItemId)> {\n+    if let Some((mark, mac)) = res.value {\n+        let src: InFile<ast::MacroItems> = expander.to_source(mac);\n+        let tree_id = item_tree::TreeId::new(src.file_id, None);\n+        let item_tree = tree_id.item_tree(db);\n+        let iter = item_tree.top_level_items().iter().filter_map(ModItem::as_assoc_item);\n+        let items = collect_items(db, module, expander, iter, tree_id, container, limit - 1);\n+\n+        expander.exit(db, mark);\n+\n+        return items;\n+    }\n+\n+    Vec::new()\n+}"}, {"sha": "c51201f6752209bd1ff887f4edbce0853f9a0c07", "filename": "crates/hir_def/src/item_tree.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7585127b92c8669e9a08b7853c547935f8f66c50/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7585127b92c8669e9a08b7853c547935f8f66c50/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs?ref=7585127b92c8669e9a08b7853c547935f8f66c50", "patch": "@@ -920,6 +920,17 @@ impl From<AssocItem> for ModItem {\n     }\n }\n \n+impl AssocItem {\n+    pub fn ast_id(self, tree: &ItemTree) -> FileAstId<ast::AssocItem> {\n+        match self {\n+            AssocItem::Function(id) => tree[id].ast_id.upcast(),\n+            AssocItem::TypeAlias(id) => tree[id].ast_id.upcast(),\n+            AssocItem::Const(id) => tree[id].ast_id.upcast(),\n+            AssocItem::MacroCall(id) => tree[id].ast_id.upcast(),\n+        }\n+    }\n+}\n+\n #[derive(Debug, Eq, PartialEq)]\n pub struct Variant {\n     pub name: Name,"}, {"sha": "730523252cf670fd28661b16f5097e44e527cd30", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7585127b92c8669e9a08b7853c547935f8f66c50/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7585127b92c8669e9a08b7853c547935f8f66c50/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=7585127b92c8669e9a08b7853c547935f8f66c50", "patch": "@@ -781,12 +781,10 @@ fn attr_macro_as_call_id(\n     macro_attr: &Attr,\n     db: &dyn db::DefDatabase,\n     krate: CrateId,\n-    def: Option<MacroDefId>,\n-) -> Result<MacroCallId, UnresolvedMacro> {\n+    def: MacroDefId,\n+) -> MacroCallId {\n     let attr_path = &item_attr.path;\n-    let def = def.ok_or_else(|| UnresolvedMacro { path: attr_path.clone() })?;\n-    let last_segment =\n-        attr_path.segments().last().ok_or_else(|| UnresolvedMacro { path: attr_path.clone() })?;\n+    let last_segment = attr_path.segments().last().expect(\"empty attribute path\");\n     let mut arg = match macro_attr.input.as_deref() {\n         Some(attr::AttrInput::TokenTree(tt, map)) => (tt.clone(), map.clone()),\n         _ => Default::default(),\n@@ -805,5 +803,5 @@ fn attr_macro_as_call_id(\n             invoc_attr_index: macro_attr.id.ast_index,\n         },\n     );\n-    Ok(res)\n+    res\n }"}, {"sha": "f793f0e002307e3dfb7405daa3a5f4e00ed15856", "filename": "crates/hir_def/src/nameres.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7585127b92c8669e9a08b7853c547935f8f66c50/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7585127b92c8669e9a08b7853c547935f8f66c50/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres.rs?ref=7585127b92c8669e9a08b7853c547935f8f66c50", "patch": "@@ -47,6 +47,7 @@\n //! path and, upon success, we run macro expansion and \"collect module\" phase on\n //! the result\n \n+pub mod attr_resolution;\n pub mod diagnostics;\n mod collector;\n mod mod_resolution;\n@@ -64,7 +65,7 @@ use la_arena::Arena;\n use profile::Count;\n use rustc_hash::FxHashMap;\n use stdx::format_to;\n-use syntax::ast;\n+use syntax::{ast, SmolStr};\n \n use crate::{\n     db::DefDatabase,\n@@ -107,6 +108,11 @@ pub struct DefMap {\n     /// (the primary purpose is to resolve derive helpers and fetch a proc-macros name)\n     exported_proc_macros: FxHashMap<MacroDefId, ProcMacroDef>,\n \n+    /// Custom attributes registered with `#![register_attr]`.\n+    registered_attrs: Vec<SmolStr>,\n+    /// Custom tool modules registered with `#![register_tool]`.\n+    registered_tools: Vec<SmolStr>,\n+\n     edition: Edition,\n     diagnostics: Vec<DefDiagnostic>,\n }\n@@ -271,6 +277,8 @@ impl DefMap {\n             prelude: None,\n             root,\n             modules,\n+            registered_attrs: Vec::new(),\n+            registered_tools: Vec::new(),\n             diagnostics: Vec::new(),\n         }\n     }\n@@ -443,6 +451,8 @@ impl DefMap {\n             extern_prelude,\n             diagnostics,\n             modules,\n+            registered_attrs,\n+            registered_tools,\n             block: _,\n             edition: _,\n             krate: _,\n@@ -454,6 +464,8 @@ impl DefMap {\n         exported_proc_macros.shrink_to_fit();\n         diagnostics.shrink_to_fit();\n         modules.shrink_to_fit();\n+        registered_attrs.shrink_to_fit();\n+        registered_tools.shrink_to_fit();\n         for (_, module) in modules.iter_mut() {\n             module.children.shrink_to_fit();\n             module.scope.shrink_to_fit();"}, {"sha": "4a7211b5c9830c3ac41e33b8ee3c5917ab998f1f", "filename": "crates/hir_def/src/nameres/attr_resolution.rs", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/7585127b92c8669e9a08b7853c547935f8f66c50/crates%2Fhir_def%2Fsrc%2Fnameres%2Fattr_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7585127b92c8669e9a08b7853c547935f8f66c50/crates%2Fhir_def%2Fsrc%2Fnameres%2Fattr_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fattr_resolution.rs?ref=7585127b92c8669e9a08b7853c547935f8f66c50", "patch": "@@ -0,0 +1,90 @@\n+//! Post-nameres attribute resolution.\n+\n+use hir_expand::MacroCallId;\n+use syntax::{ast, SmolStr};\n+\n+use crate::{\n+    attr::Attr,\n+    attr_macro_as_call_id, builtin_attr,\n+    db::DefDatabase,\n+    item_scope::BuiltinShadowMode,\n+    nameres::path_resolution::ResolveMode,\n+    path::{ModPath, PathKind},\n+    AstIdWithPath, LocalModuleId, UnresolvedMacro,\n+};\n+\n+use super::DefMap;\n+\n+pub enum ResolvedAttr {\n+    /// Attribute resolved to an attribute macro.\n+    Macro(MacroCallId),\n+    /// Attribute resolved to something else that does not require expansion.\n+    Other,\n+}\n+\n+impl DefMap {\n+    pub(crate) fn resolve_attr_macro(\n+        &self,\n+        db: &dyn DefDatabase,\n+        original_module: LocalModuleId,\n+        ast_id: AstIdWithPath<ast::Item>,\n+        attr: &Attr,\n+    ) -> Result<ResolvedAttr, UnresolvedMacro> {\n+        // NB: does not currently work for derive helpers as they aren't recorded in the `DefMap`\n+\n+        if self.is_builtin_or_registered_attr(&ast_id.path) {\n+            return Ok(ResolvedAttr::Other);\n+        }\n+\n+        let resolved_res = self.resolve_path_fp_with_macro(\n+            db,\n+            ResolveMode::Other,\n+            original_module,\n+            &ast_id.path,\n+            BuiltinShadowMode::Module,\n+        );\n+        let def = match resolved_res.resolved_def.take_macros() {\n+            Some(def) => {\n+                if def.is_attribute() {\n+                    def\n+                } else {\n+                    return Ok(ResolvedAttr::Other);\n+                }\n+            }\n+            None => return Err(UnresolvedMacro { path: ast_id.path.clone() }),\n+        };\n+\n+        Ok(ResolvedAttr::Macro(attr_macro_as_call_id(&ast_id, attr, db, self.krate, def)))\n+    }\n+\n+    pub(crate) fn is_builtin_or_registered_attr(&self, path: &ModPath) -> bool {\n+        if path.kind != PathKind::Plain {\n+            return false;\n+        }\n+\n+        let segments = path.segments();\n+\n+        if let Some(name) = segments.first() {\n+            let name = name.to_smol_str();\n+            let pred = |n: &_| *n == name;\n+\n+            let registered = self.registered_tools.iter().map(SmolStr::as_str);\n+            let is_tool = builtin_attr::TOOL_MODULES.iter().copied().chain(registered).any(pred);\n+            // FIXME: tool modules can be shadowed by actual modules\n+            if is_tool {\n+                return true;\n+            }\n+\n+            if segments.len() == 1 {\n+                let registered = self.registered_attrs.iter().map(SmolStr::as_str);\n+                let is_inert = builtin_attr::INERT_ATTRIBUTES\n+                    .iter()\n+                    .map(|it| it.name)\n+                    .chain(registered)\n+                    .any(pred);\n+                return is_inert;\n+            }\n+        }\n+        false\n+    }\n+}"}, {"sha": "e8246d4fb9a975438dfbab184ad010739541c1f8", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 44, "deletions": 86, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/7585127b92c8669e9a08b7853c547935f8f66c50/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7585127b92c8669e9a08b7853c547935f8f66c50/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=7585127b92c8669e9a08b7853c547935f8f66c50", "patch": "@@ -20,11 +20,11 @@ use itertools::Itertools;\n use la_arena::Idx;\n use limit::Limit;\n use rustc_hash::{FxHashMap, FxHashSet};\n-use syntax::{ast, SmolStr};\n+use syntax::ast;\n \n use crate::{\n     attr::{Attr, AttrId, AttrInput, Attrs},\n-    attr_macro_as_call_id, builtin_attr,\n+    attr_macro_as_call_id,\n     db::DefDatabase,\n     derive_macro_as_call_id,\n     intern::Interned,\n@@ -97,8 +97,6 @@ pub(super) fn collect_defs(db: &dyn DefDatabase, mut def_map: DefMap, tree_id: T\n         from_glob_import: Default::default(),\n         skip_attrs: Default::default(),\n         derive_helpers_in_scope: Default::default(),\n-        registered_attrs: Default::default(),\n-        registered_tools: Default::default(),\n     };\n     if tree_id.is_block() {\n         collector.seed_with_inner(tree_id);\n@@ -251,10 +249,6 @@ struct DefCollector<'a> {\n     /// Tracks which custom derives are in scope for an item, to allow resolution of derive helper\n     /// attributes.\n     derive_helpers_in_scope: FxHashMap<AstId<ast::Item>, Vec<Name>>,\n-    /// Custom attributes registered with `#![register_attr]`.\n-    registered_attrs: Vec<SmolStr>,\n-    /// Custom tool modules registered with `#![register_tool]`.\n-    registered_tools: Vec<SmolStr>,\n }\n \n impl DefCollector<'_> {\n@@ -291,10 +285,10 @@ impl DefCollector<'_> {\n                 };\n \n                 if *attr_name == hir_expand::name![register_attr] {\n-                    self.registered_attrs.push(registered_name.to_smol_str());\n+                    self.def_map.registered_attrs.push(registered_name.to_smol_str());\n                     cov_mark::hit!(register_attr);\n                 } else {\n-                    self.registered_tools.push(registered_name.to_smol_str());\n+                    self.def_map.registered_tools.push(registered_name.to_smol_str());\n                     cov_mark::hit!(register_tool);\n                 }\n             }\n@@ -1124,10 +1118,13 @@ impl DefCollector<'_> {\n                         }\n                     }\n \n-                    let def = resolver(path.clone()).filter(MacroDefId::is_attribute);\n+                    let def = match resolver(path.clone()) {\n+                        Some(def) if def.is_attribute() => def,\n+                        _ => return true,\n+                    };\n                     if matches!(\n                         def,\n-                        Some(MacroDefId {  kind:MacroDefKind::BuiltInAttr(expander, _),.. })\n+                        MacroDefId {  kind:MacroDefKind::BuiltInAttr(expander, _),.. }\n                         if expander.is_derive()\n                     ) {\n                         // Resolved to `#[derive]`\n@@ -1184,52 +1181,46 @@ impl DefCollector<'_> {\n                         return true;\n                     }\n \n-                    // Not resolved to a derive helper or the derive attribute, so try to resolve as a normal attribute.\n-                    match attr_macro_as_call_id(file_ast_id, attr, self.db, self.def_map.krate, def)\n-                    {\n-                        Ok(call_id) => {\n-                            let loc: MacroCallLoc = self.db.lookup_intern_macro_call(call_id);\n-\n-                            // Skip #[test]/#[bench] expansion, which would merely result in more memory usage\n-                            // due to duplicating functions into macro expansions\n-                            if matches!(\n-                                loc.def.kind,\n-                                MacroDefKind::BuiltInAttr(expander, _)\n-                                if expander.is_test() || expander.is_bench()\n-                            ) {\n-                                return recollect_without(self);\n-                            }\n+                    // Not resolved to a derive helper or the derive attribute, so try to treat as a normal attribute.\n+                    let call_id =\n+                        attr_macro_as_call_id(file_ast_id, attr, self.db, self.def_map.krate, def);\n+                    let loc: MacroCallLoc = self.db.lookup_intern_macro_call(call_id);\n \n-                            if let MacroDefKind::ProcMacro(exp, ..) = loc.def.kind {\n-                                if exp.is_dummy() {\n-                                    // Proc macros that cannot be expanded are treated as not\n-                                    // resolved, in order to fall back later.\n-                                    self.def_map.diagnostics.push(\n-                                        DefDiagnostic::unresolved_proc_macro(\n-                                            directive.module_id,\n-                                            loc.kind,\n-                                        ),\n-                                    );\n-\n-                                    return recollect_without(self);\n-                                }\n-                            }\n-\n-                            self.def_map.modules[directive.module_id]\n-                                .scope\n-                                .add_attr_macro_invoc(ast_id, call_id);\n+                    // Skip #[test]/#[bench] expansion, which would merely result in more memory usage\n+                    // due to duplicating functions into macro expansions\n+                    if matches!(\n+                        loc.def.kind,\n+                        MacroDefKind::BuiltInAttr(expander, _)\n+                        if expander.is_test() || expander.is_bench()\n+                    ) {\n+                        return recollect_without(self);\n+                    }\n \n-                            resolved.push((\n+                    if let MacroDefKind::ProcMacro(exp, ..) = loc.def.kind {\n+                        if exp.is_dummy() {\n+                            // Proc macros that cannot be expanded are treated as not\n+                            // resolved, in order to fall back later.\n+                            self.def_map.diagnostics.push(DefDiagnostic::unresolved_proc_macro(\n                                 directive.module_id,\n-                                call_id,\n-                                directive.depth,\n-                                directive.container,\n+                                loc.kind,\n                             ));\n-                            res = ReachedFixedPoint::No;\n-                            return false;\n+\n+                            return recollect_without(self);\n                         }\n-                        Err(UnresolvedMacro { .. }) => (),\n                     }\n+\n+                    self.def_map.modules[directive.module_id]\n+                        .scope\n+                        .add_attr_macro_invoc(ast_id, call_id);\n+\n+                    resolved.push((\n+                        directive.module_id,\n+                        call_id,\n+                        directive.depth,\n+                        directive.container,\n+                    ));\n+                    res = ReachedFixedPoint::No;\n+                    return false;\n                 }\n             }\n \n@@ -1794,7 +1785,7 @@ impl ModCollector<'_, '_> {\n             });\n \n         for attr in iter {\n-            if self.is_builtin_or_registered_attr(&attr.path) {\n+            if self.def_collector.def_map.is_builtin_or_registered_attr(&attr.path) {\n                 continue;\n             }\n             tracing::debug!(\"non-builtin attribute {}\", attr.path);\n@@ -1822,37 +1813,6 @@ impl ModCollector<'_, '_> {\n         Ok(())\n     }\n \n-    fn is_builtin_or_registered_attr(&self, path: &ModPath) -> bool {\n-        if path.kind != PathKind::Plain {\n-            return false;\n-        }\n-\n-        let segments = path.segments();\n-\n-        if let Some(name) = segments.first() {\n-            let name = name.to_smol_str();\n-            let pred = |n: &_| *n == name;\n-\n-            let registered = self.def_collector.registered_tools.iter().map(SmolStr::as_str);\n-            let is_tool = builtin_attr::TOOL_MODULES.iter().copied().chain(registered).any(pred);\n-            // FIXME: tool modules can be shadowed by actual modules\n-            if is_tool {\n-                return true;\n-            }\n-\n-            if segments.len() == 1 {\n-                let registered = self.def_collector.registered_attrs.iter().map(SmolStr::as_str);\n-                let is_inert = builtin_attr::INERT_ATTRIBUTES\n-                    .iter()\n-                    .map(|it| it.name)\n-                    .chain(registered)\n-                    .any(pred);\n-                return is_inert;\n-            }\n-        }\n-        false\n-    }\n-\n     /// If `attrs` registers a procedural macro, collects its definition.\n     fn collect_proc_macro_def(&mut self, func_name: &Name, ast_id: AstId<ast::Fn>, attrs: &Attrs) {\n         // FIXME: this should only be done in the root module of `proc-macro` crates, not everywhere\n@@ -2104,8 +2064,6 @@ mod tests {\n             from_glob_import: Default::default(),\n             skip_attrs: Default::default(),\n             derive_helpers_in_scope: Default::default(),\n-            registered_attrs: Default::default(),\n-            registered_tools: Default::default(),\n         };\n         collector.seed_with_top_level();\n         collector.collect();"}, {"sha": "749581b1ce9b250d82de9a1c07885a870b15c253", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7585127b92c8669e9a08b7853c547935f8f66c50/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7585127b92c8669e9a08b7853c547935f8f66c50/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=7585127b92c8669e9a08b7853c547935f8f66c50", "patch": "@@ -108,6 +108,17 @@ impl HasName for Macro {\n \n impl HasAttrs for Macro {}\n \n+impl From<ast::AssocItem> for ast::Item {\n+    fn from(assoc: ast::AssocItem) -> Self {\n+        match assoc {\n+            ast::AssocItem::Const(it) => ast::Item::Const(it),\n+            ast::AssocItem::Fn(it) => ast::Item::Fn(it),\n+            ast::AssocItem::MacroCall(it) => ast::Item::MacroCall(it),\n+            ast::AssocItem::TypeAlias(it) => ast::Item::TypeAlias(it),\n+        }\n+    }\n+}\n+\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum AttrKind {\n     Inner,"}]}