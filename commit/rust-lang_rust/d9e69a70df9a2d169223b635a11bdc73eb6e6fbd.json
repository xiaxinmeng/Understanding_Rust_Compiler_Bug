{"sha": "d9e69a70df9a2d169223b635a11bdc73eb6e6fbd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5ZTY5YTcwZGY5YTJkMTY5MjIzYjYzNWExMWJkYzczZWI2ZTZmYmQ=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-03-09T09:58:31Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-03-30T07:46:04Z"}, "message": "Fix fallout", "tree": {"sha": "495f8249db72c9a0ee9d65151cae94b02187f4f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/495f8249db72c9a0ee9d65151cae94b02187f4f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAljct7wACgkQpp+NIls6\n19kSvw//dX5PPkc1D4SInQd+tFZTwkWDOmI4uOm+tu79QZy1Gszi6sc31xoMeJHT\n/OkljqErNcls0pI6PspaKLCUI71nspTr3ql0YH/4YX7keDexkce67rLof+lJV6W6\nWe23S/Sx9SXVRnn9piq10Gj2k8XCv1/caE/K5wQXzFTRU90KvQgem1eUOA2ji/X+\nE3U9oPX1WdsCPskTyJHC2gZCue8w0AjxOykkAaXEz8HIRpmjGy4feN01T5d67arl\nLT1/f5gOqGpcFrezvU0lAyxClW8WICy7FoesIqk+yPmA+OGbyqpmG7qQLeXcZxug\nrLY3MRnjw+7sAPZhOPFaq13ZiIGZDjrMb6m+SfXXXsupm//q8bseh4ni1F3Gg/IK\n8+ckdo5ZmCa3vxFDlLC6h1Z5mOBLd8T/12hUzSW+8/AeZNhdC9gfImSVF1udMMKb\nVaqQa2OQ4j8zDGnMAll4UH94TPSdcr/sD76L90fewweDUloxL7pSQHEF9GpzFKph\nOYilmrZT4B0vB1oENct8h4HT8ZRHFI0wJFnLFys+9zOcEc2WL03eH51ViG6l9ZdU\nZgvn6HaRC+YvPZXMJErHeSu2LEEs3a2NvpAeF0VmkX2NI+dL6cMKvaZ9Gaa+Bmtl\nqkrG4bD14Jn/MAR1RMIt1VJKh0tJp4FCNA0623tj+uAk7pbCJI0=\n=UIKd\n-----END PGP SIGNATURE-----", "payload": "tree 495f8249db72c9a0ee9d65151cae94b02187f4f7\nparent 5de367f793c30072749681b85cb453ea8c2418eb\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1489053511 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1490859964 +0200\n\nFix fallout\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd", "html_url": "https://github.com/rust-lang/rust/commit/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5de367f793c30072749681b85cb453ea8c2418eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/5de367f793c30072749681b85cb453ea8c2418eb", "html_url": "https://github.com/rust-lang/rust/commit/5de367f793c30072749681b85cb453ea8c2418eb"}], "stats": {"total": 84, "additions": 42, "deletions": 42}, "files": [{"sha": "6b0af9849e85be18c9c02fd5fc91d8ccae6566f0", "filename": "clippy_lints/src/blacklisted_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblacklisted_name.rs?ref=d9e69a70df9a2d169223b635a11bdc73eb6e6fbd", "patch": "@@ -40,7 +40,7 @@ impl LintPass for BlackListedName {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlackListedName {\n     fn check_pat(&mut self, cx: &LateContext<'a, 'tcx>, pat: &'tcx Pat) {\n         if let PatKind::Binding(_, _, ref ident, _) = pat.node {\n-            if self.blacklist.iter().any(|s| s == &*ident.node.as_str()) {\n+            if self.blacklist.iter().any(|s| *s == *ident.node.as_str()) {\n                 span_lint(cx,\n                           BLACKLISTED_NAME,\n                           pat.span,"}, {"sha": "ea7242cdb89eb5f1d40fdd51d95aecec488e456f", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=d9e69a70df9a2d169223b635a11bdc73eb6e6fbd", "patch": "@@ -85,7 +85,7 @@ fn check_cond<'a, 'tcx, 'b>(\n     if_let_chain! {[\n         let ExprMethodCall(ref name, _, ref params) = check.node,\n         params.len() >= 2,\n-        &*name.node.as_str() == \"contains_key\",\n+        name.node.as_str() == \"contains_key\",\n         let ExprAddrOf(_, ref key) = params[1].node\n     ], {\n         let map = &params[0];\n@@ -119,7 +119,7 @@ impl<'a, 'tcx, 'b> Visitor<'tcx> for InsertVisitor<'a, 'tcx, 'b> {\n         if_let_chain! {[\n             let ExprMethodCall(ref name, _, ref params) = expr.node,\n             params.len() == 3,\n-            &*name.node.as_str() == \"insert\",\n+            name.node.as_str() == \"insert\",\n             get_item_name(self.cx, self.map) == get_item_name(self.cx, &params[0]),\n             SpanlessEq::new(self.cx).eq_expr(self.key, &params[1])\n         ], {"}, {"sha": "d0c75125df07f61567a0fea2ccecc02039d2cb95", "filename": "clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/clippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/clippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_variants.rs?ref=d9e69a70df9a2d169223b635a11bdc73eb6e6fbd", "patch": "@@ -232,7 +232,7 @@ impl EarlyLintPass for EnumVariantNames {\n             if let Some(&(ref mod_name, ref mod_camel)) = self.modules.last() {\n                 // constants don't have surrounding modules\n                 if !mod_camel.is_empty() {\n-                    if mod_name == &item_name {\n+                    if *mod_name == item_name {\n                         if let ItemKind::Mod(..) = item.node {\n                             span_lint(cx,\n                                       MODULE_INCEPTION,"}, {"sha": "4ed935682187b70da66b952be08b786baceab39c", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=d9e69a70df9a2d169223b635a11bdc73eb6e6fbd", "patch": "@@ -79,7 +79,7 @@ pub fn get_argument_fmtstr_parts<'a, 'b>(cx: &LateContext<'a, 'b>, expr: &'a Exp\n         let StmtDecl(ref decl, _) = block.stmts[0].node,\n         let DeclItem(ref decl) = decl.node,\n         let Some(NodeItem(decl)) = cx.tcx.hir.find(decl.id),\n-        &*decl.name.as_str() == \"__STATIC_FMTSTR\",\n+        decl.name.as_str() == \"__STATIC_FMTSTR\",\n         let ItemStatic(_, _, ref expr) = decl.node,\n         let ExprAddrOf(_, ref expr) = cx.tcx.hir.body(*expr).value.node, // &[\"\u2026\", \"\u2026\", \u2026]\n         let ExprArray(ref exprs) = expr.node,"}, {"sha": "13a8197058f2eb07fd4db7e006ba43b1ea7e311d", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=d9e69a70df9a2d169223b635a11bdc73eb6e6fbd", "patch": "@@ -89,7 +89,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LenZero {\n \n fn check_trait_items(cx: &LateContext, item: &Item, trait_items: &[TraitItemRef]) {\n     fn is_named_self(cx: &LateContext, item: &TraitItemRef, name: &str) -> bool {\n-        &*item.name.as_str() == name &&\n+        *item.name.as_str() == *name &&\n         if let AssociatedItemKind::Method { has_self } = item.kind {\n             has_self &&\n             {\n@@ -116,7 +116,7 @@ fn check_trait_items(cx: &LateContext, item: &Item, trait_items: &[TraitItemRef]\n \n fn check_impl_items(cx: &LateContext, item: &Item, impl_items: &[ImplItemRef]) {\n     fn is_named_self(cx: &LateContext, item: &ImplItemRef, name: &str) -> bool {\n-        &*item.name.as_str() == name &&\n+        *item.name.as_str() == *name &&\n         if let AssociatedItemKind::Method { has_self } = item.kind {\n             has_self &&\n             {\n@@ -155,7 +155,7 @@ fn check_impl_items(cx: &LateContext, item: &Item, impl_items: &[ImplItemRef]) {\n fn check_cmp(cx: &LateContext, span: Span, left: &Expr, right: &Expr, op: &str) {\n     // check if we are in an is_empty() method\n     if let Some(name) = get_item_name(cx, left) {\n-        if &*name.as_str() == \"is_empty\" {\n+        if name.as_str() == \"is_empty\" {\n             return;\n         }\n     }\n@@ -170,7 +170,7 @@ fn check_cmp(cx: &LateContext, span: Span, left: &Expr, right: &Expr, op: &str)\n \n fn check_len_zero(cx: &LateContext, span: Span, name: &Name, args: &[Expr], lit: &Lit, op: &str) {\n     if let Spanned { node: LitKind::Int(0, _), .. } = *lit {\n-        if &*name.as_str() == \"len\" && args.len() == 1 && has_is_empty(cx, &args[0]) {\n+        if name.as_str() == \"len\" && args.len() == 1 && has_is_empty(cx, &args[0]) {\n             span_lint_and_then(cx, LEN_ZERO, span, \"length comparison to zero\", |db| {\n                 db.span_suggestion(span,\n                                    \"consider using `is_empty`\",\n@@ -185,7 +185,7 @@ fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n     /// Get an `AssociatedItem` and return true if it matches `is_empty(self)`.\n     fn is_is_empty(cx: &LateContext, item: &ty::AssociatedItem) -> bool {\n         if let ty::AssociatedKind::Method = item.kind {\n-            if &*item.name.as_str() == \"is_empty\" {\n+            if item.name.as_str() == \"is_empty\" {\n                 let sig = cx.tcx.item_type(item.def_id).fn_sig();\n                 let ty = sig.skip_binder();\n                 ty.inputs().len() == 1"}, {"sha": "921d30fc9d6a8b8470205343cd7071206ebaf346", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=d9e69a70df9a2d169223b635a11bdc73eb6e6fbd", "patch": "@@ -199,7 +199,7 @@ fn allowed_lts_from(named_lts: &[LifetimeDef]) -> HashSet<RefLt> {\n \n fn lts_from_bounds<'a, T: Iterator<Item = &'a Lifetime>>(mut vec: Vec<RefLt>, bounds_lts: T) -> Vec<RefLt> {\n     for lt in bounds_lts {\n-        if &*lt.name.as_str() != \"'static\" {\n+        if lt.name.as_str() != \"'static\" {\n             vec.push(RefLt::Named(lt.name));\n         }\n     }\n@@ -228,7 +228,7 @@ impl<'v, 't> RefVisitor<'v, 't> {\n \n     fn record(&mut self, lifetime: &Option<Lifetime>) {\n         if let Some(ref lt) = *lifetime {\n-            if &*lt.name.as_str() == \"'static\" {\n+            if lt.name.as_str() == \"'static\" {\n                 self.lts.push(RefLt::Static);\n             } else if lt.is_elided() {\n                 self.lts.push(RefLt::Unnamed);"}, {"sha": "08b5a9d262ce892921ececfc408603303daf966b", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=d9e69a70df9a2d169223b635a11bdc73eb6e6fbd", "patch": "@@ -389,8 +389,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     &ExprMethodCall(method_name, _, ref method_args)) = (pat, &match_expr.node) {\n                 let iter_expr = &method_args[0];\n                 let lhs_constructor = last_path_segment(qpath);\n-                if &*method_name.node.as_str() == \"next\" && match_trait_method(cx, match_expr, &paths::ITERATOR) &&\n-                   &*lhs_constructor.name.as_str() == \"Some\" && !is_refutable(cx, &pat_args[0]) &&\n+                if method_name.node.as_str() == \"next\" && match_trait_method(cx, match_expr, &paths::ITERATOR) &&\n+                   lhs_constructor.name.as_str() == \"Some\" && !is_refutable(cx, &pat_args[0]) &&\n                    !is_iterator_used_after_while_let(cx, iter_expr) {\n                     let iterator = snippet(cx, method_args[0].span, \"_\");\n                     let loop_var = snippet(cx, pat_args[0].span, \"_\");\n@@ -409,7 +409,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n         if let StmtSemi(ref expr, _) = stmt.node {\n             if let ExprMethodCall(ref method, _, ref args) = expr.node {\n-                if args.len() == 1 && &*method.node.as_str() == \"collect\" &&\n+                if args.len() == 1 && method.node.as_str() == \"collect\" &&\n                    match_trait_method(cx, expr, &paths::ITERATOR) {\n                     span_lint(cx,\n                               UNUSED_COLLECT,\n@@ -579,10 +579,10 @@ fn is_len_call(expr: &Expr, var: &Name) -> bool {\n     if_let_chain! {[\n         let ExprMethodCall(method, _, ref len_args) = expr.node,\n         len_args.len() == 1,\n-        &*method.node.as_str() == \"len\",\n+        method.node.as_str() == \"len\",\n         let ExprPath(QPath::Resolved(_, ref path)) = len_args[0].node,\n         path.segments.len() == 1,\n-        &path.segments[0].name == var\n+        path.segments[0].name == *var\n     ], {\n         return true;\n     }}"}, {"sha": "a31870e927e60a7146b6f54169ab0ce0a61bc6a4", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=d9e69a70df9a2d169223b635a11bdc73eb6e6fbd", "patch": "@@ -28,7 +28,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // call to .map()\n         if let ExprMethodCall(name, _, ref args) = expr.node {\n-            if &*name.node.as_str() == \"map\" && args.len() == 2 {\n+            if name.node.as_str() == \"map\" && args.len() == 2 {\n                 match args[1].node {\n                     ExprClosure(_, ref decl, closure_eid, _) => {\n                         let body = cx.tcx.hir.body(closure_eid);\n@@ -53,7 +53,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                             }\n                             // explicit clone() calls ( .map(|x| x.clone()) )\n                             else if let ExprMethodCall(clone_call, _, ref clone_args) = closure_expr.node {\n-                                if &*clone_call.node.as_str() == \"clone\" &&\n+                                if clone_call.node.as_str() == \"clone\" &&\n                                     clone_args.len() == 1 &&\n                                     match_trait_method(cx, closure_expr, &paths::CLONE_TRAIT) &&\n                                     expr_eq_name(&clone_args[0], arg_ident)"}, {"sha": "46dd54648815c5c32f86df756a0bdd57c51c23b2", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=d9e69a70df9a2d169223b635a11bdc73eb6e6fbd", "patch": "@@ -257,7 +257,7 @@ fn check_single_match_opt_like(\n     };\n \n     for &(ty_path, pat_path) in candidates {\n-        if &path == pat_path && match_type(cx, ty, ty_path) {\n+        if path == *pat_path && match_type(cx, ty, ty_path) {\n             report_single_match_single_pattern(cx, ex, arms, expr, els);\n         }\n     }"}, {"sha": "1ab90c9466882d5b61ae06a726f174ea873c7732", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=d9e69a70df9a2d169223b635a11bdc73eb6e6fbd", "patch": "@@ -607,14 +607,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 lint_or_fun_call(cx, expr, &name.node.as_str(), args);\n \n                 let self_ty = cx.tables.expr_ty_adjusted(&args[0]);\n-                if args.len() == 1 && &*name.node.as_str() == \"clone\" {\n+                if args.len() == 1 && name.node.as_str() == \"clone\" {\n                     lint_clone_on_copy(cx, expr, &args[0], self_ty);\n                 }\n \n                 match self_ty.sty {\n                     ty::TyRef(_, ty) if ty.ty.sty == ty::TyStr => {\n                         for &(method, pos) in &PATTERN_METHODS {\n-                            if &*name.node.as_str() == method && args.len() > pos {\n+                            if *name.node.as_str() == *method && args.len() > pos {\n                                 lint_single_char_pattern(cx, expr, &args[pos]);\n                             }\n                         }\n@@ -646,7 +646,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         ], {\n             // check missing trait implementations\n             for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n-                if &*name.as_str() == method_name &&\n+                if *name.as_str() == *method_name &&\n                    sig.decl.inputs.len() == n_args &&\n                    out_type.matches(&sig.decl.output) &&\n                    self_kind.matches(&first_arg_ty, &first_arg, &self_ty, false) {\n@@ -683,7 +683,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             }\n \n             let ret_ty = return_ty(cx, implitem.id);\n-            if &*name.as_str() == \"new\" &&\n+            if name.as_str() == \"new\" &&\n                !ret_ty.walk().any(|t| same_tys(cx, t, ty, implitem.id)) {\n                 span_lint(cx,\n                           NEW_RET_NO_SELF,\n@@ -991,7 +991,7 @@ fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: ty::Ty) -> Option<sug\n     }\n \n     if let hir::ExprMethodCall(name, _, ref args) = expr.node {\n-        if &*name.node.as_str() == \"iter\" && may_slice(cx, cx.tables.expr_ty(&args[0])) {\n+        if name.node.as_str() == \"iter\" && may_slice(cx, cx.tables.expr_ty(&args[0])) {\n             sugg::Sugg::hir_opt(cx, &args[0]).map(|sugg| sugg.addr())\n         } else {\n             None\n@@ -1209,7 +1209,7 @@ fn lint_chars_next(cx: &LateContext, expr: &hir::Expr, chain: &hir::Expr, other:\n         arg_char.len() == 1,\n         let hir::ExprPath(ref qpath) = fun.node,\n         let Some(segment) = single_segment_path(qpath),\n-        &*segment.name.as_str() == \"Some\"\n+        segment.name.as_str() == \"Some\"\n     ], {\n         let self_ty = walk_ptrs_ty(cx.tables.expr_ty_adjusted(&args[0][0]));\n "}, {"sha": "a8dc94d74fa2b3b9e390bc4c5a793214d5c20e38", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=d9e69a70df9a2d169223b635a11bdc73eb6e6fbd", "patch": "@@ -335,7 +335,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 let binding = last_path_segment(qpath).name.as_str();\n                 if binding.starts_with('_') &&\n                     !binding.starts_with(\"__\") &&\n-                    &*binding != \"_result\" && // FIXME: #944\n+                    binding != \"_result\" && // FIXME: #944\n                     is_used(cx, expr) &&\n                     // don't lint if the declaration is in a macro\n                     non_macro_local(cx, &cx.tables.qpath_def(qpath, expr.id)) {\n@@ -378,7 +378,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n fn check_nan(cx: &LateContext, path: &Path, expr: &Expr) {\n     if !in_constant(cx, expr.id) {\n-        path.segments.last().map(|seg| if &*seg.name.as_str() == \"NAN\" {\n+        path.segments.last().map(|seg| if seg.name.as_str() == \"NAN\" {\n             span_lint(cx,\n                       CMP_NAN,\n                       expr.span,"}, {"sha": "3b3c21df536ac1e69eaba2f15ba98294229fc330", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=d9e69a70df9a2d169223b635a11bdc73eb6e6fbd", "patch": "@@ -65,7 +65,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                     if_let_chain!{[\n                         a.meta_item_list().is_some(),\n                         let Some(name) = a.name(),\n-                        &*name.as_str() == \"proc_macro_derive\",\n+                        name.as_str() == \"proc_macro_derive\",\n                     ], {\n                         return;\n                     }}\n@@ -102,7 +102,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n         let fn_sig = cx.tcx.item_type(fn_def_id).fn_sig();\n         let fn_sig = cx.tcx.liberate_late_bound_regions(param_env.free_id_outlive, &fn_sig);\n \n-        for ((input, ty), arg) in decl.inputs.iter().zip(fn_sig.inputs()).zip(&body.arguments) {\n+        for ((input, &ty), arg) in decl.inputs.iter().zip(fn_sig.inputs()).zip(&body.arguments) {\n \n             // Determines whether `ty` implements `Borrow<U>` (U != ty) specifically.\n             // This is needed due to the `Borrow<T> for T` blanket impl.\n@@ -112,8 +112,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                 } else {\n                     None\n                 })\n-                .filter(|tpred| tpred.def_id() == borrow_trait && &tpred.self_ty() == ty)\n-                .any(|tpred| &tpred.input_types().nth(1).expect(\"Borrow trait must have an parameter\") != ty);\n+                .filter(|tpred| tpred.def_id() == borrow_trait && tpred.self_ty() == ty)\n+                .any(|tpred| tpred.input_types().nth(1).expect(\"Borrow trait must have an parameter\") != ty);\n \n             if_let_chain! {[\n                 !is_self(arg),\n@@ -141,7 +141,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                         match_type(cx, ty, &paths::VEC),\n                         let TyPath(QPath::Resolved(_, ref path)) = input.node,\n                         let Some(elem_ty) = path.segments.iter()\n-                            .find(|seg| &*seg.name.as_str() == \"Vec\")\n+                            .find(|seg| seg.name.as_str() == \"Vec\")\n                             .map(|ps| ps.parameters.types()[0]),\n                     ], {\n                         let slice_ty = format!(\"&[{}]\", snippet(cx, elem_ty.span, \"_\"));"}, {"sha": "a44cd11512e082e1bee95d97d7c53c6d0f099b8e", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=d9e69a70df9a2d169223b635a11bdc73eb6e6fbd", "patch": "@@ -108,7 +108,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n                 // can't be implemented by default\n                 return;\n             }\n-            if decl.inputs.is_empty() && &*name.as_str() == \"new\" && cx.access_levels.is_reachable(id) {\n+            if decl.inputs.is_empty() && name.as_str() == \"new\" && cx.access_levels.is_reachable(id) {\n                 let self_ty = cx.tcx\n                     .item_type(cx.tcx.hir.local_def_id(cx.tcx.hir.get_parent(id)));\n                 if_let_chain!{["}, {"sha": "98b9070f6befc2d19ce70123d0f2d5a9d534bcba", "filename": "clippy_lints/src/open_options.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/clippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/clippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fopen_options.rs?ref=d9e69a70df9a2d169223b635a11bdc73eb6e6fbd", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSensical {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprMethodCall(ref name, _, ref arguments) = e.node {\n             let (obj_ty, _) = walk_ptrs_ty_depth(cx.tables.expr_ty(&arguments[0]));\n-            if &*name.node.as_str() == \"open\" && match_type(cx, obj_ty, &paths::OPEN_OPTIONS) {\n+            if name.node.as_str() == \"open\" && match_type(cx, obj_ty, &paths::OPEN_OPTIONS) {\n                 let mut options = Vec::new();\n                 get_open_options(cx, &arguments[0], &mut options);\n                 check_open_options(cx, &options, e.span);"}, {"sha": "41ea6fbc4618ef607de25e4dedaec0494acf5ec4", "filename": "clippy_lints/src/overflow_check_conditional.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs?ref=d9e69a70df9a2d169223b635a11bdc73eb6e6fbd", "patch": "@@ -38,7 +38,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OverflowCheckConditional {\n             let Expr_::ExprPath(QPath::Resolved(_, ref path1)) = ident1.node,\n             let Expr_::ExprPath(QPath::Resolved(_, ref path2)) = ident2.node,\n             let Expr_::ExprPath(QPath::Resolved(_, ref path3)) = second.node,\n-            &path1.segments[0] == &path3.segments[0] || &path2.segments[0] == &path3.segments[0],\n+            path1.segments[0] == path3.segments[0] || path2.segments[0] == path3.segments[0],\n             cx.tables.expr_ty(ident1).is_integral(),\n             cx.tables.expr_ty(ident2).is_integral()\n         ], {\n@@ -62,7 +62,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OverflowCheckConditional {\n             let Expr_::ExprPath(QPath::Resolved(_, ref path1)) = ident1.node,\n             let Expr_::ExprPath(QPath::Resolved(_, ref path2)) = ident2.node,\n             let Expr_::ExprPath(QPath::Resolved(_, ref path3)) = first.node,\n-            &path1.segments[0] == &path3.segments[0] || &path2.segments[0] == &path3.segments[0],\n+            path1.segments[0] == path3.segments[0] || path2.segments[0] == path3.segments[0],\n             cx.tables.expr_ty(ident1).is_integral(),\n             cx.tables.expr_ty(ident2).is_integral()\n         ], {"}, {"sha": "1bdd6460bc0ff22c280f3de5c95c215e061ed646", "filename": "clippy_lints/src/partialeq_ne_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=d9e69a70df9a2d169223b635a11bdc73eb6e6fbd", "patch": "@@ -43,7 +43,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             trait_ref.path.def.def_id() == cx.tcx.lang_items.eq_trait().unwrap(),\n         ], {\n             for impl_item in impl_items {\n-                if &*impl_item.name.as_str() == \"ne\" {\n+                if impl_item.name.as_str() == \"ne\" {\n                     span_lint(cx,\n                               PARTIALEQ_NE_IMPL,\n                               impl_item.span,"}, {"sha": "f43e90702730a7877be499325078104e1acd2e6c", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=d9e69a70df9a2d169223b635a11bdc73eb6e6fbd", "patch": "@@ -64,13 +64,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StepByZero {\n                 if_let_chain! {[\n                     // .iter() call\n                     let ExprMethodCall( Spanned { node: ref iter_name, .. }, _, ref iter_args ) = *iter,\n-                    &*iter_name.as_str() == \"iter\",\n+                    iter_name.as_str() == \"iter\",\n                     // range expression in .zip() call: 0..x.len()\n                     let Some(higher::Range { start: Some(ref start), end: Some(ref end), .. }) = higher::range(zip_arg),\n                     is_integer_literal(start, 0),\n                     // .len() call\n                     let ExprMethodCall(Spanned { node: ref len_name, .. }, _, ref len_args) = end.node,\n-                    &*len_name.as_str() == \"len\" && len_args.len() == 1,\n+                    len_name.as_str() == \"len\" && len_args.len() == 1,\n                     // .iter() and .len() called on same Path\n                     let ExprPath(QPath::Resolved(_, ref iter_path)) = iter_args[0].node,\n                     let ExprPath(QPath::Resolved(_, ref len_path)) = len_args[0].node,"}, {"sha": "86576422746b0ee32ef63c20222fee676812b88c", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=d9e69a70df9a2d169223b635a11bdc73eb6e6fbd", "patch": "@@ -143,7 +143,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringLitAsBytes {\n         use utils::{snippet, in_macro};\n \n         if let ExprMethodCall(ref name, _, ref args) = e.node {\n-            if &*name.node.as_str() == \"as_bytes\" {\n+            if name.node.as_str() == \"as_bytes\" {\n                 if let ExprLit(ref lit) = args[0].node {\n                     if let LitKind::Str(ref lit_content, _) = lit.node {\n                         if lit_content.as_str().chars().all(|c| c.is_ascii()) && !in_macro(cx, args[0].span) {"}, {"sha": "06f029550bce9330f199b72ad78655494be96789", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9e69a70df9a2d169223b635a11bdc73eb6e6fbd/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=d9e69a70df9a2d169223b635a11bdc73eb6e6fbd", "patch": "@@ -179,7 +179,7 @@ pub fn match_def_path(tcx: ty::TyCtxt, def_id: DefId, path: &[&str]) -> bool {\n \n     tcx.push_item_path(&mut apb, def_id);\n \n-    apb.names.len() == path.len() && apb.names.iter().zip(path.iter()).all(|(a, &b)| &**a == b)\n+    apb.names.len() == path.len() && apb.names.into_iter().zip(path.iter()).all(|(a, &b)| *a == *b)\n }\n \n /// Check if type is struct, enum or union type with given def path."}]}