{"sha": "158e0c86fe6c4db2d1dde8da156ce58aaf319dc4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1OGUwYzg2ZmU2YzRkYjJkMWRkZThkYTE1NmNlNThhYWYzMTlkYzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-19T07:56:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-19T07:56:30Z"}, "message": "auto merge of #13604 : alexcrichton/rust/connect-timeout, r=brson\n\nThis adds a `TcpStream::connect_timeout` function in order to assist opening\r\nconnections with a timeout (cc #13523). There isn't really much design space for\r\nthis specific operation (unlike timing out normal blocking reads/writes), so I\r\nam fairly confident that this is the correct interface for this function.\r\n\r\nThe function is marked #[experimental] because it takes a u64 timeout argument,\r\nand the u64 type is likely to change in the future.", "tree": {"sha": "453907889bbb6913dbc8c6686cfab9fd93acfe3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/453907889bbb6913dbc8c6686cfab9fd93acfe3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/158e0c86fe6c4db2d1dde8da156ce58aaf319dc4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/158e0c86fe6c4db2d1dde8da156ce58aaf319dc4", "html_url": "https://github.com/rust-lang/rust/commit/158e0c86fe6c4db2d1dde8da156ce58aaf319dc4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/158e0c86fe6c4db2d1dde8da156ce58aaf319dc4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a2ecb828bec0465a801b8c843f928ddccb2228f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a2ecb828bec0465a801b8c843f928ddccb2228f", "html_url": "https://github.com/rust-lang/rust/commit/5a2ecb828bec0465a801b8c843f928ddccb2228f"}, {"sha": "3915e17cd70e2d584726364851d368badb8bf15b", "url": "https://api.github.com/repos/rust-lang/rust/commits/3915e17cd70e2d584726364851d368badb8bf15b", "html_url": "https://github.com/rust-lang/rust/commit/3915e17cd70e2d584726364851d368badb8bf15b"}], "stats": {"total": 635, "additions": 490, "deletions": 145}, "files": [{"sha": "98613f885cd4527e20be6b43e98fa1aa0b059fda", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/158e0c86fe6c4db2d1dde8da156ce58aaf319dc4/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158e0c86fe6c4db2d1dde8da156ce58aaf319dc4/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=158e0c86fe6c4db2d1dde8da156ce58aaf319dc4", "patch": "@@ -87,13 +87,14 @@ pub use types::common::c95::{FILE, c_void, fpos_t};\n pub use types::common::c99::{int8_t, int16_t, int32_t, int64_t};\n pub use types::common::c99::{uint8_t, uint16_t, uint32_t, uint64_t};\n pub use types::common::posix88::{DIR, dirent_t};\n+pub use types::os::common::posix01::{timeval};\n pub use types::os::common::bsd44::{addrinfo, in_addr, in6_addr, sockaddr_storage};\n pub use types::os::common::bsd44::{ip_mreq, ip6_mreq, sockaddr, sockaddr_un};\n pub use types::os::common::bsd44::{sa_family_t, sockaddr_in, sockaddr_in6, socklen_t};\n pub use types::os::arch::c95::{c_char, c_double, c_float, c_int, c_uint};\n pub use types::os::arch::c95::{c_long, c_short, c_uchar, c_ulong};\n pub use types::os::arch::c95::{c_ushort, clock_t, ptrdiff_t};\n-pub use types::os::arch::c95::{size_t, time_t};\n+pub use types::os::arch::c95::{size_t, time_t, suseconds_t};\n pub use types::os::arch::c99::{c_longlong, c_ulonglong};\n pub use types::os::arch::c99::{intptr_t, uintptr_t};\n pub use types::os::arch::posix88::{dev_t, ino_t, mode_t};\n@@ -113,7 +114,7 @@ pub use consts::os::posix88::{STDERR_FILENO, STDIN_FILENO, S_IXUSR};\n pub use consts::os::posix88::{STDOUT_FILENO, W_OK, X_OK};\n pub use consts::os::bsd44::{AF_INET, AF_INET6, SOCK_STREAM, SOCK_DGRAM};\n pub use consts::os::bsd44::{IPPROTO_IP, IPPROTO_IPV6, IPPROTO_TCP, TCP_NODELAY};\n-pub use consts::os::bsd44::{SOL_SOCKET, SO_KEEPALIVE};\n+pub use consts::os::bsd44::{SOL_SOCKET, SO_KEEPALIVE, SO_ERROR};\n pub use consts::os::bsd44::{SO_REUSEADDR, SO_BROADCAST, SHUT_WR, IP_MULTICAST_LOOP};\n pub use consts::os::bsd44::{IP_ADD_MEMBERSHIP, IP_DROP_MEMBERSHIP};\n pub use consts::os::bsd44::{IPV6_ADD_MEMBERSHIP, IPV6_DROP_MEMBERSHIP};\n@@ -170,14 +171,13 @@ pub use funcs::bsd43::{shutdown};\n #[cfg(unix)] pub use consts::os::posix88::{ECONNREFUSED, ECONNRESET, EPERM, EPIPE};\n #[cfg(unix)] pub use consts::os::posix88::{ENOTCONN, ECONNABORTED, EADDRNOTAVAIL, EINTR};\n #[cfg(unix)] pub use consts::os::posix88::{EADDRINUSE, ENOENT, EISDIR, EAGAIN, EWOULDBLOCK};\n-#[cfg(unix)] pub use consts::os::posix88::{ECANCELED, SIGINT};\n+#[cfg(unix)] pub use consts::os::posix88::{ECANCELED, SIGINT, EINPROGRESS};\n #[cfg(unix)] pub use consts::os::posix88::{SIGTERM, SIGKILL, SIGPIPE, PROT_NONE};\n #[cfg(unix)] pub use consts::os::posix01::{SIG_IGN, WNOHANG};\n #[cfg(unix)] pub use consts::os::bsd44::{AF_UNIX};\n \n-#[cfg(unix)] pub use types::os::common::posix01::{pthread_t, timespec, timezone, timeval};\n+#[cfg(unix)] pub use types::os::common::posix01::{pthread_t, timespec, timezone};\n \n-#[cfg(unix)] pub use types::os::arch::c95::{suseconds_t};\n #[cfg(unix)] pub use types::os::arch::posix88::{uid_t, gid_t};\n #[cfg(unix)] pub use types::os::arch::posix01::{pthread_attr_t};\n #[cfg(unix)] pub use types::os::arch::posix01::{stat, utimbuf};\n@@ -195,6 +195,7 @@ pub use funcs::bsd43::{shutdown};\n #[cfg(windows)] pub use consts::os::c95::{WSAECONNREFUSED, WSAECONNRESET, WSAEACCES};\n #[cfg(windows)] pub use consts::os::c95::{WSAEWOULDBLOCK, WSAENOTCONN, WSAECONNABORTED};\n #[cfg(windows)] pub use consts::os::c95::{WSAEADDRNOTAVAIL, WSAEADDRINUSE, WSAEINTR};\n+#[cfg(windows)] pub use consts::os::c95::{WSAEINPROGRESS};\n #[cfg(windows)] pub use consts::os::extra::{ERROR_INSUFFICIENT_BUFFER};\n #[cfg(windows)] pub use consts::os::extra::{O_BINARY, O_NOINHERIT, PAGE_NOACCESS};\n #[cfg(windows)] pub use consts::os::extra::{PAGE_READONLY, PAGE_READWRITE, PAGE_EXECUTE};\n@@ -1708,6 +1709,7 @@ pub mod consts {\n             pub static SO_KEEPALIVE: c_int = 8;\n             pub static SO_BROADCAST: c_int = 32;\n             pub static SO_REUSEADDR: c_int = 4;\n+            pub static SO_ERROR: c_int = 0x1007;\n \n             pub static SHUT_RD: c_int = 0;\n             pub static SHUT_WR: c_int = 1;\n@@ -2496,6 +2498,7 @@ pub mod consts {\n             pub static SO_KEEPALIVE: c_int = 9;\n             pub static SO_BROADCAST: c_int = 6;\n             pub static SO_REUSEADDR: c_int = 2;\n+            pub static SO_ERROR: c_int = 4;\n \n             pub static SHUT_RD: c_int = 0;\n             pub static SHUT_WR: c_int = 1;\n@@ -2954,6 +2957,7 @@ pub mod consts {\n             pub static SO_KEEPALIVE: c_int = 0x0008;\n             pub static SO_BROADCAST: c_int = 0x0020;\n             pub static SO_REUSEADDR: c_int = 0x0004;\n+            pub static SO_ERROR: c_int = 0x1007;\n \n             pub static SHUT_RD: c_int = 0;\n             pub static SHUT_WR: c_int = 1;\n@@ -3340,6 +3344,7 @@ pub mod consts {\n             pub static SO_KEEPALIVE: c_int = 0x0008;\n             pub static SO_BROADCAST: c_int = 0x0020;\n             pub static SO_REUSEADDR: c_int = 0x0004;\n+            pub static SO_ERROR: c_int = 0x1007;\n \n             pub static SHUT_RD: c_int = 0;\n             pub static SHUT_WR: c_int = 1;"}, {"sha": "e2bf515a1e52301130fbb247fa82569181027977", "filename": "src/libnative/io/c_unix.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/158e0c86fe6c4db2d1dde8da156ce58aaf319dc4/src%2Flibnative%2Fio%2Fc_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158e0c86fe6c4db2d1dde8da156ce58aaf319dc4/src%2Flibnative%2Fio%2Fc_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fc_unix.rs?ref=158e0c86fe6c4db2d1dde8da156ce58aaf319dc4", "patch": "@@ -0,0 +1,76 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! C definitions used by libnative that don't belong in liblibc\n+\n+pub use self::select::fd_set;\n+\n+use libc;\n+\n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n+pub static FIONBIO: libc::c_ulong = 0x8004667e;\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"android\")]\n+pub static FIONBIO: libc::c_ulong = 0x5421;\n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n+pub static FIOCLEX: libc::c_ulong = 0x20006601;\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"android\")]\n+pub static FIOCLEX: libc::c_ulong = 0x5451;\n+\n+extern {\n+    pub fn gettimeofday(timeval: *mut libc::timeval,\n+                        tzp: *libc::c_void) -> libc::c_int;\n+    pub fn select(nfds: libc::c_int,\n+                  readfds: *fd_set,\n+                  writefds: *fd_set,\n+                  errorfds: *fd_set,\n+                  timeout: *libc::timeval) -> libc::c_int;\n+    pub fn getsockopt(sockfd: libc::c_int,\n+                      level: libc::c_int,\n+                      optname: libc::c_int,\n+                      optval: *mut libc::c_void,\n+                      optlen: *mut libc::socklen_t) -> libc::c_int;\n+    pub fn ioctl(fd: libc::c_int, req: libc::c_ulong, ...) -> libc::c_int;\n+\n+}\n+\n+#[cfg(target_os = \"macos\")]\n+mod select {\n+    pub static FD_SETSIZE: uint = 1024;\n+\n+    pub struct fd_set {\n+        fds_bits: [i32, ..(FD_SETSIZE / 32)]\n+    }\n+\n+    pub fn fd_set(set: &mut fd_set, fd: i32) {\n+        set.fds_bits[(fd / 32) as uint] |= 1 << (fd % 32);\n+    }\n+}\n+\n+#[cfg(target_os = \"android\")]\n+#[cfg(target_os = \"freebsd\")]\n+#[cfg(target_os = \"linux\")]\n+mod select {\n+    use std::uint;\n+\n+    pub static FD_SETSIZE: uint = 1024;\n+\n+    pub struct fd_set {\n+        fds_bits: [uint, ..(FD_SETSIZE / uint::BITS)]\n+    }\n+\n+    pub fn fd_set(set: &mut fd_set, fd: i32) {\n+        let fd = fd as uint;\n+        set.fds_bits[fd / uint::BITS] |= 1 << (fd % uint::BITS);\n+    }\n+}"}, {"sha": "8d75a6739146d270b165cadac34b7510aa33ed44", "filename": "src/libnative/io/c_win32.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/158e0c86fe6c4db2d1dde8da156ce58aaf319dc4/src%2Flibnative%2Fio%2Fc_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158e0c86fe6c4db2d1dde8da156ce58aaf319dc4/src%2Flibnative%2Fio%2Fc_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fc_win32.rs?ref=158e0c86fe6c4db2d1dde8da156ce58aaf319dc4", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! C definitions used by libnative that don't belong in liblibc\n+\n+#![allow(type_overflow)]\n+\n+use libc;\n+\n+pub static WSADESCRIPTION_LEN: uint = 256;\n+pub static WSASYS_STATUS_LEN: uint = 128;\n+pub static FIONBIO: libc::c_long = 0x8004667e;\n+static FD_SETSIZE: uint = 64;\n+\n+pub struct WSADATA {\n+    pub wVersion: libc::WORD,\n+    pub wHighVersion: libc::WORD,\n+    pub szDescription: [u8, ..WSADESCRIPTION_LEN + 1],\n+    pub szSystemStatus: [u8, ..WSASYS_STATUS_LEN + 1],\n+    pub iMaxSockets: u16,\n+    pub iMaxUdpDg: u16,\n+    pub lpVendorInfo: *u8,\n+}\n+\n+pub type LPWSADATA = *mut WSADATA;\n+\n+pub struct fd_set {\n+    fd_count: libc::c_uint,\n+    fd_array: [libc::SOCKET, ..FD_SETSIZE],\n+}\n+\n+pub fn fd_set(set: &mut fd_set, s: libc::SOCKET) {\n+    set.fd_array[set.fd_count as uint] = s;\n+    set.fd_count += 1;\n+}\n+\n+#[link(name = \"ws2_32\")]\n+extern \"system\" {\n+    pub fn WSAStartup(wVersionRequested: libc::WORD,\n+                      lpWSAData: LPWSADATA) -> libc::c_int;\n+    pub fn WSAGetLastError() -> libc::c_int;\n+\n+    pub fn ioctlsocket(s: libc::SOCKET, cmd: libc::c_long,\n+                       argp: *mut libc::c_ulong) -> libc::c_int;\n+    pub fn select(nfds: libc::c_int,\n+                  readfds: *mut fd_set,\n+                  writefds: *mut fd_set,\n+                  exceptfds: *mut fd_set,\n+                  timeout: *libc::timeval) -> libc::c_int;\n+    pub fn getsockopt(sockfd: libc::SOCKET,\n+                      level: libc::c_int,\n+                      optname: libc::c_int,\n+                      optval: *mut libc::c_char,\n+                      optlen: *mut libc::c_int) -> libc::c_int;\n+}"}, {"sha": "19cb5c5f1d4f0ef57d59be45915304b2fc2428b0", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/158e0c86fe6c4db2d1dde8da156ce58aaf319dc4/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158e0c86fe6c4db2d1dde8da156ce58aaf319dc4/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=158e0c86fe6c4db2d1dde8da156ce58aaf319dc4", "patch": "@@ -71,6 +71,9 @@ pub mod pipe;\n #[path = \"pipe_win32.rs\"]\n pub mod pipe;\n \n+#[cfg(unix)]    #[path = \"c_unix.rs\"]  mod c;\n+#[cfg(windows)] #[path = \"c_win32.rs\"] mod c;\n+\n mod timer_helper;\n \n pub type IoResult<T> = Result<T, IoError>;\n@@ -161,8 +164,9 @@ impl IoFactory {\n \n impl rtio::IoFactory for IoFactory {\n     // networking\n-    fn tcp_connect(&mut self, addr: SocketAddr) -> IoResult<~RtioTcpStream:Send> {\n-        net::TcpStream::connect(addr).map(|s| ~s as ~RtioTcpStream:Send)\n+    fn tcp_connect(&mut self, addr: SocketAddr,\n+                   timeout: Option<u64>) -> IoResult<~RtioTcpStream:Send> {\n+        net::TcpStream::connect(addr, timeout).map(|s| ~s as ~RtioTcpStream:Send)\n     }\n     fn tcp_bind(&mut self, addr: SocketAddr) -> IoResult<~RtioTcpListener:Send> {\n         net::TcpListener::bind(addr).map(|s| ~s as ~RtioTcpListener:Send)"}, {"sha": "be597761b1a8f8d774ca6ed5774d327bcb4d5e50", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 131, "deletions": 37, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/158e0c86fe6c4db2d1dde8da156ce58aaf319dc4/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158e0c86fe6c4db2d1dde8da156ce58aaf319dc4/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=158e0c86fe6c4db2d1dde8da156ce58aaf319dc4", "patch": "@@ -8,15 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use libc;\n use std::cast;\n use std::io::net::ip;\n use std::io;\n-use libc;\n use std::mem;\n+use std::ptr;\n use std::rt::rtio;\n use std::sync::arc::UnsafeArc;\n \n use super::{IoResult, retry, keep_going};\n+use super::c;\n \n ////////////////////////////////////////////////////////////////////////////////\n // sockaddr and misc bindings\n@@ -115,12 +117,26 @@ fn setsockopt<T>(fd: sock_t, opt: libc::c_int, val: libc::c_int,\n     }\n }\n \n+fn getsockopt<T: Copy>(fd: sock_t, opt: libc::c_int,\n+                       val: libc::c_int) -> IoResult<T> {\n+    unsafe {\n+        let mut slot: T = mem::init();\n+        let mut len = mem::size_of::<T>() as libc::socklen_t;\n+        let ret = c::getsockopt(fd, opt, val,\n+                                &mut slot as *mut _ as *mut _,\n+                                &mut len);\n+        if ret != 0 {\n+            Err(last_error())\n+        } else {\n+            assert!(len as uint == mem::size_of::<T>());\n+            Ok(slot)\n+        }\n+    }\n+}\n+\n #[cfg(windows)]\n fn last_error() -> io::IoError {\n-    extern \"system\" {\n-        fn WSAGetLastError() -> libc::c_int;\n-    }\n-    io::IoError::from_errno(unsafe { WSAGetLastError() } as uint, true)\n+    io::IoError::from_errno(unsafe { c::WSAGetLastError() } as uint, true)\n }\n \n #[cfg(not(windows))]\n@@ -197,24 +213,6 @@ pub fn init() {}\n \n #[cfg(windows)]\n pub fn init() {\n-    static WSADESCRIPTION_LEN: uint = 256;\n-    static WSASYS_STATUS_LEN: uint = 128;\n-    struct WSADATA {\n-        wVersion: libc::WORD,\n-        wHighVersion: libc::WORD,\n-        szDescription: [u8, ..WSADESCRIPTION_LEN + 1],\n-        szSystemStatus: [u8, ..WSASYS_STATUS_LEN + 1],\n-        iMaxSockets: u16,\n-        iMaxUdpDg: u16,\n-        lpVendorInfo: *u8,\n-    }\n-    type LPWSADATA = *mut WSADATA;\n-\n-    #[link(name = \"ws2_32\")]\n-    extern \"system\" {\n-        fn WSAStartup(wVersionRequested: libc::WORD,\n-                       lpWSAData: LPWSADATA) -> libc::c_int;\n-    }\n \n     unsafe {\n         use std::unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n@@ -223,9 +221,9 @@ pub fn init() {\n \n         let _guard = LOCK.lock();\n         if !INITIALIZED {\n-            let mut data: WSADATA = mem::init();\n-            let ret = WSAStartup(0x202,      // version 2.2\n-                                 &mut data);\n+            let mut data: c::WSADATA = mem::init();\n+            let ret = c::WSAStartup(0x202,      // version 2.2\n+                                    &mut data);\n             assert_eq!(ret, 0);\n             INITIALIZED = true;\n         }\n@@ -245,22 +243,118 @@ struct Inner {\n }\n \n impl TcpStream {\n-    pub fn connect(addr: ip::SocketAddr) -> IoResult<TcpStream> {\n-        unsafe {\n-            socket(addr, libc::SOCK_STREAM).and_then(|fd| {\n-                let (addr, len) = addr_to_sockaddr(addr);\n-                let addrp = &addr as *libc::sockaddr_storage;\n-                let inner = Inner { fd: fd };\n-                let ret = TcpStream { inner: UnsafeArc::new(inner) };\n-                match retry(|| {\n-                    libc::connect(fd, addrp as *libc::sockaddr,\n-                                  len as libc::socklen_t)\n-                }) {\n+    pub fn connect(addr: ip::SocketAddr,\n+                   timeout: Option<u64>) -> IoResult<TcpStream> {\n+        let fd = try!(socket(addr, libc::SOCK_STREAM));\n+        let (addr, len) = addr_to_sockaddr(addr);\n+        let inner = Inner { fd: fd };\n+        let ret = TcpStream { inner: UnsafeArc::new(inner) };\n+\n+        let len = len as libc::socklen_t;\n+        let addrp = &addr as *_ as *libc::sockaddr;\n+        match timeout {\n+            Some(timeout) => {\n+                try!(TcpStream::connect_timeout(fd, addrp, len, timeout));\n+                Ok(ret)\n+            },\n+            None => {\n+                match retry(|| unsafe { libc::connect(fd, addrp, len) }) {\n                     -1 => Err(last_error()),\n                     _ => Ok(ret),\n                 }\n+            }\n+        }\n+    }\n+\n+    // See http://developerweb.net/viewtopic.php?id=3196 for where this is\n+    // derived from.\n+    fn connect_timeout(fd: sock_t,\n+                       addrp: *libc::sockaddr,\n+                       len: libc::socklen_t,\n+                       timeout: u64) -> IoResult<()> {\n+        use std::os;\n+        #[cfg(unix)]    use INPROGRESS = libc::EINPROGRESS;\n+        #[cfg(windows)] use INPROGRESS = libc::WSAEINPROGRESS;\n+        #[cfg(unix)]    use WOULDBLOCK = libc::EWOULDBLOCK;\n+        #[cfg(windows)] use WOULDBLOCK = libc::WSAEWOULDBLOCK;\n+\n+        // Make sure the call to connect() doesn't block\n+        try!(set_nonblocking(fd, true));\n+\n+        let ret = match unsafe { libc::connect(fd, addrp, len) } {\n+            // If the connection is in progress, then we need to wait for it to\n+            // finish (with a timeout). The current strategy for doing this is\n+            // to use select() with a timeout.\n+            -1 if os::errno() as int == INPROGRESS as int ||\n+                  os::errno() as int == WOULDBLOCK as int => {\n+                let mut set: c::fd_set = unsafe { mem::init() };\n+                c::fd_set(&mut set, fd);\n+                match await(fd, &mut set, timeout) {\n+                    0 => Err(io::IoError {\n+                        kind: io::TimedOut,\n+                        desc: \"connection timed out\",\n+                        detail: None,\n+                    }),\n+                    -1 => Err(last_error()),\n+                    _ => {\n+                        let err: libc::c_int = try!(\n+                            getsockopt(fd, libc::SOL_SOCKET, libc::SO_ERROR));\n+                        if err == 0 {\n+                            Ok(())\n+                        } else {\n+                            Err(io::IoError::from_errno(err as uint, true))\n+                        }\n+                    }\n+                }\n+            }\n+\n+            -1 => Err(last_error()),\n+            _ => Ok(()),\n+        };\n+\n+        // be sure to turn blocking I/O back on\n+        try!(set_nonblocking(fd, false));\n+        return ret;\n+\n+        #[cfg(unix)]\n+        fn set_nonblocking(fd: sock_t, nb: bool) -> IoResult<()> {\n+            let set = nb as libc::c_int;\n+            super::mkerr_libc(retry(|| unsafe { c::ioctl(fd, c::FIONBIO, &set) }))\n+        }\n+        #[cfg(windows)]\n+        fn set_nonblocking(fd: sock_t, nb: bool) -> IoResult<()> {\n+            let mut set = nb as libc::c_ulong;\n+            if unsafe { c::ioctlsocket(fd, c::FIONBIO, &mut set) != 0 } {\n+                Err(last_error())\n+            } else {\n+                Ok(())\n+            }\n+        }\n+\n+        #[cfg(unix)]\n+        fn await(fd: sock_t, set: &mut c::fd_set, timeout: u64) -> libc::c_int {\n+            let start = ::io::timer::now();\n+            retry(|| unsafe {\n+                // Recalculate the timeout each iteration (it is generally\n+                // undefined what the value of the 'tv' is after select\n+                // returns EINTR).\n+                let timeout = timeout - (::io::timer::now() - start);\n+                let tv = libc::timeval {\n+                    tv_sec: (timeout / 1000) as libc::time_t,\n+                    tv_usec: ((timeout % 1000) * 1000) as libc::suseconds_t,\n+                };\n+                c::select(fd + 1, ptr::null(), set as *mut _ as *_,\n+                          ptr::null(), &tv)\n             })\n         }\n+        #[cfg(windows)]\n+        fn await(_fd: sock_t, set: &mut c::fd_set, timeout: u64) -> libc::c_int {\n+            let tv = libc::timeval {\n+                tv_sec: (timeout / 1000) as libc::time_t,\n+                tv_usec: ((timeout % 1000) * 1000) as libc::suseconds_t,\n+            };\n+            unsafe { c::select(1, ptr::mut_null(), set, ptr::mut_null(), &tv) }\n+        }\n     }\n \n     pub fn fd(&self) -> sock_t {"}, {"sha": "efdab990d18223f1e73bd4daf5d7227cab089ff6", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/158e0c86fe6c4db2d1dde8da156ce58aaf319dc4/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158e0c86fe6c4db2d1dde8da156ce58aaf319dc4/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=158e0c86fe6c4db2d1dde8da156ce58aaf319dc4", "patch": "@@ -454,7 +454,7 @@ fn spawn_process_os(config: p::ProcessConfig,\n                     err_fd: c_int) -> IoResult<SpawnProcessResult> {\n     use libc::funcs::posix88::unistd::{fork, dup2, close, chdir, execvp};\n     use libc::funcs::bsd44::getdtablesize;\n-    use libc::c_ulong;\n+    use io::c;\n \n     mod rustrt {\n         extern {\n@@ -475,16 +475,7 @@ fn spawn_process_os(config: p::ProcessConfig,\n     }\n \n     unsafe fn set_cloexec(fd: c_int) {\n-        extern { fn ioctl(fd: c_int, req: c_ulong) -> c_int; }\n-\n-        #[cfg(target_os = \"macos\")]\n-        #[cfg(target_os = \"freebsd\")]\n-        static FIOCLEX: c_ulong = 0x20006601;\n-        #[cfg(target_os = \"linux\")]\n-        #[cfg(target_os = \"android\")]\n-        static FIOCLEX: c_ulong = 0x5451;\n-\n-        let ret = ioctl(fd, FIOCLEX);\n+        let ret = c::ioctl(fd, c::FIOCLEX);\n         assert_eq!(ret, 0);\n     }\n "}, {"sha": "e5d4a6bb02b86bee60b463423740b1dff9a9ea20", "filename": "src/libnative/io/timer_unix.rs", "status": "modified", "additions": 7, "deletions": 62, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/158e0c86fe6c4db2d1dde8da156ce58aaf319dc4/src%2Flibnative%2Fio%2Ftimer_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158e0c86fe6c4db2d1dde8da156ce58aaf319dc4/src%2Flibnative%2Fio%2Ftimer_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_unix.rs?ref=158e0c86fe6c4db2d1dde8da156ce58aaf319dc4", "patch": "@@ -53,8 +53,9 @@ use std::ptr;\n use std::rt::rtio;\n use std::sync::atomics;\n \n-use io::file::FileDesc;\n use io::IoResult;\n+use io::c;\n+use io::file::FileDesc;\n use io::timer_helper;\n \n pub struct Timer {\n@@ -84,16 +85,16 @@ pub enum Req {\n }\n \n // returns the current time (in milliseconds)\n-fn now() -> u64 {\n+pub fn now() -> u64 {\n     unsafe {\n         let mut now: libc::timeval = mem::init();\n-        assert_eq!(imp::gettimeofday(&mut now, ptr::null()), 0);\n+        assert_eq!(c::gettimeofday(&mut now, ptr::null()), 0);\n         return (now.tv_sec as u64) * 1000 + (now.tv_usec as u64) / 1000;\n     }\n }\n \n fn helper(input: libc::c_int, messages: Receiver<Req>) {\n-    let mut set: imp::fd_set = unsafe { mem::init() };\n+    let mut set: c::fd_set = unsafe { mem::init() };\n \n     let mut fd = FileDesc::new(input, true);\n     let mut timeout: libc::timeval = unsafe { mem::init() };\n@@ -150,9 +151,9 @@ fn helper(input: libc::c_int, messages: Receiver<Req>) {\n             &timeout as *libc::timeval\n         };\n \n-        imp::fd_set(&mut set, input);\n+        c::fd_set(&mut set, input);\n         match unsafe {\n-            imp::select(input + 1, &set, ptr::null(), ptr::null(), timeout)\n+            c::select(input + 1, &set, ptr::null(), ptr::null(), timeout)\n         } {\n             // timed out\n             0 => signal(&mut active, &mut dead),\n@@ -283,59 +284,3 @@ impl Drop for Timer {\n         self.inner = Some(self.inner());\n     }\n }\n-\n-#[cfg(target_os = \"macos\")]\n-mod imp {\n-    use libc;\n-\n-    pub static FD_SETSIZE: uint = 1024;\n-\n-    pub struct fd_set {\n-        fds_bits: [i32, ..(FD_SETSIZE / 32)]\n-    }\n-\n-    pub fn fd_set(set: &mut fd_set, fd: i32) {\n-        set.fds_bits[(fd / 32) as uint] |= 1 << (fd % 32);\n-    }\n-\n-    extern {\n-        pub fn select(nfds: libc::c_int,\n-                      readfds: *fd_set,\n-                      writefds: *fd_set,\n-                      errorfds: *fd_set,\n-                      timeout: *libc::timeval) -> libc::c_int;\n-\n-        pub fn gettimeofday(timeval: *mut libc::timeval,\n-                            tzp: *libc::c_void) -> libc::c_int;\n-    }\n-}\n-\n-#[cfg(target_os = \"android\")]\n-#[cfg(target_os = \"freebsd\")]\n-#[cfg(target_os = \"linux\")]\n-mod imp {\n-    use libc;\n-    use std::uint;\n-\n-    pub static FD_SETSIZE: uint = 1024;\n-\n-    pub struct fd_set {\n-        fds_bits: [uint, ..(FD_SETSIZE / uint::BITS)]\n-    }\n-\n-    pub fn fd_set(set: &mut fd_set, fd: i32) {\n-        let fd = fd as uint;\n-        set.fds_bits[fd / uint::BITS] |= 1 << (fd % uint::BITS);\n-    }\n-\n-    extern {\n-        pub fn select(nfds: libc::c_int,\n-                      readfds: *fd_set,\n-                      writefds: *fd_set,\n-                      errorfds: *fd_set,\n-                      timeout: *libc::timeval) -> libc::c_int;\n-\n-        pub fn gettimeofday(timeval: *mut libc::timeval,\n-                            tzp: *libc::c_void) -> libc::c_int;\n-    }\n-}"}, {"sha": "4f1ca0b02d3d394b87913e7aeb99e152c8be3a4a", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/158e0c86fe6c4db2d1dde8da156ce58aaf319dc4/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158e0c86fe6c4db2d1dde8da156ce58aaf319dc4/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=158e0c86fe6c4db2d1dde8da156ce58aaf319dc4", "patch": "@@ -412,6 +412,7 @@ pub fn uv_error_to_io_error(uverr: UvError) -> IoError {\n             uvll::EPIPE => io::BrokenPipe,\n             uvll::ECONNABORTED => io::ConnectionAborted,\n             uvll::EADDRNOTAVAIL => io::ConnectionRefused,\n+            uvll::ECANCELED => io::TimedOut,\n             err => {\n                 uvdebug!(\"uverr.code {}\", err as int);\n                 // FIXME: Need to map remaining uv error types"}, {"sha": "cbda25485c737074439eb7b43cea7b61d76b6c45", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 71, "deletions": 18, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/158e0c86fe6c4db2d1dde8da156ce58aaf319dc4/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158e0c86fe6c4db2d1dde8da156ce58aaf319dc4/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=158e0c86fe6c4db2d1dde8da156ce58aaf319dc4", "patch": "@@ -25,6 +25,7 @@ use stream::StreamWatcher;\n use super::{Loop, Request, UvError, Buf, status_to_io_result,\n             uv_error_to_io_error, UvHandle, slice_to_uv_buf,\n             wait_until_woken_after, wakeup};\n+use timer::TimerWatcher;\n use uvio::UvIoFactory;\n use uvll;\n \n@@ -198,10 +199,14 @@ impl TcpWatcher {\n         }\n     }\n \n-    pub fn connect(io: &mut UvIoFactory, address: ip::SocketAddr)\n-        -> Result<TcpWatcher, UvError>\n-    {\n-        struct Ctx { status: c_int, task: Option<BlockedTask> }\n+    pub fn connect(io: &mut UvIoFactory,\n+                   address: ip::SocketAddr,\n+                   timeout: Option<u64>) -> Result<TcpWatcher, UvError> {\n+        struct Ctx {\n+            status: c_int,\n+            task: Option<BlockedTask>,\n+            timer: Option<~TimerWatcher>,\n+        }\n \n         let tcp = TcpWatcher::new(io);\n         let (addr, _len) = addr_to_sockaddr(address);\n@@ -215,24 +220,72 @@ impl TcpWatcher {\n         return match result {\n             0 => {\n                 req.defuse(); // uv callback now owns this request\n-                let mut cx = Ctx { status: 0, task: None };\n+                let mut cx = Ctx { status: -1, task: None, timer: None };\n+                match timeout {\n+                    Some(t) => {\n+                        let mut timer = TimerWatcher::new(io);\n+                        timer.start(timer_cb, t, 0);\n+                        cx.timer = Some(timer);\n+                    }\n+                    None => {}\n+                }\n                 wait_until_woken_after(&mut cx.task, &io.loop_, || {\n-                    req.set_data(&cx);\n+                    let data = &cx as *_;\n+                    match cx.timer {\n+                        Some(ref mut timer) => unsafe { timer.set_data(data) },\n+                        None => {}\n+                    }\n+                    req.set_data(data);\n                 });\n+                // Make sure an erroneously fired callback doesn't have access\n+                // to the context any more.\n+                req.set_data(0 as *int);\n+\n+                // If we failed because of a timeout, drop the TcpWatcher as\n+                // soon as possible because it's data is now set to null and we\n+                // want to cancel the callback ASAP.\n                 match cx.status {\n                     0 => Ok(tcp),\n-                    n => Err(UvError(n)),\n+                    n => { drop(tcp); Err(UvError(n)) }\n                 }\n             }\n             n => Err(UvError(n))\n         };\n \n+        extern fn timer_cb(handle: *uvll::uv_timer_t, status: c_int) {\n+            // Don't close the corresponding tcp request, just wake up the task\n+            // and let RAII take care of the pending watcher.\n+            assert_eq!(status, 0);\n+            let cx: &mut Ctx = unsafe {\n+                &mut *(uvll::get_data_for_uv_handle(handle) as *mut Ctx)\n+            };\n+            cx.status = uvll::ECANCELED;\n+            wakeup(&mut cx.task);\n+        }\n+\n         extern fn connect_cb(req: *uvll::uv_connect_t, status: c_int) {\n+            // This callback can be invoked with ECANCELED if the watcher is\n+            // closed by the timeout callback. In that case we just want to free\n+            // the request and be along our merry way.\n             let req = Request::wrap(req);\n-            assert!(status != uvll::ECANCELED);\n+            if status == uvll::ECANCELED { return }\n+\n             let cx: &mut Ctx = unsafe { req.get_data() };\n             cx.status = status;\n-            wakeup(&mut cx.task);\n+            match cx.timer {\n+                Some(ref mut t) => t.stop(),\n+                None => {}\n+            }\n+            // Note that the timer callback doesn't cancel the connect request\n+            // (that's the job of uv_close()), so it's possible for this\n+            // callback to get triggered after the timeout callback fires, but\n+            // before the task wakes up. In that case, we did indeed\n+            // successfully connect, but we don't need to wake someone up. We\n+            // updated the status above (correctly so), and the task will pick\n+            // up on this when it wakes up.\n+            if cx.task.is_some() {\n+                wakeup(&mut cx.task);\n+            }\n         }\n     }\n }\n@@ -741,15 +794,15 @@ mod test {\n \n     #[test]\n     fn connect_close_ip4() {\n-        match TcpWatcher::connect(local_loop(), next_test_ip4()) {\n+        match TcpWatcher::connect(local_loop(), next_test_ip4(), None) {\n             Ok(..) => fail!(),\n             Err(e) => assert_eq!(e.name(), \"ECONNREFUSED\".to_owned()),\n         }\n     }\n \n     #[test]\n     fn connect_close_ip6() {\n-        match TcpWatcher::connect(local_loop(), next_test_ip6()) {\n+        match TcpWatcher::connect(local_loop(), next_test_ip6(), None) {\n             Ok(..) => fail!(),\n             Err(e) => assert_eq!(e.name(), \"ECONNREFUSED\".to_owned()),\n         }\n@@ -799,7 +852,7 @@ mod test {\n         });\n \n         rx.recv();\n-        let mut w = match TcpWatcher::connect(local_loop(), addr) {\n+        let mut w = match TcpWatcher::connect(local_loop(), addr, None) {\n             Ok(w) => w, Err(e) => fail!(\"{:?}\", e)\n         };\n         match w.write([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) {\n@@ -835,7 +888,7 @@ mod test {\n         });\n \n         rx.recv();\n-        let mut w = match TcpWatcher::connect(local_loop(), addr) {\n+        let mut w = match TcpWatcher::connect(local_loop(), addr, None) {\n             Ok(w) => w, Err(e) => fail!(\"{:?}\", e)\n         };\n         match w.write([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) {\n@@ -928,7 +981,7 @@ mod test {\n         });\n \n         rx.recv();\n-        let mut stream = TcpWatcher::connect(local_loop(), addr).unwrap();\n+        let mut stream = TcpWatcher::connect(local_loop(), addr, None).unwrap();\n         let mut buf = [0, .. 2048];\n         let mut total_bytes_read = 0;\n         while total_bytes_read < MAX {\n@@ -1036,7 +1089,7 @@ mod test {\n \n         spawn(proc() {\n             let rx = rx.recv();\n-            let mut stream = TcpWatcher::connect(local_loop(), addr).unwrap();\n+            let mut stream = TcpWatcher::connect(local_loop(), addr, None).unwrap();\n             stream.write([0, 1, 2, 3, 4, 5, 6, 7]).unwrap();\n             stream.write([0, 1, 2, 3, 4, 5, 6, 7]).unwrap();\n             rx.recv();\n@@ -1088,9 +1141,9 @@ mod test {\n             }\n         });\n \n-        let mut stream = TcpWatcher::connect(local_loop(), addr);\n+        let mut stream = TcpWatcher::connect(local_loop(), addr, None);\n         while stream.is_err() {\n-            stream = TcpWatcher::connect(local_loop(), addr);\n+            stream = TcpWatcher::connect(local_loop(), addr, None);\n         }\n         stream.unwrap().write([0, 1, 2, 3, 4, 5, 6, 7]).unwrap();\n     }\n@@ -1115,7 +1168,7 @@ mod test {\n             drop(w.accept().unwrap());\n         });\n         rx.recv();\n-        let _w = TcpWatcher::connect(local_loop(), addr).unwrap();\n+        let _w = TcpWatcher::connect(local_loop(), addr, None).unwrap();\n         fail!();\n     }\n "}, {"sha": "3710d97827f2819fbd0ceaf4250fcdef60c494a3", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/158e0c86fe6c4db2d1dde8da156ce58aaf319dc4/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158e0c86fe6c4db2d1dde8da156ce58aaf319dc4/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=158e0c86fe6c4db2d1dde8da156ce58aaf319dc4", "patch": "@@ -48,15 +48,19 @@ impl TimerWatcher {\n         return me.install();\n     }\n \n-    fn start(&mut self, msecs: u64, period: u64) {\n+    pub fn start(&mut self, f: uvll::uv_timer_cb, msecs: u64, period: u64) {\n         assert_eq!(unsafe {\n-            uvll::uv_timer_start(self.handle, timer_cb, msecs, period)\n+            uvll::uv_timer_start(self.handle, f, msecs, period)\n         }, 0)\n     }\n \n-    fn stop(&mut self) {\n+    pub fn stop(&mut self) {\n         assert_eq!(unsafe { uvll::uv_timer_stop(self.handle) }, 0)\n     }\n+\n+    pub unsafe fn set_data<T>(&mut self, data: *T) {\n+        uvll::set_data_for_uv_handle(self.handle, data);\n+    }\n }\n \n impl HomingIO for TimerWatcher {\n@@ -92,7 +96,7 @@ impl RtioTimer for TimerWatcher {\n \n         self.action = Some(WakeTask);\n         wait_until_woken_after(&mut self.blocker, &self.uv_loop(), || {\n-            self.start(msecs, 0);\n+            self.start(timer_cb, msecs, 0);\n         });\n         self.stop();\n     }\n@@ -106,7 +110,7 @@ impl RtioTimer for TimerWatcher {\n             let _m = self.fire_homing_missile();\n             self.id += 1;\n             self.stop();\n-            self.start(msecs, 0);\n+            self.start(timer_cb, msecs, 0);\n             mem::replace(&mut self.action, Some(SendOnce(tx)))\n         };\n \n@@ -122,7 +126,7 @@ impl RtioTimer for TimerWatcher {\n             let _m = self.fire_homing_missile();\n             self.id += 1;\n             self.stop();\n-            self.start(msecs, msecs);\n+            self.start(timer_cb, msecs, msecs);\n             mem::replace(&mut self.action, Some(SendMany(tx, self.id)))\n         };\n "}, {"sha": "3769a1b8d6db42d3236f20ed64dd28137e77be88", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/158e0c86fe6c4db2d1dde8da156ce58aaf319dc4/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158e0c86fe6c4db2d1dde8da156ce58aaf319dc4/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=158e0c86fe6c4db2d1dde8da156ce58aaf319dc4", "patch": "@@ -143,10 +143,10 @@ impl IoFactory for UvIoFactory {\n     // Connect to an address and return a new stream\n     // NB: This blocks the task waiting on the connection.\n     // It would probably be better to return a future\n-    fn tcp_connect(&mut self, addr: SocketAddr)\n+    fn tcp_connect(&mut self, addr: SocketAddr, timeout: Option<u64>)\n         -> Result<~rtio::RtioTcpStream:Send, IoError>\n     {\n-        match TcpWatcher::connect(self, addr) {\n+        match TcpWatcher::connect(self, addr, timeout) {\n             Ok(t) => Ok(~t as ~rtio::RtioTcpStream:Send),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }"}, {"sha": "9c163523abef5a0091507d9a6e1482ef57cb6c54", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/158e0c86fe6c4db2d1dde8da156ce58aaf319dc4/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158e0c86fe6c4db2d1dde8da156ce58aaf319dc4/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=158e0c86fe6c4db2d1dde8da156ce58aaf319dc4", "patch": "@@ -430,6 +430,8 @@ pub enum IoErrorKind {\n     IoUnavailable,\n     /// A parameter was incorrect in a way that caused an I/O error not part of this list.\n     InvalidInput,\n+    /// The I/O operation's timeout expired, causing it to be canceled.\n+    TimedOut,\n }\n \n /// A trait for objects which are byte-oriented streams. Readers are defined by"}, {"sha": "4f1e6bd741817c4cb598985d62cf0ad7a03c92e6", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/158e0c86fe6c4db2d1dde8da156ce58aaf319dc4/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158e0c86fe6c4db2d1dde8da156ce58aaf319dc4/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=158e0c86fe6c4db2d1dde8da156ce58aaf319dc4", "patch": "@@ -22,6 +22,7 @@ use io::IoResult;\n use io::net::ip::SocketAddr;\n use io::{Reader, Writer, Listener, Acceptor};\n use kinds::Send;\n+use option::{None, Some};\n use rt::rtio::{IoFactory, LocalIo, RtioSocket, RtioTcpListener};\n use rt::rtio::{RtioTcpAcceptor, RtioTcpStream};\n \n@@ -57,7 +58,21 @@ impl TcpStream {\n     /// If no error is encountered, then `Ok(stream)` is returned.\n     pub fn connect(addr: SocketAddr) -> IoResult<TcpStream> {\n         LocalIo::maybe_raise(|io| {\n-            io.tcp_connect(addr).map(TcpStream::new)\n+            io.tcp_connect(addr, None).map(TcpStream::new)\n+        })\n+    }\n+\n+    /// Creates a TCP connection to a remote socket address, timing out after\n+    /// the specified number of milliseconds.\n+    ///\n+    /// This is the same as the `connect` method, except that if the timeout\n+    /// specified (in milliseconds) elapses before a connection is made an error\n+    /// will be returned. The error's kind will be `TimedOut`.\n+    #[experimental = \"the timeout argument may eventually change types\"]\n+    pub fn connect_timeout(addr: SocketAddr,\n+                           timeout_ms: u64) -> IoResult<TcpStream> {\n+        LocalIo::maybe_raise(|io| {\n+            io.tcp_connect(addr, Some(timeout_ms)).map(TcpStream::new)\n         })\n     }\n "}, {"sha": "0f3fc9c21ced01992793eb8e6415db317b205fb2", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/158e0c86fe6c4db2d1dde8da156ce58aaf319dc4/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158e0c86fe6c4db2d1dde8da156ce58aaf319dc4/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=158e0c86fe6c4db2d1dde8da156ce58aaf319dc4", "patch": "@@ -146,7 +146,8 @@ impl<'a> LocalIo<'a> {\n \n pub trait IoFactory {\n     // networking\n-    fn tcp_connect(&mut self, addr: SocketAddr) -> IoResult<~RtioTcpStream:Send>;\n+    fn tcp_connect(&mut self, addr: SocketAddr,\n+                   timeout: Option<u64>) -> IoResult<~RtioTcpStream:Send>;\n     fn tcp_bind(&mut self, addr: SocketAddr) -> IoResult<~RtioTcpListener:Send>;\n     fn udp_bind(&mut self, addr: SocketAddr) -> IoResult<~RtioUdpSocket:Send>;\n     fn unix_bind(&mut self, path: &CString)"}, {"sha": "26f9b2ea6b7b438895d75e8cc5ae7a274823a5ee", "filename": "src/test/run-pass/tcp-connect-timeouts.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/158e0c86fe6c4db2d1dde8da156ce58aaf319dc4/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158e0c86fe6c4db2d1dde8da156ce58aaf319dc4/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs?ref=158e0c86fe6c4db2d1dde8da156ce58aaf319dc4", "patch": "@@ -0,0 +1,92 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-pretty\n+// compile-flags:--test\n+// exec-env:RUST_TEST_TASKS=1\n+\n+// Tests for the connect_timeout() function on a TcpStream. This runs with only\n+// one test task to ensure that errors are timeouts, not file descriptor\n+// exhaustion.\n+\n+#![feature(macro_rules, globs)]\n+#![allow(experimental)]\n+\n+extern crate native;\n+extern crate green;\n+extern crate rustuv;\n+\n+#[cfg(test)] #[start]\n+fn start(argc: int, argv: **u8) -> int {\n+    green::start(argc, argv, rustuv::event_loop, __test::main)\n+}\n+\n+macro_rules! iotest (\n+    { fn $name:ident() $b:block $($a:attr)* } => (\n+        mod $name {\n+            #![allow(unused_imports)]\n+\n+            use std::io::*;\n+            use std::io::net::tcp::*;\n+            use std::io::test::*;\n+            use std::io;\n+\n+            fn f() $b\n+\n+            $($a)* #[test] fn green() { f() }\n+            $($a)* #[test] fn native() {\n+                use native;\n+                let (tx, rx) = channel();\n+                native::task::spawn(proc() { tx.send(f()) });\n+                rx.recv();\n+            }\n+        }\n+    )\n+)\n+\n+iotest!(fn eventual_timeout() {\n+    use native;\n+    let addr = next_test_ip4();\n+\n+    // Use a native task to receive connections because it turns out libuv is\n+    // really good at accepting connections and will likely run out of file\n+    // descriptors before timing out.\n+    let (tx1, rx1) = channel();\n+    let (_tx2, rx2) = channel::<()>();\n+    native::task::spawn(proc() {\n+        let _l = TcpListener::bind(addr).unwrap().listen();\n+        tx1.send(());\n+        let _ = rx2.recv_opt();\n+    });\n+    rx1.recv();\n+\n+    let mut v = Vec::new();\n+    for _ in range(0, 10000) {\n+        match TcpStream::connect_timeout(addr, 100) {\n+            Ok(e) => v.push(e),\n+            Err(ref e) if e.kind == io::TimedOut => return,\n+            Err(e) => fail!(\"other error: {}\", e),\n+        }\n+    }\n+    fail!(\"never timed out!\");\n+})\n+\n+iotest!(fn timeout_success() {\n+    let addr = next_test_ip4();\n+    let _l = TcpListener::bind(addr).unwrap().listen();\n+\n+    assert!(TcpStream::connect_timeout(addr, 1000).is_ok());\n+})\n+\n+iotest!(fn timeout_error() {\n+    let addr = next_test_ip4();\n+\n+    assert!(TcpStream::connect_timeout(addr, 1000).is_err());\n+})"}]}