{"sha": "beda82ddf1f482f286a8d9af3402626dc56d6fea", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlZGE4MmRkZjFmNDgyZjI4NmE4ZDlhZjM0MDI2MjZkYzU2ZDZmZWE=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-07T09:20:51Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-09T11:11:29Z"}, "message": "A revised, improved alias-checker\n\nThe old system tried to ensure that the location an alias pointed at\nwould retain its type. That turned out to not be strong enough in the\nface of aliases to the inside of tags.\n\nThe new system instead proves that values pointed to by aliases are\nnot replaced (or invalidated in some other way) at all. It knows of\ntwo sufficient conditions for this, and tries to prove at least of\nthem:\n\nA) The alias is 'immutably rooted' in a local, and this local is not\n   reassigned for the lifetime of the alias. Immutably rooted means\n   the alias refers to the local itself, or to something reachable\n   from the local through immutable dereferencing.\n\nB) No value whose type might include the type of the 'inner mutable\n   element' of the thing the alias refers to (for example, the box in\n   rec(mutable x = @mutable int)) is from the outer scope is accessed\n   for the lifetime of the alias. This means for functions, no other\n   argument types may include the alias's inner mutable type. For alt,\n   for each, and for, it means the body does not refer to any locals\n   originating from outside their scope that include this type.\n\nThe lifetime of an alias in an alt, for each, or for body is defined\nas the range from its definition to its last use, not to the point\nwhere it goes out of scope. This makes working around these\nrestrictions somewhat less annoying. For example, you can assign to\nyour alt-ed value you don't refer to any bindings afterwards.", "tree": {"sha": "b45a66e9755745a4991365627e142d7da90d56ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b45a66e9755745a4991365627e142d7da90d56ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/beda82ddf1f482f286a8d9af3402626dc56d6fea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/beda82ddf1f482f286a8d9af3402626dc56d6fea", "html_url": "https://github.com/rust-lang/rust/commit/beda82ddf1f482f286a8d9af3402626dc56d6fea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/beda82ddf1f482f286a8d9af3402626dc56d6fea/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43fbb071261113a87dec53c3b923d3cbf71189bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/43fbb071261113a87dec53c3b923d3cbf71189bd", "html_url": "https://github.com/rust-lang/rust/commit/43fbb071261113a87dec53c3b923d3cbf71189bd"}], "stats": {"total": 577, "additions": 423, "deletions": 154}, "files": [{"sha": "fce15a556c6fd4dcde91c3ddc7b9a9c7d751f84b", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/beda82ddf1f482f286a8d9af3402626dc56d6fea/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/beda82ddf1f482f286a8d9af3402626dc56d6fea/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=beda82ddf1f482f286a8d9af3402626dc56d6fea", "patch": "@@ -11,6 +11,10 @@ type ident = str;\n type path_ = rec(vec[ident] idents, vec[@ty] types);\n type path = spanned[path_];\n \n+fn path_name(&path p) -> str {\n+    ret str::connect(p.node.idents, \"::\");\n+}\n+\n type crate_num = int;\n const crate_num local_crate = 0;\n type def_num = int;"}, {"sha": "fa978ef53c03bc75f15971b31c0098fb2fe11587", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 394, "deletions": 149, "changes": 543, "blob_url": "https://github.com/rust-lang/rust/blob/beda82ddf1f482f286a8d9af3402626dc56d6fea/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/beda82ddf1f482f286a8d9af3402626dc56d6fea/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=beda82ddf1f482f286a8d9af3402626dc56d6fea", "patch": "@@ -1,209 +1,388 @@\n import front::ast;\n import front::ast::ident;\n-import front::ast::def_id;\n+import front::ast::def_num;\n+import util::common::span;\n+import visit::vt;\n import std::vec;\n import std::str;\n import std::option;\n import std::option::some;\n import std::option::none;\n+import std::option::is_none;\n \n-tag deref_t {\n-    field(ident);\n-    index;\n-    unbox;\n+tag valid {\n+    valid;\n+    overwritten(span, ast::path);\n+    val_taken(span, ast::path);\n }\n-type deref = rec(bool mut, deref_t t);\n \n-type ctx = @rec(@ty::ctxt tcx,\n-                resolve::def_map dm,\n-                // The current blacklisted (non-assignable) locals\n-                mutable vec[vec[def_id]] bl,\n-                // A stack of blacklists for outer function scopes\n-                mutable vec[vec[vec[def_id]]] blstack);\n+type restrict = @rec(vec[def_num] root_vars,\n+                     def_num block_defnum,\n+                     vec[def_num] bindings,\n+                     vec[ty::t] tys,\n+                     mutable valid ok);\n+\n+type scope = vec[restrict];\n+type ctx = rec(@ty::ctxt tcx,\n+               resolve::def_map dm);\n \n fn check_crate(@ty::ctxt tcx, resolve::def_map dm, &@ast::crate crate) {\n-    auto cx = @rec(tcx = tcx,\n-                   dm = dm,\n-                   mutable bl = vec::empty[vec[def_id]](),\n-                   mutable blstack = vec::empty[vec[vec[def_id]]]());\n-    auto v = rec(visit_item_pre = bind enter_item(cx, _),\n-                 visit_item_post = bind leave_item(cx, _),\n-                 visit_method_pre = bind enter_method(cx, _),\n-                 visit_method_post = bind leave_method(cx, _),\n-                 visit_expr_pre = bind check_expr(cx, _),\n-                 visit_expr_post = bind leave_expr(cx, _)\n-                 with walk::default_visitor());\n-    walk::walk_crate(v, *crate);\n-}\n-\n-fn enter_item(ctx cx, &@ast::item it) {\n-    alt (it.node) {\n-        case (ast::item_fn(_, _, _, _, _)) {\n-            vec::push(cx.blstack, cx.bl);\n-            cx.bl = [];\n-        }\n-        case (_) {}\n-    }\n-}\n-fn leave_item(ctx cx, &@ast::item it) {\n-    alt (it.node) {\n-        case (ast::item_fn(_, _, _, _, _)) {\n-            cx.bl = vec::pop(cx.blstack);\n-        }\n-        case (_) {}\n-    }\n+    auto cx = @rec(tcx = tcx, dm = dm);\n+    auto v = @rec(visit_fn = visit_fn,\n+                  visit_expr = bind visit_expr(cx, _, _, _)\n+                  with *visit::default_visitor[scope]());\n+    visit::visit_crate(*crate, [], visit::vtor(v));\n }\n \n-fn enter_method(ctx cx, &@ast::method mt) {\n-    vec::push(cx.blstack, cx.bl);\n-    cx.bl = [];\n-}\n-fn leave_method(ctx cx, &@ast::method mt) {\n-    cx.bl = vec::pop(cx.blstack);\n+fn visit_fn(&ast::_fn f, &span sp, &ident name, &ast::def_id d_id,\n+            &ast::ann a, &scope sc, &vt[scope] v) {\n+    visit::visit_fn_decl(f.decl, sc, v);\n+    vt(v).visit_block(f.body, [], v);\n }\n \n-fn check_expr(ctx cx, &@ast::expr ex) {\n+fn visit_expr(&@ctx cx, &@ast::expr ex, &scope sc, &vt[scope] v) {\n+    auto handled = false;\n     alt (ex.node) {\n         case (ast::expr_call(?f, ?args, _)) {\n-            auto fty = ty::expr_ty(*cx.tcx, f);\n-            auto argtys = alt (ty::struct(*cx.tcx, fty)) {\n-                case (ty::ty_fn(_, ?args, _, _)) { args }\n-                case (ty::ty_native_fn(_, ?args, _)) { args }\n-            };\n-            auto i = 0u;\n-            let vec[def_id] listed = [];\n-            for (ty::arg argty in argtys) {\n-                if (argty.mode != ty::mo_val) {\n-                    alt (check_rooted(cx, args.(i), false)) {\n-                        case (some(?did)) {\n-                            vec::push(listed, did);\n-                        }\n-                        case (_) {}\n-                    }\n-                }\n-                i += 1u;\n-            }\n-            // FIXME when mutable aliases can be distinguished, go over the\n-            // args again and ensure that we're not passing a blacklisted\n-            // variable by mutable alias (using 'listed' and the context\n-            // blacklist).\n+            check_call(*cx, f, args, sc);\n+        }\n+        case (ast::expr_alt(?input, ?arms, _)) {\n+            check_alt(*cx, input, arms, sc, v);\n+            handled = true;\n         }\n         case (ast::expr_put(?val, _)) {\n             alt (val) {\n-                case (some(?ex)) { check_rooted(cx, ex, false); }\n+                case (some(?ex)) {\n+                    auto root = expr_root(*cx, ex, false);\n+                    if (!is_none(root.inner_mut)) {\n+                        cx.tcx.sess.span_err\n+                            (ex.span,\n+                             \"result of put must be immutably rooted\");\n+                    }\n+                    visit_expr(cx, ex, sc, v);\n+                }\n                 case (_) {}\n             }\n+            handled = true;\n+        }\n+        case (ast::expr_for_each(?decl, ?call, ?block, _)) {\n+            check_for_each(*cx, decl, call, block, sc, v);\n+            handled = true;\n         }\n-        case (ast::expr_alt(?input, _, _)) {\n-            vec::push(cx.bl, alt (check_rooted(cx, input, true)) {\n-                case (some(?did)) { [did] }\n-                case (_) { vec::empty[def_id]() }\n-            });\n+        case (ast::expr_for(?decl, ?seq, ?block, _)) {\n+            check_for(*cx, decl, seq, block, sc, v);\n+            handled = true;\n+        }\n+\n+        case (ast::expr_path(?pt, ?ann)) {\n+            check_var(*cx, ex, pt, ann, false, sc);\n+        }\n+        case (ast::expr_move(?dest, ?src, _)) {\n+            check_assign(cx, dest, src, sc, v);\n+            handled = true;\n+        }\n+        case (ast::expr_assign(?dest, ?src, _)) {\n+            check_assign(cx, dest, src, sc, v);\n+            handled = true;\n+        }\n+        case (ast::expr_assign_op(_, ?dest, ?src, _)) {\n+            check_assign(cx, dest, src, sc, v);\n+            handled = true;\n         }\n \n-        case (ast::expr_move(?dest, _, _)) { check_assign(cx, dest); }\n-        case (ast::expr_assign(?dest, _, _)) { check_assign(cx, dest); }\n-        case (ast::expr_assign_op(_, ?dest, _, _)) { check_assign(cx, dest); }\n         case (_) {}\n     }\n+    if (!handled) { visit::visit_expr(ex, sc, v); }\n }\n \n-fn leave_expr(ctx cx, &@ast::expr ex) {\n-    alt (ex.node) {\n-        case (ast::expr_alt(_, _, _)) { vec::pop(cx.bl); }\n-        case (_) {}\n+fn check_call(&ctx cx, &@ast::expr f, &vec[@ast::expr] args, &scope sc)\n+    -> rec(vec[def_num] root_vars, vec[ty::t] unsafe_ts) {\n+    auto fty = ty::expr_ty(*cx.tcx, f);\n+    auto arg_ts = alt (ty::struct(*cx.tcx, fty)) {\n+        case (ty::ty_fn(_, ?args, _, _)) { args }\n+        case (ty::ty_native_fn(_, ?args, _)) { args }\n+    };\n+\n+    auto i = 0u;\n+    let vec[def_num] roots = [];\n+    let vec[ty::t] unsafe_ts = [];\n+    let vec[uint] unsafe_t_offsets = [];\n+    for (ty::arg arg_t in arg_ts) {\n+        if (arg_t.mode != ty::mo_val) {\n+            auto root = expr_root(cx, args.(i), false);\n+            alt (path_def_id(cx, root.ex)) {\n+                case (some(?did)) { vec::push(roots, did._1); }\n+                case (_) {}\n+            }\n+            alt (root.inner_mut) {\n+                case (some(?t)) {\n+                    vec::push(unsafe_ts, t);\n+                    vec::push(unsafe_t_offsets, i);\n+                }\n+                case (_) {}\n+            }\n+        }\n+        i += 1u;\n     }\n+\n+    if (vec::len(unsafe_ts) > 0u) {\n+        alt (f.node) {\n+            case (ast::expr_path(_, ?ann)) {\n+                if (def_is_local(cx.dm.get(ann.id))) {\n+                    cx.tcx.sess.span_err\n+                        (f.span, #fmt(\"function may alias with argument \\\n+                         %u, which is not immutably rooted\",\n+                         unsafe_t_offsets.(0)));\n+                }\n+            }\n+            case (_) {}\n+        }\n+    }\n+    auto j = 0u;\n+    for (ty::t unsafe in unsafe_ts) {\n+        auto offset = unsafe_t_offsets.(j);\n+        j += 1u;\n+        auto i = 0u;\n+        for (ty::arg arg_t in arg_ts) {\n+            if (i != offset &&\n+                // FIXME false should be replace with mutability of alias\n+                ty_can_unsafely_include(cx, unsafe, arg_t.ty, false)) {\n+                cx.tcx.sess.span_err\n+                    (args.(i).span, #fmt(\"argument %u may alias with \\\n+                     argument %u, which is not immutably rooted\", i, offset));\n+            }\n+            i += 1u;\n+        }\n+    }\n+    // FIXME when mutable aliases can be distinguished, go over the args again\n+    // and ensure that we're not passing a root variable by mutable alias\n+    // (using roots and the scope root vars).\n+\n+    ret rec(root_vars = roots, unsafe_ts = unsafe_ts);\n }\n \n-fn check_assign(&ctx cx, &@ast::expr ex) {\n-    alt (ex.node) {\n-        case (ast::expr_path(?pt, ?ann)) {\n-            auto did = ast::def_id_of_def(cx.dm.get(ann.id));\n-            for (vec[def_id] layer in cx.bl) {\n-                for (def_id black in layer) {\n-                    if (did == black) {\n-                        cx.tcx.sess.span_err\n-                            (ex.span, str::connect(pt.node.idents, \"::\") +\n-                             \" is being aliased and may not be assigned to\");\n-                    }\n+fn check_alt(&ctx cx, &@ast::expr input, &vec[ast::arm] arms,\n+             &scope sc, &vt[scope] v) {\n+    visit::visit_expr(input, sc, v);\n+    auto root = expr_root(cx, input, true);\n+    auto roots = alt (path_def_id(cx, root.ex)) {\n+        case (some(?did)) { [did._1] }\n+        case (_) { [] }\n+    };\n+    let vec[ty::t] forbidden_tp = alt (root.inner_mut) {\n+        case (some(?t)) { [t] }\n+        case (_) { [] }\n+    };\n+\n+    for (ast::arm a in arms) {\n+        auto dnums = arm_defnums(a);\n+        auto new_sc = sc;\n+        if (vec::len(dnums) > 0u) {\n+            vec::push(new_sc, @rec(root_vars=roots,\n+                                   block_defnum=dnums.(0),\n+                                   bindings=dnums,\n+                                   tys=forbidden_tp,\n+                                   mutable ok=valid));\n+        }\n+        visit::visit_arm(a, new_sc, v);\n+    }\n+}\n+\n+fn arm_defnums(&ast::arm arm) -> vec[def_num] {\n+    auto dnums = [];\n+    fn walk_pat(&mutable vec[def_num] found, &@ast::pat p) {\n+        alt (p.node) {\n+            case (ast::pat_bind(_, ?did, _)) {\n+                vec::push(found, did._1);\n+            }\n+            case (ast::pat_tag(_, ?children, _)) {\n+                for (@ast::pat child in children) {\n+                    walk_pat(found, child);\n                 }\n             }\n+            case (_) {}\n         }\n-        case (_) {}\n     }\n+    walk_pat(dnums, arm.pat);\n+    ret dnums;\n }\n \n-fn check_rooted(&ctx cx, &@ast::expr ex, bool autoderef)\n-    -> option::t[def_id] {\n-    auto root = expr_root(cx, ex, autoderef);\n-    if (has_unsafe_box(root.ds)) {\n-        cx.tcx.sess.span_err\n-            (ex.span, \"can not create alias to improperly anchored value\");\n+fn check_for_each(&ctx cx, &@ast::decl decl, &@ast::expr call,\n+                  &ast::block block, &scope sc, &vt[scope] v) {\n+    visit::visit_expr(call, sc, v);\n+    alt (call.node) {\n+        case (ast::expr_call(?f, ?args, _)) {\n+            auto data = check_call(cx, f, args, sc);\n+            auto defnum = alt (decl.node) {\n+                case (ast::decl_local(?l)) { l.id._1 }\n+            };\n+            \n+            auto new_sc = @rec(root_vars=data.root_vars,\n+                               block_defnum=defnum,\n+                               bindings=[defnum],\n+                               tys=data.unsafe_ts,\n+                               mutable ok=valid);\n+            visit::visit_block(block, sc + [new_sc], v);\n+        }\n     }\n-    alt (root.ex.node) {\n-        case (ast::expr_path(_, ?ann)) {\n-            ret some(ast::def_id_of_def(cx.dm.get(ann.id)));\n+}\n+\n+fn check_for(&ctx cx, &@ast::decl decl, &@ast::expr seq,\n+             &ast::block block, &scope sc, &vt[scope] v) {\n+    visit::visit_expr(seq, sc, v);\n+    auto defnum = alt (decl.node) {\n+        case (ast::decl_local(?l)) { l.id._1 }\n+    };\n+\n+    auto root = expr_root(cx, seq, false);\n+    auto root_def = alt (path_def_id(cx, root.ex)) {\n+        case (some(?did)) { [did._1] }\n+        case (_) { [] }\n+    };\n+    auto unsafe = alt (root.inner_mut) {\n+        case (some(?t)) { [t] }\n+        case (_) { [] }\n+    };\n+    // If this is a mutable vector, don't allow it to be touched.\n+    auto seq_t = ty::expr_ty(*cx.tcx, seq);\n+    alt (ty::struct(*cx.tcx, seq_t)) {\n+        case (ty::ty_vec(?mt)) {\n+            if (mt.mut != ast::imm) { unsafe = [seq_t]; }\n         }\n-        case (_) {\n-            ret none[def_id];\n+        case (ty::ty_str) {}\n+    }\n+\n+    auto new_sc = @rec(root_vars=root_def,\n+                       block_defnum=defnum,\n+                       bindings=[defnum],\n+                       tys=unsafe,\n+                       mutable ok=valid);\n+    visit::visit_block(block, sc + [new_sc], v);\n+}\n+\n+fn check_var(&ctx cx, &@ast::expr ex, &ast::path p, ast::ann ann, bool assign,\n+             &scope sc) {\n+    auto def = cx.dm.get(ann.id);\n+    if (!def_is_local(def)) { ret; }\n+    auto my_defnum = ast::def_id_of_def(def)._1;\n+    auto var_t = ty::expr_ty(*cx.tcx, ex);\n+    for (restrict r in sc) {\n+        // excludes variables introduced since the alias was made\n+        if (my_defnum < r.block_defnum) {\n+            for (ty::t t in r.tys) {\n+                if (ty_can_unsafely_include(cx, t, var_t, assign)) {\n+                    r.ok = val_taken(ex.span, p);\n+                }\n+            }\n+        } else if (r.ok != valid && vec::member(my_defnum, r.bindings)) {\n+            fail_alias(cx, r.ok, p);\n         }\n     }\n }\n \n-fn expr_root(&ctx cx, @ast::expr ex, bool autoderef)\n-    -> rec(@ast::expr ex, vec[deref] ds) {\n-    let vec[deref] ds = [];\n-    if (autoderef) {\n-        auto auto_unbox = maybe_auto_unbox(cx, ex);\n-        if (auto_unbox.done) {\n-            vec::push(ds, rec(mut=auto_unbox.mut, t=unbox));\n+fn fail_alias(&ctx cx, valid issue, &ast::path pt) {\n+    auto base = \" will invalidate alias \" + ast::path_name(pt) +\n+        \", which is still used\";\n+    alt (issue) {\n+        case (overwritten(?sp, ?wpt)) {\n+            cx.tcx.sess.span_err\n+                (sp, \"overwriting \" + ast::path_name(wpt) + base);\n+        }\n+        case (val_taken(?sp, ?vpt)) {\n+            cx.tcx.sess.span_err\n+                (sp, \"taking the value of \" + ast::path_name(vpt) +\n+                 base);\n+        }\n+    }\n+}\n+\n+fn check_assign(&@ctx cx, &@ast::expr dest, &@ast::expr src,\n+                &scope sc, &vt[scope] v) {\n+    visit_expr(cx, src, sc, v);\n+    alt (dest.node) {\n+        case (ast::expr_path(?p, ?ann)) {\n+            auto dnum = ast::def_id_of_def(cx.dm.get(ann.id))._1;\n+            auto var_t = ty::expr_ty(*cx.tcx, dest);\n+            for (restrict r in sc) {\n+                if (vec::member(dnum, r.root_vars)) {\n+                    r.ok = overwritten(dest.span, p);\n+                }\n+            }\n+            check_var(*cx, dest, p, ann, true, sc);\n+        }\n+        case (_) {\n+            visit_expr(cx, dest, sc, v);\n         }\n     }\n+}\n+\n+fn expr_root(&ctx cx, @ast::expr ex, bool autoderef)\n+    -> rec(@ast::expr ex, option::t[ty::t] inner_mut, bool mut_in_box) {\n+    let option::t[ty::t] mut = none;\n+    // This is not currently used but would make it possible to be more\n+    // liberal -- only stuff in a mutable box needs full type-inclusion\n+    // checking, things that aren't in a box need only be checked against\n+    // locally live aliases and their root.\n+    auto mut_in_box = false;\n     while (true) {\n         alt ({ex.node}) {\n             case (ast::expr_field(?base, ?ident, _)) {\n-                auto auto_unbox = maybe_auto_unbox(cx, base);\n-                alt (auto_unbox.t) {\n+                auto base_t = ty::expr_ty(*cx.tcx, base);\n+                auto auto_unbox = maybe_auto_unbox(cx, base_t);\n+                alt (ty::struct(*cx.tcx, auto_unbox.t)) {\n                     case (ty::ty_tup(?fields)) {\n                         auto fnm = ty::field_num(cx.tcx.sess, ex.span, ident);\n-                        auto mt = fields.(fnm).mut != ast::imm;\n-                        vec::push(ds, rec(mut=mt, t=field(ident)));\n+                        if (fields.(fnm).mut != ast::imm && is_none(mut)) {\n+                            mut = some(auto_unbox.t);\n+                        }\n                     }\n                     case (ty::ty_rec(?fields)) {\n                         for (ty::field fld in fields) {\n                             if (str::eq(ident, fld.ident)) {\n-                                auto mt = fld.mt.mut != ast::imm;\n-                                vec::push(ds, rec(mut=mt, t=field(ident)));\n+                                if (fld.mt.mut != ast::imm && is_none(mut)) {\n+                                    mut = some(auto_unbox.t);\n+                                }\n                                 break;\n                             }\n                         }\n                     }\n-                    case (ty::ty_obj(_)) {\n-                        vec::push(ds, rec(mut=false, t=field(ident)));\n-                    }\n+                    case (ty::ty_obj(_)) {}\n                 }\n                 if (auto_unbox.done) {\n-                    vec::push(ds, rec(mut=auto_unbox.mut, t=unbox));\n+                    if (!is_none(mut)) { mut_in_box = true; }\n+                    else if (auto_unbox.mut) { mut = some(base_t); }\n                 }\n                 ex = base;\n             }\n             case (ast::expr_index(?base, _, _)) {\n-                auto auto_unbox = maybe_auto_unbox(cx, base);\n-                alt (auto_unbox.t) {\n+                auto base_t = ty::expr_ty(*cx.tcx, base);\n+                auto auto_unbox = maybe_auto_unbox(cx, base_t);\n+                alt (ty::struct(*cx.tcx, auto_unbox.t)) {\n                     case (ty::ty_vec(?mt)) {\n-                        vec::push(ds, rec(mut=mt.mut != ast::imm, t=index));\n+                        if (mt.mut != ast::imm && is_none(mut)) {\n+                            mut = some(auto_unbox.t);\n+                        }\n                     }\n                 }\n                 if (auto_unbox.done) {\n-                    vec::push(ds, rec(mut=auto_unbox.mut, t=unbox));\n+                    if (!is_none(mut)) { mut_in_box = true; }\n+                    else if (auto_unbox.mut) { mut = some(base_t); }\n+                }\n+                if (auto_unbox.done && !is_none(mut)) {\n                 }\n                 ex = base;\n             }\n             case (ast::expr_unary(?op, ?base, _)) {\n                 if (op == ast::deref) {\n-                    alt (ty::struct(*cx.tcx, ty::expr_ty(*cx.tcx, base))) {\n+                    auto base_t = ty::expr_ty(*cx.tcx, base);\n+                    alt (ty::struct(*cx.tcx, base_t)) {\n                         case (ty::ty_box(?mt)) {\n-                            vec::push(ds, rec(mut=mt.mut!=ast::imm, t=unbox));\n+                            if (mt.mut != ast::imm && is_none(mut)) {\n+                                mut = some(base_t);\n+                            }\n+                            if (!is_none(mut)) {\n+                                mut_in_box = true;\n+                            }\n                         }\n                     }\n                     ex = base;\n@@ -214,34 +393,100 @@ fn expr_root(&ctx cx, @ast::expr ex, bool autoderef)\n             case (_) { break; }\n         }\n     }\n-    vec::reverse(ds);\n-    ret rec(ex = ex, ds = ds);\n+    if (autoderef) {\n+        auto ex_t = ty::expr_ty(*cx.tcx, ex);\n+        auto auto_unbox = maybe_auto_unbox(cx, ex_t);\n+        if (auto_unbox.done) {\n+            if (!is_none(mut)) { mut_in_box = true; }\n+            else if (auto_unbox.mut) { mut = some(ex_t); }\n+        }\n+    }\n+    ret rec(ex = ex, inner_mut = mut, mut_in_box = mut_in_box);\n }\n \n-fn maybe_auto_unbox(&ctx cx, &@ast::expr ex)\n-    -> rec(ty::sty t, bool done, bool mut) {\n-    auto tp = ty::struct(*cx.tcx, ty::expr_ty(*cx.tcx, ex));\n-    alt (tp) {\n+fn maybe_auto_unbox(&ctx cx, &ty::t t)\n+    -> rec(ty::t t, bool done, bool mut) {\n+    alt (ty::struct(*cx.tcx, t)) {\n         case (ty::ty_box(?mt)) {\n-            ret rec(t=ty::struct(*cx.tcx, mt.ty),\n-                    done=true, mut=mt.mut != ast::imm);\n+            ret rec(t=mt.ty, done=true, mut=mt.mut != ast::imm);\n+        }\n+        case (_) {\n+            ret rec(t=t, done=false, mut=false);\n         }\n-        case (_) { ret rec(t=tp, done=false, mut=false); }\n     }\n }\n \n-fn has_unsafe_box(&vec[deref] ds) -> bool {\n-    auto saw_mut = false;\n-    for (deref d in ds) {\n-        if (d.mut) { saw_mut = true; }\n-        if (d.t == unbox) {\n-            // Directly aliasing the content of a mutable box is never okay,\n-            // and any box living under mutable connection may be severed from\n-            // its root and freed.\n-            if (saw_mut) { ret true; }\n+fn path_def_id(&ctx cx, &@ast::expr ex) -> option::t[ast::def_id] {\n+    alt (ex.node) {\n+        case (ast::expr_path(_, ?ann)) {\n+            ret some(ast::def_id_of_def(cx.dm.get(ann.id)));\n+        }\n+        case (_) {\n+            ret none;\n         }\n     }\n-    ret false;\n+}\n+\n+fn ty_can_unsafely_include(&ctx cx, ty::t needle, ty::t haystack, bool mut)\n+    -> bool {\n+    fn get_mut(bool cur, &ty::mt mt) -> bool {\n+        ret cur || mt.mut != ast::imm;\n+    }\n+    fn helper(&ty::ctxt tcx, ty::t needle, ty::t haystack, bool mut) -> bool {\n+        if (needle == haystack) { ret true; }\n+        alt (ty::struct(tcx, haystack)) {\n+            case (ty::ty_tag(_, ?ts)) {\n+                for (ty::t t in ts) {\n+                    if (helper(tcx, needle, t, mut)) { ret true; }\n+                }\n+                ret false;\n+            }\n+            case (ty::ty_box(?mt)) {\n+                ret helper(tcx, needle, mt.ty, get_mut(mut, mt));\n+            }\n+            case (ty::ty_vec(?mt)) {\n+                ret helper(tcx, needle, mt.ty, get_mut(mut, mt));\n+            }\n+            case (ty::ty_ptr(?mt)) {\n+                ret helper(tcx, needle, mt.ty, get_mut(mut, mt));\n+            }\n+            case (ty::ty_tup(?mts)) {\n+                for (ty::mt mt in mts) {\n+                    if (helper(tcx, needle, mt.ty, get_mut(mut, mt))) {\n+                        ret true;\n+                    }\n+                }\n+                ret false;\n+            }\n+            case (ty::ty_rec(?fields)) {\n+                for (ty::field f in fields) {\n+                    if (helper(tcx, needle, f.mt.ty, get_mut(mut, f.mt))) {\n+                        ret true;\n+                    }\n+                }\n+                ret false;\n+            }\n+            // These may contain anything.\n+            case (ty::ty_fn(_, _, _, _)) { ret true; }\n+            case (ty::ty_obj(_)) { ret true; }\n+            // A type param may include everything, but can only be treated as\n+            // opaque downstream, and is thus safe unless we saw mutable\n+            // fields, in which case the whole thing can be overwritten.\n+            case (ty::ty_param(_)) { ret mut; }\n+            case (_) { ret false; }\n+        }\n+    }\n+    ret helper(*cx.tcx, needle, haystack, mut);\n+}\n+\n+fn def_is_local(&ast::def d) -> bool {\n+    ret alt (d) {\n+        case (ast::def_local(_)) { true }\n+        case (ast::def_arg(_)) { true }\n+        case (ast::def_obj_field(_)) { true }\n+        case (ast::def_binding(_)) { true }\n+        case (_) { false }\n+    };\n }\n \n // Local Variables:"}, {"sha": "1bd7307a5abf597386587fc5b461dedd6963facf", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/beda82ddf1f482f286a8d9af3402626dc56d6fea/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/beda82ddf1f482f286a8d9af3402626dc56d6fea/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=beda82ddf1f482f286a8d9af3402626dc56d6fea", "patch": "@@ -307,7 +307,7 @@ fn resolve_names(&@env e, &ast::crate c) {\n                     }\n                     case (_) {\n                         e.sess.span_err(p.span, \"not a tag variant: \" +\n-                                        str::connect(p.node.idents, \"::\"));\n+                                        ast::path_name(p));\n                     }\n                 }\n                 for (@ast::pat child in children) {"}, {"sha": "4a9551a9130f135163b273079bf22e87e74295a7", "filename": "src/test/compile-fail/unsafe-alias-2.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/beda82ddf1f482f286a8d9af3402626dc56d6fea/src%2Ftest%2Fcompile-fail%2Funsafe-alias-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/beda82ddf1f482f286a8d9af3402626dc56d6fea/src%2Ftest%2Fcompile-fail%2Funsafe-alias-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-alias-2.rs?ref=beda82ddf1f482f286a8d9af3402626dc56d6fea", "patch": "@@ -0,0 +1,15 @@\n+// error-pattern:invalidate alias x\n+\n+fn whoknows(@mutable int x) {\n+    *x = 10;\n+}\n+\n+fn main() {\n+    auto box = @mutable 1;\n+    alt (*box) {\n+        case (?x) {\n+            whoknows(box);\n+            log_err x;\n+        }\n+    }\n+}"}, {"sha": "a81b490266d84dd31c982c5b015a04837c7c6e3f", "filename": "src/test/compile-fail/unsafe-alias.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/beda82ddf1f482f286a8d9af3402626dc56d6fea/src%2Ftest%2Fcompile-fail%2Funsafe-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/beda82ddf1f482f286a8d9af3402626dc56d6fea/src%2Ftest%2Fcompile-fail%2Funsafe-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-alias.rs?ref=beda82ddf1f482f286a8d9af3402626dc56d6fea", "patch": "@@ -1,10 +1,14 @@\n-// error-pattern:can not create alias\n+// error-pattern:may alias with argument\n \n-fn foo(&int x) {\n+fn foo(&int x, fn() f) {\n     log x;\n }\n \n+fn whoknows(@mutable int x) {\n+    *x = 10;\n+}\n+\n fn main() {\n     auto box = @mutable 1;\n-    foo(*box);\n+    foo(*box, bind whoknows(box));\n }"}, {"sha": "4144e3751db0b01b2ae7352a1c51106d812eabb8", "filename": "src/test/compile-fail/unsafe-alt.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/beda82ddf1f482f286a8d9af3402626dc56d6fea/src%2Ftest%2Fcompile-fail%2Funsafe-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/beda82ddf1f482f286a8d9af3402626dc56d6fea/src%2Ftest%2Fcompile-fail%2Funsafe-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-alt.rs?ref=beda82ddf1f482f286a8d9af3402626dc56d6fea", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:x is being aliased\n+// error-pattern:invalidate alias i\n \n tag foo {\n     left(int);\n@@ -10,6 +10,7 @@ fn main() {\n     alt (x) {\n         case (left(?i)) {\n             x = right(false);\n+            log i;\n         }\n         case (_) {}\n     }"}]}