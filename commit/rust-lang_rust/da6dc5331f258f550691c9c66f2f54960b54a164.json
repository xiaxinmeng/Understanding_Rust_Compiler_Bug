{"sha": "da6dc5331f258f550691c9c66f2f54960b54a164", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhNmRjNTMzMWYyNThmNTUwNjkxYzljNjZmMmY1NDk2MGI1NGExNjQ=", "commit": {"author": {"name": "Josh Driver", "email": "keeperofdakeys@gmail.com", "date": "2017-02-23T09:48:20Z"}, "committer": {"name": "Josh Driver", "email": "keeperofdakeys@gmail.com", "date": "2017-02-23T09:58:35Z"}, "message": "Add macro suggestions for macros imported with `use`\n\nThis commit searchs modules for macro suggestions.\nIt also removes imported macro_rules from macro_names,\nand adds more corner case checks for which macros\nshould be suggested in specific contexts.", "tree": {"sha": "33171d754745742f73da7fbe366c4b9d1fe11c3b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33171d754745742f73da7fbe366c4b9d1fe11c3b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da6dc5331f258f550691c9c66f2f54960b54a164", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da6dc5331f258f550691c9c66f2f54960b54a164", "html_url": "https://github.com/rust-lang/rust/commit/da6dc5331f258f550691c9c66f2f54960b54a164", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da6dc5331f258f550691c9c66f2f54960b54a164/comments", "author": {"login": "keeperofdakeys", "id": 141626, "node_id": "MDQ6VXNlcjE0MTYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/141626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/keeperofdakeys", "html_url": "https://github.com/keeperofdakeys", "followers_url": "https://api.github.com/users/keeperofdakeys/followers", "following_url": "https://api.github.com/users/keeperofdakeys/following{/other_user}", "gists_url": "https://api.github.com/users/keeperofdakeys/gists{/gist_id}", "starred_url": "https://api.github.com/users/keeperofdakeys/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/keeperofdakeys/subscriptions", "organizations_url": "https://api.github.com/users/keeperofdakeys/orgs", "repos_url": "https://api.github.com/users/keeperofdakeys/repos", "events_url": "https://api.github.com/users/keeperofdakeys/events{/privacy}", "received_events_url": "https://api.github.com/users/keeperofdakeys/received_events", "type": "User", "site_admin": false}, "committer": {"login": "keeperofdakeys", "id": 141626, "node_id": "MDQ6VXNlcjE0MTYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/141626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/keeperofdakeys", "html_url": "https://github.com/keeperofdakeys", "followers_url": "https://api.github.com/users/keeperofdakeys/followers", "following_url": "https://api.github.com/users/keeperofdakeys/following{/other_user}", "gists_url": "https://api.github.com/users/keeperofdakeys/gists{/gist_id}", "starred_url": "https://api.github.com/users/keeperofdakeys/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/keeperofdakeys/subscriptions", "organizations_url": "https://api.github.com/users/keeperofdakeys/orgs", "repos_url": "https://api.github.com/users/keeperofdakeys/repos", "events_url": "https://api.github.com/users/keeperofdakeys/events{/privacy}", "received_events_url": "https://api.github.com/users/keeperofdakeys/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ecdc681539f05c72a2e47325e5cc917dce070b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ecdc681539f05c72a2e47325e5cc917dce070b1", "html_url": "https://github.com/rust-lang/rust/commit/4ecdc681539f05c72a2e47325e5cc917dce070b1"}], "stats": {"total": 92, "additions": 64, "deletions": 28}, "files": [{"sha": "ec02e9235beaf93b2b26fc14b3de68a0d316bc84", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da6dc5331f258f550691c9c66f2f54960b54a164/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da6dc5331f258f550691c9c66f2f54960b54a164/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=da6dc5331f258f550691c9c66f2f54960b54a164", "patch": "@@ -537,7 +537,6 @@ impl<'a> Resolver<'a> {\n                            binding: &'a NameBinding<'a>,\n                            span: Span,\n                            allow_shadowing: bool) {\n-        self.macro_names.insert(name);\n         if self.builtin_macros.insert(name, binding).is_some() && !allow_shadowing {\n             let msg = format!(\"`{}` is already in scope\", name);\n             let note ="}, {"sha": "33c5fbae62f28b20182c2a52464b4a2b9e7fbe0d", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/da6dc5331f258f550691c9c66f2f54960b54a164/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da6dc5331f258f550691c9c66f2f54960b54a164/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=da6dc5331f258f550691c9c66f2f54960b54a164", "patch": "@@ -1264,7 +1264,7 @@ impl<'a> Resolver<'a> {\n             ribs: PerNS {\n                 value_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n                 type_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n-                macro_ns: None,\n+                macro_ns: Some(vec![Rib::new(ModuleRibKind(graph_root))]),\n             },\n             label_ribs: Vec::new(),\n \n@@ -2326,8 +2326,9 @@ impl<'a> Resolver<'a> {\n                 };\n             }\n         }\n-        if primary_ns != MacroNS && path.len() == 1 &&\n-                self.macro_names.contains(&path[0].name) {\n+        let is_builtin = self.builtin_macros.get(&path[0].name).cloned()\n+            .map(|binding| binding.get_macro(self).kind() == MacroKind::Bang).unwrap_or(false);\n+        if primary_ns != MacroNS && (is_builtin || self.macro_names.contains(&path[0].name)) {\n             // Return some dummy definition, it's enough for error reporting.\n             return Some(\n                 PathResolution::new(Def::Macro(DefId::local(CRATE_DEF_INDEX), MacroKind::Bang))"}, {"sha": "a98fded59dd6473bd383d9308cbada46314c3a13", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 34, "deletions": 21, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/da6dc5331f258f550691c9c66f2f54960b54a164/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da6dc5331f258f550691c9c66f2f54960b54a164/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=da6dc5331f258f550691c9c66f2f54960b54a164", "patch": "@@ -23,7 +23,7 @@ use syntax::ast::{self, Name, Ident};\n use syntax::attr;\n use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, Determinacy, MultiModifier, MultiDecorator};\n-use syntax::ext::base::{NormalTT, Resolver as SyntaxResolver, SyntaxExtension};\n+use syntax::ext::base::{Resolver as SyntaxResolver, SyntaxExtension};\n use syntax::ext::base::MacroKind;\n use syntax::ext::expand::{Expansion, mark_tts};\n use syntax::ext::hygiene::Mark;\n@@ -152,9 +152,6 @@ impl<'a> base::Resolver for Resolver<'a> {\n     }\n \n     fn add_ext(&mut self, ident: ast::Ident, ext: Rc<SyntaxExtension>) {\n-        if let NormalTT(..) = *ext {\n-            self.macro_names.insert(ident.name);\n-        }\n         let def_id = DefId {\n             krate: BUILTIN_MACROS_CRATE,\n             index: DefIndex::new(self.macro_map.len()),\n@@ -466,24 +463,40 @@ impl<'a> Resolver<'a> {\n \n     fn suggest_macro_name(&mut self, name: &str, kind: MacroKind,\n                           err: &mut DiagnosticBuilder<'a>) {\n-        let suggestion = match kind {\n-            MacroKind::Bang =>\n-                find_best_match_for_name(self.macro_names.iter(), name, None),\n-            MacroKind::Attr |\n-            MacroKind::Derive => {\n-                // Find a suggestion from the legacy namespace.\n-                // FIXME: get_macro needs an &mut Resolver, can we do it without cloning?\n-                let builtin_macros = self.builtin_macros.clone();\n-                let names = builtin_macros.iter().filter_map(|(name, binding)| {\n-                    if binding.get_macro(self).kind() == kind {\n-                        Some(name)\n-                    } else {\n-                        None\n-                    }\n-                });\n-                find_best_match_for_name(names, name, None)\n+        // First check if this is a locally-defined bang macro.\n+        let suggestion = if let MacroKind::Bang = kind {\n+            find_best_match_for_name(self.macro_names.iter(), name, None)\n+        } else {\n+            None\n+        // Then check builtin macros.\n+        }.or_else(|| {\n+            // FIXME: get_macro needs an &mut Resolver, can we do it without cloning?\n+            let builtin_macros = self.builtin_macros.clone();\n+            let names = builtin_macros.iter().filter_map(|(name, binding)| {\n+                if binding.get_macro(self).kind() == kind {\n+                    Some(name)\n+                } else {\n+                    None\n+                }\n+            });\n+            find_best_match_for_name(names, name, None)\n+        // Then check modules.\n+        }).or_else(|| {\n+            if !self.use_extern_macros {\n+                return None;\n             }\n-        };\n+            let is_macro = |def| {\n+                if let Def::Macro(_, def_kind) = def {\n+                    def_kind == kind\n+                } else {\n+                    false\n+                }\n+            };\n+            let ident = Ident::from_str(name);\n+            self.lookup_typo_candidate(&vec![ident], MacroNS, is_macro)\n+                .as_ref().map(|s| Symbol::intern(s))\n+        });\n+\n         if let Some(suggestion) = suggestion {\n             if suggestion != name {\n                 if let MacroKind::Bang = kind {"}, {"sha": "eac0be6f84874ca8fdf9e81259ed1dc16df56848", "filename": "src/test/compile-fail-fulldeps/proc-macro/resolve-error.rs", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/da6dc5331f258f550691c9c66f2f54960b54a164/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fresolve-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da6dc5331f258f550691c9c66f2f54960b54a164/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fresolve-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fresolve-error.rs?ref=da6dc5331f258f550691c9c66f2f54960b54a164", "patch": "@@ -22,15 +22,24 @@ extern crate attr_proc_macro;\n \n use attr_proc_macro::attr_proc_macro;\n \n-#[derive(FooWithLongNam)]\n-//~^ ERROR cannot find derive macro `FooWithLongNam` in this scope\n+macro_rules! FooWithLongNam {\n+    () => {}\n+}\n+\n+#[derive(FooWithLongNan)]\n+//~^ ERROR cannot find derive macro `FooWithLongNan` in this scope\n //~^^ HELP did you mean `FooWithLongName`?\n struct Foo;\n \n #[attr_proc_macra]\n //~^ ERROR cannot find attribute macro `attr_proc_macra` in this scope\n+//~^^ HELP did you mean `attr_proc_macro`?\n struct Bar;\n \n+#[FooWithLongNan]\n+//~^ ERROR cannot find attribute macro `FooWithLongNan` in this scope\n+struct Asdf;\n+\n #[derive(Dlone)]\n //~^ ERROR cannot find derive macro `Dlone` in this scope\n //~^^ HELP did you mean `Clone`?\n@@ -41,4 +50,18 @@ struct A;\n //~^^ HELP did you mean `Clona`?\n struct B;\n \n-fn main() {}\n+#[derive(attr_proc_macra)]\n+//~^ ERROR cannot find derive macro `attr_proc_macra` in this scope\n+struct C;\n+\n+fn main() {\n+    FooWithLongNama!();\n+    //~^ ERROR cannot find macro `FooWithLongNama!` in this scope\n+    //~^^ HELP did you mean `FooWithLongNam!`?\n+\n+    attr_proc_macra!();\n+    //~^ ERROR cannot find macro `attr_proc_macra!` in this scope\n+\n+    Dlona!();\n+    //~^ ERROR cannot find macro `Dlona!` in this scope\n+}"}]}