{"sha": "30a43326d026d4b115bc400094efa0b3e13924ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwYTQzMzI2ZDAyNmQ0YjExNWJjNDAwMDk0ZWZhMGIzZTEzOTI0Y2U=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-05-02T14:50:56Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-05-20T08:44:02Z"}, "message": "apply feedback", "tree": {"sha": "3af048bdf0329086c376f5308b2a86b89f47deb7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3af048bdf0329086c376f5308b2a86b89f47deb7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30a43326d026d4b115bc400094efa0b3e13924ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30a43326d026d4b115bc400094efa0b3e13924ce", "html_url": "https://github.com/rust-lang/rust/commit/30a43326d026d4b115bc400094efa0b3e13924ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30a43326d026d4b115bc400094efa0b3e13924ce/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7afe777f79462c9023a30b31785b81e8346c96c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7afe777f79462c9023a30b31785b81e8346c96c", "html_url": "https://github.com/rust-lang/rust/commit/b7afe777f79462c9023a30b31785b81e8346c96c"}], "stats": {"total": 64, "additions": 36, "deletions": 28}, "files": [{"sha": "92e28dc35ba8be3ec38e6bfa7936e3a692997426", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 36, "deletions": 28, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/30a43326d026d4b115bc400094efa0b3e13924ce/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30a43326d026d4b115bc400094efa0b3e13924ce/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=30a43326d026d4b115bc400094efa0b3e13924ce", "patch": "@@ -471,14 +471,12 @@ pub const fn needs_drop<T>() -> bool {\n /// There is no guarantee that an all-zero byte-pattern represents a valid value of\n /// some type `T`. For example, the all-zero byte-pattern is not a valid value\n /// for reference types (`&T` and `&mut T`). Using `zeroed` on such types\n-/// causes immediate [undefined behavior][ub].\n-///\n-/// See the documentation of [`MaybeUninit<T>`] and [`MaybeUninit::zeroed()`][zeroed]\n-/// for more discussion on how to initialize values.\n+/// causes immediate [undefined behavior][ub] because [the Rust compiler assumes][inv]\n+/// that there always is a valid value in a variable it considers initialized.\n ///\n /// [zeroed]: union.MaybeUninit.html#method.zeroed\n-/// [`MaybeUninit<T>`]: union.MaybeUninit.html\n /// [ub]: ../../reference/behavior-considered-undefined.html\n+/// [inv]: union.MaybeUninit.html#initialization-invariant\n ///\n /// # Examples\n ///\n@@ -508,11 +506,21 @@ pub unsafe fn zeroed<T>() -> T {\n /// Bypasses Rust's normal memory-initialization checks by pretending to\n /// produce a value of type `T`, while doing nothing at all.\n ///\n-/// **This functon is deprecated because it basically cannot be used correctly.**\n+/// **This functon is deprecated.** Use [`MaybeUninit<T>`] instead.\n ///\n-/// Use [`MaybeUninit<T>`] instead.\n+/// The reason for deprecation is that the function basically cannot be used\n+/// correctly: [the Rust compiler assumes][inv] that values are properly initialized.\n+/// As a consequence, calling e.g. `mem::uninitialized::<bool>()` causes immediate\n+/// undefined behavior for returning a `bool` that is not definitely either `true`\n+/// or `false`. Worse, truly uninitialized memory like what gets returned here\n+/// is special in that the compiler knows that it does not have a fixed value.\n+/// This makes it undefined behavior to have uninitialized data in a variable even\n+/// if that variable has an integer type.\n+/// (Notice that the rules around uninitialized integers are not finalized yet, but\n+/// until they are, it is advisable to avoid them.)\n ///\n /// [`MaybeUninit<T>`]: union.MaybeUninit.html\n+/// [inv]: union.MaybeUninit.html#initialization-invariant\n #[inline]\n #[rustc_deprecated(since = \"1.40.0\", reason = \"use `mem::MaybeUninit` instead\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1022,21 +1030,23 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n /// use std::mem::{self, MaybeUninit};\n /// use std::ptr;\n ///\n-/// let data = unsafe {\n+/// let data = {\n ///     // Create an uninitialized array of `MaybeUninit`. The `assume_init` is\n ///     // safe because the type we are claiming to have initialized here is a\n ///     // bunch of `MaybeUninit`s, which do not require initialization.\n-///     let mut data: [MaybeUninit<Vec<u32>>; 1000] = MaybeUninit::uninit().assume_init();\n+///     let mut data: [MaybeUninit<Vec<u32>>; 1000] = unsafe {\n+///         MaybeUninit::uninit().assume_init()\n+///     };\n ///\n ///     // Dropping a `MaybeUninit` does nothing, so if there is a panic during this loop,\n ///     // we have a memory leak, but there is no memory safety issue.\n ///     for elem in &mut data[..] {\n-///         ptr::write(elem.as_mut_ptr(), vec![42]);\n+///         unsafe { ptr::write(elem.as_mut_ptr(), vec![42]); }\n ///     }\n ///\n ///     // Everything is initialized. Transmute the array to the\n ///     // initialized type.\n-///     mem::transmute::<_, [Vec<u32>; 1000]>(data)\n+///     unsafe { mem::transmute::<_, [Vec<u32>; 1000]>(data) }\n /// };\n ///\n /// println!(\"{:?}\", &data[0]);\n@@ -1049,29 +1059,27 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n /// use std::mem::MaybeUninit;\n /// use std::ptr;\n ///\n-/// unsafe {\n-///     // Create an uninitialized array of `MaybeUninit`. The `assume_init` is\n-///     // safe because the type we are claiming to have initialized here is a\n-///     // bunch of `MaybeUninit`s, which do not require initialization.\n-///     let mut data: [MaybeUninit<String>; 1000] = MaybeUninit::uninit().assume_init();\n-///     // Count the number of elements we have assigned.\n-///     let mut data_len: usize = 0;\n+/// // Create an uninitialized array of `MaybeUninit`. The `assume_init` is\n+/// // safe because the type we are claiming to have initialized here is a\n+/// // bunch of `MaybeUninit`s, which do not require initialization.\n+/// let mut data: [MaybeUninit<String>; 1000] = unsafe { MaybeUninit::uninit().assume_init() };\n+/// // Count the number of elements we have assigned.\n+/// let mut data_len: usize = 0;\n ///\n-///     for elem in &mut data[0..500] {\n-///         ptr::write(elem.as_mut_ptr(), String::from(\"hello\"));\n-///         data_len += 1;\n-///     }\n+/// for elem in &mut data[0..500] {\n+///     unsafe { ptr::write(elem.as_mut_ptr(), String::from(\"hello\")); }\n+///     data_len += 1;\n+/// }\n ///\n-///     // For each item in the array, drop if we allocated it.\n-///     for elem in &mut data[0..data_len] {\n-///         ptr::drop_in_place(elem.as_mut_ptr());\n-///     }\n+/// // For each item in the array, drop if we allocated it.\n+/// for elem in &mut data[0..data_len] {\n+///     unsafe { ptr::drop_in_place(elem.as_mut_ptr()); }\n /// }\n /// ```\n ///\n /// ## Initializing a struct field-by-field\n ///\n-/// There is unfortunately currently no supported way to create a raw pointer or reference\n+/// There is currently no supported way to create a raw pointer or reference\n /// to a field of a struct inside `MaybeUninit<Struct>`. That means it is not possible\n /// to create a struct by calling `MaybeUninit::uninit::<Struct>()` and then writing\n /// to its fields.\n@@ -1183,7 +1191,7 @@ impl<T> MaybeUninit<T> {\n     /// Gets a pointer to the contained value. Reading from this pointer or turning it\n     /// into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.\n     /// Writing to memory that this pointer (non-transitively) points to is undefined behavior\n-    /// (except inside an `UnsafeCell`).\n+    /// (except inside an `UnsafeCell<T>`).\n     ///\n     /// # Examples\n     ///"}]}