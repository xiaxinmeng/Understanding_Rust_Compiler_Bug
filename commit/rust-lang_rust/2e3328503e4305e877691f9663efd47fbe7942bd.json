{"sha": "2e3328503e4305e877691f9663efd47fbe7942bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlMzMyODUwM2U0MzA1ZTg3NzY5MWY5NjYzZWZkNDdmYmU3OTQyYmQ=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-09-05T16:41:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-09-05T16:41:27Z"}, "message": "Merge pull request #2021 from marcusklaas/needless-loop-2\n\nAdd lint to detect manual slice copies", "tree": {"sha": "226a063d5925332a1277f1ff479ebd31f4d4140c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/226a063d5925332a1277f1ff479ebd31f4d4140c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e3328503e4305e877691f9663efd47fbe7942bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e3328503e4305e877691f9663efd47fbe7942bd", "html_url": "https://github.com/rust-lang/rust/commit/2e3328503e4305e877691f9663efd47fbe7942bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e3328503e4305e877691f9663efd47fbe7942bd/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c710ac839fa27930ad5b08fe3555e3f45dfa604b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c710ac839fa27930ad5b08fe3555e3f45dfa604b", "html_url": "https://github.com/rust-lang/rust/commit/c710ac839fa27930ad5b08fe3555e3f45dfa604b"}, {"sha": "90f345df94ffa92760ce338208a034d0a3785a2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/90f345df94ffa92760ce338208a034d0a3785a2d", "html_url": "https://github.com/rust-lang/rust/commit/90f345df94ffa92760ce338208a034d0a3785a2d"}], "stats": {"total": 4922, "additions": 2596, "deletions": 2326}, "files": [{"sha": "9d5d87dc4b324d04e5848a72ea7c8fa948d49c40", "filename": "clippy_lints/src/approx_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fapprox_const.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -1,7 +1,7 @@\n use rustc::lint::*;\n use rustc::hir::*;\n use std::f64::consts as f64;\n-use syntax::ast::{Lit, LitKind, FloatTy};\n+use syntax::ast::{FloatTy, Lit, LitKind};\n use syntax::symbol;\n use utils::span_lint;\n \n@@ -91,7 +91,7 @@ fn check_known_consts(cx: &LateContext, e: &Expr, s: &symbol::Symbol, module: &s\n                     e.span,\n                     &format!(\n                         \"approximate value of `{}::consts::{}` found. \\\n-                                    Consider using it directly\",\n+                         Consider using it directly\",\n                         module,\n                         &name\n                     ),"}, {"sha": "a551ebf046bd41c325bd60a9ade9454dedb54a2e", "filename": "clippy_lints/src/arithmetic.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farithmetic.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -55,8 +55,19 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Arithmetic {\n         match expr.node {\n             hir::ExprBinary(ref op, ref l, ref r) => {\n                 match op.node {\n-                    hir::BiAnd | hir::BiOr | hir::BiBitAnd | hir::BiBitOr | hir::BiBitXor | hir::BiShl |\n-                    hir::BiShr | hir::BiEq | hir::BiLt | hir::BiLe | hir::BiNe | hir::BiGe | hir::BiGt => return,\n+                    hir::BiAnd |\n+                    hir::BiOr |\n+                    hir::BiBitAnd |\n+                    hir::BiBitOr |\n+                    hir::BiBitXor |\n+                    hir::BiShl |\n+                    hir::BiShr |\n+                    hir::BiEq |\n+                    hir::BiLt |\n+                    hir::BiLe |\n+                    hir::BiNe |\n+                    hir::BiGe |\n+                    hir::BiGt => return,\n                     _ => (),\n                 }\n                 let (l_ty, r_ty) = (cx.tables.expr_ty(l), cx.tables.expr_ty(r));"}, {"sha": "5815f6456864a7626d328aed4ee1027036b79a8c", "filename": "clippy_lints/src/array_indexing.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Farray_indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Farray_indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farray_indexing.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -3,7 +3,7 @@ use rustc::middle::const_val::ConstVal;\n use rustc::ty;\n use rustc::ty::subst::Substs;\n use rustc_const_eval::ConstContext;\n-use rustc_const_math::{ConstUsize, ConstIsize, ConstInt};\n+use rustc_const_math::{ConstInt, ConstIsize, ConstUsize};\n use rustc::hir;\n use syntax::ast::RangeLimits;\n use utils::{self, higher};\n@@ -124,29 +124,27 @@ fn to_const_range(\n     };\n \n     let end = match *end {\n-        Some(Some(ConstVal::Integral(x))) => {\n-            if limits == RangeLimits::Closed {\n-                match x {\n-                    ConstInt::U8(_) => (x + ConstInt::U8(1)),\n-                    ConstInt::U16(_) => (x + ConstInt::U16(1)),\n-                    ConstInt::U32(_) => (x + ConstInt::U32(1)),\n-                    ConstInt::U64(_) => (x + ConstInt::U64(1)),\n-                    ConstInt::U128(_) => (x + ConstInt::U128(1)),\n-                    ConstInt::Usize(ConstUsize::Us16(_)) => (x + ConstInt::Usize(ConstUsize::Us16(1))),\n-                    ConstInt::Usize(ConstUsize::Us32(_)) => (x + ConstInt::Usize(ConstUsize::Us32(1))),\n-                    ConstInt::Usize(ConstUsize::Us64(_)) => (x + ConstInt::Usize(ConstUsize::Us64(1))),\n-                    ConstInt::I8(_) => (x + ConstInt::I8(1)),\n-                    ConstInt::I16(_) => (x + ConstInt::I16(1)),\n-                    ConstInt::I32(_) => (x + ConstInt::I32(1)),\n-                    ConstInt::I64(_) => (x + ConstInt::I64(1)),\n-                    ConstInt::I128(_) => (x + ConstInt::I128(1)),\n-                    ConstInt::Isize(ConstIsize::Is16(_)) => (x + ConstInt::Isize(ConstIsize::Is16(1))),\n-                    ConstInt::Isize(ConstIsize::Is32(_)) => (x + ConstInt::Isize(ConstIsize::Is32(1))),\n-                    ConstInt::Isize(ConstIsize::Is64(_)) => (x + ConstInt::Isize(ConstIsize::Is64(1))),\n-                }.expect(\"such a big array is not realistic\")\n-            } else {\n-                x\n-            }\n+        Some(Some(ConstVal::Integral(x))) => if limits == RangeLimits::Closed {\n+            match x {\n+                ConstInt::U8(_) => (x + ConstInt::U8(1)),\n+                ConstInt::U16(_) => (x + ConstInt::U16(1)),\n+                ConstInt::U32(_) => (x + ConstInt::U32(1)),\n+                ConstInt::U64(_) => (x + ConstInt::U64(1)),\n+                ConstInt::U128(_) => (x + ConstInt::U128(1)),\n+                ConstInt::Usize(ConstUsize::Us16(_)) => (x + ConstInt::Usize(ConstUsize::Us16(1))),\n+                ConstInt::Usize(ConstUsize::Us32(_)) => (x + ConstInt::Usize(ConstUsize::Us32(1))),\n+                ConstInt::Usize(ConstUsize::Us64(_)) => (x + ConstInt::Usize(ConstUsize::Us64(1))),\n+                ConstInt::I8(_) => (x + ConstInt::I8(1)),\n+                ConstInt::I16(_) => (x + ConstInt::I16(1)),\n+                ConstInt::I32(_) => (x + ConstInt::I32(1)),\n+                ConstInt::I64(_) => (x + ConstInt::I64(1)),\n+                ConstInt::I128(_) => (x + ConstInt::I128(1)),\n+                ConstInt::Isize(ConstIsize::Is16(_)) => (x + ConstInt::Isize(ConstIsize::Is16(1))),\n+                ConstInt::Isize(ConstIsize::Is32(_)) => (x + ConstInt::Isize(ConstIsize::Is32(1))),\n+                ConstInt::Isize(ConstIsize::Is64(_)) => (x + ConstInt::Isize(ConstIsize::Is64(1))),\n+            }.expect(\"such a big array is not realistic\")\n+        } else {\n+            x\n         },\n         Some(_) => return None,\n         None => array_size,"}, {"sha": "33a1d94f420fd0fab4e7fc5200067099de7567df", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -1,7 +1,7 @@\n use rustc::hir;\n use rustc::lint::*;\n use syntax::ast;\n-use utils::{span_lint_and_then, snippet_opt, SpanlessEq, get_trait_def_id, implements_trait};\n+use utils::{get_trait_def_id, implements_trait, snippet_opt, span_lint_and_then, SpanlessEq};\n use utils::{higher, sugg};\n \n /// **What it does:** Checks for compound assignment operations (`+=` and\n@@ -88,19 +88,21 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                 if let hir::ExprBinary(binop, ref l, ref r) = rhs.node {\n                     if op.node == binop.node {\n                         let lint = |assignee: &hir::Expr, rhs: &hir::Expr| {\n-                            span_lint_and_then(cx,\n-                                               MISREFACTORED_ASSIGN_OP,\n-                                               expr.span,\n-                                               \"variable appears on both sides of an assignment operation\",\n-                                               |db| if let (Some(snip_a), Some(snip_r)) =\n-                                                   (snippet_opt(cx, assignee.span), snippet_opt(cx, rhs.span)) {\n-                                                   db.span_suggestion(expr.span,\n-                                                                      \"replace it with\",\n-                                                                      format!(\"{} {}= {}\",\n-                                                                              snip_a,\n-                                                                              op.node.as_str(),\n-                                                                              snip_r));\n-                                               });\n+                            span_lint_and_then(\n+                                cx,\n+                                MISREFACTORED_ASSIGN_OP,\n+                                expr.span,\n+                                \"variable appears on both sides of an assignment operation\",\n+                                |db| if let (Some(snip_a), Some(snip_r)) =\n+                                    (snippet_opt(cx, assignee.span), snippet_opt(cx, rhs.span))\n+                                {\n+                                    db.span_suggestion(\n+                                        expr.span,\n+                                        \"replace it with\",\n+                                        format!(\"{} {}= {}\", snip_a, op.node.as_str(), snip_r),\n+                                    );\n+                                },\n+                            );\n                         };\n                         // lhs op= l op r\n                         if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, l) {\n@@ -167,8 +169,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                             BitXor: BiBitXor,\n                             Shr: BiShr,\n                             Shl: BiShl\n-                        )\n-                        {\n+                        ) {\n                             span_lint_and_then(\n                                 cx,\n                                 ASSIGN_OP_PATTERN,\n@@ -193,7 +194,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                     // a = b commutative_op a\n                     if SpanlessEq::new(cx).ignore_fn().eq_expr(assignee, r) {\n                         match op.node {\n-                            hir::BiAdd | hir::BiMul | hir::BiAnd | hir::BiOr | hir::BiBitXor | hir::BiBitAnd |\n+                            hir::BiAdd |\n+                            hir::BiMul |\n+                            hir::BiAnd |\n+                            hir::BiOr |\n+                            hir::BiBitXor |\n+                            hir::BiBitAnd |\n                             hir::BiBitOr => {\n                                 lint(assignee, l);\n                             },"}, {"sha": "12339c039d960583b8fe9eb04d6c2dfc28ada72d", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -7,7 +7,7 @@ use rustc::ty::{self, TyCtxt};\n use semver::Version;\n use syntax::ast::{Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n use syntax::codemap::Span;\n-use utils::{in_macro, match_def_path, paths, span_lint, span_lint_and_then, snippet_opt};\n+use utils::{in_macro, match_def_path, paths, snippet_opt, span_lint, span_lint_and_then};\n \n /// **What it does:** Checks for items annotated with `#[inline(always)]`,\n /// unless the annotated function is empty or simply panics.\n@@ -110,8 +110,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n             check_attrs(cx, item.span, &item.name, &item.attrs)\n         }\n         match item.node {\n-            ItemExternCrate(_) |\n-            ItemUse(_, _) => {\n+            ItemExternCrate(_) | ItemUse(_, _) => {\n                 for attr in &item.attrs {\n                     if let Some(ref lint_list) = attr.meta_item_list() {\n                         if let Some(name) = attr.name() {\n@@ -196,30 +195,26 @@ fn is_relevant_block(tcx: TyCtxt, tables: &ty::TypeckTables, block: &Block) -> b\n     if let Some(stmt) = block.stmts.first() {\n         match stmt.node {\n             StmtDecl(_, _) => true,\n-            StmtExpr(ref expr, _) |\n-            StmtSemi(ref expr, _) => is_relevant_expr(tcx, tables, expr),\n+            StmtExpr(ref expr, _) | StmtSemi(ref expr, _) => is_relevant_expr(tcx, tables, expr),\n         }\n     } else {\n-        block.expr.as_ref().map_or(\n-            false,\n-            |e| is_relevant_expr(tcx, tables, e),\n-        )\n+        block\n+            .expr\n+            .as_ref()\n+            .map_or(false, |e| is_relevant_expr(tcx, tables, e))\n     }\n }\n \n fn is_relevant_expr(tcx: TyCtxt, tables: &ty::TypeckTables, expr: &Expr) -> bool {\n     match expr.node {\n         ExprBlock(ref block) => is_relevant_block(tcx, tables, block),\n         ExprRet(Some(ref e)) => is_relevant_expr(tcx, tables, e),\n-        ExprRet(None) |\n-        ExprBreak(_, None) => false,\n-        ExprCall(ref path_expr, _) => {\n-            if let ExprPath(ref qpath) = path_expr.node {\n-                let fun_id = tables.qpath_def(qpath, path_expr.hir_id).def_id();\n-                !match_def_path(tcx, fun_id, &paths::BEGIN_PANIC)\n-            } else {\n-                true\n-            }\n+        ExprRet(None) | ExprBreak(_, None) => false,\n+        ExprCall(ref path_expr, _) => if let ExprPath(ref qpath) = path_expr.node {\n+            let fun_id = tables.qpath_def(qpath, path_expr.hir_id).def_id();\n+            !match_def_path(tcx, fun_id, &paths::BEGIN_PANIC)\n+        } else {\n+            true\n         },\n         _ => true,\n     }"}, {"sha": "ecb12b60a16db35f7ea989c81ff5729f9936e3a8", "filename": "clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 92, "deletions": 110, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbit_mask.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -158,118 +158,100 @@ fn check_compare(cx: &LateContext, bit_op: &Expr, cmp_op: BinOp_, cmp_value: u12\n \n fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value: u128, cmp_value: u128, span: &Span) {\n     match cmp_op {\n-        BiEq | BiNe => {\n-            match bit_op {\n-                BiBitAnd => {\n-                    if mask_value & cmp_value != cmp_value {\n-                        if cmp_value != 0 {\n-                            span_lint(\n-                                cx,\n-                                BAD_BIT_MASK,\n-                                *span,\n-                                &format!(\n-                                    \"incompatible bit mask: `_ & {}` can never be equal to `{}`\",\n-                                    mask_value,\n-                                    cmp_value\n-                                ),\n-                            );\n-                        }\n-                    } else if mask_value == 0 {\n-                        span_lint(cx, BAD_BIT_MASK, *span, \"&-masking with zero\");\n-                    }\n-                },\n-                BiBitOr => {\n-                    if mask_value | cmp_value != cmp_value {\n-                        span_lint(\n-                            cx,\n-                            BAD_BIT_MASK,\n-                            *span,\n-                            &format!(\n-                                \"incompatible bit mask: `_ | {}` can never be equal to `{}`\",\n-                                mask_value,\n-                                cmp_value\n-                            ),\n-                        );\n-                    }\n-                },\n-                _ => (),\n-            }\n+        BiEq | BiNe => match bit_op {\n+            BiBitAnd => if mask_value & cmp_value != cmp_value {\n+                if cmp_value != 0 {\n+                    span_lint(\n+                        cx,\n+                        BAD_BIT_MASK,\n+                        *span,\n+                        &format!(\n+                            \"incompatible bit mask: `_ & {}` can never be equal to `{}`\",\n+                            mask_value,\n+                            cmp_value\n+                        ),\n+                    );\n+                }\n+            } else if mask_value == 0 {\n+                span_lint(cx, BAD_BIT_MASK, *span, \"&-masking with zero\");\n+            },\n+            BiBitOr => if mask_value | cmp_value != cmp_value {\n+                span_lint(\n+                    cx,\n+                    BAD_BIT_MASK,\n+                    *span,\n+                    &format!(\n+                        \"incompatible bit mask: `_ | {}` can never be equal to `{}`\",\n+                        mask_value,\n+                        cmp_value\n+                    ),\n+                );\n+            },\n+            _ => (),\n         },\n-        BiLt | BiGe => {\n-            match bit_op {\n-                BiBitAnd => {\n-                    if mask_value < cmp_value {\n-                        span_lint(\n-                            cx,\n-                            BAD_BIT_MASK,\n-                            *span,\n-                            &format!(\n-                                \"incompatible bit mask: `_ & {}` will always be lower than `{}`\",\n-                                mask_value,\n-                                cmp_value\n-                            ),\n-                        );\n-                    } else if mask_value == 0 {\n-                        span_lint(cx, BAD_BIT_MASK, *span, \"&-masking with zero\");\n-                    }\n-                },\n-                BiBitOr => {\n-                    if mask_value >= cmp_value {\n-                        span_lint(\n-                            cx,\n-                            BAD_BIT_MASK,\n-                            *span,\n-                            &format!(\n-                                \"incompatible bit mask: `_ | {}` will never be lower than `{}`\",\n-                                mask_value,\n-                                cmp_value\n-                            ),\n-                        );\n-                    } else {\n-                        check_ineffective_lt(cx, *span, mask_value, cmp_value, \"|\");\n-                    }\n-                },\n-                BiBitXor => check_ineffective_lt(cx, *span, mask_value, cmp_value, \"^\"),\n-                _ => (),\n-            }\n+        BiLt | BiGe => match bit_op {\n+            BiBitAnd => if mask_value < cmp_value {\n+                span_lint(\n+                    cx,\n+                    BAD_BIT_MASK,\n+                    *span,\n+                    &format!(\n+                        \"incompatible bit mask: `_ & {}` will always be lower than `{}`\",\n+                        mask_value,\n+                        cmp_value\n+                    ),\n+                );\n+            } else if mask_value == 0 {\n+                span_lint(cx, BAD_BIT_MASK, *span, \"&-masking with zero\");\n+            },\n+            BiBitOr => if mask_value >= cmp_value {\n+                span_lint(\n+                    cx,\n+                    BAD_BIT_MASK,\n+                    *span,\n+                    &format!(\n+                        \"incompatible bit mask: `_ | {}` will never be lower than `{}`\",\n+                        mask_value,\n+                        cmp_value\n+                    ),\n+                );\n+            } else {\n+                check_ineffective_lt(cx, *span, mask_value, cmp_value, \"|\");\n+            },\n+            BiBitXor => check_ineffective_lt(cx, *span, mask_value, cmp_value, \"^\"),\n+            _ => (),\n         },\n-        BiLe | BiGt => {\n-            match bit_op {\n-                BiBitAnd => {\n-                    if mask_value <= cmp_value {\n-                        span_lint(\n-                            cx,\n-                            BAD_BIT_MASK,\n-                            *span,\n-                            &format!(\n-                                \"incompatible bit mask: `_ & {}` will never be higher than `{}`\",\n-                                mask_value,\n-                                cmp_value\n-                            ),\n-                        );\n-                    } else if mask_value == 0 {\n-                        span_lint(cx, BAD_BIT_MASK, *span, \"&-masking with zero\");\n-                    }\n-                },\n-                BiBitOr => {\n-                    if mask_value > cmp_value {\n-                        span_lint(\n-                            cx,\n-                            BAD_BIT_MASK,\n-                            *span,\n-                            &format!(\n-                                \"incompatible bit mask: `_ | {}` will always be higher than `{}`\",\n-                                mask_value,\n-                                cmp_value\n-                            ),\n-                        );\n-                    } else {\n-                        check_ineffective_gt(cx, *span, mask_value, cmp_value, \"|\");\n-                    }\n-                },\n-                BiBitXor => check_ineffective_gt(cx, *span, mask_value, cmp_value, \"^\"),\n-                _ => (),\n-            }\n+        BiLe | BiGt => match bit_op {\n+            BiBitAnd => if mask_value <= cmp_value {\n+                span_lint(\n+                    cx,\n+                    BAD_BIT_MASK,\n+                    *span,\n+                    &format!(\n+                        \"incompatible bit mask: `_ & {}` will never be higher than `{}`\",\n+                        mask_value,\n+                        cmp_value\n+                    ),\n+                );\n+            } else if mask_value == 0 {\n+                span_lint(cx, BAD_BIT_MASK, *span, \"&-masking with zero\");\n+            },\n+            BiBitOr => if mask_value > cmp_value {\n+                span_lint(\n+                    cx,\n+                    BAD_BIT_MASK,\n+                    *span,\n+                    &format!(\n+                        \"incompatible bit mask: `_ | {}` will always be higher than `{}`\",\n+                        mask_value,\n+                        cmp_value\n+                    ),\n+                );\n+            } else {\n+                check_ineffective_gt(cx, *span, mask_value, cmp_value, \"|\");\n+            },\n+            BiBitXor => check_ineffective_gt(cx, *span, mask_value, cmp_value, \"^\"),\n+            _ => (),\n         },\n         _ => (),\n     }"}, {"sha": "114ba5fa7821ffc47fe6090a17f21d1c968bf6b5", "filename": "clippy_lints/src/blacklisted_name.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblacklisted_name.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -27,7 +27,9 @@ pub struct BlackListedName {\n \n impl BlackListedName {\n     pub fn new(blacklist: Vec<String>) -> Self {\n-        Self { blacklist: blacklist }\n+        Self {\n+            blacklist: blacklist,\n+        }\n     }\n }\n "}, {"sha": "d67a1a5394e9db935140988ebf2f972b97b3686c", "filename": "clippy_lints/src/block_in_if_condition.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -1,6 +1,6 @@\n-use rustc::lint::{LateLintPass, LateContext, LintArray, LintPass};\n+use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::hir::*;\n-use rustc::hir::intravisit::{Visitor, walk_expr, NestedVisitorMap};\n+use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use utils::*;\n \n /// **What it does:** Checks for `if` conditions that use blocks to contain an\n@@ -93,15 +93,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlockInIfCondition {\n                                 check.span,\n                                 BRACED_EXPR_MESSAGE,\n                                 &format!(\"try\\nif {} {} ... \",\n-                                                        snippet_block(cx, ex.span, \"..\"),\n-                                                        snippet_block(cx, then.span, \"..\")),\n+                                snippet_block(cx, ex.span, \"..\"),\n+                                snippet_block(cx, then.span, \"..\")),\n                             );\n                         }\n                     } else {\n-                        let span = block.expr.as_ref().map_or_else(\n-                            || block.stmts[0].span,\n-                            |e| e.span,\n-                        );\n+                        let span = block\n+                            .expr\n+                            .as_ref()\n+                            .map_or_else(|| block.stmts[0].span, |e| e.span);\n                         if in_macro(span) || differing_macro_contexts(expr.span, span) {\n                             return;\n                         }\n@@ -112,8 +112,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlockInIfCondition {\n                             check.span,\n                             COMPLEX_BLOCK_MESSAGE,\n                             &format!(\"try\\nlet res = {};\\nif res {} ... \",\n-                                                    snippet_block(cx, block.span, \"..\"),\n-                                                    snippet_block(cx, then.span, \"..\")),\n+                            snippet_block(cx, block.span, \"..\"),\n+                            snippet_block(cx, then.span, \"..\")),\n                         );\n                     }\n                 }"}, {"sha": "2587937616c8ea332045b076c6ec3f1608a39913", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 52, "deletions": 60, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -1,10 +1,10 @@\n-use rustc::lint::{LintArray, LateLintPass, LateContext, LintPass};\n+use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::hir::*;\n use rustc::hir::intravisit::*;\n-use syntax::ast::{LitKind, DUMMY_NODE_ID, NodeId};\n-use syntax::codemap::{DUMMY_SP, dummy_spanned, Span};\n+use syntax::ast::{LitKind, NodeId, DUMMY_NODE_ID};\n+use syntax::codemap::{dummy_spanned, Span, DUMMY_SP};\n use syntax::util::ThinVec;\n-use utils::{span_lint_and_then, in_macro, snippet_opt, SpanlessEq};\n+use utils::{in_macro, snippet_opt, span_lint_and_then, SpanlessEq};\n \n /// **What it does:** Checks for boolean expressions that can be written more\n /// concisely.\n@@ -96,26 +96,23 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n         if !in_macro(e.span) {\n             match e.node {\n                 ExprUnary(UnNot, ref inner) => return Ok(Bool::Not(box self.run(inner)?)),\n-                ExprBinary(binop, ref lhs, ref rhs) => {\n-                    match binop.node {\n-                        BiOr => return Ok(Bool::Or(self.extract(BiOr, &[lhs, rhs], Vec::new())?)),\n-                        BiAnd => return Ok(Bool::And(self.extract(BiAnd, &[lhs, rhs], Vec::new())?)),\n-                        _ => (),\n-                    }\n+                ExprBinary(binop, ref lhs, ref rhs) => match binop.node {\n+                    BiOr => return Ok(Bool::Or(self.extract(BiOr, &[lhs, rhs], Vec::new())?)),\n+                    BiAnd => return Ok(Bool::And(self.extract(BiAnd, &[lhs, rhs], Vec::new())?)),\n+                    _ => (),\n                 },\n-                ExprLit(ref lit) => {\n-                    match lit.node {\n-                        LitKind::Bool(true) => return Ok(Bool::True),\n-                        LitKind::Bool(false) => return Ok(Bool::False),\n-                        _ => (),\n-                    }\n+                ExprLit(ref lit) => match lit.node {\n+                    LitKind::Bool(true) => return Ok(Bool::True),\n+                    LitKind::Bool(false) => return Ok(Bool::False),\n+                    _ => (),\n                 },\n                 _ => (),\n             }\n         }\n         for (n, expr) in self.terminals.iter().enumerate() {\n             if SpanlessEq::new(self.cx).ignore_fn().eq_expr(e, expr) {\n-                #[allow(cast_possible_truncation)] return Ok(Bool::Term(n as u8));\n+                #[allow(cast_possible_truncation)]\n+                return Ok(Bool::Term(n as u8));\n             }\n             let negated = match e.node {\n                 ExprBinary(binop, ref lhs, ref rhs) => {\n@@ -141,13 +138,15 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n                 _ => continue,\n             };\n             if SpanlessEq::new(self.cx).ignore_fn().eq_expr(&negated, expr) {\n-                #[allow(cast_possible_truncation)] return Ok(Bool::Not(Box::new(Bool::Term(n as u8))));\n+                #[allow(cast_possible_truncation)]\n+                return Ok(Bool::Not(Box::new(Bool::Term(n as u8))));\n             }\n         }\n         let n = self.terminals.len();\n         self.terminals.push(e);\n         if n < 32 {\n-            #[allow(cast_possible_truncation)] Ok(Bool::Term(n as u8))\n+            #[allow(cast_possible_truncation)]\n+            Ok(Bool::Term(n as u8))\n         } else {\n             Err(\"too many literals\".to_owned())\n         }\n@@ -167,40 +166,36 @@ fn suggest(cx: &LateContext, suggestion: &Bool, terminals: &[&Expr]) -> String {\n                 s.push_str(\"false\");\n                 s\n             },\n-            Not(ref inner) => {\n-                match **inner {\n-                    And(_) | Or(_) => {\n-                        s.push('!');\n-                        recurse(true, cx, inner, terminals, s)\n-                    },\n-                    Term(n) => {\n-                        if let ExprBinary(binop, ref lhs, ref rhs) = terminals[n as usize].node {\n-                            let op = match binop.node {\n-                                BiEq => \" != \",\n-                                BiNe => \" == \",\n-                                BiLt => \" >= \",\n-                                BiGt => \" <= \",\n-                                BiLe => \" > \",\n-                                BiGe => \" < \",\n-                                _ => {\n-                                    s.push('!');\n-                                    return recurse(true, cx, inner, terminals, s);\n-                                },\n-                            };\n-                            s.push_str(&snip(lhs));\n-                            s.push_str(op);\n-                            s.push_str(&snip(rhs));\n-                            s\n-                        } else {\n+            Not(ref inner) => match **inner {\n+                And(_) | Or(_) => {\n+                    s.push('!');\n+                    recurse(true, cx, inner, terminals, s)\n+                },\n+                Term(n) => if let ExprBinary(binop, ref lhs, ref rhs) = terminals[n as usize].node {\n+                    let op = match binop.node {\n+                        BiEq => \" != \",\n+                        BiNe => \" == \",\n+                        BiLt => \" >= \",\n+                        BiGt => \" <= \",\n+                        BiLe => \" > \",\n+                        BiGe => \" < \",\n+                        _ => {\n                             s.push('!');\n-                            recurse(false, cx, inner, terminals, s)\n-                        }\n-                    },\n-                    _ => {\n-                        s.push('!');\n-                        recurse(false, cx, inner, terminals, s)\n-                    },\n-                }\n+                            return recurse(true, cx, inner, terminals, s);\n+                        },\n+                    };\n+                    s.push_str(&snip(lhs));\n+                    s.push_str(op);\n+                    s.push_str(&snip(rhs));\n+                    s\n+                } else {\n+                    s.push('!');\n+                    recurse(false, cx, inner, terminals, s)\n+                },\n+                _ => {\n+                    s.push('!');\n+                    recurse(false, cx, inner, terminals, s)\n+                },\n             },\n             And(ref v) => {\n                 if brackets {\n@@ -319,7 +314,6 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n             cx: self.cx,\n         };\n         if let Ok(expr) = h2q.run(e) {\n-\n             if h2q.terminals.len() > 8 {\n                 // QMC has exponentially slow behavior as the number of terminals increases\n                 // 8 is reasonable, it takes approximately 0.2 seconds.\n@@ -360,7 +354,7 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n                                 db.span_help(\n                                     h2q.terminals[i].span,\n                                     \"this expression can be optimized out by applying boolean operations to the \\\n-                                          outer expression\",\n+                                     outer expression\",\n                                 );\n                                 db.span_suggestion(\n                                     e.span,\n@@ -411,12 +405,10 @@ impl<'a, 'tcx> Visitor<'tcx> for NonminimalBoolVisitor<'a, 'tcx> {\n         }\n         match e.node {\n             ExprBinary(binop, _, _) if binop.node == BiOr || binop.node == BiAnd => self.bool_expr(e),\n-            ExprUnary(UnNot, ref inner) => {\n-                if self.cx.tables.node_types()[inner.hir_id].is_bool() {\n-                    self.bool_expr(e);\n-                } else {\n-                    walk_expr(self, e);\n-                }\n+            ExprUnary(UnNot, ref inner) => if self.cx.tables.node_types()[inner.hir_id].is_bool() {\n+                self.bool_expr(e);\n+            } else {\n+                walk_expr(self, e);\n             },\n             _ => walk_expr(self, e),\n         }"}, {"sha": "447214c70f886dac6dc2b45a6d62bdcbb703cf0c", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -97,23 +97,18 @@ fn get_pat_name(pat: &Pat) -> Option<Name> {\n     match pat.node {\n         PatKind::Binding(_, _, ref spname, _) => Some(spname.node),\n         PatKind::Path(ref qpath) => single_segment_path(qpath).map(|ps| ps.name),\n-        PatKind::Box(ref p) |\n-        PatKind::Ref(ref p, _) => get_pat_name(&*p),\n+        PatKind::Box(ref p) | PatKind::Ref(ref p, _) => get_pat_name(&*p),\n         _ => None,\n     }\n }\n \n fn get_path_name(expr: &Expr) -> Option<Name> {\n     match expr.node {\n-        ExprBox(ref e) |\n-        ExprAddrOf(_, ref e) |\n-        ExprUnary(UnOp::UnDeref, ref e) => get_path_name(e),\n-        ExprBlock(ref b) => {\n-            if b.stmts.is_empty() {\n-                b.expr.as_ref().and_then(|p| get_path_name(p))\n-            } else {\n-                None\n-            }\n+        ExprBox(ref e) | ExprAddrOf(_, ref e) | ExprUnary(UnOp::UnDeref, ref e) => get_path_name(e),\n+        ExprBlock(ref b) => if b.stmts.is_empty() {\n+            b.expr.as_ref().and_then(|p| get_path_name(p))\n+        } else {\n+            None\n         },\n         ExprPath(ref qpath) => single_segment_path(qpath).map(|ps| ps.name),\n         _ => None,"}, {"sha": "fb0ff23cc632d60354be20798e4d0ca98468d0b0", "filename": "clippy_lints/src/collapsible_if.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_if.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -15,7 +15,7 @@\n use rustc::lint::*;\n use syntax::ast;\n \n-use utils::{in_macro, snippet_block, span_lint_and_then, span_lint_and_sugg};\n+use utils::{in_macro, snippet_block, span_lint_and_sugg, span_lint_and_then};\n use utils::sugg::Sugg;\n \n /// **What it does:** Checks for nested `if` statements which can be collapsed\n@@ -87,12 +87,10 @@ impl EarlyLintPass for CollapsibleIf {\n \n fn check_if(cx: &EarlyContext, expr: &ast::Expr) {\n     match expr.node {\n-        ast::ExprKind::If(ref check, ref then, ref else_) => {\n-            if let Some(ref else_) = *else_ {\n-                check_collapsible_maybe_if_let(cx, else_);\n-            } else {\n-                check_collapsible_no_if_let(cx, expr, check, then);\n-            }\n+        ast::ExprKind::If(ref check, ref then, ref else_) => if let Some(ref else_) = *else_ {\n+            check_collapsible_maybe_if_let(cx, else_);\n+        } else {\n+            check_collapsible_no_if_let(cx, expr, check, then);\n         },\n         ast::ExprKind::IfLet(_, _, _, Some(ref else_)) => {\n             check_collapsible_maybe_if_let(cx, else_);\n@@ -147,8 +145,7 @@ fn expr_block(block: &ast::Block) -> Option<&ast::Expr> {\n \n     if let (Some(stmt), None) = (it.next(), it.next()) {\n         match stmt.node {\n-            ast::StmtKind::Expr(ref expr) |\n-            ast::StmtKind::Semi(ref expr) => Some(expr),\n+            ast::StmtKind::Expr(ref expr) | ast::StmtKind::Semi(ref expr) => Some(expr),\n             _ => None,\n         }\n     } else {"}, {"sha": "de62990afd5109d0d57b12e7ba49521b086d8130", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 30, "deletions": 42, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -5,8 +5,8 @@ use rustc::hir::def::Def;\n use rustc_const_eval::lookup_const_by_id;\n use rustc_const_math::ConstInt;\n use rustc::hir::*;\n-use rustc::ty::{self, TyCtxt, Ty};\n-use rustc::ty::subst::{Substs, Subst};\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::subst::{Subst, Substs};\n use std::cmp::Ordering::{self, Equal};\n use std::cmp::PartialOrd;\n use std::hash::{Hash, Hasher};\n@@ -76,7 +76,7 @@ impl PartialEq for Constant {\n             (&Constant::Vec(ref l), &Constant::Vec(ref r)) => l == r,\n             (&Constant::Repeat(ref lv, ref ls), &Constant::Repeat(ref rv, ref rs)) => ls == rs && lv == rv,\n             (&Constant::Tuple(ref l), &Constant::Tuple(ref r)) => l == r,\n-            _ => false, //TODO: Are there inter-type equalities?\n+            _ => false, // TODO: Are there inter-type equalities?\n         }\n     }\n }\n@@ -110,8 +110,7 @@ impl Hash for Constant {\n             Constant::Bool(b) => {\n                 b.hash(state);\n             },\n-            Constant::Vec(ref v) |\n-            Constant::Tuple(ref v) => {\n+            Constant::Vec(ref v) | Constant::Tuple(ref v) => {\n                 v.hash(state);\n             },\n             Constant::Repeat(ref c, l) => {\n@@ -125,12 +124,10 @@ impl Hash for Constant {\n impl PartialOrd for Constant {\n     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n         match (self, other) {\n-            (&Constant::Str(ref ls, ref l_sty), &Constant::Str(ref rs, ref r_sty)) => {\n-                if l_sty == r_sty {\n-                    Some(ls.cmp(rs))\n-                } else {\n-                    None\n-                }\n+            (&Constant::Str(ref ls, ref l_sty), &Constant::Str(ref rs, ref r_sty)) => if l_sty == r_sty {\n+                Some(ls.cmp(rs))\n+            } else {\n+                None\n             },\n             (&Constant::Char(ref l), &Constant::Char(ref r)) => Some(l.cmp(r)),\n             (&Constant::Int(l), &Constant::Int(r)) => Some(l.cmp(&r)),\n@@ -147,15 +144,14 @@ impl PartialOrd for Constant {\n                 }\n             },\n             (&Constant::Bool(ref l), &Constant::Bool(ref r)) => Some(l.cmp(r)),\n-            (&Constant::Tuple(ref l), &Constant::Tuple(ref r)) |\n-            (&Constant::Vec(ref l), &Constant::Vec(ref r)) => l.partial_cmp(r),\n-            (&Constant::Repeat(ref lv, ref ls), &Constant::Repeat(ref rv, ref rs)) => {\n-                match lv.partial_cmp(rv) {\n-                    Some(Equal) => Some(ls.cmp(rs)),\n-                    x => x,\n-                }\n+            (&Constant::Tuple(ref l), &Constant::Tuple(ref r)) | (&Constant::Vec(ref l), &Constant::Vec(ref r)) => {\n+                l.partial_cmp(r)\n+            },\n+            (&Constant::Repeat(ref lv, ref ls), &Constant::Repeat(ref rv, ref rs)) => match lv.partial_cmp(rv) {\n+                Some(Equal) => Some(ls.cmp(rs)),\n+                x => x,\n             },\n-            _ => None, //TODO: Are there any useful inter-type orderings?\n+            _ => None, // TODO: Are there any useful inter-type orderings?\n         }\n     }\n }\n@@ -177,18 +173,14 @@ pub fn lit_to_constant<'a, 'tcx>(lit: &LitKind, tcx: TyCtxt<'a, 'tcx, 'tcx>, mut\n         LitKind::Byte(b) => Constant::Int(ConstInt::U8(b)),\n         LitKind::ByteStr(ref s) => Constant::Binary(s.clone()),\n         LitKind::Char(c) => Constant::Char(c),\n-        LitKind::Int(n, hint) => {\n-            match (&ty.sty, hint) {\n-                (&ty::TyInt(ity), _) |\n-                (_, Signed(ity)) => {\n-                    Constant::Int(ConstInt::new_signed_truncating(n as i128, ity, tcx.sess.target.int_type))\n-                },\n-                (&ty::TyUint(uty), _) |\n-                (_, Unsigned(uty)) => {\n-                    Constant::Int(ConstInt::new_unsigned_truncating(n as u128, uty, tcx.sess.target.uint_type))\n-                },\n-                _ => bug!(),\n-            }\n+        LitKind::Int(n, hint) => match (&ty.sty, hint) {\n+            (&ty::TyInt(ity), _) | (_, Signed(ity)) => {\n+                Constant::Int(ConstInt::new_signed_truncating(n as i128, ity, tcx.sess.target.int_type))\n+            },\n+            (&ty::TyUint(uty), _) | (_, Unsigned(uty)) => {\n+                Constant::Int(ConstInt::new_unsigned_truncating(n as u128, uty, tcx.sess.target.uint_type))\n+            },\n+            _ => bug!(),\n         },\n         LitKind::Float(ref is, ty) => Constant::Float(is.to_string(), ty.into()),\n         LitKind::FloatUnsuffixed(ref is) => Constant::Float(is.to_string(), FloatWidth::Any),\n@@ -262,13 +254,11 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n                 };\n                 self.expr(value).map(|v| Constant::Repeat(Box::new(v), n))\n             },\n-            ExprUnary(op, ref operand) => {\n-                self.expr(operand).and_then(|o| match op {\n-                    UnNot => constant_not(&o),\n-                    UnNeg => constant_negate(o),\n-                    UnDeref => Some(o),\n-                })\n-            },\n+            ExprUnary(op, ref operand) => self.expr(operand).and_then(|o| match op {\n+                UnNot => constant_not(&o),\n+                UnNeg => constant_negate(o),\n+                UnDeref => Some(o),\n+            }),\n             ExprBinary(op, ref left, ref right) => self.binop(op, left, right),\n             // TODO: add other expressions\n             _ => None,\n@@ -287,8 +277,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n     fn fetch_path(&mut self, qpath: &QPath, id: HirId) -> Option<Constant> {\n         let def = self.tables.qpath_def(qpath, id);\n         match def {\n-            Def::Const(def_id) |\n-            Def::AssociatedConst(def_id) => {\n+            Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n                 let substs = self.tables.node_substs(id);\n                 let substs = if self.substs.is_empty() {\n                     substs\n@@ -358,8 +347,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n             (BiRem, Constant::Int(l), Some(Constant::Int(r))) => (l % r).ok().map(Constant::Int),\n             (BiAnd, Constant::Bool(false), _) => Some(Constant::Bool(false)),\n             (BiOr, Constant::Bool(true), _) => Some(Constant::Bool(true)),\n-            (BiAnd, Constant::Bool(true), Some(r)) |\n-            (BiOr, Constant::Bool(false), Some(r)) => Some(r),\n+            (BiAnd, Constant::Bool(true), Some(r)) | (BiOr, Constant::Bool(false), Some(r)) => Some(r),\n             (BiBitXor, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l ^ r)),\n             (BiBitXor, Constant::Int(l), Some(Constant::Int(r))) => (l ^ r).ok().map(Constant::Int),\n             (BiBitAnd, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l & r)),"}, {"sha": "862272456ea413d428064a594e11968baeb26d3b", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 17, "deletions": 25, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -6,7 +6,7 @@ use std::collections::hash_map::Entry;\n use syntax::symbol::InternedString;\n use syntax::util::small_vector::SmallVector;\n use utils::{SpanlessEq, SpanlessHash};\n-use utils::{get_parent_expr, in_macro, span_lint_and_then, span_note_and_lint, snippet};\n+use utils::{get_parent_expr, in_macro, snippet, span_lint_and_then, span_note_and_lint};\n \n /// **What it does:** Checks for consecutive `if`s with the same condition.\n ///\n@@ -114,7 +114,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CopyAndPaste {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if !in_macro(expr.span) {\n             // skip ifs directly in else, it will be checked in the parent if\n-            if let Some(&Expr { node: ExprIf(_, _, Some(ref else_expr)), .. }) = get_parent_expr(cx, expr) {\n+            if let Some(&Expr {\n+                node: ExprIf(_, _, Some(ref else_expr)),\n+                ..\n+            }) = get_parent_expr(cx, expr)\n+            {\n                 if else_expr.id == expr.id {\n                     return;\n                 }\n@@ -267,12 +271,9 @@ fn if_sequence(mut expr: &Expr) -> (SmallVector<&Expr>, SmallVector<&Block>) {\n fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> HashMap<InternedString, Ty<'tcx>> {\n     fn bindings_impl<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat, map: &mut HashMap<InternedString, Ty<'tcx>>) {\n         match pat.node {\n-            PatKind::Box(ref pat) |\n-            PatKind::Ref(ref pat, _) => bindings_impl(cx, pat, map),\n-            PatKind::TupleStruct(_, ref pats, _) => {\n-                for pat in pats {\n-                    bindings_impl(cx, pat, map);\n-                }\n+            PatKind::Box(ref pat) | PatKind::Ref(ref pat, _) => bindings_impl(cx, pat, map),\n+            PatKind::TupleStruct(_, ref pats, _) => for pat in pats {\n+                bindings_impl(cx, pat, map);\n             },\n             PatKind::Binding(_, _, ref ident, ref as_pat) => {\n                 if let Entry::Vacant(v) = map.entry(ident.node.as_str()) {\n@@ -282,15 +283,11 @@ fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> HashMap<Interned\n                     bindings_impl(cx, as_pat, map);\n                 }\n             },\n-            PatKind::Struct(_, ref fields, _) => {\n-                for pat in fields {\n-                    bindings_impl(cx, &pat.node.pat, map);\n-                }\n+            PatKind::Struct(_, ref fields, _) => for pat in fields {\n+                bindings_impl(cx, &pat.node.pat, map);\n             },\n-            PatKind::Tuple(ref fields, _) => {\n-                for pat in fields {\n-                    bindings_impl(cx, pat, map);\n-                }\n+            PatKind::Tuple(ref fields, _) => for pat in fields {\n+                bindings_impl(cx, pat, map);\n             },\n             PatKind::Slice(ref lhs, ref mid, ref rhs) => {\n                 for pat in lhs {\n@@ -303,10 +300,7 @@ fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> HashMap<Interned\n                     bindings_impl(cx, pat, map);\n                 }\n             },\n-            PatKind::Lit(..) |\n-            PatKind::Range(..) |\n-            PatKind::Wild |\n-            PatKind::Path(..) => (),\n+            PatKind::Lit(..) | PatKind::Range(..) | PatKind::Wild | PatKind::Path(..) => (),\n         }\n     }\n \n@@ -335,11 +329,9 @@ where\n \n     for expr in exprs {\n         match map.entry(hash(expr)) {\n-            Entry::Occupied(o) => {\n-                for o in o.get() {\n-                    if eq(o, expr) {\n-                        return Some((o, expr));\n-                    }\n+            Entry::Occupied(o) => for o in o.get() {\n+                if eq(o, expr) {\n+                    return Some((o, expr));\n                 }\n             },\n             Entry::Vacant(v) => {"}, {"sha": "ede9dcb1fbd22a9cceb19f16909f515142452b34", "filename": "clippy_lints/src/cyclomatic_complexity.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -4,11 +4,11 @@ use rustc::cfg::CFG;\n use rustc::lint::*;\n use rustc::hir::*;\n use rustc::ty;\n-use rustc::hir::intravisit::{Visitor, walk_expr, NestedVisitorMap};\n+use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use syntax::ast::{Attribute, NodeId};\n use syntax::codemap::Span;\n \n-use utils::{in_macro, LimitStack, span_help_and_lint, paths, match_type, is_allowed};\n+use utils::{in_macro, is_allowed, match_type, paths, span_help_and_lint, LimitStack};\n \n /// **What it does:** Checks for methods with high cyclomatic complexity.\n ///\n@@ -31,7 +31,9 @@ pub struct CyclomaticComplexity {\n \n impl CyclomaticComplexity {\n     pub fn new(limit: u64) -> Self {\n-        Self { limit: LimitStack::new(limit) }\n+        Self {\n+            limit: LimitStack::new(limit),\n+        }\n     }\n }\n \n@@ -125,18 +127,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CyclomaticComplexity {\n     }\n \n     fn enter_lint_attrs(&mut self, cx: &LateContext<'a, 'tcx>, attrs: &'tcx [Attribute]) {\n-        self.limit.push_attrs(\n-            cx.sess(),\n-            attrs,\n-            \"cyclomatic_complexity\",\n-        );\n+        self.limit\n+            .push_attrs(cx.sess(), attrs, \"cyclomatic_complexity\");\n     }\n     fn exit_lint_attrs(&mut self, cx: &LateContext<'a, 'tcx>, attrs: &'tcx [Attribute]) {\n-        self.limit.pop_attrs(\n-            cx.sess(),\n-            attrs,\n-            \"cyclomatic_complexity\",\n-        );\n+        self.limit\n+            .pop_attrs(cx.sess(), attrs, \"cyclomatic_complexity\");\n     }\n }\n \n@@ -194,7 +190,7 @@ fn report_cc_bug(_: &LateContext, cc: u64, narms: u64, div: u64, shorts: u64, re\n     span_bug!(\n         span,\n         \"Clippy encountered a bug calculating cyclomatic complexity: cc = {}, arms = {}, \\\n-               div = {}, shorts = {}, returns = {}. Please file a bug report.\",\n+         div = {}, shorts = {}, returns = {}. Please file a bug report.\",\n         cc,\n         narms,\n         div,\n@@ -210,9 +206,9 @@ fn report_cc_bug(cx: &LateContext, cc: u64, narms: u64, div: u64, shorts: u64, r\n             span,\n             &format!(\n                 \"Clippy encountered a bug calculating cyclomatic complexity \\\n-                                                    (hide this message with `#[allow(cyclomatic_complexity)]`): \\\n-                                                    cc = {}, arms = {}, div = {}, shorts = {}, returns = {}. \\\n-                                                    Please file a bug report.\",\n+                 (hide this message with `#[allow(cyclomatic_complexity)]`): \\\n+                 cc = {}, arms = {}, div = {}, shorts = {}, returns = {}. \\\n+                 Please file a bug report.\",\n                 cc,\n                 narms,\n                 div,"}, {"sha": "b70e591f99572be3ecf5bee9b23535b563c8f491", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -3,7 +3,7 @@ use rustc::ty::{self, Ty};\n use rustc::hir::*;\n use syntax::codemap::Span;\n use utils::paths;\n-use utils::{is_automatically_derived, span_lint_and_then, match_path, is_copy};\n+use utils::{is_automatically_derived, is_copy, match_path, span_lint_and_then};\n \n /// **What it does:** Checks for deriving `Hash` but implementing `PartialEq`\n /// explicitly.\n@@ -141,31 +141,31 @@ fn check_copy_clone<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, item: &Item, trait_ref\n             ty::TyAdt(def, _) if def.is_union() => return,\n \n             // Some types are not Clone by default but could be cloned \u201cby hand\u201d if necessary\n-            ty::TyAdt(def, substs) => {\n-                for variant in &def.variants {\n-                    for field in &variant.fields {\n-                        match field.ty(cx.tcx, substs).sty {\n-                            ty::TyArray(_, size) if size > 32 => {\n-                                return;\n-                            },\n-                            ty::TyFnPtr(..) => {\n-                                return;\n-                            },\n-                            ty::TyTuple(tys, _) if tys.len() > 12 => {\n-                                return;\n-                            },\n-                            _ => (),\n-                        }\n+            ty::TyAdt(def, substs) => for variant in &def.variants {\n+                for field in &variant.fields {\n+                    match field.ty(cx.tcx, substs).sty {\n+                        ty::TyArray(_, size) if size > 32 => {\n+                            return;\n+                        },\n+                        ty::TyFnPtr(..) => {\n+                            return;\n+                        },\n+                        ty::TyTuple(tys, _) if tys.len() > 12 => {\n+                            return;\n+                        },\n+                        _ => (),\n                     }\n                 }\n             },\n             _ => (),\n         }\n \n-        span_lint_and_then(cx,\n-                           EXPL_IMPL_CLONE_ON_COPY,\n-                           item.span,\n-                           \"you are implementing `Clone` explicitly on a `Copy` type\",\n-                           |db| { db.span_note(item.span, \"consider deriving `Clone` or removing `Copy`\"); });\n+        span_lint_and_then(\n+            cx,\n+            EXPL_IMPL_CLONE_ON_COPY,\n+            item.span,\n+            \"you are implementing `Clone` explicitly on a `Copy` type\",\n+            |db| { db.span_note(item.span, \"consider deriving `Clone` or removing `Copy`\"); },\n+        );\n     }\n }"}, {"sha": "170ca5cf0079b69ff4e7d1a07255d033e8976395", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -2,7 +2,7 @@ use itertools::Itertools;\n use pulldown_cmark;\n use rustc::lint::*;\n use syntax::ast;\n-use syntax::codemap::{Span, BytePos};\n+use syntax::codemap::{BytePos, Span};\n use syntax_pos::Pos;\n use utils::span_lint;\n \n@@ -37,7 +37,9 @@ pub struct Doc {\n \n impl Doc {\n     pub fn new(valid_idents: Vec<String>) -> Self {\n-        Self { valid_idents: valid_idents }\n+        Self {\n+            valid_idents: valid_idents,\n+        }\n     }\n }\n \n@@ -196,17 +198,13 @@ fn check_doc<'a, Events: Iterator<Item = (usize, pulldown_cmark::Event<'a>)>>(\n \n     for (offset, event) in docs {\n         match event {\n-            Start(CodeBlock(_)) |\n-            Start(Code) => in_code = true,\n-            End(CodeBlock(_)) |\n-            End(Code) => in_code = false,\n-            Start(_tag) | End(_tag) => (), // We don't care about other tags\n-            Html(_html) |\n-            InlineHtml(_html) => (), // HTML is weird, just ignore it\n+            Start(CodeBlock(_)) | Start(Code) => in_code = true,\n+            End(CodeBlock(_)) | End(Code) => in_code = false,\n+            Start(_tag) | End(_tag) => (),         // We don't care about other tags\n+            Html(_html) | InlineHtml(_html) => (), // HTML is weird, just ignore it\n             SoftBreak => (),\n             HardBreak => (),\n-            FootnoteReference(text) |\n-            Text(text) => {\n+            FootnoteReference(text) | Text(text) => {\n                 if !in_code {\n                     let index = match spans.binary_search_by(|c| c.0.cmp(&offset)) {\n                         Ok(o) => o,"}, {"sha": "be5e056d5dfb5410dd3845ddbd936ad2922d53e3", "filename": "clippy_lints/src/double_parens.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fdouble_parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fdouble_parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_parens.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -1,5 +1,5 @@\n use syntax::ast::*;\n-use rustc::lint::{EarlyContext, LintContext, LintArray, LintPass, EarlyLintPass};\n+use rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintContext, LintPass};\n \n /// **What it does:** Checks for unnecessary double parentheses.\n ///\n@@ -31,29 +31,22 @@ impl LintPass for DoubleParens {\n impl EarlyLintPass for DoubleParens {\n     fn check_expr(&mut self, cx: &EarlyContext, expr: &Expr) {\n         match expr.node {\n-            ExprKind::Paren(ref in_paren) => {\n-                match in_paren.node {\n-                    ExprKind::Paren(_) |\n-                    ExprKind::Tup(_) => {\n-                        cx.span_lint(DOUBLE_PARENS, expr.span, \"Consider removing unnecessary double parentheses\");\n-                    },\n-                    _ => {},\n-                }\n+            ExprKind::Paren(ref in_paren) => match in_paren.node {\n+                ExprKind::Paren(_) | ExprKind::Tup(_) => {\n+                    cx.span_lint(DOUBLE_PARENS, expr.span, \"Consider removing unnecessary double parentheses\");\n+                },\n+                _ => {},\n             },\n-            ExprKind::Call(_, ref params) => {\n-                if params.len() == 1 {\n-                    let param = &params[0];\n-                    if let ExprKind::Paren(_) = param.node {\n-                        cx.span_lint(DOUBLE_PARENS, param.span, \"Consider removing unnecessary double parentheses\");\n-                    }\n+            ExprKind::Call(_, ref params) => if params.len() == 1 {\n+                let param = &params[0];\n+                if let ExprKind::Paren(_) = param.node {\n+                    cx.span_lint(DOUBLE_PARENS, param.span, \"Consider removing unnecessary double parentheses\");\n                 }\n             },\n-            ExprKind::MethodCall(_, ref params) => {\n-                if params.len() == 2 {\n-                    let param = &params[1];\n-                    if let ExprKind::Paren(_) = param.node {\n-                        cx.span_lint(DOUBLE_PARENS, param.span, \"Consider removing unnecessary double parentheses\");\n-                    }\n+            ExprKind::MethodCall(_, ref params) => if params.len() == 2 {\n+                let param = &params[1];\n+                if let ExprKind::Paren(_) = param.node {\n+                    cx.span_lint(DOUBLE_PARENS, param.span, \"Consider removing unnecessary double parentheses\");\n                 }\n             },\n             _ => {},"}, {"sha": "6ca04d40067a7697ec3436afc337cddd44c3d93e", "filename": "clippy_lints/src/drop_forget_ref.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -1,7 +1,7 @@\n use rustc::lint::*;\n use rustc::ty;\n use rustc::hir::*;\n-use utils::{match_def_path, paths, span_note_and_lint, is_copy};\n+use utils::{is_copy, match_def_path, paths, span_note_and_lint};\n \n /// **What it does:** Checks for calls to `std::mem::drop` with a reference\n /// instead of an owned value.\n@@ -96,13 +96,13 @@ declare_lint! {\n }\n \n const DROP_REF_SUMMARY: &str = \"calls to `std::mem::drop` with a reference instead of an owned value. \\\n-                               Dropping a reference does nothing.\";\n+                                Dropping a reference does nothing.\";\n const FORGET_REF_SUMMARY: &str = \"calls to `std::mem::forget` with a reference instead of an owned value. \\\n-                                 Forgetting a reference does nothing.\";\n+                                  Forgetting a reference does nothing.\";\n const DROP_COPY_SUMMARY: &str = \"calls to `std::mem::drop` with a value that implements Copy. \\\n-                                Dropping a copy leaves the original intact.\";\n+                                 Dropping a copy leaves the original intact.\";\n const FORGET_COPY_SUMMARY: &str = \"calls to `std::mem::forget` with a value that implements Copy. \\\n-                                  Forgetting a copy leaves the original intact.\";\n+                                   Forgetting a copy leaves the original intact.\";\n \n #[allow(missing_copy_implementations)]\n pub struct Pass;"}, {"sha": "67a4b8d4030d6028bae22e1e214a4c6b4dd2785e", "filename": "clippy_lints/src/empty_enum.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fempty_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fempty_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fempty_enum.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -36,9 +36,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EmptyEnum {\n         let did = cx.tcx.hir.local_def_id(item.id);\n         if let ItemEnum(..) = item.node {\n             let ty = cx.tcx.type_of(did);\n-            let adt = ty.ty_adt_def().expect(\n-                \"already checked whether this is an enum\",\n-            );\n+            let adt = ty.ty_adt_def()\n+                .expect(\"already checked whether this is an enum\");\n             if adt.variants.is_empty() {\n                 span_lint_and_then(cx, EMPTY_ENUM, item.span, \"enum with no variants\", |db| {\n                     db.span_help(item.span, \"consider using the uninhabited type `!` or a wrapper around it\");"}, {"sha": "a3558a189e2af5cb0701fbf546f7b02825f6c631", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -1,5 +1,5 @@\n use rustc::hir::*;\n-use rustc::hir::intravisit::{Visitor, walk_expr, NestedVisitorMap};\n+use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc::lint::*;\n use syntax::codemap::Span;\n use utils::SpanlessEq;\n@@ -47,12 +47,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for HashMapLint {\n                     // in case of `if !m.contains_key(&k) { m.insert(k, v); }`\n                     // we can give a better error message\n                     let sole_expr = {\n-                        else_block.is_none() &&\n-                            if let ExprBlock(ref then_block) = then_block.node {\n-                                (then_block.expr.is_some() as usize) + then_block.stmts.len() == 1\n-                            } else {\n-                                true\n-                            }\n+                        else_block.is_none() && if let ExprBlock(ref then_block) = then_block.node {\n+                            (then_block.expr.is_some() as usize) + then_block.stmts.len() == 1\n+                        } else {\n+                            true\n+                        }\n                     };\n \n                     let mut visitor = InsertVisitor {"}, {"sha": "c776681d51c40bcd20af374c6f5e9d23a4082be7", "filename": "clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_clike.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -51,9 +51,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnportableVariant {\n                     let did = cx.tcx.hir.body_owner_def_id(body_id);\n                     let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n                     let substs = Substs::identity_for_item(cx.tcx.global_tcx(), did);\n-                    let bad = match cx.tcx.at(expr.span).const_eval(\n-                        param_env.and((did, substs)),\n-                    ) {\n+                    let bad = match cx.tcx\n+                        .at(expr.span)\n+                        .const_eval(param_env.and((did, substs)))\n+                    {\n                         Ok(ConstVal::Integral(Usize(Us64(i)))) => u64::from(i as u32) != i,\n                         Ok(ConstVal::Integral(Isize(Is64(i)))) => i64::from(i as i32) != i,\n                         _ => false,"}, {"sha": "9aa43653ab5f86a76cd4373498d9fd14b2538c2a", "filename": "clippy_lints/src/enum_glob_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_glob_use.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -1,7 +1,7 @@\n //! lint on `use`ing all variants of an enum\n \n use rustc::hir::*;\n-use rustc::lint::{LateLintPass, LintPass, LateContext, LintArray};\n+use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use syntax::ast::NodeId;\n use syntax::codemap::Span;\n use utils::span_lint;"}, {"sha": "c4f7f39003e08a36c5bfe5bb737a496158f357c6", "filename": "clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_variants.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -204,7 +204,7 @@ fn check_variant(\n         &format!(\"All variants have the same {}fix: `{}`\", what, value),\n         &format!(\n             \"remove the {}fixes and use full paths to \\\n-                                 the variants instead of glob imports\",\n+             the variants instead of glob imports\",\n             what\n         ),\n     );"}, {"sha": "2c268c188359f975888c9655d4106aedc6c54e7d", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -1,6 +1,6 @@\n use rustc::hir::*;\n use rustc::lint::*;\n-use utils::{SpanlessEq, span_lint, span_lint_and_then, multispan_sugg, snippet, implements_trait, is_copy};\n+use utils::{implements_trait, is_copy, multispan_sugg, snippet, span_lint, span_lint_and_then, SpanlessEq};\n \n /// **What it does:** Checks for equal operands to comparison, logical and\n /// bitwise, difference and division binary operators (`==`, `>`, etc., `&&`,\n@@ -82,8 +82,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                 #[allow(match_same_arms)]\n                 match (&left.node, &right.node) {\n                     // do not suggest to dereference literals\n-                    (&ExprLit(..), _) |\n-                    (_, &ExprLit(..)) => {},\n+                    (&ExprLit(..), _) | (_, &ExprLit(..)) => {},\n                     // &foo == &bar\n                     (&ExprAddrOf(_, ref l), &ExprAddrOf(_, ref r)) => {\n                         let lty = cx.tables.expr_ty(l);"}, {"sha": "beb96f333cbeaf6718f463bccb74a5b60df50364", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -133,7 +133,6 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n                 self.set.remove(&lid);\n             }\n         }\n-\n     }\n     fn borrow(&mut self, _: NodeId, _: Span, cmt: cmt<'tcx>, _: ty::Region, _: ty::BorrowKind, loan_cause: LoanCause) {\n         if let Categorization::Local(lid) = cmt.cat {"}, {"sha": "0710689c3d4d9f5b3118a891e11cb8a4d64739ff", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -1,7 +1,7 @@\n use rustc::lint::*;\n use rustc::ty;\n use rustc::hir::*;\n-use utils::{snippet_opt, span_lint_and_then, is_adjusted, iter_input_pats};\n+use utils::{is_adjusted, iter_input_pats, snippet_opt, span_lint_and_then};\n \n #[allow(missing_copy_implementations)]\n pub struct EtaPass;\n@@ -37,11 +37,8 @@ impl LintPass for EtaPass {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EtaPass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         match expr.node {\n-            ExprCall(_, ref args) |\n-            ExprMethodCall(_, _, ref args) => {\n-                for arg in args {\n-                    check_closure(cx, arg)\n-                }\n+            ExprCall(_, ref args) | ExprMethodCall(_, _, ref args) => for arg in args {\n+                check_closure(cx, arg)\n             },\n             _ => (),\n         }"}, {"sha": "621438b9a873f10f37e02fe38846abe677c98b66", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 25, "deletions": 31, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -1,9 +1,9 @@\n use rustc::hir::def_id::DefId;\n-use rustc::hir::intravisit::{Visitor, walk_expr, NestedVisitorMap};\n+use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc::hir::*;\n use rustc::ty;\n use rustc::lint::*;\n-use utils::{get_parent_expr, span_note_and_lint, span_lint};\n+use utils::{get_parent_expr, span_lint, span_note_and_lint};\n \n /// **What it does:** Checks for a read and a write to the same variable where\n /// whether the read occurs before or after the write depends on the evaluation\n@@ -62,20 +62,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EvalOrderDependence {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // Find a write to a local variable.\n         match expr.node {\n-            ExprAssign(ref lhs, _) |\n-            ExprAssignOp(_, ref lhs, _) => {\n-                if let ExprPath(ref qpath) = lhs.node {\n-                    if let QPath::Resolved(_, ref path) = *qpath {\n-                        if path.segments.len() == 1 {\n-                            let var = cx.tables.qpath_def(qpath, lhs.hir_id).def_id();\n-                            let mut visitor = ReadVisitor {\n-                                cx: cx,\n-                                var: var,\n-                                write_expr: expr,\n-                                last_expr: expr,\n-                            };\n-                            check_for_unsequenced_reads(&mut visitor);\n-                        }\n+            ExprAssign(ref lhs, _) | ExprAssignOp(_, ref lhs, _) => if let ExprPath(ref qpath) = lhs.node {\n+                if let QPath::Resolved(_, ref path) = *qpath {\n+                    if path.segments.len() == 1 {\n+                        let var = cx.tables.qpath_def(qpath, lhs.hir_id).def_id();\n+                        let mut visitor = ReadVisitor {\n+                            cx: cx,\n+                            var: var,\n+                            write_expr: expr,\n+                            last_expr: expr,\n+                        };\n+                        check_for_unsequenced_reads(&mut visitor);\n                     }\n                 }\n             },\n@@ -84,13 +81,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EvalOrderDependence {\n     }\n     fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n         match stmt.node {\n-            StmtExpr(ref e, _) |\n-            StmtSemi(ref e, _) => DivergenceVisitor { cx: cx }.maybe_walk_expr(e),\n-            StmtDecl(ref d, _) => {\n-                if let DeclLocal(ref local) = d.node {\n-                    if let Local { init: Some(ref e), .. } = **local {\n-                        DivergenceVisitor { cx: cx }.visit_expr(e);\n-                    }\n+            StmtExpr(ref e, _) | StmtSemi(ref e, _) => DivergenceVisitor { cx: cx }.maybe_walk_expr(e),\n+            StmtDecl(ref d, _) => if let DeclLocal(ref local) = d.node {\n+                if let Local {\n+                    init: Some(ref e), ..\n+                } = **local\n+                {\n+                    DivergenceVisitor { cx: cx }.visit_expr(e);\n                 }\n             },\n         }\n@@ -230,8 +227,7 @@ fn check_expr<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, expr: &'tcx Expr) -> St\n         ExprStruct(_, _, _) => {\n             walk_expr(vis, expr);\n         },\n-        ExprBinary(op, _, _) |\n-        ExprAssignOp(op, _, _) => {\n+        ExprBinary(op, _, _) | ExprAssignOp(op, _, _) => {\n             if op.node == BiAnd || op.node == BiOr {\n                 // x && y and x || y always evaluate x first, so these are\n                 // strictly sequenced.\n@@ -265,19 +261,17 @@ fn check_expr<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, expr: &'tcx Expr) -> St\n \n fn check_stmt<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, stmt: &'tcx Stmt) -> StopEarly {\n     match stmt.node {\n-        StmtExpr(ref expr, _) |\n-        StmtSemi(ref expr, _) => check_expr(vis, expr),\n+        StmtExpr(ref expr, _) | StmtSemi(ref expr, _) => check_expr(vis, expr),\n         StmtDecl(ref decl, _) => {\n             // If the declaration is of a local variable, check its initializer\n             // expression if it has one. Otherwise, keep going.\n             let local = match decl.node {\n                 DeclLocal(ref local) => Some(local),\n                 _ => None,\n             };\n-            local.and_then(|local| local.init.as_ref()).map_or(\n-                StopEarly::KeepGoing,\n-                |expr| check_expr(vis, expr),\n-            )\n+            local\n+                .and_then(|local| local.init.as_ref())\n+                .map_or(StopEarly::KeepGoing, |expr| check_expr(vis, expr))\n         },\n     }\n }"}, {"sha": "2577e2908a8c3b7221ab7243061f46f52724f5cb", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -57,11 +57,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     }}\n                 },\n                 // `format!(\"foo\")` expansion contains `match () { () => [], }`\n-                ExprMatch(ref matchee, _, _) => {\n-                    if let ExprTup(ref tup) = matchee.node {\n-                        if tup.is_empty() {\n-                            span_lint(cx, USELESS_FORMAT, span, \"useless use of `format!`\");\n-                        }\n+                ExprMatch(ref matchee, _, _) => if let ExprTup(ref tup) = matchee.node {\n+                    if tup.is_empty() {\n+                        span_lint(cx, USELESS_FORMAT, span, \"useless use of `format!`\");\n                     }\n                 },\n                 _ => (),"}, {"sha": "7d7129429860132bf75976803cbaf938328e9eb5", "filename": "clippy_lints/src/formatting.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformatting.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -117,7 +117,7 @@ fn check_assign(cx: &EarlyContext, expr: &ast::Expr) {\n                             eqop_span,\n                             &format!(\n                                 \"this looks like you are trying to use `.. {op}= ..`, but you \\\n-                                                     really are doing `.. = ({op} ..)`\",\n+                                 really are doing `.. = ({op} ..)`\",\n                                 op = op\n                             ),\n                             eqop_span,\n@@ -142,9 +142,9 @@ fn check_else_if(cx: &EarlyContext, expr: &ast::Expr) {\n             // the snippet should look like \" else \\n    \" with maybe comments anywhere\n             // it\u2019s bad when there is a \u2018\\n\u2019 after the \u201celse\u201d\n             if let Some(else_snippet) = snippet_opt(cx, else_span) {\n-                let else_pos = else_snippet.find(\"else\").expect(\n-                    \"there must be a `else` here\",\n-                );\n+                let else_pos = else_snippet\n+                    .find(\"else\")\n+                    .expect(\"there must be a `else` here\");\n \n                 if else_snippet[else_pos..].contains('\\n') {\n                     span_note_and_lint(\n@@ -154,7 +154,7 @@ fn check_else_if(cx: &EarlyContext, expr: &ast::Expr) {\n                         \"this is an `else if` but the formatting might hide it\",\n                         else_span,\n                         \"to remove this lint, remove the `else` or remove the new line between `else` \\\n-                                        and `if`\",\n+                         and `if`\",\n                     );\n                 }\n             }\n@@ -205,7 +205,7 @@ fn check_consecutive_ifs(cx: &EarlyContext, first: &ast::Expr, second: &ast::Exp\n                     \"this looks like an `else if` but the `else` is missing\",\n                     else_span,\n                     \"to remove this lint, add the missing `else` or add a new line before the second \\\n-                                    `if`\",\n+                     `if`\",\n                 );\n             }\n         }\n@@ -215,8 +215,9 @@ fn check_consecutive_ifs(cx: &EarlyContext, first: &ast::Expr, second: &ast::Exp\n /// Match `if` or `if let` expressions and return the `then` and `else` block.\n fn unsugar_if(expr: &ast::Expr) -> Option<(&P<ast::Block>, &Option<P<ast::Expr>>)> {\n     match expr.node {\n-        ast::ExprKind::If(_, ref then, ref else_) |\n-        ast::ExprKind::IfLet(_, _, ref then, ref else_) => Some((then, else_)),\n+        ast::ExprKind::If(_, ref then, ref else_) | ast::ExprKind::IfLet(_, _, ref then, ref else_) => {\n+            Some((then, else_))\n+        },\n         _ => None,\n     }\n }"}, {"sha": "869e621eab635431462ab0fb1d16ac81ea017274", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -6,7 +6,7 @@ use std::collections::HashSet;\n use syntax::ast;\n use syntax::abi::Abi;\n use syntax::codemap::Span;\n-use utils::{span_lint, type_is_unsafe_function, iter_input_pats};\n+use utils::{iter_input_pats, span_lint, type_is_unsafe_function};\n \n /// **What it does:** Checks for functions with too many parameters.\n ///\n@@ -60,7 +60,9 @@ pub struct Functions {\n \n impl Functions {\n     pub fn new(threshold: u64) -> Self {\n-        Self { threshold: threshold }\n+        Self {\n+            threshold: threshold,\n+        }\n     }\n }\n "}, {"sha": "a409f4c7d65c96a34b3391872f1b5e1dea00710f", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -2,7 +2,7 @@ use consts::{constant_simple, Constant};\n use rustc::lint::*;\n use rustc::hir::*;\n use syntax::codemap::Span;\n-use utils::{span_lint, snippet, in_macro};\n+use utils::{in_macro, snippet, span_lint};\n use syntax::attr::IntType::{SignedInt, UnsignedInt};\n \n /// **What it does:** Checks for identity operations, e.g. `x + 0`.\n@@ -63,16 +63,13 @@ fn check(cx: &LateContext, e: &Expr, m: i8, span: Span, arg: Span) {\n     if let Some(Constant::Int(v)) = constant_simple(cx, e) {\n         if match m {\n             0 => v.to_u128_unchecked() == 0,\n-            -1 => {\n-                match v.int_type() {\n-                    SignedInt(_) => (v.to_u128_unchecked() as i128 == -1),\n-                    UnsignedInt(_) => false,\n-                }\n+            -1 => match v.int_type() {\n+                SignedInt(_) => (v.to_u128_unchecked() as i128 == -1),\n+                UnsignedInt(_) => false,\n             },\n             1 => v.to_u128_unchecked() == 1,\n             _ => unreachable!(),\n-        }\n-        {\n+        } {\n             span_lint(\n                 cx,\n                 IDENTITY_OP,"}, {"sha": "27f41c0e6987fe9baca648231f527297402121bc", "filename": "clippy_lints/src/if_let_redundant_pattern_matching.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -1,6 +1,6 @@\n use rustc::lint::*;\n use rustc::hir::*;\n-use utils::{paths, span_lint_and_then, match_qpath, snippet};\n+use utils::{match_qpath, paths, snippet, span_lint_and_then};\n \n /// **What it does:*** Lint for redundant pattern matching over `Result` or\n /// `Option`\n@@ -45,11 +45,8 @@ impl LintPass for Pass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-\n         if let ExprMatch(ref op, ref arms, MatchSource::IfLetDesugar { .. }) = expr.node {\n-\n             if arms[0].pats.len() == 1 {\n-\n                 let good_method = match arms[0].pats[0].node {\n                     PatKind::TupleStruct(ref path, ref pats, _) if pats.len() == 1 && pats[0].node == PatKind::Wild => {\n                         if match_qpath(path, &paths::RESULT_OK) {\n@@ -68,16 +65,21 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     _ => return,\n                 };\n \n-                span_lint_and_then(cx,\n-                                   IF_LET_REDUNDANT_PATTERN_MATCHING,\n-                                   arms[0].pats[0].span,\n-                                   &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n-                                   |db| {\n-                    let span = expr.span.with_hi(op.span.hi());\n-                    db.span_suggestion(span, \"try this\", format!(\"if {}.{}\", snippet(cx, op.span, \"_\"), good_method));\n-                });\n+                span_lint_and_then(\n+                    cx,\n+                    IF_LET_REDUNDANT_PATTERN_MATCHING,\n+                    arms[0].pats[0].span,\n+                    &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n+                    |db| {\n+                        let span = expr.span.with_hi(op.span.hi());\n+                        db.span_suggestion(\n+                            span,\n+                            \"try this\",\n+                            format!(\"if {}.{}\", snippet(cx, op.span, \"_\"), good_method),\n+                        );\n+                    },\n+                );\n             }\n-\n         }\n     }\n }"}, {"sha": "3a5bcdc78d49dc259b965c2fa5985a358fe1b231", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 31, "deletions": 39, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -1,6 +1,6 @@\n use rustc::hir::*;\n use rustc::lint::*;\n-use utils::{get_trait_def_id, implements_trait, higher, match_qpath, paths, span_lint};\n+use utils::{get_trait_def_id, higher, implements_trait, match_qpath, paths, span_lint};\n \n /// **What it does:** Checks for iteration that is guaranteed to be infinite.\n ///\n@@ -66,31 +66,33 @@ enum Finiteness {\n     Finite,\n }\n \n-use self::Finiteness::{Infinite, MaybeInfinite, Finite};\n+use self::Finiteness::{Finite, Infinite, MaybeInfinite};\n \n impl Finiteness {\n     fn and(self, b: Self) -> Self {\n         match (self, b) {\n             (Finite, _) | (_, Finite) => Finite,\n-            (MaybeInfinite, _) |\n-            (_, MaybeInfinite) => MaybeInfinite,\n+            (MaybeInfinite, _) | (_, MaybeInfinite) => MaybeInfinite,\n             _ => Infinite,\n         }\n     }\n \n     fn or(self, b: Self) -> Self {\n         match (self, b) {\n             (Infinite, _) | (_, Infinite) => Infinite,\n-            (MaybeInfinite, _) |\n-            (_, MaybeInfinite) => MaybeInfinite,\n+            (MaybeInfinite, _) | (_, MaybeInfinite) => MaybeInfinite,\n             _ => Finite,\n         }\n     }\n }\n \n impl From<bool> for Finiteness {\n     fn from(b: bool) -> Self {\n-        if b { Infinite } else { Finite }\n+        if b {\n+            Infinite\n+        } else {\n+            Finite\n+        }\n     }\n }\n \n@@ -108,7 +110,7 @@ enum Heuristic {\n     All,\n }\n \n-use self::Heuristic::{Always, First, Any, All};\n+use self::Heuristic::{All, Always, Any, First};\n \n /// a slice of (method name, number of args, heuristic, bounds) tuples\n /// that will be used to determine whether the method in question\n@@ -143,11 +145,11 @@ fn is_infinite(cx: &LateContext, expr: &Expr) -> Finiteness {\n             for &(name, len, heuristic, cap) in HEURISTICS.iter() {\n                 if method.name == name && args.len() == len {\n                     return (match heuristic {\n-                                Always => Infinite,\n-                                First => is_infinite(cx, &args[0]),\n-                                Any => is_infinite(cx, &args[0]).or(is_infinite(cx, &args[1])),\n-                                All => is_infinite(cx, &args[0]).and(is_infinite(cx, &args[1])),\n-                            }).and(cap);\n+                        Always => Infinite,\n+                        First => is_infinite(cx, &args[0]),\n+                        Any => is_infinite(cx, &args[0]).or(is_infinite(cx, &args[1])),\n+                        All => is_infinite(cx, &args[0]).and(is_infinite(cx, &args[1])),\n+                    }).and(cap);\n                 }\n             }\n             if method.name == \"flat_map\" && args.len() == 2 {\n@@ -159,20 +161,15 @@ fn is_infinite(cx: &LateContext, expr: &Expr) -> Finiteness {\n             Finite\n         },\n         ExprBlock(ref block) => block.expr.as_ref().map_or(Finite, |e| is_infinite(cx, e)),\n-        ExprBox(ref e) |\n-        ExprAddrOf(_, ref e) => is_infinite(cx, e),\n-        ExprCall(ref path, _) => {\n-            if let ExprPath(ref qpath) = path.node {\n-                match_qpath(qpath, &paths::REPEAT).into()\n-            } else {\n-                Finite\n-            }\n-        },\n-        ExprStruct(..) => {\n-            higher::range(expr)\n-                .map_or(false, |r| r.end.is_none())\n-                .into()\n+        ExprBox(ref e) | ExprAddrOf(_, ref e) => is_infinite(cx, e),\n+        ExprCall(ref path, _) => if let ExprPath(ref qpath) = path.node {\n+            match_qpath(qpath, &paths::REPEAT).into()\n+        } else {\n+            Finite\n         },\n+        ExprStruct(..) => higher::range(expr)\n+            .map_or(false, |r| r.end.is_none())\n+            .into(),\n         _ => Finite,\n     }\n }\n@@ -220,23 +217,18 @@ fn complete_infinite_iter(cx: &LateContext, expr: &Expr) -> Finiteness {\n                 }\n             }\n             if method.name == \"last\" && args.len() == 1 {\n-                let not_double_ended = get_trait_def_id(cx,\n-                                        &paths::DOUBLE_ENDED_ITERATOR)\n-                                        .map_or(false, |id| {\n-                        !implements_trait(cx, cx.tables.expr_ty(&args[0]), id, &[])\n-                });\n+                let not_double_ended = get_trait_def_id(cx, &paths::DOUBLE_ENDED_ITERATOR)\n+                    .map_or(false, |id| !implements_trait(cx, cx.tables.expr_ty(&args[0]), id, &[]));\n                 if not_double_ended {\n-                    return is_infinite(cx, &args[0]); \n+                    return is_infinite(cx, &args[0]);\n                 }\n             }\n         },\n-        ExprBinary(op, ref l, ref r) => {\n-            if op.node.is_comparison() {\n-                return is_infinite(cx, l).and(is_infinite(cx, r)).and(\n-                    MaybeInfinite,\n-                );\n-            }\n-        }, //TODO: ExprLoop + Match\n+        ExprBinary(op, ref l, ref r) => if op.node.is_comparison() {\n+            return is_infinite(cx, l)\n+                .and(is_infinite(cx, r))\n+                .and(MaybeInfinite);\n+        }, // TODO: ExprLoop + Match\n         _ => (),\n     }\n     Finite"}, {"sha": "152612bd8ff2d7695a352614ce85d1764dee7476", "filename": "clippy_lints/src/is_unit_expr.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fis_unit_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fis_unit_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fis_unit_expr.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -100,12 +100,10 @@ impl EarlyLintPass for UnitExpr {\n }\n fn is_unit_expr(expr: &Expr) -> Option<Span> {\n     match expr.node {\n-        ExprKind::Block(ref block) => {\n-            if check_last_stmt_in_block(block) {\n-                Some(block.stmts[block.stmts.len() - 1].span)\n-            } else {\n-                None\n-            }\n+        ExprKind::Block(ref block) => if check_last_stmt_in_block(block) {\n+            Some(block.stmts[block.stmts.len() - 1].span)\n+        } else {\n+            None\n         },\n         ExprKind::If(_, ref then, ref else_) => {\n             let check_then = check_last_stmt_in_block(then);\n@@ -115,7 +113,11 @@ fn is_unit_expr(expr: &Expr) -> Option<Span> {\n                     return Some(*expr_else);\n                 }\n             }\n-            if check_then { Some(expr.span) } else { None }\n+            if check_then {\n+                Some(expr.span)\n+            } else {\n+                None\n+            }\n         },\n         ExprKind::Match(ref _pattern, ref arms) => {\n             for arm in arms {\n@@ -137,12 +139,9 @@ fn check_last_stmt_in_block(block: &Block) -> bool {\n     // like `panic!()`\n     match final_stmt.node {\n         StmtKind::Expr(_) => false,\n-        StmtKind::Semi(ref expr) => {\n-            match expr.node {\n-                ExprKind::Break(_, _) |\n-                ExprKind::Ret(_) => false,\n-                _ => true,\n-            }\n+        StmtKind::Semi(ref expr) => match expr.node {\n+            ExprKind::Break(_, _) | ExprKind::Ret(_) => false,\n+            _ => true,\n         },\n         _ => true,\n     }"}, {"sha": "2aabecabff07f6e2103a045efdda5d1582ef1e3d", "filename": "clippy_lints/src/items_after_statements.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fitems_after_statements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fitems_after_statements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fitems_after_statements.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -47,9 +47,10 @@ impl EarlyLintPass for ItemsAfterStatements {\n         }\n \n         // skip initial items\n-        let stmts = item.stmts.iter().map(|stmt| &stmt.node).skip_while(|s| {\n-            matches!(**s, StmtKind::Item(..))\n-        });\n+        let stmts = item.stmts\n+            .iter()\n+            .map(|stmt| &stmt.node)\n+            .skip_while(|s| matches!(**s, StmtKind::Item(..)));\n \n         // lint on all further items\n         for stmt in stmts {\n@@ -66,7 +67,7 @@ impl EarlyLintPass for ItemsAfterStatements {\n                     ITEMS_AFTER_STATEMENTS,\n                     it.span,\n                     \"adding items after statements is confusing, since items exist from the \\\n-                           start of the scope\",\n+                     start of the scope\",\n                 );\n             }\n         }"}, {"sha": "ceb0cbd6688e65bf1be56be7cdffbc4e11e11e7b", "filename": "clippy_lints/src/large_enum_variant.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_enum_variant.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -2,7 +2,7 @@\n \n use rustc::lint::*;\n use rustc::hir::*;\n-use utils::{span_lint_and_then, snippet_opt, type_size};\n+use utils::{snippet_opt, span_lint_and_then, type_size};\n use rustc::ty::TypeFoldable;\n \n /// **What it does:** Checks for large size differences between variants on\n@@ -34,7 +34,9 @@ pub struct LargeEnumVariant {\n \n impl LargeEnumVariant {\n     pub fn new(maximum_size_difference_allowed: u64) -> Self {\n-        Self { maximum_size_difference_allowed: maximum_size_difference_allowed }\n+        Self {\n+            maximum_size_difference_allowed: maximum_size_difference_allowed,\n+        }\n     }\n }\n \n@@ -49,9 +51,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LargeEnumVariant {\n         let did = cx.tcx.hir.local_def_id(item.id);\n         if let ItemEnum(ref def, _) = item.node {\n             let ty = cx.tcx.type_of(did);\n-            let adt = ty.ty_adt_def().expect(\n-                \"already checked whether this is an enum\",\n-            );\n+            let adt = ty.ty_adt_def()\n+                .expect(\"already checked whether this is an enum\");\n \n             let mut smallest_variant: Option<(_, _)> = None;\n             let mut largest_variant: Option<(_, _)> = None;\n@@ -90,15 +91,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LargeEnumVariant {\n                         |db| {\n                             if variant.fields.len() == 1 {\n                                 let span = match def.variants[i].node.data {\n-                                    VariantData::Struct(ref fields, _) |\n-                                    VariantData::Tuple(ref fields, _) => fields[0].ty.span,\n+                                    VariantData::Struct(ref fields, _) | VariantData::Tuple(ref fields, _) => {\n+                                        fields[0].ty.span\n+                                    },\n                                     VariantData::Unit(_) => unreachable!(),\n                                 };\n                                 if let Some(snip) = snippet_opt(cx, span) {\n                                     db.span_suggestion(\n                                         span,\n                                         \"consider boxing the large fields to reduce the total size of the \\\n-                                                    enum\",\n+                                         enum\",\n                                         format!(\"Box<{}>\", snip),\n                                     );\n                                     return;\n@@ -112,7 +114,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LargeEnumVariant {\n                     );\n                 }\n             }\n-\n         }\n     }\n }"}, {"sha": "9b14a44f2c04c440c7bb8d129deb1d0dee9b36e7", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 29, "deletions": 37, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -91,16 +91,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LenZero {\n \n fn check_trait_items(cx: &LateContext, visited_trait: &Item, trait_items: &[TraitItemRef]) {\n     fn is_named_self(cx: &LateContext, item: &TraitItemRef, name: &str) -> bool {\n-        item.name == name &&\n-            if let AssociatedItemKind::Method { has_self } = item.kind {\n-                has_self &&\n-                    {\n-                        let did = cx.tcx.hir.local_def_id(item.id.node_id);\n-                        cx.tcx.fn_sig(did).inputs().skip_binder().len() == 1\n-                    }\n-            } else {\n-                false\n+        item.name == name && if let AssociatedItemKind::Method { has_self } = item.kind {\n+            has_self && {\n+                let did = cx.tcx.hir.local_def_id(item.id.node_id);\n+                cx.tcx.fn_sig(did).inputs().skip_binder().len() == 1\n             }\n+        } else {\n+            false\n+        }\n     }\n \n     // fill the set with current and super traits\n@@ -121,10 +119,8 @@ fn check_trait_items(cx: &LateContext, visited_trait: &Item, trait_items: &[Trai\n             .iter()\n             .flat_map(|&i| cx.tcx.associated_items(i))\n             .any(|i| {\n-                i.kind == ty::AssociatedKind::Method &&\n-                i.method_has_self_argument &&\n-                i.name == \"is_empty\" &&\n-                cx.tcx.fn_sig(i.def_id).inputs().skip_binder().len() == 1\n+                i.kind == ty::AssociatedKind::Method && i.method_has_self_argument && i.name == \"is_empty\" &&\n+                    cx.tcx.fn_sig(i.def_id).inputs().skip_binder().len() == 1\n             });\n \n         if !is_empty_method_found {\n@@ -143,16 +139,14 @@ fn check_trait_items(cx: &LateContext, visited_trait: &Item, trait_items: &[Trai\n \n fn check_impl_items(cx: &LateContext, item: &Item, impl_items: &[ImplItemRef]) {\n     fn is_named_self(cx: &LateContext, item: &ImplItemRef, name: &str) -> bool {\n-        item.name == name &&\n-            if let AssociatedItemKind::Method { has_self } = item.kind {\n-                has_self &&\n-                    {\n-                        let did = cx.tcx.hir.local_def_id(item.id.node_id);\n-                        cx.tcx.fn_sig(did).inputs().skip_binder().len() == 1\n-                    }\n-            } else {\n-                false\n+        item.name == name && if let AssociatedItemKind::Method { has_self } = item.kind {\n+            has_self && {\n+                let did = cx.tcx.hir.local_def_id(item.id.node_id);\n+                cx.tcx.fn_sig(did).inputs().skip_binder().len() == 1\n             }\n+        } else {\n+            false\n+        }\n     }\n \n     let is_empty = if let Some(is_empty) = impl_items.iter().find(|i| is_named_self(cx, i, \"is_empty\")) {\n@@ -197,7 +191,11 @@ fn check_cmp(cx: &LateContext, span: Span, left: &Expr, right: &Expr, op: &str)\n }\n \n fn check_len_zero(cx: &LateContext, span: Span, name: Name, args: &[Expr], lit: &Lit, op: &str) {\n-    if let Spanned { node: LitKind::Int(0, _), .. } = *lit {\n+    if let Spanned {\n+        node: LitKind::Int(0, _),\n+        ..\n+    } = *lit\n+    {\n         if name == \"len\" && args.len() == 1 && has_is_empty(cx, &args[0]) {\n             span_lint_and_sugg(\n                 cx,\n@@ -231,25 +229,19 @@ fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n     /// Check the inherent impl's items for an `is_empty(self)` method.\n     fn has_is_empty_impl(cx: &LateContext, id: DefId) -> bool {\n         cx.tcx.inherent_impls(id).iter().any(|imp| {\n-            cx.tcx.associated_items(*imp).any(\n-                |item| is_is_empty(cx, &item),\n-            )\n+            cx.tcx\n+                .associated_items(*imp)\n+                .any(|item| is_is_empty(cx, &item))\n         })\n     }\n \n     let ty = &walk_ptrs_ty(cx.tables.expr_ty(expr));\n     match ty.sty {\n-        ty::TyDynamic(..) => {\n-            cx.tcx\n-                .associated_items(ty.ty_to_def_id().expect(\"trait impl not found\"))\n-                .any(|item| is_is_empty(cx, &item))\n-        },\n-        ty::TyProjection(_) => {\n-            ty.ty_to_def_id().map_or(\n-                false,\n-                |id| has_is_empty_impl(cx, id),\n-            )\n-        },\n+        ty::TyDynamic(..) => cx.tcx\n+            .associated_items(ty.ty_to_def_id().expect(\"trait impl not found\"))\n+            .any(|item| is_is_empty(cx, &item)),\n+        ty::TyProjection(_) => ty.ty_to_def_id()\n+            .map_or(false, |id| has_is_empty_impl(cx, id)),\n         ty::TyAdt(id, _) => has_is_empty_impl(cx, id.did),\n         ty::TyArray(..) | ty::TySlice(..) | ty::TyStr => true,\n         _ => false,"}, {"sha": "41ca62b470c5ae644851ca372273bd19b53a11a0", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -8,39 +8,42 @@\n #![feature(slice_patterns)]\n #![feature(stmt_expr_attributes)]\n #![feature(conservative_impl_trait)]\n-\n #![allow(unknown_lints, indexing_slicing, shadow_reuse, missing_docs_in_private_items)]\n \n-extern crate syntax;\n-extern crate syntax_pos;\n #[macro_use]\n extern crate rustc;\n+extern crate syntax;\n+extern crate syntax_pos;\n \n extern crate toml;\n \n // for unicode nfc normalization\n+\n extern crate unicode_normalization;\n \n // for semver check in attrs.rs\n+\n extern crate semver;\n \n // for regex checking\n+\n extern crate regex_syntax;\n \n // for finding minimal boolean expressions\n+\n extern crate quine_mc_cluskey;\n \n-extern crate rustc_errors;\n-extern crate rustc_plugin;\n extern crate rustc_const_eval;\n extern crate rustc_const_math;\n+extern crate rustc_errors;\n+extern crate rustc_plugin;\n \n #[macro_use]\n extern crate matches as matches_macro;\n \n+extern crate serde;\n #[macro_use]\n extern crate serde_derive;\n-extern crate serde;\n \n #[macro_use]\n extern crate lazy_static;"}, {"sha": "9e7e19a8df5aaf77e9f6816675e862606e5536ae", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -2,10 +2,10 @@ use reexport::*;\n use rustc::lint::*;\n use rustc::hir::def::Def;\n use rustc::hir::*;\n-use rustc::hir::intravisit::{Visitor, walk_ty, walk_ty_param_bound, walk_fn_decl, walk_generics, NestedVisitorMap};\n-use std::collections::{HashSet, HashMap};\n+use rustc::hir::intravisit::{walk_fn_decl, walk_generics, walk_ty, walk_ty_param_bound, NestedVisitorMap, Visitor};\n+use std::collections::{HashMap, HashSet};\n use syntax::codemap::Span;\n-use utils::{in_external_macro, span_lint, last_path_segment};\n+use utils::{in_external_macro, last_path_segment, span_lint};\n use syntax::symbol::keywords;\n \n /// **What it does:** Checks for lifetime annotations which can be removed by\n@@ -171,7 +171,9 @@ fn could_use_elision<'a, 'tcx: 'a>(\n     };\n \n     if let Some(body_id) = body {\n-        let mut checker = BodyLifetimeChecker { lifetimes_used_in_body: false };\n+        let mut checker = BodyLifetimeChecker {\n+            lifetimes_used_in_body: false,\n+        };\n         checker.visit_expr(&cx.tcx.hir.body(body_id).value);\n         if checker.lifetimes_used_in_body {\n             return false;\n@@ -192,9 +194,9 @@ fn could_use_elision<'a, 'tcx: 'a>(\n         // no output lifetimes, check distinctness of input lifetimes\n \n         // only unnamed and static, ok\n-        let unnamed_and_static = input_lts.iter().all(|lt| {\n-            *lt == RefLt::Unnamed || *lt == RefLt::Static\n-        });\n+        let unnamed_and_static = input_lts\n+            .iter()\n+            .all(|lt| *lt == RefLt::Unnamed || *lt == RefLt::Static);\n         if unnamed_and_static {\n             return false;\n         }\n@@ -210,8 +212,8 @@ fn could_use_elision<'a, 'tcx: 'a>(\n             match (&input_lts[0], &output_lts[0]) {\n                 (&RefLt::Named(n1), &RefLt::Named(n2)) if n1 == n2 => true,\n                 (&RefLt::Named(_), &RefLt::Unnamed) => true,\n-                _ => false, // already elided, different named lifetimes\n-                // or something static going on\n+                _ => false, /* already elided, different named lifetimes\n+                             * or something static going on */\n             }\n         } else {\n             false\n@@ -277,16 +279,19 @@ impl<'v, 't> RefVisitor<'v, 't> {\n     }\n \n     fn into_vec(self) -> Option<Vec<RefLt>> {\n-        if self.abort { None } else { Some(self.lts) }\n+        if self.abort {\n+            None\n+        } else {\n+            Some(self.lts)\n+        }\n     }\n \n     fn collect_anonymous_lifetimes(&mut self, qpath: &QPath, ty: &Ty) {\n         let last_path_segment = &last_path_segment(qpath).parameters;\n         if !last_path_segment.parenthesized && last_path_segment.lifetimes.is_empty() {\n             let hir_id = self.cx.tcx.hir.node_to_hir_id(ty.id);\n             match self.cx.tables.qpath_def(qpath, hir_id) {\n-                Def::TyAlias(def_id) |\n-                Def::Struct(def_id) => {\n+                Def::TyAlias(def_id) | Def::Struct(def_id) => {\n                     let generics = self.cx.tcx.generics_of(def_id);\n                     for _ in generics.regions.as_slice() {\n                         self.record(&None);\n@@ -318,11 +323,9 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n             TyPath(ref path) => {\n                 self.collect_anonymous_lifetimes(path, ty);\n             },\n-            TyImplTrait(ref param_bounds) => {\n-                for bound in param_bounds {\n-                    if let RegionTyParamBound(_) = *bound {\n-                        self.record(&None);\n-                    }\n+            TyImplTrait(ref param_bounds) => for bound in param_bounds {\n+                if let RegionTyParamBound(_) = *bound {\n+                    self.record(&None);\n                 }\n             },\n             TyTraitObject(ref bounds, ref lt) => {\n@@ -366,11 +369,9 @@ fn has_where_lifetimes<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, where_clause: &\n                 // and check that all lifetimes are allowed\n                 match visitor.into_vec() {\n                     None => return false,\n-                    Some(lts) => {\n-                        for lt in lts {\n-                            if !allowed_lts.contains(&lt) {\n-                                return true;\n-                            }\n+                    Some(lts) => for lt in lts {\n+                        if !allowed_lts.contains(&lt) {\n+                            return true;\n                         }\n                     },\n                 }"}, {"sha": "1cd539eac3983cb3f47a8f92e806ead8a821f41a", "filename": "clippy_lints/src/literal_digit_grouping.rs", "status": "modified", "additions": 22, "deletions": 28, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fliteral_digit_grouping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fliteral_digit_grouping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_digit_grouping.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -4,7 +4,7 @@\n use rustc::lint::*;\n use syntax::ast::*;\n use syntax_pos;\n-use utils::{span_help_and_lint, snippet_opt, in_external_macro};\n+use utils::{in_external_macro, snippet_opt, span_help_and_lint};\n \n /// **What it does:** Warns if a long integral or floating-point constant does\n /// not contain underscores.\n@@ -195,33 +195,27 @@ enum WarningType {\n impl WarningType {\n     pub fn display(&self, grouping_hint: &str, cx: &EarlyContext, span: &syntax_pos::Span) {\n         match *self {\n-            WarningType::UnreadableLiteral => {\n-                span_help_and_lint(\n-                    cx,\n-                    UNREADABLE_LITERAL,\n-                    *span,\n-                    \"long literal lacking separators\",\n-                    &format!(\"consider: {}\", grouping_hint),\n-                )\n-            },\n-            WarningType::LargeDigitGroups => {\n-                span_help_and_lint(\n-                    cx,\n-                    LARGE_DIGIT_GROUPS,\n-                    *span,\n-                    \"digit groups should be smaller\",\n-                    &format!(\"consider: {}\", grouping_hint),\n-                )\n-            },\n-            WarningType::InconsistentDigitGrouping => {\n-                span_help_and_lint(\n-                    cx,\n-                    INCONSISTENT_DIGIT_GROUPING,\n-                    *span,\n-                    \"digits grouped inconsistently by underscores\",\n-                    &format!(\"consider: {}\", grouping_hint),\n-                )\n-            },\n+            WarningType::UnreadableLiteral => span_help_and_lint(\n+                cx,\n+                UNREADABLE_LITERAL,\n+                *span,\n+                \"long literal lacking separators\",\n+                &format!(\"consider: {}\", grouping_hint),\n+            ),\n+            WarningType::LargeDigitGroups => span_help_and_lint(\n+                cx,\n+                LARGE_DIGIT_GROUPS,\n+                *span,\n+                \"digit groups should be smaller\",\n+                &format!(\"consider: {}\", grouping_hint),\n+            ),\n+            WarningType::InconsistentDigitGrouping => span_help_and_lint(\n+                cx,\n+                INCONSISTENT_DIGIT_GROUPING,\n+                *span,\n+                \"digits grouped inconsistently by underscores\",\n+                &format!(\"consider: {}\", grouping_hint),\n+            ),\n         };\n     }\n }"}, {"sha": "6cf2b1d9fedc32ec1a4f65088ac61526410a96ec", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 468, "deletions": 181, "changes": 649, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -1,8 +1,9 @@\n+use itertools::Itertools;\n use reexport::*;\n use rustc::hir::*;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n-use rustc::hir::intravisit::{Visitor, walk_expr, walk_block, walk_decl, walk_pat, walk_stmt, NestedVisitorMap};\n+use rustc::hir::intravisit::{walk_block, walk_decl, walk_expr, walk_pat, walk_stmt, NestedVisitorMap, Visitor};\n use rustc::hir::map::Node::{NodeBlock, NodeExpr, NodeStmt};\n use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n@@ -14,11 +15,30 @@ use std::collections::{HashMap, HashSet};\n use syntax::ast;\n use utils::sugg;\n \n-use utils::{snippet, span_lint, get_parent_expr, match_trait_method, match_type, multispan_sugg, in_external_macro,\n-            is_refutable, span_help_and_lint, is_integer_literal, get_enclosing_block, span_lint_and_then, higher,\n-            last_path_segment, span_lint_and_sugg};\n+use utils::{get_enclosing_block, get_parent_expr, higher, in_external_macro, is_integer_literal, is_refutable,\n+            last_path_segment, match_trait_method, match_type, multispan_sugg, snippet, snippet_opt,\n+            span_help_and_lint, span_lint, span_lint_and_sugg, span_lint_and_then};\n use utils::paths;\n \n+/// **What it does:** Checks for for loops that manually copy items between\n+/// slices that could be optimized by having a memcpy.\n+///\n+/// **Why is this bad?** It is not as fast as a memcpy.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// for i in 0..src.len() {\n+///     dst[i + 64] = src[i];\n+/// }\n+/// ```\n+declare_lint! {\n+    pub MANUAL_MEMCPY,\n+    Warn,\n+    \"manually copying items between slices\"\n+}\n+\n /// **What it does:** Checks for looping over the range of `0..len` of some\n /// collection just to get the values by index.\n ///\n@@ -314,6 +334,7 @@ pub struct Pass;\n impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(\n+            MANUAL_MEMCPY,\n             NEEDLESS_RANGE_LOOP,\n             EXPLICIT_ITER_LOOP,\n             EXPLICIT_INTO_ITER_LOOP,\n@@ -340,11 +361,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n         // check for never_loop\n         match expr.node {\n-            ExprWhile(_, ref block, _) |\n-            ExprLoop(ref block, _, _) => {\n-                if never_loop(block, &expr.id) {\n-                    span_lint(cx, NEVER_LOOP, expr.span, \"this loop never actually loops\");\n-                }\n+            ExprWhile(_, ref block, _) | ExprLoop(ref block, _, _) => if never_loop(block, &expr.id) {\n+                span_lint(cx, NEVER_LOOP, expr.span, \"this loop never actually loops\");\n             },\n             _ => (),\n         }\n@@ -360,7 +378,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     EMPTY_LOOP,\n                     expr.span,\n                     \"empty `loop {}` detected. You may want to either use `panic!()` or add \\\n-                           `std::thread::sleep(..);` to the loop body.\",\n+                     `std::thread::sleep(..);` to the loop body.\",\n                 );\n             }\n \n@@ -371,8 +389,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 if let ExprMatch(ref matchexpr, ref arms, ref source) = inner.node {\n                     // ensure \"if let\" compatible match structure\n                     match *source {\n-                        MatchSource::Normal |\n-                        MatchSource::IfLetDesugar { .. } => {\n+                        MatchSource::Normal | MatchSource::IfLetDesugar { .. } => {\n                             if arms.len() == 2 && arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n                                 arms[1].pats.len() == 1 && arms[1].guard.is_none() &&\n                                 is_break_expr(&arms[1].body)\n@@ -407,8 +424,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         }\n         if let ExprMatch(ref match_expr, ref arms, MatchSource::WhileLetDesugar) = expr.node {\n             let pat = &arms[0].pats[0].node;\n-            if let (&PatKind::TupleStruct(ref qpath, ref pat_args, _),\n-                    &ExprMethodCall(ref method_path, _, ref method_args)) = (pat, &match_expr.node)\n+            if let (\n+                &PatKind::TupleStruct(ref qpath, ref pat_args, _),\n+                &ExprMethodCall(ref method_path, _, ref method_args),\n+            ) = (pat, &match_expr.node)\n             {\n                 let iter_expr = &method_args[0];\n                 let lhs_constructor = last_path_segment(qpath);\n@@ -441,7 +460,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                         UNUSED_COLLECT,\n                         expr.span,\n                         \"you are collect()ing an iterator and throwing away the result. \\\n-                               Consider using an explicit for loop to exhaust the iterator\",\n+                         Consider using an explicit for loop to exhaust the iterator\",\n                     );\n                 }\n             }\n@@ -455,28 +474,25 @@ fn never_loop(block: &Block, id: &NodeId) -> bool {\n \n fn contains_continue_block(block: &Block, dest: &NodeId) -> bool {\n     block.stmts.iter().any(|e| contains_continue_stmt(e, dest)) ||\n-        block.expr.as_ref().map_or(\n-            false,\n-            |e| contains_continue_expr(e, dest),\n-        )\n+        block\n+            .expr\n+            .as_ref()\n+            .map_or(false, |e| contains_continue_expr(e, dest))\n }\n \n fn contains_continue_stmt(stmt: &Stmt, dest: &NodeId) -> bool {\n     match stmt.node {\n-        StmtSemi(ref e, _) |\n-        StmtExpr(ref e, _) => contains_continue_expr(e, dest),\n+        StmtSemi(ref e, _) | StmtExpr(ref e, _) => contains_continue_expr(e, dest),\n         StmtDecl(ref d, _) => contains_continue_decl(d, dest),\n     }\n }\n \n fn contains_continue_decl(decl: &Decl, dest: &NodeId) -> bool {\n     match decl.node {\n-        DeclLocal(ref local) => {\n-            local.init.as_ref().map_or(\n-                false,\n-                |e| contains_continue_expr(e, dest),\n-            )\n-        },\n+        DeclLocal(ref local) => local\n+            .init\n+            .as_ref()\n+            .map_or(false, |e| contains_continue_expr(e, dest)),\n         _ => false,\n     }\n }\n@@ -492,32 +508,27 @@ fn contains_continue_expr(expr: &Expr, dest: &NodeId) -> bool {\n         ExprTupField(ref e, _) |\n         ExprAddrOf(_, ref e) |\n         ExprRepeat(ref e, _) => contains_continue_expr(e, dest),\n-        ExprArray(ref es) |\n-        ExprMethodCall(_, _, ref es) |\n-        ExprTup(ref es) => es.iter().any(|e| contains_continue_expr(e, dest)),\n+        ExprArray(ref es) | ExprMethodCall(_, _, ref es) | ExprTup(ref es) => {\n+            es.iter().any(|e| contains_continue_expr(e, dest))\n+        },\n         ExprCall(ref e, ref es) => {\n             contains_continue_expr(e, dest) || es.iter().any(|e| contains_continue_expr(e, dest))\n         },\n         ExprBinary(_, ref e1, ref e2) |\n         ExprAssign(ref e1, ref e2) |\n         ExprAssignOp(_, ref e1, ref e2) |\n         ExprIndex(ref e1, ref e2) => [e1, e2].iter().any(|e| contains_continue_expr(e, dest)),\n-        ExprIf(ref e, ref e2, ref e3) => {\n-            [e, e2].iter().chain(e3.as_ref().iter()).any(|e| {\n-                contains_continue_expr(e, dest)\n-            })\n-        },\n+        ExprIf(ref e, ref e2, ref e3) => [e, e2]\n+            .iter()\n+            .chain(e3.as_ref().iter())\n+            .any(|e| contains_continue_expr(e, dest)),\n         ExprWhile(ref e, ref b, _) => contains_continue_expr(e, dest) || contains_continue_block(b, dest),\n         ExprMatch(ref e, ref arms, _) => {\n             contains_continue_expr(e, dest) || arms.iter().any(|a| contains_continue_expr(&a.body, dest))\n         },\n         ExprBlock(ref block) => contains_continue_block(block, dest),\n-        ExprStruct(_, _, ref base) => {\n-            base.as_ref().map_or(\n-                false,\n-                |e| contains_continue_expr(e, dest),\n-            )\n-        },\n+        ExprStruct(_, _, ref base) => base.as_ref()\n+            .map_or(false, |e| contains_continue_expr(e, dest)),\n         ExprAgain(d) => d.target_id.opt_id().map_or(false, |id| id == *dest),\n         _ => false,\n     }\n@@ -529,8 +540,7 @@ fn loop_exit_block(block: &Block) -> bool {\n \n fn loop_exit_stmt(stmt: &Stmt) -> bool {\n     match stmt.node {\n-        StmtSemi(ref e, _) |\n-        StmtExpr(ref e, _) => loop_exit_expr(e),\n+        StmtSemi(ref e, _) | StmtExpr(ref e, _) => loop_exit_expr(e),\n         StmtDecl(ref d, _) => loop_exit_decl(d),\n     }\n }\n@@ -552,9 +562,7 @@ fn loop_exit_expr(expr: &Expr) -> bool {\n         ExprTupField(ref e, _) |\n         ExprAddrOf(_, ref e) |\n         ExprRepeat(ref e, _) => loop_exit_expr(e),\n-        ExprArray(ref es) |\n-        ExprMethodCall(_, _, ref es) |\n-        ExprTup(ref es) => es.iter().any(|e| loop_exit_expr(e)),\n+        ExprArray(ref es) | ExprMethodCall(_, _, ref es) | ExprTup(ref es) => es.iter().any(|e| loop_exit_expr(e)),\n         ExprCall(ref e, ref es) => loop_exit_expr(e) || es.iter().any(|e| loop_exit_expr(e)),\n         ExprBinary(_, ref e1, ref e2) |\n         ExprAssign(ref e1, ref e2) |\n@@ -583,6 +591,249 @@ fn check_for_loop<'a, 'tcx>(\n     check_for_loop_arg(cx, pat, arg, expr);\n     check_for_loop_explicit_counter(cx, arg, body, expr);\n     check_for_loop_over_map_kv(cx, pat, arg, body, expr);\n+    detect_manual_memcpy(cx, pat, arg, body, expr);\n+}\n+\n+fn same_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var: DefId) -> bool {\n+    if_let_chain! {[\n+        let ExprPath(ref qpath) = expr.node,\n+        let QPath::Resolved(None, ref path) = *qpath,\n+        path.segments.len() == 1,\n+        // our variable!\n+        cx.tables.qpath_def(qpath, expr.hir_id).def_id() == var\n+    ], {\n+        return true;\n+    }}\n+\n+    false\n+}\n+\n+struct Offset {\n+    value: String,\n+    negate: bool,\n+}\n+\n+impl Offset {\n+    fn negative(s: String) -> Self {\n+        Self {\n+            value: s,\n+            negate: true,\n+        }\n+    }\n+\n+    fn positive(s: String) -> Self {\n+        Self {\n+            value: s,\n+            negate: false,\n+        }\n+    }\n+}\n+\n+struct FixedOffsetVar {\n+    var_name: String,\n+    offset: Offset,\n+}\n+\n+fn is_slice_like<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty) -> bool {\n+    let is_slice = match ty.sty {\n+        ty::TyRef(_, ref subty) => is_slice_like(cx, subty.ty),\n+        ty::TySlice(..) | ty::TyArray(..) => true,\n+        _ => false,\n+    };\n+\n+    is_slice || match_type(cx, ty, &paths::VEC) || match_type(cx, ty, &paths::VEC_DEQUE)\n+}\n+\n+fn get_fixed_offset_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var: DefId) -> Option<FixedOffsetVar> {\n+    fn extract_offset<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, e: &Expr, var: DefId) -> Option<String> {\n+        match e.node {\n+            ExprLit(ref l) => match l.node {\n+                ast::LitKind::Int(x, _ty) => Some(x.to_string()),\n+                _ => None,\n+            },\n+            ExprPath(..) if !same_var(cx, e, var) => Some(snippet_opt(cx, e.span).unwrap_or_else(|| \"??\".into())),\n+            _ => None,\n+        }\n+    }\n+\n+    if let ExprIndex(ref seqexpr, ref idx) = expr.node {\n+        let ty = cx.tables.expr_ty(seqexpr);\n+        if !is_slice_like(cx, ty) {\n+            return None;\n+        }\n+\n+        let offset = match idx.node {\n+            ExprBinary(op, ref lhs, ref rhs) => match op.node {\n+                BinOp_::BiAdd => {\n+                    let offset_opt = if same_var(cx, lhs, var) {\n+                        extract_offset(cx, rhs, var)\n+                    } else if same_var(cx, rhs, var) {\n+                        extract_offset(cx, lhs, var)\n+                    } else {\n+                        None\n+                    };\n+\n+                    offset_opt.map(Offset::positive)\n+                },\n+                BinOp_::BiSub if same_var(cx, lhs, var) => extract_offset(cx, rhs, var).map(Offset::negative),\n+                _ => None,\n+            },\n+            ExprPath(..) => if same_var(cx, idx, var) {\n+                Some(Offset::positive(\"0\".into()))\n+            } else {\n+                None\n+            },\n+            _ => None,\n+        };\n+\n+        offset.map(|o| {\n+            FixedOffsetVar {\n+                var_name: snippet_opt(cx, seqexpr.span).unwrap_or_else(|| \"???\".into()),\n+                offset: o,\n+            }\n+        })\n+    } else {\n+        None\n+    }\n+}\n+\n+fn get_indexed_assignments<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    body: &Expr,\n+    var: DefId,\n+) -> Vec<(FixedOffsetVar, FixedOffsetVar)> {\n+    fn get_assignment<'a, 'tcx>(\n+        cx: &LateContext<'a, 'tcx>,\n+        e: &Expr,\n+        var: DefId,\n+    ) -> Option<(FixedOffsetVar, FixedOffsetVar)> {\n+        if let Expr_::ExprAssign(ref lhs, ref rhs) = e.node {\n+            match (get_fixed_offset_var(cx, lhs, var), get_fixed_offset_var(cx, rhs, var)) {\n+                (Some(offset_left), Some(offset_right)) => Some((offset_left, offset_right)),\n+                _ => None,\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    if let Expr_::ExprBlock(ref b) = body.node {\n+        let Block {\n+            ref stmts,\n+            ref expr,\n+            ..\n+        } = **b;\n+\n+        stmts\n+            .iter()\n+            .map(|stmt| match stmt.node {\n+                Stmt_::StmtDecl(..) => None,\n+                Stmt_::StmtExpr(ref e, _node_id) | Stmt_::StmtSemi(ref e, _node_id) => Some(get_assignment(cx, e, var)),\n+            })\n+            .chain(\n+                expr.as_ref()\n+                    .into_iter()\n+                    .map(|e| Some(get_assignment(cx, &*e, var))),\n+            )\n+            .filter_map(|op| op)\n+            .collect::<Option<Vec<_>>>()\n+            .unwrap_or_else(|| vec![])\n+    } else {\n+        get_assignment(cx, body, var).into_iter().collect()\n+    }\n+}\n+\n+/// Check for for loops that sequentially copy items from one slice-like\n+/// object to another.\n+fn detect_manual_memcpy<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    pat: &'tcx Pat,\n+    arg: &'tcx Expr,\n+    body: &'tcx Expr,\n+    expr: &'tcx Expr,\n+) {\n+    if let Some(higher::Range {\n+        start: Some(start),\n+        ref end,\n+        limits,\n+    }) = higher::range(arg)\n+    {\n+        // the var must be a single name\n+        if let PatKind::Binding(_, def_id, _, _) = pat.node {\n+            let print_sum = |arg1: &Offset, arg2: &Offset| -> String {\n+                match (&arg1.value[..], arg1.negate, &arg2.value[..], arg2.negate) {\n+                    (\"0\", _, \"0\", _) => \"\".into(),\n+                    (\"0\", _, x, false) | (x, false, \"0\", false) => x.into(),\n+                    (\"0\", _, x, true) | (x, false, \"0\", true) => format!(\"-{}\", x),\n+                    (x, false, y, false) => format!(\"({} + {})\", x, y),\n+                    (x, false, y, true) => format!(\"({} - {})\", x, y),\n+                    (x, true, y, false) => format!(\"({} - {})\", y, x),\n+                    (x, true, y, true) => format!(\"-({} + {})\", x, y),\n+                }\n+            };\n+\n+            let print_limit = |end: &Option<&Expr>, offset: Offset, var_name: &str| if let Some(end) = *end {\n+                if_let_chain! {[\n+                    let ExprMethodCall(ref method, _, ref len_args) = end.node,\n+                    method.name == \"len\",\n+                    len_args.len() == 1,\n+                    let Some(arg) = len_args.get(0),\n+                    snippet(cx, arg.span, \"??\") == var_name,\n+                ], {\n+                    return if offset.negate {\n+                        format!(\"({} - {})\", snippet(cx, end.span, \"<src>.len()\"), offset.value)\n+                    } else {\n+                        \"\".to_owned()\n+                    };\n+                }}\n+\n+                let end_str = match limits {\n+                    ast::RangeLimits::Closed => {\n+                        let end = sugg::Sugg::hir(cx, end, \"<count>\");\n+                        format!(\"{}\", end + sugg::ONE)\n+                    },\n+                    ast::RangeLimits::HalfOpen => format!(\"{}\", snippet(cx, end.span, \"..\")),\n+                };\n+\n+                print_sum(&Offset::positive(end_str), &offset)\n+            } else {\n+                \"..\".into()\n+            };\n+\n+            // The only statements in the for loops can be indexed assignments from\n+            // indexed retrievals.\n+            let manual_copies = get_indexed_assignments(cx, body, def_id);\n+\n+            let big_sugg = manual_copies\n+                .into_iter()\n+                .map(|(dst_var, src_var)| {\n+                    let start_str = Offset::positive(snippet_opt(cx, start.span).unwrap_or_else(|| \"\".into()));\n+                    let dst_offset = print_sum(&start_str, &dst_var.offset);\n+                    let dst_limit = print_limit(end, dst_var.offset, &dst_var.var_name);\n+                    let src_offset = print_sum(&start_str, &src_var.offset);\n+                    let src_limit = print_limit(end, src_var.offset, &src_var.var_name);\n+                    let dst = if dst_offset == \"\" && dst_limit == \"\" {\n+                        dst_var.var_name\n+                    } else {\n+                        format!(\"{}[{}..{}]\", dst_var.var_name, dst_offset, dst_limit)\n+                    };\n+\n+                    format!(\"{}.clone_from_slice(&{}[{}..{}])\", dst, src_var.var_name, src_offset, src_limit)\n+                })\n+                .join(\"\\n    \");\n+\n+            if !big_sugg.is_empty() {\n+                span_lint_and_sugg(\n+                    cx,\n+                    MANUAL_MEMCPY,\n+                    expr.span,\n+                    \"it looks like you're manually copying between slices\",\n+                    \"try replacing the loop by\",\n+                    big_sugg,\n+                );\n+            }\n+        }\n+    }\n }\n \n /// Check for looping over a range and then indexing a sequence with it.\n@@ -595,10 +846,10 @@ fn check_for_loop_range<'a, 'tcx>(\n     expr: &'tcx Expr,\n ) {\n     if let Some(higher::Range {\n-                    start: Some(start),\n-                    ref end,\n-                    limits,\n-                }) = higher::range(arg)\n+        start: Some(start),\n+        ref end,\n+        limits,\n+    }) = higher::range(arg)\n     {\n         // the var must be a single name\n         if let PatKind::Binding(_, def_id, ref ident, _) = pat.node {\n@@ -613,9 +864,11 @@ fn check_for_loop_range<'a, 'tcx>(\n \n             // linting condition: we only indexed one variable\n             if visitor.indexed.len() == 1 {\n-                let (indexed, indexed_extent) = visitor.indexed.into_iter().next().expect(\n-                    \"already checked that we have exactly 1 element\",\n-                );\n+                let (indexed, indexed_extent) = visitor\n+                    .indexed\n+                    .into_iter()\n+                    .next()\n+                    .expect(\"already checked that we have exactly 1 element\");\n \n                 // ensure that the indexed variable was declared before the loop, see #601\n                 if let Some(indexed_extent) = indexed_extent {\n@@ -659,34 +912,42 @@ fn check_for_loop_range<'a, 'tcx>(\n                 };\n \n                 if visitor.nonindex {\n-                    span_lint_and_then(cx,\n-                                       NEEDLESS_RANGE_LOOP,\n-                                       expr.span,\n-                                       &format!(\"the loop variable `{}` is used to index `{}`\", ident.node, indexed),\n-                                       |db| {\n-                        multispan_sugg(db,\n-                                       \"consider using an iterator\".to_string(),\n-                                       vec![(pat.span, format!(\"({}, <item>)\", ident.node)),\n-                                            (arg.span, format!(\"{}.iter().enumerate(){}{}\", indexed, take, skip))]);\n-                    });\n+                    span_lint_and_then(\n+                        cx,\n+                        NEEDLESS_RANGE_LOOP,\n+                        expr.span,\n+                        &format!(\"the loop variable `{}` is used to index `{}`\", ident.node, indexed),\n+                        |db| {\n+                            multispan_sugg(\n+                                db,\n+                                \"consider using an iterator\".to_string(),\n+                                vec![\n+                                    (pat.span, format!(\"({}, <item>)\", ident.node)),\n+                                    (arg.span, format!(\"{}.iter().enumerate(){}{}\", indexed, take, skip)),\n+                                ],\n+                            );\n+                        },\n+                    );\n                 } else {\n                     let repl = if starts_at_zero && take.is_empty() {\n                         format!(\"&{}\", indexed)\n                     } else {\n                         format!(\"{}.iter(){}{}\", indexed, take, skip)\n                     };\n \n-                    span_lint_and_then(cx,\n-                                       NEEDLESS_RANGE_LOOP,\n-                                       expr.span,\n-                                       &format!(\"the loop variable `{}` is only used to index `{}`.\",\n-                                                ident.node,\n-                                                indexed),\n-                                       |db| {\n-                        multispan_sugg(db,\n-                                       \"consider using an iterator\".to_string(),\n-                                       vec![(pat.span, \"<item>\".to_string()), (arg.span, repl)]);\n-                    });\n+                    span_lint_and_then(\n+                        cx,\n+                        NEEDLESS_RANGE_LOOP,\n+                        expr.span,\n+                        &format!(\"the loop variable `{}` is only used to index `{}`.\", ident.node, indexed),\n+                        |db| {\n+                            multispan_sugg(\n+                                db,\n+                                \"consider using an iterator\".to_string(),\n+                                vec![(pat.span, \"<item>\".to_string()), (arg.span, repl)],\n+                            );\n+                        },\n+                    );\n                 }\n             }\n         }\n@@ -711,10 +972,10 @@ fn is_len_call(expr: &Expr, var: &Name) -> bool {\n fn check_for_loop_reverse_range(cx: &LateContext, arg: &Expr, expr: &Expr) {\n     // if this for loop is iterating over a two-sided range...\n     if let Some(higher::Range {\n-                    start: Some(start),\n-                    end: Some(end),\n-                    limits,\n-                }) = higher::range(arg)\n+        start: Some(start),\n+        end: Some(end),\n+        limits,\n+    }) = higher::range(arg)\n     {\n         // ...and both sides are compile-time constant integers...\n         let parent_item = cx.tcx.hir.get_parent(arg.id);\n@@ -743,19 +1004,25 @@ fn check_for_loop_reverse_range(cx: &LateContext, arg: &Expr, expr: &Expr) {\n                         \"..\"\n                     };\n \n-                    span_lint_and_then(cx,\n-                                       REVERSE_RANGE_LOOP,\n-                                       expr.span,\n-                                       \"this range is empty so this for loop will never run\",\n-                                       |db| {\n-                        db.span_suggestion(arg.span,\n-                                           \"consider using the following if you are attempting to iterate over this \\\n-                                            range in reverse\",\n-                                           format!(\"({end}{dots}{start}).rev()\",\n-                                                   end = end_snippet,\n-                                                   dots = dots,\n-                                                   start = start_snippet));\n-                    });\n+                    span_lint_and_then(\n+                        cx,\n+                        REVERSE_RANGE_LOOP,\n+                        expr.span,\n+                        \"this range is empty so this for loop will never run\",\n+                        |db| {\n+                            db.span_suggestion(\n+                                arg.span,\n+                                \"consider using the following if you are attempting to iterate over this \\\n+                                 range in reverse\",\n+                                format!(\n+                                    \"({end}{dots}{start}).rev()\",\n+                                    end = end_snippet,\n+                                    dots = dots,\n+                                    start = start_snippet\n+                                ),\n+                            );\n+                        },\n+                    );\n                 } else if eq && limits != ast::RangeLimits::Closed {\n                     // if they are equal, it's also problematic - this loop\n                     // will never run.\n@@ -783,7 +1050,7 @@ fn lint_iter_method(cx: &LateContext, args: &[Expr], arg: &Expr, method_name: &s\n         EXPLICIT_ITER_LOOP,\n         arg.span,\n         \"it is more idiomatic to loop over references to containers instead of using explicit \\\n-                        iteration methods\",\n+         iteration methods\",\n         \"to write this more concisely, try\",\n         format!(\"&{}{}\", muta, object),\n     )\n@@ -816,7 +1083,7 @@ fn check_for_loop_arg(cx: &LateContext, pat: &Pat, arg: &Expr, expr: &Expr) {\n                         EXPLICIT_INTO_ITER_LOOP,\n                         arg.span,\n                         \"it is more idiomatic to loop over containers instead of using explicit \\\n-                                        iteration methods`\",\n+                         iteration methods`\",\n                         \"to write this more concisely, try\",\n                         object.to_string(),\n                     );\n@@ -827,7 +1094,7 @@ fn check_for_loop_arg(cx: &LateContext, pat: &Pat, arg: &Expr, expr: &Expr) {\n                     ITER_NEXT_LOOP,\n                     expr.span,\n                     \"you are iterating over `Iterator::next()` which is an Option; this will compile but is \\\n-                           probably not what you want\",\n+                     probably not what you want\",\n                 );\n                 next_loop_linted = true;\n             }\n@@ -848,7 +1115,7 @@ fn check_arg_type(cx: &LateContext, pat: &Pat, arg: &Expr) {\n             arg.span,\n             &format!(\n                 \"for loop over `{0}`, which is an `Option`. This is more readably written as an \\\n-                                     `if let` statement.\",\n+                 `if let` statement.\",\n                 snippet(cx, arg.span, \"_\")\n             ),\n             &format!(\n@@ -864,7 +1131,7 @@ fn check_arg_type(cx: &LateContext, pat: &Pat, arg: &Expr) {\n             arg.span,\n             &format!(\n                 \"for loop over `{0}`, which is a `Result`. This is more readably written as an \\\n-                                     `if let` statement.\",\n+                 `if let` statement.\",\n                 snippet(cx, arg.span, \"_\")\n             ),\n             &format!(\n@@ -894,14 +1161,14 @@ fn check_for_loop_explicit_counter<'a, 'tcx>(\n     // For each candidate, check the parent block to see if\n     // it's initialized to zero at the start of the loop.\n     let map = &cx.tcx.hir;\n-    let parent_scope = map.get_enclosing_scope(expr.id).and_then(|id| {\n-        map.get_enclosing_scope(id)\n-    });\n+    let parent_scope = map.get_enclosing_scope(expr.id)\n+        .and_then(|id| map.get_enclosing_scope(id));\n     if let Some(parent_id) = parent_scope {\n         if let NodeBlock(block) = map.get(parent_id) {\n-            for (id, _) in visitor.states.iter().filter(\n-                |&(_, v)| *v == VarState::IncrOnce,\n-            )\n+            for (id, _) in visitor\n+                .states\n+                .iter()\n+                .filter(|&(_, v)| *v == VarState::IncrOnce)\n             {\n                 let mut visitor2 = InitializeVisitor {\n                     cx: cx,\n@@ -922,7 +1189,7 @@ fn check_for_loop_explicit_counter<'a, 'tcx>(\n                             expr.span,\n                             &format!(\n                                 \"the variable `{0}` is used as a loop counter. Consider using `for ({0}, \\\n-                                            item) in {1}.enumerate()` or similar iterators\",\n+                                 item) in {1}.enumerate()` or similar iterators\",\n                                 name,\n                                 snippet(cx, arg.span, \"_\")\n                             ),\n@@ -948,12 +1215,10 @@ fn check_for_loop_over_map_kv<'a, 'tcx>(\n         if pat.len() == 2 {\n             let arg_span = arg.span;\n             let (new_pat_span, kind, ty, mutbl) = match cx.tables.expr_ty(arg).sty {\n-                ty::TyRef(_, ref tam) => {\n-                    match (&pat[0].node, &pat[1].node) {\n-                        (key, _) if pat_is_wild(key, body) => (pat[1].span, \"value\", tam.ty, tam.mutbl),\n-                        (_, value) if pat_is_wild(value, body) => (pat[0].span, \"key\", tam.ty, MutImmutable),\n-                        _ => return,\n-                    }\n+                ty::TyRef(_, ref tam) => match (&pat[0].node, &pat[1].node) {\n+                    (key, _) if pat_is_wild(key, body) => (pat[1].span, \"value\", tam.ty, tam.mutbl),\n+                    (_, value) if pat_is_wild(value, body) => (pat[0].span, \"key\", tam.ty, MutImmutable),\n+                    _ => return,\n                 },\n                 _ => return,\n             };\n@@ -967,21 +1232,26 @@ fn check_for_loop_over_map_kv<'a, 'tcx>(\n             };\n \n             if match_type(cx, ty, &paths::HASHMAP) || match_type(cx, ty, &paths::BTREEMAP) {\n-                span_lint_and_then(cx,\n-                                   FOR_KV_MAP,\n-                                   expr.span,\n-                                   &format!(\"you seem to want to iterate on a map's {}s\", kind),\n-                                   |db| {\n-                    let map = sugg::Sugg::hir(cx, arg, \"map\");\n-                    multispan_sugg(db,\n-                                   \"use the corresponding method\".into(),\n-                                   vec![(pat_span, snippet(cx, new_pat_span, kind).into_owned()),\n-                                        (arg_span, format!(\"{}.{}s{}()\", map.maybe_par(), kind, mutbl))]);\n-                });\n+                span_lint_and_then(\n+                    cx,\n+                    FOR_KV_MAP,\n+                    expr.span,\n+                    &format!(\"you seem to want to iterate on a map's {}s\", kind),\n+                    |db| {\n+                        let map = sugg::Sugg::hir(cx, arg, \"map\");\n+                        multispan_sugg(\n+                            db,\n+                            \"use the corresponding method\".into(),\n+                            vec![\n+                                (pat_span, snippet(cx, new_pat_span, kind).into_owned()),\n+                                (arg_span, format!(\"{}.{}s{}()\", map.maybe_par(), kind, mutbl)),\n+                            ],\n+                        );\n+                    },\n+                );\n             }\n         }\n     }\n-\n }\n \n /// Return true if the pattern is a `PatWild` or an ident prefixed with `'_'`.\n@@ -1011,16 +1281,36 @@ fn match_var(expr: &Expr, var: Name) -> bool {\n \n struct UsedVisitor {\n     var: ast::Name, // var to look for\n-    used: bool, // has the var been used otherwise?\n+    used: bool,     // has the var been used otherwise?\n }\n \n impl<'tcx> Visitor<'tcx> for UsedVisitor {\n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n         if match_var(expr, self.var) {\n             self.used = true;\n-            return;\n+        } else {\n+            walk_expr(self, expr);\n+        }\n+    }\n+\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+struct DefIdUsedVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+    def_id: DefId,\n+    used: bool,\n+}\n+\n+impl<'a, 'tcx: 'a> Visitor<'tcx> for DefIdUsedVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+        if same_var(self.cx, expr, self.def_id) {\n+            self.used = true;\n+        } else {\n+            walk_expr(self, expr);\n         }\n-        walk_expr(self, expr);\n     }\n \n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n@@ -1048,40 +1338,46 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n         if_let_chain! {[\n             // an index op\n             let ExprIndex(ref seqexpr, ref idx) = expr.node,\n-            // directly indexing a variable\n-            let ExprPath(ref qpath) = idx.node,\n-            let QPath::Resolved(None, ref path) = *qpath,\n-            path.segments.len() == 1,\n-            // our variable!\n-            self.cx.tables.qpath_def(qpath, expr.hir_id).def_id() == self.var,\n             // the indexed container is referenced by a name\n             let ExprPath(ref seqpath) = seqexpr.node,\n             let QPath::Resolved(None, ref seqvar) = *seqpath,\n             seqvar.segments.len() == 1,\n         ], {\n-            let def = self.cx.tables.qpath_def(seqpath, seqexpr.hir_id);\n-            match def {\n-                Def::Local(..) | Def::Upvar(..) => {\n-                    let def_id = def.def_id();\n-                    let node_id = self.cx.tcx.hir.as_local_node_id(def_id).expect(\"local/upvar are local nodes\");\n-                    let hir_id = self.cx.tcx.hir.node_to_hir_id(node_id);\n-\n-                    let parent_id = self.cx.tcx.hir.get_parent(expr.id);\n-                    let parent_def_id = self.cx.tcx.hir.local_def_id(parent_id);\n-                    let extent = self.cx.tcx.region_scope_tree(parent_def_id).var_scope(hir_id.local_id);\n-                    self.indexed.insert(seqvar.segments[0].name, Some(extent));\n-                    return;  // no need to walk further\n-                }\n-                Def::Static(..) | Def::Const(..) => {\n-                    self.indexed.insert(seqvar.segments[0].name, None);\n-                    return;  // no need to walk further\n+            let index_used = same_var(self.cx, idx, self.var) || {\n+                let mut used_visitor = DefIdUsedVisitor {\n+                    cx: self.cx,\n+                    def_id: self.var,\n+                    used: false,\n+                };\n+                walk_expr(&mut used_visitor, idx);\n+                used_visitor.used\n+            };\n+\n+            if index_used {\n+                let def = self.cx.tables.qpath_def(seqpath, seqexpr.hir_id);\n+                match def {\n+                    Def::Local(..) | Def::Upvar(..) => {\n+                        let def_id = def.def_id();\n+                        let node_id = self.cx.tcx.hir.as_local_node_id(def_id).expect(\"local/upvar are local nodes\");\n+                        let hir_id = self.cx.tcx.hir.node_to_hir_id(node_id);\n+\n+                        let parent_id = self.cx.tcx.hir.get_parent(expr.id);\n+                        let parent_def_id = self.cx.tcx.hir.local_def_id(parent_id);\n+                        let extent = self.cx.tcx.region_scope_tree(parent_def_id).var_scope(hir_id.local_id);\n+                        self.indexed.insert(seqvar.segments[0].name, Some(extent));\n+                        return;  // no need to walk further *on the variable*\n+                    }\n+                    Def::Static(..) | Def::Const(..) => {\n+                        self.indexed.insert(seqvar.segments[0].name, None);\n+                        return;  // no need to walk further *on the variable*\n+                    }\n+                    _ => (),\n                 }\n-                _ => (),\n             }\n         }}\n \n         if_let_chain! {[\n-            // directly indexing a variable\n+            // directly using a variable\n             let ExprPath(ref qpath) = expr.node,\n             let QPath::Resolved(None, ref path) = *qpath,\n             path.segments.len() == 1,\n@@ -1196,12 +1492,9 @@ fn extract_expr_from_first_stmt(block: &Block) -> Option<&Expr> {\n fn extract_first_expr(block: &Block) -> Option<&Expr> {\n     match block.expr {\n         Some(ref expr) if block.stmts.is_empty() => Some(expr),\n-        None if !block.stmts.is_empty() => {\n-            match block.stmts[0].node {\n-                StmtExpr(ref expr, _) |\n-                StmtSemi(ref expr, _) => Some(expr),\n-                StmtDecl(..) => None,\n-            }\n+        None if !block.stmts.is_empty() => match block.stmts[0].node {\n+            StmtExpr(ref expr, _) | StmtSemi(ref expr, _) => Some(expr),\n+            StmtDecl(..) => None,\n         },\n         _ => None,\n     }\n@@ -1211,11 +1504,9 @@ fn extract_first_expr(block: &Block) -> Option<&Expr> {\n fn is_break_expr(expr: &Expr) -> bool {\n     match expr.node {\n         ExprBreak(dest, _) if dest.ident.is_none() => true,\n-        ExprBlock(ref b) => {\n-            match extract_first_expr(b) {\n-                Some(subexpr) => is_break_expr(subexpr),\n-                None => false,\n-            }\n+        ExprBlock(ref b) => match extract_first_expr(b) {\n+            Some(subexpr) => is_break_expr(subexpr),\n+            None => false,\n         },\n         _ => false,\n     }\n@@ -1226,7 +1517,7 @@ fn is_break_expr(expr: &Expr) -> bool {\n // at the start of the loop.\n #[derive(PartialEq)]\n enum VarState {\n-    Initial, // Not examined yet\n+    Initial,  // Not examined yet\n     IncrOnce, // Incremented exactly once, may be a loop counter\n     Declared, // Declared but not (yet) initialized to zero\n     Warn,\n@@ -1235,9 +1526,9 @@ enum VarState {\n \n /// Scan a for loop for variables that are incremented exactly once.\n struct IncrementVisitor<'a, 'tcx: 'a> {\n-    cx: &'a LateContext<'a, 'tcx>, // context reference\n+    cx: &'a LateContext<'a, 'tcx>,     // context reference\n     states: HashMap<NodeId, VarState>, // incremented variables\n-    depth: u32, // depth of conditional expressions\n+    depth: u32,                        // depth of conditional expressions\n     done: bool,\n }\n \n@@ -1291,7 +1582,7 @@ impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n /// Check whether a variable is initialized to zero at the start of a loop.\n struct InitializeVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>, // context reference\n-    end_expr: &'tcx Expr, // the for loop. Stop scanning here.\n+    end_expr: &'tcx Expr,          // the for loop. Stop scanning here.\n     var_id: NodeId,\n     state: VarState,\n     name: Option<Name>,\n@@ -1379,9 +1670,10 @@ fn var_def_id(cx: &LateContext, expr: &Expr) -> Option<NodeId> {\n     if let ExprPath(ref qpath) = expr.node {\n         let path_res = cx.tables.qpath_def(qpath, expr.hir_id);\n         if let Def::Local(def_id) = path_res {\n-            let node_id = cx.tcx.hir.as_local_node_id(def_id).expect(\n-                \"That DefId should be valid\",\n-            );\n+            let node_id = cx.tcx\n+                .hir\n+                .as_local_node_id(def_id)\n+                .expect(\"That DefId should be valid\");\n             return Some(node_id);\n         }\n     }\n@@ -1425,13 +1717,11 @@ fn is_loop_nested(cx: &LateContext, loop_expr: &Expr, iter_expr: &Expr) -> bool\n             return false;\n         }\n         match cx.tcx.hir.find(parent) {\n-            Some(NodeExpr(expr)) => {\n-                match expr.node {\n-                    ExprLoop(..) | ExprWhile(..) => {\n-                        return true;\n-                    },\n-                    _ => (),\n-                }\n+            Some(NodeExpr(expr)) => match expr.node {\n+                ExprLoop(..) | ExprWhile(..) => {\n+                    return true;\n+                },\n+                _ => (),\n             },\n             Some(NodeBlock(block)) => {\n                 let mut block_visitor = LoopNestVisitor {\n@@ -1455,12 +1745,12 @@ fn is_loop_nested(cx: &LateContext, loop_expr: &Expr, iter_expr: &Expr) -> bool\n \n #[derive(PartialEq, Eq)]\n enum Nesting {\n-    Unknown, // no nesting detected yet\n-    RuledOut, // the iterator is initialized or assigned within scope\n+    Unknown,     // no nesting detected yet\n+    RuledOut,    // the iterator is initialized or assigned within scope\n     LookFurther, // no nesting detected, no further walk required\n }\n \n-use self::Nesting::{Unknown, RuledOut, LookFurther};\n+use self::Nesting::{LookFurther, RuledOut, Unknown};\n \n struct LoopNestVisitor {\n     id: NodeId,\n@@ -1486,11 +1776,8 @@ impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n             return;\n         }\n         match expr.node {\n-            ExprAssign(ref path, _) |\n-            ExprAssignOp(_, ref path, _) => {\n-                if match_var(path, self.iterator) {\n-                    self.nesting = RuledOut;\n-                }\n+            ExprAssign(ref path, _) | ExprAssignOp(_, ref path, _) => if match_var(path, self.iterator) {\n+                self.nesting = RuledOut;\n             },\n             _ => walk_expr(self, expr),\n         }"}, {"sha": "733022f1703f7fa2c2d5aea103aac825f2cd031c", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -2,8 +2,8 @@ use rustc::lint::*;\n use rustc::hir::*;\n use rustc::ty;\n use syntax::ast;\n-use utils::{is_adjusted, match_qpath, match_trait_method, match_type, remove_blocks, paths, snippet,\n-            span_help_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, iter_input_pats};\n+use utils::{is_adjusted, iter_input_pats, match_qpath, match_trait_method, match_type, paths, remove_blocks, snippet,\n+            span_help_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth};\n \n /// **What it does:** Checks for mapping `clone()` over an iterator.\n ///\n@@ -73,21 +73,19 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                             }\n                         }}\n                     },\n-                    ExprPath(ref path) => {\n-                        if match_qpath(path, &paths::CLONE) {\n-                            let type_name = get_type_name(cx, expr, &args[0]).unwrap_or(\"_\");\n-                            span_help_and_lint(\n-                                cx,\n-                                MAP_CLONE,\n-                                expr.span,\n-                                &format!(\n-                                    \"you seem to be using .map() to clone the contents of an \\\n-                                                         {}, consider using `.cloned()`\",\n-                                    type_name\n-                                ),\n-                                &format!(\"try\\n{}.cloned()\", snippet(cx, args[0].span, \"..\")),\n-                            );\n-                        }\n+                    ExprPath(ref path) => if match_qpath(path, &paths::CLONE) {\n+                        let type_name = get_type_name(cx, expr, &args[0]).unwrap_or(\"_\");\n+                        span_help_and_lint(\n+                            cx,\n+                            MAP_CLONE,\n+                            expr.span,\n+                            &format!(\n+                                \"you seem to be using .map() to clone the contents of an \\\n+                                 {}, consider using `.cloned()`\",\n+                                type_name\n+                            ),\n+                            &format!(\"try\\n{}.cloned()\", snippet(cx, args[0].span, \"..\")),\n+                        );\n                     },\n                     _ => (),\n                 }"}, {"sha": "b9a4507c5d7e6ad00d4fe369b37e63d95c333fc6", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 50, "deletions": 68, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -11,8 +11,8 @@ use syntax::ast::LitKind;\n use syntax::ast::NodeId;\n use syntax::codemap::Span;\n use utils::paths;\n-use utils::{match_type, snippet, span_note_and_lint, span_lint_and_then, span_lint_and_sugg, in_external_macro,\n-            expr_block, walk_ptrs_ty, is_expn_of, remove_blocks, is_allowed};\n+use utils::{expr_block, in_external_macro, is_allowed, is_expn_of, match_type, remove_blocks, snippet,\n+            span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty};\n use utils::sugg::Sugg;\n \n /// **What it does:** Checks for matches with a single arm where an `if let`\n@@ -219,7 +219,7 @@ fn report_single_match_single_pattern(cx: &LateContext, ex: &Expr, arms: &[Arm],\n         lint,\n         expr.span,\n         \"you seem to be trying to use match for destructuring a single pattern. Consider using `if \\\n-                        let`\",\n+         let`\",\n         \"try this\",\n         format!(\n             \"if let {} = {} {}{}\",\n@@ -290,21 +290,17 @@ fn check_match_bool(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n \n                     if let Some((true_expr, false_expr)) = exprs {\n                         let sugg = match (is_unit_expr(true_expr), is_unit_expr(false_expr)) {\n-                            (false, false) => {\n-                                Some(format!(\n-                                    \"if {} {} else {}\",\n-                                    snippet(cx, ex.span, \"b\"),\n-                                    expr_block(cx, true_expr, None, \"..\"),\n-                                    expr_block(cx, false_expr, None, \"..\")\n-                                ))\n-                            },\n-                            (false, true) => {\n-                                Some(format!(\n-                                    \"if {} {}\",\n-                                    snippet(cx, ex.span, \"b\"),\n-                                    expr_block(cx, true_expr, None, \"..\")\n-                                ))\n-                            },\n+                            (false, false) => Some(format!(\n+                                \"if {} {} else {}\",\n+                                snippet(cx, ex.span, \"b\"),\n+                                expr_block(cx, true_expr, None, \"..\"),\n+                                expr_block(cx, false_expr, None, \"..\")\n+                            )),\n+                            (false, true) => Some(format!(\n+                                \"if {} {}\",\n+                                snippet(cx, ex.span, \"b\"),\n+                                expr_block(cx, true_expr, None, \"..\")\n+                            )),\n                             (true, false) => {\n                                 let test = Sugg::hir(cx, ex, \"..\");\n                                 Some(format!(\"if {} {}\", !test, expr_block(cx, false_expr, None, \"..\")))\n@@ -317,7 +313,6 @@ fn check_match_bool(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n                         }\n                     }\n                 }\n-\n             },\n         );\n     }\n@@ -384,15 +379,17 @@ fn is_panic_block(block: &Block) -> bool {\n fn check_match_ref_pats(cx: &LateContext, ex: &Expr, arms: &[Arm], source: MatchSource, expr: &Expr) {\n     if has_only_ref_pats(arms) {\n         if let ExprAddrOf(Mutability::MutImmutable, ref inner) = ex.node {\n-            span_lint_and_then(cx,\n-                               MATCH_REF_PATS,\n-                               expr.span,\n-                               \"you don't need to add `&` to both the expression and the patterns\",\n-                               |db| {\n-                let inner = Sugg::hir(cx, inner, \"..\");\n-                let template = match_template(expr.span, source, &inner);\n-                db.span_suggestion(expr.span, \"try\", template);\n-            });\n+            span_lint_and_then(\n+                cx,\n+                MATCH_REF_PATS,\n+                expr.span,\n+                \"you don't need to add `&` to both the expression and the patterns\",\n+                |db| {\n+                    let inner = Sugg::hir(cx, inner, \"..\");\n+                    let template = match_template(expr.span, source, &inner);\n+                    db.span_suggestion(expr.span, \"try\", template);\n+                },\n+            );\n         } else {\n             span_lint_and_then(\n                 cx,\n@@ -471,24 +468,18 @@ fn type_ranges(ranges: &[SpannedRange<ConstVal>]) -> TypedRanges {\n     ranges\n         .iter()\n         .filter_map(|range| match range.node {\n-            (ConstVal::Integral(start), Bound::Included(ConstVal::Integral(end))) => {\n-                Some(SpannedRange {\n-                    span: range.span,\n-                    node: (start, Bound::Included(end)),\n-                })\n-            },\n-            (ConstVal::Integral(start), Bound::Excluded(ConstVal::Integral(end))) => {\n-                Some(SpannedRange {\n-                    span: range.span,\n-                    node: (start, Bound::Excluded(end)),\n-                })\n-            },\n-            (ConstVal::Integral(start), Bound::Unbounded) => {\n-                Some(SpannedRange {\n-                    span: range.span,\n-                    node: (start, Bound::Unbounded),\n-                })\n-            },\n+            (ConstVal::Integral(start), Bound::Included(ConstVal::Integral(end))) => Some(SpannedRange {\n+                span: range.span,\n+                node: (start, Bound::Included(end)),\n+            }),\n+            (ConstVal::Integral(start), Bound::Excluded(ConstVal::Integral(end))) => Some(SpannedRange {\n+                span: range.span,\n+                node: (start, Bound::Excluded(end)),\n+            }),\n+            (ConstVal::Integral(start), Bound::Unbounded) => Some(SpannedRange {\n+                span: range.span,\n+                node: (start, Bound::Unbounded),\n+            }),\n             _ => None,\n         })\n         .collect()\n@@ -507,9 +498,9 @@ fn has_only_ref_pats(arms: &[Arm]) -> bool {\n         .flat_map(|a| &a.pats)\n         .map(|p| {\n             match p.node {\n-                PatKind::Ref(..) => Some(true),  // &-patterns\n+                PatKind::Ref(..) => Some(true), // &-patterns\n                 PatKind::Wild => Some(false),   // an \"anything\" wildcard is also fine\n-                _ => None,                    // any other pattern is not fine\n+                _ => None,                      // any other pattern is not fine\n             }\n         })\n         .collect::<Option<Vec<bool>>>();\n@@ -540,8 +531,7 @@ where\n     impl<'a, T: Copy> Kind<'a, T> {\n         fn range(&self) -> &'a SpannedRange<T> {\n             match *self {\n-                Kind::Start(_, r) |\n-                Kind::End(_, r) => r,\n+                Kind::Start(_, r) | Kind::End(_, r) => r,\n             }\n         }\n \n@@ -562,22 +552,16 @@ where\n     impl<'a, T: Copy + Ord> Ord for Kind<'a, T> {\n         fn cmp(&self, other: &Self) -> Ordering {\n             match (self.value(), other.value()) {\n-                (Bound::Included(a), Bound::Included(b)) |\n-                (Bound::Excluded(a), Bound::Excluded(b)) => a.cmp(&b),\n+                (Bound::Included(a), Bound::Included(b)) | (Bound::Excluded(a), Bound::Excluded(b)) => a.cmp(&b),\n                 // Range patterns cannot be unbounded (yet)\n-                (Bound::Unbounded, _) |\n-                (_, Bound::Unbounded) => unimplemented!(),\n-                (Bound::Included(a), Bound::Excluded(b)) => {\n-                    match a.cmp(&b) {\n-                        Ordering::Equal => Ordering::Greater,\n-                        other => other,\n-                    }\n+                (Bound::Unbounded, _) | (_, Bound::Unbounded) => unimplemented!(),\n+                (Bound::Included(a), Bound::Excluded(b)) => match a.cmp(&b) {\n+                    Ordering::Equal => Ordering::Greater,\n+                    other => other,\n                 },\n-                (Bound::Excluded(a), Bound::Included(b)) => {\n-                    match a.cmp(&b) {\n-                        Ordering::Equal => Ordering::Less,\n-                        other => other,\n-                    }\n+                (Bound::Excluded(a), Bound::Included(b)) => match a.cmp(&b) {\n+                    Ordering::Equal => Ordering::Less,\n+                    other => other,\n                 },\n             }\n         }\n@@ -594,10 +578,8 @@ where\n \n     for (a, b) in values.iter().zip(values.iter().skip(1)) {\n         match (a, b) {\n-            (&Kind::Start(_, ra), &Kind::End(_, rb)) => {\n-                if ra.node != rb.node {\n-                    return Some((ra, rb));\n-                }\n+            (&Kind::Start(_, ra), &Kind::End(_, rb)) => if ra.node != rb.node {\n+                return Some((ra, rb));\n             },\n             (&Kind::End(a, _), &Kind::Start(b, _)) if a != Bound::Included(b) => (),\n             _ => return Some((a.range(), b.range())),"}, {"sha": "9058d0d102da3ab6893a08f83b9cc1b52f937296", "filename": "clippy_lints/src/mem_forget.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_forget.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -39,8 +39,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemForget {\n                     if match forgot_ty.ty_adt_def() {\n                         Some(def) => def.has_dtor(cx.tcx),\n                         _ => false,\n-                    }\n-                    {\n+                    } {\n                         span_lint(cx, MEM_FORGET, e.span, \"usage of mem::forget on Drop type\");\n                     }\n                 }"}, {"sha": "84c213023a2d3ba901ac6d17b8707e8b3f7ad400", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 44, "deletions": 48, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -8,10 +8,10 @@ use rustc_const_eval::ConstContext;\n use std::borrow::Cow;\n use std::fmt;\n use syntax::codemap::Span;\n-use utils::{get_trait_def_id, implements_trait, in_external_macro, in_macro, is_copy, match_qpath, match_trait_method,\n-            match_type, method_chain_args, return_ty, same_tys, snippet, span_lint, span_lint_and_then,\n-            span_lint_and_sugg, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, last_path_segment,\n-            single_segment_path, match_def_path, is_self, is_self_ty, iter_input_pats, match_path};\n+use utils::{get_trait_def_id, implements_trait, in_external_macro, in_macro, is_copy, is_self, is_self_ty,\n+            iter_input_pats, last_path_segment, match_def_path, match_path, match_qpath, match_trait_method,\n+            match_type, method_chain_args, return_ty, same_tys, single_segment_path, snippet, span_lint,\n+            span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth};\n use utils::paths;\n use utils::sugg;\n \n@@ -618,11 +618,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 }\n \n                 match self_ty.sty {\n-                    ty::TyRef(_, ty) if ty.ty.sty == ty::TyStr => {\n-                        for &(method, pos) in &PATTERN_METHODS {\n-                            if method_call.name == method && args.len() > pos {\n-                                lint_single_char_pattern(cx, expr, &args[pos]);\n-                            }\n+                    ty::TyRef(_, ty) if ty.ty.sty == ty::TyStr => for &(method, pos) in &PATTERN_METHODS {\n+                        if method_call.name == method && args.len() > pos {\n+                            lint_single_char_pattern(cx, expr, &args[pos]);\n                         }\n                     },\n                     _ => (),\n@@ -723,12 +721,11 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir:\n \n                 if [\"default\", \"new\"].contains(&path) {\n                     let arg_ty = cx.tables.expr_ty(arg);\n-                    let default_trait_id =\n-                        if let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT) {\n-                            default_trait_id\n-                        } else {\n-                            return false;\n-                        };\n+                    let default_trait_id = if let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT) {\n+                        default_trait_id\n+                    } else {\n+                        return false;\n+                    };\n \n                     if implements_trait(cx, arg_ty, default_trait_id, &[]) {\n                         span_lint_and_sugg(\n@@ -771,13 +768,12 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir:\n         }\n \n         // (path, fn_has_argument, methods, suffix)\n-        let know_types: &[(&[_], _, &[_], _)] =\n-            &[\n-                (&paths::BTREEMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n-                (&paths::HASHMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n-                (&paths::OPTION, false, &[\"map_or\", \"ok_or\", \"or\", \"unwrap_or\"], \"else\"),\n-                (&paths::RESULT, true, &[\"or\", \"unwrap_or\"], \"else\"),\n-            ];\n+        let know_types: &[(&[_], _, &[_], _)] = &[\n+            (&paths::BTREEMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n+            (&paths::HASHMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n+            (&paths::OPTION, false, &[\"map_or\", \"ok_or\", \"or\", \"unwrap_or\"], \"else\"),\n+            (&paths::RESULT, true, &[\"or\", \"unwrap_or\"], \"else\"),\n+        ];\n \n         let self_ty = cx.tables.expr_ty(self_expr);\n \n@@ -835,7 +831,7 @@ fn lint_clone_on_copy(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, arg_t\n                 CLONE_DOUBLE_REF,\n                 expr.span,\n                 \"using `clone` on a double-reference; \\\n-                                this will copy the reference instead of cloning the inner type\",\n+                 this will copy the reference instead of cloning the inner type\",\n                 |db| if let Some(snip) = sugg::Sugg::hir_opt(cx, arg) {\n                     db.span_suggestion(expr.span, \"try dereferencing it\", format!(\"({}).clone()\", snip.deref()));\n                 },\n@@ -919,7 +915,7 @@ fn lint_iter_cloned_collect(cx: &LateContext, expr: &hir::Expr, iter_args: &[hir\n             ITER_CLONED_COLLECT,\n             expr.span,\n             \"called `cloned().collect()` on a slice to create a `Vec`. Calling `to_vec()` is both faster and \\\n-                   more readable\",\n+             more readable\",\n         );\n     }\n }\n@@ -1021,12 +1017,10 @@ fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: Ty) -> Option<sugg::S\n         match ty.sty {\n             ty::TySlice(_) => sugg::Sugg::hir_opt(cx, expr),\n             ty::TyAdt(def, _) if def.is_box() && may_slice(cx, ty.boxed_ty()) => sugg::Sugg::hir_opt(cx, expr),\n-            ty::TyRef(_, ty::TypeAndMut { ty: inner, .. }) => {\n-                if may_slice(cx, inner) {\n-                    sugg::Sugg::hir_opt(cx, expr)\n-                } else {\n-                    None\n-                }\n+            ty::TyRef(_, ty::TypeAndMut { ty: inner, .. }) => if may_slice(cx, inner) {\n+                sugg::Sugg::hir_opt(cx, expr)\n+            } else {\n+                None\n             },\n             _ => None,\n         }\n@@ -1052,8 +1046,8 @@ fn lint_unwrap(cx: &LateContext, expr: &hir::Expr, unwrap_args: &[hir::Expr]) {\n             expr.span,\n             &format!(\n                 \"used unwrap() on {} value. If you don't want to handle the {} case gracefully, consider \\\n-                            using expect() to provide a better panic \\\n-                            message\",\n+                 using expect() to provide a better panic \\\n+                 message\",\n                 kind,\n                 none_value\n             ),\n@@ -1222,7 +1216,7 @@ fn lint_search_is_some(\n     if match_trait_method(cx, &is_some_args[0], &paths::ITERATOR) {\n         let msg = format!(\n             \"called `is_some()` after searching an `Iterator` with {}. This is more succinctly \\\n-                           expressed by calling `any()`.\",\n+             expressed by calling `any()`.\",\n             search_method\n         );\n         let search_snippet = snippet(cx, search_args[1].span, \"..\");\n@@ -1459,35 +1453,37 @@ fn is_as_ref_or_mut_trait(ty: &hir::Ty, self_ty: &hir::Ty, generics: &hir::Gener\n     single_segment_ty(ty).map_or(false, |seg| {\n         generics.ty_params.iter().any(|param| {\n             param.name == seg.name &&\n-                param.bounds.iter().any(|bound| {\n-                    if let hir::TyParamBound::TraitTyParamBound(ref ptr, ..) = *bound {\n+                param\n+                    .bounds\n+                    .iter()\n+                    .any(|bound| if let hir::TyParamBound::TraitTyParamBound(ref ptr, ..) = *bound {\n                         let path = &ptr.trait_ref.path;\n                         match_path(path, name) &&\n-                            path.segments.last().map_or(\n-                                false,\n-                                |s| if s.parameters.parenthesized {\n+                            path.segments\n+                                .last()\n+                                .map_or(false, |s| if s.parameters.parenthesized {\n                                     false\n                                 } else {\n                                     s.parameters.types.len() == 1 &&\n                                         (is_self_ty(&s.parameters.types[0]) || is_ty(&*s.parameters.types[0], self_ty))\n-                                },\n-                            )\n+                                })\n                     } else {\n                         false\n-                    }\n-                })\n+                    })\n         })\n     })\n }\n \n fn is_ty(ty: &hir::Ty, self_ty: &hir::Ty) -> bool {\n     match (&ty.node, &self_ty.node) {\n-        (&hir::TyPath(hir::QPath::Resolved(_, ref ty_path)),\n-         &hir::TyPath(hir::QPath::Resolved(_, ref self_ty_path))) => {\n-            ty_path.segments.iter().map(|seg| seg.name).eq(\n-                self_ty_path.segments.iter().map(|seg| seg.name),\n-            )\n-        },\n+        (\n+            &hir::TyPath(hir::QPath::Resolved(_, ref ty_path)),\n+            &hir::TyPath(hir::QPath::Resolved(_, ref self_ty_path)),\n+        ) => ty_path\n+            .segments\n+            .iter()\n+            .map(|seg| seg.name)\n+            .eq(self_ty_path.segments.iter().map(|seg| seg.name)),\n         _ => false,\n     }\n }"}, {"sha": "aea92311763bc32f97b05413636603e058bd1dc1", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -1,7 +1,7 @@\n-use consts::{Constant, constant_simple};\n+use consts::{constant_simple, Constant};\n use rustc::lint::*;\n use rustc::hir::*;\n-use std::cmp::{PartialOrd, Ordering};\n+use std::cmp::{Ordering, PartialOrd};\n use utils::{match_def_path, paths, span_lint};\n \n /// **What it does:** Checks for expressions where `std::cmp::min` and `max` are\n@@ -41,9 +41,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MinMaxPass {\n                     return;\n                 }\n                 match (outer_max, outer_c.partial_cmp(&inner_c)) {\n-                    (_, None) |\n-                    (MinMax::Max, Some(Ordering::Less)) |\n-                    (MinMax::Min, Some(Ordering::Greater)) => (),\n+                    (_, None) | (MinMax::Max, Some(Ordering::Less)) | (MinMax::Min, Some(Ordering::Greater)) => (),\n                     _ => {\n                         span_lint(cx, MIN_MAX, expr.span, \"this min/max combination leads to constant result\");\n                     },"}, {"sha": "da6919da93d7e79acdc0d3686b72cf0b63b785e3", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -7,12 +7,12 @@ use rustc::ty;\n use rustc::ty::subst::Substs;\n use rustc_const_eval::ConstContext;\n use rustc_const_math::ConstFloat;\n-use syntax::codemap::{Span, ExpnFormat};\n-use utils::{get_item_name, get_parent_expr, implements_trait, in_macro, is_integer_literal, match_qpath, snippet,\n-            span_lint, span_lint_and_then, walk_ptrs_ty, last_path_segment, iter_input_pats, in_constant,\n-            match_trait_method, paths};\n+use syntax::codemap::{ExpnFormat, Span};\n+use utils::{get_item_name, get_parent_expr, implements_trait, in_constant, in_macro, is_integer_literal,\n+            iter_input_pats, last_path_segment, match_qpath, match_trait_method, paths, snippet, span_lint,\n+            span_lint_and_then, walk_ptrs_ty};\n use utils::sugg::Sugg;\n-use syntax::ast::{LitKind, CRATE_NODE_ID, FloatTy};\n+use syntax::ast::{FloatTy, LitKind, CRATE_NODE_ID};\n \n /// **What it does:** Checks for function arguments and let bindings denoted as\n /// `ref`.\n@@ -242,7 +242,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                         TOPLEVEL_REF_ARG,\n                         arg.pat.span,\n                         \"`ref` directly on a function argument is ignored. Consider using a reference type \\\n-                               instead.\",\n+                         instead.\",\n                     );\n                 },\n                 _ => {},\n@@ -385,7 +385,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 expr.span,\n                 &format!(\n                     \"used binding `{}` which is prefixed with an underscore. A leading \\\n-                                underscore signals that a binding will not be used.\",\n+                     underscore signals that a binding will not be used.\",\n                     binding\n                 ),\n             );\n@@ -484,16 +484,14 @@ fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr) {\n                 return;\n             }\n         },\n-        ExprCall(ref path, ref v) if v.len() == 1 => {\n-            if let ExprPath(ref path) = path.node {\n-                if match_qpath(path, &[\"String\", \"from_str\"]) || match_qpath(path, &[\"String\", \"from\"]) {\n-                    (cx.tables.expr_ty_adjusted(&v[0]), snippet(cx, v[0].span, \"..\"))\n-                } else {\n-                    return;\n-                }\n+        ExprCall(ref path, ref v) if v.len() == 1 => if let ExprPath(ref path) = path.node {\n+            if match_qpath(path, &[\"String\", \"from_str\"]) || match_qpath(path, &[\"String\", \"from\"]) {\n+                (cx.tables.expr_ty_adjusted(&v[0]), snippet(cx, v[0].span, \"..\"))\n             } else {\n                 return;\n             }\n+        } else {\n+            return;\n         },\n         _ => return,\n     };\n@@ -554,8 +552,7 @@ fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr) {\n fn is_used(cx: &LateContext, expr: &Expr) -> bool {\n     if let Some(parent) = get_parent_expr(cx, expr) {\n         match parent.node {\n-            ExprAssign(_, ref rhs) |\n-            ExprAssignOp(_, _, ref rhs) => **rhs == *expr,\n+            ExprAssign(_, ref rhs) | ExprAssignOp(_, _, ref rhs) => **rhs == *expr,\n             _ => is_used(cx, parent),\n         }\n     } else {\n@@ -567,20 +564,21 @@ fn is_used(cx: &LateContext, expr: &Expr) -> bool {\n /// generated by\n /// `#[derive(...)`] or the like).\n fn in_attributes_expansion(expr: &Expr) -> bool {\n-    expr.span.ctxt().outer().expn_info().map_or(\n-        false,\n-        |info| matches!(info.callee.format, ExpnFormat::MacroAttribute(_)),\n-    )\n+    expr.span\n+        .ctxt()\n+        .outer()\n+        .expn_info()\n+        .map_or(false, |info| matches!(info.callee.format, ExpnFormat::MacroAttribute(_)))\n }\n \n /// Test whether `def` is a variable defined outside a macro.\n fn non_macro_local(cx: &LateContext, def: &def::Def) -> bool {\n     match *def {\n-        def::Def::Local(def_id) |\n-        def::Def::Upvar(def_id, _, _) => {\n-            let id = cx.tcx.hir.as_local_node_id(def_id).expect(\n-                \"local variables should be found in the same crate\",\n-            );\n+        def::Def::Local(def_id) | def::Def::Upvar(def_id, _, _) => {\n+            let id = cx.tcx\n+                .hir\n+                .as_local_node_id(def_id)\n+                .expect(\"local variables should be found in the same crate\");\n             !in_macro(cx.tcx.hir.span(id))\n         },\n         _ => false,"}, {"sha": "bf4df6e287308da2e35e798be505cff31e8e6975", "filename": "clippy_lints/src/misc_early.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -4,7 +4,7 @@ use std::char;\n use syntax::ast::*;\n use syntax::codemap::Span;\n use syntax::visit::FnKind;\n-use utils::{constants, span_lint, span_help_and_lint, snippet, snippet_opt, span_lint_and_then, in_external_macro};\n+use utils::{constants, in_external_macro, snippet, snippet_opt, span_help_and_lint, span_lint, span_lint_and_then};\n \n /// **What it does:** Checks for structure field patterns bound to wildcards.\n ///\n@@ -251,7 +251,7 @@ impl EarlyLintPass for MiscEarly {\n                                 UNNEEDED_FIELD_PATTERN,\n                                 field.span,\n                                 \"You matched a field with a wildcard pattern. Consider using `..` \\\n-                                                instead\",\n+                                 instead\",\n                                 &format!(\"Try with `{} {{ {}, .. }}`\", type_name, normal[..].join(\", \")),\n                             );\n                         }\n@@ -276,7 +276,7 @@ impl EarlyLintPass for MiscEarly {\n                             *correspondence,\n                             &format!(\n                                 \"`{}` already exists, having another argument having almost the same \\\n-                                            name makes code comprehension and documentation more difficult\",\n+                                 name makes code comprehension and documentation more difficult\",\n                                 arg_name[1..].to_owned()\n                             ),\n                         );;\n@@ -293,30 +293,28 @@ impl EarlyLintPass for MiscEarly {\n             return;\n         }\n         match expr.node {\n-            ExprKind::Call(ref paren, _) => {\n-                if let ExprKind::Paren(ref closure) = paren.node {\n-                    if let ExprKind::Closure(_, ref decl, ref block, _) = closure.node {\n-                        span_lint_and_then(cx,\n-                                           REDUNDANT_CLOSURE_CALL,\n-                                           expr.span,\n-                                           \"Try not to call a closure in the expression where it is declared.\",\n-                                           |db| if decl.inputs.is_empty() {\n-                                               let hint = snippet(cx, block.span, \"..\").into_owned();\n-                                               db.span_suggestion(expr.span, \"Try doing something like: \", hint);\n-                                           });\n-                    }\n-                }\n-            },\n-            ExprKind::Unary(UnOp::Neg, ref inner) => {\n-                if let ExprKind::Unary(UnOp::Neg, _) = inner.node {\n-                    span_lint(\n+            ExprKind::Call(ref paren, _) => if let ExprKind::Paren(ref closure) = paren.node {\n+                if let ExprKind::Closure(_, ref decl, ref block, _) = closure.node {\n+                    span_lint_and_then(\n                         cx,\n-                        DOUBLE_NEG,\n+                        REDUNDANT_CLOSURE_CALL,\n                         expr.span,\n-                        \"`--x` could be misinterpreted as pre-decrement by C programmers, is usually a no-op\",\n+                        \"Try not to call a closure in the expression where it is declared.\",\n+                        |db| if decl.inputs.is_empty() {\n+                            let hint = snippet(cx, block.span, \"..\").into_owned();\n+                            db.span_suggestion(expr.span, \"Try doing something like: \", hint);\n+                        },\n                     );\n                 }\n             },\n+            ExprKind::Unary(UnOp::Neg, ref inner) => if let ExprKind::Unary(UnOp::Neg, _) = inner.node {\n+                span_lint(\n+                    cx,\n+                    DOUBLE_NEG,\n+                    expr.span,\n+                    \"`--x` could be misinterpreted as pre-decrement by C programmers, is usually a no-op\",\n+                );\n+            },\n             ExprKind::Lit(ref lit) => self.check_lit(cx, lit),\n             _ => (),\n         }"}, {"sha": "81a8b4ffb2e476acbd65d109accc2207cb0d9130", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -18,7 +18,7 @@\n // [`missing_doc`]:\n // https://github.\n // com/rust-lang/rust/blob/d6d05904697d89099b55da3331155392f1db9c00/src/librustc_lint/builtin.\n-// \n+//\n //\n //\n //\n@@ -64,13 +64,15 @@ impl ::std::default::Default for MissingDoc {\n \n impl MissingDoc {\n     pub fn new() -> Self {\n-        Self { doc_hidden_stack: vec![false] }\n+        Self {\n+            doc_hidden_stack: vec![false],\n+        }\n     }\n \n     fn doc_hidden(&self) -> bool {\n-        *self.doc_hidden_stack.last().expect(\n-            \"empty doc_hidden_stack\",\n-        )\n+        *self.doc_hidden_stack\n+            .last()\n+            .expect(\"empty doc_hidden_stack\")\n     }\n \n     fn check_missing_docs_attrs(&self, cx: &LateContext, attrs: &[ast::Attribute], sp: Span, desc: &'static str) {\n@@ -89,9 +91,9 @@ impl MissingDoc {\n             return;\n         }\n \n-        let has_doc = attrs.iter().any(|a| {\n-            a.is_value_str() && a.name().map_or(false, |n| n == \"doc\")\n-        });\n+        let has_doc = attrs\n+            .iter()\n+            .any(|a| a.is_value_str() && a.name().map_or(false, |n| n == \"doc\"));\n         if !has_doc {\n             cx.span_lint(\n                 MISSING_DOCS_IN_PRIVATE_ITEMS,\n@@ -110,14 +112,12 @@ impl LintPass for MissingDoc {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n     fn enter_lint_attrs(&mut self, _: &LateContext<'a, 'tcx>, attrs: &'tcx [ast::Attribute]) {\n-        let doc_hidden = self.doc_hidden() ||\n-            attrs.iter().any(|attr| {\n-                attr.check_name(\"doc\") &&\n-                    match attr.meta_item_list() {\n-                        None => false,\n-                        Some(l) => attr::list_contains_name(&l[..], \"hidden\"),\n-                    }\n-            });\n+        let doc_hidden = self.doc_hidden() || attrs.iter().any(|attr| {\n+            attr.check_name(\"doc\") && match attr.meta_item_list() {\n+                None => false,\n+                Some(l) => attr::list_contains_name(&l[..], \"hidden\"),\n+            }\n+        });\n         self.doc_hidden_stack.push(doc_hidden);\n     }\n \n@@ -166,10 +166,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n         let def_id = cx.tcx.hir.local_def_id(impl_item.id);\n         match cx.tcx.associated_item(def_id).container {\n             ty::TraitContainer(_) => return,\n-            ty::ImplContainer(cid) => {\n-                if cx.tcx.impl_trait_ref(cid).is_some() {\n-                    return;\n-                }\n+            ty::ImplContainer(cid) => if cx.tcx.impl_trait_ref(cid).is_some() {\n+                return;\n             },\n         }\n "}, {"sha": "c12d3dde2be2832c411da8576492bfb95916c5e5", "filename": "clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mut.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -70,7 +70,14 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n                     expr.span,\n                     \"generally you want to avoid `&mut &mut _` if possible\",\n                 );\n-            } else if let ty::TyRef(_, ty::TypeAndMut { mutbl: hir::MutMutable, .. }) = self.cx.tables.expr_ty(e).sty {\n+            } else if let ty::TyRef(\n+                _,\n+                ty::TypeAndMut {\n+                    mutbl: hir::MutMutable,\n+                    ..\n+                },\n+            ) = self.cx.tables.expr_ty(e).sty\n+            {\n                 span_lint(\n                     self.cx,\n                     MUT_MUT,\n@@ -82,21 +89,29 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n     }\n \n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n-        if let hir::TyRptr(_,\n-                           hir::MutTy {\n-                               ty: ref pty,\n-                               mutbl: hir::MutMutable,\n-                           }) = ty.node\n+        if let hir::TyRptr(\n+            _,\n+            hir::MutTy {\n+                ty: ref pty,\n+                mutbl: hir::MutMutable,\n+            },\n+        ) = ty.node\n         {\n-            if let hir::TyRptr(_, hir::MutTy { mutbl: hir::MutMutable, .. }) = pty.node {\n+            if let hir::TyRptr(\n+                _,\n+                hir::MutTy {\n+                    mutbl: hir::MutMutable,\n+                    ..\n+                },\n+            ) = pty.node\n+            {\n                 span_lint(\n                     self.cx,\n                     MUT_MUT,\n                     ty.span,\n                     \"generally you want to avoid `&mut &mut _` if possible\",\n                 );\n             }\n-\n         }\n \n         intravisit::walk_ty(self, ty);"}, {"sha": "63ccc77a03dcc6c1efa338b667ee9091b4f0f57d", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -36,15 +36,13 @@ impl LintPass for UnnecessaryMutPassed {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnecessaryMutPassed {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         match e.node {\n-            ExprCall(ref fn_expr, ref arguments) => {\n-                if let ExprPath(ref path) = fn_expr.node {\n-                    check_arguments(\n-                        cx,\n-                        arguments,\n-                        cx.tables.expr_ty(fn_expr),\n-                        &print::to_string(print::NO_ANN, |s| s.print_qpath(path, false)),\n-                    );\n-                }\n+            ExprCall(ref fn_expr, ref arguments) => if let ExprPath(ref path) = fn_expr.node {\n+                check_arguments(\n+                    cx,\n+                    arguments,\n+                    cx.tables.expr_ty(fn_expr),\n+                    &print::to_string(print::NO_ANN, |s| s.print_qpath(path, false)),\n+                );\n             },\n             ExprMethodCall(ref path, _, ref arguments) => {\n                 let def_id = cx.tables.type_dependent_defs()[e.hir_id].def_id();\n@@ -63,16 +61,23 @@ fn check_arguments<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arguments: &[Expr], typ\n             let parameters = type_definition.fn_sig(cx.tcx).skip_binder().inputs();\n             for (argument, parameter) in arguments.iter().zip(parameters.iter()) {\n                 match parameter.sty {\n-                    ty::TyRef(_, ty::TypeAndMut { mutbl: MutImmutable, .. }) |\n-                    ty::TyRawPtr(ty::TypeAndMut { mutbl: MutImmutable, .. }) => {\n-                        if let ExprAddrOf(MutMutable, _) = argument.node {\n-                            span_lint(\n-                                cx,\n-                                UNNECESSARY_MUT_PASSED,\n-                                argument.span,\n-                                &format!(\"The function/method `{}` doesn't need a mutable reference\", name),\n-                            );\n-                        }\n+                    ty::TyRef(\n+                        _,\n+                        ty::TypeAndMut {\n+                            mutbl: MutImmutable,\n+                            ..\n+                        },\n+                    ) |\n+                    ty::TyRawPtr(ty::TypeAndMut {\n+                        mutbl: MutImmutable,\n+                        ..\n+                    }) => if let ExprAddrOf(MutMutable, _) = argument.node {\n+                        span_lint(\n+                            cx,\n+                            UNNECESSARY_MUT_PASSED,\n+                            argument.span,\n+                            &format!(\"The function/method `{}` doesn't need a mutable reference\", name),\n+                        );\n                     },\n                     _ => (),\n                 }"}, {"sha": "6fe365fd25541089decf7a85e637061bb5b7dcb9", "filename": "clippy_lints/src/mutex_atomic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutex_atomic.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -2,7 +2,7 @@\n //!\n //! This lint is **warn** by default\n \n-use rustc::lint::{LintPass, LintArray, LateLintPass, LateContext};\n+use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::ty::{self, Ty};\n use rustc::hir::Expr;\n use syntax::ast;\n@@ -65,7 +65,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutexAtomic {\n                 if let Some(atomic_name) = get_atomic_name(mutex_param) {\n                     let msg = format!(\n                         \"Consider using an {} instead of a Mutex here. If you just want the locking \\\n-                                       behaviour and not the internal type, consider using Mutex<()>.\",\n+                         behaviour and not the internal type, consider using Mutex<()>.\",\n                         atomic_name\n                     );\n                     match mutex_param.sty {"}, {"sha": "bc93190cd09c6670643a937ea0da376aa5fc5a1e", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 15, "deletions": 23, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -6,7 +6,7 @@ use rustc::lint::*;\n use rustc::hir::*;\n use syntax::ast::LitKind;\n use syntax::codemap::Spanned;\n-use utils::{span_lint, span_lint_and_sugg, snippet};\n+use utils::{snippet, span_lint, span_lint_and_sugg};\n use utils::sugg::Sugg;\n \n /// **What it does:** Checks for expressions of the form `if c { true } else {\n@@ -82,17 +82,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBool {\n             };\n             if let ExprBlock(ref then_block) = then_block.node {\n                 match (fetch_bool_block(then_block), fetch_bool_expr(else_expr)) {\n-                    (RetBool(true), RetBool(true)) |\n-                    (Bool(true), Bool(true)) => {\n+                    (RetBool(true), RetBool(true)) | (Bool(true), Bool(true)) => {\n                         span_lint(\n                             cx,\n                             NEEDLESS_BOOL,\n                             e.span,\n                             \"this if-then-else expression will always return true\",\n                         );\n                     },\n-                    (RetBool(false), RetBool(false)) |\n-                    (Bool(false), Bool(false)) => {\n+                    (RetBool(false), RetBool(false)) | (Bool(false), Bool(false)) => {\n                         span_lint(\n                             cx,\n                             NEEDLESS_BOOL,\n@@ -186,16 +184,14 @@ enum Expression {\n fn fetch_bool_block(block: &Block) -> Expression {\n     match (&*block.stmts, block.expr.as_ref()) {\n         (&[], Some(e)) => fetch_bool_expr(&**e),\n-        (&[ref e], None) => {\n-            if let StmtSemi(ref e, _) = e.node {\n-                if let ExprRet(_) = e.node {\n-                    fetch_bool_expr(&**e)\n-                } else {\n-                    Expression::Other\n-                }\n+        (&[ref e], None) => if let StmtSemi(ref e, _) = e.node {\n+            if let ExprRet(_) = e.node {\n+                fetch_bool_expr(&**e)\n             } else {\n                 Expression::Other\n             }\n+        } else {\n+            Expression::Other\n         },\n         _ => Expression::Other,\n     }\n@@ -204,18 +200,14 @@ fn fetch_bool_block(block: &Block) -> Expression {\n fn fetch_bool_expr(expr: &Expr) -> Expression {\n     match expr.node {\n         ExprBlock(ref block) => fetch_bool_block(block),\n-        ExprLit(ref lit_ptr) => {\n-            if let LitKind::Bool(value) = lit_ptr.node {\n-                Expression::Bool(value)\n-            } else {\n-                Expression::Other\n-            }\n+        ExprLit(ref lit_ptr) => if let LitKind::Bool(value) = lit_ptr.node {\n+            Expression::Bool(value)\n+        } else {\n+            Expression::Other\n         },\n-        ExprRet(Some(ref expr)) => {\n-            match fetch_bool_expr(expr) {\n-                Expression::Bool(value) => Expression::RetBool(value),\n-                _ => Expression::Other,\n-            }\n+        ExprRet(Some(ref expr)) => match fetch_bool_expr(expr) {\n+            Expression::Bool(value) => Expression::RetBool(value),\n+            _ => Expression::Other,\n         },\n         _ => Expression::Other,\n     }"}, {"sha": "7dd42bca3ab7f9f7872287542c967a14b6481f5e", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -3,10 +3,10 @@\n //! This lint is **warn** by default\n \n use rustc::lint::*;\n-use rustc::hir::{ExprAddrOf, Expr, MutImmutable, Pat, PatKind, BindingAnnotation};\n+use rustc::hir::{BindingAnnotation, Expr, ExprAddrOf, MutImmutable, Pat, PatKind};\n use rustc::ty;\n-use rustc::ty::adjustment::{Adjustment, Adjust};\n-use utils::{span_lint, in_macro};\n+use rustc::ty::adjustment::{Adjust, Adjustment};\n+use utils::{in_macro, span_lint};\n \n /// **What it does:** Checks for address of operations (`&`) that are going to\n /// be dereferenced immediately by the compiler.\n@@ -43,16 +43,24 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrow {\n         if let ExprAddrOf(MutImmutable, ref inner) = e.node {\n             if let ty::TyRef(..) = cx.tables.expr_ty(inner).sty {\n                 for adj3 in cx.tables.expr_adjustments(e).windows(3) {\n-                    if let [\n-                        Adjustment { kind: Adjust::Deref(_), .. },\n-                        Adjustment { kind: Adjust::Deref(_), .. },\n-                        Adjustment { kind: Adjust::Borrow(_), .. }\n-                    ] = *adj3 {\n-                        span_lint(cx,\n-                                  NEEDLESS_BORROW,\n-                                  e.span,\n-                                  \"this expression borrows a reference that is immediately dereferenced by the \\\n-                                   compiler\");\n+                    if let [Adjustment {\n+                        kind: Adjust::Deref(_),\n+                        ..\n+                    }, Adjustment {\n+                        kind: Adjust::Deref(_),\n+                        ..\n+                    }, Adjustment {\n+                        kind: Adjust::Borrow(_),\n+                        ..\n+                    }] = *adj3\n+                    {\n+                        span_lint(\n+                            cx,\n+                            NEEDLESS_BORROW,\n+                            e.span,\n+                            \"this expression borrows a reference that is immediately dereferenced by the \\\n+                             compiler\",\n+                        );\n                     }\n                 }\n             }"}, {"sha": "1c00263cbc2d906e37046c01b3f5d47c4e6f1e80", "filename": "clippy_lints/src/needless_borrowed_ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -3,8 +3,8 @@\n //! This lint is **warn** by default\n \n use rustc::lint::*;\n-use rustc::hir::{MutImmutable, Pat, PatKind, BindingAnnotation};\n-use utils::{span_lint_and_then, in_macro, snippet};\n+use rustc::hir::{BindingAnnotation, MutImmutable, Pat, PatKind};\n+use utils::{in_macro, snippet, span_lint_and_then};\n \n /// **What it does:** Checks for useless borrowed references.\n ///"}, {"sha": "b369d8b570bee2e7b06f5fd28dc5f496164c5680", "filename": "clippy_lints/src/needless_continue.rs", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fneedless_continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fneedless_continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_continue.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -32,7 +32,7 @@ use syntax::ast;\n use syntax::codemap::{original_sp, DUMMY_SP};\n use std::borrow::Cow;\n \n-use utils::{in_macro, span_help_and_lint, snippet_block, snippet, trim_multiline};\n+use utils::{in_macro, snippet, snippet_block, span_help_and_lint, trim_multiline};\n \n /// **What it does:** The lint checks for `if`-statements appearing in loops\n /// that contain a `continue` statement in either their main blocks or their\n@@ -181,13 +181,10 @@ fn needless_continue_in_else(else_expr: &ast::Expr) -> bool {\n \n fn is_first_block_stmt_continue(block: &ast::Block) -> bool {\n     block.stmts.get(0).map_or(false, |stmt| match stmt.node {\n-        ast::StmtKind::Semi(ref e) |\n-        ast::StmtKind::Expr(ref e) => {\n-            if let ast::ExprKind::Continue(_) = e.node {\n-                true\n-            } else {\n-                false\n-            }\n+        ast::StmtKind::Semi(ref e) | ast::StmtKind::Expr(ref e) => if let ast::ExprKind::Continue(_) = e.node {\n+            true\n+        } else {\n+            false\n         },\n         _ => false,\n     })\n@@ -222,8 +219,7 @@ where\n     F: FnMut(&ast::Expr, &ast::Expr, &ast::Block, &ast::Expr),\n {\n     match stmt.node {\n-        ast::StmtKind::Semi(ref e) |\n-        ast::StmtKind::Expr(ref e) => {\n+        ast::StmtKind::Semi(ref e) | ast::StmtKind::Expr(ref e) => {\n             if let ast::ExprKind::If(ref cond, ref if_block, Some(ref else_expr)) = e.node {\n                 func(e, cond, if_block, else_expr);\n             }\n@@ -269,25 +265,20 @@ const DROP_ELSE_BLOCK_MSG: &'static str = \"Consider dropping the else clause, an\n \n \n fn emit_warning<'a>(ctx: &EarlyContext, data: &'a LintData, header: &str, typ: LintType) {\n-\n     // snip    is the whole *help* message that appears after the warning.\n     // message is the warning message.\n     // expr    is the expression which the lint warning message refers to.\n     let (snip, message, expr) = match typ {\n-        LintType::ContinueInsideElseBlock => {\n-            (\n-                suggestion_snippet_for_continue_inside_else(ctx, data, header),\n-                MSG_REDUNDANT_ELSE_BLOCK,\n-                data.else_expr,\n-            )\n-        },\n-        LintType::ContinueInsideThenBlock => {\n-            (\n-                suggestion_snippet_for_continue_inside_if(ctx, data, header),\n-                MSG_ELSE_BLOCK_NOT_NEEDED,\n-                data.if_expr,\n-            )\n-        },\n+        LintType::ContinueInsideElseBlock => (\n+            suggestion_snippet_for_continue_inside_else(ctx, data, header),\n+            MSG_REDUNDANT_ELSE_BLOCK,\n+            data.else_expr,\n+        ),\n+        LintType::ContinueInsideThenBlock => (\n+            suggestion_snippet_for_continue_inside_if(ctx, data, header),\n+            MSG_ELSE_BLOCK_NOT_NEEDED,\n+            data.if_expr,\n+        ),\n     };\n     span_help_and_lint(ctx, NEEDLESS_CONTINUE, expr.span, message, &snip);\n }"}, {"sha": "f53e8521076338635504c75dbe8f409a201c537a", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -9,9 +9,9 @@ use rustc::middle::mem_categorization as mc;\n use syntax::ast::NodeId;\n use syntax_pos::Span;\n use syntax::errors::DiagnosticBuilder;\n-use utils::{in_macro, is_self, is_copy, implements_trait, get_trait_def_id, match_type, snippet, span_lint_and_then,\n-            multispan_sugg, paths};\n-use std::collections::{HashSet, HashMap};\n+use utils::{get_trait_def_id, implements_trait, in_macro, is_copy, is_self, match_type, multispan_sugg, paths,\n+            snippet, span_lint_and_then};\n+use std::collections::{HashMap, HashSet};\n \n /// **What it does:** Checks for functions taking arguments by value, but not\n /// consuming them in its\n@@ -62,16 +62,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n         }\n \n         match kind {\n-            FnKind::ItemFn(.., attrs) => {\n-                for a in attrs {\n-                    if_let_chain!{[\n-                        a.meta_item_list().is_some(),\n-                        let Some(name) = a.name(),\n-                        name == \"proc_macro_derive\",\n-                    ], {\n-                        return;\n-                    }}\n-                }\n+            FnKind::ItemFn(.., attrs) => for a in attrs {\n+                if_let_chain!{[\n+                    a.meta_item_list().is_some(),\n+                    let Some(name) = a.name(),\n+                    name == \"proc_macro_derive\",\n+                ], {\n+                    return;\n+                }}\n             },\n             _ => return,\n         }\n@@ -106,7 +104,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n         let fn_sig = cx.tcx.erase_late_bound_regions(&fn_sig);\n \n         for ((input, &ty), arg) in decl.inputs.iter().zip(fn_sig.inputs()).zip(&body.arguments) {\n-\n             // Determines whether `ty` implements `Borrow<U>` (U != ty) specifically.\n             // This is needed due to the `Borrow<T> for T` blanket impl.\n             let implements_borrow_trait = preds\n@@ -118,9 +115,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                 })\n                 .filter(|tpred| tpred.def_id() == borrow_trait && tpred.self_ty() == ty)\n                 .any(|tpred| {\n-                    tpred.input_types().nth(1).expect(\n-                        \"Borrow trait must have an parameter\",\n-                    ) != ty\n+                    tpred\n+                        .input_types()\n+                        .nth(1)\n+                        .expect(\"Borrow trait must have an parameter\") != ty\n                 });\n \n             if_let_chain! {[\n@@ -299,8 +297,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for MovedVariablesCtxt<'a, 'tcx> {\n fn unwrap_downcast_or_interior(mut cmt: mc::cmt) -> mc::cmt {\n     loop {\n         match cmt.cat.clone() {\n-            mc::Categorization::Downcast(c, _) |\n-            mc::Categorization::Interior(c, _) => {\n+            mc::Categorization::Downcast(c, _) | mc::Categorization::Interior(c, _) => {\n                 cmt = c;\n             },\n             _ => return cmt,"}, {"sha": "1c5524af68e7834bf5bc4b3244bfd68f234ca807", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 30, "deletions": 31, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -115,43 +115,42 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n                 return;\n             }\n             if decl.inputs.is_empty() && name == \"new\" && cx.access_levels.is_reachable(id) {\n-                let self_ty = cx.tcx.type_of(\n-                    cx.tcx.hir.local_def_id(cx.tcx.hir.get_parent(id)),\n-                );\n+                let self_ty = cx.tcx\n+                    .type_of(cx.tcx.hir.local_def_id(cx.tcx.hir.get_parent(id)));\n                 if_let_chain!{[\n-                    same_tys(cx, self_ty, return_ty(cx, id)),\n-                    let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT),\n-                    !implements_trait(cx, self_ty, default_trait_id, &[])\n-                ], {\n-                    if let Some(sp) = can_derive_default(self_ty, cx, default_trait_id) {\n-                        span_lint_and_then(cx,\n-                                           NEW_WITHOUT_DEFAULT_DERIVE, span,\n-                                           &format!(\"you should consider deriving a \\\n-                                                     `Default` implementation for `{}`\",\n-                                                    self_ty),\n-                                           |db| {\n-                            db.suggest_item_with_attr(cx, sp, \"try this\", \"#[derive(Default)]\");\n-                        });\n-                    } else {\n-                        span_lint_and_then(cx,\n-                                           NEW_WITHOUT_DEFAULT, span,\n-                                           &format!(\"you should consider adding a \\\n-                                                    `Default` implementation for `{}`\",\n-                                                    self_ty),\n-                                           |db| {\n-                        db.suggest_prepend_item(cx,\n-                                                  span,\n-                                                  \"try this\",\n-                                                  &format!(\n+                                    same_tys(cx, self_ty, return_ty(cx, id)),\n+                                    let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT),\n+                                    !implements_trait(cx, self_ty, default_trait_id, &[])\n+                                ], {\n+                                    if let Some(sp) = can_derive_default(self_ty, cx, default_trait_id) {\n+                                        span_lint_and_then(cx,\n+                                                           NEW_WITHOUT_DEFAULT_DERIVE, span,\n+                                                           &format!(\"you should consider deriving a \\\n+                                                                     `Default` implementation for `{}`\",\n+                                                                    self_ty),\n+                                                           |db| {\n+                                            db.suggest_item_with_attr(cx, sp, \"try this\", \"#[derive(Default)]\");\n+                                        });\n+                                    } else {\n+                                        span_lint_and_then(cx,\n+                                                           NEW_WITHOUT_DEFAULT, span,\n+                                                           &format!(\"you should consider adding a \\\n+                                                                    `Default` implementation for `{}`\",\n+                                                                    self_ty),\n+                                                           |db| {\n+                                        db.suggest_prepend_item(cx,\n+                                                                  span,\n+                                                                  \"try this\",\n+                                                                  &format!(\n \"impl Default for {} {{\n     fn default() -> Self {{\n         Self::new()\n     }}\n }}\",\n-                                                           self_ty));\n-                        });\n-                    }\n-                }}\n+                                                                           self_ty));\n+                                        });\n+                                    }\n+                                }}\n             }\n         }\n     }"}, {"sha": "1d5e51187bbd430f4aadbe7f74755f803c2d9858", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 43, "deletions": 56, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -1,7 +1,7 @@\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::hir::def::Def;\n-use rustc::hir::{Expr, Expr_, Stmt, StmtSemi, BlockCheckMode, UnsafeSource, BiAnd, BiOr};\n-use utils::{in_macro, span_lint, snippet_opt, span_lint_and_sugg};\n+use rustc::hir::{BiAnd, BiOr, BlockCheckMode, Expr, Expr_, Stmt, StmtSemi, UnsafeSource};\n+use utils::{in_macro, snippet_opt, span_lint, span_lint_and_sugg};\n use std::ops::Deref;\n \n /// **What it does:** Checks for statements which have no effect.\n@@ -45,13 +45,11 @@ fn has_no_effect(cx: &LateContext, expr: &Expr) -> bool {\n         return false;\n     }\n     match expr.node {\n-        Expr_::ExprLit(..) |\n-        Expr_::ExprClosure(.., _) |\n-        Expr_::ExprPath(..) => true,\n-        Expr_::ExprIndex(ref a, ref b) |\n-        Expr_::ExprBinary(_, ref a, ref b) => has_no_effect(cx, a) && has_no_effect(cx, b),\n-        Expr_::ExprArray(ref v) |\n-        Expr_::ExprTup(ref v) => v.iter().all(|val| has_no_effect(cx, val)),\n+        Expr_::ExprLit(..) | Expr_::ExprClosure(.., _) | Expr_::ExprPath(..) => true,\n+        Expr_::ExprIndex(ref a, ref b) | Expr_::ExprBinary(_, ref a, ref b) => {\n+            has_no_effect(cx, a) && has_no_effect(cx, b)\n+        },\n+        Expr_::ExprArray(ref v) | Expr_::ExprTup(ref v) => v.iter().all(|val| has_no_effect(cx, val)),\n         Expr_::ExprRepeat(ref inner, _) |\n         Expr_::ExprCast(ref inner, _) |\n         Expr_::ExprType(ref inner, _) |\n@@ -61,33 +59,28 @@ fn has_no_effect(cx: &LateContext, expr: &Expr) -> bool {\n         Expr_::ExprAddrOf(_, ref inner) |\n         Expr_::ExprBox(ref inner) => has_no_effect(cx, inner),\n         Expr_::ExprStruct(_, ref fields, ref base) => {\n-            fields.iter().all(|field| has_no_effect(cx, &field.expr)) &&\n-                match *base {\n-                    Some(ref base) => has_no_effect(cx, base),\n-                    None => true,\n-                }\n+            fields.iter().all(|field| has_no_effect(cx, &field.expr)) && match *base {\n+                Some(ref base) => has_no_effect(cx, base),\n+                None => true,\n+            }\n         },\n-        Expr_::ExprCall(ref callee, ref args) => {\n-            if let Expr_::ExprPath(ref qpath) = callee.node {\n-                let def = cx.tables.qpath_def(qpath, callee.hir_id);\n-                match def {\n-                    Def::Struct(..) |\n-                    Def::Variant(..) |\n-                    Def::StructCtor(..) |\n-                    Def::VariantCtor(..) => args.iter().all(|arg| has_no_effect(cx, arg)),\n-                    _ => false,\n-                }\n-            } else {\n-                false\n+        Expr_::ExprCall(ref callee, ref args) => if let Expr_::ExprPath(ref qpath) = callee.node {\n+            let def = cx.tables.qpath_def(qpath, callee.hir_id);\n+            match def {\n+                Def::Struct(..) | Def::Variant(..) | Def::StructCtor(..) | Def::VariantCtor(..) => {\n+                    args.iter().all(|arg| has_no_effect(cx, arg))\n+                },\n+                _ => false,\n             }\n+        } else {\n+            false\n         },\n         Expr_::ExprBlock(ref block) => {\n-            block.stmts.is_empty() &&\n-                if let Some(ref expr) = block.expr {\n-                    has_no_effect(cx, expr)\n-                } else {\n-                    false\n-                }\n+            block.stmts.is_empty() && if let Some(ref expr) = block.expr {\n+                has_no_effect(cx, expr)\n+            } else {\n+                false\n+            }\n         },\n         _ => false,\n     }\n@@ -143,8 +136,7 @@ fn reduce_expression<'a>(cx: &LateContext, expr: &'a Expr) -> Option<Vec<&'a Exp\n         Expr_::ExprBinary(ref binop, ref a, ref b) if binop.node != BiAnd && binop.node != BiOr => {\n             Some(vec![&**a, &**b])\n         },\n-        Expr_::ExprArray(ref v) |\n-        Expr_::ExprTup(ref v) => Some(v.iter().collect()),\n+        Expr_::ExprArray(ref v) | Expr_::ExprTup(ref v) => Some(v.iter().collect()),\n         Expr_::ExprRepeat(ref inner, _) |\n         Expr_::ExprCast(ref inner, _) |\n         Expr_::ExprType(ref inner, _) |\n@@ -153,29 +145,24 @@ fn reduce_expression<'a>(cx: &LateContext, expr: &'a Expr) -> Option<Vec<&'a Exp\n         Expr_::ExprTupField(ref inner, _) |\n         Expr_::ExprAddrOf(_, ref inner) |\n         Expr_::ExprBox(ref inner) => reduce_expression(cx, inner).or_else(|| Some(vec![inner])),\n-        Expr_::ExprStruct(_, ref fields, ref base) => {\n-            Some(\n-                fields\n-                    .iter()\n-                    .map(|f| &f.expr)\n-                    .chain(base)\n-                    .map(Deref::deref)\n-                    .collect(),\n-            )\n-        },\n-        Expr_::ExprCall(ref callee, ref args) => {\n-            if let Expr_::ExprPath(ref qpath) = callee.node {\n-                let def = cx.tables.qpath_def(qpath, callee.hir_id);\n-                match def {\n-                    Def::Struct(..) |\n-                    Def::Variant(..) |\n-                    Def::StructCtor(..) |\n-                    Def::VariantCtor(..) => Some(args.iter().collect()),\n-                    _ => None,\n-                }\n-            } else {\n-                None\n+        Expr_::ExprStruct(_, ref fields, ref base) => Some(\n+            fields\n+                .iter()\n+                .map(|f| &f.expr)\n+                .chain(base)\n+                .map(Deref::deref)\n+                .collect(),\n+        ),\n+        Expr_::ExprCall(ref callee, ref args) => if let Expr_::ExprPath(ref qpath) = callee.node {\n+            let def = cx.tables.qpath_def(qpath, callee.hir_id);\n+            match def {\n+                Def::Struct(..) | Def::Variant(..) | Def::StructCtor(..) | Def::VariantCtor(..) => {\n+                    Some(args.iter().collect())\n+                },\n+                _ => None,\n             }\n+        } else {\n+            None\n         },\n         Expr_::ExprBlock(ref block) => {\n             if block.stmts.is_empty() {"}, {"sha": "d36054eacf4b3f93da22127ab2f8912529fca531", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 32, "deletions": 35, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -3,8 +3,8 @@ use syntax::codemap::Span;\n use syntax::symbol::InternedString;\n use syntax::ast::*;\n use syntax::attr;\n-use syntax::visit::{Visitor, walk_block, walk_pat, walk_expr};\n-use utils::{span_lint_and_then, in_macro, span_lint};\n+use syntax::visit::{walk_block, walk_expr, walk_pat, Visitor};\n+use utils::{in_macro, span_lint, span_lint_and_then};\n \n /// **What it does:** Checks for names that are very similar and thus confusing.\n ///\n@@ -82,11 +82,9 @@ impl<'a, 'tcx: 'a, 'b> Visitor<'tcx> for SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n     fn visit_pat(&mut self, pat: &'tcx Pat) {\n         match pat.node {\n             PatKind::Ident(_, id, _) => self.check_name(id.span, id.node.name),\n-            PatKind::Struct(_, ref fields, _) => {\n-                for field in fields {\n-                    if !field.node.is_shorthand {\n-                        self.visit_pat(&field.node.pat);\n-                    }\n+            PatKind::Struct(_, ref fields, _) => for field in fields {\n+                if !field.node.is_shorthand {\n+                    self.visit_pat(&field.node.pat);\n                 }\n             },\n             _ => walk_pat(self, pat),\n@@ -104,9 +102,8 @@ fn get_whitelist(interned_name: &str) -> Option<&'static [&'static str]> {\n }\n \n fn whitelisted(interned_name: &str, list: &[&str]) -> bool {\n-    list.iter().any(|&name| {\n-        interned_name.starts_with(name) || interned_name.ends_with(name)\n-    })\n+    list.iter()\n+        .any(|&name| interned_name.starts_with(name) || interned_name.ends_with(name))\n }\n \n impl<'a, 'tcx, 'b> SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n@@ -157,21 +154,21 @@ impl<'a, 'tcx, 'b> SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n             } else {\n                 let mut interned_chars = interned_name.chars();\n                 let mut existing_chars = existing_name.interned.chars();\n-                let first_i = interned_chars.next().expect(\n-                    \"we know we have at least one char\",\n-                );\n-                let first_e = existing_chars.next().expect(\n-                    \"we know we have at least one char\",\n-                );\n+                let first_i = interned_chars\n+                    .next()\n+                    .expect(\"we know we have at least one char\");\n+                let first_e = existing_chars\n+                    .next()\n+                    .expect(\"we know we have at least one char\");\n                 let eq_or_numeric = |(a, b): (char, char)| a == b || a.is_numeric() && b.is_numeric();\n \n                 if eq_or_numeric((first_i, first_e)) {\n-                    let last_i = interned_chars.next_back().expect(\n-                        \"we know we have at least two chars\",\n-                    );\n-                    let last_e = existing_chars.next_back().expect(\n-                        \"we know we have at least two chars\",\n-                    );\n+                    let last_i = interned_chars\n+                        .next_back()\n+                        .expect(\"we know we have at least two chars\");\n+                    let last_e = existing_chars\n+                        .next_back()\n+                        .expect(\"we know we have at least two chars\");\n                     if eq_or_numeric((last_i, last_e)) {\n                         if interned_chars\n                             .zip(existing_chars)\n@@ -181,12 +178,12 @@ impl<'a, 'tcx, 'b> SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n                             continue;\n                         }\n                     } else {\n-                        let second_last_i = interned_chars.next_back().expect(\n-                            \"we know we have at least three chars\",\n-                        );\n-                        let second_last_e = existing_chars.next_back().expect(\n-                            \"we know we have at least three chars\",\n-                        );\n+                        let second_last_i = interned_chars\n+                            .next_back()\n+                            .expect(\"we know we have at least three chars\");\n+                        let second_last_e = existing_chars\n+                            .next_back()\n+                            .expect(\"we know we have at least three chars\");\n                         if !eq_or_numeric((second_last_i, second_last_e)) || second_last_i == '_' ||\n                             !interned_chars.zip(existing_chars).all(eq_or_numeric)\n                         {\n@@ -197,12 +194,12 @@ impl<'a, 'tcx, 'b> SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n                         split_at = interned_name.char_indices().rev().next().map(|(i, _)| i);\n                     }\n                 } else {\n-                    let second_i = interned_chars.next().expect(\n-                        \"we know we have at least two chars\",\n-                    );\n-                    let second_e = existing_chars.next().expect(\n-                        \"we know we have at least two chars\",\n-                    );\n+                    let second_i = interned_chars\n+                        .next()\n+                        .expect(\"we know we have at least two chars\");\n+                    let second_e = existing_chars\n+                        .next()\n+                        .expect(\"we know we have at least two chars\");\n                     if !eq_or_numeric((second_i, second_e)) || second_i == '_' ||\n                         !interned_chars.zip(existing_chars).all(eq_or_numeric)\n                     {\n@@ -225,7 +222,7 @@ impl<'a, 'tcx, 'b> SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n                             span,\n                             &format!(\n                                 \"separate the discriminating character by an \\\n-                                                                underscore like: `{}_{}`\",\n+                                 underscore like: `{}_{}`\",\n                                 &interned_name[..split],\n                                 &interned_name[split..]\n                             ),"}, {"sha": "67d39333ff983427722506e72fb92bbe5150eabf", "filename": "clippy_lints/src/ok_if_let.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fok_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fok_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fok_if_let.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -1,6 +1,6 @@\n use rustc::lint::*;\n use rustc::hir::*;\n-use utils::{paths, method_chain_args, span_help_and_lint, match_type, snippet};\n+use utils::{match_type, method_chain_args, paths, snippet, span_help_and_lint};\n \n /// **What it does:*** Checks for unnecessary `ok()` in if let.\n ///"}, {"sha": "627608889337ce8aae488a272eac807be94515b5", "filename": "clippy_lints/src/open_options.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fopen_options.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -1,4 +1,4 @@\n-use rustc::hir::{Expr, ExprMethodCall, ExprLit};\n+use rustc::hir::{Expr, ExprLit, ExprMethodCall};\n use rustc::lint::*;\n use syntax::ast::LitKind;\n use syntax::codemap::{Span, Spanned};\n@@ -67,11 +67,18 @@ fn get_open_options(cx: &LateContext, argument: &Expr, options: &mut Vec<(OpenOp\n \n         // Only proceed if this is a call on some object of type std::fs::OpenOptions\n         if match_type(cx, obj_ty, &paths::OPEN_OPTIONS) && arguments.len() >= 2 {\n-\n             let argument_option = match arguments[1].node {\n                 ExprLit(ref span) => {\n-                    if let Spanned { node: LitKind::Bool(lit), .. } = **span {\n-                        if lit { Argument::True } else { Argument::False }\n+                    if let Spanned {\n+                        node: LitKind::Bool(lit),\n+                        ..\n+                    } = **span\n+                    {\n+                        if lit {\n+                            Argument::True\n+                        } else {\n+                            Argument::False\n+                        }\n                     } else {\n                         return; // The function is called with a literal\n                         // which is not a boolean literal. This is theoretically"}, {"sha": "a050873187d0e3351fc0a548253a6299a683a1e3", "filename": "clippy_lints/src/panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -1,7 +1,7 @@\n use rustc::hir::*;\n use rustc::lint::*;\n use syntax::ast::LitKind;\n-use utils::{is_direct_expn_of, match_def_path, resolve_node, paths, span_lint};\n+use utils::{is_direct_expn_of, match_def_path, paths, resolve_node, span_lint};\n \n /// **What it does:** Checks for missing parameters in `panic!`.\n ///"}, {"sha": "e06c571b6f6d885f0cbcc2a963d28185dae6f3db", "filename": "clippy_lints/src/precedence.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprecedence.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -1,7 +1,7 @@\n use rustc::lint::*;\n use syntax::ast::*;\n use syntax::codemap::Spanned;\n-use utils::{span_lint_and_sugg, snippet};\n+use utils::{snippet, span_lint_and_sugg};\n \n /// **What it does:** Checks for operations where precedence may be unclear\n /// and suggests to add parentheses. Currently it catches the following:\n@@ -89,9 +89,7 @@ impl EarlyLintPass for Precedence {\n                 if let Some(slf) = args.first() {\n                     if let ExprKind::Lit(ref lit) = slf.node {\n                         match lit.node {\n-                            LitKind::Int(..) |\n-                            LitKind::Float(..) |\n-                            LitKind::FloatUnsuffixed(..) => {\n+                            LitKind::Int(..) | LitKind::Float(..) | LitKind::FloatUnsuffixed(..) => {\n                                 span_lint_and_sugg(\n                                     cx,\n                                     PRECEDENCE,"}, {"sha": "9aca75433962dfa909d39370f61d55ee04a041d9", "filename": "clippy_lints/src/print.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprint.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -1,8 +1,8 @@\n use rustc::hir::*;\n-use rustc::hir::map::Node::{NodeItem, NodeImplItem};\n+use rustc::hir::map::Node::{NodeImplItem, NodeItem};\n use rustc::lint::*;\n use utils::paths;\n-use utils::{is_expn_of, match_def_path, resolve_node, span_lint, match_path};\n+use utils::{is_expn_of, match_def_path, match_path, resolve_node, span_lint};\n use format::get_argument_fmtstr_parts;\n \n /// **What it does:** This lint warns when you using `print!()` with a format"}, {"sha": "f12ec039f738af7a76ba995b336b761479bac6fe", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -128,27 +128,29 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId) {\n     let fn_ty = sig.skip_binder();\n \n     for (arg, ty) in decl.inputs.iter().zip(fn_ty.inputs()) {\n-        if let ty::TyRef(_,\n-                         ty::TypeAndMut {\n-                             ty,\n-                             mutbl: MutImmutable,\n-                         }) = ty.sty\n+        if let ty::TyRef(\n+            _,\n+            ty::TypeAndMut {\n+                ty,\n+                mutbl: MutImmutable,\n+            },\n+        ) = ty.sty\n         {\n             if match_type(cx, ty, &paths::VEC) {\n                 span_lint(\n                     cx,\n                     PTR_ARG,\n                     arg.span,\n                     \"writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used \\\n-                           with non-Vec-based slices. Consider changing the type to `&[...]`\",\n+                     with non-Vec-based slices. Consider changing the type to `&[...]`\",\n                 );\n             } else if match_type(cx, ty, &paths::STRING) {\n                 span_lint(\n                     cx,\n                     PTR_ARG,\n                     arg.span,\n                     \"writing `&String` instead of `&str` involves a new object where a slice will do. \\\n-                           Consider changing the type to `&str`\",\n+                     Consider changing the type to `&str`\",\n                 );\n             }\n         }\n@@ -157,10 +159,10 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId) {\n     if let FunctionRetTy::Return(ref ty) = decl.output {\n         if let Some((out, MutMutable, _)) = get_rptr_lm(ty) {\n             let mut immutables = vec![];\n-            for (_, ref mutbl, ref argspan) in\n-                decl.inputs.iter().filter_map(|ty| get_rptr_lm(ty)).filter(\n-                    |&(lt, _, _)| lt.name == out.name,\n-                )\n+            for (_, ref mutbl, ref argspan) in decl.inputs\n+                .iter()\n+                .filter_map(|ty| get_rptr_lm(ty))\n+                .filter(|&(lt, _, _)| lt.name == out.name)\n             {\n                 if *mutbl == MutMutable {\n                     return;"}, {"sha": "44c909810ea86a755f724cb73fd934df27d63269", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -1,7 +1,7 @@\n use rustc::lint::*;\n use rustc::hir::*;\n use utils::{is_integer_literal, paths, snippet, span_lint};\n-use utils::{higher, implements_trait, get_trait_def_id};\n+use utils::{get_trait_def_id, higher, implements_trait};\n \n /// **What it does:** Checks for calling `.step_by(0)` on iterators,\n /// which never terminates.\n@@ -54,7 +54,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StepByZero {\n \n             // Range with step_by(0).\n             if name == \"step_by\" && args.len() == 2 && has_step_by(cx, &args[0]) {\n-                use consts::{Constant, constant};\n+                use consts::{constant, Constant};\n                 use rustc_const_math::ConstInt::Usize;\n                 if let Some((Constant::Int(Usize(us)), _)) = constant(cx, &args[1]) {\n                     if us.as_u64(cx.sess().target.uint_type) == 0 {"}, {"sha": "fce3c6ad2850d13a2bc92659c5a1e58a01c75fe8", "filename": "clippy_lints/src/reference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Freference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Freference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freference.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -1,6 +1,6 @@\n use syntax::ast::{Expr, ExprKind, UnOp};\n use rustc::lint::*;\n-use utils::{span_lint_and_sugg, snippet};\n+use utils::{snippet, span_lint_and_sugg};\n \n /// **What it does:** Checks for usage of `*&` and `*&mut` in expressions.\n ///"}, {"sha": "8b5dedfccd44e4904029248157d61b899aa7a556", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 30, "deletions": 42, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -7,9 +7,9 @@ use rustc::ty::subst::Substs;\n use std::collections::HashSet;\n use std::error::Error;\n use syntax::ast::{LitKind, NodeId};\n-use syntax::codemap::{Span, BytePos};\n+use syntax::codemap::{BytePos, Span};\n use syntax::symbol::InternedString;\n-use utils::{is_expn_of, match_def_path, match_type, paths, span_lint, span_help_and_lint};\n+use utils::{is_expn_of, match_def_path, match_type, paths, span_help_and_lint, span_lint};\n \n /// **What it does:** Checks [regex](https://crates.io/crates/regex) creation\n /// (with `Regex::new`,`RegexBuilder::new` or `RegexSet::new`) for correct\n@@ -161,27 +161,19 @@ fn is_trivial_regex(s: &regex_syntax::Expr) -> Option<&'static str> {\n     match *s {\n         Expr::Empty | Expr::StartText | Expr::EndText => Some(\"the regex is unlikely to be useful as it is\"),\n         Expr::Literal { .. } => Some(\"consider using `str::contains`\"),\n-        Expr::Concat(ref exprs) => {\n-            match exprs.len() {\n-                2 => {\n-                    match (&exprs[0], &exprs[1]) {\n-                        (&Expr::StartText, &Expr::EndText) => Some(\"consider using `str::is_empty`\"),\n-                        (&Expr::StartText, &Expr::Literal { .. }) => Some(\"consider using `str::starts_with`\"),\n-                        (&Expr::Literal { .. }, &Expr::EndText) => Some(\"consider using `str::ends_with`\"),\n-                        _ => None,\n-                    }\n-                },\n-                3 => {\n-                    if let (&Expr::StartText, &Expr::Literal { .. }, &Expr::EndText) =\n-                        (&exprs[0], &exprs[1], &exprs[2])\n-                    {\n-                        Some(\"consider using `==` on `str`s\")\n-                    } else {\n-                        None\n-                    }\n-                },\n+        Expr::Concat(ref exprs) => match exprs.len() {\n+            2 => match (&exprs[0], &exprs[1]) {\n+                (&Expr::StartText, &Expr::EndText) => Some(\"consider using `str::is_empty`\"),\n+                (&Expr::StartText, &Expr::Literal { .. }) => Some(\"consider using `str::starts_with`\"),\n+                (&Expr::Literal { .. }, &Expr::EndText) => Some(\"consider using `str::ends_with`\"),\n                 _ => None,\n-            }\n+            },\n+            3 => if let (&Expr::StartText, &Expr::Literal { .. }, &Expr::EndText) = (&exprs[0], &exprs[1], &exprs[2]) {\n+                Some(\"consider using `==` on `str`s\")\n+            } else {\n+                None\n+            },\n+            _ => None,\n         },\n         _ => None,\n     }\n@@ -205,16 +197,14 @@ fn check_regex(cx: &LateContext, expr: &Expr, utf8: bool) {\n         if let LitKind::Str(ref r, _) = lit.node {\n             let r = &r.as_str();\n             match builder.parse(r) {\n-                Ok(r) => {\n-                    if let Some(repl) = is_trivial_regex(&r) {\n-                        span_help_and_lint(\n-                            cx,\n-                            TRIVIAL_REGEX,\n-                            expr.span,\n-                            \"trivial regex\",\n-                            &format!(\"consider using {}\", repl),\n-                        );\n-                    }\n+                Ok(r) => if let Some(repl) = is_trivial_regex(&r) {\n+                    span_help_and_lint(\n+                        cx,\n+                        TRIVIAL_REGEX,\n+                        expr.span,\n+                        \"trivial regex\",\n+                        &format!(\"consider using {}\", repl),\n+                    );\n                 },\n                 Err(e) => {\n                     span_lint(\n@@ -228,16 +218,14 @@ fn check_regex(cx: &LateContext, expr: &Expr, utf8: bool) {\n         }\n     } else if let Some(r) = const_str(cx, expr) {\n         match builder.parse(&r) {\n-            Ok(r) => {\n-                if let Some(repl) = is_trivial_regex(&r) {\n-                    span_help_and_lint(\n-                        cx,\n-                        TRIVIAL_REGEX,\n-                        expr.span,\n-                        \"trivial regex\",\n-                        &format!(\"consider using {}\", repl),\n-                    );\n-                }\n+            Ok(r) => if let Some(repl) = is_trivial_regex(&r) {\n+                span_help_and_lint(\n+                    cx,\n+                    TRIVIAL_REGEX,\n+                    expr.span,\n+                    \"trivial regex\",\n+                    &format!(\"consider using {}\", repl),\n+                );\n             },\n             Err(e) => {\n                 span_lint("}, {"sha": "0884ebbf5cf0ba33bb4dbcb5035957e389441ddd", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -3,7 +3,7 @@ use syntax::ast;\n use syntax::codemap::{Span, Spanned};\n use syntax::visit::FnKind;\n \n-use utils::{span_note_and_lint, span_lint_and_then, snippet_opt, match_path_ast, in_macro, in_external_macro};\n+use utils::{in_external_macro, in_macro, match_path_ast, snippet_opt, span_lint_and_then, span_note_and_lint};\n \n /// **What it does:** Checks for return statements at the end of a block.\n ///\n@@ -50,8 +50,7 @@ impl ReturnPass {\n     fn check_block_return(&mut self, cx: &EarlyContext, block: &ast::Block) {\n         if let Some(stmt) = block.stmts.last() {\n             match stmt.node {\n-                ast::StmtKind::Expr(ref expr) |\n-                ast::StmtKind::Semi(ref expr) => {\n+                ast::StmtKind::Expr(ref expr) | ast::StmtKind::Semi(ref expr) => {\n                     self.check_final_expr(cx, expr, Some(stmt.span));\n                 },\n                 _ => (),\n@@ -81,10 +80,8 @@ impl ReturnPass {\n                 self.check_final_expr(cx, elsexpr, None);\n             },\n             // a match expr, check all arms\n-            ast::ExprKind::Match(_, ref arms) => {\n-                for arm in arms {\n-                    self.check_final_expr(cx, &arm.body, Some(arm.body.span));\n-                }\n+            ast::ExprKind::Match(_, ref arms) => for arm in arms {\n+                self.check_final_expr(cx, &arm.body, Some(arm.body.span));\n             },\n             _ => (),\n         }\n@@ -140,8 +137,7 @@ impl LintPass for ReturnPass {\n impl EarlyLintPass for ReturnPass {\n     fn check_fn(&mut self, cx: &EarlyContext, kind: FnKind, _: &ast::FnDecl, _: Span, _: ast::NodeId) {\n         match kind {\n-            FnKind::ItemFn(.., block) |\n-            FnKind::Method(.., block) => self.check_block_return(cx, block),\n+            FnKind::ItemFn(.., block) | FnKind::Method(.., block) => self.check_block_return(cx, block),\n             FnKind::Closure(body) => self.check_final_expr(cx, body, Some(body.span)),\n         }\n     }"}, {"sha": "0ea24a33393415996af935e94466d155c229e6f8", "filename": "clippy_lints/src/serde_api.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fserde_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fserde_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fserde_api.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -1,6 +1,6 @@\n use rustc::lint::*;\n use rustc::hir::*;\n-use utils::{span_lint, get_trait_def_id, paths};\n+use utils::{get_trait_def_id, paths, span_lint};\n \n /// **What it does:** Checks for mis-uses of the serde API.\n ///"}, {"sha": "f6461b2d4388378580fb0163c7816e3800ff1032", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 51, "deletions": 65, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -4,7 +4,7 @@ use rustc::hir::*;\n use rustc::hir::intravisit::FnKind;\n use rustc::ty;\n use syntax::codemap::Span;\n-use utils::{contains_name, higher, in_external_macro, snippet, span_lint_and_then, iter_input_pats};\n+use utils::{contains_name, higher, in_external_macro, iter_input_pats, snippet, span_lint_and_then};\n \n /// **What it does:** Checks for bindings that shadow other bindings already in\n /// scope, while just changing reference level or mutability.\n@@ -111,8 +111,7 @@ fn check_block<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, block: &'tcx Block, binding\n     for stmt in &block.stmts {\n         match stmt.node {\n             StmtDecl(ref decl, _) => check_decl(cx, decl, bindings),\n-            StmtExpr(ref e, _) |\n-            StmtSemi(ref e, _) => check_expr(cx, e, bindings),\n+            StmtExpr(ref e, _) | StmtSemi(ref e, _) => check_expr(cx, e, bindings),\n         }\n     }\n     if let Some(ref o) = block.expr {\n@@ -185,54 +184,49 @@ fn check_pat<'a, 'tcx>(\n                 check_pat(cx, p, init, span, bindings);\n             }\n         },\n-        PatKind::Struct(_, ref pfields, _) => {\n-            if let Some(init_struct) = init {\n-                if let ExprStruct(_, ref efields, _) = init_struct.node {\n-                    for field in pfields {\n-                        let name = field.node.name;\n-                        let efield = efields.iter().find(|f| f.name.node == name).map(\n-                            |f| &*f.expr,\n-                        );\n-                        check_pat(cx, &field.node.pat, efield, span, bindings);\n-                    }\n-                } else {\n-                    for field in pfields {\n-                        check_pat(cx, &field.node.pat, init, span, bindings);\n-                    }\n+        PatKind::Struct(_, ref pfields, _) => if let Some(init_struct) = init {\n+            if let ExprStruct(_, ref efields, _) = init_struct.node {\n+                for field in pfields {\n+                    let name = field.node.name;\n+                    let efield = efields\n+                        .iter()\n+                        .find(|f| f.name.node == name)\n+                        .map(|f| &*f.expr);\n+                    check_pat(cx, &field.node.pat, efield, span, bindings);\n                 }\n             } else {\n                 for field in pfields {\n-                    check_pat(cx, &field.node.pat, None, span, bindings);\n+                    check_pat(cx, &field.node.pat, init, span, bindings);\n                 }\n             }\n+        } else {\n+            for field in pfields {\n+                check_pat(cx, &field.node.pat, None, span, bindings);\n+            }\n         },\n-        PatKind::Tuple(ref inner, _) => {\n-            if let Some(init_tup) = init {\n-                if let ExprTup(ref tup) = init_tup.node {\n-                    for (i, p) in inner.iter().enumerate() {\n-                        check_pat(cx, p, Some(&tup[i]), p.span, bindings);\n-                    }\n-                } else {\n-                    for p in inner {\n-                        check_pat(cx, p, init, span, bindings);\n-                    }\n+        PatKind::Tuple(ref inner, _) => if let Some(init_tup) = init {\n+            if let ExprTup(ref tup) = init_tup.node {\n+                for (i, p) in inner.iter().enumerate() {\n+                    check_pat(cx, p, Some(&tup[i]), p.span, bindings);\n                 }\n             } else {\n                 for p in inner {\n-                    check_pat(cx, p, None, span, bindings);\n+                    check_pat(cx, p, init, span, bindings);\n                 }\n             }\n+        } else {\n+            for p in inner {\n+                check_pat(cx, p, None, span, bindings);\n+            }\n         },\n-        PatKind::Box(ref inner) => {\n-            if let Some(initp) = init {\n-                if let ExprBox(ref inner_init) = initp.node {\n-                    check_pat(cx, inner, Some(&**inner_init), span, bindings);\n-                } else {\n-                    check_pat(cx, inner, init, span, bindings);\n-                }\n+        PatKind::Box(ref inner) => if let Some(initp) = init {\n+            if let ExprBox(ref inner_init) = initp.node {\n+                check_pat(cx, inner, Some(&**inner_init), span, bindings);\n             } else {\n                 check_pat(cx, inner, init, span, bindings);\n             }\n+        } else {\n+            check_pat(cx, inner, init, span, bindings);\n         },\n         PatKind::Ref(ref inner, _) => check_pat(cx, inner, init, span, bindings),\n         // PatVec(Vec<P<Pat>>, Option<P<Pat>>, Vec<P<Pat>>),\n@@ -292,13 +286,14 @@ fn lint_shadow<'a, 'tcx: 'a>(\n                 },\n             );\n         }\n-\n     } else {\n-        span_lint_and_then(cx,\n-                           SHADOW_UNRELATED,\n-                           span,\n-                           &format!(\"`{}` shadows a previous declaration\", snippet(cx, pattern_span, \"_\")),\n-                           |db| { db.span_note(prev_span, \"previous binding is here\"); });\n+        span_lint_and_then(\n+            cx,\n+            SHADOW_UNRELATED,\n+            span,\n+            &format!(\"`{}` shadows a previous declaration\", snippet(cx, pattern_span, \"_\")),\n+            |db| { db.span_note(prev_span, \"previous binding is here\"); },\n+        );\n     }\n }\n \n@@ -307,19 +302,14 @@ fn check_expr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, bindings:\n         return;\n     }\n     match expr.node {\n-        ExprUnary(_, ref e) |\n-        ExprField(ref e, _) |\n-        ExprTupField(ref e, _) |\n-        ExprAddrOf(_, ref e) |\n-        ExprBox(ref e) => check_expr(cx, e, bindings),\n-        ExprBlock(ref block) |\n-        ExprLoop(ref block, _, _) => check_block(cx, block, bindings),\n+        ExprUnary(_, ref e) | ExprField(ref e, _) | ExprTupField(ref e, _) | ExprAddrOf(_, ref e) | ExprBox(ref e) => {\n+            check_expr(cx, e, bindings)\n+        },\n+        ExprBlock(ref block) | ExprLoop(ref block, _, _) => check_block(cx, block, bindings),\n         // ExprCall\n         // ExprMethodCall\n-        ExprArray(ref v) | ExprTup(ref v) => {\n-            for e in v {\n-                check_expr(cx, e, bindings)\n-            }\n+        ExprArray(ref v) | ExprTup(ref v) => for e in v {\n+            check_expr(cx, e, bindings)\n         },\n         ExprIf(ref cond, ref then, ref otherwise) => {\n             check_expr(cx, cond, bindings);\n@@ -358,12 +348,9 @@ fn check_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: &'tcx Ty, bindings: &mut V\n             check_ty(cx, fty, bindings);\n             check_expr(cx, &cx.tcx.hir.body(body_id).value, bindings);\n         },\n-        TyPtr(MutTy { ty: ref mty, .. }) |\n-        TyRptr(_, MutTy { ty: ref mty, .. }) => check_ty(cx, mty, bindings),\n-        TyTup(ref tup) => {\n-            for t in tup {\n-                check_ty(cx, t, bindings)\n-            }\n+        TyPtr(MutTy { ty: ref mty, .. }) | TyRptr(_, MutTy { ty: ref mty, .. }) => check_ty(cx, mty, bindings),\n+        TyTup(ref tup) => for t in tup {\n+            check_ty(cx, t, bindings)\n         },\n         TyTypeof(body_id) => check_expr(cx, &cx.tcx.hir.body(body_id).value, bindings),\n         _ => (),\n@@ -372,14 +359,13 @@ fn check_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: &'tcx Ty, bindings: &mut V\n \n fn is_self_shadow(name: Name, expr: &Expr) -> bool {\n     match expr.node {\n-        ExprBox(ref inner) |\n-        ExprAddrOf(_, ref inner) => is_self_shadow(name, inner),\n+        ExprBox(ref inner) | ExprAddrOf(_, ref inner) => is_self_shadow(name, inner),\n         ExprBlock(ref block) => {\n             block.stmts.is_empty() &&\n-                block.expr.as_ref().map_or(\n-                    false,\n-                    |e| is_self_shadow(name, e),\n-                )\n+                block\n+                    .expr\n+                    .as_ref()\n+                    .map_or(false, |e| is_self_shadow(name, e))\n         },\n         ExprUnary(op, ref inner) => (UnDeref == op) && is_self_shadow(name, inner),\n         ExprPath(QPath::Resolved(_, ref path)) => path_eq_name(name, path),"}, {"sha": "b8cc6873adc4541169454ba2b8bc1817b905843c", "filename": "clippy_lints/src/should_assert_eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fshould_assert_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fshould_assert_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshould_assert_eq.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -1,6 +1,6 @@\n use rustc::lint::*;\n use rustc::hir::*;\n-use utils::{is_direct_expn_of, is_expn_of, implements_trait, span_lint};\n+use utils::{implements_trait, is_direct_expn_of, is_expn_of, span_lint};\n \n /// **What it does:** Checks for `assert!(x == y)` or `assert!(x != y)` which\n /// can be better written"}, {"sha": "0365322ef680f4f5b6802e76c9fd688a5bfc9529", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -2,7 +2,7 @@ use rustc::hir::*;\n use rustc::lint::*;\n use syntax::codemap::Spanned;\n use utils::SpanlessEq;\n-use utils::{match_type, paths, span_lint, span_lint_and_sugg, walk_ptrs_ty, get_parent_expr, is_allowed};\n+use utils::{get_parent_expr, is_allowed, match_type, paths, span_lint, span_lint_and_sugg, walk_ptrs_ty};\n \n /// **What it does:** Checks for string appends of the form `x = x + y` (without\n /// `let`!).\n@@ -108,7 +108,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringAdd {\n                     STRING_ADD_ASSIGN,\n                     e.span,\n                     \"you assigned the result of adding something to this string. Consider using \\\n-                           `String::push_str()` instead\",\n+                     `String::push_str()` instead\",\n                 );\n             }\n         }\n@@ -124,10 +124,10 @@ fn is_add(cx: &LateContext, src: &Expr, target: &Expr) -> bool {\n         ExprBinary(Spanned { node: BiAdd, .. }, ref left, _) => SpanlessEq::new(cx).eq_expr(target, left),\n         ExprBlock(ref block) => {\n             block.stmts.is_empty() &&\n-                block.expr.as_ref().map_or(\n-                    false,\n-                    |expr| is_add(cx, expr, target),\n-                )\n+                block\n+                    .expr\n+                    .as_ref()\n+                    .map_or(false, |expr| is_add(cx, expr, target))\n         },\n         _ => false,\n     }\n@@ -146,7 +146,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringLitAsBytes {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         use std::ascii::AsciiExt;\n         use syntax::ast::LitKind;\n-        use utils::{snippet, in_macro};\n+        use utils::{in_macro, snippet};\n \n         if let ExprMethodCall(ref path, _, ref args) = e.node {\n             if path.name == \"as_bytes\" {"}, {"sha": "877321255c160a36cc1e9dcff895ca9b51975ab5", "filename": "clippy_lints/src/temporary_assignment.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftemporary_assignment.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -41,11 +41,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprAssign(ref target, _) = expr.node {\n             match target.node {\n-                ExprField(ref base, _) |\n-                ExprTupField(ref base, _) => {\n-                    if is_temporary(base) && !is_adjusted(cx, base) {\n-                        span_lint(cx, TEMPORARY_ASSIGNMENT, expr.span, \"assignment to temporary\");\n-                    }\n+                ExprField(ref base, _) | ExprTupField(ref base, _) => if is_temporary(base) && !is_adjusted(cx, base) {\n+                    span_lint(cx, TEMPORARY_ASSIGNMENT, expr.span, \"assignment to temporary\");\n                 },\n                 _ => (),\n             }"}, {"sha": "a590bf744bfa4dd732c1bc793209441c83ab3c3d", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 77, "deletions": 92, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -1,7 +1,7 @@\n use rustc::lint::*;\n use rustc::ty::{self, Ty};\n use rustc::hir::*;\n-use utils::{match_def_path, paths, span_lint, span_lint_and_then, snippet, last_path_segment};\n+use utils::{last_path_segment, match_def_path, paths, snippet, span_lint, span_lint_and_then};\n use utils::sugg;\n \n /// **What it does:** Checks for transmutes that can't ever be correct on any\n@@ -95,103 +95,88 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                     let to_ty = cx.tables.expr_ty(e);\n \n                     match (&from_ty.sty, &to_ty.sty) {\n-                        _ if from_ty == to_ty => {\n-                            span_lint(\n-                                cx,\n-                                USELESS_TRANSMUTE,\n-                                e.span,\n-                                &format!(\"transmute from a type (`{}`) to itself\", from_ty),\n-                            )\n-                        },\n-                        (&ty::TyRef(_, rty), &ty::TyRawPtr(ptr_ty)) => {\n-                            span_lint_and_then(\n-                                cx,\n-                                USELESS_TRANSMUTE,\n-                                e.span,\n-                                \"transmute from a reference to a pointer\",\n-                                |db| if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n-                                    let sugg = if ptr_ty == rty {\n-                                        arg.as_ty(to_ty)\n-                                    } else {\n-                                        arg.as_ty(cx.tcx.mk_ptr(rty)).as_ty(to_ty)\n-                                    };\n+                        _ if from_ty == to_ty => span_lint(\n+                            cx,\n+                            USELESS_TRANSMUTE,\n+                            e.span,\n+                            &format!(\"transmute from a type (`{}`) to itself\", from_ty),\n+                        ),\n+                        (&ty::TyRef(_, rty), &ty::TyRawPtr(ptr_ty)) => span_lint_and_then(\n+                            cx,\n+                            USELESS_TRANSMUTE,\n+                            e.span,\n+                            \"transmute from a reference to a pointer\",\n+                            |db| if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n+                                let sugg = if ptr_ty == rty {\n+                                    arg.as_ty(to_ty)\n+                                } else {\n+                                    arg.as_ty(cx.tcx.mk_ptr(rty)).as_ty(to_ty)\n+                                };\n \n-                                    db.span_suggestion(e.span, \"try\", sugg.to_string());\n-                                },\n-                            )\n-                        },\n-                        (&ty::TyInt(_), &ty::TyRawPtr(_)) |\n-                        (&ty::TyUint(_), &ty::TyRawPtr(_)) => {\n-                            span_lint_and_then(\n-                                cx,\n-                                USELESS_TRANSMUTE,\n-                                e.span,\n-                                \"transmute from an integer to a pointer\",\n-                                |db| if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n-                                    db.span_suggestion(e.span, \"try\", arg.as_ty(&to_ty.to_string()).to_string());\n-                                },\n-                            )\n-                        },\n+                                db.span_suggestion(e.span, \"try\", sugg.to_string());\n+                            },\n+                        ),\n+                        (&ty::TyInt(_), &ty::TyRawPtr(_)) | (&ty::TyUint(_), &ty::TyRawPtr(_)) => span_lint_and_then(\n+                            cx,\n+                            USELESS_TRANSMUTE,\n+                            e.span,\n+                            \"transmute from an integer to a pointer\",\n+                            |db| if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n+                                db.span_suggestion(e.span, \"try\", arg.as_ty(&to_ty.to_string()).to_string());\n+                            },\n+                        ),\n                         (&ty::TyFloat(_), &ty::TyRef(..)) |\n                         (&ty::TyFloat(_), &ty::TyRawPtr(_)) |\n                         (&ty::TyChar, &ty::TyRef(..)) |\n-                        (&ty::TyChar, &ty::TyRawPtr(_)) => {\n-                            span_lint(\n-                                cx,\n-                                WRONG_TRANSMUTE,\n-                                e.span,\n-                                &format!(\"transmute from a `{}` to a pointer\", from_ty),\n-                            )\n-                        },\n-                        (&ty::TyRawPtr(from_ptr), _) if from_ptr.ty == to_ty => {\n-                            span_lint(\n-                                cx,\n-                                CROSSPOINTER_TRANSMUTE,\n-                                e.span,\n-                                &format!(\n-                                    \"transmute from a type (`{}`) to the type that it points to (`{}`)\",\n-                                    from_ty,\n-                                    to_ty\n-                                ),\n-                            )\n-                        },\n-                        (_, &ty::TyRawPtr(to_ptr)) if to_ptr.ty == from_ty => {\n-                            span_lint(\n-                                cx,\n-                                CROSSPOINTER_TRANSMUTE,\n-                                e.span,\n-                                &format!(\"transmute from a type (`{}`) to a pointer to that type (`{}`)\", from_ty, to_ty),\n-                            )\n-                        },\n-                        (&ty::TyRawPtr(from_pty), &ty::TyRef(_, to_rty)) => {\n-                            span_lint_and_then(\n-                                cx,\n-                                TRANSMUTE_PTR_TO_REF,\n-                                e.span,\n-                                &format!(\n-                                    \"transmute from a pointer type (`{}`) to a reference type \\\n-                                                         (`{}`)\",\n-                                    from_ty,\n-                                    to_ty\n-                                ),\n-                                |db| {\n-                                    let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n-                                    let (deref, cast) = if to_rty.mutbl == Mutability::MutMutable {\n-                                        (\"&mut *\", \"*mut\")\n-                                    } else {\n-                                        (\"&*\", \"*const\")\n-                                    };\n+                        (&ty::TyChar, &ty::TyRawPtr(_)) => span_lint(\n+                            cx,\n+                            WRONG_TRANSMUTE,\n+                            e.span,\n+                            &format!(\"transmute from a `{}` to a pointer\", from_ty),\n+                        ),\n+                        (&ty::TyRawPtr(from_ptr), _) if from_ptr.ty == to_ty => span_lint(\n+                            cx,\n+                            CROSSPOINTER_TRANSMUTE,\n+                            e.span,\n+                            &format!(\n+                                \"transmute from a type (`{}`) to the type that it points to (`{}`)\",\n+                                from_ty,\n+                                to_ty\n+                            ),\n+                        ),\n+                        (_, &ty::TyRawPtr(to_ptr)) if to_ptr.ty == from_ty => span_lint(\n+                            cx,\n+                            CROSSPOINTER_TRANSMUTE,\n+                            e.span,\n+                            &format!(\"transmute from a type (`{}`) to a pointer to that type (`{}`)\", from_ty, to_ty),\n+                        ),\n+                        (&ty::TyRawPtr(from_pty), &ty::TyRef(_, to_rty)) => span_lint_and_then(\n+                            cx,\n+                            TRANSMUTE_PTR_TO_REF,\n+                            e.span,\n+                            &format!(\n+                                \"transmute from a pointer type (`{}`) to a reference type \\\n+                                 (`{}`)\",\n+                                from_ty,\n+                                to_ty\n+                            ),\n+                            |db| {\n+                                let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n+                                let (deref, cast) = if to_rty.mutbl == Mutability::MutMutable {\n+                                    (\"&mut *\", \"*mut\")\n+                                } else {\n+                                    (\"&*\", \"*const\")\n+                                };\n \n-                                    let arg = if from_pty.ty == to_rty.ty {\n-                                        arg\n-                                    } else {\n-                                        arg.as_ty(&format!(\"{} {}\", cast, get_type_snippet(cx, qpath, to_rty.ty)))\n-                                    };\n+                                let arg = if from_pty.ty == to_rty.ty {\n+                                    arg\n+                                } else {\n+                                    arg.as_ty(&format!(\"{} {}\", cast, get_type_snippet(cx, qpath, to_rty.ty)))\n+                                };\n \n-                                    db.span_suggestion(e.span, \"try\", sugg::make_unop(deref, arg).to_string());\n-                                },\n-                            )\n-                        },\n+                                db.span_suggestion(e.span, \"try\", sugg::make_unop(deref, arg).to_string());\n+                            },\n+                        ),\n                         _ => return,\n                     };\n                 }"}, {"sha": "78e06fa80ddcf281a752bf3fb879dd4752302bc7", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 154, "deletions": 200, "changes": 354, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -1,16 +1,16 @@\n use reexport::*;\n use rustc::hir;\n use rustc::hir::*;\n-use rustc::hir::intravisit::{FnKind, Visitor, walk_ty, NestedVisitorMap};\n+use rustc::hir::intravisit::{walk_ty, FnKind, NestedVisitorMap, Visitor};\n use rustc::lint::*;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n use std::cmp::Ordering;\n-use syntax::ast::{IntTy, UintTy, FloatTy};\n+use syntax::ast::{FloatTy, IntTy, UintTy};\n use syntax::attr::IntType;\n use syntax::codemap::Span;\n-use utils::{comparisons, higher, in_external_macro, in_macro, match_def_path, snippet, span_help_and_lint, span_lint,\n-            span_lint_and_sugg, opt_def_id, last_path_segment, type_size, match_path};\n+use utils::{comparisons, higher, in_external_macro, in_macro, last_path_segment, match_def_path, match_path,\n+            opt_def_id, snippet, span_help_and_lint, span_lint, span_lint_and_sugg, type_size};\n use utils::paths;\n \n /// Handles all the linting of funky types\n@@ -114,8 +114,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypePass {\n \n     fn check_trait_item(&mut self, cx: &LateContext, item: &TraitItem) {\n         match item.node {\n-            TraitItemKind::Const(ref ty, _) |\n-            TraitItemKind::Type(_, Some(ref ty)) => check_ty(cx, ty, false),\n+            TraitItemKind::Const(ref ty, _) | TraitItemKind::Type(_, Some(ref ty)) => check_ty(cx, ty, false),\n             TraitItemKind::Method(ref sig, _) => check_fn_decl(cx, &sig.decl),\n             _ => (),\n         }\n@@ -182,20 +181,18 @@ fn check_ty(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool) {\n             match *qpath {\n                 QPath::Resolved(Some(ref ty), ref p) => {\n                     check_ty(cx, ty, is_local);\n-                    for ty in p.segments.iter().flat_map(\n-                        |seg| seg.parameters.types.iter(),\n-                    )\n+                    for ty in p.segments\n+                        .iter()\n+                        .flat_map(|seg| seg.parameters.types.iter())\n                     {\n                         check_ty(cx, ty, is_local);\n                     }\n                 },\n-                QPath::Resolved(None, ref p) => {\n-                    for ty in p.segments.iter().flat_map(\n-                        |seg| seg.parameters.types.iter(),\n-                    )\n-                    {\n-                        check_ty(cx, ty, is_local);\n-                    }\n+                QPath::Resolved(None, ref p) => for ty in p.segments\n+                    .iter()\n+                    .flat_map(|seg| seg.parameters.types.iter())\n+                {\n+                    check_ty(cx, ty, is_local);\n                 },\n                 QPath::TypeRelative(ref ty, ref seg) => {\n                     check_ty(cx, ty, is_local);\n@@ -248,13 +245,9 @@ fn check_ty(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool) {\n             }\n         },\n         // recurse\n-        TySlice(ref ty) |\n-        TyArray(ref ty, _) |\n-        TyPtr(MutTy { ref ty, .. }) => check_ty(cx, ty, is_local),\n-        TyTup(ref tys) => {\n-            for ty in tys {\n-                check_ty(cx, ty, is_local);\n-            }\n+        TySlice(ref ty) | TyArray(ref ty, _) | TyPtr(MutTy { ref ty, .. }) => check_ty(cx, ty, is_local),\n+        TyTup(ref tys) => for ty in tys {\n+            check_ty(cx, ty, is_local);\n         },\n         _ => {},\n     }\n@@ -529,34 +522,29 @@ declare_lint! {\n /// Will return 0 if the type is not an int or uint variant\n fn int_ty_to_nbits(typ: Ty, tcx: TyCtxt) -> u64 {\n     match typ.sty {\n-        ty::TyInt(i) => {\n-            match i {\n-                IntTy::Is => tcx.data_layout.pointer_size.bits(),\n-                IntTy::I8 => 8,\n-                IntTy::I16 => 16,\n-                IntTy::I32 => 32,\n-                IntTy::I64 => 64,\n-                IntTy::I128 => 128,\n-            }\n+        ty::TyInt(i) => match i {\n+            IntTy::Is => tcx.data_layout.pointer_size.bits(),\n+            IntTy::I8 => 8,\n+            IntTy::I16 => 16,\n+            IntTy::I32 => 32,\n+            IntTy::I64 => 64,\n+            IntTy::I128 => 128,\n         },\n-        ty::TyUint(i) => {\n-            match i {\n-                UintTy::Us => tcx.data_layout.pointer_size.bits(),\n-                UintTy::U8 => 8,\n-                UintTy::U16 => 16,\n-                UintTy::U32 => 32,\n-                UintTy::U64 => 64,\n-                UintTy::U128 => 128,\n-            }\n+        ty::TyUint(i) => match i {\n+            UintTy::Us => tcx.data_layout.pointer_size.bits(),\n+            UintTy::U8 => 8,\n+            UintTy::U16 => 16,\n+            UintTy::U32 => 32,\n+            UintTy::U64 => 64,\n+            UintTy::U128 => 128,\n         },\n         _ => 0,\n     }\n }\n \n fn is_isize_or_usize(typ: Ty) -> bool {\n     match typ.sty {\n-        ty::TyInt(IntTy::Is) |\n-        ty::TyUint(UintTy::Us) => true,\n+        ty::TyInt(IntTy::Is) | ty::TyUint(UintTy::Us) => true,\n         _ => false,\n     }\n }\n@@ -578,7 +566,7 @@ fn span_precision_loss_lint(cx: &LateContext, expr: &Expr, cast_from: Ty, cast_t\n         expr.span,\n         &format!(\n             \"casting {0} to {1} causes a loss of precision {2}({0} is {3} bits wide, but {1}'s mantissa \\\n-                        is only {4} bits wide)\",\n+             is only {4} bits wide)\",\n             cast_from,\n             if cast_to_f64 { \"f64\" } else { \"f32\" },\n             if arch_dependent {\n@@ -617,38 +605,32 @@ fn check_truncation_and_wrapping(cx: &LateContext, expr: &Expr, cast_from: Ty, c\n     let to_nbits = int_ty_to_nbits(cast_to, cx.tcx);\n     let (span_truncation, suffix_truncation, span_wrap, suffix_wrap) =\n         match (is_isize_or_usize(cast_from), is_isize_or_usize(cast_to)) {\n-            (true, true) | (false, false) => {\n-                (\n-                    to_nbits < from_nbits,\n-                    ArchSuffix::None,\n-                    to_nbits == from_nbits && cast_unsigned_to_signed,\n-                    ArchSuffix::None,\n-                )\n-            },\n-            (true, false) => {\n-                (\n-                    to_nbits <= 32,\n-                    if to_nbits == 32 {\n-                        ArchSuffix::_64\n-                    } else {\n-                        ArchSuffix::None\n-                    },\n-                    to_nbits <= 32 && cast_unsigned_to_signed,\n-                    ArchSuffix::_32,\n-                )\n-            },\n-            (false, true) => {\n-                (\n-                    from_nbits == 64,\n-                    ArchSuffix::_32,\n-                    cast_unsigned_to_signed,\n-                    if from_nbits == 64 {\n-                        ArchSuffix::_64\n-                    } else {\n-                        ArchSuffix::_32\n-                    },\n-                )\n-            },\n+            (true, true) | (false, false) => (\n+                to_nbits < from_nbits,\n+                ArchSuffix::None,\n+                to_nbits == from_nbits && cast_unsigned_to_signed,\n+                ArchSuffix::None,\n+            ),\n+            (true, false) => (\n+                to_nbits <= 32,\n+                if to_nbits == 32 {\n+                    ArchSuffix::_64\n+                } else {\n+                    ArchSuffix::None\n+                },\n+                to_nbits <= 32 && cast_unsigned_to_signed,\n+                ArchSuffix::_32,\n+            ),\n+            (false, true) => (\n+                from_nbits == 64,\n+                ArchSuffix::_32,\n+                cast_unsigned_to_signed,\n+                if from_nbits == 64 {\n+                    ArchSuffix::_64\n+                } else {\n+                    ArchSuffix::_32\n+                },\n+            ),\n         };\n     if span_truncation {\n         span_lint(\n@@ -690,8 +672,7 @@ fn check_lossless(cx: &LateContext, expr: &Expr, op: &Expr, cast_from: Ty, cast_\n     let cast_signed_to_unsigned = cast_from.is_signed() && !cast_to.is_signed();\n     let from_nbits = int_ty_to_nbits(cast_from, cx.tcx);\n     let to_nbits = int_ty_to_nbits(cast_to, cx.tcx);\n-    if !is_isize_or_usize(cast_from) && !is_isize_or_usize(cast_to) && from_nbits < to_nbits &&\n-        !cast_signed_to_unsigned\n+    if !is_isize_or_usize(cast_from) && !is_isize_or_usize(cast_to) && from_nbits < to_nbits && !cast_signed_to_unsigned\n     {\n         span_lossless_lint(cx, expr, op, cast_from, cast_to);\n     }\n@@ -715,19 +696,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CastPass {\n         if let ExprCast(ref ex, _) = expr.node {\n             let (cast_from, cast_to) = (cx.tables.expr_ty(ex), cx.tables.expr_ty(expr));\n             if let ExprLit(ref lit) = ex.node {\n-                use syntax::ast::{LitKind, LitIntType};\n+                use syntax::ast::{LitIntType, LitKind};\n                 match lit.node {\n-                    LitKind::Int(_, LitIntType::Unsuffixed) |\n-                    LitKind::FloatUnsuffixed(_) => {},\n-                    _ => {\n-                        if cast_from.sty == cast_to.sty && !in_external_macro(cx, expr.span) {\n-                            span_lint(\n-                                cx,\n-                                UNNECESSARY_CAST,\n-                                expr.span,\n-                                &format!(\"casting to the same type is unnecessary (`{}` -> `{}`)\", cast_from, cast_to),\n-                            );\n-                        }\n+                    LitKind::Int(_, LitIntType::Unsuffixed) | LitKind::FloatUnsuffixed(_) => {},\n+                    _ => if cast_from.sty == cast_to.sty && !in_external_macro(cx, expr.span) {\n+                        span_lint(\n+                            cx,\n+                            UNNECESSARY_CAST,\n+                            expr.span,\n+                            &format!(\"casting to the same type is unnecessary (`{}` -> `{}`)\", cast_from, cast_to),\n+                        );\n                     },\n                 }\n             }\n@@ -776,8 +754,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CastPass {\n                         check_lossless(cx, expr, ex, cast_from, cast_to);\n                     },\n                     (false, false) => {\n-                        if let (&ty::TyFloat(FloatTy::F64), &ty::TyFloat(FloatTy::F32)) =\n-                            (&cast_from.sty, &cast_to.sty)\n+                        if let (&ty::TyFloat(FloatTy::F64), &ty::TyFloat(FloatTy::F32)) = (&cast_from.sty, &cast_to.sty)\n                         {\n                             span_lint(\n                                 cx,\n@@ -786,8 +763,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CastPass {\n                                 \"casting f64 to f32 may truncate the value\",\n                             );\n                         }\n-                        if let (&ty::TyFloat(FloatTy::F32), &ty::TyFloat(FloatTy::F64)) =\n-                            (&cast_from.sty, &cast_to.sty)\n+                        if let (&ty::TyFloat(FloatTy::F32), &ty::TyFloat(FloatTy::F64)) = (&cast_from.sty, &cast_to.sty)\n                         {\n                             span_lossless_lint(cx, expr, ex, cast_from, cast_to);\n                         }\n@@ -823,7 +799,9 @@ pub struct TypeComplexityPass {\n \n impl TypeComplexityPass {\n     pub fn new(threshold: u64) -> Self {\n-        Self { threshold: threshold }\n+        Self {\n+            threshold: threshold,\n+        }\n     }\n }\n \n@@ -853,17 +831,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeComplexityPass {\n \n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         match item.node {\n-            ItemStatic(ref ty, _, _) |\n-            ItemConst(ref ty, _) => self.check_type(cx, ty),\n+            ItemStatic(ref ty, _, _) | ItemConst(ref ty, _) => self.check_type(cx, ty),\n             // functions, enums, structs, impls and traits are covered\n             _ => (),\n         }\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem) {\n         match item.node {\n-            TraitItemKind::Const(ref ty, _) |\n-            TraitItemKind::Type(_, Some(ref ty)) => self.check_type(cx, ty),\n+            TraitItemKind::Const(ref ty, _) | TraitItemKind::Type(_, Some(ref ty)) => self.check_type(cx, ty),\n             TraitItemKind::Method(MethodSig { ref decl, .. }, TraitMethod::Required(_)) => self.check_fndecl(cx, decl),\n             // methods with default impl are covered by check_fn\n             _ => (),\n@@ -872,8 +848,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeComplexityPass {\n \n     fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem) {\n         match item.node {\n-            ImplItemKind::Const(ref ty, _) |\n-            ImplItemKind::Type(ref ty) => self.check_type(cx, ty),\n+            ImplItemKind::Const(ref ty, _) | ImplItemKind::Type(ref ty) => self.check_type(cx, ty),\n             // methods are covered by check_fn\n             _ => (),\n         }\n@@ -938,9 +913,9 @@ impl<'tcx> Visitor<'tcx> for TypeComplexityVisitor {\n             TyBareFn(..) => (50 * self.nest, 1),\n \n             TyTraitObject(ref param_bounds, _) => {\n-                let has_lifetime_parameters = param_bounds.iter().any(\n-                    |bound| !bound.bound_lifetimes.is_empty(),\n-                );\n+                let has_lifetime_parameters = param_bounds\n+                    .iter()\n+                    .any(|bound| !bound.bound_lifetimes.is_empty());\n                 if has_lifetime_parameters {\n                     // complex trait bounds like A<'a, 'b>\n                     (50 * self.nest, 1)\n@@ -1101,7 +1076,7 @@ fn detect_absurd_comparison<'a>(\n         Rel::Le => {\n             match (lx, rx) {\n                 (Some(l @ ExtremeExpr { which: Minimum, .. }), _) => (l, AlwaysTrue), // min <= x\n-                (Some(l @ ExtremeExpr { which: Maximum, .. }), _) => (l, InequalityImpossible), //max <= x\n+                (Some(l @ ExtremeExpr { which: Maximum, .. }), _) => (l, InequalityImpossible), // max <= x\n                 (_, Some(r @ ExtremeExpr { which: Minimum, .. })) => (r, InequalityImpossible), // x <= min\n                 (_, Some(r @ ExtremeExpr { which: Maximum, .. })) => (r, AlwaysTrue), // x <= max\n                 _ => return None,\n@@ -1187,14 +1162,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AbsurdExtremeComparisons {\n                     let conclusion = match result {\n                         AlwaysFalse => \"this comparison is always false\".to_owned(),\n                         AlwaysTrue => \"this comparison is always true\".to_owned(),\n-                        InequalityImpossible => {\n-                            format!(\n-                                \"the case where the two sides are not equal never occurs, consider using {} == {} \\\n-                                     instead\",\n-                                snippet(cx, lhs.span, \"lhs\"),\n-                                snippet(cx, rhs.span, \"rhs\")\n-                            )\n-                        },\n+                        InequalityImpossible => format!(\n+                            \"the case where the two sides are not equal never occurs, consider using {} == {} \\\n+                             instead\",\n+                            snippet(cx, lhs.span, \"lhs\"),\n+                            snippet(cx, rhs.span, \"rhs\")\n+                        ),\n                     };\n \n                     let help = format!(\n@@ -1264,9 +1237,8 @@ impl FullInt {\n \n impl PartialEq for FullInt {\n     fn eq(&self, other: &Self) -> bool {\n-        self.partial_cmp(other).expect(\n-            \"partial_cmp only returns Some(_)\",\n-        ) == Ordering::Equal\n+        self.partial_cmp(other)\n+            .expect(\"partial_cmp only returns Some(_)\") == Ordering::Equal\n     }\n }\n \n@@ -1282,9 +1254,8 @@ impl PartialOrd for FullInt {\n }\n impl Ord for FullInt {\n     fn cmp(&self, other: &Self) -> Ordering {\n-        self.partial_cmp(other).expect(\n-            \"partial_cmp for FullInt can never return None\",\n-        )\n+        self.partial_cmp(other)\n+            .expect(\"partial_cmp for FullInt can never return None\")\n     }\n }\n \n@@ -1301,44 +1272,40 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(\n             return None;\n         }\n         match pre_cast_ty.sty {\n-            ty::TyInt(int_ty) => {\n-                Some(match int_ty {\n-                    IntTy::I8 => (FullInt::S(i128::from(i8::min_value())), FullInt::S(i128::from(i8::max_value()))),\n-                    IntTy::I16 => (\n-                        FullInt::S(i128::from(i16::min_value())),\n-                        FullInt::S(i128::from(i16::max_value())),\n-                    ),\n-                    IntTy::I32 => (\n-                        FullInt::S(i128::from(i32::min_value())),\n-                        FullInt::S(i128::from(i32::max_value())),\n-                    ),\n-                    IntTy::I64 => (\n-                        FullInt::S(i128::from(i64::min_value())),\n-                        FullInt::S(i128::from(i64::max_value())),\n-                    ),\n-                    IntTy::I128 => (FullInt::S(i128::min_value() as i128), FullInt::S(i128::max_value() as i128)),\n-                    IntTy::Is => (FullInt::S(isize::min_value() as i128), FullInt::S(isize::max_value() as i128)),\n-                })\n-            },\n-            ty::TyUint(uint_ty) => {\n-                Some(match uint_ty {\n-                    UintTy::U8 => (FullInt::U(u128::from(u8::min_value())), FullInt::U(u128::from(u8::max_value()))),\n-                    UintTy::U16 => (\n-                        FullInt::U(u128::from(u16::min_value())),\n-                        FullInt::U(u128::from(u16::max_value())),\n-                    ),\n-                    UintTy::U32 => (\n-                        FullInt::U(u128::from(u32::min_value())),\n-                        FullInt::U(u128::from(u32::max_value())),\n-                    ),\n-                    UintTy::U64 => (\n-                        FullInt::U(u128::from(u64::min_value())),\n-                        FullInt::U(u128::from(u64::max_value())),\n-                    ),\n-                    UintTy::U128 => (FullInt::U(u128::min_value() as u128), FullInt::U(u128::max_value() as u128)),\n-                    UintTy::Us => (FullInt::U(usize::min_value() as u128), FullInt::U(usize::max_value() as u128)),\n-                })\n-            },\n+            ty::TyInt(int_ty) => Some(match int_ty {\n+                IntTy::I8 => (FullInt::S(i128::from(i8::min_value())), FullInt::S(i128::from(i8::max_value()))),\n+                IntTy::I16 => (\n+                    FullInt::S(i128::from(i16::min_value())),\n+                    FullInt::S(i128::from(i16::max_value())),\n+                ),\n+                IntTy::I32 => (\n+                    FullInt::S(i128::from(i32::min_value())),\n+                    FullInt::S(i128::from(i32::max_value())),\n+                ),\n+                IntTy::I64 => (\n+                    FullInt::S(i128::from(i64::min_value())),\n+                    FullInt::S(i128::from(i64::max_value())),\n+                ),\n+                IntTy::I128 => (FullInt::S(i128::min_value() as i128), FullInt::S(i128::max_value() as i128)),\n+                IntTy::Is => (FullInt::S(isize::min_value() as i128), FullInt::S(isize::max_value() as i128)),\n+            }),\n+            ty::TyUint(uint_ty) => Some(match uint_ty {\n+                UintTy::U8 => (FullInt::U(u128::from(u8::min_value())), FullInt::U(u128::from(u8::max_value()))),\n+                UintTy::U16 => (\n+                    FullInt::U(u128::from(u16::min_value())),\n+                    FullInt::U(u128::from(u16::max_value())),\n+                ),\n+                UintTy::U32 => (\n+                    FullInt::U(u128::from(u32::min_value())),\n+                    FullInt::U(u128::from(u32::max_value())),\n+                ),\n+                UintTy::U64 => (\n+                    FullInt::U(u128::from(u64::min_value())),\n+                    FullInt::U(u128::from(u64::max_value())),\n+                ),\n+                UintTy::U128 => (FullInt::U(u128::min_value() as u128), FullInt::U(u128::max_value() as u128)),\n+                UintTy::Us => (FullInt::U(usize::min_value() as u128), FullInt::U(usize::max_value() as u128)),\n+            }),\n             _ => None,\n         }\n     } else {\n@@ -1355,15 +1322,13 @@ fn node_as_const_fullint(cx: &LateContext, expr: &Expr) -> Option<FullInt> {\n     let parent_def_id = cx.tcx.hir.local_def_id(parent_item);\n     let substs = Substs::identity_for_item(cx.tcx, parent_def_id);\n     match ConstContext::new(cx.tcx, cx.param_env.and(substs), cx.tables).eval(expr) {\n-        Ok(val) => {\n-            if let Integral(const_int) = val {\n-                match const_int.int_type() {\n-                    IntType::SignedInt(_) => Some(FullInt::S(const_int.to_u128_unchecked() as i128)),\n-                    IntType::UnsignedInt(_) => Some(FullInt::U(const_int.to_u128_unchecked())),\n-                }\n-            } else {\n-                None\n+        Ok(val) => if let Integral(const_int) = val {\n+            match const_int.int_type() {\n+                IntType::SignedInt(_) => Some(FullInt::S(const_int.to_u128_unchecked() as i128)),\n+                IntType::UnsignedInt(_) => Some(FullInt::U(const_int.to_u128_unchecked())),\n             }\n+        } else {\n+            None\n         },\n         Err(_) => None,\n     }\n@@ -1402,42 +1367,32 @@ fn upcast_comparison_bounds_err(\n                     err_upcast_comparison(cx, span, lhs, rel == Rel::Ne);\n                 }\n             } else if match rel {\n-                       Rel::Lt => {\n-                           if invert {\n-                               norm_rhs_val < lb\n-                           } else {\n-                               ub < norm_rhs_val\n-                           }\n-                       },\n-                       Rel::Le => {\n-                           if invert {\n-                               norm_rhs_val <= lb\n-                           } else {\n-                               ub <= norm_rhs_val\n-                           }\n-                       },\n-                       Rel::Eq | Rel::Ne => unreachable!(),\n-                   }\n-            {\n+                Rel::Lt => if invert {\n+                    norm_rhs_val < lb\n+                } else {\n+                    ub < norm_rhs_val\n+                },\n+                Rel::Le => if invert {\n+                    norm_rhs_val <= lb\n+                } else {\n+                    ub <= norm_rhs_val\n+                },\n+                Rel::Eq | Rel::Ne => unreachable!(),\n+            } {\n                 err_upcast_comparison(cx, span, lhs, true)\n             } else if match rel {\n-                       Rel::Lt => {\n-                           if invert {\n-                               norm_rhs_val >= ub\n-                           } else {\n-                               lb >= norm_rhs_val\n-                           }\n-                       },\n-                       Rel::Le => {\n-                           if invert {\n-                               norm_rhs_val > ub\n-                           } else {\n-                               lb > norm_rhs_val\n-                           }\n-                       },\n-                       Rel::Eq | Rel::Ne => unreachable!(),\n-                   }\n-            {\n+                Rel::Lt => if invert {\n+                    norm_rhs_val >= ub\n+                } else {\n+                    lb >= norm_rhs_val\n+                },\n+                Rel::Le => if invert {\n+                    norm_rhs_val > ub\n+                } else {\n+                    lb > norm_rhs_val\n+                },\n+                Rel::Eq | Rel::Ne => unreachable!(),\n+            } {\n                 err_upcast_comparison(cx, span, lhs, false)\n             }\n         }\n@@ -1447,7 +1402,6 @@ fn upcast_comparison_bounds_err(\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidUpcastComparisons {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprBinary(ref cmp, ref lhs, ref rhs) = expr.node {\n-\n             let normalized = comparisons::normalize_comparison(cmp.node, lhs, rhs);\n             let (rel, normalized_lhs, normalized_rhs) = if let Some(val) = normalized {\n                 val"}, {"sha": "c045c870810b086bad98cc7a205bd88358127801", "filename": "clippy_lints/src/unicode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funicode.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -3,7 +3,7 @@ use rustc::hir::*;\n use syntax::ast::{LitKind, NodeId};\n use syntax::codemap::Span;\n use unicode_normalization::UnicodeNormalization;\n-use utils::{snippet, span_help_and_lint, is_allowed};\n+use utils::{is_allowed, snippet, span_help_and_lint};\n \n /// **What it does:** Checks for the Unicode zero-width space in the code.\n ///"}, {"sha": "1c9bf70429d9232e45db6bd8fc3d42c601e9ebe0", "filename": "clippy_lints/src/unsafe_removed_from_name.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -48,13 +48,11 @@ impl EarlyLintPass for UnsafeNameRemoval {\n                         &item.span,\n                     );\n                 },\n-                ViewPath_::ViewPathList(_, ref path_list_items) => {\n-                    for path_list_item in path_list_items.iter() {\n-                        let plid = path_list_item.node;\n-                        if let Some(rename) = plid.rename {\n-                            unsafe_to_safe_check(plid.name, rename, cx, &item.span);\n-                        };\n-                    }\n+                ViewPath_::ViewPathList(_, ref path_list_items) => for path_list_item in path_list_items.iter() {\n+                    let plid = path_list_item.node;\n+                    if let Some(rename) = plid.rename {\n+                        unsafe_to_safe_check(plid.name, rename, cx, &item.span);\n+                    };\n                 },\n                 ViewPath_::ViewPathGlob(_) => {},\n             }"}, {"sha": "1af63c56107dc04c9c07b4ebe49c5d7d1fca6ef4", "filename": "clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_io_amount.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -1,6 +1,6 @@\n use rustc::lint::*;\n use rustc::hir;\n-use utils::{span_lint, match_qpath, match_trait_method, is_try, paths};\n+use utils::{is_try, match_qpath, match_trait_method, paths, span_lint};\n \n /// **What it does:** Checks for unused written/read amount.\n ///\n@@ -40,8 +40,7 @@ impl LintPass for UnusedIoAmount {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedIoAmount {\n     fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n         let expr = match s.node {\n-            hir::StmtSemi(ref expr, _) |\n-            hir::StmtExpr(ref expr, _) => &**expr,\n+            hir::StmtSemi(ref expr, _) | hir::StmtExpr(ref expr, _) => &**expr,\n             _ => return,\n         };\n \n@@ -58,13 +57,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedIoAmount {\n                 }\n             },\n \n-            hir::ExprMethodCall(ref path, _, ref args) => {\n-                match &*path.name.as_str() {\n-                    \"expect\" | \"unwrap\" | \"unwrap_or\" | \"unwrap_or_else\" => {\n-                        check_method_call(cx, &args[0], expr);\n-                    },\n-                    _ => (),\n-                }\n+            hir::ExprMethodCall(ref path, _, ref args) => match &*path.name.as_str() {\n+                \"expect\" | \"unwrap\" | \"unwrap_or\" | \"unwrap_or_else\" => {\n+                    check_method_call(cx, &args[0], expr);\n+                },\n+                _ => (),\n             },\n \n             _ => (),"}, {"sha": "6f91b873a480cf4487a14cb7d8ee7ed96f004f5f", "filename": "clippy_lints/src/unused_label.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Funused_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Funused_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_label.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -1,6 +1,6 @@\n use rustc::lint::*;\n use rustc::hir;\n-use rustc::hir::intravisit::{FnKind, Visitor, walk_expr, walk_fn, NestedVisitorMap};\n+use rustc::hir::intravisit::{walk_expr, walk_fn, FnKind, NestedVisitorMap, Visitor};\n use std::collections::HashMap;\n use syntax::ast;\n use syntax::codemap::Span;\n@@ -69,14 +69,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedLabel {\n impl<'a, 'tcx: 'a> Visitor<'tcx> for UnusedLabelVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n-            hir::ExprBreak(destination, _) |\n-            hir::ExprAgain(destination) => {\n-                if let Some(label) = destination.ident {\n-                    self.labels.remove(&label.node.name.as_str());\n-                }\n+            hir::ExprBreak(destination, _) | hir::ExprAgain(destination) => if let Some(label) = destination.ident {\n+                self.labels.remove(&label.node.name.as_str());\n             },\n-            hir::ExprLoop(_, Some(label), _) |\n-            hir::ExprWhile(_, _, Some(label)) => {\n+            hir::ExprLoop(_, Some(label), _) | hir::ExprWhile(_, _, Some(label)) => {\n                 self.labels.insert(label.node.as_str(), expr.span);\n             },\n             _ => (),"}, {"sha": "bb5f6075d0da976f6d2bd2d4fa38a785785210cc", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -1,7 +1,7 @@\n-use rustc::lint::{LintArray, LateLintPass, LateContext, LintPass};\n+use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::hir::*;\n-use rustc::hir::intravisit::{Visitor, walk_path, NestedVisitorMap};\n-use utils::{span_lint_and_then, in_macro};\n+use rustc::hir::intravisit::{walk_path, NestedVisitorMap, Visitor};\n+use utils::{in_macro, span_lint_and_then};\n use syntax::ast::NodeId;\n use syntax_pos::symbol::keywords::SelfType;\n "}, {"sha": "fafb6d12d1fd40c85a809a5960f0fbe018a8ff45", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 29, "deletions": 37, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -5,9 +5,9 @@\n \n use rustc::lint::*;\n use rustc::hir;\n-use rustc::hir::{Expr, QPath, Expr_};\n-use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n-use syntax::ast::{self, Attribute, NodeId, LitKind, DUMMY_NODE_ID};\n+use rustc::hir::{Expr, Expr_, QPath};\n+use rustc::hir::intravisit::{NestedVisitorMap, Visitor};\n+use syntax::ast::{self, Attribute, LitKind, NodeId, DUMMY_NODE_ID};\n use syntax::codemap::Span;\n use std::collections::HashMap;\n \n@@ -386,15 +386,13 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 println!(\"Again(ref {}) = {},\", destination_pat, current);\n                 // FIXME: implement label printing\n             },\n-            Expr_::ExprRet(ref opt_value) => {\n-                if let Some(ref value) = *opt_value {\n-                    let value_pat = self.next(\"value\");\n-                    println!(\"Ret(Some(ref {})) = {},\", value_pat, current);\n-                    self.current = value_pat;\n-                    self.visit_expr(value);\n-                } else {\n-                    println!(\"Ret(None) = {},\", current);\n-                }\n+            Expr_::ExprRet(ref opt_value) => if let Some(ref value) = *opt_value {\n+                let value_pat = self.next(\"value\");\n+                println!(\"Ret(Some(ref {})) = {},\", value_pat, current);\n+                self.current = value_pat;\n+                self.visit_expr(value);\n+            } else {\n+                println!(\"Ret(None) = {},\", current);\n             },\n             Expr_::ExprInlineAsm(_, ref _input, ref _output) => {\n                 println!(\"InlineAsm(_, ref input, ref output) = {},\", current);\n@@ -445,42 +443,36 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n \n fn has_attr(attrs: &[Attribute]) -> bool {\n     attrs.iter().any(|attr| {\n-        attr.check_name(\"clippy\") &&\n-            attr.meta_item_list().map_or(false, |list| {\n-                list.len() == 1 &&\n-                    match list[0].node {\n-                        ast::NestedMetaItemKind::MetaItem(ref it) => it.name == \"author\",\n-                        ast::NestedMetaItemKind::Literal(_) => false,\n-                    }\n-            })\n+        attr.check_name(\"clippy\") && attr.meta_item_list().map_or(false, |list| {\n+            list.len() == 1 && match list[0].node {\n+                ast::NestedMetaItemKind::MetaItem(ref it) => it.name == \"author\",\n+                ast::NestedMetaItemKind::Literal(_) => false,\n+            }\n+        })\n     })\n }\n \n fn print_path(path: &QPath, first: &mut bool) {\n     match *path {\n-        QPath::Resolved(_, ref path) => {\n-            for segment in &path.segments {\n+        QPath::Resolved(_, ref path) => for segment in &path.segments {\n+            if *first {\n+                *first = false;\n+            } else {\n+                print!(\", \");\n+            }\n+            print!(\"{:?}\", segment.name.as_str());\n+        },\n+        QPath::TypeRelative(ref ty, ref segment) => match ty.node {\n+            hir::Ty_::TyPath(ref inner_path) => {\n+                print_path(inner_path, first);\n                 if *first {\n                     *first = false;\n                 } else {\n                     print!(\", \");\n                 }\n                 print!(\"{:?}\", segment.name.as_str());\n-            }\n-        },\n-        QPath::TypeRelative(ref ty, ref segment) => {\n-            match ty.node {\n-                hir::Ty_::TyPath(ref inner_path) => {\n-                    print_path(inner_path, first);\n-                    if *first {\n-                        *first = false;\n-                    } else {\n-                        print!(\", \");\n-                    }\n-                    print!(\"{:?}\", segment.name.as_str());\n-                },\n-                ref other => print!(\"/* unimplemented: {:?}*/\", other),\n-            }\n+            },\n+            ref other => print!(\"/* unimplemented: {:?}*/\", other),\n         },\n     }\n }"}, {"sha": "7251538c09aa0c7bb1bb82a5d477e1f534e84aa8", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -15,14 +15,13 @@ pub fn file_from_args(\n     for arg in args.iter().filter_map(|a| a.meta_item()) {\n         if arg.name() == \"conf_file\" {\n             return match arg.node {\n-                ast::MetaItemKind::Word |\n-                ast::MetaItemKind::List(_) => Err((\"`conf_file` must be a named value\", arg.span)),\n-                ast::MetaItemKind::NameValue(ref value) => {\n-                    if let ast::LitKind::Str(ref file, _) = value.node {\n-                        Ok(Some(file.to_string().into()))\n-                    } else {\n-                        Err((\"`conf_file` value must be a string\", value.span))\n-                    }\n+                ast::MetaItemKind::Word | ast::MetaItemKind::List(_) => {\n+                    Err((\"`conf_file` must be a named value\", arg.span))\n+                },\n+                ast::MetaItemKind::NameValue(ref value) => if let ast::LitKind::Str(ref file, _) = value.node {\n+                    Ok(Some(file.to_string().into()))\n+                } else {\n+                    Err((\"`conf_file` value must be a string\", value.span))\n                 },\n             };\n         }\n@@ -45,7 +44,7 @@ pub enum Error {\n         /// The expected type.\n         &'static str,\n         /// The type we got instead.\n-        &'static str\n+        &'static str,\n     ),\n     /// There is an unknown key is the file.\n     UnknownKey(String),\n@@ -191,10 +190,8 @@ pub fn lookup_conf_file() -> io::Result<Option<path::PathBuf>> {\n                 Ok(ref md) if md.is_file() => return Ok(Some(config_file)),\n                 // Return the error if it's something other than `NotFound`; otherwise we didn't\n                 // find the project file yet, and continue searching.\n-                Err(e) => {\n-                    if e.kind() != io::ErrorKind::NotFound {\n-                        return Err(e);\n-                    }\n+                Err(e) => if e.kind() != io::ErrorKind::NotFound {\n+                    return Err(e);\n                 },\n                 _ => (),\n             }"}, {"sha": "09e40aea80de2f73bb8e9bcee967c160f4720dea", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 35, "deletions": 37, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -6,7 +6,7 @@\n use rustc::hir;\n use rustc::lint::LateContext;\n use syntax::ast;\n-use utils::{is_expn_of, match_qpath, match_def_path, resolve_node, paths};\n+use utils::{is_expn_of, match_def_path, match_qpath, paths, resolve_node};\n \n /// Convert a hir binary operator to the corresponding `ast` type.\n pub fn binop(op: hir::BinOp_) -> ast::BinOpKind {\n@@ -73,42 +73,40 @@ pub fn range(expr: &hir::Expr) -> Option<Range> {\n                 None\n             }\n         },\n-        hir::ExprStruct(ref path, ref fields, None) => {\n-            if match_qpath(path, &paths::RANGE_FROM_STD) || match_qpath(path, &paths::RANGE_FROM) {\n-                Some(Range {\n-                    start: get_field(\"start\", fields),\n-                    end: None,\n-                    limits: ast::RangeLimits::HalfOpen,\n-                })\n-            } else if match_qpath(path, &paths::RANGE_INCLUSIVE_STD) || match_qpath(path, &paths::RANGE_INCLUSIVE) {\n-                Some(Range {\n-                    start: get_field(\"start\", fields),\n-                    end: get_field(\"end\", fields),\n-                    limits: ast::RangeLimits::Closed,\n-                })\n-            } else if match_qpath(path, &paths::RANGE_STD) || match_qpath(path, &paths::RANGE) {\n-                Some(Range {\n-                    start: get_field(\"start\", fields),\n-                    end: get_field(\"end\", fields),\n-                    limits: ast::RangeLimits::HalfOpen,\n-                })\n-            } else if match_qpath(path, &paths::RANGE_TO_INCLUSIVE_STD) ||\n-                       match_qpath(path, &paths::RANGE_TO_INCLUSIVE)\n-            {\n-                Some(Range {\n-                    start: None,\n-                    end: get_field(\"end\", fields),\n-                    limits: ast::RangeLimits::Closed,\n-                })\n-            } else if match_qpath(path, &paths::RANGE_TO_STD) || match_qpath(path, &paths::RANGE_TO) {\n-                Some(Range {\n-                    start: None,\n-                    end: get_field(\"end\", fields),\n-                    limits: ast::RangeLimits::HalfOpen,\n-                })\n-            } else {\n-                None\n-            }\n+        hir::ExprStruct(ref path, ref fields, None) => if match_qpath(path, &paths::RANGE_FROM_STD) ||\n+            match_qpath(path, &paths::RANGE_FROM)\n+        {\n+            Some(Range {\n+                start: get_field(\"start\", fields),\n+                end: None,\n+                limits: ast::RangeLimits::HalfOpen,\n+            })\n+        } else if match_qpath(path, &paths::RANGE_INCLUSIVE_STD) || match_qpath(path, &paths::RANGE_INCLUSIVE) {\n+            Some(Range {\n+                start: get_field(\"start\", fields),\n+                end: get_field(\"end\", fields),\n+                limits: ast::RangeLimits::Closed,\n+            })\n+        } else if match_qpath(path, &paths::RANGE_STD) || match_qpath(path, &paths::RANGE) {\n+            Some(Range {\n+                start: get_field(\"start\", fields),\n+                end: get_field(\"end\", fields),\n+                limits: ast::RangeLimits::HalfOpen,\n+            })\n+        } else if match_qpath(path, &paths::RANGE_TO_INCLUSIVE_STD) || match_qpath(path, &paths::RANGE_TO_INCLUSIVE) {\n+            Some(Range {\n+                start: None,\n+                end: get_field(\"end\", fields),\n+                limits: ast::RangeLimits::Closed,\n+            })\n+        } else if match_qpath(path, &paths::RANGE_TO_STD) || match_qpath(path, &paths::RANGE_TO) {\n+            Some(Range {\n+                start: None,\n+                end: get_field(\"end\", fields),\n+                limits: ast::RangeLimits::HalfOpen,\n+            })\n+        } else {\n+            None\n         },\n         _ => None,\n     }"}, {"sha": "2d3d5874d8212e0a1d3c2a98f82875db1ea22212", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -46,8 +46,9 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n                     false\n                 }\n             },\n-            (&StmtExpr(ref l, _), &StmtExpr(ref r, _)) |\n-            (&StmtSemi(ref l, _), &StmtSemi(ref r, _)) => self.eq_expr(l, r),\n+            (&StmtExpr(ref l, _), &StmtExpr(ref r, _)) | (&StmtSemi(ref l, _), &StmtSemi(ref r, _)) => {\n+                self.eq_expr(l, r)\n+            },\n             _ => false,\n         }\n     }\n@@ -107,11 +108,10 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n                 lls == rls && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.node.as_str() == r.node.as_str())\n             },\n             (&ExprMatch(ref le, ref la, ref ls), &ExprMatch(ref re, ref ra, ref rs)) => {\n-                ls == rs && self.eq_expr(le, re) &&\n-                    over(la, ra, |l, r| {\n-                        self.eq_expr(&l.body, &r.body) && both(&l.guard, &r.guard, |l, r| self.eq_expr(l, r)) &&\n-                            over(&l.pats, &r.pats, |l, r| self.eq_pat(l, r))\n-                    })\n+                ls == rs && self.eq_expr(le, re) && over(la, ra, |l, r| {\n+                    self.eq_expr(&l.body, &r.body) && both(&l.guard, &r.guard, |l, r| self.eq_expr(l, r)) &&\n+                        over(&l.pats, &r.pats, |l, r| self.eq_pat(l, r))\n+                })\n             },\n             (&ExprMethodCall(ref l_path, _, ref l_args), &ExprMethodCall(ref r_path, _, ref r_args)) => {\n                 !self.ignore_fn && l_path == r_path && self.eq_exprs(l_args, r_args)\n@@ -257,9 +257,8 @@ fn both<X, F>(l: &Option<X>, r: &Option<X>, mut eq_fn: F) -> bool\n where\n     F: FnMut(&X, &X) -> bool,\n {\n-    l.as_ref().map_or_else(|| r.is_none(), |x| {\n-        r.as_ref().map_or(false, |y| eq_fn(x, y))\n-    })\n+    l.as_ref()\n+        .map_or_else(|| r.is_none(), |x| r.as_ref().map_or(false, |y| eq_fn(x, y)))\n }\n \n /// Check if two slices are equal as per `eq_fn`."}, {"sha": "cdc8ce509b45171abea809a93c5163a882161a0f", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -54,12 +54,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         match item.vis {\n             hir::Visibility::Public => println!(\"public\"),\n             hir::Visibility::Crate => println!(\"visible crate wide\"),\n-            hir::Visibility::Restricted { ref path, .. } => {\n-                println!(\n-                    \"visible in module `{}`\",\n-                    print::to_string(print::NO_ANN, |s| s.print_path(path, false))\n-                )\n-            },\n+            hir::Visibility::Restricted { ref path, .. } => println!(\n+                \"visible in module `{}`\",\n+                print::to_string(print::NO_ANN, |s| s.print_path(path, false))\n+            ),\n             hir::Visibility::Inherited => println!(\"visibility inherited from outer item\"),\n         }\n         if item.defaultness.is_default() {\n@@ -125,8 +123,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         }\n         match stmt.node {\n             hir::StmtDecl(ref decl, _) => print_decl(cx, decl),\n-            hir::StmtExpr(ref e, _) |\n-            hir::StmtSemi(ref e, _) => print_expr(cx, e, 0),\n+            hir::StmtExpr(ref e, _) | hir::StmtSemi(ref e, _) => print_expr(cx, e, 0),\n         }\n     }\n     // fn check_foreign_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx\n@@ -355,12 +352,10 @@ fn print_item(cx: &LateContext, item: &hir::Item) {\n     match item.vis {\n         hir::Visibility::Public => println!(\"public\"),\n         hir::Visibility::Crate => println!(\"visible crate wide\"),\n-        hir::Visibility::Restricted { ref path, .. } => {\n-            println!(\n-                \"visible in module `{}`\",\n-                print::to_string(print::NO_ANN, |s| s.print_path(path, false))\n-            )\n-        },\n+        hir::Visibility::Restricted { ref path, .. } => println!(\n+            \"visible in module `{}`\",\n+            print::to_string(print::NO_ANN, |s| s.print_path(path, false))\n+        ),\n         hir::Visibility::Inherited => println!(\"visibility inherited from outer item\"),\n     }\n     match item.node {"}, {"sha": "a35b034d791b50cb6a08f72426173f8013f724af", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -1,11 +1,11 @@\n use rustc::lint::*;\n use rustc::hir::*;\n-use rustc::hir::intravisit::{Visitor, walk_expr, NestedVisitorMap};\n-use utils::{paths, match_qpath, span_lint};\n+use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n+use utils::{match_qpath, paths, span_lint};\n use syntax::symbol::InternedString;\n-use syntax::ast::{Name, NodeId, ItemKind, Crate as AstCrate};\n+use syntax::ast::{Crate as AstCrate, ItemKind, Name, NodeId};\n use syntax::codemap::Span;\n-use std::collections::{HashSet, HashMap};\n+use std::collections::{HashMap, HashSet};\n \n \n /// **What it does:** Checks for various things we like to keep tidy in clippy.\n@@ -63,14 +63,17 @@ impl LintPass for Clippy {\n \n impl EarlyLintPass for Clippy {\n     fn check_crate(&mut self, cx: &EarlyContext, krate: &AstCrate) {\n-        if let Some(utils) = krate.module.items.iter().find(\n-            |item| item.ident.name == \"utils\",\n-        )\n+        if let Some(utils) = krate\n+            .module\n+            .items\n+            .iter()\n+            .find(|item| item.ident.name == \"utils\")\n         {\n             if let ItemKind::Mod(ref utils_mod) = utils.node {\n-                if let Some(paths) = utils_mod.items.iter().find(\n-                    |item| item.ident.name == \"paths\",\n-                )\n+                if let Some(paths) = utils_mod\n+                    .items\n+                    .iter()\n+                    .find(|item| item.ident.name == \"paths\")\n                 {\n                     if let ItemKind::Mod(ref paths_mod) = paths.node {\n                         let mut last_name: Option<InternedString> = None;\n@@ -83,7 +86,7 @@ impl EarlyLintPass for Clippy {\n                                         CLIPPY_LINTS_INTERNAL,\n                                         item.span,\n                                         \"this constant should be before the previous constant due to lexical \\\n-                                               ordering\",\n+                                         ordering\",\n                                     );\n                                 }\n                             }\n@@ -157,11 +160,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LintWithoutLintPass {\n \n \n fn is_lint_ref_type(ty: &Ty) -> bool {\n-    if let TyRptr(ref lt,\n-                  MutTy {\n-                      ty: ref inner,\n-                      mutbl: MutImmutable,\n-                  }) = ty.node\n+    if let TyRptr(\n+        ref lt,\n+        MutTy {\n+            ty: ref inner,\n+            mutbl: MutImmutable,\n+        },\n+    ) = ty.node\n     {\n         if lt.is_elided() {\n             return false;"}, {"sha": "29fddeaa052fa9dc907526820feb97a65f322c9b", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 95, "deletions": 106, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -5,10 +5,10 @@ use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc::hir::def::Def;\n use rustc::hir::intravisit::{NestedVisitorMap, Visitor};\n use rustc::hir::map::Node;\n-use rustc::lint::{LintContext, Level, LateContext, Lint};\n+use rustc::lint::{LateContext, Level, Lint, LintContext};\n use rustc::session::Session;\n use rustc::traits;\n-use rustc::ty::{self, TyCtxt, Ty};\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc::mir::transform::MirSource;\n use rustc_errors;\n use std::borrow::Cow;\n@@ -104,18 +104,16 @@ pub fn differing_macro_contexts(lhs: Span, rhs: Span) -> bool {\n pub fn in_constant(cx: &LateContext, id: NodeId) -> bool {\n     let parent_id = cx.tcx.hir.get_parent(id);\n     match MirSource::from_node(cx.tcx, parent_id) {\n-        MirSource::GeneratorDrop(_) |\n-        MirSource::Fn(_) => false,\n-        MirSource::Const(_) |\n-        MirSource::Static(..) |\n-        MirSource::Promoted(..) => true,\n+        MirSource::GeneratorDrop(_) | MirSource::Fn(_) => false,\n+        MirSource::Const(_) | MirSource::Static(..) | MirSource::Promoted(..) => true,\n     }\n }\n \n /// Returns true if this `expn_info` was expanded by any macro.\n pub fn in_macro(span: Span) -> bool {\n     span.ctxt().outer().expn_info().map_or(false, |info| {\n-        match info.callee.format {// don't treat range expressions desugared to structs as \"in_macro\"\n+        match info.callee.format {\n+            // don't treat range expressions desugared to structs as \"in_macro\"\n             ExpnFormat::CompilerDesugaring(kind) => kind != CompilerDesugaringKind::DotFill,\n             _ => true,\n         }\n@@ -138,18 +136,18 @@ pub fn in_external_macro<'a, T: LintContext<'a>>(cx: &T, span: Span) -> bool {\n         // no span for the callee = external macro\n         info.callee.span.map_or(true, |span| {\n             // no snippet = external macro or compiler-builtin expansion\n-            cx.sess().codemap().span_to_snippet(span).ok().map_or(\n-                true,\n-                |code| {\n-                    !code.starts_with(\"macro_rules\")\n-                },\n-            )\n+            cx.sess()\n+                .codemap()\n+                .span_to_snippet(span)\n+                .ok()\n+                .map_or(true, |code| !code.starts_with(\"macro_rules\"))\n         })\n     }\n \n-    span.ctxt().outer().expn_info().map_or(false, |info| {\n-        in_macro_ext(cx, &info)\n-    })\n+    span.ctxt()\n+        .outer()\n+        .expn_info()\n+        .map_or(false, |info| in_macro_ext(cx, &info))\n }\n \n /// Check if a `DefId`'s path matches the given absolute type path usage.\n@@ -183,9 +181,10 @@ pub fn match_def_path(tcx: TyCtxt, def_id: DefId, path: &[&str]) -> bool {\n     tcx.push_item_path(&mut apb, def_id);\n \n     apb.names.len() == path.len() &&\n-        apb.names.into_iter().zip(path.iter()).all(\n-            |(a, &b)| *a == *b,\n-        )\n+        apb.names\n+            .into_iter()\n+            .zip(path.iter())\n+            .all(|(a, &b)| *a == *b)\n }\n \n /// Check if type is struct, enum or union type with given def path.\n@@ -220,11 +219,9 @@ pub fn match_trait_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool\n \n pub fn last_path_segment(path: &QPath) -> &PathSegment {\n     match *path {\n-        QPath::Resolved(_, ref path) => {\n-            path.segments.last().expect(\n-                \"A path must have at least one segment\",\n-            )\n-        },\n+        QPath::Resolved(_, ref path) => path.segments\n+            .last()\n+            .expect(\"A path must have at least one segment\"),\n         QPath::TypeRelative(_, ref seg) => seg,\n     }\n }\n@@ -246,22 +243,22 @@ pub fn single_segment_path(path: &QPath) -> Option<&PathSegment> {\n pub fn match_qpath(path: &QPath, segments: &[&str]) -> bool {\n     match *path {\n         QPath::Resolved(_, ref path) => match_path(path, segments),\n-        QPath::TypeRelative(ref ty, ref segment) => {\n-            match ty.node {\n-                TyPath(ref inner_path) => {\n-                    !segments.is_empty() && match_qpath(inner_path, &segments[..(segments.len() - 1)]) &&\n-                        segment.name == segments[segments.len() - 1]\n-                },\n-                _ => false,\n-            }\n+        QPath::TypeRelative(ref ty, ref segment) => match ty.node {\n+            TyPath(ref inner_path) => {\n+                !segments.is_empty() && match_qpath(inner_path, &segments[..(segments.len() - 1)]) &&\n+                    segment.name == segments[segments.len() - 1]\n+            },\n+            _ => false,\n         },\n     }\n }\n \n pub fn match_path(path: &Path, segments: &[&str]) -> bool {\n-    path.segments.iter().rev().zip(segments.iter().rev()).all(\n-        |(a, b)| a.name == *b,\n-    )\n+    path.segments\n+        .iter()\n+        .rev()\n+        .zip(segments.iter().rev())\n+        .all(|(a, b)| a.name == *b)\n }\n \n /// Match a `Path` against a slice of segment string literals, e.g.\n@@ -271,19 +268,21 @@ pub fn match_path(path: &Path, segments: &[&str]) -> bool {\n /// match_qpath(path, &[\"std\", \"rt\", \"begin_unwind\"])\n /// ```\n pub fn match_path_ast(path: &ast::Path, segments: &[&str]) -> bool {\n-    path.segments.iter().rev().zip(segments.iter().rev()).all(\n-        |(a, b)| a.identifier.name == *b,\n-    )\n+    path.segments\n+        .iter()\n+        .rev()\n+        .zip(segments.iter().rev())\n+        .all(|(a, b)| a.identifier.name == *b)\n }\n \n /// Get the definition associated to a path.\n pub fn path_to_def(cx: &LateContext, path: &[&str]) -> Option<def::Def> {\n     let cstore = &cx.tcx.sess.cstore;\n \n     let crates = cstore.crates();\n-    let krate = crates.iter().find(\n-        |&&krate| cstore.crate_name(krate) == path[0],\n-    );\n+    let krate = crates\n+        .iter()\n+        .find(|&&krate| cstore.crate_name(krate) == path[0]);\n     if let Some(krate) = krate {\n         let krate = DefId {\n             krate: *krate,\n@@ -336,14 +335,9 @@ pub fn implements_trait<'a, 'tcx>(\n     ty_params: &[Ty<'tcx>],\n ) -> bool {\n     let ty = cx.tcx.erase_regions(&ty);\n-    let obligation = cx.tcx.predicate_for_trait_def(\n-        cx.param_env,\n-        traits::ObligationCause::dummy(),\n-        trait_id,\n-        0,\n-        ty,\n-        ty_params,\n-    );\n+    let obligation =\n+        cx.tcx\n+            .predicate_for_trait_def(cx.param_env, traits::ObligationCause::dummy(), trait_id, 0, ty, ty_params);\n     cx.tcx.infer_ctxt().enter(|infcx| {\n         traits::SelectionContext::new(&infcx).evaluate_obligation_conservatively(&obligation)\n     })\n@@ -522,30 +516,27 @@ pub fn get_parent_expr<'c>(cx: &'c LateContext, e: &Expr) -> Option<&'c Expr> {\n     if node_id == parent_id {\n         return None;\n     }\n-    map.find(parent_id).and_then(\n-        |node| if let Node::NodeExpr(parent) =\n-            node\n-        {\n+    map.find(parent_id)\n+        .and_then(|node| if let Node::NodeExpr(parent) = node {\n             Some(parent)\n         } else {\n             None\n-        },\n-    )\n+        })\n }\n \n pub fn get_enclosing_block<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, node: NodeId) -> Option<&'tcx Block> {\n     let map = &cx.tcx.hir;\n-    let enclosing_node = map.get_enclosing_scope(node).and_then(|enclosing_id| {\n-        map.find(enclosing_id)\n-    });\n+    let enclosing_node = map.get_enclosing_scope(node)\n+        .and_then(|enclosing_id| map.find(enclosing_id));\n     if let Some(node) = enclosing_node {\n         match node {\n             Node::NodeBlock(block) => Some(block),\n-            Node::NodeItem(&Item { node: ItemFn(_, _, _, _, _, eid), .. }) => {\n-                match cx.tcx.hir.body(eid).value.node {\n-                    ExprBlock(ref block) => Some(block),\n-                    _ => None,\n-                }\n+            Node::NodeItem(&Item {\n+                node: ItemFn(_, _, _, _, _, eid),\n+                ..\n+            }) => match cx.tcx.hir.body(eid).value.node {\n+                ExprBlock(ref block) => Some(block),\n+                _ => None,\n             },\n             _ => None,\n         }\n@@ -704,9 +695,9 @@ impl LimitStack {\n         Self { stack: vec![limit] }\n     }\n     pub fn limit(&self) -> u64 {\n-        *self.stack.last().expect(\n-            \"there should always be a value in the stack\",\n-        )\n+        *self.stack\n+            .last()\n+            .expect(\"there should always be a value in the stack\")\n     }\n     pub fn push_attrs(&mut self, sess: &Session, attrs: &[ast::Attribute], name: &'static str) {\n         let stack = &mut self.stack;\n@@ -741,9 +732,10 @@ fn parse_attrs<F: FnMut(u64)>(sess: &Session, attrs: &[ast::Attribute], name: &'\n /// See also `is_direct_expn_of`.\n pub fn is_expn_of(mut span: Span, name: &str) -> Option<Span> {\n     loop {\n-        let span_name_span = span.ctxt().outer().expn_info().map(|ei| {\n-            (ei.callee.name(), ei.call_site)\n-        });\n+        let span_name_span = span.ctxt()\n+            .outer()\n+            .expn_info()\n+            .map(|ei| (ei.callee.name(), ei.call_site));\n \n         match span_name_span {\n             Some((mac_name, new_span)) if mac_name == name => return Some(new_span),\n@@ -763,9 +755,10 @@ pub fn is_expn_of(mut span: Span, name: &str) -> Option<Span> {\n /// `bar!` by\n /// `is_direct_expn_of`.\n pub fn is_direct_expn_of(span: Span, name: &str) -> Option<Span> {\n-    let span_name_span = span.ctxt().outer().expn_info().map(|ei| {\n-        (ei.callee.name(), ei.call_site)\n-    });\n+    let span_name_span = span.ctxt()\n+        .outer()\n+        .expn_info()\n+        .map(|ei| (ei.callee.name(), ei.call_site));\n \n     match span_name_span {\n         Some((mac_name, new_span)) if mac_name == name => Some(new_span),\n@@ -800,7 +793,11 @@ pub fn camel_case_until(s: &str) -> usize {\n             return i;\n         }\n     }\n-    if up { last_i } else { s.len() }\n+    if up {\n+        last_i\n+    } else {\n+        s.len()\n+    }\n }\n \n /// Return index of the last camel-case component of `s`.\n@@ -844,9 +841,9 @@ pub fn return_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, fn_item: NodeId) -> Ty<'t\n // <'b> Foo<'b>` but\n // not for type parameters.\n pub fn same_tys<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n-    cx.tcx.infer_ctxt().enter(|infcx| {\n-        infcx.can_eq(cx.param_env, a, b).is_ok()\n-    })\n+    cx.tcx\n+        .infer_ctxt()\n+        .enter(|infcx| infcx.can_eq(cx.param_env, a, b).is_ok())\n }\n \n /// Return whether the given type is an `unsafe` function.\n@@ -875,36 +872,28 @@ pub fn is_refutable(cx: &LateContext, pat: &Pat) -> bool {\n     }\n \n     match pat.node {\n-        PatKind::Binding(..) |\n-        PatKind::Wild => false,\n-        PatKind::Box(ref pat) |\n-        PatKind::Ref(ref pat, _) => is_refutable(cx, pat),\n-        PatKind::Lit(..) |\n-        PatKind::Range(..) => true,\n+        PatKind::Binding(..) | PatKind::Wild => false,\n+        PatKind::Box(ref pat) | PatKind::Ref(ref pat, _) => is_refutable(cx, pat),\n+        PatKind::Lit(..) | PatKind::Range(..) => true,\n         PatKind::Path(ref qpath) => is_enum_variant(cx, qpath, pat.hir_id),\n         PatKind::Tuple(ref pats, _) => are_refutable(cx, pats.iter().map(|pat| &**pat)),\n-        PatKind::Struct(ref qpath, ref fields, _) => {\n-            if is_enum_variant(cx, qpath, pat.hir_id) {\n-                true\n-            } else {\n-                are_refutable(cx, fields.iter().map(|field| &*field.node.pat))\n-            }\n-        },\n-        PatKind::TupleStruct(ref qpath, ref pats, _) => {\n-            if is_enum_variant(cx, qpath, pat.hir_id) {\n-                true\n-            } else {\n-                are_refutable(cx, pats.iter().map(|pat| &**pat))\n-            }\n+        PatKind::Struct(ref qpath, ref fields, _) => if is_enum_variant(cx, qpath, pat.hir_id) {\n+            true\n+        } else {\n+            are_refutable(cx, fields.iter().map(|field| &*field.node.pat))\n         },\n-        PatKind::Slice(ref head, ref middle, ref tail) => {\n-            are_refutable(\n-                cx,\n-                head.iter().chain(middle).chain(tail.iter()).map(\n-                    |pat| &**pat,\n-                ),\n-            )\n+        PatKind::TupleStruct(ref qpath, ref pats, _) => if is_enum_variant(cx, qpath, pat.hir_id) {\n+            true\n+        } else {\n+            are_refutable(cx, pats.iter().map(|pat| &**pat))\n         },\n+        PatKind::Slice(ref head, ref middle, ref tail) => are_refutable(\n+            cx,\n+            head.iter()\n+                .chain(middle)\n+                .chain(tail.iter())\n+                .map(|pat| &**pat),\n+        ),\n     }\n }\n \n@@ -1029,9 +1018,9 @@ pub fn is_try(expr: &Expr) -> Option<&Expr> {\n }\n \n pub fn type_size<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> Option<u64> {\n-    ty.layout(cx.tcx, cx.param_env).ok().map(|layout| {\n-        layout.size(cx.tcx).bytes()\n-    })\n+    ty.layout(cx.tcx, cx.param_env)\n+        .ok()\n+        .map(|layout| layout.size(cx.tcx).bytes())\n }\n \n /// Returns true if the lint is allowed in the current context"}, {"sha": "ec0a351b8b09f16d5a6a7dc5497f47c32095dc9c", "filename": "clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -33,9 +33,7 @@ pub const ONE: Sugg<'static> = Sugg::NonParen(Cow::Borrowed(\"1\"));\n impl<'a> Display for Sugg<'a> {\n     fn fmt(&self, f: &mut std::fmt::Formatter) -> Result<(), std::fmt::Error> {\n         match *self {\n-            Sugg::NonParen(ref s) |\n-            Sugg::MaybeParen(ref s) |\n-            Sugg::BinOp(_, ref s) => s.fmt(f),\n+            Sugg::NonParen(ref s) | Sugg::MaybeParen(ref s) | Sugg::BinOp(_, ref s) => s.fmt(f),\n         }\n     }\n }\n@@ -178,12 +176,10 @@ impl<'a> Sugg<'a> {\n         match self {\n             Sugg::NonParen(..) => self,\n             // (x) and (x).y() both don't need additional parens\n-            Sugg::MaybeParen(sugg) => {\n-                if sugg.starts_with('(') && sugg.ends_with(')') {\n-                    Sugg::MaybeParen(sugg)\n-                } else {\n-                    Sugg::NonParen(format!(\"({})\", sugg).into())\n-                }\n+            Sugg::MaybeParen(sugg) => if sugg.starts_with('(') && sugg.ends_with(')') {\n+                Sugg::MaybeParen(sugg)\n+            } else {\n+                Sugg::NonParen(format!(\"({})\", sugg).into())\n             },\n             Sugg::BinOp(_, sugg) => Sugg::NonParen(format!(\"({})\", sugg).into()),\n         }\n@@ -273,8 +269,8 @@ pub fn make_assoc(op: AssocOp, lhs: &Sugg, rhs: &Sugg) -> Sugg<'static> {\n     fn needs_paren(op: &AssocOp, other: &AssocOp, dir: Associativity) -> bool {\n         other.precedence() < op.precedence() ||\n             (other.precedence() == op.precedence() &&\n-                 ((op != other && associativity(op) != dir) ||\n-                      (op == other && associativity(op) != Associativity::Both))) ||\n+                ((op != other && associativity(op) != dir) ||\n+                    (op == other && associativity(op) != Associativity::Both))) ||\n             is_shift(op) && is_arith(other) || is_shift(other) && is_arith(op)\n     }\n \n@@ -293,12 +289,24 @@ pub fn make_assoc(op: AssocOp, lhs: &Sugg, rhs: &Sugg) -> Sugg<'static> {\n     let lhs = ParenHelper::new(lhs_paren, lhs);\n     let rhs = ParenHelper::new(rhs_paren, rhs);\n     let sugg = match op {\n-        AssocOp::Add | AssocOp::BitAnd | AssocOp::BitOr | AssocOp::BitXor | AssocOp::Divide | AssocOp::Equal |\n-        AssocOp::Greater | AssocOp::GreaterEqual | AssocOp::LAnd | AssocOp::LOr | AssocOp::Less |\n-        AssocOp::LessEqual | AssocOp::Modulus | AssocOp::Multiply | AssocOp::NotEqual | AssocOp::ShiftLeft |\n-        AssocOp::ShiftRight | AssocOp::Subtract => {\n-            format!(\"{} {} {}\", lhs, op.to_ast_binop().expect(\"Those are AST ops\").to_string(), rhs)\n-        },\n+        AssocOp::Add |\n+        AssocOp::BitAnd |\n+        AssocOp::BitOr |\n+        AssocOp::BitXor |\n+        AssocOp::Divide |\n+        AssocOp::Equal |\n+        AssocOp::Greater |\n+        AssocOp::GreaterEqual |\n+        AssocOp::LAnd |\n+        AssocOp::LOr |\n+        AssocOp::Less |\n+        AssocOp::LessEqual |\n+        AssocOp::Modulus |\n+        AssocOp::Multiply |\n+        AssocOp::NotEqual |\n+        AssocOp::ShiftLeft |\n+        AssocOp::ShiftRight |\n+        AssocOp::Subtract => format!(\"{} {} {}\", lhs, op.to_ast_binop().expect(\"Those are AST ops\").to_string(), rhs),\n         AssocOp::Inplace => format!(\"in ({}) {}\", lhs, rhs),\n         AssocOp::Assign => format!(\"{} = {}\", lhs, rhs),\n         AssocOp::AssignOp(op) => format!(\"{} {}= {}\", lhs, token_to_string(&token::BinOp(op)), rhs),\n@@ -343,7 +351,16 @@ fn associativity(op: &AssocOp) -> Associativity {\n     match *op {\n         Inplace | Assign | AssignOp(_) => Associativity::Right,\n         Add | BitAnd | BitOr | BitXor | LAnd | LOr | Multiply | As | Colon => Associativity::Both,\n-        Divide | Equal | Greater | GreaterEqual | Less | LessEqual | Modulus | NotEqual | ShiftLeft | ShiftRight |\n+        Divide |\n+        Equal |\n+        Greater |\n+        GreaterEqual |\n+        Less |\n+        LessEqual |\n+        Modulus |\n+        NotEqual |\n+        ShiftLeft |\n+        ShiftRight |\n         Subtract => Associativity::Left,\n         DotDot | DotDotDot => Associativity::None,\n     }\n@@ -393,9 +410,8 @@ fn astbinop2assignop(op: ast::BinOp) -> AssocOp {\n /// before it on its line.\n fn indentation<'a, T: LintContext<'a>>(cx: &T, span: Span) -> Option<String> {\n     let lo = cx.sess().codemap().lookup_char_pos(span.lo());\n-    if let Some(line) = lo.file.get_line(\n-        lo.line - 1, /* line numbers in `Loc` are 1-based */\n-    )\n+    if let Some(line) = lo.file\n+        .get_line(lo.line - 1 /* line numbers in `Loc` are 1-based */)\n     {\n         if let Some((pos, _)) = line.char_indices().find(|&(_, c)| c != ' ' && c != '\\t') {\n             // we can mix char and byte positions here because we only consider `[ \\t]`"}, {"sha": "71f53a3e05191c67b8499c17c4317f78f6b21adb", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -72,14 +72,12 @@ fn check_vec_macro(cx: &LateContext, vec_args: &higher::VecArgs, span: Span) {\n                 return;\n             }\n         },\n-        higher::VecArgs::Vec(args) => {\n-            if let Some(last) = args.iter().last() {\n-                let span = args[0].span.to(last.span);\n+        higher::VecArgs::Vec(args) => if let Some(last) = args.iter().last() {\n+            let span = args[0].span.to(last.span);\n \n-                format!(\"&[{}]\", snippet(cx, span, \"..\")).into()\n-            } else {\n-                \"&[]\".into()\n-            }\n+            format!(\"&[{}]\", snippet(cx, span, \"..\")).into()\n+        } else {\n+            \"&[]\".into()\n         },\n     };\n "}, {"sha": "5ff9fb9ffd5dc9cfa729de681d59c9815c4469e1", "filename": "clippy_lints/src/zero_div_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fzero_div_zero.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -1,4 +1,4 @@\n-use consts::{Constant, constant_simple, FloatWidth};\n+use consts::{constant_simple, Constant, FloatWidth};\n use rustc::lint::*;\n use rustc::hir::*;\n use utils::span_help_and_lint;"}, {"sha": "fda167b69c706e5fd856d8c313c3e4a16672b8df", "filename": "mini-macro/src/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/mini-macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/mini-macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mini-macro%2Fsrc%2Flib.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -1,13 +1,12 @@\n #![feature(plugin_registrar, rustc_private)]\n \n-extern crate syntax;\n-extern crate rustc;\n extern crate rustc_plugin;\n+extern crate syntax;\n \n use syntax::codemap::Span;\n use syntax::tokenstream::TokenTree;\n-use syntax::ext::base::{ExtCtxt, MacResult, MacEager};\n-use syntax::ext::build::AstBuilder;  // trait for expr_usize\n+use syntax::ext::base::{ExtCtxt, MacEager, MacResult};\n+use syntax::ext::build::AstBuilder; // trait for expr_usize\n use rustc_plugin::Registry;\n \n fn expand_macro(cx: &mut ExtCtxt, sp: Span, _: &[TokenTree]) -> Box<MacResult + 'static> {"}, {"sha": "89de07115c540c9fba46421d41de84989fdeaaa3", "filename": "src/main.rs", "status": "modified", "additions": 14, "deletions": 31, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/src%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/src%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmain.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -45,13 +45,8 @@ impl<'a> CompilerCalls<'a> for ClippyCompilerCalls {\n         descriptions: &rustc_errors::registry::Registry,\n         output: ErrorOutputType,\n     ) -> Compilation {\n-        self.default.early_callback(\n-            matches,\n-            sopts,\n-            cfg,\n-            descriptions,\n-            output,\n-        )\n+        self.default\n+            .early_callback(matches, sopts, cfg, descriptions, output)\n     }\n     fn no_input(\n         &mut self,\n@@ -62,14 +57,8 @@ impl<'a> CompilerCalls<'a> for ClippyCompilerCalls {\n         ofile: &Option<PathBuf>,\n         descriptions: &rustc_errors::registry::Registry,\n     ) -> Option<(Input, Option<PathBuf>)> {\n-        self.default.no_input(\n-            matches,\n-            sopts,\n-            cfg,\n-            odir,\n-            ofile,\n-            descriptions,\n-        )\n+        self.default\n+            .no_input(matches, sopts, cfg, odir, ofile, descriptions)\n     }\n     fn late_callback(\n         &mut self,\n@@ -79,13 +68,8 @@ impl<'a> CompilerCalls<'a> for ClippyCompilerCalls {\n         odir: &Option<PathBuf>,\n         ofile: &Option<PathBuf>,\n     ) -> Compilation {\n-        self.default.late_callback(\n-            matches,\n-            sess,\n-            input,\n-            odir,\n-            ofile,\n-        )\n+        self.default\n+            .late_callback(matches, sess, input, odir, ofile)\n     }\n     fn build_controller(&mut self, sess: &Session, matches: &getopts::Matches) -> driver::CompileController<'a> {\n         let mut control = self.default.build_controller(sess, matches);\n@@ -101,7 +85,7 @@ impl<'a> CompilerCalls<'a> for ClippyCompilerCalls {\n                             .as_ref()\n                             .expect(\n                                 \"at this compilation stage \\\n-                                                                                          the krate must be parsed\",\n+                                 the krate must be parsed\",\n                             )\n                             .span,\n                     );\n@@ -203,13 +187,13 @@ pub fn main() {\n             .skip(2)\n             .find(|val| val.starts_with(\"--manifest-path=\"));\n \n-        let mut metadata =\n-            if let Ok(metadata) = cargo_metadata::metadata(manifest_path_arg.as_ref().map(AsRef::as_ref)) {\n-                metadata\n-            } else {\n-                let _ = io::stderr().write_fmt(format_args!(\"error: Could not obtain cargo metadata.\\n\"));\n-                process::exit(101);\n-            };\n+        let mut metadata = if let Ok(metadata) = cargo_metadata::metadata(manifest_path_arg.as_ref().map(AsRef::as_ref))\n+        {\n+            metadata\n+        } else {\n+            let _ = io::stderr().write_fmt(format_args!(\"error: Could not obtain cargo metadata.\\n\"));\n+            process::exit(101);\n+        };\n \n         let manifest_path = manifest_path_arg.map(|arg| {\n             Path::new(&arg[\"--manifest-path=\".len()..])\n@@ -359,7 +343,6 @@ fn process<I>(old_args: I) -> Result<(), i32>\n where\n     I: Iterator<Item = String>,\n {\n-\n     let mut args = vec![\"rustc\".to_owned()];\n \n     let mut found_dashes = false;"}, {"sha": "8fa0d440ee7bd71a207926af41d4e984f206ea8b", "filename": "tests/compile-test.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -29,6 +29,8 @@ fn compile_test() {\n     prepare_env();\n     run_mode(\"run-pass\", \"run-pass\");\n     run_mode(\"ui\", \"ui\");\n-    #[cfg(target_os = \"windows\")] run_mode(\"ui-windows\", \"ui\");\n-    #[cfg(not(target_os = \"windows\"))] run_mode(\"ui-posix\", \"ui\");\n+    #[cfg(target_os = \"windows\")]\n+    run_mode(\"ui-windows\", \"ui\");\n+    #[cfg(not(target_os = \"windows\"))]\n+    run_mode(\"ui-posix\", \"ui\");\n }"}, {"sha": "aa2c4d03bd5743db6053868eb28db478971c4d45", "filename": "tests/dogfood.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/tests%2Fdogfood.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/tests%2Fdogfood.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fdogfood.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -5,7 +5,7 @@\n extern crate compiletest_rs as compiletest;\n extern crate test;\n \n-use std::env::{var, set_var};\n+use std::env::{set_var, var};\n use std::path::PathBuf;\n use test::TestPaths;\n "}, {"sha": "50de10b936ca29c7f67d0ad20941e91f6025c29f", "filename": "tests/issue-825.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/tests%2Fissue-825.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/tests%2Fissue-825.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fissue-825.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -1,14 +1,12 @@\n #![feature(plugin)]\n #![plugin(clippy)]\n-\n #![allow(warnings)]\n \n // this should compile in a reasonable amount of time\n fn rust_type_id(name: &str) {\n-    if \"bool\" == &name[..] || \"uint\" == &name[..] || \"u8\" == &name[..] || \"u16\" == &name[..] ||\n-        \"u32\" == &name[..] || \"f32\" == &name[..] || \"f64\" == &name[..] || \"i8\" == &name[..] ||\n-        \"i16\" == &name[..] || \"i32\" == &name[..] ||\n-        \"i64\" == &name[..] || \"Self\" == &name[..] || \"str\" == &name[..]\n+    if \"bool\" == &name[..] || \"uint\" == &name[..] || \"u8\" == &name[..] || \"u16\" == &name[..] || \"u32\" == &name[..] ||\n+        \"f32\" == &name[..] || \"f64\" == &name[..] || \"i8\" == &name[..] || \"i16\" == &name[..] ||\n+        \"i32\" == &name[..] || \"i64\" == &name[..] || \"Self\" == &name[..] || \"str\" == &name[..]\n     {\n         unreachable!();\n     }"}, {"sha": "42d1154bf1a73793fb5fd53764f5f688d90c6486", "filename": "tests/matches.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/tests%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/tests%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmatches.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -21,26 +21,22 @@ fn test_overlapping() {\n     assert_eq!(None, overlapping(&[sp(1, Bound::Included(4)), sp(5, Bound::Included(6))]));\n     assert_eq!(\n         None,\n-        overlapping(\n-            &[\n-                sp(1, Bound::Included(4)),\n-                sp(5, Bound::Included(6)),\n-                sp(10, Bound::Included(11)),\n-            ],\n-        )\n+        overlapping(&[\n+            sp(1, Bound::Included(4)),\n+            sp(5, Bound::Included(6)),\n+            sp(10, Bound::Included(11))\n+        ],)\n     );\n     assert_eq!(\n         Some((&sp(1, Bound::Included(4)), &sp(3, Bound::Included(6)))),\n         overlapping(&[sp(1, Bound::Included(4)), sp(3, Bound::Included(6))])\n     );\n     assert_eq!(\n         Some((&sp(5, Bound::Included(6)), &sp(6, Bound::Included(11)))),\n-        overlapping(\n-            &[\n-                sp(1, Bound::Included(4)),\n-                sp(5, Bound::Included(6)),\n-                sp(6, Bound::Included(11)),\n-            ],\n-        )\n+        overlapping(&[\n+            sp(1, Bound::Included(4)),\n+            sp(5, Bound::Included(6)),\n+            sp(6, Bound::Included(11))\n+        ],)\n     );\n }"}, {"sha": "853f64b46984ee15539571a94497f0599a2c79d5", "filename": "tests/needless_continue_helpers.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/tests%2Fneedless_continue_helpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/tests%2Fneedless_continue_helpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fneedless_continue_helpers.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -1,7 +1,8 @@\n // Tests for the various helper functions used by the needless_continue\n // lint that don't belong in utils.\n+\n extern crate clippy_lints;\n-use clippy_lints::needless_continue::{erode_from_back, erode_block, erode_from_front};\n+use clippy_lints::needless_continue::{erode_block, erode_from_back, erode_from_front};\n \n #[test]\n #[cfg_attr(rustfmt, rustfmt_skip)]"}, {"sha": "b4aee6d8ce23fef5e85ba94ea49df3387b494b3a", "filename": "tests/ui/for_loop.rs", "status": "modified", "additions": 222, "deletions": 65, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/tests%2Fui%2Ffor_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/tests%2Fui%2Ffor_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor_loop.rs?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -4,14 +4,14 @@\n use std::collections::*;\n use std::rc::Rc;\n \n-static STATIC: [usize; 4] = [ 0,  1,  8, 16 ];\n-const CONST: [usize; 4] = [ 0,  1,  8, 16 ];\n+static STATIC: [usize; 4] = [0, 1, 8, 16];\n+const CONST: [usize; 4] = [0, 1, 8, 16];\n \n #[warn(clippy)]\n fn for_loop_over_option_and_result() {\n     let option = Some(1);\n     let result = option.ok_or(\"x not found\");\n-    let v = vec![0,1,2];\n+    let v = vec![0, 1, 2];\n \n     // check FOR_LOOP_OVER_OPTION lint\n     for x in option {\n@@ -27,7 +27,8 @@ fn for_loop_over_option_and_result() {\n         println!(\"{}\", x);\n     }\n \n-    // make sure LOOP_OVER_NEXT lint takes precedence when next() is the last call in the chain\n+    // make sure LOOP_OVER_NEXT lint takes precedence when next() is the last call\n+    // in the chain\n     for x in v.iter().next() {\n         println!(\"{}\", x);\n     }\n@@ -72,7 +73,8 @@ impl Unrelated {\n     }\n }\n \n-#[warn(needless_range_loop, explicit_iter_loop, explicit_into_iter_loop, iter_next_loop, reverse_range_loop, explicit_counter_loop, for_kv_map)]\n+#[warn(needless_range_loop, explicit_iter_loop, explicit_into_iter_loop, iter_next_loop, reverse_range_loop,\n+       explicit_counter_loop, for_kv_map)]\n #[warn(unused_collect)]\n #[allow(linkedlist, shadow_unrelated, unnecessary_mut_passed, cyclomatic_complexity, similar_names)]\n #[allow(many_single_char_names, unused_variables)]\n@@ -90,7 +92,9 @@ fn main() {\n         println!(\"{}\", vec[i]); // ok, not the `i` of the for-loop\n     }\n \n-    for i in 0..vec.len() { let _ = vec[i]; }\n+    for i in 0..vec.len() {\n+        let _ = vec[i];\n+    }\n \n     // ICE #746\n     for j in 0..4 {\n@@ -104,7 +108,8 @@ fn main() {\n     for i in 0..vec.len() {\n         println!(\"{} {}\", vec[i], i);\n     }\n-    for i in 0..vec.len() {      // not an error, indexing more than one variable\n+    for i in 0..vec.len() {\n+        // not an error, indexing more than one variable\n         println!(\"{} {}\", vec[i], vec2[i]);\n     }\n \n@@ -156,180 +161,240 @@ fn main() {\n         println!(\"{}\", i);\n     }\n \n-    for i in 5...5 { // not an error, this is the range with only one element \u201c5\u201d\n+    for i in 5...5 {\n+        // not an error, this is the range with only one element \u201c5\u201d\n         println!(\"{}\", i);\n     }\n \n-    for i in 0..10 { // not an error, the start index is less than the end index\n+    for i in 0..10 {\n+        // not an error, the start index is less than the end index\n         println!(\"{}\", i);\n     }\n \n-    for i in -10..0 { // not an error\n+    for i in -10..0 {\n+        // not an error\n         println!(\"{}\", i);\n     }\n \n-    for i in (10..0).map(|x| x * 2) { // not an error, it can't be known what arbitrary methods do to a range\n+    for i in (10..0).map(|x| x * 2) {\n+        // not an error, it can't be known what arbitrary methods do to a range\n         println!(\"{}\", i);\n     }\n \n     // testing that the empty range lint folds constants\n-    for i in 10..5+4 {\n+    for i in 10..5 + 4 {\n         println!(\"{}\", i);\n     }\n \n-    for i in (5+2)..(3-1) {\n+    for i in (5 + 2)..(3 - 1) {\n         println!(\"{}\", i);\n     }\n \n-    for i in (5+2)..(8-1) {\n+    for i in (5 + 2)..(8 - 1) {\n         println!(\"{}\", i);\n     }\n \n-    for i in (2*2)..(2*3) { // no error, 4..6 is fine\n+    for i in (2 * 2)..(2 * 3) {\n+        // no error, 4..6 is fine\n         println!(\"{}\", i);\n     }\n \n     let x = 42;\n-    for i in x..10 { // no error, not constant-foldable\n+    for i in x..10 {\n+        // no error, not constant-foldable\n         println!(\"{}\", i);\n     }\n \n     // See #601\n-    for i in 0..10 { // no error, id_col does not exist outside the loop\n+    for i in 0..10 {\n+        // no error, id_col does not exist outside the loop\n         let mut id_col = vec![0f64; 10];\n         id_col[i] = 1f64;\n     }\n \n-    for _v in vec.iter() { }\n+    for _v in vec.iter() {}\n \n-    for _v in vec.iter_mut() { }\n+    for _v in vec.iter_mut() {}\n \n-    let out_vec = vec![1,2,3];\n-    for _v in out_vec.into_iter() { }\n+    let out_vec = vec![1, 2, 3];\n+    for _v in out_vec.into_iter() {}\n \n     let array = [1, 2, 3];\n     for _v in array.into_iter() {}\n \n-    for _v in &vec { } // these are fine\n-    for _v in &mut vec { } // these are fine\n+    for _v in &vec {} // these are fine\n+    for _v in &mut vec {} // these are fine\n \n-    for _v in [1, 2, 3].iter() { }\n+    for _v in [1, 2, 3].iter() {}\n \n-    for _v in (&mut [1, 2, 3]).iter() { } // no error\n+    for _v in (&mut [1, 2, 3]).iter() {} // no error\n \n     for _v in [0; 32].iter() {}\n \n     for _v in [0; 33].iter() {} // no error\n \n     let ll: LinkedList<()> = LinkedList::new();\n-    for _v in ll.iter() { }\n+    for _v in ll.iter() {}\n \n     let vd: VecDeque<()> = VecDeque::new();\n-    for _v in vd.iter() { }\n+    for _v in vd.iter() {}\n \n     let bh: BinaryHeap<()> = BinaryHeap::new();\n-    for _v in bh.iter() { }\n+    for _v in bh.iter() {}\n \n     let hm: HashMap<(), ()> = HashMap::new();\n-    for _v in hm.iter() { }\n+    for _v in hm.iter() {}\n \n     let bt: BTreeMap<(), ()> = BTreeMap::new();\n-    for _v in bt.iter() { }\n+    for _v in bt.iter() {}\n \n     let hs: HashSet<()> = HashSet::new();\n-    for _v in hs.iter() { }\n+    for _v in hs.iter() {}\n \n     let bs: BTreeSet<()> = BTreeSet::new();\n-    for _v in bs.iter() { }\n+    for _v in bs.iter() {}\n \n-    for _v in vec.iter().next() { }\n+    for _v in vec.iter().next() {}\n \n     let u = Unrelated(vec![]);\n-    for _v in u.next() { } // no error\n-    for _v in u.iter() { } // no error\n+    for _v in u.next() {} // no error\n+    for _v in u.iter() {} // no error\n \n     let mut out = vec![];\n     vec.iter().cloned().map(|x| out.push(x)).collect::<Vec<_>>();\n     let _y = vec.iter().cloned().map(|x| out.push(x)).collect::<Vec<_>>(); // this is fine\n \n     // Loop with explicit counter variable\n     let mut _index = 0;\n-    for _v in &vec { _index += 1 }\n+    for _v in &vec {\n+        _index += 1\n+    }\n \n     let mut _index = 1;\n     _index = 0;\n-    for _v in &vec { _index += 1 }\n+    for _v in &vec {\n+        _index += 1\n+    }\n \n     // Potential false positives\n     let mut _index = 0;\n     _index = 1;\n-    for _v in &vec { _index += 1 }\n+    for _v in &vec {\n+        _index += 1\n+    }\n \n     let mut _index = 0;\n     _index += 1;\n-    for _v in &vec { _index += 1 }\n+    for _v in &vec {\n+        _index += 1\n+    }\n \n     let mut _index = 0;\n-    if true { _index = 1 }\n-    for _v in &vec { _index += 1 }\n+    if true {\n+        _index = 1\n+    }\n+    for _v in &vec {\n+        _index += 1\n+    }\n \n     let mut _index = 0;\n     let mut _index = 1;\n-    for _v in &vec { _index += 1 }\n+    for _v in &vec {\n+        _index += 1\n+    }\n \n     let mut _index = 0;\n-    for _v in &vec { _index += 1; _index += 1 }\n+    for _v in &vec {\n+        _index += 1;\n+        _index += 1\n+    }\n \n     let mut _index = 0;\n-    for _v in &vec { _index *= 2; _index += 1 }\n+    for _v in &vec {\n+        _index *= 2;\n+        _index += 1\n+    }\n \n     let mut _index = 0;\n-    for _v in &vec { _index = 1; _index += 1 }\n+    for _v in &vec {\n+        _index = 1;\n+        _index += 1\n+    }\n \n     let mut _index = 0;\n \n-    for _v in &vec { let mut _index = 0; _index += 1 }\n+    for _v in &vec {\n+        let mut _index = 0;\n+        _index += 1\n+    }\n \n     let mut _index = 0;\n-    for _v in &vec { _index += 1; _index = 0; }\n+    for _v in &vec {\n+        _index += 1;\n+        _index = 0;\n+    }\n \n     let mut _index = 0;\n-    for _v in &vec { for _x in 0..1 { _index += 1; }; _index += 1 }\n+    for _v in &vec {\n+        for _x in 0..1 {\n+            _index += 1;\n+        }\n+        _index += 1\n+    }\n \n     let mut _index = 0;\n-    for x in &vec { if *x == 1 { _index += 1 } }\n+    for x in &vec {\n+        if *x == 1 {\n+            _index += 1\n+        }\n+    }\n \n     let mut _index = 0;\n-    if true { _index = 1 };\n-    for _v in &vec { _index += 1 }\n+    if true {\n+        _index = 1\n+    };\n+    for _v in &vec {\n+        _index += 1\n+    }\n \n     let mut _index = 1;\n-    if false { _index = 0 };\n-    for _v in &vec { _index += 1 }\n+    if false {\n+        _index = 0\n+    };\n+    for _v in &vec {\n+        _index += 1\n+    }\n \n     let mut index = 0;\n-    { let mut _x = &mut index; }\n-    for _v in &vec { _index += 1 }\n+    {\n+        let mut _x = &mut index;\n+    }\n+    for _v in &vec {\n+        _index += 1\n+    }\n \n     let mut index = 0;\n-    for _v in &vec { index += 1 }\n+    for _v in &vec {\n+        index += 1\n+    }\n     println!(\"index: {}\", index);\n \n     for_loop_over_option_and_result();\n \n-    let m : HashMap<u64, u64> = HashMap::new();\n+    let m: HashMap<u64, u64> = HashMap::new();\n     for (_, v) in &m {\n         let _v = v;\n     }\n \n-    let m : Rc<HashMap<u64, u64>> = Rc::new(HashMap::new());\n+    let m: Rc<HashMap<u64, u64>> = Rc::new(HashMap::new());\n     for (_, v) in &*m {\n         let _v = v;\n-        // Here the `*` is not actually necesarry, but the test tests that we don't suggest\n+        // Here the `*` is not actually necesarry, but the test tests that we don't\n+        // suggest\n         // `in *m.values()` as we used to\n     }\n \n-    let mut m : HashMap<u64, u64> = HashMap::new();\n+    let mut m: HashMap<u64, u64> = HashMap::new();\n     for (_, v) in &mut m {\n         let _v = v;\n     }\n@@ -339,16 +404,20 @@ fn main() {\n         let _v = v;\n     }\n \n-    let m : HashMap<u64, u64> = HashMap::new();\n+    let m: HashMap<u64, u64> = HashMap::new();\n     let rm = &m;\n     for (k, _value) in rm {\n         let _k = k;\n     }\n \n     test_for_kv_map();\n \n-    fn f<T>(_: &T, _: &T) -> bool { unimplemented!() }\n-    fn g<T>(_: &mut [T], _: usize, _: usize) { unimplemented!() }\n+    fn f<T>(_: &T, _: &T) -> bool {\n+        unimplemented!()\n+    }\n+    fn g<T>(_: &mut [T], _: usize, _: usize) {\n+        unimplemented!()\n+    }\n     for i in 1..vec.len() {\n         if f(&vec[i - 1], &vec[i]) {\n             g(&mut vec, i - 1, i);\n@@ -362,7 +431,7 @@ fn main() {\n \n #[allow(used_underscore_binding)]\n fn test_for_kv_map() {\n-    let m : HashMap<u64, u64> = HashMap::new();\n+    let m: HashMap<u64, u64> = HashMap::new();\n \n     // No error, _value is actually used\n     for (k, _value) in &m {\n@@ -372,7 +441,7 @@ fn test_for_kv_map() {\n }\n \n #[allow(dead_code)]\n-fn partition<T:PartialOrd+Send>(v: &mut [T]) -> usize {\n+fn partition<T: PartialOrd + Send>(v: &mut [T]) -> usize {\n     let pivot = v.len() - 1;\n     let mut i = 0;\n     for j in 0..pivot {\n@@ -384,3 +453,91 @@ fn partition<T:PartialOrd+Send>(v: &mut [T]) -> usize {\n     v.swap(i, pivot);\n     i\n }\n+\n+const LOOP_OFFSET: usize = 5000;\n+\n+#[warn(needless_range_loop)]\n+pub fn manual_copy(src: &[i32], dst: &mut [i32], dst2: &mut [i32]) {\n+    // plain manual memcpy\n+    for i in 0..src.len() {\n+        dst[i] = src[i];\n+    }\n+\n+    // dst offset memcpy\n+    for i in 0..src.len() {\n+        dst[i + 10] = src[i];\n+    }\n+\n+    // src offset memcpy\n+    for i in 0..src.len() {\n+        dst[i] = src[i + 10];\n+    }\n+\n+    // src offset memcpy\n+    for i in 11..src.len() {\n+        dst[i] = src[i - 10];\n+    }\n+\n+    // overwrite entire dst\n+    for i in 0..dst.len() {\n+        dst[i] = src[i];\n+    }\n+\n+    // manual copy with branch - can't easily convert to memcpy!\n+    for i in 0..src.len() {\n+        dst[i] = src[i];\n+        if dst[i] > 5 {\n+            break;\n+        }\n+    }\n+\n+    // multiple copies - suggest two memcpy statements\n+    for i in 10..256 {\n+        dst[i] = src[i - 5];\n+        dst2[i + 500] = src[i]\n+    }\n+\n+    // this is a reversal - the copy lint shouldn't be triggered\n+    for i in 10..LOOP_OFFSET {\n+        dst[i + LOOP_OFFSET] = src[LOOP_OFFSET - i];\n+    }\n+\n+    let some_var = 5;\n+    // Offset in variable\n+    for i in 10..LOOP_OFFSET {\n+        dst[i + LOOP_OFFSET] = src[i - some_var];\n+    }\n+\n+    // Non continuous copy - don't trigger lint\n+    for i in 0..10 {\n+        dst[i + i] = src[i];\n+    }\n+\n+    let src_vec = vec![1, 2, 3, 4, 5];\n+    let mut dst_vec = vec![0, 0, 0, 0, 0];\n+\n+    // make sure vectors are supported\n+    for i in 0..src_vec.len() {\n+        dst_vec[i] = src_vec[i];\n+    }\n+\n+    // lint should not trigger when either\n+    // source or destination type is not\n+    // slice-like, like DummyStruct\n+    struct DummyStruct(i32);\n+\n+    impl ::std::ops::Index<usize> for DummyStruct {\n+        type Output = i32;\n+\n+        fn index(&self, _: usize) -> &i32 {\n+            &self.0\n+        }\n+    }\n+\n+    let src = DummyStruct(5);\n+    let mut dst_vec = vec![0; 10];\n+\n+    for i in 0..10 {\n+        dst_vec[i] = src[i];\n+    }\n+}"}, {"sha": "721b2833dec26307622b3816bbf29a70d70a1b34", "filename": "tests/ui/for_loop.stderr", "status": "modified", "additions": 267, "deletions": 187, "changes": 454, "blob_url": "https://github.com/rust-lang/rust/blob/2e3328503e4305e877691f9663efd47fbe7942bd/tests%2Fui%2Ffor_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2e3328503e4305e877691f9663efd47fbe7942bd/tests%2Fui%2Ffor_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor_loop.stderr?ref=2e3328503e4305e877691f9663efd47fbe7942bd", "patch": "@@ -25,478 +25,558 @@ error: for loop over `option.ok_or(\"x not found\")`, which is a `Result`. This is\n    = help: consider replacing `for x in option.ok_or(\"x not found\")` with `if let Ok(x) = option.ok_or(\"x not found\")`\n \n error: you are iterating over `Iterator::next()` which is an Option; this will compile but is probably not what you want\n-  --> $DIR/for_loop.rs:31:5\n+  --> $DIR/for_loop.rs:32:5\n    |\n-31 | /     for x in v.iter().next() {\n-32 | |         println!(\"{}\", x);\n-33 | |     }\n+32 | /     for x in v.iter().next() {\n+33 | |         println!(\"{}\", x);\n+34 | |     }\n    | |_____^\n    |\n    = note: `-D iter-next-loop` implied by `-D warnings`\n \n error: for loop over `v.iter().next().and(Some(0))`, which is an `Option`. This is more readably written as an `if let` statement.\n-  --> $DIR/for_loop.rs:36:14\n+  --> $DIR/for_loop.rs:37:14\n    |\n-36 |     for x in v.iter().next().and(Some(0)) {\n+37 |     for x in v.iter().next().and(Some(0)) {\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider replacing `for x in v.iter().next().and(Some(0))` with `if let Some(x) = v.iter().next().and(Some(0))`\n \n error: for loop over `v.iter().next().ok_or(\"x not found\")`, which is a `Result`. This is more readably written as an `if let` statement.\n-  --> $DIR/for_loop.rs:40:14\n+  --> $DIR/for_loop.rs:41:14\n    |\n-40 |     for x in v.iter().next().ok_or(\"x not found\") {\n+41 |     for x in v.iter().next().ok_or(\"x not found\") {\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider replacing `for x in v.iter().next().ok_or(\"x not found\")` with `if let Ok(x) = v.iter().next().ok_or(\"x not found\")`\n \n error: this loop never actually loops\n-  --> $DIR/for_loop.rs:52:5\n+  --> $DIR/for_loop.rs:53:5\n    |\n-52 | /     while let Some(x) = option {\n-53 | |         println!(\"{}\", x);\n-54 | |         break;\n-55 | |     }\n+53 | /     while let Some(x) = option {\n+54 | |         println!(\"{}\", x);\n+55 | |         break;\n+56 | |     }\n    | |_____^\n    |\n    = note: `-D never-loop` implied by `-D warnings`\n \n error: this loop never actually loops\n-  --> $DIR/for_loop.rs:58:5\n+  --> $DIR/for_loop.rs:59:5\n    |\n-58 | /     while let Ok(x) = result {\n-59 | |         println!(\"{}\", x);\n-60 | |         break;\n-61 | |     }\n+59 | /     while let Ok(x) = result {\n+60 | |         println!(\"{}\", x);\n+61 | |         break;\n+62 | |     }\n    | |_____^\n \n error: the loop variable `i` is only used to index `vec`.\n-  --> $DIR/for_loop.rs:84:5\n+  --> $DIR/for_loop.rs:86:5\n    |\n-84 | /     for i in 0..vec.len() {\n-85 | |         println!(\"{}\", vec[i]);\n-86 | |     }\n+86 | /     for i in 0..vec.len() {\n+87 | |         println!(\"{}\", vec[i]);\n+88 | |     }\n    | |_____^\n    |\n    = note: `-D needless-range-loop` implied by `-D warnings`\n help: consider using an iterator\n    |\n-84 |     for <item> in &vec {\n+86 |     for <item> in &vec {\n    |         ^^^^^^\n \n error: the loop variable `i` is only used to index `vec`.\n-  --> $DIR/for_loop.rs:93:5\n+  --> $DIR/for_loop.rs:95:5\n    |\n-93 |     for i in 0..vec.len() { let _ = vec[i]; }\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: consider using an iterator\n-   |\n-93 |     for <item> in &vec { let _ = vec[i]; }\n-   |         ^^^^^^\n-\n-error: the loop variable `j` is only used to index `STATIC`.\n-  --> $DIR/for_loop.rs:96:5\n-   |\n-96 | /     for j in 0..4 {\n-97 | |         println!(\"{:?}\", STATIC[j]);\n-98 | |     }\n+95 | /     for i in 0..vec.len() {\n+96 | |         let _ = vec[i];\n+97 | |     }\n    | |_____^\n    |\n help: consider using an iterator\n    |\n-96 |     for <item> in STATIC.iter().take(4) {\n+95 |     for <item> in &vec {\n    |         ^^^^^^\n \n-error: the loop variable `j` is only used to index `CONST`.\n+error: the loop variable `j` is only used to index `STATIC`.\n    --> $DIR/for_loop.rs:100:5\n     |\n 100 | /     for j in 0..4 {\n-101 | |         println!(\"{:?}\", CONST[j]);\n+101 | |         println!(\"{:?}\", STATIC[j]);\n 102 | |     }\n     | |_____^\n     |\n help: consider using an iterator\n     |\n-100 |     for <item> in CONST.iter().take(4) {\n+100 |     for <item> in STATIC.iter().take(4) {\n     |         ^^^^^^\n \n-error: the loop variable `i` is used to index `vec`\n+error: the loop variable `j` is only used to index `CONST`.\n    --> $DIR/for_loop.rs:104:5\n     |\n-104 | /     for i in 0..vec.len() {\n-105 | |         println!(\"{} {}\", vec[i], i);\n+104 | /     for j in 0..4 {\n+105 | |         println!(\"{:?}\", CONST[j]);\n 106 | |     }\n     | |_____^\n     |\n help: consider using an iterator\n     |\n-104 |     for (i, <item>) in vec.iter().enumerate() {\n+104 |     for <item> in CONST.iter().take(4) {\n+    |         ^^^^^^\n+\n+error: the loop variable `i` is used to index `vec`\n+   --> $DIR/for_loop.rs:108:5\n+    |\n+108 | /     for i in 0..vec.len() {\n+109 | |         println!(\"{} {}\", vec[i], i);\n+110 | |     }\n+    | |_____^\n+    |\n+help: consider using an iterator\n+    |\n+108 |     for (i, <item>) in vec.iter().enumerate() {\n     |         ^^^^^^^^^^^\n \n error: the loop variable `i` is only used to index `vec2`.\n-   --> $DIR/for_loop.rs:111:5\n+   --> $DIR/for_loop.rs:116:5\n     |\n-111 | /     for i in 0..vec.len() {\n-112 | |         println!(\"{}\", vec2[i]);\n-113 | |     }\n+116 | /     for i in 0..vec.len() {\n+117 | |         println!(\"{}\", vec2[i]);\n+118 | |     }\n     | |_____^\n     |\n help: consider using an iterator\n     |\n-111 |     for <item> in vec2.iter().take(vec.len()) {\n+116 |     for <item> in vec2.iter().take(vec.len()) {\n     |         ^^^^^^\n \n error: the loop variable `i` is only used to index `vec`.\n-   --> $DIR/for_loop.rs:115:5\n+   --> $DIR/for_loop.rs:120:5\n     |\n-115 | /     for i in 5..vec.len() {\n-116 | |         println!(\"{}\", vec[i]);\n-117 | |     }\n+120 | /     for i in 5..vec.len() {\n+121 | |         println!(\"{}\", vec[i]);\n+122 | |     }\n     | |_____^\n     |\n help: consider using an iterator\n     |\n-115 |     for <item> in vec.iter().skip(5) {\n+120 |     for <item> in vec.iter().skip(5) {\n     |         ^^^^^^\n \n error: the loop variable `i` is only used to index `vec`.\n-   --> $DIR/for_loop.rs:119:5\n+   --> $DIR/for_loop.rs:124:5\n     |\n-119 | /     for i in 0..MAX_LEN {\n-120 | |         println!(\"{}\", vec[i]);\n-121 | |     }\n+124 | /     for i in 0..MAX_LEN {\n+125 | |         println!(\"{}\", vec[i]);\n+126 | |     }\n     | |_____^\n     |\n help: consider using an iterator\n     |\n-119 |     for <item> in vec.iter().take(MAX_LEN) {\n+124 |     for <item> in vec.iter().take(MAX_LEN) {\n     |         ^^^^^^\n \n error: the loop variable `i` is only used to index `vec`.\n-   --> $DIR/for_loop.rs:123:5\n+   --> $DIR/for_loop.rs:128:5\n     |\n-123 | /     for i in 0...MAX_LEN {\n-124 | |         println!(\"{}\", vec[i]);\n-125 | |     }\n+128 | /     for i in 0...MAX_LEN {\n+129 | |         println!(\"{}\", vec[i]);\n+130 | |     }\n     | |_____^\n     |\n help: consider using an iterator\n     |\n-123 |     for <item> in vec.iter().take(MAX_LEN + 1) {\n+128 |     for <item> in vec.iter().take(MAX_LEN + 1) {\n     |         ^^^^^^\n \n error: the loop variable `i` is only used to index `vec`.\n-   --> $DIR/for_loop.rs:127:5\n+   --> $DIR/for_loop.rs:132:5\n     |\n-127 | /     for i in 5..10 {\n-128 | |         println!(\"{}\", vec[i]);\n-129 | |     }\n+132 | /     for i in 5..10 {\n+133 | |         println!(\"{}\", vec[i]);\n+134 | |     }\n     | |_____^\n     |\n help: consider using an iterator\n     |\n-127 |     for <item> in vec.iter().take(10).skip(5) {\n+132 |     for <item> in vec.iter().take(10).skip(5) {\n     |         ^^^^^^\n \n error: the loop variable `i` is only used to index `vec`.\n-   --> $DIR/for_loop.rs:131:5\n+   --> $DIR/for_loop.rs:136:5\n     |\n-131 | /     for i in 5...10 {\n-132 | |         println!(\"{}\", vec[i]);\n-133 | |     }\n+136 | /     for i in 5...10 {\n+137 | |         println!(\"{}\", vec[i]);\n+138 | |     }\n     | |_____^\n     |\n help: consider using an iterator\n     |\n-131 |     for <item> in vec.iter().take(10 + 1).skip(5) {\n+136 |     for <item> in vec.iter().take(10 + 1).skip(5) {\n     |         ^^^^^^\n \n error: the loop variable `i` is used to index `vec`\n-   --> $DIR/for_loop.rs:135:5\n+   --> $DIR/for_loop.rs:140:5\n     |\n-135 | /     for i in 5..vec.len() {\n-136 | |         println!(\"{} {}\", vec[i], i);\n-137 | |     }\n+140 | /     for i in 5..vec.len() {\n+141 | |         println!(\"{} {}\", vec[i], i);\n+142 | |     }\n     | |_____^\n     |\n help: consider using an iterator\n     |\n-135 |     for (i, <item>) in vec.iter().enumerate().skip(5) {\n+140 |     for (i, <item>) in vec.iter().enumerate().skip(5) {\n     |         ^^^^^^^^^^^\n \n error: the loop variable `i` is used to index `vec`\n-   --> $DIR/for_loop.rs:139:5\n+   --> $DIR/for_loop.rs:144:5\n     |\n-139 | /     for i in 5..10 {\n-140 | |         println!(\"{} {}\", vec[i], i);\n-141 | |     }\n+144 | /     for i in 5..10 {\n+145 | |         println!(\"{} {}\", vec[i], i);\n+146 | |     }\n     | |_____^\n     |\n help: consider using an iterator\n     |\n-139 |     for (i, <item>) in vec.iter().enumerate().take(10).skip(5) {\n+144 |     for (i, <item>) in vec.iter().enumerate().take(10).skip(5) {\n     |         ^^^^^^^^^^^\n \n error: this range is empty so this for loop will never run\n-   --> $DIR/for_loop.rs:143:5\n+   --> $DIR/for_loop.rs:148:5\n     |\n-143 | /     for i in 10..0 {\n-144 | |         println!(\"{}\", i);\n-145 | |     }\n+148 | /     for i in 10..0 {\n+149 | |         println!(\"{}\", i);\n+150 | |     }\n     | |_____^\n     |\n     = note: `-D reverse-range-loop` implied by `-D warnings`\n help: consider using the following if you are attempting to iterate over this range in reverse\n     |\n-143 |     for i in (0..10).rev() {\n+148 |     for i in (0..10).rev() {\n     |              ^^^^^^^^^^^^^\n \n error: this range is empty so this for loop will never run\n-   --> $DIR/for_loop.rs:147:5\n+   --> $DIR/for_loop.rs:152:5\n     |\n-147 | /     for i in 10...0 {\n-148 | |         println!(\"{}\", i);\n-149 | |     }\n+152 | /     for i in 10...0 {\n+153 | |         println!(\"{}\", i);\n+154 | |     }\n     | |_____^\n     |\n help: consider using the following if you are attempting to iterate over this range in reverse\n     |\n-147 |     for i in (0...10).rev() {\n+152 |     for i in (0...10).rev() {\n     |              ^^^^^^^^^^^^^^\n \n error: this range is empty so this for loop will never run\n-   --> $DIR/for_loop.rs:151:5\n+   --> $DIR/for_loop.rs:156:5\n     |\n-151 | /     for i in MAX_LEN..0 {\n-152 | |         println!(\"{}\", i);\n-153 | |     }\n+156 | /     for i in MAX_LEN..0 {\n+157 | |         println!(\"{}\", i);\n+158 | |     }\n     | |_____^\n     |\n help: consider using the following if you are attempting to iterate over this range in reverse\n     |\n-151 |     for i in (0..MAX_LEN).rev() {\n+156 |     for i in (0..MAX_LEN).rev() {\n     |              ^^^^^^^^^^^^^^^^^^\n \n error: this range is empty so this for loop will never run\n-   --> $DIR/for_loop.rs:155:5\n+   --> $DIR/for_loop.rs:160:5\n     |\n-155 | /     for i in 5..5 {\n-156 | |         println!(\"{}\", i);\n-157 | |     }\n+160 | /     for i in 5..5 {\n+161 | |         println!(\"{}\", i);\n+162 | |     }\n     | |_____^\n \n error: this range is empty so this for loop will never run\n-   --> $DIR/for_loop.rs:176:5\n+   --> $DIR/for_loop.rs:185:5\n     |\n-176 | /     for i in 10..5+4 {\n-177 | |         println!(\"{}\", i);\n-178 | |     }\n+185 | /     for i in 10..5 + 4 {\n+186 | |         println!(\"{}\", i);\n+187 | |     }\n     | |_____^\n     |\n help: consider using the following if you are attempting to iterate over this range in reverse\n     |\n-176 |     for i in (5+4..10).rev() {\n-    |              ^^^^^^^^^^^^^^^\n+185 |     for i in (5 + 4..10).rev() {\n+    |              ^^^^^^^^^^^^^^^^^\n \n error: this range is empty so this for loop will never run\n-   --> $DIR/for_loop.rs:180:5\n+   --> $DIR/for_loop.rs:189:5\n     |\n-180 | /     for i in (5+2)..(3-1) {\n-181 | |         println!(\"{}\", i);\n-182 | |     }\n+189 | /     for i in (5 + 2)..(3 - 1) {\n+190 | |         println!(\"{}\", i);\n+191 | |     }\n     | |_____^\n     |\n help: consider using the following if you are attempting to iterate over this range in reverse\n     |\n-180 |     for i in ((3-1)..(5+2)).rev() {\n-    |              ^^^^^^^^^^^^^^^^^^^^\n+189 |     for i in ((3 - 1)..(5 + 2)).rev() {\n+    |              ^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: this range is empty so this for loop will never run\n-   --> $DIR/for_loop.rs:184:5\n+   --> $DIR/for_loop.rs:193:5\n     |\n-184 | /     for i in (5+2)..(8-1) {\n-185 | |         println!(\"{}\", i);\n-186 | |     }\n+193 | /     for i in (5 + 2)..(8 - 1) {\n+194 | |         println!(\"{}\", i);\n+195 | |     }\n     | |_____^\n \n error: it is more idiomatic to loop over references to containers instead of using explicit iteration methods\n-   --> $DIR/for_loop.rs:203:15\n+   --> $DIR/for_loop.rs:215:15\n     |\n-203 |     for _v in vec.iter() { }\n+215 |     for _v in vec.iter() {}\n     |               ^^^^^^^^^^ help: to write this more concisely, try: `&vec`\n     |\n     = note: `-D explicit-iter-loop` implied by `-D warnings`\n \n error: it is more idiomatic to loop over references to containers instead of using explicit iteration methods\n-   --> $DIR/for_loop.rs:205:15\n+   --> $DIR/for_loop.rs:217:15\n     |\n-205 |     for _v in vec.iter_mut() { }\n+217 |     for _v in vec.iter_mut() {}\n     |               ^^^^^^^^^^^^^^ help: to write this more concisely, try: `&mut vec`\n \n error: it is more idiomatic to loop over containers instead of using explicit iteration methods`\n-   --> $DIR/for_loop.rs:208:15\n+   --> $DIR/for_loop.rs:220:15\n     |\n-208 |     for _v in out_vec.into_iter() { }\n+220 |     for _v in out_vec.into_iter() {}\n     |               ^^^^^^^^^^^^^^^^^^^ help: to write this more concisely, try: `out_vec`\n     |\n     = note: `-D explicit-into-iter-loop` implied by `-D warnings`\n \n error: it is more idiomatic to loop over references to containers instead of using explicit iteration methods\n-   --> $DIR/for_loop.rs:211:15\n+   --> $DIR/for_loop.rs:223:15\n     |\n-211 |     for _v in array.into_iter() {}\n+223 |     for _v in array.into_iter() {}\n     |               ^^^^^^^^^^^^^^^^^ help: to write this more concisely, try: `&array`\n \n error: it is more idiomatic to loop over references to containers instead of using explicit iteration methods\n-   --> $DIR/for_loop.rs:216:15\n+   --> $DIR/for_loop.rs:228:15\n     |\n-216 |     for _v in [1, 2, 3].iter() { }\n+228 |     for _v in [1, 2, 3].iter() {}\n     |               ^^^^^^^^^^^^^^^^ help: to write this more concisely, try: `&[1, 2, 3]`\n \n error: it is more idiomatic to loop over references to containers instead of using explicit iteration methods\n-   --> $DIR/for_loop.rs:220:15\n+   --> $DIR/for_loop.rs:232:15\n     |\n-220 |     for _v in [0; 32].iter() {}\n+232 |     for _v in [0; 32].iter() {}\n     |               ^^^^^^^^^^^^^^ help: to write this more concisely, try: `&[0; 32]`\n \n error: it is more idiomatic to loop over references to containers instead of using explicit iteration methods\n-   --> $DIR/for_loop.rs:225:15\n+   --> $DIR/for_loop.rs:237:15\n     |\n-225 |     for _v in ll.iter() { }\n+237 |     for _v in ll.iter() {}\n     |               ^^^^^^^^^ help: to write this more concisely, try: `&ll`\n \n error: it is more idiomatic to loop over references to containers instead of using explicit iteration methods\n-   --> $DIR/for_loop.rs:228:15\n+   --> $DIR/for_loop.rs:240:15\n     |\n-228 |     for _v in vd.iter() { }\n+240 |     for _v in vd.iter() {}\n     |               ^^^^^^^^^ help: to write this more concisely, try: `&vd`\n \n error: it is more idiomatic to loop over references to containers instead of using explicit iteration methods\n-   --> $DIR/for_loop.rs:231:15\n+   --> $DIR/for_loop.rs:243:15\n     |\n-231 |     for _v in bh.iter() { }\n+243 |     for _v in bh.iter() {}\n     |               ^^^^^^^^^ help: to write this more concisely, try: `&bh`\n \n error: it is more idiomatic to loop over references to containers instead of using explicit iteration methods\n-   --> $DIR/for_loop.rs:234:15\n+   --> $DIR/for_loop.rs:246:15\n     |\n-234 |     for _v in hm.iter() { }\n+246 |     for _v in hm.iter() {}\n     |               ^^^^^^^^^ help: to write this more concisely, try: `&hm`\n \n error: it is more idiomatic to loop over references to containers instead of using explicit iteration methods\n-   --> $DIR/for_loop.rs:237:15\n+   --> $DIR/for_loop.rs:249:15\n     |\n-237 |     for _v in bt.iter() { }\n+249 |     for _v in bt.iter() {}\n     |               ^^^^^^^^^ help: to write this more concisely, try: `&bt`\n \n error: it is more idiomatic to loop over references to containers instead of using explicit iteration methods\n-   --> $DIR/for_loop.rs:240:15\n+   --> $DIR/for_loop.rs:252:15\n     |\n-240 |     for _v in hs.iter() { }\n+252 |     for _v in hs.iter() {}\n     |               ^^^^^^^^^ help: to write this more concisely, try: `&hs`\n \n error: it is more idiomatic to loop over references to containers instead of using explicit iteration methods\n-   --> $DIR/for_loop.rs:243:15\n+   --> $DIR/for_loop.rs:255:15\n     |\n-243 |     for _v in bs.iter() { }\n+255 |     for _v in bs.iter() {}\n     |               ^^^^^^^^^ help: to write this more concisely, try: `&bs`\n \n error: you are iterating over `Iterator::next()` which is an Option; this will compile but is probably not what you want\n-   --> $DIR/for_loop.rs:245:5\n+   --> $DIR/for_loop.rs:257:5\n     |\n-245 |     for _v in vec.iter().next() { }\n-    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+257 |     for _v in vec.iter().next() {}\n+    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: you are collect()ing an iterator and throwing away the result. Consider using an explicit for loop to exhaust the iterator\n-   --> $DIR/for_loop.rs:252:5\n+   --> $DIR/for_loop.rs:264:5\n     |\n-252 |     vec.iter().cloned().map(|x| out.push(x)).collect::<Vec<_>>();\n+264 |     vec.iter().cloned().map(|x| out.push(x)).collect::<Vec<_>>();\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `-D unused-collect` implied by `-D warnings`\n \n error: the variable `_index` is used as a loop counter. Consider using `for (_index, item) in &vec.enumerate()` or similar iterators\n-   --> $DIR/for_loop.rs:257:5\n+   --> $DIR/for_loop.rs:269:5\n     |\n-257 |     for _v in &vec { _index += 1 }\n-    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+269 | /     for _v in &vec {\n+270 | |         _index += 1\n+271 | |     }\n+    | |_____^\n     |\n     = note: `-D explicit-counter-loop` implied by `-D warnings`\n \n error: the variable `_index` is used as a loop counter. Consider using `for (_index, item) in &vec.enumerate()` or similar iterators\n-   --> $DIR/for_loop.rs:261:5\n+   --> $DIR/for_loop.rs:275:5\n     |\n-261 |     for _v in &vec { _index += 1 }\n-    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+275 | /     for _v in &vec {\n+276 | |         _index += 1\n+277 | |     }\n+    | |_____^\n \n error: you seem to want to iterate on a map's values\n-   --> $DIR/for_loop.rs:321:5\n+   --> $DIR/for_loop.rs:385:5\n     |\n-321 | /     for (_, v) in &m {\n-322 | |         let _v = v;\n-323 | |     }\n+385 | /     for (_, v) in &m {\n+386 | |         let _v = v;\n+387 | |     }\n     | |_____^\n     |\n     = note: `-D for-kv-map` implied by `-D warnings`\n help: use the corresponding method\n     |\n-321 |     for v in m.values() {\n+385 |     for v in m.values() {\n     |         ^\n \n error: you seem to want to iterate on a map's values\n-   --> $DIR/for_loop.rs:326:5\n-    |\n-326 | /     for (_, v) in &*m {\n-327 | |         let _v = v;\n-328 | |         // Here the `*` is not actually necesarry, but the test tests that we don't suggest\n-329 | |         // `in *m.values()` as we used to\n-330 | |     }\n+   --> $DIR/for_loop.rs:390:5\n+    |\n+390 | /     for (_, v) in &*m {\n+391 | |         let _v = v;\n+392 | |         // Here the `*` is not actually necesarry, but the test tests that we don't\n+393 | |         // suggest\n+394 | |         // `in *m.values()` as we used to\n+395 | |     }\n     | |_____^\n     |\n help: use the corresponding method\n     |\n-326 |     for v in (*m).values() {\n+390 |     for v in (*m).values() {\n     |         ^\n \n error: you seem to want to iterate on a map's values\n-   --> $DIR/for_loop.rs:333:5\n+   --> $DIR/for_loop.rs:398:5\n     |\n-333 | /     for (_, v) in &mut m {\n-334 | |         let _v = v;\n-335 | |     }\n+398 | /     for (_, v) in &mut m {\n+399 | |         let _v = v;\n+400 | |     }\n     | |_____^\n     |\n help: use the corresponding method\n     |\n-333 |     for v in m.values_mut() {\n+398 |     for v in m.values_mut() {\n     |         ^\n \n error: you seem to want to iterate on a map's values\n-   --> $DIR/for_loop.rs:338:5\n+   --> $DIR/for_loop.rs:403:5\n     |\n-338 | /     for (_, v) in &mut *m {\n-339 | |         let _v = v;\n-340 | |     }\n+403 | /     for (_, v) in &mut *m {\n+404 | |         let _v = v;\n+405 | |     }\n     | |_____^\n     |\n help: use the corresponding method\n     |\n-338 |     for v in (*m).values_mut() {\n+403 |     for v in (*m).values_mut() {\n     |         ^\n \n error: you seem to want to iterate on a map's keys\n-   --> $DIR/for_loop.rs:344:5\n+   --> $DIR/for_loop.rs:409:5\n     |\n-344 | /     for (k, _value) in rm {\n-345 | |         let _k = k;\n-346 | |     }\n+409 | /     for (k, _value) in rm {\n+410 | |         let _k = k;\n+411 | |     }\n     | |_____^\n     |\n help: use the corresponding method\n     |\n-344 |     for k in rm.keys() {\n+409 |     for k in rm.keys() {\n     |         ^\n \n-error: aborting due to 50 previous errors\n+error: it looks like you're manually copying between slices\n+   --> $DIR/for_loop.rs:462:5\n+    |\n+462 | /     for i in 0..src.len() {\n+463 | |         dst[i] = src[i];\n+464 | |     }\n+    | |_____^ help: try replacing the loop by: `dst[..src.len()].clone_from_slice(&src[..])`\n+    |\n+    = note: `-D manual-memcpy` implied by `-D warnings`\n+\n+error: it looks like you're manually copying between slices\n+   --> $DIR/for_loop.rs:467:5\n+    |\n+467 | /     for i in 0..src.len() {\n+468 | |         dst[i + 10] = src[i];\n+469 | |     }\n+    | |_____^ help: try replacing the loop by: `dst[10..(src.len() + 10)].clone_from_slice(&src[..])`\n+\n+error: it looks like you're manually copying between slices\n+   --> $DIR/for_loop.rs:472:5\n+    |\n+472 | /     for i in 0..src.len() {\n+473 | |         dst[i] = src[i + 10];\n+474 | |     }\n+    | |_____^ help: try replacing the loop by: `dst[..src.len()].clone_from_slice(&src[10..])`\n+\n+error: it looks like you're manually copying between slices\n+   --> $DIR/for_loop.rs:477:5\n+    |\n+477 | /     for i in 11..src.len() {\n+478 | |         dst[i] = src[i - 10];\n+479 | |     }\n+    | |_____^ help: try replacing the loop by: `dst[11..src.len()].clone_from_slice(&src[(11 - 10)..(src.len() - 10)])`\n+\n+error: it looks like you're manually copying between slices\n+   --> $DIR/for_loop.rs:482:5\n+    |\n+482 | /     for i in 0..dst.len() {\n+483 | |         dst[i] = src[i];\n+484 | |     }\n+    | |_____^ help: try replacing the loop by: `dst.clone_from_slice(&src[..dst.len()])`\n+\n+error: it looks like you're manually copying between slices\n+   --> $DIR/for_loop.rs:495:5\n+    |\n+495 | /     for i in 10..256 {\n+496 | |         dst[i] = src[i - 5];\n+497 | |         dst2[i + 500] = src[i]\n+498 | |     }\n+    | |_____^\n+    |\n+help: try replacing the loop by\n+    |\n+495 |     dst[10..256].clone_from_slice(&src[(10 - 5)..(256 - 5)])\n+496 |     dst2[(10 + 500)..(256 + 500)].clone_from_slice(&src[10..256])\n+    |\n+\n+error: it looks like you're manually copying between slices\n+   --> $DIR/for_loop.rs:507:5\n+    |\n+507 | /     for i in 10..LOOP_OFFSET {\n+508 | |         dst[i + LOOP_OFFSET] = src[i - some_var];\n+509 | |     }\n+    | |_____^ help: try replacing the loop by: `dst[(10 + LOOP_OFFSET)..(LOOP_OFFSET + LOOP_OFFSET)].clone_from_slice(&src[(10 - some_var)..(LOOP_OFFSET - some_var)])`\n+\n+error: it looks like you're manually copying between slices\n+   --> $DIR/for_loop.rs:520:5\n+    |\n+520 | /     for i in 0..src_vec.len() {\n+521 | |         dst_vec[i] = src_vec[i];\n+522 | |     }\n+    | |_____^ help: try replacing the loop by: `dst_vec[..src_vec.len()].clone_from_slice(&src_vec[..])`\n+\n+error: aborting due to 58 previous errors\n "}]}