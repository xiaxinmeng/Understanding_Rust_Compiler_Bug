{"sha": "bd2b6c40bca71687c5e0d4d15224acd43f647cc6", "node_id": "C_kwDOAAsO6NoAKGJkMmI2YzQwYmNhNzE2ODdjNWUwZDRkMTUyMjRhY2Q0M2Y2NDdjYzY", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-02-22T10:12:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-22T10:12:30Z"}, "message": "Merge #11513\n\n11513: internal: Expand the derive attribute into a pseudo expansion r=Veykril a=Veykril\n\nQuoting my comment:\r\n\r\n> We generate a very specific expansion here, as we do not actually expand the `#[derive]` attribute\r\n> itself in name res, but we do want to expand it to something for the IDE layer, so that the input\r\n> derive attributes can be downmapped, and resolved as proper paths.\r\n> This is basically a hack, that simplifies the hacks we need in a lot of ide layer places to\r\n> somewhat inconsistently resolve derive attributes.\r\n> \r\n> As such, we expand `#[derive(Foo, bar::Bar)]` into\r\n> ```\r\n>  #[Foo]\r\n>  #[bar::Bar]\r\n>  ();\r\n> ```\r\n> which allows fallback path resolution in hir::Semantics to properly identify our derives.\r\n> Since we do not expand the attribute in nameres though, we keep the original item.\r\n> \r\n> The ideal expansion here would be for the `#[derive]` to re-emit the annotated item and somehow\r\n> use the input paths in its output as well.\r\n> But that would bring two problems with it, for one every derive would duplicate the item token tree\r\n> wasting a lot of memory, and it would also require some way to use a path in a way that makes it\r\n> always resolve as a derive without nameres recollecting them.\r\n> So this hacky approach is a lot more friendly for us, though it does require a bit of support in\r\n> [`hir::Semantics`] to make this work.\r\n\r\n\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "21538ad7d3af0e7f04fcf2117cf5639dffee32cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21538ad7d3af0e7f04fcf2117cf5639dffee32cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd2b6c40bca71687c5e0d4d15224acd43f647cc6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiFLcOCRBK7hj4Ov3rIwAAimIIAK3gfUppfMT2ptdBJF4mMb8w\n/y/CxFsDxEA+duPQPrC1g2FPUkTnOC1yuFf1Id8T2tue3UQXlAPvBMq9ObZDdEIx\nfMTeyGgf45dmBbgADUNwt4LQgtOfE2x8RuVrXP2CJX+/5jAL/aP4Vb/NqeIc1JVg\n60iZOetP8+NFSsQU06t7cxGzsKOZelc5sSoBw6N/0V6bI01WiZZNU7Luz8XFAK3+\nKnbnJIm78mFibNrLCiv2QpJrAcSAHfPXWPP4S79ArGYuT1ILi/+9y+axS/FpbsKt\nQQYF6jk8u35be4Bgbj0g+FoLIXE0iOTWBQsSxK3o/bW1aUf8MZDWuaKbhbT+ua0=\n=q2ns\n-----END PGP SIGNATURE-----\n", "payload": "tree 21538ad7d3af0e7f04fcf2117cf5639dffee32cc\nparent 1fe3b2edd68889489d2702507ac0ba22a5126adf\nparent b494795a423d91c8db06d09d6c6dc62840796e8d\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1645524750 +0000\ncommitter GitHub <noreply@github.com> 1645524750 +0000\n\nMerge #11513\n\n11513: internal: Expand the derive attribute into a pseudo expansion r=Veykril a=Veykril\n\nQuoting my comment:\r\n\r\n> We generate a very specific expansion here, as we do not actually expand the `#[derive]` attribute\r\n> itself in name res, but we do want to expand it to something for the IDE layer, so that the input\r\n> derive attributes can be downmapped, and resolved as proper paths.\r\n> This is basically a hack, that simplifies the hacks we need in a lot of ide layer places to\r\n> somewhat inconsistently resolve derive attributes.\r\n> \r\n> As such, we expand `#[derive(Foo, bar::Bar)]` into\r\n> ```\r\n>  #[Foo]\r\n>  #[bar::Bar]\r\n>  ();\r\n> ```\r\n> which allows fallback path resolution in hir::Semantics to properly identify our derives.\r\n> Since we do not expand the attribute in nameres though, we keep the original item.\r\n> \r\n> The ideal expansion here would be for the `#[derive]` to re-emit the annotated item and somehow\r\n> use the input paths in its output as well.\r\n> But that would bring two problems with it, for one every derive would duplicate the item token tree\r\n> wasting a lot of memory, and it would also require some way to use a path in a way that makes it\r\n> always resolve as a derive without nameres recollecting them.\r\n> So this hacky approach is a lot more friendly for us, though it does require a bit of support in\r\n> [`hir::Semantics`] to make this work.\r\n\r\n\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd2b6c40bca71687c5e0d4d15224acd43f647cc6", "html_url": "https://github.com/rust-lang/rust/commit/bd2b6c40bca71687c5e0d4d15224acd43f647cc6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1fe3b2edd68889489d2702507ac0ba22a5126adf", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fe3b2edd68889489d2702507ac0ba22a5126adf", "html_url": "https://github.com/rust-lang/rust/commit/1fe3b2edd68889489d2702507ac0ba22a5126adf"}, {"sha": "b494795a423d91c8db06d09d6c6dc62840796e8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b494795a423d91c8db06d09d6c6dc62840796e8d", "html_url": "https://github.com/rust-lang/rust/commit/b494795a423d91c8db06d09d6c6dc62840796e8d"}], "stats": {"total": 747, "additions": 419, "deletions": 328}, "files": [{"sha": "9f89bcf9c3d0b33ffad864d76be67972d2aa477e", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=bd2b6c40bca71687c5e0d4d15224acd43f647cc6", "patch": "@@ -1792,6 +1792,10 @@ impl MacroDef {\n         }\n     }\n \n+    pub fn is_builtin_derive(&self) -> bool {\n+        matches!(self.id.kind, MacroDefKind::BuiltInAttr(exp, _) if exp.is_derive())\n+    }\n+\n     pub fn is_attr(&self) -> bool {\n         matches!(self.kind(), MacroKind::Attr)\n     }\n@@ -2426,24 +2430,7 @@ impl Impl {\n \n     pub fn is_builtin_derive(self, db: &dyn HirDatabase) -> Option<InFile<ast::Attr>> {\n         let src = self.source(db)?;\n-        let item = src.file_id.is_builtin_derive(db.upcast())?;\n-        let hygenic = hir_expand::hygiene::Hygiene::new(db.upcast(), item.file_id);\n-\n-        // FIXME: handle `cfg_attr`\n-        let attr = item\n-            .value\n-            .attrs()\n-            .filter_map(|it| {\n-                let path = ModPath::from_src(db.upcast(), it.path()?, &hygenic)?;\n-                if path.as_ident()?.to_smol_str() == \"derive\" {\n-                    Some(it)\n-                } else {\n-                    None\n-                }\n-            })\n-            .last()?;\n-\n-        Some(item.with_value(attr))\n+        src.file_id.is_builtin_derive(db.upcast())\n     }\n }\n "}, {"sha": "20c360e302ee274929ff1a377fba6c13599cc308", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 45, "deletions": 82, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=bd2b6c40bca71687c5e0d4d15224acd43f647cc6", "patch": "@@ -5,7 +5,6 @@ mod source_to_def;\n use std::{cell::RefCell, fmt, iter};\n \n use base_db::{FileId, FileRange};\n-use either::Either;\n use hir_def::{\n     body,\n     resolver::{self, HasResolver, Resolver, TypeNs},\n@@ -19,17 +18,16 @@ use smallvec::{smallvec, SmallVec};\n use syntax::{\n     algo::skip_trivia_token,\n     ast::{self, HasAttrs as _, HasGenericParams, HasLoopBody},\n-    match_ast, AstNode, AstToken, Direction, SyntaxElement, SyntaxNode, SyntaxNodePtr, SyntaxToken,\n-    TextSize, T,\n+    match_ast, AstNode, Direction, SyntaxNode, SyntaxNodePtr, SyntaxToken, TextSize,\n };\n \n use crate::{\n     db::HirDatabase,\n     semantics::source_to_def::{ChildContainer, SourceToDefCache, SourceToDefCtx},\n     source_analyzer::{resolve_hir_path, SourceAnalyzer},\n-    Access, AssocItem, BuiltinAttr, Callable, ConstParam, Crate, Field, Function, HasAttrs as _,\n-    HasSource, HirFileId, Impl, InFile, Label, LifetimeParam, Local, MacroDef, Module, ModuleDef,\n-    Name, Path, ScopeDef, ToolModule, Trait, Type, TypeAlias, TypeParam, VariantDef,\n+    Access, AssocItem, BuiltinAttr, Callable, ConstParam, Crate, Field, Function, HasSource,\n+    HirFileId, Impl, InFile, Label, LifetimeParam, Local, MacroDef, Module, ModuleDef, Name, Path,\n+    ScopeDef, ToolModule, Trait, Type, TypeAlias, TypeParam, VariantDef,\n };\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -162,6 +160,10 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.is_attr_macro_call(item)\n     }\n \n+    pub fn is_derive_annotated(&self, item: &ast::Adt) -> bool {\n+        self.imp.is_derive_annotated(item)\n+    }\n+\n     pub fn speculative_expand(\n         &self,\n         actual_macro_call: &ast::MacroCall,\n@@ -350,14 +352,6 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.resolve_bind_pat_to_const(pat)\n     }\n \n-    pub fn resolve_derive_ident(\n-        &self,\n-        derive: &ast::Attr,\n-        ident: &ast::Ident,\n-    ) -> Option<PathResolution> {\n-        self.imp.resolve_derive_ident(derive, ident)\n-    }\n-\n     pub fn record_literal_missing_fields(&self, literal: &ast::RecordExpr) -> Vec<(Field, Type)> {\n         self.imp.record_literal_missing_fields(literal)\n     }\n@@ -475,11 +469,17 @@ impl<'db> SemanticsImpl<'db> {\n         let adt = InFile::new(file_id, &adt);\n         let src = InFile::new(file_id, attr.clone());\n         self.with_ctx(|ctx| {\n-            let (_, res) = ctx.attr_to_derive_macro_call(adt, src)?;\n+            let (.., res) = ctx.attr_to_derive_macro_call(adt, src)?;\n             Some(res.to_vec())\n         })\n     }\n \n+    fn is_derive_annotated(&self, adt: &ast::Adt) -> bool {\n+        let file_id = self.find_file(adt.syntax()).file_id;\n+        let adt = InFile::new(file_id, adt);\n+        self.with_ctx(|ctx| ctx.has_derives(adt))\n+    }\n+\n     fn is_attr_macro_call(&self, item: &ast::Item) -> bool {\n         let file_id = self.find_file(item.syntax()).file_id;\n         let src = InFile::new(file_id, item.clone());\n@@ -668,7 +668,36 @@ impl<'db> SemanticsImpl<'db> {\n                     // FIXME replace map.while_some with take_while once stable\n                     token.value.ancestors().map(ast::TokenTree::cast).while_some().last()\n                 {\n-                    let macro_call = tt.syntax().parent().and_then(ast::MacroCall::cast)?;\n+                    let parent = tt.syntax().parent()?;\n+                    // check for derive attribute here\n+                    let macro_call = match_ast! {\n+                        match parent {\n+                            ast::MacroCall(mcall) => mcall,\n+                            // attribute we failed expansion for earlier, this might be a derive invocation\n+                            // so try downmapping the token into the pseudo derive expansion\n+                            // see [hir_expand::builtin_attr_macro] for how the pseudo derive expansion works\n+                            ast::Meta(meta) => {\n+                                let attr = meta.parent_attr()?;\n+                                let adt = attr.syntax().parent().and_then(ast::Adt::cast)?;\n+                                let call_id = self.with_ctx(|ctx| {\n+                                    let (_, call_id, _) = ctx.attr_to_derive_macro_call(\n+                                        token.with_value(&adt),\n+                                        token.with_value(attr),\n+                                    )?;\n+                                    Some(call_id)\n+                                })?;\n+                                let file_id = call_id.as_file();\n+                                return process_expansion_for_token(\n+                                    &mut stack,\n+                                    file_id,\n+                                    Some(adt.into()),\n+                                    token.as_ref(),\n+                                );\n+                            },\n+                            _ => return None,\n+                        }\n+                    };\n+\n                     if tt.left_delimiter_token().map_or(false, |it| it == token.value) {\n                         return None;\n                     }\n@@ -898,72 +927,6 @@ impl<'db> SemanticsImpl<'db> {\n         self.analyze(pat.syntax()).resolve_bind_pat_to_const(self.db, pat)\n     }\n \n-    fn resolve_derive_ident(\n-        &self,\n-        derive: &ast::Attr,\n-        ident: &ast::Ident,\n-    ) -> Option<PathResolution> {\n-        debug_assert!(ident.syntax().parent().and_then(ast::TokenTree::cast).is_some());\n-        debug_assert!(ident.syntax().ancestors().any(|anc| anc == *derive.syntax()));\n-        // derive macros are always at depth 2, tokentree -> meta -> attribute\n-        let syntax = ident.syntax();\n-\n-        let tt = derive.token_tree()?;\n-        let file = self.find_file(derive.syntax());\n-        let adt = derive.syntax().parent().and_then(ast::Adt::cast)?;\n-        let adt_def = ToDef::to_def(self, file.with_value(adt.clone()))?;\n-        let res = self.with_ctx(|ctx| {\n-            let (attr_id, derives) = ctx.attr_to_derive_macro_call(\n-                file.with_value(&adt),\n-                file.with_value(derive.clone()),\n-            )?;\n-            let attrs = adt_def.attrs(self.db);\n-            let mut derive_paths = attrs.get(attr_id)?.parse_path_comma_token_tree()?;\n-\n-            let derive_idx = tt\n-                .syntax()\n-                .children_with_tokens()\n-                .filter_map(SyntaxElement::into_token)\n-                .take_while(|tok| tok != syntax)\n-                .filter(|t| t.kind() == T![,])\n-                .count();\n-            let path_segment_idx = syntax\n-                .siblings_with_tokens(Direction::Prev)\n-                .filter_map(SyntaxElement::into_token)\n-                .take_while(|tok| matches!(tok.kind(), T![:] | T![ident]))\n-                .filter(|tok| tok.kind() == T![ident])\n-                .count();\n-\n-            let mut mod_path = derive_paths.nth(derive_idx)?;\n-\n-            if path_segment_idx < mod_path.len() {\n-                // the path for the given ident is a qualifier, resolve to module if possible\n-                while path_segment_idx < mod_path.len() {\n-                    mod_path.pop_segment();\n-                }\n-                Some(Either::Left(mod_path))\n-            } else {\n-                // otherwise fetch the derive\n-                Some(Either::Right(derives[derive_idx]))\n-            }\n-        })?;\n-\n-        match res {\n-            Either::Left(path) => {\n-                let len = path.len();\n-                resolve_hir_path(\n-                    self.db,\n-                    &self.scope(derive.syntax()).resolver,\n-                    &Path::from_known_path(path, vec![None; len]),\n-                )\n-                .filter(|res| matches!(res, PathResolution::Def(ModuleDef::Module(_))))\n-            }\n-            Either::Right(derive) => derive\n-                .map(|call| MacroDef { id: self.db.lookup_intern_macro_call(call).def })\n-                .map(PathResolution::Macro),\n-        }\n-    }\n-\n     fn record_literal_missing_fields(&self, literal: &ast::RecordExpr) -> Vec<(Field, Type)> {\n         self.analyze(literal.syntax())\n             .record_literal_missing_fields(self.db, literal)"}, {"sha": "dddb8e33dcc0b4a8f91021dcbc964bf3dea5ee95", "filename": "crates/hir/src/semantics/source_to_def.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs?ref=bd2b6c40bca71687c5e0d4d15224acd43f647cc6", "patch": "@@ -249,9 +249,14 @@ impl SourceToDefCtx<'_, '_> {\n         &mut self,\n         item: InFile<&ast::Adt>,\n         src: InFile<ast::Attr>,\n-    ) -> Option<(AttrId, &[Option<MacroCallId>])> {\n+    ) -> Option<(AttrId, MacroCallId, &[Option<MacroCallId>])> {\n         let map = self.dyn_map(item)?;\n-        map[keys::DERIVE_MACRO_CALL].get(&src.value).map(|(id, ids)| (*id, &**ids))\n+        map[keys::DERIVE_MACRO_CALL]\n+            .get(&src.value)\n+            .map(|&(attr_id, call_id, ref ids)| (attr_id, call_id, &**ids))\n+    }\n+    pub(super) fn has_derives(&mut self, adt: InFile<&ast::Adt>) -> bool {\n+        self.dyn_map(adt).as_ref().map_or(false, |map| !map[keys::DERIVE_MACRO_CALL].is_empty())\n     }\n \n     fn to_def<Ast: AstNode + 'static, ID: Copy + 'static>("}, {"sha": "ef32a5891c78ea54fca9ff43b5ac17cb9d62f3b6", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=bd2b6c40bca71687c5e0d4d15224acd43f647cc6", "patch": "@@ -371,10 +371,10 @@ impl SourceAnalyzer {\n                 return builtin.map(PathResolution::BuiltinAttr);\n             }\n             return match resolve_hir_path_as_macro(db, &self.resolver, &hir_path) {\n-                res @ Some(m) if m.is_attr() => res.map(PathResolution::Macro),\n+                Some(m) => Some(PathResolution::Macro(m)),\n                 // this labels any path that starts with a tool module as the tool itself, this is technically wrong\n                 // but there is no benefit in differentiating these two cases for the time being\n-                _ => path.first_segment().and_then(|it| it.name_ref()).and_then(|name_ref| {\n+                None => path.first_segment().and_then(|it| it.name_ref()).and_then(|name_ref| {\n                     match self.resolver.krate() {\n                         Some(krate) => ToolModule::by_name(db, krate.into(), &name_ref.text()),\n                         None => ToolModule::builtin(&name_ref.text()),"}, {"sha": "1e1573d4ae0977e55e13d30f56b4aa9b41361fc8", "filename": "crates/hir_def/src/child_by_source.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs?ref=bd2b6c40bca71687c5e0d4d15224acd43f647cc6", "patch": "@@ -116,11 +116,11 @@ impl ChildBySource for ItemScope {\n         self.derive_macro_invocs().filter(|(id, _)| id.file_id == file_id).for_each(\n             |(ast_id, calls)| {\n                 let adt = ast_id.to_node(db.upcast());\n-                calls.for_each(|(attr_id, calls)| {\n+                calls.for_each(|(attr_id, call_id, calls)| {\n                     if let Some(Either::Left(attr)) =\n                         adt.doc_comments_and_attrs().nth(attr_id.ast_index as usize)\n                     {\n-                        res[keys::DERIVE_MACRO_CALL].insert(attr, (attr_id, calls.into()));\n+                        res[keys::DERIVE_MACRO_CALL].insert(attr, (attr_id, call_id, calls.into()));\n                     }\n                 });\n             },"}, {"sha": "166aa04da044ff71dbd7c5c010413fc002b3a865", "filename": "crates/hir_def/src/dyn_map.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fhir_def%2Fsrc%2Fdyn_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fhir_def%2Fsrc%2Fdyn_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdyn_map.rs?ref=bd2b6c40bca71687c5e0d4d15224acd43f647cc6", "patch": "@@ -54,6 +54,7 @@ pub trait Policy {\n \n     fn insert(map: &mut DynMap, key: Self::K, value: Self::V);\n     fn get<'a>(map: &'a DynMap, key: &Self::K) -> Option<&'a Self::V>;\n+    fn is_empty(map: &DynMap) -> bool;\n }\n \n impl<K: Hash + Eq + 'static, V: 'static> Policy for (K, V) {\n@@ -65,6 +66,9 @@ impl<K: Hash + Eq + 'static, V: 'static> Policy for (K, V) {\n     fn get<'a>(map: &'a DynMap, key: &K) -> Option<&'a V> {\n         map.map.get::<FxHashMap<K, V>>()?.get(key)\n     }\n+    fn is_empty(map: &DynMap) -> bool {\n+        map.map.get::<FxHashMap<K, V>>().map_or(true, |it| it.is_empty())\n+    }\n }\n \n pub struct DynMap {\n@@ -90,6 +94,10 @@ impl<P: Policy> KeyMap<Key<P::K, P::V, P>> {\n     pub fn get(&self, key: &P::K) -> Option<&P::V> {\n         P::get(&self.map, key)\n     }\n+\n+    pub fn is_empty(&self) -> bool {\n+        P::is_empty(&self.map)\n+    }\n }\n \n impl<P: Policy> Index<Key<P::K, P::V, P>> for DynMap {"}, {"sha": "fffec96bab90f388a0d31d028b114e4accc3a866", "filename": "crates/hir_def/src/item_scope.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs?ref=bd2b6c40bca71687c5e0d4d15224acd43f647cc6", "patch": "@@ -66,8 +66,10 @@ pub struct ItemScope {\n     attr_macros: FxHashMap<AstId<ast::Item>, MacroCallId>,\n     /// The derive macro invocations in this scope, keyed by the owner item over the actual derive attributes\n     /// paired with the derive macro invocations for the specific attribute.\n-    derive_macros:\n-        FxHashMap<AstId<ast::Adt>, SmallVec<[(AttrId, SmallVec<[Option<MacroCallId>; 1]>); 1]>>,\n+    derive_macros: FxHashMap<\n+        AstId<ast::Adt>,\n+        SmallVec<[(AttrId, MacroCallId, SmallVec<[Option<MacroCallId>; 1]>); 1]>,\n+    >,\n }\n \n pub(crate) static BUILTIN_SCOPE: Lazy<FxHashMap<Name, PerNs>> = Lazy::new(|| {\n@@ -210,7 +212,7 @@ impl ItemScope {\n         idx: usize,\n     ) {\n         if let Some(derives) = self.derive_macros.get_mut(&adt) {\n-            if let Some((_, invocs)) = derives.iter_mut().find(|&&mut (id, _)| id == attr_id) {\n+            if let Some((.., invocs)) = derives.iter_mut().find(|&&mut (id, ..)| id == attr_id) {\n                 invocs[idx] = Some(call);\n             }\n         }\n@@ -223,19 +225,23 @@ impl ItemScope {\n         &mut self,\n         adt: AstId<ast::Adt>,\n         attr_id: AttrId,\n+        call_id: MacroCallId,\n         len: usize,\n     ) {\n-        self.derive_macros.entry(adt).or_default().push((attr_id, smallvec![None; len]));\n+        self.derive_macros.entry(adt).or_default().push((attr_id, call_id, smallvec![None; len]));\n     }\n \n     pub(crate) fn derive_macro_invocs(\n         &self,\n     ) -> impl Iterator<\n-        Item = (AstId<ast::Adt>, impl Iterator<Item = (AttrId, &[Option<MacroCallId>])>),\n+        Item = (\n+            AstId<ast::Adt>,\n+            impl Iterator<Item = (AttrId, MacroCallId, &[Option<MacroCallId>])>,\n+        ),\n     > + '_ {\n-        self.derive_macros\n-            .iter()\n-            .map(|(k, v)| (*k, v.iter().map(|(attr_id, invocs)| (*attr_id, &**invocs))))\n+        self.derive_macros.iter().map(|(k, v)| {\n+            (*k, v.iter().map(|&(attr_id, call_id, ref invocs)| (attr_id, call_id, &**invocs)))\n+        })\n     }\n \n     pub(crate) fn unnamed_trait_vis(&self, tr: TraitId) -> Option<Visibility> {"}, {"sha": "8cd2d771721493061b0f6acec96dfa7c9a820dc8", "filename": "crates/hir_def/src/keys.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fhir_def%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fhir_def%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fkeys.rs?ref=bd2b6c40bca71687c5e0d4d15224acd43f647cc6", "patch": "@@ -34,7 +34,8 @@ pub const CONST_PARAM: Key<ast::ConstParam, ConstParamId> = Key::new();\n \n pub const MACRO: Key<ast::Macro, MacroDefId> = Key::new();\n pub const ATTR_MACRO_CALL: Key<ast::Item, MacroCallId> = Key::new();\n-pub const DERIVE_MACRO_CALL: Key<ast::Attr, (AttrId, Box<[Option<MacroCallId>]>)> = Key::new();\n+pub const DERIVE_MACRO_CALL: Key<ast::Attr, (AttrId, MacroCallId, Box<[Option<MacroCallId>]>)> =\n+    Key::new();\n \n /// XXX: AST Nodes and SyntaxNodes have identity equality semantics: nodes are\n /// equal if they point to exactly the same object.\n@@ -60,4 +61,7 @@ impl<AST: AstNode + 'static, ID: 'static> Policy for AstPtrPolicy<AST, ID> {\n         let key = AstPtr::new(key);\n         map.map.get::<FxHashMap<AstPtr<AST>, ID>>()?.get(&key)\n     }\n+    fn is_empty(map: &DynMap) -> bool {\n+        map.map.get::<FxHashMap<AstPtr<AST>, ID>>().map_or(true, |it| it.is_empty())\n+    }\n }"}, {"sha": "bb65d1dec87d4610a1ed49198abf9f187fbfeb71", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=bd2b6c40bca71687c5e0d4d15224acd43f647cc6", "patch": "@@ -690,9 +690,9 @@ impl AsMacroCall for InFile<&ast::MacroCall> {\n         };\n \n         macro_call_as_call_id(\n+            db,\n             &AstIdWithPath::new(ast_id.file_id, ast_id.value, path),\n             expands_to,\n-            db,\n             krate,\n             resolver,\n             error_sink,\n@@ -714,9 +714,9 @@ impl<T: ast::AstNode> AstIdWithPath<T> {\n }\n \n fn macro_call_as_call_id(\n+    db: &dyn db::DefDatabase,\n     call: &AstIdWithPath<ast::MacroCall>,\n     expand_to: ExpandTo,\n-    db: &dyn db::DefDatabase,\n     krate: CrateId,\n     resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n     error_sink: &mut dyn FnMut(ExpandError),\n@@ -739,10 +739,10 @@ fn macro_call_as_call_id(\n }\n \n fn derive_macro_as_call_id(\n+    db: &dyn db::DefDatabase,\n     item_attr: &AstIdWithPath<ast::Adt>,\n     derive_attr: AttrId,\n     derive_pos: u32,\n-    db: &dyn db::DefDatabase,\n     krate: CrateId,\n     resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n ) -> Result<MacroCallId, UnresolvedMacro> {\n@@ -761,11 +761,12 @@ fn derive_macro_as_call_id(\n }\n \n fn attr_macro_as_call_id(\n+    db: &dyn db::DefDatabase,\n     item_attr: &AstIdWithPath<ast::Item>,\n     macro_attr: &Attr,\n-    db: &dyn db::DefDatabase,\n     krate: CrateId,\n     def: MacroDefId,\n+    is_derive: bool,\n ) -> MacroCallId {\n     let mut arg = match macro_attr.input.as_deref() {\n         Some(attr::AttrInput::TokenTree(tt, map)) => (tt.clone(), map.clone()),\n@@ -782,6 +783,7 @@ fn attr_macro_as_call_id(\n             ast_id: item_attr.ast_id,\n             attr_args: Arc::new(arg),\n             invoc_attr_index: macro_attr.id.ast_index,\n+            is_derive,\n         },\n     );\n     res"}, {"sha": "4c436250db3cba54dec642b33c6409c9d27fb488", "filename": "crates/hir_def/src/nameres/attr_resolution.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fhir_def%2Fsrc%2Fnameres%2Fattr_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fhir_def%2Fsrc%2Fnameres%2Fattr_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fattr_resolution.rs?ref=bd2b6c40bca71687c5e0d4d15224acd43f647cc6", "patch": "@@ -54,7 +54,7 @@ impl DefMap {\n             None => return Err(UnresolvedMacro { path: ast_id.path.clone() }),\n         };\n \n-        Ok(ResolvedAttr::Macro(attr_macro_as_call_id(&ast_id, attr, db, self.krate, def)))\n+        Ok(ResolvedAttr::Macro(attr_macro_as_call_id(db, &ast_id, attr, self.krate, def, false)))\n     }\n \n     pub(crate) fn is_builtin_or_registered_attr(&self, path: &ModPath) -> bool {"}, {"sha": "2dd7cc485969f064765bab516c27ab5bb7271eaa", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=bd2b6c40bca71687c5e0d4d15224acd43f647cc6", "patch": "@@ -1055,9 +1055,9 @@ impl DefCollector<'_> {\n             match &directive.kind {\n                 MacroDirectiveKind::FnLike { ast_id, expand_to } => {\n                     let call_id = macro_call_as_call_id(\n+                        self.db,\n                         ast_id,\n                         *expand_to,\n-                        self.db,\n                         self.def_map.krate,\n                         &resolver,\n                         &mut |_err| (),\n@@ -1070,10 +1070,10 @@ impl DefCollector<'_> {\n                 }\n                 MacroDirectiveKind::Derive { ast_id, derive_attr, derive_pos } => {\n                     let call_id = derive_macro_as_call_id(\n+                        self.db,\n                         ast_id,\n                         *derive_attr,\n                         *derive_pos as u32,\n-                        self.db,\n                         self.def_map.krate,\n                         &resolver,\n                     );\n@@ -1170,9 +1170,20 @@ impl DefCollector<'_> {\n                                     len = idx;\n                                 }\n \n+                                // We treat the #[derive] macro as an attribute call, but we do not resolve it for nameres collection.\n+                                // This is just a trick to be able to resolve the input to derives as proper paths.\n+                                // Check the comment in [`builtin_attr_macro`].\n+                                let call_id = attr_macro_as_call_id(\n+                                    self.db,\n+                                    file_ast_id,\n+                                    attr,\n+                                    self.def_map.krate,\n+                                    def,\n+                                    true,\n+                                );\n                                 self.def_map.modules[directive.module_id]\n                                     .scope\n-                                    .init_derive_attribute(ast_id, attr.id, len + 1);\n+                                    .init_derive_attribute(ast_id, attr.id, call_id, len + 1);\n                             }\n                             None => {\n                                 let diag = DefDiagnostic::malformed_derive(\n@@ -1192,8 +1203,14 @@ impl DefCollector<'_> {\n                     }\n \n                     // Not resolved to a derive helper or the derive attribute, so try to treat as a normal attribute.\n-                    let call_id =\n-                        attr_macro_as_call_id(file_ast_id, attr, self.db, self.def_map.krate, def);\n+                    let call_id = attr_macro_as_call_id(\n+                        self.db,\n+                        file_ast_id,\n+                        attr,\n+                        self.def_map.krate,\n+                        def,\n+                        false,\n+                    );\n                     let loc: MacroCallLoc = self.db.lookup_intern_macro_call(call_id);\n \n                     // Skip #[test]/#[bench] expansion, which would merely result in more memory usage\n@@ -1310,9 +1327,9 @@ impl DefCollector<'_> {\n             match &directive.kind {\n                 MacroDirectiveKind::FnLike { ast_id, expand_to } => {\n                     let macro_call_as_call_id = macro_call_as_call_id(\n+                        self.db,\n                         ast_id,\n                         *expand_to,\n-                        self.db,\n                         self.def_map.krate,\n                         |path| {\n                             let resolved_res = self.def_map.resolve_path_fp_with_macro(\n@@ -1959,9 +1976,9 @@ impl ModCollector<'_, '_> {\n         // Case 1: try to resolve in legacy scope and expand macro_rules\n         let mut error = None;\n         match macro_call_as_call_id(\n+            self.def_collector.db,\n             &ast_id,\n             mac.expand_to,\n-            self.def_collector.db,\n             self.def_collector.def_map.krate,\n             |path| {\n                 path.as_ident().and_then(|name| {"}, {"sha": "6301da1c832df35caf3a6525fe7ec83f9e619d31", "filename": "crates/hir_expand/src/builtin_attr_macro.rs", "status": "modified", "additions": 69, "deletions": 2, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fhir_expand%2Fsrc%2Fbuiltin_attr_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fhir_expand%2Fsrc%2Fbuiltin_attr_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fbuiltin_attr_macro.rs?ref=bd2b6c40bca71687c5e0d4d15224acd43f647cc6", "patch": "@@ -1,9 +1,11 @@\n //! Builtin attributes.\n \n+use itertools::Itertools;\n use syntax::ast;\n \n use crate::{\n-    db::AstDatabase, name, AstId, CrateId, ExpandResult, MacroCallId, MacroDefId, MacroDefKind,\n+    db::AstDatabase, name, AstId, CrateId, ExpandResult, MacroCallId, MacroCallKind, MacroDefId,\n+    MacroDefKind,\n };\n \n macro_rules! register_builtin {\n@@ -53,7 +55,7 @@ register_builtin! {\n     (bench, Bench) => dummy_attr_expand,\n     (cfg_accessible, CfgAccessible) => dummy_attr_expand,\n     (cfg_eval, CfgEval) => dummy_attr_expand,\n-    (derive, Derive) => dummy_attr_expand,\n+    (derive, Derive) => derive_attr_expand,\n     (global_allocator, GlobalAllocator) => dummy_attr_expand,\n     (test, Test) => dummy_attr_expand,\n     (test_case, TestCase) => dummy_attr_expand\n@@ -79,3 +81,68 @@ fn dummy_attr_expand(\n ) -> ExpandResult<tt::Subtree> {\n     ExpandResult::ok(tt.clone())\n }\n+\n+/// We generate a very specific expansion here, as we do not actually expand the `#[derive]` attribute\n+/// itself in name res, but we do want to expand it to something for the IDE layer, so that the input\n+/// derive attributes can be downmapped, and resolved as proper paths.\n+/// This is basically a hack, that simplifies the hacks we need in a lot of ide layer places to\n+/// somewhat inconsistently resolve derive attributes.\n+///\n+/// As such, we expand `#[derive(Foo, bar::Bar)]` into\n+/// ```\n+///  #[Foo]\n+///  #[bar::Bar]\n+///  ();\n+/// ```\n+/// which allows fallback path resolution in hir::Semantics to properly identify our derives.\n+/// Since we do not expand the attribute in nameres though, we keep the original item.\n+///\n+/// The ideal expansion here would be for the `#[derive]` to re-emit the annotated item and somehow\n+/// use the input paths in its output as well.\n+/// But that would bring two problems with it, for one every derive would duplicate the item token tree\n+/// wasting a lot of memory, and it would also require some way to use a path in a way that makes it\n+/// always resolve as a derive without nameres recollecting them.\n+/// So this hacky approach is a lot more friendly for us, though it does require a bit of support in\n+/// [`hir::Semantics`] to make this work.\n+fn derive_attr_expand(\n+    db: &dyn AstDatabase,\n+    id: MacroCallId,\n+    tt: &tt::Subtree,\n+) -> ExpandResult<tt::Subtree> {\n+    let loc = db.lookup_intern_macro_call(id);\n+    let derives = match &loc.kind {\n+        MacroCallKind::Attr { attr_args, .. } => &attr_args.0,\n+        _ => return ExpandResult::ok(tt.clone()),\n+    };\n+\n+    let mk_leaf = |char| {\n+        tt::TokenTree::Leaf(tt::Leaf::Punct(tt::Punct {\n+            char,\n+            spacing: tt::Spacing::Alone,\n+            id: tt::TokenId::unspecified(),\n+        }))\n+    };\n+\n+    let mut token_trees = Vec::new();\n+    for (comma, group) in &derives\n+        .token_trees\n+        .iter()\n+        .filter_map(|tt| match tt {\n+            tt::TokenTree::Leaf(l) => Some(l),\n+            tt::TokenTree::Subtree(_) => None,\n+        })\n+        .group_by(|l| matches!(l, tt::Leaf::Punct(tt::Punct { char: ',', .. })))\n+    {\n+        if comma {\n+            continue;\n+        }\n+        token_trees.push(mk_leaf('#'));\n+        token_trees.push(mk_leaf('['));\n+        token_trees.extend(group.cloned().map(tt::TokenTree::Leaf));\n+        token_trees.push(mk_leaf(']'));\n+    }\n+    token_trees.push(mk_leaf('('));\n+    token_trees.push(mk_leaf(')'));\n+    token_trees.push(mk_leaf(';'));\n+    ExpandResult::ok(tt::Subtree { delimiter: tt.delimiter, token_trees })\n+}"}, {"sha": "d6d33b4cd724f144e336c27e9fb91e67863a4cdc", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=bd2b6c40bca71687c5e0d4d15224acd43f647cc6", "patch": "@@ -342,6 +342,7 @@ fn censor_for_macro_input(loc: &MacroCallLoc, node: &SyntaxNode) -> FxHashSet<Sy\n                     .map(|it| it.syntax().clone())\n                     .collect()\n             }\n+            MacroCallKind::Attr { is_derive: true, .. } => return None,\n             MacroCallKind::Attr { invoc_attr_index, .. } => {\n                 cov_mark::hit!(attribute_macro_attr_censoring);\n                 ast::Item::cast(node.clone())?"}, {"sha": "cc38faa13693c64d2227339fe52afa974e7ccd3b", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 68, "deletions": 14, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=bd2b6c40bca71687c5e0d4d15224acd43f647cc6", "patch": "@@ -166,6 +166,8 @@ pub enum MacroCallKind {\n         /// Outer attributes are counted first, then inner attributes. This does not support\n         /// out-of-line modules, which may have attributes spread across 2 files!\n         invoc_attr_index: u32,\n+        /// Whether this attribute is the `#[derive]` attribute.\n+        is_derive: bool,\n     },\n }\n \n@@ -218,9 +220,18 @@ impl HirFileId {\n \n                 let arg_tt = loc.kind.arg(db)?;\n \n+                let macro_def = db.macro_def(loc.def).ok()?;\n+                let (parse, exp_map) = db.parse_macro_expansion(macro_file).value?;\n+                let macro_arg = db.macro_arg(macro_file.macro_call_id)?;\n+\n                 let def = loc.def.ast_id().left().and_then(|id| {\n                     let def_tt = match id.to_node(db) {\n                         ast::Macro::MacroRules(mac) => mac.token_tree()?,\n+                        ast::Macro::MacroDef(_)\n+                            if matches!(*macro_def, TokenExpander::BuiltinAttr(_)) =>\n+                        {\n+                            return None\n+                        }\n                         ast::Macro::MacroDef(mac) => mac.body()?,\n                     };\n                     Some(InFile::new(id.file_id, def_tt))\n@@ -238,10 +249,6 @@ impl HirFileId {\n                     _ => None,\n                 });\n \n-                let macro_def = db.macro_def(loc.def).ok()?;\n-                let (parse, exp_map) = db.parse_macro_expansion(macro_file).value?;\n-                let macro_arg = db.macro_arg(macro_file.macro_call_id)?;\n-\n                 Some(ExpansionInfo {\n                     expanded: InFile::new(self, parse.syntax_node()),\n                     arg: InFile::new(loc.kind.file_id(), arg_tt),\n@@ -256,16 +263,16 @@ impl HirFileId {\n     }\n \n     /// Indicate it is macro file generated for builtin derive\n-    pub fn is_builtin_derive(&self, db: &dyn db::AstDatabase) -> Option<InFile<ast::Item>> {\n+    pub fn is_builtin_derive(&self, db: &dyn db::AstDatabase) -> Option<InFile<ast::Attr>> {\n         match self.0 {\n             HirFileIdRepr::FileId(_) => None,\n             HirFileIdRepr::MacroFile(macro_file) => {\n                 let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n-                let item = match loc.def.kind {\n+                let attr = match loc.def.kind {\n                     MacroDefKind::BuiltInDerive(..) => loc.kind.to_node(db),\n                     _ => return None,\n                 };\n-                Some(item.with_value(ast::Item::cast(item.value.clone())?))\n+                Some(attr.with_value(ast::Attr::cast(attr.value.clone())?))\n             }\n         }\n     }\n@@ -291,7 +298,7 @@ impl HirFileId {\n         }\n     }\n \n-    /// Return whether this file is an include macro\n+    /// Return whether this file is an attr macro\n     pub fn is_attr_macro(&self, db: &dyn db::AstDatabase) -> bool {\n         match self.0 {\n             HirFileIdRepr::MacroFile(macro_file) => {\n@@ -302,6 +309,17 @@ impl HirFileId {\n         }\n     }\n \n+    /// Return whether this file is the pseudo expansion of the derive attribute.\n+    pub fn is_derive_attr_macro(&self, db: &dyn db::AstDatabase) -> bool {\n+        match self.0 {\n+            HirFileIdRepr::MacroFile(macro_file) => {\n+                let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n+                matches!(loc.kind, MacroCallKind::Attr { is_derive: true, .. })\n+            }\n+            _ => false,\n+        }\n+    }\n+\n     pub fn is_macro(self) -> bool {\n         matches!(self.0, HirFileIdRepr::MacroFile(_))\n     }\n@@ -366,8 +384,29 @@ impl MacroCallKind {\n             MacroCallKind::FnLike { ast_id, .. } => {\n                 ast_id.with_value(ast_id.to_node(db).syntax().clone())\n             }\n-            MacroCallKind::Derive { ast_id, .. } => {\n-                ast_id.with_value(ast_id.to_node(db).syntax().clone())\n+            MacroCallKind::Derive { ast_id, derive_attr_index, .. } => {\n+                // FIXME: handle `cfg_attr`\n+                ast_id.with_value(ast_id.to_node(db)).map(|it| {\n+                    it.doc_comments_and_attrs()\n+                        .nth(*derive_attr_index as usize)\n+                        .and_then(|it| match it {\n+                            Either::Left(attr) => Some(attr.syntax().clone()),\n+                            Either::Right(_) => None,\n+                        })\n+                        .unwrap_or_else(|| it.syntax().clone())\n+                })\n+            }\n+            MacroCallKind::Attr { ast_id, is_derive: true, invoc_attr_index, .. } => {\n+                // FIXME: handle `cfg_attr`\n+                ast_id.with_value(ast_id.to_node(db)).map(|it| {\n+                    it.doc_comments_and_attrs()\n+                        .nth(*invoc_attr_index as usize)\n+                        .and_then(|it| match it {\n+                            Either::Left(attr) => Some(attr.syntax().clone()),\n+                            Either::Right(_) => None,\n+                        })\n+                        .unwrap_or_else(|| it.syntax().clone())\n+                })\n             }\n             MacroCallKind::Attr { ast_id, .. } => {\n                 ast_id.with_value(ast_id.to_node(db).syntax().clone())\n@@ -431,6 +470,7 @@ impl MacroCallKind {\n         match self {\n             MacroCallKind::FnLike { expand_to, .. } => *expand_to,\n             MacroCallKind::Derive { .. } => ExpandTo::Items,\n+            MacroCallKind::Attr { is_derive: true, .. } => ExpandTo::Statements,\n             MacroCallKind::Attr { .. } => ExpandTo::Items, // is this always correct?\n         }\n     }\n@@ -497,7 +537,7 @@ impl ExpansionInfo {\n \n             let token_range = token.value.text_range();\n             match &loc.kind {\n-                MacroCallKind::Attr { attr_args, invoc_attr_index, .. } => {\n+                MacroCallKind::Attr { attr_args, invoc_attr_index, is_derive, .. } => {\n                     let attr = item\n                         .doc_comments_and_attrs()\n                         .nth(*invoc_attr_index as usize)\n@@ -511,9 +551,13 @@ impl ExpansionInfo {\n                             let relative_range =\n                                 token.value.text_range().checked_sub(attr_input_start)?;\n                             // shift by the item's tree's max id\n-                            let token_id = self\n-                                .macro_arg_shift\n-                                .shift(attr_args.1.token_by_range(relative_range)?);\n+                            let token_id = attr_args.1.token_by_range(relative_range)?;\n+                            let token_id = if *is_derive {\n+                                // we do not shift for `#[derive]`, as we only need to downmap the derive attribute tokens\n+                                token_id\n+                            } else {\n+                                self.macro_arg_shift.shift(token_id)\n+                            };\n                             Some(token_id)\n                         }\n                         _ => None,\n@@ -561,6 +605,9 @@ impl ExpansionInfo {\n \n         // Attributes are a bit special for us, they have two inputs, the input tokentree and the annotated item.\n         let (token_map, tt) = match &loc.kind {\n+            MacroCallKind::Attr { attr_args, is_derive: true, .. } => {\n+                (&attr_args.1, self.attr_input_or_mac_def.clone()?.syntax().cloned())\n+            }\n             MacroCallKind::Attr { attr_args, .. } => {\n                 // try unshifting the the token id, if unshifting fails, the token resides in the non-item attribute input\n                 // note that the `TokenExpander::map_id_up` earlier only unshifts for declarative macros, so we don't double unshift with this\n@@ -716,6 +763,13 @@ impl<'a> InFile<&'a SyntaxNode> {\n     }\n }\n \n+impl InFile<SyntaxToken> {\n+    pub fn upmap(self, db: &dyn db::AstDatabase) -> Option<InFile<SyntaxToken>> {\n+        let expansion = self.file_id.expansion_info(db)?;\n+        expansion.map_token_up(db, self.as_ref()).map(|(it, _)| it)\n+    }\n+}\n+\n fn ascend_node_border_tokens(\n     db: &dyn db::AstDatabase,\n     InFile { file_id, value: node }: InFile<&SyntaxNode>,"}, {"sha": "f7326747253a0580eb1261e901f9fa4c52fb292e", "filename": "crates/ide/src/expand_macro.rs", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fide%2Fsrc%2Fexpand_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fide%2Fsrc%2Fexpand_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fexpand_macro.rs?ref=bd2b6c40bca71687c5e0d4d15224acd43f647cc6", "patch": "@@ -3,8 +3,7 @@ use ide_db::{\n     helpers::{insert_whitespace_into_node::insert_ws_into, pick_best_token},\n     RootDatabase,\n };\n-use itertools::Itertools;\n-use syntax::{ast, ted, AstNode, SyntaxKind, SyntaxNode};\n+use syntax::{ast, ted, AstNode, NodeOrToken, SyntaxKind, SyntaxNode, T};\n \n use crate::FilePosition;\n \n@@ -41,20 +40,28 @@ pub(crate) fn expand_macro(db: &RootDatabase, position: FilePosition) -> Option<\n     // struct Bar;\n     // ```\n \n-    let derive = sema.descend_into_macros(tok.clone()).iter().find_map(|descended| {\n-        let attr = descended.ancestors().find_map(ast::Attr::cast)?;\n-        let (path, tt) = attr.as_simple_call()?;\n-        if path == \"derive\" {\n-            let mut tt = tt.syntax().children_with_tokens().skip(1).join(\"\");\n-            tt.pop();\n-            let expansions = sema.expand_derive_macro(&attr)?;\n-            Some(ExpandedMacro {\n-                name: tt,\n-                expansion: expansions.into_iter().map(insert_ws_into).join(\"\"),\n-            })\n-        } else {\n-            None\n+    let derive = sema.descend_into_macros(tok.clone()).into_iter().find_map(|descended| {\n+        let hir_file = sema.hir_file_for(&descended.parent()?);\n+        if !hir_file.is_derive_attr_macro(db) {\n+            return None;\n         }\n+\n+        let name = descended.ancestors().filter_map(ast::Path::cast).last()?.to_string();\n+        // up map out of the #[derive] expansion\n+        let token = hir::InFile::new(hir_file, descended).upmap(db)?.value;\n+        let attr = token.ancestors().find_map(ast::Attr::cast)?;\n+        let expansions = sema.expand_derive_macro(&attr)?;\n+        let idx = attr\n+            .token_tree()?\n+            .token_trees_and_tokens()\n+            .filter_map(NodeOrToken::into_token)\n+            .take_while(|it| it == &token)\n+            .filter(|it| it.kind() == T![,])\n+            .count();\n+        Some(ExpandedMacro {\n+            name,\n+            expansion: expansions.get(idx).cloned().map(insert_ws_into)?.to_string(),\n+        })\n     });\n \n     if derive.is_some() {\n@@ -372,11 +379,9 @@ struct Foo {}\n struct Foo {}\n \"#,\n             expect![[r#\"\n-                Copy, Clone\n+                Copy\n                 impl < >core::marker::Copy for Foo< >{}\n \n-                impl < >core::clone::Clone for Foo< >{}\n-\n             \"#]],\n         );\n     }"}, {"sha": "a232ebd4fb7cc658414acb16a9e14f564924d260", "filename": "crates/ide/src/hover/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=bd2b6c40bca71687c5e0d4d15224acd43f647cc6", "patch": "@@ -15,6 +15,7 @@ fn check_hover_no_result(ra_fixture: &str) {\n     assert!(hover.is_none(), \"hover not expected but found: {:?}\", hover.unwrap());\n }\n \n+#[track_caller]\n fn check(ra_fixture: &str, expect: Expect) {\n     let (analysis, position) = fixture::position(ra_fixture);\n     let hover = analysis"}, {"sha": "38edda9c1c088466a1bbcac58fa615950d7b221a", "filename": "crates/ide/src/references.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=bd2b6c40bca71687c5e0d4d15224acd43f647cc6", "patch": "@@ -1564,7 +1564,6 @@ fn func$0() {}\n         );\n     }\n \n-    // FIXME\n     #[test]\n     fn derive() {\n         check(\n@@ -1575,7 +1574,11 @@ fn func$0() {}\n #[derive(proc_macros::DeriveIdentity$0)]\n struct Foo;\n \"#,\n-            expect![[r#\"\"#]],\n+            expect![[r#\"\n+                derive_identity Derive FileId(2) 1..107 45..60\n+\n+                FileId(0) 23..37\n+            \"#]],\n         )\n     }\n }"}, {"sha": "7d92c5051b14ff77fa4bb42b547a2b9e285bccaf", "filename": "crates/ide/src/syntax_highlighting.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs?ref=bd2b6c40bca71687c5e0d4d15224acd43f647cc6", "patch": "@@ -237,6 +237,20 @@ fn traverse(\n                     continue;\n                 }\n                 Some(item) if sema.is_attr_macro_call(&item) => current_attr_call = Some(item),\n+                Some(item) if current_attr_call.is_none() => {\n+                    let adt = match item {\n+                        ast::Item::Enum(it) => Some(ast::Adt::Enum(it)),\n+                        ast::Item::Struct(it) => Some(ast::Adt::Struct(it)),\n+                        ast::Item::Union(it) => Some(ast::Adt::Union(it)),\n+                        _ => None,\n+                    };\n+                    match adt {\n+                        Some(adt) if sema.is_derive_annotated(&adt) => {\n+                            current_attr_call = Some(adt.into());\n+                        }\n+                        _ => (),\n+                    }\n+                }\n                 None if ast::Attr::can_cast(node.kind()) => inside_attribute = true,\n                 _ => (),\n             },\n@@ -361,7 +375,7 @@ fn traverse(\n                 syntactic_name_ref_highlighting,\n                 node,\n             ),\n-            NodeOrToken::Token(token) => highlight::token(sema, krate, token).zip(Some(None)),\n+            NodeOrToken::Token(token) => highlight::token(sema, token).zip(Some(None)),\n         };\n         if let Some((mut highlight, binding_hash)) = element {\n             if inside_attribute {"}, {"sha": "85c0c1b286ebb859b08e68ff33ae7ef366442caf", "filename": "crates/ide/src/syntax_highlighting/highlight.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs?ref=bd2b6c40bca71687c5e0d4d15224acd43f647cc6", "patch": "@@ -18,11 +18,7 @@ use crate::{\n     Highlight, HlMod, HlTag,\n };\n \n-pub(super) fn token(\n-    sema: &Semantics<RootDatabase>,\n-    krate: Option<hir::Crate>,\n-    token: SyntaxToken,\n-) -> Option<Highlight> {\n+pub(super) fn token(sema: &Semantics<RootDatabase>, token: SyntaxToken) -> Option<Highlight> {\n     if let Some(comment) = ast::Comment::cast(token.clone()) {\n         let h = HlTag::Comment;\n         return Some(match comment.kind().doc {\n@@ -39,17 +35,10 @@ pub(super) fn token(\n         INT_NUMBER | FLOAT_NUMBER => HlTag::NumericLiteral.into(),\n         BYTE => HlTag::ByteLiteral.into(),\n         CHAR => HlTag::CharLiteral.into(),\n-        IDENT => {\n-            let tt = ast::TokenTree::cast(token.parent()?)?;\n-            let ident = ast::Ident::cast(token)?;\n+        IDENT if token.parent().and_then(ast::TokenTree::cast).is_some() => {\n             // from this point on we are inside a token tree, this only happens for identifiers\n             // that were not mapped down into macro invocations\n-            (|| {\n-                let attr = tt.parent_meta()?.parent_attr()?;\n-                let res = sema.resolve_derive_ident(&attr, &ident)?;\n-                Some(highlight_def(sema, krate, Definition::from(res)))\n-            })()\n-            .unwrap_or_else(|| HlTag::None.into())\n+            HlTag::None.into()\n         }\n         p if p.is_punct() => punctuation(sema, token, p),\n         k if k.is_keyword() => keyword(sema, token, k)?,"}, {"sha": "9c0233b028f600c2ce86455f3affd0e8682736b5", "filename": "crates/ide_assists/src/handlers/auto_import.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=bd2b6c40bca71687c5e0d4d15224acd43f647cc6", "patch": "@@ -3,7 +3,7 @@ use ide_db::helpers::{\n     insert_use::{insert_use, ImportScope},\n     mod_path_to_ast,\n };\n-use syntax::{ast, AstNode, AstToken, NodeOrToken, SyntaxElement};\n+use syntax::{ast, AstNode, NodeOrToken, SyntaxElement};\n \n use crate::{AssistContext, AssistId, AssistKind, Assists, GroupLabel};\n \n@@ -139,9 +139,7 @@ pub(super) fn find_importable_node(ctx: &AssistContext) -> Option<(ImportAssets,\n     {\n         ImportAssets::for_ident_pat(&ctx.sema, &pat).zip(Some(pat.syntax().clone().into()))\n     } else {\n-        // FIXME: Descend?\n-        let ident = ctx.find_token_at_offset()?;\n-        ImportAssets::for_derive_ident(&ctx.sema, &ident).zip(Some(ident.syntax().clone().into()))\n+        None\n     }\n }\n "}, {"sha": "8ac05bf5ff51c460ecfa750cd319d3f645159b64", "filename": "crates/ide_assists/src/handlers/replace_derive_with_manual_impl.rs", "status": "modified", "additions": 71, "deletions": 54, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs?ref=bd2b6c40bca71687c5e0d4d15224acd43f647cc6", "patch": "@@ -1,13 +1,13 @@\n-use hir::ModuleDef;\n-use ide_db::helpers::insert_whitespace_into_node::insert_ws_into;\n-use ide_db::helpers::{\n-    get_path_at_cursor_in_tt, import_assets::NameToImport, mod_path_to_ast,\n-    parse_tt_as_comma_sep_paths,\n+use hir::{InFile, ModuleDef};\n+use ide_db::{\n+    helpers::{\n+        import_assets::NameToImport, insert_whitespace_into_node::insert_ws_into, mod_path_to_ast,\n+    },\n+    items_locator,\n };\n-use ide_db::items_locator;\n use itertools::Itertools;\n use syntax::{\n-    ast::{self, AstNode, AstToken, HasName},\n+    ast::{self, AstNode, HasName},\n     SyntaxKind::WHITESPACE,\n };\n \n@@ -25,6 +25,7 @@ use crate::{\n // Converts a `derive` impl into a manual one.\n //\n // ```\n+// # //- minicore: derive\n // # trait Debug { fn fmt(&self, f: &mut Formatter) -> Result<()>; }\n // #[derive(Deb$0ug, Display)]\n // struct S;\n@@ -45,28 +46,38 @@ pub(crate) fn replace_derive_with_manual_impl(\n     acc: &mut Assists,\n     ctx: &AssistContext,\n ) -> Option<()> {\n-    let attr = ctx.find_node_at_offset::<ast::Attr>()?;\n-    let (name, args) = attr.as_simple_call()?;\n-    if name != \"derive\" {\n+    let attr = ctx.find_node_at_offset_with_descend::<ast::Attr>()?;\n+    let path = attr.path()?;\n+    let hir_file = ctx.sema.hir_file_for(attr.syntax());\n+    if !hir_file.is_derive_attr_macro(ctx.db()) {\n         return None;\n     }\n \n-    if !args.syntax().text_range().contains(ctx.offset()) {\n-        cov_mark::hit!(outside_of_attr_args);\n+    let InFile { file_id, value } = hir_file.call_node(ctx.db())?;\n+    if file_id.is_macro() {\n+        // FIXME: make this work in macro files\n         return None;\n     }\n+    // collect the derive paths from the #[derive] expansion\n+    let current_derives = ctx\n+        .sema\n+        .parse_or_expand(hir_file)?\n+        .descendants()\n+        .filter_map(ast::Attr::cast)\n+        .filter_map(|attr| attr.path())\n+        .collect::<Vec<_>>();\n \n-    let ident = args.syntax().token_at_offset(ctx.offset()).find_map(ast::Ident::cast)?;\n-    let trait_path = get_path_at_cursor_in_tt(&ident)?;\n-    let adt = attr.syntax().parent().and_then(ast::Adt::cast)?;\n+    let adt = value.parent().and_then(ast::Adt::cast)?;\n+    let attr = ast::Attr::cast(value)?;\n+    let args = attr.token_tree()?;\n \n     let current_module = ctx.sema.scope(adt.syntax()).module()?;\n     let current_crate = current_module.krate();\n \n     let found_traits = items_locator::items_with_name(\n         &ctx.sema,\n         current_crate,\n-        NameToImport::exact_case_sensitive(trait_path.segments().last()?.to_string()),\n+        NameToImport::exact_case_sensitive(path.segments().last()?.to_string()),\n         items_locator::AssocItemSearch::Exclude,\n         Some(items_locator::DEFAULT_QUERY_SEARCH_LIMIT.inner()),\n     )\n@@ -83,23 +94,21 @@ pub(crate) fn replace_derive_with_manual_impl(\n     });\n \n     let mut no_traits_found = true;\n-    let current_derives = parse_tt_as_comma_sep_paths(args.clone())?;\n-    let current_derives = current_derives.as_slice();\n     for (replace_trait_path, trait_) in found_traits.inspect(|_| no_traits_found = false) {\n         add_assist(\n             acc,\n             ctx,\n             &attr,\n             &current_derives,\n             &args,\n-            &trait_path,\n+            &path,\n             &replace_trait_path,\n             Some(trait_),\n             &adt,\n         )?;\n     }\n     if no_traits_found {\n-        add_assist(acc, ctx, &attr, &current_derives, &args, &trait_path, &trait_path, None, &adt)?;\n+        add_assist(acc, ctx, &attr, &current_derives, &args, &path, &path, None, &adt)?;\n     }\n     Some(())\n }\n@@ -128,7 +137,7 @@ fn add_assist(\n             let impl_def_with_items =\n                 impl_def_from_trait(&ctx.sema, adt, &annotated_name, trait_, replace_trait_path);\n             update_attribute(builder, old_derives, old_tree, old_trait_path, attr);\n-            let trait_path = format!(\"{}\", replace_trait_path);\n+            let trait_path = replace_trait_path.to_string();\n             match (ctx.config.snippet_cap, impl_def_with_items) {\n                 (None, _) => {\n                     builder.insert(insert_pos, generate_trait_impl_text(adt, &trait_path, \"\"))\n@@ -258,7 +267,7 @@ mod tests {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: fmt\n+//- minicore: fmt, derive\n #[derive(Debu$0g)]\n struct Foo {\n     bar: String,\n@@ -282,7 +291,7 @@ impl core::fmt::Debug for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: fmt\n+//- minicore: fmt, derive\n #[derive(Debu$0g)]\n struct Foo(String, usize);\n \"#,\n@@ -301,7 +310,7 @@ impl core::fmt::Debug for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: fmt\n+//- minicore: fmt, derive\n #[derive(Debu$0g)]\n struct Foo;\n \"#,\n@@ -321,7 +330,7 @@ impl core::fmt::Debug for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: fmt\n+//- minicore: fmt, derive\n #[derive(Debu$0g)]\n enum Foo {\n     Bar,\n@@ -351,7 +360,7 @@ impl core::fmt::Debug for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: fmt\n+//- minicore: fmt, derive\n #[derive(Debu$0g)]\n enum Foo {\n     Bar(usize, usize),\n@@ -380,7 +389,7 @@ impl core::fmt::Debug for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: fmt\n+//- minicore: fmt, derive\n #[derive(Debu$0g)]\n enum Foo {\n     Bar {\n@@ -415,7 +424,7 @@ impl core::fmt::Debug for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: default\n+//- minicore: default, derive\n #[derive(Defau$0lt)]\n struct Foo {\n     foo: usize,\n@@ -439,7 +448,7 @@ impl Default for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: default\n+//- minicore: default, derive\n #[derive(Defau$0lt)]\n struct Foo(usize);\n \"#,\n@@ -459,7 +468,7 @@ impl Default for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: default\n+//- minicore: default, derive\n #[derive(Defau$0lt)]\n struct Foo;\n \"#,\n@@ -480,7 +489,7 @@ impl Default for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: hash\n+//- minicore: hash, derive\n #[derive(Has$0h)]\n struct Foo {\n     bin: usize,\n@@ -508,7 +517,7 @@ impl core::hash::Hash for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: hash\n+//- minicore: hash, derive\n #[derive(Has$0h)]\n struct Foo(usize, usize);\n \"#,\n@@ -530,7 +539,7 @@ impl core::hash::Hash for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: hash\n+//- minicore: hash, derive\n #[derive(Has$0h)]\n enum Foo {\n     Bar,\n@@ -557,7 +566,7 @@ impl core::hash::Hash for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: clone\n+//- minicore: clone, derive\n #[derive(Clo$0ne)]\n struct Foo {\n     bin: usize,\n@@ -584,7 +593,7 @@ impl Clone for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: clone\n+//- minicore: clone, derive\n #[derive(Clo$0ne)]\n struct Foo(usize, usize);\n \"#,\n@@ -605,7 +614,7 @@ impl Clone for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: clone\n+//- minicore: clone, derive\n #[derive(Clo$0ne)]\n struct Foo;\n \"#,\n@@ -626,7 +635,7 @@ impl Clone for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: clone\n+//- minicore: clone, derive\n #[derive(Clo$0ne)]\n enum Foo {\n     Bar,\n@@ -656,7 +665,7 @@ impl Clone for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: clone\n+//- minicore: clone, derive\n #[derive(Clo$0ne)]\n enum Foo {\n     Bar(String),\n@@ -686,7 +695,7 @@ impl Clone for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: clone\n+//- minicore: clone, derive\n #[derive(Clo$0ne)]\n enum Foo {\n     Bar {\n@@ -720,7 +729,7 @@ impl Clone for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: ord\n+//- minicore: ord, derive\n #[derive(Partial$0Ord)]\n struct Foo {\n     bin: usize,\n@@ -745,7 +754,7 @@ impl PartialOrd for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: ord\n+//- minicore: ord, derive\n #[derive(Partial$0Ord)]\n struct Foo {\n     bin: usize,\n@@ -782,7 +791,7 @@ impl PartialOrd for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: ord\n+//- minicore: ord, derive\n #[derive(Partial$0Ord)]\n struct Foo(usize, usize, usize);\n \"#,\n@@ -811,7 +820,7 @@ impl PartialOrd for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: eq\n+//- minicore: eq, derive\n #[derive(Partial$0Eq)]\n struct Foo {\n     bin: usize,\n@@ -838,7 +847,7 @@ impl PartialEq for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: eq\n+//- minicore: eq, derive\n #[derive(Partial$0Eq)]\n struct Foo(usize, usize);\n \"#,\n@@ -859,7 +868,7 @@ impl PartialEq for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: eq\n+//- minicore: eq, derive\n #[derive(Partial$0Eq)]\n struct Foo;\n \"#,\n@@ -880,7 +889,7 @@ impl PartialEq for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: eq\n+//- minicore: eq, derive\n #[derive(Partial$0Eq)]\n enum Foo {\n     Bar,\n@@ -907,7 +916,7 @@ impl PartialEq for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: eq\n+//- minicore: eq, derive\n #[derive(Partial$0Eq)]\n enum Foo {\n     Bar(String),\n@@ -937,7 +946,7 @@ impl PartialEq for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: eq\n+//- minicore: eq, derive\n #[derive(Partial$0Eq)]\n enum Foo {\n     Bar {\n@@ -981,6 +990,7 @@ impl PartialEq for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n+//- minicore: derive\n mod foo {\n     pub trait Bar {\n         type Qux;\n@@ -1026,10 +1036,11 @@ impl foo::Bar for Foo {\n         )\n     }\n     #[test]\n-    fn add_custom_impl_for_unique_input() {\n+    fn add_custom_impl_for_unique_input_unknown() {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n+//- minicore: derive\n #[derive(Debu$0g)]\n struct Foo {\n     bar: String,\n@@ -1052,6 +1063,7 @@ impl Debug for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n+//- minicore: derive\n #[derive(Debug$0)]\n pub struct Foo {\n     bar: String,\n@@ -1074,6 +1086,7 @@ impl Debug for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n+//- minicore: derive\n #[derive(Display, Debug$0, Serialize)]\n struct Foo {}\n             \"#,\n@@ -1093,7 +1106,7 @@ impl Debug for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: default\n+//- minicore: default, derive\n #[derive(Defau$0lt)]\n struct Foo<T, U> {\n     foo: T,\n@@ -1120,7 +1133,7 @@ impl<T, U> Default for Foo<T, U> {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: clone\n+//- minicore: clone, derive\n #[derive(Clo$0ne)]\n struct Foo<T: Clone>(T, usize);\n \"#,\n@@ -1141,6 +1154,7 @@ impl<T: Clone> Clone for Foo<T> {\n         check_assist_not_applicable(\n             replace_derive_with_manual_impl,\n             r#\"\n+//- minicore: derive\n #[derive($0)]\n struct Foo {}\n             \"#,\n@@ -1152,6 +1166,7 @@ struct Foo {}\n         check_assist_not_applicable(\n             replace_derive_with_manual_impl,\n             r#\"\n+//- minicore: derive, fmt\n #[derive$0(Debug)]\n struct Foo {}\n             \"#,\n@@ -1160,6 +1175,7 @@ struct Foo {}\n         check_assist_not_applicable(\n             replace_derive_with_manual_impl,\n             r#\"\n+//- minicore: derive, fmt\n #[derive(Debug)$0]\n struct Foo {}\n             \"#,\n@@ -1171,6 +1187,7 @@ struct Foo {}\n         check_assist_not_applicable(\n             replace_derive_with_manual_impl,\n             r#\"\n+//- minicore: derive\n #[allow(non_camel_$0case_types)]\n struct Foo {}\n             \"#,\n@@ -1179,10 +1196,10 @@ struct Foo {}\n \n     #[test]\n     fn works_at_start_of_file() {\n-        cov_mark::check!(outside_of_attr_args);\n         check_assist_not_applicable(\n             replace_derive_with_manual_impl,\n             r#\"\n+//- minicore: derive, fmt\n $0#[derive(Debug)]\n struct S;\n             \"#,\n@@ -1194,7 +1211,7 @@ struct S;\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: clone\n+//- minicore: clone, derive\n #[derive(std::fmt::Debug, Clo$0ne)]\n pub struct Foo;\n \"#,\n@@ -1216,7 +1233,7 @@ impl Clone for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: fmt\n+//- minicore: fmt, derive\n #[derive(core::fmt::Deb$0ug, Clone)]\n pub struct Foo;\n \"#,"}, {"sha": "485b807d0556d23118294d6e0b3323a5f598f004", "filename": "crates/ide_assists/src/tests/generated.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=bd2b6c40bca71687c5e0d4d15224acd43f647cc6", "patch": "@@ -1766,6 +1766,7 @@ fn doctest_replace_derive_with_manual_impl() {\n     check_doc_test(\n         \"replace_derive_with_manual_impl\",\n         r#####\"\n+//- minicore: derive\n trait Debug { fn fmt(&self, f: &mut Formatter) -> Result<()>; }\n #[derive(Deb$0ug, Display)]\n struct S;"}, {"sha": "0d59f77a55c975d4ac5b4534d91e201feae904c7", "filename": "crates/ide_completion/src/completions/trait_impl.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ftrait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ftrait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ftrait_impl.rs?ref=bd2b6c40bca71687c5e0d4d15224acd43f647cc6", "patch": "@@ -58,15 +58,15 @@ pub(crate) fn complete_trait_impl(acc: &mut Completions, ctx: &CompletionContext\n                     (\n                         hir::AssocItem::Function(fn_item),\n                         ImplCompletionKind::All | ImplCompletionKind::Fn,\n-                    ) => add_function_impl(&trigger, acc, ctx, fn_item, hir_impl),\n+                    ) => add_function_impl(acc, ctx, &trigger, fn_item, hir_impl),\n                     (\n                         hir::AssocItem::TypeAlias(type_item),\n                         ImplCompletionKind::All | ImplCompletionKind::TypeAlias,\n-                    ) => add_type_alias_impl(&trigger, acc, ctx, type_item),\n+                    ) => add_type_alias_impl(acc, ctx, &trigger, type_item),\n                     (\n                         hir::AssocItem::Const(const_item),\n                         ImplCompletionKind::All | ImplCompletionKind::Const,\n-                    ) => add_const_impl(&trigger, acc, ctx, const_item, hir_impl),\n+                    ) => add_const_impl(acc, ctx, &trigger, const_item, hir_impl),\n                     _ => {}\n                 }\n             });\n@@ -126,9 +126,9 @@ fn completion_match(mut token: SyntaxToken) -> Option<(ImplCompletionKind, Synta\n }\n \n fn add_function_impl(\n-    fn_def_node: &SyntaxNode,\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n+    fn_def_node: &SyntaxNode,\n     func: hir::Function,\n     impl_def: hir::Impl,\n ) {\n@@ -199,9 +199,9 @@ fn get_transformed_assoc_item(\n }\n \n fn add_type_alias_impl(\n-    type_def_node: &SyntaxNode,\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n+    type_def_node: &SyntaxNode,\n     type_alias: hir::TypeAlias,\n ) {\n     let alias_name = type_alias.name(ctx.db).to_smol_str();\n@@ -217,9 +217,9 @@ fn add_type_alias_impl(\n }\n \n fn add_const_impl(\n-    const_def_node: &SyntaxNode,\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n+    const_def_node: &SyntaxNode,\n     const_: hir::Const,\n     impl_def: hir::Impl,\n ) {"}, {"sha": "ae7ba7e055ce272b383521da04a77e6105eab5a7", "filename": "crates/ide_completion/src/tests/attribute.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fide_completion%2Fsrc%2Ftests%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fide_completion%2Fsrc%2Ftests%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fattribute.rs?ref=bd2b6c40bca71687c5e0d4d15224acd43f647cc6", "patch": "@@ -735,6 +735,26 @@ mod derive {\n         )\n     }\n \n+    #[test]\n+    fn derive_no_attrs() {\n+        check_derive(\n+            r#\"\n+//- proc_macros: identity\n+//- minicore: derive\n+#[derive($0)] struct Test;\n+\"#,\n+            expect![[r#\"\"#]],\n+        );\n+        check_derive(\n+            r#\"\n+//- proc_macros: identity\n+//- minicore: derive\n+#[derive(i$0)] struct Test;\n+\"#,\n+            expect![[r#\"\"#]],\n+        );\n+    }\n+\n     #[test]\n     fn derive_flyimport() {\n         check_derive("}, {"sha": "08104efcdc2fff566163213ba377e6cc00944ba8", "filename": "crates/ide_db/src/defs.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fdefs.rs?ref=bd2b6c40bca71687c5e0d4d15224acd43f647cc6", "patch": "@@ -14,7 +14,7 @@ use hir::{\n use stdx::impl_from;\n use syntax::{\n     ast::{self, AstNode},\n-    match_ast, AstToken, SyntaxKind, SyntaxNode, SyntaxToken,\n+    match_ast, SyntaxKind, SyntaxNode, SyntaxToken,\n };\n \n use crate::RootDatabase;\n@@ -142,16 +142,6 @@ impl IdentClass {\n         token: &SyntaxToken,\n     ) -> Option<IdentClass> {\n         let parent = token.parent()?;\n-        // resolve derives if possible\n-        if let Some(ident) = ast::Ident::cast(token.clone()) {\n-            let attr = ast::TokenTree::cast(parent.clone())\n-                .and_then(|tt| tt.parent_meta())\n-                .and_then(|meta| meta.parent_attr());\n-            if let Some(attr) = attr {\n-                return NameRefClass::classify_derive(sema, &attr, &ident)\n-                    .map(IdentClass::NameRefClass);\n-            }\n-        }\n         Self::classify_node(sema, &parent)\n     }\n \n@@ -461,14 +451,6 @@ impl NameRefClass {\n             _ => None,\n         }\n     }\n-\n-    pub fn classify_derive(\n-        sema: &Semantics<RootDatabase>,\n-        attr: &ast::Attr,\n-        ident: &ast::Ident,\n-    ) -> Option<NameRefClass> {\n-        sema.resolve_derive_ident(&attr, &ident).map(Definition::from).map(NameRefClass::Definition)\n-    }\n }\n \n impl_from!("}, {"sha": "cbe4adf1b9c706e42ae9e24ad1b7267fb4a6846b", "filename": "crates/ide_db/src/helpers.rs", "status": "modified", "additions": 3, "deletions": 47, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers.rs?ref=bd2b6c40bca71687c5e0d4d15224acd43f647cc6", "patch": "@@ -9,15 +9,14 @@ pub mod node_ext;\n pub mod rust_doc;\n pub mod format_string;\n \n-use std::{collections::VecDeque, iter};\n+use std::collections::VecDeque;\n \n use base_db::FileId;\n-use hir::{ItemInNs, MacroDef, ModuleDef, Name, PathResolution, Semantics};\n+use hir::{ItemInNs, MacroDef, ModuleDef, Name, Semantics};\n use itertools::Itertools;\n use syntax::{\n     ast::{self, make, HasLoopBody},\n-    AstNode, AstToken, Direction, SyntaxElement, SyntaxKind, SyntaxToken, TokenAtOffset, WalkEvent,\n-    T,\n+    AstNode, AstToken, SyntaxKind, SyntaxToken, TokenAtOffset, WalkEvent, T,\n };\n \n use crate::{defs::Definition, RootDatabase};\n@@ -32,49 +31,6 @@ pub fn item_name(db: &RootDatabase, item: ItemInNs) -> Option<Name> {\n     }\n }\n \n-/// Parses and returns the derive path at the cursor position in the given attribute, if it is a derive.\n-/// This special case is required because the derive macro is a compiler builtin that discards the input derives.\n-///\n-/// The returned path is synthesized from TokenTree tokens and as such cannot be used with the [`Semantics`].\n-pub fn get_path_in_derive_attr(\n-    sema: &hir::Semantics<RootDatabase>,\n-    attr: &ast::Attr,\n-    cursor: &ast::Ident,\n-) -> Option<ast::Path> {\n-    let path = attr.path()?;\n-    let tt = attr.token_tree()?;\n-    if !tt.syntax().text_range().contains_range(cursor.syntax().text_range()) {\n-        return None;\n-    }\n-    let scope = sema.scope(attr.syntax());\n-    let resolved_attr = sema.resolve_path(&path)?;\n-    let derive = FamousDefs(sema, scope.krate()).core_macros_builtin_derive()?;\n-    if PathResolution::Macro(derive) != resolved_attr {\n-        return None;\n-    }\n-    get_path_at_cursor_in_tt(cursor)\n-}\n-\n-/// Parses the path the identifier is part of inside a token tree.\n-pub fn get_path_at_cursor_in_tt(cursor: &ast::Ident) -> Option<ast::Path> {\n-    let cursor = cursor.syntax();\n-    let first = cursor\n-        .siblings_with_tokens(Direction::Prev)\n-        .filter_map(SyntaxElement::into_token)\n-        .take_while(|tok| tok.kind() != T!['('] && tok.kind() != T![,])\n-        .last()?;\n-    let path_tokens = first\n-        .siblings_with_tokens(Direction::Next)\n-        .filter_map(SyntaxElement::into_token)\n-        .take_while(|tok| tok != cursor);\n-\n-    syntax::hacks::parse_expr_from_str(&path_tokens.chain(iter::once(cursor.clone())).join(\"\"))\n-        .and_then(|expr| match expr {\n-            ast::Expr::PathExpr(it) => it.path(),\n-            _ => None,\n-        })\n-}\n-\n /// Picks the token with the highest rank returned by the passed in function.\n pub fn pick_best_token(\n     tokens: TokenAtOffset<SyntaxToken>,"}, {"sha": "319a21735297a82a2e3e703248e49f3536744b54", "filename": "crates/ide_db/src/helpers/import_assets.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs?ref=bd2b6c40bca71687c5e0d4d15224acd43f647cc6", "patch": "@@ -8,11 +8,10 @@ use rustc_hash::FxHashSet;\n use syntax::{\n     ast::{self, HasName},\n     utils::path_to_string_stripping_turbo_fish,\n-    AstNode, AstToken, SyntaxNode,\n+    AstNode, SyntaxNode,\n };\n \n use crate::{\n-    helpers::get_path_in_derive_attr,\n     items_locator::{self, AssocItemSearch, DEFAULT_QUERY_SEARCH_LIMIT},\n     RootDatabase,\n };\n@@ -139,23 +138,6 @@ impl ImportAssets {\n         })\n     }\n \n-    pub fn for_derive_ident(sema: &Semantics<RootDatabase>, ident: &ast::Ident) -> Option<Self> {\n-        let attr = ident.syntax().ancestors().find_map(ast::Attr::cast)?;\n-        let path = get_path_in_derive_attr(sema, &attr, ident)?;\n-\n-        if let Some(_) = path.qualifier() {\n-            return None;\n-        }\n-\n-        let name = NameToImport::exact_case_sensitive(path.segment()?.name_ref()?.to_string());\n-        let candidate_node = attr.syntax().clone();\n-        Some(Self {\n-            import_candidate: ImportCandidate::Path(PathImportCandidate { qualifier: None, name }),\n-            module_with_candidate: sema.scope(&candidate_node).module()?,\n-            candidate_node,\n-        })\n-    }\n-\n     pub fn for_fuzzy_path(\n         module_with_candidate: Module,\n         qualifier: Option<ast::Path>,"}, {"sha": "1b916e91bfdea77b87324e3c307114b1f1ef5c74", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=bd2b6c40bca71687c5e0d4d15224acd43f647cc6", "patch": "@@ -705,6 +705,15 @@ impl ast::RangePat {\n }\n \n impl ast::TokenTree {\n+    pub fn token_trees_and_tokens(\n+        &self,\n+    ) -> impl Iterator<Item = NodeOrToken<ast::TokenTree, SyntaxToken>> {\n+        self.syntax().children_with_tokens().filter_map(|not| match not {\n+            NodeOrToken::Node(node) => ast::TokenTree::cast(node).map(NodeOrToken::Node),\n+            NodeOrToken::Token(t) => Some(NodeOrToken::Token(t)),\n+        })\n+    }\n+\n     pub fn left_delimiter_token(&self) -> Option<SyntaxToken> {\n         self.syntax()\n             .first_child_or_token()?"}, {"sha": "99ddc188d8140acf1ecfaa51302fe6df4fea17a6", "filename": "docs/dev/architecture.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/docs%2Fdev%2Farchitecture.md", "raw_url": "https://github.com/rust-lang/rust/raw/bd2b6c40bca71687c5e0d4d15224acd43f647cc6/docs%2Fdev%2Farchitecture.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Farchitecture.md?ref=bd2b6c40bca71687c5e0d4d15224acd43f647cc6", "patch": "@@ -111,7 +111,7 @@ env UPDATE_EXPECT=1 cargo qt\n \n After adding a new inline test you need to run `cargo test -p xtask` and also update the test data as described above.\n \n-Note  [`api_walkthrough`](https://github.com/rust-analyzer/rust-analyzer/blob/2fb6af89eb794f775de60b82afe56b6f986c2a40/crates/ra_syntax/src/lib.rs#L190-L348)\n+Note [`api_walkthrough`](https://github.com/rust-analyzer/rust-analyzer/blob/2fb6af89eb794f775de60b82afe56b6f986c2a40/crates/ra_syntax/src/lib.rs#L190-L348)\n in particular: it shows off various methods of working with syntax tree.\n \n See [#93](https://github.com/rust-analyzer/rust-analyzer/pull/93) for an example PR which fixes a bug in the grammar."}]}