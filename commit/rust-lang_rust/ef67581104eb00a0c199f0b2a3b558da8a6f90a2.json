{"sha": "ef67581104eb00a0c199f0b2a3b558da8a6f90a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmNjc1ODExMDRlYjAwYTBjMTk5ZjBiMmEzYjU1OGRhOGE2ZjkwYTI=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2018-12-23T16:13:11Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2018-12-23T16:13:11Z"}, "message": "Resolve paths to defs (functions currently) during type inference", "tree": {"sha": "b6cf180b26152fa06ec4b2d02e22221fb7ba7fad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6cf180b26152fa06ec4b2d02e22221fb7ba7fad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef67581104eb00a0c199f0b2a3b558da8a6f90a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef67581104eb00a0c199f0b2a3b558da8a6f90a2", "html_url": "https://github.com/rust-lang/rust/commit/ef67581104eb00a0c199f0b2a3b558da8a6f90a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef67581104eb00a0c199f0b2a3b558da8a6f90a2/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93ffbf80c632a7d38fc8bbdf6357bfd26a96a35a", "url": "https://api.github.com/repos/rust-lang/rust/commits/93ffbf80c632a7d38fc8bbdf6357bfd26a96a35a", "html_url": "https://github.com/rust-lang/rust/commit/93ffbf80c632a7d38fc8bbdf6357bfd26a96a35a"}], "stats": {"total": 302, "additions": 215, "deletions": 87}, "files": [{"sha": "51cf1825d6bf8cac7a12e0005257abb1334bcdd9", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef67581104eb00a0c199f0b2a3b558da8a6f90a2/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ef67581104eb00a0c199f0b2a3b558da8a6f90a2/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=ef67581104eb00a0c199f0b2a3b558da8a6f90a2", "patch": "@@ -695,6 +695,7 @@ name = \"ra_hir\"\n version = \"0.1.0\"\n dependencies = [\n  \"arrayvec 0.4.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"flexi_logger 0.10.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"id-arena 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "780a84291ac106e4c1850cadc93713b48d40e4de", "filename": "crates/ra_analysis/src/db.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef67581104eb00a0c199f0b2a3b558da8a6f90a2/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef67581104eb00a0c199f0b2a3b558da8a6f90a2/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdb.rs?ref=ef67581104eb00a0c199f0b2a3b558da8a6f90a2", "patch": "@@ -94,6 +94,7 @@ salsa::database_storage! {\n             fn fn_syntax() for hir::db::FnSyntaxQuery;\n             fn submodules() for hir::db::SubmodulesQuery;\n             fn infer() for hir::db::InferQuery;\n+            fn type_for_def() for hir::db::TypeForDefQuery;\n         }\n     }\n }"}, {"sha": "40996bfd738269cab2b3b9cc87c38278df0cc118", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef67581104eb00a0c199f0b2a3b558da8a6f90a2/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef67581104eb00a0c199f0b2a3b558da8a6f90a2/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=ef67581104eb00a0c199f0b2a3b558da8a6f90a2", "patch": "@@ -524,7 +524,7 @@ impl AnalysisImpl {\n         let function = ctry!(source_binder::function_from_source(\n             &*self.db, file_id, parent_fn\n         )?);\n-        let infer = function.infer(&*self.db);\n+        let infer = function.infer(&*self.db)?;\n         Ok(infer.type_of_node(node).map(|t| t.to_string()))\n     }\n "}, {"sha": "594176337d4b886656bd7977adc865076f80ade6", "filename": "crates/ra_hir/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef67581104eb00a0c199f0b2a3b558da8a6f90a2/crates%2Fra_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ef67581104eb00a0c199f0b2a3b558da8a6f90a2/crates%2Fra_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2FCargo.toml?ref=ef67581104eb00a0c199f0b2a3b558da8a6f90a2", "patch": "@@ -16,3 +16,6 @@ ra_syntax = { path = \"../ra_syntax\" }\n ra_editor = { path = \"../ra_editor\" }\n ra_db = { path = \"../ra_db\" }\n test_utils = { path = \"../test_utils\" }\n+\n+[dev-dependencies]\n+flexi_logger = \"0.10.0\""}, {"sha": "d94f75857fca5b64b62b4cf89640716ee93e2f8e", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ef67581104eb00a0c199f0b2a3b558da8a6f90a2/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef67581104eb00a0c199f0b2a3b558da8a6f90a2/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=ef67581104eb00a0c199f0b2a3b558da8a6f90a2", "patch": "@@ -14,7 +14,7 @@ use crate::{\n     function::FnId,\n     module::{ModuleId, ModuleTree, ModuleSource,\n     nameres::{ItemMap, InputModuleItems}},\n-    ty::InferenceResult,\n+    ty::{InferenceResult, Ty},\n };\n \n salsa::query_group! {\n@@ -31,11 +31,16 @@ pub trait HirDatabase: SyntaxDatabase\n         use fn query_definitions::fn_syntax;\n     }\n \n-    fn infer(fn_id: FnId) -> Arc<InferenceResult> {\n+    fn infer(fn_id: FnId) -> Cancelable<Arc<InferenceResult>> {\n         type InferQuery;\n         use fn query_definitions::infer;\n     }\n \n+    fn type_for_def(def_id: DefId) -> Cancelable<Ty> {\n+        type TypeForDefQuery;\n+        use fn query_definitions::type_for_def;\n+    }\n+\n     fn file_items(file_id: FileId) -> Arc<SourceFileItems> {\n         type SourceFileItemsQuery;\n         use fn query_definitions::file_items;"}, {"sha": "d36477b48d1dbb045fbda5f524d5fcb082fcc7c4", "filename": "crates/ra_hir/src/function.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ef67581104eb00a0c199f0b2a3b558da8a6f90a2/crates%2Fra_hir%2Fsrc%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef67581104eb00a0c199f0b2a3b558da8a6f90a2/crates%2Fra_hir%2Fsrc%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffunction.rs?ref=ef67581104eb00a0c199f0b2a3b558da8a6f90a2", "patch": "@@ -5,20 +5,21 @@ use std::{\n     sync::Arc,\n };\n \n+use ra_db::Cancelable;\n use ra_syntax::{\n     TextRange, TextUnit,\n     ast::{self, AstNode, DocCommentsOwner, NameOwner},\n };\n \n-use crate::{ DefId, HirDatabase, ty::InferenceResult };\n+use crate::{ DefId, HirDatabase, ty::InferenceResult, Module };\n \n pub use self::scope::FnScopes;\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub struct FnId(pub(crate) DefId);\n \n pub struct Function {\n-    fn_id: FnId,\n+    pub(crate) fn_id: FnId,\n }\n \n impl Function {\n@@ -27,6 +28,10 @@ impl Function {\n         Function { fn_id }\n     }\n \n+    pub fn syntax(&self, db: &impl HirDatabase) -> ast::FnDefNode {\n+        db.fn_syntax(self.fn_id)\n+    }\n+\n     pub fn scopes(&self, db: &impl HirDatabase) -> Arc<FnScopes> {\n         db.fn_scopes(self.fn_id)\n     }\n@@ -36,9 +41,14 @@ impl Function {\n         FnSignatureInfo::new(syntax.borrowed())\n     }\n \n-    pub fn infer(&self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n+    pub fn infer(&self, db: &impl HirDatabase) -> Cancelable<Arc<InferenceResult>> {\n         db.infer(self.fn_id)\n     }\n+\n+    pub fn module(&self, db: &impl HirDatabase) -> Cancelable<Module> {\n+        let loc = self.fn_id.0.loc(db);\n+        Module::new(db, loc.source_root_id, loc.module_id)\n+    }\n }\n \n #[derive(Debug, Clone)]"}, {"sha": "a0d99a84dfa556d69b6b52b2554de28a302a64ca", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ef67581104eb00a0c199f0b2a3b558da8a6f90a2/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef67581104eb00a0c199f0b2a3b558da8a6f90a2/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=ef67581104eb00a0c199f0b2a3b558da8a6f90a2", "patch": "@@ -29,7 +29,7 @@ mod ty;\n \n use std::ops::Index;\n \n-use ra_syntax::{SyntaxNodeRef, SyntaxNode};\n+use ra_syntax::{SyntaxNodeRef, SyntaxNode, SyntaxKind};\n use ra_db::{LocationIntener, SourceRootId, FileId, Cancelable};\n \n use crate::{\n@@ -67,6 +67,23 @@ pub struct DefLoc {\n     source_item_id: SourceItemId,\n }\n \n+impl DefKind {\n+    pub(crate) fn for_syntax_kind(kind: SyntaxKind) -> Option<DefKind> {\n+        match kind {\n+            SyntaxKind::FN_DEF => Some(DefKind::Function),\n+            SyntaxKind::MODULE => Some(DefKind::Module),\n+            // These define items, but don't have their own DefKinds yet:\n+            SyntaxKind::STRUCT_DEF => Some(DefKind::Item),\n+            SyntaxKind::ENUM_DEF => Some(DefKind::Item),\n+            SyntaxKind::TRAIT_DEF => Some(DefKind::Item),\n+            SyntaxKind::TYPE_DEF => Some(DefKind::Item),\n+            SyntaxKind::CONST_DEF => Some(DefKind::Item),\n+            SyntaxKind::STATIC_DEF => Some(DefKind::Item),\n+            _ => None,\n+        }\n+    }\n+}\n+\n impl DefId {\n     pub(crate) fn loc(self, db: &impl AsRef<LocationIntener<DefLoc, DefId>>) -> DefLoc {\n         db.as_ref().id2loc(self)"}, {"sha": "b5a99717072ac8835dc10c025287e34a98fc7959", "filename": "crates/ra_hir/src/mock.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef67581104eb00a0c199f0b2a3b558da8a6f90a2/crates%2Fra_hir%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef67581104eb00a0c199f0b2a3b558da8a6f90a2/crates%2Fra_hir%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmock.rs?ref=ef67581104eb00a0c199f0b2a3b558da8a6f90a2", "patch": "@@ -192,6 +192,7 @@ salsa::database_storage! {\n             fn fn_syntax() for db::FnSyntaxQuery;\n             fn submodules() for db::SubmodulesQuery;\n             fn infer() for db::InferQuery;\n+            fn type_for_def() for db::TypeForDefQuery;\n         }\n     }\n }"}, {"sha": "89111995306d5cca58ee57029c6dfb665f38f725", "filename": "crates/ra_hir/src/module.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef67581104eb00a0c199f0b2a3b558da8a6f90a2/crates%2Fra_hir%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef67581104eb00a0c199f0b2a3b558da8a6f90a2/crates%2Fra_hir%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule.rs?ref=ef67581104eb00a0c199f0b2a3b558da8a6f90a2", "patch": "@@ -2,6 +2,7 @@ pub(super) mod imp;\n pub(super) mod nameres;\n \n use std::sync::Arc;\n+use log;\n \n use ra_syntax::{\n     algo::generate,"}, {"sha": "0b152a406230ab94005589b0afd4dd71c93c70bc", "filename": "crates/ra_hir/src/module/nameres.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef67581104eb00a0c199f0b2a3b558da8a6f90a2/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef67581104eb00a0c199f0b2a3b558da8a6f90a2/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs?ref=ef67581104eb00a0c199f0b2a3b558da8a6f90a2", "patch": "@@ -272,13 +272,13 @@ where\n                 }\n             }\n         }\n-        // Populate explicitelly declared items, except modules\n+        // Populate explicitly declared items, except modules\n         for item in input.items.iter() {\n             if item.kind == MODULE {\n                 continue;\n             }\n             let def_loc = DefLoc {\n-                kind: DefKind::Item,\n+                kind: DefKind::for_syntax_kind(item.kind).unwrap_or(DefKind::Item),\n                 source_root_id: self.source_root,\n                 module_id,\n                 source_item_id: SourceItemId {"}, {"sha": "b654af9204f35fb8b60801d7b23748cc77a8f3bd", "filename": "crates/ra_hir/src/query_definitions.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ef67581104eb00a0c199f0b2a3b558da8a6f90a2/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef67581104eb00a0c199f0b2a3b558da8a6f90a2/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs?ref=ef67581104eb00a0c199f0b2a3b558da8a6f90a2", "patch": "@@ -11,15 +11,15 @@ use ra_syntax::{\n use ra_db::{SourceRootId, FileId, Cancelable,};\n \n use crate::{\n-    SourceFileItems, SourceItemId, DefKind,\n+    SourceFileItems, SourceItemId, DefKind, Function, DefId,\n     db::HirDatabase,\n     function::{FnScopes, FnId},\n     module::{\n         ModuleSource, ModuleSourceNode, ModuleId,\n         imp::Submodule,\n         nameres::{InputModuleItems, ItemMap, Resolver},\n     },\n-    ty::{self, InferenceResult}\n+    ty::{self, InferenceResult, Ty}\n };\n \n /// Resolve `FnId` to the corresponding `SyntaxNode`\n@@ -36,11 +36,13 @@ pub(super) fn fn_scopes(db: &impl HirDatabase, fn_id: FnId) -> Arc<FnScopes> {\n     Arc::new(res)\n }\n \n-pub(super) fn infer(db: &impl HirDatabase, fn_id: FnId) -> Arc<InferenceResult> {\n-    let syntax = db.fn_syntax(fn_id);\n-    let scopes = db.fn_scopes(fn_id);\n-    let res = ty::infer(db, syntax.borrowed(), scopes);\n-    Arc::new(res)\n+pub(super) fn infer(db: &impl HirDatabase, fn_id: FnId) -> Cancelable<Arc<InferenceResult>> {\n+    let function = Function { fn_id };\n+    ty::infer(db, function).map(Arc::new)\n+}\n+\n+pub(super) fn type_for_def(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Ty> {\n+    ty::type_for_def(db, def_id)\n }\n \n pub(super) fn file_items(db: &impl HirDatabase, file_id: FileId) -> Arc<SourceFileItems> {"}, {"sha": "13ee6cb2750f431b0a2c6871c877910e8f4dbafc", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 127, "deletions": 68, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/ef67581104eb00a0c199f0b2a3b558da8a6f90a2/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef67581104eb00a0c199f0b2a3b558da8a6f90a2/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=ef67581104eb00a0c199f0b2a3b558da8a6f90a2", "patch": "@@ -5,21 +5,17 @@ mod tests;\n use std::sync::Arc;\n use std::fmt;\n \n+use log;\n use rustc_hash::{FxHashMap};\n \n-use ra_db::LocalSyntaxPtr;\n+use ra_db::{LocalSyntaxPtr, Cancelable};\n use ra_syntax::{\n     SmolStr,\n     ast::{self, AstNode, LoopBodyOwner, ArgListOwner},\n     SyntaxNodeRef\n };\n \n-use crate::{\n-    FnScopes,\n-    db::HirDatabase,\n-};\n-\n-// pub(crate) type TypeId = Id<Ty>;\n+use crate::{Def, DefId, FnScopes, Module, Function, Path, db::HirDatabase};\n \n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n pub enum Ty {\n@@ -65,18 +61,6 @@ pub enum Ty {\n     /// `&'a mut T` or `&'a T`.\n     // Ref(Region<'tcx>, Ty<'tcx>, hir::Mutability),\n \n-    /// The anonymous type of a function declaration/definition. Each\n-    /// function has a unique type, which is output (for a function\n-    /// named `foo` returning an `i32`) as `fn() -> i32 {foo}`.\n-    ///\n-    /// For example the type of `bar` here:\n-    ///\n-    /// ```rust\n-    /// fn foo() -> i32 { 1 }\n-    /// let bar = foo; // bar: fn() -> i32 {foo}\n-    /// ```\n-    // FnDef(DefId, &'tcx Substs<'tcx>),\n-\n     /// A pointer to a function.  Written as `fn() -> i32`.\n     ///\n     /// For example the type of `bar` here:\n@@ -85,7 +69,7 @@ pub enum Ty {\n     /// fn foo() -> i32 { 1 }\n     /// let bar: fn() -> i32 = foo;\n     /// ```\n-    // FnPtr(PolyFnSig<'tcx>),\n+    FnPtr(Arc<FnSig>),\n \n     /// A trait, defined with `trait`.\n     // Dynamic(Binder<&'tcx List<ExistentialPredicate<'tcx>>>, ty::Region<'tcx>),\n@@ -139,6 +123,12 @@ pub enum Ty {\n \n type TyRef = Arc<Ty>;\n \n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+pub struct FnSig {\n+    input: Vec<Ty>,\n+    output: Ty,\n+}\n+\n impl Ty {\n     pub fn new(node: ast::TypeRef) -> Self {\n         use ra_syntax::ast::TypeRef::*;\n@@ -208,11 +198,55 @@ impl fmt::Display for Ty {\n                 }\n                 write!(f, \")\")\n             }\n+            Ty::FnPtr(sig) => {\n+                write!(f, \"fn(\")?;\n+                for t in &sig.input {\n+                    write!(f, \"{},\", t)?;\n+                }\n+                write!(f, \") -> {}\", sig.output)\n+            }\n             Ty::Unknown => write!(f, \"[unknown]\"),\n         }\n     }\n }\n \n+pub fn type_for_fn(db: &impl HirDatabase, f: Function) -> Cancelable<Ty> {\n+    eprintln!(\"type_for_fn {:?}\", f.fn_id);\n+    let syntax = f.syntax(db);\n+    let node = syntax.borrowed();\n+    // TODO we ignore type parameters for now\n+    let input = node\n+        .param_list()\n+        .map(|pl| {\n+            pl.params()\n+                .map(|p| p.type_ref().map(|t| Ty::new(t)).unwrap_or(Ty::Unknown))\n+                .collect()\n+        })\n+        .unwrap_or_else(Vec::new);\n+    let output = node\n+        .ret_type()\n+        .and_then(|rt| rt.type_ref())\n+        .map(|t| Ty::new(t))\n+        .unwrap_or(Ty::Unknown);\n+    let sig = FnSig { input, output };\n+    Ok(Ty::FnPtr(Arc::new(sig)))\n+}\n+\n+pub fn type_for_def(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Ty> {\n+    let def = def_id.resolve(db)?;\n+    match def {\n+        Def::Module(..) => {\n+            log::debug!(\"trying to get type for module {:?}\", def_id);\n+            Ok(Ty::Unknown)\n+        }\n+        Def::Function(f) => type_for_fn(db, f),\n+        Def::Item => {\n+            log::debug!(\"trying to get type for item of unknown type {:?}\", def_id);\n+            Ok(Ty::Unknown)\n+        }\n+    }\n+}\n+\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct InferenceResult {\n     type_for: FxHashMap<LocalSyntaxPtr, Ty>,\n@@ -224,18 +258,22 @@ impl InferenceResult {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct InferenceContext {\n+#[derive(Clone, Debug)]\n+pub struct InferenceContext<'a, D: HirDatabase> {\n+    db: &'a D,\n     scopes: Arc<FnScopes>,\n+    module: Module,\n     // TODO unification tables...\n     type_for: FxHashMap<LocalSyntaxPtr, Ty>,\n }\n \n-impl InferenceContext {\n-    fn new(scopes: Arc<FnScopes>) -> Self {\n+impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n+    fn new(db: &'a D, scopes: Arc<FnScopes>, module: Module) -> Self {\n         InferenceContext {\n             type_for: FxHashMap::default(),\n+            db,\n             scopes,\n+            module,\n         }\n     }\n \n@@ -262,36 +300,42 @@ impl InferenceContext {\n         self.unify(ty1, ty2)\n     }\n \n-    fn infer_path_expr(&mut self, expr: ast::PathExpr) -> Option<Ty> {\n-        let p = expr.path()?;\n-        if p.qualifier().is_none() {\n-            let name = p.segment().and_then(|s| s.name_ref())?;\n-            let scope_entry = self.scopes.resolve_local_name(name)?;\n-            let ty = self.type_for.get(&scope_entry.ptr())?;\n-            Some(ty.clone())\n-        } else {\n-            // TODO resolve path\n-            Some(Ty::Unknown)\n-        }\n+    fn infer_path_expr(&mut self, expr: ast::PathExpr) -> Cancelable<Option<Ty>> {\n+        let ast_path = ctry!(expr.path());\n+        let path = ctry!(Path::from_ast(ast_path));\n+        if path.is_ident() {\n+            // resolve locally\n+            let name = ctry!(ast_path.segment().and_then(|s| s.name_ref()));\n+            if let Some(scope_entry) = self.scopes.resolve_local_name(name) {\n+                let ty = ctry!(self.type_for.get(&scope_entry.ptr()));\n+                return Ok(Some(ty.clone()));\n+            };\n+        };\n+\n+        // resolve in module\n+        let resolved = ctry!(self.module.resolve_path(self.db, path)?);\n+        let ty = self.db.type_for_def(resolved)?;\n+        // TODO we will need to add type variables for type parameters etc. here\n+        Ok(Some(ty))\n     }\n \n-    fn infer_expr(&mut self, expr: ast::Expr) -> Ty {\n+    fn infer_expr(&mut self, expr: ast::Expr) -> Cancelable<Ty> {\n         let ty = match expr {\n             ast::Expr::IfExpr(e) => {\n                 if let Some(condition) = e.condition() {\n                     if let Some(e) = condition.expr() {\n                         // TODO if no pat, this should be bool\n-                        self.infer_expr(e);\n+                        self.infer_expr(e)?;\n                     }\n                     // TODO write type for pat\n                 };\n                 let if_ty = if let Some(block) = e.then_branch() {\n-                    self.infer_block(block)\n+                    self.infer_block(block)?\n                 } else {\n                     Ty::Unknown\n                 };\n                 let else_ty = if let Some(block) = e.else_branch() {\n-                    self.infer_block(block)\n+                    self.infer_block(block)?\n                 } else {\n                     Ty::Unknown\n                 };\n@@ -304,14 +348,14 @@ impl InferenceContext {\n             }\n             ast::Expr::BlockExpr(e) => {\n                 if let Some(block) = e.block() {\n-                    self.infer_block(block)\n+                    self.infer_block(block)?\n                 } else {\n                     Ty::Unknown\n                 }\n             }\n             ast::Expr::LoopExpr(e) => {\n                 if let Some(block) = e.loop_body() {\n-                    self.infer_block(block);\n+                    self.infer_block(block)?;\n                 };\n                 // TODO never, or the type of the break param\n                 Ty::Unknown\n@@ -320,59 +364,69 @@ impl InferenceContext {\n                 if let Some(condition) = e.condition() {\n                     if let Some(e) = condition.expr() {\n                         // TODO if no pat, this should be bool\n-                        self.infer_expr(e);\n+                        self.infer_expr(e)?;\n                     }\n                     // TODO write type for pat\n                 };\n                 if let Some(block) = e.loop_body() {\n                     // TODO\n-                    self.infer_block(block);\n+                    self.infer_block(block)?;\n                 };\n                 // TODO always unit?\n                 Ty::Unknown\n             }\n             ast::Expr::ForExpr(e) => {\n                 if let Some(expr) = e.iterable() {\n-                    self.infer_expr(expr);\n+                    self.infer_expr(expr)?;\n                 }\n                 if let Some(_pat) = e.pat() {\n                     // TODO write type for pat\n                 }\n                 if let Some(block) = e.loop_body() {\n-                    self.infer_block(block);\n+                    self.infer_block(block)?;\n                 }\n                 // TODO always unit?\n                 Ty::Unknown\n             }\n             ast::Expr::LambdaExpr(e) => {\n                 let _body_ty = if let Some(body) = e.body() {\n-                    self.infer_expr(body)\n+                    self.infer_expr(body)?\n                 } else {\n                     Ty::Unknown\n                 };\n                 Ty::Unknown\n             }\n             ast::Expr::CallExpr(e) => {\n+                let _callee_ty = if let Some(e) = e.expr() {\n+                    self.infer_expr(e)?\n+                } else {\n+                    Ty::Unknown\n+                };\n                 if let Some(arg_list) = e.arg_list() {\n                     for arg in arg_list.args() {\n                         // TODO unify / expect argument type\n-                        self.infer_expr(arg);\n+                        self.infer_expr(arg)?;\n                     }\n                 }\n                 Ty::Unknown\n             }\n             ast::Expr::MethodCallExpr(e) => {\n+                let _receiver_ty = if let Some(e) = e.expr() {\n+                    self.infer_expr(e)?\n+                } else {\n+                    Ty::Unknown\n+                };\n                 if let Some(arg_list) = e.arg_list() {\n                     for arg in arg_list.args() {\n                         // TODO unify / expect argument type\n-                        self.infer_expr(arg);\n+                        self.infer_expr(arg)?;\n                     }\n                 }\n                 Ty::Unknown\n             }\n             ast::Expr::MatchExpr(e) => {\n                 let _ty = if let Some(match_expr) = e.expr() {\n-                    self.infer_expr(match_expr)\n+                    self.infer_expr(match_expr)?\n                 } else {\n                     Ty::Unknown\n                 };\n@@ -381,7 +435,7 @@ impl InferenceContext {\n                         // TODO type the bindings in pat\n                         // TODO type the guard\n                         let _ty = if let Some(e) = arm.expr() {\n-                            self.infer_expr(e)\n+                            self.infer_expr(e)?\n                         } else {\n                             Ty::Unknown\n                         };\n@@ -394,12 +448,12 @@ impl InferenceContext {\n             }\n             ast::Expr::TupleExpr(_e) => Ty::Unknown,\n             ast::Expr::ArrayExpr(_e) => Ty::Unknown,\n-            ast::Expr::PathExpr(e) => self.infer_path_expr(e).unwrap_or(Ty::Unknown),\n+            ast::Expr::PathExpr(e) => self.infer_path_expr(e)?.unwrap_or(Ty::Unknown),\n             ast::Expr::ContinueExpr(_e) => Ty::Never,\n             ast::Expr::BreakExpr(_e) => Ty::Never,\n             ast::Expr::ParenExpr(e) => {\n                 if let Some(e) = e.expr() {\n-                    self.infer_expr(e)\n+                    self.infer_expr(e)?\n                 } else {\n                     Ty::Unknown\n                 }\n@@ -408,7 +462,7 @@ impl InferenceContext {\n             ast::Expr::ReturnExpr(e) => {\n                 if let Some(e) = e.expr() {\n                     // TODO unify with return type\n-                    self.infer_expr(e);\n+                    self.infer_expr(e)?;\n                 };\n                 Ty::Never\n             }\n@@ -425,15 +479,15 @@ impl InferenceContext {\n             ast::Expr::FieldExpr(_e) => Ty::Unknown,\n             ast::Expr::TryExpr(e) => {\n                 let _inner_ty = if let Some(e) = e.expr() {\n-                    self.infer_expr(e)\n+                    self.infer_expr(e)?\n                 } else {\n                     Ty::Unknown\n                 };\n                 Ty::Unknown\n             }\n             ast::Expr::CastExpr(e) => {\n                 let _inner_ty = if let Some(e) = e.expr() {\n-                    self.infer_expr(e)\n+                    self.infer_expr(e)?\n                 } else {\n                     Ty::Unknown\n                 };\n@@ -443,15 +497,15 @@ impl InferenceContext {\n             }\n             ast::Expr::RefExpr(e) => {\n                 let _inner_ty = if let Some(e) = e.expr() {\n-                    self.infer_expr(e)\n+                    self.infer_expr(e)?\n                 } else {\n                     Ty::Unknown\n                 };\n                 Ty::Unknown\n             }\n             ast::Expr::PrefixExpr(e) => {\n                 let _inner_ty = if let Some(e) = e.expr() {\n-                    self.infer_expr(e)\n+                    self.infer_expr(e)?\n                 } else {\n                     Ty::Unknown\n                 };\n@@ -462,10 +516,10 @@ impl InferenceContext {\n             ast::Expr::Literal(_e) => Ty::Unknown,\n         };\n         self.write_ty(expr.syntax(), ty.clone());\n-        ty\n+        Ok(ty)\n     }\n \n-    fn infer_block(&mut self, node: ast::Block) -> Ty {\n+    fn infer_block(&mut self, node: ast::Block) -> Cancelable<Ty> {\n         for stmt in node.statements() {\n             match stmt {\n                 ast::Stmt::LetStmt(stmt) => {\n@@ -476,7 +530,7 @@ impl InferenceContext {\n                     };\n                     let ty = if let Some(expr) = stmt.initializer() {\n                         // TODO pass expectation\n-                        let expr_ty = self.infer_expr(expr);\n+                        let expr_ty = self.infer_expr(expr)?;\n                         self.unify_with_coercion(&expr_ty, &decl_ty)\n                             .unwrap_or(decl_ty)\n                     } else {\n@@ -489,23 +543,28 @@ impl InferenceContext {\n                 }\n                 ast::Stmt::ExprStmt(expr_stmt) => {\n                     if let Some(expr) = expr_stmt.expr() {\n-                        self.infer_expr(expr);\n+                        self.infer_expr(expr)?;\n                     }\n                 }\n             }\n         }\n         let ty = if let Some(expr) = node.expr() {\n-            self.infer_expr(expr)\n+            self.infer_expr(expr)?\n         } else {\n             Ty::unit()\n         };\n         self.write_ty(node.syntax(), ty.clone());\n-        ty\n+        Ok(ty)\n     }\n }\n \n-pub fn infer(_db: &impl HirDatabase, node: ast::FnDef, scopes: Arc<FnScopes>) -> InferenceResult {\n-    let mut ctx = InferenceContext::new(scopes);\n+pub fn infer(db: &impl HirDatabase, function: Function) -> Cancelable<InferenceResult> {\n+    let scopes = function.scopes(db);\n+    let module = function.module(db)?;\n+    let mut ctx = InferenceContext::new(db, scopes, module);\n+\n+    let syntax = function.syntax(db);\n+    let node = syntax.borrowed();\n \n     if let Some(param_list) = node.param_list() {\n         for param in param_list.params() {\n@@ -529,12 +588,12 @@ pub fn infer(_db: &impl HirDatabase, node: ast::FnDef, scopes: Arc<FnScopes>) ->\n     // (see Expectation in rustc_typeck)\n \n     if let Some(block) = node.body() {\n-        ctx.infer_block(block);\n+        ctx.infer_block(block)?;\n     }\n \n     // TODO 'resolve' the types: replace inference variables by their inferred results\n \n-    InferenceResult {\n+    Ok(InferenceResult {\n         type_for: ctx.type_for,\n-    }\n+    })\n }"}, {"sha": "e0458327ae6f1c1c24069307938d2e643b33ee6d", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ef67581104eb00a0c199f0b2a3b558da8a6f90a2/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef67581104eb00a0c199f0b2a3b558da8a6f90a2/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=ef67581104eb00a0c199f0b2a3b558da8a6f90a2", "patch": "@@ -1,5 +1,8 @@\n use std::fmt::Write;\n use std::path::{PathBuf};\n+use std::sync::Once;\n+\n+use flexi_logger::Logger;\n \n use ra_db::{SyntaxDatabase};\n use ra_syntax::ast::{self, AstNode};\n@@ -22,7 +25,7 @@ fn infer_file(content: &str) -> String {\n         let func = source_binder::function_from_source(&db, file_id, fn_def)\n             .unwrap()\n             .unwrap();\n-        let inference_result = func.infer(&db);\n+        let inference_result = func.infer(&db).unwrap();\n         for (syntax_ptr, ty) in &inference_result.type_for {\n             let node = syntax_ptr.resolve(&source_file);\n             write!(\n@@ -58,6 +61,8 @@ fn ellipsize(mut text: String, max_len: usize) -> String {\n \n #[test]\n pub fn infer_tests() {\n+    static INIT: Once = Once::new();\n+    INIT.call_once(|| Logger::with_env().start().unwrap());\n     dir_tests(&test_data_dir(), &[\".\"], |text, _path| infer_file(text));\n }\n "}, {"sha": "e8b11198bbca03f8d613427aa7da05e3a15dde71", "filename": "crates/ra_hir/src/ty/tests/data/0003_paths.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ef67581104eb00a0c199f0b2a3b558da8a6f90a2/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0003_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef67581104eb00a0c199f0b2a3b558da8a6f90a2/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0003_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0003_paths.rs?ref=ef67581104eb00a0c199f0b2a3b558da8a6f90a2", "patch": "@@ -0,0 +1,10 @@\n+fn a() -> u32 { 1 }\n+\n+mod b {\n+    fn c() -> u32 { 1 }\n+}\n+\n+fn test() {\n+    a();\n+    b::c();\n+}"}, {"sha": "3a53370a2791d5914083e5da2d20b58f2dc6f962", "filename": "crates/ra_hir/src/ty/tests/data/0003_paths.txt", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ef67581104eb00a0c199f0b2a3b558da8a6f90a2/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0003_paths.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ef67581104eb00a0c199f0b2a3b558da8a6f90a2/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0003_paths.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0003_paths.txt?ref=ef67581104eb00a0c199f0b2a3b558da8a6f90a2", "patch": "@@ -0,0 +1,9 @@\n+[16; 17) '1': [unknown]\n+[14; 19) '{ 1 }': [unknown]\n+[47; 52) '{ 1 }': [unknown]\n+[49; 50) '1': [unknown]\n+[81; 87) 'b::c()': [unknown]\n+[66; 90) '{     ...c(); }': ()\n+[72; 73) 'a': fn() -> u32\n+[72; 75) 'a()': [unknown]\n+[81; 85) 'b::c': fn() -> u32"}, {"sha": "c735338619aa09b3a784b2c1d42538e1c5c341b0", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef67581104eb00a0c199f0b2a3b558da8a6f90a2/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef67581104eb00a0c199f0b2a3b558da8a6f90a2/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=ef67581104eb00a0c199f0b2a3b558da8a6f90a2", "patch": "@@ -3083,7 +3083,11 @@ impl<R: TreeRoot<RaTypes>> RetTypeNode<R> {\n }\n \n \n-impl<'a> RetType<'a> {}\n+impl<'a> RetType<'a> {\n+    pub fn type_ref(self) -> Option<TypeRef<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n \n // ReturnExpr\n #[derive(Debug, Clone, Copy,)]"}, {"sha": "e3b9032a0c6eb45ddf49168efcfc771865fcfd48", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef67581104eb00a0c199f0b2a3b558da8a6f90a2/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/ef67581104eb00a0c199f0b2a3b558da8a6f90a2/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=ef67581104eb00a0c199f0b2a3b558da8a6f90a2", "patch": "@@ -254,7 +254,7 @@ Grammar(\n             ],\n             options: [ \"ParamList\", [\"body\", \"Block\"], \"RetType\" ],\n         ),\n-        \"RetType\": (),\n+        \"RetType\": (options: [\"TypeRef\"]),\n         \"StructDef\": (\n             traits: [\n                 \"NameOwner\","}]}