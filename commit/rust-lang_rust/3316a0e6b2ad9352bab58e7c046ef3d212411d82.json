{"sha": "3316a0e6b2ad9352bab58e7c046ef3d212411d82", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzMTZhMGU2YjJhZDkzNTJiYWI1OGU3YzA0NmVmM2QyMTI0MTFkODI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-12T19:12:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-12T19:12:05Z"}, "message": "auto merge of #12797 : pczarn/rust/str_safety, r=huonw\n\nAlong the lines of `shift_ref` and `pop_ref`.", "tree": {"sha": "9f06684bd21594f62cddd650af215b593a5c2f7c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f06684bd21594f62cddd650af215b593a5c2f7c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3316a0e6b2ad9352bab58e7c046ef3d212411d82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3316a0e6b2ad9352bab58e7c046ef3d212411d82", "html_url": "https://github.com/rust-lang/rust/commit/3316a0e6b2ad9352bab58e7c046ef3d212411d82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3316a0e6b2ad9352bab58e7c046ef3d212411d82/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18356675e51ca1d01493718df3f6feed52f096a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/18356675e51ca1d01493718df3f6feed52f096a9", "html_url": "https://github.com/rust-lang/rust/commit/18356675e51ca1d01493718df3f6feed52f096a9"}, {"sha": "b0e855a7584b9893d9fe19d2eb9e7272e0c90a6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0e855a7584b9893d9fe19d2eb9e7272e0c90a6f", "html_url": "https://github.com/rust-lang/rust/commit/b0e855a7584b9893d9fe19d2eb9e7272e0c90a6f"}], "stats": {"total": 145, "additions": 85, "deletions": 60}, "files": [{"sha": "a33d041ab20c8eb8903232c3088ba4196eb1d777", "filename": "src/libglob/lib.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3316a0e6b2ad9352bab58e7c046ef3d212411d82/src%2Flibglob%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3316a0e6b2ad9352bab58e7c046ef3d212411d82/src%2Flibglob%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibglob%2Flib.rs?ref=3316a0e6b2ad9352bab58e7c046ef3d212411d82", "patch": "@@ -369,11 +369,11 @@ impl Pattern {\n                             return EntirePatternDoesntMatch;\n                         }\n \n-                        let (c, next) = file.slice_shift_char();\n-                        if require_literal(c) {\n+                        let (some_c, next) = file.slice_shift_char();\n+                        if require_literal(some_c.unwrap()) {\n                             return SubPatternDoesntMatch;\n                         }\n-                        prev_char.set(Some(c));\n+                        prev_char.set(some_c);\n                         file = next;\n                     }\n                 }\n@@ -382,7 +382,8 @@ impl Pattern {\n                         return EntirePatternDoesntMatch;\n                     }\n \n-                    let (c, next) = file.slice_shift_char();\n+                    let (some_c, next) = file.slice_shift_char();\n+                    let c = some_c.unwrap();\n                     let matches = match *token {\n                         AnyChar => {\n                             !require_literal(c)\n@@ -403,7 +404,7 @@ impl Pattern {\n                     if !matches {\n                         return SubPatternDoesntMatch;\n                     }\n-                    prev_char.set(Some(c));\n+                    prev_char.set(some_c);\n                     file = next;\n                 }\n             }"}, {"sha": "5bd14e717b1b91b11eb246a31b07b47af2b41b24", "filename": "src/libstd/str.rs", "status": "modified", "additions": 75, "deletions": 51, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/3316a0e6b2ad9352bab58e7c046ef3d212411d82/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3316a0e6b2ad9352bab58e7c046ef3d212411d82/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=3316a0e6b2ad9352bab58e7c046ef3d212411d82", "patch": "@@ -1355,6 +1355,7 @@ pub mod raw {\n     use libc;\n     use ptr;\n     use ptr::RawPtr;\n+    use option::{Option, Some, None};\n     use str::{is_utf8, OwnedStr, StrSlice};\n     use vec;\n     use vec::{MutableVector, ImmutableVector, OwnedVector};\n@@ -1464,23 +1465,31 @@ pub mod raw {\n     }\n \n     /// Removes the last byte from a string and returns it.\n+    /// Returns None when an empty string is passed.\n     /// The caller must preserve the valid UTF-8 property.\n-    pub unsafe fn pop_byte(s: &mut ~str) -> u8 {\n+    pub unsafe fn pop_byte(s: &mut ~str) -> Option<u8> {\n         let len = s.len();\n-        assert!((len > 0u));\n-        let b = s[len - 1u];\n-        s.set_len(len - 1);\n-        return b;\n+        if len == 0u {\n+            return None;\n+        } else {\n+            let b = s[len - 1u];\n+            s.set_len(len - 1);\n+            return Some(b);\n+        }\n     }\n \n     /// Removes the first byte from a string and returns it.\n+    /// Returns None when an empty string is passed.\n     /// The caller must preserve the valid UTF-8 property.\n-    pub unsafe fn shift_byte(s: &mut ~str) -> u8 {\n+    pub unsafe fn shift_byte(s: &mut ~str) -> Option<u8> {\n         let len = s.len();\n-        assert!((len > 0u));\n-        let b = s[0];\n-        *s = s.slice(1, len).to_owned();\n-        return b;\n+        if len == 0u {\n+            return None;\n+        } else {\n+            let b = s[0];\n+            *s = s.slice(1, len).to_owned();\n+            return Some(b);\n+        }\n     }\n \n     /// Access the str in its vector representation.\n@@ -2273,25 +2282,22 @@ pub trait StrSlice<'a> {\n     /// Retrieves the first character from a string slice and returns\n     /// it. This does not allocate a new string; instead, it returns a\n     /// slice that point one character beyond the character that was\n-    /// shifted.\n-    ///\n-    /// # Failure\n-    ///\n-    /// If the string does not contain any characters.\n+    /// shifted. If the string does not contain any characters,\n+    /// a tuple of None and an empty string is returned instead.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     /// let (c, s1) = s.slice_shift_char();\n-    /// assert_eq!(c, 'L');\n+    /// assert_eq!(c, Some('L'));\n     /// assert_eq!(s1, \"\u00f6we \u8001\u864e L\u00e9opard\");\n     ///\n     /// let (c, s2) = s1.slice_shift_char();\n-    /// assert_eq!(c, '\u00f6');\n+    /// assert_eq!(c, Some('\u00f6'));\n     /// assert_eq!(s2, \"we \u8001\u864e L\u00e9opard\");\n     /// ```\n-    fn slice_shift_char(&self) -> (char, &'a str);\n+    fn slice_shift_char(&self) -> (Option<char>, &'a str);\n \n     /// Levenshtein Distance between two strings.\n     fn lev_distance(&self, t: &str) -> uint;\n@@ -2744,10 +2750,14 @@ impl<'a> StrSlice<'a> for &'a str {\n     }\n \n     #[inline]\n-    fn slice_shift_char(&self) -> (char, &'a str) {\n-        let CharRange {ch, next} = self.char_range_at(0u);\n-        let next_s = unsafe { raw::slice_bytes(*self, next, self.len()) };\n-        return (ch, next_s);\n+    fn slice_shift_char(&self) -> (Option<char>, &'a str) {\n+        if self.is_empty() {\n+            return (None, *self);\n+        } else {\n+            let CharRange {ch, next} = self.char_range_at(0u);\n+            let next_s = unsafe { raw::slice_bytes(*self, next, self.len()) };\n+            return (Some(ch), next_s);\n+        }\n     }\n \n     fn lev_distance(&self, t: &str) -> uint {\n@@ -2810,19 +2820,13 @@ pub trait OwnedStr {\n     /// Appends a character to the back of a string\n     fn push_char(&mut self, c: char);\n \n-    /// Remove the final character from a string and return it\n-    ///\n-    /// # Failure\n-    ///\n-    /// If the string does not contain any characters\n-    fn pop_char(&mut self) -> char;\n+    /// Remove the final character from a string and return it. Return None\n+    /// when the string is empty.\n+    fn pop_char(&mut self) -> Option<char>;\n \n-    /// Remove the first character from a string and return it\n-    ///\n-    /// # Failure\n-    ///\n-    /// If the string does not contain any characters\n-    fn shift_char(&mut self) -> char;\n+    /// Remove the first character from a string and return it. Return None\n+    /// when the string is empty.\n+    fn shift_char(&mut self) -> Option<char>;\n \n     /// Prepend a char to a string\n     fn unshift_char(&mut self, ch: char);\n@@ -2925,19 +2929,26 @@ impl OwnedStr for ~str {\n     }\n \n     #[inline]\n-    fn pop_char(&mut self) -> char {\n+    fn pop_char(&mut self) -> Option<char> {\n         let end = self.len();\n-        assert!(end > 0u);\n-        let CharRange {ch, next} = self.char_range_at_reverse(end);\n-        unsafe { self.set_len(next); }\n-        return ch;\n+        if end == 0u {\n+            return None;\n+        } else {\n+            let CharRange {ch, next} = self.char_range_at_reverse(end);\n+            unsafe { self.set_len(next); }\n+            return Some(ch);\n+        }\n     }\n \n     #[inline]\n-    fn shift_char(&mut self) -> char {\n-        let CharRange {ch, next} = self.char_range_at(0u);\n-        *self = self.slice(next, self.len()).to_owned();\n-        return ch;\n+    fn shift_char(&mut self) -> Option<char> {\n+        if self.is_empty() {\n+            return None;\n+        } else {\n+            let CharRange {ch, next} = self.char_range_at(0u);\n+            *self = self.slice(next, self.len()).to_owned();\n+            return Some(ch);\n+        }\n     }\n \n     #[inline]\n@@ -3148,22 +3159,23 @@ mod tests {\n         let mut data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n         let cc = data.pop_char();\n         assert_eq!(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", data);\n-        assert_eq!('\u534e', cc);\n+        assert_eq!(Some('\u534e'), cc);\n     }\n \n     #[test]\n     fn test_pop_char_2() {\n         let mut data2 = ~\"\u534e\";\n         let cc2 = data2.pop_char();\n         assert_eq!(~\"\", data2);\n-        assert_eq!('\u534e', cc2);\n+        assert_eq!(Some('\u534e'), cc2);\n     }\n \n     #[test]\n-    #[should_fail]\n-    fn test_pop_char_fail() {\n+    fn test_pop_char_empty() {\n         let mut data = ~\"\";\n-        let _cc3 = data.pop_char();\n+        let cc3 = data.pop_char();\n+        assert_eq!(~\"\", data);\n+        assert_eq!(None, cc3);\n     }\n \n     #[test]\n@@ -3182,7 +3194,7 @@ mod tests {\n         let mut data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\";\n         let cc = data.shift_char();\n         assert_eq!(~\"\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", data);\n-        assert_eq!('\u0e1b', cc);\n+        assert_eq!(Some('\u0e1b'), cc);\n     }\n \n     #[test]\n@@ -3599,6 +3611,18 @@ mod tests {\n         assert!(!\"   _   \".is_whitespace());\n     }\n \n+    #[test]\n+    fn test_slice_shift_char() {\n+        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\";\n+        assert_eq!(data.slice_shift_char(), (Some('\u0e1b'), \"\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\"));\n+    }\n+\n+    #[test]\n+    fn test_slice_shift_char_2() {\n+        let empty = \"\";\n+        assert_eq!(empty.slice_shift_char(), (None, \"\"));\n+    }\n+\n     #[test]\n     fn test_push_byte() {\n         let mut s = ~\"ABC\";\n@@ -3611,15 +3635,15 @@ mod tests {\n         let mut s = ~\"ABC\";\n         let b = unsafe{raw::shift_byte(&mut s)};\n         assert_eq!(s, ~\"BC\");\n-        assert_eq!(b, 65u8);\n+        assert_eq!(b, Some(65u8));\n     }\n \n     #[test]\n     fn test_pop_byte() {\n         let mut s = ~\"ABC\";\n         let b = unsafe{raw::pop_byte(&mut s)};\n         assert_eq!(s, ~\"AB\");\n-        assert_eq!(b, 67u8);\n+        assert_eq!(b, Some(67u8));\n     }\n \n     #[test]"}, {"sha": "34ee0933d2ad09e44cdfa05a6150ec35aacb4b7c", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3316a0e6b2ad9352bab58e7c046ef3d212411d82/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3316a0e6b2ad9352bab58e7c046ef3d212411d82/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=3316a0e6b2ad9352bab58e7c046ef3d212411d82", "patch": "@@ -42,12 +42,12 @@ pub fn main() {\n     assert!((!str::is_utf8([0xf0_u8, 0xff_u8, 0xff_u8, 0x10_u8])));\n \n     let mut stack = ~\"a\u00d7c\u20ac\";\n-    assert_eq!(stack.pop_char(), '\u20ac');\n-    assert_eq!(stack.pop_char(), 'c');\n+    assert_eq!(stack.pop_char(), Some('\u20ac'));\n+    assert_eq!(stack.pop_char(), Some('c'));\n     stack.push_char('u');\n     assert!(stack == ~\"a\u00d7u\");\n-    assert_eq!(stack.shift_char(), 'a');\n-    assert_eq!(stack.shift_char(), '\u00d7');\n+    assert_eq!(stack.shift_char(), Some('a'));\n+    assert_eq!(stack.shift_char(), Some('\u00d7'));\n     stack.unshift_char('\u00df');\n     assert!(stack == ~\"\u00dfu\");\n }"}]}