{"sha": "35c6e22fab2d8b9c0911fb795532ca853d124ff1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1YzZlMjJmYWIyZDhiOWMwOTExZmI3OTU1MzJjYTg1M2QxMjRmZjE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-10T19:33:33Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-19T16:33:08Z"}, "message": "Tweak how preference factors into linkage\n\nThe new methodology can be found in the re-worded comment, but the gist of it is\nthat -C prefer-dynamic doesn't turn off static linkage. The error messages\nshould also be a little more sane now.\n\nCloses #12133", "tree": {"sha": "92ce1ee710d26320bbf1a96dbf8383c697a15ff4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92ce1ee710d26320bbf1a96dbf8383c697a15ff4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35c6e22fab2d8b9c0911fb795532ca853d124ff1", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35c6e22fab2d8b9c0911fb795532ca853d124ff1", "html_url": "https://github.com/rust-lang/rust/commit/35c6e22fab2d8b9c0911fb795532ca853d124ff1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35c6e22fab2d8b9c0911fb795532ca853d124ff1/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98b07755dd18e086aeb1ba8797821bd4a11cd713", "url": "https://api.github.com/repos/rust-lang/rust/commits/98b07755dd18e086aeb1ba8797821bd4a11cd713", "html_url": "https://github.com/rust-lang/rust/commit/98b07755dd18e086aeb1ba8797821bd4a11cd713"}], "stats": {"total": 335, "additions": 245, "deletions": 90}, "files": [{"sha": "787bbac8e6fe55d5ac57a07e9f43de3f1140cfbc", "filename": "mk/tests.mk", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35c6e22fab2d8b9c0911fb795532ca853d124ff1/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/35c6e22fab2d8b9c0911fb795532ca853d124ff1/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=35c6e22fab2d8b9c0911fb795532ca853d124ff1", "patch": "@@ -537,10 +537,6 @@ TEST_SREQ$(1)_T_$(2)_H_$(3) = \\\n # remove directive, if present, from CFG_RUSTC_FLAGS (issue #7898).\n CTEST_RUSTC_FLAGS := $$(subst --cfg ndebug,,$$(CFG_RUSTC_FLAGS))\n \n-# There's no need our entire test suite to take up gigabytes of space on disk\n-# including copies of libstd/libextra all over the place\n-CTEST_RUSTC_FLAGS := $$(CTEST_RUSTC_FLAGS) -C prefer-dynamic\n-\n # The tests can not be optimized while the rest of the compiler is optimized, so\n # filter out the optimization (if any) from rustc and then figure out if we need\n # to be optimized"}, {"sha": "7f8be5ff090e6186611eb986bb75f5985ae0b0e3", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/35c6e22fab2d8b9c0911fb795532ca853d124ff1/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c6e22fab2d8b9c0911fb795532ca853d124ff1/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=35c6e22fab2d8b9c0911fb795532ca853d124ff1", "patch": "@@ -32,6 +32,8 @@ pub struct TestProps {\n     force_host: bool,\n     // Check stdout for error-pattern output as well as stderr\n     check_stdout: bool,\n+    // Don't force a --crate-type=dylib flag on the command line\n+    no_prefer_dynamic: bool,\n }\n \n // Load any test directives embedded in the file\n@@ -45,6 +47,7 @@ pub fn load_props(testfile: &Path) -> TestProps {\n     let mut check_lines = ~[];\n     let mut force_host = false;\n     let mut check_stdout = false;\n+    let mut no_prefer_dynamic = false;\n     iter_header(testfile, |ln| {\n         match parse_error_pattern(ln) {\n           Some(ep) => error_patterns.push(ep),\n@@ -67,6 +70,10 @@ pub fn load_props(testfile: &Path) -> TestProps {\n             check_stdout = parse_check_stdout(ln);\n         }\n \n+        if !no_prefer_dynamic {\n+            no_prefer_dynamic = parse_no_prefer_dynamic(ln);\n+        }\n+\n         match parse_aux_build(ln) {\n             Some(ab) => { aux_builds.push(ab); }\n             None => {}\n@@ -99,6 +106,7 @@ pub fn load_props(testfile: &Path) -> TestProps {\n         check_lines: check_lines,\n         force_host: force_host,\n         check_stdout: check_stdout,\n+        no_prefer_dynamic: no_prefer_dynamic,\n     };\n }\n \n@@ -167,6 +175,10 @@ fn parse_check_stdout(line: &str) -> bool {\n     parse_name_directive(line, \"check-stdout\")\n }\n \n+fn parse_no_prefer_dynamic(line: &str) -> bool {\n+    parse_name_directive(line, \"no-prefer-dynamic\")\n+}\n+\n fn parse_exec_env(line: &str) -> Option<(~str, ~str)> {\n     parse_name_value_directive(line, ~\"exec-env\").map(|nv| {\n         // nv is either FOO or FOO=BAR"}, {"sha": "a24dde1561b932c442c9c3d38830bfa6db714480", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/35c6e22fab2d8b9c0911fb795532ca853d124ff1/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c6e22fab2d8b9c0911fb795532ca853d124ff1/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=35c6e22fab2d8b9c0911fb795532ca853d124ff1", "patch": "@@ -704,9 +704,13 @@ fn compose_and_run_compiler(\n     for rel_ab in props.aux_builds.iter() {\n         let abs_ab = config.aux_base.join(rel_ab.as_slice());\n         let aux_props = load_props(&abs_ab);\n+        let crate_type = if aux_props.no_prefer_dynamic {\n+            ~[]\n+        } else {\n+            ~[~\"--crate-type=dylib\"]\n+        };\n         let aux_args =\n-            make_compile_args(config, &aux_props, ~[~\"--crate-type=dylib\"]\n-                                                  + extra_link_args,\n+            make_compile_args(config, &aux_props, crate_type + extra_link_args,\n                               |a,b| {\n                                   let f = make_lib_name(a, b, testfile);\n                                   ThisDirectory(f.dir_path())\n@@ -770,6 +774,10 @@ fn make_compile_args(config: &config,\n                      ~\"-L\", config.build_base.as_str().unwrap().to_owned(),\n                      ~\"--target=\" + target]\n         + extras;\n+    if !props.no_prefer_dynamic {\n+        args.push(~\"-C\");\n+        args.push(~\"prefer-dynamic\");\n+    }\n     let path = match xform_file {\n         ThisFile(path) => { args.push(~\"-o\"); path }\n         ThisDirectory(path) => { args.push(~\"--out-dir\"); path }"}, {"sha": "a9d7d231cefd99ac117349a0e22e70dc180bda5c", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 138, "deletions": 84, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/35c6e22fab2d8b9c0911fb795532ca853d124ff1/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c6e22fab2d8b9c0911fb795532ca853d124ff1/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=35c6e22fab2d8b9c0911fb795532ca853d124ff1", "patch": "@@ -1220,6 +1220,74 @@ fn add_local_native_libraries(args: &mut ~[~str], sess: Session) {\n // the intermediate rlib version)\n fn add_upstream_rust_crates(args: &mut ~[~str], sess: Session,\n                             dylib: bool, tmpdir: &Path) {\n+\n+    // As a limitation of the current implementation, we require that everything\n+    // must be static or everything must be dynamic. The reasons for this are a\n+    // little subtle, but as with staticlibs and rlibs, the goal is to prevent\n+    // duplicate copies of the same library showing up. For example, a static\n+    // immediate dependency might show up as an upstream dynamic dependency and\n+    // we currently have no way of knowing that. We know that all dynamic\n+    // libraries require dynamic dependencies (see above), so it's satisfactory\n+    // to include either all static libraries or all dynamic libraries.\n+    //\n+    // With this limitation, we expose a compiler default linkage type and an\n+    // option to reverse that preference. The current behavior looks like:\n+    //\n+    // * If a dylib is being created, upstream dependencies must be dylibs\n+    // * If nothing else is specified, static linking is preferred\n+    // * If the -C prefer-dynamic flag is given, dynamic linking is preferred\n+    // * If one form of linking fails, the second is also attempted\n+    // * If both forms fail, then we emit an error message\n+\n+    let dynamic = get_deps(sess.cstore, cstore::RequireDynamic);\n+    let statik = get_deps(sess.cstore, cstore::RequireStatic);\n+    match (dynamic, statik, sess.opts.cg.prefer_dynamic, dylib) {\n+        (_, Some(deps), false, false) => {\n+            add_static_crates(args, sess, tmpdir, deps)\n+        }\n+\n+        (None, Some(deps), true, false) => {\n+            // If you opted in to dynamic linking and we decided to emit a\n+            // static output, you should probably be notified of such an event!\n+            sess.warn(\"dynamic linking was preferred, but dependencies \\\n+                       could not all be found in an dylib format.\");\n+            sess.warn(\"linking statically instead, using rlibs\");\n+            add_static_crates(args, sess, tmpdir, deps)\n+        }\n+\n+        (Some(deps), _, _, _) => add_dynamic_crates(args, sess, deps),\n+\n+        (None, _, _, true) => {\n+            sess.err(\"dylib output requested, but some depenencies could not \\\n+                      be found in the dylib format\");\n+            let deps = sess.cstore.get_used_crates(cstore::RequireDynamic);\n+            for (cnum, path) in deps.move_iter() {\n+                if path.is_some() { continue }\n+                let name = sess.cstore.get_crate_data(cnum).name.clone();\n+                sess.note(format!(\"dylib not found: {}\", name));\n+            }\n+        }\n+\n+        (None, None, pref, false) => {\n+            let (pref, name) = if pref {\n+                sess.err(\"dynamic linking is preferred, but dependencies were \\\n+                          not found in either dylib or rlib format\");\n+                (cstore::RequireDynamic, \"dylib\")\n+            } else {\n+                sess.err(\"dependencies were not all found in either dylib or \\\n+                          rlib format\");\n+                (cstore::RequireStatic, \"rlib\")\n+            };\n+            sess.note(format!(\"dependencies not found in the `{}` format\",\n+                              name));\n+            for (cnum, path) in sess.cstore.get_used_crates(pref).move_iter() {\n+                if path.is_some() { continue }\n+                let name = sess.cstore.get_crate_data(cnum).name.clone();\n+                sess.note(name);\n+            }\n+        }\n+    }\n+\n     // Converts a library file-stem into a cc -l argument\n     fn unlib(config: @session::Config, stem: &str) -> ~str {\n         if stem.starts_with(\"lib\") &&\n@@ -1230,96 +1298,82 @@ fn add_upstream_rust_crates(args: &mut ~[~str], sess: Session,\n         }\n     }\n \n-    let cstore = sess.cstore;\n-    if !dylib && !sess.opts.cg.prefer_dynamic {\n-        // With an executable, things get a little interesting. As a limitation\n-        // of the current implementation, we require that everything must be\n-        // static or everything must be dynamic. The reasons for this are a\n-        // little subtle, but as with the above two cases, the goal is to\n-        // prevent duplicate copies of the same library showing up. For example,\n-        // a static immediate dependency might show up as an upstream dynamic\n-        // dependency and we currently have no way of knowing that. We know that\n-        // all dynamic libraries require dynamic dependencies (see above), so\n-        // it's satisfactory to include either all static libraries or all\n-        // dynamic libraries.\n-        let crates = cstore.get_used_crates(cstore::RequireStatic);\n+    // Attempts to find all dependencies with a certain linkage preference,\n+    // returning `None` if not all libraries could be found with that\n+    // preference.\n+    fn get_deps(cstore: &cstore::CStore,  preference: cstore::LinkagePreference)\n+            -> Option<~[(ast::CrateNum, Path)]>\n+    {\n+        let crates = cstore.get_used_crates(preference);\n         if crates.iter().all(|&(_, ref p)| p.is_some()) {\n-            for (cnum, path) in crates.move_iter() {\n-                let cratepath = path.unwrap();\n-\n-                // When performing LTO on an executable output, all of the\n-                // bytecode from the upstream libraries has already been\n-                // included in our object file output. We need to modify all of\n-                // the upstream archives to remove their corresponding object\n-                // file to make sure we don't pull the same code in twice.\n-                //\n-                // We must continue to link to the upstream archives to be sure\n-                // to pull in native static dependencies. As the final caveat,\n-                // on linux it is apparently illegal to link to a blank archive,\n-                // so if an archive no longer has any object files in it after\n-                // we remove `lib.o`, then don't link against it at all.\n-                //\n-                // If we're not doing LTO, then our job is simply to just link\n-                // against the archive.\n-                if sess.lto() {\n-                    let name = sess.cstore.get_crate_data(cnum).name.clone();\n-                    time(sess.time_passes(), format!(\"altering {}.rlib\", name),\n-                         (), |()| {\n-                        let dst = tmpdir.join(cratepath.filename().unwrap());\n-                        match fs::copy(&cratepath, &dst) {\n-                            Ok(..) => {}\n-                            Err(e) => {\n-                                sess.err(format!(\"failed to copy {} to {}: {}\",\n-                                                 cratepath.display(),\n-                                                 dst.display(),\n-                                                 e));\n-                                sess.abort_if_errors();\n-                            }\n-                        }\n-                        let dst_str = dst.as_str().unwrap().to_owned();\n-                        let mut archive = Archive::open(sess, dst);\n-                        archive.remove_file(format!(\"{}.o\", name));\n-                        let files = archive.files();\n-                        if files.iter().any(|s| s.ends_with(\".o\")) {\n-                            args.push(dst_str);\n+            Some(crates.move_iter().map(|(a, b)| (a, b.unwrap())).collect())\n+        } else {\n+            None\n+        }\n+    }\n+\n+    // Adds the static \"rlib\" versions of all crates to the command line.\n+    fn add_static_crates(args: &mut ~[~str], sess: Session, tmpdir: &Path,\n+                         crates: ~[(ast::CrateNum, Path)]) {\n+        for (cnum, cratepath) in crates.move_iter() {\n+            // When performing LTO on an executable output, all of the\n+            // bytecode from the upstream libraries has already been\n+            // included in our object file output. We need to modify all of\n+            // the upstream archives to remove their corresponding object\n+            // file to make sure we don't pull the same code in twice.\n+            //\n+            // We must continue to link to the upstream archives to be sure\n+            // to pull in native static dependencies. As the final caveat,\n+            // on linux it is apparently illegal to link to a blank archive,\n+            // so if an archive no longer has any object files in it after\n+            // we remove `lib.o`, then don't link against it at all.\n+            //\n+            // If we're not doing LTO, then our job is simply to just link\n+            // against the archive.\n+            if sess.lto() {\n+                let name = sess.cstore.get_crate_data(cnum).name.clone();\n+                time(sess.time_passes(), format!(\"altering {}.rlib\", name),\n+                     (), |()| {\n+                    let dst = tmpdir.join(cratepath.filename().unwrap());\n+                    match fs::copy(&cratepath, &dst) {\n+                        Ok(..) => {}\n+                        Err(e) => {\n+                            sess.err(format!(\"failed to copy {} to {}: {}\",\n+                                             cratepath.display(),\n+                                             dst.display(),\n+                                             e));\n+                            sess.abort_if_errors();\n                         }\n-                    });\n-                } else {\n-                    args.push(cratepath.as_str().unwrap().to_owned());\n-                }\n+                    }\n+                    let dst_str = dst.as_str().unwrap().to_owned();\n+                    let mut archive = Archive::open(sess, dst);\n+                    archive.remove_file(format!(\"{}.o\", name));\n+                    let files = archive.files();\n+                    if files.iter().any(|s| s.ends_with(\".o\")) {\n+                        args.push(dst_str);\n+                    }\n+                });\n+            } else {\n+                args.push(cratepath.as_str().unwrap().to_owned());\n             }\n-            return;\n         }\n     }\n \n-    // If we're performing LTO, then it should have been previously required\n-    // that all upstream rust dependencies were available in an rlib format.\n-    assert!(!sess.lto());\n-\n-    // This is a fallback of three different  cases of linking:\n-    //\n-    // * When creating a dynamic library, all inputs are required to be dynamic\n-    //   as well\n-    // * If an executable is created with a preference on dynamic linking, then\n-    //   this case is the fallback\n-    // * If an executable is being created, and one of the inputs is missing as\n-    //   a static library, then this is the fallback case.\n-    let crates = cstore.get_used_crates(cstore::RequireDynamic);\n-    for &(cnum, ref path) in crates.iter() {\n-        let cratepath = match *path {\n-            Some(ref p) => p.clone(),\n-            None => {\n-                sess.err(format!(\"could not find dynamic library for: `{}`\",\n-                                 sess.cstore.get_crate_data(cnum).name));\n-                return\n-            }\n-        };\n-        // Just need to tell the linker about where the library lives and what\n-        // its name is\n-        let dir = cratepath.dirname_str().unwrap();\n-        if !dir.is_empty() { args.push(\"-L\" + dir); }\n-        let libarg = unlib(sess.targ_cfg, cratepath.filestem_str().unwrap());\n-        args.push(\"-l\" + libarg);\n+    // Same thing as above, but for dynamic crates instead of static crates.\n+    fn add_dynamic_crates(args: &mut ~[~str], sess: Session,\n+                          crates: ~[(ast::CrateNum, Path)]) {\n+        // If we're performing LTO, then it should have been previously required\n+        // that all upstream rust dependencies were available in an rlib format.\n+        assert!(!sess.lto());\n+\n+        for (_, cratepath) in crates.move_iter() {\n+            // Just need to tell the linker about where the library lives and\n+            // what its name is\n+            let dir = cratepath.dirname_str().unwrap();\n+            if !dir.is_empty() { args.push(\"-L\" + dir); }\n+            let libarg = unlib(sess.targ_cfg, cratepath.filestem_str().unwrap());\n+            args.push(\"-l\" + libarg);\n+        }\n     }\n }\n "}, {"sha": "57ae3f0851dd3e5fe8284ac5df7b46a3bf2d6976", "filename": "src/test/auxiliary/issue-12133-dylib.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/35c6e22fab2d8b9c0911fb795532ca853d124ff1/src%2Ftest%2Fauxiliary%2Fissue-12133-dylib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c6e22fab2d8b9c0911fb795532ca853d124ff1/src%2Ftest%2Fauxiliary%2Fissue-12133-dylib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-12133-dylib.rs?ref=35c6e22fab2d8b9c0911fb795532ca853d124ff1", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#[crate_type = \"dylib\"];"}, {"sha": "e5d109bb17ed31e16848caa2a6f2f2cbcccce508", "filename": "src/test/auxiliary/issue-12133-rlib.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/35c6e22fab2d8b9c0911fb795532ca853d124ff1/src%2Ftest%2Fauxiliary%2Fissue-12133-rlib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c6e22fab2d8b9c0911fb795532ca853d124ff1/src%2Ftest%2Fauxiliary%2Fissue-12133-rlib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-12133-rlib.rs?ref=35c6e22fab2d8b9c0911fb795532ca853d124ff1", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#[crate_type = \"rlib\"];"}, {"sha": "63a0352e2ef3a64b3e9bc9c0962119f096367133", "filename": "src/test/compile-fail/issue-12133-1.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/35c6e22fab2d8b9c0911fb795532ca853d124ff1/src%2Ftest%2Fcompile-fail%2Fissue-12133-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c6e22fab2d8b9c0911fb795532ca853d124ff1/src%2Ftest%2Fcompile-fail%2Fissue-12133-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12133-1.rs?ref=35c6e22fab2d8b9c0911fb795532ca853d124ff1", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue-12133-rlib.rs\n+// aux-build:issue-12133-dylib.rs\n+\n+// error-pattern: dynamic linking is preferred, but dependencies were not found\n+\n+extern crate a = \"issue-12133-rlib\";\n+extern crate b = \"issue-12133-dylib\";\n+\n+fn main() {}"}, {"sha": "3f42d28bf27a5b9d337595a683f1d14c40d30b70", "filename": "src/test/compile-fail/issue-12133-2.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/35c6e22fab2d8b9c0911fb795532ca853d124ff1/src%2Ftest%2Fcompile-fail%2Fissue-12133-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c6e22fab2d8b9c0911fb795532ca853d124ff1/src%2Ftest%2Fcompile-fail%2Fissue-12133-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12133-2.rs?ref=35c6e22fab2d8b9c0911fb795532ca853d124ff1", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue-12133-rlib.rs\n+// aux-build:issue-12133-dylib.rs\n+// no-prefer-dynamic\n+\n+// error-pattern: dependencies were not all found in either dylib or rlib format\n+\n+extern crate a = \"issue-12133-rlib\";\n+extern crate b = \"issue-12133-dylib\";\n+\n+fn main() {}"}, {"sha": "f97bb618e293f878f0cf8e1b5738ae79dce5be96", "filename": "src/test/compile-fail/issue-12133-3.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/35c6e22fab2d8b9c0911fb795532ca853d124ff1/src%2Ftest%2Fcompile-fail%2Fissue-12133-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35c6e22fab2d8b9c0911fb795532ca853d124ff1/src%2Ftest%2Fcompile-fail%2Fissue-12133-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12133-3.rs?ref=35c6e22fab2d8b9c0911fb795532ca853d124ff1", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue-12133-rlib.rs\n+// aux-build:issue-12133-dylib.rs\n+// no-prefer-dynamic\n+\n+// error-pattern: dylib output requested, but some depenencies could not\n+\n+#[crate_type = \"dylib\"];\n+\n+extern crate a = \"issue-12133-rlib\";\n+extern crate b = \"issue-12133-dylib\";"}]}