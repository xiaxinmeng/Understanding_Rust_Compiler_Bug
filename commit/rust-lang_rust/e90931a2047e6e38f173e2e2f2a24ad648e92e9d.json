{"sha": "e90931a2047e6e38f173e2e2f2a24ad648e92e9d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5MDkzMWEyMDQ3ZTZlMzhmMTczZTJlMmYyYTI0YWQ2NDhlOTJlOWQ=", "commit": {"author": {"name": "R\u00fcdiger Herrmann", "email": "ruediger.herrmann@gmx.de", "date": "2020-08-24T14:37:45Z"}, "committer": {"name": "R\u00fcdiger Herrmann", "email": "ruediger.herrmann@gmx.de", "date": "2020-10-10T11:46:10Z"}, "message": "Show reason for failed rename refactoring\n\nReturn an error with a meaningful message for requests to\n`textDocument/rename` if the operation cannot be performed.\nPass errors raised by rename handling code to the LSP runtime.\n\nAs a consequence, the VS Code client shows and logs the request\nas if a server-side programming error occured.\n\nResolves https://github.com/rust-analyzer/rust-analyzer/issues/3981", "tree": {"sha": "0ef92bcd580446c4ea44902f0f959d547a698943", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ef92bcd580446c4ea44902f0f959d547a698943"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e90931a2047e6e38f173e2e2f2a24ad648e92e9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e90931a2047e6e38f173e2e2f2a24ad648e92e9d", "html_url": "https://github.com/rust-lang/rust/commit/e90931a2047e6e38f173e2e2f2a24ad648e92e9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e90931a2047e6e38f173e2e2f2a24ad648e92e9d/comments", "author": {"login": "rherrmann", "id": 607182, "node_id": "MDQ6VXNlcjYwNzE4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/607182?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rherrmann", "html_url": "https://github.com/rherrmann", "followers_url": "https://api.github.com/users/rherrmann/followers", "following_url": "https://api.github.com/users/rherrmann/following{/other_user}", "gists_url": "https://api.github.com/users/rherrmann/gists{/gist_id}", "starred_url": "https://api.github.com/users/rherrmann/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rherrmann/subscriptions", "organizations_url": "https://api.github.com/users/rherrmann/orgs", "repos_url": "https://api.github.com/users/rherrmann/repos", "events_url": "https://api.github.com/users/rherrmann/events{/privacy}", "received_events_url": "https://api.github.com/users/rherrmann/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rherrmann", "id": 607182, "node_id": "MDQ6VXNlcjYwNzE4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/607182?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rherrmann", "html_url": "https://github.com/rherrmann", "followers_url": "https://api.github.com/users/rherrmann/followers", "following_url": "https://api.github.com/users/rherrmann/following{/other_user}", "gists_url": "https://api.github.com/users/rherrmann/gists{/gist_id}", "starred_url": "https://api.github.com/users/rherrmann/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rherrmann/subscriptions", "organizations_url": "https://api.github.com/users/rherrmann/orgs", "repos_url": "https://api.github.com/users/rherrmann/repos", "events_url": "https://api.github.com/users/rherrmann/events{/privacy}", "received_events_url": "https://api.github.com/users/rherrmann/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05261f5aeb1dcf01c5dfcf3e01826e57b1249ca9", "url": "https://api.github.com/repos/rust-lang/rust/commits/05261f5aeb1dcf01c5dfcf3e01826e57b1249ca9", "html_url": "https://github.com/rust-lang/rust/commit/05261f5aeb1dcf01c5dfcf3e01826e57b1249ca9"}], "stats": {"total": 199, "additions": 138, "deletions": 61}, "files": [{"sha": "d54c06b14fa37be235f80936c41e7024cd63aa6e", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e90931a2047e6e38f173e2e2f2a24ad648e92e9d/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90931a2047e6e38f173e2e2f2a24ad648e92e9d/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=e90931a2047e6e38f173e2e2f2a24ad648e92e9d", "patch": "@@ -77,7 +77,9 @@ pub use crate::{\n     hover::{HoverAction, HoverConfig, HoverGotoTypeData, HoverResult},\n     inlay_hints::{InlayHint, InlayHintsConfig, InlayKind},\n     markup::Markup,\n-    references::{Declaration, Reference, ReferenceAccess, ReferenceKind, ReferenceSearchResult},\n+    references::{\n+        Declaration, Reference, ReferenceAccess, ReferenceKind, ReferenceSearchResult, RenameError,\n+    },\n     runnables::{Runnable, RunnableKind, TestId},\n     syntax_highlighting::{\n         Highlight, HighlightModifier, HighlightModifiers, HighlightTag, HighlightedRange,\n@@ -490,7 +492,7 @@ impl Analysis {\n         &self,\n         position: FilePosition,\n         new_name: &str,\n-    ) -> Cancelable<Option<RangeInfo<SourceChange>>> {\n+    ) -> Cancelable<Result<RangeInfo<SourceChange>, RenameError>> {\n         self.with_db(|db| references::rename(db, position, new_name))\n     }\n "}, {"sha": "f65a05ea33b6ad4f51414ead03414b350649bec5", "filename": "crates/ide/src/references.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e90931a2047e6e38f173e2e2f2a24ad648e92e9d/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90931a2047e6e38f173e2e2f2a24ad648e92e9d/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=e90931a2047e6e38f173e2e2f2a24ad648e92e9d", "patch": "@@ -26,6 +26,7 @@ use syntax::{\n use crate::{display::TryToNav, FilePosition, FileRange, NavigationTarget, RangeInfo};\n \n pub(crate) use self::rename::rename;\n+pub use self::rename::RenameError;\n \n pub use ide_db::search::{Reference, ReferenceAccess, ReferenceKind};\n "}, {"sha": "f3b5cfc8c1fd9f00756b2eec9332d38a66ab9e7e", "filename": "crates/ide/src/references/rename.rs", "status": "modified", "additions": 129, "deletions": 46, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/e90931a2047e6e38f173e2e2f2a24ad648e92e9d/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90931a2047e6e38f173e2e2f2a24ad648e92e9d/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences%2Frename.rs?ref=e90931a2047e6e38f173e2e2f2a24ad648e92e9d", "patch": "@@ -6,11 +6,16 @@ use ide_db::{\n     defs::{classify_name, classify_name_ref, Definition, NameClass, NameRefClass},\n     RootDatabase,\n };\n-use std::convert::TryInto;\n+\n+use std::{\n+    convert::TryInto,\n+    error::Error,\n+    fmt::{self, Display},\n+};\n use syntax::{\n     algo::find_node_at_offset,\n     ast::{self, NameOwner},\n-    lex_single_valid_syntax_kind, match_ast, AstNode, SyntaxKind, SyntaxNode, SyntaxToken,\n+    lex_single_syntax_kind, match_ast, AstNode, SyntaxKind, SyntaxNode, SyntaxToken,\n };\n use test_utils::mark;\n use text_edit::TextEdit;\n@@ -20,17 +25,37 @@ use crate::{\n     SourceChange, SourceFileEdit, TextRange, TextSize,\n };\n \n+#[derive(Debug)]\n+pub struct RenameError(pub(crate) String);\n+\n+impl fmt::Display for RenameError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        Display::fmt(&self.0, f)\n+    }\n+}\n+\n+impl Error for RenameError {}\n+\n pub(crate) fn rename(\n     db: &RootDatabase,\n     position: FilePosition,\n     new_name: &str,\n-) -> Option<RangeInfo<SourceChange>> {\n+) -> Result<RangeInfo<SourceChange>, RenameError> {\n     let sema = Semantics::new(db);\n \n-    match lex_single_valid_syntax_kind(new_name)? {\n-        SyntaxKind::IDENT | SyntaxKind::UNDERSCORE => (),\n-        SyntaxKind::SELF_KW => return rename_to_self(&sema, position),\n-        _ => return None,\n+    match lex_single_syntax_kind(new_name) {\n+        Some(res) => match res {\n+            (SyntaxKind::IDENT, _) => (),\n+            (SyntaxKind::UNDERSCORE, _) => (),\n+            (SyntaxKind::SELF_KW, _) => return rename_to_self(&sema, position),\n+            (_, Some(syntax_error)) => {\n+                return Err(RenameError(format!(\"Invalid name `{}`: {}\", new_name, syntax_error)))\n+            }\n+            (_, None) => {\n+                return Err(RenameError(format!(\"Invalid name `{}`: not an identifier\", new_name)))\n+            }\n+        },\n+        None => return Err(RenameError(format!(\"Invalid name `{}`: not an identifier\", new_name))),\n     }\n \n     let source_file = sema.parse(position.file_id);\n@@ -103,7 +128,7 @@ fn rename_mod(\n     position: FilePosition,\n     module: Module,\n     new_name: &str,\n-) -> Option<RangeInfo<SourceChange>> {\n+) -> Result<RangeInfo<SourceChange>, RenameError> {\n     let mut source_file_edits = Vec::new();\n     let mut file_system_edits = Vec::new();\n \n@@ -125,51 +150,56 @@ fn rename_mod(\n \n     if let Some(src) = module.declaration_source(sema.db) {\n         let file_id = src.file_id.original_file(sema.db);\n-        let name = src.value.name()?;\n+        let name = src.value.name().unwrap();\n         let edit = SourceFileEdit {\n             file_id,\n             edit: TextEdit::replace(name.syntax().text_range(), new_name.into()),\n         };\n         source_file_edits.push(edit);\n     }\n \n-    let RangeInfo { range, info: refs } = find_all_refs(sema, position, None)?;\n+    let RangeInfo { range, info: refs } = find_all_refs(sema, position, None)\n+        .ok_or_else(|| RenameError(\"No references found at position\".to_string()))?;\n     let ref_edits = refs\n         .references\n         .into_iter()\n         .map(|reference| source_edit_from_reference(reference, new_name));\n     source_file_edits.extend(ref_edits);\n \n-    Some(RangeInfo::new(range, SourceChange::from_edits(source_file_edits, file_system_edits)))\n+    Ok(RangeInfo::new(range, SourceChange::from_edits(source_file_edits, file_system_edits)))\n }\n \n fn rename_to_self(\n     sema: &Semantics<RootDatabase>,\n     position: FilePosition,\n-) -> Option<RangeInfo<SourceChange>> {\n+) -> Result<RangeInfo<SourceChange>, RenameError> {\n     let source_file = sema.parse(position.file_id);\n     let syn = source_file.syntax();\n \n-    let fn_def = find_node_at_offset::<ast::Fn>(syn, position.offset)?;\n-    let params = fn_def.param_list()?;\n+    let fn_def = find_node_at_offset::<ast::Fn>(syn, position.offset)\n+        .ok_or_else(|| RenameError(\"No surrounding method declaration found\".to_string()))?;\n+    let params =\n+        fn_def.param_list().ok_or_else(|| RenameError(\"Method has no parameters\".to_string()))?;\n     if params.self_param().is_some() {\n-        return None; // method already has self param\n+        return Err(RenameError(\"Method already has a self parameter\".to_string()));\n     }\n-    let first_param = params.params().next()?;\n+    let first_param =\n+        params.params().next().ok_or_else(|| RenameError(\"Method has no parameters\".into()))?;\n     let mutable = match first_param.ty() {\n         Some(ast::Type::RefType(rt)) => rt.mut_token().is_some(),\n-        _ => return None, // not renaming other types\n+        _ => return Err(RenameError(\"Not renaming other types\".to_string())),\n     };\n \n-    let RangeInfo { range, info: refs } = find_all_refs(sema, position, None)?;\n+    let RangeInfo { range, info: refs } = find_all_refs(sema, position, None)\n+        .ok_or_else(|| RenameError(\"No reference found at position\".to_string()))?;\n \n     let param_range = first_param.syntax().text_range();\n     let (param_ref, usages): (Vec<Reference>, Vec<Reference>) = refs\n         .into_iter()\n         .partition(|reference| param_range.intersect(reference.file_range.range).is_some());\n \n     if param_ref.is_empty() {\n-        return None;\n+        return Err(RenameError(\"Parameter to rename not found\".to_string()));\n     }\n \n     let mut edits = usages\n@@ -185,7 +215,7 @@ fn rename_to_self(\n         ),\n     });\n \n-    Some(RangeInfo::new(range, SourceChange::from(edits)))\n+    Ok(RangeInfo::new(range, SourceChange::from(edits)))\n }\n \n fn text_edit_from_self_param(\n@@ -216,12 +246,13 @@ fn rename_self_to_param(\n     position: FilePosition,\n     self_token: SyntaxToken,\n     new_name: &str,\n-) -> Option<RangeInfo<SourceChange>> {\n+) -> Result<RangeInfo<SourceChange>, RenameError> {\n     let source_file = sema.parse(position.file_id);\n     let syn = source_file.syntax();\n \n     let text = sema.db.file_text(position.file_id);\n-    let fn_def = find_node_at_offset::<ast::Fn>(syn, position.offset)?;\n+    let fn_def = find_node_at_offset::<ast::Fn>(syn, position.offset)\n+        .ok_or_else(|| RenameError(\"No surrounding method declaration found\".to_string()))?;\n     let search_range = fn_def.syntax().text_range();\n \n     let mut edits: Vec<SourceFileEdit> = vec![];\n@@ -235,7 +266,8 @@ fn rename_self_to_param(\n             syn.token_at_offset(offset).find(|t| t.kind() == SyntaxKind::SELF_KW)\n         {\n             let edit = if let Some(ref self_param) = ast::SelfParam::cast(usage.parent()) {\n-                text_edit_from_self_param(syn, self_param, new_name)?\n+                text_edit_from_self_param(syn, self_param, new_name)\n+                    .ok_or_else(|| RenameError(\"No target type found\".to_string()))?\n             } else {\n                 TextEdit::replace(usage.text_range(), String::from(new_name))\n             };\n@@ -246,26 +278,29 @@ fn rename_self_to_param(\n     let range = ast::SelfParam::cast(self_token.parent())\n         .map_or(self_token.text_range(), |p| p.syntax().text_range());\n \n-    Some(RangeInfo::new(range, SourceChange::from(edits)))\n+    Ok(RangeInfo::new(range, SourceChange::from(edits)))\n }\n \n fn rename_reference(\n     sema: &Semantics<RootDatabase>,\n     position: FilePosition,\n     new_name: &str,\n-) -> Option<RangeInfo<SourceChange>> {\n-    let RangeInfo { range, info: refs } = find_all_refs(sema, position, None)?;\n+) -> Result<RangeInfo<SourceChange>, RenameError> {\n+    let RangeInfo { range, info: refs } = match find_all_refs(sema, position, None) {\n+        Some(range_info) => range_info,\n+        None => return Err(RenameError(\"No references found at position\".to_string())),\n+    };\n \n     let edit = refs\n         .into_iter()\n         .map(|reference| source_edit_from_reference(reference, new_name))\n         .collect::<Vec<_>>();\n \n     if edit.is_empty() {\n-        return None;\n+        return Err(RenameError(\"No references found at position\".to_string()));\n     }\n \n-    Some(RangeInfo::new(range, SourceChange::from(edit)))\n+    Ok(RangeInfo::new(range, SourceChange::from(edit)))\n }\n \n #[cfg(test)]\n@@ -280,25 +315,45 @@ mod tests {\n     fn check(new_name: &str, ra_fixture_before: &str, ra_fixture_after: &str) {\n         let ra_fixture_after = &trim_indent(ra_fixture_after);\n         let (analysis, position) = fixture::position(ra_fixture_before);\n-        let source_change = analysis.rename(position, new_name).unwrap();\n-        let mut text_edit_builder = TextEdit::builder();\n-        let mut file_id: Option<FileId> = None;\n-        if let Some(change) = source_change {\n-            for edit in change.info.source_file_edits {\n-                file_id = Some(edit.file_id);\n-                for indel in edit.edit.into_iter() {\n-                    text_edit_builder.replace(indel.delete, indel.insert);\n+        let rename_result = analysis\n+            .rename(position, new_name)\n+            .unwrap_or_else(|err| panic!(\"Rename to '{}' was cancelled: {}\", new_name, err));\n+        match rename_result {\n+            Ok(source_change) => {\n+                let mut text_edit_builder = TextEdit::builder();\n+                let mut file_id: Option<FileId> = None;\n+                for edit in source_change.info.source_file_edits {\n+                    file_id = Some(edit.file_id);\n+                    for indel in edit.edit.into_iter() {\n+                        text_edit_builder.replace(indel.delete, indel.insert);\n+                    }\n                 }\n+                let mut result = analysis.file_text(file_id.unwrap()).unwrap().to_string();\n+                text_edit_builder.finish().apply(&mut result);\n+                assert_eq_text!(ra_fixture_after, &*result);\n             }\n-        }\n-        let mut result = analysis.file_text(file_id.unwrap()).unwrap().to_string();\n-        text_edit_builder.finish().apply(&mut result);\n-        assert_eq_text!(ra_fixture_after, &*result);\n+            Err(err) => {\n+                if ra_fixture_after.starts_with(\"error:\") {\n+                    let error_message = ra_fixture_after\n+                        .chars()\n+                        .into_iter()\n+                        .skip(\"error:\".len())\n+                        .collect::<String>();\n+                    assert_eq!(error_message.trim(), err.to_string());\n+                    return;\n+                } else {\n+                    panic!(\"Rename to '{}' failed unexpectedly: {}\", new_name, err)\n+                }\n+            }\n+        };\n     }\n \n     fn check_expect(new_name: &str, ra_fixture: &str, expect: Expect) {\n         let (analysis, position) = fixture::position(ra_fixture);\n-        let source_change = analysis.rename(position, new_name).unwrap().unwrap();\n+        let source_change = analysis\n+            .rename(position, new_name)\n+            .unwrap()\n+            .expect(\"Expect returned RangeInfo to be Some, but was None\");\n         expect.assert_debug_eq(&source_change)\n     }\n \n@@ -313,11 +368,30 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_rename_to_invalid_identifier() {\n-        let (analysis, position) = fixture::position(r#\"fn main() { let i<|> = 1; }\"#);\n-        let new_name = \"invalid!\";\n-        let source_change = analysis.rename(position, new_name).unwrap();\n-        assert!(source_change.is_none());\n+    fn test_rename_to_invalid_identifier1() {\n+        check(\n+            \"invalid!\",\n+            r#\"fn main() { let i<|> = 1; }\"#,\n+            \"error: Invalid name `invalid!`: not an identifier\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_rename_to_invalid_identifier2() {\n+        check(\n+            \"multiple tokens\",\n+            r#\"fn main() { let i<|> = 1; }\"#,\n+            \"error: Invalid name `multiple tokens`: not an identifier\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_rename_to_invalid_identifier3() {\n+        check(\n+            \"let\",\n+            r#\"fn main() { let i<|> = 1; }\"#,\n+            \"error: Invalid name `let`: not an identifier\",\n+        );\n     }\n \n     #[test]\n@@ -349,6 +423,15 @@ fn main() {\n         );\n     }\n \n+    #[test]\n+    fn test_rename_unresolved_reference() {\n+        check(\n+            \"new_name\",\n+            r#\"fn main() { let _ = unresolved_ref<|>; }\"#,\n+            \"error: No references found at position\",\n+        );\n+    }\n+\n     #[test]\n     fn test_rename_for_macro_args() {\n         check("}, {"sha": "4e3340b0dd5ca34067fe05d1ad8c40781af01384", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e90931a2047e6e38f173e2e2f2a24ad648e92e9d/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90931a2047e6e38f173e2e2f2a24ad648e92e9d/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=e90931a2047e6e38f173e2e2f2a24ad648e92e9d", "patch": "@@ -646,14 +646,9 @@ pub(crate) fn handle_prepare_rename(\n     let _p = profile::span(\"handle_prepare_rename\");\n     let position = from_proto::file_position(&snap, params)?;\n \n-    let optional_change = snap.analysis.rename(position, \"dummy\")?;\n-    let range = match optional_change {\n-        None => return Ok(None),\n-        Some(it) => it.range,\n-    };\n-\n+    let change = snap.analysis.rename(position, \"dummy\")??;\n     let line_index = snap.analysis.file_line_index(position.file_id)?;\n-    let range = to_proto::range(&line_index, range);\n+    let range = to_proto::range(&line_index, change.range);\n     Ok(Some(PrepareRenameResponse::Range(range)))\n }\n \n@@ -672,12 +667,8 @@ pub(crate) fn handle_rename(\n         .into());\n     }\n \n-    let optional_change = snap.analysis.rename(position, &*params.new_name)?;\n-    let source_change = match optional_change {\n-        None => return Ok(None),\n-        Some(it) => it.info,\n-    };\n-    let workspace_edit = to_proto::workspace_edit(&snap, source_change)?;\n+    let change = snap.analysis.rename(position, &*params.new_name)??;\n+    let workspace_edit = to_proto::workspace_edit(&snap, change.info)?;\n     Ok(Some(workspace_edit))\n }\n "}]}