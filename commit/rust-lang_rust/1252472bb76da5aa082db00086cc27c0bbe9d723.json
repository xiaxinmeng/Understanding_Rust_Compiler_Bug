{"sha": "1252472bb76da5aa082db00086cc27c0bbe9d723", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyNTI0NzJiYjc2ZGE1YWEwODJkYjAwMDg2Y2MyN2MwYmJlOWQ3MjM=", "commit": {"author": {"name": "Palmer Cox", "email": "p@lmercox.com", "date": "2013-07-30T04:07:59Z"}, "committer": {"name": "Palmer Cox", "email": "p@lmercox.com", "date": "2013-08-02T22:49:00Z"}, "message": "Sha1: Update Sha1 to use new functionality in cryptoutil.rs", "tree": {"sha": "81697b39be1fe306f2fba10ac097119eddba81b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81697b39be1fe306f2fba10ac097119eddba81b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1252472bb76da5aa082db00086cc27c0bbe9d723", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1252472bb76da5aa082db00086cc27c0bbe9d723", "html_url": "https://github.com/rust-lang/rust/commit/1252472bb76da5aa082db00086cc27c0bbe9d723", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1252472bb76da5aa082db00086cc27c0bbe9d723/comments", "author": null, "committer": null, "parents": [{"sha": "4e7b0ee3cd8ef889c4fed673e06b91263b238e10", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e7b0ee3cd8ef889c4fed673e06b91263b238e10", "html_url": "https://github.com/rust-lang/rust/commit/4e7b0ee3cd8ef889c4fed673e06b91263b238e10"}], "stats": {"total": 138, "additions": 37, "deletions": 101}, "files": [{"sha": "86a89d79f1addb4bc34139af41c116e670782d22", "filename": "src/libextra/crypto/sha1.rs", "status": "modified", "additions": 37, "deletions": 101, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/1252472bb76da5aa082db00086cc27c0bbe9d723/src%2Flibextra%2Fcrypto%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1252472bb76da5aa082db00086cc27c0bbe9d723/src%2Flibextra%2Fcrypto%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fsha1.rs?ref=1252472bb76da5aa082db00086cc27c0bbe9d723", "patch": "@@ -23,6 +23,8 @@\n  */\n \n \n+use cryptoutil::{write_u32_be, read_u32v_be, shift_add_check_overflow, FixedBuffer, FixedBuffer64,\n+    StandardPadding};\n use digest::Digest;\n \n /*\n@@ -33,7 +35,6 @@ use digest::Digest;\n \n // Some unexported constants\n static DIGEST_BUF_LEN: uint = 5u;\n-static MSG_BLOCK_LEN: uint = 64u;\n static WORK_BUF_LEN: uint = 80u;\n static K0: u32 = 0x5A827999u32;\n static K1: u32 = 0x6ED9EBA1u32;\n@@ -43,58 +44,38 @@ static K3: u32 = 0xCA62C1D6u32;\n /// Structure representing the state of a Sha1 computation\n pub struct Sha1 {\n     priv h: [u32, ..DIGEST_BUF_LEN],\n-    priv len_low: u32,\n-    priv len_high: u32,\n-    priv msg_block: [u8, ..MSG_BLOCK_LEN],\n-    priv msg_block_idx: uint,\n+    priv length_bits: u64,\n+    priv buffer: FixedBuffer64,\n     priv computed: bool,\n-    priv work_buf: [u32, ..WORK_BUF_LEN]\n }\n \n fn add_input(st: &mut Sha1, msg: &[u8]) {\n     assert!((!st.computed));\n-    foreach element in msg.iter() {\n-        st.msg_block[st.msg_block_idx] = *element;\n-        st.msg_block_idx += 1;\n-        st.len_low += 8;\n-        if st.len_low == 0 {\n-            st.len_high += 1;\n-            if st.len_high == 0 {\n-                // FIXME: Need better failure mode (#2346)\n-                fail!();\n-            }\n-        }\n-        if st.msg_block_idx == MSG_BLOCK_LEN { process_msg_block(st); }\n-    }\n+    // Assumes that msg.len() can be converted to u64 without overflow\n+    st.length_bits = shift_add_check_overflow(st.length_bits, msg.len() as u64, 3);\n+    st.buffer.input(msg, |d: &[u8]| { process_msg_block(d, &mut st.h); });\n }\n \n-fn process_msg_block(st: &mut Sha1) {\n+fn process_msg_block(data: &[u8], h: &mut [u32, ..DIGEST_BUF_LEN]) {\n     let mut t: int; // Loop counter\n-    let mut w = st.work_buf;\n+\n+    let mut w = [0u32, ..WORK_BUF_LEN];\n \n     // Initialize the first 16 words of the vector w\n-    t = 0;\n-    while t < 16 {\n-        let mut tmp;\n-        tmp = (st.msg_block[t * 4] as u32) << 24u32;\n-        tmp = tmp | (st.msg_block[t * 4 + 1] as u32) << 16u32;\n-        tmp = tmp | (st.msg_block[t * 4 + 2] as u32) << 8u32;\n-        tmp = tmp | (st.msg_block[t * 4 + 3] as u32);\n-        w[t] = tmp;\n-        t += 1;\n-    }\n+    read_u32v_be(w.mut_slice(0, 16), data);\n \n     // Initialize the rest of vector w\n+    t = 16;\n     while t < 80 {\n         let val = w[t - 3] ^ w[t - 8] ^ w[t - 14] ^ w[t - 16];\n         w[t] = circular_shift(1, val);\n         t += 1;\n     }\n-    let mut a = st.h[0];\n-    let mut b = st.h[1];\n-    let mut c = st.h[2];\n-    let mut d = st.h[3];\n-    let mut e = st.h[4];\n+    let mut a = h[0];\n+    let mut b = h[1];\n+    let mut c = h[2];\n+    let mut d = h[3];\n+    let mut e = h[4];\n     let mut temp: u32;\n     t = 0;\n     while t < 20 {\n@@ -135,86 +116,42 @@ fn process_msg_block(st: &mut Sha1) {\n         a = temp;\n         t += 1;\n     }\n-    st.h[0] = st.h[0] + a;\n-    st.h[1] = st.h[1] + b;\n-    st.h[2] = st.h[2] + c;\n-    st.h[3] = st.h[3] + d;\n-    st.h[4] = st.h[4] + e;\n-    st.msg_block_idx = 0;\n+    h[0] += a;\n+    h[1] += b;\n+    h[2] += c;\n+    h[3] += d;\n+    h[4] += e;\n }\n \n fn circular_shift(bits: u32, word: u32) -> u32 {\n     return word << bits | word >> 32u32 - bits;\n }\n \n fn mk_result(st: &mut Sha1, rs: &mut [u8]) {\n-    if !st.computed { pad_msg(st); st.computed = true; }\n-    let mut i = 0;\n-    foreach ptr_hpart in st.h.mut_iter() {\n-        let hpart = *ptr_hpart;\n-        rs[i]   = (hpart >> 24u32 & 0xFFu32) as u8;\n-        rs[i+1] = (hpart >> 16u32 & 0xFFu32) as u8;\n-        rs[i+2] = (hpart >> 8u32 & 0xFFu32) as u8;\n-        rs[i+3] = (hpart & 0xFFu32) as u8;\n-        i += 4;\n-    }\n-}\n+    if !st.computed {\n+        st.buffer.standard_padding(8, |d: &[u8]| { process_msg_block(d, &mut st.h) });\n+        write_u32_be(st.buffer.next(4), (st.length_bits >> 32) as u32 );\n+        write_u32_be(st.buffer.next(4), st.length_bits as u32);\n+        process_msg_block(st.buffer.full_buffer(), &mut st.h);\n \n-/*\n- * According to the standard, the message must be padded to an even\n- * 512 bits.  The first padding bit must be a '1'.  The last 64 bits\n- * represent the length of the original message.  All bits in between\n- * should be 0.  This function will pad the message according to those\n- * rules by filling the msg_block vector accordingly.  It will also\n- * call process_msg_block() appropriately.  When it returns, it\n- * can be assumed that the message digest has been computed.\n- */\n-fn pad_msg(st: &mut Sha1) {\n-    /*\n-     * Check to see if the current message block is too small to hold\n-     * the initial padding bits and length.  If so, we will pad the\n-     * block, process it, and then continue padding into a second block.\n-     */\n-    if st.msg_block_idx > 55 {\n-        st.msg_block[st.msg_block_idx] = 0x80;\n-        st.msg_block_idx += 1;\n-        while st.msg_block_idx < MSG_BLOCK_LEN {\n-            st.msg_block[st.msg_block_idx] = 0;\n-            st.msg_block_idx += 1;\n-        }\n-        process_msg_block(st);\n-    } else {\n-        st.msg_block[st.msg_block_idx] = 0x80;\n-        st.msg_block_idx += 1;\n-    }\n-    while st.msg_block_idx < 56 {\n-        st.msg_block[st.msg_block_idx] = 0u8;\n-        st.msg_block_idx += 1;\n+        st.computed = true;\n     }\n \n-    // Store the message length as the last 8 octets\n-    st.msg_block[56] = (st.len_high >> 24u32 & 0xFFu32) as u8;\n-    st.msg_block[57] = (st.len_high >> 16u32 & 0xFFu32) as u8;\n-    st.msg_block[58] = (st.len_high >> 8u32 & 0xFFu32) as u8;\n-    st.msg_block[59] = (st.len_high & 0xFFu32) as u8;\n-    st.msg_block[60] = (st.len_low >> 24u32 & 0xFFu32) as u8;\n-    st.msg_block[61] = (st.len_low >> 16u32 & 0xFFu32) as u8;\n-    st.msg_block[62] = (st.len_low >> 8u32 & 0xFFu32) as u8;\n-    st.msg_block[63] = (st.len_low & 0xFFu32) as u8;\n-    process_msg_block(st);\n+    write_u32_be(rs.mut_slice(0, 4), st.h[0]);\n+    write_u32_be(rs.mut_slice(4, 8), st.h[1]);\n+    write_u32_be(rs.mut_slice(8, 12), st.h[2]);\n+    write_u32_be(rs.mut_slice(12, 16), st.h[3]);\n+    write_u32_be(rs.mut_slice(16, 20), st.h[4]);\n }\n \n impl Sha1 {\n     /// Construct a `sha` object\n     pub fn new() -> Sha1 {\n         let mut st = Sha1 {\n             h: [0u32, ..DIGEST_BUF_LEN],\n-            len_low: 0u32,\n-            len_high: 0u32,\n-            msg_block: [0u8, ..MSG_BLOCK_LEN],\n-            msg_block_idx: 0,\n+            length_bits: 0u64,\n+            buffer: FixedBuffer64::new(),\n             computed: false,\n-            work_buf: [0u32, ..WORK_BUF_LEN]\n         };\n         st.reset();\n         return st;\n@@ -223,14 +160,13 @@ impl Sha1 {\n \n impl Digest for Sha1 {\n     pub fn reset(&mut self) {\n-        self.len_low = 0;\n-        self.len_high = 0;\n-        self.msg_block_idx = 0;\n+        self.length_bits = 0;\n         self.h[0] = 0x67452301u32;\n         self.h[1] = 0xEFCDAB89u32;\n         self.h[2] = 0x98BADCFEu32;\n         self.h[3] = 0x10325476u32;\n         self.h[4] = 0xC3D2E1F0u32;\n+        self.buffer.reset();\n         self.computed = false;\n     }\n     pub fn input(&mut self, msg: &[u8]) { add_input(self, msg); }"}]}