{"sha": "5412587910f573c5d522b79a4808a1289ebea51c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0MTI1ODc5MTBmNTczYzVkNTIyYjc5YTQ4MDhhMTI4OWViZWE1MWM=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-04-21T17:24:32Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-04-23T11:37:18Z"}, "message": "clean-up adt_sized_constraint now that it uses on-demand", "tree": {"sha": "1b7f5190644fab1abcedc8980c561623a9f86767", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b7f5190644fab1abcedc8980c561623a9f86767"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5412587910f573c5d522b79a4808a1289ebea51c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5412587910f573c5d522b79a4808a1289ebea51c", "html_url": "https://github.com/rust-lang/rust/commit/5412587910f573c5d522b79a4808a1289ebea51c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5412587910f573c5d522b79a4808a1289ebea51c/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23de823e93dc19ef1b9cb65b48860a892cd6ff18", "url": "https://api.github.com/repos/rust-lang/rust/commits/23de823e93dc19ef1b9cb65b48860a892cd6ff18", "html_url": "https://github.com/rust-lang/rust/commit/23de823e93dc19ef1b9cb65b48860a892cd6ff18"}], "stats": {"total": 70, "additions": 21, "deletions": 49}, "files": [{"sha": "e61e574379069749bb25f3d1913fd294ba19fd5a", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5412587910f573c5d522b79a4808a1289ebea51c/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5412587910f573c5d522b79a4808a1289ebea51c/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=5412587910f573c5d522b79a4808a1289ebea51c", "patch": "@@ -1790,11 +1790,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             ty::TyAdt(def, substs) => {\n                 let sized_crit = def.sized_constraint(self.tcx());\n                 // (*) binder moved here\n-                Where(ty::Binder(match sized_crit.sty {\n-                    ty::TyTuple(tys, _) => tys.to_vec().subst(self.tcx(), substs),\n-                    ty::TyBool => vec![],\n-                    _ => vec![sized_crit.subst(self.tcx(), substs)]\n-                }))\n+                Where(ty::Binder(\n+                    sized_crit.iter().map(|ty| ty.subst(self.tcx(), substs)).collect()\n+                ))\n             }\n \n             ty::TyProjection(_) | ty::TyParam(_) | ty::TyAnon(..) => None,"}, {"sha": "693dd00574feb304aaddf3aa05ae122c826e47bc", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5412587910f573c5d522b79a4808a1289ebea51c/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5412587910f573c5d522b79a4808a1289ebea51c/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=5412587910f573c5d522b79a4808a1289ebea51c", "patch": "@@ -396,7 +396,7 @@ define_maps! { <'tcx>\n     pub trait_def: ItemSignature(DefId) -> &'tcx ty::TraitDef,\n     pub adt_def: ItemSignature(DefId) -> &'tcx ty::AdtDef,\n     pub adt_destructor: AdtDestructor(DefId) -> Option<ty::Destructor>,\n-    pub adt_sized_constraint: SizedConstraint(DefId) -> Ty<'tcx>,\n+    pub adt_sized_constraint: SizedConstraint(DefId) -> &'tcx [Ty<'tcx>],\n \n     /// True if this is a foreign item (i.e., linked via `extern { ... }`).\n     pub is_foreign_item: IsForeignItem(DefId) -> bool,"}, {"sha": "946c55f9406029cce0cd662c8cc501b5ced9040f", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 17, "deletions": 43, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/5412587910f573c5d522b79a4808a1289ebea51c/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5412587910f573c5d522b79a4808a1289ebea51c/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=5412587910f573c5d522b79a4808a1289ebea51c", "patch": "@@ -1780,33 +1780,26 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         queries::adt_destructor::get(tcx, DUMMY_SP, self.did)\n     }\n \n-    /// Returns a simpler type such that `Self: Sized` if and only\n+    /// Returns a list of types such that `Self: Sized` if and only\n     /// if that type is Sized, or `TyErr` if this type is recursive.\n     ///\n-    /// HACK: instead of returning a list of types, this function can\n-    /// return a tuple. In that case, the result is Sized only if\n-    /// all elements of the tuple are Sized.\n-    ///\n-    /// This is generally the `struct_tail` if this is a struct, or a\n-    /// tuple of them if this is an enum.\n-    ///\n     /// Oddly enough, checking that the sized-constraint is Sized is\n     /// actually more expressive than checking all members:\n     /// the Sized trait is inductive, so an associated type that references\n     /// Self would prevent its containing ADT from being Sized.\n     ///\n     /// Due to normalization being eager, this applies even if\n     /// the associated type is behind a pointer, e.g. issue #31299.\n-    pub fn sized_constraint(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n+    pub fn sized_constraint(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> &'tcx [Ty<'tcx>] {\n         match queries::adt_sized_constraint::try_get(tcx, DUMMY_SP, self.did) {\n-            Ok(ty) => ty,\n+            Ok(tys) => tys,\n             Err(_) => {\n                 debug!(\"adt_sized_constraint: {:?} is recursive\", self);\n                 // This should be reported as an error by `check_representable`.\n                 //\n                 // Consider the type as Sized in the meanwhile to avoid\n                 // further errors.\n-                tcx.types.err\n+                tcx.intern_type_list(&[tcx.types.err])\n             }\n         }\n     }\n@@ -1836,18 +1829,13 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n \n             TyAdt(adt, substs) => {\n                 // recursive case\n-                let adt_ty =\n-                    adt.sized_constraint(tcx)\n-                       .subst(tcx, substs);\n+                let adt_tys = adt.sized_constraint(tcx);\n                 debug!(\"sized_constraint_for_ty({:?}) intermediate = {:?}\",\n-                       ty, adt_ty);\n-                if let ty::TyTuple(ref tys, _) = adt_ty.sty {\n-                    tys.iter().flat_map(|ty| {\n-                        self.sized_constraint_for_ty(tcx, ty)\n-                    }).collect()\n-                } else {\n-                    self.sized_constraint_for_ty(tcx, adt_ty)\n-                }\n+                       ty, adt_tys);\n+                adt_tys.iter()\n+                    .map(|ty| ty.subst(tcx, substs))\n+                    .flat_map(|ty| self.sized_constraint_for_ty(tcx, ty))\n+                    .collect()\n             }\n \n             TyProjection(..) | TyAnon(..) => {\n@@ -2697,13 +2685,7 @@ fn associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n \n /// Calculates the Sized-constraint.\n ///\n-/// As the Sized-constraint of enums can be a *set* of types,\n-/// the Sized-constraint may need to be a set also. Because introducing\n-/// a new type of IVar is currently a complex affair, the Sized-constraint\n-/// may be a tuple.\n-///\n-/// In fact, there are only a few options for the constraint:\n-///     - `bool`, if the type is always Sized\n+/// In fact, there are only a few options for the types in the constraint:\n ///     - an obviously-unsized type\n ///     - a type parameter or projection whose Sizedness can't be known\n ///     - a tuple of type parameters or projections, if there are multiple\n@@ -2712,26 +2694,18 @@ fn associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n ///       check should catch this case.\n fn adt_sized_constraint<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   def_id: DefId)\n-                                  -> Ty<'tcx> {\n+                                  -> &'tcx [Ty<'tcx>] {\n     let def = tcx.lookup_adt_def(def_id);\n \n-    let tys: Vec<_> = def.variants.iter().flat_map(|v| {\n+    let result = tcx.intern_type_list(&def.variants.iter().flat_map(|v| {\n         v.fields.last()\n     }).flat_map(|f| {\n-        let ty = tcx.item_type(f.did);\n-        def.sized_constraint_for_ty(tcx, ty)\n-    }).collect();\n-\n-    let ty = match tys.len() {\n-        _ if tys.references_error() => tcx.types.err,\n-        0 => tcx.types.bool,\n-        1 => tys[0],\n-        _ => tcx.intern_tup(&tys[..], false)\n-    };\n+        def.sized_constraint_for_ty(tcx, tcx.item_type(f.did))\n+    }).collect::<Vec<_>>());\n \n-    debug!(\"adt_sized_constraint: {:?} => {:?}\", def, ty);\n+    debug!(\"adt_sized_constraint: {:?} => {:?}\", def, result);\n \n-    ty\n+    result\n }\n \n fn associated_item_def_ids<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}]}