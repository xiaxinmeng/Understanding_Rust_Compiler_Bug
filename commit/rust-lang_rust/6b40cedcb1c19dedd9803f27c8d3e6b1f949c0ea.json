{"sha": "6b40cedcb1c19dedd9803f27c8d3e6b1f949c0ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiNDBjZWRjYjFjMTlkZWRkOTgwM2YyN2M4ZDNlNmIxZjk0OWMwZWE=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-06-21T02:40:01Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-06-22T14:03:16Z"}, "message": "Pull building the environment for for_each into a seperate function.", "tree": {"sha": "3a22d2c8e155b51d57641d3f269049b060752d74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a22d2c8e155b51d57641d3f269049b060752d74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b40cedcb1c19dedd9803f27c8d3e6b1f949c0ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b40cedcb1c19dedd9803f27c8d3e6b1f949c0ea", "html_url": "https://github.com/rust-lang/rust/commit/6b40cedcb1c19dedd9803f27c8d3e6b1f949c0ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b40cedcb1c19dedd9803f27c8d3e6b1f949c0ea/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c07443e6ebad98b7a5f4599ef671e468a454d9e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c07443e6ebad98b7a5f4599ef671e468a454d9e2", "html_url": "https://github.com/rust-lang/rust/commit/c07443e6ebad98b7a5f4599ef671e468a454d9e2"}], "stats": {"total": 108, "additions": 61, "deletions": 47}, "files": [{"sha": "c9e8b0bbc302e54ab74b6c48ae1435241ac5da2a", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 61, "deletions": 47, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/6b40cedcb1c19dedd9803f27c8d3e6b1f949c0ea/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b40cedcb1c19dedd9803f27c8d3e6b1f949c0ea/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=6b40cedcb1c19dedd9803f27c8d3e6b1f949c0ea", "patch": "@@ -4196,45 +4196,17 @@ fn collect_upvars(&@block_ctxt cx, &ast::block bloc,\n     ret result;\n }\n \n-fn trans_for_each(&@block_ctxt cx, &@ast::local local, &@ast::expr seq,\n-                  &ast::block body) -> result {\n-    /*\n-     * The translation is a little .. complex here. Code like:\n-     *\n-     *    let ty1 p = ...;\n-     *\n-     *    let ty1 q = ...;\n-     *\n-     *    foreach (ty v in foo(a,b)) { body(p,q,v) }\n-     *\n-     *\n-     * Turns into a something like so (C/Rust mishmash):\n-     *\n-     *    type env = { *ty1 p, *ty2 q, ... };\n-     *\n-     *    let env e = { &p, &q, ... };\n-     *\n-     *    fn foreach123_body(env* e, ty v) { body(*(e->p),*(e->q),v) }\n-     *\n-     *    foo([foreach123_body, env*], a, b);\n-     *\n-     */\n-\n-    // Step 1: walk body and figure out which references it makes\n-    // escape. This could be determined upstream, and probably ought\n-    // to be so, eventualy.\n-\n-    auto lcx = cx.fcx.lcx;\n-    // FIXME: possibly support alias-mode here?\n-\n-    auto decl_ty = node_id_type(lcx.ccx, local.node.id);\n-    auto decl_id = local.node.id;\n-    auto upvars = collect_upvars(cx, body, decl_id);\n+// Given a block context and a list of upvars, construct a closure that\n+// contains pointers to all of the upvars and all of the tydescs in\n+// scope. Return the ValueRef and TypeRef corresponding to the closure. \n+fn build_environment(&@block_ctxt cx, &vec[ast::node_id] upvars) ->\n+    tup(ValueRef, TypeRef)\n+{\n     auto upvar_count = vec::len(upvars);\n     auto llbindingsptr;\n+\n     if (upvar_count > 0u) {\n         // Gather up the upvars.\n-\n         let vec[ValueRef] llbindings = [];\n         let vec[TypeRef] llbindingtys = [];\n         for (ast::node_id nid in upvars) {\n@@ -4253,8 +4225,8 @@ fn trans_for_each(&@block_ctxt cx, &@ast::local local, &@ast::expr seq,\n             llbindings += [llbinding];\n             llbindingtys += [val_ty(llbinding)];\n         }\n-        // Create an array of bindings and copy in aliases to the upvars.\n \n+        // Create an array of bindings and copy in aliases to the upvars.\n         llbindingsptr = alloca(cx, T_struct(llbindingtys));\n         auto i = 0u;\n         while (i < upvar_count) {\n@@ -4265,23 +4237,22 @@ fn trans_for_each(&@block_ctxt cx, &@ast::local local, &@ast::expr seq,\n         }\n     } else {\n         // Null bindings.\n-\n         llbindingsptr = C_null(T_ptr(T_i8()));\n     }\n-    // Create an environment and populate it with the bindings.\n \n+    // Create an environment and populate it with the bindings.\n     auto tydesc_count = vec::len[ValueRef](cx.fcx.lltydescs);\n     auto llenvptrty =\n-        T_closure_ptr(lcx.ccx.tn, T_ptr(T_nil()), val_ty(llbindingsptr),\n-                      tydesc_count);\n+        T_closure_ptr(cx.fcx.lcx.ccx.tn, T_ptr(T_nil()),\n+                      val_ty(llbindingsptr), tydesc_count);\n     auto llenvptr = alloca(cx, llvm::LLVMGetElementType(llenvptrty));\n     auto llbindingsptrptr =\n         cx.build.GEP(llenvptr,\n                      [C_int(0), C_int(abi::box_rc_field_body), C_int(2)]);\n     cx.build.Store(llbindingsptr, llbindingsptrptr);\n+\n     // Copy in our type descriptors, in case the iterator body needs to refer\n     // to them.\n-\n     auto lltydescsptr =\n         cx.build.GEP(llenvptr,\n                      [C_int(0), C_int(abi::box_rc_field_body),\n@@ -4293,16 +4264,58 @@ fn trans_for_each(&@block_ctxt cx, &@ast::local local, &@ast::expr seq,\n         cx.build.Store(cx.fcx.lltydescs.(i), lltydescptr);\n         i += 1u;\n     }\n-    // Step 2: Declare foreach body function.\n \n+    ret tup(llenvptr, llenvptrty);\n+}\n+\n+fn trans_for_each(&@block_ctxt cx, &@ast::local local, &@ast::expr seq,\n+                  &ast::block body) -> result {\n+    /*\n+     * The translation is a little .. complex here. Code like:\n+     *\n+     *    let ty1 p = ...;\n+     *\n+     *    let ty1 q = ...;\n+     *\n+     *    foreach (ty v in foo(a,b)) { body(p,q,v) }\n+     *\n+     *\n+     * Turns into a something like so (C/Rust mishmash):\n+     *\n+     *    type env = { *ty1 p, *ty2 q, ... };\n+     *\n+     *    let env e = { &p, &q, ... };\n+     *\n+     *    fn foreach123_body(env* e, ty v) { body(*(e->p),*(e->q),v) }\n+     *\n+     *    foo([foreach123_body, env*], a, b);\n+     *\n+     */\n+\n+    // Step 1: walk body and figure out which references it makes\n+    // escape. This could be determined upstream, and probably ought\n+    // to be so, eventualy.\n+    auto lcx = cx.fcx.lcx;\n+\n+    // FIXME: possibly support alias-mode here?\n+    auto decl_ty = node_id_type(lcx.ccx, local.node.id);\n+    auto decl_id = local.node.id;\n+    auto upvars = collect_upvars(cx, body, decl_id);\n+    auto upvar_count = vec::len(upvars);\n+\n+    auto environment_data = build_environment(cx, upvars);\n+    auto llenvptr = environment_data._0;\n+    auto llenvptrty = environment_data._1;\n+\n+    // Step 2: Declare foreach body function.\n     let str s =\n         mangle_internal_name_by_path_and_seq(lcx.ccx, lcx.path, \"foreach\");\n+\n     // The 'env' arg entering the body function is a fake env member (as in\n     // the env-part of the normal rust calling convention) that actually\n     // points to a stack allocated env in this frame. We bundle that env\n     // pointer along with the foreach-body-fn pointer into a 'normal' fn pair\n     // and pass it in as a first class fn-arg to the iterator.\n-\n     auto iter_body_llty =\n         type_of_fn_full(lcx.ccx, cx.sp, ast::proto_fn, none[TypeRef],\n                         [rec(mode=ty::mo_alias(false), ty=decl_ty)],\n@@ -4311,8 +4324,8 @@ fn trans_for_each(&@block_ctxt cx, &@ast::local local, &@ast::expr seq,\n         decl_internal_fastcall_fn(lcx.ccx.llmod, s, iter_body_llty);\n     auto fcx = new_fn_ctxt(lcx, cx.sp, lliterbody);\n     auto copy_args_bcx = new_raw_block_ctxt(fcx, fcx.llcopyargs);\n-    // Populate the upvars from the environment.\n \n+    // Populate the upvars from the environment.\n     auto llremoteenvptr =\n         copy_args_bcx.build.PointerCast(fcx.llenv, llenvptrty);\n     auto llremotebindingsptrptr =\n@@ -4321,7 +4334,7 @@ fn trans_for_each(&@block_ctxt cx, &@ast::local local, &@ast::expr seq,\n                                  C_int(abi::closure_elt_bindings)]);\n     auto llremotebindingsptr =\n         copy_args_bcx.build.Load(llremotebindingsptrptr);\n-    i = 0u;\n+    auto i = 0u;\n     while (i < upvar_count) {\n         auto upvar_id = upvars.(i);\n         auto llupvarptrptr =\n@@ -4331,12 +4344,13 @@ fn trans_for_each(&@block_ctxt cx, &@ast::local local, &@ast::expr seq,\n         fcx.llupvars.insert(upvar_id, llupvarptr);\n         i += 1u;\n     }\n-    // Populate the type parameters from the environment.\n \n+    // Populate the type parameters from the environment.\n     auto llremotetydescsptr =\n         copy_args_bcx.build.GEP(llremoteenvptr,\n                                 [C_int(0), C_int(abi::box_rc_field_body),\n                                  C_int(abi::closure_elt_ty_params)]);\n+    auto tydesc_count = vec::len[ValueRef](cx.fcx.lltydescs);\n     i = 0u;\n     while (i < tydesc_count) {\n         auto llremotetydescptr =\n@@ -4346,8 +4360,8 @@ fn trans_for_each(&@block_ctxt cx, &@ast::local local, &@ast::expr seq,\n         fcx.lltydescs += [llremotetydesc];\n         i += 1u;\n     }\n-    // Add an upvar for the loop variable alias.\n \n+    // Add an upvar for the loop variable alias.\n     fcx.llupvars.insert(decl_id, llvm::LLVMGetParam(fcx.llfn, 3u));\n     auto bcx = new_top_block_ctxt(fcx);\n     auto lltop = bcx.llbb;"}]}