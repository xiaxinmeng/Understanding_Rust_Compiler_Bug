{"sha": "a18ebf40cbbb2292ae7059e793e5aabf651ef122", "node_id": "C_kwDOAAsO6NoAKGExOGViZjQwY2JiYjIyOTJhZTcwNTllNzkzZTVhYWJmNjUxZWYxMjI", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-02-14T15:47:01Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-02-14T16:01:38Z"}, "message": "Don't allocate the generic_args vec in hir_def::Path if it consists only of `None` args", "tree": {"sha": "f1cd16ed17517751c2a9c4bbaa667cb93c200e4b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f1cd16ed17517751c2a9c4bbaa667cb93c200e4b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a18ebf40cbbb2292ae7059e793e5aabf651ef122", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a18ebf40cbbb2292ae7059e793e5aabf651ef122", "html_url": "https://github.com/rust-lang/rust/commit/a18ebf40cbbb2292ae7059e793e5aabf651ef122", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a18ebf40cbbb2292ae7059e793e5aabf651ef122/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "url": "https://api.github.com/repos/rust-lang/rust/commits/44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "html_url": "https://github.com/rust-lang/rust/commit/44568007d1f3d51b84ad58d2ddeda2badd3aeea5"}], "stats": {"total": 79, "additions": 52, "deletions": 27}, "files": [{"sha": "f53bd4f6186c1e0c844e646dc1d187070fd86659", "filename": "crates/hir-def/src/path.rs", "status": "modified", "additions": 32, "deletions": 20, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a18ebf40cbbb2292ae7059e793e5aabf651ef122/crates%2Fhir-def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a18ebf40cbbb2292ae7059e793e5aabf651ef122/crates%2Fhir-def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fpath.rs?ref=a18ebf40cbbb2292ae7059e793e5aabf651ef122", "patch": "@@ -38,11 +38,11 @@ impl Display for ImportAlias {\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Path {\n     /// Type based path like `<T>::foo`.\n-    /// Note that paths like `<Type as Trait>::foo` are desugard to `Trait::<Self=Type>::foo`.\n+    /// Note that paths like `<Type as Trait>::foo` are desugared to `Trait::<Self=Type>::foo`.\n     type_anchor: Option<Interned<TypeRef>>,\n     mod_path: Interned<ModPath>,\n-    /// Invariant: the same len as `self.mod_path.segments`\n-    generic_args: Box<[Option<Interned<GenericArgs>>]>,\n+    /// Invariant: the same len as `self.mod_path.segments` or `None` if all segments are `None`.\n+    generic_args: Option<Box<[Option<Interned<GenericArgs>>]>>,\n }\n \n /// Generic arguments to a path segment (e.g. the `i32` in `Option<i32>`). This\n@@ -102,7 +102,7 @@ impl Path {\n     ) -> Path {\n         let generic_args = generic_args.into();\n         assert_eq!(path.len(), generic_args.len());\n-        Path { type_anchor: None, mod_path: Interned::new(path), generic_args }\n+        Path { type_anchor: None, mod_path: Interned::new(path), generic_args: Some(generic_args) }\n     }\n \n     pub fn kind(&self) -> &PathKind {\n@@ -114,7 +114,14 @@ impl Path {\n     }\n \n     pub fn segments(&self) -> PathSegments<'_> {\n-        PathSegments { segments: self.mod_path.segments(), generic_args: &self.generic_args }\n+        let s = PathSegments {\n+            segments: self.mod_path.segments(),\n+            generic_args: self.generic_args.as_deref(),\n+        };\n+        if let Some(generic_args) = s.generic_args {\n+            assert_eq!(s.segments.len(), generic_args.len());\n+        }\n+        s\n     }\n \n     pub fn mod_path(&self) -> &ModPath {\n@@ -131,13 +138,15 @@ impl Path {\n                 self.mod_path.kind,\n                 self.mod_path.segments()[..self.mod_path.segments().len() - 1].iter().cloned(),\n             )),\n-            generic_args: self.generic_args[..self.generic_args.len() - 1].to_vec().into(),\n+            generic_args: self.generic_args.as_ref().map(|it| it[..it.len() - 1].to_vec().into()),\n         };\n         Some(res)\n     }\n \n     pub fn is_self_type(&self) -> bool {\n-        self.type_anchor.is_none() && *self.generic_args == [None] && self.mod_path.is_Self()\n+        self.type_anchor.is_none()\n+            && self.generic_args.as_deref().is_none()\n+            && self.mod_path.is_Self()\n     }\n }\n \n@@ -149,11 +158,11 @@ pub struct PathSegment<'a> {\n \n pub struct PathSegments<'a> {\n     segments: &'a [Name],\n-    generic_args: &'a [Option<Interned<GenericArgs>>],\n+    generic_args: Option<&'a [Option<Interned<GenericArgs>>]>,\n }\n \n impl<'a> PathSegments<'a> {\n-    pub const EMPTY: PathSegments<'static> = PathSegments { segments: &[], generic_args: &[] };\n+    pub const EMPTY: PathSegments<'static> = PathSegments { segments: &[], generic_args: None };\n     pub fn is_empty(&self) -> bool {\n         self.len() == 0\n     }\n@@ -167,26 +176,29 @@ impl<'a> PathSegments<'a> {\n         self.get(self.len().checked_sub(1)?)\n     }\n     pub fn get(&self, idx: usize) -> Option<PathSegment<'a>> {\n-        assert_eq!(self.segments.len(), self.generic_args.len());\n         let res = PathSegment {\n             name: self.segments.get(idx)?,\n-            args_and_bindings: self.generic_args.get(idx).unwrap().as_ref().map(|it| &**it),\n+            args_and_bindings: self.generic_args.and_then(|it| it.get(idx)?.as_deref()),\n         };\n         Some(res)\n     }\n     pub fn skip(&self, len: usize) -> PathSegments<'a> {\n-        assert_eq!(self.segments.len(), self.generic_args.len());\n-        PathSegments { segments: &self.segments[len..], generic_args: &self.generic_args[len..] }\n+        PathSegments {\n+            segments: &self.segments.get(len..).unwrap_or(&[]),\n+            generic_args: self.generic_args.and_then(|it| it.get(len..)),\n+        }\n     }\n     pub fn take(&self, len: usize) -> PathSegments<'a> {\n-        assert_eq!(self.segments.len(), self.generic_args.len());\n-        PathSegments { segments: &self.segments[..len], generic_args: &self.generic_args[..len] }\n+        PathSegments {\n+            segments: &self.segments.get(..len).unwrap_or(&self.segments),\n+            generic_args: self.generic_args.map(|it| it.get(..len).unwrap_or(it)),\n+        }\n     }\n     pub fn iter(&self) -> impl Iterator<Item = PathSegment<'a>> {\n-        self.segments.iter().zip(self.generic_args.iter()).map(|(name, args)| PathSegment {\n-            name,\n-            args_and_bindings: args.as_ref().map(|it| &**it),\n-        })\n+        self.segments\n+            .iter()\n+            .zip(self.generic_args.into_iter().flatten().chain(iter::repeat(&None)))\n+            .map(|(name, args)| PathSegment { name, args_and_bindings: args.as_deref() })\n     }\n }\n \n@@ -213,7 +225,7 @@ impl From<Name> for Path {\n         Path {\n             type_anchor: None,\n             mod_path: Interned::new(ModPath::from_segments(PathKind::Plain, iter::once(name))),\n-            generic_args: Box::new([None]),\n+            generic_args: None,\n         }\n     }\n }"}, {"sha": "334750a5915a774df10a1b2357eeac81268d86c1", "filename": "crates/hir-def/src/path/lower.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a18ebf40cbbb2292ae7059e793e5aabf651ef122/crates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a18ebf40cbbb2292ae7059e793e5aabf651ef122/crates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs?ref=a18ebf40cbbb2292ae7059e793e5aabf651ef122", "patch": "@@ -45,8 +45,11 @@ pub(super) fn lower_path(mut path: ast::Path, ctx: &LowerCtx<'_>) -> Option<Path\n                                 )\n                             })\n                             .map(Interned::new);\n+                        if let Some(_) = args {\n+                            generic_args.resize(segments.len(), None);\n+                            generic_args.push(args);\n+                        }\n                         segments.push(name);\n-                        generic_args.push(args)\n                     }\n                     Either::Right(crate_id) => {\n                         kind = PathKind::DollarCrate(crate_id);\n@@ -56,7 +59,6 @@ pub(super) fn lower_path(mut path: ast::Path, ctx: &LowerCtx<'_>) -> Option<Path\n             }\n             ast::PathSegmentKind::SelfTypeKw => {\n                 segments.push(name![Self]);\n-                generic_args.push(None)\n             }\n             ast::PathSegmentKind::Type { type_ref, trait_ref } => {\n                 assert!(path.qualifier().is_none()); // this can only occur at the first segment\n@@ -77,11 +79,15 @@ pub(super) fn lower_path(mut path: ast::Path, ctx: &LowerCtx<'_>) -> Option<Path\n                         kind = mod_path.kind;\n \n                         segments.extend(mod_path.segments().iter().cloned().rev());\n-                        generic_args.extend(Vec::from(path_generic_args).into_iter().rev());\n+                        if let Some(path_generic_args) = path_generic_args {\n+                            generic_args.resize(segments.len() - num_segments, None);\n+                            generic_args.extend(Vec::from(path_generic_args).into_iter().rev());\n+                        } else {\n+                            generic_args.resize(segments.len(), None);\n+                        }\n \n                         // Insert the type reference (T in the above example) as Self parameter for the trait\n-                        let last_segment =\n-                            generic_args.iter_mut().rev().nth(num_segments.saturating_sub(1))?;\n+                        let last_segment = generic_args.get_mut(segments.len() - num_segments)?;\n                         let mut args_inner = match last_segment {\n                             Some(it) => it.as_ref().clone(),\n                             None => GenericArgs::empty(),\n@@ -115,7 +121,10 @@ pub(super) fn lower_path(mut path: ast::Path, ctx: &LowerCtx<'_>) -> Option<Path\n         };\n     }\n     segments.reverse();\n-    generic_args.reverse();\n+    if !generic_args.is_empty() {\n+        generic_args.resize(segments.len(), None);\n+        generic_args.reverse();\n+    }\n \n     if segments.is_empty() && kind == PathKind::Plain && type_anchor.is_none() {\n         // plain empty paths don't exist, this means we got a single `self` segment as our path\n@@ -135,7 +144,11 @@ pub(super) fn lower_path(mut path: ast::Path, ctx: &LowerCtx<'_>) -> Option<Path\n     }\n \n     let mod_path = Interned::new(ModPath::from_segments(kind, segments));\n-    return Some(Path { type_anchor, mod_path, generic_args: generic_args.into() });\n+    return Some(Path {\n+        type_anchor,\n+        mod_path,\n+        generic_args: if generic_args.is_empty() { None } else { Some(generic_args.into()) },\n+    });\n \n     fn qualifier(path: &ast::Path) -> Option<ast::Path> {\n         if let Some(q) = path.qualifier() {"}]}