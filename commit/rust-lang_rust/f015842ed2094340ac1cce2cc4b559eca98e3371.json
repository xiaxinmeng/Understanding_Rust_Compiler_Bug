{"sha": "f015842ed2094340ac1cce2cc4b559eca98e3371", "node_id": "C_kwDOAAsO6NoAKGYwMTU4NDJlZDIwOTQzNDBhYzFjY2UyY2M0YjU1OWVjYTk4ZTMzNzE", "commit": {"author": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-11-02T21:02:39Z"}, "committer": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-11-23T19:01:11Z"}, "message": "properly handle enum field projections", "tree": {"sha": "2ed3036c3327d41a61b46ee44934aee98180cdad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ed3036c3327d41a61b46ee44934aee98180cdad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f015842ed2094340ac1cce2cc4b559eca98e3371", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f015842ed2094340ac1cce2cc4b559eca98e3371", "html_url": "https://github.com/rust-lang/rust/commit/f015842ed2094340ac1cce2cc4b559eca98e3371", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f015842ed2094340ac1cce2cc4b559eca98e3371/comments", "author": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "906c52743aa60002abadae2a9f19673bdad3cf80", "url": "https://api.github.com/repos/rust-lang/rust/commits/906c52743aa60002abadae2a9f19673bdad3cf80", "html_url": "https://github.com/rust-lang/rust/commit/906c52743aa60002abadae2a9f19673bdad3cf80"}], "stats": {"total": 84, "additions": 35, "deletions": 49}, "files": [{"sha": "b682b0c3bd470f3a3c1fa82a8e628b4951918656", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 18, "deletions": 38, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f015842ed2094340ac1cce2cc4b559eca98e3371/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f015842ed2094340ac1cce2cc4b559eca98e3371/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=f015842ed2094340ac1cce2cc4b559eca98e3371", "patch": "@@ -7,6 +7,7 @@ use rustc_hir::def_id::LocalDefId;\n use rustc_middle::hir::place::Projection as HirProjection;\n use rustc_middle::hir::place::ProjectionKind as HirProjectionKind;\n use rustc_middle::middle::region;\n+use rustc_middle::mir::tcx::PlaceTy;\n use rustc_middle::mir::AssertKind::BoundsCheck;\n use rustc_middle::mir::*;\n use rustc_middle::thir::*;\n@@ -324,56 +325,35 @@ impl<'tcx> PlaceBuilder<'tcx> {\n         }\n     }\n \n-    pub fn try_ty<D>(&self, local_decls: &D, cx: &Builder<'_, 'tcx>) -> Option<Ty<'tcx>>\n+    pub fn try_compute_ty<D>(\n+        &self,\n+        local_decls: &D,\n+        cx: &Builder<'_, 'tcx>,\n+    ) -> Option<PlaceTy<'tcx>>\n     where\n         D: HasLocalDecls<'tcx>,\n     {\n-        let tcx = cx.tcx;\n-\n-        let project_ty = |ty: Ty<'tcx>, elem: &PlaceElem<'tcx>| -> Ty<'tcx> {\n-            match elem {\n-                ProjectionElem::Deref => {\n-                    ty.builtin_deref(true)\n-                        .unwrap_or_else(|| {\n-                            bug!(\"deref projection of non-dereferenceable ty {:?}\", ty)\n-                        })\n-                        .ty\n-                }\n-                ProjectionElem::Index(_) | ProjectionElem::ConstantIndex { .. } => {\n-                    ty.builtin_index().unwrap()\n-                }\n-                ProjectionElem::Subslice { from, to, from_end } => match ty.kind() {\n-                    ty::Slice(..) => ty,\n-                    ty::Array(inner, _) if !from_end => tcx.mk_array(*inner, (to - from) as u64),\n-                    ty::Array(inner, size) if *from_end => {\n-                        let size = size.eval_usize(tcx, ty::ParamEnv::empty());\n-                        let len = size - (*from as u64) - (*to as u64);\n-                        tcx.mk_array(*inner, len)\n-                    }\n-                    _ => bug!(\"cannot subslice non-array type: `{:?}`\", ty),\n-                },\n-                ProjectionElem::Downcast(..) => ty,\n-                ProjectionElem::Field(_, ty) | ProjectionElem::OpaqueCast(ty) => *ty,\n-            }\n-        };\n-\n         match self.base {\n-            PlaceBase::Local(local) => {\n-                let base_ty = local_decls.local_decls()[local].ty;\n-                Some(self.projection.iter().fold(base_ty, |ty, &elem| project_ty(ty, &elem)))\n-            }\n+            PlaceBase::Local(_) => Some(self.clone().into_place(cx).ty(local_decls, cx.tcx)),\n             PlaceBase::Upvar { .. } => {\n                 match to_upvars_resolved_place_builder(self.clone(), cx) {\n                     Ok(resolved_place_builder) => {\n                         // `base` is guaranteed to be `PlaceBase::Local` now, so recursive call is ok\n-                        resolved_place_builder.try_ty(local_decls, cx)\n+                        resolved_place_builder.try_compute_ty(local_decls, cx)\n                     }\n                     Err(place_builder) => {\n                         match &place_builder.projection[..] {\n-                            &[ProjectionElem::OpaqueCast(base_ty), ref projections @ ..] => Some(\n-                                projections.iter().fold(base_ty, |ty, &elem| project_ty(ty, &elem)),\n-                            ),\n+                            &[ProjectionElem::OpaqueCast(base_ty), ref projections @ ..] => {\n+                                let place_ty = projections\n+                                    .iter()\n+                                    .fold(PlaceTy::from_ty(base_ty), |place_ty, &elem| {\n+                                        place_ty.projection_ty(cx.tcx, elem)\n+                                    });\n+\n+                                debug!(?place_ty);\n \n+                                Some(place_ty)\n+                            }\n                             _ => None, // would need a base `Ty` for these\n                         }\n                     }"}, {"sha": "36aa7693e827ff3009026c32fd2b88c3a8c7b2af", "filename": "compiler/rustc_mir_build/src/build/matches/simplify.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f015842ed2094340ac1cce2cc4b559eca98e3371/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f015842ed2094340ac1cce2cc4b559eca98e3371/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs?ref=f015842ed2094340ac1cce2cc4b559eca98e3371", "patch": "@@ -272,9 +272,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     || !adt_def.is_variant_list_non_exhaustive());\n                 if irrefutable {\n                     let place_builder = match_pair.place.downcast(adt_def, variant_index);\n-                    candidate\n-                        .match_pairs\n-                        .extend(self.field_match_pairs(place_builder, subpatterns));\n+                    let field_match_pairs =\n+                        self.field_match_pairs(place_builder.clone(), subpatterns);\n+                    candidate.match_pairs.extend(field_match_pairs);\n                     Ok(())\n                 } else {\n                     Err(match_pair)\n@@ -294,9 +294,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             PatKind::Leaf { ref subpatterns } => {\n                 // tuple struct, match subpats (if any)\n-                candidate\n-                    .match_pairs\n-                    .extend(self.field_match_pairs_tuple_struct(match_pair.place, subpatterns));\n+                candidate.match_pairs.extend(self.field_match_pairs(match_pair.place, subpatterns));\n                 Ok(())\n             }\n "}, {"sha": "7423b5e1ae3ec81c25aace0b75c50dd547bafb3a", "filename": "compiler/rustc_mir_build/src/build/matches/util.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f015842ed2094340ac1cce2cc4b559eca98e3371/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f015842ed2094340ac1cce2cc4b559eca98e3371/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs?ref=f015842ed2094340ac1cce2cc4b559eca98e3371", "patch": "@@ -31,10 +31,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         place_builder: PlaceBuilder<'tcx>,\n         subpatterns: &'pat [FieldPat<'tcx>],\n     ) -> Vec<MatchPair<'pat, 'tcx>> {\n-        let place_ty = place_builder\n-            .try_ty(&self.local_decls, self)\n-            .map(|ty| self.tcx.normalize_erasing_regions(self.param_env, ty));\n-        debug!(?place_ty);\n+        let place_ty_and_variant_idx =\n+            place_builder.try_compute_ty(&self.local_decls, self).map(|place_ty| {\n+                (\n+                    self.tcx.normalize_erasing_regions(self.param_env, place_ty.ty),\n+                    place_ty.variant_index,\n+                )\n+            });\n+        debug!(?place_ty_and_variant_idx);\n \n         subpatterns\n             .iter()\n@@ -43,9 +47,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // during borrow-checking on higher-ranked types if we use the\n                 // ascribed type as the field type, so we try to get the actual field\n                 // type from the `Place`, if possible, see issue #96514\n-                let field_ty = if let Some(place_ty) = place_ty {\n+                let field_ty = if let Some((place_ty, opt_variant_idx)) = place_ty_and_variant_idx {\n                     let field_idx = fieldpat.field.as_usize();\n                     let field_ty = match place_ty.kind() {\n+                        ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n+                            let variant_idx = opt_variant_idx.unwrap();\n+                            adt_def.variant(variant_idx).fields[field_idx].ty(self.tcx, substs)\n+                        }\n                         ty::Adt(adt_def, substs) => {\n                             adt_def.all_fields().collect::<Vec<_>>()[field_idx].ty(self.tcx, substs)\n                         }"}]}