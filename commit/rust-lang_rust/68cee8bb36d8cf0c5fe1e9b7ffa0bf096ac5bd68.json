{"sha": "68cee8bb36d8cf0c5fe1e9b7ffa0bf096ac5bd68", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4Y2VlOGJiMzZkOGNmMGM1ZmUxZTliN2ZmYTBiZjA5NmFjNWJkNjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-16T03:06:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-16T03:06:10Z"}, "message": "Auto merge of #51411 - nnethercote:process_predicate, r=nikomatsakis\n\nSpeed up obligation forest code\n\nHere are the rustc-perf benchmarks that get at least a 1% speedup on one or more of their runs with these patches applied:\n```\ninflate-check\n        avg: -8.7%      min: -12.1%     max: 0.0%\ninflate\n        avg: -5.9%      min: -8.6%      max: 1.1%\ninflate-opt\n        avg: -1.5%      min: -2.0%      max: -0.3%\nclap-rs-check\n        avg: -0.6%      min: -1.9%      max: 0.5%\ncoercions\n        avg: -0.2%?     min: -1.3%?     max: 0.6%?\nserde-opt\n        avg: -0.6%      min: -1.0%      max: 0.1%\ncoercions-check\n        avg: -0.4%?     min: -1.0%?     max: -0.0%?\n```", "tree": {"sha": "b3646249351f1a7c6e7211994affb66ca457446c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3646249351f1a7c6e7211994affb66ca457446c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68cee8bb36d8cf0c5fe1e9b7ffa0bf096ac5bd68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68cee8bb36d8cf0c5fe1e9b7ffa0bf096ac5bd68", "html_url": "https://github.com/rust-lang/rust/commit/68cee8bb36d8cf0c5fe1e9b7ffa0bf096ac5bd68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68cee8bb36d8cf0c5fe1e9b7ffa0bf096ac5bd68/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6103160dd60cace43443f1c5c2e7f4db8cc426e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6103160dd60cace43443f1c5c2e7f4db8cc426e", "html_url": "https://github.com/rust-lang/rust/commit/c6103160dd60cace43443f1c5c2e7f4db8cc426e"}, {"sha": "c83d152ebae3667e5545245acbe1b14bf0b74236", "url": "https://api.github.com/repos/rust-lang/rust/commits/c83d152ebae3667e5545245acbe1b14bf0b74236", "html_url": "https://github.com/rust-lang/rust/commit/c83d152ebae3667e5545245acbe1b14bf0b74236"}], "stats": {"total": 626, "additions": 319, "deletions": 307}, "files": [{"sha": "04396d73df6a2b8a79a7a792b91423f8155703e7", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 253, "deletions": 249, "changes": 502, "blob_url": "https://github.com/rust-lang/rust/blob/68cee8bb36d8cf0c5fe1e9b7ffa0bf096ac5bd68/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68cee8bb36d8cf0c5fe1e9b7ffa0bf096ac5bd68/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=68cee8bb36d8cf0c5fe1e9b7ffa0bf096ac5bd68", "patch": "@@ -12,8 +12,8 @@ use infer::{RegionObligation, InferCtxt};\n use mir::interpret::GlobalId;\n use ty::{self, Ty, TypeFoldable, ToPolyTraitRef, ToPredicate};\n use ty::error::ExpectedFound;\n-use rustc_data_structures::obligation_forest::{ObligationForest, Error};\n-use rustc_data_structures::obligation_forest::{ForestObligation, ObligationProcessor};\n+use rustc_data_structures::obligation_forest::{Error, ForestObligation, ObligationForest};\n+use rustc_data_structures::obligation_forest::{ObligationProcessor, ProcessResult};\n use std::marker::PhantomData;\n use hir::def_id::DefId;\n use middle::const_val::{ConstEvalErr, ErrKind};\n@@ -251,302 +251,306 @@ struct FulfillProcessor<'a, 'b: 'a, 'gcx: 'tcx, 'tcx: 'b> {\n     register_region_obligations: bool\n }\n \n+fn mk_pending(os: Vec<PredicateObligation<'tcx>>) -> Vec<PendingPredicateObligation<'tcx>> {\n+    os.into_iter().map(|o| PendingPredicateObligation {\n+        obligation: o,\n+        stalled_on: vec![]\n+    }).collect()\n+}\n+\n impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx, 'tcx> {\n     type Obligation = PendingPredicateObligation<'tcx>;\n     type Error = FulfillmentErrorCode<'tcx>;\n \n+    /// Processes a predicate obligation and returns either:\n+    /// - `Changed(v)` if the predicate is true, presuming that `v` are also true\n+    /// - `Unchanged` if we don't have enough info to be sure\n+    /// - `Error(e)` if the predicate does not hold\n+    ///\n+    /// This is always inlined, despite its size, because it has a single\n+    /// callsite and it is called *very* frequently.\n+    #[inline(always)]\n     fn process_obligation(&mut self,\n-                          obligation: &mut Self::Obligation)\n-                          -> Result<Option<Vec<Self::Obligation>>, Self::Error>\n-    {\n-        process_predicate(self.selcx, obligation, self.register_region_obligations)\n-            .map(|os| os.map(|os| os.into_iter().map(|o| PendingPredicateObligation {\n-                obligation: o,\n-                stalled_on: vec![]\n-            }).collect()))\n-    }\n-\n-    fn process_backedge<'c, I>(&mut self, cycle: I,\n-                               _marker: PhantomData<&'c PendingPredicateObligation<'tcx>>)\n-        where I: Clone + Iterator<Item=&'c PendingPredicateObligation<'tcx>>,\n+                          pending_obligation: &mut Self::Obligation)\n+                          -> ProcessResult<Self::Obligation, Self::Error>\n     {\n-        if self.selcx.coinductive_match(cycle.clone().map(|s| s.obligation.predicate)) {\n-            debug!(\"process_child_obligations: coinductive match\");\n-        } else {\n-            let cycle : Vec<_> = cycle.map(|c| c.obligation.clone()).collect();\n-            self.selcx.infcx().report_overflow_error_cycle(&cycle);\n+        // if we were stalled on some unresolved variables, first check\n+        // whether any of them have been resolved; if not, don't bother\n+        // doing more work yet\n+        if !pending_obligation.stalled_on.is_empty() {\n+            if pending_obligation.stalled_on.iter().all(|&ty| {\n+                let resolved_ty = self.selcx.infcx().shallow_resolve(&ty);\n+                resolved_ty == ty // nothing changed here\n+            }) {\n+                debug!(\"process_predicate: pending obligation {:?} still stalled on {:?}\",\n+                       self.selcx.infcx()\n+                           .resolve_type_vars_if_possible(&pending_obligation.obligation),\n+                       pending_obligation.stalled_on);\n+                return ProcessResult::Unchanged;\n+            }\n+            pending_obligation.stalled_on = vec![];\n         }\n-    }\n-}\n \n-/// Return the set of type variables contained in a trait ref\n-fn trait_ref_type_vars<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n-                                       t: ty::PolyTraitRef<'tcx>) -> Vec<Ty<'tcx>>\n-{\n-    t.skip_binder() // ok b/c this check doesn't care about regions\n-     .input_types()\n-     .map(|t| selcx.infcx().resolve_type_vars_if_possible(&t))\n-     .filter(|t| t.has_infer_types())\n-     .flat_map(|t| t.walk())\n-     .filter(|t| match t.sty { ty::TyInfer(_) => true, _ => false })\n-     .collect()\n-}\n+        let obligation = &mut pending_obligation.obligation;\n \n-/// Processes a predicate obligation and returns either:\n-/// - `Ok(Some(v))` if the predicate is true, presuming that `v` are also true\n-/// - `Ok(None)` if we don't have enough info to be sure\n-/// - `Err` if the predicate does not hold\n-fn process_predicate<'a, 'gcx, 'tcx>(\n-    selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n-    pending_obligation: &mut PendingPredicateObligation<'tcx>,\n-    register_region_obligations: bool)\n-    -> Result<Option<Vec<PredicateObligation<'tcx>>>,\n-              FulfillmentErrorCode<'tcx>>\n-{\n-    // if we were stalled on some unresolved variables, first check\n-    // whether any of them have been resolved; if not, don't bother\n-    // doing more work yet\n-    if !pending_obligation.stalled_on.is_empty() {\n-        if pending_obligation.stalled_on.iter().all(|&ty| {\n-            let resolved_ty = selcx.infcx().shallow_resolve(&ty);\n-            resolved_ty == ty // nothing changed here\n-        }) {\n-            debug!(\"process_predicate: pending obligation {:?} still stalled on {:?}\",\n-                   selcx.infcx().resolve_type_vars_if_possible(&pending_obligation.obligation),\n-                   pending_obligation.stalled_on);\n-            return Ok(None);\n+        if obligation.predicate.has_infer_types() {\n+            obligation.predicate =\n+                self.selcx.infcx().resolve_type_vars_if_possible(&obligation.predicate);\n         }\n-        pending_obligation.stalled_on = vec![];\n-    }\n-\n-    let obligation = &mut pending_obligation.obligation;\n-\n-    if obligation.predicate.has_infer_types() {\n-        obligation.predicate = selcx.infcx().resolve_type_vars_if_possible(&obligation.predicate);\n-    }\n \n-    match obligation.predicate {\n-        ty::Predicate::Trait(ref data) => {\n-            let trait_obligation = obligation.with(data.clone());\n-\n-            if data.is_global() && !data.has_late_bound_regions() {\n-                // no type variables present, can use evaluation for better caching.\n-                // FIXME: consider caching errors too.\n-                if selcx.infcx().predicate_must_hold(&obligation) {\n-                    debug!(\"selecting trait `{:?}` at depth {} evaluated to holds\",\n-                           data, obligation.recursion_depth);\n-                    return Ok(Some(vec![]))\n+        match obligation.predicate {\n+            ty::Predicate::Trait(ref data) => {\n+                let trait_obligation = obligation.with(data.clone());\n+\n+                if data.is_global() && !data.has_late_bound_regions() {\n+                    // no type variables present, can use evaluation for better caching.\n+                    // FIXME: consider caching errors too.\n+                    if self.selcx.infcx().predicate_must_hold(&obligation) {\n+                        debug!(\"selecting trait `{:?}` at depth {} evaluated to holds\",\n+                               data, obligation.recursion_depth);\n+                        return ProcessResult::Changed(vec![])\n+                    }\n                 }\n-            }\n \n-            match selcx.select(&trait_obligation) {\n-                Ok(Some(vtable)) => {\n-                    debug!(\"selecting trait `{:?}` at depth {} yielded Ok(Some)\",\n-                           data, obligation.recursion_depth);\n-                    Ok(Some(vtable.nested_obligations()))\n-                }\n-                Ok(None) => {\n-                    debug!(\"selecting trait `{:?}` at depth {} yielded Ok(None)\",\n-                           data, obligation.recursion_depth);\n-\n-                    // This is a bit subtle: for the most part, the\n-                    // only reason we can fail to make progress on\n-                    // trait selection is because we don't have enough\n-                    // information about the types in the trait. One\n-                    // exception is that we sometimes haven't decided\n-                    // what kind of closure a closure is. *But*, in\n-                    // that case, it turns out, the type of the\n-                    // closure will also change, because the closure\n-                    // also includes references to its upvars as part\n-                    // of its type, and those types are resolved at\n-                    // the same time.\n-                    //\n-                    // FIXME(#32286) logic seems false if no upvars\n-                    pending_obligation.stalled_on =\n-                        trait_ref_type_vars(selcx, data.to_poly_trait_ref());\n-\n-                    debug!(\"process_predicate: pending obligation {:?} now stalled on {:?}\",\n-                           selcx.infcx().resolve_type_vars_if_possible(obligation),\n-                           pending_obligation.stalled_on);\n-\n-                    Ok(None)\n-                }\n-                Err(selection_err) => {\n-                    info!(\"selecting trait `{:?}` at depth {} yielded Err\",\n-                          data, obligation.recursion_depth);\n+                match self.selcx.select(&trait_obligation) {\n+                    Ok(Some(vtable)) => {\n+                        debug!(\"selecting trait `{:?}` at depth {} yielded Ok(Some)\",\n+                               data, obligation.recursion_depth);\n+                        ProcessResult::Changed(mk_pending(vtable.nested_obligations()))\n+                    }\n+                    Ok(None) => {\n+                        debug!(\"selecting trait `{:?}` at depth {} yielded Ok(None)\",\n+                               data, obligation.recursion_depth);\n+\n+                        // This is a bit subtle: for the most part, the\n+                        // only reason we can fail to make progress on\n+                        // trait selection is because we don't have enough\n+                        // information about the types in the trait. One\n+                        // exception is that we sometimes haven't decided\n+                        // what kind of closure a closure is. *But*, in\n+                        // that case, it turns out, the type of the\n+                        // closure will also change, because the closure\n+                        // also includes references to its upvars as part\n+                        // of its type, and those types are resolved at\n+                        // the same time.\n+                        //\n+                        // FIXME(#32286) logic seems false if no upvars\n+                        pending_obligation.stalled_on =\n+                            trait_ref_type_vars(self.selcx, data.to_poly_trait_ref());\n+\n+                        debug!(\"process_predicate: pending obligation {:?} now stalled on {:?}\",\n+                               self.selcx.infcx().resolve_type_vars_if_possible(obligation),\n+                               pending_obligation.stalled_on);\n+\n+                        ProcessResult::Unchanged\n+                    }\n+                    Err(selection_err) => {\n+                        info!(\"selecting trait `{:?}` at depth {} yielded Err\",\n+                              data, obligation.recursion_depth);\n \n-                    Err(CodeSelectionError(selection_err))\n+                        ProcessResult::Error(CodeSelectionError(selection_err))\n+                    }\n                 }\n             }\n-        }\n \n-        ty::Predicate::RegionOutlives(ref binder) => {\n-            match selcx.infcx().region_outlives_predicate(&obligation.cause, binder) {\n-                Ok(()) => Ok(Some(Vec::new())),\n-                Err(_) => Err(CodeSelectionError(Unimplemented)),\n+            ty::Predicate::RegionOutlives(ref binder) => {\n+                match self.selcx.infcx().region_outlives_predicate(&obligation.cause, binder) {\n+                    Ok(()) => ProcessResult::Changed(vec![]),\n+                    Err(_) => ProcessResult::Error(CodeSelectionError(Unimplemented)),\n+                }\n             }\n-        }\n \n-        ty::Predicate::TypeOutlives(ref binder) => {\n-            // Check if there are higher-ranked regions.\n-            match binder.no_late_bound_regions() {\n-                // If there are, inspect the underlying type further.\n-                None => {\n-                    // Convert from `Binder<OutlivesPredicate<Ty, Region>>` to `Binder<Ty>`.\n-                    let binder = binder.map_bound_ref(|pred| pred.0);\n-\n-                    // Check if the type has any bound regions.\n-                    match binder.no_late_bound_regions() {\n-                        // If so, this obligation is an error (for now). Eventually we should be\n-                        // able to support additional cases here, like `for<'a> &'a str: 'a`.\n-                        None => {\n-                            Err(CodeSelectionError(Unimplemented))\n-                        }\n-                        // Otherwise, we have something of the form\n-                        // `for<'a> T: 'a where 'a not in T`, which we can treat as `T: 'static`.\n-                        Some(t_a) => {\n-                            let r_static = selcx.tcx().types.re_static;\n-                            if register_region_obligations {\n-                                selcx.infcx().register_region_obligation(\n-                                    obligation.cause.body_id,\n-                                    RegionObligation {\n-                                        sup_type: t_a,\n-                                        sub_region: r_static,\n-                                        cause: obligation.cause.clone(),\n-                                    });\n+            ty::Predicate::TypeOutlives(ref binder) => {\n+                // Check if there are higher-ranked regions.\n+                match binder.no_late_bound_regions() {\n+                    // If there are, inspect the underlying type further.\n+                    None => {\n+                        // Convert from `Binder<OutlivesPredicate<Ty, Region>>` to `Binder<Ty>`.\n+                        let binder = binder.map_bound_ref(|pred| pred.0);\n+\n+                        // Check if the type has any bound regions.\n+                        match binder.no_late_bound_regions() {\n+                            // If so, this obligation is an error (for now). Eventually we should be\n+                            // able to support additional cases here, like `for<'a> &'a str: 'a`.\n+                            None => {\n+                                ProcessResult::Error(CodeSelectionError(Unimplemented))\n+                            }\n+                            // Otherwise, we have something of the form\n+                            // `for<'a> T: 'a where 'a not in T`, which we can treat as\n+                            // `T: 'static`.\n+                            Some(t_a) => {\n+                                let r_static = self.selcx.tcx().types.re_static;\n+                                if self.register_region_obligations {\n+                                    self.selcx.infcx().register_region_obligation(\n+                                        obligation.cause.body_id,\n+                                        RegionObligation {\n+                                            sup_type: t_a,\n+                                            sub_region: r_static,\n+                                            cause: obligation.cause.clone(),\n+                                        });\n+                                }\n+                                ProcessResult::Changed(vec![])\n                             }\n-                            Ok(Some(vec![]))\n                         }\n                     }\n-                }\n-                // If there aren't, register the obligation.\n-                Some(ty::OutlivesPredicate(t_a, r_b)) => {\n-                    if register_region_obligations {\n-                        selcx.infcx().register_region_obligation(\n-                            obligation.cause.body_id,\n-                            RegionObligation {\n-                                sup_type: t_a,\n-                                sub_region: r_b,\n-                                cause: obligation.cause.clone()\n-                            });\n+                    // If there aren't, register the obligation.\n+                    Some(ty::OutlivesPredicate(t_a, r_b)) => {\n+                        if self.register_region_obligations {\n+                            self.selcx.infcx().register_region_obligation(\n+                                obligation.cause.body_id,\n+                                RegionObligation {\n+                                    sup_type: t_a,\n+                                    sub_region: r_b,\n+                                    cause: obligation.cause.clone()\n+                                });\n+                        }\n+                        ProcessResult::Changed(vec![])\n                     }\n-                    Ok(Some(vec![]))\n                 }\n             }\n-        }\n \n-        ty::Predicate::Projection(ref data) => {\n-            let project_obligation = obligation.with(data.clone());\n-            match project::poly_project_and_unify_type(selcx, &project_obligation) {\n-                Ok(None) => {\n-                    let tcx = selcx.tcx();\n-                    pending_obligation.stalled_on =\n-                        trait_ref_type_vars(selcx, data.to_poly_trait_ref(tcx));\n-                    Ok(None)\n+            ty::Predicate::Projection(ref data) => {\n+                let project_obligation = obligation.with(data.clone());\n+                match project::poly_project_and_unify_type(self.selcx, &project_obligation) {\n+                    Ok(None) => {\n+                        let tcx = self.selcx.tcx();\n+                        pending_obligation.stalled_on =\n+                            trait_ref_type_vars(self.selcx, data.to_poly_trait_ref(tcx));\n+                        ProcessResult::Unchanged\n+                    }\n+                    Ok(Some(os)) => ProcessResult::Changed(mk_pending(os)),\n+                    Err(e) => ProcessResult::Error(CodeProjectionError(e))\n                 }\n-                Ok(v) => Ok(v),\n-                Err(e) => Err(CodeProjectionError(e))\n             }\n-        }\n \n-        ty::Predicate::ObjectSafe(trait_def_id) => {\n-            if !selcx.tcx().is_object_safe(trait_def_id) {\n-                Err(CodeSelectionError(Unimplemented))\n-            } else {\n-                Ok(Some(Vec::new()))\n+            ty::Predicate::ObjectSafe(trait_def_id) => {\n+                if !self.selcx.tcx().is_object_safe(trait_def_id) {\n+                    ProcessResult::Error(CodeSelectionError(Unimplemented))\n+                } else {\n+                    ProcessResult::Changed(vec![])\n+                }\n             }\n-        }\n \n-        ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n-            match selcx.infcx().closure_kind(closure_def_id, closure_substs) {\n-                Some(closure_kind) => {\n-                    if closure_kind.extends(kind) {\n-                        Ok(Some(vec![]))\n-                    } else {\n-                        Err(CodeSelectionError(Unimplemented))\n+            ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n+                match self.selcx.infcx().closure_kind(closure_def_id, closure_substs) {\n+                    Some(closure_kind) => {\n+                        if closure_kind.extends(kind) {\n+                            ProcessResult::Changed(vec![])\n+                        } else {\n+                            ProcessResult::Error(CodeSelectionError(Unimplemented))\n+                        }\n+                    }\n+                    None => {\n+                        ProcessResult::Unchanged\n                     }\n-                }\n-                None => {\n-                    Ok(None)\n                 }\n             }\n-        }\n \n-        ty::Predicate::WellFormed(ty) => {\n-            match ty::wf::obligations(selcx.infcx(),\n-                                      obligation.param_env,\n-                                      obligation.cause.body_id,\n-                                      ty, obligation.cause.span) {\n-                None => {\n-                    pending_obligation.stalled_on = vec![ty];\n-                    Ok(None)\n+            ty::Predicate::WellFormed(ty) => {\n+                match ty::wf::obligations(self.selcx.infcx(),\n+                                          obligation.param_env,\n+                                          obligation.cause.body_id,\n+                                          ty, obligation.cause.span) {\n+                    None => {\n+                        pending_obligation.stalled_on = vec![ty];\n+                        ProcessResult::Unchanged\n+                    }\n+                    Some(os) => ProcessResult::Changed(mk_pending(os))\n                 }\n-                s => Ok(s)\n             }\n-        }\n \n-        ty::Predicate::Subtype(ref subtype) => {\n-            match selcx.infcx().subtype_predicate(&obligation.cause,\n-                                                  obligation.param_env,\n-                                                  subtype) {\n-                None => {\n-                    // none means that both are unresolved\n-                    pending_obligation.stalled_on = vec![subtype.skip_binder().a,\n-                                                         subtype.skip_binder().b];\n-                    Ok(None)\n-                }\n-                Some(Ok(ok)) => {\n-                    Ok(Some(ok.obligations))\n-                }\n-                Some(Err(err)) => {\n-                    let expected_found = ExpectedFound::new(subtype.skip_binder().a_is_expected,\n-                                                            subtype.skip_binder().a,\n-                                                            subtype.skip_binder().b);\n-                    Err(FulfillmentErrorCode::CodeSubtypeError(expected_found, err))\n+            ty::Predicate::Subtype(ref subtype) => {\n+                match self.selcx.infcx().subtype_predicate(&obligation.cause,\n+                                                           obligation.param_env,\n+                                                           subtype) {\n+                    None => {\n+                        // None means that both are unresolved.\n+                        pending_obligation.stalled_on = vec![subtype.skip_binder().a,\n+                                                             subtype.skip_binder().b];\n+                        ProcessResult::Unchanged\n+                    }\n+                    Some(Ok(ok)) => {\n+                        ProcessResult::Changed(mk_pending(ok.obligations))\n+                    }\n+                    Some(Err(err)) => {\n+                        let expected_found = ExpectedFound::new(subtype.skip_binder().a_is_expected,\n+                                                                subtype.skip_binder().a,\n+                                                                subtype.skip_binder().b);\n+                        ProcessResult::Error(\n+                            FulfillmentErrorCode::CodeSubtypeError(expected_found, err))\n+                    }\n                 }\n             }\n-        }\n \n-        ty::Predicate::ConstEvaluatable(def_id, substs) => {\n-            match selcx.tcx().lift_to_global(&obligation.param_env) {\n-                None => {\n-                    Ok(None)\n-                }\n-                Some(param_env) => {\n-                    match selcx.tcx().lift_to_global(&substs) {\n-                        Some(substs) => {\n-                            let instance = ty::Instance::resolve(\n-                                selcx.tcx().global_tcx(),\n-                                param_env,\n-                                def_id,\n-                                substs,\n-                            );\n-                            if let Some(instance) = instance {\n-                                let cid = GlobalId {\n-                                    instance,\n-                                    promoted: None,\n-                                };\n-                                match selcx.tcx().at(obligation.cause.span)\n-                                                 .const_eval(param_env.and(cid)) {\n-                                    Ok(_) => Ok(Some(vec![])),\n-                                    Err(err) => Err(CodeSelectionError(ConstEvalFailure(err)))\n+            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+                match self.selcx.tcx().lift_to_global(&obligation.param_env) {\n+                    None => {\n+                        ProcessResult::Unchanged\n+                    }\n+                    Some(param_env) => {\n+                        match self.selcx.tcx().lift_to_global(&substs) {\n+                            Some(substs) => {\n+                                let instance = ty::Instance::resolve(\n+                                    self.selcx.tcx().global_tcx(),\n+                                    param_env,\n+                                    def_id,\n+                                    substs,\n+                                );\n+                                if let Some(instance) = instance {\n+                                    let cid = GlobalId {\n+                                        instance,\n+                                        promoted: None,\n+                                    };\n+                                    match self.selcx.tcx().at(obligation.cause.span)\n+                                                          .const_eval(param_env.and(cid)) {\n+                                        Ok(_) => ProcessResult::Changed(vec![]),\n+                                        Err(err) => ProcessResult::Error(\n+                                            CodeSelectionError(ConstEvalFailure(err)))\n+                                    }\n+                                } else {\n+                                    ProcessResult::Error(\n+                                        CodeSelectionError(ConstEvalFailure(ConstEvalErr {\n+                                            span: obligation.cause.span,\n+                                            kind: ErrKind::CouldNotResolve.into(),\n+                                        }))\n+                                    )\n                                 }\n-                            } else {\n-                                Err(CodeSelectionError(ConstEvalFailure(ConstEvalErr {\n-                                    span: obligation.cause.span,\n-                                    kind: ErrKind::CouldNotResolve.into(),\n-                                })))\n+                            },\n+                            None => {\n+                                pending_obligation.stalled_on = substs.types().collect();\n+                                ProcessResult::Unchanged\n                             }\n-                        },\n-                        None => {\n-                            pending_obligation.stalled_on = substs.types().collect();\n-                            Ok(None)\n                         }\n                     }\n                 }\n             }\n         }\n     }\n+\n+    fn process_backedge<'c, I>(&mut self, cycle: I,\n+                               _marker: PhantomData<&'c PendingPredicateObligation<'tcx>>)\n+        where I: Clone + Iterator<Item=&'c PendingPredicateObligation<'tcx>>,\n+    {\n+        if self.selcx.coinductive_match(cycle.clone().map(|s| s.obligation.predicate)) {\n+            debug!(\"process_child_obligations: coinductive match\");\n+        } else {\n+            let cycle : Vec<_> = cycle.map(|c| c.obligation.clone()).collect();\n+            self.selcx.infcx().report_overflow_error_cycle(&cycle);\n+        }\n+    }\n+}\n+\n+/// Return the set of type variables contained in a trait ref\n+fn trait_ref_type_vars<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n+                                       t: ty::PolyTraitRef<'tcx>) -> Vec<Ty<'tcx>>\n+{\n+    t.skip_binder() // ok b/c this check doesn't care about regions\n+     .input_types()\n+     .map(|t| selcx.infcx().resolve_type_vars_if_possible(&t))\n+     .filter(|t| t.has_infer_types())\n+     .flat_map(|t| t.walk())\n+     .filter(|t| match t.sty { ty::TyInfer(_) => true, _ => false })\n+     .collect()\n }\n \n fn to_fulfillment_error<'tcx>("}, {"sha": "990dc66c66a3c8829b4e57a4881e84a21358e667", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/68cee8bb36d8cf0c5fe1e9b7ffa0bf096ac5bd68/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68cee8bb36d8cf0c5fe1e9b7ffa0bf096ac5bd68/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=68cee8bb36d8cf0c5fe1e9b7ffa0bf096ac5bd68", "patch": "@@ -41,7 +41,7 @@ pub trait ObligationProcessor {\n \n     fn process_obligation(&mut self,\n                           obligation: &mut Self::Obligation)\n-                          -> Result<Option<Vec<Self::Obligation>>, Self::Error>;\n+                          -> ProcessResult<Self::Obligation, Self::Error>;\n \n     /// As we do the cycle check, we invoke this callback when we\n     /// encounter an actual cycle. `cycle` is an iterator that starts\n@@ -57,6 +57,14 @@ pub trait ObligationProcessor {\n         where I: Clone + Iterator<Item=&'c Self::Obligation>;\n }\n \n+/// The result type used by `process_obligation`.\n+#[derive(Debug)]\n+pub enum ProcessResult<O, E> {\n+    Unchanged,\n+    Changed(Vec<O>),\n+    Error(E),\n+}\n+\n pub struct ObligationForest<O: ForestObligation> {\n     /// The list of obligations. In between calls to\n     /// `process_obligations`, this list only contains nodes in the\n@@ -136,8 +144,8 @@ pub struct Outcome<O, E> {\n \n     /// If true, then we saw no successful obligations, which means\n     /// there is no point in further iteration. This is based on the\n-    /// assumption that when trait matching returns `Err` or\n-    /// `Ok(None)`, those results do not affect environmental\n+    /// assumption that when trait matching returns `Error` or\n+    /// `Unchanged`, those results do not affect environmental\n     /// inference state. (Note that if we invoke `process_obligations`\n     /// with no pending obligations, stalled will be true.)\n     pub stalled: bool,\n@@ -270,11 +278,11 @@ impl<O: ForestObligation> ObligationForest<O> {\n                    result);\n \n             match result {\n-                Ok(None) => {\n-                    // no change in state\n+                ProcessResult::Unchanged => {\n+                    // No change in state.\n                 }\n-                Ok(Some(children)) => {\n-                    // if we saw a Some(_) result, we are not (yet) stalled\n+                ProcessResult::Changed(children) => {\n+                    // We are not (yet) stalled.\n                     stalled = false;\n                     self.nodes[index].state.set(NodeState::Success);\n \n@@ -290,7 +298,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                         }\n                     }\n                 }\n-                Err(err) => {\n+                ProcessResult::Error(err) => {\n                     stalled = false;\n                     let backtrace = self.error_at(index);\n                     errors.push(Error {"}, {"sha": "527a1ef0ec441052c60823cf079466316e330e90", "filename": "src/librustc_data_structures/obligation_forest/test.rs", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/68cee8bb36d8cf0c5fe1e9b7ffa0bf096ac5bd68/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68cee8bb36d8cf0c5fe1e9b7ffa0bf096ac5bd68/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs?ref=68cee8bb36d8cf0c5fe1e9b7ffa0bf096ac5bd68", "patch": "@@ -10,7 +10,7 @@\n \n #![cfg(test)]\n \n-use super::{ObligationForest, ObligationProcessor, Outcome, Error};\n+use super::{Error, ObligationForest, ObligationProcessor, Outcome, ProcessResult};\n \n use std::fmt;\n use std::marker::PhantomData;\n@@ -31,7 +31,7 @@ struct ClosureObligationProcessor<OF, BF, O, E> {\n \n #[allow(non_snake_case)]\n fn C<OF, BF, O>(of: OF, bf: BF) -> ClosureObligationProcessor<OF, BF, O, &'static str>\n-    where OF: FnMut(&mut O) -> Result<Option<Vec<O>>, &'static str>,\n+    where OF: FnMut(&mut O) -> ProcessResult<O, &'static str>,\n           BF: FnMut(&[O])\n {\n     ClosureObligationProcessor {\n@@ -44,15 +44,15 @@ fn C<OF, BF, O>(of: OF, bf: BF) -> ClosureObligationProcessor<OF, BF, O, &'stati\n impl<OF, BF, O, E> ObligationProcessor for ClosureObligationProcessor<OF, BF, O, E>\n     where O: super::ForestObligation + fmt::Debug,\n           E: fmt::Debug,\n-          OF: FnMut(&mut O) -> Result<Option<Vec<O>>, E>,\n+          OF: FnMut(&mut O) -> ProcessResult<O, E>,\n           BF: FnMut(&[O])\n {\n     type Obligation = O;\n     type Error = E;\n \n     fn process_obligation(&mut self,\n                           obligation: &mut Self::Obligation)\n-                          -> Result<Option<Vec<Self::Obligation>>, Self::Error>\n+                          -> ProcessResult<Self::Obligation, Self::Error>\n     {\n         (self.process_obligation)(obligation)\n     }\n@@ -78,9 +78,9 @@ fn push_pop() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A\" => Ok(Some(vec![\"A.1\", \"A.2\", \"A.3\"])),\n-                \"B\" => Err(\"B is for broken\"),\n-                \"C\" => Ok(Some(vec![])),\n+                \"A\" => ProcessResult::Changed(vec![\"A.1\", \"A.2\", \"A.3\"]),\n+                \"B\" => ProcessResult::Error(\"B is for broken\"),\n+                \"C\" => ProcessResult::Changed(vec![]),\n                 _ => unreachable!(),\n             }\n         }, |_| {}));\n@@ -101,10 +101,10 @@ fn push_pop() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A.1\" => Ok(None),\n-                \"A.2\" => Ok(None),\n-                \"A.3\" => Ok(Some(vec![\"A.3.i\"])),\n-                \"D\" => Ok(Some(vec![\"D.1\", \"D.2\"])),\n+                \"A.1\" => ProcessResult::Unchanged,\n+                \"A.2\" => ProcessResult::Unchanged,\n+                \"A.3\" => ProcessResult::Changed(vec![\"A.3.i\"]),\n+                \"D\" => ProcessResult::Changed(vec![\"D.1\", \"D.2\"]),\n                 _ => unreachable!(),\n             }\n         }, |_| {}));\n@@ -119,11 +119,11 @@ fn push_pop() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A.1\" => Ok(Some(vec![])),\n-                \"A.2\" => Err(\"A is for apple\"),\n-                \"A.3.i\" => Ok(Some(vec![])),\n-                \"D.1\" => Ok(Some(vec![\"D.1.i\"])),\n-                \"D.2\" => Ok(Some(vec![\"D.2.i\"])),\n+                \"A.1\" => ProcessResult::Changed(vec![]),\n+                \"A.2\" => ProcessResult::Error(\"A is for apple\"),\n+                \"A.3.i\" => ProcessResult::Changed(vec![]),\n+                \"D.1\" => ProcessResult::Changed(vec![\"D.1.i\"]),\n+                \"D.2\" => ProcessResult::Changed(vec![\"D.2.i\"]),\n                 _ => unreachable!(),\n             }\n         }, |_| {}));\n@@ -138,8 +138,8 @@ fn push_pop() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"D.1.i\" => Err(\"D is for dumb\"),\n-                \"D.2.i\" => Ok(Some(vec![])),\n+                \"D.1.i\" => ProcessResult::Error(\"D is for dumb\"),\n+                \"D.2.i\" => ProcessResult::Changed(vec![]),\n                 _ => panic!(\"unexpected obligation {:?}\", obligation),\n             }\n         }, |_| {}));\n@@ -167,7 +167,7 @@ fn success_in_grandchildren() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A\" => Ok(Some(vec![\"A.1\", \"A.2\", \"A.3\"])),\n+                \"A\" => ProcessResult::Changed(vec![\"A.1\", \"A.2\", \"A.3\"]),\n                 _ => unreachable!(),\n             }\n         }, |_| {}));\n@@ -177,9 +177,9 @@ fn success_in_grandchildren() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A.1\" => Ok(Some(vec![])),\n-                \"A.2\" => Ok(Some(vec![\"A.2.i\", \"A.2.ii\"])),\n-                \"A.3\" => Ok(Some(vec![])),\n+                \"A.1\" => ProcessResult::Changed(vec![]),\n+                \"A.2\" => ProcessResult::Changed(vec![\"A.2.i\", \"A.2.ii\"]),\n+                \"A.3\" => ProcessResult::Changed(vec![]),\n                 _ => unreachable!(),\n             }\n         }, |_| {}));\n@@ -189,8 +189,8 @@ fn success_in_grandchildren() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A.2.i\" => Ok(Some(vec![\"A.2.i.a\"])),\n-                \"A.2.ii\" => Ok(Some(vec![])),\n+                \"A.2.i\" => ProcessResult::Changed(vec![\"A.2.i.a\"]),\n+                \"A.2.ii\" => ProcessResult::Changed(vec![]),\n                 _ => unreachable!(),\n             }\n         }, |_| {}));\n@@ -200,7 +200,7 @@ fn success_in_grandchildren() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A.2.i.a\" => Ok(Some(vec![])),\n+                \"A.2.i.a\" => ProcessResult::Changed(vec![]),\n                 _ => unreachable!(),\n             }\n         }, |_| {}));\n@@ -223,7 +223,7 @@ fn to_errors_no_throw() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A\" => Ok(Some(vec![\"A.1\", \"A.2\", \"A.3\"])),\n+                \"A\" => ProcessResult::Changed(vec![\"A.1\", \"A.2\", \"A.3\"]),\n                 _ => unreachable!(),\n             }\n         }, |_|{}));\n@@ -244,7 +244,7 @@ fn diamond() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A\" => Ok(Some(vec![\"A.1\", \"A.2\"])),\n+                \"A\" => ProcessResult::Changed(vec![\"A.1\", \"A.2\"]),\n                 _ => unreachable!(),\n             }\n         }, |_|{}));\n@@ -254,8 +254,8 @@ fn diamond() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A.1\" => Ok(Some(vec![\"D\"])),\n-                \"A.2\" => Ok(Some(vec![\"D\"])),\n+                \"A.1\" => ProcessResult::Changed(vec![\"D\"]),\n+                \"A.2\" => ProcessResult::Changed(vec![\"D\"]),\n                 _ => unreachable!(),\n             }\n         }, |_|{}));\n@@ -266,7 +266,7 @@ fn diamond() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"D\" => { d_count += 1; Ok(Some(vec![])) },\n+                \"D\" => { d_count += 1; ProcessResult::Changed(vec![]) },\n                 _ => unreachable!(),\n             }\n         }, |_|{}));\n@@ -281,7 +281,7 @@ fn diamond() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A'\" => Ok(Some(vec![\"A'.1\", \"A'.2\"])),\n+                \"A'\" => ProcessResult::Changed(vec![\"A'.1\", \"A'.2\"]),\n                 _ => unreachable!(),\n             }\n         }, |_|{}));\n@@ -291,8 +291,8 @@ fn diamond() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A'.1\" => Ok(Some(vec![\"D'\", \"A'\"])),\n-                \"A'.2\" => Ok(Some(vec![\"D'\"])),\n+                \"A'.1\" => ProcessResult::Changed(vec![\"D'\", \"A'\"]),\n+                \"A'.2\" => ProcessResult::Changed(vec![\"D'\"]),\n                 _ => unreachable!(),\n             }\n         }, |_|{}));\n@@ -303,7 +303,7 @@ fn diamond() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"D'\" => { d_count += 1; Err(\"operation failed\") },\n+                \"D'\" => { d_count += 1; ProcessResult::Error(\"operation failed\") },\n                 _ => unreachable!(),\n             }\n         }, |_|{}));\n@@ -329,7 +329,7 @@ fn done_dependency() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A: Sized\" | \"B: Sized\" | \"C: Sized\" => Ok(Some(vec![])),\n+                \"A: Sized\" | \"B: Sized\" | \"C: Sized\" => ProcessResult::Changed(vec![]),\n                 _ => unreachable!(),\n             }\n         }, |_|{}));\n@@ -340,11 +340,11 @@ fn done_dependency() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"(A,B,C): Sized\" => Ok(Some(vec![\n+                \"(A,B,C): Sized\" => ProcessResult::Changed(vec![\n                     \"A: Sized\",\n                     \"B: Sized\",\n                     \"C: Sized\"\n-                        ])),\n+                        ]),\n                 _ => unreachable!(),\n             }\n         }, |_|{}));\n@@ -367,10 +367,10 @@ fn orphan() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A\" => Ok(Some(vec![\"D\", \"E\"])),\n-                \"B\" => Ok(None),\n-                \"C1\" => Ok(Some(vec![])),\n-                \"C2\" => Ok(Some(vec![])),\n+                \"A\" => ProcessResult::Changed(vec![\"D\", \"E\"]),\n+                \"B\" => ProcessResult::Unchanged,\n+                \"C1\" => ProcessResult::Changed(vec![]),\n+                \"C2\" => ProcessResult::Changed(vec![]),\n                 _ => unreachable!(),\n             }\n         }, |_|{}));\n@@ -380,8 +380,8 @@ fn orphan() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"D\" | \"E\" => Ok(None),\n-                \"B\" => Ok(Some(vec![\"D\"])),\n+                \"D\" | \"E\" => ProcessResult::Unchanged,\n+                \"B\" => ProcessResult::Changed(vec![\"D\"]),\n                 _ => unreachable!(),\n             }\n         }, |_|{}));\n@@ -391,8 +391,8 @@ fn orphan() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"D\" => Ok(None),\n-                \"E\" => Err(\"E is for error\"),\n+                \"D\" => ProcessResult::Unchanged,\n+                \"E\" => ProcessResult::Error(\"E is for error\"),\n                 _ => unreachable!(),\n             }\n         }, |_|{}));\n@@ -405,7 +405,7 @@ fn orphan() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"D\" => Err(\"D is dead\"),\n+                \"D\" => ProcessResult::Error(\"D is dead\"),\n                 _ => unreachable!(),\n             }\n         }, |_|{}));\n@@ -429,8 +429,8 @@ fn simultaneous_register_and_error() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A\" => Err(\"An error\"),\n-                \"B\" => Ok(Some(vec![\"A\"])),\n+                \"A\" => ProcessResult::Error(\"An error\"),\n+                \"B\" => ProcessResult::Changed(vec![\"A\"]),\n                 _ => unreachable!(),\n             }\n         }, |_|{}));\n@@ -447,8 +447,8 @@ fn simultaneous_register_and_error() {\n     let Outcome { completed: ok, errors: err, .. } =\n         forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A\" => Err(\"An error\"),\n-                \"B\" => Ok(Some(vec![\"A\"])),\n+                \"A\" => ProcessResult::Error(\"An error\"),\n+                \"B\" => ProcessResult::Changed(vec![\"A\"]),\n                 _ => unreachable!(),\n             }\n         }, |_|{}));"}]}